["```py\n@[ext]\nstructure  Point  where\n  x  :  ℝ\n  y  :  ℝ\n  z  :  ℝ \n```", "```py\n#check  Point.ext\n\nexample  (a  b  :  Point)  (hx  :  a.x  =  b.x)  (hy  :  a.y  =  b.y)  (hz  :  a.z  =  b.z)  :  a  =  b  :=  by\n  ext\n  repeat'  assumption \n```", "```py\ndef  myPoint1  :  Point  where\n  x  :=  2\n  y  :=  -1\n  z  :=  4\n\ndef  myPoint2  :  Point  :=\n  ⟨2,  -1,  4⟩\n\ndef  myPoint3  :=\n  Point.mk  2  (-1)  4 \n```", "```py\nstructure  Point'  where  build  ::\n  x  :  ℝ\n  y  :  ℝ\n  z  :  ℝ\n\n#check  Point'.build  2  (-1)  4 \n```", "```py\nnamespace  Point\n\ndef  add  (a  b  :  Point)  :  Point  :=\n  ⟨a.x  +  b.x,  a.y  +  b.y,  a.z  +  b.z⟩\n\ndef  add'  (a  b  :  Point)  :  Point  where\n  x  :=  a.x  +  b.x\n  y  :=  a.y  +  b.y\n  z  :=  a.z  +  b.z\n\n#check  add  myPoint1  myPoint2\n#check  myPoint1.add  myPoint2\n\nend  Point\n\n#check  Point.add  myPoint1  myPoint2\n#check  myPoint1.add  myPoint2 \n```", "```py\nprotected  theorem  add_comm  (a  b  :  Point)  :  add  a  b  =  add  b  a  :=  by\n  rw  [add,  add]\n  ext  <;>  dsimp\n  repeat'  apply  add_comm\n\nexample  (a  b  :  Point)  :  add  a  b  =  add  b  a  :=  by  simp  [add,  add_comm] \n```", "```py\ntheorem  add_x  (a  b  :  Point)  :  (a.add  b).x  =  a.x  +  b.x  :=\n  rfl \n```", "```py\ndef  addAlt  :  Point  →  Point  →  Point\n  |  Point.mk  x₁  y₁  z₁,  Point.mk  x₂  y₂  z₂  =>  ⟨x₁  +  x₂,  y₁  +  y₂,  z₁  +  z₂⟩\n\ndef  addAlt'  :  Point  →  Point  →  Point\n  |  ⟨x₁,  y₁,  z₁⟩,  ⟨x₂,  y₂,  z₂⟩  =>  ⟨x₁  +  x₂,  y₁  +  y₂,  z₁  +  z₂⟩\n\ntheorem  addAlt_x  (a  b  :  Point)  :  (a.addAlt  b).x  =  a.x  +  b.x  :=  by\n  rfl\n\ntheorem  addAlt_comm  (a  b  :  Point)  :  addAlt  a  b  =  addAlt  b  a  :=  by\n  rw  [addAlt,  addAlt]\n  -- the same proof still works, but the goal view here is harder to read\n  ext  <;>  dsimp\n  repeat'  apply  add_comm \n```", "```py\nprotected  theorem  add_assoc  (a  b  c  :  Point)  :  (a.add  b).add  c  =  a.add  (b.add  c)  :=  by\n  sorry\n\ndef  smul  (r  :  ℝ)  (a  :  Point)  :  Point  :=\n  sorry\n\ntheorem  smul_distrib  (r  :  ℝ)  (a  b  :  Point)  :\n  (smul  r  a).add  (smul  r  b)  =  smul  r  (a.add  b)  :=  by\n  sorry \n```", "```py\nstructure  StandardTwoSimplex  where\n  x  :  ℝ\n  y  :  ℝ\n  z  :  ℝ\n  x_nonneg  :  0  ≤  x\n  y_nonneg  :  0  ≤  y\n  z_nonneg  :  0  ≤  z\n  sum_eq  :  x  +  y  +  z  =  1 \n```", "```py\ndef  swapXy  (a  :  StandardTwoSimplex)  :  StandardTwoSimplex\n  where\n  x  :=  a.y\n  y  :=  a.x\n  z  :=  a.z\n  x_nonneg  :=  a.y_nonneg\n  y_nonneg  :=  a.x_nonneg\n  z_nonneg  :=  a.z_nonneg\n  sum_eq  :=  by  rw  [add_comm  a.y  a.x,  a.sum_eq] \n```", "```py\nnoncomputable  section\n\ndef  midpoint  (a  b  :  StandardTwoSimplex)  :  StandardTwoSimplex\n  where\n  x  :=  (a.x  +  b.x)  /  2\n  y  :=  (a.y  +  b.y)  /  2\n  z  :=  (a.z  +  b.z)  /  2\n  x_nonneg  :=  div_nonneg  (add_nonneg  a.x_nonneg  b.x_nonneg)  (by  norm_num)\n  y_nonneg  :=  div_nonneg  (add_nonneg  a.y_nonneg  b.y_nonneg)  (by  norm_num)\n  z_nonneg  :=  div_nonneg  (add_nonneg  a.z_nonneg  b.z_nonneg)  (by  norm_num)\n  sum_eq  :=  by  field_simp;  linarith  [a.sum_eq,  b.sum_eq] \n```", "```py\ndef  weightedAverage  (lambda  :  Real)  (lambda_nonneg  :  0  ≤  lambda)  (lambda_le  :  lambda  ≤  1)\n  (a  b  :  StandardTwoSimplex)  :  StandardTwoSimplex  :=\n  sorry \n```", "```py\nopen  BigOperators\n\nstructure  StandardSimplex  (n  :  ℕ)  where\n  V  :  Fin  n  →  ℝ\n  NonNeg  :  ∀  i  :  Fin  n,  0  ≤  V  i\n  sum_eq_one  :  (∑  i,  V  i)  =  1\n\nnamespace  StandardSimplex\n\ndef  midpoint  (n  :  ℕ)  (a  b  :  StandardSimplex  n)  :  StandardSimplex  n\n  where\n  V  i  :=  (a.V  i  +  b.V  i)  /  2\n  NonNeg  :=  by\n  intro  i\n  apply  div_nonneg\n  ·  linarith  [a.NonNeg  i,  b.NonNeg  i]\n  norm_num\n  sum_eq_one  :=  by\n  simp  [div_eq_mul_inv,  ←  Finset.sum_mul,  Finset.sum_add_distrib,\n  a.sum_eq_one,  b.sum_eq_one]\n  field_simp\n\nend  StandardSimplex \n```", "```py\nstructure  IsLinear  (f  :  ℝ  →  ℝ)  where\n  is_additive  :  ∀  x  y,  f  (x  +  y)  =  f  x  +  f  y\n  preserves_mul  :  ∀  x  c,  f  (c  *  x)  =  c  *  f  x\n\nsection\nvariable  (f  :  ℝ  →  ℝ)  (linf  :  IsLinear  f)\n\n#check  linf.is_additive\n#check  linf.preserves_mul\n\nend \n```", "```py\ndef  Point''  :=\n  ℝ  ×  ℝ  ×  ℝ\n\ndef  IsLinear'  (f  :  ℝ  →  ℝ)  :=\n  (∀  x  y,  f  (x  +  y)  =  f  x  +  f  y)  ∧  ∀  x  c,  f  (c  *  x)  =  c  *  f  x \n```", "```py\ndef  PReal  :=\n  {  y  :  ℝ  //  0  <  y  }\n\nsection\nvariable  (x  :  PReal)\n\n#check  x.val\n#check  x.property\n#check  x.1\n#check  x.2\n\nend \n```", "```py\ndef  StandardTwoSimplex'  :=\n  {  p  :  ℝ  ×  ℝ  ×  ℝ  //  0  ≤  p.1  ∧  0  ≤  p.2.1  ∧  0  ≤  p.2.2  ∧  p.1  +  p.2.1  +  p.2.2  =  1  }\n\ndef  StandardSimplex'  (n  :  ℕ)  :=\n  {  v  :  Fin  n  →  ℝ  //  (∀  i  :  Fin  n,  0  ≤  v  i)  ∧  (∑  i,  v  i)  =  1  } \n```", "```py\ndef  StdSimplex  :=  Σ  n  :  ℕ,  StandardSimplex  n\n\nsection\nvariable  (s  :  StdSimplex)\n\n#check  s.fst\n#check  s.snd\n\n#check  s.1\n#check  s.2\n\nend \n```", "```py\nstructure  Group₁  (α  :  Type*)  where\n  mul  :  α  →  α  →  α\n  one  :  α\n  inv  :  α  →  α\n  mul_assoc  :  ∀  x  y  z  :  α,  mul  (mul  x  y)  z  =  mul  x  (mul  y  z)\n  mul_one  :  ∀  x  :  α,  mul  x  one  =  x\n  one_mul  :  ∀  x  :  α,  mul  one  x  =  x\n  inv_mul_cancel  :  ∀  x  :  α,  mul  (inv  x)  x  =  one \n```", "```py\nstructure  Grp₁  where\n  α  :  Type*\n  str  :  Group₁  α \n```", "```py\nvariable  (α  β  γ  :  Type*)\nvariable  (f  :  α  ≃  β)  (g  :  β  ≃  γ)\n\n#check  Equiv  α  β\n#check  (f.toFun  :  α  →  β)\n#check  (f.invFun  :  β  →  α)\n#check  (f.right_inv  :  ∀  x  :  β,  f  (f.invFun  x)  =  x)\n#check  (f.left_inv  :  ∀  x  :  α,  f.invFun  (f  x)  =  x)\n#check  (Equiv.refl  α  :  α  ≃  α)\n#check  (f.symm  :  β  ≃  α)\n#check  (f.trans  g  :  α  ≃  γ) \n```", "```py\nexample  (x  :  α)  :  (f.trans  g).toFun  x  =  g.toFun  (f.toFun  x)  :=\n  rfl\n\nexample  (x  :  α)  :  (f.trans  g)  x  =  g  (f  x)  :=\n  rfl\n\nexample  :  (f.trans  g  :  α  →  γ)  =  g  ∘  f  :=\n  rfl \n```", "```py\nexample  (α  :  Type*)  :  Equiv.Perm  α  =  (α  ≃  α)  :=\n  rfl \n```", "```py\ndef  permGroup  {α  :  Type*}  :  Group₁  (Equiv.Perm  α)\n  where\n  mul  f  g  :=  Equiv.trans  g  f\n  one  :=  Equiv.refl  α\n  inv  :=  Equiv.symm\n  mul_assoc  f  g  h  :=  (Equiv.trans_assoc  _  _  _).symm\n  one_mul  :=  Equiv.trans_refl\n  mul_one  :=  Equiv.refl_trans\n  inv_mul_cancel  :=  Equiv.self_trans_symm \n```", "```py\nstructure  AddGroup₁  (α  :  Type*)  where\n  (add  :  α  →  α  →  α)\n  -- fill in the rest\n@[ext]\nstructure  Point  where\n  x  :  ℝ\n  y  :  ℝ\n  z  :  ℝ\n\nnamespace  Point\n\ndef  add  (a  b  :  Point)  :  Point  :=\n  ⟨a.x  +  b.x,  a.y  +  b.y,  a.z  +  b.z⟩\n\ndef  neg  (a  :  Point)  :  Point  :=  sorry\n\ndef  zero  :  Point  :=  sorry\n\ndef  addGroupPoint  :  AddGroup₁  Point  :=  sorry\n\nend  Point \n```", "```py\nvariable  {α  :  Type*}  (f  g  :  Equiv.Perm  α)  (n  :  ℕ)\n\n#check  f  *  g\n#check  mul_assoc  f  g  g⁻¹\n\n-- group power, defined for any group\n#check  g  ^  n\n\nexample  :  f  *  g  *  g⁻¹  =  f  :=  by  rw  [mul_assoc,  mul_inv_cancel,  mul_one]\n\nexample  :  f  *  g  *  g⁻¹  =  f  :=\n  mul_inv_cancel_right  f  g\n\nexample  {α  :  Type*}  (f  g  :  Equiv.Perm  α)  :  g.symm.trans  (g.trans  f)  =  f  :=\n  mul_inv_cancel_right  f  g \n```", "```py\nclass  Group₂  (α  :  Type*)  where\n  mul  :  α  →  α  →  α\n  one  :  α\n  inv  :  α  →  α\n  mul_assoc  :  ∀  x  y  z  :  α,  mul  (mul  x  y)  z  =  mul  x  (mul  y  z)\n  mul_one  :  ∀  x  :  α,  mul  x  one  =  x\n  one_mul  :  ∀  x  :  α,  mul  one  x  =  x\n  inv_mul_cancel  :  ∀  x  :  α,  mul  (inv  x)  x  =  one\n\ninstance  {α  :  Type*}  :  Group₂  (Equiv.Perm  α)  where\n  mul  f  g  :=  Equiv.trans  g  f\n  one  :=  Equiv.refl  α\n  inv  :=  Equiv.symm\n  mul_assoc  f  g  h  :=  (Equiv.trans_assoc  _  _  _).symm\n  one_mul  :=  Equiv.trans_refl\n  mul_one  :=  Equiv.refl_trans\n  inv_mul_cancel  :=  Equiv.self_trans_symm \n```", "```py\n#check  Group₂.mul\n\ndef  mySquare  {α  :  Type*}  [Group₂  α]  (x  :  α)  :=\n  Group₂.mul  x  x\n\n#check  mySquare\n\nsection\nvariable  {β  :  Type*}  (f  g  :  Equiv.Perm  β)\n\nexample  :  Group₂.mul  f  g  =  g.trans  f  :=\n  rfl\n\nexample  :  mySquare  f  =  f.trans  f  :=\n  rfl\n\nend \n```", "```py\ninstance  :  Inhabited  Point  where  default  :=  ⟨0,  0,  0⟩\n\n#check  (default  :  Point)\n\nexample  :  ([]  :  List  Point).headI  =  default  :=\n  rfl \n```", "```py\ninstance  :  Add  Point  where  add  :=  Point.add\n\nsection\nvariable  (x  y  :  Point)\n\n#check  x  +  y\n\nexample  :  x  +  y  =  Point.add  x  y  :=\n  rfl\n\nend \n```", "```py\ninstance  {α  :  Type*}  [Group₂  α]  :  Mul  α  :=\n  ⟨Group₂.mul⟩\n\ninstance  {α  :  Type*}  [Group₂  α]  :  One  α  :=\n  ⟨Group₂.one⟩\n\ninstance  {α  :  Type*}  [Group₂  α]  :  Inv  α  :=\n  ⟨Group₂.inv⟩\n\nsection\nvariable  {α  :  Type*}  (f  g  :  Equiv.Perm  α)\n\n#check  f  *  1  *  g⁻¹\n\ndef  foo  :  f  *  1  *  g⁻¹  =  g.symm.trans  ((Equiv.refl  α).trans  f)  :=\n  rfl\n\nend \n```", "```py\nclass  AddGroup₂  (α  :  Type*)  where\n  add  :  α  →  α  →  α\n  -- fill in the rest \n```", "```py\n@[ext]\nstructure  GaussInt  where\n  re  :  ℤ\n  im  :  ℤ \n```", "```py\ninstance  :  Zero  GaussInt  :=\n  ⟨⟨0,  0⟩⟩\n\ninstance  :  One  GaussInt  :=\n  ⟨⟨1,  0⟩⟩\n\ninstance  :  Add  GaussInt  :=\n  ⟨fun  x  y  ↦  ⟨x.re  +  y.re,  x.im  +  y.im⟩⟩\n\ninstance  :  Neg  GaussInt  :=\n  ⟨fun  x  ↦  ⟨-x.re,  -x.im⟩⟩\n\ninstance  :  Mul  GaussInt  :=\n  ⟨fun  x  y  ↦  ⟨x.re  *  y.re  -  x.im  *  y.im,  x.re  *  y.im  +  x.im  *  y.re⟩⟩ \n```", "```py\ntheorem  zero_def  :  (0  :  GaussInt)  =  ⟨0,  0⟩  :=\n  rfl\n\ntheorem  one_def  :  (1  :  GaussInt)  =  ⟨1,  0⟩  :=\n  rfl\n\ntheorem  add_def  (x  y  :  GaussInt)  :  x  +  y  =  ⟨x.re  +  y.re,  x.im  +  y.im⟩  :=\n  rfl\n\ntheorem  neg_def  (x  :  GaussInt)  :  -x  =  ⟨-x.re,  -x.im⟩  :=\n  rfl\n\ntheorem  mul_def  (x  y  :  GaussInt)  :\n  x  *  y  =  ⟨x.re  *  y.re  -  x.im  *  y.im,  x.re  *  y.im  +  x.im  *  y.re⟩  :=\n  rfl \n```", "```py\n@[simp]\ntheorem  zero_re  :  (0  :  GaussInt).re  =  0  :=\n  rfl\n\n@[simp]\ntheorem  zero_im  :  (0  :  GaussInt).im  =  0  :=\n  rfl\n\n@[simp]\ntheorem  one_re  :  (1  :  GaussInt).re  =  1  :=\n  rfl\n\n@[simp]\ntheorem  one_im  :  (1  :  GaussInt).im  =  0  :=\n  rfl\n\n@[simp]\ntheorem  add_re  (x  y  :  GaussInt)  :  (x  +  y).re  =  x.re  +  y.re  :=\n  rfl\n\n@[simp]\ntheorem  add_im  (x  y  :  GaussInt)  :  (x  +  y).im  =  x.im  +  y.im  :=\n  rfl\n\n@[simp]\ntheorem  neg_re  (x  :  GaussInt)  :  (-x).re  =  -x.re  :=\n  rfl\n\n@[simp]\ntheorem  neg_im  (x  :  GaussInt)  :  (-x).im  =  -x.im  :=\n  rfl\n\n@[simp]\ntheorem  mul_re  (x  y  :  GaussInt)  :  (x  *  y).re  =  x.re  *  y.re  -  x.im  *  y.im  :=\n  rfl\n\n@[simp]\ntheorem  mul_im  (x  y  :  GaussInt)  :  (x  *  y).im  =  x.re  *  y.im  +  x.im  *  y.re  :=\n  rfl \n```", "```py\ninstance  instCommRing  :  CommRing  GaussInt  where\n  zero  :=  0\n  one  :=  1\n  add  :=  (·  +  ·)\n  neg  x  :=  -x\n  mul  :=  (·  *  ·)\n  nsmul  :=  nsmulRec\n  zsmul  :=  zsmulRec\n  add_assoc  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  zero_add  :=  by\n  intro\n  ext  <;>  simp\n  add_zero  :=  by\n  intro\n  ext  <;>  simp\n  neg_add_cancel  :=  by\n  intro\n  ext  <;>  simp\n  add_comm  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  mul_assoc  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  one_mul  :=  by\n  intro\n  ext  <;>  simp\n  mul_one  :=  by\n  intro\n  ext  <;>  simp\n  left_distrib  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  right_distrib  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  mul_comm  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  zero_mul  :=  by\n  intros\n  ext  <;>  simp\n  mul_zero  :=  by\n  intros\n  ext  <;>  simp \n```", "```py\ninstance  :  Nontrivial  GaussInt  :=  by\n  use  0,  1\n  rw  [Ne,  GaussInt.ext_iff]\n  simp \n```", "```py\nexample  (a  b  :  ℤ)  :  a  =  b  *  (a  /  b)  +  a  %  b  :=\n  Eq.symm  (Int.ediv_add_emod  a  b)\n\nexample  (a  b  :  ℤ)  :  b  ≠  0  →  0  ≤  a  %  b  :=\n  Int.emod_nonneg  a\n\nexample  (a  b  :  ℤ)  :  b  ≠  0  →  a  %  b  <  |b|  :=\n  Int.emod_lt_abs  a \n```", "```py\ndef  div'  (a  b  :  ℤ)  :=\n  (a  +  b  /  2)  /  b\n\ndef  mod'  (a  b  :  ℤ)  :=\n  (a  +  b  /  2)  %  b  -  b  /  2\n\ntheorem  div'_add_mod'  (a  b  :  ℤ)  :  b  *  div'  a  b  +  mod'  a  b  =  a  :=  by\n  rw  [div',  mod']\n  linarith  [Int.ediv_add_emod  (a  +  b  /  2)  b]\n\ntheorem  abs_mod'_le  (a  b  :  ℤ)  (h  :  0  <  b)  :  |mod'  a  b|  ≤  b  /  2  :=  by\n  rw  [mod',  abs_le]\n  constructor\n  ·  linarith  [Int.emod_nonneg  (a  +  b  /  2)  h.ne']\n  have  :=  Int.emod_lt_of_pos  (a  +  b  /  2)  h\n  have  :=  Int.ediv_add_emod  b  2\n  have  :=  Int.emod_lt_of_pos  b  zero_lt_two\n  linarith \n```", "```py\ntheorem  mod'_eq  (a  b  :  ℤ)  :  mod'  a  b  =  a  -  b  *  div'  a  b  :=  by  linarith  [div'_add_mod'  a  b] \n```", "```py\ntheorem  sq_add_sq_eq_zero  {α  :  Type*}  [Ring  α]  [LinearOrder  α]  [IsStrictOrderedRing  α]\n  (x  y  :  α)  :  x  ^  2  +  y  ^  2  =  0  ↔  x  =  0  ∧  y  =  0  :=  by\n  sorry \n```", "```py\ndef  norm  (x  :  GaussInt)  :=\n  x.re  ^  2  +  x.im  ^  2\n\n@[simp]\ntheorem  norm_nonneg  (x  :  GaussInt)  :  0  ≤  norm  x  :=  by\n  sorry\ntheorem  norm_eq_zero  (x  :  GaussInt)  :  norm  x  =  0  ↔  x  =  0  :=  by\n  sorry\ntheorem  norm_pos  (x  :  GaussInt)  :  0  <  norm  x  ↔  x  ≠  0  :=  by\n  sorry\ntheorem  norm_mul  (x  y  :  GaussInt)  :  norm  (x  *  y)  =  norm  x  *  norm  y  :=  by\n  sorry \n```", "```py\ndef  conj  (x  :  GaussInt)  :  GaussInt  :=\n  ⟨x.re,  -x.im⟩\n\n@[simp]\ntheorem  conj_re  (x  :  GaussInt)  :  (conj  x).re  =  x.re  :=\n  rfl\n\n@[simp]\ntheorem  conj_im  (x  :  GaussInt)  :  (conj  x).im  =  -x.im  :=\n  rfl\n\ntheorem  norm_conj  (x  :  GaussInt)  :  norm  (conj  x)  =  norm  x  :=  by  simp  [norm] \n```", "```py\ninstance  :  Div  GaussInt  :=\n  ⟨fun  x  y  ↦  ⟨Int.div'  (x  *  conj  y).re  (norm  y),  Int.div'  (x  *  conj  y).im  (norm  y)⟩⟩ \n```", "```py\ninstance  :  Mod  GaussInt  :=\n  ⟨fun  x  y  ↦  x  -  y  *  (x  /  y)⟩\n\ntheorem  div_def  (x  y  :  GaussInt)  :\n  x  /  y  =  ⟨Int.div'  (x  *  conj  y).re  (norm  y),  Int.div'  (x  *  conj  y).im  (norm  y)⟩  :=\n  rfl\n\ntheorem  mod_def  (x  y  :  GaussInt)  :  x  %  y  =  x  -  y  *  (x  /  y)  :=\n  rfl \n```", "```py\ntheorem  norm_mod_lt  (x  :  GaussInt)  {y  :  GaussInt}  (hy  :  y  ≠  0)  :\n  (x  %  y).norm  <  y.norm  :=  by\n  have  norm_y_pos  :  0  <  norm  y  :=  by  rwa  [norm_pos]\n  have  H1  :  x  %  y  *  conj  y  =  ⟨Int.mod'  (x  *  conj  y).re  (norm  y),  Int.mod'  (x  *  conj  y).im  (norm  y)⟩\n  ·  ext  <;>  simp  [Int.mod'_eq,  mod_def,  div_def,  norm]  <;>  ring\n  have  H2  :  norm  (x  %  y)  *  norm  y  ≤  norm  y  /  2  *  norm  y\n  ·  calc\n  norm  (x  %  y)  *  norm  y  =  norm  (x  %  y  *  conj  y)  :=  by  simp  only  [norm_mul,  norm_conj]\n  _  =  |Int.mod'  (x.re  *  y.re  +  x.im  *  y.im)  (norm  y)|  ^  2\n  +  |Int.mod'  (-(x.re  *  y.im)  +  x.im  *  y.re)  (norm  y)|  ^  2  :=  by  simp  [H1,  norm,  sq_abs]\n  _  ≤  (y.norm  /  2)  ^  2  +  (y.norm  /  2)  ^  2  :=  by  gcongr  <;>  apply  Int.abs_mod'_le  _  _  norm_y_pos\n  _  =  norm  y  /  2  *  (norm  y  /  2  *  2)  :=  by  ring\n  _  ≤  norm  y  /  2  *  norm  y  :=  by  gcongr;  apply  Int.ediv_mul_le;  norm_num\n  calc  norm  (x  %  y)  ≤  norm  y  /  2  :=  le_of_mul_le_mul_right  H2  norm_y_pos\n  _  <  norm  y  :=  by\n  apply  Int.ediv_lt_of_lt_mul\n  ·  norm_num\n  ·  linarith \n```", "```py\ntheorem  coe_natAbs_norm  (x  :  GaussInt)  :  (x.norm.natAbs  :  ℤ)  =  x.norm  :=\n  Int.natAbs_of_nonneg  (norm_nonneg  _)\n\ntheorem  natAbs_norm_mod_lt  (x  y  :  GaussInt)  (hy  :  y  ≠  0)  :\n  (x  %  y).norm.natAbs  <  y.norm.natAbs  :=  by\n  apply  Int.ofNat_lt.1\n  simp  only  [Int.natCast_natAbs,  abs_of_nonneg,  norm_nonneg]\n  exact  norm_mod_lt  x  hy \n```", "```py\ntheorem  not_norm_mul_left_lt_norm  (x  :  GaussInt)  {y  :  GaussInt}  (hy  :  y  ≠  0)  :\n  ¬(norm  (x  *  y)).natAbs  <  (norm  x).natAbs  :=  by\n  apply  not_lt_of_ge\n  rw  [norm_mul,  Int.natAbs_mul]\n  apply  le_mul_of_one_le_right  (Nat.zero_le  _)\n  apply  Int.ofNat_le.1\n  rw  [coe_natAbs_norm]\n  exact  Int.add_one_le_of_lt  ((norm_pos  _).mpr  hy) \n```", "```py\ninstance  :  EuclideanDomain  GaussInt  :=\n  {  GaussInt.instCommRing  with\n  quotient  :=  (·  /  ·)\n  remainder  :=  (·  %  ·)\n  quotient_mul_add_remainder_eq  :=\n  fun  x  y  ↦  by  rw  [mod_def,  add_comm]  ;  ring\n  quotient_zero  :=  fun  x  ↦  by\n  simp  [div_def,  norm,  Int.div']\n  rfl\n  r  :=  (measure  (Int.natAbs  ∘  norm)).1\n  r_wellFounded  :=  (measure  (Int.natAbs  ∘  norm)).2\n  remainder_lt  :=  natAbs_norm_mod_lt\n  mul_left_not_lt  :=  not_norm_mul_left_lt_norm  } \n```", "```py\nexample  (x  :  GaussInt)  :  Irreducible  x  ↔  Prime  x  :=\n  irreducible_iff_prime \n```", "```py\n@[ext]\nstructure  Point  where\n  x  :  ℝ\n  y  :  ℝ\n  z  :  ℝ \n```", "```py\n#check  Point.ext\n\nexample  (a  b  :  Point)  (hx  :  a.x  =  b.x)  (hy  :  a.y  =  b.y)  (hz  :  a.z  =  b.z)  :  a  =  b  :=  by\n  ext\n  repeat'  assumption \n```", "```py\ndef  myPoint1  :  Point  where\n  x  :=  2\n  y  :=  -1\n  z  :=  4\n\ndef  myPoint2  :  Point  :=\n  ⟨2,  -1,  4⟩\n\ndef  myPoint3  :=\n  Point.mk  2  (-1)  4 \n```", "```py\nstructure  Point'  where  build  ::\n  x  :  ℝ\n  y  :  ℝ\n  z  :  ℝ\n\n#check  Point'.build  2  (-1)  4 \n```", "```py\nnamespace  Point\n\ndef  add  (a  b  :  Point)  :  Point  :=\n  ⟨a.x  +  b.x,  a.y  +  b.y,  a.z  +  b.z⟩\n\ndef  add'  (a  b  :  Point)  :  Point  where\n  x  :=  a.x  +  b.x\n  y  :=  a.y  +  b.y\n  z  :=  a.z  +  b.z\n\n#check  add  myPoint1  myPoint2\n#check  myPoint1.add  myPoint2\n\nend  Point\n\n#check  Point.add  myPoint1  myPoint2\n#check  myPoint1.add  myPoint2 \n```", "```py\nprotected  theorem  add_comm  (a  b  :  Point)  :  add  a  b  =  add  b  a  :=  by\n  rw  [add,  add]\n  ext  <;>  dsimp\n  repeat'  apply  add_comm\n\nexample  (a  b  :  Point)  :  add  a  b  =  add  b  a  :=  by  simp  [add,  add_comm] \n```", "```py\ntheorem  add_x  (a  b  :  Point)  :  (a.add  b).x  =  a.x  +  b.x  :=\n  rfl \n```", "```py\ndef  addAlt  :  Point  →  Point  →  Point\n  |  Point.mk  x₁  y₁  z₁,  Point.mk  x₂  y₂  z₂  =>  ⟨x₁  +  x₂,  y₁  +  y₂,  z₁  +  z₂⟩\n\ndef  addAlt'  :  Point  →  Point  →  Point\n  |  ⟨x₁,  y₁,  z₁⟩,  ⟨x₂,  y₂,  z₂⟩  =>  ⟨x₁  +  x₂,  y₁  +  y₂,  z₁  +  z₂⟩\n\ntheorem  addAlt_x  (a  b  :  Point)  :  (a.addAlt  b).x  =  a.x  +  b.x  :=  by\n  rfl\n\ntheorem  addAlt_comm  (a  b  :  Point)  :  addAlt  a  b  =  addAlt  b  a  :=  by\n  rw  [addAlt,  addAlt]\n  -- the same proof still works, but the goal view here is harder to read\n  ext  <;>  dsimp\n  repeat'  apply  add_comm \n```", "```py\nprotected  theorem  add_assoc  (a  b  c  :  Point)  :  (a.add  b).add  c  =  a.add  (b.add  c)  :=  by\n  sorry\n\ndef  smul  (r  :  ℝ)  (a  :  Point)  :  Point  :=\n  sorry\n\ntheorem  smul_distrib  (r  :  ℝ)  (a  b  :  Point)  :\n  (smul  r  a).add  (smul  r  b)  =  smul  r  (a.add  b)  :=  by\n  sorry \n```", "```py\nstructure  StandardTwoSimplex  where\n  x  :  ℝ\n  y  :  ℝ\n  z  :  ℝ\n  x_nonneg  :  0  ≤  x\n  y_nonneg  :  0  ≤  y\n  z_nonneg  :  0  ≤  z\n  sum_eq  :  x  +  y  +  z  =  1 \n```", "```py\ndef  swapXy  (a  :  StandardTwoSimplex)  :  StandardTwoSimplex\n  where\n  x  :=  a.y\n  y  :=  a.x\n  z  :=  a.z\n  x_nonneg  :=  a.y_nonneg\n  y_nonneg  :=  a.x_nonneg\n  z_nonneg  :=  a.z_nonneg\n  sum_eq  :=  by  rw  [add_comm  a.y  a.x,  a.sum_eq] \n```", "```py\nnoncomputable  section\n\ndef  midpoint  (a  b  :  StandardTwoSimplex)  :  StandardTwoSimplex\n  where\n  x  :=  (a.x  +  b.x)  /  2\n  y  :=  (a.y  +  b.y)  /  2\n  z  :=  (a.z  +  b.z)  /  2\n  x_nonneg  :=  div_nonneg  (add_nonneg  a.x_nonneg  b.x_nonneg)  (by  norm_num)\n  y_nonneg  :=  div_nonneg  (add_nonneg  a.y_nonneg  b.y_nonneg)  (by  norm_num)\n  z_nonneg  :=  div_nonneg  (add_nonneg  a.z_nonneg  b.z_nonneg)  (by  norm_num)\n  sum_eq  :=  by  field_simp;  linarith  [a.sum_eq,  b.sum_eq] \n```", "```py\ndef  weightedAverage  (lambda  :  Real)  (lambda_nonneg  :  0  ≤  lambda)  (lambda_le  :  lambda  ≤  1)\n  (a  b  :  StandardTwoSimplex)  :  StandardTwoSimplex  :=\n  sorry \n```", "```py\nopen  BigOperators\n\nstructure  StandardSimplex  (n  :  ℕ)  where\n  V  :  Fin  n  →  ℝ\n  NonNeg  :  ∀  i  :  Fin  n,  0  ≤  V  i\n  sum_eq_one  :  (∑  i,  V  i)  =  1\n\nnamespace  StandardSimplex\n\ndef  midpoint  (n  :  ℕ)  (a  b  :  StandardSimplex  n)  :  StandardSimplex  n\n  where\n  V  i  :=  (a.V  i  +  b.V  i)  /  2\n  NonNeg  :=  by\n  intro  i\n  apply  div_nonneg\n  ·  linarith  [a.NonNeg  i,  b.NonNeg  i]\n  norm_num\n  sum_eq_one  :=  by\n  simp  [div_eq_mul_inv,  ←  Finset.sum_mul,  Finset.sum_add_distrib,\n  a.sum_eq_one,  b.sum_eq_one]\n  field_simp\n\nend  StandardSimplex \n```", "```py\nstructure  IsLinear  (f  :  ℝ  →  ℝ)  where\n  is_additive  :  ∀  x  y,  f  (x  +  y)  =  f  x  +  f  y\n  preserves_mul  :  ∀  x  c,  f  (c  *  x)  =  c  *  f  x\n\nsection\nvariable  (f  :  ℝ  →  ℝ)  (linf  :  IsLinear  f)\n\n#check  linf.is_additive\n#check  linf.preserves_mul\n\nend \n```", "```py\ndef  Point''  :=\n  ℝ  ×  ℝ  ×  ℝ\n\ndef  IsLinear'  (f  :  ℝ  →  ℝ)  :=\n  (∀  x  y,  f  (x  +  y)  =  f  x  +  f  y)  ∧  ∀  x  c,  f  (c  *  x)  =  c  *  f  x \n```", "```py\ndef  PReal  :=\n  {  y  :  ℝ  //  0  <  y  }\n\nsection\nvariable  (x  :  PReal)\n\n#check  x.val\n#check  x.property\n#check  x.1\n#check  x.2\n\nend \n```", "```py\ndef  StandardTwoSimplex'  :=\n  {  p  :  ℝ  ×  ℝ  ×  ℝ  //  0  ≤  p.1  ∧  0  ≤  p.2.1  ∧  0  ≤  p.2.2  ∧  p.1  +  p.2.1  +  p.2.2  =  1  }\n\ndef  StandardSimplex'  (n  :  ℕ)  :=\n  {  v  :  Fin  n  →  ℝ  //  (∀  i  :  Fin  n,  0  ≤  v  i)  ∧  (∑  i,  v  i)  =  1  } \n```", "```py\ndef  StdSimplex  :=  Σ  n  :  ℕ,  StandardSimplex  n\n\nsection\nvariable  (s  :  StdSimplex)\n\n#check  s.fst\n#check  s.snd\n\n#check  s.1\n#check  s.2\n\nend \n```", "```py\nstructure  Group₁  (α  :  Type*)  where\n  mul  :  α  →  α  →  α\n  one  :  α\n  inv  :  α  →  α\n  mul_assoc  :  ∀  x  y  z  :  α,  mul  (mul  x  y)  z  =  mul  x  (mul  y  z)\n  mul_one  :  ∀  x  :  α,  mul  x  one  =  x\n  one_mul  :  ∀  x  :  α,  mul  one  x  =  x\n  inv_mul_cancel  :  ∀  x  :  α,  mul  (inv  x)  x  =  one \n```", "```py\nstructure  Grp₁  where\n  α  :  Type*\n  str  :  Group₁  α \n```", "```py\nvariable  (α  β  γ  :  Type*)\nvariable  (f  :  α  ≃  β)  (g  :  β  ≃  γ)\n\n#check  Equiv  α  β\n#check  (f.toFun  :  α  →  β)\n#check  (f.invFun  :  β  →  α)\n#check  (f.right_inv  :  ∀  x  :  β,  f  (f.invFun  x)  =  x)\n#check  (f.left_inv  :  ∀  x  :  α,  f.invFun  (f  x)  =  x)\n#check  (Equiv.refl  α  :  α  ≃  α)\n#check  (f.symm  :  β  ≃  α)\n#check  (f.trans  g  :  α  ≃  γ) \n```", "```py\nexample  (x  :  α)  :  (f.trans  g).toFun  x  =  g.toFun  (f.toFun  x)  :=\n  rfl\n\nexample  (x  :  α)  :  (f.trans  g)  x  =  g  (f  x)  :=\n  rfl\n\nexample  :  (f.trans  g  :  α  →  γ)  =  g  ∘  f  :=\n  rfl \n```", "```py\nexample  (α  :  Type*)  :  Equiv.Perm  α  =  (α  ≃  α)  :=\n  rfl \n```", "```py\ndef  permGroup  {α  :  Type*}  :  Group₁  (Equiv.Perm  α)\n  where\n  mul  f  g  :=  Equiv.trans  g  f\n  one  :=  Equiv.refl  α\n  inv  :=  Equiv.symm\n  mul_assoc  f  g  h  :=  (Equiv.trans_assoc  _  _  _).symm\n  one_mul  :=  Equiv.trans_refl\n  mul_one  :=  Equiv.refl_trans\n  inv_mul_cancel  :=  Equiv.self_trans_symm \n```", "```py\nstructure  AddGroup₁  (α  :  Type*)  where\n  (add  :  α  →  α  →  α)\n  -- fill in the rest\n@[ext]\nstructure  Point  where\n  x  :  ℝ\n  y  :  ℝ\n  z  :  ℝ\n\nnamespace  Point\n\ndef  add  (a  b  :  Point)  :  Point  :=\n  ⟨a.x  +  b.x,  a.y  +  b.y,  a.z  +  b.z⟩\n\ndef  neg  (a  :  Point)  :  Point  :=  sorry\n\ndef  zero  :  Point  :=  sorry\n\ndef  addGroupPoint  :  AddGroup₁  Point  :=  sorry\n\nend  Point \n```", "```py\nvariable  {α  :  Type*}  (f  g  :  Equiv.Perm  α)  (n  :  ℕ)\n\n#check  f  *  g\n#check  mul_assoc  f  g  g⁻¹\n\n-- group power, defined for any group\n#check  g  ^  n\n\nexample  :  f  *  g  *  g⁻¹  =  f  :=  by  rw  [mul_assoc,  mul_inv_cancel,  mul_one]\n\nexample  :  f  *  g  *  g⁻¹  =  f  :=\n  mul_inv_cancel_right  f  g\n\nexample  {α  :  Type*}  (f  g  :  Equiv.Perm  α)  :  g.symm.trans  (g.trans  f)  =  f  :=\n  mul_inv_cancel_right  f  g \n```", "```py\nclass  Group₂  (α  :  Type*)  where\n  mul  :  α  →  α  →  α\n  one  :  α\n  inv  :  α  →  α\n  mul_assoc  :  ∀  x  y  z  :  α,  mul  (mul  x  y)  z  =  mul  x  (mul  y  z)\n  mul_one  :  ∀  x  :  α,  mul  x  one  =  x\n  one_mul  :  ∀  x  :  α,  mul  one  x  =  x\n  inv_mul_cancel  :  ∀  x  :  α,  mul  (inv  x)  x  =  one\n\ninstance  {α  :  Type*}  :  Group₂  (Equiv.Perm  α)  where\n  mul  f  g  :=  Equiv.trans  g  f\n  one  :=  Equiv.refl  α\n  inv  :=  Equiv.symm\n  mul_assoc  f  g  h  :=  (Equiv.trans_assoc  _  _  _).symm\n  one_mul  :=  Equiv.trans_refl\n  mul_one  :=  Equiv.refl_trans\n  inv_mul_cancel  :=  Equiv.self_trans_symm \n```", "```py\n#check  Group₂.mul\n\ndef  mySquare  {α  :  Type*}  [Group₂  α]  (x  :  α)  :=\n  Group₂.mul  x  x\n\n#check  mySquare\n\nsection\nvariable  {β  :  Type*}  (f  g  :  Equiv.Perm  β)\n\nexample  :  Group₂.mul  f  g  =  g.trans  f  :=\n  rfl\n\nexample  :  mySquare  f  =  f.trans  f  :=\n  rfl\n\nend \n```", "```py\ninstance  :  Inhabited  Point  where  default  :=  ⟨0,  0,  0⟩\n\n#check  (default  :  Point)\n\nexample  :  ([]  :  List  Point).headI  =  default  :=\n  rfl \n```", "```py\ninstance  :  Add  Point  where  add  :=  Point.add\n\nsection\nvariable  (x  y  :  Point)\n\n#check  x  +  y\n\nexample  :  x  +  y  =  Point.add  x  y  :=\n  rfl\n\nend \n```", "```py\ninstance  {α  :  Type*}  [Group₂  α]  :  Mul  α  :=\n  ⟨Group₂.mul⟩\n\ninstance  {α  :  Type*}  [Group₂  α]  :  One  α  :=\n  ⟨Group₂.one⟩\n\ninstance  {α  :  Type*}  [Group₂  α]  :  Inv  α  :=\n  ⟨Group₂.inv⟩\n\nsection\nvariable  {α  :  Type*}  (f  g  :  Equiv.Perm  α)\n\n#check  f  *  1  *  g⁻¹\n\ndef  foo  :  f  *  1  *  g⁻¹  =  g.symm.trans  ((Equiv.refl  α).trans  f)  :=\n  rfl\n\nend \n```", "```py\nclass  AddGroup₂  (α  :  Type*)  where\n  add  :  α  →  α  →  α\n  -- fill in the rest \n```", "```py\n@[ext]\nstructure  GaussInt  where\n  re  :  ℤ\n  im  :  ℤ \n```", "```py\ninstance  :  Zero  GaussInt  :=\n  ⟨⟨0,  0⟩⟩\n\ninstance  :  One  GaussInt  :=\n  ⟨⟨1,  0⟩⟩\n\ninstance  :  Add  GaussInt  :=\n  ⟨fun  x  y  ↦  ⟨x.re  +  y.re,  x.im  +  y.im⟩⟩\n\ninstance  :  Neg  GaussInt  :=\n  ⟨fun  x  ↦  ⟨-x.re,  -x.im⟩⟩\n\ninstance  :  Mul  GaussInt  :=\n  ⟨fun  x  y  ↦  ⟨x.re  *  y.re  -  x.im  *  y.im,  x.re  *  y.im  +  x.im  *  y.re⟩⟩ \n```", "```py\ntheorem  zero_def  :  (0  :  GaussInt)  =  ⟨0,  0⟩  :=\n  rfl\n\ntheorem  one_def  :  (1  :  GaussInt)  =  ⟨1,  0⟩  :=\n  rfl\n\ntheorem  add_def  (x  y  :  GaussInt)  :  x  +  y  =  ⟨x.re  +  y.re,  x.im  +  y.im⟩  :=\n  rfl\n\ntheorem  neg_def  (x  :  GaussInt)  :  -x  =  ⟨-x.re,  -x.im⟩  :=\n  rfl\n\ntheorem  mul_def  (x  y  :  GaussInt)  :\n  x  *  y  =  ⟨x.re  *  y.re  -  x.im  *  y.im,  x.re  *  y.im  +  x.im  *  y.re⟩  :=\n  rfl \n```", "```py\n@[simp]\ntheorem  zero_re  :  (0  :  GaussInt).re  =  0  :=\n  rfl\n\n@[simp]\ntheorem  zero_im  :  (0  :  GaussInt).im  =  0  :=\n  rfl\n\n@[simp]\ntheorem  one_re  :  (1  :  GaussInt).re  =  1  :=\n  rfl\n\n@[simp]\ntheorem  one_im  :  (1  :  GaussInt).im  =  0  :=\n  rfl\n\n@[simp]\ntheorem  add_re  (x  y  :  GaussInt)  :  (x  +  y).re  =  x.re  +  y.re  :=\n  rfl\n\n@[simp]\ntheorem  add_im  (x  y  :  GaussInt)  :  (x  +  y).im  =  x.im  +  y.im  :=\n  rfl\n\n@[simp]\ntheorem  neg_re  (x  :  GaussInt)  :  (-x).re  =  -x.re  :=\n  rfl\n\n@[simp]\ntheorem  neg_im  (x  :  GaussInt)  :  (-x).im  =  -x.im  :=\n  rfl\n\n@[simp]\ntheorem  mul_re  (x  y  :  GaussInt)  :  (x  *  y).re  =  x.re  *  y.re  -  x.im  *  y.im  :=\n  rfl\n\n@[simp]\ntheorem  mul_im  (x  y  :  GaussInt)  :  (x  *  y).im  =  x.re  *  y.im  +  x.im  *  y.re  :=\n  rfl \n```", "```py\ninstance  instCommRing  :  CommRing  GaussInt  where\n  zero  :=  0\n  one  :=  1\n  add  :=  (·  +  ·)\n  neg  x  :=  -x\n  mul  :=  (·  *  ·)\n  nsmul  :=  nsmulRec\n  zsmul  :=  zsmulRec\n  add_assoc  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  zero_add  :=  by\n  intro\n  ext  <;>  simp\n  add_zero  :=  by\n  intro\n  ext  <;>  simp\n  neg_add_cancel  :=  by\n  intro\n  ext  <;>  simp\n  add_comm  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  mul_assoc  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  one_mul  :=  by\n  intro\n  ext  <;>  simp\n  mul_one  :=  by\n  intro\n  ext  <;>  simp\n  left_distrib  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  right_distrib  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  mul_comm  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  zero_mul  :=  by\n  intros\n  ext  <;>  simp\n  mul_zero  :=  by\n  intros\n  ext  <;>  simp \n```", "```py\ninstance  :  Nontrivial  GaussInt  :=  by\n  use  0,  1\n  rw  [Ne,  GaussInt.ext_iff]\n  simp \n```", "```py\nexample  (a  b  :  ℤ)  :  a  =  b  *  (a  /  b)  +  a  %  b  :=\n  Eq.symm  (Int.ediv_add_emod  a  b)\n\nexample  (a  b  :  ℤ)  :  b  ≠  0  →  0  ≤  a  %  b  :=\n  Int.emod_nonneg  a\n\nexample  (a  b  :  ℤ)  :  b  ≠  0  →  a  %  b  <  |b|  :=\n  Int.emod_lt_abs  a \n```", "```py\ndef  div'  (a  b  :  ℤ)  :=\n  (a  +  b  /  2)  /  b\n\ndef  mod'  (a  b  :  ℤ)  :=\n  (a  +  b  /  2)  %  b  -  b  /  2\n\ntheorem  div'_add_mod'  (a  b  :  ℤ)  :  b  *  div'  a  b  +  mod'  a  b  =  a  :=  by\n  rw  [div',  mod']\n  linarith  [Int.ediv_add_emod  (a  +  b  /  2)  b]\n\ntheorem  abs_mod'_le  (a  b  :  ℤ)  (h  :  0  <  b)  :  |mod'  a  b|  ≤  b  /  2  :=  by\n  rw  [mod',  abs_le]\n  constructor\n  ·  linarith  [Int.emod_nonneg  (a  +  b  /  2)  h.ne']\n  have  :=  Int.emod_lt_of_pos  (a  +  b  /  2)  h\n  have  :=  Int.ediv_add_emod  b  2\n  have  :=  Int.emod_lt_of_pos  b  zero_lt_two\n  linarith \n```", "```py\ntheorem  mod'_eq  (a  b  :  ℤ)  :  mod'  a  b  =  a  -  b  *  div'  a  b  :=  by  linarith  [div'_add_mod'  a  b] \n```", "```py\ntheorem  sq_add_sq_eq_zero  {α  :  Type*}  [Ring  α]  [LinearOrder  α]  [IsStrictOrderedRing  α]\n  (x  y  :  α)  :  x  ^  2  +  y  ^  2  =  0  ↔  x  =  0  ∧  y  =  0  :=  by\n  sorry \n```", "```py\ndef  norm  (x  :  GaussInt)  :=\n  x.re  ^  2  +  x.im  ^  2\n\n@[simp]\ntheorem  norm_nonneg  (x  :  GaussInt)  :  0  ≤  norm  x  :=  by\n  sorry\ntheorem  norm_eq_zero  (x  :  GaussInt)  :  norm  x  =  0  ↔  x  =  0  :=  by\n  sorry\ntheorem  norm_pos  (x  :  GaussInt)  :  0  <  norm  x  ↔  x  ≠  0  :=  by\n  sorry\ntheorem  norm_mul  (x  y  :  GaussInt)  :  norm  (x  *  y)  =  norm  x  *  norm  y  :=  by\n  sorry \n```", "```py\ndef  conj  (x  :  GaussInt)  :  GaussInt  :=\n  ⟨x.re,  -x.im⟩\n\n@[simp]\ntheorem  conj_re  (x  :  GaussInt)  :  (conj  x).re  =  x.re  :=\n  rfl\n\n@[simp]\ntheorem  conj_im  (x  :  GaussInt)  :  (conj  x).im  =  -x.im  :=\n  rfl\n\ntheorem  norm_conj  (x  :  GaussInt)  :  norm  (conj  x)  =  norm  x  :=  by  simp  [norm] \n```", "```py\ninstance  :  Div  GaussInt  :=\n  ⟨fun  x  y  ↦  ⟨Int.div'  (x  *  conj  y).re  (norm  y),  Int.div'  (x  *  conj  y).im  (norm  y)⟩⟩ \n```", "```py\ninstance  :  Mod  GaussInt  :=\n  ⟨fun  x  y  ↦  x  -  y  *  (x  /  y)⟩\n\ntheorem  div_def  (x  y  :  GaussInt)  :\n  x  /  y  =  ⟨Int.div'  (x  *  conj  y).re  (norm  y),  Int.div'  (x  *  conj  y).im  (norm  y)⟩  :=\n  rfl\n\ntheorem  mod_def  (x  y  :  GaussInt)  :  x  %  y  =  x  -  y  *  (x  /  y)  :=\n  rfl \n```", "```py\ntheorem  norm_mod_lt  (x  :  GaussInt)  {y  :  GaussInt}  (hy  :  y  ≠  0)  :\n  (x  %  y).norm  <  y.norm  :=  by\n  have  norm_y_pos  :  0  <  norm  y  :=  by  rwa  [norm_pos]\n  have  H1  :  x  %  y  *  conj  y  =  ⟨Int.mod'  (x  *  conj  y).re  (norm  y),  Int.mod'  (x  *  conj  y).im  (norm  y)⟩\n  ·  ext  <;>  simp  [Int.mod'_eq,  mod_def,  div_def,  norm]  <;>  ring\n  have  H2  :  norm  (x  %  y)  *  norm  y  ≤  norm  y  /  2  *  norm  y\n  ·  calc\n  norm  (x  %  y)  *  norm  y  =  norm  (x  %  y  *  conj  y)  :=  by  simp  only  [norm_mul,  norm_conj]\n  _  =  |Int.mod'  (x.re  *  y.re  +  x.im  *  y.im)  (norm  y)|  ^  2\n  +  |Int.mod'  (-(x.re  *  y.im)  +  x.im  *  y.re)  (norm  y)|  ^  2  :=  by  simp  [H1,  norm,  sq_abs]\n  _  ≤  (y.norm  /  2)  ^  2  +  (y.norm  /  2)  ^  2  :=  by  gcongr  <;>  apply  Int.abs_mod'_le  _  _  norm_y_pos\n  _  =  norm  y  /  2  *  (norm  y  /  2  *  2)  :=  by  ring\n  _  ≤  norm  y  /  2  *  norm  y  :=  by  gcongr;  apply  Int.ediv_mul_le;  norm_num\n  calc  norm  (x  %  y)  ≤  norm  y  /  2  :=  le_of_mul_le_mul_right  H2  norm_y_pos\n  _  <  norm  y  :=  by\n  apply  Int.ediv_lt_of_lt_mul\n  ·  norm_num\n  ·  linarith \n```", "```py\ntheorem  coe_natAbs_norm  (x  :  GaussInt)  :  (x.norm.natAbs  :  ℤ)  =  x.norm  :=\n  Int.natAbs_of_nonneg  (norm_nonneg  _)\n\ntheorem  natAbs_norm_mod_lt  (x  y  :  GaussInt)  (hy  :  y  ≠  0)  :\n  (x  %  y).norm.natAbs  <  y.norm.natAbs  :=  by\n  apply  Int.ofNat_lt.1\n  simp  only  [Int.natCast_natAbs,  abs_of_nonneg,  norm_nonneg]\n  exact  norm_mod_lt  x  hy \n```", "```py\ntheorem  not_norm_mul_left_lt_norm  (x  :  GaussInt)  {y  :  GaussInt}  (hy  :  y  ≠  0)  :\n  ¬(norm  (x  *  y)).natAbs  <  (norm  x).natAbs  :=  by\n  apply  not_lt_of_ge\n  rw  [norm_mul,  Int.natAbs_mul]\n  apply  le_mul_of_one_le_right  (Nat.zero_le  _)\n  apply  Int.ofNat_le.1\n  rw  [coe_natAbs_norm]\n  exact  Int.add_one_le_of_lt  ((norm_pos  _).mpr  hy) \n```", "```py\ninstance  :  EuclideanDomain  GaussInt  :=\n  {  GaussInt.instCommRing  with\n  quotient  :=  (·  /  ·)\n  remainder  :=  (·  %  ·)\n  quotient_mul_add_remainder_eq  :=\n  fun  x  y  ↦  by  rw  [mod_def,  add_comm]  ;  ring\n  quotient_zero  :=  fun  x  ↦  by\n  simp  [div_def,  norm,  Int.div']\n  rfl\n  r  :=  (measure  (Int.natAbs  ∘  norm)).1\n  r_wellFounded  :=  (measure  (Int.natAbs  ∘  norm)).2\n  remainder_lt  :=  natAbs_norm_mod_lt\n  mul_left_not_lt  :=  not_norm_mul_left_lt_norm  } \n```", "```py\nexample  (x  :  GaussInt)  :  Irreducible  x  ↔  Prime  x  :=\n  irreducible_iff_prime \n```", "```py\n@[ext]\nstructure  Point  where\n  x  :  ℝ\n  y  :  ℝ\n  z  :  ℝ \n```", "```py\n#check  Point.ext\n\nexample  (a  b  :  Point)  (hx  :  a.x  =  b.x)  (hy  :  a.y  =  b.y)  (hz  :  a.z  =  b.z)  :  a  =  b  :=  by\n  ext\n  repeat'  assumption \n```", "```py\ndef  myPoint1  :  Point  where\n  x  :=  2\n  y  :=  -1\n  z  :=  4\n\ndef  myPoint2  :  Point  :=\n  ⟨2,  -1,  4⟩\n\ndef  myPoint3  :=\n  Point.mk  2  (-1)  4 \n```", "```py\nstructure  Point'  where  build  ::\n  x  :  ℝ\n  y  :  ℝ\n  z  :  ℝ\n\n#check  Point'.build  2  (-1)  4 \n```", "```py\nnamespace  Point\n\ndef  add  (a  b  :  Point)  :  Point  :=\n  ⟨a.x  +  b.x,  a.y  +  b.y,  a.z  +  b.z⟩\n\ndef  add'  (a  b  :  Point)  :  Point  where\n  x  :=  a.x  +  b.x\n  y  :=  a.y  +  b.y\n  z  :=  a.z  +  b.z\n\n#check  add  myPoint1  myPoint2\n#check  myPoint1.add  myPoint2\n\nend  Point\n\n#check  Point.add  myPoint1  myPoint2\n#check  myPoint1.add  myPoint2 \n```", "```py\nprotected  theorem  add_comm  (a  b  :  Point)  :  add  a  b  =  add  b  a  :=  by\n  rw  [add,  add]\n  ext  <;>  dsimp\n  repeat'  apply  add_comm\n\nexample  (a  b  :  Point)  :  add  a  b  =  add  b  a  :=  by  simp  [add,  add_comm] \n```", "```py\ntheorem  add_x  (a  b  :  Point)  :  (a.add  b).x  =  a.x  +  b.x  :=\n  rfl \n```", "```py\ndef  addAlt  :  Point  →  Point  →  Point\n  |  Point.mk  x₁  y₁  z₁,  Point.mk  x₂  y₂  z₂  =>  ⟨x₁  +  x₂,  y₁  +  y₂,  z₁  +  z₂⟩\n\ndef  addAlt'  :  Point  →  Point  →  Point\n  |  ⟨x₁,  y₁,  z₁⟩,  ⟨x₂,  y₂,  z₂⟩  =>  ⟨x₁  +  x₂,  y₁  +  y₂,  z₁  +  z₂⟩\n\ntheorem  addAlt_x  (a  b  :  Point)  :  (a.addAlt  b).x  =  a.x  +  b.x  :=  by\n  rfl\n\ntheorem  addAlt_comm  (a  b  :  Point)  :  addAlt  a  b  =  addAlt  b  a  :=  by\n  rw  [addAlt,  addAlt]\n  -- the same proof still works, but the goal view here is harder to read\n  ext  <;>  dsimp\n  repeat'  apply  add_comm \n```", "```py\nprotected  theorem  add_assoc  (a  b  c  :  Point)  :  (a.add  b).add  c  =  a.add  (b.add  c)  :=  by\n  sorry\n\ndef  smul  (r  :  ℝ)  (a  :  Point)  :  Point  :=\n  sorry\n\ntheorem  smul_distrib  (r  :  ℝ)  (a  b  :  Point)  :\n  (smul  r  a).add  (smul  r  b)  =  smul  r  (a.add  b)  :=  by\n  sorry \n```", "```py\nstructure  StandardTwoSimplex  where\n  x  :  ℝ\n  y  :  ℝ\n  z  :  ℝ\n  x_nonneg  :  0  ≤  x\n  y_nonneg  :  0  ≤  y\n  z_nonneg  :  0  ≤  z\n  sum_eq  :  x  +  y  +  z  =  1 \n```", "```py\ndef  swapXy  (a  :  StandardTwoSimplex)  :  StandardTwoSimplex\n  where\n  x  :=  a.y\n  y  :=  a.x\n  z  :=  a.z\n  x_nonneg  :=  a.y_nonneg\n  y_nonneg  :=  a.x_nonneg\n  z_nonneg  :=  a.z_nonneg\n  sum_eq  :=  by  rw  [add_comm  a.y  a.x,  a.sum_eq] \n```", "```py\nnoncomputable  section\n\ndef  midpoint  (a  b  :  StandardTwoSimplex)  :  StandardTwoSimplex\n  where\n  x  :=  (a.x  +  b.x)  /  2\n  y  :=  (a.y  +  b.y)  /  2\n  z  :=  (a.z  +  b.z)  /  2\n  x_nonneg  :=  div_nonneg  (add_nonneg  a.x_nonneg  b.x_nonneg)  (by  norm_num)\n  y_nonneg  :=  div_nonneg  (add_nonneg  a.y_nonneg  b.y_nonneg)  (by  norm_num)\n  z_nonneg  :=  div_nonneg  (add_nonneg  a.z_nonneg  b.z_nonneg)  (by  norm_num)\n  sum_eq  :=  by  field_simp;  linarith  [a.sum_eq,  b.sum_eq] \n```", "```py\ndef  weightedAverage  (lambda  :  Real)  (lambda_nonneg  :  0  ≤  lambda)  (lambda_le  :  lambda  ≤  1)\n  (a  b  :  StandardTwoSimplex)  :  StandardTwoSimplex  :=\n  sorry \n```", "```py\nopen  BigOperators\n\nstructure  StandardSimplex  (n  :  ℕ)  where\n  V  :  Fin  n  →  ℝ\n  NonNeg  :  ∀  i  :  Fin  n,  0  ≤  V  i\n  sum_eq_one  :  (∑  i,  V  i)  =  1\n\nnamespace  StandardSimplex\n\ndef  midpoint  (n  :  ℕ)  (a  b  :  StandardSimplex  n)  :  StandardSimplex  n\n  where\n  V  i  :=  (a.V  i  +  b.V  i)  /  2\n  NonNeg  :=  by\n  intro  i\n  apply  div_nonneg\n  ·  linarith  [a.NonNeg  i,  b.NonNeg  i]\n  norm_num\n  sum_eq_one  :=  by\n  simp  [div_eq_mul_inv,  ←  Finset.sum_mul,  Finset.sum_add_distrib,\n  a.sum_eq_one,  b.sum_eq_one]\n  field_simp\n\nend  StandardSimplex \n```", "```py\nstructure  IsLinear  (f  :  ℝ  →  ℝ)  where\n  is_additive  :  ∀  x  y,  f  (x  +  y)  =  f  x  +  f  y\n  preserves_mul  :  ∀  x  c,  f  (c  *  x)  =  c  *  f  x\n\nsection\nvariable  (f  :  ℝ  →  ℝ)  (linf  :  IsLinear  f)\n\n#check  linf.is_additive\n#check  linf.preserves_mul\n\nend \n```", "```py\ndef  Point''  :=\n  ℝ  ×  ℝ  ×  ℝ\n\ndef  IsLinear'  (f  :  ℝ  →  ℝ)  :=\n  (∀  x  y,  f  (x  +  y)  =  f  x  +  f  y)  ∧  ∀  x  c,  f  (c  *  x)  =  c  *  f  x \n```", "```py\ndef  PReal  :=\n  {  y  :  ℝ  //  0  <  y  }\n\nsection\nvariable  (x  :  PReal)\n\n#check  x.val\n#check  x.property\n#check  x.1\n#check  x.2\n\nend \n```", "```py\ndef  StandardTwoSimplex'  :=\n  {  p  :  ℝ  ×  ℝ  ×  ℝ  //  0  ≤  p.1  ∧  0  ≤  p.2.1  ∧  0  ≤  p.2.2  ∧  p.1  +  p.2.1  +  p.2.2  =  1  }\n\ndef  StandardSimplex'  (n  :  ℕ)  :=\n  {  v  :  Fin  n  →  ℝ  //  (∀  i  :  Fin  n,  0  ≤  v  i)  ∧  (∑  i,  v  i)  =  1  } \n```", "```py\ndef  StdSimplex  :=  Σ  n  :  ℕ,  StandardSimplex  n\n\nsection\nvariable  (s  :  StdSimplex)\n\n#check  s.fst\n#check  s.snd\n\n#check  s.1\n#check  s.2\n\nend \n```", "```py\nstructure  Group₁  (α  :  Type*)  where\n  mul  :  α  →  α  →  α\n  one  :  α\n  inv  :  α  →  α\n  mul_assoc  :  ∀  x  y  z  :  α,  mul  (mul  x  y)  z  =  mul  x  (mul  y  z)\n  mul_one  :  ∀  x  :  α,  mul  x  one  =  x\n  one_mul  :  ∀  x  :  α,  mul  one  x  =  x\n  inv_mul_cancel  :  ∀  x  :  α,  mul  (inv  x)  x  =  one \n```", "```py\nstructure  Grp₁  where\n  α  :  Type*\n  str  :  Group₁  α \n```", "```py\nvariable  (α  β  γ  :  Type*)\nvariable  (f  :  α  ≃  β)  (g  :  β  ≃  γ)\n\n#check  Equiv  α  β\n#check  (f.toFun  :  α  →  β)\n#check  (f.invFun  :  β  →  α)\n#check  (f.right_inv  :  ∀  x  :  β,  f  (f.invFun  x)  =  x)\n#check  (f.left_inv  :  ∀  x  :  α,  f.invFun  (f  x)  =  x)\n#check  (Equiv.refl  α  :  α  ≃  α)\n#check  (f.symm  :  β  ≃  α)\n#check  (f.trans  g  :  α  ≃  γ) \n```", "```py\nexample  (x  :  α)  :  (f.trans  g).toFun  x  =  g.toFun  (f.toFun  x)  :=\n  rfl\n\nexample  (x  :  α)  :  (f.trans  g)  x  =  g  (f  x)  :=\n  rfl\n\nexample  :  (f.trans  g  :  α  →  γ)  =  g  ∘  f  :=\n  rfl \n```", "```py\nexample  (α  :  Type*)  :  Equiv.Perm  α  =  (α  ≃  α)  :=\n  rfl \n```", "```py\ndef  permGroup  {α  :  Type*}  :  Group₁  (Equiv.Perm  α)\n  where\n  mul  f  g  :=  Equiv.trans  g  f\n  one  :=  Equiv.refl  α\n  inv  :=  Equiv.symm\n  mul_assoc  f  g  h  :=  (Equiv.trans_assoc  _  _  _).symm\n  one_mul  :=  Equiv.trans_refl\n  mul_one  :=  Equiv.refl_trans\n  inv_mul_cancel  :=  Equiv.self_trans_symm \n```", "```py\nstructure  AddGroup₁  (α  :  Type*)  where\n  (add  :  α  →  α  →  α)\n  -- fill in the rest\n@[ext]\nstructure  Point  where\n  x  :  ℝ\n  y  :  ℝ\n  z  :  ℝ\n\nnamespace  Point\n\ndef  add  (a  b  :  Point)  :  Point  :=\n  ⟨a.x  +  b.x,  a.y  +  b.y,  a.z  +  b.z⟩\n\ndef  neg  (a  :  Point)  :  Point  :=  sorry\n\ndef  zero  :  Point  :=  sorry\n\ndef  addGroupPoint  :  AddGroup₁  Point  :=  sorry\n\nend  Point \n```", "```py\nvariable  {α  :  Type*}  (f  g  :  Equiv.Perm  α)  (n  :  ℕ)\n\n#check  f  *  g\n#check  mul_assoc  f  g  g⁻¹\n\n-- group power, defined for any group\n#check  g  ^  n\n\nexample  :  f  *  g  *  g⁻¹  =  f  :=  by  rw  [mul_assoc,  mul_inv_cancel,  mul_one]\n\nexample  :  f  *  g  *  g⁻¹  =  f  :=\n  mul_inv_cancel_right  f  g\n\nexample  {α  :  Type*}  (f  g  :  Equiv.Perm  α)  :  g.symm.trans  (g.trans  f)  =  f  :=\n  mul_inv_cancel_right  f  g \n```", "```py\nclass  Group₂  (α  :  Type*)  where\n  mul  :  α  →  α  →  α\n  one  :  α\n  inv  :  α  →  α\n  mul_assoc  :  ∀  x  y  z  :  α,  mul  (mul  x  y)  z  =  mul  x  (mul  y  z)\n  mul_one  :  ∀  x  :  α,  mul  x  one  =  x\n  one_mul  :  ∀  x  :  α,  mul  one  x  =  x\n  inv_mul_cancel  :  ∀  x  :  α,  mul  (inv  x)  x  =  one\n\ninstance  {α  :  Type*}  :  Group₂  (Equiv.Perm  α)  where\n  mul  f  g  :=  Equiv.trans  g  f\n  one  :=  Equiv.refl  α\n  inv  :=  Equiv.symm\n  mul_assoc  f  g  h  :=  (Equiv.trans_assoc  _  _  _).symm\n  one_mul  :=  Equiv.trans_refl\n  mul_one  :=  Equiv.refl_trans\n  inv_mul_cancel  :=  Equiv.self_trans_symm \n```", "```py\n#check  Group₂.mul\n\ndef  mySquare  {α  :  Type*}  [Group₂  α]  (x  :  α)  :=\n  Group₂.mul  x  x\n\n#check  mySquare\n\nsection\nvariable  {β  :  Type*}  (f  g  :  Equiv.Perm  β)\n\nexample  :  Group₂.mul  f  g  =  g.trans  f  :=\n  rfl\n\nexample  :  mySquare  f  =  f.trans  f  :=\n  rfl\n\nend \n```", "```py\ninstance  :  Inhabited  Point  where  default  :=  ⟨0,  0,  0⟩\n\n#check  (default  :  Point)\n\nexample  :  ([]  :  List  Point).headI  =  default  :=\n  rfl \n```", "```py\ninstance  :  Add  Point  where  add  :=  Point.add\n\nsection\nvariable  (x  y  :  Point)\n\n#check  x  +  y\n\nexample  :  x  +  y  =  Point.add  x  y  :=\n  rfl\n\nend \n```", "```py\ninstance  {α  :  Type*}  [Group₂  α]  :  Mul  α  :=\n  ⟨Group₂.mul⟩\n\ninstance  {α  :  Type*}  [Group₂  α]  :  One  α  :=\n  ⟨Group₂.one⟩\n\ninstance  {α  :  Type*}  [Group₂  α]  :  Inv  α  :=\n  ⟨Group₂.inv⟩\n\nsection\nvariable  {α  :  Type*}  (f  g  :  Equiv.Perm  α)\n\n#check  f  *  1  *  g⁻¹\n\ndef  foo  :  f  *  1  *  g⁻¹  =  g.symm.trans  ((Equiv.refl  α).trans  f)  :=\n  rfl\n\nend \n```", "```py\nclass  AddGroup₂  (α  :  Type*)  where\n  add  :  α  →  α  →  α\n  -- fill in the rest \n```", "```py\n@[ext]\nstructure  GaussInt  where\n  re  :  ℤ\n  im  :  ℤ \n```", "```py\ninstance  :  Zero  GaussInt  :=\n  ⟨⟨0,  0⟩⟩\n\ninstance  :  One  GaussInt  :=\n  ⟨⟨1,  0⟩⟩\n\ninstance  :  Add  GaussInt  :=\n  ⟨fun  x  y  ↦  ⟨x.re  +  y.re,  x.im  +  y.im⟩⟩\n\ninstance  :  Neg  GaussInt  :=\n  ⟨fun  x  ↦  ⟨-x.re,  -x.im⟩⟩\n\ninstance  :  Mul  GaussInt  :=\n  ⟨fun  x  y  ↦  ⟨x.re  *  y.re  -  x.im  *  y.im,  x.re  *  y.im  +  x.im  *  y.re⟩⟩ \n```", "```py\ntheorem  zero_def  :  (0  :  GaussInt)  =  ⟨0,  0⟩  :=\n  rfl\n\ntheorem  one_def  :  (1  :  GaussInt)  =  ⟨1,  0⟩  :=\n  rfl\n\ntheorem  add_def  (x  y  :  GaussInt)  :  x  +  y  =  ⟨x.re  +  y.re,  x.im  +  y.im⟩  :=\n  rfl\n\ntheorem  neg_def  (x  :  GaussInt)  :  -x  =  ⟨-x.re,  -x.im⟩  :=\n  rfl\n\ntheorem  mul_def  (x  y  :  GaussInt)  :\n  x  *  y  =  ⟨x.re  *  y.re  -  x.im  *  y.im,  x.re  *  y.im  +  x.im  *  y.re⟩  :=\n  rfl \n```", "```py\n@[simp]\ntheorem  zero_re  :  (0  :  GaussInt).re  =  0  :=\n  rfl\n\n@[simp]\ntheorem  zero_im  :  (0  :  GaussInt).im  =  0  :=\n  rfl\n\n@[simp]\ntheorem  one_re  :  (1  :  GaussInt).re  =  1  :=\n  rfl\n\n@[simp]\ntheorem  one_im  :  (1  :  GaussInt).im  =  0  :=\n  rfl\n\n@[simp]\ntheorem  add_re  (x  y  :  GaussInt)  :  (x  +  y).re  =  x.re  +  y.re  :=\n  rfl\n\n@[simp]\ntheorem  add_im  (x  y  :  GaussInt)  :  (x  +  y).im  =  x.im  +  y.im  :=\n  rfl\n\n@[simp]\ntheorem  neg_re  (x  :  GaussInt)  :  (-x).re  =  -x.re  :=\n  rfl\n\n@[simp]\ntheorem  neg_im  (x  :  GaussInt)  :  (-x).im  =  -x.im  :=\n  rfl\n\n@[simp]\ntheorem  mul_re  (x  y  :  GaussInt)  :  (x  *  y).re  =  x.re  *  y.re  -  x.im  *  y.im  :=\n  rfl\n\n@[simp]\ntheorem  mul_im  (x  y  :  GaussInt)  :  (x  *  y).im  =  x.re  *  y.im  +  x.im  *  y.re  :=\n  rfl \n```", "```py\ninstance  instCommRing  :  CommRing  GaussInt  where\n  zero  :=  0\n  one  :=  1\n  add  :=  (·  +  ·)\n  neg  x  :=  -x\n  mul  :=  (·  *  ·)\n  nsmul  :=  nsmulRec\n  zsmul  :=  zsmulRec\n  add_assoc  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  zero_add  :=  by\n  intro\n  ext  <;>  simp\n  add_zero  :=  by\n  intro\n  ext  <;>  simp\n  neg_add_cancel  :=  by\n  intro\n  ext  <;>  simp\n  add_comm  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  mul_assoc  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  one_mul  :=  by\n  intro\n  ext  <;>  simp\n  mul_one  :=  by\n  intro\n  ext  <;>  simp\n  left_distrib  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  right_distrib  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  mul_comm  :=  by\n  intros\n  ext  <;>  simp  <;>  ring\n  zero_mul  :=  by\n  intros\n  ext  <;>  simp\n  mul_zero  :=  by\n  intros\n  ext  <;>  simp \n```", "```py\ninstance  :  Nontrivial  GaussInt  :=  by\n  use  0,  1\n  rw  [Ne,  GaussInt.ext_iff]\n  simp \n```", "```py\nexample  (a  b  :  ℤ)  :  a  =  b  *  (a  /  b)  +  a  %  b  :=\n  Eq.symm  (Int.ediv_add_emod  a  b)\n\nexample  (a  b  :  ℤ)  :  b  ≠  0  →  0  ≤  a  %  b  :=\n  Int.emod_nonneg  a\n\nexample  (a  b  :  ℤ)  :  b  ≠  0  →  a  %  b  <  |b|  :=\n  Int.emod_lt_abs  a \n```", "```py\ndef  div'  (a  b  :  ℤ)  :=\n  (a  +  b  /  2)  /  b\n\ndef  mod'  (a  b  :  ℤ)  :=\n  (a  +  b  /  2)  %  b  -  b  /  2\n\ntheorem  div'_add_mod'  (a  b  :  ℤ)  :  b  *  div'  a  b  +  mod'  a  b  =  a  :=  by\n  rw  [div',  mod']\n  linarith  [Int.ediv_add_emod  (a  +  b  /  2)  b]\n\ntheorem  abs_mod'_le  (a  b  :  ℤ)  (h  :  0  <  b)  :  |mod'  a  b|  ≤  b  /  2  :=  by\n  rw  [mod',  abs_le]\n  constructor\n  ·  linarith  [Int.emod_nonneg  (a  +  b  /  2)  h.ne']\n  have  :=  Int.emod_lt_of_pos  (a  +  b  /  2)  h\n  have  :=  Int.ediv_add_emod  b  2\n  have  :=  Int.emod_lt_of_pos  b  zero_lt_two\n  linarith \n```", "```py\ntheorem  mod'_eq  (a  b  :  ℤ)  :  mod'  a  b  =  a  -  b  *  div'  a  b  :=  by  linarith  [div'_add_mod'  a  b] \n```", "```py\ntheorem  sq_add_sq_eq_zero  {α  :  Type*}  [Ring  α]  [LinearOrder  α]  [IsStrictOrderedRing  α]\n  (x  y  :  α)  :  x  ^  2  +  y  ^  2  =  0  ↔  x  =  0  ∧  y  =  0  :=  by\n  sorry \n```", "```py\ndef  norm  (x  :  GaussInt)  :=\n  x.re  ^  2  +  x.im  ^  2\n\n@[simp]\ntheorem  norm_nonneg  (x  :  GaussInt)  :  0  ≤  norm  x  :=  by\n  sorry\ntheorem  norm_eq_zero  (x  :  GaussInt)  :  norm  x  =  0  ↔  x  =  0  :=  by\n  sorry\ntheorem  norm_pos  (x  :  GaussInt)  :  0  <  norm  x  ↔  x  ≠  0  :=  by\n  sorry\ntheorem  norm_mul  (x  y  :  GaussInt)  :  norm  (x  *  y)  =  norm  x  *  norm  y  :=  by\n  sorry \n```", "```py\ndef  conj  (x  :  GaussInt)  :  GaussInt  :=\n  ⟨x.re,  -x.im⟩\n\n@[simp]\ntheorem  conj_re  (x  :  GaussInt)  :  (conj  x).re  =  x.re  :=\n  rfl\n\n@[simp]\ntheorem  conj_im  (x  :  GaussInt)  :  (conj  x).im  =  -x.im  :=\n  rfl\n\ntheorem  norm_conj  (x  :  GaussInt)  :  norm  (conj  x)  =  norm  x  :=  by  simp  [norm] \n```", "```py\ninstance  :  Div  GaussInt  :=\n  ⟨fun  x  y  ↦  ⟨Int.div'  (x  *  conj  y).re  (norm  y),  Int.div'  (x  *  conj  y).im  (norm  y)⟩⟩ \n```", "```py\ninstance  :  Mod  GaussInt  :=\n  ⟨fun  x  y  ↦  x  -  y  *  (x  /  y)⟩\n\ntheorem  div_def  (x  y  :  GaussInt)  :\n  x  /  y  =  ⟨Int.div'  (x  *  conj  y).re  (norm  y),  Int.div'  (x  *  conj  y).im  (norm  y)⟩  :=\n  rfl\n\ntheorem  mod_def  (x  y  :  GaussInt)  :  x  %  y  =  x  -  y  *  (x  /  y)  :=\n  rfl \n```", "```py\ntheorem  norm_mod_lt  (x  :  GaussInt)  {y  :  GaussInt}  (hy  :  y  ≠  0)  :\n  (x  %  y).norm  <  y.norm  :=  by\n  have  norm_y_pos  :  0  <  norm  y  :=  by  rwa  [norm_pos]\n  have  H1  :  x  %  y  *  conj  y  =  ⟨Int.mod'  (x  *  conj  y).re  (norm  y),  Int.mod'  (x  *  conj  y).im  (norm  y)⟩\n  ·  ext  <;>  simp  [Int.mod'_eq,  mod_def,  div_def,  norm]  <;>  ring\n  have  H2  :  norm  (x  %  y)  *  norm  y  ≤  norm  y  /  2  *  norm  y\n  ·  calc\n  norm  (x  %  y)  *  norm  y  =  norm  (x  %  y  *  conj  y)  :=  by  simp  only  [norm_mul,  norm_conj]\n  _  =  |Int.mod'  (x.re  *  y.re  +  x.im  *  y.im)  (norm  y)|  ^  2\n  +  |Int.mod'  (-(x.re  *  y.im)  +  x.im  *  y.re)  (norm  y)|  ^  2  :=  by  simp  [H1,  norm,  sq_abs]\n  _  ≤  (y.norm  /  2)  ^  2  +  (y.norm  /  2)  ^  2  :=  by  gcongr  <;>  apply  Int.abs_mod'_le  _  _  norm_y_pos\n  _  =  norm  y  /  2  *  (norm  y  /  2  *  2)  :=  by  ring\n  _  ≤  norm  y  /  2  *  norm  y  :=  by  gcongr;  apply  Int.ediv_mul_le;  norm_num\n  calc  norm  (x  %  y)  ≤  norm  y  /  2  :=  le_of_mul_le_mul_right  H2  norm_y_pos\n  _  <  norm  y  :=  by\n  apply  Int.ediv_lt_of_lt_mul\n  ·  norm_num\n  ·  linarith \n```", "```py\ntheorem  coe_natAbs_norm  (x  :  GaussInt)  :  (x.norm.natAbs  :  ℤ)  =  x.norm  :=\n  Int.natAbs_of_nonneg  (norm_nonneg  _)\n\ntheorem  natAbs_norm_mod_lt  (x  y  :  GaussInt)  (hy  :  y  ≠  0)  :\n  (x  %  y).norm.natAbs  <  y.norm.natAbs  :=  by\n  apply  Int.ofNat_lt.1\n  simp  only  [Int.natCast_natAbs,  abs_of_nonneg,  norm_nonneg]\n  exact  norm_mod_lt  x  hy \n```", "```py\ntheorem  not_norm_mul_left_lt_norm  (x  :  GaussInt)  {y  :  GaussInt}  (hy  :  y  ≠  0)  :\n  ¬(norm  (x  *  y)).natAbs  <  (norm  x).natAbs  :=  by\n  apply  not_lt_of_ge\n  rw  [norm_mul,  Int.natAbs_mul]\n  apply  le_mul_of_one_le_right  (Nat.zero_le  _)\n  apply  Int.ofNat_le.1\n  rw  [coe_natAbs_norm]\n  exact  Int.add_one_le_of_lt  ((norm_pos  _).mpr  hy) \n```", "```py\ninstance  :  EuclideanDomain  GaussInt  :=\n  {  GaussInt.instCommRing  with\n  quotient  :=  (·  /  ·)\n  remainder  :=  (·  %  ·)\n  quotient_mul_add_remainder_eq  :=\n  fun  x  y  ↦  by  rw  [mod_def,  add_comm]  ;  ring\n  quotient_zero  :=  fun  x  ↦  by\n  simp  [div_def,  norm,  Int.div']\n  rfl\n  r  :=  (measure  (Int.natAbs  ∘  norm)).1\n  r_wellFounded  :=  (measure  (Int.natAbs  ∘  norm)).2\n  remainder_lt  :=  natAbs_norm_mod_lt\n  mul_left_not_lt  :=  not_norm_mul_left_lt_norm  } \n```", "```py\nexample  (x  :  GaussInt)  :  Irreducible  x  ↔  Prime  x  :=\n  irreducible_iff_prime \n```"]