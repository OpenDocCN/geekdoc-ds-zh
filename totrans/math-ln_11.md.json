["```py\ndef  principal  {Î±  :  Type*}  (s  :  Set  Î±)  :  Filter  Î±\n  where\n  sets  :=  {  t  |  s  âŠ†  t  }\n  univ_sets  :=  sorry\n  sets_of_superset  :=  sorry\n  inter_sets  :=  sorry \n```", "```py\nexample  :  Filter  â„•  :=\n  {  sets  :=  {  s  |  âˆƒ  a,  âˆ€  b,  a  â‰¤  b  â†’  b  âˆˆ  s  }\n  univ_sets  :=  sorry\n  sets_of_superset  :=  sorry\n  inter_sets  :=  sorry  } \n```", "```py\ndef  Tendstoâ‚  {X  Y  :  Type*}  (f  :  X  â†’  Y)  (F  :  Filter  X)  (G  :  Filter  Y)  :=\n  âˆ€  V  âˆˆ  G,  f  â»Â¹'  V  âˆˆ  F \n```", "```py\ndef  Tendstoâ‚‚  {X  Y  :  Type*}  (f  :  X  â†’  Y)  (F  :  Filter  X)  (G  :  Filter  Y)  :=\n  map  f  F  â‰¤  G\n\nexample  {X  Y  :  Type*}  (f  :  X  â†’  Y)  (F  :  Filter  X)  (G  :  Filter  Y)  :\n  Tendstoâ‚‚  f  F  G  â†”  Tendstoâ‚  f  F  G  :=\n  Iff.rfl \n```", "```py\n#check  (@Filter.map_mono  :  âˆ€  {Î±  Î²}  {m  :  Î±  â†’  Î²},  Monotone  (map  m))\n\n#check\n  (@Filter.map_map  :\n  âˆ€  {Î±  Î²  Î³}  {f  :  Filter  Î±}  {m  :  Î±  â†’  Î²}  {m'  :  Î²  â†’  Î³},  map  m'  (map  m  f)  =  map  (m'  âˆ˜  m)  f) \n```", "```py\nexample  {X  Y  Z  :  Type*}  {F  :  Filter  X}  {G  :  Filter  Y}  {H  :  Filter  Z}  {f  :  X  â†’  Y}  {g  :  Y  â†’  Z}\n  (hf  :  Tendstoâ‚  f  F  G)  (hg  :  Tendstoâ‚  g  G  H)  :  Tendstoâ‚  (g  âˆ˜  f)  F  H  :=\n  sorry \n```", "```py\nvariable  (f  :  â„  â†’  â„)  (xâ‚€  yâ‚€  :  â„)\n\n#check  comap  ((â†‘)  :  â„š  â†’  â„)  (ğ“  xâ‚€)\n\n#check  Tendsto  (f  âˆ˜  (â†‘))  (comap  ((â†‘)  :  â„š  â†’  â„)  (ğ“  xâ‚€))  (ğ“  yâ‚€) \n```", "```py\nsection\nvariable  {Î±  Î²  Î³  :  Type*}  (F  :  Filter  Î±)  {m  :  Î³  â†’  Î²}  {n  :  Î²  â†’  Î±}\n\n#check  (comap_comap  :  comap  m  (comap  n  F)  =  comap  (n  âˆ˜  m)  F)\n\nend \n```", "```py\nexample  :  ğ“  (xâ‚€,  yâ‚€)  =  ğ“  xâ‚€  Ã—Ë¢  ğ“  yâ‚€  :=\n  nhds_prod_eq \n```", "```py\n#check  le_inf_iff\n\nexample  (f  :  â„•  â†’  â„  Ã—  â„)  (xâ‚€  yâ‚€  :  â„)  :\n  Tendsto  f  atTop  (ğ“  (xâ‚€,  yâ‚€))  â†”\n  Tendsto  (Prod.fst  âˆ˜  f)  atTop  (ğ“  xâ‚€)  âˆ§  Tendsto  (Prod.snd  âˆ˜  f)  atTop  (ğ“  yâ‚€)  :=\n  sorry \n```", "```py\nexample  (xâ‚€  :  â„)  :  HasBasis  (ğ“  xâ‚€)  (fun  Îµ  :  â„  â†¦  0  <  Îµ)  fun  Îµ  â†¦  Ioo  (xâ‚€  -  Îµ)  (xâ‚€  +  Îµ)  :=\n  nhds_basis_Ioo_pos  xâ‚€ \n```", "```py\nexample  (u  :  â„•  â†’  â„)  (xâ‚€  :  â„)  :\n  Tendsto  u  atTop  (ğ“  xâ‚€)  â†”  âˆ€  Îµ  >  0,  âˆƒ  N,  âˆ€  n  â‰¥  N,  u  n  âˆˆ  Ioo  (xâ‚€  -  Îµ)  (xâ‚€  +  Îµ)  :=  by\n  have  :  atTop.HasBasis  (fun  _  :  â„•  â†¦  True)  Ici  :=  atTop_basis\n  rw  [this.tendsto_iff  (nhds_basis_Ioo_pos  xâ‚€)]\n  simp \n```", "```py\nexample  (P  Q  :  â„•  â†’  Prop)  (hP  :  âˆ€á¶   n  in  atTop,  P  n)  (hQ  :  âˆ€á¶   n  in  atTop,  Q  n)  :\n  âˆ€á¶   n  in  atTop,  P  n  âˆ§  Q  n  :=\n  hP.and  hQ \n```", "```py\nexample  (u  v  :  â„•  â†’  â„)  (h  :  âˆ€á¶   n  in  atTop,  u  n  =  v  n)  (xâ‚€  :  â„)  :\n  Tendsto  u  atTop  (ğ“  xâ‚€)  â†”  Tendsto  v  atTop  (ğ“  xâ‚€)  :=\n  tendsto_congr'  h\n\nexample  (u  v  :  â„•  â†’  â„)  (h  :  u  =á¶ [atTop]  v)  (xâ‚€  :  â„)  :\n  Tendsto  u  atTop  (ğ“  xâ‚€)  â†”  Tendsto  v  atTop  (ğ“  xâ‚€)  :=\n  tendsto_congr'  h \n```", "```py\n#check  Eventually.of_forall\n#check  Eventually.mono\n#check  Eventually.and \n```", "```py\nexample  (P  Q  R  :  â„•  â†’  Prop)  (hP  :  âˆ€á¶   n  in  atTop,  P  n)  (hQ  :  âˆ€á¶   n  in  atTop,  Q  n)\n  (hR  :  âˆ€á¶   n  in  atTop,  P  n  âˆ§  Q  n  â†’  R  n)  :  âˆ€á¶   n  in  atTop,  R  n  :=  by\n  apply  (hP.and  (hQ.and  hR)).mono\n  rintro  n  âŸ¨h,  h',  h''âŸ©\n  exact  h''  âŸ¨h,  h'âŸ©\n\nexample  (P  Q  R  :  â„•  â†’  Prop)  (hP  :  âˆ€á¶   n  in  atTop,  P  n)  (hQ  :  âˆ€á¶   n  in  atTop,  Q  n)\n  (hR  :  âˆ€á¶   n  in  atTop,  P  n  âˆ§  Q  n  â†’  R  n)  :  âˆ€á¶   n  in  atTop,  R  n  :=  by\n  filter_upwards  [hP,  hQ,  hR]  with  n  h  h'  h''\n  exact  h''  âŸ¨h,  h'âŸ© \n```", "```py\n#check  mem_closure_iff_clusterPt\n#check  le_principal_iff\n#check  neBot_of_le\n\nexample  (u  :  â„•  â†’  â„)  (M  :  Set  â„)  (x  :  â„)  (hux  :  Tendsto  u  atTop  (ğ“  x))\n  (huM  :  âˆ€á¶   n  in  atTop,  u  n  âˆˆ  M)  :  x  âˆˆ  closure  M  :=\n  sorry \n```", "```py\nvariable  {X  :  Type*}  [MetricSpace  X]  (a  b  c  :  X)\n\n#check  (dist  a  b  :  â„)\n#check  (dist_nonneg  :  0  â‰¤  dist  a  b)\n#check  (dist_eq_zero  :  dist  a  b  =  0  â†”  a  =  b)\n#check  (dist_comm  a  b  :  dist  a  b  =  dist  b  a)\n#check  (dist_triangle  a  b  c  :  dist  a  c  â‰¤  dist  a  b  +  dist  b  c) \n```", "```py\nexample  {u  :  â„•  â†’  X}  {a  :  X}  :\n  Tendsto  u  atTop  (ğ“  a)  â†”  âˆ€  Îµ  >  0,  âˆƒ  N,  âˆ€  n  â‰¥  N,  dist  (u  n)  a  <  Îµ  :=\n  Metric.tendsto_atTop\n\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  :\n  Continuous  f  â†”\n  âˆ€  x  :  X,  âˆ€  Îµ  >  0,  âˆƒ  Î´  >  0,  âˆ€  x',  dist  x'  x  <  Î´  â†’  dist  (f  x')  (f  x)  <  Îµ  :=\n  Metric.continuous_iff \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=  by  continuity \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=\n  continuous_dist.comp  ((hf.comp  continuous_fst).prodMk  (hf.comp  continuous_snd)) \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=  by\n  apply  Continuous.dist\n  exact  hf.comp  continuous_fst\n  exact  hf.comp  continuous_snd\n\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=\n  (hf.comp  continuous_fst).dist  (hf.comp  continuous_snd) \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=\n  hf.fst'.dist  hf.snd' \n```", "```py\nexample  {f  :  â„  â†’  X}  (hf  :  Continuous  f)  :  Continuous  fun  x  :  â„  â†¦  f  (x  ^  2  +  x)  :=\n  sorry \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  (f  :  X  â†’  Y)  (a  :  X)  :\n  ContinuousAt  f  a  â†”  âˆ€  Îµ  >  0,  âˆƒ  Î´  >  0,  âˆ€  {x},  dist  x  a  <  Î´  â†’  dist  (f  x)  (f  a)  <  Îµ  :=\n  Metric.continuousAt_iff \n```", "```py\nvariable  (r  :  â„)\n\nexample  :  Metric.ball  a  r  =  {  b  |  dist  b  a  <  r  }  :=\n  rfl\n\nexample  :  Metric.closedBall  a  r  =  {  b  |  dist  b  a  â‰¤  r  }  :=\n  rfl \n```", "```py\nexample  (hr  :  0  <  r)  :  a  âˆˆ  Metric.ball  a  r  :=\n  Metric.mem_ball_self  hr\n\nexample  (hr  :  0  â‰¤  r)  :  a  âˆˆ  Metric.closedBall  a  r  :=\n  Metric.mem_closedBall_self  hr \n```", "```py\nexample  (s  :  Set  X)  :  IsOpen  s  â†”  âˆ€  x  âˆˆ  s,  âˆƒ  Îµ  >  0,  Metric.ball  x  Îµ  âŠ†  s  :=\n  Metric.isOpen_iff \n```", "```py\nexample  {s  :  Set  X}  :  IsClosed  s  â†”  IsOpen  (sá¶œ)  :=\n  isOpen_compl_iff.symm\n\nexample  {s  :  Set  X}  (hs  :  IsClosed  s)  {u  :  â„•  â†’  X}  (hu  :  Tendsto  u  atTop  (ğ“  a))\n  (hus  :  âˆ€  n,  u  n  âˆˆ  s)  :  a  âˆˆ  s  :=\n  hs.mem_of_tendsto  hu  (Eventually.of_forall  hus)\n\nexample  {s  :  Set  X}  :  a  âˆˆ  closure  s  â†”  âˆ€  Îµ  >  0,  âˆƒ  b  âˆˆ  s,  a  âˆˆ  Metric.ball  b  Îµ  :=\n  Metric.mem_closure_iff \n```", "```py\nexample  {u  :  â„•  â†’  X}  (hu  :  Tendsto  u  atTop  (ğ“  a))  {s  :  Set  X}  (hs  :  âˆ€  n,  u  n  âˆˆ  s)  :\n  a  âˆˆ  closure  s  :=  by\n  sorry \n```", "```py\nexample  {x  :  X}  {s  :  Set  X}  :  s  âˆˆ  ğ“  x  â†”  âˆƒ  Îµ  >  0,  Metric.ball  x  Îµ  âŠ†  s  :=\n  Metric.nhds_basis_ball.mem_iff\n\nexample  {x  :  X}  {s  :  Set  X}  :  s  âˆˆ  ğ“  x  â†”  âˆƒ  Îµ  >  0,  Metric.closedBall  x  Îµ  âŠ†  s  :=\n  Metric.nhds_basis_closedBall.mem_iff \n```", "```py\nexample  :  IsCompact  (Set.Icc  0  1  :  Set  â„)  :=\n  isCompact_Icc\n\nexample  {s  :  Set  X}  (hs  :  IsCompact  s)  {u  :  â„•  â†’  X}  (hu  :  âˆ€  n,  u  n  âˆˆ  s)  :\n  âˆƒ  a  âˆˆ  s,  âˆƒ  Ï†  :  â„•  â†’  â„•,  StrictMono  Ï†  âˆ§  Tendsto  (u  âˆ˜  Ï†)  atTop  (ğ“  a)  :=\n  hs.tendsto_subseq  hu\n\nexample  {s  :  Set  X}  (hs  :  IsCompact  s)  (hs'  :  s.Nonempty)  {f  :  X  â†’  â„}\n  (hfs  :  ContinuousOn  f  s)  :\n  âˆƒ  x  âˆˆ  s,  âˆ€  y  âˆˆ  s,  f  x  â‰¤  f  y  :=\n  hs.exists_isMinOn  hs'  hfs\n\nexample  {s  :  Set  X}  (hs  :  IsCompact  s)  (hs'  :  s.Nonempty)  {f  :  X  â†’  â„}\n  (hfs  :  ContinuousOn  f  s)  :\n  âˆƒ  x  âˆˆ  s,  âˆ€  y  âˆˆ  s,  f  y  â‰¤  f  x  :=\n  hs.exists_isMaxOn  hs'  hfs\n\nexample  {s  :  Set  X}  (hs  :  IsCompact  s)  :  IsClosed  s  :=\n  hs.isClosed \n```", "```py\nexample  {X  :  Type*}  [MetricSpace  X]  [CompactSpace  X]  :  IsCompact  (univ  :  Set  X)  :=\n  isCompact_univ \n```", "```py\nexample  {X  :  Type*}  [MetricSpace  X]  {Y  :  Type*}  [MetricSpace  Y]  {f  :  X  â†’  Y}  :\n  UniformContinuous  f  â†”\n  âˆ€  Îµ  >  0,  âˆƒ  Î´  >  0,  âˆ€  {a  b  :  X},  dist  a  b  <  Î´  â†’  dist  (f  a)  (f  b)  <  Îµ  :=\n  Metric.uniformContinuous_iff \n```", "```py\nexample  {X  :  Type*}  [MetricSpace  X]  [CompactSpace  X]\n  {Y  :  Type*}  [MetricSpace  Y]  {f  :  X  â†’  Y}\n  (hf  :  Continuous  f)  :  UniformContinuous  f  :=  by\n  sorry \n```", "```py\nexample  (u  :  â„•  â†’  X)  :\n  CauchySeq  u  â†”  âˆ€  Îµ  >  0,  âˆƒ  N  :  â„•,  âˆ€  m  â‰¥  N,  âˆ€  n  â‰¥  N,  dist  (u  m)  (u  n)  <  Îµ  :=\n  Metric.cauchySeq_iff\n\nexample  (u  :  â„•  â†’  X)  :\n  CauchySeq  u  â†”  âˆ€  Îµ  >  0,  âˆƒ  N  :  â„•,  âˆ€  n  â‰¥  N,  dist  (u  n)  (u  N)  <  Îµ  :=\n  Metric.cauchySeq_iff'\n\nexample  [CompleteSpace  X]  (u  :  â„•  â†’  X)  (hu  :  CauchySeq  u)  :\n  âˆƒ  x,  Tendsto  u  atTop  (ğ“  x)  :=\n  cauchySeq_tendsto_of_complete  hu \n```", "```py\ntheorem  cauchySeq_of_le_geometric_two'  {u  :  â„•  â†’  X}\n  (hu  :  âˆ€  n  :  â„•,  dist  (u  n)  (u  (n  +  1))  â‰¤  (1  /  2)  ^  n)  :  CauchySeq  u  :=  by\n  rw  [Metric.cauchySeq_iff']\n  intro  Îµ  Îµ_pos\n  obtain  âŸ¨N,  hNâŸ©  :  âˆƒ  N  :  â„•,  1  /  2  ^  N  *  2  <  Îµ  :=  by  sorry\n  use  N\n  intro  n  hn\n  obtain  âŸ¨k,  rfl  :  n  =  N  +  kâŸ©  :=  le_iff_exists_add.mp  hn\n  calc\n  dist  (u  (N  +  k))  (u  N)  =  dist  (u  (N  +  0))  (u  (N  +  k))  :=  sorry\n  _  â‰¤  âˆ‘  i  âˆˆ  range  k,  dist  (u  (N  +  i))  (u  (N  +  (i  +  1)))  :=  sorry\n  _  â‰¤  âˆ‘  i  âˆˆ  range  k,  (1  /  2  :  â„)  ^  (N  +  i)  :=  sorry\n  _  =  1  /  2  ^  N  *  âˆ‘  i  âˆˆ  range  k,  (1  /  2  :  â„)  ^  i  :=  sorry\n  _  â‰¤  1  /  2  ^  N  *  2  :=  sorry\n  _  <  Îµ  :=  sorry \n```", "```py\nopen  Metric\n\nexample  [CompleteSpace  X]  (f  :  â„•  â†’  Set  X)  (ho  :  âˆ€  n,  IsOpen  (f  n))  (hd  :  âˆ€  n,  Dense  (f  n))  :\n  Dense  (â‹‚  n,  f  n)  :=  by\n  let  B  :  â„•  â†’  â„  :=  fun  n  â†¦  (1  /  2)  ^  n\n  have  Bpos  :  âˆ€  n,  0  <  B  n\n  sorry\n  /- Translate the density assumption into two functions `center` and `radius` associating\n to any n, x, Î´, Î´pos a center and a positive radius such that\n `closedBall center radius` is included both in `f n` and in `closedBall x Î´`.\n We can also require `radius â‰¤ (1/2)^(n+1)`, to ensure we get a Cauchy sequence later. -/\n  have  :\n  âˆ€  (n  :  â„•)  (x  :  X),\n  âˆ€  Î´  >  0,  âˆƒ  y  :  X,  âˆƒ  r  >  0,  r  â‰¤  B  (n  +  1)  âˆ§  closedBall  y  r  âŠ†  closedBall  x  Î´  âˆ©  f  n  :=\n  by  sorry\n  choose!  center  radius  Hpos  HB  Hball  using  this\n  intro  x\n  rw  [mem_closure_iff_nhds_basis  nhds_basis_closedBall]\n  intro  Îµ  Îµpos\n  /- `Îµ` is positive. We have to find a point in the ball of radius `Îµ` around `x`\n belonging to all `f n`. For this, we construct inductively a sequence\n `F n = (c n, r n)` such that the closed ball `closedBall (c n) (r n)` is included\n in the previous ball and in `f n`, and such that `r n` is small enough to ensure\n that `c n` is a Cauchy sequence. Then `c n` converges to a limit which belongs\n to all the `f n`. -/\n  let  F  :  â„•  â†’  X  Ã—  â„  :=  fun  n  â†¦\n  Nat.recOn  n  (Prod.mk  x  (min  Îµ  (B  0)))\n  fun  n  p  â†¦  Prod.mk  (center  n  p.1  p.2)  (radius  n  p.1  p.2)\n  let  c  :  â„•  â†’  X  :=  fun  n  â†¦  (F  n).1\n  let  r  :  â„•  â†’  â„  :=  fun  n  â†¦  (F  n).2\n  have  rpos  :  âˆ€  n,  0  <  r  n  :=  by  sorry\n  have  rB  :  âˆ€  n,  r  n  â‰¤  B  n  :=  by  sorry\n  have  incl  :  âˆ€  n,  closedBall  (c  (n  +  1))  (r  (n  +  1))  âŠ†  closedBall  (c  n)  (r  n)  âˆ©  f  n  :=  by\n  sorry\n  have  cdist  :  âˆ€  n,  dist  (c  n)  (c  (n  +  1))  â‰¤  B  n  :=  by  sorry\n  have  :  CauchySeq  c  :=  cauchySeq_of_le_geometric_two'  cdist\n  -- as the sequence `c n` is Cauchy in a complete space, it converges to a limit `y`.\n  rcases  cauchySeq_tendsto_of_complete  this  with  âŸ¨y,  ylimâŸ©\n  -- this point `y` will be the desired point. We will check that it belongs to all\n  -- `f n` and to `ball x Îµ`.\n  use  y\n  have  I  :  âˆ€  n,  âˆ€  m  â‰¥  n,  closedBall  (c  m)  (r  m)  âŠ†  closedBall  (c  n)  (r  n)  :=  by  sorry\n  have  yball  :  âˆ€  n,  y  âˆˆ  closedBall  (c  n)  (r  n)  :=  by  sorry\n  sorry \n```", "```py\nsection\nvariable  {X  :  Type*}  [TopologicalSpace  X]\n\nexample  :  IsOpen  (univ  :  Set  X)  :=\n  isOpen_univ\n\nexample  :  IsOpen  (âˆ…  :  Set  X)  :=\n  isOpen_empty\n\nexample  {Î¹  :  Type*}  {s  :  Î¹  â†’  Set  X}  (hs  :  âˆ€  i,  IsOpen  (s  i))  :  IsOpen  (â‹ƒ  i,  s  i)  :=\n  isOpen_iUnion  hs\n\nexample  {Î¹  :  Type*}  [Fintype  Î¹]  {s  :  Î¹  â†’  Set  X}  (hs  :  âˆ€  i,  IsOpen  (s  i))  :\n  IsOpen  (â‹‚  i,  s  i)  :=\n  isOpen_iInter_of_finite  hs \n```", "```py\nvariable  {Y  :  Type*}  [TopologicalSpace  Y]\n\nexample  {f  :  X  â†’  Y}  :  Continuous  f  â†”  âˆ€  s,  IsOpen  s  â†’  IsOpen  (f  â»Â¹'  s)  :=\n  continuous_def \n```", "```py\nexample  {f  :  X  â†’  Y}  {x  :  X}  :  ContinuousAt  f  x  â†”  map  f  (ğ“  x)  â‰¤  ğ“  (f  x)  :=\n  Iff.rfl \n```", "```py\nexample  {f  :  X  â†’  Y}  {x  :  X}  :  ContinuousAt  f  x  â†”  âˆ€  U  âˆˆ  ğ“  (f  x),  âˆ€á¶   x  in  ğ“  x,  f  x  âˆˆ  U  :=\n  Iff.rfl \n```", "```py\nexample  {x  :  X}  {s  :  Set  X}  :  s  âˆˆ  ğ“  x  â†”  âˆƒ  t,  t  âŠ†  s  âˆ§  IsOpen  t  âˆ§  x  âˆˆ  t  :=\n  mem_nhds_iff \n```", "```py\nexample  (x  :  X)  :  pure  x  â‰¤  ğ“  x  :=\n  pure_le_nhds  x\n\nexample  (x  :  X)  (P  :  X  â†’  Prop)  (h  :  âˆ€á¶   y  in  ğ“  x,  P  y)  :  P  x  :=\n  h.self_of_nhds \n```", "```py\nexample  {P  :  X  â†’  Prop}  {x  :  X}  (h  :  âˆ€á¶   y  in  ğ“  x,  P  y)  :  âˆ€á¶   y  in  ğ“  x,  âˆ€á¶   z  in  ğ“  y,  P  z  :=\n  eventually_eventually_nhds.mpr  h \n```", "```py\nexample  {Î±  :  Type*}  (n  :  Î±  â†’  Filter  Î±)  (Hâ‚€  :  âˆ€  a,  pure  a  â‰¤  n  a)\n  (H  :  âˆ€  a  :  Î±,  âˆ€  p  :  Î±  â†’  Prop,  (âˆ€á¶   x  in  n  a,  p  x)  â†’  âˆ€á¶   y  in  n  a,  âˆ€á¶   x  in  n  y,  p  x)  :\n  âˆ€  a,  âˆ€  s  âˆˆ  n  a,  âˆƒ  t  âˆˆ  n  a,  t  âŠ†  s  âˆ§  âˆ€  a'  âˆˆ  t,  s  âˆˆ  n  a'  :=  by\n  sorry\nend \n```", "```py\nvariable  {X  Y  :  Type*}\n\nexample  (f  :  X  â†’  Y)  :  TopologicalSpace  X  â†’  TopologicalSpace  Y  :=\n  TopologicalSpace.coinduced  f\n\nexample  (f  :  X  â†’  Y)  :  TopologicalSpace  Y  â†’  TopologicalSpace  X  :=\n  TopologicalSpace.induced  f\n\nexample  (f  :  X  â†’  Y)  (T_X  :  TopologicalSpace  X)  (T_Y  :  TopologicalSpace  Y)  :\n  TopologicalSpace.coinduced  f  T_X  â‰¤  T_Y  â†”  T_X  â‰¤  TopologicalSpace.induced  f  T_Y  :=\n  coinduced_le_iff_le_induced \n```", "```py\nexample  {T  T'  :  TopologicalSpace  X}  :  T  â‰¤  T'  â†”  âˆ€  s,  T'.IsOpen  s  â†’  T.IsOpen  s  :=\n  Iff.rfl \n```", "```py\nexample  (T_X  :  TopologicalSpace  X)  (T_Y  :  TopologicalSpace  Y)  (f  :  X  â†’  Y)  :\n  Continuous  f  â†”  TopologicalSpace.coinduced  f  T_X  â‰¤  T_Y  :=\n  continuous_iff_coinduced_le \n```", "```py\nexample  {Z  :  Type*}  (f  :  X  â†’  Y)  (T_X  :  TopologicalSpace  X)  (T_Z  :  TopologicalSpace  Z)\n  (g  :  Y  â†’  Z)  :\n  @Continuous  Y  Z  (TopologicalSpace.coinduced  f  T_X)  T_Z  g  â†”\n  @Continuous  X  Z  T_X  T_Z  (g  âˆ˜  f)  :=  by\n  rw  [continuous_iff_coinduced_le,  coinduced_compose,  continuous_iff_coinduced_le] \n```", "```py\nexample  (Î¹  :  Type*)  (X  :  Î¹  â†’  Type*)  (T_X  :  âˆ€  i,  TopologicalSpace  (X  i))  :\n  (Pi.topologicalSpace  :  TopologicalSpace  (âˆ€  i,  X  i))  =\n  â¨…  i,  TopologicalSpace.induced  (fun  x  â†¦  x  i)  (T_X  i)  :=\n  rfl \n```", "```py\nexample  [TopologicalSpace  X]  [T2Space  X]  {u  :  â„•  â†’  X}  {a  b  :  X}  (ha  :  Tendsto  u  atTop  (ğ“  a))\n  (hb  :  Tendsto  u  atTop  (ğ“  b))  :  a  =  b  :=\n  tendsto_nhds_unique  ha  hb\n\nexample  [TopologicalSpace  X]  [RegularSpace  X]  (a  :  X)  :\n  (ğ“  a).HasBasis  (fun  s  :  Set  X  â†¦  s  âˆˆ  ğ“  a  âˆ§  IsClosed  s)  id  :=\n  closed_nhds_basis  a \n```", "```py\nexample  [TopologicalSpace  X]  {x  :  X}  :\n  (ğ“  x).HasBasis  (fun  t  :  Set  X  â†¦  t  âˆˆ  ğ“  x  âˆ§  IsOpen  t)  id  :=\n  nhds_basis_opens'  x \n```", "```py\ntheorem  aux  {X  Y  A  :  Type*}  [TopologicalSpace  X]  {c  :  A  â†’  X}\n  {f  :  A  â†’  Y}  {x  :  X}  {F  :  Filter  Y}\n  (h  :  Tendsto  f  (comap  c  (ğ“  x))  F)  {V'  :  Set  Y}  (V'_in  :  V'  âˆˆ  F)  :\n  âˆƒ  V  âˆˆ  ğ“  x,  IsOpen  V  âˆ§  c  â»Â¹'  V  âŠ†  f  â»Â¹'  V'  :=  by\n  sorry \n```", "```py\nexample  [TopologicalSpace  X]  [TopologicalSpace  Y]  [T3Space  Y]  {A  :  Set  X}\n  (hA  :  âˆ€  x,  x  âˆˆ  closure  A)  {f  :  A  â†’  Y}  (f_cont  :  Continuous  f)\n  (hf  :  âˆ€  x  :  X,  âˆƒ  c  :  Y,  Tendsto  f  (comap  (â†‘)  (ğ“  x))  (ğ“  c))  :\n  âˆƒ  Ï†  :  X  â†’  Y,  Continuous  Ï†  âˆ§  âˆ€  a  :  A,  Ï†  a  =  f  a  :=  by\n  sorry\n\n#check  HasBasis.tendsto_right_iff \n```", "```py\nexample  [TopologicalSpace  X]  [FirstCountableTopology  X]\n  {s  :  Set  X}  {a  :  X}  :\n  a  âˆˆ  closure  s  â†”  âˆƒ  u  :  â„•  â†’  X,  (âˆ€  n,  u  n  âˆˆ  s)  âˆ§  Tendsto  u  atTop  (ğ“  a)  :=\n  mem_closure_iff_seq_limit \n```", "```py\nvariable  [TopologicalSpace  X]\n\nexample  {F  :  Filter  X}  {x  :  X}  :  ClusterPt  x  F  â†”  NeBot  (ğ“  x  âŠ“  F)  :=\n  Iff.rfl\n\nexample  {s  :  Set  X}  :\n  IsCompact  s  â†”  âˆ€  (F  :  Filter  X)  [NeBot  F],  F  â‰¤  ğ“Ÿ  s  â†’  âˆƒ  a  âˆˆ  s,  ClusterPt  a  F  :=\n  Iff.rfl \n```", "```py\nexample  [FirstCountableTopology  X]  {s  :  Set  X}  {u  :  â„•  â†’  X}  (hs  :  IsCompact  s)\n  (hu  :  âˆ€  n,  u  n  âˆˆ  s)  :  âˆƒ  a  âˆˆ  s,  âˆƒ  Ï†  :  â„•  â†’  â„•,  StrictMono  Ï†  âˆ§  Tendsto  (u  âˆ˜  Ï†)  atTop  (ğ“  a)  :=\n  hs.tendsto_subseq  hu \n```", "```py\nvariable  [TopologicalSpace  Y]\n\nexample  {x  :  X}  {F  :  Filter  X}  {G  :  Filter  Y}  (H  :  ClusterPt  x  F)  {f  :  X  â†’  Y}\n  (hfx  :  ContinuousAt  f  x)  (hf  :  Tendsto  f  F  G)  :  ClusterPt  (f  x)  G  :=\n  ClusterPt.map  H  hfx  hf \n```", "```py\nexample  [TopologicalSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  {s  :  Set  X}  (hs  :  IsCompact  s)  :\n  IsCompact  (f  ''  s)  :=  by\n  intro  F  F_ne  F_le\n  have  map_eq  :  map  f  (ğ“Ÿ  s  âŠ“  comap  f  F)  =  ğ“Ÿ  (f  ''  s)  âŠ“  F  :=  by  sorry\n  have  Hne  :  (ğ“Ÿ  s  âŠ“  comap  f  F).NeBot  :=  by  sorry\n  have  Hle  :  ğ“Ÿ  s  âŠ“  comap  f  F  â‰¤  ğ“Ÿ  s  :=  inf_le_left\n  sorry \n```", "```py\nexample  {Î¹  :  Type*}  {s  :  Set  X}  (hs  :  IsCompact  s)  (U  :  Î¹  â†’  Set  X)  (hUo  :  âˆ€  i,  IsOpen  (U  i))\n  (hsU  :  s  âŠ†  â‹ƒ  i,  U  i)  :  âˆƒ  t  :  Finset  Î¹,  s  âŠ†  â‹ƒ  i  âˆˆ  t,  U  i  :=\n  hs.elim_finite_subcover  U  hUo  hsU \n```", "```py\ndef  principal  {Î±  :  Type*}  (s  :  Set  Î±)  :  Filter  Î±\n  where\n  sets  :=  {  t  |  s  âŠ†  t  }\n  univ_sets  :=  sorry\n  sets_of_superset  :=  sorry\n  inter_sets  :=  sorry \n```", "```py\nexample  :  Filter  â„•  :=\n  {  sets  :=  {  s  |  âˆƒ  a,  âˆ€  b,  a  â‰¤  b  â†’  b  âˆˆ  s  }\n  univ_sets  :=  sorry\n  sets_of_superset  :=  sorry\n  inter_sets  :=  sorry  } \n```", "```py\ndef  Tendstoâ‚  {X  Y  :  Type*}  (f  :  X  â†’  Y)  (F  :  Filter  X)  (G  :  Filter  Y)  :=\n  âˆ€  V  âˆˆ  G,  f  â»Â¹'  V  âˆˆ  F \n```", "```py\ndef  Tendstoâ‚‚  {X  Y  :  Type*}  (f  :  X  â†’  Y)  (F  :  Filter  X)  (G  :  Filter  Y)  :=\n  map  f  F  â‰¤  G\n\nexample  {X  Y  :  Type*}  (f  :  X  â†’  Y)  (F  :  Filter  X)  (G  :  Filter  Y)  :\n  Tendstoâ‚‚  f  F  G  â†”  Tendstoâ‚  f  F  G  :=\n  Iff.rfl \n```", "```py\n#check  (@Filter.map_mono  :  âˆ€  {Î±  Î²}  {m  :  Î±  â†’  Î²},  Monotone  (map  m))\n\n#check\n  (@Filter.map_map  :\n  âˆ€  {Î±  Î²  Î³}  {f  :  Filter  Î±}  {m  :  Î±  â†’  Î²}  {m'  :  Î²  â†’  Î³},  map  m'  (map  m  f)  =  map  (m'  âˆ˜  m)  f) \n```", "```py\nexample  {X  Y  Z  :  Type*}  {F  :  Filter  X}  {G  :  Filter  Y}  {H  :  Filter  Z}  {f  :  X  â†’  Y}  {g  :  Y  â†’  Z}\n  (hf  :  Tendstoâ‚  f  F  G)  (hg  :  Tendstoâ‚  g  G  H)  :  Tendstoâ‚  (g  âˆ˜  f)  F  H  :=\n  sorry \n```", "```py\nvariable  (f  :  â„  â†’  â„)  (xâ‚€  yâ‚€  :  â„)\n\n#check  comap  ((â†‘)  :  â„š  â†’  â„)  (ğ“  xâ‚€)\n\n#check  Tendsto  (f  âˆ˜  (â†‘))  (comap  ((â†‘)  :  â„š  â†’  â„)  (ğ“  xâ‚€))  (ğ“  yâ‚€) \n```", "```py\nsection\nvariable  {Î±  Î²  Î³  :  Type*}  (F  :  Filter  Î±)  {m  :  Î³  â†’  Î²}  {n  :  Î²  â†’  Î±}\n\n#check  (comap_comap  :  comap  m  (comap  n  F)  =  comap  (n  âˆ˜  m)  F)\n\nend \n```", "```py\nexample  :  ğ“  (xâ‚€,  yâ‚€)  =  ğ“  xâ‚€  Ã—Ë¢  ğ“  yâ‚€  :=\n  nhds_prod_eq \n```", "```py\n#check  le_inf_iff\n\nexample  (f  :  â„•  â†’  â„  Ã—  â„)  (xâ‚€  yâ‚€  :  â„)  :\n  Tendsto  f  atTop  (ğ“  (xâ‚€,  yâ‚€))  â†”\n  Tendsto  (Prod.fst  âˆ˜  f)  atTop  (ğ“  xâ‚€)  âˆ§  Tendsto  (Prod.snd  âˆ˜  f)  atTop  (ğ“  yâ‚€)  :=\n  sorry \n```", "```py\nexample  (xâ‚€  :  â„)  :  HasBasis  (ğ“  xâ‚€)  (fun  Îµ  :  â„  â†¦  0  <  Îµ)  fun  Îµ  â†¦  Ioo  (xâ‚€  -  Îµ)  (xâ‚€  +  Îµ)  :=\n  nhds_basis_Ioo_pos  xâ‚€ \n```", "```py\nexample  (u  :  â„•  â†’  â„)  (xâ‚€  :  â„)  :\n  Tendsto  u  atTop  (ğ“  xâ‚€)  â†”  âˆ€  Îµ  >  0,  âˆƒ  N,  âˆ€  n  â‰¥  N,  u  n  âˆˆ  Ioo  (xâ‚€  -  Îµ)  (xâ‚€  +  Îµ)  :=  by\n  have  :  atTop.HasBasis  (fun  _  :  â„•  â†¦  True)  Ici  :=  atTop_basis\n  rw  [this.tendsto_iff  (nhds_basis_Ioo_pos  xâ‚€)]\n  simp \n```", "```py\nexample  (P  Q  :  â„•  â†’  Prop)  (hP  :  âˆ€á¶   n  in  atTop,  P  n)  (hQ  :  âˆ€á¶   n  in  atTop,  Q  n)  :\n  âˆ€á¶   n  in  atTop,  P  n  âˆ§  Q  n  :=\n  hP.and  hQ \n```", "```py\nexample  (u  v  :  â„•  â†’  â„)  (h  :  âˆ€á¶   n  in  atTop,  u  n  =  v  n)  (xâ‚€  :  â„)  :\n  Tendsto  u  atTop  (ğ“  xâ‚€)  â†”  Tendsto  v  atTop  (ğ“  xâ‚€)  :=\n  tendsto_congr'  h\n\nexample  (u  v  :  â„•  â†’  â„)  (h  :  u  =á¶ [atTop]  v)  (xâ‚€  :  â„)  :\n  Tendsto  u  atTop  (ğ“  xâ‚€)  â†”  Tendsto  v  atTop  (ğ“  xâ‚€)  :=\n  tendsto_congr'  h \n```", "```py\n#check  Eventually.of_forall\n#check  Eventually.mono\n#check  Eventually.and \n```", "```py\nexample  (P  Q  R  :  â„•  â†’  Prop)  (hP  :  âˆ€á¶   n  in  atTop,  P  n)  (hQ  :  âˆ€á¶   n  in  atTop,  Q  n)\n  (hR  :  âˆ€á¶   n  in  atTop,  P  n  âˆ§  Q  n  â†’  R  n)  :  âˆ€á¶   n  in  atTop,  R  n  :=  by\n  apply  (hP.and  (hQ.and  hR)).mono\n  rintro  n  âŸ¨h,  h',  h''âŸ©\n  exact  h''  âŸ¨h,  h'âŸ©\n\nexample  (P  Q  R  :  â„•  â†’  Prop)  (hP  :  âˆ€á¶   n  in  atTop,  P  n)  (hQ  :  âˆ€á¶   n  in  atTop,  Q  n)\n  (hR  :  âˆ€á¶   n  in  atTop,  P  n  âˆ§  Q  n  â†’  R  n)  :  âˆ€á¶   n  in  atTop,  R  n  :=  by\n  filter_upwards  [hP,  hQ,  hR]  with  n  h  h'  h''\n  exact  h''  âŸ¨h,  h'âŸ© \n```", "```py\n#check  mem_closure_iff_clusterPt\n#check  le_principal_iff\n#check  neBot_of_le\n\nexample  (u  :  â„•  â†’  â„)  (M  :  Set  â„)  (x  :  â„)  (hux  :  Tendsto  u  atTop  (ğ“  x))\n  (huM  :  âˆ€á¶   n  in  atTop,  u  n  âˆˆ  M)  :  x  âˆˆ  closure  M  :=\n  sorry \n```", "```py\nvariable  {X  :  Type*}  [MetricSpace  X]  (a  b  c  :  X)\n\n#check  (dist  a  b  :  â„)\n#check  (dist_nonneg  :  0  â‰¤  dist  a  b)\n#check  (dist_eq_zero  :  dist  a  b  =  0  â†”  a  =  b)\n#check  (dist_comm  a  b  :  dist  a  b  =  dist  b  a)\n#check  (dist_triangle  a  b  c  :  dist  a  c  â‰¤  dist  a  b  +  dist  b  c) \n```", "```py\nexample  {u  :  â„•  â†’  X}  {a  :  X}  :\n  Tendsto  u  atTop  (ğ“  a)  â†”  âˆ€  Îµ  >  0,  âˆƒ  N,  âˆ€  n  â‰¥  N,  dist  (u  n)  a  <  Îµ  :=\n  Metric.tendsto_atTop\n\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  :\n  Continuous  f  â†”\n  âˆ€  x  :  X,  âˆ€  Îµ  >  0,  âˆƒ  Î´  >  0,  âˆ€  x',  dist  x'  x  <  Î´  â†’  dist  (f  x')  (f  x)  <  Îµ  :=\n  Metric.continuous_iff \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=  by  continuity \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=\n  continuous_dist.comp  ((hf.comp  continuous_fst).prodMk  (hf.comp  continuous_snd)) \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=  by\n  apply  Continuous.dist\n  exact  hf.comp  continuous_fst\n  exact  hf.comp  continuous_snd\n\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=\n  (hf.comp  continuous_fst).dist  (hf.comp  continuous_snd) \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=\n  hf.fst'.dist  hf.snd' \n```", "```py\nexample  {f  :  â„  â†’  X}  (hf  :  Continuous  f)  :  Continuous  fun  x  :  â„  â†¦  f  (x  ^  2  +  x)  :=\n  sorry \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  (f  :  X  â†’  Y)  (a  :  X)  :\n  ContinuousAt  f  a  â†”  âˆ€  Îµ  >  0,  âˆƒ  Î´  >  0,  âˆ€  {x},  dist  x  a  <  Î´  â†’  dist  (f  x)  (f  a)  <  Îµ  :=\n  Metric.continuousAt_iff \n```", "```py\nvariable  (r  :  â„)\n\nexample  :  Metric.ball  a  r  =  {  b  |  dist  b  a  <  r  }  :=\n  rfl\n\nexample  :  Metric.closedBall  a  r  =  {  b  |  dist  b  a  â‰¤  r  }  :=\n  rfl \n```", "```py\nexample  (hr  :  0  <  r)  :  a  âˆˆ  Metric.ball  a  r  :=\n  Metric.mem_ball_self  hr\n\nexample  (hr  :  0  â‰¤  r)  :  a  âˆˆ  Metric.closedBall  a  r  :=\n  Metric.mem_closedBall_self  hr \n```", "```py\nexample  (s  :  Set  X)  :  IsOpen  s  â†”  âˆ€  x  âˆˆ  s,  âˆƒ  Îµ  >  0,  Metric.ball  x  Îµ  âŠ†  s  :=\n  Metric.isOpen_iff \n```", "```py\nexample  {s  :  Set  X}  :  IsClosed  s  â†”  IsOpen  (sá¶œ)  :=\n  isOpen_compl_iff.symm\n\nexample  {s  :  Set  X}  (hs  :  IsClosed  s)  {u  :  â„•  â†’  X}  (hu  :  Tendsto  u  atTop  (ğ“  a))\n  (hus  :  âˆ€  n,  u  n  âˆˆ  s)  :  a  âˆˆ  s  :=\n  hs.mem_of_tendsto  hu  (Eventually.of_forall  hus)\n\nexample  {s  :  Set  X}  :  a  âˆˆ  closure  s  â†”  âˆ€  Îµ  >  0,  âˆƒ  b  âˆˆ  s,  a  âˆˆ  Metric.ball  b  Îµ  :=\n  Metric.mem_closure_iff \n```", "```py\nexample  {u  :  â„•  â†’  X}  (hu  :  Tendsto  u  atTop  (ğ“  a))  {s  :  Set  X}  (hs  :  âˆ€  n,  u  n  âˆˆ  s)  :\n  a  âˆˆ  closure  s  :=  by\n  sorry \n```", "```py\nexample  {x  :  X}  {s  :  Set  X}  :  s  âˆˆ  ğ“  x  â†”  âˆƒ  Îµ  >  0,  Metric.ball  x  Îµ  âŠ†  s  :=\n  Metric.nhds_basis_ball.mem_iff\n\nexample  {x  :  X}  {s  :  Set  X}  :  s  âˆˆ  ğ“  x  â†”  âˆƒ  Îµ  >  0,  Metric.closedBall  x  Îµ  âŠ†  s  :=\n  Metric.nhds_basis_closedBall.mem_iff \n```", "```py\nexample  :  IsCompact  (Set.Icc  0  1  :  Set  â„)  :=\n  isCompact_Icc\n\nexample  {s  :  Set  X}  (hs  :  IsCompact  s)  {u  :  â„•  â†’  X}  (hu  :  âˆ€  n,  u  n  âˆˆ  s)  :\n  âˆƒ  a  âˆˆ  s,  âˆƒ  Ï†  :  â„•  â†’  â„•,  StrictMono  Ï†  âˆ§  Tendsto  (u  âˆ˜  Ï†)  atTop  (ğ“  a)  :=\n  hs.tendsto_subseq  hu\n\nexample  {s  :  Set  X}  (hs  :  IsCompact  s)  (hs'  :  s.Nonempty)  {f  :  X  â†’  â„}\n  (hfs  :  ContinuousOn  f  s)  :\n  âˆƒ  x  âˆˆ  s,  âˆ€  y  âˆˆ  s,  f  x  â‰¤  f  y  :=\n  hs.exists_isMinOn  hs'  hfs\n\nexample  {s  :  Set  X}  (hs  :  IsCompact  s)  (hs'  :  s.Nonempty)  {f  :  X  â†’  â„}\n  (hfs  :  ContinuousOn  f  s)  :\n  âˆƒ  x  âˆˆ  s,  âˆ€  y  âˆˆ  s,  f  y  â‰¤  f  x  :=\n  hs.exists_isMaxOn  hs'  hfs\n\nexample  {s  :  Set  X}  (hs  :  IsCompact  s)  :  IsClosed  s  :=\n  hs.isClosed \n```", "```py\nexample  {X  :  Type*}  [MetricSpace  X]  [CompactSpace  X]  :  IsCompact  (univ  :  Set  X)  :=\n  isCompact_univ \n```", "```py\nexample  {X  :  Type*}  [MetricSpace  X]  {Y  :  Type*}  [MetricSpace  Y]  {f  :  X  â†’  Y}  :\n  UniformContinuous  f  â†”\n  âˆ€  Îµ  >  0,  âˆƒ  Î´  >  0,  âˆ€  {a  b  :  X},  dist  a  b  <  Î´  â†’  dist  (f  a)  (f  b)  <  Îµ  :=\n  Metric.uniformContinuous_iff \n```", "```py\nexample  {X  :  Type*}  [MetricSpace  X]  [CompactSpace  X]\n  {Y  :  Type*}  [MetricSpace  Y]  {f  :  X  â†’  Y}\n  (hf  :  Continuous  f)  :  UniformContinuous  f  :=  by\n  sorry \n```", "```py\nexample  (u  :  â„•  â†’  X)  :\n  CauchySeq  u  â†”  âˆ€  Îµ  >  0,  âˆƒ  N  :  â„•,  âˆ€  m  â‰¥  N,  âˆ€  n  â‰¥  N,  dist  (u  m)  (u  n)  <  Îµ  :=\n  Metric.cauchySeq_iff\n\nexample  (u  :  â„•  â†’  X)  :\n  CauchySeq  u  â†”  âˆ€  Îµ  >  0,  âˆƒ  N  :  â„•,  âˆ€  n  â‰¥  N,  dist  (u  n)  (u  N)  <  Îµ  :=\n  Metric.cauchySeq_iff'\n\nexample  [CompleteSpace  X]  (u  :  â„•  â†’  X)  (hu  :  CauchySeq  u)  :\n  âˆƒ  x,  Tendsto  u  atTop  (ğ“  x)  :=\n  cauchySeq_tendsto_of_complete  hu \n```", "```py\ntheorem  cauchySeq_of_le_geometric_two'  {u  :  â„•  â†’  X}\n  (hu  :  âˆ€  n  :  â„•,  dist  (u  n)  (u  (n  +  1))  â‰¤  (1  /  2)  ^  n)  :  CauchySeq  u  :=  by\n  rw  [Metric.cauchySeq_iff']\n  intro  Îµ  Îµ_pos\n  obtain  âŸ¨N,  hNâŸ©  :  âˆƒ  N  :  â„•,  1  /  2  ^  N  *  2  <  Îµ  :=  by  sorry\n  use  N\n  intro  n  hn\n  obtain  âŸ¨k,  rfl  :  n  =  N  +  kâŸ©  :=  le_iff_exists_add.mp  hn\n  calc\n  dist  (u  (N  +  k))  (u  N)  =  dist  (u  (N  +  0))  (u  (N  +  k))  :=  sorry\n  _  â‰¤  âˆ‘  i  âˆˆ  range  k,  dist  (u  (N  +  i))  (u  (N  +  (i  +  1)))  :=  sorry\n  _  â‰¤  âˆ‘  i  âˆˆ  range  k,  (1  /  2  :  â„)  ^  (N  +  i)  :=  sorry\n  _  =  1  /  2  ^  N  *  âˆ‘  i  âˆˆ  range  k,  (1  /  2  :  â„)  ^  i  :=  sorry\n  _  â‰¤  1  /  2  ^  N  *  2  :=  sorry\n  _  <  Îµ  :=  sorry \n```", "```py\nopen  Metric\n\nexample  [CompleteSpace  X]  (f  :  â„•  â†’  Set  X)  (ho  :  âˆ€  n,  IsOpen  (f  n))  (hd  :  âˆ€  n,  Dense  (f  n))  :\n  Dense  (â‹‚  n,  f  n)  :=  by\n  let  B  :  â„•  â†’  â„  :=  fun  n  â†¦  (1  /  2)  ^  n\n  have  Bpos  :  âˆ€  n,  0  <  B  n\n  sorry\n  /- Translate the density assumption into two functions `center` and `radius` associating\n to any n, x, Î´, Î´pos a center and a positive radius such that\n `closedBall center radius` is included both in `f n` and in `closedBall x Î´`.\n We can also require `radius â‰¤ (1/2)^(n+1)`, to ensure we get a Cauchy sequence later. -/\n  have  :\n  âˆ€  (n  :  â„•)  (x  :  X),\n  âˆ€  Î´  >  0,  âˆƒ  y  :  X,  âˆƒ  r  >  0,  r  â‰¤  B  (n  +  1)  âˆ§  closedBall  y  r  âŠ†  closedBall  x  Î´  âˆ©  f  n  :=\n  by  sorry\n  choose!  center  radius  Hpos  HB  Hball  using  this\n  intro  x\n  rw  [mem_closure_iff_nhds_basis  nhds_basis_closedBall]\n  intro  Îµ  Îµpos\n  /- `Îµ` is positive. We have to find a point in the ball of radius `Îµ` around `x`\n belonging to all `f n`. For this, we construct inductively a sequence\n `F n = (c n, r n)` such that the closed ball `closedBall (c n) (r n)` is included\n in the previous ball and in `f n`, and such that `r n` is small enough to ensure\n that `c n` is a Cauchy sequence. Then `c n` converges to a limit which belongs\n to all the `f n`. -/\n  let  F  :  â„•  â†’  X  Ã—  â„  :=  fun  n  â†¦\n  Nat.recOn  n  (Prod.mk  x  (min  Îµ  (B  0)))\n  fun  n  p  â†¦  Prod.mk  (center  n  p.1  p.2)  (radius  n  p.1  p.2)\n  let  c  :  â„•  â†’  X  :=  fun  n  â†¦  (F  n).1\n  let  r  :  â„•  â†’  â„  :=  fun  n  â†¦  (F  n).2\n  have  rpos  :  âˆ€  n,  0  <  r  n  :=  by  sorry\n  have  rB  :  âˆ€  n,  r  n  â‰¤  B  n  :=  by  sorry\n  have  incl  :  âˆ€  n,  closedBall  (c  (n  +  1))  (r  (n  +  1))  âŠ†  closedBall  (c  n)  (r  n)  âˆ©  f  n  :=  by\n  sorry\n  have  cdist  :  âˆ€  n,  dist  (c  n)  (c  (n  +  1))  â‰¤  B  n  :=  by  sorry\n  have  :  CauchySeq  c  :=  cauchySeq_of_le_geometric_two'  cdist\n  -- as the sequence `c n` is Cauchy in a complete space, it converges to a limit `y`.\n  rcases  cauchySeq_tendsto_of_complete  this  with  âŸ¨y,  ylimâŸ©\n  -- this point `y` will be the desired point. We will check that it belongs to all\n  -- `f n` and to `ball x Îµ`.\n  use  y\n  have  I  :  âˆ€  n,  âˆ€  m  â‰¥  n,  closedBall  (c  m)  (r  m)  âŠ†  closedBall  (c  n)  (r  n)  :=  by  sorry\n  have  yball  :  âˆ€  n,  y  âˆˆ  closedBall  (c  n)  (r  n)  :=  by  sorry\n  sorry \n```", "```py\nsection\nvariable  {X  :  Type*}  [TopologicalSpace  X]\n\nexample  :  IsOpen  (univ  :  Set  X)  :=\n  isOpen_univ\n\nexample  :  IsOpen  (âˆ…  :  Set  X)  :=\n  isOpen_empty\n\nexample  {Î¹  :  Type*}  {s  :  Î¹  â†’  Set  X}  (hs  :  âˆ€  i,  IsOpen  (s  i))  :  IsOpen  (â‹ƒ  i,  s  i)  :=\n  isOpen_iUnion  hs\n\nexample  {Î¹  :  Type*}  [Fintype  Î¹]  {s  :  Î¹  â†’  Set  X}  (hs  :  âˆ€  i,  IsOpen  (s  i))  :\n  IsOpen  (â‹‚  i,  s  i)  :=\n  isOpen_iInter_of_finite  hs \n```", "```py\nvariable  {Y  :  Type*}  [TopologicalSpace  Y]\n\nexample  {f  :  X  â†’  Y}  :  Continuous  f  â†”  âˆ€  s,  IsOpen  s  â†’  IsOpen  (f  â»Â¹'  s)  :=\n  continuous_def \n```", "```py\nexample  {f  :  X  â†’  Y}  {x  :  X}  :  ContinuousAt  f  x  â†”  map  f  (ğ“  x)  â‰¤  ğ“  (f  x)  :=\n  Iff.rfl \n```", "```py\nexample  {f  :  X  â†’  Y}  {x  :  X}  :  ContinuousAt  f  x  â†”  âˆ€  U  âˆˆ  ğ“  (f  x),  âˆ€á¶   x  in  ğ“  x,  f  x  âˆˆ  U  :=\n  Iff.rfl \n```", "```py\nexample  {x  :  X}  {s  :  Set  X}  :  s  âˆˆ  ğ“  x  â†”  âˆƒ  t,  t  âŠ†  s  âˆ§  IsOpen  t  âˆ§  x  âˆˆ  t  :=\n  mem_nhds_iff \n```", "```py\nexample  (x  :  X)  :  pure  x  â‰¤  ğ“  x  :=\n  pure_le_nhds  x\n\nexample  (x  :  X)  (P  :  X  â†’  Prop)  (h  :  âˆ€á¶   y  in  ğ“  x,  P  y)  :  P  x  :=\n  h.self_of_nhds \n```", "```py\nexample  {P  :  X  â†’  Prop}  {x  :  X}  (h  :  âˆ€á¶   y  in  ğ“  x,  P  y)  :  âˆ€á¶   y  in  ğ“  x,  âˆ€á¶   z  in  ğ“  y,  P  z  :=\n  eventually_eventually_nhds.mpr  h \n```", "```py\nexample  {Î±  :  Type*}  (n  :  Î±  â†’  Filter  Î±)  (Hâ‚€  :  âˆ€  a,  pure  a  â‰¤  n  a)\n  (H  :  âˆ€  a  :  Î±,  âˆ€  p  :  Î±  â†’  Prop,  (âˆ€á¶   x  in  n  a,  p  x)  â†’  âˆ€á¶   y  in  n  a,  âˆ€á¶   x  in  n  y,  p  x)  :\n  âˆ€  a,  âˆ€  s  âˆˆ  n  a,  âˆƒ  t  âˆˆ  n  a,  t  âŠ†  s  âˆ§  âˆ€  a'  âˆˆ  t,  s  âˆˆ  n  a'  :=  by\n  sorry\nend \n```", "```py\nvariable  {X  Y  :  Type*}\n\nexample  (f  :  X  â†’  Y)  :  TopologicalSpace  X  â†’  TopologicalSpace  Y  :=\n  TopologicalSpace.coinduced  f\n\nexample  (f  :  X  â†’  Y)  :  TopologicalSpace  Y  â†’  TopologicalSpace  X  :=\n  TopologicalSpace.induced  f\n\nexample  (f  :  X  â†’  Y)  (T_X  :  TopologicalSpace  X)  (T_Y  :  TopologicalSpace  Y)  :\n  TopologicalSpace.coinduced  f  T_X  â‰¤  T_Y  â†”  T_X  â‰¤  TopologicalSpace.induced  f  T_Y  :=\n  coinduced_le_iff_le_induced \n```", "```py\nexample  {T  T'  :  TopologicalSpace  X}  :  T  â‰¤  T'  â†”  âˆ€  s,  T'.IsOpen  s  â†’  T.IsOpen  s  :=\n  Iff.rfl \n```", "```py\nexample  (T_X  :  TopologicalSpace  X)  (T_Y  :  TopologicalSpace  Y)  (f  :  X  â†’  Y)  :\n  Continuous  f  â†”  TopologicalSpace.coinduced  f  T_X  â‰¤  T_Y  :=\n  continuous_iff_coinduced_le \n```", "```py\nexample  {Z  :  Type*}  (f  :  X  â†’  Y)  (T_X  :  TopologicalSpace  X)  (T_Z  :  TopologicalSpace  Z)\n  (g  :  Y  â†’  Z)  :\n  @Continuous  Y  Z  (TopologicalSpace.coinduced  f  T_X)  T_Z  g  â†”\n  @Continuous  X  Z  T_X  T_Z  (g  âˆ˜  f)  :=  by\n  rw  [continuous_iff_coinduced_le,  coinduced_compose,  continuous_iff_coinduced_le] \n```", "```py\nexample  (Î¹  :  Type*)  (X  :  Î¹  â†’  Type*)  (T_X  :  âˆ€  i,  TopologicalSpace  (X  i))  :\n  (Pi.topologicalSpace  :  TopologicalSpace  (âˆ€  i,  X  i))  =\n  â¨…  i,  TopologicalSpace.induced  (fun  x  â†¦  x  i)  (T_X  i)  :=\n  rfl \n```", "```py\nexample  [TopologicalSpace  X]  [T2Space  X]  {u  :  â„•  â†’  X}  {a  b  :  X}  (ha  :  Tendsto  u  atTop  (ğ“  a))\n  (hb  :  Tendsto  u  atTop  (ğ“  b))  :  a  =  b  :=\n  tendsto_nhds_unique  ha  hb\n\nexample  [TopologicalSpace  X]  [RegularSpace  X]  (a  :  X)  :\n  (ğ“  a).HasBasis  (fun  s  :  Set  X  â†¦  s  âˆˆ  ğ“  a  âˆ§  IsClosed  s)  id  :=\n  closed_nhds_basis  a \n```", "```py\nexample  [TopologicalSpace  X]  {x  :  X}  :\n  (ğ“  x).HasBasis  (fun  t  :  Set  X  â†¦  t  âˆˆ  ğ“  x  âˆ§  IsOpen  t)  id  :=\n  nhds_basis_opens'  x \n```", "```py\ntheorem  aux  {X  Y  A  :  Type*}  [TopologicalSpace  X]  {c  :  A  â†’  X}\n  {f  :  A  â†’  Y}  {x  :  X}  {F  :  Filter  Y}\n  (h  :  Tendsto  f  (comap  c  (ğ“  x))  F)  {V'  :  Set  Y}  (V'_in  :  V'  âˆˆ  F)  :\n  âˆƒ  V  âˆˆ  ğ“  x,  IsOpen  V  âˆ§  c  â»Â¹'  V  âŠ†  f  â»Â¹'  V'  :=  by\n  sorry \n```", "```py\nexample  [TopologicalSpace  X]  [TopologicalSpace  Y]  [T3Space  Y]  {A  :  Set  X}\n  (hA  :  âˆ€  x,  x  âˆˆ  closure  A)  {f  :  A  â†’  Y}  (f_cont  :  Continuous  f)\n  (hf  :  âˆ€  x  :  X,  âˆƒ  c  :  Y,  Tendsto  f  (comap  (â†‘)  (ğ“  x))  (ğ“  c))  :\n  âˆƒ  Ï†  :  X  â†’  Y,  Continuous  Ï†  âˆ§  âˆ€  a  :  A,  Ï†  a  =  f  a  :=  by\n  sorry\n\n#check  HasBasis.tendsto_right_iff \n```", "```py\nexample  [TopologicalSpace  X]  [FirstCountableTopology  X]\n  {s  :  Set  X}  {a  :  X}  :\n  a  âˆˆ  closure  s  â†”  âˆƒ  u  :  â„•  â†’  X,  (âˆ€  n,  u  n  âˆˆ  s)  âˆ§  Tendsto  u  atTop  (ğ“  a)  :=\n  mem_closure_iff_seq_limit \n```", "```py\nvariable  [TopologicalSpace  X]\n\nexample  {F  :  Filter  X}  {x  :  X}  :  ClusterPt  x  F  â†”  NeBot  (ğ“  x  âŠ“  F)  :=\n  Iff.rfl\n\nexample  {s  :  Set  X}  :\n  IsCompact  s  â†”  âˆ€  (F  :  Filter  X)  [NeBot  F],  F  â‰¤  ğ“Ÿ  s  â†’  âˆƒ  a  âˆˆ  s,  ClusterPt  a  F  :=\n  Iff.rfl \n```", "```py\nexample  [FirstCountableTopology  X]  {s  :  Set  X}  {u  :  â„•  â†’  X}  (hs  :  IsCompact  s)\n  (hu  :  âˆ€  n,  u  n  âˆˆ  s)  :  âˆƒ  a  âˆˆ  s,  âˆƒ  Ï†  :  â„•  â†’  â„•,  StrictMono  Ï†  âˆ§  Tendsto  (u  âˆ˜  Ï†)  atTop  (ğ“  a)  :=\n  hs.tendsto_subseq  hu \n```", "```py\nvariable  [TopologicalSpace  Y]\n\nexample  {x  :  X}  {F  :  Filter  X}  {G  :  Filter  Y}  (H  :  ClusterPt  x  F)  {f  :  X  â†’  Y}\n  (hfx  :  ContinuousAt  f  x)  (hf  :  Tendsto  f  F  G)  :  ClusterPt  (f  x)  G  :=\n  ClusterPt.map  H  hfx  hf \n```", "```py\nexample  [TopologicalSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  {s  :  Set  X}  (hs  :  IsCompact  s)  :\n  IsCompact  (f  ''  s)  :=  by\n  intro  F  F_ne  F_le\n  have  map_eq  :  map  f  (ğ“Ÿ  s  âŠ“  comap  f  F)  =  ğ“Ÿ  (f  ''  s)  âŠ“  F  :=  by  sorry\n  have  Hne  :  (ğ“Ÿ  s  âŠ“  comap  f  F).NeBot  :=  by  sorry\n  have  Hle  :  ğ“Ÿ  s  âŠ“  comap  f  F  â‰¤  ğ“Ÿ  s  :=  inf_le_left\n  sorry \n```", "```py\nexample  {Î¹  :  Type*}  {s  :  Set  X}  (hs  :  IsCompact  s)  (U  :  Î¹  â†’  Set  X)  (hUo  :  âˆ€  i,  IsOpen  (U  i))\n  (hsU  :  s  âŠ†  â‹ƒ  i,  U  i)  :  âˆƒ  t  :  Finset  Î¹,  s  âŠ†  â‹ƒ  i  âˆˆ  t,  U  i  :=\n  hs.elim_finite_subcover  U  hUo  hsU \n```", "```py\ndef  principal  {Î±  :  Type*}  (s  :  Set  Î±)  :  Filter  Î±\n  where\n  sets  :=  {  t  |  s  âŠ†  t  }\n  univ_sets  :=  sorry\n  sets_of_superset  :=  sorry\n  inter_sets  :=  sorry \n```", "```py\nexample  :  Filter  â„•  :=\n  {  sets  :=  {  s  |  âˆƒ  a,  âˆ€  b,  a  â‰¤  b  â†’  b  âˆˆ  s  }\n  univ_sets  :=  sorry\n  sets_of_superset  :=  sorry\n  inter_sets  :=  sorry  } \n```", "```py\ndef  Tendstoâ‚  {X  Y  :  Type*}  (f  :  X  â†’  Y)  (F  :  Filter  X)  (G  :  Filter  Y)  :=\n  âˆ€  V  âˆˆ  G,  f  â»Â¹'  V  âˆˆ  F \n```", "```py\ndef  Tendstoâ‚‚  {X  Y  :  Type*}  (f  :  X  â†’  Y)  (F  :  Filter  X)  (G  :  Filter  Y)  :=\n  map  f  F  â‰¤  G\n\nexample  {X  Y  :  Type*}  (f  :  X  â†’  Y)  (F  :  Filter  X)  (G  :  Filter  Y)  :\n  Tendstoâ‚‚  f  F  G  â†”  Tendstoâ‚  f  F  G  :=\n  Iff.rfl \n```", "```py\n#check  (@Filter.map_mono  :  âˆ€  {Î±  Î²}  {m  :  Î±  â†’  Î²},  Monotone  (map  m))\n\n#check\n  (@Filter.map_map  :\n  âˆ€  {Î±  Î²  Î³}  {f  :  Filter  Î±}  {m  :  Î±  â†’  Î²}  {m'  :  Î²  â†’  Î³},  map  m'  (map  m  f)  =  map  (m'  âˆ˜  m)  f) \n```", "```py\nexample  {X  Y  Z  :  Type*}  {F  :  Filter  X}  {G  :  Filter  Y}  {H  :  Filter  Z}  {f  :  X  â†’  Y}  {g  :  Y  â†’  Z}\n  (hf  :  Tendstoâ‚  f  F  G)  (hg  :  Tendstoâ‚  g  G  H)  :  Tendstoâ‚  (g  âˆ˜  f)  F  H  :=\n  sorry \n```", "```py\nvariable  (f  :  â„  â†’  â„)  (xâ‚€  yâ‚€  :  â„)\n\n#check  comap  ((â†‘)  :  â„š  â†’  â„)  (ğ“  xâ‚€)\n\n#check  Tendsto  (f  âˆ˜  (â†‘))  (comap  ((â†‘)  :  â„š  â†’  â„)  (ğ“  xâ‚€))  (ğ“  yâ‚€) \n```", "```py\nsection\nvariable  {Î±  Î²  Î³  :  Type*}  (F  :  Filter  Î±)  {m  :  Î³  â†’  Î²}  {n  :  Î²  â†’  Î±}\n\n#check  (comap_comap  :  comap  m  (comap  n  F)  =  comap  (n  âˆ˜  m)  F)\n\nend \n```", "```py\nexample  :  ğ“  (xâ‚€,  yâ‚€)  =  ğ“  xâ‚€  Ã—Ë¢  ğ“  yâ‚€  :=\n  nhds_prod_eq \n```", "```py\n#check  le_inf_iff\n\nexample  (f  :  â„•  â†’  â„  Ã—  â„)  (xâ‚€  yâ‚€  :  â„)  :\n  Tendsto  f  atTop  (ğ“  (xâ‚€,  yâ‚€))  â†”\n  Tendsto  (Prod.fst  âˆ˜  f)  atTop  (ğ“  xâ‚€)  âˆ§  Tendsto  (Prod.snd  âˆ˜  f)  atTop  (ğ“  yâ‚€)  :=\n  sorry \n```", "```py\nexample  (xâ‚€  :  â„)  :  HasBasis  (ğ“  xâ‚€)  (fun  Îµ  :  â„  â†¦  0  <  Îµ)  fun  Îµ  â†¦  Ioo  (xâ‚€  -  Îµ)  (xâ‚€  +  Îµ)  :=\n  nhds_basis_Ioo_pos  xâ‚€ \n```", "```py\nexample  (u  :  â„•  â†’  â„)  (xâ‚€  :  â„)  :\n  Tendsto  u  atTop  (ğ“  xâ‚€)  â†”  âˆ€  Îµ  >  0,  âˆƒ  N,  âˆ€  n  â‰¥  N,  u  n  âˆˆ  Ioo  (xâ‚€  -  Îµ)  (xâ‚€  +  Îµ)  :=  by\n  have  :  atTop.HasBasis  (fun  _  :  â„•  â†¦  True)  Ici  :=  atTop_basis\n  rw  [this.tendsto_iff  (nhds_basis_Ioo_pos  xâ‚€)]\n  simp \n```", "```py\nexample  (P  Q  :  â„•  â†’  Prop)  (hP  :  âˆ€á¶   n  in  atTop,  P  n)  (hQ  :  âˆ€á¶   n  in  atTop,  Q  n)  :\n  âˆ€á¶   n  in  atTop,  P  n  âˆ§  Q  n  :=\n  hP.and  hQ \n```", "```py\nexample  (u  v  :  â„•  â†’  â„)  (h  :  âˆ€á¶   n  in  atTop,  u  n  =  v  n)  (xâ‚€  :  â„)  :\n  Tendsto  u  atTop  (ğ“  xâ‚€)  â†”  Tendsto  v  atTop  (ğ“  xâ‚€)  :=\n  tendsto_congr'  h\n\nexample  (u  v  :  â„•  â†’  â„)  (h  :  u  =á¶ [atTop]  v)  (xâ‚€  :  â„)  :\n  Tendsto  u  atTop  (ğ“  xâ‚€)  â†”  Tendsto  v  atTop  (ğ“  xâ‚€)  :=\n  tendsto_congr'  h \n```", "```py\n#check  Eventually.of_forall\n#check  Eventually.mono\n#check  Eventually.and \n```", "```py\nexample  (P  Q  R  :  â„•  â†’  Prop)  (hP  :  âˆ€á¶   n  in  atTop,  P  n)  (hQ  :  âˆ€á¶   n  in  atTop,  Q  n)\n  (hR  :  âˆ€á¶   n  in  atTop,  P  n  âˆ§  Q  n  â†’  R  n)  :  âˆ€á¶   n  in  atTop,  R  n  :=  by\n  apply  (hP.and  (hQ.and  hR)).mono\n  rintro  n  âŸ¨h,  h',  h''âŸ©\n  exact  h''  âŸ¨h,  h'âŸ©\n\nexample  (P  Q  R  :  â„•  â†’  Prop)  (hP  :  âˆ€á¶   n  in  atTop,  P  n)  (hQ  :  âˆ€á¶   n  in  atTop,  Q  n)\n  (hR  :  âˆ€á¶   n  in  atTop,  P  n  âˆ§  Q  n  â†’  R  n)  :  âˆ€á¶   n  in  atTop,  R  n  :=  by\n  filter_upwards  [hP,  hQ,  hR]  with  n  h  h'  h''\n  exact  h''  âŸ¨h,  h'âŸ© \n```", "```py\n#check  mem_closure_iff_clusterPt\n#check  le_principal_iff\n#check  neBot_of_le\n\nexample  (u  :  â„•  â†’  â„)  (M  :  Set  â„)  (x  :  â„)  (hux  :  Tendsto  u  atTop  (ğ“  x))\n  (huM  :  âˆ€á¶   n  in  atTop,  u  n  âˆˆ  M)  :  x  âˆˆ  closure  M  :=\n  sorry \n```", "```py\nvariable  {X  :  Type*}  [MetricSpace  X]  (a  b  c  :  X)\n\n#check  (dist  a  b  :  â„)\n#check  (dist_nonneg  :  0  â‰¤  dist  a  b)\n#check  (dist_eq_zero  :  dist  a  b  =  0  â†”  a  =  b)\n#check  (dist_comm  a  b  :  dist  a  b  =  dist  b  a)\n#check  (dist_triangle  a  b  c  :  dist  a  c  â‰¤  dist  a  b  +  dist  b  c) \n```", "```py\nexample  {u  :  â„•  â†’  X}  {a  :  X}  :\n  Tendsto  u  atTop  (ğ“  a)  â†”  âˆ€  Îµ  >  0,  âˆƒ  N,  âˆ€  n  â‰¥  N,  dist  (u  n)  a  <  Îµ  :=\n  Metric.tendsto_atTop\n\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  :\n  Continuous  f  â†”\n  âˆ€  x  :  X,  âˆ€  Îµ  >  0,  âˆƒ  Î´  >  0,  âˆ€  x',  dist  x'  x  <  Î´  â†’  dist  (f  x')  (f  x)  <  Îµ  :=\n  Metric.continuous_iff \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=  by  continuity \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=\n  continuous_dist.comp  ((hf.comp  continuous_fst).prodMk  (hf.comp  continuous_snd)) \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=  by\n  apply  Continuous.dist\n  exact  hf.comp  continuous_fst\n  exact  hf.comp  continuous_snd\n\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=\n  (hf.comp  continuous_fst).dist  (hf.comp  continuous_snd) \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=\n  hf.fst'.dist  hf.snd' \n```", "```py\nexample  {f  :  â„  â†’  X}  (hf  :  Continuous  f)  :  Continuous  fun  x  :  â„  â†¦  f  (x  ^  2  +  x)  :=\n  sorry \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  (f  :  X  â†’  Y)  (a  :  X)  :\n  ContinuousAt  f  a  â†”  âˆ€  Îµ  >  0,  âˆƒ  Î´  >  0,  âˆ€  {x},  dist  x  a  <  Î´  â†’  dist  (f  x)  (f  a)  <  Îµ  :=\n  Metric.continuousAt_iff \n```", "```py\nvariable  (r  :  â„)\n\nexample  :  Metric.ball  a  r  =  {  b  |  dist  b  a  <  r  }  :=\n  rfl\n\nexample  :  Metric.closedBall  a  r  =  {  b  |  dist  b  a  â‰¤  r  }  :=\n  rfl \n```", "```py\nexample  (hr  :  0  <  r)  :  a  âˆˆ  Metric.ball  a  r  :=\n  Metric.mem_ball_self  hr\n\nexample  (hr  :  0  â‰¤  r)  :  a  âˆˆ  Metric.closedBall  a  r  :=\n  Metric.mem_closedBall_self  hr \n```", "```py\nexample  (s  :  Set  X)  :  IsOpen  s  â†”  âˆ€  x  âˆˆ  s,  âˆƒ  Îµ  >  0,  Metric.ball  x  Îµ  âŠ†  s  :=\n  Metric.isOpen_iff \n```", "```py\nexample  {s  :  Set  X}  :  IsClosed  s  â†”  IsOpen  (sá¶œ)  :=\n  isOpen_compl_iff.symm\n\nexample  {s  :  Set  X}  (hs  :  IsClosed  s)  {u  :  â„•  â†’  X}  (hu  :  Tendsto  u  atTop  (ğ“  a))\n  (hus  :  âˆ€  n,  u  n  âˆˆ  s)  :  a  âˆˆ  s  :=\n  hs.mem_of_tendsto  hu  (Eventually.of_forall  hus)\n\nexample  {s  :  Set  X}  :  a  âˆˆ  closure  s  â†”  âˆ€  Îµ  >  0,  âˆƒ  b  âˆˆ  s,  a  âˆˆ  Metric.ball  b  Îµ  :=\n  Metric.mem_closure_iff \n```", "```py\nexample  {u  :  â„•  â†’  X}  (hu  :  Tendsto  u  atTop  (ğ“  a))  {s  :  Set  X}  (hs  :  âˆ€  n,  u  n  âˆˆ  s)  :\n  a  âˆˆ  closure  s  :=  by\n  sorry \n```", "```py\nexample  {x  :  X}  {s  :  Set  X}  :  s  âˆˆ  ğ“  x  â†”  âˆƒ  Îµ  >  0,  Metric.ball  x  Îµ  âŠ†  s  :=\n  Metric.nhds_basis_ball.mem_iff\n\nexample  {x  :  X}  {s  :  Set  X}  :  s  âˆˆ  ğ“  x  â†”  âˆƒ  Îµ  >  0,  Metric.closedBall  x  Îµ  âŠ†  s  :=\n  Metric.nhds_basis_closedBall.mem_iff \n```", "```py\nexample  :  IsCompact  (Set.Icc  0  1  :  Set  â„)  :=\n  isCompact_Icc\n\nexample  {s  :  Set  X}  (hs  :  IsCompact  s)  {u  :  â„•  â†’  X}  (hu  :  âˆ€  n,  u  n  âˆˆ  s)  :\n  âˆƒ  a  âˆˆ  s,  âˆƒ  Ï†  :  â„•  â†’  â„•,  StrictMono  Ï†  âˆ§  Tendsto  (u  âˆ˜  Ï†)  atTop  (ğ“  a)  :=\n  hs.tendsto_subseq  hu\n\nexample  {s  :  Set  X}  (hs  :  IsCompact  s)  (hs'  :  s.Nonempty)  {f  :  X  â†’  â„}\n  (hfs  :  ContinuousOn  f  s)  :\n  âˆƒ  x  âˆˆ  s,  âˆ€  y  âˆˆ  s,  f  x  â‰¤  f  y  :=\n  hs.exists_isMinOn  hs'  hfs\n\nexample  {s  :  Set  X}  (hs  :  IsCompact  s)  (hs'  :  s.Nonempty)  {f  :  X  â†’  â„}\n  (hfs  :  ContinuousOn  f  s)  :\n  âˆƒ  x  âˆˆ  s,  âˆ€  y  âˆˆ  s,  f  y  â‰¤  f  x  :=\n  hs.exists_isMaxOn  hs'  hfs\n\nexample  {s  :  Set  X}  (hs  :  IsCompact  s)  :  IsClosed  s  :=\n  hs.isClosed \n```", "```py\nexample  {X  :  Type*}  [MetricSpace  X]  [CompactSpace  X]  :  IsCompact  (univ  :  Set  X)  :=\n  isCompact_univ \n```", "```py\nexample  {X  :  Type*}  [MetricSpace  X]  {Y  :  Type*}  [MetricSpace  Y]  {f  :  X  â†’  Y}  :\n  UniformContinuous  f  â†”\n  âˆ€  Îµ  >  0,  âˆƒ  Î´  >  0,  âˆ€  {a  b  :  X},  dist  a  b  <  Î´  â†’  dist  (f  a)  (f  b)  <  Îµ  :=\n  Metric.uniformContinuous_iff \n```", "```py\nexample  {X  :  Type*}  [MetricSpace  X]  [CompactSpace  X]\n  {Y  :  Type*}  [MetricSpace  Y]  {f  :  X  â†’  Y}\n  (hf  :  Continuous  f)  :  UniformContinuous  f  :=  by\n  sorry \n```", "```py\nexample  (u  :  â„•  â†’  X)  :\n  CauchySeq  u  â†”  âˆ€  Îµ  >  0,  âˆƒ  N  :  â„•,  âˆ€  m  â‰¥  N,  âˆ€  n  â‰¥  N,  dist  (u  m)  (u  n)  <  Îµ  :=\n  Metric.cauchySeq_iff\n\nexample  (u  :  â„•  â†’  X)  :\n  CauchySeq  u  â†”  âˆ€  Îµ  >  0,  âˆƒ  N  :  â„•,  âˆ€  n  â‰¥  N,  dist  (u  n)  (u  N)  <  Îµ  :=\n  Metric.cauchySeq_iff'\n\nexample  [CompleteSpace  X]  (u  :  â„•  â†’  X)  (hu  :  CauchySeq  u)  :\n  âˆƒ  x,  Tendsto  u  atTop  (ğ“  x)  :=\n  cauchySeq_tendsto_of_complete  hu \n```", "```py\ntheorem  cauchySeq_of_le_geometric_two'  {u  :  â„•  â†’  X}\n  (hu  :  âˆ€  n  :  â„•,  dist  (u  n)  (u  (n  +  1))  â‰¤  (1  /  2)  ^  n)  :  CauchySeq  u  :=  by\n  rw  [Metric.cauchySeq_iff']\n  intro  Îµ  Îµ_pos\n  obtain  âŸ¨N,  hNâŸ©  :  âˆƒ  N  :  â„•,  1  /  2  ^  N  *  2  <  Îµ  :=  by  sorry\n  use  N\n  intro  n  hn\n  obtain  âŸ¨k,  rfl  :  n  =  N  +  kâŸ©  :=  le_iff_exists_add.mp  hn\n  calc\n  dist  (u  (N  +  k))  (u  N)  =  dist  (u  (N  +  0))  (u  (N  +  k))  :=  sorry\n  _  â‰¤  âˆ‘  i  âˆˆ  range  k,  dist  (u  (N  +  i))  (u  (N  +  (i  +  1)))  :=  sorry\n  _  â‰¤  âˆ‘  i  âˆˆ  range  k,  (1  /  2  :  â„)  ^  (N  +  i)  :=  sorry\n  _  =  1  /  2  ^  N  *  âˆ‘  i  âˆˆ  range  k,  (1  /  2  :  â„)  ^  i  :=  sorry\n  _  â‰¤  1  /  2  ^  N  *  2  :=  sorry\n  _  <  Îµ  :=  sorry \n```", "```py\nopen  Metric\n\nexample  [CompleteSpace  X]  (f  :  â„•  â†’  Set  X)  (ho  :  âˆ€  n,  IsOpen  (f  n))  (hd  :  âˆ€  n,  Dense  (f  n))  :\n  Dense  (â‹‚  n,  f  n)  :=  by\n  let  B  :  â„•  â†’  â„  :=  fun  n  â†¦  (1  /  2)  ^  n\n  have  Bpos  :  âˆ€  n,  0  <  B  n\n  sorry\n  /- Translate the density assumption into two functions `center` and `radius` associating\n to any n, x, Î´, Î´pos a center and a positive radius such that\n `closedBall center radius` is included both in `f n` and in `closedBall x Î´`.\n We can also require `radius â‰¤ (1/2)^(n+1)`, to ensure we get a Cauchy sequence later. -/\n  have  :\n  âˆ€  (n  :  â„•)  (x  :  X),\n  âˆ€  Î´  >  0,  âˆƒ  y  :  X,  âˆƒ  r  >  0,  r  â‰¤  B  (n  +  1)  âˆ§  closedBall  y  r  âŠ†  closedBall  x  Î´  âˆ©  f  n  :=\n  by  sorry\n  choose!  center  radius  Hpos  HB  Hball  using  this\n  intro  x\n  rw  [mem_closure_iff_nhds_basis  nhds_basis_closedBall]\n  intro  Îµ  Îµpos\n  /- `Îµ` is positive. We have to find a point in the ball of radius `Îµ` around `x`\n belonging to all `f n`. For this, we construct inductively a sequence\n `F n = (c n, r n)` such that the closed ball `closedBall (c n) (r n)` is included\n in the previous ball and in `f n`, and such that `r n` is small enough to ensure\n that `c n` is a Cauchy sequence. Then `c n` converges to a limit which belongs\n to all the `f n`. -/\n  let  F  :  â„•  â†’  X  Ã—  â„  :=  fun  n  â†¦\n  Nat.recOn  n  (Prod.mk  x  (min  Îµ  (B  0)))\n  fun  n  p  â†¦  Prod.mk  (center  n  p.1  p.2)  (radius  n  p.1  p.2)\n  let  c  :  â„•  â†’  X  :=  fun  n  â†¦  (F  n).1\n  let  r  :  â„•  â†’  â„  :=  fun  n  â†¦  (F  n).2\n  have  rpos  :  âˆ€  n,  0  <  r  n  :=  by  sorry\n  have  rB  :  âˆ€  n,  r  n  â‰¤  B  n  :=  by  sorry\n  have  incl  :  âˆ€  n,  closedBall  (c  (n  +  1))  (r  (n  +  1))  âŠ†  closedBall  (c  n)  (r  n)  âˆ©  f  n  :=  by\n  sorry\n  have  cdist  :  âˆ€  n,  dist  (c  n)  (c  (n  +  1))  â‰¤  B  n  :=  by  sorry\n  have  :  CauchySeq  c  :=  cauchySeq_of_le_geometric_two'  cdist\n  -- as the sequence `c n` is Cauchy in a complete space, it converges to a limit `y`.\n  rcases  cauchySeq_tendsto_of_complete  this  with  âŸ¨y,  ylimâŸ©\n  -- this point `y` will be the desired point. We will check that it belongs to all\n  -- `f n` and to `ball x Îµ`.\n  use  y\n  have  I  :  âˆ€  n,  âˆ€  m  â‰¥  n,  closedBall  (c  m)  (r  m)  âŠ†  closedBall  (c  n)  (r  n)  :=  by  sorry\n  have  yball  :  âˆ€  n,  y  âˆˆ  closedBall  (c  n)  (r  n)  :=  by  sorry\n  sorry \n```", "```py\nexample  {u  :  â„•  â†’  X}  {a  :  X}  :\n  Tendsto  u  atTop  (ğ“  a)  â†”  âˆ€  Îµ  >  0,  âˆƒ  N,  âˆ€  n  â‰¥  N,  dist  (u  n)  a  <  Îµ  :=\n  Metric.tendsto_atTop\n\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  :\n  Continuous  f  â†”\n  âˆ€  x  :  X,  âˆ€  Îµ  >  0,  âˆƒ  Î´  >  0,  âˆ€  x',  dist  x'  x  <  Î´  â†’  dist  (f  x')  (f  x)  <  Îµ  :=\n  Metric.continuous_iff \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=  by  continuity \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=\n  continuous_dist.comp  ((hf.comp  continuous_fst).prodMk  (hf.comp  continuous_snd)) \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=  by\n  apply  Continuous.dist\n  exact  hf.comp  continuous_fst\n  exact  hf.comp  continuous_snd\n\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=\n  (hf.comp  continuous_fst).dist  (hf.comp  continuous_snd) \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  :\n  Continuous  fun  p  :  X  Ã—  X  â†¦  dist  (f  p.1)  (f  p.2)  :=\n  hf.fst'.dist  hf.snd' \n```", "```py\nexample  {f  :  â„  â†’  X}  (hf  :  Continuous  f)  :  Continuous  fun  x  :  â„  â†¦  f  (x  ^  2  +  x)  :=\n  sorry \n```", "```py\nexample  {X  Y  :  Type*}  [MetricSpace  X]  [MetricSpace  Y]  (f  :  X  â†’  Y)  (a  :  X)  :\n  ContinuousAt  f  a  â†”  âˆ€  Îµ  >  0,  âˆƒ  Î´  >  0,  âˆ€  {x},  dist  x  a  <  Î´  â†’  dist  (f  x)  (f  a)  <  Îµ  :=\n  Metric.continuousAt_iff \n```", "```py\nvariable  (r  :  â„)\n\nexample  :  Metric.ball  a  r  =  {  b  |  dist  b  a  <  r  }  :=\n  rfl\n\nexample  :  Metric.closedBall  a  r  =  {  b  |  dist  b  a  â‰¤  r  }  :=\n  rfl \n```", "```py\nexample  (hr  :  0  <  r)  :  a  âˆˆ  Metric.ball  a  r  :=\n  Metric.mem_ball_self  hr\n\nexample  (hr  :  0  â‰¤  r)  :  a  âˆˆ  Metric.closedBall  a  r  :=\n  Metric.mem_closedBall_self  hr \n```", "```py\nexample  (s  :  Set  X)  :  IsOpen  s  â†”  âˆ€  x  âˆˆ  s,  âˆƒ  Îµ  >  0,  Metric.ball  x  Îµ  âŠ†  s  :=\n  Metric.isOpen_iff \n```", "```py\nexample  {s  :  Set  X}  :  IsClosed  s  â†”  IsOpen  (sá¶œ)  :=\n  isOpen_compl_iff.symm\n\nexample  {s  :  Set  X}  (hs  :  IsClosed  s)  {u  :  â„•  â†’  X}  (hu  :  Tendsto  u  atTop  (ğ“  a))\n  (hus  :  âˆ€  n,  u  n  âˆˆ  s)  :  a  âˆˆ  s  :=\n  hs.mem_of_tendsto  hu  (Eventually.of_forall  hus)\n\nexample  {s  :  Set  X}  :  a  âˆˆ  closure  s  â†”  âˆ€  Îµ  >  0,  âˆƒ  b  âˆˆ  s,  a  âˆˆ  Metric.ball  b  Îµ  :=\n  Metric.mem_closure_iff \n```", "```py\nexample  {u  :  â„•  â†’  X}  (hu  :  Tendsto  u  atTop  (ğ“  a))  {s  :  Set  X}  (hs  :  âˆ€  n,  u  n  âˆˆ  s)  :\n  a  âˆˆ  closure  s  :=  by\n  sorry \n```", "```py\nexample  {x  :  X}  {s  :  Set  X}  :  s  âˆˆ  ğ“  x  â†”  âˆƒ  Îµ  >  0,  Metric.ball  x  Îµ  âŠ†  s  :=\n  Metric.nhds_basis_ball.mem_iff\n\nexample  {x  :  X}  {s  :  Set  X}  :  s  âˆˆ  ğ“  x  â†”  âˆƒ  Îµ  >  0,  Metric.closedBall  x  Îµ  âŠ†  s  :=\n  Metric.nhds_basis_closedBall.mem_iff \n```", "```py\nexample  :  IsCompact  (Set.Icc  0  1  :  Set  â„)  :=\n  isCompact_Icc\n\nexample  {s  :  Set  X}  (hs  :  IsCompact  s)  {u  :  â„•  â†’  X}  (hu  :  âˆ€  n,  u  n  âˆˆ  s)  :\n  âˆƒ  a  âˆˆ  s,  âˆƒ  Ï†  :  â„•  â†’  â„•,  StrictMono  Ï†  âˆ§  Tendsto  (u  âˆ˜  Ï†)  atTop  (ğ“  a)  :=\n  hs.tendsto_subseq  hu\n\nexample  {s  :  Set  X}  (hs  :  IsCompact  s)  (hs'  :  s.Nonempty)  {f  :  X  â†’  â„}\n  (hfs  :  ContinuousOn  f  s)  :\n  âˆƒ  x  âˆˆ  s,  âˆ€  y  âˆˆ  s,  f  x  â‰¤  f  y  :=\n  hs.exists_isMinOn  hs'  hfs\n\nexample  {s  :  Set  X}  (hs  :  IsCompact  s)  (hs'  :  s.Nonempty)  {f  :  X  â†’  â„}\n  (hfs  :  ContinuousOn  f  s)  :\n  âˆƒ  x  âˆˆ  s,  âˆ€  y  âˆˆ  s,  f  y  â‰¤  f  x  :=\n  hs.exists_isMaxOn  hs'  hfs\n\nexample  {s  :  Set  X}  (hs  :  IsCompact  s)  :  IsClosed  s  :=\n  hs.isClosed \n```", "```py\nexample  {X  :  Type*}  [MetricSpace  X]  [CompactSpace  X]  :  IsCompact  (univ  :  Set  X)  :=\n  isCompact_univ \n```", "```py\nexample  {X  :  Type*}  [MetricSpace  X]  {Y  :  Type*}  [MetricSpace  Y]  {f  :  X  â†’  Y}  :\n  UniformContinuous  f  â†”\n  âˆ€  Îµ  >  0,  âˆƒ  Î´  >  0,  âˆ€  {a  b  :  X},  dist  a  b  <  Î´  â†’  dist  (f  a)  (f  b)  <  Îµ  :=\n  Metric.uniformContinuous_iff \n```", "```py\nexample  {X  :  Type*}  [MetricSpace  X]  [CompactSpace  X]\n  {Y  :  Type*}  [MetricSpace  Y]  {f  :  X  â†’  Y}\n  (hf  :  Continuous  f)  :  UniformContinuous  f  :=  by\n  sorry \n```", "```py\nexample  (u  :  â„•  â†’  X)  :\n  CauchySeq  u  â†”  âˆ€  Îµ  >  0,  âˆƒ  N  :  â„•,  âˆ€  m  â‰¥  N,  âˆ€  n  â‰¥  N,  dist  (u  m)  (u  n)  <  Îµ  :=\n  Metric.cauchySeq_iff\n\nexample  (u  :  â„•  â†’  X)  :\n  CauchySeq  u  â†”  âˆ€  Îµ  >  0,  âˆƒ  N  :  â„•,  âˆ€  n  â‰¥  N,  dist  (u  n)  (u  N)  <  Îµ  :=\n  Metric.cauchySeq_iff'\n\nexample  [CompleteSpace  X]  (u  :  â„•  â†’  X)  (hu  :  CauchySeq  u)  :\n  âˆƒ  x,  Tendsto  u  atTop  (ğ“  x)  :=\n  cauchySeq_tendsto_of_complete  hu \n```", "```py\ntheorem  cauchySeq_of_le_geometric_two'  {u  :  â„•  â†’  X}\n  (hu  :  âˆ€  n  :  â„•,  dist  (u  n)  (u  (n  +  1))  â‰¤  (1  /  2)  ^  n)  :  CauchySeq  u  :=  by\n  rw  [Metric.cauchySeq_iff']\n  intro  Îµ  Îµ_pos\n  obtain  âŸ¨N,  hNâŸ©  :  âˆƒ  N  :  â„•,  1  /  2  ^  N  *  2  <  Îµ  :=  by  sorry\n  use  N\n  intro  n  hn\n  obtain  âŸ¨k,  rfl  :  n  =  N  +  kâŸ©  :=  le_iff_exists_add.mp  hn\n  calc\n  dist  (u  (N  +  k))  (u  N)  =  dist  (u  (N  +  0))  (u  (N  +  k))  :=  sorry\n  _  â‰¤  âˆ‘  i  âˆˆ  range  k,  dist  (u  (N  +  i))  (u  (N  +  (i  +  1)))  :=  sorry\n  _  â‰¤  âˆ‘  i  âˆˆ  range  k,  (1  /  2  :  â„)  ^  (N  +  i)  :=  sorry\n  _  =  1  /  2  ^  N  *  âˆ‘  i  âˆˆ  range  k,  (1  /  2  :  â„)  ^  i  :=  sorry\n  _  â‰¤  1  /  2  ^  N  *  2  :=  sorry\n  _  <  Îµ  :=  sorry \n```", "```py\nopen  Metric\n\nexample  [CompleteSpace  X]  (f  :  â„•  â†’  Set  X)  (ho  :  âˆ€  n,  IsOpen  (f  n))  (hd  :  âˆ€  n,  Dense  (f  n))  :\n  Dense  (â‹‚  n,  f  n)  :=  by\n  let  B  :  â„•  â†’  â„  :=  fun  n  â†¦  (1  /  2)  ^  n\n  have  Bpos  :  âˆ€  n,  0  <  B  n\n  sorry\n  /- Translate the density assumption into two functions `center` and `radius` associating\n to any n, x, Î´, Î´pos a center and a positive radius such that\n `closedBall center radius` is included both in `f n` and in `closedBall x Î´`.\n We can also require `radius â‰¤ (1/2)^(n+1)`, to ensure we get a Cauchy sequence later. -/\n  have  :\n  âˆ€  (n  :  â„•)  (x  :  X),\n  âˆ€  Î´  >  0,  âˆƒ  y  :  X,  âˆƒ  r  >  0,  r  â‰¤  B  (n  +  1)  âˆ§  closedBall  y  r  âŠ†  closedBall  x  Î´  âˆ©  f  n  :=\n  by  sorry\n  choose!  center  radius  Hpos  HB  Hball  using  this\n  intro  x\n  rw  [mem_closure_iff_nhds_basis  nhds_basis_closedBall]\n  intro  Îµ  Îµpos\n  /- `Îµ` is positive. We have to find a point in the ball of radius `Îµ` around `x`\n belonging to all `f n`. For this, we construct inductively a sequence\n `F n = (c n, r n)` such that the closed ball `closedBall (c n) (r n)` is included\n in the previous ball and in `f n`, and such that `r n` is small enough to ensure\n that `c n` is a Cauchy sequence. Then `c n` converges to a limit which belongs\n to all the `f n`. -/\n  let  F  :  â„•  â†’  X  Ã—  â„  :=  fun  n  â†¦\n  Nat.recOn  n  (Prod.mk  x  (min  Îµ  (B  0)))\n  fun  n  p  â†¦  Prod.mk  (center  n  p.1  p.2)  (radius  n  p.1  p.2)\n  let  c  :  â„•  â†’  X  :=  fun  n  â†¦  (F  n).1\n  let  r  :  â„•  â†’  â„  :=  fun  n  â†¦  (F  n).2\n  have  rpos  :  âˆ€  n,  0  <  r  n  :=  by  sorry\n  have  rB  :  âˆ€  n,  r  n  â‰¤  B  n  :=  by  sorry\n  have  incl  :  âˆ€  n,  closedBall  (c  (n  +  1))  (r  (n  +  1))  âŠ†  closedBall  (c  n)  (r  n)  âˆ©  f  n  :=  by\n  sorry\n  have  cdist  :  âˆ€  n,  dist  (c  n)  (c  (n  +  1))  â‰¤  B  n  :=  by  sorry\n  have  :  CauchySeq  c  :=  cauchySeq_of_le_geometric_two'  cdist\n  -- as the sequence `c n` is Cauchy in a complete space, it converges to a limit `y`.\n  rcases  cauchySeq_tendsto_of_complete  this  with  âŸ¨y,  ylimâŸ©\n  -- this point `y` will be the desired point. We will check that it belongs to all\n  -- `f n` and to `ball x Îµ`.\n  use  y\n  have  I  :  âˆ€  n,  âˆ€  m  â‰¥  n,  closedBall  (c  m)  (r  m)  âŠ†  closedBall  (c  n)  (r  n)  :=  by  sorry\n  have  yball  :  âˆ€  n,  y  âˆˆ  closedBall  (c  n)  (r  n)  :=  by  sorry\n  sorry \n```", "```py\nsection\nvariable  {X  :  Type*}  [TopologicalSpace  X]\n\nexample  :  IsOpen  (univ  :  Set  X)  :=\n  isOpen_univ\n\nexample  :  IsOpen  (âˆ…  :  Set  X)  :=\n  isOpen_empty\n\nexample  {Î¹  :  Type*}  {s  :  Î¹  â†’  Set  X}  (hs  :  âˆ€  i,  IsOpen  (s  i))  :  IsOpen  (â‹ƒ  i,  s  i)  :=\n  isOpen_iUnion  hs\n\nexample  {Î¹  :  Type*}  [Fintype  Î¹]  {s  :  Î¹  â†’  Set  X}  (hs  :  âˆ€  i,  IsOpen  (s  i))  :\n  IsOpen  (â‹‚  i,  s  i)  :=\n  isOpen_iInter_of_finite  hs \n```", "```py\nvariable  {Y  :  Type*}  [TopologicalSpace  Y]\n\nexample  {f  :  X  â†’  Y}  :  Continuous  f  â†”  âˆ€  s,  IsOpen  s  â†’  IsOpen  (f  â»Â¹'  s)  :=\n  continuous_def \n```", "```py\nexample  {f  :  X  â†’  Y}  {x  :  X}  :  ContinuousAt  f  x  â†”  map  f  (ğ“  x)  â‰¤  ğ“  (f  x)  :=\n  Iff.rfl \n```", "```py\nexample  {f  :  X  â†’  Y}  {x  :  X}  :  ContinuousAt  f  x  â†”  âˆ€  U  âˆˆ  ğ“  (f  x),  âˆ€á¶   x  in  ğ“  x,  f  x  âˆˆ  U  :=\n  Iff.rfl \n```", "```py\nexample  {x  :  X}  {s  :  Set  X}  :  s  âˆˆ  ğ“  x  â†”  âˆƒ  t,  t  âŠ†  s  âˆ§  IsOpen  t  âˆ§  x  âˆˆ  t  :=\n  mem_nhds_iff \n```", "```py\nexample  (x  :  X)  :  pure  x  â‰¤  ğ“  x  :=\n  pure_le_nhds  x\n\nexample  (x  :  X)  (P  :  X  â†’  Prop)  (h  :  âˆ€á¶   y  in  ğ“  x,  P  y)  :  P  x  :=\n  h.self_of_nhds \n```", "```py\nexample  {P  :  X  â†’  Prop}  {x  :  X}  (h  :  âˆ€á¶   y  in  ğ“  x,  P  y)  :  âˆ€á¶   y  in  ğ“  x,  âˆ€á¶   z  in  ğ“  y,  P  z  :=\n  eventually_eventually_nhds.mpr  h \n```", "```py\nexample  {Î±  :  Type*}  (n  :  Î±  â†’  Filter  Î±)  (Hâ‚€  :  âˆ€  a,  pure  a  â‰¤  n  a)\n  (H  :  âˆ€  a  :  Î±,  âˆ€  p  :  Î±  â†’  Prop,  (âˆ€á¶   x  in  n  a,  p  x)  â†’  âˆ€á¶   y  in  n  a,  âˆ€á¶   x  in  n  y,  p  x)  :\n  âˆ€  a,  âˆ€  s  âˆˆ  n  a,  âˆƒ  t  âˆˆ  n  a,  t  âŠ†  s  âˆ§  âˆ€  a'  âˆˆ  t,  s  âˆˆ  n  a'  :=  by\n  sorry\nend \n```", "```py\nvariable  {X  Y  :  Type*}\n\nexample  (f  :  X  â†’  Y)  :  TopologicalSpace  X  â†’  TopologicalSpace  Y  :=\n  TopologicalSpace.coinduced  f\n\nexample  (f  :  X  â†’  Y)  :  TopologicalSpace  Y  â†’  TopologicalSpace  X  :=\n  TopologicalSpace.induced  f\n\nexample  (f  :  X  â†’  Y)  (T_X  :  TopologicalSpace  X)  (T_Y  :  TopologicalSpace  Y)  :\n  TopologicalSpace.coinduced  f  T_X  â‰¤  T_Y  â†”  T_X  â‰¤  TopologicalSpace.induced  f  T_Y  :=\n  coinduced_le_iff_le_induced \n```", "```py\nexample  {T  T'  :  TopologicalSpace  X}  :  T  â‰¤  T'  â†”  âˆ€  s,  T'.IsOpen  s  â†’  T.IsOpen  s  :=\n  Iff.rfl \n```", "```py\nexample  (T_X  :  TopologicalSpace  X)  (T_Y  :  TopologicalSpace  Y)  (f  :  X  â†’  Y)  :\n  Continuous  f  â†”  TopologicalSpace.coinduced  f  T_X  â‰¤  T_Y  :=\n  continuous_iff_coinduced_le \n```", "```py\nexample  {Z  :  Type*}  (f  :  X  â†’  Y)  (T_X  :  TopologicalSpace  X)  (T_Z  :  TopologicalSpace  Z)\n  (g  :  Y  â†’  Z)  :\n  @Continuous  Y  Z  (TopologicalSpace.coinduced  f  T_X)  T_Z  g  â†”\n  @Continuous  X  Z  T_X  T_Z  (g  âˆ˜  f)  :=  by\n  rw  [continuous_iff_coinduced_le,  coinduced_compose,  continuous_iff_coinduced_le] \n```", "```py\nexample  (Î¹  :  Type*)  (X  :  Î¹  â†’  Type*)  (T_X  :  âˆ€  i,  TopologicalSpace  (X  i))  :\n  (Pi.topologicalSpace  :  TopologicalSpace  (âˆ€  i,  X  i))  =\n  â¨…  i,  TopologicalSpace.induced  (fun  x  â†¦  x  i)  (T_X  i)  :=\n  rfl \n```", "```py\nexample  [TopologicalSpace  X]  [T2Space  X]  {u  :  â„•  â†’  X}  {a  b  :  X}  (ha  :  Tendsto  u  atTop  (ğ“  a))\n  (hb  :  Tendsto  u  atTop  (ğ“  b))  :  a  =  b  :=\n  tendsto_nhds_unique  ha  hb\n\nexample  [TopologicalSpace  X]  [RegularSpace  X]  (a  :  X)  :\n  (ğ“  a).HasBasis  (fun  s  :  Set  X  â†¦  s  âˆˆ  ğ“  a  âˆ§  IsClosed  s)  id  :=\n  closed_nhds_basis  a \n```", "```py\nexample  [TopologicalSpace  X]  {x  :  X}  :\n  (ğ“  x).HasBasis  (fun  t  :  Set  X  â†¦  t  âˆˆ  ğ“  x  âˆ§  IsOpen  t)  id  :=\n  nhds_basis_opens'  x \n```", "```py\ntheorem  aux  {X  Y  A  :  Type*}  [TopologicalSpace  X]  {c  :  A  â†’  X}\n  {f  :  A  â†’  Y}  {x  :  X}  {F  :  Filter  Y}\n  (h  :  Tendsto  f  (comap  c  (ğ“  x))  F)  {V'  :  Set  Y}  (V'_in  :  V'  âˆˆ  F)  :\n  âˆƒ  V  âˆˆ  ğ“  x,  IsOpen  V  âˆ§  c  â»Â¹'  V  âŠ†  f  â»Â¹'  V'  :=  by\n  sorry \n```", "```py\nexample  [TopologicalSpace  X]  [TopologicalSpace  Y]  [T3Space  Y]  {A  :  Set  X}\n  (hA  :  âˆ€  x,  x  âˆˆ  closure  A)  {f  :  A  â†’  Y}  (f_cont  :  Continuous  f)\n  (hf  :  âˆ€  x  :  X,  âˆƒ  c  :  Y,  Tendsto  f  (comap  (â†‘)  (ğ“  x))  (ğ“  c))  :\n  âˆƒ  Ï†  :  X  â†’  Y,  Continuous  Ï†  âˆ§  âˆ€  a  :  A,  Ï†  a  =  f  a  :=  by\n  sorry\n\n#check  HasBasis.tendsto_right_iff \n```", "```py\nexample  [TopologicalSpace  X]  [FirstCountableTopology  X]\n  {s  :  Set  X}  {a  :  X}  :\n  a  âˆˆ  closure  s  â†”  âˆƒ  u  :  â„•  â†’  X,  (âˆ€  n,  u  n  âˆˆ  s)  âˆ§  Tendsto  u  atTop  (ğ“  a)  :=\n  mem_closure_iff_seq_limit \n```", "```py\nvariable  [TopologicalSpace  X]\n\nexample  {F  :  Filter  X}  {x  :  X}  :  ClusterPt  x  F  â†”  NeBot  (ğ“  x  âŠ“  F)  :=\n  Iff.rfl\n\nexample  {s  :  Set  X}  :\n  IsCompact  s  â†”  âˆ€  (F  :  Filter  X)  [NeBot  F],  F  â‰¤  ğ“Ÿ  s  â†’  âˆƒ  a  âˆˆ  s,  ClusterPt  a  F  :=\n  Iff.rfl \n```", "```py\nexample  [FirstCountableTopology  X]  {s  :  Set  X}  {u  :  â„•  â†’  X}  (hs  :  IsCompact  s)\n  (hu  :  âˆ€  n,  u  n  âˆˆ  s)  :  âˆƒ  a  âˆˆ  s,  âˆƒ  Ï†  :  â„•  â†’  â„•,  StrictMono  Ï†  âˆ§  Tendsto  (u  âˆ˜  Ï†)  atTop  (ğ“  a)  :=\n  hs.tendsto_subseq  hu \n```", "```py\nvariable  [TopologicalSpace  Y]\n\nexample  {x  :  X}  {F  :  Filter  X}  {G  :  Filter  Y}  (H  :  ClusterPt  x  F)  {f  :  X  â†’  Y}\n  (hfx  :  ContinuousAt  f  x)  (hf  :  Tendsto  f  F  G)  :  ClusterPt  (f  x)  G  :=\n  ClusterPt.map  H  hfx  hf \n```", "```py\nexample  [TopologicalSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  {s  :  Set  X}  (hs  :  IsCompact  s)  :\n  IsCompact  (f  ''  s)  :=  by\n  intro  F  F_ne  F_le\n  have  map_eq  :  map  f  (ğ“Ÿ  s  âŠ“  comap  f  F)  =  ğ“Ÿ  (f  ''  s)  âŠ“  F  :=  by  sorry\n  have  Hne  :  (ğ“Ÿ  s  âŠ“  comap  f  F).NeBot  :=  by  sorry\n  have  Hle  :  ğ“Ÿ  s  âŠ“  comap  f  F  â‰¤  ğ“Ÿ  s  :=  inf_le_left\n  sorry \n```", "```py\nexample  {Î¹  :  Type*}  {s  :  Set  X}  (hs  :  IsCompact  s)  (U  :  Î¹  â†’  Set  X)  (hUo  :  âˆ€  i,  IsOpen  (U  i))\n  (hsU  :  s  âŠ†  â‹ƒ  i,  U  i)  :  âˆƒ  t  :  Finset  Î¹,  s  âŠ†  â‹ƒ  i  âˆˆ  t,  U  i  :=\n  hs.elim_finite_subcover  U  hUo  hsU \n```", "```py\nsection\nvariable  {X  :  Type*}  [TopologicalSpace  X]\n\nexample  :  IsOpen  (univ  :  Set  X)  :=\n  isOpen_univ\n\nexample  :  IsOpen  (âˆ…  :  Set  X)  :=\n  isOpen_empty\n\nexample  {Î¹  :  Type*}  {s  :  Î¹  â†’  Set  X}  (hs  :  âˆ€  i,  IsOpen  (s  i))  :  IsOpen  (â‹ƒ  i,  s  i)  :=\n  isOpen_iUnion  hs\n\nexample  {Î¹  :  Type*}  [Fintype  Î¹]  {s  :  Î¹  â†’  Set  X}  (hs  :  âˆ€  i,  IsOpen  (s  i))  :\n  IsOpen  (â‹‚  i,  s  i)  :=\n  isOpen_iInter_of_finite  hs \n```", "```py\nvariable  {Y  :  Type*}  [TopologicalSpace  Y]\n\nexample  {f  :  X  â†’  Y}  :  Continuous  f  â†”  âˆ€  s,  IsOpen  s  â†’  IsOpen  (f  â»Â¹'  s)  :=\n  continuous_def \n```", "```py\nexample  {f  :  X  â†’  Y}  {x  :  X}  :  ContinuousAt  f  x  â†”  map  f  (ğ“  x)  â‰¤  ğ“  (f  x)  :=\n  Iff.rfl \n```", "```py\nexample  {f  :  X  â†’  Y}  {x  :  X}  :  ContinuousAt  f  x  â†”  âˆ€  U  âˆˆ  ğ“  (f  x),  âˆ€á¶   x  in  ğ“  x,  f  x  âˆˆ  U  :=\n  Iff.rfl \n```", "```py\nexample  {x  :  X}  {s  :  Set  X}  :  s  âˆˆ  ğ“  x  â†”  âˆƒ  t,  t  âŠ†  s  âˆ§  IsOpen  t  âˆ§  x  âˆˆ  t  :=\n  mem_nhds_iff \n```", "```py\nexample  (x  :  X)  :  pure  x  â‰¤  ğ“  x  :=\n  pure_le_nhds  x\n\nexample  (x  :  X)  (P  :  X  â†’  Prop)  (h  :  âˆ€á¶   y  in  ğ“  x,  P  y)  :  P  x  :=\n  h.self_of_nhds \n```", "```py\nexample  {P  :  X  â†’  Prop}  {x  :  X}  (h  :  âˆ€á¶   y  in  ğ“  x,  P  y)  :  âˆ€á¶   y  in  ğ“  x,  âˆ€á¶   z  in  ğ“  y,  P  z  :=\n  eventually_eventually_nhds.mpr  h \n```", "```py\nexample  {Î±  :  Type*}  (n  :  Î±  â†’  Filter  Î±)  (Hâ‚€  :  âˆ€  a,  pure  a  â‰¤  n  a)\n  (H  :  âˆ€  a  :  Î±,  âˆ€  p  :  Î±  â†’  Prop,  (âˆ€á¶   x  in  n  a,  p  x)  â†’  âˆ€á¶   y  in  n  a,  âˆ€á¶   x  in  n  y,  p  x)  :\n  âˆ€  a,  âˆ€  s  âˆˆ  n  a,  âˆƒ  t  âˆˆ  n  a,  t  âŠ†  s  âˆ§  âˆ€  a'  âˆˆ  t,  s  âˆˆ  n  a'  :=  by\n  sorry\nend \n```", "```py\nvariable  {X  Y  :  Type*}\n\nexample  (f  :  X  â†’  Y)  :  TopologicalSpace  X  â†’  TopologicalSpace  Y  :=\n  TopologicalSpace.coinduced  f\n\nexample  (f  :  X  â†’  Y)  :  TopologicalSpace  Y  â†’  TopologicalSpace  X  :=\n  TopologicalSpace.induced  f\n\nexample  (f  :  X  â†’  Y)  (T_X  :  TopologicalSpace  X)  (T_Y  :  TopologicalSpace  Y)  :\n  TopologicalSpace.coinduced  f  T_X  â‰¤  T_Y  â†”  T_X  â‰¤  TopologicalSpace.induced  f  T_Y  :=\n  coinduced_le_iff_le_induced \n```", "```py\nexample  {T  T'  :  TopologicalSpace  X}  :  T  â‰¤  T'  â†”  âˆ€  s,  T'.IsOpen  s  â†’  T.IsOpen  s  :=\n  Iff.rfl \n```", "```py\nexample  (T_X  :  TopologicalSpace  X)  (T_Y  :  TopologicalSpace  Y)  (f  :  X  â†’  Y)  :\n  Continuous  f  â†”  TopologicalSpace.coinduced  f  T_X  â‰¤  T_Y  :=\n  continuous_iff_coinduced_le \n```", "```py\nexample  {Z  :  Type*}  (f  :  X  â†’  Y)  (T_X  :  TopologicalSpace  X)  (T_Z  :  TopologicalSpace  Z)\n  (g  :  Y  â†’  Z)  :\n  @Continuous  Y  Z  (TopologicalSpace.coinduced  f  T_X)  T_Z  g  â†”\n  @Continuous  X  Z  T_X  T_Z  (g  âˆ˜  f)  :=  by\n  rw  [continuous_iff_coinduced_le,  coinduced_compose,  continuous_iff_coinduced_le] \n```", "```py\nexample  (Î¹  :  Type*)  (X  :  Î¹  â†’  Type*)  (T_X  :  âˆ€  i,  TopologicalSpace  (X  i))  :\n  (Pi.topologicalSpace  :  TopologicalSpace  (âˆ€  i,  X  i))  =\n  â¨…  i,  TopologicalSpace.induced  (fun  x  â†¦  x  i)  (T_X  i)  :=\n  rfl \n```", "```py\nexample  [TopologicalSpace  X]  [T2Space  X]  {u  :  â„•  â†’  X}  {a  b  :  X}  (ha  :  Tendsto  u  atTop  (ğ“  a))\n  (hb  :  Tendsto  u  atTop  (ğ“  b))  :  a  =  b  :=\n  tendsto_nhds_unique  ha  hb\n\nexample  [TopologicalSpace  X]  [RegularSpace  X]  (a  :  X)  :\n  (ğ“  a).HasBasis  (fun  s  :  Set  X  â†¦  s  âˆˆ  ğ“  a  âˆ§  IsClosed  s)  id  :=\n  closed_nhds_basis  a \n```", "```py\nexample  [TopologicalSpace  X]  {x  :  X}  :\n  (ğ“  x).HasBasis  (fun  t  :  Set  X  â†¦  t  âˆˆ  ğ“  x  âˆ§  IsOpen  t)  id  :=\n  nhds_basis_opens'  x \n```", "```py\ntheorem  aux  {X  Y  A  :  Type*}  [TopologicalSpace  X]  {c  :  A  â†’  X}\n  {f  :  A  â†’  Y}  {x  :  X}  {F  :  Filter  Y}\n  (h  :  Tendsto  f  (comap  c  (ğ“  x))  F)  {V'  :  Set  Y}  (V'_in  :  V'  âˆˆ  F)  :\n  âˆƒ  V  âˆˆ  ğ“  x,  IsOpen  V  âˆ§  c  â»Â¹'  V  âŠ†  f  â»Â¹'  V'  :=  by\n  sorry \n```", "```py\nexample  [TopologicalSpace  X]  [TopologicalSpace  Y]  [T3Space  Y]  {A  :  Set  X}\n  (hA  :  âˆ€  x,  x  âˆˆ  closure  A)  {f  :  A  â†’  Y}  (f_cont  :  Continuous  f)\n  (hf  :  âˆ€  x  :  X,  âˆƒ  c  :  Y,  Tendsto  f  (comap  (â†‘)  (ğ“  x))  (ğ“  c))  :\n  âˆƒ  Ï†  :  X  â†’  Y,  Continuous  Ï†  âˆ§  âˆ€  a  :  A,  Ï†  a  =  f  a  :=  by\n  sorry\n\n#check  HasBasis.tendsto_right_iff \n```", "```py\nexample  [TopologicalSpace  X]  [FirstCountableTopology  X]\n  {s  :  Set  X}  {a  :  X}  :\n  a  âˆˆ  closure  s  â†”  âˆƒ  u  :  â„•  â†’  X,  (âˆ€  n,  u  n  âˆˆ  s)  âˆ§  Tendsto  u  atTop  (ğ“  a)  :=\n  mem_closure_iff_seq_limit \n```", "```py\nvariable  [TopologicalSpace  X]\n\nexample  {F  :  Filter  X}  {x  :  X}  :  ClusterPt  x  F  â†”  NeBot  (ğ“  x  âŠ“  F)  :=\n  Iff.rfl\n\nexample  {s  :  Set  X}  :\n  IsCompact  s  â†”  âˆ€  (F  :  Filter  X)  [NeBot  F],  F  â‰¤  ğ“Ÿ  s  â†’  âˆƒ  a  âˆˆ  s,  ClusterPt  a  F  :=\n  Iff.rfl \n```", "```py\nexample  [FirstCountableTopology  X]  {s  :  Set  X}  {u  :  â„•  â†’  X}  (hs  :  IsCompact  s)\n  (hu  :  âˆ€  n,  u  n  âˆˆ  s)  :  âˆƒ  a  âˆˆ  s,  âˆƒ  Ï†  :  â„•  â†’  â„•,  StrictMono  Ï†  âˆ§  Tendsto  (u  âˆ˜  Ï†)  atTop  (ğ“  a)  :=\n  hs.tendsto_subseq  hu \n```", "```py\nvariable  [TopologicalSpace  Y]\n\nexample  {x  :  X}  {F  :  Filter  X}  {G  :  Filter  Y}  (H  :  ClusterPt  x  F)  {f  :  X  â†’  Y}\n  (hfx  :  ContinuousAt  f  x)  (hf  :  Tendsto  f  F  G)  :  ClusterPt  (f  x)  G  :=\n  ClusterPt.map  H  hfx  hf \n```", "```py\nexample  [TopologicalSpace  Y]  {f  :  X  â†’  Y}  (hf  :  Continuous  f)  {s  :  Set  X}  (hs  :  IsCompact  s)  :\n  IsCompact  (f  ''  s)  :=  by\n  intro  F  F_ne  F_le\n  have  map_eq  :  map  f  (ğ“Ÿ  s  âŠ“  comap  f  F)  =  ğ“Ÿ  (f  ''  s)  âŠ“  F  :=  by  sorry\n  have  Hne  :  (ğ“Ÿ  s  âŠ“  comap  f  F).NeBot  :=  by  sorry\n  have  Hle  :  ğ“Ÿ  s  âŠ“  comap  f  F  â‰¤  ğ“Ÿ  s  :=  inf_le_left\n  sorry \n```", "```py\nexample  {Î¹  :  Type*}  {s  :  Set  X}  (hs  :  IsCompact  s)  (U  :  Î¹  â†’  Set  X)  (hUo  :  âˆ€  i,  IsOpen  (U  i))\n  (hsU  :  s  âŠ†  â‹ƒ  i,  U  i)  :  âˆƒ  t  :  Finset  Î¹,  s  âŠ†  â‹ƒ  i  âˆˆ  t,  U  i  :=\n  hs.elim_finite_subcover  U  hUo  hsU \n```"]