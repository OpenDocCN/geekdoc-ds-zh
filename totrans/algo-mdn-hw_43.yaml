- en: External Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部内存
- en: 原文：[https://en.algorithmica.org/hpc/external-memory/](https://en.algorithmica.org/hpc/external-memory/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/external-memory/](https://en.algorithmica.org/hpc/external-memory/)
- en: How long does it take to add two numbers together? Being one of the most frequently
    used instructions, `add` by itself only takes one cycle to execute. So, if the
    data is already loaded into registers, it takes one just cycle.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 添加两个数字需要多长时间？作为最常用的指令之一，`add`本身只需要一个周期来执行。所以，如果数据已经加载到寄存器中，它只需要一个周期。
- en: 'But in the general case (`*c = *a + *b`), we need to fetch its operands from
    memory first:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但在一般情况（`*c = *a + *b`）下，我们首先需要从内存中检索其操作数：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you fetch anything from memory, there is always some latency before the
    data arrives. Moreover, the request doesn’t go directly to its ultimate storage
    location, but it first goes through a complex system of address translation units
    and caching layers designed to both help in memory management and reduce latency.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从内存中检索任何内容时，数据到达之前总会有一些延迟。此外，请求不会直接发送到其最终存储位置，而是首先通过一个复杂的地址转换单元和缓存层系统，这个系统旨在帮助内存管理并减少延迟。
- en: 'Therefore, the only correct answer to this question is “it depends” — primarily
    on where the operands are stored:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对这个问题的唯一正确答案是“这取决于”——主要取决于操作数存储的位置：
- en: If the data is stored in the main memory (RAM), it will take around ~100ns,
    or about 200 cycles, to fetch it, and then another 200 cycles to write it back.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据存储在主内存（RAM）中，检索它将需要大约~100ns，或者大约200个周期，然后还需要200个周期来将其写回。
- en: If it was accessed recently, it is probably *cached* and will take less than
    that to fetch, depending on how long ago it was accessed — it could be ~50 cycles
    for the slowest layer of cache and around 4-5 cycles for the fastest.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它最近被访问过，它可能已经被*缓存*，并且检索它所需的时间将少于那个时间，这取决于它最后一次被访问的时间——对于最慢的缓存层可能是大约50个周期，对于最快的缓存层可能是大约4-5个周期。
- en: But it could also be stored on some type of *external memory* such as a hard
    drive, and in this case, it will take around 5ms, or roughly $10^7$ cycles (!)
    to access it.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但它也可能存储在某种类型的*外部内存*上，例如硬盘，在这种情况下，访问它将需要大约5毫秒，或者大约$10^7$个周期（！）。
- en: Such a high variance of memory performance is caused by the fact that memory
    hardware doesn’t follow the same [laws of silicon scaling](/hpc/complexity/hardware)
    as CPU chips do. Memory is still improving through other means, but if 50 years
    ago memory timings were roughly on the same scale with the instruction latencies,
    nowadays they lag far behind.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种内存性能的高变异性是由内存硬件不遵循与CPU芯片相同的[硅缩放定律](/hpc/complexity/hardware)这一事实造成的。内存仍在通过其他方式不断改进，但如果50年前内存的定时与指令延迟大致在同一规模，那么现在它们落后得远。
- en: '![](../Images/45a70362bd76c5497d92f72512eb0c4a.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/45a70362bd76c5497d92f72512eb0c4a.png)'
- en: To be less of a limiting factor, modern memory systems are becoming increasingly
    [hierarchical](hierarchy), where the higher layers trade off some of their capacity
    for reduced latency. As these characteristics may change in the orders of magnitude
    between the layers — especially in the case of external memory types — it became
    crucial for many memory-intensive algorithms to optimize their I/O operations
    before anything else.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少限制因素，现代内存系统正变得越来越[分层](hierarchy)，其中较高层通过减少一些容量来降低延迟。由于这些特性可能在层之间以数量级的方式变化——特别是在外部内存类型的情况下——对于许多内存密集型算法来说，在所有其他操作之前优化它们的I/O操作变得至关重要。
- en: This prompted the creation of a new cost model, called the *external memory
    model*, whose only primitive operations are block reads and writes, and everything
    else has zero cost as long as it only involves data stored in a limited-sized
    local memory. It spawned an exciting new field of *external memory algorithms*,
    which we will study in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这促使创建了一个新的成本模型，称为*外部内存模型*，其唯一的原始操作是块读取和写入，只要它只涉及存储在有限大小的本地内存中的数据，其他所有操作的成本都是零。它催生了一个令人兴奋的新领域，即*外部内存算法*，我们将在本章中研究。
- en: '[← Montgomery Multiplication](https://en.algorithmica.org/hpc/number-theory/montgomery/)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[← Montgomery Multiplication](https://en.algorithmica.org/hpc/number-theory/montgomery/)'
- en: '[← ../Number Theory](https://en.algorithmica.org/hpc/number-theory/)[Memory
    Hierarchy →](https://en.algorithmica.org/hpc/external-memory/hierarchy/)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[← ../Number Theory](https://en.algorithmica.org/hpc/number-theory/)[Memory
    Hierarchy →](https://en.algorithmica.org/hpc/external-memory/hierarchy/)'
- en: '[../RAM & CPU Caches →](https://en.algorithmica.org/hpc/cpu-cache/)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[../RAM & CPU Caches →](https://en.algorithmica.org/hpc/cpu-cache/)'
