- en: Stiffness and Damping in Constraint Solving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://phys-sim-book.github.io/lec31.5-stiffness_damping.html](https://phys-sim-book.github.io/lec31.5-stiffness_damping.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  prefs: []
  type: TYPE_NORMAL
- en: '[Stiffness](#stiffness)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Material stiffness is controlled by a parameter k∈[0,1], which controls how
    strongly a constraint is enforced. The most straightforward way to incorporate
    stiffness is to scale the calculated correction by k: Δpi​←k⋅Δpi​. However, this
    makes the effective stiffness dependent on the number of solver iterations, ns​.
    If a constraint is projected ns​ times, the remaining error after the projections
    would be proportional to (1−k)ns​. A more robust formulation that decouples stiffness
    from the iteration count is: k′=1−(1−k)1/ns​(32.5.1) By scaling the correction
    by k′ instead of k, the remaining error after ns​ iterations becomes (1−k′)ns​=1−k,
    which is independent of ns​. This allows artists to tune the material stiffness
    k without worrying about how many solver iterations are being used.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Damping](#damping)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the PBD method is generally stable, simulations can exhibit excessive
    oscillations or kinetic energy gain, particularly with stiff constraints. The
    quality of dynamic simulations can generally be improved by the incorporation
    of an appropriate damping scheme. It can improve the stability by reducing temporal
    jittering of the point positions of an object. It also allows for larger time
    steps which increases the performance of a dynamic simulation.
  prefs: []
  type: TYPE_NORMAL
- en: A naive damping of all velocities can undesirably affect the global motion of
    an object, slowing down its overall translation and rotation. A more sophisticated
    approach is to damp only the relative motions of particles while preserving the
    total linear and angular momentum of the system.
  prefs: []
  type: TYPE_NORMAL
- en: '****Method 32.5.1 (Momentum-Conserving Damping).****'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Compute Center of Mass and Velocity:** pcm​=∑i​mi​∑i​mi​pi​​, vcm​=∑i​mi​∑i​mi​vi​​'
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Compute Angular Momentum and Inertia Tensor:** Let ri​=xi​−pcm​.'
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: L=∑i​ri​×(mi​vi​)
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: I=∑i​mi​((ri​⋅ri​)Id−ri​⊗ri​)
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Compute Angular Velocity:** ω=I−1L'
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Apply Damping:** For each particle i:'
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'a. Calculate the velocity deviation from rigid body motion: Δvi​=(vcm​+ω×ri​)−vi​'
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b. Apply damping to the deviation: vi​←vi​+kdamping​Δvi​'
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: This method effectively isolates the non-rigid components of motion and damps
    only them. In the extreme case where kdamping​=1, all relative motion is eliminated,
    and the object behaves as a perfect rigid body.
  prefs: []
  type: TYPE_NORMAL
- en: '[Extended Position Based Dynamics (XPBD)](#extended-position-based-dynamics-xpbd)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the stiffness formulation in Equation [(32.5.1)](#eq:pbd:stiffness) decouples
    the effective stiffness from the solver iteration count, a fundamental limitation
    of standard PBD remains: the resulting material stiffness is still dependent on
    the simulation time step Δt. An extension known as **Extended Position Based Dynamics
    (XPBD)** addresses this issue, enabling true parameter-independent stiffness.'
  prefs: []
  type: TYPE_NORMAL
- en: XPBD is derived from a compliant constraint formulation and introduces the concept
    of compliance as the inverse of stiffness.
  prefs: []
  type: TYPE_NORMAL
- en: '****Definition 32.5.1 (Compliance).**** Compliance, α≥0, is the inverse of
    a material''s stiffness k, with α=1/k. It describes a material''s propensity to
    deform under load. In XPBD, a compliance of α=0 corresponds to an infinitely stiff,
    or hard, constraint.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The core idea of XPBD is to treat the Lagrange multiplier λ not as a temporary
    value recalculated in each iteration, but as a physical quantity representing
    the accumulated impulse that is incrementally updated. In each solver iteration,
    we calculate an impulse increment, Δλ, and add it to the total impulse λ for that
    constraint. The formula for this increment modifies Equation [(32.4.3)](lec31.4-solver.html#eq:solver:lambda)
    as follows: Δλ=∑j​wj​∣∇pj​​C(p)∣2+α^−C(p)−α^λ​(32.5.2) Here, λ is the total accumulated
    Lagrange multiplier for the constraint from previous iterations within the current
    time step. The term α^ is the time-step scaled compliance, defined as: α^=(Δt)2α​
    This scaling ensures that the compliance parameter α has physically consistent
    units within the dynamical system. After computing Δλ, the solver updates both
    the particle positions and the accumulated Lagrange multiplier for that constraint:
    Δpi​=−Δλwi​∇pi​​C(p)andλ←λ+Δλ'
  prefs: []
  type: TYPE_NORMAL
- en: '***Remark 32.5.1 (Interpretation of XPBD).*** The +α^ term in the denominator
    of Equation [(32.5.2)](#eq:pbd:xpbd_delta_lambda) acts to limit the magnitude
    of the corrective impulse Δλ. As compliance α increases (i.e., the material becomes
    softer), α^ grows, thus reducing the impulse applied per iteration. In the case
    of zero compliance (α=0), the α^ terms vanish, and the formula for Δλ reduces
    to the standard PBD formulation in Equation [(32.4.3)](lec31.4-solver.html#eq:solver:lambda).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The primary benefit of XPBD is **not faster convergence, but convergence to
    a physically consistent state that correctly reflects the user-defined compliance
    α**, independent of the time step or iteration count. If the solver is terminated
    early, the system still exhibits the desired softness to some degree rather than
    an artificial, uncontrolled compliance. This makes material behavior more predictable
    and robust.
  prefs: []
  type: TYPE_NORMAL
