["```py\ndef inhomogeneous_er_random_graph(rng, n, M):\n\n    G = nx.Graph()\n    G.add_nodes_from(range(n))\n    for i in range(n):\n        for j in range(i + 1, n):\n            if rng.random() < M[i, j]:\n                G.add_edge(i, j)\n\n    return G \n```", "```py\nseed = 535\nrng = np.random.default_rng(seed)\n\nn = 20\nM = rng.random([n, n])\nM = (M + M.T) / 2 # ensures symmetry of M (why?)\n\nG = inhomogeneous_er_random_graph(rng, n, M) \n```", "```py\nnx.draw_networkx(G, node_color='black', font_color='white')\nplt.axis('off')\nplt.show() \n```", "```py\ndef er_random_graph(rng, n, p):\n    M = p * (np.ones((n, n)) - np.eye(n))\n    return inhomogeneous_er_random_graph(rng, n, M) \n```", "```py\ndef estimate_edge_density(rng, n, p, num_samples=100):\n\n    total_edges = 0\n    total_possible_edges = n * (n - 1) / 2\n\n    for _ in range(num_samples):\n        G = er_random_graph(rng, n, p)\n        total_edges += G.number_of_edges()\n\n    average_edges = total_edges / num_samples\n    edge_density = average_edges / total_possible_edges\n    return edge_density \n```", "```py\nn = 10\np = 0.3\nnum_samples = 1000\n\nestimated_density = estimate_edge_density(rng, n, p, num_samples)\nprint(f\"Estimated edge density for an ER graph with n={n} and p={p}: {estimated_density}\") \n```", "```py\nEstimated edge density for an ER graph with n=10 and p=0.3: 0.3004888888888889 \n```", "```py\ndef estimate_connected_probability(rng, n, p, num_samples=100):\n\n    connected_count = 0\n\n    for _ in range(num_samples):\n        G = er_random_graph(rng, n, p)\n        if nx.is_connected(G):\n            connected_count += 1\n\n    connected_probability = connected_count / num_samples\n    return connected_probability\n\ndef plot_connected_probability(rng, n, p_values, num_samples=100):\n\n    probabilities = []\n    for p in p_values:\n        prob = estimate_connected_probability(rng, n, p, num_samples)\n        probabilities.append(prob)\n\n    plt.figure(figsize=(6, 4))\n    plt.plot(p_values, probabilities, marker='o', color='black')\n    plt.xlabel('$p$'), plt.ylabel('Estimated probability of being connected')\n    plt.show() \n```", "```py\nn = 100\np_values = np.linspace(0, 0.1, 50)\nnum_samples = 250\nplot_connected_probability(rng, n, p_values, num_samples) \n```", "```py\nnp.log(n)/n \n```", "```py\n0.04605170185988092 \n```", "```py\ndef sbm_random_graph(rng, n, block_assignments, B):\n\n    num_blocks = B.shape[0]\n    Z = np.zeros((n, num_blocks))\n    for i in range(n):\n        Z[i, block_assignments[i]] = 1\n    M = Z @ B @ Z.T\n\n    return inhomogeneous_er_random_graph(rng, n, M) \n```", "```py\nB = np.array([[0.8, 0.1], [0.1, 0.8]])\n\nn = 50\nblock_assignments = rng.choice(2, n)\n\nG = sbm_random_graph(rng, n, block_assignments, B) \n```", "```py\nplt.figure(figsize=(6,6))\npos = nx.spring_layout(G)\nnx.draw(G, pos, with_labels=True, node_color=block_assignments, cmap='rainbow',\n        node_size=200, font_size=10, font_color='white')\nplt.show() \n```", "```py\ndef generate_block_assignments(rng, n, beta):\n    return rng.choice(len(beta), size=n, p=beta) \n```", "```py\nn = 50\nbeta = [0.33, 0.67]\nB = np.array([[0.5, 0.03], [0.03, 0.4]])\n\nblock_assignments = generate_block_assignments(rng, n, beta)\nG = sbm_random_graph(rng, n, block_assignments, B) \n```", "```py\nplt.figure(figsize=(6,6))\npos = nx.spring_layout(G)\nnx.draw(G, pos, with_labels=True, node_color=block_assignments, cmap=plt.cm.rainbow,\n        node_size=200, font_size=10, font_color='white')\nplt.show() \n```", "```py\nA = nx.adjacency_matrix(G).toarray()\ns, sc = mmids.spectral_cut2(A)\n\nplt.figure(figsize=(6,6))\nmmids.viz_cut(G, s, pos, node_size=200, with_labels=True) \n```", "```py\ndef calculate_incorrect_fraction(block_assignments, inferred_s, inferred_sc):\n\n    n = len(block_assignments)\n\n    inferred_assignments = np.zeros(n)\n    for i in inferred_s:\n        inferred_assignments[i] = 0\n    for i in inferred_sc:\n        inferred_assignments[i] = 1\n\n    incorrect_assignments_1 = np.sum(block_assignments != inferred_assignments)/n\n    incorrect_assignments_2 = np.sum(block_assignments == inferred_assignments)/n\n\n    return np.minimum(incorrect_assignments_1, incorrect_assignments_2) \n```", "```py\nfraction_incorrect = calculate_incorrect_fraction(block_assignments, s, sc)\nprint(f\"Fraction of incorrectly assigned vertices: {fraction_incorrect}\") \n```", "```py\nFraction of incorrectly assigned vertices: 0.0 \n```", "```py\nn = 100\nbeta = [0.55, 0.45]\nB = np.array([[0.55, 0.25], [0.25, 0.45]])\n\nblock_assignments = generate_block_assignments(rng, n, beta)\nG = sbm_random_graph(rng, n, block_assignments, B) \n```", "```py\nA = nx.adjacency_matrix(G).toarray()\ns, sc = mmids.spectral_cut2(A)\nfraction_incorrect = calculate_incorrect_fraction(block_assignments, s, sc)\nprint(f\"Fraction of incorrectly assigned vertices: {fraction_incorrect}\") \n```", "```py\nFraction of incorrectly assigned vertices: 0.22 \n```", "```py\nn, p = 5, 0.4\nrng = np.random.default_rng(123)\nG = nx.Graph()\nG.add_nodes_from(range(n))\nfor i in range(n):\n    for j in range(i + 1, n):\n        if rng.random() < p:\n            G.add_edge(i, j) \n```", "```py\ndef inhomogeneous_er_random_graph(rng, n, M):\n\n    G = nx.Graph()\n    G.add_nodes_from(range(n))\n    for i in range(n):\n        for j in range(i + 1, n):\n            if rng.random() < M[i, j]:\n                G.add_edge(i, j)\n\n    return G \n```", "```py\nseed = 535\nrng = np.random.default_rng(seed)\n\nn = 20\nM = rng.random([n, n])\nM = (M + M.T) / 2 # ensures symmetry of M (why?)\n\nG = inhomogeneous_er_random_graph(rng, n, M) \n```", "```py\nnx.draw_networkx(G, node_color='black', font_color='white')\nplt.axis('off')\nplt.show() \n```", "```py\ndef er_random_graph(rng, n, p):\n    M = p * (np.ones((n, n)) - np.eye(n))\n    return inhomogeneous_er_random_graph(rng, n, M) \n```", "```py\ndef estimate_edge_density(rng, n, p, num_samples=100):\n\n    total_edges = 0\n    total_possible_edges = n * (n - 1) / 2\n\n    for _ in range(num_samples):\n        G = er_random_graph(rng, n, p)\n        total_edges += G.number_of_edges()\n\n    average_edges = total_edges / num_samples\n    edge_density = average_edges / total_possible_edges\n    return edge_density \n```", "```py\nn = 10\np = 0.3\nnum_samples = 1000\n\nestimated_density = estimate_edge_density(rng, n, p, num_samples)\nprint(f\"Estimated edge density for an ER graph with n={n} and p={p}: {estimated_density}\") \n```", "```py\nEstimated edge density for an ER graph with n=10 and p=0.3: 0.3004888888888889 \n```", "```py\ndef estimate_connected_probability(rng, n, p, num_samples=100):\n\n    connected_count = 0\n\n    for _ in range(num_samples):\n        G = er_random_graph(rng, n, p)\n        if nx.is_connected(G):\n            connected_count += 1\n\n    connected_probability = connected_count / num_samples\n    return connected_probability\n\ndef plot_connected_probability(rng, n, p_values, num_samples=100):\n\n    probabilities = []\n    for p in p_values:\n        prob = estimate_connected_probability(rng, n, p, num_samples)\n        probabilities.append(prob)\n\n    plt.figure(figsize=(6, 4))\n    plt.plot(p_values, probabilities, marker='o', color='black')\n    plt.xlabel('$p$'), plt.ylabel('Estimated probability of being connected')\n    plt.show() \n```", "```py\nn = 100\np_values = np.linspace(0, 0.1, 50)\nnum_samples = 250\nplot_connected_probability(rng, n, p_values, num_samples) \n```", "```py\nnp.log(n)/n \n```", "```py\n0.04605170185988092 \n```", "```py\ndef sbm_random_graph(rng, n, block_assignments, B):\n\n    num_blocks = B.shape[0]\n    Z = np.zeros((n, num_blocks))\n    for i in range(n):\n        Z[i, block_assignments[i]] = 1\n    M = Z @ B @ Z.T\n\n    return inhomogeneous_er_random_graph(rng, n, M) \n```", "```py\nB = np.array([[0.8, 0.1], [0.1, 0.8]])\n\nn = 50\nblock_assignments = rng.choice(2, n)\n\nG = sbm_random_graph(rng, n, block_assignments, B) \n```", "```py\nplt.figure(figsize=(6,6))\npos = nx.spring_layout(G)\nnx.draw(G, pos, with_labels=True, node_color=block_assignments, cmap='rainbow',\n        node_size=200, font_size=10, font_color='white')\nplt.show() \n```", "```py\ndef generate_block_assignments(rng, n, beta):\n    return rng.choice(len(beta), size=n, p=beta) \n```", "```py\nn = 50\nbeta = [0.33, 0.67]\nB = np.array([[0.5, 0.03], [0.03, 0.4]])\n\nblock_assignments = generate_block_assignments(rng, n, beta)\nG = sbm_random_graph(rng, n, block_assignments, B) \n```", "```py\nplt.figure(figsize=(6,6))\npos = nx.spring_layout(G)\nnx.draw(G, pos, with_labels=True, node_color=block_assignments, cmap=plt.cm.rainbow,\n        node_size=200, font_size=10, font_color='white')\nplt.show() \n```", "```py\nA = nx.adjacency_matrix(G).toarray()\ns, sc = mmids.spectral_cut2(A)\n\nplt.figure(figsize=(6,6))\nmmids.viz_cut(G, s, pos, node_size=200, with_labels=True) \n```", "```py\ndef calculate_incorrect_fraction(block_assignments, inferred_s, inferred_sc):\n\n    n = len(block_assignments)\n\n    inferred_assignments = np.zeros(n)\n    for i in inferred_s:\n        inferred_assignments[i] = 0\n    for i in inferred_sc:\n        inferred_assignments[i] = 1\n\n    incorrect_assignments_1 = np.sum(block_assignments != inferred_assignments)/n\n    incorrect_assignments_2 = np.sum(block_assignments == inferred_assignments)/n\n\n    return np.minimum(incorrect_assignments_1, incorrect_assignments_2) \n```", "```py\nfraction_incorrect = calculate_incorrect_fraction(block_assignments, s, sc)\nprint(f\"Fraction of incorrectly assigned vertices: {fraction_incorrect}\") \n```", "```py\nFraction of incorrectly assigned vertices: 0.0 \n```", "```py\nn = 100\nbeta = [0.55, 0.45]\nB = np.array([[0.55, 0.25], [0.25, 0.45]])\n\nblock_assignments = generate_block_assignments(rng, n, beta)\nG = sbm_random_graph(rng, n, block_assignments, B) \n```", "```py\nA = nx.adjacency_matrix(G).toarray()\ns, sc = mmids.spectral_cut2(A)\nfraction_incorrect = calculate_incorrect_fraction(block_assignments, s, sc)\nprint(f\"Fraction of incorrectly assigned vertices: {fraction_incorrect}\") \n```", "```py\nFraction of incorrectly assigned vertices: 0.22 \n```", "```py\nn, p = 5, 0.4\nrng = np.random.default_rng(123)\nG = nx.Graph()\nG.add_nodes_from(range(n))\nfor i in range(n):\n    for j in range(i + 1, n):\n        if rng.random() < p:\n            G.add_edge(i, j) \n```"]