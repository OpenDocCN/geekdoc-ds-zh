- en: 2 Get started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 开始学习
- en: 原文：[https://socviz.co/gettingstarted.html](https://socviz.co/gettingstarted.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://socviz.co/gettingstarted.html](https://socviz.co/gettingstarted.html)
- en: In this Chapter, we will begin to learn how to create pictures of data that
    people, including ourselves, can look at and learn from. R and ggplot are the
    tools we will use. The best way to learn them is to follow along and repeatedly
    write code as you go. The material in this book is designed to be interactive
    and hands-on. If you work through it with me using the approach described below,
    you will end up with a book much like this one, with many code samples along side
    your notes, and the figures or other output produced by that code shown nearby.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始学习如何创建人们，包括我们自己，可以查看并从中学习的数据图片。我们将使用 R 和 ggplot 作为工具。学习它们的最佳方式是跟随并反复编写代码。本书中的材料旨在具有交互性和实践性。如果你按照下面描述的方法与我一起工作，你最终会得到一本与这本书非常相似的书，其中包含了大量的代码示例和你的笔记，以及由该代码产生的图表或其他输出。
- en: I strongly encourage you to type out your code, rather than copying and pasting
    the examples from the text. Typing it out will help you learn it. At the beginning
    it may feel like tedious transcription you don’t fully understand. But it slows
    you down in a way that gets you used to what the syntax and structure of R is
    like, and is a very effective way to learn the language. It’s especially useful
    for ggplot, where the code for our figures will repeatedly have a very similar
    structure, built up piece by piece.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你亲自输入代码，而不是从文本中复制粘贴示例。亲自输入代码将帮助你学习。一开始可能会感觉像是一种乏味的转录，你并不完全理解。但它会以某种方式让你放慢速度，适应
    R 的语法和结构，这是一种非常有效的学习语言的方法。对于 ggplot 来说，特别有用，因为我们图表的代码将反复具有非常相似的结构，逐步构建而成。
- en: 2.1 Work in plain text, using RMarkdown
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 使用纯文本和 RMarkdown 进行工作
- en: When taking notes, and when writing your own code, you should write plain text
    in a text editor. Do not use Microsoft Word or some other word processor. You
    may be used to thinking of your final outputs (e.g. a Word file, a PDF document,
    presentation slides, or the tables and figures you make) as what’s “real” about
    your project. Instead, it’s better to think of the data and code as what’s real,
    together with the text you write. The idea is that all of your finished output—your
    figures, tables, and text, and so on—can be procedurally and reproducibly generated
    from code, data, and written material stored in a simple, plain-text format.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在做笔记和编写自己的代码时，你应该在文本编辑器中编写纯文本。不要使用 Microsoft Word 或其他文字处理软件。你可能习惯于将你的最终输出（例如
    Word 文件、PDF 文档、演示文稿或你制作的表格和图表）视为你项目中的“真实”内容。相反，最好是认为数据和代码才是真实的内容，连同你写的文本一起。想法是，你所有的最终输出——你的图表、表格和文本等——都可以通过代码、数据和存储在简单纯文本格式中的书面材料按程序和可重复地生成。
- en: '![Top: Some elements of RMarkdown syntax. Bottom: From a plain text RMarkdown
    file to PDF output.](../Images/8b3c8114189c9e97fe617516777a7dd3.png)![Top: Some
    elements of RMarkdown syntax. Bottom: From a plain text RMarkdown file to PDF
    output.](../Images/8a6a98cd16161948fc8e6571bbbc8658.png) Figure 2.1: Top: Some
    elements of RMarkdown syntax. Bottom: From a plain text RMarkdown file to PDF
    output.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '![顶部：RMarkdown 语法的一些元素。底部：从纯文本 RMarkdown 文件到 PDF 输出。](../Images/8b3c8114189c9e97fe617516777a7dd3.png)![顶部：RMarkdown
    语法的一些元素。底部：从纯文本 RMarkdown 文件到 PDF 输出。](../Images/8a6a98cd16161948fc8e6571bbbc8658.png)
    图 2.1：顶部：RMarkdown 语法的一些元素。底部：从纯文本 RMarkdown 文件到 PDF 输出。'
- en: The ability to reproduce your work in this way is important to the scientific
    process. But you should also see it as a pragmatic choice that will make life
    easier for you in future. The reality for most of us is that the person who will
    most want to easily reproduce your work is *you*, six months or a year from now.
    This is especially true for graphics and figures. These often have a “finished”
    quality to them, as a result of much tweaking and adjustments to the details of
    the figure. That can make them hard to reproduce later. While it is normal for
    graphics to undergo a substantial amount of polishing on their way to publication,
    our goal is to do as much of this as possible *programmatically*, in code we write,
    rather than in a way that is retrospectively invisible, as for example when we
    edit an image in an application like Adobe Illustrator.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式重现你的工作对于科学过程来说非常重要。但你也应该将其视为一个实用性的选择，这将使你未来的生活更加轻松。对我们大多数人来说，最希望轻松重现你工作的人是六个月或一年后的你自己。这对于图形和图形尤其如此。由于对图形细节进行了大量的调整和修改，它们往往具有“完成”的品质。这可能会使它们在以后难以重现。虽然图形在发表之前进行大量的打磨是正常的，但我们的目标是尽可能通过编程的方式，在我们的代码中完成这些工作，而不是以事后不可见的方式，例如在Adobe
    Illustrator等应用程序中编辑图像。
- en: 'While learning ggplot, and later while doing data analysis, you will find yourself
    constantly pinging back and forth between three things:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习ggplot以及后来进行数据分析时，你会发现自己在三个事物之间不断来回切换：
- en: '*Writing code*. You will write a lot of code to produce plots. You will also
    write code to load your data, to look quickly at tables of that data. Sometimes
    you will want to summarize, rearrange, subset, or augment your data, or run a
    statistical model with it. You will want to be able to write that code as easily
    and effectively as possible.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*编写代码*。你将编写大量代码来生成图形。你还将编写代码来加载数据，快速查看数据的表格。有时你可能想要总结、重新排列、子集或增强你的数据，或者用统计模型与之一起运行。你希望能够尽可能轻松有效地编写这些代码。'
- en: '*Looking at output*. Your code is a set of instructions that, when executed,
    produces the output you want: a table, a model, or a figure. It is often helpful
    to be able to see that output, and its partial results. While we’re working, it’s
    also useful to keep the code and the things produced by the code close together,
    if we can.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*查看输出*。你的代码是一组指令，当执行时，会产生你想要的输出：一个表格、一个模型或一个图形。能够看到这个输出及其部分结果通常很有帮助。在我们工作的过程中，如果可能的话，将代码及其产生的结果保持在一起也是很实用的。'
- en: '*Taking Notes*. You will also be writing about what we are doing, and what
    your results mean. When learning how to do something in ggplot, for instance,
    you will want to make notes to yourself about what you did, why you wrote it this
    way rather than that, or what this new concept, function, or instruction does.
    Later, when doing data analysis and making figures, you will be writing up reports
    or drafting papers.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*做笔记*。你还将记录我们所做的工作以及你的结果意味着什么。例如，在学习如何使用ggplot时，你将想要为自己做笔记，记录你做了什么，为什么这样写而不是那样写，或者这个新的概念、函数或指令是什么。后来，在数据分析制作图形时，你将撰写报告或起草论文。'
- en: 'How can you do all this effectively? The simplest way to keep code and notes
    together is to write your code and intersperse it with comments. All programming
    languages have some way of demarcating lines as comments, usually by putting a
    special character (like `#`) at the start of the line. We could create a plain-text
    script file called, e.g., `notes.r`, containing code and our comments on it. This
    is fine as far as it goes. But except for very short files, it will be difficult
    to do anything useful with the comments we write. If we want a report from an
    analysis, for example, we will have to write it up separately. While a script
    file can keep comments and code together, it loses the connection between code
    and its output, such as the figure we want to produce. But there is a better alternative:
    we can write our notes using RMarkdown.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如何有效地完成所有这些工作？最简单的方法是将代码和注释写在一起。所有编程语言都有一种方式来标记注释行，通常是在行首放置一个特殊字符（如`#`）。我们可以创建一个名为，例如，`notes.r`的纯文本脚本文件，其中包含代码和我们对它的注释。就目前而言，这是可以的。但对于非常短的文件，使用我们写的注释来做任何有用的事情都会很困难。如果我们想要一份分析报告，例如，我们必须单独编写。虽然脚本文件可以将注释和代码保持在一起，但它失去了代码与其输出之间的联系，例如我们想要生成的图形。但有一个更好的选择：我们可以使用RMarkdown来写我们的笔记。
- en: An RMarkdown file is just a plain text document where text (such as notes or
    discussion) is interspersed with pieces, or *chunks*, of R code. When you feed
    the document to R, it *knits* this file into a new document by running the R code
    piece by piece, in sequence, and either supplementing or replacing the chunks
    of code with their output. The resulting file is then converted into a more easily-readable
    document formatted in HTML, PDF, or Word. The non-code segments of the document
    are plain text, but they can have simple formatting instructions in them. These
    are set using [Markdown](http://en.wikipedia.org/wiki/Markdown), a set of conventions
    for marking up plain text in a way that indicates how it should be formatted.
    The basic elements of Markdown are shown in the upper part of Figure [2.1](gettingstarted.html#fig:ch-02-markdown-margin).
    When you create a markdown document in R Studio, it contains some sample text
    to get you started.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: RMarkdown 文件只是一个普通的文本文档，其中文本（如笔记或讨论）与 R 代码的片段或*块*交织在一起。当你将文档输入到 R 中时，它会通过逐个运行
    R 代码片段，按顺序将文件*编织*成一个新的文档，并用它们的输出补充或替换代码块。生成的文件随后被转换成格式为 HTML、PDF 或 Word 的更易于阅读的文档。文档的非代码部分是纯文本，但它们可以包含简单的格式化指令。这些指令使用
    [Markdown](http://en.wikipedia.org/wiki/Markdown) 设置，这是一套标记纯文本的约定，指示其格式化方式。Markdown
    的基本元素显示在图 [2.1](gettingstarted.html#fig:ch-02-markdown-margin) 的上半部分。当你使用 R Studio
    创建 markdown 文档时，它会包含一些示例文本以帮助你开始。
- en: 'RMarkdown documents look like the one shown schematically in the lower part
    of Figure [2.1](gettingstarted.html#fig:ch-02-markdown-margin). Your notes or
    text, with Markdown formatting as needed, are interspersed with code. There is
    a set format for code chunks. They look like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: RMarkdown 文档看起来就像图 [2.1](gettingstarted.html#fig:ch-02-markdown-margin) 的下半部分所示。你的笔记或文本，根据需要使用
    Markdown 格式化，与代码交织在一起。代码块有一个固定的格式。它们看起来像这样：
- en: '[PRE0]{r}'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]{r}'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Three backticks (on a U.S. keyboard, that’s the character under the escape key)
    followed by a pair of curly braces containing the name of the language we are
    using.The format is language-agnostic, and can be used with, e.g. Python and other
    languages. The backticks-and-braces part signal that a chunk of code is about
    to begin. You write your code as needed, and then end the chunk with a new line
    containing just three backticks.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 三个反引号（在美国键盘上，这是位于 Esc 键下的字符）后跟一对大括号，包含我们正在使用的语言名称。这个格式是语言无关的，可以与 Python 和其他语言一起使用。反引号和大括号部分表示一个代码块即将开始。你根据需要编写代码，然后在一个只包含三个反引号的新行中结束代码块。
- en: If you keep your notes in this way, you will be able to see the code you wrote,
    the output it produces, and your own commentary or clarification on it in a convenient
    way. Moreover, you can turn it into a good-looking document right away.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以这种方式保存笔记，你将能够方便地看到你编写的代码、它产生的输出以及你对它的评论或说明。此外，你还可以立即将其转换成一个看起来不错的文档。
- en: 2.2 Use R with RStudio
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 使用 RStudio 中的 R
- en: 2.2.1 The RStudio environment
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 RStudio 环境
- en: R itself is a relatively small application with next to no user interface. Everything
    works through a command line, or *console*. At its most basic, you launch it from
    your Terminal application (on a Mac) or Command Prompt (on Windows) by typing
    `R`. Once launched, R awaits your instructions at a command line of its own, denoted
    by the right angle bracket symbol, `>`. When you type an instruction and hit return,
    R interprets it and sends any resulting output back to the console.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: R 本身是一个相对较小的应用程序，几乎没有用户界面。所有操作都通过命令行或*控制台*进行。最基本的，你可以通过在终端应用程序（在 Mac 上）或命令提示符（在
    Windows 上）中输入 `R` 来启动它。一旦启动，R 就会在自己的命令行上等待你的指令，由右箭头符号 `>` 表示。当你输入指令并按回车键时，R 会解释它并将任何结果输出返回到控制台。
- en: 'Figure 2.2: Bare-bones R running from the Terminal.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：从终端运行的裸骨 R。
- en: '![Bare-bones R running from the Terminal.](../Images/f7cb8f4fd5b5c80f5f4080a8be3c777e.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![从终端运行的裸骨 R。](../Images/f7cb8f4fd5b5c80f5f4080a8be3c777e.png)'
- en: In addition to interacting with the console, you can also write your code in
    a text file and send that to R all at once. You can use any good text editor to
    write your `.r` scripts. But although a plain text file and a command line is
    the absolute minimum you need to work with R, it is a rather spartan arrangement.
    We can make life easier for ourselves by using [RStudio](https://rstudio.com).
    RStudio is an “integrated development environment”, or IDE. It is a separate application
    from R proper. When launched, it starts up an instance of R’s console inside of
    itself. It also conveniently pulls together various other elements to help you
    get your work done. These include the document where you are writing your code,
    the output it produces, and R’s help system. RStudio also knows about RMarkdown,
    and understands a lot about the R language and the organization of your project.
    When you launch RStudio, it should look much like Figure [2.3](gettingstarted.html#fig:ch-02-rstudio1).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与控制台交互外，你还可以在文本文件中编写你的代码，并将整个文件一次性发送给R。你可以使用任何好的文本编辑器来编写你的`.r`脚本。但是，尽管纯文本文件和命令行是使用R所需的绝对最小配置，但它是一种相当简朴的安排。我们可以通过使用[RStudio](https://rstudio.com)来使生活变得更简单。RStudio是一个“集成开发环境”，或IDE。它是一个与R本身分开的应用程序。当启动时，它会在自身内部启动R控制台的一个实例。它还方便地汇集了各种其他元素来帮助你完成工作。这些包括你编写代码的文档、它产生的输出以及R的帮助系统。RStudio还了解RMarkdown，并且对R语言和你的项目组织有深入了解。当你启动RStudio时，它应该看起来与图[2.3](gettingstarted.html#fig:ch-02-rstudio1)非常相似。
- en: '![The RStudio IDE.](../Images/a0414452145bf50b63b622bdb5f88caa.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![RStudio IDE.](../Images/a0414452145bf50b63b622bdb5f88caa.png)'
- en: 'Figure 2.3: The RStudio IDE.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：RStudio IDE。
- en: 2.2.2 Create a project
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 创建项目
- en: To begin, create a project. From the menu, choose File > New Project … from
    the menu bar, choose the New Directory option, and create the project.You can
    create your new project wherever you like—most commonly it will go somewhere in
    your Documents folder. Once it is set up, create an RMarkdown file in the directory,
    with File > New File > RMarkdown. This will give you a set of choices including
    the default “Document”. The `socviz` library comes with a small RMarkdown template
    that follows the structure of this book. To use it instead of the default document,
    after selecting File > New File > RMarkdown, choose the “From Template” option
    in the sidebar of the dialog box that appears. Then choose “Data Visualization
    Notes” from the resulting list of options. When the RMarkdown document appears,
    save it right away in your project folder, with File > Save. The `socviz` template
    contains a little bit of information about how RMarkdown works, together with
    some headers to get you started. Read what it has to say. Look at the code chunks
    and RMarkdown formatting. Experiment with knitting the document, and compare the
    output to the content of the plain text document.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个项目。从菜单中选择文件 > 新建项目 … 从菜单栏中选择新建目录选项，并创建项目。你可以将新项目创建在任何你喜欢的位置——最常见的是它会在你的文档文件夹中。一旦设置好，在该目录中创建一个RMarkdown文件，方法是文件
    > 新建文件 > RMarkdown。这将为你提供一系列选择，包括默认的“文档”。`socviz`库附带了一个小型RMarkdown模板，该模板遵循本书的结构。要使用它而不是默认文档，在选择了文件
    > 新建文件 > RMarkdown之后，在出现的对话框侧边栏中选择“从模板”选项。然后从结果选项列表中选择“数据可视化笔记”。当RMarkdown文档出现时，立即使用文件
    > 保存将其保存在你的项目文件夹中。`socviz`模板包含了一些关于RMarkdown如何工作的信息，以及一些帮助你开始的头信息。阅读它所说的话。查看代码块和RMarkdown格式。尝试编织文档，并将输出与纯文本文档的内容进行比较。
- en: RMarkdown is not required for R. An alternative is to use an R script, which
    just contains R commands only.You can create an r script via File > New File >
    R Script. R script files conventionally have the extension `.r` or `.R`. (RMarkdown
    files conventionally end in `.Rmd`.) A very brief project might just need a single
    `.r` file. But RMarkdown is very useful for documents, notes, or reports of any
    length, especially when you need to take notes. If you do use an `.r` file you
    can leave comments or notes to yourself by starting a line with the hash character,
    `#`. You can also add comments at the end of lines in this way, as for any particular
    line R will ignore whatever code or text that appears after a `#`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: RMarkdown 不是 R 的必需品。一个替代方案是使用 R 脚本，它只包含 R 命令。你可以通过 File > New File > R Script
    创建一个 R 脚本。R 脚本文件通常有 `.r` 或 `.R` 的扩展名。（RMarkdown 文件通常以 `.Rmd` 结尾。）一个非常简单的项目可能只需要一个
    `.r` 文件。但 RMarkdown 对于任何长度和内容的文档、笔记或报告都非常有用，尤其是当你需要做笔记时。如果你使用 `.r` 文件，你可以通过在行首使用井号字符
    `#` 来给自己留下注释或笔记。你也可以以这种方式在行尾添加注释，就像对于任何特定的行，R 会忽略 `#` 之后出现的任何代码或文本。
- en: RStudio has various keyboard and menu shortcuts to help you edit code and text
    quickly. For example you can insert chunks of code in your RMarkdown document
    with a keyboard shortcut.`Command+Option+I` on MacOS. `Ctrl+Alt+I` on Windows.
    This saves you from writing the backticks and braces every time. You can run the
    current line of code with a shortcut, too.`Command+Enter` on MacOS. `Alt+Enter`
    on Windows. A third shortcut gives you a pop-over display with summary of many
    other useful keystroke combinations.`Option+Shift+K` on MacOS. `Alt-Shift-K` on
    Windows. RMarkdown documents can include all kinds of other options and formatting
    paraphernalia, from text formatting to cross-references to bibliographical information.
    But never mind about those for now.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio 有各种键盘和菜单快捷键来帮助你快速编辑代码和文本。例如，你可以使用键盘快捷键在 RMarkdown 文档中插入代码块。在 MacOS 上是
    `Command+Option+I`，在 Windows 上是 `Ctrl+Alt+I`。这样可以节省你每次都要写反引号和大括号的时间。你也可以使用快捷键运行当前行代码，在
    MacOS 上是 `Command+Enter`，在 Windows 上是 `Alt+Enter`。还有一个快捷键会给你一个弹出显示，其中包含许多其他有用的按键组合的摘要。在
    MacOS 上是 `Option+Shift+K`，在 Windows 上是 `Alt-Shift-K`。RMarkdown 文档可以包含所有种类的其他选项和格式化元素，从文本格式到交叉引用到参考文献信息。但现在不必担心这些。
- en: 'Figure 2.4: An RMarkdown file open in R Studio. The small icons in the top
    right-hand corner of each code chunk can be used to set options (the gear icon),
    run all chunks up to the current one (the downward-facing triangle), and just
    run the current chunk (the right-facing triangle).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：在 R Studio 中打开的 RMarkdown 文件。每个代码块右上角的小图标可以用来设置选项（齿轮图标），运行所有代码块直到当前一个（向下三角形），或者只运行当前代码块（向右三角形）。
- en: '![An RMarkdown file open in R Studio. The small icons in the top right-hand
    corner of each code chunk can be used to set options (the gear icon), run all
    chunks up to the current one (the downward-facing triangle), and just run the
    current chunk (the right-facing triangle).](../Images/778c59a11834942c702d99559e87754e.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![在 R Studio 中打开的 RMarkdown 文件。每个代码块右上角的小图标可以用来设置选项（齿轮图标），运行所有代码块直到当前一个（向下三角形），以及只运行当前代码块（向右三角形）](../Images/778c59a11834942c702d99559e87754e.png)'
- en: 'To make sure you are ready to go, load the `tidyverse` library. The tidyverse
    is a suite of related libraries for R developed by Hadley Wickham and others.
    The `ggplot2` library is one of its components. The other pieces make it easier
    to get data in to R and manipulate it once it is there. Either knit the notes
    file you created from the socviz template, or load the library manually at the
    console:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你已准备好开始，请加载 `tidyverse` 库。tidyverse 是由 Hadley Wickham 和其他人开发的一系列相关 R 库。`ggplot2`
    库是其组成部分之一。其他部分使将数据导入 R 和处理变得更容易。你可以从 socviz 模板创建的笔记文件中编织，或者手动在控制台中加载库：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We load the `socviz` library after the tidyverse. This library contains datasets
    that we will use throughout the book, along with some other tools that will make
    life a little easier. If you get an error message saying either library can’t
    be found, then re-read the “Before you Begin” section in the Preface to this book
    and follow the instructions there.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 tidyverse 之后加载 `socviz` 库。这个库包含了本书中我们将要使用的所有数据集，以及一些会使生活变得轻松的其他工具。如果你收到一个错误信息，说找不到任何一个库，那么请重新阅读本书前言中的“开始之前”部分，并按照那里的说明操作。
- en: You only need to *install* a library once, but you will need to *load* it at
    the beginning of each R session with `library()` if you want to use the tools
    it contains. In practice this means that the very first lines of your working
    file should contain a code chunk that loads the libraries you will need in the
    file. If you forget to do this, then R will be unable to find the functions you
    want to use later on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要安装一次库，但如果你想要使用它包含的工具，你需要在每个R会话的开始使用`library()`来加载它。实际上这意味着你工作文件中的第一行应该包含一个代码块，用于加载文件中需要的库。如果你忘记这样做，那么R将无法找到你稍后想要使用的函数。
- en: 2.3 Things to know about R
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 关于R的注意事项
- en: Any new piece of software takes a bit of getting used to. This is especially
    true when using an IDE to work in a language like R. You are getting oriented
    to the language itself (what happens at the console), while learning to take notes
    in what might seem like an odd format (chunks of code interspersed with plain-text
    comments), in an IDE that that has a many features designed to make your life
    easier in the long run, but which can be hard to decipher at the beginning. Here
    are some general points to bear in mind about how R is designed. They might help
    you get a feel for how the language works.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 任何新的软件都需要一段时间来适应。当你使用IDE在像R这样的语言中工作时，这一点尤其正确。你正在适应语言本身（控制台发生的事情），同时学习在可能看起来很奇怪的形式（代码块与纯文本注释交织）中做笔记，在一个旨在长期使你的生活更轻松的IDE中，但一开始可能很难理解。以下是一些关于R设计的通用要点，它们可能有助于你了解语言的工作方式。
- en: 2.3.1 Everything has a name
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 所有的东西都有一个名字
- en: In R, everything you deal with has a name. You refer to things by their names
    as you examine, use, or modify them. Named entities include variables (like `x`,
    or `y`), data that you have loaded (like `my_data`), and functions that you use.
    (More about functions momentarily.) You will spend a lot of time talking about,
    creating, referring to, and modifying things with names.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，你处理的所有东西都有一个名字。你通过名字来引用事物，无论是检查、使用还是修改它们。命名实体包括变量（如`x`或`y`）、你加载的数据（如`my_data`）以及你使用的函数。（关于函数的更多信息稍后提供。）你将花费大量时间讨论、创建、引用和修改带有名字的事物。
- en: Some names are forbidden. These include reserved words like `FALSE` and `TRUE`,
    core programming words like `Inf`, `for`, `else`, `break`, `function`, and words
    for special entities like `NA` and `NaN`. (These last two are codes designating
    missing data and “Not a Number”, respectively.) You probably won’t use these names
    by accident, but it’s good do know that they are not allowed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一些名字是被禁止的。这包括像`FALSE`和`TRUE`这样的保留词，像`Inf`、`for`、`else`、`break`、`function`这样的核心编程词，以及像`NA`和`NaN`这样的特殊实体词。（最后两个是表示缺失数据和“不是一个数字”的代码。）你可能不会意外地使用这些名字，但了解它们是不被允许的是好的。
- en: Some names you should not use, even if they are technically permitted. These
    are mostly words that are already in use for objects or functions that form part
    of the core of R. These include the names of basic functions like `q()` or `c()`,
    common statistical functions like `mean()`, `range()` or `var()`, and built-in
    mathematical constants like `pi`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一些名字你不应该使用，即使它们在技术上是被允许的。这些名字大多已经用于构成R核心部分的物体或函数。这包括像`q()`或`c()`这样的基本函数，像`mean()`、`range()`或`var()`这样的常见统计函数，以及像`pi`这样的内置数学常数。
- en: Names in R are case sensitive. The object `my_data` is not the same as the object
    `My_Data`. When choosing names for things, be concise, consistent, and informative.
    Follow the style of the tidyverse and name things in lower case, separating words
    with the underscore character, `_`, as needed. Do not use spaces when naming things,
    including variables in your data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: R中的名字是区分大小写的。对象`my_data`与对象`My_Data`不同。在为事物选择名字时，要简洁、一致且具有信息性。根据tidyverse的风格，将事物命名为小写，根据需要使用下划线字符`_`分隔单词。在命名事物时不要使用空格，包括你的数据中的变量。
- en: 2.3.2 Everything is an object
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 所有的东西都是对象
- en: Some objects are built in to R, some are added via libraries, and some are created
    by the user. But almost everything is some kind of object. The code you write
    will create, manipulate, and use named objects as a matter of course. We can start
    immediately. Let’s create a vector of numbers. The command `c()` is a function.
    It’s short for “combine” or “concatenate”. It will take a sequence of comma-separated
    things inside the parentheses and join them together into a vector where each
    element is still individually accessible.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些对象是R内置的，一些是通过库添加的，还有一些是由用户创建的。但几乎一切都是某种对象。你编写的代码将创建、操作和使用命名对象，这是理所当然的。我们可以立即开始。让我们创建一个数字向量。`c()`是一个函数。它代表“组合”或“连接”。它将括号内以逗号分隔的一系列事物连接起来，形成一个向量，其中每个元素仍然可以单独访问。
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead of sending the result to the console, we can instead *assign* it to
    an object we createYou can type the arrow using `<` and then `-`.:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将结果发送到控制台，而不是将其*分配*给我们创建的对象。你可以使用`<`和`-`来输入箭头：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To see what you made, type the name of the object and hit return:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你创建的内容，请输入对象的名称并按回车键：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each of our numbers is still there, and can be accessed directly if we want.
    They are now just part of a new object, a vector, called `my_numbers`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有数字仍然在那里，如果我们想直接访问它们，也是可以的。现在它们只是新对象，即向量`my_numbers`的一部分。
- en: 'You create objects by assigning them to names. The *assignment operator* is
    `<-`. Think of assignment as the verb “gets”, reading left to right. So, the bit
    of code above can be read as “The object `my_numbers` gets the result of concatenating
    the following numbers: 1, 2, …” TheIf you only learn one keyboard shortcut in
    RStudio make it this one! Always use `Option+minus` on MacOS or `Alt+minus` on
    Windows to type the assignment operator. operator is two separate keys on your
    keyboard: the `<` key and the `-` (minus) key. Because you type this so often
    in R, there is a shortcut for it in R Studio. To write the assignment operator
    in one step, hold down the `option` key and hit `-`. On Windows hold down the
    `alt` key and hit `-`. You will be constantly creating objects in this way, and
    trying typing the two characters separately is both tedious and prone to error.
    You will make hard-to-notice mistakes like typing `< -` (with a space in between
    the characters) instead of `<-`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过将对象分配给名称来创建对象。*赋值运算符*是`<-`。将赋值看作是“得到”这个动词，从左到右读取。因此，上面的代码片段可以读作：“对象`my_numbers`得到了以下数字连接的结果：1,
    2, …”赋值运算符是键盘上的两个独立键：`<`键和`-`（减号）键。因为你在R中经常输入这个，R Studio中有一个快捷键。要一步写出赋值运算符，请按住`option`键并敲击`-`。在Windows上，请按住`alt`键并敲击`-`。你将不断地以这种方式创建对象，单独输入这两个字符既麻烦又容易出错。你可能会犯一些难以察觉的错误，比如输入`<
    -`（字符之间有空格）而不是`<-`。
- en: When you create objects by assigning things to names, they come into existence
    in R’s *workspace* or *environment*. You can think of this most straightforwardly
    as your project directory. Your workspace is specific to your current project.
    It is the folder from which you launched R. Unless you have particular needs (such
    as extremely large datasets or analytical tastes that take a very long time) you
    will not need to give any thought to where objects “really” live. Just think of
    your code and data files as the permanent features of your project. When you start
    up an R project, you will generally begin by loading your data. That is, you will
    read it in from disk and assign it to a named object like `my_data`. The rest
    of your code will be a series of instructions to act on and create more named
    objects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过将事物分配给名称来创建对象时，它们在R的*工作区*或*环境*中存在。你可以最直接地将其视为你的项目目录。你的工作区是特定于你的当前项目的。它是你启动R的文件夹。除非你有特殊需求（例如，非常大的数据集或需要非常长时间的分析口味），你不需要考虑对象“真正”在哪里。只需将你的代码和数据文件视为项目的永久特征。当你启动一个R项目时，你通常首先加载数据。也就是说，你会从磁盘读取它并将其分配给一个名为`my_data`的命名对象。你其余的代码将是一系列指令，用于操作和创建更多的命名对象。
- en: 2.3.3 You do things using functions
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 使用函数进行操作
- en: '![Upper: What functions look like, very schematically. Lower: an imaginary
    function that takes two vectors and plots them with a title. We supply the function
    with the particular vectors we want it to use, and the title. The vectors are
    objects, so are given as-is. The title is not an object, so we enclose it in quotes.](../Images/7a6859d77a6a3eaf81c369f8905db946.png)
    Figure 2.5: Upper: What functions look like, very schematically. Lower: an imaginary
    function that takes two vectors and plots them with a title. We supply the function
    with the particular vectors we want it to use, and the title. The vectors are
    objects, so are given as-is. The title is not an object, so we enclose it in quotes.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![上图：函数的外观，非常简略。下图：一个想象中的函数，它接受两个向量并将它们以标题的形式绘制出来。我们向函数提供它想要使用的特定向量以及标题。向量是对象，所以直接给出。标题不是对象，所以我们用引号括起来。](../Images/7a6859d77a6a3eaf81c369f8905db946.png)
    图2.5：上图：函数的外观，非常简略。下图：一个想象中的函数，它接受两个向量并将它们以标题的形式绘制出来。我们向函数提供它想要使用的特定向量以及标题。向量是对象，所以直接给出。标题不是对象，所以我们用引号括起来。'
- en: You do almost everything in R using functions. Think of a function as a special
    kind of object that can perform actions for you. It produces output based on the
    input that it receives. Like a good dog, when we want a function to do something
    for us, we *call* it. Somewhat less like a dog, it will reliably do what we tell
    it. We give the function some information, it acts on that information, and some
    results come out the other side. Functions can be recognized by the parentheses
    at the end of their names. This distinguishes them from other objects, such as
    single numbers, named vectors, tables of data, and so on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎在 R 中使用函数做所有事情。将函数视为一种可以为你执行动作的特殊类型的对象。它根据接收到的输入产生输出。像一只好狗一样，当我们想让函数为我们做某事时，我们
    *调用* 它。它不像狗那么少，它会可靠地执行我们告诉它的事情。我们给函数一些信息，它根据这些信息行动，然后从另一边产生一些结果。函数可以通过其名称末尾的括号来识别。这使它们与其他对象区分开来，例如单个数字、命名向量、数据表等。
- en: 'The parentheses are what allow you to send information to the function. Most
    functions accept one or more named *arguments*. A function’s arguments are the
    things it needs to know in order to do something. They can be some bit of your
    data (`data = my_numbers`), or specific instructions (`title = "GDP per Capita"`),
    or an option you want to choose (`smoothing = "splines", show = FALSE`). For example,
    the object `my_numbers` is a numeric vector:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 括号允许你向函数发送信息。大多数函数接受一个或多个命名 *参数*。函数的参数是它需要知道以便执行某事的东西。它们可以是你的数据的一部分（`data =
    my_numbers`），或特定的指令（`title = "GDP per Capita"`），或你想要选择的选项（`smoothing = "splines",
    show = FALSE`）。例如，对象 `my_numbers` 是一个数值向量：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: But the thing we used to create it, `c()`, is a function. It concatenates items
    into a vector composed of the series of comma-separated elements you give it.
    Similarly, `mean()` is a function that calculates a simple average for a vector
    of numbers. What happens if we just type `mean()` without any arguments inside
    the parentheses?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们用来创建它的东西，`c()`，是一个函数。它将项目连接成一个由你给出的逗号分隔的元素序列组成的向量。同样，`mean()` 是一个计算数字向量简单平均值的函数。如果我们只输入
    `mean()` 而不提供任何括号内的参数，会发生什么？
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The error message is terse but informative. The function needs an argument
    to work, and we haven’t given it one. In this case, ‘x’, the name of another object
    that `mean()` can perform its calculation on:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息简洁但信息丰富。函数需要一个参数来工作，而我们没有提供。在这种情况下，‘x’，是另一个`mean()`可以执行其计算的对象的名称：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'While the function arguments have names that are used internally, (here, `x`),
    you don’t strictly need to specify the name for the function to work:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数参数有内部使用的名称（这里，`x`），但你并不严格需要指定名称来使函数工作：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you omit the name of the argument, R will just assume you are giving the
    function what it needs, and in a default order. The documentation for a function
    will tell you what the order of required arguments is for any particular function.See
    the Appendix for a guide to how to read the help page for a function. For simple
    functions that only require one or two arguments, omitting their names is usually
    not confusing. For more complex functions, you will typically want to use the
    names of the arguments rather than try to remember what the ordering is.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你省略了参数的名称，R 会假设你正在按照默认顺序提供函数所需的参数。函数的文档会告诉你任何特定函数所需参数的顺序。参见附录，了解如何阅读函数的帮助页面。对于只需要一个或两个参数的简单函数，省略它们的名称通常不会造成混淆。对于更复杂的函数，你通常会希望使用参数的名称，而不是试图记住它们的顺序。
- en: In general, when providing arguments to a function the syntax is `<argument>
    = <value>`. If `<value>` is a named *object* that already exists in your workspace,
    like a vector of numbers of a table of data, then you provide it unquoted, as
    in `mean(my_numbers)`. If `<value>` is not an object, a number, or a logical value
    like `TRUE`, then you usually put it in quotes, e.g., `labels(x = "X Axis Label")`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在向函数提供参数时，语法是 `<argument> = <value>`。如果 `<value>` 是已经存在于你的工作空间中的命名 *对象*，比如数字向量或数据表，那么你提供它时不需要引号，例如
    `mean(my_numbers)`。如果 `<value>` 不是一个对象、一个数字或像 `TRUE` 这样的逻辑值，那么你通常需要用引号括起来，例如 `labels(x
    = "X Axis Label")`。
- en: Functions take inputs via their arguments, do something, and return outputs.
    What the output is depends on what the function does. The `c()` function takes
    a sequence of comma-separated elements and returns a vector consisting of those
    same elements. The `mean()` function takes a vector of numbers and returns a single
    number, their average. Functions can return far more than single numbers. The
    output returned by functions can be a table of data, or a complex object such
    as the results of a linear model, or the instructions needed to draw a plot on
    the screen (as we shall see). They can even be other functions. For example, the
    `summary()` function performs a series of calculations on a vector and produces
    what is in effect a little table with named elements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通过它们的参数接收输入，执行某些操作，并返回输出。输出的内容取决于函数执行的操作。`c()` 函数接收一系列以逗号分隔的元素，并返回一个包含这些相同元素的向量。`mean()`
    函数接收一个数字向量，并返回一个单一数字，即它们的平均值。函数可以返回比单一数字更多的内容。函数返回的输出可以是数据表，或者是一个复杂对象，如线性模型的输出，或者是在屏幕上绘制图形所需的指令（我们将会看到）。它们甚至可以是其他函数。例如，`summary()`
    函数对一个向量执行一系列计算，并生成一个实际上带有命名元素的简表。
- en: A function’s argument names are internal to that function. Say you have created
    an object in your environment named `x`, for example. A function like `mean()`
    also has a named argument, `x`, but R will not get confused by this. It will not
    use your `x` object by mistake.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数名称是该函数内部的。比如说，你在你的环境中创建了一个名为 `x` 的对象，例如。像 `mean()` 这样的函数也有一个名为 `x` 的命名参数，但
    R 不会因此混淆。它不会错误地使用你的 `x` 对象。
- en: 'As we have already seen with `c()` and `mean()`, you can assign the result
    of a function to an object:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经通过 `c()` 和 `mean()` 看到的，你可以将函数的结果赋值给一个对象：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you do this, there’s no output to the console. R just puts the results
    into the new object, as you instructed. To look inside the object you can type
    its name and hit return:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，控制台没有输出。R 只是将结果放入你指定的新的对象中。要查看对象的内容，你可以输入它的名字并按回车键：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 2.3.4 Functions come in libraries
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 函数来自库
- en: The code you write will be more or less complex depending on the task you want
    to accomplish. Once you have gotten used to working in R, you will probably end
    up writing your own functions to produce the results that you need. But as with
    other programming languages, you will not have to do everything yourself. Families
    of useful functions are bundled into libraries that you can install, load into
    your R session, and make use of as you work. Libraries save you from reinventing
    the wheel. They make it so that you do not, for example, have to figure out how
    to write code from scratch to draw a shape on screen, or load a data file into
    memory. Libraries are also what allow you to build on the efforts of others in
    order to do your own work. Ggplot is a library of functions. There are many other
    such libraries and we will make use of several throughout this book, either by
    loading them with the `library()` function, or “reaching in” to them and pulling
    a useful function from them directly. Writing code and functions of your own is
    a good way to get a sense of the amazing volume of effort put into R and its associated
    toolkits, work freely contributed by many hands over the years and available for
    anyone to use.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的代码的复杂程度将取决于你想要完成的任务。一旦你习惯了在R中工作，你可能会最终编写自己的函数来生成你需要的输出。但与其他编程语言一样，你不必事事亲力亲为。有用的函数系列被打包成库，你可以安装这些库，将它们加载到你的R会话中，并在工作中使用它们。库可以帮助你避免重复造轮子。它们使得你不必，例如，从头开始编写代码来在屏幕上绘制形状，或加载数据文件到内存中。库还允许你利用他人的努力来开展自己的工作。Ggplot是一个函数库。还有许多其他这样的库，我们将在本书中多次使用它们，要么通过使用`library()`函数加载它们，要么“深入”到它们中直接提取有用的函数。编写自己的代码和函数是了解投入R及其相关工具包中的惊人工作量的一种好方法，这是多年来许多人的自由贡献，任何人都可以使用。
- en: All of the visualization we will do will involve choosing the right function
    or functions, and then giving those functions the right instructions through a
    series of named arguments. Most of the mistakes we will make, and the errors we
    will fix, will involve us having not picked the right function, or having not
    fed the function the right arguments, or having failed to provide information
    in a form the function can understand.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的所有可视化都将涉及选择正确的函数或函数集，然后通过一系列命名参数给这些函数提供正确的指令。我们将会犯的大多数错误，以及我们将要修复的错误，将涉及我们没有选择正确的函数，或者没有向函数提供正确的参数，或者没有以函数可以理解的形式提供信息。
- en: For now, just remember that you do things in R by creating and manipulating
    named objects. You manipulate objects by feeding information about them to functions.
    The functions do something useful with that information (calculate a mean, recode
    a variable, fit a model) and give you the results back.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需记住，你在R中通过创建和操作命名对象来完成事情。你通过向函数提供有关对象的信息来操作对象。函数会使用这些信息做些有用的事情（计算平均值、重新编码变量、拟合模型）并将结果返回给你。
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first two functions here gave us a simple table of counts and calculated
    the standard deviation of `my_numbers`. It’s worth noticing what R did in the
    last three cases. First we multiplied `my_numbers` by two. R interprets that as
    you asking it to take each *element* of `my_numbers` one at a time and multiply
    it by five. It does the same with the instruction `my_numbers + 1`. The single
    value is “recycled” down the length of the vector. By contrast, in the last case
    we add `my_numbers` to itself. Because the two objects being added are the same
    length, R adds each element in the first vector to the corresponding element in
    the second vector. This is an example of a *vectorized* operation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里前两个函数给我们提供了一个简单的计数表，并计算了`my_numbers`的标准差。值得注意的是R在最后三个案例中的行为。首先，我们将`my_numbers`乘以二。R解释为你要它逐个乘以`my_numbers`中的每个*元素*。它对指令`my_numbers
    + 1`也做了同样的事情。单个值被“回收”到向量的长度。相比之下，在最后一个案例中，我们将`my_numbers`加到它自己上。因为被加的两个对象长度相同，R将第一个向量中的每个元素加到第二个向量中相应的元素上。这是一个*向量化*操作的例子。
- en: 2.3.5 If you’re not sure what an object is, ask for its class
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 如果你不确定一个对象是什么，可以询问它的类别
- en: Every object has a *class*. This is the sort of object it is, whether a vector,
    a character string, a function, a list, and so on. Knowing an object’s class tells
    you a lot about what you can and can’t do with it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有一个*类别*。这是它的类型，无论是向量、字符字符串、函数、列表等等。了解一个对象的类别可以告诉你很多关于你可以用它做什么，不能做什么的信息。
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Certain actions you take may change an object’s class. For instance, consider
    `my_numbers` again:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您采取的某些操作可能会改变对象的类别。例如，再次考虑`my_numbers`：
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The function added the word “Apple” to our vector of numbers, as we asked. But
    in doing so, the result is that the new object also has a new class, switching
    from “numeric” to “character”. All the numbers are now enclosed in quotes. They
    have been turned into character strings. In that form, they can’t be used in calculations.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数按照我们的要求，在我们的数字向量中添加了单词“Apple”。但在这样做的时候，结果是新的对象也获得了一个新的类别，从“numeric”切换到“character”。所有的数字现在都被引号包围。它们已经被转换成了字符字符串。以这种形式，它们不能用于计算。
- en: Most of the work we’ll be doing will not involve directly picking out this or
    that value from vectors or other entities. Instead we will try to work at a slightly
    higher level that will be easier and safer. But it’s worth knowing just the very
    basicsThe Appendix has a little more discussion of the basics of selecting the
    elements within objects. of how elements of vectors can be referred to, because
    the c() function in particular is a useful tool.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要进行的多数工作不会直接从向量或其他实体中挑选出这个或那个值。相反，我们将尝试在一个稍微高一点的水平上工作，这将更容易也更安全。但了解如何引用向量元素的基础知识是值得的，因为c()函数尤其是一个有用的工具。
- en: 'We will spend a lot of time in this book working with a series of datasets.
    These typically start life as files stored locally on your computer or somewhere
    remotely accessible to you. Once they are imported into R, then like everything
    exist as objects of some kind. R has several classes of objects used to store
    data. A basic one is a matrix, which consists of rows and columns of numbers.
    But the most common kind of data object in R is a *data frame*, which you can
    think of as a rectangular table consisting of rows (of observations) and columns
    (of variables). In a data frame the columns can be of different classes. Some
    may be character strings, some numeric, and so on. For instance, here is a very
    small dataset from the `socviz` library:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将花费大量时间处理一系列数据集。这些数据集通常最初是存储在您的计算机本地或您可以远程访问的地方的文件。一旦它们被导入到R中，它们就像所有其他事物一样，以某种类型的对象存在。R有几种用于存储数据的对象类别。最基本的一种是矩阵，它由数字的行和列组成。但在R中最常见的数据对象类型是*数据框*，您可以将它想象成一个由行（观测值）和列（变量）组成的矩形表格。在数据框中，列可以是不同的类别。有些可能是字符字符串，有些是数值，等等。例如，这里是从`socviz`库中的一个非常小的数据集：
- en: '[PRE40]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this `titanic` data, two of the columns are numeric and two are not. You
    can access the rows and columns in various ways. For example, the `$` operator
    allows you to pick out a named column of a data frame:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`titanic`数据中，有两列是数值的，有两列不是。您可以通过各种方式访问行和列。例如，`$`运算符允许您选择数据框的命名列：
- en: '[PRE44]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In Appendix [A.1.2](appendix.html#app-select) there is a little more information
    about selecting particular elements from different kinds of objects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在附录[A.1.2](appendix.html#app-select)中有更多关于从不同类型的对象中选择特定元素的信息。
- en: 'We will also regularly encounter a slightly augmented version of a data frame
    called a *tibble*. The tidyverse libraries make extensive use of tibbles. Like
    data frames, they are used to store variables of different classes all together
    in a single table of data. They also do a little more to let us know about what
    they contain, and are a little more friendly when interacted with from the console.
    We can convert a data frame to a tibble if we want:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将经常遇到数据框的一个稍微增强的版本，称为*tibble*。tidyverse库广泛使用了tibbles。像数据框一样，它们用于将不同类别的变量全部存储在单个数据表中。它们还做了一些额外的工作，让我们了解它们包含的内容，并且在与控制台交互时更加友好。如果我们想，我们可以将数据框转换为tibble：
- en: '[PRE46]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Look carefully at the top and bottom of the output to see what additional information
    the tibble class gives you over and above the data frame version.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看输出顶部和底部，以了解tibble类别相对于数据框版本提供了哪些额外信息。
- en: 2.3.6 To see inside an object, ask for its structure
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.6 查看对象内部结构
- en: The `str()` function is sometimes useful. It lets you see what is inside an
    object.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`str()`函数有时很有用。它让您可以看到对象内部的内容。'
- en: '[PRE48]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Fair warning: while some objects are relatively simple (a vector is just a
    sequence of numbers), others are more complicated, so asking about their `str()`
    might output a forbidding amount of information to the console. In general, complex
    objects are organized collections of simpler objects, often assembled as a big
    list, sometimes with a nested structure. Think for example of a master to-do list
    for a complex activity like moving house. It might be organized into sub-tasks
    of different kinds, several of which would themselves have lists of individual
    items. One list of tasks might be related to scheduling the moving truck, another
    might cover things to be donated, and a third list of tasks might be related to
    setting up utilities at the new house. In a similar sort of way, the objects we
    create to make plots will have many parts and sub-parts, as the overall task of
    drawing a plot has many individual to-do items. But we will be able to build these
    objects up from simple forms through a series of well-defined steps. And unlike
    moving house, the computer will take care of actually carrying out the task for
    us. We just need to get the to-do list right.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒：虽然有些对象相对简单（向量只是一串数字的序列），但其他对象更复杂，所以询问它们的`str()`可能会在控制台输出大量的信息。一般来说，复杂对象是简单对象的有序集合，通常作为一个大列表组装，有时具有嵌套结构。例如，考虑一个复杂活动（如搬家）的主待办事项列表。它可能被组织成不同种类的子任务，其中一些子任务本身可能有单独项目的列表。一个任务列表可能与调度搬家卡车有关，另一个可能涉及要捐赠的东西，第三个任务列表可能与在新房子里设置公用事业有关。以类似的方式，我们创建用于制作图表的对象将有许多部分和子部分，因为绘制图表的整体任务有许多单独的待办事项。但我们将能够通过一系列定义良好的步骤从简单形式构建这些对象。而且与搬家不同，计算机将为我们执行实际的任务。我们只需要确保待办事项列表正确。
- en: 2.4 Be patient with R, and with yourself
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 对R和对自己要有耐心
- en: Like all programming languages, R does exactly what you tell it to, rather than
    exactly what you want it to. This can make it frustrating to work with. It is
    as if one had an endlessly energetic, powerful, but also extremely literal-minded
    robot to order around. Remember that no-one writes fluent, error-free code on
    the first go all the time. From simple typos to big misunderstandings, mistakes
    are a standard part of the activity of programming. This is why error-checking,
    debugging, and testing are also a central part of programming. So, just try to
    be patient with yourself and with R while you use it. Expect to make errors, and
    don’t worry when that happens. You won’t break anything. Each time you figure
    out why a bit of code has gone wrong you will have learned a new thing about how
    the language works.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有编程语言一样，R会按照您告诉它的去做，而不是按照您希望它做的去做。这可能会让人感到沮丧。这就像有一个永无止境的、强大的、但同时也非常字面意思的机器人来指挥。请记住，没有人总是第一次就能写出流畅且无错误的代码。从简单的打字错误到大的误解，错误是编程活动中的标准部分。这就是为什么错误检查、调试和测试也是编程的核心部分。所以，当您使用R时，请尽量对自己和R有耐心。预期会犯错误，当这种情况发生时，不要担心。您不会破坏任何东西。每次您弄清楚为什么一段代码出了问题，您就会对语言的工作方式有新的了解。
- en: 'Here are three very specific things to watch out for:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三件非常具体的事情需要注意：
- en: Make sure parentheses are balanced and that every opening “`(`” has a corresponding
    closing “`)`”.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保括号平衡，并且每个开头的“`(`”都有一个相应的结尾“`)`”。
- en: Make sure you complete your expressions. If you think you have completed typing
    your code, but instead of seeing the `>` command prompt at the console you see
    the `+` character instead, that may mean R thinks you haven’t written a complete
    expression yet. You can hit `Esc` or `Ctrl-C` to force your way back to the console
    and try typing your code again.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您完成了表达式。如果您认为您已经完成了代码的输入，但在控制台看到的是`>`命令提示符而不是`+`字符，这可能意味着R认为您还没有写完一个完整的表达式。您可以按`Esc`或`Ctrl-C`强制回到控制台并再次尝试输入代码。
- en: 'In ggplot specifically, as you will see, we will build up plots a piece at
    a time by adding expressions to one another. When doing this, make sure your `+`
    character goes at the end of the line, and not the beginning. That is, write this:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ggplot中特别地，正如您将看到的，我们将通过一次添加一个表达式来逐步构建图表。在这个过程中，请确保您的`+`字符位于行尾，而不是行首。也就是说，这样写：
- en: '[PRE52]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'and not this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是这样：
- en: '[PRE53]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: R Studio will do its best to help you with the task of writing your code. It
    will highlight your code by syntax; it will try to match characters (like parentheses)
    that need to be balanced; it will try to narrow down the source of errors in code
    that fails to run; it will try to auto-complete the names of objects you type,
    so that you make fewer typos; it will make help files more easily accessible and
    the arguments of functions directly available. Go slowly and see how the software
    is trying to help you out.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: R Studio会尽其所能帮助你完成编写代码的任务。它会通过语法高亮你的代码；它会尝试匹配需要平衡的字符（如括号）；它会尝试缩小代码运行失败时的错误来源；它会尝试自动完成你输入的对象名称，这样你可以减少输入错误；它会使得帮助文件更容易访问，并且函数的参数直接可用。慢慢来，看看软件是如何试图帮助你解决问题的。
- en: 2.5 Get data into R
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 将数据导入R
- en: Before we can plot anything at all we have to get our data into R in a format
    it can use. Cleaning and reading in your data is one of the least immediately
    satisfying pieces of an analysis, whether you use R, StataThese are all commercial
    software applications for statistical analysis. Stata, in particular, is in wide
    use across the social sciences., SAS, SPSS, or any other statistical software.
    This is the reason that many of the datasets for this book are provided in a pre-prepared
    form via the `socviz` library rather than as data files you must manually read
    in. However, it is something you will have to face, and that you will want to
    do, sooner rather than later if you want to use the skills you learn in this book.
    We might as well see how to do it now. Even when learning R, it can be useful
    and very motivating to try out the code on your own data rather than working with
    the sample datasets.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够绘制任何东西之前，我们必须将数据以R能够使用的形式导入到R中。清洗和读取数据是分析中最不令人满意的部分之一，无论你使用R、Stata、SAS、SPSS还是任何其他统计软件。这也是为什么本书中的许多数据集都是通过`socviz`库以预准备的形式提供的，而不是作为你必须手动读取的数据文件。然而，这是你必须面对的事情，也是你想要尽早而不是晚些时候去做的事情，如果你想要使用本书中学到的技能。我们不妨现在就看看如何操作。即使在学习R的过程中，尝试使用自己的数据而不是样本数据集来运行代码也是非常有用和鼓舞人心的。
- en: Use the `read_csv()` function to read in comma separated data. This function
    is in the `readr` library, one of the pieces of the tidyverse. R and the tidyverse
    also have functions to import various Stata, SAS, and SPSS formats directly. These
    can be found in the `haven` library. All we need to do is point `read_csv()` at
    a file. This can be a local file, e.g. in a subdirectory called `data/`, or it
    can be a remote file. If `read_csv()` is given a URL or ftp address it will follow
    it automatically. In this example, we have a CSV file called `organdonation.csv`
    stored at a remote location. While online, we assign the URL for the file to an
    object, for convenience, and then tell `read_csv()` to fetch it for us and put
    it in an object named `organs`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`read_csv()`函数读取以逗号分隔的数据。这个函数位于`tidyverse`的一部分，即`readr`库中。R和`tidyverse`还有直接导入各种Stata、SAS和SPSS格式的函数。这些可以在`haven`库中找到。我们只需要将`read_csv()`指向一个文件。这可以是一个本地文件，例如在名为`data/`的子目录中，或者它可以是远程文件。如果`read_csv()`被赋予一个URL或ftp地址，它将自动跟随。在这个例子中，我们有一个名为`organdonation.csv`的CSV文件，存储在远程位置。当在线时，我们将文件的URL分配给一个对象，以便方便，然后告诉`read_csv()`为我们获取它并将其放入名为`organs`的对象中。
- en: '[PRE54]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The resulting message at the console tells us the `read_csv()` function has
    assigned a class to each of the columns of the object it created from the CSV
    file. There are columns with integer values, some are character strings, and so
    on. (The `double` class is for numbers other than integers.) Part of the reason
    `read_csv()` is telling you this information is that it is helpful to know what
    class each column, or variable, is. A variable’s class determines what sort of
    operations can be performed on it. You also see this information because the tidyverse’s
    `read_csv()` (with an underscore character in the middle of its name) is more
    opinionated than an older, and also still very widely-used function, `read.csv()`
    (with a period in the middle of its name). The newer `read_csv()` will not classify
    variables as factors unless you tell it to. This is in contrast to the older function,
    which treats any vector of characters as a factor unless told otherwise. Factors
    have some very useful features in R (especially when it comes to representing
    various kinds of treatment and control groups in experiments), but they often
    trip up users who are not fully aware of them. Thus, `read_csv()` avoids them
    unless you explicitly say otherwise.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出的结果告诉我们，`read_csv()` 函数已经将一个类别分配给了从 CSV 文件创建的对象的每一列。这些列包含整数值，一些是字符字符串，等等。（`double`
    类用于非整数的数字。）`read_csv()` 告诉你这些信息的一部分原因是因为知道每一列或变量的类别是有帮助的。一个变量的类别决定了可以对其执行的操作类型。你也能看到这些信息，因为
    tidyverse 的 `read_csv()`（其名称中间有一个下划线字符）比一个较老且仍然非常广泛使用的函数 `read.csv()`（其名称中间有一个点字符）更有观点。新的
    `read_csv()` 除非你明确告诉它，否则不会将变量分类为因子。这与较老的函数形成对比，后者除非明确告知，否则将任何字符向量视为因子。因子在 R 中有一些非常有用的特性（尤其是在表示实验中的各种处理组和对照组时），但它们经常让那些不完全了解它们的人感到困惑。因此，`read_csv()`
    除非你明确表示，否则会避免使用因子。
- en: R can read in data files in many different formats. The `haven` package is part
    of the tidyverse. It provides functions to read files created in a variety of
    commercial software packages.R can also talk directly to databases, a topic not
    covered here. If your dataset is a Stata `.dta` file, for instance, you can use
    the `read_dta()` function in much the same way as we used `read_csv()` above.
    This function can read and write variables stored as logical values, integers,
    numbers, characters and factors. Stata also has a *labelled* data class that the
    haven library partially supports.See haven’s documentation for more details. In
    general you will end up converting labelled variables to one of R’s basic classes.
    Stata also supports an extensive coding scheme for missing data. This is generally
    not used directly in R, where missing data is coded simply as `NA`. Again, you
    will need to take care that any labelled variables imported into R are coded properly,
    so that you do not end up mistakenly using missing data in your analysis.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: R 可以读取多种不同格式的数据文件。`haven` 包是 tidyverse 的一部分。它提供了读取由各种商业软件包创建的文件的函数。R 还可以直接与数据库通信，这不是本节的内容。例如，如果你的数据集是一个
    Stata `.dta` 文件，你可以像我们上面使用 `read_csv()` 一样使用 `read_dta()` 函数。这个函数可以读取和写入存储为逻辑值、整数、数字、字符和因子的变量。Stata
    还有一个 *标记的* 数据类别，haven 库部分支持。有关更多详细信息，请参阅 haven 的文档。通常，你最终会将标记变量转换为 R 的基本类别之一。Stata
    还支持一个广泛的数据编码方案，用于缺失数据。这通常在 R 中不直接使用，在 R 中缺失数据简单地编码为 `NA`。同样，你需要注意，任何导入到 R 中的标记变量都应正确编码，以免在分析中错误地使用缺失数据。
- en: When preparing your data for use in R, and in particular for graphing with `ggplot`,
    bear in mind that it is best if it is represented in a “tidy” format. Essentially
    this means that your data should be in *long* rather than *wide* format, with
    every observation a row and every variable a column. We will discuss this in more
    detail in Chapter [3](makeplot.html#makeplot), and you can also consult the discussion
    of tidy data in the Appendix.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备在 R 中使用数据，特别是使用 `ggplot` 进行绘图时，请记住，最好以“整洁”格式表示。本质上这意味着你的数据应该以 *长* 格式而不是
    *宽* 格式，每个观测值一行，每个变量一列。我们将在第 [3](makeplot.html#makeplot) 章节中更详细地讨论这个问题，你还可以参考附录中关于整洁数据的讨论。
- en: 2.6 Make your first figure
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 制作你的第一个图表
- en: That’s enough ground-clearing for now. Writing code can be frustrating, but
    it also allows you to do interesting things quickly. Since the goal of this book
    is not to teach you all about R, but just how to produce good graphics, we can
    postpone a lot of details until later (or indeed ignore them indefinitely). We
    will start as we mean to go on, by using a function to make a named object, and
    plot the result. We will use the Gapminder dataset, which you should already have
    available on your computer. We load the data with `library()` and take a look.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的准备工作已经足够了。编写代码可能会让人沮丧，但它也允许你快速完成有趣的事情。由于这本书的目标不是教你所有关于R的知识，而是教你如何制作好的图形，我们可以将很多细节推迟到以后（或者实际上无限期地忽略它们）。我们将从使用一个函数来创建一个命名对象，并绘制结果开始，这样我们就可以继续前进。我们将使用Gapminder数据集，你应该已经在你的电脑上准备好了。我们用`library()`加载数据，并查看一下。
- en: '[PRE57]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is a table of data about a large number of countries, each observed over
    several years. Let’s make a scatterplot with it. Type the code below and try to
    get a sense of what’s happening. Don’t worry too much yet about the details.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于大量国家数据的表格，每个国家观察了数年。让我们用这个数据制作一个散点图。输入下面的代码，并尝试感受一下正在发生的事情。现在不必过于担心细节。
- en: '[PRE59]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Figure 2.6: Life expectancy plotted against GDP per capita for a large number
    of country-years.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：为大量国家-年数据绘制的预期寿命与人均GDP的关系图。
- en: '![Life expectancy plotted against GDP per capita for a large number of country-years.](../Images/4bb84df38c71e2e6800e0eb2e04fdea8.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![为大量国家-年数据绘制的预期寿命与人均GDP的关系图](../Images/4bb84df38c71e2e6800e0eb2e04fdea8.png)'
- en: Not a bad start. Our graph is fairly legible, it has its axes informatively
    labeled, and it shows some sort of relationship between the two variables we have
    chosen. It could also be made better. Let’s learn more about how to improve it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个不错的开始。我们的图表相当清晰，它的轴上有信息性的标签，并且显示了我们所选择的两个变量之间的一些关系。它还可以做得更好。让我们学习更多关于如何改进它的方法。
- en: 2.7 Where to go next
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7 接下来去哪里
- en: You should go straight to the next Chapter. However, you could also spend a
    little more time getting familiar with R and RStudio. Some information in the
    Appendix to this book might already be worth glancing at, especially the additional
    introductory material on R, and the discussion there about some common problems
    that tend to happen when reading in your own data. There`swirlstats.com` are several`tryr.codeschool.com`
    free or initially free online introductions`datacamp.com` to the R language that
    are worth trying. You do not need to know the material they cover in order to
    keep going with this book, but you might find one or more of them useful. If you
    get a little bogged down in any of them, or find the examples they choose are
    not that relevant to you, don’t worry. These introductions tend to want to introduce
    you to a range of programming concepts and tools that we will not need right away.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该直接进入下一章。然而，你也可以花更多的时间熟悉R和RStudio。这本书附录中的一些信息可能已经值得浏览，特别是关于R的额外入门材料，以及其中关于在读取自己的数据时可能遇到的一些常见问题的讨论。在`swirlstats.com`有多个`tryr.codeschool.com`免费或最初免费的在线R语言介绍`datacamp.com`，值得一试。你不需要了解他们涵盖的材料才能继续阅读这本书，但你可能会发现其中之一或多个对你有帮助。如果你在其中的任何一个上遇到了困难，或者发现他们选择的例子与你不太相关，不要担心。这些介绍倾向于介绍你一系列编程概念和工具，而我们目前并不需要它们。
- en: It is also worth familiarizing yourself a little with how RStudio works and
    with what it can do for you. The RStudio website`rstudio.com` has a great deal
    of introductory material to help you along. You can also find a number of handy
    cheat sheets there that summarize different pieces of RStudio, RMarkdown, and
    various tidyverse packages that we will use throughout the book.`rstudio.com/resources/cheatsheets`
    These cheat-sheets are not meant to teach you the material. But they are helpful
    points of reference once you are up and running.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 也有必要熟悉一下RStudio的工作方式和它能为你做什么。RStudio网站`rstudio.com`提供了大量的入门材料来帮助你。你还可以在那里找到许多实用的速查表，总结了RStudio、RMarkdown以及我们将在整本书中使用的各种tidyverse包的不同部分.`rstudio.com/resources/cheatsheets`这些速查表不是为了教你材料，但一旦你开始使用，它们是很有帮助的参考资料。
- en: 2.1 Work in plain text, using RMarkdown
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 使用纯文本，通过RMarkdown进行工作
- en: When taking notes, and when writing your own code, you should write plain text
    in a text editor. Do not use Microsoft Word or some other word processor. You
    may be used to thinking of your final outputs (e.g. a Word file, a PDF document,
    presentation slides, or the tables and figures you make) as what’s “real” about
    your project. Instead, it’s better to think of the data and code as what’s real,
    together with the text you write. The idea is that all of your finished output—your
    figures, tables, and text, and so on—can be procedurally and reproducibly generated
    from code, data, and written material stored in a simple, plain-text format.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在做笔记和编写自己的代码时，你应该在文本编辑器中编写纯文本。不要使用Microsoft Word或其他文字处理软件。你可能习惯于将最终输出（例如Word文件、PDF文档、演示文稿或你制作的表格和图形）视为你项目中的“真实”内容。相反，最好是认为数据和代码才是“真实”的，连同你写的文本一起。想法是，你所有的最终输出——你的图形、表格和文本等——都可以通过存储在简单纯文本格式中的代码、数据和书面材料按程序和可重复地生成。
- en: '![Top: Some elements of RMarkdown syntax. Bottom: From a plain text RMarkdown
    file to PDF output.](../Images/8b3c8114189c9e97fe617516777a7dd3.png)![Top: Some
    elements of RMarkdown syntax. Bottom: From a plain text RMarkdown file to PDF
    output.](../Images/8a6a98cd16161948fc8e6571bbbc8658.png) Figure 2.1: Top: Some
    elements of RMarkdown syntax. Bottom: From a plain text RMarkdown file to PDF
    output.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![顶部：RMarkdown语法的一些元素。底部：从纯文本RMarkdown文件到PDF输出的转换。](../Images/8b3c8114189c9e97fe617516777a7dd3.png)![顶部：RMarkdown语法的一些元素。底部：从纯文本RMarkdown文件到PDF输出的转换。](../Images/8a6a98cd16161948fc8e6571bbbc8658.png)
    图2.1：顶部：RMarkdown语法的一些元素。底部：从纯文本RMarkdown文件到PDF输出的转换。'
- en: The ability to reproduce your work in this way is important to the scientific
    process. But you should also see it as a pragmatic choice that will make life
    easier for you in future. The reality for most of us is that the person who will
    most want to easily reproduce your work is *you*, six months or a year from now.
    This is especially true for graphics and figures. These often have a “finished”
    quality to them, as a result of much tweaking and adjustments to the details of
    the figure. That can make them hard to reproduce later. While it is normal for
    graphics to undergo a substantial amount of polishing on their way to publication,
    our goal is to do as much of this as possible *programmatically*, in code we write,
    rather than in a way that is retrospectively invisible, as for example when we
    edit an image in an application like Adobe Illustrator.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式重现你的工作对于科学过程来说非常重要。但你也应该将其视为一个实用性的选择，这将使你未来的生活更加轻松。对我们大多数人来说，最希望轻松重现你工作的人是*你*，六个月或一年后的你。这对于图形和图形尤其如此。由于对图形细节进行了大量的调整和修改，它们往往具有“完成”的外观。这可能会使它们在以后难以重现。虽然图形在出版过程中进行大量润色是正常的，但我们的目标是尽可能通过编写代码以编程方式来完成这项工作，而不是以事后不可见的方式，例如在Adobe
    Illustrator等应用程序中编辑图像。
- en: 'While learning ggplot, and later while doing data analysis, you will find yourself
    constantly pinging back and forth between three things:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习ggplot以及后来进行数据分析的过程中，你会发现自己在三个事物之间不断来回切换：
- en: '*Writing code*. You will write a lot of code to produce plots. You will also
    write code to load your data, to look quickly at tables of that data. Sometimes
    you will want to summarize, rearrange, subset, or augment your data, or run a
    statistical model with it. You will want to be able to write that code as easily
    and effectively as possible.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*编写代码*。你将编写大量代码来生成图形。你还将编写代码来加载数据，快速查看数据的表格。有时你可能想要总结、重新排列、子集化或增强你的数据，或者用统计模型来处理它。你希望能够尽可能轻松有效地编写这些代码。'
- en: '*Looking at output*. Your code is a set of instructions that, when executed,
    produces the output you want: a table, a model, or a figure. It is often helpful
    to be able to see that output, and its partial results. While we’re working, it’s
    also useful to keep the code and the things produced by the code close together,
    if we can.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*查看输出*。你的代码是一组指令，当执行时，会产生你想要的输出：一个表格、一个模型或一个图形。能够看到那个输出及其部分结果通常很有帮助。在我们工作的过程中，如果可能的话，将代码和代码产生的结果保持在一起也是很有用的。'
- en: '*Taking Notes*. You will also be writing about what we are doing, and what
    your results mean. When learning how to do something in ggplot, for instance,
    you will want to make notes to yourself about what you did, why you wrote it this
    way rather than that, or what this new concept, function, or instruction does.
    Later, when doing data analysis and making figures, you will be writing up reports
    or drafting papers.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*记录笔记*。你还将撰写关于我们在做什么以及你的结果意味着什么的内容。例如，当你学习如何使用ggplot时，你将想要记录下你所做的操作，为什么你这样写而不是那样写，或者这个新概念、函数或指令的作用。稍后，当你进行数据分析并制作图表时，你将撰写报告或起草论文。'
- en: 'How can you do all this effectively? The simplest way to keep code and notes
    together is to write your code and intersperse it with comments. All programming
    languages have some way of demarcating lines as comments, usually by putting a
    special character (like `#`) at the start of the line. We could create a plain-text
    script file called, e.g., `notes.r`, containing code and our comments on it. This
    is fine as far as it goes. But except for very short files, it will be difficult
    to do anything useful with the comments we write. If we want a report from an
    analysis, for example, we will have to write it up separately. While a script
    file can keep comments and code together, it loses the connection between code
    and its output, such as the figure we want to produce. But there is a better alternative:
    we can write our notes using RMarkdown.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如何有效地完成所有这些？将代码和笔记放在一起的最简单方法是编写代码并在其中穿插注释。所有编程语言都有一种方式来标记行作为注释，通常是在行的开头放置一个特殊字符（如`#`）。我们可以创建一个名为，例如，`notes.r`的纯文本脚本文件，其中包含代码和我们对它的注释。就目前而言，这是可以的。但对于非常短的文件，使用我们写的注释来做任何有用的事情都会很困难。如果我们想要一份分析报告，例如，我们必须单独编写它。虽然脚本文件可以将注释和代码放在一起，但它失去了代码与其输出之间的联系，例如我们想要生成的图表。但有一个更好的选择：我们可以使用RMarkdown来编写我们的笔记。
- en: An RMarkdown file is just a plain text document where text (such as notes or
    discussion) is interspersed with pieces, or *chunks*, of R code. When you feed
    the document to R, it *knits* this file into a new document by running the R code
    piece by piece, in sequence, and either supplementing or replacing the chunks
    of code with their output. The resulting file is then converted into a more easily-readable
    document formatted in HTML, PDF, or Word. The non-code segments of the document
    are plain text, but they can have simple formatting instructions in them. These
    are set using [Markdown](http://en.wikipedia.org/wiki/Markdown), a set of conventions
    for marking up plain text in a way that indicates how it should be formatted.
    The basic elements of Markdown are shown in the upper part of Figure [2.1](gettingstarted.html#fig:ch-02-markdown-margin).
    When you create a markdown document in R Studio, it contains some sample text
    to get you started.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: RMarkdown文件只是一个纯文本文档，其中文本（如笔记或讨论）与R代码片段或*块*交织在一起。当你将文档输入R时，它会通过逐个、按顺序运行R代码块来*编织*这个文件，并用它们的输出补充或替换代码块。生成的文件随后被转换成格式为HTML、PDF或Word的更易于阅读的文档。文档的非代码部分是纯文本，但它们可以包含简单的格式化指令。这些指令使用[Markdown](http://en.wikipedia.org/wiki/Markdown)设置，这是一套标记纯文本的约定，指示其格式化方式。Markdown的基本元素如图[2.1](gettingstarted.html#fig:ch-02-markdown-margin)上部分所示。当你使用R
    Studio创建Markdown文档时，它包含一些示例文本以帮助你开始。
- en: 'RMarkdown documents look like the one shown schematically in the lower part
    of Figure [2.1](gettingstarted.html#fig:ch-02-markdown-margin). Your notes or
    text, with Markdown formatting as needed, are interspersed with code. There is
    a set format for code chunks. They look like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: RMarkdown文档看起来就像图[2.1](gettingstarted.html#fig:ch-02-markdown-margin)下部分所示的那样。你的笔记或文本，根据需要使用Markdown格式，与代码交织在一起。代码块有一个固定的格式。它们看起来像这样：
- en: '[PRE60]{r}'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE60]{r}'
- en: '[PRE61]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Three backticks (on a U.S. keyboard, that’s the character under the escape key)
    followed by a pair of curly braces containing the name of the language we are
    using.The format is language-agnostic, and can be used with, e.g. Python and other
    languages. The backticks-and-braces part signal that a chunk of code is about
    to begin. You write your code as needed, and then end the chunk with a new line
    containing just three backticks.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 三个反引号（在美国键盘上，这是位于Esc键下的字符）后面跟着一对花括号，其中包含我们正在使用的语言名称。这种格式是语言无关的，可以与Python和其他语言一起使用。反引号和花括号部分表示即将开始一段代码。你需要根据需要编写代码，然后使用包含仅三个反引号的新行来结束代码块。
- en: If you keep your notes in this way, you will be able to see the code you wrote,
    the output it produces, and your own commentary or clarification on it in a convenient
    way. Moreover, you can turn it into a good-looking document right away.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以这种方式保存你的笔记，你将能够以方便的方式看到你编写的代码、它产生的输出以及你对其的评论或解释。此外，你还可以立即将其转换成一个看起来不错的文档。
- en: 2.2 Use R with RStudio
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 使用RStudio中的R
- en: 2.2.1 The RStudio environment
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 RStudio环境
- en: R itself is a relatively small application with next to no user interface. Everything
    works through a command line, or *console*. At its most basic, you launch it from
    your Terminal application (on a Mac) or Command Prompt (on Windows) by typing
    `R`. Once launched, R awaits your instructions at a command line of its own, denoted
    by the right angle bracket symbol, `>`. When you type an instruction and hit return,
    R interprets it and sends any resulting output back to the console.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: R本身是一个相对较小的应用程序，几乎没有用户界面。所有操作都通过命令行或*控制台*进行。在最基本的情况下，你通过在Mac的终端应用程序或Windows的命令提示符中键入`R`来启动它。一旦启动，R就会在它自己的命令行中等待你的指令，该命令行由右尖括号符号`>`表示。当你输入指令并按回车键时，R会解释它并将任何产生的输出发送回控制台。
- en: 'Figure 2.2: Bare-bones R running from the Terminal.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：从终端运行的基本R。
- en: '![Bare-bones R running from the Terminal.](../Images/f7cb8f4fd5b5c80f5f4080a8be3c777e.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![从终端运行的基本R。](../Images/f7cb8f4fd5b5c80f5f4080a8be3c777e.png)'
- en: In addition to interacting with the console, you can also write your code in
    a text file and send that to R all at once. You can use any good text editor to
    write your `.r` scripts. But although a plain text file and a command line is
    the absolute minimum you need to work with R, it is a rather spartan arrangement.
    We can make life easier for ourselves by using [RStudio](https://rstudio.com).
    RStudio is an “integrated development environment”, or IDE. It is a separate application
    from R proper. When launched, it starts up an instance of R’s console inside of
    itself. It also conveniently pulls together various other elements to help you
    get your work done. These include the document where you are writing your code,
    the output it produces, and R’s help system. RStudio also knows about RMarkdown,
    and understands a lot about the R language and the organization of your project.
    When you launch RStudio, it should look much like Figure [2.3](gettingstarted.html#fig:ch-02-rstudio1).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与控制台交互外，你还可以将你的代码写入一个文本文件，并将该文件一次性发送给R。你可以使用任何好的文本编辑器来编写你的`.r`脚本。尽管纯文本文件和命令行是使用R所需的最基本工具，但这种安排相当简朴。我们可以通过使用[RStudio](https://rstudio.com)来使生活变得更简单。RStudio是一个“集成开发环境”，或IDE。它是一个与R本身分开的应用程序。当启动时，它会在自身内部启动R控制台的一个实例。它还方便地汇集了各种其他元素来帮助你完成工作。这些包括你编写代码的文档、它产生的输出以及R的帮助系统。RStudio还了解RMarkdown，并且对R语言和你的项目组织有深入了解。当你启动RStudio时，它应该看起来与图[2.3](gettingstarted.html#fig:ch-02-rstudio1)非常相似。
- en: '![The RStudio IDE.](../Images/a0414452145bf50b63b622bdb5f88caa.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![RStudio IDE。](../Images/a0414452145bf50b63b622bdb5f88caa.png)'
- en: 'Figure 2.3: The RStudio IDE.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：RStudio IDE。
- en: 2.2.2 Create a project
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 创建项目
- en: To begin, create a project. From the menu, choose File > New Project … from
    the menu bar, choose the New Directory option, and create the project.You can
    create your new project wherever you like—most commonly it will go somewhere in
    your Documents folder. Once it is set up, create an RMarkdown file in the directory,
    with File > New File > RMarkdown. This will give you a set of choices including
    the default “Document”. The `socviz` library comes with a small RMarkdown template
    that follows the structure of this book. To use it instead of the default document,
    after selecting File > New File > RMarkdown, choose the “From Template” option
    in the sidebar of the dialog box that appears. Then choose “Data Visualization
    Notes” from the resulting list of options. When the RMarkdown document appears,
    save it right away in your project folder, with File > Save. The `socviz` template
    contains a little bit of information about how RMarkdown works, together with
    some headers to get you started. Read what it has to say. Look at the code chunks
    and RMarkdown formatting. Experiment with knitting the document, and compare the
    output to the content of the plain text document.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个项目。从菜单中选择文件 > 新建项目 … 从菜单栏中选择新建目录选项，并创建项目。你可以将新项目创建在任何你喜欢的位置——最常见的是它会在你的文档文件夹中。一旦设置好，在该目录中创建一个RMarkdown文件，方法是文件
    > 新建文件 > RMarkdown。这将为你提供一组选择，包括默认的“文档”。`socviz`库附带了一个小型RMarkdown模板，该模板遵循本书的结构。要使用它而不是默认文档，在选择了文件
    > 新建文件 > RMarkdown之后，在出现的对话框侧边栏中选择“从模板”选项。然后从结果选项列表中选择“数据可视化笔记”。当RMarkdown文档出现时，立即使用文件
    > 保存将其保存在你的项目文件夹中。`socviz`模板包含了一些关于RMarkdown如何工作的信息，以及一些帮助你开始的标题。阅读它所说的话。查看代码块和RMarkdown格式。通过实验性地编织文档，并将输出与纯文本文档的内容进行比较。
- en: RMarkdown is not required for R. An alternative is to use an R script, which
    just contains R commands only.You can create an r script via File > New File >
    R Script. R script files conventionally have the extension `.r` or `.R`. (RMarkdown
    files conventionally end in `.Rmd`.) A very brief project might just need a single
    `.r` file. But RMarkdown is very useful for documents, notes, or reports of any
    length, especially when you need to take notes. If you do use an `.r` file you
    can leave comments or notes to yourself by starting a line with the hash character,
    `#`. You can also add comments at the end of lines in this way, as for any particular
    line R will ignore whatever code or text that appears after a `#`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: RMarkdown不是R的必需品。一个替代方案是使用R脚本，它只包含R命令。你可以通过文件 > 新建文件 > R Script创建一个r脚本。R脚本文件通常有`.r`或`.R`的扩展名。（RMarkdown文件通常以`.Rmd`结尾。）一个非常简短的项目可能只需要一个`.r`文件。但RMarkdown对于任何长度文档、笔记或报告都非常有用，尤其是当你需要做笔记时。如果你使用`.r`文件，你可以通过在行首使用井号字符`#`来给自己留下注释或笔记。你也可以以这种方式在行尾添加注释，就像R对任何特定行之后的代码或文本都会忽略一样。
- en: RStudio has various keyboard and menu shortcuts to help you edit code and text
    quickly. For example you can insert chunks of code in your RMarkdown document
    with a keyboard shortcut.`Command+Option+I` on MacOS. `Ctrl+Alt+I` on Windows.
    This saves you from writing the backticks and braces every time. You can run the
    current line of code with a shortcut, too.`Command+Enter` on MacOS. `Alt+Enter`
    on Windows. A third shortcut gives you a pop-over display with summary of many
    other useful keystroke combinations.`Option+Shift+K` on MacOS. `Alt-Shift-K` on
    Windows. RMarkdown documents can include all kinds of other options and formatting
    paraphernalia, from text formatting to cross-references to bibliographical information.
    But never mind about those for now.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio有各种键盘和菜单快捷键来帮助你快速编辑代码和文本。例如，你可以使用键盘快捷键在RMarkdown文档中插入代码块。在MacOS上为`Command+Option+I`。在Windows上为`Ctrl+Alt+I`。这样可以避免每次都写背引号和大括号。你也可以使用快捷键运行当前行代码，`Command+Enter`在MacOS上。`Alt+Enter`在Windows上。第三个快捷键为你提供了一个弹出显示，其中包含许多其他有用的按键组合的摘要。`Option+Shift+K`在MacOS上。`Alt-Shift-K`在Windows上。RMarkdown文档可以包含所有种类的其他选项和格式化工具，从文本格式到交叉引用到参考文献信息。但现在不必担心这些。
- en: 'Figure 2.4: An RMarkdown file open in R Studio. The small icons in the top
    right-hand corner of each code chunk can be used to set options (the gear icon),
    run all chunks up to the current one (the downward-facing triangle), and just
    run the current chunk (the right-facing triangle).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：在R Studio中打开的RMarkdown文件。每个代码块右上角的小图标可以用来设置选项（齿轮图标），运行到当前代码块的所有代码块（向下三角形），以及仅运行当前代码块（向右三角形）。
- en: '![An RMarkdown file open in R Studio. The small icons in the top right-hand
    corner of each code chunk can be used to set options (the gear icon), run all
    chunks up to the current one (the downward-facing triangle), and just run the
    current chunk (the right-facing triangle).](../Images/778c59a11834942c702d99559e87754e.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![An RMarkdown file open in R Studio. The small icons in the top right-hand
    corner of each code chunk can be used to set options (the gear icon), run all
    chunks up to the current one (the downward-facing triangle), and just run the
    current chunk (the right-facing triangle).](../Images/778c59a11834942c702d99559e87754e.png)'
- en: 'To make sure you are ready to go, load the `tidyverse` library. The tidyverse
    is a suite of related libraries for R developed by Hadley Wickham and others.
    The `ggplot2` library is one of its components. The other pieces make it easier
    to get data in to R and manipulate it once it is there. Either knit the notes
    file you created from the socviz template, or load the library manually at the
    console:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您已准备好开始，请加载 `tidyverse` 库。tidyverse 是由 Hadley Wickham 和其他人开发的一系列相关 R 库的集合。`ggplot2`
    库是其组成部分之一。其他部分使将数据导入 R 并在导入后对其进行操作变得更加容易。您可以通过从 socviz 模板创建的笔记文件进行编织，或者手动在控制台中加载库：
- en: '[PRE62]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We load the `socviz` library after the tidyverse. This library contains datasets
    that we will use throughout the book, along with some other tools that will make
    life a little easier. If you get an error message saying either library can’t
    be found, then re-read the “Before you Begin” section in the Preface to this book
    and follow the instructions there.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 tidyverse 之后加载 `socviz` 库。这个库包含我们在整本书中都会使用的数据集，以及一些会使生活变得更轻松的其他工具。如果您收到错误消息，说明任一库找不到，那么请重新阅读本书序言中的“开始之前”部分，并遵循那里的说明。
- en: You only need to *install* a library once, but you will need to *load* it at
    the beginning of each R session with `library()` if you want to use the tools
    it contains. In practice this means that the very first lines of your working
    file should contain a code chunk that loads the libraries you will need in the
    file. If you forget to do this, then R will be unable to find the functions you
    want to use later on.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需要 *安装* 库一次，但如果您想使用其中包含的工具，则在每个 R 会话开始时需要使用 `library()` 来 *加载* 它。实际上，这意味着您的工作文件中的第一行应该包含一个代码块，用于加载文件中需要的库。如果您忘记这样做，那么
    R 将无法找到您稍后想要使用的函数。
- en: 2.2.1 The RStudio environment
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 RStudio 环境
- en: R itself is a relatively small application with next to no user interface. Everything
    works through a command line, or *console*. At its most basic, you launch it from
    your Terminal application (on a Mac) or Command Prompt (on Windows) by typing
    `R`. Once launched, R awaits your instructions at a command line of its own, denoted
    by the right angle bracket symbol, `>`. When you type an instruction and hit return,
    R interprets it and sends any resulting output back to the console.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: R 本身是一个相对较小的应用程序，几乎没有用户界面。所有操作都通过命令行或 *控制台* 完成。在最基本的情况下，您可以通过在终端应用程序（在 Mac 上）或命令提示符（在
    Windows 上）中输入 `R` 来启动它。一旦启动，R 就会在自己的命令行上等待您的指令，该命令行以右箭头符号 `>` 表示。当您输入指令并按回车键时，R
    会解释它并将任何结果输出返回到控制台。
- en: 'Figure 2.2: Bare-bones R running from the Terminal.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：从终端运行的基础 R。
- en: '![Bare-bones R running from the Terminal.](../Images/f7cb8f4fd5b5c80f5f4080a8be3c777e.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Bare-bones R running from the Terminal.](../Images/f7cb8f4fd5b5c80f5f4080a8be3c777e.png)'
- en: In addition to interacting with the console, you can also write your code in
    a text file and send that to R all at once. You can use any good text editor to
    write your `.r` scripts. But although a plain text file and a command line is
    the absolute minimum you need to work with R, it is a rather spartan arrangement.
    We can make life easier for ourselves by using [RStudio](https://rstudio.com).
    RStudio is an “integrated development environment”, or IDE. It is a separate application
    from R proper. When launched, it starts up an instance of R’s console inside of
    itself. It also conveniently pulls together various other elements to help you
    get your work done. These include the document where you are writing your code,
    the output it produces, and R’s help system. RStudio also knows about RMarkdown,
    and understands a lot about the R language and the organization of your project.
    When you launch RStudio, it should look much like Figure [2.3](gettingstarted.html#fig:ch-02-rstudio1).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与控制台交互外，你还可以在文本文件中编写你的代码，并将整个文件一次性发送给R。你可以使用任何好的文本编辑器来编写你的`.r`脚本。尽管纯文本文件和命令行是使用R所需的最基本工具，但这种安排相当简朴。我们可以通过使用[RStudio](https://rstudio.com)来使生活变得更简单。RStudio是一个“集成开发环境”，或IDE。它是一个与R本身分开的应用程序。当启动时，它会在自身内部启动R控制台的一个实例。它还方便地汇集了各种其他元素来帮助你完成工作。这些包括你编写代码的文档、它产生的输出以及R的帮助系统。RStudio还了解RMarkdown，并对R语言和你的项目组织有深入了解。当你启动RStudio时，它应该看起来与图[2.3](gettingstarted.html#fig:ch-02-rstudio1)非常相似。
- en: '![The RStudio IDE.](../Images/a0414452145bf50b63b622bdb5f88caa.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![RStudio集成开发环境](../Images/a0414452145bf50b63b622bdb5f88caa.png)'
- en: 'Figure 2.3: The RStudio IDE.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：RStudio集成开发环境。
- en: 2.2.2 Create a project
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 创建项目
- en: To begin, create a project. From the menu, choose File > New Project … from
    the menu bar, choose the New Directory option, and create the project.You can
    create your new project wherever you like—most commonly it will go somewhere in
    your Documents folder. Once it is set up, create an RMarkdown file in the directory,
    with File > New File > RMarkdown. This will give you a set of choices including
    the default “Document”. The `socviz` library comes with a small RMarkdown template
    that follows the structure of this book. To use it instead of the default document,
    after selecting File > New File > RMarkdown, choose the “From Template” option
    in the sidebar of the dialog box that appears. Then choose “Data Visualization
    Notes” from the resulting list of options. When the RMarkdown document appears,
    save it right away in your project folder, with File > Save. The `socviz` template
    contains a little bit of information about how RMarkdown works, together with
    some headers to get you started. Read what it has to say. Look at the code chunks
    and RMarkdown formatting. Experiment with knitting the document, and compare the
    output to the content of the plain text document.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个项目。从菜单中选择文件 > 新建项目…从菜单栏中选择新建目录选项，并创建项目。你可以将你的新项目放在任何你喜欢的位置——最常见的是它会在你的文档文件夹中。一旦设置好，在该目录中创建一个RMarkdown文件，方法是选择文件
    > 新建文件 > RMarkdown。这将为你提供一组选择，包括默认的“文档”。`socviz`库附带了一个小型RMarkdown模板，它遵循本书的结构。要使用它而不是默认文档，在选择了文件
    > 新建文件 > RMarkdown之后，选择对话框侧边栏中的“从模板”选项。然后从结果选项列表中选择“数据可视化笔记”。当RMarkdown文档出现时，立即使用文件
    > 保存将其保存在你的项目文件夹中。`socviz`模板包含了一些关于RMarkdown如何工作的信息，以及一些帮助你开始的标题。阅读它的说明。查看代码块和RMarkdown格式。尝试编织文档，并将输出与纯文本文档的内容进行比较。
- en: RMarkdown is not required for R. An alternative is to use an R script, which
    just contains R commands only.You can create an r script via File > New File >
    R Script. R script files conventionally have the extension `.r` or `.R`. (RMarkdown
    files conventionally end in `.Rmd`.) A very brief project might just need a single
    `.r` file. But RMarkdown is very useful for documents, notes, or reports of any
    length, especially when you need to take notes. If you do use an `.r` file you
    can leave comments or notes to yourself by starting a line with the hash character,
    `#`. You can also add comments at the end of lines in this way, as for any particular
    line R will ignore whatever code or text that appears after a `#`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: RMarkdown不是R语言必需的。一个替代方案是使用R脚本，它只包含R命令。你可以通过文件 > 新建文件 > R脚本创建一个r脚本。R脚本文件通常有`.r`或`.R`的扩展名。（RMarkdown文件通常以`.Rmd`结尾。）一个非常简短的项目可能只需要一个`.r`文件。但RMarkdown对于任何长度文档、笔记或报告都非常有用，尤其是当你需要做笔记时。如果你使用`.r`文件，你可以通过在行首使用井号字符`#`来给自己留下注释或笔记。你也可以以这种方式在行尾添加注释，就像R会忽略任何在`#`之后出现的代码或文本一样。
- en: RStudio has various keyboard and menu shortcuts to help you edit code and text
    quickly. For example you can insert chunks of code in your RMarkdown document
    with a keyboard shortcut.`Command+Option+I` on MacOS. `Ctrl+Alt+I` on Windows.
    This saves you from writing the backticks and braces every time. You can run the
    current line of code with a shortcut, too.`Command+Enter` on MacOS. `Alt+Enter`
    on Windows. A third shortcut gives you a pop-over display with summary of many
    other useful keystroke combinations.`Option+Shift+K` on MacOS. `Alt-Shift-K` on
    Windows. RMarkdown documents can include all kinds of other options and formatting
    paraphernalia, from text formatting to cross-references to bibliographical information.
    But never mind about those for now.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio提供了各种键盘和菜单快捷键来帮助你快速编辑代码和文本。例如，你可以使用键盘快捷键在RMarkdown文档中插入代码块。在MacOS上为`Command+Option+I`，在Windows上为`Ctrl+Alt+I`。这样可以避免每次都输入反引号和花括号。你也可以使用快捷键运行当前行代码，MacOS上为`Command+Enter`，Windows上为`Alt+Enter`。还有一个快捷键可以给你一个弹出显示，其中包含许多其他有用的按键组合的摘要。在MacOS上为`Option+Shift+K`，在Windows上为`Alt-Shift-K`。RMarkdown文档可以包含所有种类的其他选项和格式化工具，从文本格式到交叉引用到参考文献信息。但现在不必担心这些。
- en: 'Figure 2.4: An RMarkdown file open in R Studio. The small icons in the top
    right-hand corner of each code chunk can be used to set options (the gear icon),
    run all chunks up to the current one (the downward-facing triangle), and just
    run the current chunk (the right-facing triangle).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：在R Studio中打开的RMarkdown文件。每个代码块右上角的小图标可以用来设置选项（齿轮图标），运行所有代码块直到当前一个（向下三角形），以及只运行当前代码块（向右三角形）。
- en: '![An RMarkdown file open in R Studio. The small icons in the top right-hand
    corner of each code chunk can be used to set options (the gear icon), run all
    chunks up to the current one (the downward-facing triangle), and just run the
    current chunk (the right-facing triangle).](../Images/778c59a11834942c702d99559e87754e.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![在R Studio中打开的RMarkdown文件。每个代码块右上角的小图标可以用来设置选项（齿轮图标），运行所有代码块直到当前一个（向下三角形），或者只运行当前代码块（向右三角形）。](../Images/778c59a11834942c702d99559e87754e.png)'
- en: 'To make sure you are ready to go, load the `tidyverse` library. The tidyverse
    is a suite of related libraries for R developed by Hadley Wickham and others.
    The `ggplot2` library is one of its components. The other pieces make it easier
    to get data in to R and manipulate it once it is there. Either knit the notes
    file you created from the socviz template, or load the library manually at the
    console:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你已准备好出发，请加载`tidyverse`库。tidyverse是由Hadley Wickham和其他人开发的一系列相关库，用于R语言。`ggplot2`库是其组成部分之一。其他部分使得将数据导入R并对其进行操作变得更加容易。你可以从socviz模板创建的笔记文件中编织，或者手动在控制台中加载库：
- en: '[PRE63]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We load the `socviz` library after the tidyverse. This library contains datasets
    that we will use throughout the book, along with some other tools that will make
    life a little easier. If you get an error message saying either library can’t
    be found, then re-read the “Before you Begin” section in the Preface to this book
    and follow the instructions there.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在加载tidyverse之后加载`socviz`库。这个库包含我们在整本书中都会使用的数据集，以及一些会使生活变得轻松一些的其他工具。如果你收到错误消息，说找不到任何一个库，那么请重新阅读本书序言中的“开始之前”部分，并遵循那里的说明。
- en: You only need to *install* a library once, but you will need to *load* it at
    the beginning of each R session with `library()` if you want to use the tools
    it contains. In practice this means that the very first lines of your working
    file should contain a code chunk that loads the libraries you will need in the
    file. If you forget to do this, then R will be unable to find the functions you
    want to use later on.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要安装一次库，但如果你想要使用它包含的工具，你需要在每个 R 会话的开始使用 `library()` 来加载它。在实践中，这意味着你的工作文件中的第一行应该包含一个代码块，用于加载文件中需要的库。如果你忘记这样做，那么
    R 将无法找到你稍后想要使用的函数。
- en: 2.3 Things to know about R
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 关于 R 的须知事项
- en: Any new piece of software takes a bit of getting used to. This is especially
    true when using an IDE to work in a language like R. You are getting oriented
    to the language itself (what happens at the console), while learning to take notes
    in what might seem like an odd format (chunks of code interspersed with plain-text
    comments), in an IDE that that has a many features designed to make your life
    easier in the long run, but which can be hard to decipher at the beginning. Here
    are some general points to bear in mind about how R is designed. They might help
    you get a feel for how the language works.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 任何新的软件都需要一段时间来适应。当使用 IDE 在像 R 这样的语言中工作时，这一点尤其正确。你正在适应语言本身（控制台发生的事情），同时学习在可能看起来很奇怪的形式（代码块与纯文本注释交织）中做笔记，在
    IDE 中，它具有许多旨在使你的生活长期更轻松的功能，但一开始可能很难理解。以下是一些关于 R 设计的一般要点，它们可能有助于你了解语言的工作方式。
- en: 2.3.1 Everything has a name
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 一切都有名称
- en: In R, everything you deal with has a name. You refer to things by their names
    as you examine, use, or modify them. Named entities include variables (like `x`,
    or `y`), data that you have loaded (like `my_data`), and functions that you use.
    (More about functions momentarily.) You will spend a lot of time talking about,
    creating, referring to, and modifying things with names.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，你处理的一切都有名称。你通过名称来引用事物，无论是检查、使用还是修改它们。命名实体包括变量（如 `x` 或 `y`）、你加载的数据（如 `my_data`）以及你使用的函数。（关于函数的更多内容稍后介绍。）你将花费大量时间讨论、创建、引用和修改具有名称的事物。
- en: Some names are forbidden. These include reserved words like `FALSE` and `TRUE`,
    core programming words like `Inf`, `for`, `else`, `break`, `function`, and words
    for special entities like `NA` and `NaN`. (These last two are codes designating
    missing data and “Not a Number”, respectively.) You probably won’t use these names
    by accident, but it’s good do know that they are not allowed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有些名称是禁止使用的。这包括像 `FALSE` 和 `TRUE` 这样的保留词，像 `Inf`、`for`、`else`、`break`、`function`
    这样的核心编程词，以及像 `NA` 和 `NaN` 这样的特殊实体词。（最后两个是表示缺失数据和“不是一个数字”的代码。）你可能不会意外地使用这些名称，但了解它们是不被允许的总是好的。
- en: Some names you should not use, even if they are technically permitted. These
    are mostly words that are already in use for objects or functions that form part
    of the core of R. These include the names of basic functions like `q()` or `c()`,
    common statistical functions like `mean()`, `range()` or `var()`, and built-in
    mathematical constants like `pi`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有些名称你不应该使用，即使技术上允许。这些主要是已经用于 R 核心对象或函数的单词。这包括像 `q()` 或 `c()` 这样的基本函数名称，像 `mean()`、`range()`
    或 `var()` 这样的常见统计函数，以及像 `pi` 这样的内置数学常数。
- en: Names in R are case sensitive. The object `my_data` is not the same as the object
    `My_Data`. When choosing names for things, be concise, consistent, and informative.
    Follow the style of the tidyverse and name things in lower case, separating words
    with the underscore character, `_`, as needed. Do not use spaces when naming things,
    including variables in your data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的名称是区分大小写的。对象 `my_data` 与对象 `My_Data` 不相同。在为事物选择名称时，要简洁、一致且具有信息性。遵循 tidyverse
    的风格，以小写命名事物，根据需要使用下划线字符 `_` 分隔单词。在命名事物时不要使用空格，包括你的数据中的变量。
- en: 2.3.2 Everything is an object
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 一切都是对象
- en: Some objects are built in to R, some are added via libraries, and some are created
    by the user. But almost everything is some kind of object. The code you write
    will create, manipulate, and use named objects as a matter of course. We can start
    immediately. Let’s create a vector of numbers. The command `c()` is a function.
    It’s short for “combine” or “concatenate”. It will take a sequence of comma-separated
    things inside the parentheses and join them together into a vector where each
    element is still individually accessible.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一些对象是R内置的，一些是通过库添加的，还有一些是由用户创建的。但几乎一切都是某种对象。你编写的代码将创建、操作和使用命名对象，这是理所当然的。我们可以立即开始。让我们创建一个数字向量。命令`c()`是一个函数。它代表“组合”或“连接”。它将括号内以逗号分隔的一系列事物连接起来，形成一个向量，其中每个元素仍然可以单独访问。
- en: '[PRE64]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Instead of sending the result to the console, we can instead *assign* it to
    an object we createYou can type the arrow using `<` and then `-`.:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将结果发送到控制台，而不是将其分配给我们创建的对象。你可以使用`<`和`-`来输入箭头：
- en: '[PRE66]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To see what you made, type the name of the object and hit return:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你创建的内容，输入对象的名称并按回车键：
- en: '[PRE67]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Each of our numbers is still there, and can be accessed directly if we want.
    They are now just part of a new object, a vector, called `my_numbers`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有数字仍然在那里，如果我们想直接访问它们，也是可以的。现在它们只是新对象，即向量`my_numbers`的一部分。
- en: 'You create objects by assigning them to names. The *assignment operator* is
    `<-`. Think of assignment as the verb “gets”, reading left to right. So, the bit
    of code above can be read as “The object `my_numbers` gets the result of concatenating
    the following numbers: 1, 2, …” TheIf you only learn one keyboard shortcut in
    RStudio make it this one! Always use `Option+minus` on MacOS or `Alt+minus` on
    Windows to type the assignment operator. operator is two separate keys on your
    keyboard: the `<` key and the `-` (minus) key. Because you type this so often
    in R, there is a shortcut for it in R Studio. To write the assignment operator
    in one step, hold down the `option` key and hit `-`. On Windows hold down the
    `alt` key and hit `-`. You will be constantly creating objects in this way, and
    trying typing the two characters separately is both tedious and prone to error.
    You will make hard-to-notice mistakes like typing `< -` (with a space in between
    the characters) instead of `<-`.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过将对象分配给名称来创建对象。赋值运算符是`<-`。将赋值看作动词“得到”，从左到右读取。因此，上面的代码片段可以读作：“对象`my_numbers`得到了以下数字连接的结果：1,
    2, …”赋值运算符是键盘上的两个独立键：`<`键和`-`（减号）键。因为你在R中经常输入这个，R Studio中有一个快捷键。要一步输入赋值运算符，按住`option`键并敲击`-`。在Windows上，按住`alt`键并敲击`-`。你将不断地以这种方式创建对象，单独输入这两个字符既麻烦又容易出错。你可能会犯一些难以察觉的错误，比如输入`<
    -`（字符之间有空格）而不是`<-`。
- en: When you create objects by assigning things to names, they come into existence
    in R’s *workspace* or *environment*. You can think of this most straightforwardly
    as your project directory. Your workspace is specific to your current project.
    It is the folder from which you launched R. Unless you have particular needs (such
    as extremely large datasets or analytical tastes that take a very long time) you
    will not need to give any thought to where objects “really” live. Just think of
    your code and data files as the permanent features of your project. When you start
    up an R project, you will generally begin by loading your data. That is, you will
    read it in from disk and assign it to a named object like `my_data`. The rest
    of your code will be a series of instructions to act on and create more named
    objects.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过将事物分配给名称来创建对象时，它们在R的*工作区*或*环境*中存在。你可以最直接地将其视为你的项目目录。你的工作区是特定于你的当前项目的。它是你启动R的文件夹。除非你有特殊需求（例如非常大的数据集或需要很长时间的分析口味），你不需要考虑对象“真正”在哪里。只需将你的代码和数据文件视为项目的永久特征。当你启动一个R项目时，你通常首先加载数据。也就是说，你会从磁盘读取它并将其分配给一个名为`my_data`的命名对象。你其余的代码将是一系列操作和创建更多命名对象的指令。
- en: 2.3.3 You do things using functions
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 使用函数进行操作
- en: '![Upper: What functions look like, very schematically. Lower: an imaginary
    function that takes two vectors and plots them with a title. We supply the function
    with the particular vectors we want it to use, and the title. The vectors are
    objects, so are given as-is. The title is not an object, so we enclose it in quotes.](../Images/7a6859d77a6a3eaf81c369f8905db946.png)
    Figure 2.5: Upper: What functions look like, very schematically. Lower: an imaginary
    function that takes two vectors and plots them with a title. We supply the function
    with the particular vectors we want it to use, and the title. The vectors are
    objects, so are given as-is. The title is not an object, so we enclose it in quotes.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![上图：函数的外观，非常简略。下图：一个想象中的函数，它接受两个向量并将它们绘制成带有标题的图表。我们向函数提供我们想要它使用的特定向量以及标题。向量是对象，所以直接给出。标题不是对象，所以我们用引号括起来。](../Images/7a6859d77a6a3eaf81c369f8905db946.png)
    图2.5：上图：函数的外观，非常简略。下图：一个想象中的函数，它接受两个向量并将它们绘制成带有标题的图表。我们向函数提供我们想要它使用的特定向量以及标题。向量是对象，所以直接给出。标题不是对象，所以我们用引号括起来。'
- en: You do almost everything in R using functions. Think of a function as a special
    kind of object that can perform actions for you. It produces output based on the
    input that it receives. Like a good dog, when we want a function to do something
    for us, we *call* it. Somewhat less like a dog, it will reliably do what we tell
    it. We give the function some information, it acts on that information, and some
    results come out the other side. Functions can be recognized by the parentheses
    at the end of their names. This distinguishes them from other objects, such as
    single numbers, named vectors, tables of data, and so on.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎在R中用函数做所有事情。将函数视为一种特殊的对象，它可以为你执行操作。它根据接收到的输入产生输出。就像一只好狗，当我们想让函数为我们做某事时，我们*调用*它。多少有点不像狗，它会可靠地执行我们告诉它的事情。我们给函数一些信息，它根据这些信息行动，然后从另一边产生一些结果。函数可以通过其名称末尾的括号来识别。这使它们与其他对象区分开来，例如单个数字、命名向量、数据表等。
- en: 'The parentheses are what allow you to send information to the function. Most
    functions accept one or more named *arguments*. A function’s arguments are the
    things it needs to know in order to do something. They can be some bit of your
    data (`data = my_numbers`), or specific instructions (`title = "GDP per Capita"`),
    or an option you want to choose (`smoothing = "splines", show = FALSE`). For example,
    the object `my_numbers` is a numeric vector:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 括号允许你向函数发送信息。大多数函数接受一个或多个命名*参数*。函数的参数是它需要知道才能执行某事的东西。它们可以是你的数据的一部分（`data = my_numbers`），或特定的指令（`title
    = "GDP per Capita"`），或你想要选择的选项（`smoothing = "splines", show = FALSE`）。例如，对象`my_numbers`是一个数值向量：
- en: '[PRE69]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: But the thing we used to create it, `c()`, is a function. It concatenates items
    into a vector composed of the series of comma-separated elements you give it.
    Similarly, `mean()` is a function that calculates a simple average for a vector
    of numbers. What happens if we just type `mean()` without any arguments inside
    the parentheses?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们用来创建它的东西，`c()`，是一个函数。它将项目连接成一个由你给出的逗号分隔元素组成的向量。同样，`mean()`是一个计算数字向量简单平均值的函数。如果我们只是键入`mean()`而不在括号内提供任何参数会发生什么？
- en: '[PRE71]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The error message is terse but informative. The function needs an argument
    to work, and we haven’t given it one. In this case, ‘x’, the name of another object
    that `mean()` can perform its calculation on:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息简洁但信息丰富。该函数需要一个参数才能工作，而我们还没有给它提供。在这种情况下，“x”，另一个名为“mean()”可以执行其计算的物体的名称：
- en: '[PRE72]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'While the function arguments have names that are used internally, (here, `x`),
    you don’t strictly need to specify the name for the function to work:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数参数有内部使用的名称（这里，`x`），但你并不严格需要指定名称才能使函数工作：
- en: '[PRE76]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: If you omit the name of the argument, R will just assume you are giving the
    function what it needs, and in a default order. The documentation for a function
    will tell you what the order of required arguments is for any particular function.See
    the Appendix for a guide to how to read the help page for a function. For simple
    functions that only require one or two arguments, omitting their names is usually
    not confusing. For more complex functions, you will typically want to use the
    names of the arguments rather than try to remember what the ordering is.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你省略了参数的名称，R 会假设你正在按照默认顺序提供函数所需的内容。函数的文档会告诉你任何特定函数所需参数的顺序。参见附录，了解如何阅读函数的帮助页面。对于只需要一个或两个参数的简单函数，省略它们的名称通常不会造成混淆。对于更复杂的函数，你通常会希望使用参数的名称，而不是试图记住它们的顺序。
- en: In general, when providing arguments to a function the syntax is `<argument>
    = <value>`. If `<value>` is a named *object* that already exists in your workspace,
    like a vector of numbers of a table of data, then you provide it unquoted, as
    in `mean(my_numbers)`. If `<value>` is not an object, a number, or a logical value
    like `TRUE`, then you usually put it in quotes, e.g., `labels(x = "X Axis Label")`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在向函数提供参数时，语法是 `<argument> = <value>`。如果 `<value>` 是一个已经存在于你的工作空间中的命名 *对象*，例如数字向量或数据表，那么你提供它时不需要引号，例如
    `mean(my_numbers)`。如果 `<value>` 不是一个对象、一个数字或像 `TRUE` 这样的逻辑值，那么你通常需要将其放在引号中，例如
    `labels(x = "X Axis Label")`。
- en: Functions take inputs via their arguments, do something, and return outputs.
    What the output is depends on what the function does. The `c()` function takes
    a sequence of comma-separated elements and returns a vector consisting of those
    same elements. The `mean()` function takes a vector of numbers and returns a single
    number, their average. Functions can return far more than single numbers. The
    output returned by functions can be a table of data, or a complex object such
    as the results of a linear model, or the instructions needed to draw a plot on
    the screen (as we shall see). They can even be other functions. For example, the
    `summary()` function performs a series of calculations on a vector and produces
    what is in effect a little table with named elements.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通过它们的参数接收输入，执行某些操作，并返回输出。输出的内容取决于函数执行的操作。`c()` 函数接收一系列以逗号分隔的元素，并返回一个包含这些相同元素的向量。`mean()`
    函数接收一个数字向量，并返回一个单一数字，即它们的平均值。函数可以返回比单一数字更多的内容。函数返回的输出可以是一个数据表，或者是一个复杂对象，如线性模型的输出，或者是在屏幕上绘制图形所需的指令（我们将看到）。它们甚至可以是其他函数。例如，`summary()`
    函数对一个向量执行一系列计算，并产生一个实际上带有命名元素的简表。
- en: A function’s argument names are internal to that function. Say you have created
    an object in your environment named `x`, for example. A function like `mean()`
    also has a named argument, `x`, but R will not get confused by this. It will not
    use your `x` object by mistake.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数名称是该函数内部的。比如说，你在你的环境中创建了一个名为 `x` 的对象。像 `mean()` 这样的函数也有一个名为 `x` 的命名参数，但
    R 不会因此混淆。它不会错误地使用你的 `x` 对象。
- en: 'As we have already seen with `c()` and `mean()`, you can assign the result
    of a function to an object:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经通过 `c()` 和 `mean()` 看到的，你可以将函数的结果分配给一个对象：
- en: '[PRE78]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'When you do this, there’s no output to the console. R just puts the results
    into the new object, as you instructed. To look inside the object you can type
    its name and hit return:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，控制台没有输出。R 只是将结果放入新的对象中，正如你所指示的。要查看对象的内容，你可以输入其名称并按回车键：
- en: '[PRE79]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 2.3.4 Functions come in libraries
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 函数来自库
- en: The code you write will be more or less complex depending on the task you want
    to accomplish. Once you have gotten used to working in R, you will probably end
    up writing your own functions to produce the results that you need. But as with
    other programming languages, you will not have to do everything yourself. Families
    of useful functions are bundled into libraries that you can install, load into
    your R session, and make use of as you work. Libraries save you from reinventing
    the wheel. They make it so that you do not, for example, have to figure out how
    to write code from scratch to draw a shape on screen, or load a data file into
    memory. Libraries are also what allow you to build on the efforts of others in
    order to do your own work. Ggplot is a library of functions. There are many other
    such libraries and we will make use of several throughout this book, either by
    loading them with the `library()` function, or “reaching in” to them and pulling
    a useful function from them directly. Writing code and functions of your own is
    a good way to get a sense of the amazing volume of effort put into R and its associated
    toolkits, work freely contributed by many hands over the years and available for
    anyone to use.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的代码的复杂程度将取决于你想要完成的任务。一旦你习惯了在 R 中工作，你可能会最终编写自己的函数来生成你需要的输出。但与其他编程语言一样，你不必自己完成所有事情。有用的函数系列被打包成库，你可以安装这些库，将它们加载到你的
    R 会话中，并在工作中使用它们。库可以让你避免重复造轮子。它们使得你不必，例如，从头开始编写代码来在屏幕上绘制形状，或加载数据文件到内存中。库还允许你利用他人的努力来开展自己的工作。Ggplot
    是一个函数库。还有许多其他这样的库，我们将在本书中多次使用它们，要么通过使用 `library()` 函数加载它们，要么“深入”到它们中直接提取有用的函数。编写自己的代码和函数是了解投入
    R 及其相关工具包中的惊人工作量的一种好方法，这是多年来许多人的自由贡献，任何人都可以使用。
- en: All of the visualization we will do will involve choosing the right function
    or functions, and then giving those functions the right instructions through a
    series of named arguments. Most of the mistakes we will make, and the errors we
    will fix, will involve us having not picked the right function, or having not
    fed the function the right arguments, or having failed to provide information
    in a form the function can understand.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的所有可视化都将涉及选择正确的函数或函数集，然后通过一系列命名参数给这些函数提供正确的指令。我们将会犯的大多数错误和我们将要修复的错误，将涉及我们没有选择正确的函数，或者没有向函数提供正确的参数，或者没有以函数可以理解的形式提供信息。
- en: For now, just remember that you do things in R by creating and manipulating
    named objects. You manipulate objects by feeding information about them to functions.
    The functions do something useful with that information (calculate a mean, recode
    a variable, fit a model) and give you the results back.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需记住，你在 R 中通过创建和操作命名对象来完成事情。你通过向函数提供有关它们的信息来操作对象。函数使用这些信息做些有用的事情（计算平均值、重新编码变量、拟合模型）并将结果返回给你。
- en: '[PRE81]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The first two functions here gave us a simple table of counts and calculated
    the standard deviation of `my_numbers`. It’s worth noticing what R did in the
    last three cases. First we multiplied `my_numbers` by two. R interprets that as
    you asking it to take each *element* of `my_numbers` one at a time and multiply
    it by five. It does the same with the instruction `my_numbers + 1`. The single
    value is “recycled” down the length of the vector. By contrast, in the last case
    we add `my_numbers` to itself. Because the two objects being added are the same
    length, R adds each element in the first vector to the corresponding element in
    the second vector. This is an example of a *vectorized* operation.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出的前两个函数给我们提供了一个简单的计数表，并计算了 `my_numbers` 的标准差。值得注意的是 R 在最后三个案例中的行为。首先，我们将
    `my_numbers` 乘以二。R 解释为你要它逐个乘以 `my_numbers` 的每个 *元素*。它对指令 `my_numbers + 1` 也做了同样的事情。单个值被“回收”到向量的长度。相比之下，在最后一个案例中，我们将
    `my_numbers` 加到它自己上。因为被加的两个对象长度相同，R 将第一个向量中的每个元素加到第二个向量中相应的元素上。这是一个 *向量化* 操作的例子。
- en: 2.3.5 If you’re not sure what an object is, ask for its class
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 如果你不确定一个对象是什么，可以询问它的类
- en: Every object has a *class*. This is the sort of object it is, whether a vector,
    a character string, a function, a list, and so on. Knowing an object’s class tells
    you a lot about what you can and can’t do with it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有一个 *类*。这是它所属的类型，无论是向量、字符字符串、函数、列表等等。了解一个对象的类可以让你知道很多关于你可以用它做什么和不能做什么的信息。
- en: '[PRE91]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Certain actions you take may change an object’s class. For instance, consider
    `my_numbers` again:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你采取的某些操作可能会改变一个对象的类别。例如，再次考虑 `my_numbers`：
- en: '[PRE97]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The function added the word “Apple” to our vector of numbers, as we asked. But
    in doing so, the result is that the new object also has a new class, switching
    from “numeric” to “character”. All the numbers are now enclosed in quotes. They
    have been turned into character strings. In that form, they can’t be used in calculations.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 添加单词“Apple”到我们的数字向量中，正如我们所请求的。但在这样做的时候，结果是新的对象也获得了一个新的类别，从“numeric”切换到“character”。所有的数字现在都被引号包围。它们已经被转换成了字符字符串。以这种形式，它们不能用于计算。
- en: Most of the work we’ll be doing will not involve directly picking out this or
    that value from vectors or other entities. Instead we will try to work at a slightly
    higher level that will be easier and safer. But it’s worth knowing just the very
    basicsThe Appendix has a little more discussion of the basics of selecting the
    elements within objects. of how elements of vectors can be referred to, because
    the c() function in particular is a useful tool.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的许多工作将不会直接从向量或其他实体中挑选出这个或那个值。相反，我们将尝试在一个稍微高一点的水平上工作，这将更容易也更安全。但了解如何引用向量元素的基础知识是值得的，因为
    `c()` 函数特别是一个有用的工具。
- en: 'We will spend a lot of time in this book working with a series of datasets.
    These typically start life as files stored locally on your computer or somewhere
    remotely accessible to you. Once they are imported into R, then like everything
    exist as objects of some kind. R has several classes of objects used to store
    data. A basic one is a matrix, which consists of rows and columns of numbers.
    But the most common kind of data object in R is a *data frame*, which you can
    think of as a rectangular table consisting of rows (of observations) and columns
    (of variables). In a data frame the columns can be of different classes. Some
    may be character strings, some numeric, and so on. For instance, here is a very
    small dataset from the `socviz` library:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将花费大量时间处理一系列数据集。这些数据集通常最初存储在你的计算机本地或你远程可访问的地方的文件中。一旦它们被导入到 R 中，它们就像所有其他事物一样，以某种类型的对象存在。R
    有几个用于存储数据的对象类别。一个基本的是矩阵，它由数字的行和列组成。但 R 中最常见的数据对象类型是 *数据框*，你可以将其想象为一个由行（观测值）和列（变量）组成的矩形表。在数据框中，列可以是不同的类别。一些可能是字符字符串，一些是数值型，等等。例如，这里是从
    `socviz` 库中的一个非常小的数据集：
- en: '[PRE101]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In this `titanic` data, two of the columns are numeric and two are not. You
    can access the rows and columns in various ways. For example, the `$` operator
    allows you to pick out a named column of a data frame:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `titanic` 数据中，有两列是数值型的，有两列不是。你可以以各种方式访问行和列。例如，`$` 运算符允许你选择数据框的一个命名列：
- en: '[PRE105]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: In Appendix [A.1.2](appendix.html#app-select) there is a little more information
    about selecting particular elements from different kinds of objects.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在附录 [A.1.2](appendix.html#app-select) 中，有更多关于从不同类型的对象中选择特定元素的基础知识的讨论。
- en: 'We will also regularly encounter a slightly augmented version of a data frame
    called a *tibble*. The tidyverse libraries make extensive use of tibbles. Like
    data frames, they are used to store variables of different classes all together
    in a single table of data. They also do a little more to let us know about what
    they contain, and are a little more friendly when interacted with from the console.
    We can convert a data frame to a tibble if we want:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将经常遇到数据框的一个稍微增强的版本，称为 *tibble*。tidyverse 库广泛使用 tibbles。像数据框一样，它们用于将不同类别的变量一起存储在单个数据表中。它们还做了一些额外的工作，让我们了解它们包含的内容，并且在与控制台交互时更加友好。如果我们想，我们可以将数据框转换为
    tibble：
- en: '[PRE107]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Look carefully at the top and bottom of the output to see what additional information
    the tibble class gives you over and above the data frame version.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看输出顶部和底部，以了解 tibble 类比数据框版本提供了哪些额外信息。
- en: 2.3.6 To see inside an object, ask for its structure
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.6 要查看对象内部，请请求其结构
- en: The `str()` function is sometimes useful. It lets you see what is inside an
    object.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`str()` 函数有时很有用。它让你可以看到对象内部的内容。'
- en: '[PRE109]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Fair warning: while some objects are relatively simple (a vector is just a
    sequence of numbers), others are more complicated, so asking about their `str()`
    might output a forbidding amount of information to the console. In general, complex
    objects are organized collections of simpler objects, often assembled as a big
    list, sometimes with a nested structure. Think for example of a master to-do list
    for a complex activity like moving house. It might be organized into sub-tasks
    of different kinds, several of which would themselves have lists of individual
    items. One list of tasks might be related to scheduling the moving truck, another
    might cover things to be donated, and a third list of tasks might be related to
    setting up utilities at the new house. In a similar sort of way, the objects we
    create to make plots will have many parts and sub-parts, as the overall task of
    drawing a plot has many individual to-do items. But we will be able to build these
    objects up from simple forms through a series of well-defined steps. And unlike
    moving house, the computer will take care of actually carrying out the task for
    us. We just need to get the to-do list right.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下：虽然有些对象相对简单（向量只是一系列数字的序列），但其他对象则更复杂，所以询问它们的 `str()` 可能会在控制台输出大量的信息。一般来说，复杂对象是由更简单的对象组成的组织集合，通常是一个大列表，有时具有嵌套结构。例如，考虑一个复杂活动（如搬家）的主待办事项列表。它可能被组织成不同种类的子任务，其中一些子任务本身可能有自己的项目列表。一个任务列表可能与安排搬家卡车的时间表相关，另一个可能与捐赠物品相关，而第三个任务列表可能与在新家中设置公用事业相关。以类似的方式，我们创建用于制作图表的对象将具有许多部分和子部分，因为绘制图表的整体任务有许多单独的待办事项。但我们将能够通过一系列定义良好的步骤从简单形式构建这些对象。而且与搬家不同，计算机将为我们实际执行任务。我们只需要确保待办事项列表正确无误。
- en: 2.3.1 Everything has a name
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 所有的东西都有一个名字
- en: In R, everything you deal with has a name. You refer to things by their names
    as you examine, use, or modify them. Named entities include variables (like `x`,
    or `y`), data that you have loaded (like `my_data`), and functions that you use.
    (More about functions momentarily.) You will spend a lot of time talking about,
    creating, referring to, and modifying things with names.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，你处理的所有东西都有一个名字。你通过名字来引用它们，无论是检查、使用还是修改它们。命名实体包括变量（如 `x` 或 `y`）、你加载的数据（如
    `my_data`）以及你使用的函数。（关于函数的更多信息稍后提供。）你将花费大量时间讨论、创建、引用和修改带有名字的事物。
- en: Some names are forbidden. These include reserved words like `FALSE` and `TRUE`,
    core programming words like `Inf`, `for`, `else`, `break`, `function`, and words
    for special entities like `NA` and `NaN`. (These last two are codes designating
    missing data and “Not a Number”, respectively.) You probably won’t use these names
    by accident, but it’s good do know that they are not allowed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 有些名字是禁止使用的。这些包括像 `FALSE` 和 `TRUE` 这样的保留字，像 `Inf`、`for`、`else`、`break`、`function`
    这样的核心编程词汇，以及像 `NA` 和 `NaN` 这样的特殊实体名称。（最后两个是表示缺失数据和“不是一个数字”的代码。）你可能不会意外地使用这些名字，但了解它们是不被允许的总是好的。
- en: Some names you should not use, even if they are technically permitted. These
    are mostly words that are already in use for objects or functions that form part
    of the core of R. These include the names of basic functions like `q()` or `c()`,
    common statistical functions like `mean()`, `range()` or `var()`, and built-in
    mathematical constants like `pi`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有些名字你不应该使用，即使技术上允许。这些主要是已经用于构成 R 核心的对象或函数的单词。这包括像 `q()` 或 `c()` 这样的基本函数名称，像
    `mean()`、`range()` 或 `var()` 这样的常见统计函数，以及像 `pi` 这样的内置数学常数。
- en: Names in R are case sensitive. The object `my_data` is not the same as the object
    `My_Data`. When choosing names for things, be concise, consistent, and informative.
    Follow the style of the tidyverse and name things in lower case, separating words
    with the underscore character, `_`, as needed. Do not use spaces when naming things,
    including variables in your data.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的名字是区分大小写的。对象 `my_data` 与对象 `My_Data` 不相同。在为事物选择名字时，要简洁、一致且具有信息性。遵循 tidyverse
    风格，用小写字母命名事物，根据需要用下划线字符 `_` 分隔单词。在命名事物时不要使用空格，包括数据中的变量。
- en: 2.3.2 Everything is an object
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 所有的东西都是一个对象
- en: Some objects are built in to R, some are added via libraries, and some are created
    by the user. But almost everything is some kind of object. The code you write
    will create, manipulate, and use named objects as a matter of course. We can start
    immediately. Let’s create a vector of numbers. The command `c()` is a function.
    It’s short for “combine” or “concatenate”. It will take a sequence of comma-separated
    things inside the parentheses and join them together into a vector where each
    element is still individually accessible.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一些对象是 R 内置的，一些是通过库添加的，还有一些是由用户创建的。但几乎一切都是某种对象。你编写的代码将创建、操作和使用命名对象，这是理所当然的。我们可以立即开始。让我们创建一个数字向量。`c()`
    命令是一个函数。它代表“组合”或“连接”。它将括号内以逗号分隔的一系列事物连接起来，形成一个向量，其中每个元素仍然可以单独访问。
- en: '[PRE113]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Instead of sending the result to the console, we can instead *assign* it to
    an object we createYou can type the arrow using `<` and then `-`.:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将结果发送到控制台，也可以将其**分配**给我们创建的对象。你可以使用 `<` 和 `-` 来输入箭头：
- en: '[PRE115]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'To see what you made, type the name of the object and hit return:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你创建的内容，请输入对象的名称并按回车键：
- en: '[PRE116]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Each of our numbers is still there, and can be accessed directly if we want.
    They are now just part of a new object, a vector, called `my_numbers`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有数字仍然在那里，如果我们想直接访问它们也是可以的。它们现在只是新对象，一个向量，称为 `my_numbers` 的组成部分。
- en: 'You create objects by assigning them to names. The *assignment operator* is
    `<-`. Think of assignment as the verb “gets”, reading left to right. So, the bit
    of code above can be read as “The object `my_numbers` gets the result of concatenating
    the following numbers: 1, 2, …” TheIf you only learn one keyboard shortcut in
    RStudio make it this one! Always use `Option+minus` on MacOS or `Alt+minus` on
    Windows to type the assignment operator. operator is two separate keys on your
    keyboard: the `<` key and the `-` (minus) key. Because you type this so often
    in R, there is a shortcut for it in R Studio. To write the assignment operator
    in one step, hold down the `option` key and hit `-`. On Windows hold down the
    `alt` key and hit `-`. You will be constantly creating objects in this way, and
    trying typing the two characters separately is both tedious and prone to error.
    You will make hard-to-notice mistakes like typing `< -` (with a space in between
    the characters) instead of `<-`.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过将它们分配给名称来创建对象。**赋值运算符**是 `<-`。将赋值想象成动词“得到”，从左到右读取。因此，上面的代码片段可以读作“对象 `my_numbers`
    得到了以下数字连接的结果：1, 2, …”。如果你只在 RStudio 中学习一个键盘快捷键，那就让它成为这个吧！在 MacOS 上始终使用 `Option+minus`，在
    Windows 上使用 `Alt+minus` 来输入赋值运算符。赋值运算符在键盘上是两个单独的键：`<` 键和 `-`（减号）键。因为你在 R 中输入这个符号如此频繁，R
    Studio 中有一个快捷键。要一步写出赋值运算符，请按住 `option` 键并敲击 `-`。在 Windows 上，请按住 `alt` 键并敲击 `-`。你将不断地以这种方式创建对象，单独输入这两个字符既麻烦又容易出错。你可能会犯一些难以察觉的错误，比如输入
    `< -`（字符之间有空格）而不是 `<-`。
- en: When you create objects by assigning things to names, they come into existence
    in R’s *workspace* or *environment*. You can think of this most straightforwardly
    as your project directory. Your workspace is specific to your current project.
    It is the folder from which you launched R. Unless you have particular needs (such
    as extremely large datasets or analytical tastes that take a very long time) you
    will not need to give any thought to where objects “really” live. Just think of
    your code and data files as the permanent features of your project. When you start
    up an R project, you will generally begin by loading your data. That is, you will
    read it in from disk and assign it to a named object like `my_data`. The rest
    of your code will be a series of instructions to act on and create more named
    objects.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过将事物分配给名称来创建对象时，它们在 R 的**工作区**或**环境**中存在。你可以最直接地将其想象成你的项目目录。你的工作区仅针对你的当前项目。它是你启动
    R 的文件夹。除非你有特殊需求（例如非常大的数据集或需要很长时间的分析偏好），否则你不需要考虑对象“真正”在哪里。只需将你的代码和数据文件视为你项目的永久特征。当你启动一个
    R 项目时，你通常首先加载数据。也就是说，你会从磁盘读取它并将其分配给一个名为 `my_data` 的命名对象。你代码的其余部分将是一系列指令，用于操作和创建更多的命名对象。
- en: 2.3.3 You do things using functions
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 使用函数做事
- en: '![Upper: What functions look like, very schematically. Lower: an imaginary
    function that takes two vectors and plots them with a title. We supply the function
    with the particular vectors we want it to use, and the title. The vectors are
    objects, so are given as-is. The title is not an object, so we enclose it in quotes.](../Images/7a6859d77a6a3eaf81c369f8905db946.png)
    Figure 2.5: Upper: What functions look like, very schematically. Lower: an imaginary
    function that takes two vectors and plots them with a title. We supply the function
    with the particular vectors we want it to use, and the title. The vectors are
    objects, so are given as-is. The title is not an object, so we enclose it in quotes.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![上图：函数的外观，非常简略。下图：一个想象中的函数，它接受两个向量并将它们以标题的形式绘制出来。我们向函数提供我们想要它使用的特定向量以及标题。向量是对象，所以直接给出。标题不是对象，所以我们用引号括起来。](../Images/7a6859d77a6a3eaf81c369f8905db946.png)
    图2.5：上图：函数的外观，非常简略。下图：一个想象中的函数，它接受两个向量并以标题的形式绘制它们。我们向函数提供我们想要它使用的特定向量以及标题。向量是对象，所以直接给出。标题不是对象，所以我们用引号括起来。'
- en: You do almost everything in R using functions. Think of a function as a special
    kind of object that can perform actions for you. It produces output based on the
    input that it receives. Like a good dog, when we want a function to do something
    for us, we *call* it. Somewhat less like a dog, it will reliably do what we tell
    it. We give the function some information, it acts on that information, and some
    results come out the other side. Functions can be recognized by the parentheses
    at the end of their names. This distinguishes them from other objects, such as
    single numbers, named vectors, tables of data, and so on.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，你几乎用函数做所有事情。将函数视为一种特殊类型的对象，它可以为你执行操作。它根据接收到的输入产生输出。就像一只好狗，当我们想让函数为我们做某事时，我们*调用*它。多少有点不像狗，它会可靠地执行我们告诉它的事情。我们给函数一些信息，它根据这些信息行动，然后从另一边产生一些结果。函数可以通过其名称末尾的括号来识别。这使它们与其他对象区分开来，例如单个数字、命名向量、数据表等。
- en: 'The parentheses are what allow you to send information to the function. Most
    functions accept one or more named *arguments*. A function’s arguments are the
    things it needs to know in order to do something. They can be some bit of your
    data (`data = my_numbers`), or specific instructions (`title = "GDP per Capita"`),
    or an option you want to choose (`smoothing = "splines", show = FALSE`). For example,
    the object `my_numbers` is a numeric vector:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 括号允许你向函数发送信息。大多数函数接受一个或多个命名*参数*。函数的参数是它需要知道以执行某事的东西。它们可以是你的数据的一部分（`data = my_numbers`），或特定的指令（`title
    = "人均GDP"`），或你想要选择的选项（`smoothing = "splines", show = FALSE`）。例如，对象`my_numbers`是一个数值向量：
- en: '[PRE118]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: But the thing we used to create it, `c()`, is a function. It concatenates items
    into a vector composed of the series of comma-separated elements you give it.
    Similarly, `mean()` is a function that calculates a simple average for a vector
    of numbers. What happens if we just type `mean()` without any arguments inside
    the parentheses?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们用来创建它的东西，`c()`，是一个函数。它将项目连接成一个由逗号分隔的元素组成的向量。同样，`mean()`是一个函数，它计算数字向量的简单平均值。如果我们只是键入`mean()`而不在括号内提供任何参数会发生什么？
- en: '[PRE120]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The error message is terse but informative. The function needs an argument
    to work, and we haven’t given it one. In this case, ‘x’, the name of another object
    that `mean()` can perform its calculation on:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息简洁但信息丰富。该函数需要一个参数才能工作，而我们还没有给它提供。在这种情况下，“x”，另一个名为“mean()”可以执行其计算的物体的名称：
- en: '[PRE121]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'While the function arguments have names that are used internally, (here, `x`),
    you don’t strictly need to specify the name for the function to work:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数参数有内部使用的名称（这里，`x`），但你并不严格需要指定名称以使函数工作：
- en: '[PRE125]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: If you omit the name of the argument, R will just assume you are giving the
    function what it needs, and in a default order. The documentation for a function
    will tell you what the order of required arguments is for any particular function.See
    the Appendix for a guide to how to read the help page for a function. For simple
    functions that only require one or two arguments, omitting their names is usually
    not confusing. For more complex functions, you will typically want to use the
    names of the arguments rather than try to remember what the ordering is.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你省略了参数的名称，R 会假设你正在按照默认顺序提供函数所需的参数。函数的文档会告诉你特定函数所需参数的顺序。参见附录，了解如何阅读函数的帮助页面。对于只需要一个或两个参数的简单函数，省略它们的名称通常不会造成混淆。对于更复杂的函数，你通常会希望使用参数的名称，而不是试图记住它们的顺序。
- en: In general, when providing arguments to a function the syntax is `<argument>
    = <value>`. If `<value>` is a named *object* that already exists in your workspace,
    like a vector of numbers of a table of data, then you provide it unquoted, as
    in `mean(my_numbers)`. If `<value>` is not an object, a number, or a logical value
    like `TRUE`, then you usually put it in quotes, e.g., `labels(x = "X Axis Label")`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，向函数提供参数时，语法是 `<argument> = <value>`。如果 `<value>` 是一个已经存在于你工作空间中的命名 *对象*，比如数字向量或数据表，那么你可以不使用引号提供它，例如
    `mean(my_numbers)`。如果 `<value>` 不是一个对象、一个数字或像 `TRUE` 这样的逻辑值，那么你通常需要用引号括起来，例如，`labels(x
    = "X Axis Label")`。
- en: Functions take inputs via their arguments, do something, and return outputs.
    What the output is depends on what the function does. The `c()` function takes
    a sequence of comma-separated elements and returns a vector consisting of those
    same elements. The `mean()` function takes a vector of numbers and returns a single
    number, their average. Functions can return far more than single numbers. The
    output returned by functions can be a table of data, or a complex object such
    as the results of a linear model, or the instructions needed to draw a plot on
    the screen (as we shall see). They can even be other functions. For example, the
    `summary()` function performs a series of calculations on a vector and produces
    what is in effect a little table with named elements.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通过它们的参数接收输入，执行某些操作，并返回输出。输出的内容取决于函数执行的操作。`c()` 函数接收一系列以逗号分隔的元素，并返回一个包含这些相同元素的向量。`mean()`
    函数接收一个数字向量，并返回一个单一数字，即它们的平均值。函数可以返回比单一数字更多的内容。函数返回的输出可以是一个数据表，或者是一个复杂对象，如线性模型的输出，或者是在屏幕上绘制图形所需的指令（我们将会看到）。它们甚至可以是其他函数。例如，`summary()`
    函数对一个向量执行一系列计算，并生成一个实际上带有命名元素的简表。
- en: A function’s argument names are internal to that function. Say you have created
    an object in your environment named `x`, for example. A function like `mean()`
    also has a named argument, `x`, but R will not get confused by this. It will not
    use your `x` object by mistake.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数名称是该函数内部的。比如说，你在你的环境中创建了一个名为 `x` 的对象。像 `mean()` 这样的函数也有一个名为 `x` 的命名参数，但
    R 不会因此混淆。它不会错误地使用你的 `x` 对象。
- en: 'As we have already seen with `c()` and `mean()`, you can assign the result
    of a function to an object:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经通过 `c()` 和 `mean()` 看到的，你可以将函数的结果赋给一个对象：
- en: '[PRE127]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'When you do this, there’s no output to the console. R just puts the results
    into the new object, as you instructed. To look inside the object you can type
    its name and hit return:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，控制台不会有输出。R 只是将结果放入你指定的新的对象中。要查看对象的内容，你可以输入它的名字并按回车键：
- en: '[PRE128]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 2.3.4 Functions come in libraries
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 函数来自库
- en: The code you write will be more or less complex depending on the task you want
    to accomplish. Once you have gotten used to working in R, you will probably end
    up writing your own functions to produce the results that you need. But as with
    other programming languages, you will not have to do everything yourself. Families
    of useful functions are bundled into libraries that you can install, load into
    your R session, and make use of as you work. Libraries save you from reinventing
    the wheel. They make it so that you do not, for example, have to figure out how
    to write code from scratch to draw a shape on screen, or load a data file into
    memory. Libraries are also what allow you to build on the efforts of others in
    order to do your own work. Ggplot is a library of functions. There are many other
    such libraries and we will make use of several throughout this book, either by
    loading them with the `library()` function, or “reaching in” to them and pulling
    a useful function from them directly. Writing code and functions of your own is
    a good way to get a sense of the amazing volume of effort put into R and its associated
    toolkits, work freely contributed by many hands over the years and available for
    anyone to use.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的代码的复杂程度将取决于你想要完成的任务。一旦你习惯了在R中工作，你可能会最终编写自己的函数来生成你需要的输出。但与其他编程语言一样，你不必事事亲力亲为。有用的函数系列被打包成库，你可以安装这些库，将它们加载到你的R会话中，并在工作中使用它们。库可以帮助你避免重复造轮子。它们使得你不必，例如，从头开始编写代码来在屏幕上绘制形状，或加载数据文件到内存中。库还允许你利用他人的努力来开展自己的工作。Ggplot是一个函数库。还有许多其他这样的库，我们将在本书中多次使用它们，要么通过使用`library()`函数加载它们，要么“深入”到它们中直接提取有用的函数。编写自己的代码和函数是了解投入R及其相关工具包中的惊人工作量的一种好方法，这是多年来许多人的自由贡献，任何人都可以使用。
- en: All of the visualization we will do will involve choosing the right function
    or functions, and then giving those functions the right instructions through a
    series of named arguments. Most of the mistakes we will make, and the errors we
    will fix, will involve us having not picked the right function, or having not
    fed the function the right arguments, or having failed to provide information
    in a form the function can understand.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的所有可视化都将涉及选择正确的函数或函数集，然后通过一系列命名参数向这些函数提供正确的指令。我们将会犯的大部分错误和我们将要修复的错误，将涉及我们没有选择正确的函数，或者没有向函数提供正确的参数，或者没有以函数能够理解的形式提供信息。
- en: For now, just remember that you do things in R by creating and manipulating
    named objects. You manipulate objects by feeding information about them to functions.
    The functions do something useful with that information (calculate a mean, recode
    a variable, fit a model) and give you the results back.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需记住，你在R中通过创建和操作命名对象来完成事情。你通过向函数提供有关对象的信息来操作对象。函数使用这些信息做些有用的事情（计算平均值、重新编码变量、拟合模型）并将结果返回给你。
- en: '[PRE130]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The first two functions here gave us a simple table of counts and calculated
    the standard deviation of `my_numbers`. It’s worth noticing what R did in the
    last three cases. First we multiplied `my_numbers` by two. R interprets that as
    you asking it to take each *element* of `my_numbers` one at a time and multiply
    it by five. It does the same with the instruction `my_numbers + 1`. The single
    value is “recycled” down the length of the vector. By contrast, in the last case
    we add `my_numbers` to itself. Because the two objects being added are the same
    length, R adds each element in the first vector to the corresponding element in
    the second vector. This is an example of a *vectorized* operation.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这里前两个函数为我们提供了一个简单的计数表，并计算了`my_numbers`的标准差。值得注意的是R在最后三个案例中的行为。首先，我们将`my_numbers`乘以二。R将其解释为你要求它逐个乘以`my_numbers`中的每个*元素*。它对指令`my_numbers
    + 1`也做了同样的事情。单个值被“回收”到向量的长度。相比之下，在最后一个案例中，我们将`my_numbers`加到它自己上。因为被加的两个对象长度相同，R将第一个向量中的每个元素加到第二个向量中相应的元素上。这是一个*向量化*操作的例子。
- en: 2.3.5 If you’re not sure what an object is, ask for its class
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 如果你不确定一个对象是什么，可以询问它的类
- en: Every object has a *class*. This is the sort of object it is, whether a vector,
    a character string, a function, a list, and so on. Knowing an object’s class tells
    you a lot about what you can and can’t do with it.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有一个*类*。这是它的对象类型，无论是向量、字符字符串、函数、列表等等。了解一个对象的类可以告诉你很多关于你可以用它做什么和不能做什么的信息。
- en: '[PRE140]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Certain actions you take may change an object’s class. For instance, consider
    `my_numbers` again:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 您采取的某些操作可能会改变对象的类别。例如，再次考虑`my_numbers`：
- en: '[PRE146]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The function added the word “Apple” to our vector of numbers, as we asked. But
    in doing so, the result is that the new object also has a new class, switching
    from “numeric” to “character”. All the numbers are now enclosed in quotes. They
    have been turned into character strings. In that form, they can’t be used in calculations.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数按照我们的要求，将单词“Apple”添加到了我们的数字向量中。但在这样做的同时，结果是新的对象也获得了一个新的类别，从“numeric”切换到“character”。所有的数字现在都被引号包围。它们已经被转换成了字符字符串。以这种形式，它们不能用于计算。
- en: Most of the work we’ll be doing will not involve directly picking out this or
    that value from vectors or other entities. Instead we will try to work at a slightly
    higher level that will be easier and safer. But it’s worth knowing just the very
    basicsThe Appendix has a little more discussion of the basics of selecting the
    elements within objects. of how elements of vectors can be referred to, because
    the c() function in particular is a useful tool.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的的大部分工作将不会涉及直接从向量或其他实体中挑选这个或那个值。相反，我们将尝试在一个稍微高一级的水平上工作，这将更容易也更安全。但了解元素如何引用的非常基础的知识是值得的，因为c()函数特别是一个有用的工具。附录中对选择对象内元素的基本知识有一些讨论。
- en: 'We will spend a lot of time in this book working with a series of datasets.
    These typically start life as files stored locally on your computer or somewhere
    remotely accessible to you. Once they are imported into R, then like everything
    exist as objects of some kind. R has several classes of objects used to store
    data. A basic one is a matrix, which consists of rows and columns of numbers.
    But the most common kind of data object in R is a *data frame*, which you can
    think of as a rectangular table consisting of rows (of observations) and columns
    (of variables). In a data frame the columns can be of different classes. Some
    may be character strings, some numeric, and so on. For instance, here is a very
    small dataset from the `socviz` library:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将花费大量时间处理一系列数据集。这些数据集通常最初存储在您的计算机本地或您可以远程访问的地方的文件中。一旦它们被导入到R中，就像所有其他事物一样，它们都作为某种类型的对象存在。R有几种用于存储数据的对象类别。其中一个是矩阵，它由数字的行和列组成。但在R中最常见的数据对象类型是*数据框*，您可以将它想象成一个由行（观测值）和列（变量）组成的矩形表格。在数据框中，列可以是不同的类别。有些可能是字符字符串，有些是数值，等等。例如，这里是从`socviz`库中一个非常小的数据集：
- en: '[PRE150]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'In this `titanic` data, two of the columns are numeric and two are not. You
    can access the rows and columns in various ways. For example, the `$` operator
    allows you to pick out a named column of a data frame:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`titanic`数据中，有两列是数值的，有两列不是。您可以通过各种方式访问行和列。例如，`$`运算符允许您从数据框中挑选出命名的列：
- en: '[PRE154]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: In Appendix [A.1.2](appendix.html#app-select) there is a little more information
    about selecting particular elements from different kinds of objects.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在附录[A.1.2](appendix.html#app-select)中，有更多关于从不同类型的对象中选择特定元素的信息。
- en: 'We will also regularly encounter a slightly augmented version of a data frame
    called a *tibble*. The tidyverse libraries make extensive use of tibbles. Like
    data frames, they are used to store variables of different classes all together
    in a single table of data. They also do a little more to let us know about what
    they contain, and are a little more friendly when interacted with from the console.
    We can convert a data frame to a tibble if we want:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将经常遇到一种稍微增强的数据框版本，称为*tibble*。tidyverse库广泛使用了tibbles。与数据框一样，它们用于将不同类别的变量全部存储在单个数据表中。它们还做了一些额外的工作，让我们了解它们包含的内容，并且在与控制台交互时更加友好。如果我们想，可以将数据框转换为tibble：
- en: '[PRE156]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Look carefully at the top and bottom of the output to see what additional information
    the tibble class gives you over and above the data frame version.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看输出顶部和底部，以了解tibble类别相对于数据框版本提供了哪些额外信息。
- en: 2.3.6 To see inside an object, ask for its structure
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.6 要查看对象内部，请请求其结构
- en: The `str()` function is sometimes useful. It lets you see what is inside an
    object.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`str()`函数有时很有用。它让您可以看到对象内部的内容。'
- en: '[PRE158]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Fair warning: while some objects are relatively simple (a vector is just a
    sequence of numbers), others are more complicated, so asking about their `str()`
    might output a forbidding amount of information to the console. In general, complex
    objects are organized collections of simpler objects, often assembled as a big
    list, sometimes with a nested structure. Think for example of a master to-do list
    for a complex activity like moving house. It might be organized into sub-tasks
    of different kinds, several of which would themselves have lists of individual
    items. One list of tasks might be related to scheduling the moving truck, another
    might cover things to be donated, and a third list of tasks might be related to
    setting up utilities at the new house. In a similar sort of way, the objects we
    create to make plots will have many parts and sub-parts, as the overall task of
    drawing a plot has many individual to-do items. But we will be able to build these
    objects up from simple forms through a series of well-defined steps. And unlike
    moving house, the computer will take care of actually carrying out the task for
    us. We just need to get the to-do list right.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：虽然有些对象相对简单（向量只是一系列数字的序列），但其他对象则更为复杂，因此询问它们的 `str()` 可能会在控制台输出大量令人望而生畏的信息。一般来说，复杂对象是由更简单的对象组成的组织集合，通常作为一个大列表，有时具有嵌套结构。例如，考虑一个复杂活动如搬家的大任务待办清单。它可能被组织成不同种类的子任务，其中一些子任务本身可能有自己的项目列表。一个任务列表可能与调度搬家卡车有关，另一个可能与捐赠物品有关，而第三个任务列表可能与在新家中设置公用事业有关。以类似的方式，我们创建用于制作图表的对象将具有许多部分和子部分，因为绘制图表的整体任务有许多单独的任务项。但我们将能够通过一系列定义良好的步骤从简单形式构建这些对象。而且与搬家不同，计算机将为我们执行实际的任务。我们只需要确保待办清单正确无误。
- en: 2.4 Be patient with R, and with yourself
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 对 R 和自己要有耐心
- en: Like all programming languages, R does exactly what you tell it to, rather than
    exactly what you want it to. This can make it frustrating to work with. It is
    as if one had an endlessly energetic, powerful, but also extremely literal-minded
    robot to order around. Remember that no-one writes fluent, error-free code on
    the first go all the time. From simple typos to big misunderstandings, mistakes
    are a standard part of the activity of programming. This is why error-checking,
    debugging, and testing are also a central part of programming. So, just try to
    be patient with yourself and with R while you use it. Expect to make errors, and
    don’t worry when that happens. You won’t break anything. Each time you figure
    out why a bit of code has gone wrong you will have learned a new thing about how
    the language works.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有编程语言一样，R 完全按照你告诉它的去做，而不是按照你想要它做的去做。这可能会让人感到沮丧。这就像有一个永无止境的、强大的、但同时也非常字面意思的机器人来指挥。记住，没有人总是第一次就能写出流畅且无错误的代码。从简单的打字错误到大的误解，错误是编程活动中的标准部分。这就是为什么错误检查、调试和测试也是编程的核心部分。所以，在使用
    R 的过程中，请对自己和 R 保持耐心。预期会出错，当这种情况发生时，不要担心。你不会破坏任何东西。每次你弄清楚为什么一段代码出了问题，你都会对语言的工作方式有新的了解。
- en: 'Here are three very specific things to watch out for:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三件非常具体的事情需要注意：
- en: Make sure parentheses are balanced and that every opening “`(`” has a corresponding
    closing “`)`”.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保括号平衡，并且每个开头的 “`(`” 都有一个相应的结尾 “`)`”。
- en: Make sure you complete your expressions. If you think you have completed typing
    your code, but instead of seeing the `>` command prompt at the console you see
    the `+` character instead, that may mean R thinks you haven’t written a complete
    expression yet. You can hit `Esc` or `Ctrl-C` to force your way back to the console
    and try typing your code again.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你完成了你的表达式。如果你认为你已经完成了代码的输入，但在控制台看到的是 `>` 命令提示符而不是 `+` 字符，这可能意味着 R 认为你还没有写完完整的表达式。你可以按
    `Esc` 或 `Ctrl-C` 强制回到控制台并再次尝试输入你的代码。
- en: 'In ggplot specifically, as you will see, we will build up plots a piece at
    a time by adding expressions to one another. When doing this, make sure your `+`
    character goes at the end of the line, and not the beginning. That is, write this:'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ggplot 中，正如你将看到的，我们将通过将表达式添加到一起逐步构建图表。当你这样做时，确保你的 `+` 字符位于行的末尾，而不是开头。也就是说，这样写：
- en: '[PRE162]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'and not this:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是这样：
- en: '[PRE163]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: R Studio will do its best to help you with the task of writing your code. It
    will highlight your code by syntax; it will try to match characters (like parentheses)
    that need to be balanced; it will try to narrow down the source of errors in code
    that fails to run; it will try to auto-complete the names of objects you type,
    so that you make fewer typos; it will make help files more easily accessible and
    the arguments of functions directly available. Go slowly and see how the software
    is trying to help you out.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: R Studio 将尽力帮助你完成编写代码的任务。它将通过语法突出显示你的代码；它将尝试匹配需要平衡的字符（如括号）；它将尝试缩小无法运行的代码中的错误来源；它将尝试自动完成你输入的对象名称，这样你就可以减少输入错误；它将使帮助文件更容易访问，并使函数的参数直接可用。慢慢来，看看软件是如何试图帮助你解决问题的。
- en: 2.5 Get data into R
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 将数据导入 R
- en: Before we can plot anything at all we have to get our data into R in a format
    it can use. Cleaning and reading in your data is one of the least immediately
    satisfying pieces of an analysis, whether you use R, StataThese are all commercial
    software applications for statistical analysis. Stata, in particular, is in wide
    use across the social sciences., SAS, SPSS, or any other statistical software.
    This is the reason that many of the datasets for this book are provided in a pre-prepared
    form via the `socviz` library rather than as data files you must manually read
    in. However, it is something you will have to face, and that you will want to
    do, sooner rather than later if you want to use the skills you learn in this book.
    We might as well see how to do it now. Even when learning R, it can be useful
    and very motivating to try out the code on your own data rather than working with
    the sample datasets.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够绘制任何东西之前，我们必须将数据以 R 可以使用的形式导入到 R 中。清理和读取数据是分析中最不令人满意的部分之一，无论你使用 R、Stata、SAS、SPSS
    或任何其他统计软件。这也是本书中的许多数据集通过 `socviz` 库以预准备的形式提供而不是作为必须手动读取的数据文件的原因。然而，这是你必须面对的，也是你想要尽早而不是更晚完成的事情，如果你想要使用本书中学到的技能。我们不妨现在看看如何操作。即使在学习
    R 时，尝试使用自己的数据而不是样本数据集来运行代码也是非常有用和鼓舞人心的。
- en: Use the `read_csv()` function to read in comma separated data. This function
    is in the `readr` library, one of the pieces of the tidyverse. R and the tidyverse
    also have functions to import various Stata, SAS, and SPSS formats directly. These
    can be found in the `haven` library. All we need to do is point `read_csv()` at
    a file. This can be a local file, e.g. in a subdirectory called `data/`, or it
    can be a remote file. If `read_csv()` is given a URL or ftp address it will follow
    it automatically. In this example, we have a CSV file called `organdonation.csv`
    stored at a remote location. While online, we assign the URL for the file to an
    object, for convenience, and then tell `read_csv()` to fetch it for us and put
    it in an object named `organs`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `read_csv()` 函数读取以逗号分隔的数据。此函数位于 `readr` 库中，它是 tidyverse 的一部分。R 和 tidyverse
    还提供了直接导入各种 Stata、SAS 和 SPSS 格式的函数。这些函数可以在 `haven` 库中找到。我们只需要将 `read_csv()` 函数指向一个文件。这可以是一个本地文件，例如在名为
    `data/` 的子目录中，或者它也可以是一个远程文件。如果 `read_csv()` 被提供了一个 URL 或 ftp 地址，它将自动跟随。在这个例子中，我们有一个名为
    `organdonation.csv` 的 CSV 文件，存储在远程位置。当在线时，我们为文件分配 URL 并将其分配给一个对象以方便使用，然后告诉 `read_csv()`
    为我们获取它并将其放入名为 `organs` 的对象中。
- en: '[PRE164]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The resulting message at the console tells us the `read_csv()` function has
    assigned a class to each of the columns of the object it created from the CSV
    file. There are columns with integer values, some are character strings, and so
    on. (The `double` class is for numbers other than integers.) Part of the reason
    `read_csv()` is telling you this information is that it is helpful to know what
    class each column, or variable, is. A variable’s class determines what sort of
    operations can be performed on it. You also see this information because the tidyverse’s
    `read_csv()` (with an underscore character in the middle of its name) is more
    opinionated than an older, and also still very widely-used function, `read.csv()`
    (with a period in the middle of its name). The newer `read_csv()` will not classify
    variables as factors unless you tell it to. This is in contrast to the older function,
    which treats any vector of characters as a factor unless told otherwise. Factors
    have some very useful features in R (especially when it comes to representing
    various kinds of treatment and control groups in experiments), but they often
    trip up users who are not fully aware of them. Thus, `read_csv()` avoids them
    unless you explicitly say otherwise.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出的结果消息告诉我们，`read_csv()` 函数已经为其从 CSV 文件创建的对象的每一列分配了一个类别。有一些列包含整数值，一些是字符字符串，等等。（`double`
    类别用于非整数的数字。）`read_csv()` 告诉你这些信息的一部分原因是了解每一列或变量的类别是有帮助的。变量的类别决定了可以对其执行的操作类型。你还看到这些信息，因为
    tidyverse 的 `read_csv()`（其名称中间有一个下划线字符）比一个较老但仍然非常广泛使用的函数 `read.csv()`（其名称中间有一个点字符）更有意见。较新的
    `read_csv()` 除非你明确告诉它，否则不会将变量分类为因子。这与较老的函数形成对比，后者除非明确告知，否则将任何字符向量视为因子。因子在 R 中有一些非常有用的特性（尤其是在表示实验中的各种处理和控制组时），但它们经常让那些不完全了解它们的人陷入困境。因此，`read_csv()`
    除非你明确表示，否则会避免使用因子。
- en: R can read in data files in many different formats. The `haven` package is part
    of the tidyverse. It provides functions to read files created in a variety of
    commercial software packages.R can also talk directly to databases, a topic not
    covered here. If your dataset is a Stata `.dta` file, for instance, you can use
    the `read_dta()` function in much the same way as we used `read_csv()` above.
    This function can read and write variables stored as logical values, integers,
    numbers, characters and factors. Stata also has a *labelled* data class that the
    haven library partially supports.See haven’s documentation for more details. In
    general you will end up converting labelled variables to one of R’s basic classes.
    Stata also supports an extensive coding scheme for missing data. This is generally
    not used directly in R, where missing data is coded simply as `NA`. Again, you
    will need to take care that any labelled variables imported into R are coded properly,
    so that you do not end up mistakenly using missing data in your analysis.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: R 可以读取多种不同格式的数据文件。`haven` 包是 tidyverse 的一部分。它提供了读取由各种商业软件包创建的文件的函数。R 还可以直接与数据库通信，但这不是本文讨论的主题。例如，如果你的数据集是一个
    Stata 的 `.dta` 文件，你可以使用 `read_dta()` 函数，其使用方式与上面我们使用的 `read_csv()` 几乎相同。这个函数可以读取和写入存储为逻辑值、整数、数字、字符和因子的变量。Stata
    还有一个 `labelled` 数据类别，haven 库部分支持。有关更多详细信息，请参阅 haven 的文档。通常，你最终会将标签变量转换为 R 的基本类别之一。Stata
    还支持一个广泛的缺失数据编码方案。这通常在 R 中不直接使用，在 R 中缺失数据简单地编码为 `NA`。同样，你需要注意，任何导入到 R 中的标签变量都应正确编码，以免在分析中错误地使用缺失数据。
- en: When preparing your data for use in R, and in particular for graphing with `ggplot`,
    bear in mind that it is best if it is represented in a “tidy” format. Essentially
    this means that your data should be in *long* rather than *wide* format, with
    every observation a row and every variable a column. We will discuss this in more
    detail in Chapter [3](makeplot.html#makeplot), and you can also consult the discussion
    of tidy data in the Appendix.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备在 R 中使用数据，特别是使用 `ggplot` 进行绘图时，请记住，最好以“整洁”格式表示。本质上这意味着你的数据应该以 *长* 格式而不是
    *宽* 格式，每个观测值一行，每个变量一列。我们将在第 [3](makeplot.html#makeplot) 章节中更详细地讨论这个问题，你还可以参考附录中关于整洁数据的讨论。
- en: 2.6 Make your first figure
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 制作你的第一个图表
- en: That’s enough ground-clearing for now. Writing code can be frustrating, but
    it also allows you to do interesting things quickly. Since the goal of this book
    is not to teach you all about R, but just how to produce good graphics, we can
    postpone a lot of details until later (or indeed ignore them indefinitely). We
    will start as we mean to go on, by using a function to make a named object, and
    plot the result. We will use the Gapminder dataset, which you should already have
    available on your computer. We load the data with `library()` and take a look.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经足够清理场地了。编写代码可能会让人感到沮丧，但它也允许你快速完成有趣的事情。由于本书的目标不是教你所有关于R的知识，而是仅仅教你如何制作好的图形，我们可以将很多细节推迟到以后（或者实际上无限期地忽略它们）。我们将从使用一个函数来创建一个命名对象并绘制结果开始，这样我们就可以继续前进。我们将使用Gapminder数据集，你应该已经在你的电脑上准备好了。我们使用`library()`来加载数据，并查看一下。
- en: '[PRE167]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: This is a table of data about a large number of countries, each observed over
    several years. Let’s make a scatterplot with it. Type the code below and try to
    get a sense of what’s happening. Don’t worry too much yet about the details.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于大量国家数据的表格，每个国家都被观察了多年。让我们用这个数据制作一个散点图。输入下面的代码，并尝试理解正在发生的事情。现在不必太担心细节。
- en: '[PRE169]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Figure 2.6: Life expectancy plotted against GDP per capita for a large number
    of country-years.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：大量国家-年数据中人均GDP与预期寿命的关系。
- en: '![Life expectancy plotted against GDP per capita for a large number of country-years.](../Images/4bb84df38c71e2e6800e0eb2e04fdea8.png)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![大量国家-年数据中人均GDP与预期寿命的关系](../Images/4bb84df38c71e2e6800e0eb2e04fdea8.png)'
- en: Not a bad start. Our graph is fairly legible, it has its axes informatively
    labeled, and it shows some sort of relationship between the two variables we have
    chosen. It could also be made better. Let’s learn more about how to improve it.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个不错的开始。我们的图表相当清晰，它的轴被信息性地标注，并且显示了我们所选择的两个变量之间的一些关系。它还可以做得更好。让我们学习更多关于如何改进它的方法。
- en: 2.7 Where to go next
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7 去哪里继续
- en: You should go straight to the next Chapter. However, you could also spend a
    little more time getting familiar with R and RStudio. Some information in the
    Appendix to this book might already be worth glancing at, especially the additional
    introductory material on R, and the discussion there about some common problems
    that tend to happen when reading in your own data. There`swirlstats.com` are several`tryr.codeschool.com`
    free or initially free online introductions`datacamp.com` to the R language that
    are worth trying. You do not need to know the material they cover in order to
    keep going with this book, but you might find one or more of them useful. If you
    get a little bogged down in any of them, or find the examples they choose are
    not that relevant to you, don’t worry. These introductions tend to want to introduce
    you to a range of programming concepts and tools that we will not need right away.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该直接跳到下一章。然而，你也可以花更多的时间熟悉R和RStudio。本书附录中的一些信息可能已经值得浏览，特别是关于R的额外入门材料，以及那里关于在读取自己的数据时经常出现的一些常见问题的讨论。`swirlstats.com`和`tryr.codeschool.com`有几个免费或最初免费的在线R语言介绍`datacamp.com`，值得一试。你不需要知道他们涵盖的材料才能继续阅读本书，但你可能会发现其中之一或多个对你有帮助。如果你在其中的任何一个中遇到了困难，或者发现他们选择的例子与你不太相关，不要担心。这些介绍倾向于介绍你一系列编程概念和工具，而我们不需要立即使用它们。
- en: It is also worth familiarizing yourself a little with how RStudio works and
    with what it can do for you. The RStudio website`rstudio.com` has a great deal
    of introductory material to help you along. You can also find a number of handy
    cheat sheets there that summarize different pieces of RStudio, RMarkdown, and
    various tidyverse packages that we will use throughout the book.`rstudio.com/resources/cheatsheets`
    These cheat-sheets are not meant to teach you the material. But they are helpful
    points of reference once you are up and running.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 也有必要熟悉一下RStudio的工作方式和它能为你做什么。RStudio网站`rstudio.com`有很多入门材料可以帮助你。你还可以在那里找到许多实用的速查表，总结了我们将全书使用的不同RStudio、RMarkdown和各种tidyverse包的内容.`rstudio.com/resources/cheatsheets`这些速查表不是为了教你材料，但一旦你开始使用，它们是很有帮助的参考资料。
