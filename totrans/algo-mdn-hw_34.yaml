- en: Newton's Method
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 牛顿法
- en: 原文：[https://en.algorithmica.org/hpc/arithmetic/newton/](https://en.algorithmica.org/hpc/arithmetic/newton/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://en.algorithmica.org/hpc/arithmetic/newton/](https://en.algorithmica.org/hpc/arithmetic/newton/)'
- en: Reaching the maximum possible precision is rarely required from a practical
    algorithm. In real-world data, modeling and measurement errors are usually several
    orders of magnitude larger than the errors that come from rounding floating-point
    numbers and such, and we are often perfectly happy with picking an approximate
    method that trades off precision for speed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际算法来说，很少需要达到最大可能的精度。在现实世界的数据中，建模和测量误差通常比来自舍入浮点数等的误差大几个数量级，我们通常对选择一个以速度换取精度的近似方法感到非常满意。
- en: 'In this section, we introduce one of the most important building blocks in
    such approximate, numerical algorithms: *Newton’s method*.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍这类近似数值算法中最重要构建块之一：*牛顿法*。
- en: '## [#](https://en.algorithmica.org/hpc/arithmetic/newton/#newtons-method)Newton’s
    Method'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '## [#](https://en.algorithmica.org/hpc/arithmetic/newton/#newtons-method) 牛顿法'
- en: 'Newton’s method is a simple yet very powerful algorithm for finding approximate
    roots of real-valued functions, that is, the solutions to the following generic
    equation:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿法是一种简单但非常强大的算法，用于寻找实值函数的近似根，即以下通用方程的解：
- en: $$ f(x) = 0 $$
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: $$ f(x) = 0 $$
- en: The only thing assumed about the function $f$ is that at least one root exists
    and that $f(x)$ is continuous and differentiable on the search interval. There
    are also some [boring corner cases](https://en.wikipedia.org/wiki/Newton%27s_method#Failure_analysis),
    but they almost never occur in practice, so we will just informally say that the
    function is “good.”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数 $f$ 的唯一假设是至少存在一个根，并且 $f(x)$ 在搜索区间上是连续且可微的。还有一些[无聊的边界情况](https://en.wikipedia.org/wiki/Newton%27s_method#Failure_analysis)，但在实际中它们几乎从未发生，所以我们只是非正式地说函数是“好的”。
- en: The main idea of the algorithm is to start with some initial approximation $x_0$
    and then iteratively improve it by drawing the tangent to the graph of the function
    at $x = x_i$ and setting the next approximation $x_{i+1}$ equal to the $x$-coordinate
    of its intersection with the $x$-axis. The intuition is that if the function $f$
    is “[good](https://en.wikipedia.org/wiki/Smoothness)” and $x_i$ is already close
    enough to the root, then $x_{i+1}$ will be even closer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的主要思想是从某个初始近似 $x_0$ 开始，然后通过在 $x = x_i$ 处绘制函数的切线并设置下一个近似 $x_{i+1}$ 等于其与 $x$
    轴的交点的 $x$ 坐标来迭代地改进它。直观上，如果函数 $f$ 是“[好的](https://en.wikipedia.org/wiki/Smoothness)”并且
    $x_i$ 已经足够接近根，那么 $x_{i+1}$ 将会更接近。
- en: '![](../Images/18f0c447cf274c200cca85ada7b37649.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/18f0c447cf274c200cca85ada7b37649.png)'
- en: 'To obtain the point of intersection for $x_n$, we need to equal its tangent
    line function to zero:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得 $x_n$ 的交点，我们需要将其切线函数设为零：
- en: $$ 0 = f(x_i) + (x_{i+1} - x_i) f'(x_i) $$ from which we derive $$ x_{i+1} =
    x_i - \frac{f(x_i)}{f'(x_i)} $$
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: $$ 0 = f(x_i) + (x_{i+1} - x_i) f'(x_i) $$ 从中我们推导出 $$ x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}
    $$
- en: 'Newton’s method is very important: it is the basis of a wide range of optimization
    solvers in science and engineering.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿法非常重要：它是科学和工程中广泛使用的优化求解器的基础。
- en: '### [#](https://en.algorithmica.org/hpc/arithmetic/newton/#square-root)Square
    Root'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/arithmetic/newton/#square-root) 平方根'
- en: 'As a simple example, let’s derive the algorithm for the problem of finding
    square roots:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为简单的例子，让我们推导出求解平方根问题的算法：
- en: '$$ x = \sqrt n \iff x^2 = n \iff f(x) = x^2 - n = 0 $$ If we substitute $f(x)
    = x^2 - n$ into the generic formula above, we can obtain the following update
    rule: $$ x_{i+1} = x_i - \frac{x_i^2 - n}{2 x_i} = \frac{x_i + n / x_i}{2} $$'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: $$ x = \sqrt n \iff x^2 = n \iff f(x) = x^2 - n = 0 $$ 如果我们将 $f(x) = x^2 - n$
    代入上述通用公式，我们可以得到以下更新规则：$$ x_{i+1} = x_i - \frac{x_i^2 - n}{2 x_i} = \frac{x_i +
    n / x_i}{2} $$
- en: 'In practice we also want to stop it as soon as it is close enough to the right
    answer, which we can simply check after each iteration:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们也希望一旦它足够接近正确答案就停止它，这我们可以在每次迭代后简单地检查：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The algorithm converges for many functions, although it does so reliably and
    provably only for a certain subset of them (e.g., convex functions). Another question
    is how fast the convergence is, if it occurs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法对许多函数都收敛，尽管它只对它们的一定子集（例如凸函数）可靠且可证明地收敛。另一个问题是如果发生收敛，收敛速度有多快。
- en: '### [#](https://en.algorithmica.org/hpc/arithmetic/newton/#rate-of-convergence)Rate
    of Convergence'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/arithmetic/newton/#rate-of-convergence)
    收敛速度'
- en: 'Let’s run a few iterations of Newton’s method to find the square root of $2$,
    starting with $x_0 = 1$, and check how many digits it got correct after each iteration:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行几次牛顿法来找到 $2$ 的平方根，起始值为 $x_0 = 1$，并检查每次迭代后有多少位是正确的：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Looking carefully, we can see that the number of accurate digits approximately
    doubles on each iteration. This fantastic convergence rate is not a coincidence.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，我们可以看到每次迭代的准确数字数量大约翻倍。这种惊人的收敛速度并非巧合。
- en: 'To analyze convergence rate quantitatively, we need to consider a small relative
    error $\delta_i$ on the $i$-th iteration and determine how much smaller the error
    $\delta_{i+1}$ is on the next iteration:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定量分析收敛速度，我们需要考虑第 $i$ 次迭代的微小相对误差 $\delta_i$，并确定下一次迭代的误差 $\delta_{i+1}$ 有多小：
- en: $$ |\delta_i| = \frac{|x_n - x|}{x} $$ We can express $x_i$ as $x \cdot (1 +
    \delta_i)$. Plugging it into the Newton iteration formula and dividing both sides
    by $x$ we get $$ 1 + \delta_{i+1} = \frac{1}{2} (1 + \delta_i + \frac{1}{1 + \delta_i})
    = \frac{1}{2} (1 + \delta_i + 1 - \delta_i + \delta_i^2 + o(\delta_i^2)) = 1 +
    \frac{\delta_i^2}{2} + o(\delta_i^2) $$
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: $$ |\delta_i| = \frac{|x_n - x|}{x} $$ 我们可以将 $x_i$ 表示为 $x \cdot (1 + \delta_i)$。将其代入牛顿迭代公式，并将两边除以
    $x$，我们得到 $$ 1 + \delta_{i+1} = \frac{1}{2} (1 + \delta_i + \frac{1}{1 + \delta_i})
    = \frac{1}{2} (1 + \delta_i + 1 - \delta_i + \delta_i^2 + o(\delta_i^2)) = 1 +
    \frac{\delta_i^2}{2} + o(\delta_i^2) $$
- en: Here we have Taylor-expanded $(1 + \delta_i)^{-1}$ at $0$, using the assumption
    that the error $d_i$ is small (since the sequence converges, $d_i \ll 1$ for sufficiently
    large $n$).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用误差 $d_i$ 很小的假设（由于序列收敛，对于足够大的 $n$，$d_i \ll 1$）在 $0$ 处对 $(1 + \delta_i)^{-1}$
    进行泰勒展开。
- en: Rearranging for $\delta_{i+1}$, we obtain
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对 $\delta_{i+1}$ 进行重新排列，我们得到
- en: $$ \delta_{i+1} = \frac{\delta_i^2}{2} + o(\delta_i^2) $$
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: $$ \delta_{i+1} = \frac{\delta_i^2}{2} + o(\delta_i^2) $$
- en: which means that the error roughly squares (and halves) on each iteration once
    we are close to the solution. Since the logarithm $(- \log_{10} \delta_i)$ is
    roughly the number of accurate significant digits in the answer $x_i$, squaring
    the relative error corresponds precisely to doubling the number of significant
    digits that we had observed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一旦我们接近解，误差大致平方（并减半）。由于对数 $(- \log_{10} \delta_i)$ 大约是答案 $x_i$ 中的有效数字的数量，平方相对误差正好对应于我们观察到的有效数字数量的加倍。
- en: This is known as *quadratic convergence*, and in fact, this is not limited to
    finding square roots. With detailed proof being left as an exercise to the reader,
    it can be shown that, in general
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**二次收敛**，实际上，这不仅仅限于求平方根。详细的证明留给读者作为练习，可以证明，在一般情况下
- en: $$ |\delta_{i+1}| = \frac{|f''(x_i)|}{2 \cdot |f'(x_n)|} \cdot \delta_i^2 $$
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: $$ |\delta_{i+1}| = \frac{|f''(x_i)|}{2 \cdot |f'(x_n)|} \cdot \delta_i^2 $$
- en: which results in at least quadratic convergence under a few additional assumptions,
    namely $f’(x)$ not being equal to $0$ and $f’’(x)$ being continuous.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这在几个额外的假设下至少导致二次收敛，即 $f’(x)$ 不等于 $0$，且 $f’’(x)$ 是连续的。
- en: '## [#](https://en.algorithmica.org/hpc/arithmetic/newton/#further-reading)Further
    Reading'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '## [#](https://en.algorithmica.org/hpc/arithmetic/newton/#further-reading)进一步阅读'
- en: '[Introduction to numerical methods at MIT](https://ocw.mit.edu/courses/mathematics/18-330-introduction-to-numerical-analysis-spring-2012/lecture-notes/MIT18_330S12_Chapter4.pdf).
    [← Rounding Errors](https://en.algorithmica.org/hpc/arithmetic/errors/)[Fast Inverse
    Square Root →](https://en.algorithmica.org/hpc/arithmetic/rsqrt/)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[MIT的数值方法介绍](https://ocw.mit.edu/courses/mathematics/18-330-introduction-to-numerical-analysis-spring-2012/lecture-notes/MIT18_330S12_Chapter4.pdf).
    [←舍入误差](https://en.algorithmica.org/hpc/arithmetic/errors/)[快速逆平方根→](https://en.algorithmica.org/hpc/arithmetic/rsqrt/)'
