<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>6.1Â Introduction to Structured DatağŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>6.1Â Introduction to Structured DatağŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/intro-struct-data.html">https://dcic-world.org/2025-08-27/intro-struct-data.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._.Understanding_the_.Kinds_of_.Compound_.Data%29" class="toclink" data-pltdoc="x">6.1.1Â Understanding the Kinds of Compound Data</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.A_.First_.Peek_at_.Structured_.Data%29" class="toclink" data-pltdoc="x">6.1.1.1Â A First Peek at Structured Data</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.A_.First_.Peek_at_.Conditional_.Data%29" class="toclink" data-pltdoc="x">6.1.1.2Â A First Peek at Conditional Data</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data%29" class="toclink" data-pltdoc="x">6.1.2Â Defining and Creating Structured and Conditional Data</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._struct-data-eg%29" class="toclink" data-pltdoc="x">6.1.2.1Â Defining and Creating Structured Data</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Annotations_for_.Structured_.Data%29" class="toclink" data-pltdoc="x">6.1.2.2Â Annotations for Structured Data</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Defining_and_.Creating_.Conditional_.Data%29" class="toclink" data-pltdoc="x">6.1.2.3Â Defining and Creating Conditional Data</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Programming_with_.Structured_and_.Conditional_.Data%29" class="toclink" data-pltdoc="x">6.1.3Â Programming with Structured and Conditional Data</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Extracting_.Fields_from_.Structured_.Data%29" class="toclink" data-pltdoc="x">6.1.3.1Â Extracting Fields from Structured Data</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._telling-apart-variants%29" class="toclink" data-pltdoc="x">6.1.3.2Â Telling Apart Variants of Conditional Data</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._process-fields-variants%29" class="toclink" data-pltdoc="x">6.1.3.3Â Processing Fields of Variants</a></p></td></tr></table><p>Earlier we had our first look at types. Until now, we have only seen
the types that Pyret provides us, which is an interesting but
nevertheless quite limited set. Most programs we write will contain
many more kinds of data.</p><section class="SsectionLevel4" id="section 6.1.1"><h4 class="heading">6.1.1Â <a name="(part._.Understanding_the_.Kinds_of_.Compound_.Data)"/>Understanding the Kinds of Compound Data<a href="#(part._.Understanding_the_.Kinds_of_.Compound_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><section class="SsectionLevel5" id="section 6.1.1.1"><h5 class="heading">6.1.1.1Â <a name="(part._.A_.First_.Peek_at_.Structured_.Data)"/>A First Peek at Structured Data<a href="#(part._.A_.First_.Peek_at_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>There are times when a datum has many attributes, or parts. We
need to keep them all together, and sometimes take them apart. For
instance:
</p><ul><li><p>An iTunes entry contains a bunch of information about a single
song: not only its name but also its singer, its length, its genre,
and so on.</p><p><img src="../Images/72a14943124cb68143f994a2a282a9ac.png" alt="" width="1112" height="60" data-original-src="https://dcic-world.org/2025-08-27/itunes-1.png"/></p></li><li><p>Your GMail application contains a bunch of information about a
single message: its sender, the subject line, the conversation itâ€™s
part of, the body, and quite a bit more.</p><p><img src="../Images/17a64e6b5180eb56ebf06a02ffe39113.png" alt="" width="1136" height="46" data-original-src="https://dcic-world.org/2025-08-27/gmail-1.png"/></p></li></ul><p>In examples like this, we see the need for structured data: a
single datum has structure, i.e., it
actually consists of many pieces. The number of pieces is
fixed, but may be of different kinds (some might be numbers,
some strings, some images, and different types may be mixed together
in that one datum).  Some might even be other structured data:
for instance, a date usually has at least three parts, the day, month,
and year. The parts of a structured datum are called its fields.</p></section><section class="SsectionLevel5" id="section 6.1.1.2"><h5 class="heading">6.1.1.2Â <a name="(part._.A_.First_.Peek_at_.Conditional_.Data)"/>A First Peek at Conditional Data<a href="#(part._.A_.First_.Peek_at_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Then there are times when we want to represent different kinds of
data under a single, collective umbrella. Here are a few examples:
</p><ul><li><p>A traffic light can be in different states: red, yellow, or
green.Yes, in some countries there are different or more
colors and color-combinations. Collectively, they represent one
thing: a new type called a traffic light state.</p></li><li><p>A zoo consists of many kinds of animals. Collectively, they
represent one thing: a new type called an animal. Some condition
determines which particular kind of animal a zookeeper might be dealing
with.</p></li><li><p>A social network consists of different kinds of pages. Some
pages represent individual humans, some places, some organizations,
some might stand for activities, and so on. Collectively, they
represent a new type: a social media page.</p></li><li><p>A notification application may report many kinds of events. Some
are for email messages (which have many fields, as weâ€™ve discussed),
some are for reminders (which might have a timestamp and a note), some
for instant messages (similar to an email message, but without a
subject), some might even be for the arrival of a package by physical
mail (with a timestamp, shipper, tracking number, and delivery
note). Collectively, these all represent a new type: a notification.</p></li></ul><p>We call these â€œconditionalâ€ data because they represent an â€œorâ€: a
traffic light is red or green or yellow; a social
mediumâ€™s page is for a person or location or
organization; and so on. Sometimes we care exactly which kind of thing
weâ€™re looking at: a driver behaves differently on different colors,
and a zookeeper feeds each animal differently. At other times, we
might not care: if weâ€™re just counting how many animals are in the
zoo, or how many pages are on a social network, or how many unread
notifications we have, their details donâ€™t matter. Therefore, there are
times when we ignore the conditional and treat the datum as a member
of the collective, and other times when we do care about the
conditional and do different things depending on the individual
datum. We will make all this concrete as we start to write programs.</p></section></section><section class="SsectionLevel4" id="section 6.1.2"><h4 class="heading">6.1.2Â <a name="(part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data)"/>Defining and Creating Structured and Conditional Data<a href="#(part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>We have used the word â€œdataâ€ above, but thatâ€™s actually been a bit
of a lie. As we said earlier, data are how we represent
information in the computer. What weâ€™ve been discussing above is
really different kinds of information, not exactly how they are
represented. But to write programs, we must wrestle concretely with
representations. Thatâ€™s what we will do now, i.e., actually show
data representations of all this information.</p><section class="SsectionLevel5" id="section 6.1.2.1"><h5 class="heading">6.1.2.1Â <a name="(part._struct-data-eg)"/>Defining and Creating Structured Data<a href="#(part._struct-data-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s start with defining structured data, such as an iTunes song
record. Hereâ€™s a simplified version of the information such an app
might store:
</p><ul><li><p>The songâ€™s name, which is a <code data-lang="pyret" class="sourceCode">String</code>.</p></li><li><p>The songâ€™s singer, which is also a <code data-lang="pyret" class="sourceCode">String</code>.</p></li><li><p>The songâ€™s year, which is a <code data-lang="pyret" class="sourceCode">Number</code>.</p></li></ul><p>Letâ€™s now introduce the syntax by which we can teach this to Pyret:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name, singer, year) end</code></pre><p>This tells Pyret to introduce a new type of data, in this case
called <code data-lang="pyret" class="sourceCode">ITunesSong</code>We follow a convention that types
always begin with a capital letter.. The way we actually make one of
these data is by calling <code data-lang="pyret" class="sourceCode">song</code> with three parameters; for
instance:Itâ€™s worth noting that music managers that are
capable of making distinctions between, say, Dance, Electronica, and
Electronic/Dance, classify two of these three songs by a single genre:
â€œWorldâ€.
</p><a name="(elem._structured-examples)"/>&lt;structured-examples&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">song("La Vie en Rose", "Ã‰dith Piaf", 1945)
song("Stressed Out", "twenty one pilots", 2015)
song("Waqt Ne Kiya Kya Haseen Sitam", "Geeta Dutt", 1959)</code></pre><p>Always follow a data definition with a few concrete instances of the
data! This makes sure you actually do know how to make data of that
form. Indeed, itâ€™s not essential but a good habit to give names to the
data weâ€™ve defined, so that we can use them later:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver = song("La Vie en Rose", "Ã‰dith Piaf", 1945)
so = song("Stressed Out", "twenty one pilots", 2015)
wnkkhs = song("Waqt Ne Kiya Kya Haseen Sitam", "Geeta Dutt", 1959)</code></pre><p>In terms of the directory, structured data are no different from
simple data. Each of the three definitions above creates an entry in
the directory, as follows:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">lver</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">so</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("Stressed Out", "twenty one pilots", 2015)</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">wnkkhs</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("Waqt Ne Kiya Kya Haseen Sitam","Geeta Dutt", 1959)</code></pre></li></ul></section><section class="SsectionLevel5" id="section 6.1.2.2"><h5 class="heading">6.1.2.2Â <a name="(part._.Annotations_for_.Structured_.Data)"/>Annotations for Structured Data<a href="#(part._.Annotations_for_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Recall that in [<a href="From_Repeated_Expressions_to_Functions.html#%28part._fun-annotations%29" data-pltdoc="x">Type Annotations</a>] we discussed annotating our functions. Well, we
can annotate our data, too! In particular, we can annotate both the
definition of data and their creation. For the former,
consider this data definition, which makes the annotation information
weâ€™d recorded informally in text a formal part of the program:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name :: String, singer :: String, year :: Number) end</code></pre><p>Similarly, we can annotate the variables bound to examples of the
data. But what should we write here?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: ___ = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre><p>Recall that annotations takes names of types, and the new type weâ€™ve
created is called <code data-lang="pyret" class="sourceCode">ITunesSong</code>. Therefore, we should write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: ITunesSong = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What happens if we instead write this?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: String = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre><p>What error do we get? How about if instead we write these?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: song = song("La Vie en Rose", "Ã‰dith Piaf", 1945)
lver :: 1 = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre><p>Make sure you familiarize yourself with the error messages that you
get.</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 6.1.2.3"><h5 class="heading">6.1.2.3Â <a name="(part._.Defining_and_.Creating_.Conditional_.Data)"/>Defining and Creating Conditional Data<a href="#(part._.Defining_and_.Creating_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>The <code data-lang="pyret" class="sourceCode">data</code> construct in Pyret also lets us create conditional
data, with a slightly different syntax. For instance, say we want to
define the colors of a traffic light:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data TLColor:
  | Red
  | Yellow
  | Green
end</code></pre><p>Conventionally, the names of the options begin in
lower-case, but if they have no additional structure, we often
capitalize the initial to make them look different from ordinary
variables: i.e., <code data-lang="pyret" class="sourceCode">Red</code> rather than <code data-lang="pyret" class="sourceCode">red</code>.
Each <code data-lang="pyret" class="sourceCode">|</code> (pronounced â€œstickâ€) introduces another option. You
would make instances of traffic light colors as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Red
Green
Yellow</code></pre><p>A more interesting and common example is when each condition has some
structure to it; for instance:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Animal:
  | boa(name :: String, length :: Number)
  | armadillo(name :: String, liveness :: Boolean)
end</code></pre><p>â€œIn Texas, there ainâ€™t nothinâ€™ in the middle of the road
except yellow stripes and a dead armadillo.â€â€”<wbr/>Jim Hightower
We can make examples of them as you would expect:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1 = boa("Ayisha", 10)
b2 = boa("Bonito", 8)
a1 = armadillo("Glypto", true)</code></pre><p>We call the different conditions variants.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How would you annotate the three variable bindings?</p></blockquote></blockquote><p>Notice that the distinction between boas and armadillos is lost in the
annotation.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1 :: Animal = boa("Ayisha", 10)
b2 :: Animal = boa("Bonito", 8)
a1 :: Animal = armadillo("Glypto", true)</code></pre><p>When defining a conditional datum the first stick is actually
optional, but adding it makes the variants line up nicely. This helps
us realize that our first example
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name, singer, year) end</code></pre><p>is really just the same as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong:
  | song(name, singer, year)
end</code></pre><p>i.e., a conditional type with just one condition, where that one
condition is structured.</p></section></section><section class="SsectionLevel4" id="section 6.1.3"><h4 class="heading">6.1.3Â <a name="(part._.Programming_with_.Structured_and_.Conditional_.Data)"/>Programming with Structured and Conditional Data<a href="#(part._.Programming_with_.Structured_and_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>So far weâ€™ve learned how to create structured and conditional data,
but not yet how to take them apart or write any expressions that
involve them. As you might expect, we need to figure out how to
</p><ul><li><p>take apart the fields of a structured datum, and</p></li><li><p>tell apart the variants of a conditional datum.</p></li></ul><p>As weâ€™ll see, Pyret also gives us a convenient way to do both
together.</p><section class="SsectionLevel5" id="section 6.1.3.1"><h5 class="heading">6.1.3.1Â <a name="(part._.Extracting_.Fields_from_.Structured_.Data)"/>Extracting Fields from Structured Data<a href="#(part._.Extracting_.Fields_from_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s write a function that tells us how old a song is. First, letâ€™s
think about what the function consumes (an <code data-lang="pyret" class="sourceCode">ITunesSong</code>) and
produces (a <code data-lang="pyret" class="sourceCode">Number</code>). This gives us a rough skeleton for the
function:
</p><a name="(elem._song-age)"/>&lt;song-age&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  <a href="#%28elem._song-age-body%29" data-pltdoc="x">&lt;song-age-body&gt;</a>
end</code></pre><p>We know that the form of the body must be roughly:
</p><a name="(elem._song-age-body)"/>&lt;song-age-body&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2016 - &lt;get the song year&gt;</code></pre><p>We can get the song year by using Pyretâ€™s field access, which is
a <code data-lang="pyret" class="sourceCode">.</code> followed by a fieldâ€™s nameâ€”<wbr/>in this case,
<code data-lang="pyret" class="sourceCode">year</code>â€”<wbr/>following the variable that holds the structured
datum. Thus, we get the <code data-lang="pyret" class="sourceCode">year</code> field of <code data-lang="pyret" class="sourceCode">s</code> (the parameter
to <code data-lang="pyret" class="sourceCode">song-age</code>) with
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">s.year</code></pre><p>So the entire function body is:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  2016 - s.year
end</code></pre><p>It would be good to also record some examples
(<a href="#%28elem._structured-examples%29" data-pltdoc="x">&lt;structured-examples&gt;</a>), giving us a comprehensive
definition of the function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  2016 - s.year
where:
  song-age(lver) is 71
  song-age(so) is 1
  song-age(wnkkhs) is 57
end</code></pre></section><section class="SsectionLevel5" id="section 6.1.3.2"><h5 class="heading">6.1.3.2Â <a name="(part._telling-apart-variants)"/>Telling Apart Variants of Conditional Data<a href="#(part._telling-apart-variants)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Now letâ€™s see how we tell apart variants. For this, we again use
<code data-lang="pyret" class="sourceCode">cases</code>, as we saw for lists. We create one branch for each of
the variants. Thus, if we wanted to compute advice for a driver based on a
traffic lightâ€™s state, we might write:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun advice(c :: TLColor) -&gt; String:
  cases (TLColor) c:
    | Red =&gt; "wait!"
    | Yellow =&gt; "get ready..."
    | Green =&gt; "go!"
  end
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What happens if you leave out the <code data-lang="pyret" class="sourceCode">=&gt;</code>?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What if you leave out a variant? Leave out the <code data-lang="pyret" class="sourceCode">Red</code> variant,
then try both <code data-lang="pyret" class="sourceCode">advice(Yellow)</code> and <code data-lang="pyret" class="sourceCode">advice(Red)</code>.</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 6.1.3.3"><h5 class="heading">6.1.3.3Â <a name="(part._process-fields-variants)"/>Processing Fields of Variants<a href="#(part._process-fields-variants)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>In this example, the variants had no fields. But if the variant has
fields, Pyret expects you to list names of variables for those fields,
and will then automatically bind those variablesâ€”<wbr/>so you donâ€™t need
to use the <code data-lang="pyret" class="sourceCode">.</code>-notation to get the field values.</p><p>To illustrate this, assume we want to get the name of any animal:
</p><a name="(elem._animal-name)"/>&lt;animal-name&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun animal-name(a :: Animal) -&gt; String:
  <a href="#%28elem._animal-name-body%29" data-pltdoc="x">&lt;animal-name-body&gt;</a>
end</code></pre><p>Because an <code data-lang="pyret" class="sourceCode">Animal</code> is conditionally defined, we know that we are
likely to want a <code data-lang="pyret" class="sourceCode">cases</code> to pull it apart; furthermore, we should
give names to each of the fields:Note that the names of the
variables do not have to match the names of
fields. Conventionally, we give longer, descriptive names to
the field definitions and short names to the corresponding variables.</p><a name="(elem._animal-name-body)"/>&lt;animal-name-body&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (Animal) a:
  | boa(n, l) =&gt; ...
  | armadillo(n, l) =&gt; ...
end</code></pre><p>In both cases, we want to return the field <code data-lang="pyret" class="sourceCode">n</code>, giving us the
complete function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun animal-name(a :: Animal) -&gt; String:
  cases (Animal) a:
    | boa(n, l) =&gt; n
    | armadillo(n, l) =&gt; n
  end
where:
  animal-name(b1) is "Ayisha"
  animal-name(b2) is "Bonito"
  animal-name(a1) is "Glypto"
end</code></pre><p>Letâ€™s look at how Pyret would evaluate a function call like
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">animal-name(boa("Bonito", 8))</code></pre><p>The argument <code data-lang="pyret" class="sourceCode">boa("Bonito", 8)</code> is a value. In the same way as we
substitute simple data types like strings and numbers for parameters
when we evaluate a function, we do the same thing here. After
substituting, we are left with the following expression to evaluate:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (Animal) boa("Bonito", 8):
  | boa(n, l) =&gt; n
  | armadillo(n, l) =&gt; n
end</code></pre><p>Next, Pyret determines which case matches the data (the first one, for
<code data-lang="pyret" class="sourceCode">boa</code>, in this case). It then substitutes the field names with the
corresponding components of the datum result expression for the
matched case. In this case, we will substitute uses of <code data-lang="pyret" class="sourceCode">n</code> with
<code data-lang="pyret" class="sourceCode">"Bonito"</code> and uses of <code data-lang="pyret" class="sourceCode">l</code> with <code data-lang="pyret" class="sourceCode">8</code>. In this program,
the entire result expression is a use of <code data-lang="pyret" class="sourceCode">n</code>, so the result of
the program in this case is <code data-lang="pyret" class="sourceCode">"Bonito"</code>.</p></section></section>&#13;
<h4 class="heading">6.1.1Â <a name="(part._.Understanding_the_.Kinds_of_.Compound_.Data)"/>Understanding the Kinds of Compound Data<a href="#(part._.Understanding_the_.Kinds_of_.Compound_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><section class="SsectionLevel5" id="section 6.1.1.1"><h5 class="heading">6.1.1.1Â <a name="(part._.A_.First_.Peek_at_.Structured_.Data)"/>A First Peek at Structured Data<a href="#(part._.A_.First_.Peek_at_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>There are times when a datum has many attributes, or parts. We
need to keep them all together, and sometimes take them apart. For
instance:
</p><ul><li><p>An iTunes entry contains a bunch of information about a single
song: not only its name but also its singer, its length, its genre,
and so on.</p><p><img src="../Images/72a14943124cb68143f994a2a282a9ac.png" alt="" width="1112" height="60" data-original-src="https://dcic-world.org/2025-08-27/itunes-1.png"/></p></li><li><p>Your GMail application contains a bunch of information about a
single message: its sender, the subject line, the conversation itâ€™s
part of, the body, and quite a bit more.</p><p><img src="../Images/17a64e6b5180eb56ebf06a02ffe39113.png" alt="" width="1136" height="46" data-original-src="https://dcic-world.org/2025-08-27/gmail-1.png"/></p></li></ul><p>In examples like this, we see the need for structured data: a
single datum has structure, i.e., it
actually consists of many pieces. The number of pieces is
fixed, but may be of different kinds (some might be numbers,
some strings, some images, and different types may be mixed together
in that one datum).  Some might even be other structured data:
for instance, a date usually has at least three parts, the day, month,
and year. The parts of a structured datum are called its fields.</p></section><section class="SsectionLevel5" id="section 6.1.1.2"><h5 class="heading">6.1.1.2Â <a name="(part._.A_.First_.Peek_at_.Conditional_.Data)"/>A First Peek at Conditional Data<a href="#(part._.A_.First_.Peek_at_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Then there are times when we want to represent different kinds of
data under a single, collective umbrella. Here are a few examples:
</p><ul><li><p>A traffic light can be in different states: red, yellow, or
green.Yes, in some countries there are different or more
colors and color-combinations. Collectively, they represent one
thing: a new type called a traffic light state.</p></li><li><p>A zoo consists of many kinds of animals. Collectively, they
represent one thing: a new type called an animal. Some condition
determines which particular kind of animal a zookeeper might be dealing
with.</p></li><li><p>A social network consists of different kinds of pages. Some
pages represent individual humans, some places, some organizations,
some might stand for activities, and so on. Collectively, they
represent a new type: a social media page.</p></li><li><p>A notification application may report many kinds of events. Some
are for email messages (which have many fields, as weâ€™ve discussed),
some are for reminders (which might have a timestamp and a note), some
for instant messages (similar to an email message, but without a
subject), some might even be for the arrival of a package by physical
mail (with a timestamp, shipper, tracking number, and delivery
note). Collectively, these all represent a new type: a notification.</p></li></ul><p>We call these â€œconditionalâ€ data because they represent an â€œorâ€: a
traffic light is red or green or yellow; a social
mediumâ€™s page is for a person or location or
organization; and so on. Sometimes we care exactly which kind of thing
weâ€™re looking at: a driver behaves differently on different colors,
and a zookeeper feeds each animal differently. At other times, we
might not care: if weâ€™re just counting how many animals are in the
zoo, or how many pages are on a social network, or how many unread
notifications we have, their details donâ€™t matter. Therefore, there are
times when we ignore the conditional and treat the datum as a member
of the collective, and other times when we do care about the
conditional and do different things depending on the individual
datum. We will make all this concrete as we start to write programs.</p></section>&#13;
<h5 class="heading">6.1.1.1Â <a name="(part._.A_.First_.Peek_at_.Structured_.Data)"/>A First Peek at Structured Data<a href="#(part._.A_.First_.Peek_at_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>There are times when a datum has many attributes, or parts. We
need to keep them all together, and sometimes take them apart. For
instance:
</p><ul><li><p>An iTunes entry contains a bunch of information about a single
song: not only its name but also its singer, its length, its genre,
and so on.</p><p><img src="../Images/72a14943124cb68143f994a2a282a9ac.png" alt="" width="1112" height="60" data-original-src="https://dcic-world.org/2025-08-27/itunes-1.png"/></p></li><li><p>Your GMail application contains a bunch of information about a
single message: its sender, the subject line, the conversation itâ€™s
part of, the body, and quite a bit more.</p><p><img src="../Images/17a64e6b5180eb56ebf06a02ffe39113.png" alt="" width="1136" height="46" data-original-src="https://dcic-world.org/2025-08-27/gmail-1.png"/></p></li></ul><p>In examples like this, we see the need for structured data: a
single datum has structure, i.e., it
actually consists of many pieces. The number of pieces is
fixed, but may be of different kinds (some might be numbers,
some strings, some images, and different types may be mixed together
in that one datum).  Some might even be other structured data:
for instance, a date usually has at least three parts, the day, month,
and year. The parts of a structured datum are called its fields.</p>&#13;
<h5 class="heading">6.1.1.2Â <a name="(part._.A_.First_.Peek_at_.Conditional_.Data)"/>A First Peek at Conditional Data<a href="#(part._.A_.First_.Peek_at_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Then there are times when we want to represent different kinds of
data under a single, collective umbrella. Here are a few examples:
</p><ul><li><p>A traffic light can be in different states: red, yellow, or
green.Yes, in some countries there are different or more
colors and color-combinations. Collectively, they represent one
thing: a new type called a traffic light state.</p></li><li><p>A zoo consists of many kinds of animals. Collectively, they
represent one thing: a new type called an animal. Some condition
determines which particular kind of animal a zookeeper might be dealing
with.</p></li><li><p>A social network consists of different kinds of pages. Some
pages represent individual humans, some places, some organizations,
some might stand for activities, and so on. Collectively, they
represent a new type: a social media page.</p></li><li><p>A notification application may report many kinds of events. Some
are for email messages (which have many fields, as weâ€™ve discussed),
some are for reminders (which might have a timestamp and a note), some
for instant messages (similar to an email message, but without a
subject), some might even be for the arrival of a package by physical
mail (with a timestamp, shipper, tracking number, and delivery
note). Collectively, these all represent a new type: a notification.</p></li></ul><p>We call these â€œconditionalâ€ data because they represent an â€œorâ€: a
traffic light is red or green or yellow; a social
mediumâ€™s page is for a person or location or
organization; and so on. Sometimes we care exactly which kind of thing
weâ€™re looking at: a driver behaves differently on different colors,
and a zookeeper feeds each animal differently. At other times, we
might not care: if weâ€™re just counting how many animals are in the
zoo, or how many pages are on a social network, or how many unread
notifications we have, their details donâ€™t matter. Therefore, there are
times when we ignore the conditional and treat the datum as a member
of the collective, and other times when we do care about the
conditional and do different things depending on the individual
datum. We will make all this concrete as we start to write programs.</p>&#13;
<h4 class="heading">6.1.2Â <a name="(part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data)"/>Defining and Creating Structured and Conditional Data<a href="#(part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>We have used the word â€œdataâ€ above, but thatâ€™s actually been a bit
of a lie. As we said earlier, data are how we represent
information in the computer. What weâ€™ve been discussing above is
really different kinds of information, not exactly how they are
represented. But to write programs, we must wrestle concretely with
representations. Thatâ€™s what we will do now, i.e., actually show
data representations of all this information.</p><section class="SsectionLevel5" id="section 6.1.2.1"><h5 class="heading">6.1.2.1Â <a name="(part._struct-data-eg)"/>Defining and Creating Structured Data<a href="#(part._struct-data-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s start with defining structured data, such as an iTunes song
record. Hereâ€™s a simplified version of the information such an app
might store:
</p><ul><li><p>The songâ€™s name, which is a <code data-lang="pyret" class="sourceCode">String</code>.</p></li><li><p>The songâ€™s singer, which is also a <code data-lang="pyret" class="sourceCode">String</code>.</p></li><li><p>The songâ€™s year, which is a <code data-lang="pyret" class="sourceCode">Number</code>.</p></li></ul><p>Letâ€™s now introduce the syntax by which we can teach this to Pyret:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name, singer, year) end</code></pre><p>This tells Pyret to introduce a new type of data, in this case
called <code data-lang="pyret" class="sourceCode">ITunesSong</code>We follow a convention that types
always begin with a capital letter.. The way we actually make one of
these data is by calling <code data-lang="pyret" class="sourceCode">song</code> with three parameters; for
instance:Itâ€™s worth noting that music managers that are
capable of making distinctions between, say, Dance, Electronica, and
Electronic/Dance, classify two of these three songs by a single genre:
â€œWorldâ€.
</p><a name="(elem._structured-examples)"/>&lt;structured-examples&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">song("La Vie en Rose", "Ã‰dith Piaf", 1945)
song("Stressed Out", "twenty one pilots", 2015)
song("Waqt Ne Kiya Kya Haseen Sitam", "Geeta Dutt", 1959)</code></pre><p>Always follow a data definition with a few concrete instances of the
data! This makes sure you actually do know how to make data of that
form. Indeed, itâ€™s not essential but a good habit to give names to the
data weâ€™ve defined, so that we can use them later:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver = song("La Vie en Rose", "Ã‰dith Piaf", 1945)
so = song("Stressed Out", "twenty one pilots", 2015)
wnkkhs = song("Waqt Ne Kiya Kya Haseen Sitam", "Geeta Dutt", 1959)</code></pre><p>In terms of the directory, structured data are no different from
simple data. Each of the three definitions above creates an entry in
the directory, as follows:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">lver</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">so</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("Stressed Out", "twenty one pilots", 2015)</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">wnkkhs</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("Waqt Ne Kiya Kya Haseen Sitam","Geeta Dutt", 1959)</code></pre></li></ul></section><section class="SsectionLevel5" id="section 6.1.2.2"><h5 class="heading">6.1.2.2Â <a name="(part._.Annotations_for_.Structured_.Data)"/>Annotations for Structured Data<a href="#(part._.Annotations_for_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Recall that in [<a href="From_Repeated_Expressions_to_Functions.html#%28part._fun-annotations%29" data-pltdoc="x">Type Annotations</a>] we discussed annotating our functions. Well, we
can annotate our data, too! In particular, we can annotate both the
definition of data and their creation. For the former,
consider this data definition, which makes the annotation information
weâ€™d recorded informally in text a formal part of the program:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name :: String, singer :: String, year :: Number) end</code></pre><p>Similarly, we can annotate the variables bound to examples of the
data. But what should we write here?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: ___ = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre><p>Recall that annotations takes names of types, and the new type weâ€™ve
created is called <code data-lang="pyret" class="sourceCode">ITunesSong</code>. Therefore, we should write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: ITunesSong = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What happens if we instead write this?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: String = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre><p>What error do we get? How about if instead we write these?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: song = song("La Vie en Rose", "Ã‰dith Piaf", 1945)
lver :: 1 = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre><p>Make sure you familiarize yourself with the error messages that you
get.</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 6.1.2.3"><h5 class="heading">6.1.2.3Â <a name="(part._.Defining_and_.Creating_.Conditional_.Data)"/>Defining and Creating Conditional Data<a href="#(part._.Defining_and_.Creating_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>The <code data-lang="pyret" class="sourceCode">data</code> construct in Pyret also lets us create conditional
data, with a slightly different syntax. For instance, say we want to
define the colors of a traffic light:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data TLColor:
  | Red
  | Yellow
  | Green
end</code></pre><p>Conventionally, the names of the options begin in
lower-case, but if they have no additional structure, we often
capitalize the initial to make them look different from ordinary
variables: i.e., <code data-lang="pyret" class="sourceCode">Red</code> rather than <code data-lang="pyret" class="sourceCode">red</code>.
Each <code data-lang="pyret" class="sourceCode">|</code> (pronounced â€œstickâ€) introduces another option. You
would make instances of traffic light colors as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Red
Green
Yellow</code></pre><p>A more interesting and common example is when each condition has some
structure to it; for instance:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Animal:
  | boa(name :: String, length :: Number)
  | armadillo(name :: String, liveness :: Boolean)
end</code></pre><p>â€œIn Texas, there ainâ€™t nothinâ€™ in the middle of the road
except yellow stripes and a dead armadillo.â€â€”<wbr/>Jim Hightower
We can make examples of them as you would expect:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1 = boa("Ayisha", 10)
b2 = boa("Bonito", 8)
a1 = armadillo("Glypto", true)</code></pre><p>We call the different conditions variants.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How would you annotate the three variable bindings?</p></blockquote></blockquote><p>Notice that the distinction between boas and armadillos is lost in the
annotation.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1 :: Animal = boa("Ayisha", 10)
b2 :: Animal = boa("Bonito", 8)
a1 :: Animal = armadillo("Glypto", true)</code></pre><p>When defining a conditional datum the first stick is actually
optional, but adding it makes the variants line up nicely. This helps
us realize that our first example
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name, singer, year) end</code></pre><p>is really just the same as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong:
  | song(name, singer, year)
end</code></pre><p>i.e., a conditional type with just one condition, where that one
condition is structured.</p></section>&#13;
<h5 class="heading">6.1.2.1Â <a name="(part._struct-data-eg)"/>Defining and Creating Structured Data<a href="#(part._struct-data-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s start with defining structured data, such as an iTunes song
record. Hereâ€™s a simplified version of the information such an app
might store:
</p><ul><li><p>The songâ€™s name, which is a <code data-lang="pyret" class="sourceCode">String</code>.</p></li><li><p>The songâ€™s singer, which is also a <code data-lang="pyret" class="sourceCode">String</code>.</p></li><li><p>The songâ€™s year, which is a <code data-lang="pyret" class="sourceCode">Number</code>.</p></li></ul><p>Letâ€™s now introduce the syntax by which we can teach this to Pyret:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name, singer, year) end</code></pre><p>This tells Pyret to introduce a new type of data, in this case
called <code data-lang="pyret" class="sourceCode">ITunesSong</code>We follow a convention that types
always begin with a capital letter.. The way we actually make one of
these data is by calling <code data-lang="pyret" class="sourceCode">song</code> with three parameters; for
instance:Itâ€™s worth noting that music managers that are
capable of making distinctions between, say, Dance, Electronica, and
Electronic/Dance, classify two of these three songs by a single genre:
â€œWorldâ€.
</p><a name="(elem._structured-examples)"/>&lt;structured-examples&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">song("La Vie en Rose", "Ã‰dith Piaf", 1945)
song("Stressed Out", "twenty one pilots", 2015)
song("Waqt Ne Kiya Kya Haseen Sitam", "Geeta Dutt", 1959)</code></pre><p>Always follow a data definition with a few concrete instances of the
data! This makes sure you actually do know how to make data of that
form. Indeed, itâ€™s not essential but a good habit to give names to the
data weâ€™ve defined, so that we can use them later:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver = song("La Vie en Rose", "Ã‰dith Piaf", 1945)
so = song("Stressed Out", "twenty one pilots", 2015)
wnkkhs = song("Waqt Ne Kiya Kya Haseen Sitam", "Geeta Dutt", 1959)</code></pre><p>In terms of the directory, structured data are no different from
simple data. Each of the three definitions above creates an entry in
the directory, as follows:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">lver</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">so</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("Stressed Out", "twenty one pilots", 2015)</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">wnkkhs</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("Waqt Ne Kiya Kya Haseen Sitam","Geeta Dutt", 1959)</code></pre></li></ul>&#13;
<h5 class="heading">6.1.2.2Â <a name="(part._.Annotations_for_.Structured_.Data)"/>Annotations for Structured Data<a href="#(part._.Annotations_for_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Recall that in [<a href="From_Repeated_Expressions_to_Functions.html#%28part._fun-annotations%29" data-pltdoc="x">Type Annotations</a>] we discussed annotating our functions. Well, we
can annotate our data, too! In particular, we can annotate both the
definition of data and their creation. For the former,
consider this data definition, which makes the annotation information
weâ€™d recorded informally in text a formal part of the program:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name :: String, singer :: String, year :: Number) end</code></pre><p>Similarly, we can annotate the variables bound to examples of the
data. But what should we write here?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: ___ = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre><p>Recall that annotations takes names of types, and the new type weâ€™ve
created is called <code data-lang="pyret" class="sourceCode">ITunesSong</code>. Therefore, we should write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: ITunesSong = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What happens if we instead write this?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: String = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre><p>What error do we get? How about if instead we write these?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: song = song("La Vie en Rose", "Ã‰dith Piaf", 1945)
lver :: 1 = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre><p>Make sure you familiarize yourself with the error messages that you
get.</p></blockquote></blockquote>&#13;
<h5 class="heading">6.1.2.3Â <a name="(part._.Defining_and_.Creating_.Conditional_.Data)"/>Defining and Creating Conditional Data<a href="#(part._.Defining_and_.Creating_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>The <code data-lang="pyret" class="sourceCode">data</code> construct in Pyret also lets us create conditional
data, with a slightly different syntax. For instance, say we want to
define the colors of a traffic light:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data TLColor:
  | Red
  | Yellow
  | Green
end</code></pre><p>Conventionally, the names of the options begin in
lower-case, but if they have no additional structure, we often
capitalize the initial to make them look different from ordinary
variables: i.e., <code data-lang="pyret" class="sourceCode">Red</code> rather than <code data-lang="pyret" class="sourceCode">red</code>.
Each <code data-lang="pyret" class="sourceCode">|</code> (pronounced â€œstickâ€) introduces another option. You
would make instances of traffic light colors as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Red
Green
Yellow</code></pre><p>A more interesting and common example is when each condition has some
structure to it; for instance:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Animal:
  | boa(name :: String, length :: Number)
  | armadillo(name :: String, liveness :: Boolean)
end</code></pre><p>â€œIn Texas, there ainâ€™t nothinâ€™ in the middle of the road
except yellow stripes and a dead armadillo.â€â€”<wbr/>Jim Hightower
We can make examples of them as you would expect:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1 = boa("Ayisha", 10)
b2 = boa("Bonito", 8)
a1 = armadillo("Glypto", true)</code></pre><p>We call the different conditions variants.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How would you annotate the three variable bindings?</p></blockquote></blockquote><p>Notice that the distinction between boas and armadillos is lost in the
annotation.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1 :: Animal = boa("Ayisha", 10)
b2 :: Animal = boa("Bonito", 8)
a1 :: Animal = armadillo("Glypto", true)</code></pre><p>When defining a conditional datum the first stick is actually
optional, but adding it makes the variants line up nicely. This helps
us realize that our first example
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name, singer, year) end</code></pre><p>is really just the same as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong:
  | song(name, singer, year)
end</code></pre><p>i.e., a conditional type with just one condition, where that one
condition is structured.</p>&#13;
<h4 class="heading">6.1.3Â <a name="(part._.Programming_with_.Structured_and_.Conditional_.Data)"/>Programming with Structured and Conditional Data<a href="#(part._.Programming_with_.Structured_and_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>So far weâ€™ve learned how to create structured and conditional data,
but not yet how to take them apart or write any expressions that
involve them. As you might expect, we need to figure out how to
</p><ul><li><p>take apart the fields of a structured datum, and</p></li><li><p>tell apart the variants of a conditional datum.</p></li></ul><p>As weâ€™ll see, Pyret also gives us a convenient way to do both
together.</p><section class="SsectionLevel5" id="section 6.1.3.1"><h5 class="heading">6.1.3.1Â <a name="(part._.Extracting_.Fields_from_.Structured_.Data)"/>Extracting Fields from Structured Data<a href="#(part._.Extracting_.Fields_from_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s write a function that tells us how old a song is. First, letâ€™s
think about what the function consumes (an <code data-lang="pyret" class="sourceCode">ITunesSong</code>) and
produces (a <code data-lang="pyret" class="sourceCode">Number</code>). This gives us a rough skeleton for the
function:
</p><a name="(elem._song-age)"/>&lt;song-age&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  <a href="#%28elem._song-age-body%29" data-pltdoc="x">&lt;song-age-body&gt;</a>
end</code></pre><p>We know that the form of the body must be roughly:
</p><a name="(elem._song-age-body)"/>&lt;song-age-body&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2016 - &lt;get the song year&gt;</code></pre><p>We can get the song year by using Pyretâ€™s field access, which is
a <code data-lang="pyret" class="sourceCode">.</code> followed by a fieldâ€™s nameâ€”<wbr/>in this case,
<code data-lang="pyret" class="sourceCode">year</code>â€”<wbr/>following the variable that holds the structured
datum. Thus, we get the <code data-lang="pyret" class="sourceCode">year</code> field of <code data-lang="pyret" class="sourceCode">s</code> (the parameter
to <code data-lang="pyret" class="sourceCode">song-age</code>) with
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">s.year</code></pre><p>So the entire function body is:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  2016 - s.year
end</code></pre><p>It would be good to also record some examples
(<a href="#%28elem._structured-examples%29" data-pltdoc="x">&lt;structured-examples&gt;</a>), giving us a comprehensive
definition of the function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  2016 - s.year
where:
  song-age(lver) is 71
  song-age(so) is 1
  song-age(wnkkhs) is 57
end</code></pre></section><section class="SsectionLevel5" id="section 6.1.3.2"><h5 class="heading">6.1.3.2Â <a name="(part._telling-apart-variants)"/>Telling Apart Variants of Conditional Data<a href="#(part._telling-apart-variants)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Now letâ€™s see how we tell apart variants. For this, we again use
<code data-lang="pyret" class="sourceCode">cases</code>, as we saw for lists. We create one branch for each of
the variants. Thus, if we wanted to compute advice for a driver based on a
traffic lightâ€™s state, we might write:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun advice(c :: TLColor) -&gt; String:
  cases (TLColor) c:
    | Red =&gt; "wait!"
    | Yellow =&gt; "get ready..."
    | Green =&gt; "go!"
  end
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What happens if you leave out the <code data-lang="pyret" class="sourceCode">=&gt;</code>?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What if you leave out a variant? Leave out the <code data-lang="pyret" class="sourceCode">Red</code> variant,
then try both <code data-lang="pyret" class="sourceCode">advice(Yellow)</code> and <code data-lang="pyret" class="sourceCode">advice(Red)</code>.</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 6.1.3.3"><h5 class="heading">6.1.3.3Â <a name="(part._process-fields-variants)"/>Processing Fields of Variants<a href="#(part._process-fields-variants)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>In this example, the variants had no fields. But if the variant has
fields, Pyret expects you to list names of variables for those fields,
and will then automatically bind those variablesâ€”<wbr/>so you donâ€™t need
to use the <code data-lang="pyret" class="sourceCode">.</code>-notation to get the field values.</p><p>To illustrate this, assume we want to get the name of any animal:
</p><a name="(elem._animal-name)"/>&lt;animal-name&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun animal-name(a :: Animal) -&gt; String:
  <a href="#%28elem._animal-name-body%29" data-pltdoc="x">&lt;animal-name-body&gt;</a>
end</code></pre><p>Because an <code data-lang="pyret" class="sourceCode">Animal</code> is conditionally defined, we know that we are
likely to want a <code data-lang="pyret" class="sourceCode">cases</code> to pull it apart; furthermore, we should
give names to each of the fields:Note that the names of the
variables do not have to match the names of
fields. Conventionally, we give longer, descriptive names to
the field definitions and short names to the corresponding variables.</p><a name="(elem._animal-name-body)"/>&lt;animal-name-body&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (Animal) a:
  | boa(n, l) =&gt; ...
  | armadillo(n, l) =&gt; ...
end</code></pre><p>In both cases, we want to return the field <code data-lang="pyret" class="sourceCode">n</code>, giving us the
complete function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun animal-name(a :: Animal) -&gt; String:
  cases (Animal) a:
    | boa(n, l) =&gt; n
    | armadillo(n, l) =&gt; n
  end
where:
  animal-name(b1) is "Ayisha"
  animal-name(b2) is "Bonito"
  animal-name(a1) is "Glypto"
end</code></pre><p>Letâ€™s look at how Pyret would evaluate a function call like
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">animal-name(boa("Bonito", 8))</code></pre><p>The argument <code data-lang="pyret" class="sourceCode">boa("Bonito", 8)</code> is a value. In the same way as we
substitute simple data types like strings and numbers for parameters
when we evaluate a function, we do the same thing here. After
substituting, we are left with the following expression to evaluate:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (Animal) boa("Bonito", 8):
  | boa(n, l) =&gt; n
  | armadillo(n, l) =&gt; n
end</code></pre><p>Next, Pyret determines which case matches the data (the first one, for
<code data-lang="pyret" class="sourceCode">boa</code>, in this case). It then substitutes the field names with the
corresponding components of the datum result expression for the
matched case. In this case, we will substitute uses of <code data-lang="pyret" class="sourceCode">n</code> with
<code data-lang="pyret" class="sourceCode">"Bonito"</code> and uses of <code data-lang="pyret" class="sourceCode">l</code> with <code data-lang="pyret" class="sourceCode">8</code>. In this program,
the entire result expression is a use of <code data-lang="pyret" class="sourceCode">n</code>, so the result of
the program in this case is <code data-lang="pyret" class="sourceCode">"Bonito"</code>.</p></section>&#13;
<h5 class="heading">6.1.3.1Â <a name="(part._.Extracting_.Fields_from_.Structured_.Data)"/>Extracting Fields from Structured Data<a href="#(part._.Extracting_.Fields_from_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s write a function that tells us how old a song is. First, letâ€™s
think about what the function consumes (an <code data-lang="pyret" class="sourceCode">ITunesSong</code>) and
produces (a <code data-lang="pyret" class="sourceCode">Number</code>). This gives us a rough skeleton for the
function:
</p><a name="(elem._song-age)"/>&lt;song-age&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  <a href="#%28elem._song-age-body%29" data-pltdoc="x">&lt;song-age-body&gt;</a>
end</code></pre><p>We know that the form of the body must be roughly:
</p><a name="(elem._song-age-body)"/>&lt;song-age-body&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2016 - &lt;get the song year&gt;</code></pre><p>We can get the song year by using Pyretâ€™s field access, which is
a <code data-lang="pyret" class="sourceCode">.</code> followed by a fieldâ€™s nameâ€”<wbr/>in this case,
<code data-lang="pyret" class="sourceCode">year</code>â€”<wbr/>following the variable that holds the structured
datum. Thus, we get the <code data-lang="pyret" class="sourceCode">year</code> field of <code data-lang="pyret" class="sourceCode">s</code> (the parameter
to <code data-lang="pyret" class="sourceCode">song-age</code>) with
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">s.year</code></pre><p>So the entire function body is:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  2016 - s.year
end</code></pre><p>It would be good to also record some examples
(<a href="#%28elem._structured-examples%29" data-pltdoc="x">&lt;structured-examples&gt;</a>), giving us a comprehensive
definition of the function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  2016 - s.year
where:
  song-age(lver) is 71
  song-age(so) is 1
  song-age(wnkkhs) is 57
end</code></pre>&#13;
<h5 class="heading">6.1.3.2Â <a name="(part._telling-apart-variants)"/>Telling Apart Variants of Conditional Data<a href="#(part._telling-apart-variants)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Now letâ€™s see how we tell apart variants. For this, we again use
<code data-lang="pyret" class="sourceCode">cases</code>, as we saw for lists. We create one branch for each of
the variants. Thus, if we wanted to compute advice for a driver based on a
traffic lightâ€™s state, we might write:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun advice(c :: TLColor) -&gt; String:
  cases (TLColor) c:
    | Red =&gt; "wait!"
    | Yellow =&gt; "get ready..."
    | Green =&gt; "go!"
  end
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What happens if you leave out the <code data-lang="pyret" class="sourceCode">=&gt;</code>?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What if you leave out a variant? Leave out the <code data-lang="pyret" class="sourceCode">Red</code> variant,
then try both <code data-lang="pyret" class="sourceCode">advice(Yellow)</code> and <code data-lang="pyret" class="sourceCode">advice(Red)</code>.</p></blockquote></blockquote>&#13;
<h5 class="heading">6.1.3.3Â <a name="(part._process-fields-variants)"/>Processing Fields of Variants<a href="#(part._process-fields-variants)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>In this example, the variants had no fields. But if the variant has
fields, Pyret expects you to list names of variables for those fields,
and will then automatically bind those variablesâ€”<wbr/>so you donâ€™t need
to use the <code data-lang="pyret" class="sourceCode">.</code>-notation to get the field values.</p><p>To illustrate this, assume we want to get the name of any animal:
</p><a name="(elem._animal-name)"/>&lt;animal-name&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun animal-name(a :: Animal) -&gt; String:
  <a href="#%28elem._animal-name-body%29" data-pltdoc="x">&lt;animal-name-body&gt;</a>
end</code></pre><p>Because an <code data-lang="pyret" class="sourceCode">Animal</code> is conditionally defined, we know that we are
likely to want a <code data-lang="pyret" class="sourceCode">cases</code> to pull it apart; furthermore, we should
give names to each of the fields:Note that the names of the
variables do not have to match the names of
fields. Conventionally, we give longer, descriptive names to
the field definitions and short names to the corresponding variables.</p><a name="(elem._animal-name-body)"/>&lt;animal-name-body&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (Animal) a:
  | boa(n, l) =&gt; ...
  | armadillo(n, l) =&gt; ...
end</code></pre><p>In both cases, we want to return the field <code data-lang="pyret" class="sourceCode">n</code>, giving us the
complete function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun animal-name(a :: Animal) -&gt; String:
  cases (Animal) a:
    | boa(n, l) =&gt; n
    | armadillo(n, l) =&gt; n
  end
where:
  animal-name(b1) is "Ayisha"
  animal-name(b2) is "Bonito"
  animal-name(a1) is "Glypto"
end</code></pre><p>Letâ€™s look at how Pyret would evaluate a function call like
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">animal-name(boa("Bonito", 8))</code></pre><p>The argument <code data-lang="pyret" class="sourceCode">boa("Bonito", 8)</code> is a value. In the same way as we
substitute simple data types like strings and numbers for parameters
when we evaluate a function, we do the same thing here. After
substituting, we are left with the following expression to evaluate:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (Animal) boa("Bonito", 8):
  | boa(n, l) =&gt; n
  | armadillo(n, l) =&gt; n
end</code></pre><p>Next, Pyret determines which case matches the data (the first one, for
<code data-lang="pyret" class="sourceCode">boa</code>, in this case). It then substitutes the field names with the
corresponding components of the datum result expression for the
matched case. In this case, we will substitute uses of <code data-lang="pyret" class="sourceCode">n</code> with
<code data-lang="pyret" class="sourceCode">"Bonito"</code> and uses of <code data-lang="pyret" class="sourceCode">l</code> with <code data-lang="pyret" class="sourceCode">8</code>. In this program,
the entire result expression is a use of <code data-lang="pyret" class="sourceCode">n</code>, so the result of
the program in this case is <code data-lang="pyret" class="sourceCode">"Bonito"</code>.</p>    
</body>
</html>