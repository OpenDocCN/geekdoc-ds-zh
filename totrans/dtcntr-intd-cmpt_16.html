<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>6.1Â Introduction to Structured DatağŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>6.1Â Introduction to Structured DatağŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/intro-struct-data.html">https://dcic-world.org/2025-08-27/intro-struct-data.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Understanding_the_.Kinds_of_.Compound_.Data%29" class="toclink" data-pltdoc="x">6.1.1<span class="hspace">Â </span>Understanding the Kinds of Compound Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.A_.First_.Peek_at_.Structured_.Data%29" class="toclink" data-pltdoc="x">6.1.1.1<span class="hspace">Â </span>A First Peek at Structured Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.A_.First_.Peek_at_.Conditional_.Data%29" class="toclink" data-pltdoc="x">6.1.1.2<span class="hspace">Â </span>A First Peek at Conditional Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data%29" class="toclink" data-pltdoc="x">6.1.2<span class="hspace">Â </span>Defining and Creating Structured and Conditional Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._struct-data-eg%29" class="toclink" data-pltdoc="x">6.1.2.1<span class="hspace">Â </span>Defining and Creating Structured Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Annotations_for_.Structured_.Data%29" class="toclink" data-pltdoc="x">6.1.2.2<span class="hspace">Â </span>Annotations for Structured Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Defining_and_.Creating_.Conditional_.Data%29" class="toclink" data-pltdoc="x">6.1.2.3<span class="hspace">Â </span>Defining and Creating Conditional Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Programming_with_.Structured_and_.Conditional_.Data%29" class="toclink" data-pltdoc="x">6.1.3<span class="hspace">Â </span>Programming with Structured and Conditional Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Extracting_.Fields_from_.Structured_.Data%29" class="toclink" data-pltdoc="x">6.1.3.1<span class="hspace">Â </span>Extracting Fields from Structured Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._telling-apart-variants%29" class="toclink" data-pltdoc="x">6.1.3.2<span class="hspace">Â </span>Telling Apart Variants of Conditional Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._process-fields-variants%29" class="toclink" data-pltdoc="x">6.1.3.3<span class="hspace">Â </span>Processing Fields of Variants</a></p></td></tr></table><p>Earlier we had our first look at types. Until now, we have only seen
the types that Pyret provides us, which is an interesting but
nevertheless quite limited set. Most programs we write will contain
many more kinds of data.</p><section class="SsectionLevel4" id="section 6.1.1"><h4 class="heading">6.1.1<span class="stt">Â </span><a name="(part._.Understanding_the_.Kinds_of_.Compound_.Data)"/>Understanding the Kinds of Compound Data<span class="button-group"><a href="#(part._.Understanding_the_.Kinds_of_.Compound_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><section class="SsectionLevel5" id="section 6.1.1.1"><h5 class="heading">6.1.1.1<span class="stt">Â </span><a name="(part._.A_.First_.Peek_at_.Structured_.Data)"/>A First Peek at Structured Data<span class="button-group"><a href="#(part._.A_.First_.Peek_at_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">There are times when a datum has many <span style="font-style: italic">attributes</span>, or parts. We
need to keep them all together, and sometimes take them apart. For
instance:
</div><div class="SIntrapara"><ul><li><p>An iTunes entry contains a bunch of information about a single
song: not only its name but also its singer, its length, its genre,
and so on.</p><p><img src="../Images/72a14943124cb68143f994a2a282a9ac.png" alt="" width="1112" height="60" data-original-src="https://dcic-world.org/2025-08-27/itunes-1.png"/></p></li><li><p>Your GMail application contains a bunch of information about a
single message: its sender, the subject line, the conversation itâ€™s
part of, the body, and quite a bit more.</p><p><img src="../Images/17a64e6b5180eb56ebf06a02ffe39113.png" alt="" width="1136" height="46" data-original-src="https://dcic-world.org/2025-08-27/gmail-1.png"/></p></li></ul></div><div class="SIntrapara">In examples like this, we see the need for <span style="font-style: italic">structured</span> data: a
single datum has <span class="emph">structure</span>, i.e., it
actually consists of many pieces. The number of pieces is
<span style="font-style: italic">fixed</span>, but may be of different kinds (some might be numbers,
some strings, some images, and different types may be mixed together
in that one datum).  Some might even be other structured data:
for instance, a date usually has at least three parts, the day, month,
and year. The parts of a structured datum are called its <span style="font-style: italic">fields</span>.</div></section><section class="SsectionLevel5" id="section 6.1.1.2"><h5 class="heading">6.1.1.2<span class="stt">Â </span><a name="(part._.A_.First_.Peek_at_.Conditional_.Data)"/>A First Peek at Conditional Data<span class="button-group"><a href="#(part._.A_.First_.Peek_at_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Then there are times when we want to represent different <span class="emph">kinds</span> of
data under a single, collective umbrella. Here are a few examples:
</div><div class="SIntrapara"><ul><li><p>A traffic light can be in different states: red, yellow, or
green.<span class="refelem"><span class="refcolumn"><span class="refcontent">Yes, in some countries there are different or more
colors and color-combinations.</span></span></span> Collectively, they represent one
thing: a new type called a traffic light state.</p></li><li><p>A zoo consists of many kinds of animals. Collectively, they
represent one thing: a new type called an animal. Some condition
determines which particular kind of animal a zookeeper might be dealing
with.</p></li><li><p>A social network consists of different kinds of pages. Some
pages represent individual humans, some places, some organizations,
some might stand for activities, and so on. Collectively, they
represent a new type: a social media page.</p></li><li><p>A notification application may report many kinds of events. Some
are for email messages (which have many fields, as weâ€™ve discussed),
some are for reminders (which might have a timestamp and a note), some
for instant messages (similar to an email message, but without a
subject), some might even be for the arrival of a package by physical
mail (with a timestamp, shipper, tracking number, and delivery
note). Collectively, these all represent a new type: a notification.</p></li></ul></div><div class="SIntrapara">We call these â€œconditionalâ€ data because they represent an â€œorâ€: a
traffic light is red <span class="emph">or</span> green <span class="emph">or</span> yellow; a social
mediumâ€™s page is for a person <span class="emph">or</span> location <span class="emph">or</span>
organization; and so on. Sometimes we care exactly which kind of thing
weâ€™re looking at: a driver behaves differently on different colors,
and a zookeeper feeds each animal differently. At other times, we
might not care: if weâ€™re just counting how many animals are in the
zoo, or how many pages are on a social network, or how many unread
notifications we have, their details donâ€™t matter. Therefore, there are
times when we ignore the conditional and treat the datum as a member
of the collective, and other times when we do care about the
conditional and do different things depending on the individual
datum. We will make all this concrete as we start to write programs.</div></section></section><section class="SsectionLevel4" id="section 6.1.2"><h4 class="heading">6.1.2<span class="stt">Â </span><a name="(part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data)"/>Defining and Creating Structured and Conditional Data<span class="button-group"><a href="#(part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>We have used the word â€œdataâ€ above, but thatâ€™s actually been a bit
of a lie. As we said earlier, data are how we represent
information in the computer. What weâ€™ve been discussing above is
really different kinds of information, not exactly how they are
represented. But to write programs, we must wrestle concretely with
representations. Thatâ€™s what we will do now, i.e., actually show
<span class="emph">data</span> representations of all this information.</p><section class="SsectionLevel5" id="section 6.1.2.1"><h5 class="heading">6.1.2.1<span class="stt">Â </span><a name="(part._struct-data-eg)"/>Defining and Creating Structured Data<span class="button-group"><a href="#(part._struct-data-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Letâ€™s start with defining structured data, such as an iTunes song
record. Hereâ€™s a simplified version of the information such an app
might store:
</div><div class="SIntrapara"><ul><li><p>The songâ€™s name, which is a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">String</code></span>.</p></li><li><p>The songâ€™s singer, which is also a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">String</code></span>.</p></li><li><p>The songâ€™s year, which is a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>.</p></li></ul></div><div class="SIntrapara">Letâ€™s now introduce the syntax by which we can teach this to Pyret:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name, singer, year) end</code></pre></div></div></div><div class="SIntrapara">This tells Pyret to introduce a <span class="emph">new type of data</span>, in this case
called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ITunesSong</code></span><span class="refelem"><span class="refcolumn"><span class="refcontent">We follow a convention that types
always begin with a capital letter.</span></span></span>. The way we actually make one of
these data is by calling <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">song</code></span> with three parameters; for
instance:<span class="refelem"><span class="refcolumn"><span class="refcontent">Itâ€™s worth noting that music managers that are
capable of making distinctions between, say, Dance, Electronica, and
Electronic/Dance, classify two of these three songs by a single genre:
â€œWorldâ€.</span></span></span>
</div><div class="SIntrapara"><a name="(elem._structured-examples)"/>&lt;<span style="font-style: italic">structured-examples</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">song("La Vie en Rose", "Ã‰dith Piaf", 1945)
song("Stressed Out", "twenty one pilots", 2015)
song("Waqt Ne Kiya Kya Haseen Sitam", "Geeta Dutt", 1959)</code></pre></div></div></div><div class="SIntrapara">Always follow a data definition with a few concrete instances of the
data! This makes sure you actually do know how to make data of that
form. Indeed, itâ€™s not essential but a good habit to give names to the
data weâ€™ve defined, so that we can use them later:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver = song("La Vie en Rose", "Ã‰dith Piaf", 1945)
so = song("Stressed Out", "twenty one pilots", 2015)
wnkkhs = song("Waqt Ne Kiya Kya Haseen Sitam", "Geeta Dutt", 1959)</code></pre></div></div></div><p>In terms of the directory, structured data are no different from
simple data. Each of the three definitions above creates an entry in
the directory, as follows:</p><div class="HeapExpr EmptyHeap"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">lver</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">so</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("Stressed Out", "twenty one pilots", 2015)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">wnkkhs</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("Waqt Ne Kiya Kya Haseen Sitam","Geeta Dutt", 1959)</code></pre></div></div></div></li></ul></div><p/><div class="clear"/></div></section><section class="SsectionLevel5" id="section 6.1.2.2"><h5 class="heading">6.1.2.2<span class="stt">Â </span><a name="(part._.Annotations_for_.Structured_.Data)"/>Annotations for Structured Data<span class="button-group"><a href="#(part._.Annotations_for_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Recall that in [<a href="From_Repeated_Expressions_to_Functions.html#%28part._fun-annotations%29" data-pltdoc="x">Type Annotations</a>] we discussed annotating our functions. Well, we
can annotate our data, too! In particular, we can annotate both the
<span class="emph">definition</span> of data and their <span class="emph">creation</span>. For the former,
consider this data definition, which makes the annotation information
weâ€™d recorded informally in text a formal part of the program:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name :: String, singer :: String, year :: Number) end</code></pre></div></div></div><div class="SIntrapara">Similarly, we can annotate the variables bound to examples of the
data. But what should we write here?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: ___ = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></div></div></div><div class="SIntrapara">Recall that annotations takes names of types, and the new type weâ€™ve
created is called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ITunesSong</code></span>. Therefore, we should write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: ITunesSong = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">What happens if we instead write this?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: String = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></div></div></div><div class="SIntrapara">What error do we get? How about if instead we write these?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: song = song("La Vie en Rose", "Ã‰dith Piaf", 1945)
lver :: 1 = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></div></div></div><div class="SIntrapara">Make sure you familiarize yourself with the error messages that you
get.</div></blockquote></blockquote></section><section class="SsectionLevel5" id="section 6.1.2.3"><h5 class="heading">6.1.2.3<span class="stt">Â </span><a name="(part._.Defining_and_.Creating_.Conditional_.Data)"/>Defining and Creating Conditional Data<span class="button-group"><a href="#(part._.Defining_and_.Creating_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data</code></span> construct in Pyret also lets us create conditional
data, with a slightly different syntax. For instance, say we want to
define the colors of a traffic light:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data TLColor:
  | Red
  | Yellow
  | Green
end</code></pre></div></div></div><div class="SIntrapara"><span class="refelem"><span class="refcolumn"><span class="refcontent">Conventionally, the names of the options begin in
lower-case, but if they have no additional structure, we often
capitalize the initial to make them look different from ordinary
variables: i.e., <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Red</code></span> rather than <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">red</code></span>.</span></span></span>
Each <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">|</code></span> (pronounced â€œstickâ€) introduces another option. You
would make instances of traffic light colors as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Red
Green
Yellow</code></pre></div></div></div><p/><div class="SIntrapara">A more interesting and common example is when each condition has some
structure to it; for instance:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Animal:
  | boa(name :: String, length :: Number)
  | armadillo(name :: String, liveness :: Boolean)
end</code></pre></div></div></div><div class="SIntrapara"><span class="refelem"><span class="refcolumn"><span class="refcontent">â€œIn Texas, there ainâ€™t nothinâ€™ in the middle of the road
except yellow stripes and a dead armadillo.â€â€”<wbr/>Jim Hightower</span></span></span>
We can make examples of them as you would expect:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1 = boa("Ayisha", 10)
b2 = boa("Bonito", 8)
a1 = armadillo("Glypto", true)</code></pre></div></div></div><div class="SIntrapara">We call the different conditions <span style="font-style: italic">variants</span>.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How would you annotate the three variable bindings?</p></blockquote></blockquote><p>Notice that the distinction between boas and armadillos is lost in the
annotation.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1 :: Animal = boa("Ayisha", 10)
b2 :: Animal = boa("Bonito", 8)
a1 :: Animal = armadillo("Glypto", true)</code></pre></div></div><p/><div class="SIntrapara">When defining a conditional datum the first stick is actually
optional, but adding it makes the variants line up nicely. This helps
us realize that our first example
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name, singer, year) end</code></pre></div></div></div><div class="SIntrapara">is really just the same as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong:
  | song(name, singer, year)
end</code></pre></div></div></div><div class="SIntrapara">i.e., a conditional type with just one condition, where that one
condition is structured.</div></section></section><section class="SsectionLevel4" id="section 6.1.3"><h4 class="heading">6.1.3<span class="stt">Â </span><a name="(part._.Programming_with_.Structured_and_.Conditional_.Data)"/>Programming with Structured and Conditional Data<span class="button-group"><a href="#(part._.Programming_with_.Structured_and_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">So far weâ€™ve learned how to create structured and conditional data,
but not yet how to take them apart or write any expressions that
involve them. As you might expect, we need to figure out how to
</div><div class="SIntrapara"><ul><li><p>take apart the fields of a structured datum, and</p></li><li><p>tell apart the variants of a conditional datum.</p></li></ul></div><p>As weâ€™ll see, Pyret also gives us a convenient way to do both
together.</p><section class="SsectionLevel5" id="section 6.1.3.1"><h5 class="heading">6.1.3.1<span class="stt">Â </span><a name="(part._.Extracting_.Fields_from_.Structured_.Data)"/>Extracting Fields from Structured Data<span class="button-group"><a href="#(part._.Extracting_.Fields_from_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Letâ€™s write a function that tells us how old a song is. First, letâ€™s
think about what the function consumes (an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ITunesSong</code></span>) and
produces (a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>). This gives us a rough skeleton for the
function:
</div><div class="SIntrapara"><a name="(elem._song-age)"/>&lt;<span style="font-style: italic">song-age</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  <a href="#%28elem._song-age-body%29" data-pltdoc="x">&lt;<span style="font-style: italic">song-age-body</span>&gt;</a>
end</code></pre></div></div></div><div class="SIntrapara">We know that the form of the body must be roughly:
</div><div class="SIntrapara"><a name="(elem._song-age-body)"/>&lt;<span style="font-style: italic">song-age-body</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2016 - &lt;get the song year&gt;</code></pre></div></div></div><div class="SIntrapara">We can get the song year by using Pyretâ€™s <span style="font-style: italic">field access</span>, which is
a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.</code></span> followed by a fieldâ€™s nameâ€”<wbr/>in this case,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">year</code></span>â€”<wbr/>following the variable that holds the structured
datum. Thus, we get the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">year</code></span> field of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">s</code></span> (the parameter
to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">song-age</code></span>) with
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">s.year</code></pre></div></div></div><div class="SIntrapara">So the entire function body is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  2016 - s.year
end</code></pre></div></div></div><div class="SIntrapara">It would be good to also record some examples
(<a href="#%28elem._structured-examples%29" data-pltdoc="x">&lt;<span style="font-style: italic">structured-examples</span>&gt;</a>), giving us a comprehensive
definition of the function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  2016 - s.year
where:
  song-age(lver) is 71
  song-age(so) is 1
  song-age(wnkkhs) is 57
end</code></pre></div></div></div></section><section class="SsectionLevel5" id="section 6.1.3.2"><h5 class="heading">6.1.3.2<span class="stt">Â </span><a name="(part._telling-apart-variants)"/>Telling Apart Variants of Conditional Data<span class="button-group"><a href="#(part._telling-apart-variants)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Now letâ€™s see how we tell apart variants. For this, we again use
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>, as we saw for lists. We create one branch for each of
the variants. Thus, if we wanted to compute advice for a driver based on a
traffic lightâ€™s state, we might write:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun advice(c :: TLColor) -&gt; String:
  cases (TLColor) c:
    | Red =&gt; "wait!"
    | Yellow =&gt; "get ready..."
    | Green =&gt; "go!"
  end
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What happens if you leave out the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;</code></span>?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What if you leave out a variant? Leave out the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Red</code></span> variant,
then try both <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">advice(Yellow)</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">advice(Red)</code></span>.</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 6.1.3.3"><h5 class="heading">6.1.3.3<span class="stt">Â </span><a name="(part._process-fields-variants)"/>Processing Fields of Variants<span class="button-group"><a href="#(part._process-fields-variants)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>In this example, the variants had no fields. But if the variant has
fields, Pyret expects you to list names of variables for those fields,
and will then automatically bind those variablesâ€”<wbr/>so you donâ€™t need
to use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.</code></span>-notation to get the field values.</p><p/><div class="SIntrapara">To illustrate this, assume we want to get the name of any animal:
</div><div class="SIntrapara"><a name="(elem._animal-name)"/>&lt;<span style="font-style: italic">animal-name</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun animal-name(a :: Animal) -&gt; String:
  <a href="#%28elem._animal-name-body%29" data-pltdoc="x">&lt;<span style="font-style: italic">animal-name-body</span>&gt;</a>
end</code></pre></div></div></div><div class="SIntrapara">Because an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Animal</code></span> is conditionally defined, we know that we are
likely to want a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> to pull it apart; furthermore, we should
give names to each of the fields:<span class="refelem"><span class="refcolumn"><span class="refcontent">Note that the names of the
<span class="emph">variables</span> do not have to match the names of
<span class="emph">fields</span>. Conventionally, we give longer, descriptive names to
the field definitions and short names to the corresponding variables.</span></span></span></div><p/><div class="SIntrapara"><a name="(elem._animal-name-body)"/>&lt;<span style="font-style: italic">animal-name-body</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (Animal) a:
  | boa(n, l) =&gt; ...
  | armadillo(n, l) =&gt; ...
end</code></pre></div></div></div><p/><div class="SIntrapara">In both cases, we want to return the field <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n</code></span>, giving us the
complete function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun animal-name(a :: Animal) -&gt; String:
  cases (Animal) a:
    | boa(n, l) =&gt; n
    | armadillo(n, l) =&gt; n
  end
where:
  animal-name(b1) is "Ayisha"
  animal-name(b2) is "Bonito"
  animal-name(a1) is "Glypto"
end</code></pre></div></div></div><p/><div class="SIntrapara">Letâ€™s look at how Pyret would evaluate a function call like
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">animal-name(boa("Bonito", 8))</code></pre></div></div></div><div class="SIntrapara">The argument <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">boa("Bonito", 8)</code></span> is a value. In the same way as we
substitute simple data types like strings and numbers for parameters
when we evaluate a function, we do the same thing here. After
substituting, we are left with the following expression to evaluate:</div><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (Animal) boa("Bonito", 8):
  | boa(n, l) =&gt; n
  | armadillo(n, l) =&gt; n
end</code></pre></div></div><p>Next, Pyret determines which case matches the data (the first one, for
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">boa</code></span>, in this case). It then substitutes the field names with the
corresponding components of the datum result expression for the
matched case. In this case, we will substitute uses of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n</code></span> with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Bonito"</code></span> and uses of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l</code></span> with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">8</code></span>. In this program,
the entire result expression is a use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n</code></span>, so the result of
the program in this case is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Bonito"</code></span>.</p></section></section>&#13;
<h4 class="heading">6.1.1<span class="stt">Â </span><a name="(part._.Understanding_the_.Kinds_of_.Compound_.Data)"/>Understanding the Kinds of Compound Data<span class="button-group"><a href="#(part._.Understanding_the_.Kinds_of_.Compound_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><section class="SsectionLevel5" id="section 6.1.1.1"><h5 class="heading">6.1.1.1<span class="stt">Â </span><a name="(part._.A_.First_.Peek_at_.Structured_.Data)"/>A First Peek at Structured Data<span class="button-group"><a href="#(part._.A_.First_.Peek_at_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">There are times when a datum has many <span style="font-style: italic">attributes</span>, or parts. We
need to keep them all together, and sometimes take them apart. For
instance:
</div><div class="SIntrapara"><ul><li><p>An iTunes entry contains a bunch of information about a single
song: not only its name but also its singer, its length, its genre,
and so on.</p><p><img src="../Images/72a14943124cb68143f994a2a282a9ac.png" alt="" width="1112" height="60" data-original-src="https://dcic-world.org/2025-08-27/itunes-1.png"/></p></li><li><p>Your GMail application contains a bunch of information about a
single message: its sender, the subject line, the conversation itâ€™s
part of, the body, and quite a bit more.</p><p><img src="../Images/17a64e6b5180eb56ebf06a02ffe39113.png" alt="" width="1136" height="46" data-original-src="https://dcic-world.org/2025-08-27/gmail-1.png"/></p></li></ul></div><div class="SIntrapara">In examples like this, we see the need for <span style="font-style: italic">structured</span> data: a
single datum has <span class="emph">structure</span>, i.e., it
actually consists of many pieces. The number of pieces is
<span style="font-style: italic">fixed</span>, but may be of different kinds (some might be numbers,
some strings, some images, and different types may be mixed together
in that one datum).  Some might even be other structured data:
for instance, a date usually has at least three parts, the day, month,
and year. The parts of a structured datum are called its <span style="font-style: italic">fields</span>.</div></section><section class="SsectionLevel5" id="section 6.1.1.2"><h5 class="heading">6.1.1.2<span class="stt">Â </span><a name="(part._.A_.First_.Peek_at_.Conditional_.Data)"/>A First Peek at Conditional Data<span class="button-group"><a href="#(part._.A_.First_.Peek_at_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Then there are times when we want to represent different <span class="emph">kinds</span> of
data under a single, collective umbrella. Here are a few examples:
</div><div class="SIntrapara"><ul><li><p>A traffic light can be in different states: red, yellow, or
green.<span class="refelem"><span class="refcolumn"><span class="refcontent">Yes, in some countries there are different or more
colors and color-combinations.</span></span></span> Collectively, they represent one
thing: a new type called a traffic light state.</p></li><li><p>A zoo consists of many kinds of animals. Collectively, they
represent one thing: a new type called an animal. Some condition
determines which particular kind of animal a zookeeper might be dealing
with.</p></li><li><p>A social network consists of different kinds of pages. Some
pages represent individual humans, some places, some organizations,
some might stand for activities, and so on. Collectively, they
represent a new type: a social media page.</p></li><li><p>A notification application may report many kinds of events. Some
are for email messages (which have many fields, as weâ€™ve discussed),
some are for reminders (which might have a timestamp and a note), some
for instant messages (similar to an email message, but without a
subject), some might even be for the arrival of a package by physical
mail (with a timestamp, shipper, tracking number, and delivery
note). Collectively, these all represent a new type: a notification.</p></li></ul></div><div class="SIntrapara">We call these â€œconditionalâ€ data because they represent an â€œorâ€: a
traffic light is red <span class="emph">or</span> green <span class="emph">or</span> yellow; a social
mediumâ€™s page is for a person <span class="emph">or</span> location <span class="emph">or</span>
organization; and so on. Sometimes we care exactly which kind of thing
weâ€™re looking at: a driver behaves differently on different colors,
and a zookeeper feeds each animal differently. At other times, we
might not care: if weâ€™re just counting how many animals are in the
zoo, or how many pages are on a social network, or how many unread
notifications we have, their details donâ€™t matter. Therefore, there are
times when we ignore the conditional and treat the datum as a member
of the collective, and other times when we do care about the
conditional and do different things depending on the individual
datum. We will make all this concrete as we start to write programs.</div></section>&#13;
<h5 class="heading">6.1.1.1<span class="stt">Â </span><a name="(part._.A_.First_.Peek_at_.Structured_.Data)"/>A First Peek at Structured Data<span class="button-group"><a href="#(part._.A_.First_.Peek_at_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">There are times when a datum has many <span style="font-style: italic">attributes</span>, or parts. We
need to keep them all together, and sometimes take them apart. For
instance:
</div><div class="SIntrapara"><ul><li><p>An iTunes entry contains a bunch of information about a single
song: not only its name but also its singer, its length, its genre,
and so on.</p><p><img src="../Images/72a14943124cb68143f994a2a282a9ac.png" alt="" width="1112" height="60" data-original-src="https://dcic-world.org/2025-08-27/itunes-1.png"/></p></li><li><p>Your GMail application contains a bunch of information about a
single message: its sender, the subject line, the conversation itâ€™s
part of, the body, and quite a bit more.</p><p><img src="../Images/17a64e6b5180eb56ebf06a02ffe39113.png" alt="" width="1136" height="46" data-original-src="https://dcic-world.org/2025-08-27/gmail-1.png"/></p></li></ul></div><div class="SIntrapara">In examples like this, we see the need for <span style="font-style: italic">structured</span> data: a
single datum has <span class="emph">structure</span>, i.e., it
actually consists of many pieces. The number of pieces is
<span style="font-style: italic">fixed</span>, but may be of different kinds (some might be numbers,
some strings, some images, and different types may be mixed together
in that one datum).  Some might even be other structured data:
for instance, a date usually has at least three parts, the day, month,
and year. The parts of a structured datum are called its <span style="font-style: italic">fields</span>.</div>&#13;
<h5 class="heading">6.1.1.2<span class="stt">Â </span><a name="(part._.A_.First_.Peek_at_.Conditional_.Data)"/>A First Peek at Conditional Data<span class="button-group"><a href="#(part._.A_.First_.Peek_at_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Then there are times when we want to represent different <span class="emph">kinds</span> of
data under a single, collective umbrella. Here are a few examples:
</div><div class="SIntrapara"><ul><li><p>A traffic light can be in different states: red, yellow, or
green.<span class="refelem"><span class="refcolumn"><span class="refcontent">Yes, in some countries there are different or more
colors and color-combinations.</span></span></span> Collectively, they represent one
thing: a new type called a traffic light state.</p></li><li><p>A zoo consists of many kinds of animals. Collectively, they
represent one thing: a new type called an animal. Some condition
determines which particular kind of animal a zookeeper might be dealing
with.</p></li><li><p>A social network consists of different kinds of pages. Some
pages represent individual humans, some places, some organizations,
some might stand for activities, and so on. Collectively, they
represent a new type: a social media page.</p></li><li><p>A notification application may report many kinds of events. Some
are for email messages (which have many fields, as weâ€™ve discussed),
some are for reminders (which might have a timestamp and a note), some
for instant messages (similar to an email message, but without a
subject), some might even be for the arrival of a package by physical
mail (with a timestamp, shipper, tracking number, and delivery
note). Collectively, these all represent a new type: a notification.</p></li></ul></div><div class="SIntrapara">We call these â€œconditionalâ€ data because they represent an â€œorâ€: a
traffic light is red <span class="emph">or</span> green <span class="emph">or</span> yellow; a social
mediumâ€™s page is for a person <span class="emph">or</span> location <span class="emph">or</span>
organization; and so on. Sometimes we care exactly which kind of thing
weâ€™re looking at: a driver behaves differently on different colors,
and a zookeeper feeds each animal differently. At other times, we
might not care: if weâ€™re just counting how many animals are in the
zoo, or how many pages are on a social network, or how many unread
notifications we have, their details donâ€™t matter. Therefore, there are
times when we ignore the conditional and treat the datum as a member
of the collective, and other times when we do care about the
conditional and do different things depending on the individual
datum. We will make all this concrete as we start to write programs.</div>&#13;
<h4 class="heading">6.1.2<span class="stt">Â </span><a name="(part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data)"/>Defining and Creating Structured and Conditional Data<span class="button-group"><a href="#(part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>We have used the word â€œdataâ€ above, but thatâ€™s actually been a bit
of a lie. As we said earlier, data are how we represent
information in the computer. What weâ€™ve been discussing above is
really different kinds of information, not exactly how they are
represented. But to write programs, we must wrestle concretely with
representations. Thatâ€™s what we will do now, i.e., actually show
<span class="emph">data</span> representations of all this information.</p><section class="SsectionLevel5" id="section 6.1.2.1"><h5 class="heading">6.1.2.1<span class="stt">Â </span><a name="(part._struct-data-eg)"/>Defining and Creating Structured Data<span class="button-group"><a href="#(part._struct-data-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Letâ€™s start with defining structured data, such as an iTunes song
record. Hereâ€™s a simplified version of the information such an app
might store:
</div><div class="SIntrapara"><ul><li><p>The songâ€™s name, which is a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">String</code></span>.</p></li><li><p>The songâ€™s singer, which is also a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">String</code></span>.</p></li><li><p>The songâ€™s year, which is a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>.</p></li></ul></div><div class="SIntrapara">Letâ€™s now introduce the syntax by which we can teach this to Pyret:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name, singer, year) end</code></pre></div></div></div><div class="SIntrapara">This tells Pyret to introduce a <span class="emph">new type of data</span>, in this case
called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ITunesSong</code></span><span class="refelem"><span class="refcolumn"><span class="refcontent">We follow a convention that types
always begin with a capital letter.</span></span></span>. The way we actually make one of
these data is by calling <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">song</code></span> with three parameters; for
instance:<span class="refelem"><span class="refcolumn"><span class="refcontent">Itâ€™s worth noting that music managers that are
capable of making distinctions between, say, Dance, Electronica, and
Electronic/Dance, classify two of these three songs by a single genre:
â€œWorldâ€.</span></span></span>
</div><div class="SIntrapara"><a name="(elem._structured-examples)"/>&lt;<span style="font-style: italic">structured-examples</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">song("La Vie en Rose", "Ã‰dith Piaf", 1945)
song("Stressed Out", "twenty one pilots", 2015)
song("Waqt Ne Kiya Kya Haseen Sitam", "Geeta Dutt", 1959)</code></pre></div></div></div><div class="SIntrapara">Always follow a data definition with a few concrete instances of the
data! This makes sure you actually do know how to make data of that
form. Indeed, itâ€™s not essential but a good habit to give names to the
data weâ€™ve defined, so that we can use them later:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver = song("La Vie en Rose", "Ã‰dith Piaf", 1945)
so = song("Stressed Out", "twenty one pilots", 2015)
wnkkhs = song("Waqt Ne Kiya Kya Haseen Sitam", "Geeta Dutt", 1959)</code></pre></div></div></div><p>In terms of the directory, structured data are no different from
simple data. Each of the three definitions above creates an entry in
the directory, as follows:</p><div class="HeapExpr EmptyHeap"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">lver</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">so</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("Stressed Out", "twenty one pilots", 2015)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">wnkkhs</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("Waqt Ne Kiya Kya Haseen Sitam","Geeta Dutt", 1959)</code></pre></div></div></div></li></ul></div><p/><div class="clear"/></div></section><section class="SsectionLevel5" id="section 6.1.2.2"><h5 class="heading">6.1.2.2<span class="stt">Â </span><a name="(part._.Annotations_for_.Structured_.Data)"/>Annotations for Structured Data<span class="button-group"><a href="#(part._.Annotations_for_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Recall that in [<a href="From_Repeated_Expressions_to_Functions.html#%28part._fun-annotations%29" data-pltdoc="x">Type Annotations</a>] we discussed annotating our functions. Well, we
can annotate our data, too! In particular, we can annotate both the
<span class="emph">definition</span> of data and their <span class="emph">creation</span>. For the former,
consider this data definition, which makes the annotation information
weâ€™d recorded informally in text a formal part of the program:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name :: String, singer :: String, year :: Number) end</code></pre></div></div></div><div class="SIntrapara">Similarly, we can annotate the variables bound to examples of the
data. But what should we write here?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: ___ = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></div></div></div><div class="SIntrapara">Recall that annotations takes names of types, and the new type weâ€™ve
created is called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ITunesSong</code></span>. Therefore, we should write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: ITunesSong = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">What happens if we instead write this?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: String = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></div></div></div><div class="SIntrapara">What error do we get? How about if instead we write these?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: song = song("La Vie en Rose", "Ã‰dith Piaf", 1945)
lver :: 1 = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></div></div></div><div class="SIntrapara">Make sure you familiarize yourself with the error messages that you
get.</div></blockquote></blockquote></section><section class="SsectionLevel5" id="section 6.1.2.3"><h5 class="heading">6.1.2.3<span class="stt">Â </span><a name="(part._.Defining_and_.Creating_.Conditional_.Data)"/>Defining and Creating Conditional Data<span class="button-group"><a href="#(part._.Defining_and_.Creating_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data</code></span> construct in Pyret also lets us create conditional
data, with a slightly different syntax. For instance, say we want to
define the colors of a traffic light:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data TLColor:
  | Red
  | Yellow
  | Green
end</code></pre></div></div></div><div class="SIntrapara"><span class="refelem"><span class="refcolumn"><span class="refcontent">Conventionally, the names of the options begin in
lower-case, but if they have no additional structure, we often
capitalize the initial to make them look different from ordinary
variables: i.e., <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Red</code></span> rather than <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">red</code></span>.</span></span></span>
Each <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">|</code></span> (pronounced â€œstickâ€) introduces another option. You
would make instances of traffic light colors as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Red
Green
Yellow</code></pre></div></div></div><p/><div class="SIntrapara">A more interesting and common example is when each condition has some
structure to it; for instance:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Animal:
  | boa(name :: String, length :: Number)
  | armadillo(name :: String, liveness :: Boolean)
end</code></pre></div></div></div><div class="SIntrapara"><span class="refelem"><span class="refcolumn"><span class="refcontent">â€œIn Texas, there ainâ€™t nothinâ€™ in the middle of the road
except yellow stripes and a dead armadillo.â€â€”<wbr/>Jim Hightower</span></span></span>
We can make examples of them as you would expect:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1 = boa("Ayisha", 10)
b2 = boa("Bonito", 8)
a1 = armadillo("Glypto", true)</code></pre></div></div></div><div class="SIntrapara">We call the different conditions <span style="font-style: italic">variants</span>.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How would you annotate the three variable bindings?</p></blockquote></blockquote><p>Notice that the distinction between boas and armadillos is lost in the
annotation.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1 :: Animal = boa("Ayisha", 10)
b2 :: Animal = boa("Bonito", 8)
a1 :: Animal = armadillo("Glypto", true)</code></pre></div></div><p/><div class="SIntrapara">When defining a conditional datum the first stick is actually
optional, but adding it makes the variants line up nicely. This helps
us realize that our first example
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name, singer, year) end</code></pre></div></div></div><div class="SIntrapara">is really just the same as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong:
  | song(name, singer, year)
end</code></pre></div></div></div><div class="SIntrapara">i.e., a conditional type with just one condition, where that one
condition is structured.</div></section>&#13;
<h5 class="heading">6.1.2.1<span class="stt">Â </span><a name="(part._struct-data-eg)"/>Defining and Creating Structured Data<span class="button-group"><a href="#(part._struct-data-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Letâ€™s start with defining structured data, such as an iTunes song
record. Hereâ€™s a simplified version of the information such an app
might store:
</div><div class="SIntrapara"><ul><li><p>The songâ€™s name, which is a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">String</code></span>.</p></li><li><p>The songâ€™s singer, which is also a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">String</code></span>.</p></li><li><p>The songâ€™s year, which is a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>.</p></li></ul></div><div class="SIntrapara">Letâ€™s now introduce the syntax by which we can teach this to Pyret:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name, singer, year) end</code></pre></div></div></div><div class="SIntrapara">This tells Pyret to introduce a <span class="emph">new type of data</span>, in this case
called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ITunesSong</code></span><span class="refelem"><span class="refcolumn"><span class="refcontent">We follow a convention that types
always begin with a capital letter.</span></span></span>. The way we actually make one of
these data is by calling <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">song</code></span> with three parameters; for
instance:<span class="refelem"><span class="refcolumn"><span class="refcontent">Itâ€™s worth noting that music managers that are
capable of making distinctions between, say, Dance, Electronica, and
Electronic/Dance, classify two of these three songs by a single genre:
â€œWorldâ€.</span></span></span>
</div><div class="SIntrapara"><a name="(elem._structured-examples)"/>&lt;<span style="font-style: italic">structured-examples</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">song("La Vie en Rose", "Ã‰dith Piaf", 1945)
song("Stressed Out", "twenty one pilots", 2015)
song("Waqt Ne Kiya Kya Haseen Sitam", "Geeta Dutt", 1959)</code></pre></div></div></div><div class="SIntrapara">Always follow a data definition with a few concrete instances of the
data! This makes sure you actually do know how to make data of that
form. Indeed, itâ€™s not essential but a good habit to give names to the
data weâ€™ve defined, so that we can use them later:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver = song("La Vie en Rose", "Ã‰dith Piaf", 1945)
so = song("Stressed Out", "twenty one pilots", 2015)
wnkkhs = song("Waqt Ne Kiya Kya Haseen Sitam", "Geeta Dutt", 1959)</code></pre></div></div></div><p>In terms of the directory, structured data are no different from
simple data. Each of the three definitions above creates an entry in
the directory, as follows:</p><div class="HeapExpr EmptyHeap"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">lver</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">so</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("Stressed Out", "twenty one pilots", 2015)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">wnkkhs</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">song("Waqt Ne Kiya Kya Haseen Sitam","Geeta Dutt", 1959)</code></pre></div></div></div></li></ul></div><p/><div class="clear"/></div>&#13;
<h5 class="heading">6.1.2.2<span class="stt">Â </span><a name="(part._.Annotations_for_.Structured_.Data)"/>Annotations for Structured Data<span class="button-group"><a href="#(part._.Annotations_for_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Recall that in [<a href="From_Repeated_Expressions_to_Functions.html#%28part._fun-annotations%29" data-pltdoc="x">Type Annotations</a>] we discussed annotating our functions. Well, we
can annotate our data, too! In particular, we can annotate both the
<span class="emph">definition</span> of data and their <span class="emph">creation</span>. For the former,
consider this data definition, which makes the annotation information
weâ€™d recorded informally in text a formal part of the program:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name :: String, singer :: String, year :: Number) end</code></pre></div></div></div><div class="SIntrapara">Similarly, we can annotate the variables bound to examples of the
data. But what should we write here?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: ___ = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></div></div></div><div class="SIntrapara">Recall that annotations takes names of types, and the new type weâ€™ve
created is called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ITunesSong</code></span>. Therefore, we should write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: ITunesSong = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">What happens if we instead write this?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: String = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></div></div></div><div class="SIntrapara">What error do we get? How about if instead we write these?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lver :: song = song("La Vie en Rose", "Ã‰dith Piaf", 1945)
lver :: 1 = song("La Vie en Rose", "Ã‰dith Piaf", 1945)</code></pre></div></div></div><div class="SIntrapara">Make sure you familiarize yourself with the error messages that you
get.</div></blockquote></blockquote>&#13;
<h5 class="heading">6.1.2.3<span class="stt">Â </span><a name="(part._.Defining_and_.Creating_.Conditional_.Data)"/>Defining and Creating Conditional Data<span class="button-group"><a href="#(part._.Defining_and_.Creating_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data</code></span> construct in Pyret also lets us create conditional
data, with a slightly different syntax. For instance, say we want to
define the colors of a traffic light:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data TLColor:
  | Red
  | Yellow
  | Green
end</code></pre></div></div></div><div class="SIntrapara"><span class="refelem"><span class="refcolumn"><span class="refcontent">Conventionally, the names of the options begin in
lower-case, but if they have no additional structure, we often
capitalize the initial to make them look different from ordinary
variables: i.e., <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Red</code></span> rather than <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">red</code></span>.</span></span></span>
Each <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">|</code></span> (pronounced â€œstickâ€) introduces another option. You
would make instances of traffic light colors as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Red
Green
Yellow</code></pre></div></div></div><p/><div class="SIntrapara">A more interesting and common example is when each condition has some
structure to it; for instance:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Animal:
  | boa(name :: String, length :: Number)
  | armadillo(name :: String, liveness :: Boolean)
end</code></pre></div></div></div><div class="SIntrapara"><span class="refelem"><span class="refcolumn"><span class="refcontent">â€œIn Texas, there ainâ€™t nothinâ€™ in the middle of the road
except yellow stripes and a dead armadillo.â€â€”<wbr/>Jim Hightower</span></span></span>
We can make examples of them as you would expect:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1 = boa("Ayisha", 10)
b2 = boa("Bonito", 8)
a1 = armadillo("Glypto", true)</code></pre></div></div></div><div class="SIntrapara">We call the different conditions <span style="font-style: italic">variants</span>.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How would you annotate the three variable bindings?</p></blockquote></blockquote><p>Notice that the distinction between boas and armadillos is lost in the
annotation.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1 :: Animal = boa("Ayisha", 10)
b2 :: Animal = boa("Bonito", 8)
a1 :: Animal = armadillo("Glypto", true)</code></pre></div></div><p/><div class="SIntrapara">When defining a conditional datum the first stick is actually
optional, but adding it makes the variants line up nicely. This helps
us realize that our first example
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong: song(name, singer, year) end</code></pre></div></div></div><div class="SIntrapara">is really just the same as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ITunesSong:
  | song(name, singer, year)
end</code></pre></div></div></div><div class="SIntrapara">i.e., a conditional type with just one condition, where that one
condition is structured.</div>&#13;
<h4 class="heading">6.1.3<span class="stt">Â </span><a name="(part._.Programming_with_.Structured_and_.Conditional_.Data)"/>Programming with Structured and Conditional Data<span class="button-group"><a href="#(part._.Programming_with_.Structured_and_.Conditional_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">So far weâ€™ve learned how to create structured and conditional data,
but not yet how to take them apart or write any expressions that
involve them. As you might expect, we need to figure out how to
</div><div class="SIntrapara"><ul><li><p>take apart the fields of a structured datum, and</p></li><li><p>tell apart the variants of a conditional datum.</p></li></ul></div><p>As weâ€™ll see, Pyret also gives us a convenient way to do both
together.</p><section class="SsectionLevel5" id="section 6.1.3.1"><h5 class="heading">6.1.3.1<span class="stt">Â </span><a name="(part._.Extracting_.Fields_from_.Structured_.Data)"/>Extracting Fields from Structured Data<span class="button-group"><a href="#(part._.Extracting_.Fields_from_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Letâ€™s write a function that tells us how old a song is. First, letâ€™s
think about what the function consumes (an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ITunesSong</code></span>) and
produces (a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>). This gives us a rough skeleton for the
function:
</div><div class="SIntrapara"><a name="(elem._song-age)"/>&lt;<span style="font-style: italic">song-age</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  <a href="#%28elem._song-age-body%29" data-pltdoc="x">&lt;<span style="font-style: italic">song-age-body</span>&gt;</a>
end</code></pre></div></div></div><div class="SIntrapara">We know that the form of the body must be roughly:
</div><div class="SIntrapara"><a name="(elem._song-age-body)"/>&lt;<span style="font-style: italic">song-age-body</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2016 - &lt;get the song year&gt;</code></pre></div></div></div><div class="SIntrapara">We can get the song year by using Pyretâ€™s <span style="font-style: italic">field access</span>, which is
a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.</code></span> followed by a fieldâ€™s nameâ€”<wbr/>in this case,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">year</code></span>â€”<wbr/>following the variable that holds the structured
datum. Thus, we get the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">year</code></span> field of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">s</code></span> (the parameter
to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">song-age</code></span>) with
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">s.year</code></pre></div></div></div><div class="SIntrapara">So the entire function body is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  2016 - s.year
end</code></pre></div></div></div><div class="SIntrapara">It would be good to also record some examples
(<a href="#%28elem._structured-examples%29" data-pltdoc="x">&lt;<span style="font-style: italic">structured-examples</span>&gt;</a>), giving us a comprehensive
definition of the function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  2016 - s.year
where:
  song-age(lver) is 71
  song-age(so) is 1
  song-age(wnkkhs) is 57
end</code></pre></div></div></div></section><section class="SsectionLevel5" id="section 6.1.3.2"><h5 class="heading">6.1.3.2<span class="stt">Â </span><a name="(part._telling-apart-variants)"/>Telling Apart Variants of Conditional Data<span class="button-group"><a href="#(part._telling-apart-variants)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Now letâ€™s see how we tell apart variants. For this, we again use
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>, as we saw for lists. We create one branch for each of
the variants. Thus, if we wanted to compute advice for a driver based on a
traffic lightâ€™s state, we might write:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun advice(c :: TLColor) -&gt; String:
  cases (TLColor) c:
    | Red =&gt; "wait!"
    | Yellow =&gt; "get ready..."
    | Green =&gt; "go!"
  end
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What happens if you leave out the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;</code></span>?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What if you leave out a variant? Leave out the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Red</code></span> variant,
then try both <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">advice(Yellow)</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">advice(Red)</code></span>.</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 6.1.3.3"><h5 class="heading">6.1.3.3<span class="stt">Â </span><a name="(part._process-fields-variants)"/>Processing Fields of Variants<span class="button-group"><a href="#(part._process-fields-variants)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>In this example, the variants had no fields. But if the variant has
fields, Pyret expects you to list names of variables for those fields,
and will then automatically bind those variablesâ€”<wbr/>so you donâ€™t need
to use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.</code></span>-notation to get the field values.</p><p/><div class="SIntrapara">To illustrate this, assume we want to get the name of any animal:
</div><div class="SIntrapara"><a name="(elem._animal-name)"/>&lt;<span style="font-style: italic">animal-name</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun animal-name(a :: Animal) -&gt; String:
  <a href="#%28elem._animal-name-body%29" data-pltdoc="x">&lt;<span style="font-style: italic">animal-name-body</span>&gt;</a>
end</code></pre></div></div></div><div class="SIntrapara">Because an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Animal</code></span> is conditionally defined, we know that we are
likely to want a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> to pull it apart; furthermore, we should
give names to each of the fields:<span class="refelem"><span class="refcolumn"><span class="refcontent">Note that the names of the
<span class="emph">variables</span> do not have to match the names of
<span class="emph">fields</span>. Conventionally, we give longer, descriptive names to
the field definitions and short names to the corresponding variables.</span></span></span></div><p/><div class="SIntrapara"><a name="(elem._animal-name-body)"/>&lt;<span style="font-style: italic">animal-name-body</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (Animal) a:
  | boa(n, l) =&gt; ...
  | armadillo(n, l) =&gt; ...
end</code></pre></div></div></div><p/><div class="SIntrapara">In both cases, we want to return the field <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n</code></span>, giving us the
complete function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun animal-name(a :: Animal) -&gt; String:
  cases (Animal) a:
    | boa(n, l) =&gt; n
    | armadillo(n, l) =&gt; n
  end
where:
  animal-name(b1) is "Ayisha"
  animal-name(b2) is "Bonito"
  animal-name(a1) is "Glypto"
end</code></pre></div></div></div><p/><div class="SIntrapara">Letâ€™s look at how Pyret would evaluate a function call like
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">animal-name(boa("Bonito", 8))</code></pre></div></div></div><div class="SIntrapara">The argument <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">boa("Bonito", 8)</code></span> is a value. In the same way as we
substitute simple data types like strings and numbers for parameters
when we evaluate a function, we do the same thing here. After
substituting, we are left with the following expression to evaluate:</div><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (Animal) boa("Bonito", 8):
  | boa(n, l) =&gt; n
  | armadillo(n, l) =&gt; n
end</code></pre></div></div><p>Next, Pyret determines which case matches the data (the first one, for
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">boa</code></span>, in this case). It then substitutes the field names with the
corresponding components of the datum result expression for the
matched case. In this case, we will substitute uses of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n</code></span> with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Bonito"</code></span> and uses of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l</code></span> with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">8</code></span>. In this program,
the entire result expression is a use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n</code></span>, so the result of
the program in this case is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Bonito"</code></span>.</p></section>&#13;
<h5 class="heading">6.1.3.1<span class="stt">Â </span><a name="(part._.Extracting_.Fields_from_.Structured_.Data)"/>Extracting Fields from Structured Data<span class="button-group"><a href="#(part._.Extracting_.Fields_from_.Structured_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Letâ€™s write a function that tells us how old a song is. First, letâ€™s
think about what the function consumes (an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ITunesSong</code></span>) and
produces (a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>). This gives us a rough skeleton for the
function:
</div><div class="SIntrapara"><a name="(elem._song-age)"/>&lt;<span style="font-style: italic">song-age</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  <a href="#%28elem._song-age-body%29" data-pltdoc="x">&lt;<span style="font-style: italic">song-age-body</span>&gt;</a>
end</code></pre></div></div></div><div class="SIntrapara">We know that the form of the body must be roughly:
</div><div class="SIntrapara"><a name="(elem._song-age-body)"/>&lt;<span style="font-style: italic">song-age-body</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2016 - &lt;get the song year&gt;</code></pre></div></div></div><div class="SIntrapara">We can get the song year by using Pyretâ€™s <span style="font-style: italic">field access</span>, which is
a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.</code></span> followed by a fieldâ€™s nameâ€”<wbr/>in this case,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">year</code></span>â€”<wbr/>following the variable that holds the structured
datum. Thus, we get the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">year</code></span> field of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">s</code></span> (the parameter
to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">song-age</code></span>) with
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">s.year</code></pre></div></div></div><div class="SIntrapara">So the entire function body is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  2016 - s.year
end</code></pre></div></div></div><div class="SIntrapara">It would be good to also record some examples
(<a href="#%28elem._structured-examples%29" data-pltdoc="x">&lt;<span style="font-style: italic">structured-examples</span>&gt;</a>), giving us a comprehensive
definition of the function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun song-age(s :: ITunesSong) -&gt; Number:
  2016 - s.year
where:
  song-age(lver) is 71
  song-age(so) is 1
  song-age(wnkkhs) is 57
end</code></pre></div></div></div>&#13;
<h5 class="heading">6.1.3.2<span class="stt">Â </span><a name="(part._telling-apart-variants)"/>Telling Apart Variants of Conditional Data<span class="button-group"><a href="#(part._telling-apart-variants)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Now letâ€™s see how we tell apart variants. For this, we again use
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>, as we saw for lists. We create one branch for each of
the variants. Thus, if we wanted to compute advice for a driver based on a
traffic lightâ€™s state, we might write:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun advice(c :: TLColor) -&gt; String:
  cases (TLColor) c:
    | Red =&gt; "wait!"
    | Yellow =&gt; "get ready..."
    | Green =&gt; "go!"
  end
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What happens if you leave out the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;</code></span>?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What if you leave out a variant? Leave out the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Red</code></span> variant,
then try both <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">advice(Yellow)</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">advice(Red)</code></span>.</p></blockquote></blockquote>&#13;
<h5 class="heading">6.1.3.3<span class="stt">Â </span><a name="(part._process-fields-variants)"/>Processing Fields of Variants<span class="button-group"><a href="#(part._process-fields-variants)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>In this example, the variants had no fields. But if the variant has
fields, Pyret expects you to list names of variables for those fields,
and will then automatically bind those variablesâ€”<wbr/>so you donâ€™t need
to use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.</code></span>-notation to get the field values.</p><p/><div class="SIntrapara">To illustrate this, assume we want to get the name of any animal:
</div><div class="SIntrapara"><a name="(elem._animal-name)"/>&lt;<span style="font-style: italic">animal-name</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun animal-name(a :: Animal) -&gt; String:
  <a href="#%28elem._animal-name-body%29" data-pltdoc="x">&lt;<span style="font-style: italic">animal-name-body</span>&gt;</a>
end</code></pre></div></div></div><div class="SIntrapara">Because an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Animal</code></span> is conditionally defined, we know that we are
likely to want a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> to pull it apart; furthermore, we should
give names to each of the fields:<span class="refelem"><span class="refcolumn"><span class="refcontent">Note that the names of the
<span class="emph">variables</span> do not have to match the names of
<span class="emph">fields</span>. Conventionally, we give longer, descriptive names to
the field definitions and short names to the corresponding variables.</span></span></span></div><p/><div class="SIntrapara"><a name="(elem._animal-name-body)"/>&lt;<span style="font-style: italic">animal-name-body</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (Animal) a:
  | boa(n, l) =&gt; ...
  | armadillo(n, l) =&gt; ...
end</code></pre></div></div></div><p/><div class="SIntrapara">In both cases, we want to return the field <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n</code></span>, giving us the
complete function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun animal-name(a :: Animal) -&gt; String:
  cases (Animal) a:
    | boa(n, l) =&gt; n
    | armadillo(n, l) =&gt; n
  end
where:
  animal-name(b1) is "Ayisha"
  animal-name(b2) is "Bonito"
  animal-name(a1) is "Glypto"
end</code></pre></div></div></div><p/><div class="SIntrapara">Letâ€™s look at how Pyret would evaluate a function call like
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">animal-name(boa("Bonito", 8))</code></pre></div></div></div><div class="SIntrapara">The argument <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">boa("Bonito", 8)</code></span> is a value. In the same way as we
substitute simple data types like strings and numbers for parameters
when we evaluate a function, we do the same thing here. After
substituting, we are left with the following expression to evaluate:</div><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (Animal) boa("Bonito", 8):
  | boa(n, l) =&gt; n
  | armadillo(n, l) =&gt; n
end</code></pre></div></div><p>Next, Pyret determines which case matches the data (the first one, for
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">boa</code></span>, in this case). It then substitutes the field names with the
corresponding components of the datum result expression for the
matched case. In this case, we will substitute uses of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n</code></span> with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Bonito"</code></span> and uses of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l</code></span> with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">8</code></span>. In this program,
the entire result expression is a use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n</code></span>, so the result of
the program in this case is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Bonito"</code></span>.</p>    
</body>
</html>