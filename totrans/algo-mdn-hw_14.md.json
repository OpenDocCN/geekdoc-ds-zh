["```cpp\nfor (int i = 0; i < N; i++)  a[i] = rand() % 100;   volatile int s;   for (int i = 0; i < N; i++)  if (a[i] < 50) s += a[i]; \n```", "```cpp\nfor (int i = 0; i < N; i++)  s += (a[i] < 50) * a[i]; \n```", "```cpp\nmov  ebx, eax   ; t = x sub  ebx, 50    ; t -= 50 sar  ebx, 31    ; t >>= 31 imul  eax, ebx   ; x *= t \n```", "```cpp\nmov  ebx, eax   ; t = x sub  ebx, 50    ; t -= 50 sar  ebx, 31    ; t >>= 31 ; imul  eax, ebx ; x *= t sub  ebx, 1     ; t -= 1 (causing underflow if t = 0) and  eax, ebx   ; x &= t \n```", "```cpp\nmov     ebx, 0      ; cmov doesn't support immediate values, so we need a zero register cmp     eax, 50 cmovge  eax, ebx    ; eax = (eax >= 50 ? eax : ebx=0) \n```", "```cpp\nfor (int i = 0; i < N; i++)  s += (a[i] < 50 ? a[i] : 0); \n```", "```cpp\n mov     eax, 0 mov     ecx, -4000000 loop:  mov     esi, dword ptr [rdx + a + 4000000]  ; load a[i] cmp     esi, 50 cmovge  esi, eax                            ; esi = (esi >= 50 ? esi : eax=0) add     dword ptr [rsp + 12], esi           ; s += esi add     rdx, 4 jnz     loop                                ; \"iterate while rdx is not zero\" \n```", "```cpp\nint lower_bound(int x) {  int *base = t, len = n; while (len > 1) { int half = len / 2; base += (base[half - 1] < x) * half; // will be replaced with a \"cmov\" len -= half; } return *base; } \n```", "```cpp\n/* volatile */ int s = 0;   for (int i = 0; i < N; i++)  if (a[i] < 50) s += a[i]; \n```"]