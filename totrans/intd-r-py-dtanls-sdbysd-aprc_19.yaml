- en: Chapter 14 An Introduction to Object-Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章 对面向对象编程的介绍
- en: 原文：[https://randpythonbook.netlify.app/an-introduction-to-object-oriented-programming](https://randpythonbook.netlify.app/an-introduction-to-object-oriented-programming)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://randpythonbook.netlify.app/an-introduction-to-object-oriented-programming](https://randpythonbook.netlify.app/an-introduction-to-object-oriented-programming)
- en: '**Object-Oriented Programming (OOP)** is a way of thinking about how to organize
    programs. This way of thinking focuses on objects. In the next chapter, we focus
    on organizing programs by functions, but for now we stick to objects. We already
    know about objects from the last chapter, so what’s new here?'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程（OOP）**是一种组织程序的方式。这种方式关注对象。在下一章中，我们将关注通过函数组织程序，但现在我们坚持使用对象。我们已经从上一章了解了对象，那么这里有什么新的内容呢？'
- en: 'The difference is that we’re creating our own *types* now. In the last chapter
    we learned about built-in types: floating point numbers, lists, arrays, functions,
    etc. Now we will discuss broadly how one can create his own types in both R and
    Python. These user-defined types can be used as cookie cutters. Once we have the
    cookie cutter, we can make as many cookies as we want!'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 差别在于我们现在正在创建自己的**类型**。在上一章中，我们学习了内置类型：浮点数、列表、数组、函数等。现在我们将广泛讨论如何在R和Python中创建自己的类型。这些用户定义的类型可以用作模具。一旦我们有了模具，我们就可以制作尽可能多的饼干！
- en: We will not go into this too deeply, but it is important to know how how code
    works so that we can use it more effectively. For instance, in Python, we frequently
    write code like `my_data_frame.doSomething()`. The material in this chapter will
    go a long way to describe how we can make our own types with custom behavior.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨这一点，但了解代码的工作原理非常重要，这样我们才能更有效地使用它。例如，在Python中，我们经常编写像`my_data_frame.doSomething()`这样的代码。本章的内容将详细描述我们如何创建具有自定义行为的自己的类型。
- en: '* * *'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Here are a few abstract concepts that will help thinking about OOP. They are
    not mutually exclusive, and they aren’t unique to OOP, but understanding these
    words will help you understand the purpose of OOP. Later on, when we start looking
    at code examples, I will alert you to when these concepts are coming into play.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些抽象概念，将有助于思考面向对象编程。它们不是相互排斥的，也不是面向对象编程独有的，但理解这些词汇将有助于你理解面向对象编程的目的。稍后，当我们开始查看代码示例时，我会提醒你这些概念何时开始发挥作用。
- en: '**Composition** refers to the idea when one type of object *contains* an object
    of another type. For example, a linear model object could hold on to estimated
    regression coefficients, residuals, etc.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**指的是一种类型的对象**包含**了另一种类型对象的观念。例如，一个线性模型对象可以保留估计的回归系数、残差等。'
- en: '**Inheritance** takes place when an object can be considered to be of another
    type(s). For example, an analysis of variance linear regression model might be
    a special case of a general linear model.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**发生在对象可以被认为是另一种类型（或多种类型）的情况。例如，方差分析线性回归模型可能是一般线性模型的一个特例。'
- en: '**Polymorphism** is the idea that the programmer can use the same code on objects
    of different types. For example, built-in functions in both R and Python can work
    on arguments of a wide variety of different types.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态性**是指程序员可以在不同类型的对象上使用相同的代码。例如，R和Python中的内置函数都可以作用于各种不同类型的参数。'
- en: '**Encapsulation** is another word for complexity hiding. Do you have to understand
    every line of code in a package you’re using? No, because a lot of details are
    purposefully hidden from you.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**是复杂性隐藏的另一种说法。你真的需要理解你使用的包中的每一行代码吗？不，因为很多细节是有意被隐藏起来的。'
- en: '**Modularity** is an idea related to encapsulation–it means splitting something
    into independent pieces. How you split code into different files, different functions,
    different classes–all of that has to do with modularity. It promotes encapsulation,
    and it allows you to think about only a few lines of code at a time.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**是与封装相关的一个概念——它意味着将某物分成独立的片段。你如何将代码分成不同的文件、不同的函数、不同的类——所有这些都涉及到模块化。它促进了封装，并允许你一次只思考几行代码。'
- en: The **interface**, between you and the code you’re using, describes *what* can
    happen, but not *how* it happens. In other words, it describes some functionality
    so that you can decide whether you want to use it, but there are not enough details
    for you to make it work yourself. For example, all you have to do to be able to
    estimate a complicated statistical model is to look up some documentation.[^(23)](#fn23)
    In other words, you only need to be familiar with the interface, not the implementation.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你和所使用的代码之间的**接口**描述了**可以发生什么**，但并不描述**如何发生**。换句话说，它描述了一些功能，以便你可以决定是否想要使用它，但不足以让你自己实现它。例如，你只需要查阅一些文档就能估计一个复杂的统计模型。[^(23)](#fn23)换句话说，你只需要熟悉接口，而不需要了解实现细节。
- en: The **implementation** of some code you’re using describes *how* it works in
    detail. If you are a package author, you can change your code’s implementation
    “behind the scenes” and ideally, your end-users would never notice.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你所使用的某些代码的**实现**详细描述了它是如何工作的。如果你是包的作者，你可以更改代码的实现“幕后”，理想情况下，最终用户永远不会注意到。
- en: 14.1 OOP In Python
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 Python 中的面向对象编程
- en: 14.1.1 Overview
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1 概述
- en: In Python, [classes](https://docs.python.org/3/tutorial/classes.html) are user-defined
    types. When you define your own class, you describe what kind of information it
    holds onto, and how it behaves.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，[类](https://docs.python.org/3/tutorial/classes.html)是用户定义的类型。当你定义自己的类时，你描述了它所持有的信息类型以及它的行为方式。
- en: To define your own type, use the [`class` keyword](https://docs.python.org/3/tutorial/classes.html#class-definition-syntax).
    Objects created with a user-defined class are sometimes called **instances**.
    They behave according to the rules written in the class definition–they always
    have data and/or functions bundled together in the same way, but these instances
    do not all have the same data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义自己的类型，请使用 `class` 关键字([class 定义语法](https://docs.python.org/3/tutorial/classes.html#class-definition-syntax))。使用用户定义的类创建的对象有时被称为**实例**。它们根据类定义中编写的规则行事——它们总是以相同的方式捆绑数据和相关函数，但这些实例并不都具有相同的数据。
- en: To be more clear, classes may have the following two things in their definition.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚，类在其定义中可能有以下两点。
- en: '**Attributes (aka data members)** are pieces of data “owned” by an instance
    created by the class.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性（也称为数据成员）**是类创建的实例所“拥有”的数据片段。'
- en: '**(Instance) methods** are functions “owned” by an instance created by the
    class. They can use and/or modify data belonging to the class.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(实例)方法**是类创建的实例所“拥有”的函数。它们可以使用和/或修改属于类的数据。'
- en: 14.1.2 A First Example
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2 第一个例子
- en: 'Here’s a simple example. Say we are interested in calculating, from numerical
    data \(x_1, \ldots, x_n\), a sample mean: \[\begin{equation} \bar{x}_n = \frac{\sum_{i=1}^n
    x_i}{n}. \end{equation}\]'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子。比如说，我们感兴趣的是从数值数据 \(x_1, \ldots, x_n\) 中计算样本均值：\[\begin{equation}
    \bar{x}_n = \frac{\sum_{i=1}^n x_i}{n}. \end{equation}\]
- en: In Python, we can usually calculate this one number very easily using `np.average`.
    However, this function requires that we pass into it all of the data at once.
    What if we don’t have all the data at any given time? In other words, suppose
    that the data arrive intermittently . We might consider taking advantage of a
    recursive formula for the sample means.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们通常可以使用 `np.average` 非常容易地计算这个数字。然而，这个函数要求我们一次性传递所有数据。如果我们不是在任何给定时间都有所有数据怎么办？换句话说，假设数据是间歇性到达的。我们可能考虑利用样本均值的递归公式。
- en: \[\begin{equation} \bar{x}_n = \frac{(n-1) \bar{x}_{n-1} + x_n}{n} \end{equation}\]
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} \bar{x}_n = \frac{(n-1) \bar{x}_{n-1} + x_n}{n} \end{equation}\]
- en: 'How would we program this in Python? A first option: we might create a variable
    `my_running_ave`, and after every data point arrives, we could'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在 Python 中编写这个程序？一个选择是：我们可能创建一个变量 `my_running_ave`，每次数据点到达后，我们就可以
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are a few problems with this. Every time we add a data point, the formula
    slightly changes. Every time we update the average, we have to write a different
    line of code. This opens up the possibility for more bugs, and it makes your code
    less likely to be used by other people and more difficult to understand. And if
    we were trying to code up something more complicated than a running average? That
    would make matters even worse.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这有几个问题。每次我们添加一个数据点，公式都会略有变化。每次我们更新平均值，我们必须编写不同的代码行。这增加了出现更多错误的可能性，并使得你的代码不太可能被其他人使用，也更难以理解。如果我们试图编写比移动平均更复杂的代码呢？那会使问题变得更糟。
- en: 'A second option: write a class that holds onto the running average, and that
    has'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选择：编写一个包含运行平均值的类，并且它有
- en: an `update` method that updates the running average every time a new data point
    is received, and
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`update`方法，每次接收到新的数据点时都会更新运行平均值，并且
- en: a `get_current_xbar` method that gets the most up-to-date information for us.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`get_current_xbar`方法，为我们获取最新的信息。
- en: 'Using our code would look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的代码看起来是这样的：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is a Python convention that stipules class names should be written in
    `UpperCamelCase` (e.g. `RunningMean`).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个约定，即类名应该使用`UpperCamelCase`（例如`RunningMean`）来编写。
- en: That’s much better! Notice the *encapsulation*–while looking at this code we
    do not need to think about the mathematical formula that is used to process the
    data. We only need to type in the correct data being used. In other words, the
    *implementation* is separated from the *interface*. The interface in this case,
    is just the name of the class methods, and the arguments they expect. That’s all
    we need to know about to use this code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这好多了！注意*封装*——当我们查看这段代码时，我们不需要考虑用于处理数据的数学公式。我们只需要输入正确的数据即可。换句话说，*实现*与*接口*是分离的。在这个例子中，接口只是类方法的名称以及它们期望的参数。这就是我们使用此代码所需了解的全部。
- en: After seeing these new words that are unfamiliar and long, it’s tempting to
    dismiss these new ideas as superfluous. After all, if you are confident that you
    can get your program working, why stress about all these new concepts? If it ain’t
    broke, don’t fix it, right?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到这些不熟悉且长的单词后，人们可能会倾向于将这些新想法视为多余的。毕竟，如果你自信能够让你的程序运行起来，为什么还要担心所有这些新概念呢？如果它没有坏，为什么要修复它，对吧？
- en: I urge you to try to keep an open mind, particularly if you are already confident
    that you understand the basics of programming in R and Python. The topics in this
    chapter are more centered around design choices. This material won’t help you
    write a first draft of a script even faster, but it will make your code much better.
    Even though you will have to slow down a bit before you start typing, thinking
    about your program more deeply will prevent bugs and allow more people to use
    your code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我敦促你们保持开放的心态，尤其是如果你已经自信地认为自己理解了R和Python编程的基础。本章的主题更侧重于设计选择。这些材料不会帮助你更快地写出脚本的初稿，但会使你的代码更加出色。即使你开始输入之前需要稍微慢一点，但更深入地思考你的程序将防止错误，并允许更多的人使用你的代码。
- en: Classes (obviously) need to be defined before they are used, so here is the
    definition of our class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类（显然）在使用之前需要定义，所以这里是我们的类定义。
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Methods that look like `__init__`, or that possess names that begin and end
    with two underscores, are called **dunder (double underscore) methods**, **special
    methods** or **magic methods**. There are many that you can take advantage of!
    For more information see [this](https://docs.python.org/3/reference/datamodel.html#special-method-names).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像`__init__`或以两个下划线开头和结尾的名称的方法被称为**双下划线（double underscore）方法**、**特殊方法**或**魔法方法**。有很多可以利用！更多信息请参阅[这里](https://docs.python.org/3/reference/datamodel.html#special-method-names)。
- en: 'Here are the details of the class definition:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是类定义的详细信息：
- en: Defining class methods looks exactly like defining functions! The primary difference
    is that the first argument must be `self`. If the definition of a method refers
    to `self`, then this allows the class instance to refer to its own (heretofore
    undefined) data attributes. Also, these method definitions are indented inside
    the definition of the class.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义类方法看起来就像定义函数！主要区别在于第一个参数必须是`self`。如果方法的定义引用了`self`，那么这允许类实例引用其自己的（之前未定义的）数据属性。此外，这些方法定义缩进在类的定义内部。
- en: This class owns two data attributes. One to represent the number of data points
    seen up to now (`n`), and another to represent the current running average (`current_xbar`).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类拥有两个数据属性。一个用于表示到目前为止看到的数据点数量（`n`），另一个用于表示当前的运行平均值（`current_xbar`）。
- en: Referring to data members requires dot notation. `self.n` refers to the `n`
    belonging to any instance. This data attribute is free to vary between all the
    objects instantiated by this class.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引用数据成员需要点符号。`self.n`指的是属于任何实例的`n`。这个数据属性可以自由地在由这个类实例化的所有对象之间变化。
- en: The `__init__` method performs the setup operations that are performed every
    time any object is instantiated.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__init__`方法执行在每次实例化任何对象时进行的设置操作。'
- en: The `update` method provides the core functionality using the recursive formula
    displayed above.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update`方法使用上面显示的递归公式提供了核心功能。'
- en: '`get_current_xbar` simply returns the current average. In the case that this
    function is called before any data has been seen, it returns `None`.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get_current_xbar` 简单地返回当前平均值。在没有任何数据被看到之前调用此函数的情况下，它返回 `None`。'
- en: 'A few things you might find interesting:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一些你可能感兴趣的事情：
- en: Computationally, there is never any requirement that we must hold *all* of the
    data points in memory. Our data set could be infinitely large, and our class will
    hold onto only one floating point number, and one integer.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从计算的角度来看，我们永远没有必须保留 *所有* 数据点的内存的要求。我们的数据集可能无限大，而我们的类将只保留一个浮点数和一个整数。
- en: This example is generalizable to other statistical methods. In a mathematical
    statistics course, you will learn about a large class of models having *sufficient
    statistics*. Most sufficient statistics have recursive formulas like the one above.
    Second, many algorithms in *time series analysis* have recursive formulas and
    are often needed to analyze large streams of data. They can all be wrapped into
    a class in a way that is similar to the above example.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个例子可以推广到其他统计方法。在数学统计学课程中，你会了解到一大类具有 *充分统计量* 的模型。大多数充分统计量都有类似于上面的递归公式。其次，许多
    *时间序列分析* 中的算法都有递归公式，并且通常需要分析大量数据流。它们都可以以类似于上述示例的方式封装到类中。
- en: 14.1.3 Adding Inheritance
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.3 添加继承
- en: How can we use inheritance in statistical programming? A primary benefit of
    inheritance is code re-use, so one example of inheritance is writing a generic
    algorithm as a base class, and a specific algorithm as a class that inherits from
    the base class. For example, we could re-use the code in the `RunningMean` class
    in a variety of other classes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在统计编程中使用继承？继承的一个主要好处是代码重用，因此继承的一个例子是将通用算法作为基类编写，将特定算法作为从基类继承的类。例如，我们可以在
    `RunningMean` 类中重用代码，并在各种其他类中。
- en: Let’s make some assumptions about a *parametric model* that is generating our
    data. Suppose I assume that the data points \(x_1, \ldots, x_n\) are a “random
    sample”[^(24)](#fn24) from a normal distribution with mean \(\mu\) and variance
    \(\sigma^2=1\). \(\mu\) is assumed to be unknown (this is, after all, and interval
    for \(\mu\)), and \(\sigma^2\) is assumed to be known, for simplicity.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对生成我们数据的 *参数模型* 做一些假设。假设我假设数据点 \(x_1, \ldots, x_n\) 是从具有均值 \(\mu\) 和方差 \(\sigma^2=1\)
    的正态分布中抽取的“随机样本”。\(\mu\) 被假设为未知（毕竟，这是一个关于 \(\mu\) 的区间），为了简单起见，\(\sigma^2\) 被假设为已知。
- en: A \(95\%\) confidence interval for the true unknown population mean \(\mu\)
    is
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于真实未知总体均值 \(\mu\) 的 \(95\%\) 置信区间是
- en: \[\begin{equation} \left( \bar{x} - 1.96 \sqrt{\frac{\sigma^2}{n}}, \bar{x}
    + 1.96 \sqrt{\frac{\sigma^2}{n}} \right). \end{equation}\]
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} \left( \bar{x} - 1.96 \sqrt{\frac{\sigma^2}{n}}, \bar{x}
    + 1.96 \sqrt{\frac{\sigma^2}{n}} \right). \end{equation}\]
- en: The width of the interval shrinks as we get more data (as \(n \to \infty\)).
    We can write another class that, not only calculates the center of this interval,
    \(\bar{x}\), but also returns the interval endpoints.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们获得更多数据（当 \(n \to \infty\)），区间的宽度会缩小。我们可以编写另一个类，它不仅计算这个区间的中心 \(\bar{x}\)，还返回区间的端点。
- en: If we wrote another class from scratch, then we would need to rewrite a lot
    of the code that we already have in the definition of `RunningMean`. Instead,
    we’ll use the idea of [*inheritance*](https://docs.python.org/3/tutorial/classes.html#inheritance).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从头开始编写另一个类，那么我们就需要在 `RunningMean` 的定义中重写我们已有的大量代码。相反，我们将使用 *继承* 的概念。
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The parentheses in the first line of the class definition signal that this new
    class definition is inheriting from `RunningMean`. Inside the definition of this
    new class, when I refer to `self.current_xbar` Python knows what I’m referring
    to because it is defined in the base class. Last, I am using `super()` to access
    the base class’s methods, such as `__init__`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义的第一行中的括号表示这个新的类定义是从 `RunningMean` 继承的。在这个新类的定义中，当我提到 `self.current_xbar`
    时，Python 知道我在指什么，因为它在基类中定义了。最后，我使用 `super()` 来访问基类的方法，例如 `__init__`。
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example also demonstrates **polymorphism.** Polymorphism comes from the
    Greek for “many forms.” “Forms” means “type” or “class” in this case. If the same
    code (usually a function or method) works on objects of different types, that’s
    polymorphic. Here, the `update` method worked on an object of class `RunningCI`,
    as well as an object of `RunningMean`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也展示了**多态性**。多态性来自希腊语中的“许多形式”。“形式”在这里意味着“类型”或“类”。如果相同的代码（通常是一个函数或方法）可以作用于不同类型的对象，那么这就是多态的。在这里，`update`方法作用于`RunningCI`类的对象，以及`RunningMean`类的对象。
- en: Why is this useful? Consider this example.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么用？考虑这个例子。
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Inside the inner `for` loop, there is no need for include conditional logic
    that tests for what kind of type each `thing` is. We can iterate through time
    more succinctly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部`for`循环中，没有必要包含检查每个`thing`类型的条件逻辑。我们可以更简洁地遍历时间。
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If, in the future, you add a new class called `class7`, then you need to change
    this inner `for` loop, as well as provide new code for the class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将来你添加一个名为`class7`的新类，那么你需要更改这个内部`for`循环，并为该类提供新的代码。
- en: 14.1.4 Adding in Composition
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.4 在组合中添加
- en: '*Composition* also enables code re-use. Inheritance ensures an “is a” relationship
    between base and derived classes, and composition promotes a “has a” relationship.
    Sometimes it can be tricky to decide which technique to use, especially when it
    comes to statistical programming.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*组合*也使代码重用成为可能。继承确保了基类和派生类之间的“是”关系，而组合促进了“有”关系。有时决定使用哪种技术可能很棘手，尤其是在统计编程方面。'
- en: Regarding the example above, you might argue that a confidence interval isn’t
    a particular type of a sample mean. Rather, it only *has a* sample mean. If you
    believe this, then you might opt for a composition based model instead. With composition,
    the derived class (the confidence interval class) will be decoupled from the base
    class (the sample mean class). This decoupling will have a few implications. In
    general, composition is more flexible, but can lead to longer, uglier code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关于上面的例子，你可能会争辩说置信区间不是样本均值的特定类型。相反，它只是*拥有*样本均值。如果你相信这一点，那么你可能会选择基于组合的模型。在组合中，派生类（置信区间类）将与基类（样本均值类）解耦。这种解耦将带来一些影响。一般来说，组合更灵活，但可能会导致更长、更丑陋的代码。
- en: You will lose polymorphism.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将失去多态性。
- en: Your code might become less re-usable.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的代码可能变得不太可重用。
- en: You have to write any derive class methods you want because you don’t inherit
    any from the base class. For example, you won’t automatically get the `.update()`
    or the `.get_current_xbar()` method for free. This can be tedious if there are
    a lot of methods you want both classes to have that should work the same exact
    way for both classes. If there are, you would have to re-write a bunch of method
    definitions.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须编写任何你想要的派生类方法，因为你没有从基类继承任何方法。例如，你不会自动获得`.update()`或`.get_current_xbar()`方法。如果有大量你希望两个类都有且行为完全相同的方法，这可能会很繁琐。如果有，你就必须重写一大堆方法定义。
- en: On the other hand, this could be good if you have methods that behave completely
    differently. Each method you write can have totally different behavior in the
    derived class, even if the method names are the same in both classes. For instance,
    `.update()` could mean something totally different in these two classes. Also,
    in the derive class, you can still call the base class’s `.update()` method.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，如果你有行为完全不同的方法，这可能是个好事。你写的每个方法在派生类中都可以有完全不同的行为，即使两个类中的方法名相同。例如，`.update()`在这两个类中可能意味着完全不同的事情。此外，在派生类中，你仍然可以调用基类的`.update()`方法。
- en: Many-to-one relationships are easier. It’s generally easier to “own” many base
    class instances rather than inherit from many base classes at once. This is especially
    true if this is the only book on programming you plan on reading–I completely
    avoid the topic of multiple inheritance!
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多对一的关系更容易处理。通常来说，同时“拥有”多个基类实例比一次性从多个基类继承要容易得多。这一点尤其适用于你计划阅读的这本书是关于编程的唯一一本书时——我完全避开了多重继承的话题！
- en: Sometimes it is very difficult to choose between using composition or using
    inheritance. However, this choice should be made very carefully. If you make the
    wrong one, and realize too late, *refactoring* your code might be very time consuming!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候在采用组合或继承之间做出选择是非常困难的。然而，这个选择应该非常谨慎地做出。如果你做出了错误的选择，并且意识到得太晚，*重构*你的代码可能会非常耗时！
- en: Here is an example implementation of a confidence interval using composition.
    Notice that this class “owns” a `RunningMean` instance called `self.mean`. This
    is contrast with *inheriting* from the `RunningMean` class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用组合实现的置信区间的示例。请注意，这个类“拥有”一个名为`self.mean`的`RunningMean`实例。这与从`RunningMean`类中*继承*形成对比。
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 14.2 OOP In R
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 R中的面向对象编程
- en: R, unlike Python, has many different kinds of classes. In R, there is not only
    one way to make a class. There are many! I will discuss
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python不同，R有许多不同种类的类。在R中，创建类的方式不止一种。有很多！我将讨论
- en: S3 classes,
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S3类，
- en: S4 classes,
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S4类，
- en: Reference classes, and
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类，以及
- en: R6 classes.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R6类。
- en: If you like how Python does OOP, you will like reference classes and R6 classes,
    while S3 and S4 classes will feel strange to you.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢Python的面向对象编程，你将喜欢引用类和R6类，而S3和S4类对你来说可能很陌生。
- en: It’s best to learn about them chronologically, in my opinion. S3 classes came
    first, S4 classes sought to improve upon those. Reference classes rely on S4 classes,
    and R6 classes are an improved version of Reference classes (Wickham [2014](#ref-wickham2014advanced)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为最好按时间顺序了解它们。S3类是最先出现的，S4类试图改进这些。引用类依赖于S4类，而R6类是引用类的改进版本（Wickham [2014](#ref-wickham2014advanced)）。
- en: '14.2.1 S3 objects: The Big Picture'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.1 S3对象：整体概述
- en: With S3 (and S4) objects, calling a method `print()` will not look like this.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用S3（和S4）对象时，调用方法`print()`看起来不会是这样的。
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Instead, it will look like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，它将看起来像这样：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The primary goal of S3 is *polymorphism* (Grolemund [2014](#ref-grolemund2014hands)).
    We want functions like `print()`, `summary()` and `plot()` to behave differently
    when objects of a different type are passed in to them. Printing a linear model
    should look a lot different than printing a data frame, right? So we can write
    code like the following, we only have to remember fewer functions as an end-user,
    and the “right” thing will always happen. If you’re writing a package, it’s also
    nice for your users that they’re able to use the regular functions that they’re
    familiar with. For instance, I allow users of my package [`cPseudoMaRg`](https://cran.r-project.org/web/packages/cPseudoMaRg/index.html)
    (Brown [2021](#ref-cpm)) to call `print()` on objects of type `cpmResults`. In
    section [13.2](/visualization#plotting-with-ggplot2), `ggplot2` instances, which
    are much more complicated than plain `numeric` `vector`s, are `+`ed together.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: S3的主要目标是*多态性*（Grolemund [2014](#ref-grolemund2014hands)）。我们希望像`print()`、`summary()`和`plot()`这样的函数在传入不同类型的对象时表现不同。打印线性模型应该看起来与打印数据框有很大不同，对吧？因此，我们可以编写如下代码，作为最终用户，我们只需要记住更少的函数，而且“正确”的事情总是会发生。如果你正在编写一个包，这也很好，因为你的用户能够使用他们熟悉的常规函数。例如，我允许我的包`cPseudoMaRg`（Brown
    [2021](#ref-cpm)）的用户在`cpmResults`类型的对象上调用`print()`。在[13.2](/visualization#plotting-with-ggplot2)节中，`ggplot2`实例，它们比普通的`numeric`
    `vector`s复杂得多，是通过`+`连接在一起的。
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This works because these “high-level” functions (such as `print()`), will look
    at its input and choose the most appropriate function to call, based on what kind
    of type the input has. `print()` is the high-level function. When you run some
    of the above code, it might not be obvious which specific function `print()` chooses
    for each input. You can’t see that happening, yet.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以可行，是因为这些“高级”函数（如`print()`）会查看其输入，并根据输入的类型选择最合适的函数来调用。`print()`是高级函数。当你运行上述代码的一些部分时，可能不明显`print()`为每个输入选择了哪个具体函数。你还看不到这个过程发生。
- en: Last, recall that this discussion only applies to S3 objects. Not all objects
    are S3 objects, though. To find out if an object `x` is an S3 object, use `is.object(x)`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，这次讨论仅适用于S3对象。尽管如此，并非所有对象都是S3对象。要确定对象`x`是否是S3对象，请使用`is.object(x)`。
- en: 14.2.2 Using S3 objects
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.2 使用S3对象
- en: 'Using S3 objects is so easy that you probably don’t even know that you’re actually
    using them. You can just try to call functions on objects, look at the output,
    and if you’re happy with it, you’re good. However, if you’ve ever asked yourself:
    “why does `print()` (or another function) do different things all the time?” then
    this section will be useful to you.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用S3对象非常简单，你可能甚至不知道你实际上正在使用它们。你只需尝试在对象上调用函数，查看输出，如果你对此满意，那就行了。然而，如果你曾经问过自己：“为什么`print()`（或另一个函数）总是做不同的事情？”那么这一节对你将很有用。
- en: '`print()` is a [**generic function**](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Method-dispatching)
    which is a function that looks at the type of its first argument, and then calls
    another, more specialized function depending on what type that argument is. Not
    all functions in R are generic, but some are. In addition to `print()`, `summary()`
    and `plot()` are the most ubiquitous generic functions. Generic functions are
    an *interface*, because the user does not need to concern himself with the details
    going on behind the scenes.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()` 是一个 [**泛型函数**](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Method-dispatching)，它查看其第一个参数的类型，然后根据该参数的类型调用另一个更专业的函数。R
    中的并非所有函数都是泛型，但有些是。除了 `print()` 之外，`summary()` 和 `plot()` 是最普遍的泛型函数。泛型函数是一个**接口**，因为用户不需要关心幕后发生的细节。'
- en: In R, a **method** is a specialized function that gets chosen by the generic
    function for a particular type of input. The method is the *implementation*. When
    the generic function chooses a particular method, this is called **method dispatch**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，**方法**是一个专门为特定类型的输入由泛型函数选择的函数。方法是实现。当泛型函数选择特定方法时，这被称为**方法调度**。
- en: If you look at the definition of a generic function, let’s take `plot()` for
    instance, it has a single line that calls `UseMethod()`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查看泛型函数的定义，以 `plot()` 为例，它包含一个调用 `UseMethod()` 的单行。
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`UseMethod()` performs method dispatch. Which methods can be dispatched to?
    To see that, use the `methods()` function.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseMethod()` 执行方法调度。可以调度哪些方法？要查看，请使用 `methods()` 函数。'
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All of these S3 class methods share the same naming convention. Their name has
    the generic function’s name as a prefix, then a dot (`.`), then the name of the
    class that they are specifically written to be used with.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些 S3 类方法都遵循相同的命名约定。它们的名称以泛型函数的名称为前缀，然后是一个点（`.`），然后是它们特别编写的用于的类的名称。
- en: R’s dot-notation is nothing like Python’s dot-notation! In R, functions do not
    *belong* to types/classes like they do in Python!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: R 的点符号与 Python 的点符号完全不同！在 R 中，函数不像 Python 那样属于类型/类！
- en: Method dispatch works by looking at the `class` attribute of an S3 object argument.
    An object in R may or may not have a set of [**attributes**](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Attributes),
    which are a collection of name/value pairs that give a particular object extra
    functionality. Regular `vector`s in R don’t have attributes (e.g. try running
    `attributes(1:3)`), but objects that are “embellished” versions of a `vector`
    might (e.g. run `attributes(factor(1:3))`). Attributes in R are similar to attributes
    in Python, but they are usually only used as “tags” to elicit some sort of behavior
    when the object is passed into a function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调度是通过查看 S3 对象参数的 `class` 属性来工作的。R 中的对象可能具有一组 [**属性**](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Attributes)，这些属性是一系列名称/值对，为特定对象提供额外的功能。R
    中的常规 `vector` 没有属性（例如，尝试运行 `attributes(1:3)`），但“装饰”过的 `vector` 版本可能会有（例如，运行 `attributes(factor(1:3))`）。R
    中的属性与 Python 中的属性类似，但它们通常仅用作“标签”，在对象传递给函数时引发某种行为。
- en: '`class()` will return misleading results if it’s called on an object that isn’t
    an S3 object. Make sure to check with `is.object()` first.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `class()` 在非 S3 对象上调用，它将返回误导性的结果。请确保首先使用 `is.object()` 进行检查。
- en: Also, these methods are not *encapsulated* inside a class definition like they
    are in Python, either. They just look like loose functions–the method definition
    for a particular class is not defined inside the class. These class methods can
    be defined just as ordinary functions, out on their own, in whatever file you
    think is appropriate to define functions in.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些方法也不像 Python 那样封装在类定义中。它们看起来就像松散的函数一样——特定类的方法定义不在类内部。这些类方法可以像普通函数一样定义，独立于任何你认为适合定义函数的文件。
- en: As an example, let’s try to `plot()` some specific objects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们尝试 `plot()` 一些特定的对象。
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![A Scatterplot Matrix](../Images/15cf78d6d3edd472464c98d6a5765c81.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![散点矩阵图](../Images/15cf78d6d3edd472464c98d6a5765c81.png)'
- en: 'Figure 14.1: A Scatterplot Matrix'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：散点矩阵
- en: Because `aDF` has its `class` set to `data.frame`, this causes `plot()` to try
    to find a `plot.data.frame()` method. If this method was not found, R would attempt
    to find/use a `plot.default()` method. If no default method existed, an error
    would be thrown.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `aDF` 的 `class` 被设置为 `data.frame`，这导致 `plot()` 尝试查找 `plot.data.frame()` 方法。如果找不到此方法，R
    将尝试查找/使用 `plot.default()` 方法。如果没有默认方法存在，将抛出错误。
- en: As another example, we can play around with objects created with the `ecdf()`
    function. This function computes an *empirical cumulative distribution function*,
    which takes a real number as an input, and outputs the proportion of observations
    that are less than or equal to that input[^(25)](#fn25).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，我们可以用`ecdf()`函数创建的对象来玩耍。这个函数计算一个*经验累积分布函数*，它接受一个实数作为输入，并输出小于或等于该输入的观测比例[^(25)](#fn25)。
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Plotting an Empirical Cumulative Distribution Function](../Images/8067f769a65a18f9e6d91ba1a89b614a.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![绘制经验累积分布函数](../Images/8067f769a65a18f9e6d91ba1a89b614a.png)'
- en: 'Figure 14.2: Plotting an Empirical Cumulative Distribution Function'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：绘制经验累积分布函数
- en: This is how *inheritance* works in S3\. The `ecdf` class inherits from the `stepfun`
    class, which in turn inherits from the `function` class. When you call `plot(myECDF)`,
    ultimately `plot.ecdf()` is used on this object. However, if `plot.ecdf()` did
    not exist, `plot.stepfun()` would be tried. S3 inheritance in R is much simpler
    than Python’s inheritance!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是S3中*继承*的工作方式。`ecdf`类继承自`stepfun`类，而`stepfun`类又继承自`function`类。当你调用`plot(myECDF)`时，最终会使用`plot.ecdf()`来处理这个对象。然而，如果`plot.ecdf()`不存在，则会尝试使用`plot.stepfun()`。R中的S3继承比Python的继承要简单得多！
- en: 14.2.3 Creating S3 objects
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.3 创建S3对象
- en: Creating an S3 object is very easy, and is a nice way to spruce up some bundled
    up object that you’re returning from a function, say. All you have to do is tag
    an object by changing its class attribute. Just assign a character `vector` to
    it!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建S3对象非常简单，并且是一种很好的方式来美化你从函数返回的捆绑对象，比如说。你只需要通过改变其类属性来标记对象！只需将一个字符`vector`分配给它！
- en: Here is an example of creating an object of `CoolClass`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是创建`CoolClass`对象的一个例子。
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`myThing` is now an instance of `CoolClass`, even though I never defined what
    a `CoolClass` was ahead of time! If you’re used to Python, this should seem very
    strange. Compared to Python, this approach is very flexible, but also, kind of
    dangerous, because you can change the `class`es of existing objects. You shouldn’t
    do that, but you could if you wanted to.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`myThing`现在是一个`CoolClass`的实例，尽管我事先从未定义过`CoolClass`是什么！如果你习惯了Python，这应该看起来非常奇怪。与Python相比，这种方法非常灵活，但同时也有些危险，因为你可以改变现有对象的`class`。你不应该这样做，但如果你愿意，你可以。'
- en: After you start creating your own S3 objects, you can write your own methods
    associated with these objects. That way, when a user of your code uses typical
    generic functions, such as `summary()`, on your S3 object, you can control what
    interesting things will happen to the user of your package. Here’s an example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始创建自己的S3对象之后，你可以为这些对象编写自己的方法。这样，当你的代码的用户在S3对象上使用典型的通用函数，如`summary()`时，你可以控制你的包用户会发生什么有趣的事情。这里有一个例子。
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `summary()` method I wrote for this class is the following.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这个类编写的`summary()`方法如下。
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When writing this, I kept the signature the same as `summary()`’s.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这个时，我保持了与`summary()`相同的签名。
- en: '14.2.4 S4 objects: The Big Picture'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.4 S4对象：整体图景
- en: S4 was developed after S3\. If you look at your search path (type `search()`),
    you will see `package:methods`. That’s where all the code you need to do S4 is.
    Here are the similarities and differences between S3 and S4.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: S4是在S3之后开发的。如果你查看你的搜索路径（输入`search()`），你会看到`package:methods`。那里有你做S4所需的所有代码。以下是S3和S4之间的相似之处和不同之处。
- en: They both use generic functions and methods work in the same way.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们都使用通用的函数和方法，工作方式相同。
- en: Unlike in S3, S4 classes allow you to use multiple dispatch, which means the
    generic function can dispatch on multiple arguments, instead of just the first
    argument.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与S3不同，S4类允许你使用多态，这意味着通用函数可以在多个参数上分发，而不仅仅是第一个参数。
- en: S4 class definitions are strict–they aren’t just name tags like in S3.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S4类的定义是严格的——它们不像S3那样只是名字标签。
- en: S4 inheritance feels more like Python’s. You can think of a base class object
    living inside a child class object.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S4继承感觉更像是Python的。你可以想象一个基类对象存在于子类对象内部。
- en: S4 classes can have default data members via `prototype`s.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S4类可以通过`prototype`s拥有默认数据成员。
- en: Much more information about S4 classes can be obtained by reading [Chapter 15
    in Hadley Wickham’s book.](https://adv-r.hadley.nz/s4.html)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读[Hadley Wickham的书中第15章](https://adv-r.hadley.nz/s4.html)可以获得更多关于S4类的信息。
- en: 14.2.5 Using S4 objects
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.5 使用S4对象
- en: One CRAN package that uses S4 is the [Matrix package.](https://cran.r-project.org/web/packages/Matrix/vignettes/Intro2Matrix.pdf)
    Here is a short and simple code example.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用S4的CRAN包是[Matrix包](https://cran.r-project.org/web/packages/Matrix/vignettes/Intro2Matrix.pdf)。下面是一个简短且简单的代码示例。
- en: S4 objects are also extremely popular in packages hosted on [Bioconductor](https://www.bioconductor.org/).
    Bioconductor is similar to CRAN, but its software has a much more specific focus
    on bioinformatics. To download packages from Bioconductor, you can check out the
    installation instructions provided [here](https://bioconductor.org/help/course-materials/2017/Zurich/S4-classes-and-methods.html).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: S4对象在[Bioconductor](https://www.bioconductor.org/)上托管的包中也非常受欢迎。Bioconductor类似于CRAN，但其软件在生物信息学方面有更具体的关注。要从Bioconductor下载包，您可以查看提供的安装说明[这里](https://bioconductor.org/help/course-materials/2017/Zurich/S4-classes-and-methods.html)。
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Inside an S4 object, data members are called **slots**, and they are accessed
    with the `@` operator (instead of the `$` operator). Objects can be tested if
    they are S4 with the function `isS4()`. Otherwise, they look and feel just like
    S3 objects.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在S4对象内部，数据成员被称为**插槽**，并且使用`@`运算符（而不是`$`运算符）进行访问。可以使用`isS4()`函数测试对象是否为S4。否则，它们看起来和感觉就像S3对象一样。
- en: 14.2.6 Creating S4 objects
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.6 创建S4对象
- en: 'Here are the key takeaways:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些关键要点：
- en: create a new S4 class with `setClass()`,
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`setClass()`创建一个新的S4类，
- en: create a new S4 object with `new()`,
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`new()`创建一个新的S4对象，
- en: S4 classes have a fixed amount of slots, a name, and a fixed inheritance structure.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S4类具有固定数量的插槽、一个名称和一个固定的继承结构。
- en: Let’s do an example that resembles the example we did in Python, where we defined
    a `RunningMean` class and a `RunningCI` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个类似于我们在Python中做的示例，其中我们定义了一个`RunningMean`类和一个`RunningCI`类。
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, unlike in S3 class’s, we actually have to define a class with `setClass()`.
    In the parlance of S4, `slots=` are a class’ data members, and `contains=` signals
    that one class inherits from another (even though “contains” kind of sounds like
    it’s suggesting *composition*).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，与S3类不同，我们实际上需要使用`setClass()`来定义一个类。在S4的术语中，`slots=`是一个类的数据成员，而`contains=`表示一个类继承自另一个类（尽管“contains”听起来像是在暗示*组合*）。
- en: New objects can be created with the `new()` function after this is accomplished.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些操作后，可以使用`new()`函数创建新对象。
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next we want to define an `update()` generic function that will work on objects
    of both types. This is what gives us *polymorphism* . The generic `update()` will
    call specialized methods for objects of class `RunningMean` and `RunningCI`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要定义一个适用于两种类型对象的`update()`泛型函数。这就是给我们带来*多态性*的原因。泛型`update()`将调用`RunningMean`和`RunningCI`类对象的专用方法。
- en: Recall that in the Python example, each class had its own update method. Here,
    we still have a specialized method for each class, but S4 methods don’t have to
    be defined inside the class definition, as we can see below.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在Python示例中，每个类都有自己的更新方法。在这里，我们仍然为每个类有一个专用方法，但S4方法不需要在类定义内部定义，如下所示。
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here’s a demonstration of using these two classes that mirrors the example in
    subsection [14.1.3](/an-introduction-to-object-oriented-programming#adding-inheritance)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用这两个类的演示，与子节[14.1.3](/an-introduction-to-object-oriented-programming#adding-inheritance)中的示例类似。
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This looks more *functional* (more information on functional programming is
    available in chapter [15](/an-introduction-to-functional-programming#an-introduction-to-functional-programming))
    than the Python example because the `update()` function does not change an object
    with a side effect. Instead, it takes the old object, changes it, returns the
    new object, and uses assignment to overwrite the object. The benefit of this approach
    is that the assignment operator (`<-`) signals to us that something is changing.
    However, there is more data copying involved, so the program is presumably slower
    than it needs to be.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python示例相比，这看起来更*函数式*（有关函数式编程的更多信息，请参阅第15章[15](/an-introduction-to-functional-programming#an-introduction-to-functional-programming)）。因为`update()`函数不会通过副作用改变一个对象。相反，它接受旧对象，对其进行更改，返回新对象，并使用赋值来覆盖对象。这种方法的优点是赋值运算符（`<-`）会向我们发出变化的信号。然而，涉及更多的数据复制，因此程序可能比所需的要慢。
- en: The big takeaway here is that S3 and S4 don’t feel like Python’s encapsulated
    OOP. If we wanted to write stateful programs, we might consider using Reference
    Classes, or R6 classes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最大的收获是S3和S4不像Python的封装面向对象。如果我们想编写有状态的程序，我们可能需要考虑使用引用类，或者R6类。
- en: '14.2.7 Reference Classes: The Big Picture'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.7 引用类：全景
- en: '[**Reference Classes**](https://www.rdocumentation.org/packages/methods/versions/3.6.2/topics/ReferenceClasses)
    are built on top of S4 classes, and were released in late 2010\. They feel very
    different from S3 and S4 classes, and they more closely resemble Python classes,
    because'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[**引用类**](https://www.rdocumentation.org/packages/methods/versions/3.6.2/topics/ReferenceClasses)建立在S4类之上，并于2010年底发布。它们与S3和S4类感觉非常不同，并且它们更接近Python类，因为'
- en: their method definitions are *encapsulated* inside class definitions like in
    Python, and
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们的方法定义被封装在类定义中，就像在Python中一样，并且
- en: the objects they construct are *mutable*.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们构建的对象是可变的。
- en: So it will feel much more like Python’s class system. Some might say using reference
    classes that will lead to code that is not very R-ish, but it can be useful for
    certain types of programs (e.g. long-running code, code that that performs many/high-dimensional/complicated
    simulations, or code that circumvents storing large data set in your computer’s
    memory all at once).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它将感觉更像是Python的类系统。有些人可能会说使用引用类会导致代码不太像R语言风格的代码，但它在某些类型的程序中可能很有用（例如，长时间运行的代码、执行许多/高维/复杂模拟的代码，或者绕过一次性将大量数据集存储在计算机内存中的代码）。
- en: 14.2.8 Creating Reference Classes
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.8 创建引用类
- en: Creating reference classes is done with the function `setRefClass`. I create
    a class called `RunningMean` that produces the same behavior as that in the previous
    example.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建引用类使用`setRefClass`函数。我创建了一个名为`RunningMean`的类，它产生与上一个示例相同的行为。
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This tells us a few things. First, data members are called *fields* now. Second,
    changing class variables is done with the `<<-`. We can use it just as before.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们一些事情。首先，数据成员现在被称为*字段*。其次，更改类变量使用`<<-`完成。我们可以像以前一样使用它。
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Compare how similar this code looks to the code in [14.1.2](/an-introduction-to-object-oriented-programming#a-first-example)!
    Note the paucity of assignment operators, and plenty of side effects.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 比较一下这段代码与[14.1.2](/an-introduction-to-object-oriented-programming#a-first-example)中的代码的相似性！注意赋值运算符的稀少，以及副作用的多。
- en: 14.2.9 Creating R6 Classes
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.9 创建R6类
- en: I quickly implement the above example as an R6 class. A more detailed introduction
    to R6 classes is provided in [the vignette from the package authors.](https://r6.r-lib.org/articles/Introduction.html)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我迅速将上述示例实现为一个R6类。R6类的更详细介绍可以在[包作者的vignette中找到。](https://r6.r-lib.org/articles/Introduction.html)
- en: 'You’ll notice the reappearance of the `self` keyword. R6 classes have a `self`
    keyword just like in Python. They are similar to reference classes, but there
    are a few differences:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到`self`关键字的再次出现。R6类有`self`关键字，就像在Python中一样。它们类似于引用类，但有一些区别：
- en: they have [better performance than reference classes](https://r6.r-lib.org/articles/Performance.html),
    and
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们比引用类有更好的性能，并且
- en: they don’t make use of the `<<-` operator.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们没有使用`<<-`运算符。
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 14.3 Exercises
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 练习
- en: 14.3.1 Python Questions
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.1 Python问题
- en: If you are interested in estimating a linear regression model, there is a [`LinearRegression`
    class](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html)
    that you might consider using in the `sklearn.linear_model` submodule. In this
    lab, we will create something similar, but a little more simplified.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣于估计线性回归模型，你可以考虑在`sklearn.linear_model`子模块中使用一个名为`LinearRegression`的类。在这个实验中，我们将创建类似的东西，但稍微简化一些。
- en: 'A simple linear regression model will take in \(n\) independent variables \(x_1,
    \ldots, x_n\), and \(n\) dependent variables \(y_1, \ldots, y_n\), and try to
    describe their relationship with a function: \[\begin{equation} y_i = \beta_0
    + \beta_1 x_i + \epsilon_i. \end{equation}\] The coefficients \(\beta_0\) and
    \(\beta_1\) are unknown, and so must be estimated with the data. Estimating the
    variance of the noise terms \(\epsilon_i\) may also be of interest, but we do
    not concern ourselves with that here.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的线性回归模型将接受\(n\)个独立变量\(x_1, \ldots, x_n\)和\(n\)个因变量\(y_1, \ldots, y_n\)，并尝试用函数描述它们之间的关系：\[\begin{equation}
    y_i = \beta_0 + \beta_1 x_i + \epsilon_i. \end{equation}\] 系数\(\beta_0\)和\(\beta_1\)是未知的，因此必须用数据估计。估计噪声项\(\epsilon_i\)的方差也可能很有兴趣，但在这里我们不关心这一点。
- en: 'The formulas for the estimated slope (i.e. \(\hat{\beta}_1\)) and the estimated
    intercept (i.e. \(\hat{\beta}_0\)) are as follows: \[\begin{equation} \hat{\beta}_1
    = \frac{\sum_{i=1}^n (x_i - \bar{x})(y_i-\bar{y)}}{\sum_{j=1}^n (x_j - \bar{x})^2}
    \end{equation}\]'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 估计斜率（即 \(\hat{\beta}_1\)）和估计截距（即 \(\hat{\beta}_0\)）的公式如下： \[\begin{equation}
    \hat{\beta}_1 = \frac{\sum_{i=1}^n (x_i - \bar{x})(y_i-\bar{y)}}{\sum_{j=1}^n
    (x_j - \bar{x})^2} \end{equation}\]
- en: \[\begin{equation} \hat{\beta}_0 = \bar{y} - \hat{\beta}_1\bar{x}. \end{equation}\]
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} \hat{\beta}_0 = \bar{y} - \hat{\beta}_1\bar{x}. \end{equation}\]
- en: Create a class that performs simple linear regression.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个执行简单线性回归的类。
- en: Name it `SimpleLinReg`.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名为 `SimpleLinReg`。
- en: Its `.__init__()` method should not take any additional parameters. It should
    set two data attributes/members `est_intercept` and `est_slope`, to `np.nan`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的 `.__init__()` 方法不应该接受任何额外的参数。它应该设置两个数据属性/成员 `est_intercept` 和 `est_slope`，为
    `np.nan`。
- en: Give it a `.fit()` method that takes in two 1-dimensional Numpy arrays. The
    first should be the array of independent values, and the second should be the
    set of dependent values.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给它一个 `.fit()` 方法，它接受两个一维 Numpy 数组。第一个应该是独立值的数组，第二个应该是依赖值的集合。
- en: '`.fit(x,y)` should not `return` anything, but it should store two data attributes/members:
    `est_intercept` and `est_slope`. Every time `.fit()` is called, it will re-calculate
    the coefficient/parameter estimates.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.fit(x,y)` 不应该 `return` 任何内容，但它应该存储两个数据属性/成员：`est_intercept` 和 `est_slope`。每次调用
    `.fit()` 时，它将重新计算系数/参数估计。'
- en: Give it a `.get_coeffs()` method. It should not make any changes to the data
    attributes/members of the class. It should simply `return` a Numpy array with
    the parameter estimates inside. Make the first element the estimated intercept,
    and the second element the estimated slope. If no such coefficients have been
    estimated at the time of its calling, it should return the same size array but
    with the initial `np.nan`s inside.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给它一个 `.get_coeffs()` 方法。它不应该对类的数据属性/成员做出任何更改。它应该简单地 `return` 一个包含参数估计的 Numpy
    数组。第一个元素是估计的截距，第二个元素是估计的斜率。如果在调用时尚未估计出这样的系数，它应该返回相同大小的数组，但内部包含初始的 `np.nan`。
- en: 'After you’ve finished writing your first class, you can bask in the glory and
    run the following test code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成第一个类编写之后，你可以沉浸在这份荣耀之中，并运行以下测试代码：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Reconsider the above question that asked you to write a class called `SimpleLinReg`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 重新考虑上述问题，要求你编写一个名为 `SimpleLinReg` 的类。
- en: Write a new class called `LinearRegression2` that preserves all of the existing
    functionality of `SimpleLinReg`. Do this in a way that does not excessively copy
    and paste code from `SimpleLinReg`.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个新的类 `LinearRegression2`，保留 `SimpleLinReg` 的所有现有功能。以不大量复制粘贴 `SimpleLinReg`
    中的代码的方式完成此操作。
- en: Give your new class a method called `.visualize()` that takes no arguments and
    plots the most recent data, the data most recently provided to `.fit()`, in a
    scatterplot with the estimated regression line superimposed.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给你的新类添加一个名为 `.visualize()` 的方法，该方法不接受任何参数，并绘制最近的数据，即最近提供给 `.fit()` 的数据，在散点图上叠加估计的回归线。
- en: 'Unfortunately, `SimpleLinReg().fit(x,y).get_coeffs()` will not return estimated
    regression coefficients. Give your new class this functionality. In other words,
    make `LinearRegression2().fit(x,y).get_coeffs()` spit out regression coefficients.
    Hint: the solution should only require one extra line of code, and it should involve
    the `self` keyword.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不幸的是，`SimpleLinReg().fit(x,y).get_coeffs()` 不会返回估计的回归系数。给你的新类这个功能。换句话说，使 `LinearRegression2().fit(x,y).get_coeffs()`
    输出回归系数。提示：解决方案只需要一行额外的代码，并且应该涉及 `self` 关键字。
- en: Consider the following time series model (West and Harrison [1989](#ref-West1989BayesianFA))
    \[\begin{equation} y_t = \beta_t + \epsilon_t \\ \beta_t = \beta_{t-1} + w_t \\
    \beta_1 = w_1 \end{equation}\] Here \(y_t\) is observed time series data, each
    \(\epsilon_t\) is measurement noise with variance \(V\) and each \(w_t\) is also
    noise but with variance \(W\). Think of \(\beta_t\) as a time-varying regression
    coefficient.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下时间序列模型（West 和 Harrison [1989](#ref-West1989BayesianFA)） \[\begin{equation}
    y_t = \beta_t + \epsilon_t \\ \beta_t = \beta_{t-1} + w_t \\ \beta_1 = w_1 \end{equation}\]
    这里 \(y_t\) 是观察到的时序数据，每个 \(\epsilon_t\) 是测量噪声，方差为 \(V\)，每个 \(w_t\) 也是噪声，但方差为 \(W\)。将
    \(\beta_t\) 视为时间变化的回归系数。
- en: Imagine our data are arriving sequentially. The **Kalman Filter** (Kalman [1960](#ref-kalman_filt))
    cite provides an “optimal” estimate of each \(\beta_t\) given all of the information
    we have up to time \(t\). What’s better is that the algorithm is recursive. Future
    estimates of \(\beta_t\) will be easy to calculate given our estimates of \(\beta_{t-1}\).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的数据是按顺序到达的。**卡尔曼滤波器**（Kalman [1960](#ref-kalman_filt)）提供了一种“最优”估计，给定我们到时间
    \(t\) 所有的信息，对每个 \(\beta_t\) 进行估计。更好的是，该算法是递归的。给定我们对 \(\beta_{t-1}\) 的估计，未来对 \(\beta_t\)
    的估计将很容易计算。
- en: Let’s call the mean of \(\beta_{t-1}\) (given all the information up to time
    \(t-1\)) \(m_{t-1}\), and the variance of \(\beta_{t-1}\) (given all the information
    up to time \(t-1\)) \(P_{t-1}\). Then the Kalman recursions for this particular
    model are
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称 \(\beta_{t-1}\) 的均值（给定到时间 \(t-1\) 的所有信息）为 \(m_{t-1}\)，以及 \(\beta_{t-1}\)
    的方差（给定到时间 \(t-1\) 的所有信息）为 \(P_{t-1}\)。那么，这个特定模型的卡尔曼递归为
- en: \[\begin{equation} M_t = M_{t-1} + \left(\frac{P_{t-1} + W}{P_{t-1} + W+V} \right)(y_t
    - M_{t-1}) \end{equation}\]
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} M_t = M_{t-1} + \left(\frac{P_{t-1} + W}{P_{t-1} + W+V} \right)(y_t
    - M_{t-1}) \end{equation}\]
- en: \[\begin{equation} P_t = \left(1 - \frac{P_{t-1} + W}{P_{t-1} + W+V} \right)(P_{t-1}
    + W) \end{equation}\] for \(t \ge 1\).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} P_t = \left(1 - \frac{P_{t-1} + W}{P_{t-1} + W+V} \right)(P_{t-1}
    + W) \end{equation}\] 对于 \(t \ge 1\)。
- en: Write a class called `TVIKalman` (TVI stands for time-varying intercept).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个名为 `TVIKalman` 的类（TVI代表时变截距）。
- en: 'Have `TVIKalman` take two floating points in to its `.__init__()` method in
    this order: `V` and `W`. These two numbers are positive, and are the variance
    parameters of the model. Store these two numbers. Also, store \(0\) and \(W+V\)
    as members/attributes called `filter_mean` and `filter_variance`, respectively.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TVIKalman` 的 `.__init__()` 方法中按此顺序接受两个浮点数：`V` 和 `W`。这两个数都是正数，是模型的方差参数。存储这两个数。此外，将
    `0` 和 `W+V` 分别存储为名为 `filter_mean` 和 `filter_variance` 的成员/属性。'
- en: 'Give `TVIKalman` another method: `.update(yt)`. This function should not return
    anything, but it should update the filtering distribution’s mean and variance
    numbers, `filter_mean` and `filter_variance`, given a new data point.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给 `TVIKalman` 添加另一个方法：`.update(yt)`。这个函数不应该返回任何内容，但它应该根据新的数据点更新滤波分布的均值和方差数值，即
    `filter_mean` 和 `filter_variance`。
- en: 'Give `TVIKalman` another method: `.get_confidence_interval()`. It should not
    take any arguments, and it should return a length two Numpy array. The ordered
    elements of that array should be \(M_t\) plus and minus two standard deviations–a
    standard deviation at time \(t\) is \(\sqrt{P_t}\).'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给 `TVIKalman` 添加另一个方法：`.get_confidence_interval()`。它不接受任何参数，并应返回一个长度为两的 Numpy
    数组。该数组的有序元素应该是 \(M_t\) 加上和减去两个标准差——时间 \(t\) 的标准差是 \(\sqrt{P_t}\)。
- en: 'Create a `DataFrame` called `results` with the three columns called `yt`, `lower`,
    and `upper`. The last two columns should be a sequence of confidence intervals
    given to you by the method you wrote. The first column should contain the following
    data: `[-1.7037539, -0.5966818, -0.7061919, -0.1226606, -0.5431923]`. Plot all
    three columns in a single line plot. Initialize your Kalman Filter object with
    both `V` and `W` set equal to \(.5\).'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `results` 的 `DataFrame`，包含三个列，分别命名为 `yt`、`lower` 和 `upper`。最后两列应该是你编写的方法给出的置信区间序列。第一列应包含以下数据：`[-1.7037539,
    -0.5966818, -0.7061919, -0.1226606, -0.5431923]`。将所有三列绘制在单行图中。使用 `V` 和 `W` 都设置为
    \(.5\) 的值初始化你的卡尔曼滤波器对象。
- en: 14.3.2 R Questions
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.2 R 问题
- en: 'Which of the following classes in R produce objects that are mutable? Select
    all that apply: S3, S4, reference classes, and R6.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个 R 类可以产生可变对象？选择所有适用的：S3、S4、引用类和 R6。
- en: 'Which of the following classes in R produce objects that can have methods?
    Select all that apply: S3, S4, reference classes, and R6.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个 R 类可以产生具有方法的对象？选择所有适用的：S3、S4、引用类和 R6。
- en: 'Which of the following classes in R produce objects that can store data? Select
    all that apply: S3, S4, reference classes, and R6.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个 R 类可以产生可以存储数据的对象？选择所有适用的：S3、S4、引用类和 R6。
- en: 'Which of the following classes in R have encapsulated definitions? Select all
    that apply: S3, S4, reference classes, and R6.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个 R 类具有封装定义？选择所有适用的：S3、S4、引用类和 R6。
- en: 'Which of the following classes in R have “slots”? Select all that apply: S3,
    S4, reference classes, and R6.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个 R 类具有“槽”？选择所有适用的：S3、S4、引用类和 R6。
- en: Which of the following class systems in R is the newest? S3, S4, reference classes,
    or R6?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个 R 类系统是最新的？S3、S4、引用类还是 R6？
- en: Which of the following class systems in R is the oldest? S3, S4, reference classes,
    or R6?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，以下哪个类系统是最古老的？S3、S4、引用类还是 R6？
- en: 'Which of the following classes in R requires you to `library()` in something?
    Select all that apply: S3, S4, reference classes, and R6.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，以下哪个类需要你在某处使用 `library()`？选择所有适用的：S3、S4、引用类和 R6。
- en: 'Suppose you have the following data set: \(X_1, \ldots, X_n\). You assume it
    is a random sample from a Normal distribution with unknown mean and variance parameters,
    denoted by \(\mu\) and \(\sigma^2\), respectively. Consider testing the null hypothesis
    that \(\mu = 0\) at a significance level of \(\alpha\). To carry out this test,
    you calculate \[\begin{equation} t = \frac{\bar{X}}{S/\sqrt{n}} \end{equation}\]
    and you reject the null hypothesis if \(|t| > t_{n-1,\alpha/2}\). This is **Student’s
    T-Test** (Student [1908](#ref-student1908probable)). Here \(S^2 = \sum_i(X_i -
    \bar{X})^2 / (n-1)\) is the sample variance, and \(t_{n-1,\alpha/2}\) is the \(1-\alpha/2\)
    quantile of a t-distribution with \(n-1\) degrees of freedom.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个以下数据集：\(X_1, \ldots, X_n\)。你假设它是一个来自具有未知均值和方差参数的正态分布的随机样本，分别用 \(\mu\)
    和 \(\sigma^2\) 表示。考虑在显著性水平 \(\alpha\) 下检验 \(\mu = 0\) 的零假设。为了进行这项测试，你计算 \[\begin{equation}
    t = \frac{\bar{X}}{S/\sqrt{n}} \end{equation}\] 并且如果 \(|t| > t_{n-1,\alpha/2}\)，则拒绝零假设。这是
    **Student 的 t 检验** (Student [1908](#ref-student1908probable))。这里 \(S^2 = \sum_i(X_i
    - \bar{X})^2 / (n-1)\) 是样本方差，而 \(t_{n-1,\alpha/2}\) 是具有 \(n-1\) 个自由度的 t 分布的 \(1-\alpha/2\)
    分位数。
- en: 'Write a function called `doTTest()` that performs the above hypothesis test.
    It should accept two parameters: `dataVec` (a `vector` of data) and `significanceLevel`
    (which is \(\alpha\)). Have the second parameter default to `.05`.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个名为 `doTTest()` 的函数，该函数执行上述假设测试。它应接受两个参数：`dataVec`（数据向量）和 `significanceLevel`（这是
    \(\alpha\)）。第二个参数默认为 `.05`。
- en: Have it return an S3 object created from a `list`. The `class` of this `list`
    should be `"TwoSidedTTest"`. The elements in the `list` should be named `decision`
    and `testStat`. The `decision` object should be either `"reject"` or `"fail to
    reject"`. The test stat should be equal to the calculation you made above for
    \(t\).
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让它返回一个由 `list` 创建的 S3 对象。这个 `list` 的 `class` 应该是 `"TwoSidedTTest"`。`list` 中的元素应该命名为
    `decision` 和 `testStat`。`decision` 对象应该是 `"reject"` 或 `"fail to reject"`。测试统计量应该等于你上面计算的
    \(t\) 值。
- en: 'Create a `summary` method for this new class you created: `TwoSidedTTest`.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你创建的新类 `TwoSidedTTest` 创建一个 `summary` 方法。
- en: Suppose you have a target density \(p(x)\) that you are only able to evaluate
    up to a normalizing constant. In other words, suppose that for some \(c > 0\),
    \(p(x) = f(x) / c\), and you are only able to evaluate \(f(\cdot)\). Your goal
    is that you would like to be able to approximate the expected value of \(p(x)\)
    (i.e. \(\int x p(x) dx\)) using some proposal distribution \(q(x)\). \(q(x)\)
    is flexible in that you can sample from it, and you can evaluate it. We will use
    **importance sampling** (H. Kahn [1950](#ref-impsamping1)) (H Kahn [1950](#ref-impsamping2))
    to achieve this.[^(26)](#fn26)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个目标密度 \(p(x)\)，你只能评估到归一化常数。换句话说，假设对于某个 \(c > 0\)，\(p(x) = f(x) / c\)，而你只能评估
    \(f(\cdot)\)。你的目标是能够使用某个建议分布 \(q(x)\) 近似 \(p(x)\) 的期望值（即 \(\int x p(x) dx\)）。\(q(x)\)
    是灵活的，因为你可以从中采样，并且可以评估它。我们将使用 **重要性抽样** (H. Kahn [1950](#ref-impsamping1)) (H Kahn
    [1950](#ref-impsamping2)) 来实现这一点。[^(26)](#fn26)
- en: '**Algorithm 1**: Importance Sampling i) Sample \(X^1, \ldots, X^n\) from \(q(x)\),
    ii. For each sample \(x^i\), calculate an unnormalized weight \(\tilde{w}^i:=
    \frac{f(x^i)}{q(x^i)}\), iii. Calculate the normalized weights \(w^i = \tilde{w}^i
    \bigg/ \sum_j \tilde{w}^j\). iv. Calculate the weighted average \(\sum_{i=1}^n
    w^i x^i\).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法 1**: 重要性抽样 i) 从 \(q(x)\) 中采样 \(X^1, \ldots, X^n\)，ii. 对于每个样本 \(x^i\)，计算未归一化权重
    \(\tilde{w}^i:= \frac{f(x^i)}{q(x^i)}\)，iii. 计算归一化权重 \(w^i = \tilde{w}^i \bigg/
    \sum_j \tilde{w}^j\)。iv. 计算加权平均值 \(\sum_{i=1}^n w^i x^i\)。'
- en: In practice it is beneficial to use log-densities, because it will avoid underflow
    issues. After you evaluate each \(\log \tilde{w}^i\), before you exponentiate
    them, subtract a number \(m\) from all the values. A good choice for \(m\) is
    \(\max_i (\log \tilde{w}^i)\). These new values will produce the same normalized
    weights because
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，使用对数密度是有益的，因为它将避免下溢问题。在你评估每个 \(\log \tilde{w}^i\) 之后，在你对它们进行指数化之前，从所有值中减去一个数字
    \(m\)。\(m\) 的一个好选择是 \(\max_i (\log \tilde{w}^i)\)。这些新值将产生相同的归一化权重，因为
- en: \[\begin{equation} w^i = \exp[ \log \tilde{w}^i - m] \bigg/ \sum_j \exp[\log
    \tilde{w}^j - m]. \end{equation}\]
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} w^i = \exp[ \log \tilde{w}^i - m] \bigg/ \sum_j \exp[\log
    \tilde{w}^j - m]. \end{equation}\]
- en: Create an R6 class called `ImpSamp` that performs importance sampling.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ImpSamp` 的 R6 类，用于执行重要性采样。
- en: It should store function data values `qSamp`, `logQEval`, and `logFEval`.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该存储函数数据值 `qSamp`、`logQEval` 和 `logFEval`。
- en: 'Give it an `initialize()` method that takes in three arguments: `logFEvalFunc`,
    `qSampFunc` and `logQEvalFunc`.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给它一个 `initialize()` 方法，该方法接受三个参数：`logFEvalFunc`、`qSampFunc` 和 `logQEvalFunc`。
- en: '`initialize()` will set the stored function values equal to the function objects
    passed in.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize()` 方法将存储的函数值设置为传入的函数对象。'
- en: The functions performing random sampling should only take a single argument
    referring to the number of samples desired.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行随机采样的函数应仅接受一个参数，表示所需的样本数。
- en: The evaluation functions should take a `vector` as an input and return a `vector`
    as an output.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估函数应该接受一个 `vector` 作为输入，并返回一个 `vector` 作为输出。
- en: Write a method called `computeApproxExpec` that computes and returns the importance
    sampling estimate of \(\int x p(x) dx\). Have this method take an integer argument
    that represents the number of desired samples to use for the computation.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个名为 `computeApproxExpec` 的方法，该方法计算并返回 \(\int x p(x) dx\) 的重要性采样估计。此方法应接受一个整数参数，表示用于计算的所需样本数。
- en: Is it better to make this code object-oriented, or would you prefer a simple
    function that spits out the answer? Why?
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是将此代码设计为面向对象更好，还是你更倾向于一个简单的输出答案的函数？为什么？
- en: References
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Brown, Taylor. 2021\. *CPseudoMaRg: Constructs a Correlated Pseudo-Marginal
    Sampler*. [https://CRAN.R-project.org/package=cPseudoMaRg](https://CRAN.R-project.org/package=cPseudoMaRg).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 'Brown, Taylor. 2021. *CPseudoMaRg: Constructs a Correlated Pseudo-Marginal
    Sampler*. [https://CRAN.R-project.org/package=cPseudoMaRg](https://CRAN.R-project.org/package=cPseudoMaRg).'
- en: 'Grolemund, G. 2014\. *Hands-on Programming with R: Write Your Own Functions
    and Simulations*. O’Reilly Media. [https://books.google.com/books?id=S04BBAAAQBAJ](https://books.google.com/books?id=S04BBAAAQBAJ).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Grolemund, G. 2014. *动手编程 R：编写自己的函数和模拟*. O’Reilly Media. [https://books.google.com/books?id=S04BBAAAQBAJ](https://books.google.com/books?id=S04BBAAAQBAJ).
- en: Kahn, H. 1950\. “Random Sampling (Monte Carlo) Techniques in Neutron Attenuation
    Problems–I.” *Nucleonics* 6 5.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Kahn, H. 1950. “中子衰减问题中的随机采样（蒙特卡洛）技术–I.” *Nucleonics* 6 5.
- en: 'Kahn, H. 1950\. “Random Sampling (Monte Carlo) Techniques in Neutron Attenuation
    Problems. II.” *Nucleonics (U.S.) Ceased Publication* Vol: 6, No. 6 (June). [https://www.osti.gov/biblio/4399718](https://www.osti.gov/biblio/4399718).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'Kahn, H. 1950. “中子衰减问题中的随机采样（蒙特卡洛）技术–II.” *Nucleonics (U.S.) Ceased Publication*
    Vol: 6, No. 6 (June). [https://www.osti.gov/biblio/4399718](https://www.osti.gov/biblio/4399718).'
- en: 'Kalman, R. E. 1960\. “A New Approach to Linear Filtering and Prediction Problems.”
    *Journal of Basic Engineering* 82 (1): 35–45\. [https://doi.org/10.1115/1.3662552](https://doi.org/10.1115/1.3662552).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'Kalman, R. E. 1960. “一种新的线性滤波和预测问题方法.” *Journal of Basic Engineering* 82 (1):
    35–45\. [https://doi.org/10.1115/1.3662552](https://doi.org/10.1115/1.3662552).'
- en: Student. 1908\. “The Probable Error of a Mean.” *Biometrika*, 1–25.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 学生. 1908. “平均数的可能误差.” *Biometrika*, 1–25.
- en: West, Michael A., and Jeff Harrison. 1989\. “Bayesian Forecasting and Dynamic
    Models.” In.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: West, Michael A. 和 Jeff Harrison. 1989. “贝叶斯预测和动态模型.” In.
- en: Wickham, H. 2014\. *Advanced R*. Chapman & Hall/Crc the R Series. Taylor & Francis.
    [https://books.google.com/books?id=PFHFNAEACAAJ](https://books.google.com/books?id=PFHFNAEACAAJ).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Wickham, H. 2014. *高级 R*. Chapman & Hall/Crc the R Series. Taylor & Francis.
    [https://books.google.com/books?id=PFHFNAEACAAJ](https://books.google.com/books?id=PFHFNAEACAAJ).
- en: '* * *'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Just because you can do this, doesn’t mean you *should*, though![↩](/an-introduction-to-object-oriented-programming#fnref23)
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然你可以这样做，但这并不意味着你应该这样做![↩](/an-introduction-to-object-oriented-programming#fnref23)
- en: Otherwise known as an independent and identically distributed sample[↩](/an-introduction-to-object-oriented-programming#fnref24)
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也称为独立同分布样本[↩](/an-introduction-to-object-oriented-programming#fnref24)
- en: It’s defined as \(\hat{F}(x) = \frac{1}{n}\sum_{i=1}^n \mathbf{1}(X_i \le x)\).[↩](/an-introduction-to-object-oriented-programming#fnref25)
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它被定义为 \(\hat{F}(x) = \frac{1}{n}\sum_{i=1}^n \mathbf{1}(X_i \le x)\)。[↩](/an-introduction-to-object-oriented-programming#fnref25)
- en: Note that this is a similar setup to the accept-reject sampling problem we had
    earlier, and this algorithm is closely-related with the Monte Carlo algorithm
    we used in the exercises of chapter 3.[↩](/an-introduction-to-object-oriented-programming#fnref26)
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，这与我们之前遇到的接受-拒绝采样问题类似，并且这个算法与我们在第3章练习中使用的蒙特卡洛算法密切相关。[↩](/an-introduction-to-object-oriented-programming#fnref26)
