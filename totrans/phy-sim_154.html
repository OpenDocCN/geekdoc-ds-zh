<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Particle-In-Cell Transfer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Particle-In-Cell Transfer</h1>
<blockquote>原文：<a href="https://phys-sim-book.github.io/lec29.2-pic_transfer.html">https://phys-sim-book.github.io/lec29.2-pic_transfer.html</a></blockquote>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"/>

<p>At the beginning of each simulation step, the grid must be cleared before accumulating new particle-to-grid transfers.</p>
<p><a name="imp:lec29:reset_grid"/>
<strong>Implementation 30.2.1 (Reset Grid, simulator.py).</strong></p>
<pre><code class="language-python">def reset_grid():
    # after each transfer, the grid is reset
    grid_m.fill(0)
    grid_v.fill(0)
</code></pre>
<p>We adopt the Saint Venant–Kirchhoff (StVK) constitutive model formulated in the logarithmic (Hencky) strain space using the SVD of the deformation gradient.</p>
<p><a name="imp:lec29:stvk"/>
<strong>Implementation 30.2.2 (Stvk Hencky Elasticity, simulator.py).</strong></p>
<pre><code class="language-python">@ti.func
def StVK_Hencky_PK1_2D(F):
    U, sig, V = ti.svd(F)
    inv_sig = sig.inverse()
    e = ti.Matrix([[ti.log(sig[0, 0]), 0], [0, ti.log(sig[1, 1])]])
    return U @ (2 * mu * inv_sig @ e + lam * e.trace() * inv_sig) @ V.transpose()
</code></pre>
<p>During the particle-to-grid (P2G) transfer, we use quadratic B-spline interpolation to distribute each particle’s mass, momentum, and internal force to its neighboring grid nodes. This process follows the PIC (Particle-In-Cell) formulation, where particle velocities are directly transferred to the grid without storing affine velocity fields.</p>
<p><a name="imp:lec29:p2g"/>
<strong>Implementation 30.2.3 (PIC Particle-to-Grid (P2G) Transfers, simulator.py).</strong></p>
<pre><code class="language-python">@ti.kernel
def particle_to_grid_transfer():
    for p in range(N_particles):
        base = (x[p] / dx - 0.5).cast(int)
        fx = x[p] / dx - base.cast(float)
        # quadratic B-spline interpolating functions (Section 26.2)
        w = [0.5 * (1.5 - fx) ** 2, 0.75 - (fx - 1) ** 2, 0.5 * (fx - 0.5) ** 2]
        # gradient of the interpolating function (Section 26.2)
        dw_dx = [fx - 1.5, 2 * (1.0 - fx), fx - 0.5]

        P = StVK_Hencky_PK1_2D(F[p])
        for i in ti.static(range(3)):
            for j in ti.static(range(3)):
                offset = ti.Vector([i, j])
                weight = w[i][0] * w[j][1]
                grad_weight = ti.Vector([(1. / dx) * dw_dx[i][0] * w[j][1], 
                                          w[i][0] * (1. / dx) * dw_dx[j][1]])

                grid_m[base + offset] += weight * m[p] # mass transfer
                grid_v[base + offset] += weight * m[p] * v[p] # momentum Transfer, PIC formulation
                # internal force (stress) transfer
                fi = -vol[p] * P @ F[p].transpose() @ grad_weight
                grid_v[base + offset] += dt * fi
</code></pre>
<p>Right after Particle-to-Grid (P2G) Transfer, we normalize grid momentum to obtain nodal velocities and enforces Dirichlet boundary conditions near the domain edges by zeroing out velocities.</p>
<p><a name="imp:lec29:grid_update"/>
<strong>Implementation 30.2.4 (Grid Update, simulator.py).</strong></p>
<pre><code class="language-python">@ti.kernel
def update_grid():
    for i, j in grid_m:
        if grid_m[i, j] &gt; 0:
            grid_v[i, j] = grid_v[i, j] / grid_m[i, j] # extract updated nodal velocity from transferred nodal momentum

            # Dirichlet BC near the bounding box
            if i &lt;= 3 or i &gt; grid_size - 3 or j &lt;= 2 or j &gt; grid_size - 3:
                grid_v[i, j] = 0
</code></pre>
<p>During the grid-to-particle (G2P) transfer, we gather the updated velocity from the background grid and compute the elastic deformation gradient update using the velocity gradient derived from the interpolation function.</p>
<p><a name="imp:lec29:g2p"/>
<strong>Implementation 30.2.5 (PIC Grid-to-Particle (G2P) Transfers, simulator.py).</strong></p>
<pre><code class="language-python">@ti.kernel
def grid_to_particle_transfer():
    for p in range(N_particles):
        base = (x[p] / dx - 0.5).cast(int)
        fx = x[p] / dx - base.cast(float)
        # quadratic B-spline interpolating functions (Section 26.2)
        w = [0.5 * (1.5 - fx) ** 2, 0.75 - (fx - 1) ** 2, 0.5 * (fx - 0.5) ** 2]
        # gradient of the interpolating function (Section 26.2)
        dw_dx = [fx - 1.5, 2 * (1.0 - fx), fx - 0.5]

        new_v = ti.Vector.zero(float, 2)
        v_grad_wT = ti.Matrix.zero(float, 2, 2)
        for i in ti.static(range(3)):
            for j in ti.static(range(3)):
                offset = ti.Vector([i, j])
                weight = w[i][0] * w[j][1]
                grad_weight = ti.Vector([(1. / dx) * dw_dx[i][0] * w[j][1], 
                                          w[i][0] * (1. / dx) * dw_dx[j][1]])

                new_v += weight * grid_v[base + offset]
                v_grad_wT += grid_v[base + offset].outer_product(grad_weight)

        v[p] = new_v
        F[p] = (ti.Matrix.identity(float, 2) + dt * v_grad_wT) @ F[p]
</code></pre>
<p>Finally, particle positions are updated through advection using symplectic Euler time integration.</p>
<p><a name="imp:lec29:particle_update"/>
<strong>Implementation 30.2.6 (Particle State Update, simulator.py).</strong></p>
<pre><code class="language-python">@ti.kernel
def update_particle_state():
    for p in range(N_particles):
        x[p] += dt * v[p] # advection
</code></pre>
<p>A full MPM simulation step consists of the following stages:</p>
<p><a name="imp:lec29:time_step"/>
<strong>Implementation 30.2.7 (A full time step of MPM, simulator.py).</strong></p>
<pre><code class="language-python">def step():
    # a single time step of the Material Point Method (MPM) simulation
    reset_grid()
    particle_to_grid_transfer()
    update_grid()
    grid_to_particle_transfer()
    update_particle_state()
</code></pre>
<figure>
    <center>
    <img src="../Images/1bcb904b717ed3313178f48f22cea71e.png" data-original-src="https://phys-sim-book.github.io/img/lec29/mpm_elastic_blocks_simulation_result.png"/>
    </center>
    <figcaption><b><a name="fig:lec29:mpm_elastic_blocks_simulation_result"/>
Figure 30.2.1.</b> <b>Time sequence of two colliding elastic blocks in 2D</b>. The red and blue blocks approach each other with opposite velocities, undergo large elastic deformation upon impact, and rebound with shape recovery. The simulation demonstrates symmetric momentum exchange and elastic energy storage under the MPM framework. </figcaption>
</figure>
                        
</body>
</html>