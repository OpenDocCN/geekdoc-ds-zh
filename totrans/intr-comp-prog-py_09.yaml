- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: TESTING AND DEBUGGING
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和调试
- en: We hate to bring this up, but Dr. Pangloss[^(49)](#c8-fn-0001) was wrong. We
    do not live in “the best of all possible worlds.” There are some places where
    it rains too little, and others where it rains too much. Some places are too cold,
    some too hot, and some too hot in the summer and too cold in the winter. Sometimes
    the stock market goes down—a lot. Sometimes cheaters do win (see Houston Astros).
    And, annoyingly, our programs don't always function properly the first time we
    run them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想提起这一点，但庞格洛斯博士[^(49)](#c8-fn-0001)错了。我们并不生活在“所有可能世界中最好的世界”里。有些地方降雨太少，有些地方降雨太多。有些地方太冷，有些地方太热，有些地方夏天太热而冬天太冷。有时股市大幅下跌。有时作弊者会赢（参见休斯顿太空人队）。而且令人恼火的是，我们的程序并不总是在第一次运行时就正常工作。
- en: Books have been written about how to deal with this last problem, and there
    is a lot to be learned from reading these books. However, in the interest of providing
    you with some hints that might help you complete that next problem set on time,
    this chapter provides a highly condensed discussion of the topic. While all of
    the programming examples are in Python, the general principles apply to getting
    any complex system to work.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何处理最后一个问题已经有书籍问世，从这些书中有很多可以学习的东西。然而，为了给你提供一些可能帮助你按时完成下一个问题集的提示，本章提供了这一主题的高度浓缩讨论。虽然所有的编程示例都是用Python写的，但一般原则适用于让任何复杂系统正常工作。
- en: '**Testing** is the process of running a program to try and ascertain whether
    it works as intended. **Debugging** is the process of trying to fix a program
    that you already know does not work as intended.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试**是运行程序以试图确定其是否按预期工作的过程。**调试**是尝试修复一个你已经知道不按预期工作的程序的过程。'
- en: Testing and debugging are not processes that you should begin to think about
    after a program has been built. Good programmers design their programs in ways
    that make them easier to test and debug. The key to doing this is breaking the
    program into separate components that can be implemented, tested, and debugged
    independently of other components. At this point in the book, we have discussed
    only one mechanism for modularizing programs, the function. So, for now, all of
    our examples will be based around functions. When we get to other mechanisms,
    in particular classes, we will return to some of the topics covered in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和调试并不是你在程序构建后才应该考虑的过程。优秀的程序员以更容易进行测试和调试的方式设计他们的程序。做到这一点的关键是将程序拆分成可以独立实现、测试和调试的组件。在本书的这一点上，我们只讨论了一种模块化程序的机制，即函数。因此，目前为止，我们的所有示例将围绕函数进行。当我们涉及其他机制，特别是类时，我们会回到本章讨论的一些主题。
- en: The first step in getting a program to work is getting the language system to
    agree to run it—that is, eliminating syntax errors and static semantic errors
    that can be detected without running the program. If you haven't gotten past that
    point in your programming, you're not ready for this chapter. Spend a bit more
    time working on small programs, and then come back.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使程序正常工作的第一步是让语言系统同意运行它——也就是说，消除那些在不运行程序的情况下就能检测到的语法错误和静态语义错误。如果你在编程中还没有过这一关，那你还不准备好进入本章。多花点时间做一些小程序，然后再回来。
- en: 8.1 Testing
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 测试
- en: The purpose of testing is to show that bugs exist, not to show that a program
    is bug-free. To quote Edsger Dijkstra, “Program testing can be used to show the
    presence of bugs, but never to show their absence!” [^(50)](#c8-fn-0002) Or, as
    Albert Einstein reputedly said, “No amount of experimentation can ever prove me
    right; a single experiment can prove me wrong.”
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的目的是显示存在错误，而不是证明程序没有错误。引用艾兹格·迪杰斯特拉的话：“程序测试可以用来显示错误的存在，但永远不能证明它们的缺失！” [^(50)](#c8-fn-0002)
    或者，正如阿尔伯特·爱因斯坦所说：“任何实验都无法证明我正确；一个实验可以证明我错误。”
- en: Why is this so? Even the simplest of programs has billions of possible inputs.
    Consider, for example, a program that purports to meet the specification
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会这样？即使是最简单的程序也有数十亿种可能的输入。比如，考虑一个声称满足规格的程序。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Running it on all pairs of integers would be, to say the least, tedious. The
    best we can do is to run it on pairs of integers that have a reasonable probability
    of producing the wrong answer if there is a bug in the program.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有整数对上运行它，至少可以说是乏味的。我们能做的最好是对那些在程序中存在错误的情况下，有合理概率产生错误答案的整数对进行测试。
- en: The key to testing is finding a collection of inputs, called a **test suite**,
    that has a high likelihood of revealing bugs, yet does not take too long to run.
    The key to doing this is partitioning the space of all possible inputs into subsets
    that provide equivalent information about the correctness of the program, and
    then constructing a test suite that contains at least one input from each partition.
    (Usually, constructing such a test suite is not actually possible. Think of this
    as an unachievable ideal.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的关键在于找到一个输入集合，称为**测试套件（test suite）**，它有较高的可能性揭示缺陷，但运行时间不应过长。做到这一点的关键是将所有可能输入的空间划分为提供关于程序正确性的等效信息的子集，然后构建一个包含每个划分至少一个输入的测试套件。（通常，构建这样的测试套件实际上是不可能的。可以将其视为一个不可实现的理想。）
- en: 'A **partition** of a set divides that set into a collection of subsets such
    that each element of the original set belongs to exactly one of the subsets. Consider,
    for example, `is_smaller(x, y)`. The set of possible inputs is all pairwise combinations
    of integers. One way to partition this set is into these nine subsets:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个集合的**划分**将该集合分为一组子集，使得原集合的每个元素正好属于一个子集。例如，考虑`is_smaller(x, y)`。可能输入的集合是所有整数的成对组合。划分这个集合的一种方式是将其分为九个子集：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we tested the implementation on at least one value from each of these subsets,
    we would have a good chance (but no guarantee) of exposing a bug if one exists.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这些子集的每个值上测试实现，如果存在缺陷，我们有很好的机会（但没有保证）暴露出该缺陷。
- en: For most programs, finding a good partitioning of the inputs is far easier said
    than done. Typically, people rely on heuristics based on exploring different paths
    through some combination of the code and the specifications. Heuristics based
    on exploring paths through the code fall into a class called **glass-box** (or
    **white-box**) **testing**. Heuristics based on exploring paths through the specification
    fall into a class called **black-box testing**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数程序，找到良好的输入划分远比说起来容易。通常，人们依赖于基于探索代码和规范某种组合的不同路径的启发式方法。基于通过代码探索路径的启发式方法属于**透明盒（glass-box）**（或**白盒（white-box）**）**测试**类。基于通过规范探索路径的启发式方法属于**黑盒测试（black-box
    testing）**类。
- en: 8.1.1 Black-Box Testing
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 黑盒测试
- en: In principle, black-box tests are constructed without looking at the code to
    be tested. Black-box testing allows testers and implementers to be drawn from
    separate populations. When those of us who teach programming courses generate
    test cases for the problem sets we assign students, we are developing black-box
    test suites. Developers of commercial software often have quality assurance groups
    that are largely independent of development groups. They too develop black-box
    test suites.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，黑盒测试是在不查看要测试代码的情况下构建的。黑盒测试允许测试人员和实现人员来自不同的群体。当我们这些教授编程课程的人为分配给学生的问题集生成测试用例时，我们正在开发黑盒测试套件。商业软件的开发者通常拥有与开发组基本独立的质量保证组。他们也会开发黑盒测试套件。
- en: This independence reduces the likelihood of generating test suites that exhibit
    mistakes that are correlated with mistakes in the code. Suppose, for example,
    that the author of a program made the implicit, but invalid, assumption that a
    function would never be called with a negative number. If the same person constructed
    the test suite for the program, he would likely repeat the mistake, and not test
    the function with a negative argument.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种独立性降低了生成测试套件时错误与代码中错误相关联的可能性。例如，假设程序的作者做出了隐含但无效的假设，即一个函数永远不会被负数调用。如果同一个人构建了程序的测试套件，他很可能会重复这个错误，而不测试负参数的函数。
- en: Another positive feature of black-box testing is that it is robust with respect
    to implementation changes. Since the test data is generated without knowledge
    of the implementation, the tests need not be changed when the implementation is
    changed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试的另一个积极特征是它对实现变化的鲁棒性。由于测试数据是在不知实现的情况下生成的，因此实现变更时测试无需更改。
- en: As we said earlier, a good way to generate black-box test data is to explore
    paths through a specification. Consider, the specification
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，生成黑盒测试数据的一个好方法是通过规范探索路径。考虑这个规范。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There seem to be only two distinct paths through this specification: one corresponding
    to `x = 0` and one corresponding to `x > 0`. However, common sense tells us that
    while it is necessary to test these two cases, it is hardly sufficient.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个规范中似乎只有两条不同的路径：一条对应于`x = 0`，另一条对应于`x > 0`。然而，常识告诉我们，虽然必须测试这两种情况，但这远远不够。
- en: Boundary conditions should also be tested. Looking at an argument of type list
    often means looking at the empty list, a list with exactly one element, a list
    with immutable elements, a list with mutable elements, and a list containing lists.
    When dealing with numbers, it typically means looking at very small and very large
    values as well as “typical” values. For `sqrt`, for example, it might make sense
    to try values of `x` and `epsilon` similar to those in [Figure 8-1](#c8-fig-0001).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 边界条件也应进行测试。查看类型为列表的参数通常意味着查看空列表、只有一个元素的列表、不可变元素的列表、可变元素的列表，以及包含列表的列表。处理数字时，通常意味着查看非常小和非常大的值以及“典型”值。例如，对于`sqrt`，尝试值`x`和`epsilon`与[图
    8-1](#c8-fig-0001)中的值相似可能是有意义的。
- en: '![c8-fig-0001.jpg](../images/c8-fig-0001.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![c8-fig-0001.jpg](../images/c8-fig-0001.jpg)'
- en: '[Figure 8-1](#c8-fig-0001a) Testing boundary conditions'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-1](#c8-fig-0001a) 测试边界条件'
- en: The first four rows are intended to represent typical cases. Notice that the
    values for `x` include a perfect square, a number less than one, and a number
    with an irrational square root. If any of these tests fail, there is a bug in
    the program that needs to be fixed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前四行旨在表示典型案例。注意，`x`的值包括一个完全平方数、一个小于一的数和一个具有无理平方根的数。如果这些测试中的任何一个失败，则程序中存在需要修复的错误。
- en: The remaining rows test extremely large and small values of `x` and `epsilon`.
    If any of these tests fail, something needs to be fixed. Perhaps there is a bug
    in the code that needs to be fixed, or perhaps the specification needs to be changed
    so that it is easier to meet. It might, for example, be unreasonable to expect
    to find an approximation of a square root when `epsilon` is ridiculously small.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的行测试`x`和`epsilon`的极大和极小值。如果这些测试中的任何一个失败，就需要修复某些内容。可能代码中存在一个需要修复的错误，或者可能需要更改规范，以便更容易满足。例如，期望在`epsilon`极小的情况下找到平方根的近似值可能是不合理的。
- en: Another important boundary condition to think about is aliasing. Consider the
    code
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的边界条件是别名。考虑代码
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It will work most of the time, but not when `L1` and `L2` refer to the same
    list. Any test suite that did not include a call of the form `copy(L, L)`, would
    not reveal the bug.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常可以正常工作，但在`L1`和`L2`指向同一列表时则不然。任何未包含形式为`copy(L, L)`的调用的测试套件，都无法揭示这个错误。
- en: 8.1.2 Glass-Box Testing
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 玻璃盒测试
- en: 'Black-box testing should never be skipped, but it is rarely sufficient. Without
    looking at the internal structure of the code, it is impossible to know which
    test cases are likely to provide new information. Consider the trivial example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 黑箱测试绝不能被跳过，但它通常是不够的。没有查看代码的内部结构，无法知道哪些测试用例可能提供新信息。考虑这个简单的例子：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Looking at the code, we can see that because of the test `if x <= 2`, the values
    `0`, `1`, and `2` are treated as special cases, and therefore need to be tested.
    Without looking at the code, one might not test `is_prime(2)`, and would therefore
    not discover that the function call `is_prime(2)` returns `False`, erroneously
    indicating that `2` is not a prime.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 查看代码后，我们可以看到由于测试`if x <= 2`，值`0`、`1`和`2`被视为特例，因此需要进行测试。如果不查看代码，可能不会测试`is_prime(2)`，因此不会发现函数调用`is_prime(2)`返回`False`，错误地表示`2`不是素数。
- en: Glass-box test suites are usually much easier to construct than black-box test
    suites. Specifications, including many in this book, are usually incomplete and
    often pretty sloppy, making it a challenge to estimate how thoroughly a black-box
    test suite explores the space of interesting inputs. In contrast, the notion of
    a path through code is well defined, and it is relatively easy to evaluate how
    thoroughly one is exploring the space. There are, in fact, commercial tools that
    can be used to objectively measure the completeness of glass-box tests.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 玻璃盒测试套件通常比黑盒测试套件更容易构建。规范（包括本书中的许多规范）通常是不完整的，且相当粗糙，这使得估计黑盒测试套件对有趣输入空间的探索程度变得具有挑战性。相比之下，代码路径的概念是明确的，评估探索的彻底程度相对容易。实际上，有商业工具可用于客观地测量玻璃盒测试的完整性。
- en: A glass-box test suite is **path-complete** if it exercises every potential
    path through the program. This is typically impossible to achieve, because it
    depends upon the number of times each loop is executed and the depth of each recursion.
    For example, a recursive implementation of factorial follows a different path
    for each possible input (because the number of levels of recursion will differ).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个玻璃盒测试套件是**路径完整**的，如果它测试程序中的每一个潜在路径。这通常是无法实现的，因为它取决于每个循环执行的次数和每次递归的深度。例如，递归实现的阶乘对每个可能的输入遵循不同的路径（因为递归的层数不同）。
- en: 'Furthermore, even a path-complete test suite does not guarantee that all bugs
    will be exposed. Consider:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使是路径完整的测试套件也不能保证所有的bug都会被暴露。考虑：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The specification suggests that there are two possible cases: `x` either is
    negative or it isn''t. This suggests that the set of inputs `{2, -2}` is sufficient
    to explore all paths in the specification. This test suite has the additional
    nice property of forcing the program through all of its paths, so it looks like
    a complete glass-box suite as well. The only problem is that this test suite will
    not expose the fact that `abs(-1)` will return `-1`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 规范建议有两种可能情况：`x`要么为负，要么不是。这表明输入集合`{2, -2}`足以探索规范中的所有路径。这个测试套件还有一个额外的优点，就是强迫程序遍历所有路径，因此它看起来像是一个完整的玻璃盒测试套件。唯一的问题是，这个测试套件不会暴露`abs(-1)`会返回`-1`的事实。
- en: 'Despite the limitations of glass-box testing, a few rules of thumb are usually
    worth following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管玻璃盒测试存在局限性，但通常值得遵循一些经验法则：
- en: Exercise both branches of all `if` statements.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对所有`if`语句的两个分支都要进行测试。
- en: Make sure that each `except` clause (see Chapter 9) is executed.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保每个`except`子句（见第9章）都被执行。
- en: For each `for` loop, have test cases in which
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个`for`循环，设置测试用例，其中
- en: ○ The loop is not entered (e.g., if the loop is iterating over the elements
    of a list, make sure that it is tested on the empty list).
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 循环未被进入（例如，如果循环是迭代列表中的元素，请确保在空列表上进行测试）。
- en: ○ The body of the loop is executed exactly once.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 循环体被执行恰好一次。
- en: ○ The body of the loop is executed more than once.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 循环体被执行多于一次。
- en: For each `while` loop
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个`while`循环
- en: ○ Look at the same kinds of cases as when dealing with `for` loops.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 查看与处理`for`循环时相同类型的情况。
- en: ○ Include test cases corresponding to all possible ways of exiting the loop.
    For example, for a loop starting with
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 包含对应于所有可能退出循环的测试用例。例如，对于一个以
- en: '`while len(L) > 0 and not L[i] == e`'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while len(L) > 0 and not L[i] == e`'
- en: find cases where the loop exits because `len(L)` is greater than zero and cases
    where it exits because `L[i] == e`.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到由于`len(L)`大于零而退出循环的情况，以及由于`L[i] == e`而退出循环的情况。
- en: For recursive functions, include test cases that cause the function to return
    with no recursive calls, exactly one recursive call, and more than one recursive
    call.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于递归函数，包含导致函数在没有递归调用、恰好一次递归调用和多于一次递归调用时返回的测试用例。
- en: 8.1.3 Conducting Tests
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 进行测试
- en: Testing is often thought of as occurring in two phases. One should always start
    with **unit testing**. During this phase, testers construct and run tests designed
    to ascertain whether individual units of code (e.g., functions) work properly.
    This is followed by **integration testing**, which is designed to ascertain whether
    groups of units function properly when combined. Finally, **functional testing**
    is used to check if the program as a whole behaves as intended. In practice, testers
    cycle through these phases, since failures during integration or functional testing
    lead to making changes to individual units.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常被认为分为两个阶段。应始终从**单元测试**开始。在这个阶段，测试人员构建并运行旨在确定单个代码单元（例如函数）是否正常工作的测试。接下来是**集成测试**，旨在确定单元组合在一起时是否正常工作。最后，**功能测试**用于检查程序整体是否按预期行为。实际上，测试人员在这些阶段之间循环，因为集成或功能测试中的失败会导致对单个单元进行更改。
- en: Functional testing is almost always the most challenging phase. The intended
    behavior of an entire program is considerably harder to characterize than the
    intended behavior of each of its parts. For example, characterizing the intended
    behavior of a word processor is considerably more challenging than characterizing
    the behavior of the subsystem that counts the number of characters in a document.
    Problems of scale can also make functional testing difficult. It is not unusual
    for functional tests to take hours or even days to run.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试几乎总是最具挑战性的阶段。整个程序的预期行为比每个部分的预期行为更难以表征。例如，表征文字处理器的预期行为要比表征计算文档中字符数的子系统的行为困难得多。规模问题也可能使功能测试变得困难。功能测试耗时数小时甚至数天并不罕见。
- en: Many industrial software development organizations have a **software quality
    assurance (SQA)** group that is separate from the group charged with implementing
    the software. The mission of an SQA group is to ensure that before the software
    is released, it is suitable for its intended purpose. In some organizations the
    development group is responsible for unit testing and the QA group for integration
    and functional testing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 许多工业软件开发组织设有独立于实施软件的团队的**软件质量保证（SQA）**小组。SQA小组的使命是确保软件在发布之前适合其预期目的。在某些组织中，开发小组负责单元测试，而质量保证小组负责集成和功能测试。
- en: In industry, the testing process is often highly automated. Testers[^(51)](#c8-fn-0003)
    do not sit at terminals typing inputs and checking outputs. Instead, they use
    **test drivers** that autonomously
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在工业界，测试过程通常高度自动化。测试人员[^(51)](#c8-fn-0003)不会坐在终端上输入数据和检查输出。相反，他们使用**测试驱动程序**，这些驱动程序能够自主执行。
- en: Set up the environment needed to invoke the program (or units) to test.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置需要调用程序（或单元）进行测试的环境。
- en: Invoke the program (or units) to test with a predefined or automatically generated
    sequence of inputs.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预定义或自动生成的输入序列调用程序（或单元）进行测试。
- en: Save the results of these invocations.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存这些调用的结果。
- en: Check the acceptability of test results.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查测试结果的可接受性。
- en: Prepare an appropriate report.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备一份适当的报告。
- en: During unit testing, we often need to build **stubs** as well as drivers. Drivers
    simulate parts of the program that use the unit being tested, whereas stubs simulate
    parts of the program used by the unit being tested. Stubs are useful because they
    allow people to test units that depend upon software or sometimes even hardware
    that does not yet exist. This allows teams of programmers to simultaneously develop
    and test multiple parts of a system.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试过程中，我们通常需要构建**桩**和驱动程序。驱动程序模拟使用被测单元的程序部分，而桩则模拟被测单元使用的程序部分。桩很有用，因为它们允许人们测试依赖于尚未存在的软件或有时甚至是硬件的单元。这使得程序员团队能够同时开发和测试系统的多个部分。
- en: Ideally, a stub should
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，桩应该
- en: Check the reasonableness of the environment and arguments supplied by the caller
    (calling a function with inappropriate arguments is a common error).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查调用者提供的环境和参数的合理性（用不当参数调用函数是一种常见错误）。
- en: Modify arguments and global variables in a manner consistent with the specification.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以与规范一致的方式修改参数和全局变量。
- en: Return values consistent with the specification.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回与规范一致的值。
- en: Building adequate stubs is often a challenge. If the unit the stub replaces
    is intended to perform some complex task, building a stub that performs actions
    consistent with the specification may be tantamount to writing the program that
    the stub is designed to replace. One way to surmount this problem is to limit
    the set of arguments accepted by the stub, and create a table that contains the
    values to return for each combination of arguments to be used in the test suite.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 构建足够的桩常常是一项挑战。如果桩所替代的单元旨在执行某些复杂任务，构建一个与规范一致的桩可能相当于编写桩所设计替代的程序。克服这个问题的一种方法是限制桩接受的参数集，并创建一个包含每种参数组合的返回值的表。
- en: One attraction of automating the testing process is that it facilitates **regression
    testing**. As programmers attempt to debug a program, it is all too common to
    install a “fix” that breaks something, or maybe many things, that used to work.
    Whenever any change is made, no matter how small, you should check that the program
    still passes all of the tests that it used to pass.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试过程的一个吸引力是它促进了**回归测试**。当程序员试图调试一个程序时，安装一个“修复”通常会破坏曾经正常工作的一些或多个功能。无论做出多小的改变，都应检查程序是否仍通过所有之前通过的测试。
- en: 8.2 Debugging
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 调试
- en: There is a charming urban legend about how the process of fixing flaws in software
    came to be known as debugging. The photo in [Figure 8-2](#c8-fig-0002) is of a
    page, from September 9, 1947, in a laboratory book from the group working on the
    Mark II Aiken Relay Calculator at Harvard University. Notice the moth taped to
    the page and the phrase “First actual case of bug being found” below it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 关于修复软件缺陷的过程为何被称为调试，有一个迷人的都市传说。[图8-2](#c8-fig-0002)中的照片是一份来自1947年9月的实验室记录，记录了哈佛大学Mark
    II艾肯继电器计算机组的工作。注意页面上贴着的蛾子和下面的短语“第一次发现的bug”。
- en: '![c8-fig-0002.jpg](../images/c8-fig-0002.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![c8-fig-0002.jpg](../images/c8-fig-0002.jpg)'
- en: '[Figure 8-2](#c8-fig-0002a) Not the first bug'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-2](#c8-fig-0002a) 不是第一个bug'
- en: Some have claimed that the discovery of that unfortunate moth trapped in the
    Mark II led to the use of the phrase debugging. However the wording, “First actual
    case of a bug being found,” suggests that a less literal interpretation of the
    phrase was already common. Grace Murray Hopper,[^(52)](#c8-fn-0004) a leader of
    the Mark II project, made it clear that the term “bug” was already in wide use
    to describe problems with electronic systems during World War II. And well prior
    to that, *Hawkins’ New Catechism of Electricity*, an 1896 electrical handbook,
    included the entry, “The term ‘bug’ is used to a limited extent to designate any
    fault or trouble in the connections or working of electric apparatus.” In English
    usage the word “bugbear” means “anything causing seemingly needless or excessive
    fear or anxiety.” [^(53)](#c8-fn-0005) Shakespeare seems to have shortened this
    to “bug” when he had Hamlet kvetch about “bugs and goblins in my life.”
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有人声称，困在Mark II中的那只不幸的蛾子的发现导致了“调试”这一短语的使用。然而，措辞“第一次发现的真实案例”暗示这个短语的更不字面化的解释已经相当普遍。Mark
    II项目的领导者**格雷斯·穆雷·霍普**明确表示，“bug”一词在二战期间已经被广泛用来描述电子系统的问题。而在此之前，*霍金斯电力新教义*这本1896年的电力手册中已包含条目：“‘bug’一词在有限的范围内用来指代电器连接或工作中的任何故障或问题。”在英语中，“bugbear”一词意为“导致似乎无谓或过度恐惧或焦虑的任何事物”。莎士比亚似乎把这个缩短为“bug”，当他让哈姆雷特抱怨“我生活中的bug和小鬼”时。
- en: The use of the word “**bug**” sometimes leads people to ignore the fundamental
    fact that if you wrote a program and it has a “bug,” you messed up. Bugs do not
    crawl unbidden into flawless programs. If your program has a bug, it is because
    you put it there. Bugs do not breed in programs. If your program has multiple
    bugs, it is because you made multiple mistakes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: “**bug**”一词的使用有时会让人忽视一个基本事实：如果你编写了一个程序并且它有一个“bug”，那么是你犯了错。错误不会自然而然地出现在完美的程序中。如果你的程序有bug，那是因为你把它放进去了。错误不会在程序中繁殖。如果你的程序有多个bug，那是因为你犯了多个错误。
- en: 'Runtime bugs can be categorized along two dimensions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时错误可以沿两个维度进行分类：
- en: '**Overt → covert**: An **overt bug** has an obvious manifestation, e.g., the
    program crashes or takes far longer (maybe forever) to run than it should. A **covert
    bug** has no obvious manifestation. The program may run to conclusion with no
    problem—other than providing an incorrect answer. Many bugs fall between the two
    extremes, and whether the bug is overt can depend upon how carefully you examine
    the behavior of the program.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**明显→隐蔽**：一个**明显的bug**有明显的表现，例如程序崩溃或运行时间远长于应有的时间（可能永远）。一个**隐蔽的bug**没有明显的表现。程序可能顺利运行到结束——只是提供了错误的答案。许多bug介于这两种极端之间，bug是否明显可能取决于你多仔细地检查程序的行为。'
- en: '**Persistent → intermittent**: A **persistent bug** occurs every time the program
    is run with the same inputs. An **intermittent bug** occurs only some of the time,
    even when the program is run on the same inputs and seemingly under the same conditions.
    When we get to Chapter 16, we will look at programs that model situations in which
    randomness plays a role. In programs of that kind, intermittent bugs are common.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性 → 间歇性**：**持久性错误**是在相同输入下，每次运行程序时都会发生的错误。**间歇性错误**则只在某些情况下发生，即使程序在相同输入和看似相同条件下运行。当我们进入第16章时，将探讨在随机性起作用的情况下建模的程序。这类程序中，间歇性错误是很常见的。'
- en: The best kind of bugs to have are overt and persistent. Developers can be under
    no illusion about the advisability of deploying the program. And if someone else
    is foolish enough to attempt to use it, they will quickly discover their folly.
    Perhaps the program will do something horrible before crashing, e.g., delete files,
    but at least the user will have reason to be worried (if not panicked). Good programmers
    try to write their programs in such a way that programming mistakes lead to bugs
    that are both overt and persistent. This is often called **defensive programming**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的错误是明显且持久的。开发人员不应抱有部署该程序的幻想。如果其他人傻到尝试使用它，他们会迅速意识到自己的愚蠢。也许程序会在崩溃之前做一些可怕的事情，例如删除文件，但至少用户会有理由感到担忧（甚至恐慌）。优秀的程序员会尽量以一种方式编写程序，使编程错误导致的缺陷既明显又持久。这通常被称为**防御性编程**。
- en: The next step into the pit of undesirability is bugs that are overt but intermittent.
    An air traffic control system that computes the correct location for planes almost
    all the time would be far more dangerous than one that makes obvious mistakes
    all the time. One can live in a fool's paradise for a period of time, and maybe
    get so far as deploying a system incorporating the flawed program, but sooner
    or later the bug will become manifest. If the conditions prompting the bug to
    become manifest are easily reproducible, it is often relatively easy to track
    down and repair the problem. If the conditions provoking the bug are not clear,
    life is much harder.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 进入不理想状态的下一步是明显但间歇性的错误。一个几乎总能计算出飞机正确位置的空中交通管制系统，远比一个总是犯明显错误的系统危险。人们可能会在虚幻的乐园中生活一段时间，甚至将有缺陷的程序部署，但迟早这个错误会显现出来。如果促使错误显现的条件容易重现，通常相对容易追踪和修复问题。如果导致错误的条件不明确，生活就会变得困难得多。
- en: Programs that fail in covert ways are often highly dangerous. Since they are
    not apparently problematical, people use them and trust them to do the right thing.
    Increasingly, society relies on software to perform critical computations that
    are beyond the ability of humans to carry out or even check for correctness. Therefore,
    a program can provide an undetected fallacious answer for long periods of time.
    Such programs can, and have, caused a lot of damage.[^(54)](#c8-fn-0006) A program
    that evaluates the risk of a mortgage bond portfolio and confidently spits out
    the wrong answer can get a bank (and perhaps all of society) into a lot of trouble.
    Software in a flight management computer can make the difference between an aircraft
    remaining airborne or not.[^(55)](#c8-fn-0007) A radiation therapy machine that
    delivers a little more or a little less radiation than intended can be the difference
    between life and death for a person with cancer. A program that makes a covert
    error only occasionally may or may not wreak less havoc than one that always commits
    such an error. Bugs that are both covert and intermittent are almost always the
    hardest to find and fix.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以隐蔽方式失败的程序往往非常危险。由于它们表面上并没有明显问题，人们使用并信任它们能正确执行任务。社会日益依赖软件进行超出人类能力范围的关键计算，甚至无法验证其正确性。因此，一个程序可能会在长时间内提供未被发现的错误答案。这类程序造成的损害是巨大的。[^(54)](#c8-fn-0006)
    评估抵押债券投资组合风险的程序若输出错误答案，可能会让银行（甚至整个社会）陷入麻烦。飞行管理计算机中的软件可能决定飞机是否能继续飞行。[^(55)](#c8-fn-0007)
    对于癌症患者来说，放射治疗机器若提供多或少的辐射，都可能是生与死的区别。偶尔发生隐蔽错误的程序，可能不会比总是出错的程序造成更少的破坏。隐蔽且间歇性出现的错误几乎总是最难发现和修复的。
- en: 8.2.1 Learning to Debug
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 学习调试
- en: Debugging is a learned skill. Nobody does it well instinctively. The good news
    is that it's not hard to learn, and it is a transferable skill. The same skills
    used to debug software can be used to find out what is wrong with other complex
    systems, e.g., laboratory experiments or sick humans.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是一项学习技能。没有人能够凭直觉做到这一点。好消息是，它并不难学，而且是一项可转移的技能。用于调试软件的相同技能可以用于发现其他复杂系统中的问题，例如实验室实验或生病的人。
- en: For at least four decades people have been building tools called **debuggers**,
    and debugging tools are built into all of the popular Python IDEs. (If you haven't
    already, give the debugging tool in Spyder a try.) These tools can help. But what's
    much more important is how you approach the problem. Many experienced programmers
    don't even bother with debugging tools, relying instead on the `print` statement.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的四十多年里，人们一直在构建称为**调试器**的工具，调试工具已经内置于所有流行的Python IDE中。（如果你还没试过，建议尝试Spyder中的调试工具。）这些工具可以提供帮助。但更重要的是你如何看待这个问题。许多经验丰富的程序员甚至不使用调试工具，而是依赖于`print`语句。
- en: Debugging starts when testing has demonstrated that the program behaves in undesirable
    ways. Debugging is the process of searching for an explanation of that behavior.
    The key to being consistently good at debugging is being systematic in conducting
    that search.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试表明程序表现出不理想的行为时，调试便开始了。调试是寻找该行为解释的过程。持续优秀调试的关键是在进行搜索时保持系统性。
- en: Start by studying the available data. This includes the test results and the
    program text. Study all of the test results. Examine not only the tests that revealed
    the presence of a problem, but also those tests that seemed to work perfectly.
    Trying to understand why one test worked and another did not is often illuminating.
    When looking at the program text, keep in mind that you don't completely understand
    it. If you did, there probably wouldn't be a bug.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，研究可用的数据。这包括测试结果和程序文本。研究所有测试结果。不仅要检查揭示问题存在的测试，还要检查那些似乎完美工作的测试。试图理解为什么一个测试有效而另一个无效常常会很有启发性。在查看程序文本时，要记住你并不完全理解它。如果你理解了，可能就不会有错误。
- en: Next, form a hypothesis that you believe to be consistent with all the data.
    The hypothesis could be as narrow as “if I change line 403 from `x < y` to `x
    <= y`, the problem will go away” or as broad as “my program is not working because
    I forgot about the possibility of aliasing in multiple places.”
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，形成一个你认为与所有数据一致的假设。这个假设可以像“如果我将第403行从`x < y`改为`x <= y`，问题就会消失”那样狭窄，也可以像“我的程序不工作是因为我忘记了多个地方可能存在别名问题”那样广泛。
- en: Next, design and run a repeatable experiment with the potential to refute the
    hypothesis. For example, you might put a print statement before and after each
    loop. If these are always paired, then the hypothesis that a loop is causing nontermination
    has been refuted. Decide before running the experiment how you would interpret
    various possible results. All humans are subject to what psychologists call **confirmation
    bias**—we interpret information in a way that reinforces what we want to believe.
    If you wait until after you run the experiment to think about what the results
    should be, you are more likely to fall prey to wishful thinking.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设计并运行一个可重复的实验，以可能驳斥这个假设。例如，你可以在每个循环前后放置打印语句。如果这些打印语句总是成对出现，那么循环导致非终止的假设就被驳斥了。在运行实验之前决定如何解释各种可能的结果。所有人都受到心理学家称之为**确认偏误**的影响——我们以一种强化我们想要相信的方式来解释信息。如果你在运行实验后才考虑结果应该是什么，你更可能落入一厢情愿的思维陷阱。
- en: Finally, keep a record of what experiments you have tried. When you've spent
    many hours changing your code trying to track down an elusive bug, it's easy to
    forget what you have already tried. If you aren't careful, you can waste way too
    many hours trying the same experiment (or more likely an experiment that looks
    different but will give you the same information) over and over again. Remember,
    as many have said, “insanity is doing the same thing, over and over again, but
    expecting different results.” [^(56)](#c8-fn-0008)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，记录你尝试过的实验。当你花了很多小时更改代码以试图追踪一个难以捉摸的错误时，很容易忘记你已经尝试过什么。如果你不小心，你可能会浪费太多时间反复尝试相同的实验（或者更可能是看似不同但会给你相同信息的实验）。记住，正如许多人所说，“疯狂就是不断重复相同的事情，却期待不同的结果。” [^(56)](#c8-fn-0008)
- en: 8.2.2 Designing the Experiment
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 设计实验
- en: Think of debugging as a search process, and each experiment as an attempt to
    reduce the size of the search space. One way to reduce the size of the search
    space is to design an experiment that can be used to decide whether a specific
    region of code is responsible for a problem uncovered during testing. Another
    way to reduce the search space is to reduce the amount of test data needed to
    provoke a manifestation of a bug.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将调试视为一个搜索过程，每个实验都是试图缩小搜索空间的尝试。缩小搜索空间的一种方法是设计一个实验，用于判断代码的特定区域是否对在测试中发现的问题负责。另一种缩小搜索空间的方法是减少需要引发bug表现的测试数据量。
- en: Let's look at a contrived example to see how you might go about debugging it.
    Imagine that you wrote the palindrome-checking code in [Figure 8-3](#c8-fig-0003).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个虚构的例子，看看你可能如何进行调试。想象一下，你在[图 8-3](#c8-fig-0003)中编写了回文检查代码。
- en: '![c8-fig-0003.jpg](../images/c8-fig-0003.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![c8-fig-0003.jpg](../images/c8-fig-0003.jpg)'
- en: '[Figure 8-3](#c8-fig-0003a) Program with bugs'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-3](#c8-fig-0003a) 有bug的程序'
- en: Now, imagine that you are so confident of your programming skills that you put
    this code up on the web—without testing it. Suppose further that you receive an
    email saying, “I tested your !!**! program by entering the 3,116,480 letters in
    the *Bible*, and your program printed `Yes`. Yet any fool can see that the *Bible*
    is not a palindrome. Fix it! (Your program, not the *Bible*.)”
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下你对自己的编程技能充满信心，以至于将这段代码上传到网络上——没有经过测试。进一步假设你收到了一个电子邮件，上面写着：“我通过输入*圣经*中的3,116,480个字母测试了你的!!**!程序，你的程序打印了`是`。然而任何傻瓜都能看出*圣经*不是回文。修复它！（是你的程序，不是*圣经*。）”
- en: You could try and test it on the *Bible*. But it might be more sensible to begin
    by trying it on something smaller. In fact, it would make sense to test it on
    a minimal non-palindrome, e.g.,
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试在*圣经*上测试它。但开始时尝试在更小的东西上可能更明智。实际上，测试一个最小的非回文字符串是有意义的，例如，
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The good news is that it fails even this simple test, so you don't have to type
    in millions of characters. The bad news is that you have no idea why it failed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，它甚至未能通过这个简单测试，因此你不必输入数百万个字符。坏消息是，你不知道为什么它失败了。
- en: In this case, the code is small enough that you can probably stare at it and
    find the bug (or bugs). However, let's pretend that it is too large to do this,
    and start to systematically reduce the search space.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，代码足够小，你可能可以盯着它找到bug（或多个bug）。不过，让我们假装它太大而无法做到这一点，开始系统地缩小搜索空间。
- en: Often the best way to do this is to conduct a **bisection search**. Find some
    point about halfway through the code, and devise an experiment that will allow
    you to decide if there is a problem before that point that might be related to
    the symptom. (Of course, there may be problems after that point as well, but it
    is usually best to hunt down one problem at a time.) In choosing such a point,
    look for a place where some easily examined intermediate values provide useful
    information. If an intermediate value is not what you expected, there is probably
    a problem that occurred prior to that point in the code. If the intermediate values
    all look fine, the bug probably lies somewhere later in the code. This process
    can be repeated until you have narrowed the region in which a problem is located
    to a few lines of code, or a few units if you are testing a large system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法通常是进行**二分搜索**。找到代码中大约一半的某个点，并设计一个实验，以便在该点之前判断是否存在可能与症状相关的问题。（当然，该点之后可能也有问题，但通常最好一次解决一个问题。）在选择这样一个点时，寻找一些容易检查的中间值，这些值能提供有用的信息。如果某个中间值不是你所期望的，那么很可能在代码的那个点之前就发生了问题。如果所有中间值看起来都正常，bug可能出现在代码的后面。这个过程可以重复进行，直到你将问题所在的区域缩小到几行代码，或者如果你在测试一个大型系统，则缩小到几个单元。
- en: Looking at `silly`, the halfway point is around the line `if is_pal(result)`.
    The obvious thing to check is whether `result` has the expected value, `['a',
    'b']`. We check this by inserting the statement `print(result)` before the `if`
    statement in `silly`. When the experiment is run, the program prints `['b']`,suggesting
    that something has already gone wrong. The next step is to print the value `result`
    roughly halfway through the loop. This quickly reveals that `result` is never
    more than one element long, suggesting that the initialization of `result` needs
    to be moved outside the `for` loop.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `silly`，中途点大约在 `if is_pal(result)` 行。显而易见的检查是 `result` 是否具有预期值 `['a', 'b']`。我们通过在
    `silly` 的 `if` 语句之前插入 `print(result)` 语句来检查这一点。当实验运行时，程序打印 `['b']`，这表明事情已经出错。下一步是在循环中大约中途打印值
    `result`。这很快揭示 `result` 从未超过一个元素，表明 `result` 的初始化需要移到 `for` 循环之外。
- en: The “corrected” code for `silly` is
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: “修正后的” `silly` 代码是
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's try that, and see if `result` has the correct value after the `for` loop.
    It does, but unfortunately the program still prints `Yes`. Now, we have reason
    to believe that a second bug lies below the `print` statement. So, let's look
    at `is_pal`. Insert the line
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这个，看看 `for` 循环后 `result` 是否有正确的值。确实如此，但不幸的是程序仍然打印 `Yes`。现在，我们有理由相信第二个错误出现在
    `print` 语句下方。因此，让我们查看 `is_pal`。插入这一行
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: before the `return` statement. When we run the code, we see that `temp` has
    the expected value, but `x` does not. Moving up the code, we insert a `print`
    statement after the line of code `temp = x`, and discover that both `temp` and
    `x` have the value `['a', 'b']`. A quick inspection of the code reveals that in
    `is_pal` we wrote `temp.reverse` rather than `temp.reverse()`—the evaluation of
    `temp.reverse` returns the built-in `reverse` method for lists, but does not invoke
    it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`return` 语句之前。当我们运行代码时，我们发现 `temp` 的值是预期的，但 `x` 不是。向上移动代码，我们在代码行 `temp = x`
    后插入了一个 `print` 语句，发现 `temp` 和 `x` 的值都是 `[''a'', ''b'']`。快速检查代码后发现，在 `is_pal` 中我们写成了
    `temp.reverse` 而不是 `temp.reverse()`——`temp.reverse` 的评估返回了列表的内置 `reverse` 方法，但并没有调用它。'
- en: 'We run the test again, and now it seems that both `temp` and `x` have the value
    `[''b'',''a'']`. We have now narrowed the bug to one line. It seems that `temp.reverse()`
    unexpectedly changed the value of `x`. An aliasing bug has bitten us: `temp` and
    `x` are names for the same list, both before and after the list gets reversed.
    One way to fix the bug is to replace the first assignment statement in `is_pal`
    by `temp = x[:]`, which makes a copy of `x`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次运行测试，现在似乎 `temp` 和 `x` 的值都是 `['b', 'a']`。我们已经将错误缩小到一行。看起来 `temp.reverse()`
    意外地改变了 `x` 的值。一个别名错误出现了：`temp` 和 `x` 是同一个列表的名称，在列表被反转之前和之后都是如此。修复这个错误的一种方法是将 `is_pal`
    中的第一个赋值语句替换为 `temp = x[:]`，这会创建 `x` 的一个副本。
- en: The corrected version of `is_pal` is
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 修正后的 `is_pal` 版本是
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 8.2.3 When the Going Gets Tough
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 当事情变得棘手时
- en: Joseph P. Kennedy, father of U.S. President John F. Kennedy, reputedly instructed
    his children, “When the going gets tough, the tough get going.” [^(57)](#c8-fn-0009)
    But he never debugged a piece of software. This subsection contains a few pragmatic
    hints about what to do when the debugging gets tough.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 约瑟夫·P·肯尼迪，美国总统约翰·F·肯尼迪的父亲，曾声称告诫他的孩子们：“当事情变得棘手时，强者开始行动。” [^(57)](#c8-fn-0009)但他从未调试过一段软件。这个小节包含一些关于调试变得棘手时该怎么办的务实提示。
- en: '*Look for the usual suspects*. Have you'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*寻找常见问题*。你是否在'
- en: ○ Passed arguments to a function in the wrong order?
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 以错误的顺序向函数传递参数？
- en: ○ Misspelled a name, e.g., typed a lowercase letter when you should have typed
    an uppercase one?
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 拼写错误的名字，例如，在应该大写字母时打成小写字母？
- en: ○ Failed to reinitialize a variable?
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 未能重新初始化变量？
- en: ○ Tested that two-floating point values are equal (`==`) instead of nearly equal
    (remember that floating-point arithmetic is not the same as the arithmetic you
    learned in school)?
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 测试两个浮点值是否相等 (`==`)，而不是近似相等（记住，浮点运算与你在学校学的算术是不同的）？
- en: ○ Tested for value equality (e.g., compared two lists by writing the expression
    `L1 == L2`) when you meant to test for object equality (e.g., `id(L1) == id(L2))`?
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 在需要测试对象相等性时（例如，使用表达式 `L1 == L2` 比较两个列表）测试值相等性（例如，`id(L1) == id(L2)`）？
- en: ○ Forgotten that some built-in function has a side effect?
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 忘记某个内置函数有副作用？
- en: ○ Forgotten the `()` that turns a reference to an object of type `function`
    into a function invocation?
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 忘记了将一个对 `function` 类型对象的引用转换为函数调用的 `()`？
- en: ○ Created an unintentional alias?
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 创建了一个无意的别名？
- en: ○ Made any other mistake that is typical for you?
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 是否犯了你典型的其他错误？
- en: '*Stop asking yourself why the program isn''t doing what you want it to. Instead,
    ask yourself why it is doing what it is.* That should be an easier question to
    answer, and will probably be a good first step in figuring out how to fix the
    program.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*停止问自己为什么程序没有按照你的想法运行。相反，问问自己为什么它会这样运行。* 这个问题应该更容易回答，也可能是找出如何修复程序的第一步。'
- en: '*Keep in mind that the bug is probably not where you think it is.* If it were,
    you would have found it long ago. One practical way to decide where to look is
    asking where the bug cannot be. As Sherlock Holmes said, “Eliminate all other
    factors, and the one which remains must be the truth.” [^(58)](#c8-fn-0010)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*记住，错误可能不在你认为的地方。* 如果在，你早就找到了。决定查看哪里的一个实用方法是问问错误不可能出现在哪里。正如福尔摩斯所说：“排除所有其他因素，剩下的那个必须是真相。” [^(58)](#c8-fn-0010)'
- en: '*Try to explain the problem to somebody else.* We all develop blind spots.
    Merely attempting to explain the problem to someone will often lead you to see
    things you have missed. You can also try to explain why the bug cannot be in certain
    places.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尝试向其他人解释这个问题。* 我们都会产生盲点。仅仅尝试向某人解释问题，通常会让你看到自己遗漏的地方。你还可以尝试解释为什么这个错误不可能出现在某些地方。'
- en: '*Don''t believe everything you read.*[*^(59)*](#c8-fn-0011) In particular,
    don''t believe the documentation. The code may not be doing what the comments
    suggest.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不要相信你看到的一切。*[*^(59)*](#c8-fn-0011) 特别是，不要相信文档。代码可能并没有按照注释所建议的那样运行。'
- en: '*Stop debugging and start writing documentation.* This will help you approach
    the problem from a different perspective.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*停止调试，开始编写文档。* 这将帮助你从不同的角度看待问题。'
- en: '*Walk away and try again tomorrow*. This may mean that bug is fixed later than
    if you had stuck with it, but you will probably spend less of your time looking
    for it. That is, it is possible to trade latency for efficiency. (Students, this
    is an excellent reason to start work on programming problem sets earlier rather
    than later!)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*走开，明天再试。* 这可能意味着修复这个错误的时间比坚持下去要晚，但你可能会花更少的时间去寻找它。也就是说，可以用延迟来换取效率。（学生们，这也是你们早点开始编程问题集工作的一个绝佳理由！）'
- en: 8.2.4 When You Have Found “The” Bug
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.4 当你找到“那个”错误时
- en: When you think you have found a bug in your code, the temptation to start coding
    and testing a fix is almost irresistible. It is often better, however, to pause.
    Remember that the goal is not to fix one bug, but to move rapidly and efficiently
    towards a bug-free program.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你认为在代码中发现了一个错误时，开始编码和测试修复的诱惑几乎不可抵挡。然而，通常更好的是暂停。记住，目标不是修复一个错误，而是快速有效地朝着无错误的程序迈进。
- en: Ask yourself if this bug explains all the observed symptoms, or whether it is
    just the tip of the iceberg. If the latter, it may be better to take care of the
    bug in concert with other changes. Suppose, for example, that you have discovered
    that the bug is the result of accidentally mutating a list. You could circumvent
    the problem locally, perhaps by making a copy of the list. Alternatively, you
    could consider using a tuple instead of a list (since tuples are immutable), perhaps
    eliminating similar bugs elsewhere in the code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 问问自己这个错误是否解释了所有观察到的症状，还是仅仅冰山一角。如果是后者，可能最好与其他更改一起处理这个错误。假设，例如，你发现这个错误是因为意外改变了一个列表。你可以局部规避这个问题，可能通过复制列表来实现。或者，你可以考虑用元组代替列表（因为元组是不可变的），也许可以消除代码中其他类似的错误。
- en: Before making any change, try and understand the ramification of the proposed
    “fix.” Will it break something else? Does it introduce excessive complexity? Does
    it offer the opportunity to tidy up other parts of the code?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何更改之前，尝试理解提议的“修复”的影响。它会破坏其他内容吗？是否引入了过度复杂性？是否提供了整理代码其他部分的机会？
- en: Always make sure that you can get back to where you are. Nothing is more frustrating
    than realizing that a long series of changes have left you farther from the goal
    than when you started, and having no way to get back to your starting point. Disk
    space is usually plentiful. Use it to store old versions of your program.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 始终确保你可以回到当前位置。没有什么比意识到一系列更改让你离目标更远却没有办法回到起点更让人沮丧。磁盘空间通常是充足的。利用它来存储程序的旧版本。
- en: Finally, if there are many unexplained errors, you might consider whether finding
    and fixing bugs one at a time is even the right approach. Maybe you would be better
    off thinking about a better way to organize your program or maybe a simpler algorithm
    that will be easier to implement correctly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果有许多未解释的错误，你可能需要考虑一下，逐个查找和修复错误是否是正确的方法。也许你更应该考虑更好的程序组织方式，或者可能是一个更简单的算法，这样更容易正确实现。
- en: 8.3 Terms Introduced in Chapter
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 本章介绍的术语
- en: testing
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: debugging
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: test suite
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试套件
- en: partition of inputs
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入分区
- en: glass-box testing
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玻璃盒测试
- en: black-box testing
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑盒测试
- en: path-complete testing
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径完全测试
- en: unit testing
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: integration testing
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: functional testing
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试
- en: software quality assurance (SQA)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件质量保证（SQA）
- en: test driver
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动程序
- en: test stub
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试存根
- en: regression testing
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归测试
- en: bug
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: overt bug
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显性错误
- en: covert bug
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐蔽错误
- en: persistent bug
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久性错误
- en: intermittent bug
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 间歇性错误
- en: defensive programming
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防御性编程
- en: debuggers
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试工具
- en: confirmation bias
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认偏误
- en: bisection search
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二分搜索
