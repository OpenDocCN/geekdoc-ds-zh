- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TESTING AND DEBUGGING
  prefs: []
  type: TYPE_NORMAL
- en: We hate to bring this up, but Dr. Pangloss[^(49)](#c8-fn-0001) was wrong. We
    do not live in “the best of all possible worlds.” There are some places where
    it rains too little, and others where it rains too much. Some places are too cold,
    some too hot, and some too hot in the summer and too cold in the winter. Sometimes
    the stock market goes down—a lot. Sometimes cheaters do win (see Houston Astros).
    And, annoyingly, our programs don't always function properly the first time we
    run them.
  prefs: []
  type: TYPE_NORMAL
- en: Books have been written about how to deal with this last problem, and there
    is a lot to be learned from reading these books. However, in the interest of providing
    you with some hints that might help you complete that next problem set on time,
    this chapter provides a highly condensed discussion of the topic. While all of
    the programming examples are in Python, the general principles apply to getting
    any complex system to work.
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing** is the process of running a program to try and ascertain whether
    it works as intended. **Debugging** is the process of trying to fix a program
    that you already know does not work as intended.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing and debugging are not processes that you should begin to think about
    after a program has been built. Good programmers design their programs in ways
    that make them easier to test and debug. The key to doing this is breaking the
    program into separate components that can be implemented, tested, and debugged
    independently of other components. At this point in the book, we have discussed
    only one mechanism for modularizing programs, the function. So, for now, all of
    our examples will be based around functions. When we get to other mechanisms,
    in particular classes, we will return to some of the topics covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in getting a program to work is getting the language system to
    agree to run it—that is, eliminating syntax errors and static semantic errors
    that can be detected without running the program. If you haven't gotten past that
    point in your programming, you're not ready for this chapter. Spend a bit more
    time working on small programs, and then come back.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of testing is to show that bugs exist, not to show that a program
    is bug-free. To quote Edsger Dijkstra, “Program testing can be used to show the
    presence of bugs, but never to show their absence!” [^(50)](#c8-fn-0002) Or, as
    Albert Einstein reputedly said, “No amount of experimentation can ever prove me
    right; a single experiment can prove me wrong.”
  prefs: []
  type: TYPE_NORMAL
- en: Why is this so? Even the simplest of programs has billions of possible inputs.
    Consider, for example, a program that purports to meet the specification
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Running it on all pairs of integers would be, to say the least, tedious. The
    best we can do is to run it on pairs of integers that have a reasonable probability
    of producing the wrong answer if there is a bug in the program.
  prefs: []
  type: TYPE_NORMAL
- en: The key to testing is finding a collection of inputs, called a **test suite**,
    that has a high likelihood of revealing bugs, yet does not take too long to run.
    The key to doing this is partitioning the space of all possible inputs into subsets
    that provide equivalent information about the correctness of the program, and
    then constructing a test suite that contains at least one input from each partition.
    (Usually, constructing such a test suite is not actually possible. Think of this
    as an unachievable ideal.)
  prefs: []
  type: TYPE_NORMAL
- en: 'A **partition** of a set divides that set into a collection of subsets such
    that each element of the original set belongs to exactly one of the subsets. Consider,
    for example, `is_smaller(x, y)`. The set of possible inputs is all pairwise combinations
    of integers. One way to partition this set is into these nine subsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we tested the implementation on at least one value from each of these subsets,
    we would have a good chance (but no guarantee) of exposing a bug if one exists.
  prefs: []
  type: TYPE_NORMAL
- en: For most programs, finding a good partitioning of the inputs is far easier said
    than done. Typically, people rely on heuristics based on exploring different paths
    through some combination of the code and the specifications. Heuristics based
    on exploring paths through the code fall into a class called **glass-box** (or
    **white-box**) **testing**. Heuristics based on exploring paths through the specification
    fall into a class called **black-box testing**.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.1 Black-Box Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In principle, black-box tests are constructed without looking at the code to
    be tested. Black-box testing allows testers and implementers to be drawn from
    separate populations. When those of us who teach programming courses generate
    test cases for the problem sets we assign students, we are developing black-box
    test suites. Developers of commercial software often have quality assurance groups
    that are largely independent of development groups. They too develop black-box
    test suites.
  prefs: []
  type: TYPE_NORMAL
- en: This independence reduces the likelihood of generating test suites that exhibit
    mistakes that are correlated with mistakes in the code. Suppose, for example,
    that the author of a program made the implicit, but invalid, assumption that a
    function would never be called with a negative number. If the same person constructed
    the test suite for the program, he would likely repeat the mistake, and not test
    the function with a negative argument.
  prefs: []
  type: TYPE_NORMAL
- en: Another positive feature of black-box testing is that it is robust with respect
    to implementation changes. Since the test data is generated without knowledge
    of the implementation, the tests need not be changed when the implementation is
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: As we said earlier, a good way to generate black-box test data is to explore
    paths through a specification. Consider, the specification
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There seem to be only two distinct paths through this specification: one corresponding
    to `x = 0` and one corresponding to `x > 0`. However, common sense tells us that
    while it is necessary to test these two cases, it is hardly sufficient.'
  prefs: []
  type: TYPE_NORMAL
- en: Boundary conditions should also be tested. Looking at an argument of type list
    often means looking at the empty list, a list with exactly one element, a list
    with immutable elements, a list with mutable elements, and a list containing lists.
    When dealing with numbers, it typically means looking at very small and very large
    values as well as “typical” values. For `sqrt`, for example, it might make sense
    to try values of `x` and `epsilon` similar to those in [Figure 8-1](#c8-fig-0001).
  prefs: []
  type: TYPE_NORMAL
- en: '![c8-fig-0001.jpg](../images/c8-fig-0001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 8-1](#c8-fig-0001a) Testing boundary conditions'
  prefs: []
  type: TYPE_NORMAL
- en: The first four rows are intended to represent typical cases. Notice that the
    values for `x` include a perfect square, a number less than one, and a number
    with an irrational square root. If any of these tests fail, there is a bug in
    the program that needs to be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining rows test extremely large and small values of `x` and `epsilon`.
    If any of these tests fail, something needs to be fixed. Perhaps there is a bug
    in the code that needs to be fixed, or perhaps the specification needs to be changed
    so that it is easier to meet. It might, for example, be unreasonable to expect
    to find an approximation of a square root when `epsilon` is ridiculously small.
  prefs: []
  type: TYPE_NORMAL
- en: Another important boundary condition to think about is aliasing. Consider the
    code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It will work most of the time, but not when `L1` and `L2` refer to the same
    list. Any test suite that did not include a call of the form `copy(L, L)`, would
    not reveal the bug.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.2 Glass-Box Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Black-box testing should never be skipped, but it is rarely sufficient. Without
    looking at the internal structure of the code, it is impossible to know which
    test cases are likely to provide new information. Consider the trivial example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the code, we can see that because of the test `if x <= 2`, the values
    `0`, `1`, and `2` are treated as special cases, and therefore need to be tested.
    Without looking at the code, one might not test `is_prime(2)`, and would therefore
    not discover that the function call `is_prime(2)` returns `False`, erroneously
    indicating that `2` is not a prime.
  prefs: []
  type: TYPE_NORMAL
- en: Glass-box test suites are usually much easier to construct than black-box test
    suites. Specifications, including many in this book, are usually incomplete and
    often pretty sloppy, making it a challenge to estimate how thoroughly a black-box
    test suite explores the space of interesting inputs. In contrast, the notion of
    a path through code is well defined, and it is relatively easy to evaluate how
    thoroughly one is exploring the space. There are, in fact, commercial tools that
    can be used to objectively measure the completeness of glass-box tests.
  prefs: []
  type: TYPE_NORMAL
- en: A glass-box test suite is **path-complete** if it exercises every potential
    path through the program. This is typically impossible to achieve, because it
    depends upon the number of times each loop is executed and the depth of each recursion.
    For example, a recursive implementation of factorial follows a different path
    for each possible input (because the number of levels of recursion will differ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, even a path-complete test suite does not guarantee that all bugs
    will be exposed. Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The specification suggests that there are two possible cases: `x` either is
    negative or it isn''t. This suggests that the set of inputs `{2, -2}` is sufficient
    to explore all paths in the specification. This test suite has the additional
    nice property of forcing the program through all of its paths, so it looks like
    a complete glass-box suite as well. The only problem is that this test suite will
    not expose the fact that `abs(-1)` will return `-1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the limitations of glass-box testing, a few rules of thumb are usually
    worth following:'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise both branches of all `if` statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that each `except` clause (see Chapter 9) is executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each `for` loop, have test cases in which
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ The loop is not entered (e.g., if the loop is iterating over the elements
    of a list, make sure that it is tested on the empty list).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ The body of the loop is executed exactly once.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ The body of the loop is executed more than once.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For each `while` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ Look at the same kinds of cases as when dealing with `for` loops.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ Include test cases corresponding to all possible ways of exiting the loop.
    For example, for a loop starting with
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while len(L) > 0 and not L[i] == e`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: find cases where the loop exits because `len(L)` is greater than zero and cases
    where it exits because `L[i] == e`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For recursive functions, include test cases that cause the function to return
    with no recursive calls, exactly one recursive call, and more than one recursive
    call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.1.3 Conducting Tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Testing is often thought of as occurring in two phases. One should always start
    with **unit testing**. During this phase, testers construct and run tests designed
    to ascertain whether individual units of code (e.g., functions) work properly.
    This is followed by **integration testing**, which is designed to ascertain whether
    groups of units function properly when combined. Finally, **functional testing**
    is used to check if the program as a whole behaves as intended. In practice, testers
    cycle through these phases, since failures during integration or functional testing
    lead to making changes to individual units.
  prefs: []
  type: TYPE_NORMAL
- en: Functional testing is almost always the most challenging phase. The intended
    behavior of an entire program is considerably harder to characterize than the
    intended behavior of each of its parts. For example, characterizing the intended
    behavior of a word processor is considerably more challenging than characterizing
    the behavior of the subsystem that counts the number of characters in a document.
    Problems of scale can also make functional testing difficult. It is not unusual
    for functional tests to take hours or even days to run.
  prefs: []
  type: TYPE_NORMAL
- en: Many industrial software development organizations have a **software quality
    assurance (SQA)** group that is separate from the group charged with implementing
    the software. The mission of an SQA group is to ensure that before the software
    is released, it is suitable for its intended purpose. In some organizations the
    development group is responsible for unit testing and the QA group for integration
    and functional testing.
  prefs: []
  type: TYPE_NORMAL
- en: In industry, the testing process is often highly automated. Testers[^(51)](#c8-fn-0003)
    do not sit at terminals typing inputs and checking outputs. Instead, they use
    **test drivers** that autonomously
  prefs: []
  type: TYPE_NORMAL
- en: Set up the environment needed to invoke the program (or units) to test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke the program (or units) to test with a predefined or automatically generated
    sequence of inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the results of these invocations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the acceptability of test results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepare an appropriate report.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During unit testing, we often need to build **stubs** as well as drivers. Drivers
    simulate parts of the program that use the unit being tested, whereas stubs simulate
    parts of the program used by the unit being tested. Stubs are useful because they
    allow people to test units that depend upon software or sometimes even hardware
    that does not yet exist. This allows teams of programmers to simultaneously develop
    and test multiple parts of a system.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, a stub should
  prefs: []
  type: TYPE_NORMAL
- en: Check the reasonableness of the environment and arguments supplied by the caller
    (calling a function with inappropriate arguments is a common error).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify arguments and global variables in a manner consistent with the specification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return values consistent with the specification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building adequate stubs is often a challenge. If the unit the stub replaces
    is intended to perform some complex task, building a stub that performs actions
    consistent with the specification may be tantamount to writing the program that
    the stub is designed to replace. One way to surmount this problem is to limit
    the set of arguments accepted by the stub, and create a table that contains the
    values to return for each combination of arguments to be used in the test suite.
  prefs: []
  type: TYPE_NORMAL
- en: One attraction of automating the testing process is that it facilitates **regression
    testing**. As programmers attempt to debug a program, it is all too common to
    install a “fix” that breaks something, or maybe many things, that used to work.
    Whenever any change is made, no matter how small, you should check that the program
    still passes all of the tests that it used to pass.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a charming urban legend about how the process of fixing flaws in software
    came to be known as debugging. The photo in [Figure 8-2](#c8-fig-0002) is of a
    page, from September 9, 1947, in a laboratory book from the group working on the
    Mark II Aiken Relay Calculator at Harvard University. Notice the moth taped to
    the page and the phrase “First actual case of bug being found” below it.
  prefs: []
  type: TYPE_NORMAL
- en: '![c8-fig-0002.jpg](../images/c8-fig-0002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 8-2](#c8-fig-0002a) Not the first bug'
  prefs: []
  type: TYPE_NORMAL
- en: Some have claimed that the discovery of that unfortunate moth trapped in the
    Mark II led to the use of the phrase debugging. However the wording, “First actual
    case of a bug being found,” suggests that a less literal interpretation of the
    phrase was already common. Grace Murray Hopper,[^(52)](#c8-fn-0004) a leader of
    the Mark II project, made it clear that the term “bug” was already in wide use
    to describe problems with electronic systems during World War II. And well prior
    to that, *Hawkins’ New Catechism of Electricity*, an 1896 electrical handbook,
    included the entry, “The term ‘bug’ is used to a limited extent to designate any
    fault or trouble in the connections or working of electric apparatus.” In English
    usage the word “bugbear” means “anything causing seemingly needless or excessive
    fear or anxiety.” [^(53)](#c8-fn-0005) Shakespeare seems to have shortened this
    to “bug” when he had Hamlet kvetch about “bugs and goblins in my life.”
  prefs: []
  type: TYPE_NORMAL
- en: The use of the word “**bug**” sometimes leads people to ignore the fundamental
    fact that if you wrote a program and it has a “bug,” you messed up. Bugs do not
    crawl unbidden into flawless programs. If your program has a bug, it is because
    you put it there. Bugs do not breed in programs. If your program has multiple
    bugs, it is because you made multiple mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Runtime bugs can be categorized along two dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overt → covert**: An **overt bug** has an obvious manifestation, e.g., the
    program crashes or takes far longer (maybe forever) to run than it should. A **covert
    bug** has no obvious manifestation. The program may run to conclusion with no
    problem—other than providing an incorrect answer. Many bugs fall between the two
    extremes, and whether the bug is overt can depend upon how carefully you examine
    the behavior of the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent → intermittent**: A **persistent bug** occurs every time the program
    is run with the same inputs. An **intermittent bug** occurs only some of the time,
    even when the program is run on the same inputs and seemingly under the same conditions.
    When we get to Chapter 16, we will look at programs that model situations in which
    randomness plays a role. In programs of that kind, intermittent bugs are common.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best kind of bugs to have are overt and persistent. Developers can be under
    no illusion about the advisability of deploying the program. And if someone else
    is foolish enough to attempt to use it, they will quickly discover their folly.
    Perhaps the program will do something horrible before crashing, e.g., delete files,
    but at least the user will have reason to be worried (if not panicked). Good programmers
    try to write their programs in such a way that programming mistakes lead to bugs
    that are both overt and persistent. This is often called **defensive programming**.
  prefs: []
  type: TYPE_NORMAL
- en: The next step into the pit of undesirability is bugs that are overt but intermittent.
    An air traffic control system that computes the correct location for planes almost
    all the time would be far more dangerous than one that makes obvious mistakes
    all the time. One can live in a fool's paradise for a period of time, and maybe
    get so far as deploying a system incorporating the flawed program, but sooner
    or later the bug will become manifest. If the conditions prompting the bug to
    become manifest are easily reproducible, it is often relatively easy to track
    down and repair the problem. If the conditions provoking the bug are not clear,
    life is much harder.
  prefs: []
  type: TYPE_NORMAL
- en: Programs that fail in covert ways are often highly dangerous. Since they are
    not apparently problematical, people use them and trust them to do the right thing.
    Increasingly, society relies on software to perform critical computations that
    are beyond the ability of humans to carry out or even check for correctness. Therefore,
    a program can provide an undetected fallacious answer for long periods of time.
    Such programs can, and have, caused a lot of damage.[^(54)](#c8-fn-0006) A program
    that evaluates the risk of a mortgage bond portfolio and confidently spits out
    the wrong answer can get a bank (and perhaps all of society) into a lot of trouble.
    Software in a flight management computer can make the difference between an aircraft
    remaining airborne or not.[^(55)](#c8-fn-0007) A radiation therapy machine that
    delivers a little more or a little less radiation than intended can be the difference
    between life and death for a person with cancer. A program that makes a covert
    error only occasionally may or may not wreak less havoc than one that always commits
    such an error. Bugs that are both covert and intermittent are almost always the
    hardest to find and fix.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1 Learning to Debug
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Debugging is a learned skill. Nobody does it well instinctively. The good news
    is that it's not hard to learn, and it is a transferable skill. The same skills
    used to debug software can be used to find out what is wrong with other complex
    systems, e.g., laboratory experiments or sick humans.
  prefs: []
  type: TYPE_NORMAL
- en: For at least four decades people have been building tools called **debuggers**,
    and debugging tools are built into all of the popular Python IDEs. (If you haven't
    already, give the debugging tool in Spyder a try.) These tools can help. But what's
    much more important is how you approach the problem. Many experienced programmers
    don't even bother with debugging tools, relying instead on the `print` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging starts when testing has demonstrated that the program behaves in undesirable
    ways. Debugging is the process of searching for an explanation of that behavior.
    The key to being consistently good at debugging is being systematic in conducting
    that search.
  prefs: []
  type: TYPE_NORMAL
- en: Start by studying the available data. This includes the test results and the
    program text. Study all of the test results. Examine not only the tests that revealed
    the presence of a problem, but also those tests that seemed to work perfectly.
    Trying to understand why one test worked and another did not is often illuminating.
    When looking at the program text, keep in mind that you don't completely understand
    it. If you did, there probably wouldn't be a bug.
  prefs: []
  type: TYPE_NORMAL
- en: Next, form a hypothesis that you believe to be consistent with all the data.
    The hypothesis could be as narrow as “if I change line 403 from `x < y` to `x
    <= y`, the problem will go away” or as broad as “my program is not working because
    I forgot about the possibility of aliasing in multiple places.”
  prefs: []
  type: TYPE_NORMAL
- en: Next, design and run a repeatable experiment with the potential to refute the
    hypothesis. For example, you might put a print statement before and after each
    loop. If these are always paired, then the hypothesis that a loop is causing nontermination
    has been refuted. Decide before running the experiment how you would interpret
    various possible results. All humans are subject to what psychologists call **confirmation
    bias**—we interpret information in a way that reinforces what we want to believe.
    If you wait until after you run the experiment to think about what the results
    should be, you are more likely to fall prey to wishful thinking.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, keep a record of what experiments you have tried. When you've spent
    many hours changing your code trying to track down an elusive bug, it's easy to
    forget what you have already tried. If you aren't careful, you can waste way too
    many hours trying the same experiment (or more likely an experiment that looks
    different but will give you the same information) over and over again. Remember,
    as many have said, “insanity is doing the same thing, over and over again, but
    expecting different results.” [^(56)](#c8-fn-0008)
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.2 Designing the Experiment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Think of debugging as a search process, and each experiment as an attempt to
    reduce the size of the search space. One way to reduce the size of the search
    space is to design an experiment that can be used to decide whether a specific
    region of code is responsible for a problem uncovered during testing. Another
    way to reduce the search space is to reduce the amount of test data needed to
    provoke a manifestation of a bug.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a contrived example to see how you might go about debugging it.
    Imagine that you wrote the palindrome-checking code in [Figure 8-3](#c8-fig-0003).
  prefs: []
  type: TYPE_NORMAL
- en: '![c8-fig-0003.jpg](../images/c8-fig-0003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 8-3](#c8-fig-0003a) Program with bugs'
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that you are so confident of your programming skills that you put
    this code up on the web—without testing it. Suppose further that you receive an
    email saying, “I tested your !!**! program by entering the 3,116,480 letters in
    the *Bible*, and your program printed `Yes`. Yet any fool can see that the *Bible*
    is not a palindrome. Fix it! (Your program, not the *Bible*.)”
  prefs: []
  type: TYPE_NORMAL
- en: You could try and test it on the *Bible*. But it might be more sensible to begin
    by trying it on something smaller. In fact, it would make sense to test it on
    a minimal non-palindrome, e.g.,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The good news is that it fails even this simple test, so you don't have to type
    in millions of characters. The bad news is that you have no idea why it failed.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the code is small enough that you can probably stare at it and
    find the bug (or bugs). However, let's pretend that it is too large to do this,
    and start to systematically reduce the search space.
  prefs: []
  type: TYPE_NORMAL
- en: Often the best way to do this is to conduct a **bisection search**. Find some
    point about halfway through the code, and devise an experiment that will allow
    you to decide if there is a problem before that point that might be related to
    the symptom. (Of course, there may be problems after that point as well, but it
    is usually best to hunt down one problem at a time.) In choosing such a point,
    look for a place where some easily examined intermediate values provide useful
    information. If an intermediate value is not what you expected, there is probably
    a problem that occurred prior to that point in the code. If the intermediate values
    all look fine, the bug probably lies somewhere later in the code. This process
    can be repeated until you have narrowed the region in which a problem is located
    to a few lines of code, or a few units if you are testing a large system.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at `silly`, the halfway point is around the line `if is_pal(result)`.
    The obvious thing to check is whether `result` has the expected value, `['a',
    'b']`. We check this by inserting the statement `print(result)` before the `if`
    statement in `silly`. When the experiment is run, the program prints `['b']`,suggesting
    that something has already gone wrong. The next step is to print the value `result`
    roughly halfway through the loop. This quickly reveals that `result` is never
    more than one element long, suggesting that the initialization of `result` needs
    to be moved outside the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: The “corrected” code for `silly` is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's try that, and see if `result` has the correct value after the `for` loop.
    It does, but unfortunately the program still prints `Yes`. Now, we have reason
    to believe that a second bug lies below the `print` statement. So, let's look
    at `is_pal`. Insert the line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: before the `return` statement. When we run the code, we see that `temp` has
    the expected value, but `x` does not. Moving up the code, we insert a `print`
    statement after the line of code `temp = x`, and discover that both `temp` and
    `x` have the value `['a', 'b']`. A quick inspection of the code reveals that in
    `is_pal` we wrote `temp.reverse` rather than `temp.reverse()`—the evaluation of
    `temp.reverse` returns the built-in `reverse` method for lists, but does not invoke
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We run the test again, and now it seems that both `temp` and `x` have the value
    `[''b'',''a'']`. We have now narrowed the bug to one line. It seems that `temp.reverse()`
    unexpectedly changed the value of `x`. An aliasing bug has bitten us: `temp` and
    `x` are names for the same list, both before and after the list gets reversed.
    One way to fix the bug is to replace the first assignment statement in `is_pal`
    by `temp = x[:]`, which makes a copy of `x`.'
  prefs: []
  type: TYPE_NORMAL
- en: The corrected version of `is_pal` is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 8.2.3 When the Going Gets Tough
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Joseph P. Kennedy, father of U.S. President John F. Kennedy, reputedly instructed
    his children, “When the going gets tough, the tough get going.” [^(57)](#c8-fn-0009)
    But he never debugged a piece of software. This subsection contains a few pragmatic
    hints about what to do when the debugging gets tough.
  prefs: []
  type: TYPE_NORMAL
- en: '*Look for the usual suspects*. Have you'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ Passed arguments to a function in the wrong order?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ Misspelled a name, e.g., typed a lowercase letter when you should have typed
    an uppercase one?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ Failed to reinitialize a variable?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ Tested that two-floating point values are equal (`==`) instead of nearly equal
    (remember that floating-point arithmetic is not the same as the arithmetic you
    learned in school)?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ Tested for value equality (e.g., compared two lists by writing the expression
    `L1 == L2`) when you meant to test for object equality (e.g., `id(L1) == id(L2))`?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ Forgotten that some built-in function has a side effect?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ Forgotten the `()` that turns a reference to an object of type `function`
    into a function invocation?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ Created an unintentional alias?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ Made any other mistake that is typical for you?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Stop asking yourself why the program isn''t doing what you want it to. Instead,
    ask yourself why it is doing what it is.* That should be an easier question to
    answer, and will probably be a good first step in figuring out how to fix the
    program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Keep in mind that the bug is probably not where you think it is.* If it were,
    you would have found it long ago. One practical way to decide where to look is
    asking where the bug cannot be. As Sherlock Holmes said, “Eliminate all other
    factors, and the one which remains must be the truth.” [^(58)](#c8-fn-0010)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Try to explain the problem to somebody else.* We all develop blind spots.
    Merely attempting to explain the problem to someone will often lead you to see
    things you have missed. You can also try to explain why the bug cannot be in certain
    places.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Don''t believe everything you read.*[*^(59)*](#c8-fn-0011) In particular,
    don''t believe the documentation. The code may not be doing what the comments
    suggest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Stop debugging and start writing documentation.* This will help you approach
    the problem from a different perspective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Walk away and try again tomorrow*. This may mean that bug is fixed later than
    if you had stuck with it, but you will probably spend less of your time looking
    for it. That is, it is possible to trade latency for efficiency. (Students, this
    is an excellent reason to start work on programming problem sets earlier rather
    than later!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.2.4 When You Have Found “The” Bug
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you think you have found a bug in your code, the temptation to start coding
    and testing a fix is almost irresistible. It is often better, however, to pause.
    Remember that the goal is not to fix one bug, but to move rapidly and efficiently
    towards a bug-free program.
  prefs: []
  type: TYPE_NORMAL
- en: Ask yourself if this bug explains all the observed symptoms, or whether it is
    just the tip of the iceberg. If the latter, it may be better to take care of the
    bug in concert with other changes. Suppose, for example, that you have discovered
    that the bug is the result of accidentally mutating a list. You could circumvent
    the problem locally, perhaps by making a copy of the list. Alternatively, you
    could consider using a tuple instead of a list (since tuples are immutable), perhaps
    eliminating similar bugs elsewhere in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Before making any change, try and understand the ramification of the proposed
    “fix.” Will it break something else? Does it introduce excessive complexity? Does
    it offer the opportunity to tidy up other parts of the code?
  prefs: []
  type: TYPE_NORMAL
- en: Always make sure that you can get back to where you are. Nothing is more frustrating
    than realizing that a long series of changes have left you farther from the goal
    than when you started, and having no way to get back to your starting point. Disk
    space is usually plentiful. Use it to store old versions of your program.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if there are many unexplained errors, you might consider whether finding
    and fixing bugs one at a time is even the right approach. Maybe you would be better
    off thinking about a better way to organize your program or maybe a simpler algorithm
    that will be easier to implement correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 Terms Introduced in Chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: test suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: partition of inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: glass-box testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: black-box testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: path-complete testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: functional testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: software quality assurance (SQA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: test driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: test stub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: regression testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: bug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: overt bug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: covert bug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: persistent bug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: intermittent bug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defensive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: debuggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: confirmation bias
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: bisection search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
