- en: 32Â GlossaryğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/glossary.html](https://dcic-world.org/2025-08-27/glossary.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: â˜ bandwidth
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The bandwidth between two network nodes is the quantity of data that can be
    transferred in a unit of time between the nodes.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: â˜ cache
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'A cache is an instance of a [â˜› space-time tradeoff](#%28elem._glossary-space-time._tradeoff%29):
    it trades space for time by using the space to avoid recomputing an answer. The
    act of using a cache is called caching. The word â€œcacheâ€ is often used loosely;
    we use it only for information that can be perfectly reconstructed even if it
    were lost: this enables a program that needs to reverse the tradeâ€”<wbr>i.e., use
    less space in return for more timeâ€”<wbr>to do so safely, knowing it will lose
    no information and thus not sacrifice correctness.'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: â˜ coinduction
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Coinduction is a proof principle for mathematical structures that are equipped
    with methods of observation rather than of construction. Conversely, functions
    over inductive data take them apart; functions over coinductive data construct
    them. The [classic tutorial](http://www.cs.ru.nl/~bart/PAPERS/JR.pdf) on the topic
    will be useful to mathematically sophisticated readers.
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: â˜ idempotence
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: An idempotent operator is one whose repeated application to any value in its
    domain yields the same result as a single application (note that this implies
    the range is a subset of the domain). Thus, a function \(f\) is idempotent if,
    for all \(x\) in its domain, \(f(f(x)) = f(x)\) (and by induction this holds for
    additional applications of \(f\)).
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: â˜ invariants
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Invariants are assertions about programs that are intended to always be true
    (â€œin-vary-antâ€â€”<wbr>never varying). For instance, a sorting routine may have as
    an invariant that the list it returns is sorted.
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: â˜ latency
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The latency between two network nodes is the time it takes for packets to go
    between the nodes.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: â˜ metasyntactic variable
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: A metasyntactic variable is one that lives outside the language, and ranges
    over a fragment of syntax. For instance, if we write â€œfor expressions `e1` and
    `e2`, the sum `e1 + e2`â€, we do not mean the programmer literally wrote â€œ`e1`â€
    in the program; rather we are using `e1` to refer to whatever the programmer might
    write on the left of the addition sign. Therefore, `e1` is metasyntax.
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: â˜ packed representation
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: At the machine level, a packed representation is one that ignores traditional
    alignment boundaries (in older or smaller machines, bytes; on most contemporary
    machines, words) to let multiple values fit inside or even spill over the boundary.
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For instance, say we wish to store a vector of four values, each of which represents
    one of four options. A traditional representation would store one value per alignment
    boundary, thereby consuming four units of memory. A packed representation would
    recognize that each value requires two bits, and four of them can fit into eight
    bits, so a single byte can hold all four values. Suppose instead we wished to
    store four values representing five options each, therefore requiring three bits
    for each value. A byte- or word-aligned representation would not fundamentally
    change, but the packed representation would use two bytes to store the twelve
    bits, even permitting the third valueâ€™s three bits to be split across a byte boundary.
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬å¸Œæœ›å­˜å‚¨ä¸€ä¸ªåŒ…å«å››ä¸ªå€¼çš„å‘é‡ï¼Œæ¯ä¸ªå€¼ä»£è¡¨å››ä¸ªé€‰é¡¹ä¸­çš„ä¸€ä¸ªã€‚ä¼ ç»Ÿçš„è¡¨ç¤ºæ–¹æ³•ä¼šä¸ºæ¯ä¸ªå¯¹é½è¾¹ç•Œå­˜å‚¨ä¸€ä¸ªå€¼ï¼Œä»è€Œæ¶ˆè€—å››ä¸ªå†…å­˜å•ä½ã€‚å‹ç¼©è¡¨ç¤ºæ–¹æ³•ä¼šè®¤è¯†åˆ°æ¯ä¸ªå€¼éœ€è¦ä¸¤ä¸ªä½ï¼Œå››ä¸ªå€¼å¯ä»¥æ”¾å…¥å…«ä¸ªä½ä¸­ï¼Œå› æ­¤ä¸€ä¸ªå­—èŠ‚å¯ä»¥å­˜å‚¨æ‰€æœ‰å››ä¸ªå€¼ã€‚å‡è®¾æˆ‘ä»¬å¸Œæœ›å­˜å‚¨ä»£è¡¨äº”ä¸ªé€‰é¡¹çš„å››ä¸ªå€¼ï¼Œå› æ­¤æ¯ä¸ªå€¼éœ€è¦ä¸‰ä¸ªä½ã€‚å­—èŠ‚æˆ–å­—å¯¹é½çš„è¡¨ç¤ºæ–¹æ³•åœ¨æœ¬è´¨ä¸Šä¸ä¼šæ”¹å˜ï¼Œä½†å‹ç¼©è¡¨ç¤ºæ–¹æ³•å°†ä½¿ç”¨ä¸¤ä¸ªå­—èŠ‚æ¥å­˜å‚¨åäºŒä¸ªä½ï¼Œç”šè‡³å…è®¸ç¬¬ä¸‰ä¸ªå€¼çš„ä¸‰ä¸ªä½è·¨è¶Šä¸€ä¸ªå­—èŠ‚è¾¹ç•Œã€‚
- en: ''
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Of course, packed representations have a cost. Extracting the values requires
    more careful and complex operations. Thus, they represent a classic [â˜› space-time
    tradeoff](#%28elem._glossary-space-time._tradeoff%29): using more time to shrink
    space consumption. More subtly, packed representations can confound certain run-time
    systems that may have expected data to be aligned.'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œå‹ç¼©è¡¨ç¤ºæ–¹æ³•æ˜¯æœ‰ä»£ä»·çš„ã€‚æå–å€¼éœ€è¦æ›´ä»”ç»†å’Œå¤æ‚çš„æ“ä½œã€‚å› æ­¤ï¼Œå®ƒä»¬ä»£è¡¨äº†ä¸€ä¸ªç»å…¸çš„[â˜›ç©ºé—´-æ—¶é—´æƒè¡¡](#%28elem._glossary-space-time._tradeoff%29)ï¼šä½¿ç”¨æ›´å¤šçš„æ—¶é—´æ¥å‡å°‘ç©ºé—´æ¶ˆè€—ã€‚æ›´å¾®å¦™çš„æ˜¯ï¼Œå‹ç¼©è¡¨ç¤ºå¯èƒ½ä¼šä½¿æŸäº›è¿è¡Œæ—¶ç³»ç»Ÿæ„Ÿåˆ°å›°æƒ‘ï¼Œè¿™äº›ç³»ç»Ÿå¯èƒ½æœŸæœ›æ•°æ®æ˜¯å¯¹é½çš„ã€‚
- en: â˜ parsing
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: â˜è§£æ
- en: 'Parsing is, very broadly speaking, the act of converting content in one kind
    of structured input into content in another. The structures could be very similar,
    but usually they are quite different. Often, the input format is simple while
    the output format is expected to capture rich information about the content of
    the input. For instance, the input might be a linear sequence of characters on
    an input stream, and the output might be expected to be rich and tree-structured
    according to some datatype: most program and natural-language parsers are faced
    with this task.'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è§£æï¼Œéå¸¸å¹¿æ³›åœ°è¯´ï¼Œæ˜¯å°†ä¸€ç§ç»“æ„åŒ–è¾“å…¥çš„å†…å®¹è½¬æ¢ä¸ºå¦ä¸€ç§å†…å®¹çš„è¡Œä¸ºã€‚è¿™äº›ç»“æ„å¯èƒ½éå¸¸ç›¸ä¼¼ï¼Œä½†é€šå¸¸å®ƒä»¬ç›¸å½“ä¸åŒã€‚é€šå¸¸ï¼Œè¾“å…¥æ ¼å¼å¾ˆç®€å•ï¼Œè€Œè¾“å‡ºæ ¼å¼é¢„è®¡ä¼šæ•è·æœ‰å…³è¾“å…¥å†…å®¹çš„ä¸°å¯Œä¿¡æ¯ã€‚ä¾‹å¦‚ï¼Œè¾“å…¥å¯èƒ½æ˜¯ä¸€ä¸ªè¾“å…¥æµä¸Šçš„å­—ç¬¦çš„çº¿æ€§åºåˆ—ï¼Œè€Œè¾“å‡ºå¯èƒ½é¢„è®¡æ˜¯ä¸°å¯Œä¸”æ ‘çŠ¶ç»“æ„ï¼Œæ ¹æ®æŸäº›æ•°æ®ç±»å‹ï¼šå¤§å¤šæ•°ç¨‹åºå’Œè‡ªç„¶è¯­è¨€è§£æå™¨éƒ½é¢ä¸´è¿™ä¸ªä»»åŠ¡ã€‚
- en: â˜ reduction
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: â˜å‡å°‘
- en: Reduction is a relationship between a pair of situationsâ€”<wbr>problems, functions,
    data structures, etc.â€”<wbr>where one is defined in terms of the other. A reduction
    R is a function from situations of the form P to ones of the form Q if, for every
    instance of P, R can construct an instance of Q such that it preserves the meaning
    of P. Note that the converse strictly does not need to hold.
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‡å°‘æ˜¯ä¸¤ä¸ªæƒ…å†µâ€”â€”é—®é¢˜ã€å‡½æ•°ã€æ•°æ®ç»“æ„ç­‰â€”â€”ä¹‹é—´çš„å…³ç³»ï¼Œå…¶ä¸­ä¸€ä¸ªå®šä¹‰ä¸ºå¦ä¸€ä¸ªã€‚å¦‚æœå¯¹äºæ¯ä¸ªPçš„æƒ…å†µï¼ŒRå¯ä»¥æ„é€ ä¸€ä¸ªQçš„æƒ…å†µï¼Œå¹¶ä¸”å®ƒä¿ç•™äº†Pçš„æ„ä¹‰ï¼Œé‚£ä¹ˆRæ˜¯ä»å½¢å¼ä¸ºPçš„æƒ…å†µåˆ°å½¢å¼ä¸ºQçš„æƒ…å†µçš„å‡½æ•°ã€‚æ³¨æ„ï¼Œé€†å‘½é¢˜ä¸¥æ ¼æ¥è¯´å¹¶ä¸éœ€è¦æˆç«‹ã€‚
- en: â˜ space-time tradeoff
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: â˜ç©ºé—´-æ—¶é—´æƒè¡¡
- en: 'Suppose you have an expensive computation that always produces the same answer
    for a given set of inputs. Once you have computed the answer once, you now have
    a choice: store the answer so that you can simply look it up when you need it
    again, or throw it away and re-compute it the next time. The former uses more
    space, but saves time; the latter uses less space, but consumes more time. This,
    at its heart, is the space-time tradeoff. Memoization [[Avoiding Recomputation
    by Remembering Answers](avoid-recomp.html)] and using a [â˜› cache](#%28elem._glossary-cache%29)
    are both instances of it.'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‡è®¾ä½ æœ‰ä¸€ä¸ªæ˜‚è´µçš„è®¡ç®—ï¼Œå¯¹äºç»™å®šçš„è¾“å…¥é›†æ€»æ˜¯äº§ç”Ÿç›¸åŒçš„ç­”æ¡ˆã€‚ä¸€æ—¦ä½ è®¡ç®—å‡ºäº†ç­”æ¡ˆï¼Œä½ ç°åœ¨æœ‰ä¸€ä¸ªé€‰æ‹©ï¼šå°†ç­”æ¡ˆå­˜å‚¨èµ·æ¥ï¼Œä»¥ä¾¿åœ¨éœ€è¦æ—¶å¯ä»¥ç®€å•åœ°æŸ¥æ‰¾ï¼Œæˆ–è€…ä¸¢å¼ƒå®ƒå¹¶åœ¨ä¸‹ä¸€æ¬¡é‡æ–°è®¡ç®—ã€‚å‰è€…ä½¿ç”¨æ›´å¤šçš„ç©ºé—´ï¼Œä½†èŠ‚çœæ—¶é—´ï¼›åè€…ä½¿ç”¨è¾ƒå°‘çš„ç©ºé—´ï¼Œä½†æ¶ˆè€—æ›´å¤šçš„æ—¶é—´ã€‚ä»æ ¹æœ¬ä¸Šè¯´ï¼Œè¿™æ˜¯ç©ºé—´-æ—¶é—´æƒè¡¡ã€‚è®°å¿†åŒ–ï¼ˆ[é¿å…é‡å¤è®¡ç®—é€šè¿‡è®°ä½ç­”æ¡ˆ](avoid-recomp.html)ï¼‰å’Œä½¿ç”¨[â˜›ç¼“å­˜](#%28elem._glossary-cache%29)éƒ½æ˜¯å®ƒçš„å®ä¾‹ã€‚
- en: â˜ type variable
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: â˜ç±»å‹å˜é‡
- en: Type variables are identifiers in the type language that (usually) range over
    actual types.
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç±»å‹å˜é‡æ˜¯ç±»å‹è¯­è¨€ä¸­çš„æ ‡è¯†ç¬¦ï¼Œé€šå¸¸è¦†ç›–å®é™…ç±»å‹ã€‚
- en: â˜ wire format
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: â˜çº¿æ ¼å¼
- en: A notation used to transmit data across, as opposed to within, a closed platform
    (such as a virtual machine). These are usually expected to be relatively simple
    because they must be implemented in many languages and on weak processes. They
    are also expected to be unambiguous to aid simple, fast, and correct parsing.
    Popular examples include XML, JSON, and s-expressions.
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç”¨äºåœ¨å°é—­å¹³å°ï¼ˆå¦‚è™šæ‹Ÿæœºï¼‰ä¹‹å¤–ä¼ è¾“æ•°æ®çš„ç¬¦å·ï¼Œä¸åœ¨å¹³å°å†…éƒ¨ä¼ è¾“çš„ç¬¦å·ç›¸å¯¹ã€‚è¿™äº›ç¬¦å·é€šå¸¸é¢„æœŸç›¸å¯¹ç®€å•ï¼Œå› ä¸ºå®ƒä»¬å¿…é¡»ç”¨å¤šç§è¯­è¨€å’Œå¼±å¤„ç†è¿‡ç¨‹å®ç°ã€‚å®ƒä»¬è¿˜é¢„æœŸæ˜¯æ˜ç¡®çš„ï¼Œä»¥å¸®åŠ©ç®€å•ã€å¿«é€Ÿå’Œæ­£ç¡®åœ°è§£æã€‚æµè¡Œçš„ä¾‹å­åŒ…æ‹¬XMLã€JSONå’Œsè¡¨è¾¾å¼ã€‚
