<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>13.1Â Mutating VariablesğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>13.1Â Mutating VariablesğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/mutating-variables.html">https://dcic-world.org/2025-08-27/mutating-variables.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._mutating-vars-memory%29" class="toclink" data-pltdoc="x">13.1.1Â Mutating Variables in Memory</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._var-mut-aliasing%29" class="toclink" data-pltdoc="x">13.1.2Â Variable Mutation and Aliasing</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Mutating_.Variables_versus_.Mutating_.Data_.Fields%29" class="toclink" data-pltdoc="x">13.1.3Â Mutating Variables versus Mutating Data Fields</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Mutating_.Parameters_in_.Function_.Calls%29" class="toclink" data-pltdoc="x">13.1.4Â Mutating Parameters in Function Calls</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._mut-top-level-vars-in-func%29" class="toclink" data-pltdoc="x">13.1.5Â Mutating Top-Level Variables within Functions</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.The_.Many_.Roles_of_.Variables%29" class="toclink" data-pltdoc="x">13.1.6Â The Many Roles of Variables</a></p></td></tr></table><section class="SsectionLevel4" id="section 13.1.1"><h4 class="heading">13.1.1Â <a name="(part._mutating-vars-memory)"/>Mutating Variables in Memory<a href="#(part._mutating-vars-memory)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Now that we have introduced the idea of the heap, letâ€™s revisit our
use of a variable to compute the sum of elements in a list. Here again
is the code we wrote for this earlier (in <a href="intro-python.html#%28part._python-for-loops%29" data-pltdoc="x">Introducing <code data-lang="text/x-python" class="sourceCode">For</code> Loops</a>):</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
for num in [5, 1, 7, 3]:
   run_total = run_total + num</code></pre><p>Letâ€™s see how the directory and heap update as we run this code.  In
<a href="mutating-structures.html#%28part._basic-data-heap%29" data-pltdoc="x">Basic Data and the Heap</a>, we pointed out that basic data (such as
numbers, strings, and booleans) donâ€™t get put in the heap because they
have no internal structure. Those values are stored in the directory
itself. Therefore, the initial value for <code data-lang="text/x-python" class="sourceCode">run_total</code> is stored
within the directory.</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">0</code></pre></li></ul><p>The <code data-lang="text/x-python" class="sourceCode">for</code> loop also sets up a directory entry, this time for
the variable <code data-lang="text/x-python" class="sourceCode">num</code> that is used to refer to the list
elements. When the loop starts, <code data-lang="text/x-python" class="sourceCode">num</code> takes on the first value
in the list. Thus, the directory appears as:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">0</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">5</code></pre></li></ul><p>Inside the <code data-lang="text/x-python" class="sourceCode">for</code> loop, we compute a new value for
<code data-lang="text/x-python" class="sourceCode">run_total</code>. The use of <code data-lang="text/x-python" class="sourceCode">=</code> tells Python to modify the
value of <code data-lang="text/x-python" class="sourceCode">run_total</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Does this modification get made in the directory or the heap?</p></blockquote></blockquote><p>Since basic data values are stored only in the directory, this update
modifies the contents of the directory. The heap isnâ€™t involved:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">5</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">5</code></pre></li></ul><p>This process continues: Python advances <code data-lang="text/x-python" class="sourceCode">num</code> to the next list
element</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">5</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">1</code></pre></li></ul><p>then modifies the value of <code data-lang="text/x-python" class="sourceCode">run_total</code></p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">6</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">1</code></pre></li></ul><p>This process continues until all of the list elements have been
processed. When the for-loop ends, the directory contents are:
</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">16</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">3</code></pre></li></ul><p>There are two takeaways from this example:</p><ul><li><p>When we use <code data-lang="text/x-python" class="sourceCode">=</code> to update the value associated with a
variable, the variableâ€™s entry in the directory changes to reflect the
new value.</p></li><li><p><code data-lang="text/x-python" class="sourceCode">For</code> loops
introduce a name into the directory (the one the programmer chose to
refer to the individual list elements). As the loop progresses, Python
updates the value associated with that name to refer to each
successive element.</p></li></ul><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Draw the sequence of directory contents for the following program:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">score = 0
score = score + 4
score = 10</code></pre></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Draw the sequence of directory contents for the following program:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">count_long = 0
for word in ["here", "are", "some", "words"]:
  if len(word) &gt; 4:
    count_long = count_long + 1</code></pre></blockquote></blockquote></section><section class="SsectionLevel4" id="section 13.1.2"><h4 class="heading">13.1.2Â <a name="(part._var-mut-aliasing)"/>Variable Mutation and Aliasing<a href="#(part._var-mut-aliasing)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In <a href="mutating-structures.html" data-pltdoc="x">Mutating Structures</a>, we saw how a statement of the form
<code data-lang="text/x-python" class="sourceCode">elena.acct.balance = 500</code> resulted in a change to
<code data-lang="text/x-python" class="sourceCode">jorge.acct.balance</code>. Does this same effect occur if we update the
value of a variable directly, rather than a field? Consider the
following example:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">y = 5
x = y</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do the directory and heap look like after running this code?</p></blockquote></blockquote><p>Since <code data-lang="text/x-python" class="sourceCode">x</code> and <code data-lang="text/x-python" class="sourceCode">y</code> are assigned basic values, there are
no values in the heap:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">y</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">5</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">5</code></pre></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>If we now evaluate <code data-lang="text/x-python" class="sourceCode">y = 3</code>, does the value of <code data-lang="text/x-python" class="sourceCode">x</code>
change?</p></blockquote></blockquote><p>It does not. The value associated with <code data-lang="text/x-python" class="sourceCode">y</code> in the directory
changes, but there is no connection between <code data-lang="text/x-python" class="sourceCode">x</code> and <code data-lang="text/x-python" class="sourceCode">y</code>
in the directory. The statement <code data-lang="text/x-python" class="sourceCode">x = y</code> says â€œget the value of
<code data-lang="text/x-python" class="sourceCode">y</code> and associate it with <code data-lang="text/x-python" class="sourceCode">x</code> in the
directoryâ€. Immediately after this statement, <code data-lang="text/x-python" class="sourceCode">y</code> and
<code data-lang="text/x-python" class="sourceCode">x</code> refer to the same value, but this relationship is neither
tracked nor maintained. If we associate either variable with a new
value, as we do with <code data-lang="text/x-python" class="sourceCode">y = 3</code>, the directory entry for that
variableâ€”<wbr/>and only the directory entry for that variableâ€”<wbr/>are
changed to reflect the new value. Thus, the directory after we
evaluate <code data-lang="text/x-python" class="sourceCode">y = 3</code> appears as follows:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">y</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">3</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">5</code></pre></li></ul><p>This example highlights that aliasing occurs only when two variables
refer to the same piece of data with components, not when variables
refer to basic data. This is because data with components are stored
in the heap, with heap address stored in the directory. Note, though,
that uses of <code data-lang="text/x-python" class="sourceCode">varname = ...</code> still affect the directory, even
when the values are data with components.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>After running the following code, what is the value of <code data-lang="text/x-python" class="sourceCode">ac2.balance</code>?</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">ac1 = Account(8623, 600)
ac2 = ac1
ac1 = Account(8721, 350)</code></pre><p>Draw the directory and heap contents for this program and check your
prediction.</p></blockquote></blockquote><p>All three of these lines results in changes in the directory; the
first two result in changes in the heap, but only because we made new
pieces of data. <code data-lang="text/x-python" class="sourceCode">ac1</code> and <code data-lang="text/x-python" class="sourceCode">ac2</code> are alises immediately
after running the second line, but the third line breaks that
relationship.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>After running the following code, what is the value of <code data-lang="text/x-python" class="sourceCode">ac3.balance</code>?</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">savings = 475
ac3 = Account(8722, savings)
savings = 500</code></pre><p>Draw the directory and heap contents for this program and check your
prediction.</p></blockquote></blockquote><p>Since the value of <code data-lang="text/x-python" class="sourceCode">savings</code> is stored in <code data-lang="text/x-python" class="sourceCode">ac3.balance</code>,
and not the name <code data-lang="text/x-python" class="sourceCode">savings</code> itself, updating the value of
<code data-lang="text/x-python" class="sourceCode">savings</code> on the third line does not affect <code data-lang="text/x-python" class="sourceCode">ac3.balance</code>.</p></section><section class="SsectionLevel4" id="section 13.1.3"><h4 class="heading">13.1.3Â <a name="(part._.Mutating_.Variables_versus_.Mutating_.Data_.Fields)"/>Mutating Variables versus Mutating Data Fields<a href="#(part._.Mutating_.Variables_versus_.Mutating_.Data_.Fields)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Weâ€™ve now seen two different forms of updates in programs: updates to
fields of structured data in <a href="mutating-structures.html" data-pltdoc="x">Mutating Structures</a>, and updates to
the values associated with names when computing over lists with
<code data-lang="text/x-python" class="sourceCode">for</code> loops. At a quick glance, these two forms of update look
similar:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1.balance = acct1.balance - 50
run_total = run_total + fst</code></pre><p>Both use the <code data-lang="text/x-python" class="sourceCode">=</code> operator and compute a new value on the right
side. The left sides, however, are subtly different: one is a field
within structured data, while the other is a name in the directory. This
difference turns out to be significant: the first form changes a value
stored in the heap but leaves the directory unchanged, while the
second updates the directory but leaves the heap unchanged.</p><p>At this point, you might not appreciate why this difference is
significant. But for now, letâ€™s summarize how each of these forms
impacts each of the directory and the heap.</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Rules for updating the directory and the heap</p><blockquote class="StrategyBody"><p>Summarizing, the rules for how the directory and memory update are as follows:</p><ul><li><p>We add to the heap when a data constructor is used</p></li><li><p>We update the heap when a field of existing data is reassigned</p></li><li><p>We add to the directory when a name is used for the first time (this
includes parameters and internal variables when a function is called)</p></li><li><p>We update the directory when a name that is already in the
directory is subsequently assigned a new value)</p></li></ul></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>After running the following code, what is the value of <code data-lang="text/x-python" class="sourceCode">ac3.balance</code>?</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">ac2 = Account(8728, 200)
ac3 = ac2
print(ac3.balance)
ac2.balance = 500
print(ac3.balance)
ac2 = Account(8734, 350)
ac2.balance = 700
print(ac3.balance)</code></pre><p>Draw the directory and heap contents for this program and check your
prediction.</p></blockquote></blockquote><p>This example combines updates to variables and updates to fields. On
the third line, <code data-lang="text/x-python" class="sourceCode">ac2</code> and <code data-lang="text/x-python" class="sourceCode">ac3</code> refer to the same
address in the heap (which contains the <code data-lang="text/x-python" class="sourceCode">Account</code> with id
<code data-lang="text/x-python" class="sourceCode">8728</code>. Immediately after updating <code data-lang="text/x-python" class="sourceCode">ac2.balance</code> on the
fourth line, the balance in both <code data-lang="text/x-python" class="sourceCode">ac2</code> and <code data-lang="text/x-python" class="sourceCode">ac3</code> is 500. Line
six, however, creates a new <code data-lang="text/x-python" class="sourceCode">Account</code> in the heap and updates
the directory to have <code data-lang="text/x-python" class="sourceCode">ac2</code> refer to that new
<code data-lang="text/x-python" class="sourceCode">Account</code>. From that point on, <code data-lang="text/x-python" class="sourceCode">ac2</code> and <code data-lang="text/x-python" class="sourceCode">ac3</code>
refer to different accounts, so the update to the balance in
<code data-lang="text/x-python" class="sourceCode">ac2</code> on the seventh line does not affect <code data-lang="text/x-python" class="sourceCode">ac3</code>.</p><p>This example illustrates the subtleties and impacts of different uses of
<code data-lang="text/x-python" class="sourceCode">=</code>. Programs behave differently depending on whether the left
side of the <code data-lang="text/x-python" class="sourceCode">=</code> is a variable name or a field reference, and on
whether the right side is basic data or data with components. We will
continue to work with these various combinations to build your
understanding of when and how to use each one.</p></section><section class="SsectionLevel4" id="section 13.1.4"><h4 class="heading">13.1.4Â <a name="(part._.Mutating_.Parameters_in_.Function_.Calls)"/>Mutating Parameters in Function Calls<a href="#(part._.Mutating_.Parameters_in_.Function_.Calls)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In <a href="Conditionals_and_Booleans.html#%28part._func-comp-directory%29" data-pltdoc="x">Function Composition and the Directory</a>, we showed how
function calls create their own local directory segments to store any
names that get introduced while running the function. Now that we have
the ability to update the values associated with variables, we should
revisit this topic to understand what happens when these updates occur
within functions.</p><p>Consider the following two functions:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def add10(num: int):
  num = num + 10

def deposit10(ac: Account)
  ac.balance = ac.balance + 10</code></pre><p>Letâ€™s use these two functions in a program:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x = 15
a = Account(8435, 500)
add10(x)
deposit10(a)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What are the values of <code data-lang="text/x-python" class="sourceCode">x</code> and <code data-lang="text/x-python" class="sourceCode">a</code> when the program has
finished?</p></blockquote></blockquote><p>Letâ€™s draw out the directory and heap for this program.</p><p>We need a way to distinguish local directories from the
global one â€“ easiest for now might be to add a form for
local-env-with-heap that uses the label â€œLocal Directory (fun name)â€.</p><p>After the first two lines but before the function calls, we have the
following:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">15</code></p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a</code></pre><p>Â â†’Â 1014</p></li></ul><p>Heap</p><ul><li><p>1014:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8435, 500)</code></pre></li></ul><p>Calling <code data-lang="text/x-python" class="sourceCode">add10</code> creates a local directory containing the name
of the parameter:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">15</code></p></li></ul><p>Heap</p><ul><li><p>1014:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8435, 500)</code></pre></li></ul><p>Wait â€“ why is the heap listed alongside the local directory? Only the
directory gets localized during function calls. The same heap is used
at all times.</p><p>The body of <code data-lang="text/x-python" class="sourceCode">add10</code> now updates the value of <code data-lang="text/x-python" class="sourceCode">num</code> in
the directory to 25. This does not affect the value of <code data-lang="text/x-python" class="sourceCode">x</code> in
the top-level directory, for the same reasons we explained in <a href="#%28part._var-mut-aliasing%29" data-pltdoc="x">Variable Mutation and Aliasing</a>
regarding the lack of aliasing between variables that refer to basic
data. Thus, once the function finishes and the local directory is
deleted, the value associated with <code data-lang="text/x-python" class="sourceCode">x</code> is unchanged.</p><p>Now, letâ€™s evaluate the call <code data-lang="text/x-python" class="sourceCode">deposit10(a)</code>. As with
<code data-lang="text/x-python" class="sourceCode">add10</code>, we create a local directory and create an entry for
the parameter. What gets associated with that parameter in the
directory, however?</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">ac</code></pre><p>Â â†’Â 1014</p></li></ul><p>Heap</p><ul><li><p>1014:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8435, 500)</code></pre></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Why didnâ€™t we create a new <code data-lang="text/x-python" class="sourceCode">Account</code> datum when we made the
function call?</p></blockquote></blockquote><p>Remember our rule for when we create new data in the heap: we only
create heap data when we explicitly use a constructor. The function
call does not involve creating a new <code data-lang="text/x-python" class="sourceCode">Account</code>. Whatever is
associated with the name <code data-lang="text/x-python" class="sourceCode">a</code> gets associated with the parameter
name <code data-lang="text/x-python" class="sourceCode">ac</code>. In other words, we have created an alias between
<code data-lang="text/x-python" class="sourceCode">a</code> and <code data-lang="text/x-python" class="sourceCode">ac</code>.</p><p>In the body of <code data-lang="text/x-python" class="sourceCode">deposit10</code>, we update the balance of
<code data-lang="text/x-python" class="sourceCode">ac</code>, which is also the balance of <code data-lang="text/x-python" class="sourceCode">a</code> due to the
aliasing. Since there is no local heap, when the function call is
over, the new balance persists in <code data-lang="text/x-python" class="sourceCode">a</code>.</p><p>All weâ€™ve done here is put together pieces that weâ€™ve already seen,
just in a new context. Weâ€™re passing parameters and updating either
the (local) directory or the heap according to how we have used
<code data-lang="text/x-python" class="sourceCode">=</code>. But this example highlights a detail that initially
confuses many people when they start writing functions that update
variables.</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Updating Values within Functions</p><blockquote class="StrategyBody"><p>If you want a function to update a value and have that update persist
after the function completes, you must put that value inside a piece
of data. You cannot have it be basic data associated with a variable
name.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 13.1.5"><h4 class="heading">13.1.5Â <a name="(part._mut-top-level-vars-in-func)"/>Mutating Top-Level Variables within Functions<a href="#(part._mut-top-level-vars-in-func)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Letâ€™s return to our banking example to illustrate a situation where
the ability to update variables is extremely useful. Consider our
current process for creating new accounts in the bank by looking at
the following example:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">ac5 = Account(8702, 435)
ac6 = Account(8703, 280)
ac7 = Account(8704, 375)</code></pre><p>Notice that each time we create an <code data-lang="text/x-python" class="sourceCode">Account</code> we have to take
care to increase the id number? What if we made a typo or
accidentally forgot to do this?</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">ac5 = Account(8702, 435)
ac6 = Account(8703, 280)
ac7 = Account(8703, 375)</code></pre><p>Now weâ€™d have multiple accounts with the same ID number, when we
really need these numbers to be unique across all accounts. To avoid
such problems, we should instead have a function for creating accounts
that takes the initial balance as input and uses a guaranteed-unique
ID number.</p><p>How might we write such a function? The challenge is to be able to
generate unique ID numbers each time. What if we used a variable to
store the next available ID number, updating it each time we created a
new account? That function might look at follows:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">nextID = 8000 # stores the next available ID number

def create_acct(init_bal: float) -&gt; Account:
  new_acct = Account(nextID, init_bal)
  nextID = nextID + 1
  return(new_acct)</code></pre><p>Letâ€™s run this program, creating new accounts as follows:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">ac5 = create_acct(435)
ac6 = create_acct(280)
ac7 = create_acct(375)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Copy this code into Python and run it. Check that each of
<code data-lang="text/x-python" class="sourceCode">ac5</code>, <code data-lang="text/x-python" class="sourceCode">ac6</code>, and <code data-lang="text/x-python" class="sourceCode">ac7</code> have unique ID numbers.</p></blockquote></blockquote><p>What happened? All three of these have the same ID of
<code data-lang="text/x-python" class="sourceCode">8000</code>. It looks like our update to <code data-lang="text/x-python" class="sourceCode">nextID</code> just didnâ€™t
work. Actually, it did work, but to understand how, we have to look at
what happened in the directory.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Draw the memory diagram for this example.</p></blockquote></blockquote><p>After we set up <code data-lang="text/x-python" class="sourceCode">nextID</code> and define the function, our memory
diagram appears as:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">nextID</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">8000</code></p></li></ul><p>Now, letâ€™s evaluate <code data-lang="text/x-python" class="sourceCode">ac5 = create_acct(435)</code>. We call
<code data-lang="text/x-python" class="sourceCode">create_acct</code>, which yields the following local directory after
creating the <code data-lang="text/x-python" class="sourceCode">Account</code> but before updating <code data-lang="text/x-python" class="sourceCode">nextID</code>.</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">init_bal</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">435</code></p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">new_acct</code></pre><p>Â â†’Â 1015</p></li></ul><p>Heap</p><ul><li><p>1015:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8000, 435)</code></pre></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you think happens when we run <code data-lang="text/x-python" class="sourceCode">nextID = nextID + 1</code>?</p></blockquote></blockquote><p>Letâ€™s run this carefully. Python first evaluates the right side of the
<code data-lang="text/x-python" class="sourceCode">=</code> (<code data-lang="text/x-python" class="sourceCode">nextID + 1</code>). <code data-lang="text/x-python" class="sourceCode">nextID</code> is not in the local
directory, so Python retrieves its value (<code data-lang="text/x-python" class="sourceCode">8000</code>) from the
top-level directory. Thus, this computation becomes <code data-lang="text/x-python" class="sourceCode">nextID = 8001</code>.</p><p>The question here is how Python treats <code data-lang="text/x-python" class="sourceCode">nextID = 8001</code>: we
currently have both the local directory for the function call and the
top-level directory. Which one should get the new value of
<code data-lang="text/x-python" class="sourceCode">nextID</code>? Since the local directory is active, Python sets the
value of <code data-lang="text/x-python" class="sourceCode">nextID</code> there.</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">init_bal</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">435</code></p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">new_acct</code></pre><p>Â â†’Â 1015</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">nextID</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">8001</code></p></li></ul><p>Heap</p><ul><li><p>1015:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8000, 435)</code></pre></li></ul><p>Letâ€™s repeat that: Python computed <code data-lang="text/x-python" class="sourceCode">nextID + 1</code> using the
<code data-lang="text/x-python" class="sourceCode">nextID</code> value from the top-level directory since there was no
value for <code data-lang="text/x-python" class="sourceCode">nextID</code> in the local directory. But the setting of
the value of <code data-lang="text/x-python" class="sourceCode">nextID</code> could and did occur in the local
directory. Thus, when <code data-lang="text/x-python" class="sourceCode">create_acct</code> finishes, the value of
<code data-lang="text/x-python" class="sourceCode">nextID</code> in the top-level directory is unchanged. As a result,
all of the accounts get the same value.</p><p>The computuation we are trying to doâ€”<wbr/>updating the top-level
variableâ€”<wbr/>is just fine. The problem is that Python (reasonably)
defaults to the local directory. To make this work, we need to tell
Python that we want to make updates to <code data-lang="text/x-python" class="sourceCode">next_id</code> in the
top-level directory. Hereâ€™s the version of <code data-lang="text/x-python" class="sourceCode">create_acct</code> that
does that:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def create_acct(init_bal: float) -&gt; Account:
  global nextID
  new_acct = Account(nextID, init_bal)
  nextID = nextID + 1
  return(new_acct)</code></pre><p>The <code data-lang="text/x-python" class="sourceCode">global</code> keyword tells Python to make updates to the given
variable in the top-level directory, not the local directory. Once we
make this modification, each account we create will get a unique ID
number.</p><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Keeping IDs Unpredictable</p><blockquote class="RespCSBody"><p>While this general pattern of generating unique IDs works, in practice
we shouldnâ€™t use consecutive numbers. Consecutive numbers are
guessable: if there is an account <code data-lang="text/x-python" class="sourceCode">8000</code> there must be an
account <code data-lang="text/x-python" class="sourceCode">8001</code>, and so on. Guessable account numbers could make
it easier for someone who keeps trying to guess valid IDs to use to
log into websites or otherwise access information.</p><p>Instead, we would use a computation that is less predictable than
â€œadd 1â€ when storing the <code data-lang="text/x-python" class="sourceCode">nextID</code> value. For now, the
pattern we have shown you is fine. If you were building a real system,
however, youâ€™d want to make that computation a bit more sophisticated.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 13.1.6"><h4 class="heading">13.1.6Â <a name="(part._.The_.Many_.Roles_of_.Variables)"/>The Many Roles of Variables<a href="#(part._.The_.Many_.Roles_of_.Variables)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>At this point, we have used the single coding construct of a variable
in the directory for multiple purposes. Itâ€™s worth stepping back and
calling those out explicitly. In general, variables serve one of the
following purposes:</p><ol><li><p>Tracking progress of a computation (e.g., the running value of a
result in a <code data-lang="text/x-python" class="sourceCode">for</code>-loop)</p></li><li><p>Maintaining information across multiple calls to a single
function (e.g., the <code data-lang="text/x-python" class="sourceCode">next-id</code> variable)</p></li><li><p>Naming a local or intermediate value in a computation</p></li></ol><p>Each of these uses involves a different programming pattern. The first
creates a variable locally within a function. The second two create
top-level variables and require using <code data-lang="text/x-python" class="sourceCode">global</code> in functions
that modify the contents. The third is different from the second,
however, in that the third is only meant to be used by a single
function. Ideally, there would be a way to not expose the variable to
all functions in the third case. Indeed, many programming languages
(including Pyret) make it easy to do that. This is harder to achieve
with introductory-level concepts in Python, however. The fourth is
more about local names rather than variables, in that our code never
updates the value after the variable is created.</p><p>We call out these three roles precisely because they invoke different
code patterns, despite using the same fine-grained concept (assigning
a new value to a variable). When you look at a new programming
problem, you can ask yourself whether the problem involves one of
these purposes, and use that to guide your choice of pattern to use.</p></section>&#13;
<h4 class="heading">13.1.1Â <a name="(part._mutating-vars-memory)"/>Mutating Variables in Memory<a href="#(part._mutating-vars-memory)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Now that we have introduced the idea of the heap, letâ€™s revisit our
use of a variable to compute the sum of elements in a list. Here again
is the code we wrote for this earlier (in <a href="intro-python.html#%28part._python-for-loops%29" data-pltdoc="x">Introducing <code data-lang="text/x-python" class="sourceCode">For</code> Loops</a>):</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
for num in [5, 1, 7, 3]:
   run_total = run_total + num</code></pre><p>Letâ€™s see how the directory and heap update as we run this code.  In
<a href="mutating-structures.html#%28part._basic-data-heap%29" data-pltdoc="x">Basic Data and the Heap</a>, we pointed out that basic data (such as
numbers, strings, and booleans) donâ€™t get put in the heap because they
have no internal structure. Those values are stored in the directory
itself. Therefore, the initial value for <code data-lang="text/x-python" class="sourceCode">run_total</code> is stored
within the directory.</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">0</code></pre></li></ul><p>The <code data-lang="text/x-python" class="sourceCode">for</code> loop also sets up a directory entry, this time for
the variable <code data-lang="text/x-python" class="sourceCode">num</code> that is used to refer to the list
elements. When the loop starts, <code data-lang="text/x-python" class="sourceCode">num</code> takes on the first value
in the list. Thus, the directory appears as:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">0</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">5</code></pre></li></ul><p>Inside the <code data-lang="text/x-python" class="sourceCode">for</code> loop, we compute a new value for
<code data-lang="text/x-python" class="sourceCode">run_total</code>. The use of <code data-lang="text/x-python" class="sourceCode">=</code> tells Python to modify the
value of <code data-lang="text/x-python" class="sourceCode">run_total</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Does this modification get made in the directory or the heap?</p></blockquote></blockquote><p>Since basic data values are stored only in the directory, this update
modifies the contents of the directory. The heap isnâ€™t involved:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">5</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">5</code></pre></li></ul><p>This process continues: Python advances <code data-lang="text/x-python" class="sourceCode">num</code> to the next list
element</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">5</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">1</code></pre></li></ul><p>then modifies the value of <code data-lang="text/x-python" class="sourceCode">run_total</code></p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">6</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">1</code></pre></li></ul><p>This process continues until all of the list elements have been
processed. When the for-loop ends, the directory contents are:
</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">16</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">3</code></pre></li></ul><p>There are two takeaways from this example:</p><ul><li><p>When we use <code data-lang="text/x-python" class="sourceCode">=</code> to update the value associated with a
variable, the variableâ€™s entry in the directory changes to reflect the
new value.</p></li><li><p><code data-lang="text/x-python" class="sourceCode">For</code> loops
introduce a name into the directory (the one the programmer chose to
refer to the individual list elements). As the loop progresses, Python
updates the value associated with that name to refer to each
successive element.</p></li></ul><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Draw the sequence of directory contents for the following program:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">score = 0
score = score + 4
score = 10</code></pre></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Draw the sequence of directory contents for the following program:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">count_long = 0
for word in ["here", "are", "some", "words"]:
  if len(word) &gt; 4:
    count_long = count_long + 1</code></pre></blockquote></blockquote>&#13;
<h4 class="heading">13.1.2Â <a name="(part._var-mut-aliasing)"/>Variable Mutation and Aliasing<a href="#(part._var-mut-aliasing)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In <a href="mutating-structures.html" data-pltdoc="x">Mutating Structures</a>, we saw how a statement of the form
<code data-lang="text/x-python" class="sourceCode">elena.acct.balance = 500</code> resulted in a change to
<code data-lang="text/x-python" class="sourceCode">jorge.acct.balance</code>. Does this same effect occur if we update the
value of a variable directly, rather than a field? Consider the
following example:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">y = 5
x = y</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do the directory and heap look like after running this code?</p></blockquote></blockquote><p>Since <code data-lang="text/x-python" class="sourceCode">x</code> and <code data-lang="text/x-python" class="sourceCode">y</code> are assigned basic values, there are
no values in the heap:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">y</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">5</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">5</code></pre></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>If we now evaluate <code data-lang="text/x-python" class="sourceCode">y = 3</code>, does the value of <code data-lang="text/x-python" class="sourceCode">x</code>
change?</p></blockquote></blockquote><p>It does not. The value associated with <code data-lang="text/x-python" class="sourceCode">y</code> in the directory
changes, but there is no connection between <code data-lang="text/x-python" class="sourceCode">x</code> and <code data-lang="text/x-python" class="sourceCode">y</code>
in the directory. The statement <code data-lang="text/x-python" class="sourceCode">x = y</code> says â€œget the value of
<code data-lang="text/x-python" class="sourceCode">y</code> and associate it with <code data-lang="text/x-python" class="sourceCode">x</code> in the
directoryâ€. Immediately after this statement, <code data-lang="text/x-python" class="sourceCode">y</code> and
<code data-lang="text/x-python" class="sourceCode">x</code> refer to the same value, but this relationship is neither
tracked nor maintained. If we associate either variable with a new
value, as we do with <code data-lang="text/x-python" class="sourceCode">y = 3</code>, the directory entry for that
variableâ€”<wbr/>and only the directory entry for that variableâ€”<wbr/>are
changed to reflect the new value. Thus, the directory after we
evaluate <code data-lang="text/x-python" class="sourceCode">y = 3</code> appears as follows:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">y</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">3</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">5</code></pre></li></ul><p>This example highlights that aliasing occurs only when two variables
refer to the same piece of data with components, not when variables
refer to basic data. This is because data with components are stored
in the heap, with heap address stored in the directory. Note, though,
that uses of <code data-lang="text/x-python" class="sourceCode">varname = ...</code> still affect the directory, even
when the values are data with components.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>After running the following code, what is the value of <code data-lang="text/x-python" class="sourceCode">ac2.balance</code>?</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">ac1 = Account(8623, 600)
ac2 = ac1
ac1 = Account(8721, 350)</code></pre><p>Draw the directory and heap contents for this program and check your
prediction.</p></blockquote></blockquote><p>All three of these lines results in changes in the directory; the
first two result in changes in the heap, but only because we made new
pieces of data. <code data-lang="text/x-python" class="sourceCode">ac1</code> and <code data-lang="text/x-python" class="sourceCode">ac2</code> are alises immediately
after running the second line, but the third line breaks that
relationship.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>After running the following code, what is the value of <code data-lang="text/x-python" class="sourceCode">ac3.balance</code>?</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">savings = 475
ac3 = Account(8722, savings)
savings = 500</code></pre><p>Draw the directory and heap contents for this program and check your
prediction.</p></blockquote></blockquote><p>Since the value of <code data-lang="text/x-python" class="sourceCode">savings</code> is stored in <code data-lang="text/x-python" class="sourceCode">ac3.balance</code>,
and not the name <code data-lang="text/x-python" class="sourceCode">savings</code> itself, updating the value of
<code data-lang="text/x-python" class="sourceCode">savings</code> on the third line does not affect <code data-lang="text/x-python" class="sourceCode">ac3.balance</code>.</p>&#13;
<h4 class="heading">13.1.3Â <a name="(part._.Mutating_.Variables_versus_.Mutating_.Data_.Fields)"/>Mutating Variables versus Mutating Data Fields<a href="#(part._.Mutating_.Variables_versus_.Mutating_.Data_.Fields)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Weâ€™ve now seen two different forms of updates in programs: updates to
fields of structured data in <a href="mutating-structures.html" data-pltdoc="x">Mutating Structures</a>, and updates to
the values associated with names when computing over lists with
<code data-lang="text/x-python" class="sourceCode">for</code> loops. At a quick glance, these two forms of update look
similar:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1.balance = acct1.balance - 50
run_total = run_total + fst</code></pre><p>Both use the <code data-lang="text/x-python" class="sourceCode">=</code> operator and compute a new value on the right
side. The left sides, however, are subtly different: one is a field
within structured data, while the other is a name in the directory. This
difference turns out to be significant: the first form changes a value
stored in the heap but leaves the directory unchanged, while the
second updates the directory but leaves the heap unchanged.</p><p>At this point, you might not appreciate why this difference is
significant. But for now, letâ€™s summarize how each of these forms
impacts each of the directory and the heap.</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Rules for updating the directory and the heap</p><blockquote class="StrategyBody"><p>Summarizing, the rules for how the directory and memory update are as follows:</p><ul><li><p>We add to the heap when a data constructor is used</p></li><li><p>We update the heap when a field of existing data is reassigned</p></li><li><p>We add to the directory when a name is used for the first time (this
includes parameters and internal variables when a function is called)</p></li><li><p>We update the directory when a name that is already in the
directory is subsequently assigned a new value)</p></li></ul></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>After running the following code, what is the value of <code data-lang="text/x-python" class="sourceCode">ac3.balance</code>?</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">ac2 = Account(8728, 200)
ac3 = ac2
print(ac3.balance)
ac2.balance = 500
print(ac3.balance)
ac2 = Account(8734, 350)
ac2.balance = 700
print(ac3.balance)</code></pre><p>Draw the directory and heap contents for this program and check your
prediction.</p></blockquote></blockquote><p>This example combines updates to variables and updates to fields. On
the third line, <code data-lang="text/x-python" class="sourceCode">ac2</code> and <code data-lang="text/x-python" class="sourceCode">ac3</code> refer to the same
address in the heap (which contains the <code data-lang="text/x-python" class="sourceCode">Account</code> with id
<code data-lang="text/x-python" class="sourceCode">8728</code>. Immediately after updating <code data-lang="text/x-python" class="sourceCode">ac2.balance</code> on the
fourth line, the balance in both <code data-lang="text/x-python" class="sourceCode">ac2</code> and <code data-lang="text/x-python" class="sourceCode">ac3</code> is 500. Line
six, however, creates a new <code data-lang="text/x-python" class="sourceCode">Account</code> in the heap and updates
the directory to have <code data-lang="text/x-python" class="sourceCode">ac2</code> refer to that new
<code data-lang="text/x-python" class="sourceCode">Account</code>. From that point on, <code data-lang="text/x-python" class="sourceCode">ac2</code> and <code data-lang="text/x-python" class="sourceCode">ac3</code>
refer to different accounts, so the update to the balance in
<code data-lang="text/x-python" class="sourceCode">ac2</code> on the seventh line does not affect <code data-lang="text/x-python" class="sourceCode">ac3</code>.</p><p>This example illustrates the subtleties and impacts of different uses of
<code data-lang="text/x-python" class="sourceCode">=</code>. Programs behave differently depending on whether the left
side of the <code data-lang="text/x-python" class="sourceCode">=</code> is a variable name or a field reference, and on
whether the right side is basic data or data with components. We will
continue to work with these various combinations to build your
understanding of when and how to use each one.</p>&#13;
<h4 class="heading">13.1.4Â <a name="(part._.Mutating_.Parameters_in_.Function_.Calls)"/>Mutating Parameters in Function Calls<a href="#(part._.Mutating_.Parameters_in_.Function_.Calls)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In <a href="Conditionals_and_Booleans.html#%28part._func-comp-directory%29" data-pltdoc="x">Function Composition and the Directory</a>, we showed how
function calls create their own local directory segments to store any
names that get introduced while running the function. Now that we have
the ability to update the values associated with variables, we should
revisit this topic to understand what happens when these updates occur
within functions.</p><p>Consider the following two functions:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def add10(num: int):
  num = num + 10

def deposit10(ac: Account)
  ac.balance = ac.balance + 10</code></pre><p>Letâ€™s use these two functions in a program:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x = 15
a = Account(8435, 500)
add10(x)
deposit10(a)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What are the values of <code data-lang="text/x-python" class="sourceCode">x</code> and <code data-lang="text/x-python" class="sourceCode">a</code> when the program has
finished?</p></blockquote></blockquote><p>Letâ€™s draw out the directory and heap for this program.</p><p>We need a way to distinguish local directories from the
global one â€“ easiest for now might be to add a form for
local-env-with-heap that uses the label â€œLocal Directory (fun name)â€.</p><p>After the first two lines but before the function calls, we have the
following:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">15</code></p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a</code></pre><p>Â â†’Â 1014</p></li></ul><p>Heap</p><ul><li><p>1014:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8435, 500)</code></pre></li></ul><p>Calling <code data-lang="text/x-python" class="sourceCode">add10</code> creates a local directory containing the name
of the parameter:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">15</code></p></li></ul><p>Heap</p><ul><li><p>1014:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8435, 500)</code></pre></li></ul><p>Wait â€“ why is the heap listed alongside the local directory? Only the
directory gets localized during function calls. The same heap is used
at all times.</p><p>The body of <code data-lang="text/x-python" class="sourceCode">add10</code> now updates the value of <code data-lang="text/x-python" class="sourceCode">num</code> in
the directory to 25. This does not affect the value of <code data-lang="text/x-python" class="sourceCode">x</code> in
the top-level directory, for the same reasons we explained in <a href="#%28part._var-mut-aliasing%29" data-pltdoc="x">Variable Mutation and Aliasing</a>
regarding the lack of aliasing between variables that refer to basic
data. Thus, once the function finishes and the local directory is
deleted, the value associated with <code data-lang="text/x-python" class="sourceCode">x</code> is unchanged.</p><p>Now, letâ€™s evaluate the call <code data-lang="text/x-python" class="sourceCode">deposit10(a)</code>. As with
<code data-lang="text/x-python" class="sourceCode">add10</code>, we create a local directory and create an entry for
the parameter. What gets associated with that parameter in the
directory, however?</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">ac</code></pre><p>Â â†’Â 1014</p></li></ul><p>Heap</p><ul><li><p>1014:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8435, 500)</code></pre></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Why didnâ€™t we create a new <code data-lang="text/x-python" class="sourceCode">Account</code> datum when we made the
function call?</p></blockquote></blockquote><p>Remember our rule for when we create new data in the heap: we only
create heap data when we explicitly use a constructor. The function
call does not involve creating a new <code data-lang="text/x-python" class="sourceCode">Account</code>. Whatever is
associated with the name <code data-lang="text/x-python" class="sourceCode">a</code> gets associated with the parameter
name <code data-lang="text/x-python" class="sourceCode">ac</code>. In other words, we have created an alias between
<code data-lang="text/x-python" class="sourceCode">a</code> and <code data-lang="text/x-python" class="sourceCode">ac</code>.</p><p>In the body of <code data-lang="text/x-python" class="sourceCode">deposit10</code>, we update the balance of
<code data-lang="text/x-python" class="sourceCode">ac</code>, which is also the balance of <code data-lang="text/x-python" class="sourceCode">a</code> due to the
aliasing. Since there is no local heap, when the function call is
over, the new balance persists in <code data-lang="text/x-python" class="sourceCode">a</code>.</p><p>All weâ€™ve done here is put together pieces that weâ€™ve already seen,
just in a new context. Weâ€™re passing parameters and updating either
the (local) directory or the heap according to how we have used
<code data-lang="text/x-python" class="sourceCode">=</code>. But this example highlights a detail that initially
confuses many people when they start writing functions that update
variables.</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Updating Values within Functions</p><blockquote class="StrategyBody"><p>If you want a function to update a value and have that update persist
after the function completes, you must put that value inside a piece
of data. You cannot have it be basic data associated with a variable
name.</p></blockquote></blockquote>&#13;
<h4 class="heading">13.1.5Â <a name="(part._mut-top-level-vars-in-func)"/>Mutating Top-Level Variables within Functions<a href="#(part._mut-top-level-vars-in-func)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Letâ€™s return to our banking example to illustrate a situation where
the ability to update variables is extremely useful. Consider our
current process for creating new accounts in the bank by looking at
the following example:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">ac5 = Account(8702, 435)
ac6 = Account(8703, 280)
ac7 = Account(8704, 375)</code></pre><p>Notice that each time we create an <code data-lang="text/x-python" class="sourceCode">Account</code> we have to take
care to increase the id number? What if we made a typo or
accidentally forgot to do this?</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">ac5 = Account(8702, 435)
ac6 = Account(8703, 280)
ac7 = Account(8703, 375)</code></pre><p>Now weâ€™d have multiple accounts with the same ID number, when we
really need these numbers to be unique across all accounts. To avoid
such problems, we should instead have a function for creating accounts
that takes the initial balance as input and uses a guaranteed-unique
ID number.</p><p>How might we write such a function? The challenge is to be able to
generate unique ID numbers each time. What if we used a variable to
store the next available ID number, updating it each time we created a
new account? That function might look at follows:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">nextID = 8000 # stores the next available ID number

def create_acct(init_bal: float) -&gt; Account:
  new_acct = Account(nextID, init_bal)
  nextID = nextID + 1
  return(new_acct)</code></pre><p>Letâ€™s run this program, creating new accounts as follows:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">ac5 = create_acct(435)
ac6 = create_acct(280)
ac7 = create_acct(375)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Copy this code into Python and run it. Check that each of
<code data-lang="text/x-python" class="sourceCode">ac5</code>, <code data-lang="text/x-python" class="sourceCode">ac6</code>, and <code data-lang="text/x-python" class="sourceCode">ac7</code> have unique ID numbers.</p></blockquote></blockquote><p>What happened? All three of these have the same ID of
<code data-lang="text/x-python" class="sourceCode">8000</code>. It looks like our update to <code data-lang="text/x-python" class="sourceCode">nextID</code> just didnâ€™t
work. Actually, it did work, but to understand how, we have to look at
what happened in the directory.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Draw the memory diagram for this example.</p></blockquote></blockquote><p>After we set up <code data-lang="text/x-python" class="sourceCode">nextID</code> and define the function, our memory
diagram appears as:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">nextID</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">8000</code></p></li></ul><p>Now, letâ€™s evaluate <code data-lang="text/x-python" class="sourceCode">ac5 = create_acct(435)</code>. We call
<code data-lang="text/x-python" class="sourceCode">create_acct</code>, which yields the following local directory after
creating the <code data-lang="text/x-python" class="sourceCode">Account</code> but before updating <code data-lang="text/x-python" class="sourceCode">nextID</code>.</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">init_bal</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">435</code></p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">new_acct</code></pre><p>Â â†’Â 1015</p></li></ul><p>Heap</p><ul><li><p>1015:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8000, 435)</code></pre></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you think happens when we run <code data-lang="text/x-python" class="sourceCode">nextID = nextID + 1</code>?</p></blockquote></blockquote><p>Letâ€™s run this carefully. Python first evaluates the right side of the
<code data-lang="text/x-python" class="sourceCode">=</code> (<code data-lang="text/x-python" class="sourceCode">nextID + 1</code>). <code data-lang="text/x-python" class="sourceCode">nextID</code> is not in the local
directory, so Python retrieves its value (<code data-lang="text/x-python" class="sourceCode">8000</code>) from the
top-level directory. Thus, this computation becomes <code data-lang="text/x-python" class="sourceCode">nextID = 8001</code>.</p><p>The question here is how Python treats <code data-lang="text/x-python" class="sourceCode">nextID = 8001</code>: we
currently have both the local directory for the function call and the
top-level directory. Which one should get the new value of
<code data-lang="text/x-python" class="sourceCode">nextID</code>? Since the local directory is active, Python sets the
value of <code data-lang="text/x-python" class="sourceCode">nextID</code> there.</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">init_bal</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">435</code></p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">new_acct</code></pre><p>Â â†’Â 1015</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">nextID</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">8001</code></p></li></ul><p>Heap</p><ul><li><p>1015:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8000, 435)</code></pre></li></ul><p>Letâ€™s repeat that: Python computed <code data-lang="text/x-python" class="sourceCode">nextID + 1</code> using the
<code data-lang="text/x-python" class="sourceCode">nextID</code> value from the top-level directory since there was no
value for <code data-lang="text/x-python" class="sourceCode">nextID</code> in the local directory. But the setting of
the value of <code data-lang="text/x-python" class="sourceCode">nextID</code> could and did occur in the local
directory. Thus, when <code data-lang="text/x-python" class="sourceCode">create_acct</code> finishes, the value of
<code data-lang="text/x-python" class="sourceCode">nextID</code> in the top-level directory is unchanged. As a result,
all of the accounts get the same value.</p><p>The computuation we are trying to doâ€”<wbr/>updating the top-level
variableâ€”<wbr/>is just fine. The problem is that Python (reasonably)
defaults to the local directory. To make this work, we need to tell
Python that we want to make updates to <code data-lang="text/x-python" class="sourceCode">next_id</code> in the
top-level directory. Hereâ€™s the version of <code data-lang="text/x-python" class="sourceCode">create_acct</code> that
does that:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def create_acct(init_bal: float) -&gt; Account:
  global nextID
  new_acct = Account(nextID, init_bal)
  nextID = nextID + 1
  return(new_acct)</code></pre><p>The <code data-lang="text/x-python" class="sourceCode">global</code> keyword tells Python to make updates to the given
variable in the top-level directory, not the local directory. Once we
make this modification, each account we create will get a unique ID
number.</p><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Keeping IDs Unpredictable</p><blockquote class="RespCSBody"><p>While this general pattern of generating unique IDs works, in practice
we shouldnâ€™t use consecutive numbers. Consecutive numbers are
guessable: if there is an account <code data-lang="text/x-python" class="sourceCode">8000</code> there must be an
account <code data-lang="text/x-python" class="sourceCode">8001</code>, and so on. Guessable account numbers could make
it easier for someone who keeps trying to guess valid IDs to use to
log into websites or otherwise access information.</p><p>Instead, we would use a computation that is less predictable than
â€œadd 1â€ when storing the <code data-lang="text/x-python" class="sourceCode">nextID</code> value. For now, the
pattern we have shown you is fine. If you were building a real system,
however, youâ€™d want to make that computation a bit more sophisticated.</p></blockquote></blockquote>&#13;
<h4 class="heading">13.1.6Â <a name="(part._.The_.Many_.Roles_of_.Variables)"/>The Many Roles of Variables<a href="#(part._.The_.Many_.Roles_of_.Variables)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>At this point, we have used the single coding construct of a variable
in the directory for multiple purposes. Itâ€™s worth stepping back and
calling those out explicitly. In general, variables serve one of the
following purposes:</p><ol><li><p>Tracking progress of a computation (e.g., the running value of a
result in a <code data-lang="text/x-python" class="sourceCode">for</code>-loop)</p></li><li><p>Maintaining information across multiple calls to a single
function (e.g., the <code data-lang="text/x-python" class="sourceCode">next-id</code> variable)</p></li><li><p>Naming a local or intermediate value in a computation</p></li></ol><p>Each of these uses involves a different programming pattern. The first
creates a variable locally within a function. The second two create
top-level variables and require using <code data-lang="text/x-python" class="sourceCode">global</code> in functions
that modify the contents. The third is different from the second,
however, in that the third is only meant to be used by a single
function. Ideally, there would be a way to not expose the variable to
all functions in the third case. Indeed, many programming languages
(including Pyret) make it easy to do that. This is harder to achieve
with introductory-level concepts in Python, however. The fourth is
more about local names rather than variables, in that our code never
updates the value after the variable is created.</p><p>We call out these three roles precisely because they invoke different
code patterns, despite using the same fine-grained concept (assigning
a new value to a variable). When you look at a new programming
problem, you can ask yourself whether the problem involves one of
these purposes, and use that to guide your choice of pattern to use.</p>    
</body>
</html>