- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SOME SIMPLE NUMERICAL PROGRAMS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered some basic Python constructs, it is time to start thinking
    about how we can combine those constructs to write simple programs. Along the
    way, we'll sneak in more language constructs and some algorithmic techniques.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 3.1â€ƒExhaustive Enumeration
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code in [Figure 3-1](#c3-fig-0001) prints the integer cube root, if it exists,
    of an integer. If the input is not a perfect cube, it prints a message to that
    effect. The operator `!=` means not equal.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '![c3-fig-0001.jpg](../images/c3-fig-0001.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
- en: '[Figure 3-1](#c3-fig-0001a)â€ƒUsing exhaustive enumeration to find the cube root'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The code first attempts to set the variable `ans` to the cube root of the absolute
    value of `x`. If it succeeds, it then sets `ans` to `-ans` if `x` is negative.
    The heavy lifting (such as it is) in this code is done in the `while` loop. Whenever
    a program contains a loop, it is important to understand what causes the program
    to eventually exit this loop. For what values of `x` will this `while` loop terminate?
    The answer is â€œall integers.â€ This can be argued quite simply.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The value of the expression `ans**3` starts at `0` and gets larger each time
    through the loop.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it reaches or exceeds `abs(x)`, the loop terminates.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since `abs(x)` is always positive, there are only a finite number of iterations
    before the loop must terminate.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This argument is based upon the notion of a **decrementing function**. This
    is a function that has the following properties:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: It maps a set of program variables into an integer.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the loop is entered, its value is nonnegative.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When its value is â‰¤ 0, the loop terminates.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its value is decreased every time through the loop.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the decrementing function for the `while` loop in [Figure 3-1](#c3-fig-0001)?
    It is `abs(x)Â â€‘Â ans**3`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's insert some errors and see what happens. First, try commenting out
    the statement `ans = 0`. The Python interpreter prints the error message
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: because the interpreter attempts to find the value to which `ans` is bound before
    it has been bound to anything. Now, restore the initialization of `ans`, replace
    the statement `ans = ans + 1` by `ans`Â `=`Â `ans`, and try finding the cube root
    of 8\. After you get tired of waiting, enter â€œcontrol câ€ (hold down the `Ctrl`
    key and the `c` key simultaneously). This will return you to the user prompt in
    the shell.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Now, add the statement
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: at the start of the loop, and try running it again. This time it will print
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: over and over again.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The program would have run forever because the loop body is no longer reducing
    the distance between `ans**3` and `abs(x)`. When confronted with a program that
    seems not to be terminating, experienced programmers often insert print statements,
    such as the one here, to test whether the decrementing function is indeed being
    decremented.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The algorithmic technique used in this program is a variant of **guess-and-check**
    called **exhaustive enumeration**. We enumerate all possibilities until we get
    to the right answer or exhaust the space of possibilities. At first blush, this
    may seem like an incredibly stupid way to solve a problem. Surprisingly, however,
    exhaustive enumeration algorithms are often the most practical way to solve a
    problem. They are typically easy to implement and easy to understand. And, in
    many cases, they run fast enough for all practical purposes. Remove or comment
    out the print statement that you inserted for debugging, and reinsert the statement
    `ansÂ = ansÂ +Â 1`. Now try finding the cube root of `1957816251`. The program will
    finish almost instantaneously. Now, try `7406961012236344616`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç¨‹åºä½¿ç”¨çš„ç®—æ³•æŠ€æœ¯æ˜¯**çŒœæµ‹ä¸æ£€æŸ¥**çš„ä¸€ç§å˜ä½“ï¼Œç§°ä¸º**è€—å°½æšä¸¾**ã€‚æˆ‘ä»¬æšä¸¾æ‰€æœ‰å¯èƒ½æ€§ï¼Œç›´åˆ°æ‰¾åˆ°æ­£ç¡®ç­”æ¡ˆæˆ–ç©·å°½æ‰€æœ‰å¯èƒ½æ€§ã€‚ä¹ä¸€çœ‹ï¼Œè¿™ä¼¼ä¹æ˜¯è§£å†³é—®é¢˜çš„ä¸€ä¸ªæå…¶æ„šè ¢çš„æ–¹æ³•ã€‚ç„¶è€Œï¼Œä»¤äººæƒŠè®¶çš„æ˜¯ï¼Œè€—å°½æšä¸¾ç®—æ³•å¾€å¾€æ˜¯è§£å†³é—®é¢˜çš„æœ€å®é™…æ–¹æ³•ã€‚å®ƒä»¬é€šå¸¸æ˜“äºå®ç°å’Œç†è§£ï¼Œå¹¶ä¸”åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œå®ƒä»¬çš„è¿è¡Œé€Ÿåº¦è¶³å¤Ÿå¿«ä»¥æ»¡è¶³æ‰€æœ‰å®é™…éœ€æ±‚ã€‚å»æ‰æˆ–æ³¨é‡Šæ‰ä½ ä¸ºè°ƒè¯•æ’å…¥çš„æ‰“å°è¯­å¥ï¼Œå¹¶é‡æ–°æ’å…¥è¯­å¥`ans
    = ans + 1`ã€‚ç°åœ¨å°è¯•å¯»æ‰¾`1957816251`çš„ç«‹æ–¹æ ¹ã€‚ç¨‹åºå‡ ä¹ä¼šç¬é—´å®Œæˆã€‚ç°åœ¨è¯•è¯•`7406961012236344616`ã€‚
- en: As you can see, even if millions of guesses are required, run time is not usually
    a problem. Modern computers are amazingly fast. It takes less than one nanosecondâ€”one
    billionth of a secondâ€”to execute an instruction. It's hard to appreciate how fast
    that is. For perspective, it takes slightly more than a nanosecond for light to
    travel a single foot (0.3 meters). Another way to think about this is that in
    the time it takes for the sound of your voice to travel a 100 feet, a modern computer
    can execute millions of instructions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚ä½ æ‰€çœ‹åˆ°çš„ï¼Œå³ä½¿éœ€è¦æ•°ç™¾ä¸‡æ¬¡çŒœæµ‹ï¼Œè¿è¡Œæ—¶é—´é€šå¸¸ä¹Ÿä¸æ˜¯é—®é¢˜ã€‚ç°ä»£è®¡ç®—æœºé€Ÿåº¦æƒŠäººã€‚æ‰§è¡Œä¸€æ¡æŒ‡ä»¤æ‰€éœ€çš„æ—¶é—´ä¸åˆ°ä¸€çº³ç§’â€”â€”åäº¿åˆ†ä¹‹ä¸€ç§’ã€‚å¾ˆéš¾æƒ³è±¡è¿™æœ‰å¤šå¿«ã€‚ä¸ºäº†æ›´å¥½åœ°ç†è§£ï¼Œå…‰åœ¨ä¸€è‹±å°ºï¼ˆ0.3ç±³ï¼‰ä¸­ä¼ æ’­çš„æ—¶é—´ç¨å¾®è¶…è¿‡ä¸€çº³ç§’ã€‚å¦ä¸€ç§ç†è§£æ–¹å¼æ˜¯ï¼Œåœ¨ä½ å£°éŸ³ä¼ æ’­100è‹±å°ºçš„æ—¶é—´å†…ï¼Œç°ä»£è®¡ç®—æœºå¯ä»¥æ‰§è¡Œæ•°ç™¾ä¸‡æ¡æŒ‡ä»¤ã€‚
- en: Just for fun, try executing the code
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ä»…ä¸ºå¥½ç©ï¼Œå°è¯•æ‰§è¡Œè¯¥ä»£ç ã€‚
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See how large an integer you need to enter before there is a perceptible pause
    before the result is printed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹çœ‹ä½ éœ€è¦è¾“å…¥å¤šå¤§çš„æ•´æ•°ï¼Œæ‰èƒ½åœ¨ç»“æœæ‰“å°ä¹‹å‰æ„ŸçŸ¥åˆ°å»¶è¿Ÿã€‚
- en: 'Let''s look at another example of exhaustive enumeration: testing whether an
    integer is a prime number and returning the smallest divisor if it is not. A prime
    number is an integer greater than 1 that is evenly divisible only by itself and
    1\. For example, 2, 3, 5, and 111,119 are primes, and 4, 6, 8 and 62,710,561 are
    not primes.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªè€—å°½æšä¸¾çš„å¦ä¸€ä¸ªä¾‹å­ï¼šæµ‹è¯•ä¸€ä¸ªæ•´æ•°æ˜¯å¦ä¸ºè´¨æ•°ï¼Œå¹¶åœ¨ä¸æ˜¯æ—¶è¿”å›æœ€å°çš„å› å­ã€‚è´¨æ•°æ˜¯å¤§äº1çš„æ•´æ•°ï¼Œä»…èƒ½è¢«è‡ªèº«å’Œ1æ•´é™¤ã€‚ä¾‹å¦‚ï¼Œ2ã€3ã€5å’Œ111,119æ˜¯è´¨æ•°ï¼Œè€Œ4ã€6ã€8å’Œ62,710,561ä¸æ˜¯è´¨æ•°ã€‚
- en: The simplest way to find out if an integer, x, greater than 3 is prime, is to
    divide x by each integer between 2 and, x-1\. If the remainder of any of those
    divisions is 0, x is not prime, otherwise x is prime. The code in [Figure 3-2](#c3-fig-0002)
    implements that approach. It first asks the user to enter an integer, converts
    the returned string to an `int`, and assigns that integer to the variable `x`.
    It then sets up the initial conditions for an exhaustive enumeration by initializing
    `guess` to `2` and the variable `smallest_divisor` to `None`â€”indicating that until
    proven otherwise, the code assumes that `x` is prime.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ç¡®å®šä¸€ä¸ªå¤§äº3çš„æ•´æ•°`x`æ˜¯å¦ä¸ºè´¨æ•°çš„æœ€ç®€å•æ–¹æ³•æ˜¯å°†`x`é™¤ä»¥2åˆ°`x-1`ä¹‹é—´çš„æ¯ä¸ªæ•´æ•°ã€‚å¦‚æœå…¶ä¸­ä»»ä½•ä¸€ä¸ªé™¤æ³•çš„ä½™æ•°ä¸º0ï¼Œåˆ™`x`ä¸æ˜¯è´¨æ•°ï¼Œå¦åˆ™`x`æ˜¯è´¨æ•°ã€‚[å›¾3-2](#c3-fig-0002)ä¸­çš„ä»£ç å®ç°äº†è¿™ç§æ–¹æ³•ã€‚å®ƒé¦–å…ˆè¦æ±‚ç”¨æˆ·è¾“å…¥ä¸€ä¸ªæ•´æ•°ï¼Œå°†è¿”å›çš„å­—ç¬¦ä¸²è½¬æ¢ä¸º`int`ï¼Œå¹¶å°†è¯¥æ•´æ•°èµ‹å€¼ç»™å˜é‡`x`ã€‚æ¥ç€ï¼Œå®ƒé€šè¿‡å°†`guess`åˆå§‹åŒ–ä¸º`2`å’Œå°†å˜é‡`smallest_divisor`åˆå§‹åŒ–ä¸º`None`æ¥è®¾ç½®è€—å°½æšä¸¾çš„åˆå§‹æ¡ä»¶â€”â€”è¿™è¡¨æ˜åœ¨æœªè¯æ˜çš„æƒ…å†µä¸‹ï¼Œä»£ç å‡å®š`x`ä¸ºè´¨æ•°ã€‚
- en: The exhaustive enumeration is done within a `for` loop. The loop terminates
    when either all possible integer divisors of `x` have been tried or it has discovered
    an integer that is a divisor of `x`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: è€—å°½æšä¸¾æ˜¯åœ¨`for`å¾ªç¯ä¸­å®Œæˆçš„ã€‚å½“æ‰€æœ‰å¯èƒ½çš„`x`çš„æ•´æ•°å› å­éƒ½å·²å°è¯•è¿‡ï¼Œæˆ–è€…å‘ç°ä¸€ä¸ª`x`çš„å› å­æ—¶ï¼Œå¾ªç¯ç»ˆæ­¢ã€‚
- en: After exiting the loop, the code checks the value of `smallest_divisor` and
    prints the appropriate text. The trick of initializing a variable before entering
    a loop, and then checking whether that value has been changed upon exit, is a
    common one.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: é€€å‡ºå¾ªç¯åï¼Œä»£ç æ£€æŸ¥`smallest_divisor`çš„å€¼å¹¶æ‰“å°ç›¸åº”çš„æ–‡æœ¬ã€‚åœ¨è¿›å…¥å¾ªç¯ä¹‹å‰åˆå§‹åŒ–å˜é‡ï¼Œç„¶åæ£€æŸ¥è¯¥å€¼åœ¨é€€å‡ºæ—¶æ˜¯å¦å·²æ›´æ”¹æ˜¯ä¸€ç§å¸¸è§çš„æŠ€å·§ã€‚
- en: '![c3-fig-0002.jpg](../images/c3-fig-0002.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0002.jpg](../images/c3-fig-0002.jpg)'
- en: '[Figure 3-2](#c3-fig-0002a)â€ƒUsing exhaustive enumeration to test primality'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[å›¾3-2](#c3-fig-0002a)â€ƒä½¿ç”¨è€—å°½æšä¸¾æµ‹è¯•è´¨æ€§ã€‚'
- en: '**Finger exercise:** Change the code in [Figure 3-2](#c3-fig-0002) so that
    it returns the largest rather than the smallest divisor. Hint: if y*z = x and
    y is the smallest divisor of x, z is the largest divisor of x.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç»ƒä¹ ï¼š** ä¿®æ”¹[å›¾3-2](#c3-fig-0002)ä¸­çš„ä»£ç ï¼Œä½¿å…¶è¿”å›æœ€å¤§è€Œä¸æ˜¯æœ€å°çš„é™¤æ•°ã€‚æç¤ºï¼šå¦‚æœ`y*z = x`ä¸”`y`æ˜¯`x`çš„æœ€å°é™¤æ•°ï¼Œ`z`å°±æ˜¯`x`çš„æœ€å¤§é™¤æ•°ã€‚'
- en: The code in [Figure 3-2](#c3-fig-0002) works, but is unnecessarily inefficient.
    For example, there is no need to check even numbers beyond 2, since if an integer
    is divisible by any even number, it is divisible by 2\. The code in [Figure 3-3](#c3-fig-0003)
    takes advantage of this fact by first testing whether `x` is an even number. If
    not, it uses a loop to test whether `x` is divisible by any odd number.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[å›¾3-2](#c3-fig-0002)ä¸­çš„ä»£ç èƒ½å¤Ÿè¿è¡Œï¼Œä½†æ•ˆç‡ä¸å¿…è¦åœ°ä½ã€‚ä¾‹å¦‚ï¼Œæ£€æŸ¥å¤§äº2çš„å¶æ•°æ˜¯æ²¡æœ‰å¿…è¦çš„ï¼Œå› ä¸ºå¦‚æœä¸€ä¸ªæ•´æ•°èƒ½è¢«ä»»ä½•å¶æ•°æ•´é™¤ï¼Œé‚£ä¹ˆå®ƒå¿…å®šèƒ½è¢«2æ•´é™¤ã€‚[å›¾3-3](#c3-fig-0003)ä¸­çš„ä»£ç åˆ©ç”¨äº†è¿™ä¸€ç‚¹ï¼Œå…ˆæµ‹è¯•`x`æ˜¯å¦æ˜¯å¶æ•°ã€‚å¦‚æœä¸æ˜¯ï¼Œå®ƒä¼šä½¿ç”¨å¾ªç¯æµ‹è¯•`x`æ˜¯å¦èƒ½è¢«ä»»ä½•å¥‡æ•°æ•´é™¤ã€‚'
- en: While the code in [Figure 3-3](#c3-fig-0003) is slightly more complex than the
    code in [Figure 3-2](#c3-fig-0002), it is considerably faster, since half as many
    numbers are checked within the loop. The opportunity to trade code complexity
    for runtime efficiency is a common phenomenon. But faster does not always mean
    better. There is a lot to be said for simple code that is obviously correct and
    still fast enough to be useful.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡[å›¾3-3](#c3-fig-0003)ä¸­çš„ä»£ç æ¯”[å›¾3-2](#c3-fig-0002)ä¸­çš„ä»£ç ç¨å¤æ‚ï¼Œä½†å®ƒæ˜æ˜¾æ›´å¿«ï¼Œå› ä¸ºåœ¨å¾ªç¯ä¸­æ£€æŸ¥çš„æ•°å­—å‡å°‘äº†ä¸€åŠã€‚å°†ä»£ç å¤æ‚æ€§ä¸è¿è¡Œæ•ˆç‡è¿›è¡Œæƒè¡¡æ˜¯ä¸€ä¸ªå¸¸è§ç°è±¡ã€‚ä½†æ›´å¿«å¹¶ä¸æ€»æ„å‘³ç€æ›´å¥½ã€‚ç®€å•çš„ä»£ç æ˜æ˜¾æ­£ç¡®ï¼Œå¹¶ä¸”ä»ç„¶è¶³å¤Ÿå¿«ä»¥ä¾¿æœ‰ç”¨ï¼Œå€¼å¾—èµç¾ã€‚
- en: '![c3-fig-0003.jpg](../images/c3-fig-0003.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0003.jpg](../images/c3-fig-0003.jpg)'
- en: '[Figure 3-3](#c3-fig-0003a)â€ƒA more efficient primality test'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[å›¾3-3](#c3-fig-0003a)â€ƒæ›´é«˜æ•ˆçš„è´¨æ•°æµ‹è¯•'
- en: '**Finger exercise:** Write a program that asks the user to enter an integer
    and prints two integers, `root` and `pwr`, such that `1 < pwr < 6` and `root**pwr`
    is equal to the integer entered by the user. If no such pair of integers exists,
    it should print a message to that effect.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç»ƒä¹ ï¼š** ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œè¦æ±‚ç”¨æˆ·è¾“å…¥ä¸€ä¸ªæ•´æ•°ï¼Œå¹¶æ‰“å°ä¸¤ä¸ªæ•´æ•°`root`å’Œ`pwr`ï¼Œä½¿å¾—`1 < pwr < 6`å¹¶ä¸”`root**pwr`ç­‰äºç”¨æˆ·è¾“å…¥çš„æ•´æ•°ã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„æ•´æ•°å¯¹ï¼Œåº”è¯¥æ‰“å°ç›¸åº”çš„æ¶ˆæ¯ã€‚'
- en: '**Finger exercise:** Write a program that prints the sum of the prime numbers
    greater than 2 and less than 1000\. Hint: you probably want to have a loop that
    is a primality test nested inside a loop that iterates over the odd integers between
    3 and 999.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç»ƒä¹ ï¼š** ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œæ‰“å°å¤§äº2ä¸”å°äº1000çš„æ‰€æœ‰è´¨æ•°çš„å’Œã€‚æç¤ºï¼šä½ å¯èƒ½æƒ³è¦ä¸€ä¸ªå¾ªç¯ï¼Œå…¶ä¸­åŒ…å«ä¸€ä¸ªåµŒå¥—åœ¨å¾ªç¯å†…çš„è´¨æ•°æµ‹è¯•ï¼Œè¿­ä»£3åˆ°999ä¹‹é—´çš„å¥‡æ•°ã€‚'
- en: 3.2â€ƒApproximate Solutions and Bisection Search
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2â€ƒè¿‘ä¼¼è§£å’ŒäºŒåˆ†æŸ¥æ‰¾
- en: Imagine that someone asks you to write a program that prints the square root
    of any nonnegative number. What should you do?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡ä¸€ä¸‹ï¼Œæœ‰äººè¦æ±‚ä½ ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œæ‰“å°ä»»ä½•éè´Ÿæ•°çš„å¹³æ–¹æ ¹ã€‚ä½ åº”è¯¥æ€ä¹ˆåšï¼Ÿ
- en: You should probably start by saying that you need a better problem statement.
    For example, what should the program do if asked to find the square root of `2`?
    The square root of `2` is not a rational number. This means that there is no way
    to precisely represent its value as a finite string of digits (or as a `float)`,
    so the problem as initially stated cannot be solved.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½åº”è¯¥å…ˆè¯´ä½ éœ€è¦ä¸€ä¸ªæ›´å¥½çš„é—®é¢˜é™ˆè¿°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœè¢«è¦æ±‚æ‰¾åˆ°`2`çš„å¹³æ–¹æ ¹ï¼Œç¨‹åºåº”è¯¥æ€ä¹ˆåšï¼Ÿ`2`çš„å¹³æ–¹æ ¹ä¸æ˜¯ä¸€ä¸ªæœ‰ç†æ•°ã€‚è¿™æ„å‘³ç€æ²¡æœ‰åŠæ³•ç²¾ç¡®è¡¨ç¤ºå®ƒçš„å€¼ä¸ºæœ‰é™çš„æ•°å­—å­—ç¬¦ä¸²ï¼ˆæˆ–ä½œä¸º`float`ï¼‰ï¼Œæ‰€ä»¥æœ€åˆé™ˆè¿°çš„é—®é¢˜æ— æ³•è§£å†³ã€‚
- en: The thing a program can do is find an **approximation** to the square rootâ€”i.e.,
    an answer that is close enough to the actual square root to be useful. We will
    return to this issue in considerable detail later in the book. But for now, let's
    think of â€œclose enoughâ€ as an answer that lies within some constant, call it `epsilon`,
    of the actual answer.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ç¨‹åºå¯ä»¥åšçš„äº‹æƒ…æ˜¯æ‰¾åˆ°å¹³æ–¹æ ¹çš„**è¿‘ä¼¼å€¼**â€”â€”å³ï¼Œæ¥è¿‘å®é™…å¹³æ–¹æ ¹çš„ç­”æ¡ˆï¼Œä»¥ä¾¿æœ‰ç”¨ã€‚æˆ‘ä»¬ç¨åå°†åœ¨ä¹¦ä¸­è¯¦ç»†è®¨è®ºè¿™ä¸ªé—®é¢˜ã€‚ä½†ç°åœ¨ï¼Œè®©æˆ‘ä»¬æŠŠâ€œè¶³å¤Ÿæ¥è¿‘â€ç†è§£ä¸ºåœ¨å®é™…ç­”æ¡ˆçš„æŸä¸ªå¸¸é‡èŒƒå›´å†…ï¼Œç§°ä¹‹ä¸º`epsilon`ã€‚
- en: The code in [Figure 3-4](#c3-fig-0004) implements an algorithm that prints an
    approximation to the square root of `x`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[å›¾3-4](#c3-fig-0004)ä¸­çš„ä»£ç å®ç°äº†ä¸€ä¸ªæ‰“å°`x`çš„å¹³æ–¹æ ¹è¿‘ä¼¼å€¼çš„ç®—æ³•ã€‚'
- en: '![c3-fig-0004.jpg](../images/c3-fig-0004.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0004.jpg](../images/c3-fig-0004.jpg)'
- en: '[Figure 3-4](#c3-fig-0004a)â€ƒApproximating the square root using exhaustive
    enumeration'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[å›¾3-4](#c3-fig-0004a)â€ƒä½¿ç”¨ç©·ä¸¾æšä¸¾æ¥è¿‘ä¼¼å¹³æ–¹æ ¹'
- en: Once again, we are using exhaustive enumeration. Notice that this method for
    finding the square root has nothing in common with the way of finding square roots
    using a pencil that you might have learned in middle school. It is often the case
    that the best way to solve a problem with a computer is quite different from how
    one would approach the problem by hand.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å†æ¬¡ä½¿ç”¨ç©·ä¸¾æšä¸¾ã€‚è¯·æ³¨æ„ï¼Œè¿™ç§å¯»æ‰¾å¹³æ–¹æ ¹çš„æ–¹æ³•ä¸æ‚¨åœ¨ä¸­å­¦æ—¶å­¦åˆ°çš„ç”¨é“…ç¬”æ‰¾å¹³æ–¹æ ¹çš„æ–¹æ³•æ²¡æœ‰ä»»ä½•å…±åŒä¹‹å¤„ã€‚è®¡ç®—æœºè§£å†³é—®é¢˜çš„æœ€ä½³æ–¹æ³•é€šå¸¸ä¸æ‰‹å·¥è§£å†³é—®é¢˜çš„æ–¹æ³•å¤§ç›¸å¾„åº­ã€‚
- en: If `x` is 25, the code will print
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœ`x`æ˜¯25ï¼Œä»£ç å°†æ‰“å°
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Should we be disappointed that the program didn't figure out that `25` is a
    perfect square and print `5`? No. The program did what it was intended to do.
    Though it would have been OK to print `5`, doing so is no better than printing
    any value close enough to `5`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åº”è¯¥å¤±æœ›äºç¨‹åºæ²¡æœ‰è¯†åˆ«å‡º`25`æ˜¯ä¸€ä¸ªå®Œå…¨å¹³æ–¹å¹¶æ‰“å°`5`å—ï¼Ÿä¸ã€‚ç¨‹åºåšäº†å®ƒåº”è¯¥åšçš„äº‹ã€‚è™½ç„¶æ‰“å°`5`ä¹Ÿå¯ä»¥ï¼Œä½†è¿™æ ·åšä¸æ‰“å°ä»»ä½•æ¥è¿‘`5`çš„å€¼å¹¶æ²¡æœ‰ä»€ä¹ˆä¸åŒã€‚
- en: What do you think will happen if we set `x = 0.25`? Will it find a root close
    to `0.5`? Nope. Alas, it will report
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬è®¾å®š`x = 0.25`ï¼Œä½ è®¤ä¸ºä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿå®ƒä¼šæ‰¾åˆ°æ¥è¿‘`0.5`çš„æ ¹å—ï¼Ÿä¸ã€‚å¯æƒœï¼Œå®ƒä¼šæŠ¥å‘Š
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Exhaustive enumeration is a search technique that works only if the set of values
    being searched includes the answer. In this case, we are enumerating the values
    between `0` and the value of `x`. When `x` is between `0` and `1`, the square
    root of `x` does not lie in this interval. One way to fix this is to change the
    second operand of `and` in the first line of the `while` loop to get
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ç©·ä¸¾æšä¸¾æ˜¯ä¸€ç§æœç´¢æŠ€æœ¯ï¼Œåªæœ‰åœ¨è¢«æœç´¢çš„å€¼é›†åˆä¸­åŒ…å«ç­”æ¡ˆæ—¶æ‰æœ‰æ•ˆã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åœ¨æšä¸¾`0`åˆ°`x`çš„å€¼ã€‚å½“`x`åœ¨`0`å’Œ`1`ä¹‹é—´æ—¶ï¼Œ`x`çš„å¹³æ–¹æ ¹ä¸åœ¨è¿™ä¸ªåŒºé—´å†…ã€‚è§£å†³è¿™ä¸ªé—®é¢˜çš„ä¸€ç§æ–¹æ³•æ˜¯æ”¹å˜`while`å¾ªç¯ç¬¬ä¸€è¡Œä¸­`and`çš„ç¬¬äºŒä¸ªæ“ä½œæ•°ï¼Œä»¥å¾—åˆ°
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When we run our code after this change, it reports that
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬åœ¨è¿™ä¸ªå˜åŒ–åè¿è¡Œä»£ç æ—¶ï¼Œå®ƒæŠ¥å‘Š
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let's think about how long the program will take to run. The number of
    iterations depends upon how close the answer is to our starting point, 0, and
    on the size of the steps. Roughly speaking, the program will execute the `while`
    loop at most `x/step` times.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬æƒ³æƒ³ç¨‹åºè¿è¡Œéœ€è¦å¤šé•¿æ—¶é—´ã€‚è¿­ä»£æ¬¡æ•°å–å†³äºç­”æ¡ˆä¸æˆ‘ä»¬èµ·å§‹ç‚¹0çš„æ¥è¿‘ç¨‹åº¦ï¼Œä»¥åŠæ­¥é•¿çš„å¤§å°ã€‚ç²—ç•¥æ¥è¯´ï¼Œç¨‹åºæœ€å¤šä¼šæ‰§è¡Œ`while`å¾ªç¯`x/step`æ¬¡ã€‚
- en: Let's try the code on something bigger, e.g., `x = 123456`. It will run for
    a quite a while, and then print
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°è¯•åœ¨æ›´å¤§çš„æ•°ä¸Šè¿è¡Œä»£ç ï¼Œä¾‹å¦‚`x = 123456`ã€‚å®ƒå°†è¿è¡Œä¸€æ®µæ—¶é—´ï¼Œç„¶åæ‰“å°
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What do you think happened? Surely there is a floating-point number that approximates
    the square root of `123456` to within `0.01`. Why didn't our program find it?
    The problem is that our step size was too large, and the program skipped over
    all the suitable answers. Once again, we are exhaustively searching a space that
    doesn't contain a solution. Try making `step` equal to `epsilon**3` and running
    the program. It will eventually find a suitable answer, but you might not have
    the patience to wait for it to do so.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ è®¤ä¸ºå‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿè‚¯å®šæœ‰ä¸€ä¸ªæµ®ç‚¹æ•°å¯ä»¥å°†`123456`çš„å¹³æ–¹æ ¹è¿‘ä¼¼åˆ°`0.01`ä¹‹å†…ã€‚ä¸ºä»€ä¹ˆæˆ‘ä»¬çš„ç¨‹åºæ²¡æœ‰æ‰¾åˆ°å®ƒï¼Ÿé—®é¢˜åœ¨äºæˆ‘ä»¬çš„æ­¥é•¿å¤ªå¤§ï¼Œç¨‹åºè·³è¿‡äº†æ‰€æœ‰åˆé€‚çš„ç­”æ¡ˆã€‚æˆ‘ä»¬åˆä¸€æ¬¡åœ¨ä¸€ä¸ªä¸åŒ…å«è§£çš„ç©ºé—´ä¸­è¿›è¡Œç©·ä¸¾æœç´¢ã€‚è¯•ç€å°†`step`è®¾ä¸º`epsilon**3`å¹¶è¿è¡Œç¨‹åºã€‚å®ƒæœ€ç»ˆä¼šæ‰¾åˆ°ä¸€ä¸ªåˆé€‚çš„ç­”æ¡ˆï¼Œä½†ä½ å¯èƒ½æ²¡æœ‰è€å¿ƒç­‰å¾…å®ƒã€‚
- en: Roughly how many guesses will it have to make? The step size will be `0.000001`
    and the square root of `123456` is around `351.36`. This means that the program
    will have to make in the neighborhood of `351,000,000` guesses to find a satisfactory
    answer. We could try to speed it up by starting closer to the answer, but that
    presumes that we know the neighborhood of the answer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: å¤§æ¦‚éœ€è¦å¤šå°‘æ¬¡çŒœæµ‹ï¼Ÿæ­¥é•¿å°†æ˜¯`0.000001`ï¼Œ`123456`çš„å¹³æ–¹æ ¹å¤§çº¦æ˜¯`351.36`ã€‚è¿™æ„å‘³ç€ç¨‹åºå¿…é¡»è¿›è¡Œå¤§çº¦`351,000,000`æ¬¡çŒœæµ‹æ‰èƒ½æ‰¾åˆ°æ»¡æ„çš„ç­”æ¡ˆã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡æ›´æ¥è¿‘ç­”æ¡ˆçš„èµ·å§‹ç‚¹æ¥åŠ é€Ÿï¼Œä½†è¿™å‡è®¾æˆ‘ä»¬çŸ¥é“ç­”æ¡ˆçš„é‚»åŸŸã€‚
- en: The time has come to look for a different way to attack the problem. We need
    to choose a better algorithm rather than fine-tune the current one. But before
    doing so, let's look at a problem that, at first blush, appears to be completely
    different from root finding.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æ˜¯å¯»æ‰¾ä¸åŒæ–¹æ³•è§£å†³é—®é¢˜çš„æ—¶å€™äº†ã€‚æˆ‘ä»¬éœ€è¦é€‰æ‹©ä¸€ä¸ªæ›´å¥½çš„ç®—æ³•ï¼Œè€Œä¸æ˜¯å¾®è°ƒå½“å‰çš„ç®—æ³•ã€‚ä½†åœ¨è¿™æ ·åšä¹‹å‰ï¼Œè®©æˆ‘ä»¬çœ‹ä¸€ä¸ªä¹ä¸€çœ‹ä¸æ ¹å¯»æ‰¾å®Œå…¨ä¸åŒçš„é—®é¢˜ã€‚
- en: Consider the problem of discovering whether a word starting with a given sequence
    of letters appears in a hard-copy dictionary[^(22)](#c3-fn-0001) of the English
    language. Exhaustive enumeration would, in principle, work. You could begin at
    the first word and examine each word until either you found a word starting with
    the sequence of letters or you ran out of words to examine. If the dictionary
    contained `n` words, it would, on average, take `n/2` probes to find the word.
    If the word were not in the dictionary, it would take `n` probes. Of course, those
    who have had the pleasure of looking a word up in a physical (rather than online)
    dictionary would never proceed in this way.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘å‘ç°ä¸€ä¸ªä»¥ç»™å®šå­—æ¯åºåˆ—å¼€å¤´çš„å•è¯æ˜¯å¦å‡ºç°åœ¨è‹±è¯­çš„çº¸è´¨å­—å…¸[^(22)](#c3-fn-0001)ä¸­çš„é—®é¢˜ã€‚ç†è®ºä¸Šï¼Œç©·ä¸¾æšä¸¾æ˜¯å¯è¡Œçš„ã€‚ä½ å¯ä»¥ä»ç¬¬ä¸€ä¸ªå•è¯å¼€å§‹ï¼Œæ£€æŸ¥æ¯ä¸ªå•è¯ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªä»¥è¯¥å­—æ¯åºåˆ—å¼€å¤´çš„å•è¯ï¼Œæˆ–è€…æ£€æŸ¥å®Œæ‰€æœ‰å•è¯ã€‚å¦‚æœå­—å…¸åŒ…å«
    `n` ä¸ªå•è¯ï¼Œå¹³å‡éœ€è¦ `n/2` æ¬¡æŸ¥è¯¢æ‰èƒ½æ‰¾åˆ°è¯¥å•è¯ã€‚å¦‚æœè¯¥å•è¯ä¸åœ¨å­—å…¸ä¸­ï¼Œåˆ™éœ€è¦ `n` æ¬¡æŸ¥è¯¢ã€‚å½“ç„¶ï¼Œé‚£äº›æ›¾ç»åœ¨çº¸è´¨ï¼ˆè€Œéåœ¨çº¿ï¼‰å­—å…¸ä¸­æŸ¥æ‰¾å•è¯çš„äººæ°¸è¿œä¸ä¼šä»¥è¿™ç§æ–¹å¼è¿›è¡Œã€‚
- en: Fortunately, the folks who publish hard-copy dictionaries go to the trouble
    of putting the words in lexicographical order. This allows us to open the book
    to a page where we think the word might lie (e.g., near the middle for words starting
    with the letter m). If the sequence of letters lexicographically precedes the
    first word on the page, we know to go backwards. If the sequence of letters follows
    the last word on the page, we know to go forwards. Otherwise, we check whether
    the sequence of letters matches a word on the page.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¸è¿çš„æ˜¯ï¼Œå‡ºç‰ˆçº¸è´¨å­—å…¸çš„äººä¼šè´¹å¿ƒå°†å•è¯æŒ‰å­—å…¸é¡ºåºæ’åˆ—ã€‚è¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿæ‰“å¼€ä¹¦æœ¬åˆ°æˆ‘ä»¬è®¤ä¸ºè¯¥å•è¯å¯èƒ½å­˜åœ¨çš„ä¸€é¡µï¼ˆä¾‹å¦‚ï¼Œå¯¹äºä»¥å­—æ¯ m å¼€å¤´çš„å•è¯ï¼Œé€šå¸¸æ˜¯åœ¨ä¸­é—´é™„è¿‘ï¼‰ã€‚å¦‚æœå­—æ¯åºåˆ—åœ¨é¡µé¢ä¸Šç¬¬ä¸€ä¸ªå•è¯ä¹‹å‰ï¼Œæˆ‘ä»¬å°±çŸ¥é“è¦å‘åæŸ¥æ‰¾ã€‚å¦‚æœå­—æ¯åºåˆ—åœ¨é¡µé¢ä¸Šæœ€åä¸€ä¸ªå•è¯ä¹‹åï¼Œæˆ‘ä»¬å°±çŸ¥é“è¦å‘å‰æŸ¥æ‰¾ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬æ£€æŸ¥å­—æ¯åºåˆ—æ˜¯å¦ä¸é¡µé¢ä¸Šçš„å•è¯åŒ¹é…ã€‚
- en: Now let's take the same idea and apply it to the problem of finding the square
    root of x. Suppose we know that a good approximation to the square root of `x`
    lies somewhere between `0` and `max`. We can exploit the fact that numbers are
    **totally ordered**. That is, for any pair of distinct numbers, `n1` and `n2`,
    either `n1Â <Â n2` or `n1Â >Â n2`. So, we can think of the square root of x as lying
    somewhere on the line
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ¥æŠŠåŒæ ·çš„æ€è·¯åº”ç”¨äºå¯»æ‰¾ x çš„å¹³æ–¹æ ¹çš„é—®é¢˜ã€‚å‡è®¾æˆ‘ä»¬çŸ¥é“ `x` çš„å¹³æ–¹æ ¹çš„ä¸€ä¸ªå¥½è¿‘ä¼¼å€¼ä½äº `0` å’Œ `max` ä¹‹é—´ã€‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨æ•°å­—æ˜¯**å®Œå…¨æœ‰åº**çš„è¿™ä¸€äº‹å®ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºä»»ä½•ä¸€å¯¹ä¸åŒçš„æ•°å­—ï¼Œ`n1`
    å’Œ `n2`ï¼Œè¦ä¹ˆ `n1 < n2`ï¼Œè¦ä¹ˆ `n1 > n2`ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è®¤ä¸º x çš„å¹³æ–¹æ ¹ä½äºä»¥ä¸‹çº¿æ®µä¸Š
- en: '`0`_________________________________________________________`max`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`_________________________________________________________`max`'
- en: and start searching that interval. Since we don't necessarily know where to
    start searching, let's start in the middle.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åå¼€å§‹æœç´¢è¯¥åŒºé—´ã€‚ç”±äºæˆ‘ä»¬ä¸ä¸€å®šçŸ¥é“ä»å“ªé‡Œå¼€å§‹æœç´¢ï¼Œè®©æˆ‘ä»¬ä»ä¸­é—´å¼€å§‹ã€‚
- en: '`0`__________________________guess__________________________`max`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`__________________________guess__________________________`max`'
- en: If that is not the right answer (and it won't be most of the time), ask whether
    it is too big or too small. If it is too big, we know that the answer must lie
    to the left. If it is too small, we know that the answer must lie to the right.
    We then repeat the process on the smaller interval. [Figure 3-5](#c3-fig-0005)
    contains an implementation and test of this algorithm.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœè¿™ä¸æ˜¯æ­£ç¡®çš„ç­”æ¡ˆï¼ˆå¤§å¤šæ•°æ—¶å€™éƒ½ä¸æ˜¯ï¼‰ï¼Œè¯·è¯¢é—®å®ƒæ˜¯å¤ªå¤§è¿˜æ˜¯å¤ªå°ã€‚å¦‚æœå¤ªå¤§ï¼Œæˆ‘ä»¬çŸ¥é“ç­”æ¡ˆå¿…é¡»åœ¨å·¦ä¾§ã€‚å¦‚æœå¤ªå°ï¼Œæˆ‘ä»¬çŸ¥é“ç­”æ¡ˆå¿…é¡»åœ¨å³ä¾§ã€‚ç„¶åæˆ‘ä»¬åœ¨æ›´å°çš„åŒºé—´ä¸Šé‡å¤è¿™ä¸ªè¿‡ç¨‹ã€‚[å›¾
    3-5](#c3-fig-0005) åŒ…å«äº†è¯¥ç®—æ³•çš„å®ç°å’Œæµ‹è¯•ã€‚
- en: '![c3-fig-0005.jpg](../images/c3-fig-0005.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0005.jpg](../images/c3-fig-0005.jpg)'
- en: '[Figure 3-5](#c3-fig-0005a)â€ƒUsing bisection search to approximate square root'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[å›¾ 3-5](#c3-fig-0005)â€ƒä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ¥è¿‘ä¼¼å¹³æ–¹æ ¹'
- en: When run for `x` = 25, it prints
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: å½“è¿è¡Œ `x` = 25 æ—¶ï¼Œå®ƒæ‰“å°
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that it finds a different answer than our earlier algorithm. That is
    perfectly fine, since it still meets the problem's specification.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œå®ƒæ‰¾åˆ°çš„ç­”æ¡ˆä¸æˆ‘ä»¬æ—©æœŸçš„ç®—æ³•ä¸åŒã€‚è¿™å®Œå…¨æ²¡é—®é¢˜ï¼Œå› ä¸ºå®ƒä»ç„¶ç¬¦åˆé—®é¢˜çš„è§„èŒƒã€‚
- en: More important, notice that at each iteration of the loop, the size of the space
    to be searched is cut in half. For this reason, the algorithm is called **bisection
    search**. Bisection search is a huge improvement over our earlier algorithm, which
    reduced the search space by only a small amount at each iteration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´é‡è¦çš„æ˜¯ï¼Œè¯·æ³¨æ„åœ¨å¾ªç¯çš„æ¯æ¬¡è¿­ä»£ä¸­ï¼Œè¦æœç´¢çš„ç©ºé—´å¤§å°å‡åŠã€‚å› æ­¤ï¼Œè¯¥ç®—æ³•è¢«ç§°ä¸º**äºŒåˆ†æŸ¥æ‰¾**ã€‚äºŒåˆ†æŸ¥æ‰¾ç›¸æ¯”äºæˆ‘ä»¬æ—©æœŸçš„ç®—æ³•æœ‰äº†å·¨å¤§çš„æ”¹è¿›ï¼Œåè€…åœ¨æ¯æ¬¡è¿­ä»£ä¸­ä»…å‡å°‘äº†å°‘é‡æœç´¢ç©ºé—´ã€‚
- en: Let us try `x = 123456` again. This time the program takes only 30 guesses to
    find an acceptable answer. How about `x = 123456789` ? It takes only 45 guesses.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å†æ¬¡å°è¯•`x = 123456`ã€‚è¿™æ¬¡ç¨‹åºä»…éœ€30æ¬¡çŒœæµ‹å°±èƒ½æ‰¾åˆ°ä¸€ä¸ªå¯æ¥å—çš„ç­”æ¡ˆã€‚`x = 123456789`å‘¢ï¼Ÿä»…éœ€45æ¬¡çŒœæµ‹ã€‚
- en: There is nothing special about using this algorithm to find square roots. For
    example, by changing a couple of `2`'s to `3`'s, we can use it to approximate
    a cube root of a nonnegative number. In Chapter 4, we introduce a language mechanism
    that allows us to generalize this code to find any root.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¯¥ç®—æ³•æ¥å¯»æ‰¾å¹³æ–¹æ ¹å¹¶æ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«ä¹‹å¤„ã€‚ä¾‹å¦‚ï¼Œé€šè¿‡å°†å‡ ä¸ª`2`æ”¹ä¸º`3`ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥è¿‘ä¼¼ä¸€ä¸ªéè´Ÿæ•°çš„ç«‹æ–¹æ ¹ã€‚åœ¨ç¬¬4ç« ä¸­ï¼Œæˆ‘ä»¬å°†ä»‹ç»ä¸€ç§è¯­è¨€æœºåˆ¶ï¼Œä½¿æˆ‘ä»¬èƒ½å¤Ÿå°†è¿™æ®µä»£ç æ¨å¹¿åˆ°å¯»æ‰¾ä»»ä½•æ ¹ã€‚
- en: Bisection search is a widely useful technique for many things other than finding
    roots. For example, the code in [Figure 3-6](#c3-fig-0006) uses bisection search
    to find an approximation to the log base 2 of `x` (i.e., a number, `ans`, such
    that `2**ans` is close to `x`). It is structured exactly like the code used to
    find an approximation to a square root. It first finds an interval containing
    a suitable answer, and then uses bisection search to efficiently explore that
    interval.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: äºŒåˆ†æœç´¢æ˜¯ä¸€ç§å¹¿æ³›é€‚ç”¨çš„æŠ€æœ¯ï¼Œé™¤äº†å¯»æ‰¾æ ¹ä»¥å¤–è¿˜å¯ä»¥ç”¨äºè®¸å¤šå…¶ä»–äº‹æƒ…ã€‚ä¾‹å¦‚ï¼Œ[å›¾ 3-6](#c3-fig-0006)ä¸­çš„ä»£ç ä½¿ç”¨äºŒåˆ†æœç´¢æ¥å¯»æ‰¾`x`çš„ä»¥2ä¸ºåº•çš„å¯¹æ•°çš„è¿‘ä¼¼å€¼ï¼ˆå³ï¼Œä¸€ä¸ªæ•°å­—`ans`ï¼Œä½¿å¾—`2**ans`æ¥è¿‘äº`x`ï¼‰ã€‚å®ƒçš„ç»“æ„ä¸ç”¨äºå¯»æ‰¾å¹³æ–¹æ ¹è¿‘ä¼¼å€¼çš„ä»£ç å®Œå…¨ç›¸åŒã€‚å®ƒé¦–å…ˆæ‰¾åˆ°ä¸€ä¸ªåŒ…å«åˆé€‚ç­”æ¡ˆçš„åŒºé—´ï¼Œç„¶åä½¿ç”¨äºŒåˆ†æœç´¢é«˜æ•ˆåœ°æ¢ç´¢è¯¥åŒºé—´ã€‚
- en: '![c3-fig-0006.jpg](../images/c3-fig-0006.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![c3-fig-0006.jpg](../images/c3-fig-0006.jpg)'
- en: '[Figure 3-6](#c3-fig-0006a)â€ƒUsing bisection search to estimate log base 2'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[å›¾ 3-6](#c3-fig-0006)â€ƒä½¿ç”¨äºŒåˆ†æœç´¢æ¥ä¼°è®¡ä»¥2ä¸ºåº•çš„å¯¹æ•°'
- en: Bisection search is an example of a **successive approximation** method. Such
    methods work by making a sequence of guesses with the property that each guess
    is closer to a correct answer than the previous guess. We will look at an important
    successive approximation algorithm, Newton's method, later in this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: äºŒåˆ†æœç´¢æ˜¯**é€æ¬¡é€¼è¿‘**æ–¹æ³•çš„ä¸€ä¸ªç¤ºä¾‹ã€‚è¿™ç§æ–¹æ³•é€šè¿‡ä¸€ç³»åˆ—çŒœæµ‹æ¥å·¥ä½œï¼Œæ¯ä¸ªçŒœæµ‹éƒ½æ¯”å‰ä¸€ä¸ªçŒœæµ‹æ›´æ¥è¿‘æ­£ç¡®ç­”æ¡ˆã€‚æˆ‘ä»¬å°†åœ¨æœ¬ç« ç¨åè®¨è®ºä¸€ä¸ªé‡è¦çš„é€æ¬¡é€¼è¿‘ç®—æ³•ï¼Œç‰›é¡¿æ³•ã€‚
- en: '**Finger exercise:** What would the code in [Figure 3-5](#c3-fig-0005) do if
    `x = -25`?'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**åŠ¨æ‰‹ç»ƒä¹ ï¼š** å¦‚æœ`x = -25`ï¼Œé‚£ä¹ˆ[å›¾ 3-5](#c3-fig-0005)ä¸­çš„ä»£ç ä¼šåšä»€ä¹ˆï¼Ÿ'
- en: '**Finger exercise:** What would have to be changed to make the code in [Figure
    3-5](#c3-fig-0005) work for finding an approximation to the cube root of both
    negative and positive numbers? Hint: think about changing `low` to ensure that
    the answer lies within the region being searched.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**åŠ¨æ‰‹ç»ƒä¹ ï¼š** ä¸ºäº†è®©[å›¾ 3-5](#c3-fig-0005)ä¸­çš„ä»£ç èƒ½å¤Ÿæ‰¾åˆ°è´Ÿæ•°å’Œæ­£æ•°çš„ç«‹æ–¹æ ¹è¿‘ä¼¼å€¼ï¼Œéœ€è¦åšå‡ºä»€ä¹ˆæ›´æ”¹ï¼Ÿæç¤ºï¼šè€ƒè™‘æ”¹å˜`low`ä»¥ç¡®ä¿ç­”æ¡ˆä½äºè¢«æœç´¢çš„åŒºåŸŸå†…ã€‚'
- en: '**Finger exercise:** The Empire State Building is 102 stories high. A man wanted
    to know the highest floor from which he could drop an egg without the egg breaking.
    He proposed to drop an egg from the top floor. If it broke, he would go down a
    floor, and try it again. He would do this until the egg did not break. At worst,
    this method requires 102 eggs. Implement a method that at worst uses seven eggs.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**åŠ¨æ‰‹ç»ƒä¹ ï¼š** å¸å›½å¤§å¦æœ‰102å±‚ã€‚ä¸€åç”·å­æƒ³çŸ¥é“ä»–å¯ä»¥ä»å“ªä¸ªæœ€é«˜æ¥¼å±‚æ‰”é¸¡è›‹è€Œä¸ä¼šç ´ã€‚äºæ˜¯ä»–æå‡ºä»é¡¶æ¥¼æ‰”ä¸€ä¸ªé¸¡è›‹ã€‚å¦‚æœé¸¡è›‹ç ´äº†ï¼Œä»–å°±ä¸‹é™ä¸€å±‚ï¼Œå†è¯•ä¸€æ¬¡ã€‚ä»–ä¼šä¸€ç›´è¿™æ ·åšï¼Œç›´åˆ°é¸¡è›‹ä¸ç ´ã€‚æœ€åæƒ…å†µä¸‹ï¼Œè¿™ç§æ–¹æ³•éœ€è¦102ä¸ªé¸¡è›‹ã€‚å®ç°ä¸€ç§æ–¹æ³•ï¼Œæœ€å¤šåªä½¿ç”¨ä¸ƒä¸ªé¸¡è›‹ã€‚'
- en: 3.3â€ƒA Few Words about Using Floats
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3â€ƒå…³äºä½¿ç”¨æµ®ç‚¹æ•°çš„å‡ ç‚¹è¯´æ˜
- en: Most of the time, numbers of type `float` provide a reasonably good approximation
    to real numbers. But â€œmost of the timeâ€ is not all of the time, and when they
    don't, it can lead to surprising consequences. For example, try running the code
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œ`float`ç±»å‹çš„æ•°å­—èƒ½å¤Ÿ reasonably åœ°è¿‘ä¼¼çœŸå®æ•°å­—ã€‚ä½†â€œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹â€å¹¶ä¸æ„å‘³ç€åœ¨æ‰€æœ‰æƒ…å†µä¸‹ï¼Œå½“å®ƒä»¬ä¸å‡†ç¡®æ—¶ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ„æƒ³ä¸åˆ°çš„åæœã€‚ä¾‹å¦‚ï¼Œå°è¯•è¿è¡Œä»¥ä¸‹ä»£ç ï¼š
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Perhaps you, like most people, find it surprising that it prints,
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è®¸ä½ å’Œå¤§å¤šæ•°äººä¸€æ ·ï¼Œå‘ç°å®ƒæ‰“å°çš„ç»“æœä»¤äººæƒŠè®¶ã€‚
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Why does it get to the `else` clause in the first place?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆå®ƒé¦–å…ˆä¼šè¿›å…¥`else`è¯­å¥å‘¢ï¼Ÿ
- en: To understand why this happens, we need to understand how floating-point numbers
    are represented in the computer during a computation. To understand that, we need
    to understand **binary numbers**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: è¦ç†è§£ä¸ºä»€ä¹ˆä¼šå‘ç”Ÿè¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬éœ€è¦äº†è§£åœ¨è®¡ç®—è¿‡ç¨‹ä¸­æµ®ç‚¹æ•°æ˜¯å¦‚ä½•åœ¨è®¡ç®—æœºä¸­è¡¨ç¤ºçš„ã€‚è¦ç†è§£è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£**äºŒè¿›åˆ¶æ•°**ã€‚
- en: When you first learned about decimal numbersâ€”i.e., numbers base `10`â€”you learned
    that any decimal number can be represented by a sequence of the digits `0123456789`.
    The rightmost digit is the `10`â° place, the next digit towards the left is the
    `10`Â¹ place, etc. For example, the sequence of decimal digits `302` represents
    `3`*`100` `+ 0`*`10 + 2`*`1`. How many different numbers can be represented by
    a sequence of length `n`? A sequence of length `1` can represent any one of 10
    numbers (`0-9`); a sequence of length 2 can represent 100 different numbers (`0-99`).
    More generally, a sequence of length n can represent `10`^n different numbers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Binary numbersâ€”numbers base `2`â€”work similarly. A binary number is represented
    by a sequence of digits each of which is either `0` or `1`. These digits are often
    called **bits**. The rightmost digit is the `2`â°place, the next digit towards
    the left is the `2`Â¹ place, etc. For example, the sequence of binary digits `101`
    represents `1`*`4 + 0`*`2 + 1`*`1 = 5`. How many different numbers can be represented
    by a sequence of length n? `2`^n.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** What is the decimal equivalent of the binary number `10011`?'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps because most people have ten fingers, we like to use decimals to represent
    numbers. On the other hand, all modern computer systems represent numbers in binary.
    This is not because computers are born with two fingers. It is because it is easy
    to build hardware **switches**, i.e., devices that can be in only one of two states,
    on or off. That computers use a binary representation and people a decimal representation
    can lead to occasional cognitive dissonance.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: In modern programming languages non-integer numbers are implemented using a
    representation called **floating point**. For the moment, let's pretend that the
    internal representation is in decimal. We would represent a number as a pair of
    integersâ€”the **significant digits** of the number and an **exponent**. For example,
    the number `1.949` would be represented as the pair `(1949, -3)`, which stands
    for the product `1949`*`10`^(-3).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The number of significant digits determines the **precision** with which numbers
    can be represented. If, for example, there were only two significant digits, the
    number `1.949` could not be represented exactly. It would have to be converted
    to some approximation of `1.949`, in this case `1.9`. That approximation is called
    the **rounded value**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Modern computers use binary, not decimal, representations. They represent the
    significant digits and exponents in binary rather than decimal, and raise `2`
    rather than `10` to the exponent. For example, the number represented by the decimal
    digits `0.625` (`5/8`) would be represented as the pair `(101, -11)`; `b`ecause
    `101` is the binary representation of the number 5 and -`11` is the binary representation
    of -3, the pair `(101, -11)` stands for `5`*`2`^(-3) `= 5/8 = 0.625`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: What about the decimal fraction `1/10`, which we write in Python as `0.1`? The
    best we can do with four significant binary digits is `(0011, -101)`. This is
    equivalent to `3/32`, i.e., `0.09375`. If we had five significant binary digits,
    we would represent `0.1` as `(11001, -1000)`, which is equivalent to `25/256`,
    i.e., `0.09765625`. How many significant digits would we need to get an exact
    floating-point representation of `0.1`? An infinite number of digits! There do
    not exist integers `sig` and `exp` such that `sig` * `2`^(-exp) equals `0.1`.
    So, no matter how many bits Python (or any other language) uses to represent floating-point
    numbers, it can represent only an approximation to `0.1`. In most Python implementations,
    there are `53` bits of precision available for floating-point numbers, so the
    significant digits stored for the decimal number `0.1` will be
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆåè¿›åˆ¶åˆ†æ•°`1/10`ï¼Œæˆ‘ä»¬åœ¨Pythonä¸­å†™ä½œ`0.1`ï¼Œæœ€ä½³çš„å››ä¸ªæœ‰æ•ˆäºŒè¿›åˆ¶æ•°å­—æ˜¯`(0011, -101)`ã€‚è¿™ç›¸å½“äº`3/32`ï¼Œå³`0.09375`ã€‚å¦‚æœæˆ‘ä»¬æœ‰äº”ä¸ªæœ‰æ•ˆäºŒè¿›åˆ¶æ•°å­—ï¼Œæˆ‘ä»¬å°†`0.1`è¡¨ç¤ºä¸º`(11001,
    -1000)`ï¼Œè¿™ç›¸å½“äº`25/256`ï¼Œå³`0.09765625`ã€‚æˆ‘ä»¬éœ€è¦å¤šå°‘ä¸ªæœ‰æ•ˆæ•°å­—æ‰èƒ½å‡†ç¡®è¡¨ç¤º`0.1`çš„æµ®ç‚¹æ•°ï¼Ÿæ— é™å¤šä¸ªæ•°å­—ï¼ä¸å­˜åœ¨æ•´æ•°`sig`å’Œ`exp`ä½¿å¾—`sig`
    * `2^(-exp)`ç­‰äº`0.1`ã€‚å› æ­¤ï¼Œæ— è®ºPythonï¼ˆæˆ–ä»»ä½•å…¶ä»–è¯­è¨€ï¼‰ä½¿ç”¨å¤šå°‘ä½æ¥è¡¨ç¤ºæµ®ç‚¹æ•°ï¼Œå®ƒåªèƒ½è¡¨ç¤ºå¯¹`0.1`çš„è¿‘ä¼¼ã€‚åœ¨å¤§å¤šæ•°Pythonå®ç°ä¸­ï¼Œæµ®ç‚¹æ•°å¯ç”¨`53`ä½ç²¾åº¦ï¼Œå› æ­¤å­˜å‚¨çš„åè¿›åˆ¶æ•°`0.1`çš„æœ‰æ•ˆæ•°å­—å°†æ˜¯ã€‚
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is equivalent to the decimal number
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç›¸å½“äºåè¿›åˆ¶æ•°ã€‚
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Pretty close to `1/10`, but not exactly `1/10`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: éå¸¸æ¥è¿‘`1/10`ï¼Œä½†å¹¶ä¸å®Œå…¨æ˜¯`1/10`ã€‚
- en: Returning to the original mystery, why does
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: å›åˆ°æœ€åˆçš„è°œé¢˜ï¼Œä¸ºä»€ä¹ˆã€‚
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: print
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰“å°ã€‚
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '``We now see that the test `x == 1.0` produces the result `False` because the
    value to which `x` is bound is not exactly `1.0`. This explains why the `else`
    clause was executed. But why did it decide that `x` was less than 1.0 when the
    floating-point representation of 0.1 is slightly greater than 0.1? Because during
    some iteration of the loop, Python ran out of significant digits and did some
    rounding, which happened to be downwards. What gets printed if we add to the end
    of the `else` clause the code `print x == 10.0*0.1`? It prints `False`. It''s
    not what our elementary school teachers taught us, but adding `0.1` ten times
    does not produce the same value as multiplying `0.1` by `10`.    By the way, if
    you want to explicitly round a floating-point number, use the `round` function.
    The expression `round(x, num_digits)` returns the floating-point number equivalent
    to rounding the value of `x` to `num_digits` digits following the decimal point.
    For example, printÂ `round(2**0.5, 3)` will print `1.414` as an approximation to
    the square root of 2.    Does the difference between real and floating-point numbers
    really matter? Most of the time, mercifully, it does not. There are few situations
    where the difference between `0.9999999999999999`, `1.0`, and `1.00000000000000001`
    matter. However, one thing that is almost always worth worrying about is tests
    for equality. As we have seen, using `==` to compare two floating-point values
    can produce a surprising result. It is almost always more appropriate to ask whether
    two floating point values are close enough to each other, not whether they are
    identical. So, for example, it is better to write `abs(xâ€‘y) < 0.0001` rather than
    `x == y`.    Another thing to worry about is the accumulation of rounding errors.
    Most of the time things work out okay, because sometimes the number stored in
    the computer is a little bigger than intended, and sometimes it is a little smaller
    than intended. However, in some programs, the errors will all be in the same direction
    and accumulate over time.``  ``## 3.4â€ƒNewtonâ€“Raphson[^(23)](#c3-fn-0002)    The
    most commonly used approximation algorithm is usually attributed to Isaac Newton.
    It is typically called Newton''s method, but is sometimes referred to as the **Newtonâ€“Raphson**
    method.[^(24)](#c3-fn-0003) It can be used to find the real roots of many functions,
    but we will look at it only in the context of finding the real roots of a polynomial
    with one variable. The generalization to polynomials with multiple variables is
    straightforward both mathematically and algorithmically.    A **polynomial** with
    one variable (by convention, we write the variable as `*x*`) is either 0 or the
    sum of a finite number of nonzero terms, e.g., `3*x*Â² + 2*x* + 3`. Each term,
    e.g., `3*x*Â²`, consists of a constant (the **coefficient** of the term, `3` in
    this case) multiplied by the variable (`*x*` in this case) raised to a nonnegative
    integer exponent (`2` in this case). The exponent in a term is called the **degree**
    of that term. The degree of a polynomial is the largest degree of any single term.
    Some examples are `3` (degree `0`), `2.5*x* + 12` (degree `1`), and `3*x*Â²` (degreeÂ 2).    If
    `*p*` is a polynomial and `*r*` a real number, we will write `*p*(*r*)` to stand
    for the value of the polynomial when `*x* = *r*`. A **root** of the polynomial
    `*p*` is a solution to the equation `*p* = 0`, i.e., an `*r*` such that `*p*(*r*)
    = 0`. So, for example, the problem of finding an approximation to the square root
    of `24` can be formulated as finding an *x* such that `*x*Â² âˆ’ 24` is close to
    `0`.    Newton proved a theorem that implies that if a value, call it `*guess*`,
    is an approximation to a root of a polynomial, then `*guess* âˆ’ ğ‘(*guess*)/ğ‘â€™(*guess*)`,
    where `*p*â€™` is the first derivative of `*p*`, is a better approximation than
    `*guess*`.    The first derivative of a function `*f*(*x*)` can be thought of
    as expressing how the value of `*f*(*x*)` changes with respect to changes in `*x*`.
    For example, the first derivative of a constant is 0, because the value of a constant
    doesn''t change. For any term `*c***x^p*`, the first derivative of that term is
    `*c***p***x^p*^(âˆ’1)`. So, the first derivative of a polynomial of the form  ![c3-fig-5001.jpg](../images/c3-fig-5001.jpg)      is  ![c3-fig-5002.jpg](../images/c3-fig-5002.jpg)      To
    find the square root of a number, say *k*, we need to find a value *x* such that
    `*x*Â² âˆ’ *k* = 0`. The first derivative of this polynomial is simply `2*x*`. Therefore,
    we know that we can improve on the current guess by choosing as our next guess
    `*guess* âˆ’ (*guess*2 âˆ’ ğ‘˜)/2 * *guess*`. [Figure 3-7](#c3-fig-0009) contains code
    illustrating how to use this method to quickly find an approximation to the square
    root.  ![c3-fig-0007.jpg](../images/c3-fig-0007.jpg)    [Figure 3-7](#c3-fig-0009a)â€ƒImplementation
    of Newtonâ€“Raphson method      **Finger exercise:** Add some code to the implementation
    of Newtonâ€“Raphson that keeps track of the number of iterations used to find the
    root. Use that code as part of a program that compares the efficiency of Newtonâ€“Raphson
    and bisection search. (You should discover that Newtonâ€“Raphson is far more efficient.)    ##
    3.5â€ƒTerms Introduced in Chapter    *   decrementing function *   guess-and-check
    *   exhaustive enumeration *   approximation *   total ordering *   bisection
    search *   successive approximation *   binary numbers *   bit *   switch *   floating
    point *   significant digits *   exponent *   precision *   rounding *   Newtonâ€“Raphson
    *   polynomial *   coefficient *   degree *   root``'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
