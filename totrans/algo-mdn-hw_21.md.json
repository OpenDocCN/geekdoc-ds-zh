["```cpp\nfor (unsigned int i = 0; i < n; i++) {  // ... } \n```", "```cpp\nT at(size_t k) {  if (k >= size()) throw std::out_of_range(\"Array index exceeds its size\"); return _memory[k]; } \n```", "```cpp\nvoid assume(bool pred) {  if (!pred) __builtin_unreachable(); } \n```", "```cpp\nunsigned div_unsigned(unsigned x) {  return x / 2; } \n```", "```cpp\nshr eax \n```", "```cpp\nint div_signed(int x) {  return x / 2; } \n```", "```cpp\nmov  ebx, eax shr  ebx, 31    ; extract the sign bit add  eax, ebx   ; add 1 to the value if it is negative to ensure rounding towards zero sar  eax        ; this one shifts in sign bits \n```", "```cpp\nint div_assume(int x) {  assume(x >= 0); return x / 2; } \n```", "```cpp\nvoid add(int *a, int *b, int n) {  for (int i = 0; i < n; i++) a[i] += b[i]; } \n```", "```cpp\nvoid add(int * __restrict__ a, const int * __restrict__ b, int n) {  for (int i = 0; i < n; i++) a[i] += b[i]; } \n```", "```cpp\nT at(size_t k) [[ expects: k < n ]] {  return _memory[k]; } \n```", "```cpp\nbool is_power_of_two(int m) {  return m > 0 && (m & (m - 1) == 0); }   int mod_power_of_two(int x, int m)  [[ expects: x >= 0 ]] [[ expects: is_power_of_two(m) ]] [[ ensures r: r >= 0 && r < m ]] {  int r = x & (m - 1); [[ assert: r = x % m ]]; return r; } \n```"]