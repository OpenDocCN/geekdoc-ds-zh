<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Case Study: Hanging Square*</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Case Study: Hanging Square*</h1>
<blockquote>原文：<a href="https://phys-sim-book.github.io/lec5.3-hanging_square.html">https://phys-sim-book.github.io/lec5.3-hanging_square.html</a></blockquote>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"/>

<p>We use a simple case study to end this lecture. Based on the <a href="lec4-2d_mass_spring.html">mass-spring system</a> developed in a previous section, we implement gravitational energy and sticky Dirichlet boundary conditions to simulate a hanging square.
The excutable Python project for this section can be found at <a href="https://github.com/phys-sim-book/solid-sim-tutorial">https://github.com/phys-sim-book/solid-sim-tutorial</a> under the <code>2_dirichlet</code> folder.
<a href="https://github.com/MuGdxy/muda">MUDA</a> GPU implementations can be found at <a href="https://github.com/phys-sim-book/solid-sim-tutorial-gpu">https://github.com/phys-sim-book/solid-sim-tutorial-gpu</a> under the <code>simulators/2_dirichlet</code> folder.</p>
<p>Gravitational energy has
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"/><span class="mord">−</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"/><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">∇</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"/><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"/><span class="mspace" style="margin-right:0.1667em;"/><span class="mord text"><span class="mord">and</span></span><span class="mspace" style="margin-right:1em;"/><span class="mord"><span class="mord">∇</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"/><span class="mord">0</span><span class="mpunct">,</span></span></span></span></span>
which can be trivially implemented:</p>
<p><a name="imp:lec5:GravityEnergy"/>
<strong>Implementation 5.3.1 (GravityEnergy.py).</strong></p>
<pre><code class="language-python">import numpy as np

gravity = [0.0, -9.81]

def val(x, m):
    sum = 0.0
    for i in range(0, len(x)):
        sum += -m[i] * x[i].dot(gravity)
    return sum

def grad(x, m):
    g = np.array([gravity] * len(x))
    for i in range(0, len(x)):
        g[i] *= -m[i]
    return g

# Hessian is 0
</code></pre>
<p>Then we just need to make sure the gravitational energy is added into the Incremental Potential (IP):</p>
<p><a name="imp:lec5:time_integrator_1"/>
<strong>Implementation 5.3.2 (Adding gravity to IP, time_integrator.py).</strong></p>
<pre><code class="language-python">def IP_val(x, e, x_tilde, m, l2, k, h):
    return InertiaEnergy.val(x, x_tilde, m) + h * h * (MassSpringEnergy.val(x, e, l2, k) + GravityEnergy.val(x, m))     # implicit Euler

def IP_grad(x, e, x_tilde, m, l2, k, h):
    return InertiaEnergy.grad(x, x_tilde, m) + h * h * (MassSpringEnergy.grad(x, e, l2, k) + GravityEnergy.grad(x, m))   # implicit Euler
</code></pre>
<p>For the sticky Dirichlet boundary condition, we modify the system accordingly when computing search direction:</p>
<p><a name="imp:lec5:time_integrator_2"/>
<strong>Implementation 5.3.3 (DOF elimination, time_integrator.py).</strong></p>
<pre><code class="language-python">def search_dir(x, e, x_tilde, m, l2, k, is_DBC, h):
    projected_hess = IP_hess(x, e, x_tilde, m, l2, k, h)
    reshaped_grad = IP_grad(x, e, x_tilde, m, l2, k, h).reshape(len(x) * 2, 1)
    # eliminate DOF by modifying gradient and Hessian for DBC:
    for i, j in zip(*projected_hess.nonzero()):
        if is_DBC[int(i / 2)] | is_DBC[int(j / 2)]: 
            projected_hess[i, j] = (i == j)
    for i in range(0, len(x)):
        if is_DBC[i]:
            reshaped_grad[i * 2] = reshaped_grad[i * 2 + 1] = 0.0
    return spsolve(projected_hess, -reshaped_grad).reshape(len(x), 2)
</code></pre>
<p>Here <code>is_DBC</code> is an array marking whether a node is Dirichlet or not as we store the Dirichlet node indices in <code>DBC</code>:</p>
<p><a name="imp:lec5:time_simulator_1"/>
<strong>Implementation 5.3.4 (DBC definition, simulator.py).</strong></p>
<pre><code class="language-python">DBC = [n_seg, (n_seg + 1) * (n_seg + 1) - 1]  # fix the left and right top nodes

# ...

# identify whether a node is Dirichlet
is_DBC = [False] * len(x)
for i in DBC:
    is_DBC[i] = True
</code></pre>
<p>Finally, after making sure <code>is_DBC</code> is passed to the time integrator, we can simulate an energetic hanging square (no initial stretching) with a smaller spring stiffness <code>k=1e3</code> at framerate time step size <code>h=0.02</code> (<a href="#fig:lec5:hanging_square_sim">Figure 5.3.1</a>).</p>
<figure>
    <center>
    <img src="../Images/317ee47351ea8c28fbddd347fac640c0.png" width="550" data-original-src="https://phys-sim-book.github.io/img/lec5/hanging_square.jpg"/>
    </center>
    <figcaption><b><a name="fig:lec5:hanging_square_sim"/>
Figure 5.3.1.</b> From left to right: initial, intermediate, and final static frame of the hanging square simulation. </figcaption>
</figure>
                        
</body>
</html>