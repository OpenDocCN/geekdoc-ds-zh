- en: Precomputation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://en.algorithmica.org/hpc/compilation/precalc/](https://en.algorithmica.org/hpc/compilation/precalc/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When compilers can infer that a certain variable does not depend on any user-provided
    data, they can compute its value during compile time and turn it into a constant
    by embedding it into the generated machine code.
  prefs: []
  type: TYPE_NORMAL
- en: This optimization helps performance a lot, but it is not a part of the C++ standard,
    so compilers don’t *have to* do that. When a compile-time computation is either
    hard to implement or time-intensive, a compiler may pass on that opportunity.
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/compilation/precalc/#constant-expressions)Constant
    Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more reliable solution, in modern C++ you can mark a function as `constexpr`;
    if it is called by passing constants its value is guaranteed to be computed during
    compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These functions have some restrictions like that they only call other `constexpr`
    functions and can’t do memory allocation, but otherwise, they are executed “as
    is.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that while `constexpr` functions don’t cost anything during run time,
    they still increase compilation time, so at least remotely care about their efficiency
    and don’t put something NP-complete in them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There used to be many more limitations in earlier C++ standards, like you could
    not use any sort of state inside them and had to rely on recursion, so the whole
    process felt more like Haskell programming rather than C++. Since C++17, you can
    even compute static arrays using the imperative style, which is useful for precomputing
    lookup tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that when you call `constexpr` functions while passing non-constants,
    the compiler may or may not compute them during compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, even though technically we perform a constant number of iterations
    and call `fibonacci` with parameters known at compile time, they are technically
    not compile-time constants. It’s up to the compiler whether to optimize this loop
    or not — and for heavy computations, it often chooses not to. [← Contract Programming](https://en.algorithmica.org/hpc/compilation/contracts/)[../Profiling
    →](https://en.algorithmica.org/hpc/profiling/)
  prefs: []
  type: TYPE_NORMAL
