["```py\nvariable  {K  :  Type*}  [Field  K]  {V  :  Type*}  [AddCommGroup  V]  [Module  K  V] \n```", "```py\nexample  (a  :  K)  (u  v  :  V)  :  a  •  (u  +  v)  =  a  •  u  +  a  •  v  :=\n  smul_add  a  u  v\n\nexample  (a  b  :  K)  (u  :  V)  :  (a  +  b)  •  u  =  a  •  u  +  b  •  u  :=\n  add_smul  a  b  u\n\nexample  (a  b  :  K)  (u  :  V)  :  a  •  b  •  u  =  b  •  a  •  u  :=\n  smul_comm  a  b  u \n```", "```py\nexample  {R  M  :  Type*}  [CommSemiring  R]  [AddCommMonoid  M]  [Module  R  M]  :\n  Module  (Ideal  R)  (Submodule  R  M)  :=\n  inferInstance \n```", "```py\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]\n\nvariable  (φ  :  V  →ₗ[K]  W)\n\nexample  (a  :  K)  (v  :  V)  :  φ  (a  •  v)  =  a  •  φ  v  :=\n  map_smul  φ  a  v\n\nexample  (v  w  :  V)  :  φ  (v  +  w)  =  φ  v  +  φ  w  :=\n  map_add  φ  v  w \n```", "```py\nvariable  (ψ  :  V  →ₗ[K]  W)\n\n#check  (2  •  φ  +  ψ  :  V  →ₗ[K]  W) \n```", "```py\nvariable  (θ  :  W  →ₗ[K]  V)\n\n#check  (φ.comp  θ  :  W  →ₗ[K]  W)\n#check  (φ  ∘ₗ  θ  :  W  →ₗ[K]  W) \n```", "```py\nexample  :  V  →ₗ[K]  V  where\n  toFun  v  :=  3  •  v\n  map_add'  _  _  :=  smul_add  ..\n  map_smul'  _  _  :=  smul_comm  .. \n```", "```py\n#check  (φ.map_add'  :  ∀  x  y  :  V,  φ.toFun  (x  +  y)  =  φ.toFun  x  +  φ.toFun  y)\n#check  (φ.map_add  :  ∀  x  y  :  V,  φ  (x  +  y)  =  φ  x  +  φ  y)\n#check  (map_add  φ  :  ∀  x  y  :  V,  φ  (x  +  y)  =  φ  x  +  φ  y) \n```", "```py\n#check  (LinearMap.lsmul  K  V  3  :  V  →ₗ[K]  V)\n#check  (LinearMap.lsmul  K  V  :  K  →ₗ[K]  V  →ₗ[K]  V) \n```", "```py\nexample  (f  :  V  ≃ₗ[K]  W)  :  f  ≪≫ₗ  f.symm  =  LinearEquiv.refl  K  V  :=\n  f.self_trans_symm \n```", "```py\nnoncomputable  example  (f  :  V  →ₗ[K]  W)  (h  :  Function.Bijective  f)  :  V  ≃ₗ[K]  W  :=\n  .ofBijective  f  h \n```", "```py\nsection  binary_product\n\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]\nvariable  {U  :  Type*}  [AddCommGroup  U]  [Module  K  U]\nvariable  {T  :  Type*}  [AddCommGroup  T]  [Module  K  T]\n\n-- First projection map\nexample  :  V  ×  W  →ₗ[K]  V  :=  LinearMap.fst  K  V  W\n\n-- Second projection map\nexample  :  V  ×  W  →ₗ[K]  W  :=  LinearMap.snd  K  V  W\n\n-- Universal property of the product\nexample  (φ  :  U  →ₗ[K]  V)  (ψ  :  U  →ₗ[K]  W)  :  U  →ₗ[K]  V  ×  W  :=  LinearMap.prod  φ  ψ\n\n-- The product map does the expected thing, first component\nexample  (φ  :  U  →ₗ[K]  V)  (ψ  :  U  →ₗ[K]  W)  :  LinearMap.fst  K  V  W  ∘ₗ  LinearMap.prod  φ  ψ  =  φ  :=  rfl\n\n-- The product map does the expected thing, second component\nexample  (φ  :  U  →ₗ[K]  V)  (ψ  :  U  →ₗ[K]  W)  :  LinearMap.snd  K  V  W  ∘ₗ  LinearMap.prod  φ  ψ  =  ψ  :=  rfl\n\n-- We can also combine maps in parallel\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  T)  :  (V  ×  W)  →ₗ[K]  (U  ×  T)  :=  φ.prodMap  ψ\n\n-- This is simply done by combining the projections with the universal property\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  T)  :\n  φ.prodMap  ψ  =  (φ  ∘ₗ  .fst  K  V  W).prod  (ψ  ∘ₗ  .snd  K  V  W)  :=  rfl\n\n-- First inclusion map\nexample  :  V  →ₗ[K]  V  ×  W  :=  LinearMap.inl  K  V  W\n\n-- Second inclusion map\nexample  :  W  →ₗ[K]  V  ×  W  :=  LinearMap.inr  K  V  W\n\n-- Universal property of the sum (aka coproduct)\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  U)  :  V  ×  W  →ₗ[K]  U  :=  φ.coprod  ψ\n\n-- The coproduct map does the expected thing, first component\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  U)  :  φ.coprod  ψ  ∘ₗ  LinearMap.inl  K  V  W  =  φ  :=\n  LinearMap.coprod_inl  φ  ψ\n\n-- The coproduct map does the expected thing, second component\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  U)  :  φ.coprod  ψ  ∘ₗ  LinearMap.inr  K  V  W  =  ψ  :=\n  LinearMap.coprod_inr  φ  ψ\n\n-- The coproduct map is defined in the expected way\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  U)  (v  :  V)  (w  :  W)  :\n  φ.coprod  ψ  (v,  w)  =  φ  v  +  ψ  w  :=\n  rfl\n\nend  binary_product \n```", "```py\nsection  families\nopen  DirectSum\n\nvariable  {ι  :  Type*}  [DecidableEq  ι]\n  (V  :  ι  →  Type*)  [∀  i,  AddCommGroup  (V  i)]  [∀  i,  Module  K  (V  i)]\n\n-- The universal property of the direct sum assembles maps from the summands to build\n-- a map from the direct sum\nexample  (φ  :  Π  i,  (V  i  →ₗ[K]  W))  :  (⨁  i,  V  i)  →ₗ[K]  W  :=\n  DirectSum.toModule  K  ι  W  φ\n\n-- The universal property of the direct product assembles maps into the factors\n-- to build a map into the direct product\nexample  (φ  :  Π  i,  (W  →ₗ[K]  V  i))  :  W  →ₗ[K]  (Π  i,  V  i)  :=\n  LinearMap.pi  φ\n\n-- The projection maps from the product\nexample  (i  :  ι)  :  (Π  j,  V  j)  →ₗ[K]  V  i  :=  LinearMap.proj  i\n\n-- The inclusion maps into the sum\nexample  (i  :  ι)  :  V  i  →ₗ[K]  (⨁  i,  V  i)  :=  DirectSum.lof  K  ι  V  i\n\n-- The inclusion maps into the product\nexample  (i  :  ι)  :  V  i  →ₗ[K]  (Π  i,  V  i)  :=  LinearMap.single  K  V  i\n\n-- In case `ι` is a finite type, there is an isomorphism between the sum and product.\nexample  [Fintype  ι]  :  (⨁  i,  V  i)  ≃ₗ[K]  (Π  i,  V  i)  :=\n  linearEquivFunOnFintype  K  ι  V\n\nend  families \n```", "```py\nvariable  {K  :  Type*}  [Field  K]  {V  :  Type*}  [AddCommGroup  V]  [Module  K  V]\n\nexample  (U  :  Submodule  K  V)  {x  y  :  V}  (hx  :  x  ∈  U)  (hy  :  y  ∈  U)  :\n  x  +  y  ∈  U  :=\n  U.add_mem  hx  hy\n\nexample  (U  :  Submodule  K  V)  {x  :  V}  (hx  :  x  ∈  U)  (a  :  K)  :\n  a  •  x  ∈  U  :=\n  U.smul_mem  a  hx \n```", "```py\nnoncomputable  example  :  Submodule  ℝ  ℂ  where\n  carrier  :=  Set.range  ((↑)  :  ℝ  →  ℂ)\n  add_mem'  :=  by\n  rintro  _  _  ⟨n,  rfl⟩  ⟨m,  rfl⟩\n  use  n  +  m\n  simp\n  zero_mem'  :=  by\n  use  0\n  simp\n  smul_mem'  :=  by\n  rintro  c  -  ⟨a,  rfl⟩\n  use  c*a\n  simp \n```", "```py\ndef  preimage  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]  (φ  :  V  →ₗ[K]  W)  (H  :  Submodule  K  W)  :\n  Submodule  K  V  where\n  carrier  :=  φ  ⁻¹'  H\n  zero_mem'  :=  by\n  sorry\n  add_mem'  :=  by\n  sorry\n  smul_mem'  :=  by\n  sorry \n```", "```py\nexample  (U  :  Submodule  K  V)  :  Module  K  U  :=  inferInstance \n```", "```py\nexample  (U  :  Submodule  K  V)  :  Module  K  {x  :  V  //  x  ∈  U}  :=  inferInstance \n```", "```py\nexample  (H  H'  :  Submodule  K  V)  :\n  ((H  ⊓  H'  :  Submodule  K  V)  :  Set  V)  =  (H  :  Set  V)  ∩  (H'  :  Set  V)  :=  rfl \n```", "```py\nexample  (H  H'  :  Submodule  K  V)  :\n  ((H  ⊔  H'  :  Submodule  K  V)  :  Set  V)  =  Submodule.span  K  ((H  :  Set  V)  ∪  (H'  :  Set  V))  :=  by\n  simp  [Submodule.span_union] \n```", "```py\nexample  (x  :  V)  :  x  ∈  (⊤  :  Submodule  K  V)  :=  trivial \n```", "```py\nexample  (x  :  V)  :  x  ∈  (⊥  :  Submodule  K  V)  ↔  x  =  0  :=  Submodule.mem_bot  K \n```", "```py\n-- If two subspaces are in direct sum then they span the whole space.\nexample  (U  V  :  Submodule  K  V)  (h  :  IsCompl  U  V)  :\n  U  ⊔  V  =  ⊤  :=  h.sup_eq_top\n\n-- If two subspaces are in direct sum then they intersect only at zero.\nexample  (U  V  :  Submodule  K  V)  (h  :  IsCompl  U  V)  :\n  U  ⊓  V  =  ⊥  :=  h.inf_eq_bot\n\nsection\nopen  DirectSum\nvariable  {ι  :  Type*}  [DecidableEq  ι]\n\n-- If subspaces are in direct sum then they span the whole space.\nexample  (U  :  ι  →  Submodule  K  V)  (h  :  DirectSum.IsInternal  U)  :\n  ⨆  i,  U  i  =  ⊤  :=  h.submodule_iSup_eq_top\n\n-- If subspaces are in direct sum then they pairwise intersect only at zero.\nexample  {ι  :  Type*}  [DecidableEq  ι]  (U  :  ι  →  Submodule  K  V)  (h  :  DirectSum.IsInternal  U)\n  {i  j  :  ι}  (hij  :  i  ≠  j)  :  U  i  ⊓  U  j  =  ⊥  :=\n  (h.submodule_iSupIndep.pairwiseDisjoint  hij).eq_bot\n\n-- Those conditions characterize direct sums.\n#check  DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top\n\n-- The relation with external direct sums: if a family of subspaces is\n-- in internal direct sum then the map from their external direct sum into `V`\n-- is a linear isomorphism.\nnoncomputable  example  {ι  :  Type*}  [DecidableEq  ι]  (U  :  ι  →  Submodule  K  V)\n  (h  :  DirectSum.IsInternal  U)  :  (⨁  i,  U  i)  ≃ₗ[K]  V  :=\n  LinearEquiv.ofBijective  (coeLinearMap  U)  h\nend \n```", "```py\nexample  {s  :  Set  V}  (E  :  Submodule  K  V)  :  Submodule.span  K  s  ≤  E  ↔  s  ⊆  E  :=\n  Submodule.span_le\n\nexample  :  GaloisInsertion  (Submodule.span  K)  ((↑)  :  Submodule  K  V  →  Set  V)  :=\n  Submodule.gi  K  V \n```", "```py\nexample  {S  T  :  Submodule  K  V}  {x  :  V}  (h  :  x  ∈  S  ⊔  T)  :\n  ∃  s  ∈  S,  ∃  t  ∈  T,  x  =  s  +  t  :=  by\n  rw  [←  S.span_eq,  ←  T.span_eq,  ←  Submodule.span_union]  at  h\n  induction  h  using  Submodule.span_induction  with\n  |  mem  y  h  =>\n  sorry\n  |  zero  =>\n  sorry\n  |  add  x  y  hx  hy  hx'  hy'  =>\n  sorry\n  |  smul  a  x  hx  hx'  =>\n  sorry \n```", "```py\nsection\n\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]  (φ  :  V  →ₗ[K]  W)\n\nvariable  (E  :  Submodule  K  V)  in\n#check  (Submodule.map  φ  E  :  Submodule  K  W)\n\nvariable  (F  :  Submodule  K  W)  in\n#check  (Submodule.comap  φ  F  :  Submodule  K  V) \n```", "```py\nexample  :  LinearMap.range  φ  =  .map  φ  ⊤  :=  LinearMap.range_eq_map  φ\n\nexample  :  LinearMap.ker  φ  =  .comap  φ  ⊥  :=  Submodule.comap_bot  φ  -- or `rfl` \n```", "```py\nopen  Function  LinearMap\n\nexample  :  Injective  φ  ↔  ker  φ  =  ⊥  :=  ker_eq_bot.symm\n\nexample  :  Surjective  φ  ↔  range  φ  =  ⊤  :=  range_eq_top.symm \n```", "```py\n#check  Submodule.mem_map_of_mem\n#check  Submodule.mem_map\n#check  Submodule.mem_comap\n\nexample  (E  :  Submodule  K  V)  (F  :  Submodule  K  W)  :\n  Submodule.map  φ  E  ≤  F  ↔  E  ≤  Submodule.comap  φ  F  :=  by\n  sorry \n```", "```py\nvariable  (E  :  Submodule  K  V)\n\nexample  :  Module  K  (V  ⧸  E)  :=  inferInstance\n\nexample  :  V  →ₗ[K]  V  ⧸  E  :=  E.mkQ\n\nexample  :  ker  E.mkQ  =  E  :=  E.ker_mkQ\n\nexample  :  range  E.mkQ  =  ⊤  :=  E.range_mkQ\n\nexample  (hφ  :  E  ≤  ker  φ)  :  V  ⧸  E  →ₗ[K]  W  :=  E.liftQ  φ  hφ\n\nexample  (F  :  Submodule  K  W)  (hφ  :  E  ≤  .comap  φ  F)  :  V  ⧸  E  →ₗ[K]  W  ⧸  F  :=  E.mapQ  F  φ  hφ\n\nnoncomputable  example  :  (V  ⧸  LinearMap.ker  φ)  ≃ₗ[K]  range  φ  :=  φ.quotKerEquivRange \n```", "```py\nopen  Submodule\n\n#check  Submodule.map_comap_eq\n#check  Submodule.comap_map_eq\n\nexample  :  Submodule  K  (V  ⧸  E)  ≃  {  F  :  Submodule  K  V  //  E  ≤  F  }  where\n  toFun  :=  sorry\n  invFun  :=  sorry\n  left_inv  :=  sorry\n  right_inv  :=  sorry \n```", "```py\nvariable  {K  :  Type*}  [Field  K]  {V  :  Type*}  [AddCommGroup  V]  [Module  K  V]\n\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]\n\nopen  Polynomial  Module  LinearMap  End\n\nexample  (φ  ψ  :  End  K  V)  :  φ  *  ψ  =  φ  ∘ₗ  ψ  :=\n  End.mul_eq_comp  φ  ψ  -- `rfl` would also work\n\n-- evaluating `P` on `φ`\nexample  (P  :  K[X])  (φ  :  End  K  V)  :  V  →ₗ[K]  V  :=\n  aeval  φ  P\n\n-- evaluating `X` on `φ` gives back `φ`\nexample  (φ  :  End  K  V)  :  aeval  φ  (X  :  K[X])  =  φ  :=\n  aeval_X  φ \n```", "```py\n#check  Submodule.eq_bot_iff\n#check  Submodule.mem_inf\n#check  LinearMap.mem_ker\n\nexample  (P  Q  :  K[X])  (h  :  IsCoprime  P  Q)  (φ  :  End  K  V)  :  ker  (aeval  φ  P)  ⊓  ker  (aeval  φ  Q)  =  ⊥  :=  by\n  sorry\n\n#check  Submodule.add_mem_sup\n#check  map_mul\n#check  End.mul_apply\n#check  LinearMap.ker_le_ker_comp\n\nexample  (P  Q  :  K[X])  (h  :  IsCoprime  P  Q)  (φ  :  End  K  V)  :\n  ker  (aeval  φ  P)  ⊔  ker  (aeval  φ  Q)  =  ker  (aeval  φ  (P*Q))  :=  by\n  sorry \n```", "```py\nexample  (φ  :  End  K  V)  (a  :  K)  :  φ.eigenspace  a  =  LinearMap.ker  (φ  -  a  •  1)  :=\n  End.eigenspace_def \n```", "```py\nexample  (φ  :  End  K  V)  (a  :  K)  :  φ.HasEigenvalue  a  ↔  φ.eigenspace  a  ≠  ⊥  :=\n  Iff.rfl\n\nexample  (φ  :  End  K  V)  (a  :  K)  :  φ.HasEigenvalue  a  ↔  ∃  v,  φ.HasEigenvector  a  v  :=\n  ⟨End.HasEigenvalue.exists_hasEigenvector,  fun  ⟨_,  hv⟩  ↦  φ.hasEigenvalue_of_hasEigenvector  hv⟩\n\nexample  (φ  :  End  K  V)  :  φ.Eigenvalues  =  {a  //  φ.HasEigenvalue  a}  :=\n  rfl\n\n-- Eigenvalue are roots of the minimal polynomial\nexample  (φ  :  End  K  V)  (a  :  K)  :  φ.HasEigenvalue  a  →  (minpoly  K  φ).IsRoot  a  :=\n  φ.isRoot_of_hasEigenvalue\n\n-- In finite dimension, the converse is also true (we will discuss dimension below)\nexample  [FiniteDimensional  K  V]  (φ  :  End  K  V)  (a  :  K)  :\n  φ.HasEigenvalue  a  ↔  (minpoly  K  φ).IsRoot  a  :=\n  φ.hasEigenvalue_iff_isRoot\n\n-- Cayley-Hamilton\nexample  [FiniteDimensional  K  V]  (φ  :  End  K  V)  :  aeval  φ  φ.charpoly  =  0  :=\n  φ.aeval_self_charpoly \n```", "```py\nsection  matrices\n\n-- Adding vectors\n#eval  ![1,  2]  +  ![3,  4]  -- ![4, 6]\n\n-- Adding matrices\n#eval  !![1,  2;  3,  4]  +  !![3,  4;  5,  6]  -- !![4, 6; 8, 10]\n\n-- Multiplying matrices\n#eval  !![1,  2;  3,  4]  *  !![3,  4;  5,  6]  -- !![13, 16; 29, 36] \n```", "```py\nopen  Matrix\n\n-- matrices acting on vectors on the left\n#eval  !![1,  2;  3,  4]  *ᵥ  ![1,  1]  -- ![3, 7]\n\n-- matrices acting on vectors on the left, resulting in a size one matrix\n#eval  !![1,  2]  *ᵥ  ![1,  1]  -- ![3]\n\n-- matrices acting on vectors on the right\n#eval  ![1,  1,  1]  ᵥ*  !![1,  2;  3,  4;  5,  6]  -- ![9, 12] \n```", "```py\n#eval  replicateRow  (Fin  1)  ![1,  2]  -- !![1, 2]\n\n#eval  replicateCol  (Fin  1)  ![1,  2]  -- !![1; 2] \n```", "```py\n-- vector dot product\n#eval  ![1,  2]  ⬝ᵥ  ![3,  4]  -- `11`\n\n-- matrix transpose\n#eval  !![1,  2;  3,  4]ᵀ  -- `!![1, 3; 2, 4]`\n\n-- determinant\n#eval  !![(1  :  ℤ),  2;  3,  4].det  -- `-2`\n\n-- trace\n#eval  !![(1  :  ℤ),  2;  3,  4].trace  -- `5` \n```", "```py\n#simp  !![(1  :  ℝ),  2;  3,  4].det  -- `4 - 2*3`\n\n#norm_num  !![(1  :  ℝ),  2;  3,  4].det  -- `-2`\n\n#norm_num  !![(1  :  ℝ),  2;  3,  4].trace  -- `5`\n\nvariable  (a  b  c  d  :  ℝ)  in\n#simp  !![a,  b;  c,  d].det  -- `a * d – b * c` \n```", "```py\n#norm_num  [Matrix.inv_def]  !![(1  :  ℝ),  2;  3,  4]⁻¹  -- !![-2, 1; 3 / 2, -(1 / 2)] \n```", "```py\nexample  :  !![(1  :  ℝ),  2;  3,  4]⁻¹  *  !![(1  :  ℝ),  2;  3,  4]  =  1  :=  by\n  have  :  Invertible  !![(1  :  ℝ),  2;  3,  4]  :=  by\n  apply  Matrix.invertibleOfIsUnitDet\n  norm_num\n  simp \n```", "```py\nexample  :  !![(1  :  ℝ),  2;  3,  4]⁻¹  *  !![(1  :  ℝ),  2;  3,  4]  =  1  :=  by\n  norm_num  [Matrix.inv_def]\n  exact  one_fin_two.symm \n```", "```py\nsection\n\nexample  :  (fun  _  ↦  1  :  Fin  2  →  Fin  2  →  ℤ)  =  !![1,  1;  1,  1]  :=  by\n  ext  i  j\n  fin_cases  i  <;>  fin_cases  j  <;>  rfl\n\nexample  :  (fun  _  ↦  1  :  Fin  2  →  Fin  2  →  ℤ)  *  (fun  _  ↦  1  :  Fin  2  →  Fin  2  →  ℤ)  =  !![1,  1;  1,  1]  :=  by\n  ext  i  j\n  fin_cases  i  <;>  fin_cases  j  <;>  rfl\n\nexample  :  !![1,  1;  1,  1]  *  !![1,  1;  1,  1]  =  !![2,  2;  2,  2]  :=  by\n  norm_num \n```", "```py\nexample  {n  :  ℕ}  (v  :  Fin  n  →  ℝ)  :\n  Matrix.vandermonde  v  =  Matrix.of  (fun  i  j  :  Fin  n  ↦  v  i  ^  (j  :  ℕ))  :=\n  rfl\nend\nend  matrices \n```", "```py\nvariable  {K  :  Type*}  [Field  K]  {V  :  Type*}  [AddCommGroup  V]  [Module  K  V]\n\nsection\n\nvariable  {ι  :  Type*}  (B  :  Basis  ι  K  V)  (v  :  V)  (i  :  ι)\n\n-- The basis vector with index ``i``\n#check  (B  i  :  V)\n\n-- the linear isomorphism with the model space given by ``B``\n#check  (B.repr  :  V  ≃ₗ[K]  ι  →₀  K)\n\n-- the component function of ``v``\n#check  (B.repr  v  :  ι  →₀  K)\n\n-- the component of ``v`` with index ``i``\n#check  (B.repr  v  i  :  K) \n```", "```py\nnoncomputable  example  (b  :  ι  →  V)  (b_indep  :  LinearIndependent  K  b)\n  (b_spans  :  ∀  v,  v  ∈  Submodule.span  K  (Set.range  b))  :  Basis  ι  K  V  :=\n  Basis.mk  b_indep  (fun  v  _  ↦  b_spans  v)\n\n-- The family of vectors underlying the above basis is indeed ``b``.\nexample  (b  :  ι  →  V)  (b_indep  :  LinearIndependent  K  b)\n  (b_spans  :  ∀  v,  v  ∈  Submodule.span  K  (Set.range  b))  (i  :  ι)  :\n  Basis.mk  b_indep  (fun  v  _  ↦  b_spans  v)  i  =  b  i  :=\n  Basis.mk_apply  b_indep  (fun  v  _  ↦  b_spans  v)  i \n```", "```py\nvariable  [DecidableEq  ι] \n```", "```py\nexample  :  Finsupp.basisSingleOne.repr  =  LinearEquiv.refl  K  (ι  →₀  K)  :=\n  rfl\n\nexample  (i  :  ι)  :  Finsupp.basisSingleOne  i  =  Finsupp.single  i  1  :=\n  rfl \n```", "```py\nexample  [Finite  ι]  (x  :  ι  →  K)  (i  :  ι)  :  (Pi.basisFun  K  ι).repr  x  i  =  x  i  :=  by\n  simp \n```", "```py\nexample  [Fintype  ι]  :  ∑  i  :  ι,  B.repr  v  i  •  (B  i)  =  v  :=\n  B.sum_repr  v \n```", "```py\nexample  (c  :  ι  →₀  K)  (f  :  ι  →  V)  (s  :  Finset  ι)  (h  :  c.support  ⊆  s)  :\n  Finsupp.linearCombination  K  f  c  =  ∑  i  ∈  s,  c  i  •  f  i  :=\n  Finsupp.linearCombination_apply_of_mem_supported  K  h \n```", "```py\nexample  :  Finsupp.linearCombination  K  B  (B.repr  v)  =  v  :=\n  B.linearCombination_repr  v \n```", "```py\nvariable  (f  :  ι  →  V)  in\n#check  (Finsupp.linearCombination  K  f  :  (ι  →₀  K)  →ₗ[K]  V) \n```", "```py\nsection\n\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]\n  (φ  :  V  →ₗ[K]  W)  (u  :  ι  →  W)\n\n#check  (B.constr  K  :  (ι  →  W)  ≃ₗ[K]  (V  →ₗ[K]  W))\n\n#check  (B.constr  K  u  :  V  →ₗ[K]  W)\n\nexample  (i  :  ι)  :  B.constr  K  u  (B  i)  =  u  i  :=\n  B.constr_basis  K  u  i \n```", "```py\nexample  (φ  ψ  :  V  →ₗ[K]  W)  (h  :  ∀  i,  φ  (B  i)  =  ψ  (B  i))  :  φ  =  ψ  :=\n  B.ext  h \n```", "```py\nvariable  {ι'  :  Type*}  (B'  :  Basis  ι'  K  W)  [Fintype  ι]  [DecidableEq  ι]  [Fintype  ι']  [DecidableEq  ι']\n\nopen  LinearMap\n\n#check  (toMatrix  B  B'  :  (V  →ₗ[K]  W)  ≃ₗ[K]  Matrix  ι'  ι  K)\n\nopen  Matrix  -- get access to the ``*ᵥ`` notation for multiplication between matrices and vectors.\n\nexample  (φ  :  V  →ₗ[K]  W)  (v  :  V)  :  (toMatrix  B  B'  φ)  *ᵥ  (B.repr  v)  =  B'.repr  (φ  v)  :=\n  toMatrix_mulVec_repr  B  B'  φ  v\n\nvariable  {ι''  :  Type*}  (B''  :  Basis  ι''  K  W)  [Fintype  ι'']  [DecidableEq  ι'']\n\nexample  (φ  :  V  →ₗ[K]  W)  :  (toMatrix  B  B''  φ)  =  (toMatrix  B'  B''  .id)  *  (toMatrix  B  B'  φ)  :=  by\n  simp\n\nend \n```", "```py\nopen  Module  LinearMap  Matrix\n\n-- Some lemmas coming from the fact that `LinearMap.toMatrix` is an algebra morphism.\n#check  toMatrix_comp\n#check  id_comp\n#check  comp_id\n#check  toMatrix_id\n\n-- Some lemmas coming from the fact that ``Matrix.det`` is a multiplicative monoid morphism.\n#check  Matrix.det_mul\n#check  Matrix.det_one\n\nexample  [Fintype  ι]  (B'  :  Basis  ι  K  V)  (φ  :  End  K  V)  :\n  (toMatrix  B  B  φ).det  =  (toMatrix  B'  B'  φ).det  :=  by\n  set  M  :=  toMatrix  B  B  φ\n  set  M'  :=  toMatrix  B'  B'  φ\n  set  P  :=  (toMatrix  B  B')  LinearMap.id\n  set  P'  :=  (toMatrix  B'  B)  LinearMap.id\n  sorry\nend \n```", "```py\nsection\n#check  (Module.finrank  K  V  :  ℕ)\n\n-- `Fin n → K` is the archetypical space with dimension `n` over `K`.\nexample  (n  :  ℕ)  :  Module.finrank  K  (Fin  n  →  K)  =  n  :=\n  Module.finrank_fin_fun  K\n\n-- Seen as a vector space over itself, `ℂ` has dimension one.\nexample  :  Module.finrank  ℂ  ℂ  =  1  :=\n  Module.finrank_self  ℂ\n\n-- But as a real vector space it has dimension two.\nexample  :  Module.finrank  ℝ  ℂ  =  2  :=\n  Complex.finrank_real_complex \n```", "```py\nexample  [FiniteDimensional  K  V]  :  0  <  Module.finrank  K  V  ↔  Nontrivial  V  :=\n  Module.finrank_pos_iff \n```", "```py\nexample  [FiniteDimensional  K  V]  (h  :  0  <  Module.finrank  K  V)  :  Nontrivial  V  :=  by\n  apply  (Module.finrank_pos_iff  (R  :=  K)).1\n  exact  h \n```", "```py\nvariable  {ι  :  Type*}  (B  :  Basis  ι  K  V)\n\nexample  [Finite  ι]  :  FiniteDimensional  K  V  :=  FiniteDimensional.of_fintype_basis  B\n\nexample  [FiniteDimensional  K  V]  :  Finite  ι  :=\n  (FiniteDimensional.fintypeBasisIndex  B).finite\nend \n```", "```py\nsection\nvariable  (E  F  :  Submodule  K  V)  [FiniteDimensional  K  V]\n\nopen  Module\n\nexample  :  finrank  K  (E  ⊔  F  :  Submodule  K  V)  +  finrank  K  (E  ⊓  F  :  Submodule  K  V)  =\n  finrank  K  E  +  finrank  K  F  :=\n  Submodule.finrank_sup_add_finrank_inf_eq  E  F\n\nexample  :  finrank  K  E  ≤  finrank  K  V  :=  Submodule.finrank_le  E \n```", "```py\nexample  (h  :  finrank  K  V  <  finrank  K  E  +  finrank  K  F)  :\n  Nontrivial  (E  ⊓  F  :  Submodule  K  V)  :=  by\n  sorry\nend \n```", "```py\n#check  V  -- Type u_2\n#check  Module.rank  K  V  -- Cardinal.{u_2} \n```", "```py\nuniverse  u  v  -- `u` and `v` will denote universe levels\n\nvariable  {ι  :  Type  u}  (B  :  Basis  ι  K  V)\n  {ι'  :  Type  v}  (B'  :  Basis  ι'  K  V)\n\nexample  :  Cardinal.lift.{v,  u}  (.mk  ι)  =  Cardinal.lift.{u,  v}  (.mk  ι')  :=\n  mk_eq_mk_of_basis  B  B' \n```", "```py\nexample  [FiniteDimensional  K  V]  :\n  (Module.finrank  K  V  :  Cardinal)  =  Module.rank  K  V  :=\n  Module.finrank_eq_rank  K  V \n```", "```py\nvariable  {K  :  Type*}  [Field  K]  {V  :  Type*}  [AddCommGroup  V]  [Module  K  V] \n```", "```py\nexample  (a  :  K)  (u  v  :  V)  :  a  •  (u  +  v)  =  a  •  u  +  a  •  v  :=\n  smul_add  a  u  v\n\nexample  (a  b  :  K)  (u  :  V)  :  (a  +  b)  •  u  =  a  •  u  +  b  •  u  :=\n  add_smul  a  b  u\n\nexample  (a  b  :  K)  (u  :  V)  :  a  •  b  •  u  =  b  •  a  •  u  :=\n  smul_comm  a  b  u \n```", "```py\nexample  {R  M  :  Type*}  [CommSemiring  R]  [AddCommMonoid  M]  [Module  R  M]  :\n  Module  (Ideal  R)  (Submodule  R  M)  :=\n  inferInstance \n```", "```py\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]\n\nvariable  (φ  :  V  →ₗ[K]  W)\n\nexample  (a  :  K)  (v  :  V)  :  φ  (a  •  v)  =  a  •  φ  v  :=\n  map_smul  φ  a  v\n\nexample  (v  w  :  V)  :  φ  (v  +  w)  =  φ  v  +  φ  w  :=\n  map_add  φ  v  w \n```", "```py\nvariable  (ψ  :  V  →ₗ[K]  W)\n\n#check  (2  •  φ  +  ψ  :  V  →ₗ[K]  W) \n```", "```py\nvariable  (θ  :  W  →ₗ[K]  V)\n\n#check  (φ.comp  θ  :  W  →ₗ[K]  W)\n#check  (φ  ∘ₗ  θ  :  W  →ₗ[K]  W) \n```", "```py\nexample  :  V  →ₗ[K]  V  where\n  toFun  v  :=  3  •  v\n  map_add'  _  _  :=  smul_add  ..\n  map_smul'  _  _  :=  smul_comm  .. \n```", "```py\n#check  (φ.map_add'  :  ∀  x  y  :  V,  φ.toFun  (x  +  y)  =  φ.toFun  x  +  φ.toFun  y)\n#check  (φ.map_add  :  ∀  x  y  :  V,  φ  (x  +  y)  =  φ  x  +  φ  y)\n#check  (map_add  φ  :  ∀  x  y  :  V,  φ  (x  +  y)  =  φ  x  +  φ  y) \n```", "```py\n#check  (LinearMap.lsmul  K  V  3  :  V  →ₗ[K]  V)\n#check  (LinearMap.lsmul  K  V  :  K  →ₗ[K]  V  →ₗ[K]  V) \n```", "```py\nexample  (f  :  V  ≃ₗ[K]  W)  :  f  ≪≫ₗ  f.symm  =  LinearEquiv.refl  K  V  :=\n  f.self_trans_symm \n```", "```py\nnoncomputable  example  (f  :  V  →ₗ[K]  W)  (h  :  Function.Bijective  f)  :  V  ≃ₗ[K]  W  :=\n  .ofBijective  f  h \n```", "```py\nsection  binary_product\n\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]\nvariable  {U  :  Type*}  [AddCommGroup  U]  [Module  K  U]\nvariable  {T  :  Type*}  [AddCommGroup  T]  [Module  K  T]\n\n-- First projection map\nexample  :  V  ×  W  →ₗ[K]  V  :=  LinearMap.fst  K  V  W\n\n-- Second projection map\nexample  :  V  ×  W  →ₗ[K]  W  :=  LinearMap.snd  K  V  W\n\n-- Universal property of the product\nexample  (φ  :  U  →ₗ[K]  V)  (ψ  :  U  →ₗ[K]  W)  :  U  →ₗ[K]  V  ×  W  :=  LinearMap.prod  φ  ψ\n\n-- The product map does the expected thing, first component\nexample  (φ  :  U  →ₗ[K]  V)  (ψ  :  U  →ₗ[K]  W)  :  LinearMap.fst  K  V  W  ∘ₗ  LinearMap.prod  φ  ψ  =  φ  :=  rfl\n\n-- The product map does the expected thing, second component\nexample  (φ  :  U  →ₗ[K]  V)  (ψ  :  U  →ₗ[K]  W)  :  LinearMap.snd  K  V  W  ∘ₗ  LinearMap.prod  φ  ψ  =  ψ  :=  rfl\n\n-- We can also combine maps in parallel\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  T)  :  (V  ×  W)  →ₗ[K]  (U  ×  T)  :=  φ.prodMap  ψ\n\n-- This is simply done by combining the projections with the universal property\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  T)  :\n  φ.prodMap  ψ  =  (φ  ∘ₗ  .fst  K  V  W).prod  (ψ  ∘ₗ  .snd  K  V  W)  :=  rfl\n\n-- First inclusion map\nexample  :  V  →ₗ[K]  V  ×  W  :=  LinearMap.inl  K  V  W\n\n-- Second inclusion map\nexample  :  W  →ₗ[K]  V  ×  W  :=  LinearMap.inr  K  V  W\n\n-- Universal property of the sum (aka coproduct)\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  U)  :  V  ×  W  →ₗ[K]  U  :=  φ.coprod  ψ\n\n-- The coproduct map does the expected thing, first component\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  U)  :  φ.coprod  ψ  ∘ₗ  LinearMap.inl  K  V  W  =  φ  :=\n  LinearMap.coprod_inl  φ  ψ\n\n-- The coproduct map does the expected thing, second component\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  U)  :  φ.coprod  ψ  ∘ₗ  LinearMap.inr  K  V  W  =  ψ  :=\n  LinearMap.coprod_inr  φ  ψ\n\n-- The coproduct map is defined in the expected way\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  U)  (v  :  V)  (w  :  W)  :\n  φ.coprod  ψ  (v,  w)  =  φ  v  +  ψ  w  :=\n  rfl\n\nend  binary_product \n```", "```py\nsection  families\nopen  DirectSum\n\nvariable  {ι  :  Type*}  [DecidableEq  ι]\n  (V  :  ι  →  Type*)  [∀  i,  AddCommGroup  (V  i)]  [∀  i,  Module  K  (V  i)]\n\n-- The universal property of the direct sum assembles maps from the summands to build\n-- a map from the direct sum\nexample  (φ  :  Π  i,  (V  i  →ₗ[K]  W))  :  (⨁  i,  V  i)  →ₗ[K]  W  :=\n  DirectSum.toModule  K  ι  W  φ\n\n-- The universal property of the direct product assembles maps into the factors\n-- to build a map into the direct product\nexample  (φ  :  Π  i,  (W  →ₗ[K]  V  i))  :  W  →ₗ[K]  (Π  i,  V  i)  :=\n  LinearMap.pi  φ\n\n-- The projection maps from the product\nexample  (i  :  ι)  :  (Π  j,  V  j)  →ₗ[K]  V  i  :=  LinearMap.proj  i\n\n-- The inclusion maps into the sum\nexample  (i  :  ι)  :  V  i  →ₗ[K]  (⨁  i,  V  i)  :=  DirectSum.lof  K  ι  V  i\n\n-- The inclusion maps into the product\nexample  (i  :  ι)  :  V  i  →ₗ[K]  (Π  i,  V  i)  :=  LinearMap.single  K  V  i\n\n-- In case `ι` is a finite type, there is an isomorphism between the sum and product.\nexample  [Fintype  ι]  :  (⨁  i,  V  i)  ≃ₗ[K]  (Π  i,  V  i)  :=\n  linearEquivFunOnFintype  K  ι  V\n\nend  families \n```", "```py\nvariable  {K  :  Type*}  [Field  K]  {V  :  Type*}  [AddCommGroup  V]  [Module  K  V]\n\nexample  (U  :  Submodule  K  V)  {x  y  :  V}  (hx  :  x  ∈  U)  (hy  :  y  ∈  U)  :\n  x  +  y  ∈  U  :=\n  U.add_mem  hx  hy\n\nexample  (U  :  Submodule  K  V)  {x  :  V}  (hx  :  x  ∈  U)  (a  :  K)  :\n  a  •  x  ∈  U  :=\n  U.smul_mem  a  hx \n```", "```py\nnoncomputable  example  :  Submodule  ℝ  ℂ  where\n  carrier  :=  Set.range  ((↑)  :  ℝ  →  ℂ)\n  add_mem'  :=  by\n  rintro  _  _  ⟨n,  rfl⟩  ⟨m,  rfl⟩\n  use  n  +  m\n  simp\n  zero_mem'  :=  by\n  use  0\n  simp\n  smul_mem'  :=  by\n  rintro  c  -  ⟨a,  rfl⟩\n  use  c*a\n  simp \n```", "```py\ndef  preimage  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]  (φ  :  V  →ₗ[K]  W)  (H  :  Submodule  K  W)  :\n  Submodule  K  V  where\n  carrier  :=  φ  ⁻¹'  H\n  zero_mem'  :=  by\n  sorry\n  add_mem'  :=  by\n  sorry\n  smul_mem'  :=  by\n  sorry \n```", "```py\nexample  (U  :  Submodule  K  V)  :  Module  K  U  :=  inferInstance \n```", "```py\nexample  (U  :  Submodule  K  V)  :  Module  K  {x  :  V  //  x  ∈  U}  :=  inferInstance \n```", "```py\nexample  (H  H'  :  Submodule  K  V)  :\n  ((H  ⊓  H'  :  Submodule  K  V)  :  Set  V)  =  (H  :  Set  V)  ∩  (H'  :  Set  V)  :=  rfl \n```", "```py\nexample  (H  H'  :  Submodule  K  V)  :\n  ((H  ⊔  H'  :  Submodule  K  V)  :  Set  V)  =  Submodule.span  K  ((H  :  Set  V)  ∪  (H'  :  Set  V))  :=  by\n  simp  [Submodule.span_union] \n```", "```py\nexample  (x  :  V)  :  x  ∈  (⊤  :  Submodule  K  V)  :=  trivial \n```", "```py\nexample  (x  :  V)  :  x  ∈  (⊥  :  Submodule  K  V)  ↔  x  =  0  :=  Submodule.mem_bot  K \n```", "```py\n-- If two subspaces are in direct sum then they span the whole space.\nexample  (U  V  :  Submodule  K  V)  (h  :  IsCompl  U  V)  :\n  U  ⊔  V  =  ⊤  :=  h.sup_eq_top\n\n-- If two subspaces are in direct sum then they intersect only at zero.\nexample  (U  V  :  Submodule  K  V)  (h  :  IsCompl  U  V)  :\n  U  ⊓  V  =  ⊥  :=  h.inf_eq_bot\n\nsection\nopen  DirectSum\nvariable  {ι  :  Type*}  [DecidableEq  ι]\n\n-- If subspaces are in direct sum then they span the whole space.\nexample  (U  :  ι  →  Submodule  K  V)  (h  :  DirectSum.IsInternal  U)  :\n  ⨆  i,  U  i  =  ⊤  :=  h.submodule_iSup_eq_top\n\n-- If subspaces are in direct sum then they pairwise intersect only at zero.\nexample  {ι  :  Type*}  [DecidableEq  ι]  (U  :  ι  →  Submodule  K  V)  (h  :  DirectSum.IsInternal  U)\n  {i  j  :  ι}  (hij  :  i  ≠  j)  :  U  i  ⊓  U  j  =  ⊥  :=\n  (h.submodule_iSupIndep.pairwiseDisjoint  hij).eq_bot\n\n-- Those conditions characterize direct sums.\n#check  DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top\n\n-- The relation with external direct sums: if a family of subspaces is\n-- in internal direct sum then the map from their external direct sum into `V`\n-- is a linear isomorphism.\nnoncomputable  example  {ι  :  Type*}  [DecidableEq  ι]  (U  :  ι  →  Submodule  K  V)\n  (h  :  DirectSum.IsInternal  U)  :  (⨁  i,  U  i)  ≃ₗ[K]  V  :=\n  LinearEquiv.ofBijective  (coeLinearMap  U)  h\nend \n```", "```py\nexample  {s  :  Set  V}  (E  :  Submodule  K  V)  :  Submodule.span  K  s  ≤  E  ↔  s  ⊆  E  :=\n  Submodule.span_le\n\nexample  :  GaloisInsertion  (Submodule.span  K)  ((↑)  :  Submodule  K  V  →  Set  V)  :=\n  Submodule.gi  K  V \n```", "```py\nexample  {S  T  :  Submodule  K  V}  {x  :  V}  (h  :  x  ∈  S  ⊔  T)  :\n  ∃  s  ∈  S,  ∃  t  ∈  T,  x  =  s  +  t  :=  by\n  rw  [←  S.span_eq,  ←  T.span_eq,  ←  Submodule.span_union]  at  h\n  induction  h  using  Submodule.span_induction  with\n  |  mem  y  h  =>\n  sorry\n  |  zero  =>\n  sorry\n  |  add  x  y  hx  hy  hx'  hy'  =>\n  sorry\n  |  smul  a  x  hx  hx'  =>\n  sorry \n```", "```py\nsection\n\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]  (φ  :  V  →ₗ[K]  W)\n\nvariable  (E  :  Submodule  K  V)  in\n#check  (Submodule.map  φ  E  :  Submodule  K  W)\n\nvariable  (F  :  Submodule  K  W)  in\n#check  (Submodule.comap  φ  F  :  Submodule  K  V) \n```", "```py\nexample  :  LinearMap.range  φ  =  .map  φ  ⊤  :=  LinearMap.range_eq_map  φ\n\nexample  :  LinearMap.ker  φ  =  .comap  φ  ⊥  :=  Submodule.comap_bot  φ  -- or `rfl` \n```", "```py\nopen  Function  LinearMap\n\nexample  :  Injective  φ  ↔  ker  φ  =  ⊥  :=  ker_eq_bot.symm\n\nexample  :  Surjective  φ  ↔  range  φ  =  ⊤  :=  range_eq_top.symm \n```", "```py\n#check  Submodule.mem_map_of_mem\n#check  Submodule.mem_map\n#check  Submodule.mem_comap\n\nexample  (E  :  Submodule  K  V)  (F  :  Submodule  K  W)  :\n  Submodule.map  φ  E  ≤  F  ↔  E  ≤  Submodule.comap  φ  F  :=  by\n  sorry \n```", "```py\nvariable  (E  :  Submodule  K  V)\n\nexample  :  Module  K  (V  ⧸  E)  :=  inferInstance\n\nexample  :  V  →ₗ[K]  V  ⧸  E  :=  E.mkQ\n\nexample  :  ker  E.mkQ  =  E  :=  E.ker_mkQ\n\nexample  :  range  E.mkQ  =  ⊤  :=  E.range_mkQ\n\nexample  (hφ  :  E  ≤  ker  φ)  :  V  ⧸  E  →ₗ[K]  W  :=  E.liftQ  φ  hφ\n\nexample  (F  :  Submodule  K  W)  (hφ  :  E  ≤  .comap  φ  F)  :  V  ⧸  E  →ₗ[K]  W  ⧸  F  :=  E.mapQ  F  φ  hφ\n\nnoncomputable  example  :  (V  ⧸  LinearMap.ker  φ)  ≃ₗ[K]  range  φ  :=  φ.quotKerEquivRange \n```", "```py\nopen  Submodule\n\n#check  Submodule.map_comap_eq\n#check  Submodule.comap_map_eq\n\nexample  :  Submodule  K  (V  ⧸  E)  ≃  {  F  :  Submodule  K  V  //  E  ≤  F  }  where\n  toFun  :=  sorry\n  invFun  :=  sorry\n  left_inv  :=  sorry\n  right_inv  :=  sorry \n```", "```py\nvariable  {K  :  Type*}  [Field  K]  {V  :  Type*}  [AddCommGroup  V]  [Module  K  V]\n\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]\n\nopen  Polynomial  Module  LinearMap  End\n\nexample  (φ  ψ  :  End  K  V)  :  φ  *  ψ  =  φ  ∘ₗ  ψ  :=\n  End.mul_eq_comp  φ  ψ  -- `rfl` would also work\n\n-- evaluating `P` on `φ`\nexample  (P  :  K[X])  (φ  :  End  K  V)  :  V  →ₗ[K]  V  :=\n  aeval  φ  P\n\n-- evaluating `X` on `φ` gives back `φ`\nexample  (φ  :  End  K  V)  :  aeval  φ  (X  :  K[X])  =  φ  :=\n  aeval_X  φ \n```", "```py\n#check  Submodule.eq_bot_iff\n#check  Submodule.mem_inf\n#check  LinearMap.mem_ker\n\nexample  (P  Q  :  K[X])  (h  :  IsCoprime  P  Q)  (φ  :  End  K  V)  :  ker  (aeval  φ  P)  ⊓  ker  (aeval  φ  Q)  =  ⊥  :=  by\n  sorry\n\n#check  Submodule.add_mem_sup\n#check  map_mul\n#check  End.mul_apply\n#check  LinearMap.ker_le_ker_comp\n\nexample  (P  Q  :  K[X])  (h  :  IsCoprime  P  Q)  (φ  :  End  K  V)  :\n  ker  (aeval  φ  P)  ⊔  ker  (aeval  φ  Q)  =  ker  (aeval  φ  (P*Q))  :=  by\n  sorry \n```", "```py\nexample  (φ  :  End  K  V)  (a  :  K)  :  φ.eigenspace  a  =  LinearMap.ker  (φ  -  a  •  1)  :=\n  End.eigenspace_def \n```", "```py\nexample  (φ  :  End  K  V)  (a  :  K)  :  φ.HasEigenvalue  a  ↔  φ.eigenspace  a  ≠  ⊥  :=\n  Iff.rfl\n\nexample  (φ  :  End  K  V)  (a  :  K)  :  φ.HasEigenvalue  a  ↔  ∃  v,  φ.HasEigenvector  a  v  :=\n  ⟨End.HasEigenvalue.exists_hasEigenvector,  fun  ⟨_,  hv⟩  ↦  φ.hasEigenvalue_of_hasEigenvector  hv⟩\n\nexample  (φ  :  End  K  V)  :  φ.Eigenvalues  =  {a  //  φ.HasEigenvalue  a}  :=\n  rfl\n\n-- Eigenvalue are roots of the minimal polynomial\nexample  (φ  :  End  K  V)  (a  :  K)  :  φ.HasEigenvalue  a  →  (minpoly  K  φ).IsRoot  a  :=\n  φ.isRoot_of_hasEigenvalue\n\n-- In finite dimension, the converse is also true (we will discuss dimension below)\nexample  [FiniteDimensional  K  V]  (φ  :  End  K  V)  (a  :  K)  :\n  φ.HasEigenvalue  a  ↔  (minpoly  K  φ).IsRoot  a  :=\n  φ.hasEigenvalue_iff_isRoot\n\n-- Cayley-Hamilton\nexample  [FiniteDimensional  K  V]  (φ  :  End  K  V)  :  aeval  φ  φ.charpoly  =  0  :=\n  φ.aeval_self_charpoly \n```", "```py\nsection  matrices\n\n-- Adding vectors\n#eval  ![1,  2]  +  ![3,  4]  -- ![4, 6]\n\n-- Adding matrices\n#eval  !![1,  2;  3,  4]  +  !![3,  4;  5,  6]  -- !![4, 6; 8, 10]\n\n-- Multiplying matrices\n#eval  !![1,  2;  3,  4]  *  !![3,  4;  5,  6]  -- !![13, 16; 29, 36] \n```", "```py\nopen  Matrix\n\n-- matrices acting on vectors on the left\n#eval  !![1,  2;  3,  4]  *ᵥ  ![1,  1]  -- ![3, 7]\n\n-- matrices acting on vectors on the left, resulting in a size one matrix\n#eval  !![1,  2]  *ᵥ  ![1,  1]  -- ![3]\n\n-- matrices acting on vectors on the right\n#eval  ![1,  1,  1]  ᵥ*  !![1,  2;  3,  4;  5,  6]  -- ![9, 12] \n```", "```py\n#eval  replicateRow  (Fin  1)  ![1,  2]  -- !![1, 2]\n\n#eval  replicateCol  (Fin  1)  ![1,  2]  -- !![1; 2] \n```", "```py\n-- vector dot product\n#eval  ![1,  2]  ⬝ᵥ  ![3,  4]  -- `11`\n\n-- matrix transpose\n#eval  !![1,  2;  3,  4]ᵀ  -- `!![1, 3; 2, 4]`\n\n-- determinant\n#eval  !![(1  :  ℤ),  2;  3,  4].det  -- `-2`\n\n-- trace\n#eval  !![(1  :  ℤ),  2;  3,  4].trace  -- `5` \n```", "```py\n#simp  !![(1  :  ℝ),  2;  3,  4].det  -- `4 - 2*3`\n\n#norm_num  !![(1  :  ℝ),  2;  3,  4].det  -- `-2`\n\n#norm_num  !![(1  :  ℝ),  2;  3,  4].trace  -- `5`\n\nvariable  (a  b  c  d  :  ℝ)  in\n#simp  !![a,  b;  c,  d].det  -- `a * d – b * c` \n```", "```py\n#norm_num  [Matrix.inv_def]  !![(1  :  ℝ),  2;  3,  4]⁻¹  -- !![-2, 1; 3 / 2, -(1 / 2)] \n```", "```py\nexample  :  !![(1  :  ℝ),  2;  3,  4]⁻¹  *  !![(1  :  ℝ),  2;  3,  4]  =  1  :=  by\n  have  :  Invertible  !![(1  :  ℝ),  2;  3,  4]  :=  by\n  apply  Matrix.invertibleOfIsUnitDet\n  norm_num\n  simp \n```", "```py\nexample  :  !![(1  :  ℝ),  2;  3,  4]⁻¹  *  !![(1  :  ℝ),  2;  3,  4]  =  1  :=  by\n  norm_num  [Matrix.inv_def]\n  exact  one_fin_two.symm \n```", "```py\nsection\n\nexample  :  (fun  _  ↦  1  :  Fin  2  →  Fin  2  →  ℤ)  =  !![1,  1;  1,  1]  :=  by\n  ext  i  j\n  fin_cases  i  <;>  fin_cases  j  <;>  rfl\n\nexample  :  (fun  _  ↦  1  :  Fin  2  →  Fin  2  →  ℤ)  *  (fun  _  ↦  1  :  Fin  2  →  Fin  2  →  ℤ)  =  !![1,  1;  1,  1]  :=  by\n  ext  i  j\n  fin_cases  i  <;>  fin_cases  j  <;>  rfl\n\nexample  :  !![1,  1;  1,  1]  *  !![1,  1;  1,  1]  =  !![2,  2;  2,  2]  :=  by\n  norm_num \n```", "```py\nexample  {n  :  ℕ}  (v  :  Fin  n  →  ℝ)  :\n  Matrix.vandermonde  v  =  Matrix.of  (fun  i  j  :  Fin  n  ↦  v  i  ^  (j  :  ℕ))  :=\n  rfl\nend\nend  matrices \n```", "```py\nvariable  {K  :  Type*}  [Field  K]  {V  :  Type*}  [AddCommGroup  V]  [Module  K  V]\n\nsection\n\nvariable  {ι  :  Type*}  (B  :  Basis  ι  K  V)  (v  :  V)  (i  :  ι)\n\n-- The basis vector with index ``i``\n#check  (B  i  :  V)\n\n-- the linear isomorphism with the model space given by ``B``\n#check  (B.repr  :  V  ≃ₗ[K]  ι  →₀  K)\n\n-- the component function of ``v``\n#check  (B.repr  v  :  ι  →₀  K)\n\n-- the component of ``v`` with index ``i``\n#check  (B.repr  v  i  :  K) \n```", "```py\nnoncomputable  example  (b  :  ι  →  V)  (b_indep  :  LinearIndependent  K  b)\n  (b_spans  :  ∀  v,  v  ∈  Submodule.span  K  (Set.range  b))  :  Basis  ι  K  V  :=\n  Basis.mk  b_indep  (fun  v  _  ↦  b_spans  v)\n\n-- The family of vectors underlying the above basis is indeed ``b``.\nexample  (b  :  ι  →  V)  (b_indep  :  LinearIndependent  K  b)\n  (b_spans  :  ∀  v,  v  ∈  Submodule.span  K  (Set.range  b))  (i  :  ι)  :\n  Basis.mk  b_indep  (fun  v  _  ↦  b_spans  v)  i  =  b  i  :=\n  Basis.mk_apply  b_indep  (fun  v  _  ↦  b_spans  v)  i \n```", "```py\nvariable  [DecidableEq  ι] \n```", "```py\nexample  :  Finsupp.basisSingleOne.repr  =  LinearEquiv.refl  K  (ι  →₀  K)  :=\n  rfl\n\nexample  (i  :  ι)  :  Finsupp.basisSingleOne  i  =  Finsupp.single  i  1  :=\n  rfl \n```", "```py\nexample  [Finite  ι]  (x  :  ι  →  K)  (i  :  ι)  :  (Pi.basisFun  K  ι).repr  x  i  =  x  i  :=  by\n  simp \n```", "```py\nexample  [Fintype  ι]  :  ∑  i  :  ι,  B.repr  v  i  •  (B  i)  =  v  :=\n  B.sum_repr  v \n```", "```py\nexample  (c  :  ι  →₀  K)  (f  :  ι  →  V)  (s  :  Finset  ι)  (h  :  c.support  ⊆  s)  :\n  Finsupp.linearCombination  K  f  c  =  ∑  i  ∈  s,  c  i  •  f  i  :=\n  Finsupp.linearCombination_apply_of_mem_supported  K  h \n```", "```py\nexample  :  Finsupp.linearCombination  K  B  (B.repr  v)  =  v  :=\n  B.linearCombination_repr  v \n```", "```py\nvariable  (f  :  ι  →  V)  in\n#check  (Finsupp.linearCombination  K  f  :  (ι  →₀  K)  →ₗ[K]  V) \n```", "```py\nsection\n\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]\n  (φ  :  V  →ₗ[K]  W)  (u  :  ι  →  W)\n\n#check  (B.constr  K  :  (ι  →  W)  ≃ₗ[K]  (V  →ₗ[K]  W))\n\n#check  (B.constr  K  u  :  V  →ₗ[K]  W)\n\nexample  (i  :  ι)  :  B.constr  K  u  (B  i)  =  u  i  :=\n  B.constr_basis  K  u  i \n```", "```py\nexample  (φ  ψ  :  V  →ₗ[K]  W)  (h  :  ∀  i,  φ  (B  i)  =  ψ  (B  i))  :  φ  =  ψ  :=\n  B.ext  h \n```", "```py\nvariable  {ι'  :  Type*}  (B'  :  Basis  ι'  K  W)  [Fintype  ι]  [DecidableEq  ι]  [Fintype  ι']  [DecidableEq  ι']\n\nopen  LinearMap\n\n#check  (toMatrix  B  B'  :  (V  →ₗ[K]  W)  ≃ₗ[K]  Matrix  ι'  ι  K)\n\nopen  Matrix  -- get access to the ``*ᵥ`` notation for multiplication between matrices and vectors.\n\nexample  (φ  :  V  →ₗ[K]  W)  (v  :  V)  :  (toMatrix  B  B'  φ)  *ᵥ  (B.repr  v)  =  B'.repr  (φ  v)  :=\n  toMatrix_mulVec_repr  B  B'  φ  v\n\nvariable  {ι''  :  Type*}  (B''  :  Basis  ι''  K  W)  [Fintype  ι'']  [DecidableEq  ι'']\n\nexample  (φ  :  V  →ₗ[K]  W)  :  (toMatrix  B  B''  φ)  =  (toMatrix  B'  B''  .id)  *  (toMatrix  B  B'  φ)  :=  by\n  simp\n\nend \n```", "```py\nopen  Module  LinearMap  Matrix\n\n-- Some lemmas coming from the fact that `LinearMap.toMatrix` is an algebra morphism.\n#check  toMatrix_comp\n#check  id_comp\n#check  comp_id\n#check  toMatrix_id\n\n-- Some lemmas coming from the fact that ``Matrix.det`` is a multiplicative monoid morphism.\n#check  Matrix.det_mul\n#check  Matrix.det_one\n\nexample  [Fintype  ι]  (B'  :  Basis  ι  K  V)  (φ  :  End  K  V)  :\n  (toMatrix  B  B  φ).det  =  (toMatrix  B'  B'  φ).det  :=  by\n  set  M  :=  toMatrix  B  B  φ\n  set  M'  :=  toMatrix  B'  B'  φ\n  set  P  :=  (toMatrix  B  B')  LinearMap.id\n  set  P'  :=  (toMatrix  B'  B)  LinearMap.id\n  sorry\nend \n```", "```py\nsection\n#check  (Module.finrank  K  V  :  ℕ)\n\n-- `Fin n → K` is the archetypical space with dimension `n` over `K`.\nexample  (n  :  ℕ)  :  Module.finrank  K  (Fin  n  →  K)  =  n  :=\n  Module.finrank_fin_fun  K\n\n-- Seen as a vector space over itself, `ℂ` has dimension one.\nexample  :  Module.finrank  ℂ  ℂ  =  1  :=\n  Module.finrank_self  ℂ\n\n-- But as a real vector space it has dimension two.\nexample  :  Module.finrank  ℝ  ℂ  =  2  :=\n  Complex.finrank_real_complex \n```", "```py\nexample  [FiniteDimensional  K  V]  :  0  <  Module.finrank  K  V  ↔  Nontrivial  V  :=\n  Module.finrank_pos_iff \n```", "```py\nexample  [FiniteDimensional  K  V]  (h  :  0  <  Module.finrank  K  V)  :  Nontrivial  V  :=  by\n  apply  (Module.finrank_pos_iff  (R  :=  K)).1\n  exact  h \n```", "```py\nvariable  {ι  :  Type*}  (B  :  Basis  ι  K  V)\n\nexample  [Finite  ι]  :  FiniteDimensional  K  V  :=  FiniteDimensional.of_fintype_basis  B\n\nexample  [FiniteDimensional  K  V]  :  Finite  ι  :=\n  (FiniteDimensional.fintypeBasisIndex  B).finite\nend \n```", "```py\nsection\nvariable  (E  F  :  Submodule  K  V)  [FiniteDimensional  K  V]\n\nopen  Module\n\nexample  :  finrank  K  (E  ⊔  F  :  Submodule  K  V)  +  finrank  K  (E  ⊓  F  :  Submodule  K  V)  =\n  finrank  K  E  +  finrank  K  F  :=\n  Submodule.finrank_sup_add_finrank_inf_eq  E  F\n\nexample  :  finrank  K  E  ≤  finrank  K  V  :=  Submodule.finrank_le  E \n```", "```py\nexample  (h  :  finrank  K  V  <  finrank  K  E  +  finrank  K  F)  :\n  Nontrivial  (E  ⊓  F  :  Submodule  K  V)  :=  by\n  sorry\nend \n```", "```py\n#check  V  -- Type u_2\n#check  Module.rank  K  V  -- Cardinal.{u_2} \n```", "```py\nuniverse  u  v  -- `u` and `v` will denote universe levels\n\nvariable  {ι  :  Type  u}  (B  :  Basis  ι  K  V)\n  {ι'  :  Type  v}  (B'  :  Basis  ι'  K  V)\n\nexample  :  Cardinal.lift.{v,  u}  (.mk  ι)  =  Cardinal.lift.{u,  v}  (.mk  ι')  :=\n  mk_eq_mk_of_basis  B  B' \n```", "```py\nexample  [FiniteDimensional  K  V]  :\n  (Module.finrank  K  V  :  Cardinal)  =  Module.rank  K  V  :=\n  Module.finrank_eq_rank  K  V \n```", "```py\nvariable  {K  :  Type*}  [Field  K]  {V  :  Type*}  [AddCommGroup  V]  [Module  K  V] \n```", "```py\nexample  (a  :  K)  (u  v  :  V)  :  a  •  (u  +  v)  =  a  •  u  +  a  •  v  :=\n  smul_add  a  u  v\n\nexample  (a  b  :  K)  (u  :  V)  :  (a  +  b)  •  u  =  a  •  u  +  b  •  u  :=\n  add_smul  a  b  u\n\nexample  (a  b  :  K)  (u  :  V)  :  a  •  b  •  u  =  b  •  a  •  u  :=\n  smul_comm  a  b  u \n```", "```py\nexample  {R  M  :  Type*}  [CommSemiring  R]  [AddCommMonoid  M]  [Module  R  M]  :\n  Module  (Ideal  R)  (Submodule  R  M)  :=\n  inferInstance \n```", "```py\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]\n\nvariable  (φ  :  V  →ₗ[K]  W)\n\nexample  (a  :  K)  (v  :  V)  :  φ  (a  •  v)  =  a  •  φ  v  :=\n  map_smul  φ  a  v\n\nexample  (v  w  :  V)  :  φ  (v  +  w)  =  φ  v  +  φ  w  :=\n  map_add  φ  v  w \n```", "```py\nvariable  (ψ  :  V  →ₗ[K]  W)\n\n#check  (2  •  φ  +  ψ  :  V  →ₗ[K]  W) \n```", "```py\nvariable  (θ  :  W  →ₗ[K]  V)\n\n#check  (φ.comp  θ  :  W  →ₗ[K]  W)\n#check  (φ  ∘ₗ  θ  :  W  →ₗ[K]  W) \n```", "```py\nexample  :  V  →ₗ[K]  V  where\n  toFun  v  :=  3  •  v\n  map_add'  _  _  :=  smul_add  ..\n  map_smul'  _  _  :=  smul_comm  .. \n```", "```py\n#check  (φ.map_add'  :  ∀  x  y  :  V,  φ.toFun  (x  +  y)  =  φ.toFun  x  +  φ.toFun  y)\n#check  (φ.map_add  :  ∀  x  y  :  V,  φ  (x  +  y)  =  φ  x  +  φ  y)\n#check  (map_add  φ  :  ∀  x  y  :  V,  φ  (x  +  y)  =  φ  x  +  φ  y) \n```", "```py\n#check  (LinearMap.lsmul  K  V  3  :  V  →ₗ[K]  V)\n#check  (LinearMap.lsmul  K  V  :  K  →ₗ[K]  V  →ₗ[K]  V) \n```", "```py\nexample  (f  :  V  ≃ₗ[K]  W)  :  f  ≪≫ₗ  f.symm  =  LinearEquiv.refl  K  V  :=\n  f.self_trans_symm \n```", "```py\nnoncomputable  example  (f  :  V  →ₗ[K]  W)  (h  :  Function.Bijective  f)  :  V  ≃ₗ[K]  W  :=\n  .ofBijective  f  h \n```", "```py\nsection  binary_product\n\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]\nvariable  {U  :  Type*}  [AddCommGroup  U]  [Module  K  U]\nvariable  {T  :  Type*}  [AddCommGroup  T]  [Module  K  T]\n\n-- First projection map\nexample  :  V  ×  W  →ₗ[K]  V  :=  LinearMap.fst  K  V  W\n\n-- Second projection map\nexample  :  V  ×  W  →ₗ[K]  W  :=  LinearMap.snd  K  V  W\n\n-- Universal property of the product\nexample  (φ  :  U  →ₗ[K]  V)  (ψ  :  U  →ₗ[K]  W)  :  U  →ₗ[K]  V  ×  W  :=  LinearMap.prod  φ  ψ\n\n-- The product map does the expected thing, first component\nexample  (φ  :  U  →ₗ[K]  V)  (ψ  :  U  →ₗ[K]  W)  :  LinearMap.fst  K  V  W  ∘ₗ  LinearMap.prod  φ  ψ  =  φ  :=  rfl\n\n-- The product map does the expected thing, second component\nexample  (φ  :  U  →ₗ[K]  V)  (ψ  :  U  →ₗ[K]  W)  :  LinearMap.snd  K  V  W  ∘ₗ  LinearMap.prod  φ  ψ  =  ψ  :=  rfl\n\n-- We can also combine maps in parallel\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  T)  :  (V  ×  W)  →ₗ[K]  (U  ×  T)  :=  φ.prodMap  ψ\n\n-- This is simply done by combining the projections with the universal property\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  T)  :\n  φ.prodMap  ψ  =  (φ  ∘ₗ  .fst  K  V  W).prod  (ψ  ∘ₗ  .snd  K  V  W)  :=  rfl\n\n-- First inclusion map\nexample  :  V  →ₗ[K]  V  ×  W  :=  LinearMap.inl  K  V  W\n\n-- Second inclusion map\nexample  :  W  →ₗ[K]  V  ×  W  :=  LinearMap.inr  K  V  W\n\n-- Universal property of the sum (aka coproduct)\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  U)  :  V  ×  W  →ₗ[K]  U  :=  φ.coprod  ψ\n\n-- The coproduct map does the expected thing, first component\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  U)  :  φ.coprod  ψ  ∘ₗ  LinearMap.inl  K  V  W  =  φ  :=\n  LinearMap.coprod_inl  φ  ψ\n\n-- The coproduct map does the expected thing, second component\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  U)  :  φ.coprod  ψ  ∘ₗ  LinearMap.inr  K  V  W  =  ψ  :=\n  LinearMap.coprod_inr  φ  ψ\n\n-- The coproduct map is defined in the expected way\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  U)  (v  :  V)  (w  :  W)  :\n  φ.coprod  ψ  (v,  w)  =  φ  v  +  ψ  w  :=\n  rfl\n\nend  binary_product \n```", "```py\nsection  families\nopen  DirectSum\n\nvariable  {ι  :  Type*}  [DecidableEq  ι]\n  (V  :  ι  →  Type*)  [∀  i,  AddCommGroup  (V  i)]  [∀  i,  Module  K  (V  i)]\n\n-- The universal property of the direct sum assembles maps from the summands to build\n-- a map from the direct sum\nexample  (φ  :  Π  i,  (V  i  →ₗ[K]  W))  :  (⨁  i,  V  i)  →ₗ[K]  W  :=\n  DirectSum.toModule  K  ι  W  φ\n\n-- The universal property of the direct product assembles maps into the factors\n-- to build a map into the direct product\nexample  (φ  :  Π  i,  (W  →ₗ[K]  V  i))  :  W  →ₗ[K]  (Π  i,  V  i)  :=\n  LinearMap.pi  φ\n\n-- The projection maps from the product\nexample  (i  :  ι)  :  (Π  j,  V  j)  →ₗ[K]  V  i  :=  LinearMap.proj  i\n\n-- The inclusion maps into the sum\nexample  (i  :  ι)  :  V  i  →ₗ[K]  (⨁  i,  V  i)  :=  DirectSum.lof  K  ι  V  i\n\n-- The inclusion maps into the product\nexample  (i  :  ι)  :  V  i  →ₗ[K]  (Π  i,  V  i)  :=  LinearMap.single  K  V  i\n\n-- In case `ι` is a finite type, there is an isomorphism between the sum and product.\nexample  [Fintype  ι]  :  (⨁  i,  V  i)  ≃ₗ[K]  (Π  i,  V  i)  :=\n  linearEquivFunOnFintype  K  ι  V\n\nend  families \n```", "```py\nvariable  {K  :  Type*}  [Field  K]  {V  :  Type*}  [AddCommGroup  V]  [Module  K  V] \n```", "```py\nexample  (a  :  K)  (u  v  :  V)  :  a  •  (u  +  v)  =  a  •  u  +  a  •  v  :=\n  smul_add  a  u  v\n\nexample  (a  b  :  K)  (u  :  V)  :  (a  +  b)  •  u  =  a  •  u  +  b  •  u  :=\n  add_smul  a  b  u\n\nexample  (a  b  :  K)  (u  :  V)  :  a  •  b  •  u  =  b  •  a  •  u  :=\n  smul_comm  a  b  u \n```", "```py\nexample  {R  M  :  Type*}  [CommSemiring  R]  [AddCommMonoid  M]  [Module  R  M]  :\n  Module  (Ideal  R)  (Submodule  R  M)  :=\n  inferInstance \n```", "```py\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]\n\nvariable  (φ  :  V  →ₗ[K]  W)\n\nexample  (a  :  K)  (v  :  V)  :  φ  (a  •  v)  =  a  •  φ  v  :=\n  map_smul  φ  a  v\n\nexample  (v  w  :  V)  :  φ  (v  +  w)  =  φ  v  +  φ  w  :=\n  map_add  φ  v  w \n```", "```py\nvariable  (ψ  :  V  →ₗ[K]  W)\n\n#check  (2  •  φ  +  ψ  :  V  →ₗ[K]  W) \n```", "```py\nvariable  (θ  :  W  →ₗ[K]  V)\n\n#check  (φ.comp  θ  :  W  →ₗ[K]  W)\n#check  (φ  ∘ₗ  θ  :  W  →ₗ[K]  W) \n```", "```py\nexample  :  V  →ₗ[K]  V  where\n  toFun  v  :=  3  •  v\n  map_add'  _  _  :=  smul_add  ..\n  map_smul'  _  _  :=  smul_comm  .. \n```", "```py\n#check  (φ.map_add'  :  ∀  x  y  :  V,  φ.toFun  (x  +  y)  =  φ.toFun  x  +  φ.toFun  y)\n#check  (φ.map_add  :  ∀  x  y  :  V,  φ  (x  +  y)  =  φ  x  +  φ  y)\n#check  (map_add  φ  :  ∀  x  y  :  V,  φ  (x  +  y)  =  φ  x  +  φ  y) \n```", "```py\n#check  (LinearMap.lsmul  K  V  3  :  V  →ₗ[K]  V)\n#check  (LinearMap.lsmul  K  V  :  K  →ₗ[K]  V  →ₗ[K]  V) \n```", "```py\nexample  (f  :  V  ≃ₗ[K]  W)  :  f  ≪≫ₗ  f.symm  =  LinearEquiv.refl  K  V  :=\n  f.self_trans_symm \n```", "```py\nnoncomputable  example  (f  :  V  →ₗ[K]  W)  (h  :  Function.Bijective  f)  :  V  ≃ₗ[K]  W  :=\n  .ofBijective  f  h \n```", "```py\nsection  binary_product\n\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]\nvariable  {U  :  Type*}  [AddCommGroup  U]  [Module  K  U]\nvariable  {T  :  Type*}  [AddCommGroup  T]  [Module  K  T]\n\n-- First projection map\nexample  :  V  ×  W  →ₗ[K]  V  :=  LinearMap.fst  K  V  W\n\n-- Second projection map\nexample  :  V  ×  W  →ₗ[K]  W  :=  LinearMap.snd  K  V  W\n\n-- Universal property of the product\nexample  (φ  :  U  →ₗ[K]  V)  (ψ  :  U  →ₗ[K]  W)  :  U  →ₗ[K]  V  ×  W  :=  LinearMap.prod  φ  ψ\n\n-- The product map does the expected thing, first component\nexample  (φ  :  U  →ₗ[K]  V)  (ψ  :  U  →ₗ[K]  W)  :  LinearMap.fst  K  V  W  ∘ₗ  LinearMap.prod  φ  ψ  =  φ  :=  rfl\n\n-- The product map does the expected thing, second component\nexample  (φ  :  U  →ₗ[K]  V)  (ψ  :  U  →ₗ[K]  W)  :  LinearMap.snd  K  V  W  ∘ₗ  LinearMap.prod  φ  ψ  =  ψ  :=  rfl\n\n-- We can also combine maps in parallel\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  T)  :  (V  ×  W)  →ₗ[K]  (U  ×  T)  :=  φ.prodMap  ψ\n\n-- This is simply done by combining the projections with the universal property\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  T)  :\n  φ.prodMap  ψ  =  (φ  ∘ₗ  .fst  K  V  W).prod  (ψ  ∘ₗ  .snd  K  V  W)  :=  rfl\n\n-- First inclusion map\nexample  :  V  →ₗ[K]  V  ×  W  :=  LinearMap.inl  K  V  W\n\n-- Second inclusion map\nexample  :  W  →ₗ[K]  V  ×  W  :=  LinearMap.inr  K  V  W\n\n-- Universal property of the sum (aka coproduct)\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  U)  :  V  ×  W  →ₗ[K]  U  :=  φ.coprod  ψ\n\n-- The coproduct map does the expected thing, first component\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  U)  :  φ.coprod  ψ  ∘ₗ  LinearMap.inl  K  V  W  =  φ  :=\n  LinearMap.coprod_inl  φ  ψ\n\n-- The coproduct map does the expected thing, second component\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  U)  :  φ.coprod  ψ  ∘ₗ  LinearMap.inr  K  V  W  =  ψ  :=\n  LinearMap.coprod_inr  φ  ψ\n\n-- The coproduct map is defined in the expected way\nexample  (φ  :  V  →ₗ[K]  U)  (ψ  :  W  →ₗ[K]  U)  (v  :  V)  (w  :  W)  :\n  φ.coprod  ψ  (v,  w)  =  φ  v  +  ψ  w  :=\n  rfl\n\nend  binary_product \n```", "```py\nsection  families\nopen  DirectSum\n\nvariable  {ι  :  Type*}  [DecidableEq  ι]\n  (V  :  ι  →  Type*)  [∀  i,  AddCommGroup  (V  i)]  [∀  i,  Module  K  (V  i)]\n\n-- The universal property of the direct sum assembles maps from the summands to build\n-- a map from the direct sum\nexample  (φ  :  Π  i,  (V  i  →ₗ[K]  W))  :  (⨁  i,  V  i)  →ₗ[K]  W  :=\n  DirectSum.toModule  K  ι  W  φ\n\n-- The universal property of the direct product assembles maps into the factors\n-- to build a map into the direct product\nexample  (φ  :  Π  i,  (W  →ₗ[K]  V  i))  :  W  →ₗ[K]  (Π  i,  V  i)  :=\n  LinearMap.pi  φ\n\n-- The projection maps from the product\nexample  (i  :  ι)  :  (Π  j,  V  j)  →ₗ[K]  V  i  :=  LinearMap.proj  i\n\n-- The inclusion maps into the sum\nexample  (i  :  ι)  :  V  i  →ₗ[K]  (⨁  i,  V  i)  :=  DirectSum.lof  K  ι  V  i\n\n-- The inclusion maps into the product\nexample  (i  :  ι)  :  V  i  →ₗ[K]  (Π  i,  V  i)  :=  LinearMap.single  K  V  i\n\n-- In case `ι` is a finite type, there is an isomorphism between the sum and product.\nexample  [Fintype  ι]  :  (⨁  i,  V  i)  ≃ₗ[K]  (Π  i,  V  i)  :=\n  linearEquivFunOnFintype  K  ι  V\n\nend  families \n```", "```py\nvariable  {K  :  Type*}  [Field  K]  {V  :  Type*}  [AddCommGroup  V]  [Module  K  V]\n\nexample  (U  :  Submodule  K  V)  {x  y  :  V}  (hx  :  x  ∈  U)  (hy  :  y  ∈  U)  :\n  x  +  y  ∈  U  :=\n  U.add_mem  hx  hy\n\nexample  (U  :  Submodule  K  V)  {x  :  V}  (hx  :  x  ∈  U)  (a  :  K)  :\n  a  •  x  ∈  U  :=\n  U.smul_mem  a  hx \n```", "```py\nnoncomputable  example  :  Submodule  ℝ  ℂ  where\n  carrier  :=  Set.range  ((↑)  :  ℝ  →  ℂ)\n  add_mem'  :=  by\n  rintro  _  _  ⟨n,  rfl⟩  ⟨m,  rfl⟩\n  use  n  +  m\n  simp\n  zero_mem'  :=  by\n  use  0\n  simp\n  smul_mem'  :=  by\n  rintro  c  -  ⟨a,  rfl⟩\n  use  c*a\n  simp \n```", "```py\ndef  preimage  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]  (φ  :  V  →ₗ[K]  W)  (H  :  Submodule  K  W)  :\n  Submodule  K  V  where\n  carrier  :=  φ  ⁻¹'  H\n  zero_mem'  :=  by\n  sorry\n  add_mem'  :=  by\n  sorry\n  smul_mem'  :=  by\n  sorry \n```", "```py\nexample  (U  :  Submodule  K  V)  :  Module  K  U  :=  inferInstance \n```", "```py\nexample  (U  :  Submodule  K  V)  :  Module  K  {x  :  V  //  x  ∈  U}  :=  inferInstance \n```", "```py\nexample  (H  H'  :  Submodule  K  V)  :\n  ((H  ⊓  H'  :  Submodule  K  V)  :  Set  V)  =  (H  :  Set  V)  ∩  (H'  :  Set  V)  :=  rfl \n```", "```py\nexample  (H  H'  :  Submodule  K  V)  :\n  ((H  ⊔  H'  :  Submodule  K  V)  :  Set  V)  =  Submodule.span  K  ((H  :  Set  V)  ∪  (H'  :  Set  V))  :=  by\n  simp  [Submodule.span_union] \n```", "```py\nexample  (x  :  V)  :  x  ∈  (⊤  :  Submodule  K  V)  :=  trivial \n```", "```py\nexample  (x  :  V)  :  x  ∈  (⊥  :  Submodule  K  V)  ↔  x  =  0  :=  Submodule.mem_bot  K \n```", "```py\n-- If two subspaces are in direct sum then they span the whole space.\nexample  (U  V  :  Submodule  K  V)  (h  :  IsCompl  U  V)  :\n  U  ⊔  V  =  ⊤  :=  h.sup_eq_top\n\n-- If two subspaces are in direct sum then they intersect only at zero.\nexample  (U  V  :  Submodule  K  V)  (h  :  IsCompl  U  V)  :\n  U  ⊓  V  =  ⊥  :=  h.inf_eq_bot\n\nsection\nopen  DirectSum\nvariable  {ι  :  Type*}  [DecidableEq  ι]\n\n-- If subspaces are in direct sum then they span the whole space.\nexample  (U  :  ι  →  Submodule  K  V)  (h  :  DirectSum.IsInternal  U)  :\n  ⨆  i,  U  i  =  ⊤  :=  h.submodule_iSup_eq_top\n\n-- If subspaces are in direct sum then they pairwise intersect only at zero.\nexample  {ι  :  Type*}  [DecidableEq  ι]  (U  :  ι  →  Submodule  K  V)  (h  :  DirectSum.IsInternal  U)\n  {i  j  :  ι}  (hij  :  i  ≠  j)  :  U  i  ⊓  U  j  =  ⊥  :=\n  (h.submodule_iSupIndep.pairwiseDisjoint  hij).eq_bot\n\n-- Those conditions characterize direct sums.\n#check  DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top\n\n-- The relation with external direct sums: if a family of subspaces is\n-- in internal direct sum then the map from their external direct sum into `V`\n-- is a linear isomorphism.\nnoncomputable  example  {ι  :  Type*}  [DecidableEq  ι]  (U  :  ι  →  Submodule  K  V)\n  (h  :  DirectSum.IsInternal  U)  :  (⨁  i,  U  i)  ≃ₗ[K]  V  :=\n  LinearEquiv.ofBijective  (coeLinearMap  U)  h\nend \n```", "```py\nexample  {s  :  Set  V}  (E  :  Submodule  K  V)  :  Submodule.span  K  s  ≤  E  ↔  s  ⊆  E  :=\n  Submodule.span_le\n\nexample  :  GaloisInsertion  (Submodule.span  K)  ((↑)  :  Submodule  K  V  →  Set  V)  :=\n  Submodule.gi  K  V \n```", "```py\nexample  {S  T  :  Submodule  K  V}  {x  :  V}  (h  :  x  ∈  S  ⊔  T)  :\n  ∃  s  ∈  S,  ∃  t  ∈  T,  x  =  s  +  t  :=  by\n  rw  [←  S.span_eq,  ←  T.span_eq,  ←  Submodule.span_union]  at  h\n  induction  h  using  Submodule.span_induction  with\n  |  mem  y  h  =>\n  sorry\n  |  zero  =>\n  sorry\n  |  add  x  y  hx  hy  hx'  hy'  =>\n  sorry\n  |  smul  a  x  hx  hx'  =>\n  sorry \n```", "```py\nsection\n\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]  (φ  :  V  →ₗ[K]  W)\n\nvariable  (E  :  Submodule  K  V)  in\n#check  (Submodule.map  φ  E  :  Submodule  K  W)\n\nvariable  (F  :  Submodule  K  W)  in\n#check  (Submodule.comap  φ  F  :  Submodule  K  V) \n```", "```py\nexample  :  LinearMap.range  φ  =  .map  φ  ⊤  :=  LinearMap.range_eq_map  φ\n\nexample  :  LinearMap.ker  φ  =  .comap  φ  ⊥  :=  Submodule.comap_bot  φ  -- or `rfl` \n```", "```py\nopen  Function  LinearMap\n\nexample  :  Injective  φ  ↔  ker  φ  =  ⊥  :=  ker_eq_bot.symm\n\nexample  :  Surjective  φ  ↔  range  φ  =  ⊤  :=  range_eq_top.symm \n```", "```py\n#check  Submodule.mem_map_of_mem\n#check  Submodule.mem_map\n#check  Submodule.mem_comap\n\nexample  (E  :  Submodule  K  V)  (F  :  Submodule  K  W)  :\n  Submodule.map  φ  E  ≤  F  ↔  E  ≤  Submodule.comap  φ  F  :=  by\n  sorry \n```", "```py\nvariable  (E  :  Submodule  K  V)\n\nexample  :  Module  K  (V  ⧸  E)  :=  inferInstance\n\nexample  :  V  →ₗ[K]  V  ⧸  E  :=  E.mkQ\n\nexample  :  ker  E.mkQ  =  E  :=  E.ker_mkQ\n\nexample  :  range  E.mkQ  =  ⊤  :=  E.range_mkQ\n\nexample  (hφ  :  E  ≤  ker  φ)  :  V  ⧸  E  →ₗ[K]  W  :=  E.liftQ  φ  hφ\n\nexample  (F  :  Submodule  K  W)  (hφ  :  E  ≤  .comap  φ  F)  :  V  ⧸  E  →ₗ[K]  W  ⧸  F  :=  E.mapQ  F  φ  hφ\n\nnoncomputable  example  :  (V  ⧸  LinearMap.ker  φ)  ≃ₗ[K]  range  φ  :=  φ.quotKerEquivRange \n```", "```py\nopen  Submodule\n\n#check  Submodule.map_comap_eq\n#check  Submodule.comap_map_eq\n\nexample  :  Submodule  K  (V  ⧸  E)  ≃  {  F  :  Submodule  K  V  //  E  ≤  F  }  where\n  toFun  :=  sorry\n  invFun  :=  sorry\n  left_inv  :=  sorry\n  right_inv  :=  sorry \n```", "```py\nvariable  {K  :  Type*}  [Field  K]  {V  :  Type*}  [AddCommGroup  V]  [Module  K  V]\n\nexample  (U  :  Submodule  K  V)  {x  y  :  V}  (hx  :  x  ∈  U)  (hy  :  y  ∈  U)  :\n  x  +  y  ∈  U  :=\n  U.add_mem  hx  hy\n\nexample  (U  :  Submodule  K  V)  {x  :  V}  (hx  :  x  ∈  U)  (a  :  K)  :\n  a  •  x  ∈  U  :=\n  U.smul_mem  a  hx \n```", "```py\nnoncomputable  example  :  Submodule  ℝ  ℂ  where\n  carrier  :=  Set.range  ((↑)  :  ℝ  →  ℂ)\n  add_mem'  :=  by\n  rintro  _  _  ⟨n,  rfl⟩  ⟨m,  rfl⟩\n  use  n  +  m\n  simp\n  zero_mem'  :=  by\n  use  0\n  simp\n  smul_mem'  :=  by\n  rintro  c  -  ⟨a,  rfl⟩\n  use  c*a\n  simp \n```", "```py\ndef  preimage  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]  (φ  :  V  →ₗ[K]  W)  (H  :  Submodule  K  W)  :\n  Submodule  K  V  where\n  carrier  :=  φ  ⁻¹'  H\n  zero_mem'  :=  by\n  sorry\n  add_mem'  :=  by\n  sorry\n  smul_mem'  :=  by\n  sorry \n```", "```py\nexample  (U  :  Submodule  K  V)  :  Module  K  U  :=  inferInstance \n```", "```py\nexample  (U  :  Submodule  K  V)  :  Module  K  {x  :  V  //  x  ∈  U}  :=  inferInstance \n```", "```py\nexample  (H  H'  :  Submodule  K  V)  :\n  ((H  ⊓  H'  :  Submodule  K  V)  :  Set  V)  =  (H  :  Set  V)  ∩  (H'  :  Set  V)  :=  rfl \n```", "```py\nexample  (H  H'  :  Submodule  K  V)  :\n  ((H  ⊔  H'  :  Submodule  K  V)  :  Set  V)  =  Submodule.span  K  ((H  :  Set  V)  ∪  (H'  :  Set  V))  :=  by\n  simp  [Submodule.span_union] \n```", "```py\nexample  (x  :  V)  :  x  ∈  (⊤  :  Submodule  K  V)  :=  trivial \n```", "```py\nexample  (x  :  V)  :  x  ∈  (⊥  :  Submodule  K  V)  ↔  x  =  0  :=  Submodule.mem_bot  K \n```", "```py\n-- If two subspaces are in direct sum then they span the whole space.\nexample  (U  V  :  Submodule  K  V)  (h  :  IsCompl  U  V)  :\n  U  ⊔  V  =  ⊤  :=  h.sup_eq_top\n\n-- If two subspaces are in direct sum then they intersect only at zero.\nexample  (U  V  :  Submodule  K  V)  (h  :  IsCompl  U  V)  :\n  U  ⊓  V  =  ⊥  :=  h.inf_eq_bot\n\nsection\nopen  DirectSum\nvariable  {ι  :  Type*}  [DecidableEq  ι]\n\n-- If subspaces are in direct sum then they span the whole space.\nexample  (U  :  ι  →  Submodule  K  V)  (h  :  DirectSum.IsInternal  U)  :\n  ⨆  i,  U  i  =  ⊤  :=  h.submodule_iSup_eq_top\n\n-- If subspaces are in direct sum then they pairwise intersect only at zero.\nexample  {ι  :  Type*}  [DecidableEq  ι]  (U  :  ι  →  Submodule  K  V)  (h  :  DirectSum.IsInternal  U)\n  {i  j  :  ι}  (hij  :  i  ≠  j)  :  U  i  ⊓  U  j  =  ⊥  :=\n  (h.submodule_iSupIndep.pairwiseDisjoint  hij).eq_bot\n\n-- Those conditions characterize direct sums.\n#check  DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top\n\n-- The relation with external direct sums: if a family of subspaces is\n-- in internal direct sum then the map from their external direct sum into `V`\n-- is a linear isomorphism.\nnoncomputable  example  {ι  :  Type*}  [DecidableEq  ι]  (U  :  ι  →  Submodule  K  V)\n  (h  :  DirectSum.IsInternal  U)  :  (⨁  i,  U  i)  ≃ₗ[K]  V  :=\n  LinearEquiv.ofBijective  (coeLinearMap  U)  h\nend \n```", "```py\nexample  {s  :  Set  V}  (E  :  Submodule  K  V)  :  Submodule.span  K  s  ≤  E  ↔  s  ⊆  E  :=\n  Submodule.span_le\n\nexample  :  GaloisInsertion  (Submodule.span  K)  ((↑)  :  Submodule  K  V  →  Set  V)  :=\n  Submodule.gi  K  V \n```", "```py\nexample  {S  T  :  Submodule  K  V}  {x  :  V}  (h  :  x  ∈  S  ⊔  T)  :\n  ∃  s  ∈  S,  ∃  t  ∈  T,  x  =  s  +  t  :=  by\n  rw  [←  S.span_eq,  ←  T.span_eq,  ←  Submodule.span_union]  at  h\n  induction  h  using  Submodule.span_induction  with\n  |  mem  y  h  =>\n  sorry\n  |  zero  =>\n  sorry\n  |  add  x  y  hx  hy  hx'  hy'  =>\n  sorry\n  |  smul  a  x  hx  hx'  =>\n  sorry \n```", "```py\nsection\n\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]  (φ  :  V  →ₗ[K]  W)\n\nvariable  (E  :  Submodule  K  V)  in\n#check  (Submodule.map  φ  E  :  Submodule  K  W)\n\nvariable  (F  :  Submodule  K  W)  in\n#check  (Submodule.comap  φ  F  :  Submodule  K  V) \n```", "```py\nexample  :  LinearMap.range  φ  =  .map  φ  ⊤  :=  LinearMap.range_eq_map  φ\n\nexample  :  LinearMap.ker  φ  =  .comap  φ  ⊥  :=  Submodule.comap_bot  φ  -- or `rfl` \n```", "```py\nopen  Function  LinearMap\n\nexample  :  Injective  φ  ↔  ker  φ  =  ⊥  :=  ker_eq_bot.symm\n\nexample  :  Surjective  φ  ↔  range  φ  =  ⊤  :=  range_eq_top.symm \n```", "```py\n#check  Submodule.mem_map_of_mem\n#check  Submodule.mem_map\n#check  Submodule.mem_comap\n\nexample  (E  :  Submodule  K  V)  (F  :  Submodule  K  W)  :\n  Submodule.map  φ  E  ≤  F  ↔  E  ≤  Submodule.comap  φ  F  :=  by\n  sorry \n```", "```py\nvariable  (E  :  Submodule  K  V)\n\nexample  :  Module  K  (V  ⧸  E)  :=  inferInstance\n\nexample  :  V  →ₗ[K]  V  ⧸  E  :=  E.mkQ\n\nexample  :  ker  E.mkQ  =  E  :=  E.ker_mkQ\n\nexample  :  range  E.mkQ  =  ⊤  :=  E.range_mkQ\n\nexample  (hφ  :  E  ≤  ker  φ)  :  V  ⧸  E  →ₗ[K]  W  :=  E.liftQ  φ  hφ\n\nexample  (F  :  Submodule  K  W)  (hφ  :  E  ≤  .comap  φ  F)  :  V  ⧸  E  →ₗ[K]  W  ⧸  F  :=  E.mapQ  F  φ  hφ\n\nnoncomputable  example  :  (V  ⧸  LinearMap.ker  φ)  ≃ₗ[K]  range  φ  :=  φ.quotKerEquivRange \n```", "```py\nopen  Submodule\n\n#check  Submodule.map_comap_eq\n#check  Submodule.comap_map_eq\n\nexample  :  Submodule  K  (V  ⧸  E)  ≃  {  F  :  Submodule  K  V  //  E  ≤  F  }  where\n  toFun  :=  sorry\n  invFun  :=  sorry\n  left_inv  :=  sorry\n  right_inv  :=  sorry \n```", "```py\nvariable  {K  :  Type*}  [Field  K]  {V  :  Type*}  [AddCommGroup  V]  [Module  K  V]\n\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]\n\nopen  Polynomial  Module  LinearMap  End\n\nexample  (φ  ψ  :  End  K  V)  :  φ  *  ψ  =  φ  ∘ₗ  ψ  :=\n  End.mul_eq_comp  φ  ψ  -- `rfl` would also work\n\n-- evaluating `P` on `φ`\nexample  (P  :  K[X])  (φ  :  End  K  V)  :  V  →ₗ[K]  V  :=\n  aeval  φ  P\n\n-- evaluating `X` on `φ` gives back `φ`\nexample  (φ  :  End  K  V)  :  aeval  φ  (X  :  K[X])  =  φ  :=\n  aeval_X  φ \n```", "```py\n#check  Submodule.eq_bot_iff\n#check  Submodule.mem_inf\n#check  LinearMap.mem_ker\n\nexample  (P  Q  :  K[X])  (h  :  IsCoprime  P  Q)  (φ  :  End  K  V)  :  ker  (aeval  φ  P)  ⊓  ker  (aeval  φ  Q)  =  ⊥  :=  by\n  sorry\n\n#check  Submodule.add_mem_sup\n#check  map_mul\n#check  End.mul_apply\n#check  LinearMap.ker_le_ker_comp\n\nexample  (P  Q  :  K[X])  (h  :  IsCoprime  P  Q)  (φ  :  End  K  V)  :\n  ker  (aeval  φ  P)  ⊔  ker  (aeval  φ  Q)  =  ker  (aeval  φ  (P*Q))  :=  by\n  sorry \n```", "```py\nexample  (φ  :  End  K  V)  (a  :  K)  :  φ.eigenspace  a  =  LinearMap.ker  (φ  -  a  •  1)  :=\n  End.eigenspace_def \n```", "```py\nexample  (φ  :  End  K  V)  (a  :  K)  :  φ.HasEigenvalue  a  ↔  φ.eigenspace  a  ≠  ⊥  :=\n  Iff.rfl\n\nexample  (φ  :  End  K  V)  (a  :  K)  :  φ.HasEigenvalue  a  ↔  ∃  v,  φ.HasEigenvector  a  v  :=\n  ⟨End.HasEigenvalue.exists_hasEigenvector,  fun  ⟨_,  hv⟩  ↦  φ.hasEigenvalue_of_hasEigenvector  hv⟩\n\nexample  (φ  :  End  K  V)  :  φ.Eigenvalues  =  {a  //  φ.HasEigenvalue  a}  :=\n  rfl\n\n-- Eigenvalue are roots of the minimal polynomial\nexample  (φ  :  End  K  V)  (a  :  K)  :  φ.HasEigenvalue  a  →  (minpoly  K  φ).IsRoot  a  :=\n  φ.isRoot_of_hasEigenvalue\n\n-- In finite dimension, the converse is also true (we will discuss dimension below)\nexample  [FiniteDimensional  K  V]  (φ  :  End  K  V)  (a  :  K)  :\n  φ.HasEigenvalue  a  ↔  (minpoly  K  φ).IsRoot  a  :=\n  φ.hasEigenvalue_iff_isRoot\n\n-- Cayley-Hamilton\nexample  [FiniteDimensional  K  V]  (φ  :  End  K  V)  :  aeval  φ  φ.charpoly  =  0  :=\n  φ.aeval_self_charpoly \n```", "```py\nsection  matrices\n\n-- Adding vectors\n#eval  ![1,  2]  +  ![3,  4]  -- ![4, 6]\n\n-- Adding matrices\n#eval  !![1,  2;  3,  4]  +  !![3,  4;  5,  6]  -- !![4, 6; 8, 10]\n\n-- Multiplying matrices\n#eval  !![1,  2;  3,  4]  *  !![3,  4;  5,  6]  -- !![13, 16; 29, 36] \n```", "```py\nopen  Matrix\n\n-- matrices acting on vectors on the left\n#eval  !![1,  2;  3,  4]  *ᵥ  ![1,  1]  -- ![3, 7]\n\n-- matrices acting on vectors on the left, resulting in a size one matrix\n#eval  !![1,  2]  *ᵥ  ![1,  1]  -- ![3]\n\n-- matrices acting on vectors on the right\n#eval  ![1,  1,  1]  ᵥ*  !![1,  2;  3,  4;  5,  6]  -- ![9, 12] \n```", "```py\n#eval  replicateRow  (Fin  1)  ![1,  2]  -- !![1, 2]\n\n#eval  replicateCol  (Fin  1)  ![1,  2]  -- !![1; 2] \n```", "```py\n-- vector dot product\n#eval  ![1,  2]  ⬝ᵥ  ![3,  4]  -- `11`\n\n-- matrix transpose\n#eval  !![1,  2;  3,  4]ᵀ  -- `!![1, 3; 2, 4]`\n\n-- determinant\n#eval  !![(1  :  ℤ),  2;  3,  4].det  -- `-2`\n\n-- trace\n#eval  !![(1  :  ℤ),  2;  3,  4].trace  -- `5` \n```", "```py\n#simp  !![(1  :  ℝ),  2;  3,  4].det  -- `4 - 2*3`\n\n#norm_num  !![(1  :  ℝ),  2;  3,  4].det  -- `-2`\n\n#norm_num  !![(1  :  ℝ),  2;  3,  4].trace  -- `5`\n\nvariable  (a  b  c  d  :  ℝ)  in\n#simp  !![a,  b;  c,  d].det  -- `a * d – b * c` \n```", "```py\n#norm_num  [Matrix.inv_def]  !![(1  :  ℝ),  2;  3,  4]⁻¹  -- !![-2, 1; 3 / 2, -(1 / 2)] \n```", "```py\nexample  :  !![(1  :  ℝ),  2;  3,  4]⁻¹  *  !![(1  :  ℝ),  2;  3,  4]  =  1  :=  by\n  have  :  Invertible  !![(1  :  ℝ),  2;  3,  4]  :=  by\n  apply  Matrix.invertibleOfIsUnitDet\n  norm_num\n  simp \n```", "```py\nexample  :  !![(1  :  ℝ),  2;  3,  4]⁻¹  *  !![(1  :  ℝ),  2;  3,  4]  =  1  :=  by\n  norm_num  [Matrix.inv_def]\n  exact  one_fin_two.symm \n```", "```py\nsection\n\nexample  :  (fun  _  ↦  1  :  Fin  2  →  Fin  2  →  ℤ)  =  !![1,  1;  1,  1]  :=  by\n  ext  i  j\n  fin_cases  i  <;>  fin_cases  j  <;>  rfl\n\nexample  :  (fun  _  ↦  1  :  Fin  2  →  Fin  2  →  ℤ)  *  (fun  _  ↦  1  :  Fin  2  →  Fin  2  →  ℤ)  =  !![1,  1;  1,  1]  :=  by\n  ext  i  j\n  fin_cases  i  <;>  fin_cases  j  <;>  rfl\n\nexample  :  !![1,  1;  1,  1]  *  !![1,  1;  1,  1]  =  !![2,  2;  2,  2]  :=  by\n  norm_num \n```", "```py\nexample  {n  :  ℕ}  (v  :  Fin  n  →  ℝ)  :\n  Matrix.vandermonde  v  =  Matrix.of  (fun  i  j  :  Fin  n  ↦  v  i  ^  (j  :  ℕ))  :=\n  rfl\nend\nend  matrices \n```", "```py\nvariable  {K  :  Type*}  [Field  K]  {V  :  Type*}  [AddCommGroup  V]  [Module  K  V]\n\nsection\n\nvariable  {ι  :  Type*}  (B  :  Basis  ι  K  V)  (v  :  V)  (i  :  ι)\n\n-- The basis vector with index ``i``\n#check  (B  i  :  V)\n\n-- the linear isomorphism with the model space given by ``B``\n#check  (B.repr  :  V  ≃ₗ[K]  ι  →₀  K)\n\n-- the component function of ``v``\n#check  (B.repr  v  :  ι  →₀  K)\n\n-- the component of ``v`` with index ``i``\n#check  (B.repr  v  i  :  K) \n```", "```py\nnoncomputable  example  (b  :  ι  →  V)  (b_indep  :  LinearIndependent  K  b)\n  (b_spans  :  ∀  v,  v  ∈  Submodule.span  K  (Set.range  b))  :  Basis  ι  K  V  :=\n  Basis.mk  b_indep  (fun  v  _  ↦  b_spans  v)\n\n-- The family of vectors underlying the above basis is indeed ``b``.\nexample  (b  :  ι  →  V)  (b_indep  :  LinearIndependent  K  b)\n  (b_spans  :  ∀  v,  v  ∈  Submodule.span  K  (Set.range  b))  (i  :  ι)  :\n  Basis.mk  b_indep  (fun  v  _  ↦  b_spans  v)  i  =  b  i  :=\n  Basis.mk_apply  b_indep  (fun  v  _  ↦  b_spans  v)  i \n```", "```py\nvariable  [DecidableEq  ι] \n```", "```py\nexample  :  Finsupp.basisSingleOne.repr  =  LinearEquiv.refl  K  (ι  →₀  K)  :=\n  rfl\n\nexample  (i  :  ι)  :  Finsupp.basisSingleOne  i  =  Finsupp.single  i  1  :=\n  rfl \n```", "```py\nexample  [Finite  ι]  (x  :  ι  →  K)  (i  :  ι)  :  (Pi.basisFun  K  ι).repr  x  i  =  x  i  :=  by\n  simp \n```", "```py\nexample  [Fintype  ι]  :  ∑  i  :  ι,  B.repr  v  i  •  (B  i)  =  v  :=\n  B.sum_repr  v \n```", "```py\nexample  (c  :  ι  →₀  K)  (f  :  ι  →  V)  (s  :  Finset  ι)  (h  :  c.support  ⊆  s)  :\n  Finsupp.linearCombination  K  f  c  =  ∑  i  ∈  s,  c  i  •  f  i  :=\n  Finsupp.linearCombination_apply_of_mem_supported  K  h \n```", "```py\nexample  :  Finsupp.linearCombination  K  B  (B.repr  v)  =  v  :=\n  B.linearCombination_repr  v \n```", "```py\nvariable  (f  :  ι  →  V)  in\n#check  (Finsupp.linearCombination  K  f  :  (ι  →₀  K)  →ₗ[K]  V) \n```", "```py\nsection\n\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]\n  (φ  :  V  →ₗ[K]  W)  (u  :  ι  →  W)\n\n#check  (B.constr  K  :  (ι  →  W)  ≃ₗ[K]  (V  →ₗ[K]  W))\n\n#check  (B.constr  K  u  :  V  →ₗ[K]  W)\n\nexample  (i  :  ι)  :  B.constr  K  u  (B  i)  =  u  i  :=\n  B.constr_basis  K  u  i \n```", "```py\nexample  (φ  ψ  :  V  →ₗ[K]  W)  (h  :  ∀  i,  φ  (B  i)  =  ψ  (B  i))  :  φ  =  ψ  :=\n  B.ext  h \n```", "```py\nvariable  {ι'  :  Type*}  (B'  :  Basis  ι'  K  W)  [Fintype  ι]  [DecidableEq  ι]  [Fintype  ι']  [DecidableEq  ι']\n\nopen  LinearMap\n\n#check  (toMatrix  B  B'  :  (V  →ₗ[K]  W)  ≃ₗ[K]  Matrix  ι'  ι  K)\n\nopen  Matrix  -- get access to the ``*ᵥ`` notation for multiplication between matrices and vectors.\n\nexample  (φ  :  V  →ₗ[K]  W)  (v  :  V)  :  (toMatrix  B  B'  φ)  *ᵥ  (B.repr  v)  =  B'.repr  (φ  v)  :=\n  toMatrix_mulVec_repr  B  B'  φ  v\n\nvariable  {ι''  :  Type*}  (B''  :  Basis  ι''  K  W)  [Fintype  ι'']  [DecidableEq  ι'']\n\nexample  (φ  :  V  →ₗ[K]  W)  :  (toMatrix  B  B''  φ)  =  (toMatrix  B'  B''  .id)  *  (toMatrix  B  B'  φ)  :=  by\n  simp\n\nend \n```", "```py\nopen  Module  LinearMap  Matrix\n\n-- Some lemmas coming from the fact that `LinearMap.toMatrix` is an algebra morphism.\n#check  toMatrix_comp\n#check  id_comp\n#check  comp_id\n#check  toMatrix_id\n\n-- Some lemmas coming from the fact that ``Matrix.det`` is a multiplicative monoid morphism.\n#check  Matrix.det_mul\n#check  Matrix.det_one\n\nexample  [Fintype  ι]  (B'  :  Basis  ι  K  V)  (φ  :  End  K  V)  :\n  (toMatrix  B  B  φ).det  =  (toMatrix  B'  B'  φ).det  :=  by\n  set  M  :=  toMatrix  B  B  φ\n  set  M'  :=  toMatrix  B'  B'  φ\n  set  P  :=  (toMatrix  B  B')  LinearMap.id\n  set  P'  :=  (toMatrix  B'  B)  LinearMap.id\n  sorry\nend \n```", "```py\nsection\n#check  (Module.finrank  K  V  :  ℕ)\n\n-- `Fin n → K` is the archetypical space with dimension `n` over `K`.\nexample  (n  :  ℕ)  :  Module.finrank  K  (Fin  n  →  K)  =  n  :=\n  Module.finrank_fin_fun  K\n\n-- Seen as a vector space over itself, `ℂ` has dimension one.\nexample  :  Module.finrank  ℂ  ℂ  =  1  :=\n  Module.finrank_self  ℂ\n\n-- But as a real vector space it has dimension two.\nexample  :  Module.finrank  ℝ  ℂ  =  2  :=\n  Complex.finrank_real_complex \n```", "```py\nexample  [FiniteDimensional  K  V]  :  0  <  Module.finrank  K  V  ↔  Nontrivial  V  :=\n  Module.finrank_pos_iff \n```", "```py\nexample  [FiniteDimensional  K  V]  (h  :  0  <  Module.finrank  K  V)  :  Nontrivial  V  :=  by\n  apply  (Module.finrank_pos_iff  (R  :=  K)).1\n  exact  h \n```", "```py\nvariable  {ι  :  Type*}  (B  :  Basis  ι  K  V)\n\nexample  [Finite  ι]  :  FiniteDimensional  K  V  :=  FiniteDimensional.of_fintype_basis  B\n\nexample  [FiniteDimensional  K  V]  :  Finite  ι  :=\n  (FiniteDimensional.fintypeBasisIndex  B).finite\nend \n```", "```py\nsection\nvariable  (E  F  :  Submodule  K  V)  [FiniteDimensional  K  V]\n\nopen  Module\n\nexample  :  finrank  K  (E  ⊔  F  :  Submodule  K  V)  +  finrank  K  (E  ⊓  F  :  Submodule  K  V)  =\n  finrank  K  E  +  finrank  K  F  :=\n  Submodule.finrank_sup_add_finrank_inf_eq  E  F\n\nexample  :  finrank  K  E  ≤  finrank  K  V  :=  Submodule.finrank_le  E \n```", "```py\nexample  (h  :  finrank  K  V  <  finrank  K  E  +  finrank  K  F)  :\n  Nontrivial  (E  ⊓  F  :  Submodule  K  V)  :=  by\n  sorry\nend \n```", "```py\n#check  V  -- Type u_2\n#check  Module.rank  K  V  -- Cardinal.{u_2} \n```", "```py\nuniverse  u  v  -- `u` and `v` will denote universe levels\n\nvariable  {ι  :  Type  u}  (B  :  Basis  ι  K  V)\n  {ι'  :  Type  v}  (B'  :  Basis  ι'  K  V)\n\nexample  :  Cardinal.lift.{v,  u}  (.mk  ι)  =  Cardinal.lift.{u,  v}  (.mk  ι')  :=\n  mk_eq_mk_of_basis  B  B' \n```", "```py\nexample  [FiniteDimensional  K  V]  :\n  (Module.finrank  K  V  :  Cardinal)  =  Module.rank  K  V  :=\n  Module.finrank_eq_rank  K  V \n```", "```py\nsection  matrices\n\n-- Adding vectors\n#eval  ![1,  2]  +  ![3,  4]  -- ![4, 6]\n\n-- Adding matrices\n#eval  !![1,  2;  3,  4]  +  !![3,  4;  5,  6]  -- !![4, 6; 8, 10]\n\n-- Multiplying matrices\n#eval  !![1,  2;  3,  4]  *  !![3,  4;  5,  6]  -- !![13, 16; 29, 36] \n```", "```py\nopen  Matrix\n\n-- matrices acting on vectors on the left\n#eval  !![1,  2;  3,  4]  *ᵥ  ![1,  1]  -- ![3, 7]\n\n-- matrices acting on vectors on the left, resulting in a size one matrix\n#eval  !![1,  2]  *ᵥ  ![1,  1]  -- ![3]\n\n-- matrices acting on vectors on the right\n#eval  ![1,  1,  1]  ᵥ*  !![1,  2;  3,  4;  5,  6]  -- ![9, 12] \n```", "```py\n#eval  replicateRow  (Fin  1)  ![1,  2]  -- !![1, 2]\n\n#eval  replicateCol  (Fin  1)  ![1,  2]  -- !![1; 2] \n```", "```py\n-- vector dot product\n#eval  ![1,  2]  ⬝ᵥ  ![3,  4]  -- `11`\n\n-- matrix transpose\n#eval  !![1,  2;  3,  4]ᵀ  -- `!![1, 3; 2, 4]`\n\n-- determinant\n#eval  !![(1  :  ℤ),  2;  3,  4].det  -- `-2`\n\n-- trace\n#eval  !![(1  :  ℤ),  2;  3,  4].trace  -- `5` \n```", "```py\n#simp  !![(1  :  ℝ),  2;  3,  4].det  -- `4 - 2*3`\n\n#norm_num  !![(1  :  ℝ),  2;  3,  4].det  -- `-2`\n\n#norm_num  !![(1  :  ℝ),  2;  3,  4].trace  -- `5`\n\nvariable  (a  b  c  d  :  ℝ)  in\n#simp  !![a,  b;  c,  d].det  -- `a * d – b * c` \n```", "```py\n#norm_num  [Matrix.inv_def]  !![(1  :  ℝ),  2;  3,  4]⁻¹  -- !![-2, 1; 3 / 2, -(1 / 2)] \n```", "```py\nexample  :  !![(1  :  ℝ),  2;  3,  4]⁻¹  *  !![(1  :  ℝ),  2;  3,  4]  =  1  :=  by\n  have  :  Invertible  !![(1  :  ℝ),  2;  3,  4]  :=  by\n  apply  Matrix.invertibleOfIsUnitDet\n  norm_num\n  simp \n```", "```py\nexample  :  !![(1  :  ℝ),  2;  3,  4]⁻¹  *  !![(1  :  ℝ),  2;  3,  4]  =  1  :=  by\n  norm_num  [Matrix.inv_def]\n  exact  one_fin_two.symm \n```", "```py\nsection\n\nexample  :  (fun  _  ↦  1  :  Fin  2  →  Fin  2  →  ℤ)  =  !![1,  1;  1,  1]  :=  by\n  ext  i  j\n  fin_cases  i  <;>  fin_cases  j  <;>  rfl\n\nexample  :  (fun  _  ↦  1  :  Fin  2  →  Fin  2  →  ℤ)  *  (fun  _  ↦  1  :  Fin  2  →  Fin  2  →  ℤ)  =  !![1,  1;  1,  1]  :=  by\n  ext  i  j\n  fin_cases  i  <;>  fin_cases  j  <;>  rfl\n\nexample  :  !![1,  1;  1,  1]  *  !![1,  1;  1,  1]  =  !![2,  2;  2,  2]  :=  by\n  norm_num \n```", "```py\nexample  {n  :  ℕ}  (v  :  Fin  n  →  ℝ)  :\n  Matrix.vandermonde  v  =  Matrix.of  (fun  i  j  :  Fin  n  ↦  v  i  ^  (j  :  ℕ))  :=\n  rfl\nend\nend  matrices \n```", "```py\nvariable  {K  :  Type*}  [Field  K]  {V  :  Type*}  [AddCommGroup  V]  [Module  K  V]\n\nsection\n\nvariable  {ι  :  Type*}  (B  :  Basis  ι  K  V)  (v  :  V)  (i  :  ι)\n\n-- The basis vector with index ``i``\n#check  (B  i  :  V)\n\n-- the linear isomorphism with the model space given by ``B``\n#check  (B.repr  :  V  ≃ₗ[K]  ι  →₀  K)\n\n-- the component function of ``v``\n#check  (B.repr  v  :  ι  →₀  K)\n\n-- the component of ``v`` with index ``i``\n#check  (B.repr  v  i  :  K) \n```", "```py\nnoncomputable  example  (b  :  ι  →  V)  (b_indep  :  LinearIndependent  K  b)\n  (b_spans  :  ∀  v,  v  ∈  Submodule.span  K  (Set.range  b))  :  Basis  ι  K  V  :=\n  Basis.mk  b_indep  (fun  v  _  ↦  b_spans  v)\n\n-- The family of vectors underlying the above basis is indeed ``b``.\nexample  (b  :  ι  →  V)  (b_indep  :  LinearIndependent  K  b)\n  (b_spans  :  ∀  v,  v  ∈  Submodule.span  K  (Set.range  b))  (i  :  ι)  :\n  Basis.mk  b_indep  (fun  v  _  ↦  b_spans  v)  i  =  b  i  :=\n  Basis.mk_apply  b_indep  (fun  v  _  ↦  b_spans  v)  i \n```", "```py\nvariable  [DecidableEq  ι] \n```", "```py\nexample  :  Finsupp.basisSingleOne.repr  =  LinearEquiv.refl  K  (ι  →₀  K)  :=\n  rfl\n\nexample  (i  :  ι)  :  Finsupp.basisSingleOne  i  =  Finsupp.single  i  1  :=\n  rfl \n```", "```py\nexample  [Finite  ι]  (x  :  ι  →  K)  (i  :  ι)  :  (Pi.basisFun  K  ι).repr  x  i  =  x  i  :=  by\n  simp \n```", "```py\nexample  [Fintype  ι]  :  ∑  i  :  ι,  B.repr  v  i  •  (B  i)  =  v  :=\n  B.sum_repr  v \n```", "```py\nexample  (c  :  ι  →₀  K)  (f  :  ι  →  V)  (s  :  Finset  ι)  (h  :  c.support  ⊆  s)  :\n  Finsupp.linearCombination  K  f  c  =  ∑  i  ∈  s,  c  i  •  f  i  :=\n  Finsupp.linearCombination_apply_of_mem_supported  K  h \n```", "```py\nexample  :  Finsupp.linearCombination  K  B  (B.repr  v)  =  v  :=\n  B.linearCombination_repr  v \n```", "```py\nvariable  (f  :  ι  →  V)  in\n#check  (Finsupp.linearCombination  K  f  :  (ι  →₀  K)  →ₗ[K]  V) \n```", "```py\nsection\n\nvariable  {W  :  Type*}  [AddCommGroup  W]  [Module  K  W]\n  (φ  :  V  →ₗ[K]  W)  (u  :  ι  →  W)\n\n#check  (B.constr  K  :  (ι  →  W)  ≃ₗ[K]  (V  →ₗ[K]  W))\n\n#check  (B.constr  K  u  :  V  →ₗ[K]  W)\n\nexample  (i  :  ι)  :  B.constr  K  u  (B  i)  =  u  i  :=\n  B.constr_basis  K  u  i \n```", "```py\nexample  (φ  ψ  :  V  →ₗ[K]  W)  (h  :  ∀  i,  φ  (B  i)  =  ψ  (B  i))  :  φ  =  ψ  :=\n  B.ext  h \n```", "```py\nvariable  {ι'  :  Type*}  (B'  :  Basis  ι'  K  W)  [Fintype  ι]  [DecidableEq  ι]  [Fintype  ι']  [DecidableEq  ι']\n\nopen  LinearMap\n\n#check  (toMatrix  B  B'  :  (V  →ₗ[K]  W)  ≃ₗ[K]  Matrix  ι'  ι  K)\n\nopen  Matrix  -- get access to the ``*ᵥ`` notation for multiplication between matrices and vectors.\n\nexample  (φ  :  V  →ₗ[K]  W)  (v  :  V)  :  (toMatrix  B  B'  φ)  *ᵥ  (B.repr  v)  =  B'.repr  (φ  v)  :=\n  toMatrix_mulVec_repr  B  B'  φ  v\n\nvariable  {ι''  :  Type*}  (B''  :  Basis  ι''  K  W)  [Fintype  ι'']  [DecidableEq  ι'']\n\nexample  (φ  :  V  →ₗ[K]  W)  :  (toMatrix  B  B''  φ)  =  (toMatrix  B'  B''  .id)  *  (toMatrix  B  B'  φ)  :=  by\n  simp\n\nend \n```", "```py\nopen  Module  LinearMap  Matrix\n\n-- Some lemmas coming from the fact that `LinearMap.toMatrix` is an algebra morphism.\n#check  toMatrix_comp\n#check  id_comp\n#check  comp_id\n#check  toMatrix_id\n\n-- Some lemmas coming from the fact that ``Matrix.det`` is a multiplicative monoid morphism.\n#check  Matrix.det_mul\n#check  Matrix.det_one\n\nexample  [Fintype  ι]  (B'  :  Basis  ι  K  V)  (φ  :  End  K  V)  :\n  (toMatrix  B  B  φ).det  =  (toMatrix  B'  B'  φ).det  :=  by\n  set  M  :=  toMatrix  B  B  φ\n  set  M'  :=  toMatrix  B'  B'  φ\n  set  P  :=  (toMatrix  B  B')  LinearMap.id\n  set  P'  :=  (toMatrix  B'  B)  LinearMap.id\n  sorry\nend \n```", "```py\nsection\n#check  (Module.finrank  K  V  :  ℕ)\n\n-- `Fin n → K` is the archetypical space with dimension `n` over `K`.\nexample  (n  :  ℕ)  :  Module.finrank  K  (Fin  n  →  K)  =  n  :=\n  Module.finrank_fin_fun  K\n\n-- Seen as a vector space over itself, `ℂ` has dimension one.\nexample  :  Module.finrank  ℂ  ℂ  =  1  :=\n  Module.finrank_self  ℂ\n\n-- But as a real vector space it has dimension two.\nexample  :  Module.finrank  ℝ  ℂ  =  2  :=\n  Complex.finrank_real_complex \n```", "```py\nexample  [FiniteDimensional  K  V]  :  0  <  Module.finrank  K  V  ↔  Nontrivial  V  :=\n  Module.finrank_pos_iff \n```", "```py\nexample  [FiniteDimensional  K  V]  (h  :  0  <  Module.finrank  K  V)  :  Nontrivial  V  :=  by\n  apply  (Module.finrank_pos_iff  (R  :=  K)).1\n  exact  h \n```", "```py\nvariable  {ι  :  Type*}  (B  :  Basis  ι  K  V)\n\nexample  [Finite  ι]  :  FiniteDimensional  K  V  :=  FiniteDimensional.of_fintype_basis  B\n\nexample  [FiniteDimensional  K  V]  :  Finite  ι  :=\n  (FiniteDimensional.fintypeBasisIndex  B).finite\nend \n```", "```py\nsection\nvariable  (E  F  :  Submodule  K  V)  [FiniteDimensional  K  V]\n\nopen  Module\n\nexample  :  finrank  K  (E  ⊔  F  :  Submodule  K  V)  +  finrank  K  (E  ⊓  F  :  Submodule  K  V)  =\n  finrank  K  E  +  finrank  K  F  :=\n  Submodule.finrank_sup_add_finrank_inf_eq  E  F\n\nexample  :  finrank  K  E  ≤  finrank  K  V  :=  Submodule.finrank_le  E \n```", "```py\nexample  (h  :  finrank  K  V  <  finrank  K  E  +  finrank  K  F)  :\n  Nontrivial  (E  ⊓  F  :  Submodule  K  V)  :=  by\n  sorry\nend \n```", "```py\n#check  V  -- Type u_2\n#check  Module.rank  K  V  -- Cardinal.{u_2} \n```", "```py\nuniverse  u  v  -- `u` and `v` will denote universe levels\n\nvariable  {ι  :  Type  u}  (B  :  Basis  ι  K  V)\n  {ι'  :  Type  v}  (B'  :  Basis  ι'  K  V)\n\nexample  :  Cardinal.lift.{v,  u}  (.mk  ι)  =  Cardinal.lift.{u,  v}  (.mk  ι')  :=\n  mk_eq_mk_of_basis  B  B' \n```", "```py\nexample  [FiniteDimensional  K  V]  :\n  (Module.finrank  K  V  :  Cardinal)  =  Module.rank  K  V  :=\n  Module.finrank_eq_rank  K  V \n```"]