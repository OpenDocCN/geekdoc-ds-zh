- en: Boundary Conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://phys-sim-book.github.io/lec28.1-grid_bc.html](https://phys-sim-book.github.io/lec28.1-grid_bc.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  prefs: []
  type: TYPE_NORMAL
- en: In the Material Point Method, **boundary conditions (BCs)** are enforced on
    the background Eulerian grid, because the governing equations—discretized in their
    weak form—are formulated over grid nodes, which serve as the true degrees of freedom
    (DOFs) of the system. These nodes must satisfy Newton's Second Law. Thus, all
    external constraints, including static walls, moving boundaries, or contact forces,
    must be applied directly on the grid after P2G and before G2P.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we denote the nodal velocity at a grid node xi​ as v^in+1​. After
    external force integration, we apply different velocity projections on boundary
    nodes depending on the type of boundary condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[Types of Boundary Conditions](#types-of-boundary-conditions)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let n be the surface normal at a boundary grid node xi​:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sticky**: The velocity is fully suppressed: v^in+1​←0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slip**: Only the normal component is removed; tangential motion is preserved:
    v^in+1​←v^in+1​−n(n⊤v^in+1​).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separate (One-way wall)**: Normal inflow is blocked, but outward motion is
    allowed: v^in+1​←v^in+1​−n⋅min(n⊤v^in+1​,0).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These operations are **local**, applied independently to each boundary grid
    node.
  prefs: []
  type: TYPE_NORMAL
- en: '[External Forces](#external-forces)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'External forces such as **gravity** can be added after P2G:'
  prefs: []
  type: TYPE_NORMAL
- en: v^in+1​←v^in+1​+Δt⋅g.
  prefs: []
  type: TYPE_NORMAL
- en: '[Moving Colliders](#moving-colliders)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For moving or deforming objects, [**Signed Distance Functions (SDFs)**](./lec7.1-signed_dists.html)
    are used to detect whether a grid node xi​ lies inside the object. Once detected,
    the **surface normal** n and the **relative velocity** Δv are computed, and the
    grid velocity is adjusted accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '[Coulomb Friction](#coulomb-friction)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To enforce **Coulomb friction** on embedded colliders (e.g., sphere or capsule),
    we apply a projected velocity correction in the direction of the surface normal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let n be the contact normal and Δv be the opposing velocity (i.e., Δv=vSDF​−v^in+1​).
    Define the normal component:'
  prefs: []
  type: TYPE_NORMAL
- en: v˙n​=n⊤Δv.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the corrected grid velocity is:'
  prefs: []
  type: TYPE_NORMAL
- en: v^in+1​←v^in+1​+Δv⋅μ+n⋅v˙n​⋅(1−μ),
  prefs: []
  type: TYPE_NORMAL
- en: where μ∈[0,1] is the **friction coefficient**. This operation smoothly blends
    between full **separation** (μ=0) and **sticking** (μ=1).
  prefs: []
  type: TYPE_NORMAL
