["```\n#include  <stdio.h>\n#include  <openacc.h>\n\n#define NX 102400\n\nint  main(void)\n{\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n  int  i;\n\n  /* Initialization of the vectors */\n  for  (i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  2.0;\n  }\n\n #pragma acc kernels  for  (i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n\n  return  0;\n} \n```", "```\nprogram main\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  integer  ::  i\n\n  double precision  ::  vecA(nx),  vecB(nx),  vecC(nx)\n\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$acc kernels  do i  =  1,  nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  end do\n !$acc end kernels \nend program \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n\n#define NX 102400\n\nint  main(void)\n{\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n  int  i;\n\n  /* Initialization of the vectors */\n  for  (i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  2.0;\n  }\n\n #pragma acc parallel loop  for  (i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n\n  return  0;\n} \n```", "```\nprogram main\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  integer  ::  i\n\n  double precision  ::  vecA(nx),  vecB(nx),  vecC(nx)\n\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$acc parallel loop  do i  =  1,  nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  end do\n !$acc end parallel loop \nend program \n```", "```\n#include  <stdio.h>\n\n#define NX 102400\n\nint  main(void)\n{\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n  int  i;\n\n  /* Initialization of the vectors */\n  for  (i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  2.0;\n  }\n\n #pragma omp target  for  (i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n\n  return  0;\n} \n```", "```\nprogram main\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  integer  ::  i\n\n  double precision  ::  vecA(nx),  vecB(nx),  vecC(nx)\n\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$omp target  do i  =  1,  nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  end do\n !$omp end target \nend program \n```", "```\nsalloc  -A  project_465002387  -N  1  -t  1:00:00  -p  standard-g  --gpus-per-node=1\n\nmodule  load  LUMI/24.03\nmodule  load  partition/G\nmodule  load  rocm/6.0.3\n\n# OpenMP\ncc  -O2  -fopenmp  -o  ex1  ex1.c\n# Only OpenACC Fortran is supported by HPE compiler.\n\nexport  CRAY_ACC_DEBUG=2\nsrun  ./ex1 \n```", "```\nsalloc  -A  project_465002387  -N  1  -t  1:00:00  -p  standard-g  --gpus-per-node=1\n\nmodule  load  LUMI/24.03\nmodule  load  partition/G\nmodule  load  rocm/6.0.3\n\nexport  CRAY_ACC_DEBUG=2\n# OpenMP\nftn  -O2  -homp  -o  ex1  ex1.f90\nsrun  ./ex1\n\n# OpenACC\nftn  -O2  -hacc  -o  ex1  ex1.f90\nsrun  ./ex1 \n```", "```\n#include  <stdio.h>\n#include  <math.h>\n#define NX 102400\n\nint  main(void){\n  double  vecA[NX],vecB[NX],vecC[NX];\n\n  /* Initialize vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n\n  #pragma omp target teams distribute parallel for simd\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(nx)  ::  vecA,vecB,vecC\n  integer  ::  i\n\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n  !$omp target teams distribute parallel do simd\n  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$omp end target teams distribute parallel do simd\nend program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n#define NX 102400\n\nint  main(void)  {\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n\n  /* Initialization of the vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n  #pragma acc parallel loop\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n} \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(:),  allocatable  ::  vecA,vecB,vecC\n  integer  ::  i\n\n  allocate  (vecA(nx),  vecB(nx),vecC(nx))\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n  !$acc parallel loop\n  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$acc end parallel loop\nend program vecsum \n```", "```\n#pragma omp target data [clauses]\n{structured-block} \n```", "```\n!$omp target data [clauses]\n  structured-block\n!$omp end target data \n```", "```\n#pragma acc data [clauses]\n  {structured-block} \n```", "```\n!$acc data [clauses]\n  structured-block\n!$acc end data \n```", "```\n#pragma omp target enter data [clauses] \n```", "```\n#pragma omp target exit data \n```", "```\n!$omp target enter data [clauses] \n```", "```\n!$omp target exit data \n```", "```\n#pragma acc enter data [clauses] \n```", "```\n#pragma acc exit data \n```", "```\n!$acc enter data [clauses] \n```", "```\n!$acc exit data \n```", "```\n#pragma omp target update [clauses] \n```", "```\nmotion-clause:\n  to  (list)\n  from  (list) \n```", "```\n!$omp target update [clauses] \n```", "```\nmotion-clause:\n  to  (list)\n  from  (list) \n```", "```\n#pragma acc update [clauses] \n```", "```\nmotion-clause:\n  self  (list)\n  device  (list) \n```", "```\n!$acc update [clauses] \n```", "```\nmotion-clause:\n  self  (list)\n  device  (list) \n```", "```\n#include  <stdio.h>\nint  main(void)\n{\nint  x  =  0;\n\n#pragma omp target data map(tofrom:x)\n{\n  /* check point 1 */\n  x  =  10;\n  /* check point 2 */\n#pragma omp target update to(x)\n  /* check point 3 */\n}\n\nreturn  0;\n} \n```", "```\nprogram ex_update\nimplicit none\n\ninteger  ::  x\n\nx  =  0\n!$acc data copy(x)\n! check point 1\nx  =  10\n! check point 2\n!$acc update device(x)\n! check point 3\n!$acc end data\n\nend program ex_update \n```", "```\n#include  <stdio.h>\n#include  <math.h>\n#define NX 102400\n\nint  main(void){\n  double  vecA[NX],vecB[NX],vecC[NX];\n\n  /* Initialize vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n  /* Adding mapping clauses here */\n  #pragma omp target teams distribute parallel for simd\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n} \n```", "```\nprogram vecsum\nimplicit none\n\ninteger,  parameter  ::  nx  =  102400\nreal,  dimension(nx)  ::  vecA,vecB,vecC\n  real  ::  sum\ninteger  ::  i\n\n! Initialization of vectors\ndo i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\nend do\n! Adding mapping clauses here\n!$omp target teams distribute parallel do simd\ndo i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\nenddo\n!$omp end target teams distribute parallel do simd\n\nsum  =  0.0\n! Calculate the sum\ndo i  =  1,  nx\n  sum  =  vecC(i)  +  sum\nend do\nwrite(*,'(A,F18.6)')  'The sum is: ',  sum\n\nend program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n#define NX 102400\n\nint  main(void)  {\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n\n  /* Initialization of the vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n  /* Adding mapping clauses here */\n  #pragma acc parallel loop\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(:),  allocatable  ::  vecA,vecB,vecC\n  real  ::  sum\n  integer  ::  i\n\n  allocate  (vecA(nx),  vecB(nx),vecC(nx))\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n  ! Adding mapping clauses here\n  !$acc parallel loop\n  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$acc end parallel loop\n\n  sum  =  0.0\n  ! Calculate the sum\n  do i  =  1,  nx\n  sum  =  vecC(i)  +  sum\n  end do\n write(*,'(A,F18.6)')  'The sum is: ',  sum\n\n  end program vecsum \n```", "```\n#include  <stdio.h>\n#include  <math.h>\n#define NX 102400\n\nint  main(void){\n  double  vecA[NX],vecB[NX],vecC[NX];\n\n  /* Initialize vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n\n #pragma omp target teams distribute parallel for simd map(to:vecA[0:NX],vecB[0:NX]) map(from:vecC[0:NX])  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(nx)  ::  vecA,vecB,vecC\n  real  ::  sum\n  integer  ::  i\n\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$omp target teams distribute parallel do simd map(to:vecA,vecB) map(from:vecC)  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$omp end target teams distribute parallel do simd\n\n  sum  =  0.0\n  ! Calculate the sum\n  do i  =  1,  nx\n  sum  =  vecC(i)  +  sum\n  end do\n write(*,'(A,F18.6)')  'The sum is: ',  sum\n\n  end program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n#define NX 102400\n\nint  main(void)  {\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n\n  /* Initialization of the vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n\n #pragma acc parallel loop copyin(vecA[0:NX],vecB[0:NX]) copyout(vecC[0:NX])  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(nx)  ::  vecA,vecB,vecC\n  real  ::  sum\n  integer  ::  i\n\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$acc parallel loop copyin(vecA,vecB) copyout(vecC)  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$acc end parallel loop\n\n  sum  =  0.0\n  ! Calculate the sum\n  do i  =  1,  nx\n  sum  =  vecC(i)  +  sum\n  end do\n write(*,'(A,F18.6)')  'The sum is: ',  sum\n\n  end program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n\n#define NX 102400\n\nint  main(void)\n{\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n  int  i;\n\n  /* Initialization of the vectors */\n  for  (i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  2.0;\n  }\n\n #pragma acc kernels  for  (i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n\n  return  0;\n} \n```", "```\nprogram main\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  integer  ::  i\n\n  double precision  ::  vecA(nx),  vecB(nx),  vecC(nx)\n\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$acc kernels  do i  =  1,  nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  end do\n !$acc end kernels \nend program \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n\n#define NX 102400\n\nint  main(void)\n{\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n  int  i;\n\n  /* Initialization of the vectors */\n  for  (i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  2.0;\n  }\n\n #pragma acc parallel loop  for  (i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n\n  return  0;\n} \n```", "```\nprogram main\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  integer  ::  i\n\n  double precision  ::  vecA(nx),  vecB(nx),  vecC(nx)\n\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$acc parallel loop  do i  =  1,  nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  end do\n !$acc end parallel loop \nend program \n```", "```\n#include  <stdio.h>\n\n#define NX 102400\n\nint  main(void)\n{\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n  int  i;\n\n  /* Initialization of the vectors */\n  for  (i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  2.0;\n  }\n\n #pragma omp target  for  (i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n\n  return  0;\n} \n```", "```\nprogram main\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  integer  ::  i\n\n  double precision  ::  vecA(nx),  vecB(nx),  vecC(nx)\n\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$omp target  do i  =  1,  nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  end do\n !$omp end target \nend program \n```", "```\nsalloc  -A  project_465002387  -N  1  -t  1:00:00  -p  standard-g  --gpus-per-node=1\n\nmodule  load  LUMI/24.03\nmodule  load  partition/G\nmodule  load  rocm/6.0.3\n\n# OpenMP\ncc  -O2  -fopenmp  -o  ex1  ex1.c\n# Only OpenACC Fortran is supported by HPE compiler.\n\nexport  CRAY_ACC_DEBUG=2\nsrun  ./ex1 \n```", "```\nsalloc  -A  project_465002387  -N  1  -t  1:00:00  -p  standard-g  --gpus-per-node=1\n\nmodule  load  LUMI/24.03\nmodule  load  partition/G\nmodule  load  rocm/6.0.3\n\nexport  CRAY_ACC_DEBUG=2\n# OpenMP\nftn  -O2  -homp  -o  ex1  ex1.f90\nsrun  ./ex1\n\n# OpenACC\nftn  -O2  -hacc  -o  ex1  ex1.f90\nsrun  ./ex1 \n```", "```\n#include  <stdio.h>\n#include  <math.h>\n#define NX 102400\n\nint  main(void){\n  double  vecA[NX],vecB[NX],vecC[NX];\n\n  /* Initialize vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n\n  #pragma omp target teams distribute parallel for simd\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(nx)  ::  vecA,vecB,vecC\n  integer  ::  i\n\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n  !$omp target teams distribute parallel do simd\n  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$omp end target teams distribute parallel do simd\nend program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n#define NX 102400\n\nint  main(void)  {\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n\n  /* Initialization of the vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n  #pragma acc parallel loop\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n} \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(:),  allocatable  ::  vecA,vecB,vecC\n  integer  ::  i\n\n  allocate  (vecA(nx),  vecB(nx),vecC(nx))\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n  !$acc parallel loop\n  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$acc end parallel loop\nend program vecsum \n```", "```\n#pragma omp target data [clauses]\n{structured-block} \n```", "```\n!$omp target data [clauses]\n  structured-block\n!$omp end target data \n```", "```\n#pragma acc data [clauses]\n  {structured-block} \n```", "```\n!$acc data [clauses]\n  structured-block\n!$acc end data \n```", "```\n#pragma omp target enter data [clauses] \n```", "```\n#pragma omp target exit data \n```", "```\n!$omp target enter data [clauses] \n```", "```\n!$omp target exit data \n```", "```\n#pragma acc enter data [clauses] \n```", "```\n#pragma acc exit data \n```", "```\n!$acc enter data [clauses] \n```", "```\n!$acc exit data \n```", "```\n#pragma omp target update [clauses] \n```", "```\nmotion-clause:\n  to  (list)\n  from  (list) \n```", "```\n!$omp target update [clauses] \n```", "```\nmotion-clause:\n  to  (list)\n  from  (list) \n```", "```\n#pragma acc update [clauses] \n```", "```\nmotion-clause:\n  self  (list)\n  device  (list) \n```", "```\n!$acc update [clauses] \n```", "```\nmotion-clause:\n  self  (list)\n  device  (list) \n```", "```\n#include  <stdio.h>\nint  main(void)\n{\nint  x  =  0;\n\n#pragma omp target data map(tofrom:x)\n{\n  /* check point 1 */\n  x  =  10;\n  /* check point 2 */\n#pragma omp target update to(x)\n  /* check point 3 */\n}\n\nreturn  0;\n} \n```", "```\nprogram ex_update\nimplicit none\n\ninteger  ::  x\n\nx  =  0\n!$acc data copy(x)\n! check point 1\nx  =  10\n! check point 2\n!$acc update device(x)\n! check point 3\n!$acc end data\n\nend program ex_update \n```", "```\n#include  <stdio.h>\n#include  <math.h>\n#define NX 102400\n\nint  main(void){\n  double  vecA[NX],vecB[NX],vecC[NX];\n\n  /* Initialize vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n  /* Adding mapping clauses here */\n  #pragma omp target teams distribute parallel for simd\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n} \n```", "```\nprogram vecsum\nimplicit none\n\ninteger,  parameter  ::  nx  =  102400\nreal,  dimension(nx)  ::  vecA,vecB,vecC\n  real  ::  sum\ninteger  ::  i\n\n! Initialization of vectors\ndo i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\nend do\n! Adding mapping clauses here\n!$omp target teams distribute parallel do simd\ndo i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\nenddo\n!$omp end target teams distribute parallel do simd\n\nsum  =  0.0\n! Calculate the sum\ndo i  =  1,  nx\n  sum  =  vecC(i)  +  sum\nend do\nwrite(*,'(A,F18.6)')  'The sum is: ',  sum\n\nend program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n#define NX 102400\n\nint  main(void)  {\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n\n  /* Initialization of the vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n  /* Adding mapping clauses here */\n  #pragma acc parallel loop\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(:),  allocatable  ::  vecA,vecB,vecC\n  real  ::  sum\n  integer  ::  i\n\n  allocate  (vecA(nx),  vecB(nx),vecC(nx))\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n  ! Adding mapping clauses here\n  !$acc parallel loop\n  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$acc end parallel loop\n\n  sum  =  0.0\n  ! Calculate the sum\n  do i  =  1,  nx\n  sum  =  vecC(i)  +  sum\n  end do\n write(*,'(A,F18.6)')  'The sum is: ',  sum\n\n  end program vecsum \n```", "```\n#include  <stdio.h>\n#include  <math.h>\n#define NX 102400\n\nint  main(void){\n  double  vecA[NX],vecB[NX],vecC[NX];\n\n  /* Initialize vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n\n #pragma omp target teams distribute parallel for simd map(to:vecA[0:NX],vecB[0:NX]) map(from:vecC[0:NX])  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(nx)  ::  vecA,vecB,vecC\n  real  ::  sum\n  integer  ::  i\n\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$omp target teams distribute parallel do simd map(to:vecA,vecB) map(from:vecC)  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$omp end target teams distribute parallel do simd\n\n  sum  =  0.0\n  ! Calculate the sum\n  do i  =  1,  nx\n  sum  =  vecC(i)  +  sum\n  end do\n write(*,'(A,F18.6)')  'The sum is: ',  sum\n\n  end program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n#define NX 102400\n\nint  main(void)  {\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n\n  /* Initialization of the vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n\n #pragma acc parallel loop copyin(vecA[0:NX],vecB[0:NX]) copyout(vecC[0:NX])  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(nx)  ::  vecA,vecB,vecC\n  real  ::  sum\n  integer  ::  i\n\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$acc parallel loop copyin(vecA,vecB) copyout(vecC)  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$acc end parallel loop\n\n  sum  =  0.0\n  ! Calculate the sum\n  do i  =  1,  nx\n  sum  =  vecC(i)  +  sum\n  end do\n write(*,'(A,F18.6)')  'The sum is: ',  sum\n\n  end program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n\n#define NX 102400\n\nint  main(void)\n{\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n  int  i;\n\n  /* Initialization of the vectors */\n  for  (i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  2.0;\n  }\n\n #pragma acc kernels  for  (i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n\n  return  0;\n} \n```", "```\nprogram main\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  integer  ::  i\n\n  double precision  ::  vecA(nx),  vecB(nx),  vecC(nx)\n\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$acc kernels  do i  =  1,  nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  end do\n !$acc end kernels \nend program \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n\n#define NX 102400\n\nint  main(void)\n{\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n  int  i;\n\n  /* Initialization of the vectors */\n  for  (i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  2.0;\n  }\n\n #pragma acc parallel loop  for  (i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n\n  return  0;\n} \n```", "```\nprogram main\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  integer  ::  i\n\n  double precision  ::  vecA(nx),  vecB(nx),  vecC(nx)\n\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$acc parallel loop  do i  =  1,  nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  end do\n !$acc end parallel loop \nend program \n```", "```\n#include  <stdio.h>\n\n#define NX 102400\n\nint  main(void)\n{\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n  int  i;\n\n  /* Initialization of the vectors */\n  for  (i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  2.0;\n  }\n\n #pragma omp target  for  (i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n\n  return  0;\n} \n```", "```\nprogram main\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  integer  ::  i\n\n  double precision  ::  vecA(nx),  vecB(nx),  vecC(nx)\n\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$omp target  do i  =  1,  nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  end do\n !$omp end target \nend program \n```", "```\nsalloc  -A  project_465002387  -N  1  -t  1:00:00  -p  standard-g  --gpus-per-node=1\n\nmodule  load  LUMI/24.03\nmodule  load  partition/G\nmodule  load  rocm/6.0.3\n\n# OpenMP\ncc  -O2  -fopenmp  -o  ex1  ex1.c\n# Only OpenACC Fortran is supported by HPE compiler.\n\nexport  CRAY_ACC_DEBUG=2\nsrun  ./ex1 \n```", "```\nsalloc  -A  project_465002387  -N  1  -t  1:00:00  -p  standard-g  --gpus-per-node=1\n\nmodule  load  LUMI/24.03\nmodule  load  partition/G\nmodule  load  rocm/6.0.3\n\nexport  CRAY_ACC_DEBUG=2\n# OpenMP\nftn  -O2  -homp  -o  ex1  ex1.f90\nsrun  ./ex1\n\n# OpenACC\nftn  -O2  -hacc  -o  ex1  ex1.f90\nsrun  ./ex1 \n```", "```\n#include  <stdio.h>\n#include  <math.h>\n#define NX 102400\n\nint  main(void){\n  double  vecA[NX],vecB[NX],vecC[NX];\n\n  /* Initialize vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n\n  #pragma omp target teams distribute parallel for simd\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(nx)  ::  vecA,vecB,vecC\n  integer  ::  i\n\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n  !$omp target teams distribute parallel do simd\n  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$omp end target teams distribute parallel do simd\nend program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n#define NX 102400\n\nint  main(void)  {\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n\n  /* Initialization of the vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n  #pragma acc parallel loop\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n} \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(:),  allocatable  ::  vecA,vecB,vecC\n  integer  ::  i\n\n  allocate  (vecA(nx),  vecB(nx),vecC(nx))\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n  !$acc parallel loop\n  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$acc end parallel loop\nend program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n\n#define NX 102400\n\nint  main(void)\n{\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n  int  i;\n\n  /* Initialization of the vectors */\n  for  (i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  2.0;\n  }\n\n #pragma acc kernels  for  (i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n\n  return  0;\n} \n```", "```\nprogram main\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  integer  ::  i\n\n  double precision  ::  vecA(nx),  vecB(nx),  vecC(nx)\n\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$acc kernels  do i  =  1,  nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  end do\n !$acc end kernels \nend program \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n\n#define NX 102400\n\nint  main(void)\n{\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n  int  i;\n\n  /* Initialization of the vectors */\n  for  (i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  2.0;\n  }\n\n #pragma acc parallel loop  for  (i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n\n  return  0;\n} \n```", "```\nprogram main\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  integer  ::  i\n\n  double precision  ::  vecA(nx),  vecB(nx),  vecC(nx)\n\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$acc parallel loop  do i  =  1,  nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  end do\n !$acc end parallel loop \nend program \n```", "```\n#include  <stdio.h>\n\n#define NX 102400\n\nint  main(void)\n{\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n  int  i;\n\n  /* Initialization of the vectors */\n  for  (i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  2.0;\n  }\n\n #pragma omp target  for  (i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n\n  return  0;\n} \n```", "```\nprogram main\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  integer  ::  i\n\n  double precision  ::  vecA(nx),  vecB(nx),  vecC(nx)\n\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$omp target  do i  =  1,  nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  end do\n !$omp end target \nend program \n```", "```\nsalloc  -A  project_465002387  -N  1  -t  1:00:00  -p  standard-g  --gpus-per-node=1\n\nmodule  load  LUMI/24.03\nmodule  load  partition/G\nmodule  load  rocm/6.0.3\n\n# OpenMP\ncc  -O2  -fopenmp  -o  ex1  ex1.c\n# Only OpenACC Fortran is supported by HPE compiler.\n\nexport  CRAY_ACC_DEBUG=2\nsrun  ./ex1 \n```", "```\nsalloc  -A  project_465002387  -N  1  -t  1:00:00  -p  standard-g  --gpus-per-node=1\n\nmodule  load  LUMI/24.03\nmodule  load  partition/G\nmodule  load  rocm/6.0.3\n\nexport  CRAY_ACC_DEBUG=2\n# OpenMP\nftn  -O2  -homp  -o  ex1  ex1.f90\nsrun  ./ex1\n\n# OpenACC\nftn  -O2  -hacc  -o  ex1  ex1.f90\nsrun  ./ex1 \n```", "```\n#include  <stdio.h>\n#include  <math.h>\n#define NX 102400\n\nint  main(void){\n  double  vecA[NX],vecB[NX],vecC[NX];\n\n  /* Initialize vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n\n  #pragma omp target teams distribute parallel for simd\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(nx)  ::  vecA,vecB,vecC\n  integer  ::  i\n\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n  !$omp target teams distribute parallel do simd\n  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$omp end target teams distribute parallel do simd\nend program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n#define NX 102400\n\nint  main(void)  {\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n\n  /* Initialization of the vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n  #pragma acc parallel loop\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n} \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(:),  allocatable  ::  vecA,vecB,vecC\n  integer  ::  i\n\n  allocate  (vecA(nx),  vecB(nx),vecC(nx))\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n  !$acc parallel loop\n  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$acc end parallel loop\nend program vecsum \n```", "```\n#pragma omp target data [clauses]\n{structured-block} \n```", "```\n!$omp target data [clauses]\n  structured-block\n!$omp end target data \n```", "```\n#pragma acc data [clauses]\n  {structured-block} \n```", "```\n!$acc data [clauses]\n  structured-block\n!$acc end data \n```", "```\n#pragma omp target enter data [clauses] \n```", "```\n#pragma omp target exit data \n```", "```\n!$omp target enter data [clauses] \n```", "```\n!$omp target exit data \n```", "```\n#pragma acc enter data [clauses] \n```", "```\n#pragma acc exit data \n```", "```\n!$acc enter data [clauses] \n```", "```\n!$acc exit data \n```", "```\n#pragma omp target update [clauses] \n```", "```\nmotion-clause:\n  to  (list)\n  from  (list) \n```", "```\n!$omp target update [clauses] \n```", "```\nmotion-clause:\n  to  (list)\n  from  (list) \n```", "```\n#pragma acc update [clauses] \n```", "```\nmotion-clause:\n  self  (list)\n  device  (list) \n```", "```\n!$acc update [clauses] \n```", "```\nmotion-clause:\n  self  (list)\n  device  (list) \n```", "```\n#include  <stdio.h>\nint  main(void)\n{\nint  x  =  0;\n\n#pragma omp target data map(tofrom:x)\n{\n  /* check point 1 */\n  x  =  10;\n  /* check point 2 */\n#pragma omp target update to(x)\n  /* check point 3 */\n}\n\nreturn  0;\n} \n```", "```\nprogram ex_update\nimplicit none\n\ninteger  ::  x\n\nx  =  0\n!$acc data copy(x)\n! check point 1\nx  =  10\n! check point 2\n!$acc update device(x)\n! check point 3\n!$acc end data\n\nend program ex_update \n```", "```\n#include  <stdio.h>\n#include  <math.h>\n#define NX 102400\n\nint  main(void){\n  double  vecA[NX],vecB[NX],vecC[NX];\n\n  /* Initialize vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n  /* Adding mapping clauses here */\n  #pragma omp target teams distribute parallel for simd\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n} \n```", "```\nprogram vecsum\nimplicit none\n\ninteger,  parameter  ::  nx  =  102400\nreal,  dimension(nx)  ::  vecA,vecB,vecC\n  real  ::  sum\ninteger  ::  i\n\n! Initialization of vectors\ndo i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\nend do\n! Adding mapping clauses here\n!$omp target teams distribute parallel do simd\ndo i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\nenddo\n!$omp end target teams distribute parallel do simd\n\nsum  =  0.0\n! Calculate the sum\ndo i  =  1,  nx\n  sum  =  vecC(i)  +  sum\nend do\nwrite(*,'(A,F18.6)')  'The sum is: ',  sum\n\nend program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n#define NX 102400\n\nint  main(void)  {\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n\n  /* Initialization of the vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n  /* Adding mapping clauses here */\n  #pragma acc parallel loop\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(:),  allocatable  ::  vecA,vecB,vecC\n  real  ::  sum\n  integer  ::  i\n\n  allocate  (vecA(nx),  vecB(nx),vecC(nx))\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n  ! Adding mapping clauses here\n  !$acc parallel loop\n  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$acc end parallel loop\n\n  sum  =  0.0\n  ! Calculate the sum\n  do i  =  1,  nx\n  sum  =  vecC(i)  +  sum\n  end do\n write(*,'(A,F18.6)')  'The sum is: ',  sum\n\n  end program vecsum \n```", "```\n#include  <stdio.h>\n#include  <math.h>\n#define NX 102400\n\nint  main(void){\n  double  vecA[NX],vecB[NX],vecC[NX];\n\n  /* Initialize vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n\n #pragma omp target teams distribute parallel for simd map(to:vecA[0:NX],vecB[0:NX]) map(from:vecC[0:NX])  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(nx)  ::  vecA,vecB,vecC\n  real  ::  sum\n  integer  ::  i\n\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$omp target teams distribute parallel do simd map(to:vecA,vecB) map(from:vecC)  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$omp end target teams distribute parallel do simd\n\n  sum  =  0.0\n  ! Calculate the sum\n  do i  =  1,  nx\n  sum  =  vecC(i)  +  sum\n  end do\n write(*,'(A,F18.6)')  'The sum is: ',  sum\n\n  end program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n#define NX 102400\n\nint  main(void)  {\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n\n  /* Initialization of the vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n\n #pragma acc parallel loop copyin(vecA[0:NX],vecB[0:NX]) copyout(vecC[0:NX])  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(nx)  ::  vecA,vecB,vecC\n  real  ::  sum\n  integer  ::  i\n\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$acc parallel loop copyin(vecA,vecB) copyout(vecC)  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$acc end parallel loop\n\n  sum  =  0.0\n  ! Calculate the sum\n  do i  =  1,  nx\n  sum  =  vecC(i)  +  sum\n  end do\n write(*,'(A,F18.6)')  'The sum is: ',  sum\n\n  end program vecsum \n```", "```\n#pragma omp target data [clauses]\n{structured-block} \n```", "```\n!$omp target data [clauses]\n  structured-block\n!$omp end target data \n```", "```\n#pragma acc data [clauses]\n  {structured-block} \n```", "```\n!$acc data [clauses]\n  structured-block\n!$acc end data \n```", "```\n#pragma omp target enter data [clauses] \n```", "```\n#pragma omp target exit data \n```", "```\n!$omp target enter data [clauses] \n```", "```\n!$omp target exit data \n```", "```\n#pragma acc enter data [clauses] \n```", "```\n#pragma acc exit data \n```", "```\n!$acc enter data [clauses] \n```", "```\n!$acc exit data \n```", "```\n#pragma omp target update [clauses] \n```", "```\nmotion-clause:\n  to  (list)\n  from  (list) \n```", "```\n!$omp target update [clauses] \n```", "```\nmotion-clause:\n  to  (list)\n  from  (list) \n```", "```\n#pragma acc update [clauses] \n```", "```\nmotion-clause:\n  self  (list)\n  device  (list) \n```", "```\n!$acc update [clauses] \n```", "```\nmotion-clause:\n  self  (list)\n  device  (list) \n```", "```\n#include  <stdio.h>\nint  main(void)\n{\nint  x  =  0;\n\n#pragma omp target data map(tofrom:x)\n{\n  /* check point 1 */\n  x  =  10;\n  /* check point 2 */\n#pragma omp target update to(x)\n  /* check point 3 */\n}\n\nreturn  0;\n} \n```", "```\nprogram ex_update\nimplicit none\n\ninteger  ::  x\n\nx  =  0\n!$acc data copy(x)\n! check point 1\nx  =  10\n! check point 2\n!$acc update device(x)\n! check point 3\n!$acc end data\n\nend program ex_update \n```", "```\n#include  <stdio.h>\n#include  <math.h>\n#define NX 102400\n\nint  main(void){\n  double  vecA[NX],vecB[NX],vecC[NX];\n\n  /* Initialize vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n  /* Adding mapping clauses here */\n  #pragma omp target teams distribute parallel for simd\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n} \n```", "```\nprogram vecsum\nimplicit none\n\ninteger,  parameter  ::  nx  =  102400\nreal,  dimension(nx)  ::  vecA,vecB,vecC\n  real  ::  sum\ninteger  ::  i\n\n! Initialization of vectors\ndo i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\nend do\n! Adding mapping clauses here\n!$omp target teams distribute parallel do simd\ndo i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\nenddo\n!$omp end target teams distribute parallel do simd\n\nsum  =  0.0\n! Calculate the sum\ndo i  =  1,  nx\n  sum  =  vecC(i)  +  sum\nend do\nwrite(*,'(A,F18.6)')  'The sum is: ',  sum\n\nend program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n#define NX 102400\n\nint  main(void)  {\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n\n  /* Initialization of the vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n  /* Adding mapping clauses here */\n  #pragma acc parallel loop\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(:),  allocatable  ::  vecA,vecB,vecC\n  real  ::  sum\n  integer  ::  i\n\n  allocate  (vecA(nx),  vecB(nx),vecC(nx))\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n  ! Adding mapping clauses here\n  !$acc parallel loop\n  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$acc end parallel loop\n\n  sum  =  0.0\n  ! Calculate the sum\n  do i  =  1,  nx\n  sum  =  vecC(i)  +  sum\n  end do\n write(*,'(A,F18.6)')  'The sum is: ',  sum\n\n  end program vecsum \n```", "```\n#include  <stdio.h>\n#include  <math.h>\n#define NX 102400\n\nint  main(void){\n  double  vecA[NX],vecB[NX],vecC[NX];\n\n  /* Initialize vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n\n #pragma omp target teams distribute parallel for simd map(to:vecA[0:NX],vecB[0:NX]) map(from:vecC[0:NX])  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(nx)  ::  vecA,vecB,vecC\n  real  ::  sum\n  integer  ::  i\n\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$omp target teams distribute parallel do simd map(to:vecA,vecB) map(from:vecC)  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$omp end target teams distribute parallel do simd\n\n  sum  =  0.0\n  ! Calculate the sum\n  do i  =  1,  nx\n  sum  =  vecC(i)  +  sum\n  end do\n write(*,'(A,F18.6)')  'The sum is: ',  sum\n\n  end program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n#define NX 102400\n\nint  main(void)  {\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n\n  /* Initialization of the vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n\n #pragma acc parallel loop copyin(vecA[0:NX],vecB[0:NX]) copyout(vecC[0:NX])  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(nx)  ::  vecA,vecB,vecC\n  real  ::  sum\n  integer  ::  i\n\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$acc parallel loop copyin(vecA,vecB) copyout(vecC)  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$acc end parallel loop\n\n  sum  =  0.0\n  ! Calculate the sum\n  do i  =  1,  nx\n  sum  =  vecC(i)  +  sum\n  end do\n write(*,'(A,F18.6)')  'The sum is: ',  sum\n\n  end program vecsum \n```", "```\n#pragma omp target data [clauses]\n{structured-block} \n```", "```\n!$omp target data [clauses]\n  structured-block\n!$omp end target data \n```", "```\n#pragma acc data [clauses]\n  {structured-block} \n```", "```\n!$acc data [clauses]\n  structured-block\n!$acc end data \n```", "```\n#pragma omp target enter data [clauses] \n```", "```\n#pragma omp target exit data \n```", "```\n!$omp target enter data [clauses] \n```", "```\n!$omp target exit data \n```", "```\n#pragma acc enter data [clauses] \n```", "```\n#pragma acc exit data \n```", "```\n!$acc enter data [clauses] \n```", "```\n!$acc exit data \n```", "```\n#pragma omp target update [clauses] \n```", "```\nmotion-clause:\n  to  (list)\n  from  (list) \n```", "```\n!$omp target update [clauses] \n```", "```\nmotion-clause:\n  to  (list)\n  from  (list) \n```", "```\n#pragma acc update [clauses] \n```", "```\nmotion-clause:\n  self  (list)\n  device  (list) \n```", "```\n!$acc update [clauses] \n```", "```\nmotion-clause:\n  self  (list)\n  device  (list) \n```", "```\n#include  <stdio.h>\nint  main(void)\n{\nint  x  =  0;\n\n#pragma omp target data map(tofrom:x)\n{\n  /* check point 1 */\n  x  =  10;\n  /* check point 2 */\n#pragma omp target update to(x)\n  /* check point 3 */\n}\n\nreturn  0;\n} \n```", "```\nprogram ex_update\nimplicit none\n\ninteger  ::  x\n\nx  =  0\n!$acc data copy(x)\n! check point 1\nx  =  10\n! check point 2\n!$acc update device(x)\n! check point 3\n!$acc end data\n\nend program ex_update \n```", "```\n#include  <stdio.h>\n#include  <math.h>\n#define NX 102400\n\nint  main(void){\n  double  vecA[NX],vecB[NX],vecC[NX];\n\n  /* Initialize vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n  /* Adding mapping clauses here */\n  #pragma omp target teams distribute parallel for simd\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n} \n```", "```\nprogram vecsum\nimplicit none\n\ninteger,  parameter  ::  nx  =  102400\nreal,  dimension(nx)  ::  vecA,vecB,vecC\n  real  ::  sum\ninteger  ::  i\n\n! Initialization of vectors\ndo i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\nend do\n! Adding mapping clauses here\n!$omp target teams distribute parallel do simd\ndo i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\nenddo\n!$omp end target teams distribute parallel do simd\n\nsum  =  0.0\n! Calculate the sum\ndo i  =  1,  nx\n  sum  =  vecC(i)  +  sum\nend do\nwrite(*,'(A,F18.6)')  'The sum is: ',  sum\n\nend program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n#define NX 102400\n\nint  main(void)  {\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n\n  /* Initialization of the vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n  /* Adding mapping clauses here */\n  #pragma acc parallel loop\n  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(:),  allocatable  ::  vecA,vecB,vecC\n  real  ::  sum\n  integer  ::  i\n\n  allocate  (vecA(nx),  vecB(nx),vecC(nx))\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n  ! Adding mapping clauses here\n  !$acc parallel loop\n  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$acc end parallel loop\n\n  sum  =  0.0\n  ! Calculate the sum\n  do i  =  1,  nx\n  sum  =  vecC(i)  +  sum\n  end do\n write(*,'(A,F18.6)')  'The sum is: ',  sum\n\n  end program vecsum \n```", "```\n#include  <stdio.h>\n#include  <math.h>\n#define NX 102400\n\nint  main(void){\n  double  vecA[NX],vecB[NX],vecC[NX];\n\n  /* Initialize vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n\n #pragma omp target teams distribute parallel for simd map(to:vecA[0:NX],vecB[0:NX]) map(from:vecC[0:NX])  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(nx)  ::  vecA,vecB,vecC\n  real  ::  sum\n  integer  ::  i\n\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$omp target teams distribute parallel do simd map(to:vecA,vecB) map(from:vecC)  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$omp end target teams distribute parallel do simd\n\n  sum  =  0.0\n  ! Calculate the sum\n  do i  =  1,  nx\n  sum  =  vecC(i)  +  sum\n  end do\n write(*,'(A,F18.6)')  'The sum is: ',  sum\n\n  end program vecsum \n```", "```\n#include  <stdio.h>\n#include  <openacc.h>\n#define NX 102400\n\nint  main(void)  {\n  double  vecA[NX],  vecB[NX],  vecC[NX];\n\n  /* Initialization of the vectors */\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecA[i]  =  1.0;\n  vecB[i]  =  1.0;\n  }\n\n #pragma acc parallel loop copyin(vecA[0:NX],vecB[0:NX]) copyout(vecC[0:NX])  {\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  vecC[i]  =  vecA[i]  +  vecB[i];\n  }\n  }\n\n  double  sum  =  0.0;\n  for  (int  i  =  0;  i  <  NX;  i++)  {\n  sum  +=  vecC[i];\n  }\n  printf(\"The sum is: %8.6f \\n\",  sum);\n  } \n```", "```\nprogram vecsum\n  implicit none\n\n  integer,  parameter  ::  nx  =  102400\n  real,  dimension(nx)  ::  vecA,vecB,vecC\n  real  ::  sum\n  integer  ::  i\n\n  ! Initialization of vectors\n  do i  =  1,  nx\n  vecA(i)  =  1.0\n  vecB(i)  =  1.0\n  end do\n\n !$acc parallel loop copyin(vecA,vecB) copyout(vecC)  do i=1,nx\n  vecC(i)  =  vecA(i)  +  vecB(i)\n  enddo\n  !$acc end parallel loop\n\n  sum  =  0.0\n  ! Calculate the sum\n  do i  =  1,  nx\n  sum  =  vecC(i)  +  sum\n  end do\n write(*,'(A,F18.6)')  'The sum is: ',  sum\n\n  end program vecsum \n```"]