<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>5.5. Application: graph partitioning via spectral clustering#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>5.5. Application: graph partitioning via spectral clustering#</h1>
<blockquote>原文：<a href="https://mmids-textbook.github.io/chap05_specgraph/05_partitioning/roch-mmids-specgraph-partitioning.html">https://mmids-textbook.github.io/chap05_specgraph/05_partitioning/roch-mmids-specgraph-partitioning.html</a></blockquote>

<p>In this section, we use the spectral properties of the Laplacian of a graph to identify “good” cuts.</p>
<section id="how-to-cut-a-graph">
<h2><span class="section-number">5.5.1. </span>How to cut a graph<a class="headerlink" href="#how-to-cut-a-graph" title="Link to this heading">#</a></h2>
<p>Let <span class="math notranslate nohighlight">\(G=(V, E)\)</span> be a graph. Imagine that we are interested in finding a good cut. That is, roughly speaking, we seek to divide it into two disjoint subsets of vertices to achieve two goals simultaneously:</p>
<ol class="arabic simple">
<li><p>the two sets have relatively few edges between them</p></li>
<li><p>neither set is too small.</p></li>
</ol>
<p>We will show that the Laplacian eigenvectors provide useful information in order to perform this kind of graph cutting. First we formulate the problem formally.</p>
<p><strong>Cut ratio</strong> One way to make the graph cutting more precise is to consider the following combinatorial quantity.</p>
<p><strong>DEFINITION</strong> <strong>(Isoperimetric Number)</strong> <span class="math notranslate nohighlight">\(\idx{isoperimetric number}\xdi\)</span> Let <span class="math notranslate nohighlight">\(G=(V, E)\)</span> be a graph. A cut<span class="math notranslate nohighlight">\(\idx{cut}\xdi\)</span> is a bipartition <span class="math notranslate nohighlight">\((S, S^c)\)</span> of the vertices of <span class="math notranslate nohighlight">\(G\)</span>, where <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(S^c = V\setminus S\)</span> are non-empty subsets of <span class="math notranslate nohighlight">\(V\)</span>. The corresponding cutset is the set of edges between <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(S^c\)</span></p>
<div class="math notranslate nohighlight">
\[
E(S,S^c)
=
\{
\{i,j\} \in E : i \in S, j \in S^c 
\}.
\]</div>
<p>This is also known as the edge boundary of <span class="math notranslate nohighlight">\(S\)</span> (denoted <span class="math notranslate nohighlight">\(\partial S\)</span>). The size of the cutset<span class="math notranslate nohighlight">\(\idx{cutset}\xdi\)</span> is then <span class="math notranslate nohighlight">\(|E(S,S^c)|\)</span>, the number of edges between <span class="math notranslate nohighlight">\(S\)</span> to <span class="math notranslate nohighlight">\(S^c\)</span>. The cut ratio<span class="math notranslate nohighlight">\(\idx{cut ratio}\xdi\)</span> of <span class="math notranslate nohighlight">\((S,S^c)\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[
\phi(S) 
= 
\frac{|E(S,S^c)|}{\min\{|S|, |S^c|\}}
\]</div>
<p>and the isoperimetric number (or <a class="reference external" href="https://en.wikipedia.org/wiki/Spectral_graph_theory#Cheeger_constant">Cheeger constant</a>)<span class="math notranslate nohighlight">\(\idx{Cheeger constant}\xdi\)</span> of <span class="math notranslate nohighlight">\(G\)</span> is the smallest value this quantity can take on <span class="math notranslate nohighlight">\(G\)</span>, that is,</p>
<div class="math notranslate nohighlight">
\[
\phi_G
= 
\min_{\emptyset \neq S \subset V} \phi(S).
\]</div>
<p><span class="math notranslate nohighlight">\(\natural\)</span></p>
<p>In words: the cut ratio is attempting to minimize the number of edges across a cut, while penalizing cuts with a small number of vertices on either side. These correspond to the goals above and we will use this criterion to assess the quality of graph cuts.</p>
<p><em>Why do we need the denominator?</em> If we were to minimize only the numerator <span class="math notranslate nohighlight">\(|E(S,S^c)|\)</span> over all cuts (without the deonominator in <span class="math notranslate nohighlight">\(\phi(S)\)</span>), we would get what is known as the <a class="reference external" href="https://en.wikipedia.org/wiki/Minimum_cut">minimum cut (or min-cut) problem</a>. That problem is easier to solve. In particular, it can be solved using a beautiful <a class="reference external" href="https://en.wikipedia.org/wiki/Karger%27s_algorithm">randomized algorithm</a>. However, it tends to produce unbalanced cuts, where one side is much smaller than the other. This is not what we want here.</p>
<p><strong>Figure:</strong> Bridges are a good example of a bottleneck (i.e., a good cut) in a transportation network. (<em>Credit:</em> Made with <a class="reference external" href="https://www.midjourney.com/">Midjourney</a>)</p>
<p><img alt="Bridges" src="../Images/cc1af6f4a7c4f2d7fde93d3160917989.png" data-original-src="https://mmids-textbook.github.io/_images/small-improbably555_street_map_of_montreal_island_and_south_shore._br_8d08831c-f53f-4967-8b37-74d9898a4840.png"/></p>
<p><span class="math notranslate nohighlight">\(\bowtie\)</span></p>
<p><strong>EXAMPLE:</strong> <strong>(A Random Tree)</strong> We illustrate the definitions above on a tree, that is, a connected graph with no cycle. The function <a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.generators.trees.random_labeled_tree.html"><code class="docutils literal notranslate"><span class="pre">networkx.random_labeled_tree</span></code></a> can produce a random one. As before we use a <code class="docutils literal notranslate"><span class="pre">seed</span></code> for reproducibility. Again, we use <span class="math notranslate nohighlight">\(0,\ldots,n-1\)</span> for the vertex set.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G_tree</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">random_labeled_tree</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">111</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G_tree</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">circular_layout</span><span class="p">(</span><span class="n">G_tree</span><span class="p">),</span> 
                 <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/2d38afa13c4b3f67959d61320268e3d2f6194a7ef1bd38797b0c53892bb7a732.png" src="../Images/bfa48d48a70dbd181dc398a4217fd612.png" data-original-src="https://mmids-textbook.github.io/_images/2d38afa13c4b3f67959d61320268e3d2f6194a7ef1bd38797b0c53892bb7a732.png"/>
</div>
</div>
<p>Suppose we take <span class="math notranslate nohighlight">\(S = \{0,1,2,3\}\)</span>. Then <span class="math notranslate nohighlight">\(S^c = \{4,5\}\)</span> and</p>
<div class="math notranslate nohighlight">
\[
E(S,S^c)
= \{\{1,5\}, \{2,4\}\}.
\]</div>
<p>The cut ratio is then</p>
<div class="math notranslate nohighlight">
\[
\phi(S)
= \frac{|E(S,S^c)|}{\min\{|S|,|S^c|\}}
= \frac{2}{2}
= 1.
\]</div>
<p>A better cut is given by <span class="math notranslate nohighlight">\(S = \{0,1,5\}\)</span>. In that case <span class="math notranslate nohighlight">\(S^c = \{2,3,4\}\)</span>,</p>
<div class="math notranslate nohighlight">
\[
E(S,S^c)= \{\{1,3\}\},
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\phi(S)
= \frac{|E(S,S^c)|}{\min\{|S|,|S^c|\}}
= \frac{1}{3}.
\]</div>
<p>This is also equal to <span class="math notranslate nohighlight">\(\phi_G\)</span>. Indeed, in a connected graph with <span class="math notranslate nohighlight">\(n\)</span> vertices, the numerator is at least <span class="math notranslate nohighlight">\(1\)</span> and the denominator is at most <span class="math notranslate nohighlight">\(n/2\)</span>, which is achieved here.</p>
<p><span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p><strong>Cheeger’s inequalities</strong> A key result of spectral graph theory establishes a quantitative relation between the isoperimetric number and the second smallest Laplacian eigenvalue.</p>
<p><strong>THEOREM</strong> <strong>(Cheeger)</strong> <span class="math notranslate nohighlight">\(\idx{Cheeger's inequality}\xdi\)</span> Let <span class="math notranslate nohighlight">\(G = (V, E)\)</span> be a graph with <span class="math notranslate nohighlight">\(n = |V|\)</span> vertices and maximum degree <span class="math notranslate nohighlight">\(\bar{\delta}\)</span>. Let <span class="math notranslate nohighlight">\(0 = \mu_1 \leq \mu_2 \leq \cdots \leq \mu_n\)</span> be its Laplacian eigenvalues. Then</p>
<div class="math notranslate nohighlight">
\[
\frac{\phi_G^2}{2 \bar{\delta}} \leq \mu_2 \leq 2 \phi_G.
\]</div>
<p><span class="math notranslate nohighlight">\(\sharp\)</span></p>
<p>We only prove the easy direction, <span class="math notranslate nohighlight">\(\mu_2 \leq 2 \phi_G\)</span>, which shows explicitly how the connection between <span class="math notranslate nohighlight">\(\mu_2\)</span> and <span class="math notranslate nohighlight">\(\phi_G\)</span> comes about.</p>
<p><em>Proof idea:</em> To show that <span class="math notranslate nohighlight">\(\mu_2 \leq 2 \phi_G\)</span>, we find an appropriate test vector to plug into the extremal characterization of <span class="math notranslate nohighlight">\(\mu_2\)</span> and link it to <span class="math notranslate nohighlight">\(\phi_G\)</span>.</p>
<p><em>Proof:</em> Recall that, from the <em>Variational Characterization of <span class="math notranslate nohighlight">\(\mu_2\)</span></em>, we have</p>
<div class="math notranslate nohighlight">
\[
\mu_2 
= \min\left\{
\sum_{\{u, v\} \in E} (x_u - x_v)^2 \,:\,
\mathbf{x} = (x_1, \ldots, x_n) \in \mathbb{R}^n, 
\sum_{u=1}^n x_u = 0,
\sum_{u = 1}^n x_u^2 = 1
\right\}.
\]</div>
<p><em><strong>Constructing a good test vector:</strong></em> We construct an <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> that provides a good upper bound. Let <span class="math notranslate nohighlight">\(\emptyset \neq S \subset V\)</span> be a proper, nonempty subset of <span class="math notranslate nohighlight">\(V\)</span> such that <span class="math notranslate nohighlight">\(0 &lt; |S| \leq \frac{1}{2}|V|\)</span>. We choose a vector that takes one value on <span class="math notranslate nohighlight">\(S\)</span> and a different value on <span class="math notranslate nohighlight">\(S^c\)</span>. Taking a cue from the two-component example above we consider the vector with entries</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
x_i
=
\begin{cases}
\sqrt{\frac{|S^c|}{n |S|}} &amp; \text{if $i \in S$}\\
- \sqrt{\frac{|S|}{n |S^c|}} &amp; \text{if $i \in S^c$}.
\end{cases}
\end{align*}\]</div>
<p>This choice ensures that</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\sum_{i=1}^n x_i
&amp;= \sum_{i\in S} \sqrt{\frac{|S^c|}{n |S|}} + \sum_{i\in S^c} \left(- \sqrt{\frac{|S|}{n |S^c|}}\right)\\
&amp;= |S| \sqrt{\frac{|S^c|}{n |S|}} - |S^c| \sqrt{\frac{|S|}{n |S^c|}}\\
&amp;= \sqrt{\frac{|S| |S^c|}{n}} - \sqrt{\frac{|S||S^c| }{n}}\\
&amp;= 0,
\end{align*}\]</div>
<p>as well</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\sum_{i=1}^n x_i^2
&amp;= \sum_{i\in S} \left(\sqrt{\frac{|S^c|}{n |S|}}\right)^2  + \sum_{i\in S^c} \left(- \sqrt{\frac{|S|}{n |S^c|}}\right)^2\\
&amp;= |S| \frac{|S^c|}{n |S|} + |S^c| \frac{|S|}{n |S^c|}\\
&amp;= \frac{|S^c| + |S|}{n}\\
&amp;=1.
\end{align*}\]</div>
<p>To evaluate the Laplacian quadratic form, we note that <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> takes the same value everywhere on <span class="math notranslate nohighlight">\(S\)</span> (and on <span class="math notranslate nohighlight">\(S^c\)</span>). Hence the sum over edges reduces to</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\sum_{\{i, j\} \in E} (x_i - x_j)^2
&amp;= \sum_{\substack{\{i, j\} \in E \\ x_i\neq x_j}} \left(\sqrt{\frac{|S^c|}{n |S|}} 
+ \sqrt{\frac{|S|}{n |S^c|}}\right)^2\\
&amp;= \sum_{\substack{\{i, j\} \in E \\ x_i\neq x_j}} \left(\frac{|S^c| + |S|}{\sqrt{n |S| |S^c|}}\right)^2\\
&amp;= |E(S,S^c)|\frac{n}{|S| |S^c|},
\end{align*}\]</div>
<p>where we used that, for each edge <span class="math notranslate nohighlight">\(\{i, j\} \in E\)</span> where <span class="math notranslate nohighlight">\(x_i \neq x_j\)</span>, one endvertex is in <span class="math notranslate nohighlight">\(S\)</span> and one endvertex is in <span class="math notranslate nohighlight">\(S^c\)</span>.</p>
<p><em><strong>Using the definition of the isoperimetric number:</strong></em> So for this choice of <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> we have</p>
<div class="math notranslate nohighlight">
\[
\mu_2 \leq \sum_{\{i, j\} \in E} (x_i - x_j)^2
= \frac{n |E(S,S^c)|}{|S^c| |S|}
= \frac{|E(S,S^c)|}{(|S^c|/n) |S|}
\leq 2 \frac{|E(S,S^c)|}{|S|}
\]</div>
<p>where we used that <span class="math notranslate nohighlight">\(|S^c| \geq n/2\)</span>. This inequality holds for any <span class="math notranslate nohighlight">\(S\)</span> such that <span class="math notranslate nohighlight">\(0 &lt; |S| \leq \frac{1}{2}|V|\)</span>. In particular, it holds for the <span class="math notranslate nohighlight">\(S\)</span> producing the smallest value. Hence, by the definition of the isoperimetric number, we get</p>
<div class="math notranslate nohighlight">
\[
\mu_2 \leq 2 \phi_G
\]</div>
<p>as claimed. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p><strong>NUMERICAL CORNER:</strong> We return to the random tree example above. We claimed that <span class="math notranslate nohighlight">\(\phi_G = 1/3\)</span>. The maximum degree is <span class="math notranslate nohighlight">\(\bar{\delta} = 3\)</span>. We now compute <span class="math notranslate nohighlight">\(\mu_2\)</span>. We first compute the Laplacian matrix.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">phi_G</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
<span class="n">max_deg</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>
</div>
</div>
</div>
<p>We now compute <span class="math notranslate nohighlight">\(\mu_2\)</span>. We first compute the Laplacian matrix.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">L_tree</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">laplacian_matrix</span><span class="p">(</span><span class="n">G_tree</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">L_tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[[ 1 -1  0  0  0  0]
 [-1  3  0 -1  0 -1]
 [ 0  0  2 -1 -1  0]
 [ 0 -1 -1  2  0  0]
 [ 0  0 -1  0  1  0]
 [ 0 -1  0  0  0  1]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">L_tree</span><span class="p">)</span> 
<span class="n">mu_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">w</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mu_2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>0.32486912943335317
</pre></div>
</div>
</div>
</div>
<p>We check <em>Cheeger’s inequalities</em>. The left-hand side is:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="p">(</span><span class="n">phi_G</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">max_deg</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>0.018518518518518517
</pre></div>
</div>
</div>
</div>
<p>The right-hand side is:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="mi">2</span> <span class="o">*</span> <span class="n">phi_G</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>0.6666666666666666
</pre></div>
</div>
</div>
</div>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
<p><strong>A graph-cutting algorithm</strong> We only proved the easy direction of <em>Cheeger’s inequalities</em>. It is however useful to sketch the other direction (the actual <a class="reference external" href="https://en.wikipedia.org/wiki/Cheeger_constant#Cheeger's_inequality">Cheeger’s inequality</a> in the graph context), as it contains an important algorithmic idea.</p>
<p><em><strong>An algorithm:</strong></em> The input is the graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span>. Let <span class="math notranslate nohighlight">\(\mathbf{y}_2 \in \mathbb{R}^n\)</span> be the unit-norm eigenvector of the Laplacian matrix <span class="math notranslate nohighlight">\(L\)</span> associated to its second smallest eigenvalue <span class="math notranslate nohighlight">\(\mu_2\)</span>, i.e., <span class="math notranslate nohighlight">\(\mathbf{y}_2\)</span> is the Fiedler vector. There is one entry of <span class="math notranslate nohighlight">\(\mathbf{y}_2 = (y_{2,1}, \ldots, y_{2,n})\)</span> for each vertex of <span class="math notranslate nohighlight">\(G\)</span>. We use these entries to embed the graph <span class="math notranslate nohighlight">\(G\)</span> in <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>: vertex <span class="math notranslate nohighlight">\(i\)</span> is mapped to <span class="math notranslate nohighlight">\(y_{2,i}\)</span>. Now order the entries <span class="math notranslate nohighlight">\(y_{2,\pi(1)}, \ldots, y_{2,\pi(n)}\)</span>, where <span class="math notranslate nohighlight">\(\pi\)</span> is a <a class="reference external" href="https://en.wikipedia.org/wiki/Permutation">permutation</a><span class="math notranslate nohighlight">\(\idx{permutation}\xdi\)</span>, that is, a re-ordering of <span class="math notranslate nohighlight">\(1,\ldots,n\)</span>. Specifically, <span class="math notranslate nohighlight">\(\pi(1)\)</span> is the vertex corresponding to the smallest entry of <span class="math notranslate nohighlight">\(\mathbf{y}_{2}\)</span>, <span class="math notranslate nohighlight">\(\pi(2)\)</span> is the second smallest, and so on. We consider only cuts of the form</p>
<div class="math notranslate nohighlight">
\[
S_k = \{\pi(1), \ldots, \pi(k)\}
\]</div>
<p>and we output the cut <span class="math notranslate nohighlight">\((S_k, S_k^c)\)</span> that minimizes the cut ratio</p>
<div class="math notranslate nohighlight">
\[
\phi(S_k)
= \frac{|E(S_k,S_k^c)|}{\min\{k, n-k\}},
\]</div>
<p>for the <span class="math notranslate nohighlight">\(k \leq n-1\)</span>.</p>
<p>What can be proved rigorously (but we will not do this here) is that there exists some <span class="math notranslate nohighlight">\(k^* \in\{1,\ldots,n-1\}\)</span> such that</p>
<div class="math notranslate nohighlight">
\[
\mu_2 
= 
\sum_{\{u, v\} \in E} (y_{2,u} - y_{2,v})^2
\geq 
\frac{\phi(S_{k^*})^2}{2 \bar{\delta}}
\geq 
\frac{\phi_G^2}{2 \bar{\delta}},
\]</div>
<p>which implies the lower bound in <em>Cheeger’s inequalities</em>. The leftmost inequality is the non-trivial one.</p>
<p>Since <span class="math notranslate nohighlight">\(\mu_2 \leq 2 \phi_G\)</span>, this implies that</p>
<div class="math notranslate nohighlight">
\[
\phi(S_{k^*})
\leq \sqrt{4 \bar{\delta} \phi_G}.
\]</div>
<p>So <span class="math notranslate nohighlight">\(\phi(S_{k^*})\)</span> may not achieve <span class="math notranslate nohighlight">\(\phi_G\)</span>, but we do get some guarantee on the quality of the cut produced by this algorithm.</p>
<p>See, for example, [<a class="reference external" href="https://ocw.mit.edu/courses/mathematics/18-409-topics-in-theoretical-computer-science-an-algorithmists-toolkit-fall-2009/index.htm">Kel</a>, Lecture 3, Section 4.2] for more details.</p>
<p>The above provides a heuristic to find a cut with provable guarantees. We implement it next. In contrast, the problem of finding a cut which minimizes the cut ratio is known to be <a class="reference external" href="https://en.wikipedia.org/wiki/NP-hardness">NP-hard</a><span class="math notranslate nohighlight">\(\idx{NP-hardness}\xdi\)</span>, that is, roughly speaking it is computationally intractable.</p>
<p>We implement the graph cutting algorithm above.</p>
<p>We now implement this heuristic in Python. We first write an auxiliary function that takes as input an adjacency matrix, an ordering of the vertices and a value <span class="math notranslate nohighlight">\(k\)</span>. It returns the cut ratio for the first <span class="math notranslate nohighlight">\(k\)</span> vertices in the order.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">cut_ratio</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">edge_boundary</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
            <span class="n">edge_boundary</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">order</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            
    <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">edge_boundary</span><span class="o">/</span><span class="n">denominator</span>
</pre></div>
</div>
</div>
</div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">cut_ratio</span></code> function, we first compute the Laplacian, find the second eigenvector and corresponding order of vertices. Then we compute the cut ratio for every <span class="math notranslate nohighlight">\(k\)</span>. Finally we output the cut (both <span class="math notranslate nohighlight">\(S_k\)</span> and <span class="math notranslate nohighlight">\(S_k^c\)</span>) corresponding to the minimum, as a tuple of arrays.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">spectral_cut2</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">degrees</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">degrees</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">D</span> <span class="o">-</span> <span class="n">A</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> 
    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">w</span><span class="p">)[</span><span class="mi">1</span><span class="p">]])</span>
    
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">phi</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cut_ratio</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">imin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">order</span><span class="p">[</span><span class="n">imin</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, to help visualize the output, we write a function coloring the vertices according to which side of the cut they are on.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">viz_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
    <span class="n">assign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">assign</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">assign</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="n">with_labels</span><span class="p">,</span> 
            <span class="n">cmap</span><span class="o">=</span><span class="s1">'spring'</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="n">node_size</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'k'</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p><strong>NUMERICAL CORNER:</strong> We will illustrate this on the path graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">spectral_layout</span><span class="p">(</span><span class="n">G</span><span class="p">),</span> 
                 <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/4ebfff7c18330f27d88859052bc61ef4bf3023b05b644a97c42754c8bbfbdfcd.png" src="../Images/9060b16650e938e492286e8b623cd2cb.png" data-original-src="https://mmids-textbook.github.io/_images/4ebfff7c18330f27d88859052bc61ef4bf3023b05b644a97c42754c8bbfbdfcd.png"/>
</div>
</div>
<p>We apply our spectral-based cutting algorihtm.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="n">s</span><span class="p">,</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">spectral_cut2</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[0 1 2 3 4]
[5 6 7 8 9]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spectral_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">viz_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/2211d003904642e7dd7cb3c055a2d5959293cb510b165c444cc591a56f3c74c5.png" src="../Images/2f0dc8bc361ef1af11564249dcfd4461.png" data-original-src="https://mmids-textbook.github.io/_images/2211d003904642e7dd7cb3c055a2d5959293cb510b165c444cc591a56f3c74c5.png"/>
</div>
</div>
<p>Let’s try it on the grid graph. Can you guess what the cut will be?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">grid_2d_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="n">s</span><span class="p">,</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">spectral_cut2</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spectral_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">viz_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/8473946b131310e3fb5eb51083f06728f05af3d93a601c7f6f8dcd0880c61d00.png" src="../Images/6b069ea231b753d5f8e27e249ea1456e.png" data-original-src="https://mmids-textbook.github.io/_images/8473946b131310e3fb5eb51083f06728f05af3d93a601c7f6f8dcd0880c61d00.png"/>
</div>
</div>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
<p><strong>How to compute the second smallest eigenvalue?</strong> There is one last piece of business to take care of. How do we compute the Fiedler vector? Previously, we have seen an iterative approach based on taking powers of the matrix to compute <em>the largest eigenvalue and corresponding eigenvector</em> of a positive semidefinite matrix. We show here how to adapt this approach to our task at hand. The details are left as a series of exercises.</p>
<p>First, we modify the Laplacian matrix to invert the order of the eigenvalues without changing the eigenvectors themselves. This way the smallest eigenvalues will become the largest ones. By the <em>Laplacian and Maximum Degree Lemma</em>, <span class="math notranslate nohighlight">\(\mu_i \leq 2 \bar{\delta}\)</span> for all <span class="math notranslate nohighlight">\(i=1,\ldots,n\)</span>, where recall that <span class="math notranslate nohighlight">\(\bar{\delta}\)</span> is the largest degree of the graph.</p>
<p><strong>LEMMA</strong> <strong>(Inverting the Order of Eigenvalues)</strong> <span class="math notranslate nohighlight">\(\idx{inverting the order of eigenvalues lemma}\xdi\)</span> For <span class="math notranslate nohighlight">\(i=1,\ldots,n\)</span>, let <span class="math notranslate nohighlight">\(\lambda_i = 2 \bar{\delta} - \mu_i\)</span>. The matrix <span class="math notranslate nohighlight">\(M = 2 \bar{\delta} I_{n\times n} - L\)</span> is positive semidefinite and has eigenvector decomposition</p>
<div class="math notranslate nohighlight">
\[
M = \sum_{i=1}^{n} \lambda_i \mathbf{y}_i \mathbf{y}_i^T.
\]</div>
<p><span class="math notranslate nohighlight">\(\flat\)</span></p>
<p>Second, our goal is now to compute the second largest eigenvalue of <span class="math notranslate nohighlight">\(M\)</span> – not the largest one. But we already know the largest one. It is <span class="math notranslate nohighlight">\(\lambda_1 = 2\bar{\delta} - \mu_1 = 2 \bar{\delta}\)</span> and its associated eigenvector is <span class="math notranslate nohighlight">\(\mathbf{y}_1 = \frac{1}{\sqrt{n}}(1,\ldots,1)\)</span>. It turns out that we can simply apply power iteration with a starting vector that is orthogonal to <span class="math notranslate nohighlight">\(\mathbf{y}_1\)</span>. Such a vector can be constructed by taking a random vector and subtracting its orthogonal projection on <span class="math notranslate nohighlight">\(\mathbf{y}_1\)</span>.</p>
<p><strong>LEMMA</strong> <strong>(Power Iteration for the Second Largest Eigenvalue)</strong> Assume that <span class="math notranslate nohighlight">\(\mu_1 &lt; \mu_2 &lt; \mu_3\)</span>. Let <span class="math notranslate nohighlight">\(\mathbf{x} \in \mathbb{R}^n\)</span> be a vector such that <span class="math notranslate nohighlight">\(\langle \mathbf{y}_1, \mathbf{x} \rangle = 0\)</span> and <span class="math notranslate nohighlight">\(\langle \mathbf{y}_2, \mathbf{x} \rangle &gt; 0\)</span>. Then</p>
<div class="math notranslate nohighlight">
\[
\frac{M^{k} \mathbf{x}}{\|M^{k} \mathbf{x}\|} \to \mathbf{y}_2
\]</div>
<p>as <span class="math notranslate nohighlight">\(k \to +\infty\)</span>. If instead <span class="math notranslate nohighlight">\(\langle \mathbf{y}_2, \mathbf{x} \rangle &lt; 0\)</span>, then the limit is <span class="math notranslate nohighlight">\(- \mathbf{y}_2\)</span>. <span class="math notranslate nohighlight">\(\flat\)</span></p>
<p><strong>The relaxation perspective</strong> Here is another intuitive way to shed light on the effectiveness of spectral partitioning. Assume we have a graph <span class="math notranslate nohighlight">\(G = (V,E)\)</span> with an even number <span class="math notranslate nohighlight">\(n = |V|\)</span> of vertices. Suppose we are looking for the best balanced cut <span class="math notranslate nohighlight">\((S,S^c)\)</span> in the sense that it minimizes the number of edges <span class="math notranslate nohighlight">\(|E(S,S^c)|\)</span> across it over all cuts with <span class="math notranslate nohighlight">\(|S| = |S^c| = n/2\)</span>. This is known as the <a class="reference external" href="https://link.springer.com/referenceworkentry/10.1007/978-1-4939-2864-4_231">minimum bisection problem</a>.</p>
<p>Mathematically, we can formulate this as the followign discrete optimization problem:</p>
<div class="math notranslate nohighlight">
\[
\min\left\{\frac{1}{4} \sum_{\{i,j\} \in E} (x_i - x_j)^2\,:\, \mathbf{x} = (x_1,\ldots,x_n) \in \{-1,+1\}^n, \sum_{i=1}^n x_i = 0 \right\}.
\]</div>
<p>The condition <span class="math notranslate nohighlight">\(\mathbf{x} \in \{-1,+1\}^n\)</span> implicitly assigns each vertex <span class="math notranslate nohighlight">\(i\)</span> to <span class="math notranslate nohighlight">\(S\)</span> (if <span class="math notranslate nohighlight">\(x_i = -1\)</span>) or <span class="math notranslate nohighlight">\(S^c\)</span> (if <span class="math notranslate nohighlight">\(x_i=+1\)</span>). The condition <span class="math notranslate nohighlight">\(\sum_{i=1}^n x_i = 0\)</span> then ensures that the cut <span class="math notranslate nohighlight">\((S,S^c)\)</span> is balanced, that is, that <span class="math notranslate nohighlight">\(|S| = |S^c|\)</span>. Under this interpretation, the term <span class="math notranslate nohighlight">\((x_i - x_j)^2\)</span> is either <span class="math notranslate nohighlight">\(0\)</span> if <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> are on the same side of the cut, or <span class="math notranslate nohighlight">\(4\)</span> if they are on opposite sides.</p>
<p>This is a hard computational problem. One way to approach such a discrete optimization problem is to relax it. That is, to turn it into an optimization problem with continuous variables. Specifically here we consider instead</p>
<div class="math notranslate nohighlight">
\[
\min\left\{\frac{1}{4} \sum_{\{i,j\} \in E} (x_i - x_j)^2\,:\, \mathbf{x} = (x_1,\ldots,x_n) \in \mathbb{R}^n, \sum_{i=1}^n x_i = 0,  \sum_{i=1}^n x_i^2 = n\right\}.
\]</div>
<p>The optimal objective value of this relaxed problem is necessarily smaller or equal than the original one. Indeed any solution to the original problem satisfies the constraints of the relaxation. Up to a scaling factor, this last problem is equivalent to the variational characterization of <span class="math notranslate nohighlight">\(\mu_2\)</span>. Indeed, one can prove that the minimum achieved is <span class="math notranslate nohighlight">\(\frac{\mu_2 n}{4}\)</span> (Try it!).</p>
<p><strong>NUMERICAL CORNER:</strong> We return to the <a class="reference external" href="https://en.wikipedia.org/wiki/Zachary%27s_karate_club">Karate Club dataset</a>.</p>
<p><strong>Figure:</strong> Dojo (<em>Credit:</em> Made with <a class="reference external" href="https://www.midjourney.com/">Midjourney</a>)</p>
<p><img alt="Kids in a dojo" src="../Images/6b732b2a4c677bbb26d3e4d6e907880a.png" data-original-src="https://mmids-textbook.github.io/_images/kids_sitting_in_a_dojo-small.png"/></p>
<p><span class="math notranslate nohighlight">\(\bowtie\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">karate_club_graph</span><span class="p">()</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We seek to find natural sub-communities. We use the spectral properties of the Laplacian. Specifically, we use our <code class="docutils literal notranslate"><span class="pre">spectral_cut2</span></code> and <code class="docutils literal notranslate"><span class="pre">viz_cut</span></code> functions to compute a good cut and vizualize it.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">s</span><span class="p">,</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">spectral_cut2</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[18 26 20 14 29 22 24 15 23 25 32 27  9 33 31 28 30  8]
[ 2 13  1 19  7  3 12  0 21 17 11  4 10  6  5 16]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">viz_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/a0fae7b032318e0bf638db5fd30e11cead1d6304485bc0a49d38190321ba5a37.png" src="../Images/acf48fe63af2b9b2bb66e36917f2217f.png" data-original-src="https://mmids-textbook.github.io/_images/a0fae7b032318e0bf638db5fd30e11cead1d6304485bc0a49d38190321ba5a37.png"/>
</div>
</div>
<p>It is not trivial to assess the quality of the resulting cut. But this particular example has a known ground-truth community structure (which partly explains its widespread use). Quoting from <a class="reference external" href="https://en.wikipedia.org/wiki/Zachary%27s_karate_club">Wikipedia</a>:</p>
<blockquote>
<div><p>A social network of a karate club was studied by Wayne W. Zachary for a period of three years from 1970 to 1972. The network captures 34 members of a karate club, documenting links between pairs of members who interacted outside the club. During the study a conflict arose between the administrator “John A” and instructor “Mr. Hi” (pseudonyms), which led to the split of the club into two. Half of the members formed a new club around Mr. Hi; members from the other part found a new instructor or gave up karate. Based on collected data Zachary correctly assigned all but one member of the club to the groups they actually joined after the split.</p>
</div></blockquote>
<p>This ground truth is the following. We use <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.nonzero.html#numpy.nonzero"><code class="docutils literal notranslate"><span class="pre">numpy.nonzero</span></code></a> to convert it into a cut.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">truth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> 
                  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">s_truth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">truth</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">viz_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s_truth</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/a0fae7b032318e0bf638db5fd30e11cead1d6304485bc0a49d38190321ba5a37.png" src="../Images/acf48fe63af2b9b2bb66e36917f2217f.png" data-original-src="https://mmids-textbook.github.io/_images/a0fae7b032318e0bf638db5fd30e11cead1d6304485bc0a49d38190321ba5a37.png"/>
</div>
</div>
<p>You can check that our cut perfectly matches the ground truth.</p>
<p><strong>CHAT &amp; LEARN</strong> Investigate alternative graph partitioning algorithms, such as the Kernighan-Lin algorithm. Ask your favorite AI chatbot to explain how it works and compare its performance to spectral clustering on this dataset. (<a class="reference external" href="https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_specgraph_notebook.ipynb">Open In Colab</a>) <span class="math notranslate nohighlight">\(\ddagger\)</span></p>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
<p><em><strong>Self-assessment quiz</strong></em> <em>(with help from Claude, Gemini, and ChatGPT)</em></p>
<p><strong>1</strong> Which of the following best describes the ‘cut ratio’ of a graph cut <span class="math notranslate nohighlight">\((S, S^c)\)</span>?</p>
<p>a) The ratio of the number of edges between <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(S^c\)</span> to the total number of edges in the graph.</p>
<p>b) The ratio of the number of edges between <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(S^c\)</span> to the size of the smaller set, <span class="math notranslate nohighlight">\(\min\{|S|, |S^c|\}\)</span>.</p>
<p>c) The ratio of the number of edges within <span class="math notranslate nohighlight">\(S\)</span> to the number of edges within <span class="math notranslate nohighlight">\(S^c\)</span>.</p>
<p>d) The ratio of the total number of edges in the graph to the number of edges between <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(S^c\)</span>.</p>
<p><strong>2</strong> What is the isoperimetric number (or Cheeger constant) of a graph <span class="math notranslate nohighlight">\(G\)</span>?</p>
<p>a) The largest value of the cut ratio over all possible cuts.</p>
<p>b) The smallest value of the cut ratio over all possible cuts.</p>
<p>c) The average value of the cut ratio over all possible cuts.</p>
<p>d) The median value of the cut ratio over all possible cuts.</p>
<p><strong>3</strong> What do <em>Cheeger’s inequalities</em> establish?</p>
<p>a) A relationship between the isoperimetric number and the largest Laplacian eigenvalue.</p>
<p>b) A relationship between the isoperimetric number and the second largest Laplacian eigenvalue.</p>
<p>c) A relationship between the isoperimetric number and the smallest Laplacian eigenvalue.</p>
<p>d) A relationship between the isoperimetric number and the second smallest Laplacian eigenvalue.</p>
<p><strong>4</strong> In the context of spectral graph theory, what is the Fiedler vector?</p>
<p>a) The eigenvector associated with the largest eigenvalue of the Laplacian matrix.</p>
<p>b) The eigenvector associated with the smallest eigenvalue of the Laplacian matrix.</p>
<p>c) The eigenvector associated with the second smallest eigenvalue of the Laplacian matrix.</p>
<p>d) The eigenvector associated with the second largest eigenvalue of the Laplacian matrix.</p>
<p><strong>5</strong> Which of the following is the relaxation of the minimum bisection problem presented in the text?</p>
<div class="math notranslate nohighlight">
\[
\min \frac{1}{4} \left\{\sum_{\{i,j\} \in E} (x_i - x_j)^2 : \mathbf{x} = (x_1, ..., x_n) \in \{-1, +1\}^n, \sum_{i=1}^n x_i = 0\right\}
\]</div>
<p>a)</p>
<div class="math notranslate nohighlight">
\[
\min \frac{1}{4} \left\{\sum_{\{i,j\} \in E} (x_i - x_j)^2 : \mathbf{x} = (x_1, ..., x_n) \in \mathbb{R}^n, \sum_{i=1}^n x_i = 0, \sum_{i=1}^n x_i^2 = n\right\}
\]</div>
<p>b)</p>
<div class="math notranslate nohighlight">
\[
\min \frac{1}{4} \left\{\sum_{\{i,j\} \in E} |x_i - x_j| : \mathbf{x} = (x_1, ..., x_n) \in \mathbb{R}^n, \sum_{i=1}^n x_i = 0, \sum_{i=1}^n x_i^2 = n\right\}
\]</div>
<p>c)</p>
<div class="math notranslate nohighlight">
\[
\max \frac{1}{4} \left\{\sum_{\{i,j\} \in E} (x_i - x_j)^2 : \mathbf{x} = (x_1, ..., x_n) \in \mathbb{R}^n, \sum_{i=1}^n x_i = 0, \sum_{i=1}^n x_i^2 = n\right\}
\]</div>
<p>d)</p>
<div class="math notranslate nohighlight">
\[
\max \frac{1}{4} \left\{\sum_{\{i,j\} \in E} |x_i - x_j| : \mathbf{x} = (x_1, ..., x_n) \in \mathbb{R}^n, \sum_{i=1}^n x_i = 0, \sum_{i=1}^n x_i^2 = n\right\}
\]</div>
<p>Answer for 1: b. Justification: The text defines the cut ratio as <span class="math notranslate nohighlight">\(\phi(S) = \frac{|E(S, S^c)|}{\min\{|S|, |S^c|\}}\)</span>, where <span class="math notranslate nohighlight">\(|E(S, S^c)|\)</span> is the number of edges between <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(S^c\)</span>.</p>
<p>Answer for 2: b. Justification: The text defines the isoperimetric number as “the smallest value [the cut ratio] can take on <span class="math notranslate nohighlight">\(G\)</span>, that is, <span class="math notranslate nohighlight">\(\phi_G = \min_{\emptyset \neq S \subset V} \phi(S)\)</span>.”</p>
<p>Answer for 3: d. Justification: The text states that “A key result of spectral graph theory establishes a quantitative relation between the isoperimetric number and the second smallest Laplacian eigenvalue.”</p>
<p>Answer for 4: c. Justification: The text refers to the eigenvector associated with the second smallest eigenvalue of the Laplacian matrix as the Fiedler vector.</p>
<p>Answer for 5: a. Justification: The text replaces the constraint <span class="math notranslate nohighlight">\(\mathbf{x} = (x_1, ..., x_n) \in \{-1, +1\}^n\)</span> with <span class="math notranslate nohighlight">\(\mathbf{x} = (x_1, ..., x_n) \in \mathbb{R}^n\)</span> and adds the constraint <span class="math notranslate nohighlight">\(\sum_{i=1}^n x_i^2 = n\)</span> to maintain the balanced cut property.</p>
</section>
&#13;

<h2><span class="section-number">5.5.1. </span>How to cut a graph<a class="headerlink" href="#how-to-cut-a-graph" title="Link to this heading">#</a></h2>
<p>Let <span class="math notranslate nohighlight">\(G=(V, E)\)</span> be a graph. Imagine that we are interested in finding a good cut. That is, roughly speaking, we seek to divide it into two disjoint subsets of vertices to achieve two goals simultaneously:</p>
<ol class="arabic simple">
<li><p>the two sets have relatively few edges between them</p></li>
<li><p>neither set is too small.</p></li>
</ol>
<p>We will show that the Laplacian eigenvectors provide useful information in order to perform this kind of graph cutting. First we formulate the problem formally.</p>
<p><strong>Cut ratio</strong> One way to make the graph cutting more precise is to consider the following combinatorial quantity.</p>
<p><strong>DEFINITION</strong> <strong>(Isoperimetric Number)</strong> <span class="math notranslate nohighlight">\(\idx{isoperimetric number}\xdi\)</span> Let <span class="math notranslate nohighlight">\(G=(V, E)\)</span> be a graph. A cut<span class="math notranslate nohighlight">\(\idx{cut}\xdi\)</span> is a bipartition <span class="math notranslate nohighlight">\((S, S^c)\)</span> of the vertices of <span class="math notranslate nohighlight">\(G\)</span>, where <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(S^c = V\setminus S\)</span> are non-empty subsets of <span class="math notranslate nohighlight">\(V\)</span>. The corresponding cutset is the set of edges between <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(S^c\)</span></p>
<div class="math notranslate nohighlight">
\[
E(S,S^c)
=
\{
\{i,j\} \in E : i \in S, j \in S^c 
\}.
\]</div>
<p>This is also known as the edge boundary of <span class="math notranslate nohighlight">\(S\)</span> (denoted <span class="math notranslate nohighlight">\(\partial S\)</span>). The size of the cutset<span class="math notranslate nohighlight">\(\idx{cutset}\xdi\)</span> is then <span class="math notranslate nohighlight">\(|E(S,S^c)|\)</span>, the number of edges between <span class="math notranslate nohighlight">\(S\)</span> to <span class="math notranslate nohighlight">\(S^c\)</span>. The cut ratio<span class="math notranslate nohighlight">\(\idx{cut ratio}\xdi\)</span> of <span class="math notranslate nohighlight">\((S,S^c)\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[
\phi(S) 
= 
\frac{|E(S,S^c)|}{\min\{|S|, |S^c|\}}
\]</div>
<p>and the isoperimetric number (or <a class="reference external" href="https://en.wikipedia.org/wiki/Spectral_graph_theory#Cheeger_constant">Cheeger constant</a>)<span class="math notranslate nohighlight">\(\idx{Cheeger constant}\xdi\)</span> of <span class="math notranslate nohighlight">\(G\)</span> is the smallest value this quantity can take on <span class="math notranslate nohighlight">\(G\)</span>, that is,</p>
<div class="math notranslate nohighlight">
\[
\phi_G
= 
\min_{\emptyset \neq S \subset V} \phi(S).
\]</div>
<p><span class="math notranslate nohighlight">\(\natural\)</span></p>
<p>In words: the cut ratio is attempting to minimize the number of edges across a cut, while penalizing cuts with a small number of vertices on either side. These correspond to the goals above and we will use this criterion to assess the quality of graph cuts.</p>
<p><em>Why do we need the denominator?</em> If we were to minimize only the numerator <span class="math notranslate nohighlight">\(|E(S,S^c)|\)</span> over all cuts (without the deonominator in <span class="math notranslate nohighlight">\(\phi(S)\)</span>), we would get what is known as the <a class="reference external" href="https://en.wikipedia.org/wiki/Minimum_cut">minimum cut (or min-cut) problem</a>. That problem is easier to solve. In particular, it can be solved using a beautiful <a class="reference external" href="https://en.wikipedia.org/wiki/Karger%27s_algorithm">randomized algorithm</a>. However, it tends to produce unbalanced cuts, where one side is much smaller than the other. This is not what we want here.</p>
<p><strong>Figure:</strong> Bridges are a good example of a bottleneck (i.e., a good cut) in a transportation network. (<em>Credit:</em> Made with <a class="reference external" href="https://www.midjourney.com/">Midjourney</a>)</p>
<p><img alt="Bridges" src="../Images/cc1af6f4a7c4f2d7fde93d3160917989.png" data-original-src="https://mmids-textbook.github.io/_images/small-improbably555_street_map_of_montreal_island_and_south_shore._br_8d08831c-f53f-4967-8b37-74d9898a4840.png"/></p>
<p><span class="math notranslate nohighlight">\(\bowtie\)</span></p>
<p><strong>EXAMPLE:</strong> <strong>(A Random Tree)</strong> We illustrate the definitions above on a tree, that is, a connected graph with no cycle. The function <a class="reference external" href="https://networkx.org/documentation/stable/reference/generated/networkx.generators.trees.random_labeled_tree.html"><code class="docutils literal notranslate"><span class="pre">networkx.random_labeled_tree</span></code></a> can produce a random one. As before we use a <code class="docutils literal notranslate"><span class="pre">seed</span></code> for reproducibility. Again, we use <span class="math notranslate nohighlight">\(0,\ldots,n-1\)</span> for the vertex set.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G_tree</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">random_labeled_tree</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">111</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G_tree</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">circular_layout</span><span class="p">(</span><span class="n">G_tree</span><span class="p">),</span> 
                 <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/2d38afa13c4b3f67959d61320268e3d2f6194a7ef1bd38797b0c53892bb7a732.png" src="../Images/bfa48d48a70dbd181dc398a4217fd612.png" data-original-src="https://mmids-textbook.github.io/_images/2d38afa13c4b3f67959d61320268e3d2f6194a7ef1bd38797b0c53892bb7a732.png"/>
</div>
</div>
<p>Suppose we take <span class="math notranslate nohighlight">\(S = \{0,1,2,3\}\)</span>. Then <span class="math notranslate nohighlight">\(S^c = \{4,5\}\)</span> and</p>
<div class="math notranslate nohighlight">
\[
E(S,S^c)
= \{\{1,5\}, \{2,4\}\}.
\]</div>
<p>The cut ratio is then</p>
<div class="math notranslate nohighlight">
\[
\phi(S)
= \frac{|E(S,S^c)|}{\min\{|S|,|S^c|\}}
= \frac{2}{2}
= 1.
\]</div>
<p>A better cut is given by <span class="math notranslate nohighlight">\(S = \{0,1,5\}\)</span>. In that case <span class="math notranslate nohighlight">\(S^c = \{2,3,4\}\)</span>,</p>
<div class="math notranslate nohighlight">
\[
E(S,S^c)= \{\{1,3\}\},
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\phi(S)
= \frac{|E(S,S^c)|}{\min\{|S|,|S^c|\}}
= \frac{1}{3}.
\]</div>
<p>This is also equal to <span class="math notranslate nohighlight">\(\phi_G\)</span>. Indeed, in a connected graph with <span class="math notranslate nohighlight">\(n\)</span> vertices, the numerator is at least <span class="math notranslate nohighlight">\(1\)</span> and the denominator is at most <span class="math notranslate nohighlight">\(n/2\)</span>, which is achieved here.</p>
<p><span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p><strong>Cheeger’s inequalities</strong> A key result of spectral graph theory establishes a quantitative relation between the isoperimetric number and the second smallest Laplacian eigenvalue.</p>
<p><strong>THEOREM</strong> <strong>(Cheeger)</strong> <span class="math notranslate nohighlight">\(\idx{Cheeger's inequality}\xdi\)</span> Let <span class="math notranslate nohighlight">\(G = (V, E)\)</span> be a graph with <span class="math notranslate nohighlight">\(n = |V|\)</span> vertices and maximum degree <span class="math notranslate nohighlight">\(\bar{\delta}\)</span>. Let <span class="math notranslate nohighlight">\(0 = \mu_1 \leq \mu_2 \leq \cdots \leq \mu_n\)</span> be its Laplacian eigenvalues. Then</p>
<div class="math notranslate nohighlight">
\[
\frac{\phi_G^2}{2 \bar{\delta}} \leq \mu_2 \leq 2 \phi_G.
\]</div>
<p><span class="math notranslate nohighlight">\(\sharp\)</span></p>
<p>We only prove the easy direction, <span class="math notranslate nohighlight">\(\mu_2 \leq 2 \phi_G\)</span>, which shows explicitly how the connection between <span class="math notranslate nohighlight">\(\mu_2\)</span> and <span class="math notranslate nohighlight">\(\phi_G\)</span> comes about.</p>
<p><em>Proof idea:</em> To show that <span class="math notranslate nohighlight">\(\mu_2 \leq 2 \phi_G\)</span>, we find an appropriate test vector to plug into the extremal characterization of <span class="math notranslate nohighlight">\(\mu_2\)</span> and link it to <span class="math notranslate nohighlight">\(\phi_G\)</span>.</p>
<p><em>Proof:</em> Recall that, from the <em>Variational Characterization of <span class="math notranslate nohighlight">\(\mu_2\)</span></em>, we have</p>
<div class="math notranslate nohighlight">
\[
\mu_2 
= \min\left\{
\sum_{\{u, v\} \in E} (x_u - x_v)^2 \,:\,
\mathbf{x} = (x_1, \ldots, x_n) \in \mathbb{R}^n, 
\sum_{u=1}^n x_u = 0,
\sum_{u = 1}^n x_u^2 = 1
\right\}.
\]</div>
<p><em><strong>Constructing a good test vector:</strong></em> We construct an <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> that provides a good upper bound. Let <span class="math notranslate nohighlight">\(\emptyset \neq S \subset V\)</span> be a proper, nonempty subset of <span class="math notranslate nohighlight">\(V\)</span> such that <span class="math notranslate nohighlight">\(0 &lt; |S| \leq \frac{1}{2}|V|\)</span>. We choose a vector that takes one value on <span class="math notranslate nohighlight">\(S\)</span> and a different value on <span class="math notranslate nohighlight">\(S^c\)</span>. Taking a cue from the two-component example above we consider the vector with entries</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
x_i
=
\begin{cases}
\sqrt{\frac{|S^c|}{n |S|}} &amp; \text{if $i \in S$}\\
- \sqrt{\frac{|S|}{n |S^c|}} &amp; \text{if $i \in S^c$}.
\end{cases}
\end{align*}\]</div>
<p>This choice ensures that</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\sum_{i=1}^n x_i
&amp;= \sum_{i\in S} \sqrt{\frac{|S^c|}{n |S|}} + \sum_{i\in S^c} \left(- \sqrt{\frac{|S|}{n |S^c|}}\right)\\
&amp;= |S| \sqrt{\frac{|S^c|}{n |S|}} - |S^c| \sqrt{\frac{|S|}{n |S^c|}}\\
&amp;= \sqrt{\frac{|S| |S^c|}{n}} - \sqrt{\frac{|S||S^c| }{n}}\\
&amp;= 0,
\end{align*}\]</div>
<p>as well</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\sum_{i=1}^n x_i^2
&amp;= \sum_{i\in S} \left(\sqrt{\frac{|S^c|}{n |S|}}\right)^2  + \sum_{i\in S^c} \left(- \sqrt{\frac{|S|}{n |S^c|}}\right)^2\\
&amp;= |S| \frac{|S^c|}{n |S|} + |S^c| \frac{|S|}{n |S^c|}\\
&amp;= \frac{|S^c| + |S|}{n}\\
&amp;=1.
\end{align*}\]</div>
<p>To evaluate the Laplacian quadratic form, we note that <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> takes the same value everywhere on <span class="math notranslate nohighlight">\(S\)</span> (and on <span class="math notranslate nohighlight">\(S^c\)</span>). Hence the sum over edges reduces to</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\sum_{\{i, j\} \in E} (x_i - x_j)^2
&amp;= \sum_{\substack{\{i, j\} \in E \\ x_i\neq x_j}} \left(\sqrt{\frac{|S^c|}{n |S|}} 
+ \sqrt{\frac{|S|}{n |S^c|}}\right)^2\\
&amp;= \sum_{\substack{\{i, j\} \in E \\ x_i\neq x_j}} \left(\frac{|S^c| + |S|}{\sqrt{n |S| |S^c|}}\right)^2\\
&amp;= |E(S,S^c)|\frac{n}{|S| |S^c|},
\end{align*}\]</div>
<p>where we used that, for each edge <span class="math notranslate nohighlight">\(\{i, j\} \in E\)</span> where <span class="math notranslate nohighlight">\(x_i \neq x_j\)</span>, one endvertex is in <span class="math notranslate nohighlight">\(S\)</span> and one endvertex is in <span class="math notranslate nohighlight">\(S^c\)</span>.</p>
<p><em><strong>Using the definition of the isoperimetric number:</strong></em> So for this choice of <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> we have</p>
<div class="math notranslate nohighlight">
\[
\mu_2 \leq \sum_{\{i, j\} \in E} (x_i - x_j)^2
= \frac{n |E(S,S^c)|}{|S^c| |S|}
= \frac{|E(S,S^c)|}{(|S^c|/n) |S|}
\leq 2 \frac{|E(S,S^c)|}{|S|}
\]</div>
<p>where we used that <span class="math notranslate nohighlight">\(|S^c| \geq n/2\)</span>. This inequality holds for any <span class="math notranslate nohighlight">\(S\)</span> such that <span class="math notranslate nohighlight">\(0 &lt; |S| \leq \frac{1}{2}|V|\)</span>. In particular, it holds for the <span class="math notranslate nohighlight">\(S\)</span> producing the smallest value. Hence, by the definition of the isoperimetric number, we get</p>
<div class="math notranslate nohighlight">
\[
\mu_2 \leq 2 \phi_G
\]</div>
<p>as claimed. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p><strong>NUMERICAL CORNER:</strong> We return to the random tree example above. We claimed that <span class="math notranslate nohighlight">\(\phi_G = 1/3\)</span>. The maximum degree is <span class="math notranslate nohighlight">\(\bar{\delta} = 3\)</span>. We now compute <span class="math notranslate nohighlight">\(\mu_2\)</span>. We first compute the Laplacian matrix.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">phi_G</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
<span class="n">max_deg</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>
</div>
</div>
</div>
<p>We now compute <span class="math notranslate nohighlight">\(\mu_2\)</span>. We first compute the Laplacian matrix.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">L_tree</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">laplacian_matrix</span><span class="p">(</span><span class="n">G_tree</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">L_tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[[ 1 -1  0  0  0  0]
 [-1  3  0 -1  0 -1]
 [ 0  0  2 -1 -1  0]
 [ 0 -1 -1  2  0  0]
 [ 0  0 -1  0  1  0]
 [ 0 -1  0  0  0  1]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">L_tree</span><span class="p">)</span> 
<span class="n">mu_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">w</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mu_2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>0.32486912943335317
</pre></div>
</div>
</div>
</div>
<p>We check <em>Cheeger’s inequalities</em>. The left-hand side is:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="p">(</span><span class="n">phi_G</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">max_deg</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>0.018518518518518517
</pre></div>
</div>
</div>
</div>
<p>The right-hand side is:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="mi">2</span> <span class="o">*</span> <span class="n">phi_G</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>0.6666666666666666
</pre></div>
</div>
</div>
</div>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
<p><strong>A graph-cutting algorithm</strong> We only proved the easy direction of <em>Cheeger’s inequalities</em>. It is however useful to sketch the other direction (the actual <a class="reference external" href="https://en.wikipedia.org/wiki/Cheeger_constant#Cheeger's_inequality">Cheeger’s inequality</a> in the graph context), as it contains an important algorithmic idea.</p>
<p><em><strong>An algorithm:</strong></em> The input is the graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span>. Let <span class="math notranslate nohighlight">\(\mathbf{y}_2 \in \mathbb{R}^n\)</span> be the unit-norm eigenvector of the Laplacian matrix <span class="math notranslate nohighlight">\(L\)</span> associated to its second smallest eigenvalue <span class="math notranslate nohighlight">\(\mu_2\)</span>, i.e., <span class="math notranslate nohighlight">\(\mathbf{y}_2\)</span> is the Fiedler vector. There is one entry of <span class="math notranslate nohighlight">\(\mathbf{y}_2 = (y_{2,1}, \ldots, y_{2,n})\)</span> for each vertex of <span class="math notranslate nohighlight">\(G\)</span>. We use these entries to embed the graph <span class="math notranslate nohighlight">\(G\)</span> in <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>: vertex <span class="math notranslate nohighlight">\(i\)</span> is mapped to <span class="math notranslate nohighlight">\(y_{2,i}\)</span>. Now order the entries <span class="math notranslate nohighlight">\(y_{2,\pi(1)}, \ldots, y_{2,\pi(n)}\)</span>, where <span class="math notranslate nohighlight">\(\pi\)</span> is a <a class="reference external" href="https://en.wikipedia.org/wiki/Permutation">permutation</a><span class="math notranslate nohighlight">\(\idx{permutation}\xdi\)</span>, that is, a re-ordering of <span class="math notranslate nohighlight">\(1,\ldots,n\)</span>. Specifically, <span class="math notranslate nohighlight">\(\pi(1)\)</span> is the vertex corresponding to the smallest entry of <span class="math notranslate nohighlight">\(\mathbf{y}_{2}\)</span>, <span class="math notranslate nohighlight">\(\pi(2)\)</span> is the second smallest, and so on. We consider only cuts of the form</p>
<div class="math notranslate nohighlight">
\[
S_k = \{\pi(1), \ldots, \pi(k)\}
\]</div>
<p>and we output the cut <span class="math notranslate nohighlight">\((S_k, S_k^c)\)</span> that minimizes the cut ratio</p>
<div class="math notranslate nohighlight">
\[
\phi(S_k)
= \frac{|E(S_k,S_k^c)|}{\min\{k, n-k\}},
\]</div>
<p>for the <span class="math notranslate nohighlight">\(k \leq n-1\)</span>.</p>
<p>What can be proved rigorously (but we will not do this here) is that there exists some <span class="math notranslate nohighlight">\(k^* \in\{1,\ldots,n-1\}\)</span> such that</p>
<div class="math notranslate nohighlight">
\[
\mu_2 
= 
\sum_{\{u, v\} \in E} (y_{2,u} - y_{2,v})^2
\geq 
\frac{\phi(S_{k^*})^2}{2 \bar{\delta}}
\geq 
\frac{\phi_G^2}{2 \bar{\delta}},
\]</div>
<p>which implies the lower bound in <em>Cheeger’s inequalities</em>. The leftmost inequality is the non-trivial one.</p>
<p>Since <span class="math notranslate nohighlight">\(\mu_2 \leq 2 \phi_G\)</span>, this implies that</p>
<div class="math notranslate nohighlight">
\[
\phi(S_{k^*})
\leq \sqrt{4 \bar{\delta} \phi_G}.
\]</div>
<p>So <span class="math notranslate nohighlight">\(\phi(S_{k^*})\)</span> may not achieve <span class="math notranslate nohighlight">\(\phi_G\)</span>, but we do get some guarantee on the quality of the cut produced by this algorithm.</p>
<p>See, for example, [<a class="reference external" href="https://ocw.mit.edu/courses/mathematics/18-409-topics-in-theoretical-computer-science-an-algorithmists-toolkit-fall-2009/index.htm">Kel</a>, Lecture 3, Section 4.2] for more details.</p>
<p>The above provides a heuristic to find a cut with provable guarantees. We implement it next. In contrast, the problem of finding a cut which minimizes the cut ratio is known to be <a class="reference external" href="https://en.wikipedia.org/wiki/NP-hardness">NP-hard</a><span class="math notranslate nohighlight">\(\idx{NP-hardness}\xdi\)</span>, that is, roughly speaking it is computationally intractable.</p>
<p>We implement the graph cutting algorithm above.</p>
<p>We now implement this heuristic in Python. We first write an auxiliary function that takes as input an adjacency matrix, an ordering of the vertices and a value <span class="math notranslate nohighlight">\(k\)</span>. It returns the cut ratio for the first <span class="math notranslate nohighlight">\(k\)</span> vertices in the order.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">cut_ratio</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">edge_boundary</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
            <span class="n">edge_boundary</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">order</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            
    <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">edge_boundary</span><span class="o">/</span><span class="n">denominator</span>
</pre></div>
</div>
</div>
</div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">cut_ratio</span></code> function, we first compute the Laplacian, find the second eigenvector and corresponding order of vertices. Then we compute the cut ratio for every <span class="math notranslate nohighlight">\(k\)</span>. Finally we output the cut (both <span class="math notranslate nohighlight">\(S_k\)</span> and <span class="math notranslate nohighlight">\(S_k^c\)</span>) corresponding to the minimum, as a tuple of arrays.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">spectral_cut2</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">degrees</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">degrees</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">D</span> <span class="o">-</span> <span class="n">A</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> 
    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">w</span><span class="p">)[</span><span class="mi">1</span><span class="p">]])</span>
    
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">phi</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cut_ratio</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">imin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">order</span><span class="p">[</span><span class="n">imin</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, to help visualize the output, we write a function coloring the vertices according to which side of the cut they are on.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">viz_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
    <span class="n">assign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">assign</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">assign</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="n">with_labels</span><span class="p">,</span> 
            <span class="n">cmap</span><span class="o">=</span><span class="s1">'spring'</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="n">node_size</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'k'</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p><strong>NUMERICAL CORNER:</strong> We will illustrate this on the path graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">spectral_layout</span><span class="p">(</span><span class="n">G</span><span class="p">),</span> 
                 <span class="n">node_color</span><span class="o">=</span><span class="s1">'black'</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">'white'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/4ebfff7c18330f27d88859052bc61ef4bf3023b05b644a97c42754c8bbfbdfcd.png" src="../Images/9060b16650e938e492286e8b623cd2cb.png" data-original-src="https://mmids-textbook.github.io/_images/4ebfff7c18330f27d88859052bc61ef4bf3023b05b644a97c42754c8bbfbdfcd.png"/>
</div>
</div>
<p>We apply our spectral-based cutting algorihtm.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="n">s</span><span class="p">,</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">spectral_cut2</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[0 1 2 3 4]
[5 6 7 8 9]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spectral_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">viz_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/2211d003904642e7dd7cb3c055a2d5959293cb510b165c444cc591a56f3c74c5.png" src="../Images/2f0dc8bc361ef1af11564249dcfd4461.png" data-original-src="https://mmids-textbook.github.io/_images/2211d003904642e7dd7cb3c055a2d5959293cb510b165c444cc591a56f3c74c5.png"/>
</div>
</div>
<p>Let’s try it on the grid graph. Can you guess what the cut will be?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">grid_2d_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="n">s</span><span class="p">,</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">spectral_cut2</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spectral_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">viz_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/8473946b131310e3fb5eb51083f06728f05af3d93a601c7f6f8dcd0880c61d00.png" src="../Images/6b069ea231b753d5f8e27e249ea1456e.png" data-original-src="https://mmids-textbook.github.io/_images/8473946b131310e3fb5eb51083f06728f05af3d93a601c7f6f8dcd0880c61d00.png"/>
</div>
</div>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
<p><strong>How to compute the second smallest eigenvalue?</strong> There is one last piece of business to take care of. How do we compute the Fiedler vector? Previously, we have seen an iterative approach based on taking powers of the matrix to compute <em>the largest eigenvalue and corresponding eigenvector</em> of a positive semidefinite matrix. We show here how to adapt this approach to our task at hand. The details are left as a series of exercises.</p>
<p>First, we modify the Laplacian matrix to invert the order of the eigenvalues without changing the eigenvectors themselves. This way the smallest eigenvalues will become the largest ones. By the <em>Laplacian and Maximum Degree Lemma</em>, <span class="math notranslate nohighlight">\(\mu_i \leq 2 \bar{\delta}\)</span> for all <span class="math notranslate nohighlight">\(i=1,\ldots,n\)</span>, where recall that <span class="math notranslate nohighlight">\(\bar{\delta}\)</span> is the largest degree of the graph.</p>
<p><strong>LEMMA</strong> <strong>(Inverting the Order of Eigenvalues)</strong> <span class="math notranslate nohighlight">\(\idx{inverting the order of eigenvalues lemma}\xdi\)</span> For <span class="math notranslate nohighlight">\(i=1,\ldots,n\)</span>, let <span class="math notranslate nohighlight">\(\lambda_i = 2 \bar{\delta} - \mu_i\)</span>. The matrix <span class="math notranslate nohighlight">\(M = 2 \bar{\delta} I_{n\times n} - L\)</span> is positive semidefinite and has eigenvector decomposition</p>
<div class="math notranslate nohighlight">
\[
M = \sum_{i=1}^{n} \lambda_i \mathbf{y}_i \mathbf{y}_i^T.
\]</div>
<p><span class="math notranslate nohighlight">\(\flat\)</span></p>
<p>Second, our goal is now to compute the second largest eigenvalue of <span class="math notranslate nohighlight">\(M\)</span> – not the largest one. But we already know the largest one. It is <span class="math notranslate nohighlight">\(\lambda_1 = 2\bar{\delta} - \mu_1 = 2 \bar{\delta}\)</span> and its associated eigenvector is <span class="math notranslate nohighlight">\(\mathbf{y}_1 = \frac{1}{\sqrt{n}}(1,\ldots,1)\)</span>. It turns out that we can simply apply power iteration with a starting vector that is orthogonal to <span class="math notranslate nohighlight">\(\mathbf{y}_1\)</span>. Such a vector can be constructed by taking a random vector and subtracting its orthogonal projection on <span class="math notranslate nohighlight">\(\mathbf{y}_1\)</span>.</p>
<p><strong>LEMMA</strong> <strong>(Power Iteration for the Second Largest Eigenvalue)</strong> Assume that <span class="math notranslate nohighlight">\(\mu_1 &lt; \mu_2 &lt; \mu_3\)</span>. Let <span class="math notranslate nohighlight">\(\mathbf{x} \in \mathbb{R}^n\)</span> be a vector such that <span class="math notranslate nohighlight">\(\langle \mathbf{y}_1, \mathbf{x} \rangle = 0\)</span> and <span class="math notranslate nohighlight">\(\langle \mathbf{y}_2, \mathbf{x} \rangle &gt; 0\)</span>. Then</p>
<div class="math notranslate nohighlight">
\[
\frac{M^{k} \mathbf{x}}{\|M^{k} \mathbf{x}\|} \to \mathbf{y}_2
\]</div>
<p>as <span class="math notranslate nohighlight">\(k \to +\infty\)</span>. If instead <span class="math notranslate nohighlight">\(\langle \mathbf{y}_2, \mathbf{x} \rangle &lt; 0\)</span>, then the limit is <span class="math notranslate nohighlight">\(- \mathbf{y}_2\)</span>. <span class="math notranslate nohighlight">\(\flat\)</span></p>
<p><strong>The relaxation perspective</strong> Here is another intuitive way to shed light on the effectiveness of spectral partitioning. Assume we have a graph <span class="math notranslate nohighlight">\(G = (V,E)\)</span> with an even number <span class="math notranslate nohighlight">\(n = |V|\)</span> of vertices. Suppose we are looking for the best balanced cut <span class="math notranslate nohighlight">\((S,S^c)\)</span> in the sense that it minimizes the number of edges <span class="math notranslate nohighlight">\(|E(S,S^c)|\)</span> across it over all cuts with <span class="math notranslate nohighlight">\(|S| = |S^c| = n/2\)</span>. This is known as the <a class="reference external" href="https://link.springer.com/referenceworkentry/10.1007/978-1-4939-2864-4_231">minimum bisection problem</a>.</p>
<p>Mathematically, we can formulate this as the followign discrete optimization problem:</p>
<div class="math notranslate nohighlight">
\[
\min\left\{\frac{1}{4} \sum_{\{i,j\} \in E} (x_i - x_j)^2\,:\, \mathbf{x} = (x_1,\ldots,x_n) \in \{-1,+1\}^n, \sum_{i=1}^n x_i = 0 \right\}.
\]</div>
<p>The condition <span class="math notranslate nohighlight">\(\mathbf{x} \in \{-1,+1\}^n\)</span> implicitly assigns each vertex <span class="math notranslate nohighlight">\(i\)</span> to <span class="math notranslate nohighlight">\(S\)</span> (if <span class="math notranslate nohighlight">\(x_i = -1\)</span>) or <span class="math notranslate nohighlight">\(S^c\)</span> (if <span class="math notranslate nohighlight">\(x_i=+1\)</span>). The condition <span class="math notranslate nohighlight">\(\sum_{i=1}^n x_i = 0\)</span> then ensures that the cut <span class="math notranslate nohighlight">\((S,S^c)\)</span> is balanced, that is, that <span class="math notranslate nohighlight">\(|S| = |S^c|\)</span>. Under this interpretation, the term <span class="math notranslate nohighlight">\((x_i - x_j)^2\)</span> is either <span class="math notranslate nohighlight">\(0\)</span> if <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> are on the same side of the cut, or <span class="math notranslate nohighlight">\(4\)</span> if they are on opposite sides.</p>
<p>This is a hard computational problem. One way to approach such a discrete optimization problem is to relax it. That is, to turn it into an optimization problem with continuous variables. Specifically here we consider instead</p>
<div class="math notranslate nohighlight">
\[
\min\left\{\frac{1}{4} \sum_{\{i,j\} \in E} (x_i - x_j)^2\,:\, \mathbf{x} = (x_1,\ldots,x_n) \in \mathbb{R}^n, \sum_{i=1}^n x_i = 0,  \sum_{i=1}^n x_i^2 = n\right\}.
\]</div>
<p>The optimal objective value of this relaxed problem is necessarily smaller or equal than the original one. Indeed any solution to the original problem satisfies the constraints of the relaxation. Up to a scaling factor, this last problem is equivalent to the variational characterization of <span class="math notranslate nohighlight">\(\mu_2\)</span>. Indeed, one can prove that the minimum achieved is <span class="math notranslate nohighlight">\(\frac{\mu_2 n}{4}\)</span> (Try it!).</p>
<p><strong>NUMERICAL CORNER:</strong> We return to the <a class="reference external" href="https://en.wikipedia.org/wiki/Zachary%27s_karate_club">Karate Club dataset</a>.</p>
<p><strong>Figure:</strong> Dojo (<em>Credit:</em> Made with <a class="reference external" href="https://www.midjourney.com/">Midjourney</a>)</p>
<p><img alt="Kids in a dojo" src="../Images/6b732b2a4c677bbb26d3e4d6e907880a.png" data-original-src="https://mmids-textbook.github.io/_images/kids_sitting_in_a_dojo-small.png"/></p>
<p><span class="math notranslate nohighlight">\(\bowtie\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">karate_club_graph</span><span class="p">()</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We seek to find natural sub-communities. We use the spectral properties of the Laplacian. Specifically, we use our <code class="docutils literal notranslate"><span class="pre">spectral_cut2</span></code> and <code class="docutils literal notranslate"><span class="pre">viz_cut</span></code> functions to compute a good cut and vizualize it.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">s</span><span class="p">,</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">spectral_cut2</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[18 26 20 14 29 22 24 15 23 25 32 27  9 33 31 28 30  8]
[ 2 13  1 19  7  3 12  0 21 17 11  4 10  6  5 16]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">viz_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/a0fae7b032318e0bf638db5fd30e11cead1d6304485bc0a49d38190321ba5a37.png" src="../Images/acf48fe63af2b9b2bb66e36917f2217f.png" data-original-src="https://mmids-textbook.github.io/_images/a0fae7b032318e0bf638db5fd30e11cead1d6304485bc0a49d38190321ba5a37.png"/>
</div>
</div>
<p>It is not trivial to assess the quality of the resulting cut. But this particular example has a known ground-truth community structure (which partly explains its widespread use). Quoting from <a class="reference external" href="https://en.wikipedia.org/wiki/Zachary%27s_karate_club">Wikipedia</a>:</p>
<blockquote>
<div><p>A social network of a karate club was studied by Wayne W. Zachary for a period of three years from 1970 to 1972. The network captures 34 members of a karate club, documenting links between pairs of members who interacted outside the club. During the study a conflict arose between the administrator “John A” and instructor “Mr. Hi” (pseudonyms), which led to the split of the club into two. Half of the members formed a new club around Mr. Hi; members from the other part found a new instructor or gave up karate. Based on collected data Zachary correctly assigned all but one member of the club to the groups they actually joined after the split.</p>
</div></blockquote>
<p>This ground truth is the following. We use <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.nonzero.html#numpy.nonzero"><code class="docutils literal notranslate"><span class="pre">numpy.nonzero</span></code></a> to convert it into a cut.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">truth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> 
                  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">s_truth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">truth</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">viz_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s_truth</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/a0fae7b032318e0bf638db5fd30e11cead1d6304485bc0a49d38190321ba5a37.png" src="../Images/acf48fe63af2b9b2bb66e36917f2217f.png" data-original-src="https://mmids-textbook.github.io/_images/a0fae7b032318e0bf638db5fd30e11cead1d6304485bc0a49d38190321ba5a37.png"/>
</div>
</div>
<p>You can check that our cut perfectly matches the ground truth.</p>
<p><strong>CHAT &amp; LEARN</strong> Investigate alternative graph partitioning algorithms, such as the Kernighan-Lin algorithm. Ask your favorite AI chatbot to explain how it works and compare its performance to spectral clustering on this dataset. (<a class="reference external" href="https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_specgraph_notebook.ipynb">Open In Colab</a>) <span class="math notranslate nohighlight">\(\ddagger\)</span></p>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
<p><em><strong>Self-assessment quiz</strong></em> <em>(with help from Claude, Gemini, and ChatGPT)</em></p>
<p><strong>1</strong> Which of the following best describes the ‘cut ratio’ of a graph cut <span class="math notranslate nohighlight">\((S, S^c)\)</span>?</p>
<p>a) The ratio of the number of edges between <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(S^c\)</span> to the total number of edges in the graph.</p>
<p>b) The ratio of the number of edges between <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(S^c\)</span> to the size of the smaller set, <span class="math notranslate nohighlight">\(\min\{|S|, |S^c|\}\)</span>.</p>
<p>c) The ratio of the number of edges within <span class="math notranslate nohighlight">\(S\)</span> to the number of edges within <span class="math notranslate nohighlight">\(S^c\)</span>.</p>
<p>d) The ratio of the total number of edges in the graph to the number of edges between <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(S^c\)</span>.</p>
<p><strong>2</strong> What is the isoperimetric number (or Cheeger constant) of a graph <span class="math notranslate nohighlight">\(G\)</span>?</p>
<p>a) The largest value of the cut ratio over all possible cuts.</p>
<p>b) The smallest value of the cut ratio over all possible cuts.</p>
<p>c) The average value of the cut ratio over all possible cuts.</p>
<p>d) The median value of the cut ratio over all possible cuts.</p>
<p><strong>3</strong> What do <em>Cheeger’s inequalities</em> establish?</p>
<p>a) A relationship between the isoperimetric number and the largest Laplacian eigenvalue.</p>
<p>b) A relationship between the isoperimetric number and the second largest Laplacian eigenvalue.</p>
<p>c) A relationship between the isoperimetric number and the smallest Laplacian eigenvalue.</p>
<p>d) A relationship between the isoperimetric number and the second smallest Laplacian eigenvalue.</p>
<p><strong>4</strong> In the context of spectral graph theory, what is the Fiedler vector?</p>
<p>a) The eigenvector associated with the largest eigenvalue of the Laplacian matrix.</p>
<p>b) The eigenvector associated with the smallest eigenvalue of the Laplacian matrix.</p>
<p>c) The eigenvector associated with the second smallest eigenvalue of the Laplacian matrix.</p>
<p>d) The eigenvector associated with the second largest eigenvalue of the Laplacian matrix.</p>
<p><strong>5</strong> Which of the following is the relaxation of the minimum bisection problem presented in the text?</p>
<div class="math notranslate nohighlight">
\[
\min \frac{1}{4} \left\{\sum_{\{i,j\} \in E} (x_i - x_j)^2 : \mathbf{x} = (x_1, ..., x_n) \in \{-1, +1\}^n, \sum_{i=1}^n x_i = 0\right\}
\]</div>
<p>a)</p>
<div class="math notranslate nohighlight">
\[
\min \frac{1}{4} \left\{\sum_{\{i,j\} \in E} (x_i - x_j)^2 : \mathbf{x} = (x_1, ..., x_n) \in \mathbb{R}^n, \sum_{i=1}^n x_i = 0, \sum_{i=1}^n x_i^2 = n\right\}
\]</div>
<p>b)</p>
<div class="math notranslate nohighlight">
\[
\min \frac{1}{4} \left\{\sum_{\{i,j\} \in E} |x_i - x_j| : \mathbf{x} = (x_1, ..., x_n) \in \mathbb{R}^n, \sum_{i=1}^n x_i = 0, \sum_{i=1}^n x_i^2 = n\right\}
\]</div>
<p>c)</p>
<div class="math notranslate nohighlight">
\[
\max \frac{1}{4} \left\{\sum_{\{i,j\} \in E} (x_i - x_j)^2 : \mathbf{x} = (x_1, ..., x_n) \in \mathbb{R}^n, \sum_{i=1}^n x_i = 0, \sum_{i=1}^n x_i^2 = n\right\}
\]</div>
<p>d)</p>
<div class="math notranslate nohighlight">
\[
\max \frac{1}{4} \left\{\sum_{\{i,j\} \in E} |x_i - x_j| : \mathbf{x} = (x_1, ..., x_n) \in \mathbb{R}^n, \sum_{i=1}^n x_i = 0, \sum_{i=1}^n x_i^2 = n\right\}
\]</div>
<p>Answer for 1: b. Justification: The text defines the cut ratio as <span class="math notranslate nohighlight">\(\phi(S) = \frac{|E(S, S^c)|}{\min\{|S|, |S^c|\}}\)</span>, where <span class="math notranslate nohighlight">\(|E(S, S^c)|\)</span> is the number of edges between <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(S^c\)</span>.</p>
<p>Answer for 2: b. Justification: The text defines the isoperimetric number as “the smallest value [the cut ratio] can take on <span class="math notranslate nohighlight">\(G\)</span>, that is, <span class="math notranslate nohighlight">\(\phi_G = \min_{\emptyset \neq S \subset V} \phi(S)\)</span>.”</p>
<p>Answer for 3: d. Justification: The text states that “A key result of spectral graph theory establishes a quantitative relation between the isoperimetric number and the second smallest Laplacian eigenvalue.”</p>
<p>Answer for 4: c. Justification: The text refers to the eigenvector associated with the second smallest eigenvalue of the Laplacian matrix as the Fiedler vector.</p>
<p>Answer for 5: a. Justification: The text replaces the constraint <span class="math notranslate nohighlight">\(\mathbf{x} = (x_1, ..., x_n) \in \{-1, +1\}^n\)</span> with <span class="math notranslate nohighlight">\(\mathbf{x} = (x_1, ..., x_n) \in \mathbb{R}^n\)</span> and adds the constraint <span class="math notranslate nohighlight">\(\sum_{i=1}^n x_i^2 = n\)</span> to maintain the balanced cut property.</p>
    
</body>
</html>