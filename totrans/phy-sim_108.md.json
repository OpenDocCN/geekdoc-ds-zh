["```py\n # self-contact\n    dhat_sqr = dhat * dhat\n    for xI in bp:\n        for eI in be:\n            if xI != eI[0] and xI != eI[1]: # do not consider a point and its incident edge\n                d_sqr = PE.val(x[xI], x[eI[0]], x[eI[1]])\n                if d_sqr < dhat_sqr:\n                    s = d_sqr / dhat_sqr\n                    # since d_sqr is used, need to divide by 8 not 2 here for consistency to linear elasticity:\n                    sum += 0.5 * contact_area[xI] * dhat * kappa / 8 * (s - 1) * math.log(s) \n```", "```py\n # self-contact\n    dhat_sqr = dhat * dhat\n    for xI in bp:\n        for eI in be:\n            if xI != eI[0] and xI != eI[1]: # do not consider a point and its incident edge\n                d_sqr = PE.val(x[xI], x[eI[0]], x[eI[1]])\n                if d_sqr < dhat_sqr:\n                    s = d_sqr / dhat_sqr\n                    # since d_sqr is used, need to divide by 8 not 2 here for consistency to linear elasticity:\n                    local_grad = 0.5 * contact_area[xI] * dhat * (kappa / 8 * (math.log(s) / dhat_sqr + (s - 1) / d_sqr)) * PE.grad(x[xI], x[eI[0]], x[eI[1]])\n                    g[xI] += local_grad[0:2]\n                    g[eI[0]] += local_grad[2:4]\n                    g[eI[1]] += local_grad[4:6] \n```", "```py\n # self-contact\n    dhat_sqr = dhat * dhat\n    for xI in bp:\n        for eI in be:\n            if xI != eI[0] and xI != eI[1]: # do not consider a point and its incident edge\n                d_sqr = PE.val(x[xI], x[eI[0]], x[eI[1]])\n                if d_sqr < dhat_sqr:\n                    d_sqr_grad = PE.grad(x[xI], x[eI[0]], x[eI[1]])\n                    s = d_sqr / dhat_sqr\n                    # since d_sqr is used, need to divide by 8 not 2 here for consistency to linear elasticity:\n                    local_hess = 0.5 * contact_area[xI] * dhat * utils.make_PSD(kappa / (8 * d_sqr * d_sqr * dhat_sqr) * (d_sqr + dhat_sqr) * np.outer(d_sqr_grad, d_sqr_grad) \\\n                        + (kappa / 8 * (math.log(s) / dhat_sqr + (s - 1) / d_sqr)) * PE.hess(x[xI], x[eI[0]], x[eI[1]]))\n                    index = [xI, eI[0], eI[1]]\n                    for nI in range(0, 3):\n                        for nJ in range(0, 3):\n                            for c in range(0, 2):\n                                for r in range(0, 2):\n                                    IJV[0].append(index[nI] * 2 + r)\n                                    IJV[1].append(index[nJ] * 2 + c)\n                                    IJV[2] = np.append(IJV[2], local_hess[nI * 2 + r, nJ * 2 + c]) \n```"]