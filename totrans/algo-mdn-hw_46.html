<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>External Memory Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>External Memory Model</h1>
<blockquote>原文：<a href="https://en.algorithmica.org/hpc/external-memory/model/">https://en.algorithmica.org/hpc/external-memory/model/</a></blockquote><div id="search"><input id="search-bar" type="search" placeholder="Search this book…" oninput="search()"/><div id="search-count"/><div id="search-results"/></div><header><div class="info"/></header><article><p>To reason about the performance of memory-bound algorithms, we need to develop a cost model that is more sensitive to expensive block I/O operations but is not too rigorous to still be useful.</p><span class="anchor" id="cache-aware-model"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/external-memory/model/#cache-aware-model">#</a>Cache-Aware Model</h3><p>In the <a href="/hpc/complexity">standard RAM model</a>, we ignore the fact that primitive operations take unequal time to complete. Most importantly, it does not differentiate between operations on different types of memory, equating a read from RAM taking ~50ns in real-time with a read from HDD taking ~5ms, or about a $10^5$ times as much.</p><p>Similar in spirit, in the <em>external memory model</em>, we simply ignore every operation that is not an I/O operation. More specifically, we consider one level of cache hierarchy and assume the following about the hardware and the problem:</p><ul><li>The size of the dataset is $N$, and it is all stored in <em>external</em> memory, which we can read and write in blocks of $B$ elements in a unit time (reading a whole block and just one element takes the same time).</li><li>We can store $M$ elements in <em>internal</em> memory, meaning that we can store up to $\left \lfloor \frac{M}{B} \right \rfloor$ blocks.</li><li>We only care about I/O operations: any computations done in-between the reads and the writes are free.</li><li>We additionally assume $N \gg M \gg B$.</li></ul><p>In this model, we measure the performance of an algorithm in terms of its high-level <em>I/O operations</em>, or <em>IOPS</em> — that is, the total number of blocks read or written to external memory during execution.</p><p>We will mostly focus on the case where the internal memory is RAM and the external memory is SSD or HDD, although the underlying analysis techniques that we will develop are applicable to any layer in the cache hierarchy. Under these settings, reasonable block size $B$ is about 1MB, internal memory size $M$ is usually a few gigabytes, and $N$ is up to a few terabytes.</p><span class="anchor" id="array-scan"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/external-memory/model/#array-scan">#</a>Array Scan</h3><p>As a simple example, when we calculate the sum of an array by iterating through it one element at a time, we implicitly load it by chunks of $O(B)$ elements and, in terms of the external memory model, process these chunks one by one:</p>$$
\underbrace{a_1, a_2, a_3,} _ {B_1}
\underbrace{a_4, a_5, a_6,} _ {B_2}
\ldots
\underbrace{a_{n-3}, a_{n-2}, a_{n-1}} _ {B_{m-1}}
$$
Thus, in the external memory model, the complexity of summation and other linear array scans is
$$
SCAN(N) \stackrel{\text{def}}{=} O\left(\left \lceil \frac{N}{B} \right \rceil \right) \; \text{IOPS}
$$<p>You can implement external array scan explicitly like this:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">FILE</span> <span class="o">*</span><span class="n">input</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"input.bin"</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">buffer</span><span class="p">[</span><span class="n">M</span><span class="p">],</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// while the file is not fully processed
</span></span></span><span class="line"><span class="cl"><span class="c1"/><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// read up to M of 4-byte elements from the input stream
</span></span></span><span class="line"><span class="cl"><span class="c1"/>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//  ^ the number of elements that were actually read
</span></span></span><span class="line"><span class="cl"><span class="c1"/>
</span></span><span class="line"><span class="cl">    <span class="c1">// if we can't read any more elements, finish
</span></span></span><span class="line"><span class="cl"><span class="c1"/>    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// sum elements in-memory
</span></span></span><span class="line"><span class="cl"><span class="c1"/>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum</span> <span class="o">+=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">fclose</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
</span></span></code></pre></div><p>Note that, in most cases, operating systems do this buffering automatically. Even when the data is just redirected to the standard input from a normal file, the operating system buffers its stream and reads it in blocks of ~4KB (by default).</p></article><div class="nextprev"><div class="left"><a href="https://en.algorithmica.org/hpc/external-memory/virtual/" id="prev-article">← Virtual Memory</a></div><div class="right"><a href="https://en.algorithmica.org/hpc/external-memory/sorting/" id="next-article">External Sorting →</a></div></div>    
</body>
</html>