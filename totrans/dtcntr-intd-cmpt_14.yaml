- en: 5.3Â Recursive DatağŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.3 é€’å½’æ•°æ®ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/recursive-data.html](https://dcic-world.org/2025-08-27/recursive-data.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/recursive-data.html](https://dcic-world.org/2025-08-27/recursive-data.html)
- en: '| Â Â Â Â [5.3.1Â Functions to Process Recursive Data](#%28part._.Functions_to_.Process_.Recursive_.Data%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   [5.3.1 å¤„ç†é€’å½’æ•°æ®çš„åŠŸèƒ½](#%28part._.Functions_to_.Process_.Recursive_.Data%29)
    |'
- en: '| Â Â Â Â [5.3.2Â A Template for Processing Recursive Data](#%28part._.A_.Template_for_.Processing_.Recursive_.Data%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|   [5.3.2 å¤„ç†é€’å½’æ•°æ®çš„æ¨¡æ¿](#%28part._.A_.Template_for_.Processing_.Recursive_.Data%29)
    |'
- en: '| Â Â Â Â [5.3.3Â The Design Recipe](#%28part._.The_.Design_.Recipe%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|   [5.3.3 è®¾è®¡é…æ–¹](#%28part._.The_.Design_.Recipe%29) |'
- en: In [Telling Apart Variants of Conditional Data](intro-struct-data.html#%28part._telling-apart-variants%29),
    we used `cases` to distinguish between different forms of conditional data. We
    had used `cases` earlier, specifically to distinguish between empty and non-empty
    lists in [Processing Lists](processing-lists.html). This suggests that lists are
    also a form of conditional data, just one that is built into Pyret. Indeed, this
    is the case.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[Telling Apart Variants of Conditional Data](intro-struct-data.html#%28part._telling-apart-variants%29)ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†`cases`æ¥åŒºåˆ†ä¸åŒçš„æ¡ä»¶æ•°æ®å½¢å¼ã€‚æˆ‘ä»¬ä¹‹å‰ä¹Ÿä½¿ç”¨è¿‡`cases`ï¼Œå…·ä½“æ¥è¯´ï¼Œæ˜¯åœ¨[Processing
    Lists](processing-lists.html)ä¸­åŒºåˆ†ç©ºåˆ—è¡¨å’Œéç©ºåˆ—è¡¨ã€‚è¿™è¡¨æ˜åˆ—è¡¨ä¹Ÿæ˜¯ä¸€ç§æ¡ä»¶æ•°æ®å½¢å¼ï¼Œåªæ˜¯å®ƒæ˜¯Pyretå†…ç½®çš„ã€‚ç¡®å®å¦‚æ­¤ã€‚
- en: 'To understand lists as conditional data, letâ€™s create a data definition for
    a new type `NumList` which contains a list of numbers (this differs from built-in
    lists, which work with any type of element). To avoid conflicts with Pyretâ€™s built-in
    `empty` value and `link` operator, weâ€™ll have `NumList` use `nl-empty` as its
    empty value and `nl-link` as the operator that builds new lists. Hereâ€™s a partial
    definition:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç†è§£åˆ—è¡¨ä½œä¸ºæ¡ä»¶æ•°æ®ï¼Œè®©æˆ‘ä»¬ä¸ºä¸€ä¸ªæ–°çš„ç±»å‹`NumList`åˆ›å»ºä¸€ä¸ªæ•°æ®å®šä¹‰ï¼Œå®ƒåŒ…å«ä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼ˆè¿™ä¸å†…ç½®åˆ—è¡¨ä¸åŒï¼Œå†…ç½®åˆ—è¡¨å¯ä»¥å¤„ç†ä»»ä½•ç±»å‹çš„å…ƒç´ ï¼‰ã€‚ä¸ºäº†é¿å…ä¸Pyretçš„å†…ç½®`empty`å€¼å’Œ`link`è¿ç®—ç¬¦å†²çªï¼Œæˆ‘ä»¬å°†ä½¿ç”¨`nl-empty`ä½œä¸º`NumList`çš„ç©ºå€¼ï¼Œå¹¶ä½¿ç”¨`nl-link`ä½œä¸ºæ„å»ºæ–°åˆ—è¡¨çš„è¿ç®—ç¬¦ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªéƒ¨åˆ†å®šä¹‰ï¼š
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Do Now!
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fill in the blank in the `nl-link` condition with the corresponding field(s)
    and corresponding types. The blank could contain anywhere from 0 through multiple
    fields.
  id: totrans-10
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨`nl-link`æ¡ä»¶ä¸­å¡«å†™ç›¸åº”çš„å­—æ®µå’Œç±»å‹ã€‚ç©ºç™½å¤„å¯ä»¥åŒ…å«ä»0åˆ°å¤šä¸ªå­—æ®µã€‚
- en: 'From working with lists earlier, hopefully you remembered that list constructors
    take two inputs: the first element of the list and a list to build on (the rest
    of the list). That suggests that we need two fields here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ä»ä¹‹å‰å¤„ç†åˆ—è¡¨çš„å·¥ä½œä¸­ï¼Œå¸Œæœ›æ‚¨è¿˜è®°å¾—åˆ—è¡¨æ„é€ å‡½æ•°éœ€è¦ä¸¤ä¸ªè¾“å…¥ï¼šåˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ å’Œè¦æ„å»ºçš„åˆ—è¡¨ï¼ˆåˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†ï¼‰ã€‚è¿™è¡¨æ˜æˆ‘ä»¬åœ¨è¿™é‡Œéœ€è¦ä¸¤ä¸ªå­—æ®µï¼š
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Do Now!
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fill in the types for `first` and `rest` if you havenâ€™t already.
  id: totrans-15
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨è¿˜æ²¡æœ‰å¡«å†™ï¼Œè¯·å¡«å†™`first`å’Œ`rest`çš„ç±»å‹ã€‚
- en: Since weâ€™re making a list of numbers, the `first` field should contain type
    `Number`. What about the `rest` field? It needs to be a list of numbers, so its
    type should be `NumList`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæˆ‘ä»¬æ­£åœ¨åˆ›å»ºä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œ`first`å­—æ®µåº”åŒ…å«ç±»å‹`Number`ã€‚é‚£ä¹ˆ`rest`å­—æ®µå‘¢ï¼Ÿå®ƒéœ€è¦æ˜¯ä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œå› æ­¤å…¶ç±»å‹åº”è¯¥æ˜¯`NumList`ã€‚
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice something interesting (and new) here: the type of the `rest` field is
    the same type (`NumList`) as the conditional data that we are defining. We can,
    quite literally, draw the arrows that show the self-referential part of the definition:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„è¿™é‡Œçš„ä¸€ä¸ªæœ‰è¶£ï¼ˆä¸”æ–°é¢–ï¼‰çš„ç°è±¡ï¼š`rest`å­—æ®µçš„ç±»å‹ä¸æˆ‘ä»¬æ‰€å®šä¹‰çš„æ¡ä»¶æ•°æ®ç±»å‹ç›¸åŒï¼ˆ`NumList`ï¼‰ã€‚æˆ‘ä»¬å¯ä»¥éå¸¸ç›´è§‚åœ°ç”»å‡ºè¡¨ç¤ºå®šä¹‰ä¸­è‡ªå¼•ç”¨éƒ¨åˆ†çš„ç®­å¤´ï¼š
- en: '![](../Images/8c8f0c1555bb84656f4e12c9faa58d32.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8c8f0c1555bb84656f4e12c9faa58d32.png)'
- en: 'Does that actually work? Yes. Think about how we might build up a list with
    the numbers 2, 7, and 3 (in that order). We start with `nl-empty`, which is a
    valid `NumList`. We then use `nl-link` to add the numbers onto that list, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å®é™…ä¸Šå¯è¡Œå—ï¼Ÿæ˜¯çš„ã€‚æƒ³æƒ³æˆ‘ä»¬å¦‚ä½•æ„å»ºä¸€ä¸ªåŒ…å«æ•°å­—2ã€7å’Œ3ï¼ˆæŒ‰æ­¤é¡ºåºï¼‰çš„åˆ—è¡¨ã€‚æˆ‘ä»¬ä»ä¸€ä¸ªæœ‰æ•ˆçš„`NumList`å¼€å§‹ï¼Œå³`nl-empty`ã€‚ç„¶åæˆ‘ä»¬ä½¿ç”¨`nl-link`å°†æ•°å­—æ·»åŠ åˆ°è¯¥åˆ—è¡¨ä¸­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In each case, the `rest` argument is itself a valid `NumList`. While defining
    data in terms of itself might seem problematic, it works fine because in order
    to build actual data, we had to start with the `nl-empty` condition, which does
    not refer to `NumList`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ¯ç§æƒ…å†µä¸‹ï¼Œ`rest`å‚æ•°æœ¬èº«å°±æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„`NumList`ã€‚è™½ç„¶ç”¨è‡ªèº«å®šä¹‰æ•°æ®å¯èƒ½çœ‹èµ·æ¥æœ‰é—®é¢˜ï¼Œä½†å®é™…ä¸Šå®ƒè¿è¡Œè‰¯å¥½ï¼Œå› ä¸ºä¸ºäº†æ„å»ºå®é™…çš„æ•°æ®ï¼Œæˆ‘ä»¬å¿…é¡»ä»`nl-empty`æ¡ä»¶å¼€å§‹ï¼Œå®ƒå¹¶ä¸å¼•ç”¨`NumList`ã€‚
- en: 'Data definitions that build on fields of the same type are called recursive
    data. Recursive data definitions are powerful because they permit us to create
    data that are unbounded or arbitrarily-sized. Given a `NumList`, there is an easy
    way to make a new, larger one: just use `nl-link`. So, we need to consider larger
    lists:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: å»ºç«‹åœ¨ç›¸åŒç±»å‹å­—æ®µä¹‹ä¸Šçš„æ•°æ®å®šä¹‰ç§°ä¸ºé€’å½’æ•°æ®ã€‚é€’å½’æ•°æ®å®šä¹‰ä¹‹æ‰€ä»¥å¼ºå¤§ï¼Œæ˜¯å› ä¸ºå®ƒä»¬å…è®¸æˆ‘ä»¬åˆ›å»ºæ— ç•Œæˆ–ä»»æ„å¤§å°çš„æ•°æ®ã€‚ç»™å®šä¸€ä¸ª `NumList`ï¼Œæœ‰ä¸€ä¸ªç®€å•çš„æ–¹æ³•å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°çš„æ›´å¤§çš„
    `NumList`ï¼šåªéœ€ä½¿ç”¨ `nl-link`ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘æ›´å¤§çš„åˆ—è¡¨ï¼š
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 5.3.1Â Functions to Process Recursive Data[ğŸ”—](#(part._.Functions_to_.Process_.Recursive_.Data)
    "Link to here")
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1 å¤„ç†é€’å½’æ•°æ®å‡½æ•°[ğŸ”—](#(part._.Functions_to_.Process_.Recursive_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Letâ€™s try to write a function `contains-3`, which returns `true` if the `NumList`
    contains the value `3`, and `false` otherwise.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°è¯•ç¼–å†™ä¸€ä¸ªå‡½æ•° `contains-3`ï¼Œå¦‚æœ `NumList` åŒ…å«å€¼ `3`ï¼Œåˆ™è¿”å› `true`ï¼Œå¦åˆ™è¿”å› `false`ã€‚
- en: 'First, our header:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬çš„æ ‡é¢˜ï¼š
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, some tests:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œä¸€äº›æµ‹è¯•ï¼š
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we did in [Processing Fields of Variants](intro-struct-data.html#%28part._process-fields-variants%29),
    we will use `cases` to distinguish the variants. In addition, since we are going
    to have to use the fields of `nl-link` to compute a result in that case, we will
    list those in the initial code outline:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬åœ¨ [å¤„ç†å˜ä½“å­—æ®µ](intro-struct-data.html#%28part._process-fields-variants%29) ä¸­æ‰€åšçš„é‚£æ ·ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨
    `cases` æ¥åŒºåˆ†å˜ä½“ã€‚æ­¤å¤–ï¼Œç”±äºæˆ‘ä»¬å°†åœ¨é‚£ç§æƒ…å†µä¸‹ä½¿ç”¨ `nl-link` çš„å­—æ®µæ¥è®¡ç®—ç»“æœï¼Œæˆ‘ä»¬å°†åœ¨åˆå§‹ä»£ç æ¦‚è¦ä¸­åˆ—å‡ºè¿™äº›å­—æ®µï¼š
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Following our examples, the answer must be false in the `nl-empty` case. In
    the `nl-link` case, if the `first` element is `3`, weâ€™ve successfully answered
    the question. That only leaves the case where the argument is an `nl-link` and
    the first element does not equal `3`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: æŒ‰ç…§æˆ‘ä»¬çš„ä¾‹å­ï¼Œåœ¨ `nl-empty` çš„æƒ…å†µä¸‹ç­”æ¡ˆå¿…é¡»æ˜¯ `false`ã€‚åœ¨ `nl-link` çš„æƒ…å†µä¸‹ï¼Œå¦‚æœ `first` å…ƒç´ æ˜¯ `3`ï¼Œæˆ‘ä»¬å°±æˆåŠŸåœ°å›ç­”äº†é—®é¢˜ã€‚è¿™åªå‰©ä¸‹ä¸€ç§æƒ…å†µï¼Œå³å‚æ•°æ˜¯ä¸€ä¸ª
    `nl-link` ä¸”ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ç­‰äº `3`ï¼š
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since we know `rest` is a `NumList` (based on the data definition), we can
    use a `cases` expression to work with it. This is sort of like filling in a part
    of the template again:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæˆ‘ä»¬çŸ¥é“ `rest` æ˜¯ä¸€ä¸ª `NumList`ï¼ˆåŸºäºæ•°æ®å®šä¹‰ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `cases` è¡¨è¾¾å¼æ¥å¤„ç†å®ƒã€‚è¿™æœ‰ç‚¹åƒå†æ¬¡å¡«å†™æ¨¡æ¿çš„ä¸€éƒ¨åˆ†ï¼š
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the `rest` was empty, then we havenâ€™t found `3` (just like when we checked
    the original argument, `nl`). If the `rest` was a `nl-link`, then we need to check
    if the first thing in the rest of the list is `3` or not:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœ `rest` æ˜¯ç©ºçš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ²¡æœ‰æ‰¾åˆ° `3`ï¼ˆå°±åƒå½“æˆ‘ä»¬æ£€æŸ¥åŸå§‹å‚æ•° `nl` æ—¶ä¸€æ ·ï¼‰ã€‚å¦‚æœ `rest` æ˜¯ä¸€ä¸ª `nl-link`ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦æ£€æŸ¥åˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„ç¬¬ä¸€é¡¹æ˜¯å¦æ˜¯
    `3`ï¼š
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since `rest-of-rest` is a `NumList`, we can fill in a `cases` for it again:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äº `rest-of-rest` æ˜¯ä¸€ä¸ª `NumList`ï¼Œæˆ‘ä»¬å¯ä»¥å†æ¬¡ä¸ºå®ƒå¡«å†™ä¸€ä¸ª `cases`ï¼š
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See where this is going? Not anywhere good. We can copy this `cases` expression
    as many times as we want, but we can never answer the question for a list that
    is just one element longer than the number of times we copy the code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹çœ‹è¿™ä¼šèµ°å‘ä½•æ–¹ï¼Ÿå¹¶ä¸æ˜¯ä¸€ä¸ªå¥½åœ°æ–¹ã€‚æˆ‘ä»¬å¯ä»¥åƒå¤åˆ¶ `cases` è¡¨è¾¾å¼ä¸€æ ·å¤šæ¬¡å¤åˆ¶ï¼Œä½†æˆ‘ä»¬æ°¸è¿œæ— æ³•å›ç­”æ¯”æˆ‘ä»¬å¤åˆ¶ä»£ç æ¬¡æ•°å¤šä¸€ä¸ªå…ƒç´ çš„åˆ—è¡¨çš„é—®é¢˜ã€‚
- en: So what to do? We tried this approach of using another copy of `cases` based
    on the observation that `rest` is a `NumList`, and `cases` provides a meaningful
    way to break apart a `NumList`; in fact, itâ€™s what the recipe seems to lead to
    naturally.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£æˆ‘ä»¬è¯¥æ€ä¹ˆåŠï¼Ÿæˆ‘ä»¬å°è¯•äº†åŸºäºè§‚å¯Ÿ `rest` æ˜¯ä¸€ä¸ª `NumList`ï¼Œå¹¶ä¸” `cases` æä¾›äº†ä¸€ç§æœ‰æ„ä¹‰çš„æ–¹å¼æ¥åˆ†è§£ `NumList` çš„æ–¹æ³•ï¼Œè¿™ç§æ–¹æ³•ï¼šå®é™…ä¸Šï¼Œè¿™æ­£æ˜¯é…æ–¹è‡ªç„¶å¼•å¯¼æˆ‘ä»¬èµ°å‘çš„æ–¹å‘ã€‚
- en: 'Letâ€™s go back to the step where the problem began, after filling in the template
    with the first check for `3`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å›åˆ°é—®é¢˜å¼€å§‹çš„åœ°æ–¹ï¼Œåœ¨ç”¨ `3` çš„ç¬¬ä¸€æ¬¡æ£€æŸ¥å¡«å†™æ¨¡æ¿ä¹‹åï¼š
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We need a way to compute whether or not the value `3` is contained in `rest`.
    Looking back at the data definition, we see that `rest` is a perfectly valid `NumList`,
    simply by the definition of `nl-link`. And we have a function (or, most of one)
    whose job is to figure out if a `NumList` contains `3` or not: `contains-3`. That
    ought to be something we can call with `rest` as an argument, and get back the
    value we want:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹æ³•æ¥è®¡ç®—å€¼ `3` æ˜¯å¦åŒ…å«åœ¨ `rest` ä¸­ã€‚å›é¡¾æ•°æ®å®šä¹‰ï¼Œæˆ‘ä»¬çœ‹åˆ° `rest` æ˜¯ä¸€ä¸ªå®Œå…¨æœ‰æ•ˆçš„ `NumList`ï¼Œä»…ä»…æ ¹æ® `nl-link`
    çš„å®šä¹‰ã€‚æˆ‘ä»¬æœ‰ä¸€ä¸ªå‡½æ•°ï¼ˆæˆ–è€…ï¼Œå¤§éƒ¨åˆ†æ˜¯ï¼‰å…¶ä»»åŠ¡æ˜¯ç¡®å®šä¸€ä¸ª `NumList` æ˜¯å¦åŒ…å« `3`ï¼š`contains-3`ã€‚è¿™åº”è¯¥æ˜¯æˆ‘ä»¬å¯ä»¥ç”¨ `rest`
    ä½œä¸ºå‚æ•°è°ƒç”¨çš„ä¸œè¥¿ï¼Œå¹¶å¾—åˆ°æˆ‘ä»¬æƒ³è¦çš„ç»“æœï¼š
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And lo and behold, all of the tests defined above pass. Itâ€™s useful to step
    through whatâ€™s happening when this function is called. Letâ€™s look at an example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹çœ‹å‘ç”Ÿäº†ä»€ä¹ˆï¼Œæ‰€æœ‰çš„æµ‹è¯•éƒ½é€šè¿‡äº†ã€‚å½“è¿™ä¸ªå‡½æ•°è¢«è°ƒç”¨æ—¶ï¼Œäº†è§£æ­£åœ¨å‘ç”Ÿçš„äº‹æƒ…æ˜¯æœ‰ç”¨çš„ã€‚è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªä¾‹å­ï¼š
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we substitute the argument value in place of `nl` everywhere it appears;
    thatâ€™s just the usual rule for function calls.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬å°†å‚æ•°å€¼æ›¿æ¢åˆ° `nl` å‡ºç°çš„æ‰€æœ‰åœ°æ–¹ï¼›è¿™åªæ˜¯å‡½æ•°è°ƒç”¨çš„å¸¸è§„è§„åˆ™ã€‚
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we find the case that matches the constructor `nl-link`, and substitute
    the corresponding pieces of the `nl-link` value for the `first` and `rest` identifiers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ‰¾åˆ°ä¸æ„é€ å‡½æ•° `nl-link` åŒ¹é…çš„æ¡ˆä¾‹ï¼Œå¹¶å°† `nl-link` å€¼çš„ç›¸åº”éƒ¨åˆ†æ›¿æ¢ä¸º `first` å’Œ `rest` æ ‡è¯†ç¬¦ã€‚
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since `1` isnâ€™t `3`, the comparison evaluates to `false`, and this whole expression
    evaluates to the contents of the `else` branch.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äº `1` ä¸ç­‰äº `3`ï¼Œæ¯”è¾ƒè¯„ä¼°ä¸º `false`ï¼Œæ•´ä¸ªè¡¨è¾¾å¼è¯„ä¼°ä¸º `else` åˆ†æ”¯çš„å†…å®¹ã€‚
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is another function call, so we substitute the value `nl-link(3, nl-empty)`,
    which was the `rest` field of the original input, into the body of `contains-3`
    this time.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åˆæ˜¯ä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿™æ¬¡å°†åŸå§‹è¾“å…¥çš„ `rest` å­—æ®µ `nl-link(3, nl-empty)` æ›¿æ¢åˆ° `contains-3` çš„ä¸»ä½“ä¸­ã€‚
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Again, we substitute into the `nl-link` branch.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡ï¼Œæˆ‘ä»¬å°†å€¼æ›¿æ¢åˆ° `nl-link` åˆ†æ”¯ä¸­ã€‚
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This time, since `3` is `3`, we take the first branch of the `if` expression,
    and the whole original call evaluates to `true`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ¬¡ï¼Œç”±äº `3` ç­‰äº `3`ï¼Œæˆ‘ä»¬é€‰æ‹©äº† `if` è¡¨è¾¾å¼çš„ç¬¬ä¸€ä¸ªåˆ†æ”¯ï¼Œæ•´ä¸ªåŸå§‹è°ƒç”¨è¯„ä¼°ä¸º `true`ã€‚
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: An interesting feature of this trace through the evaluation is that we reached
    the expression `contains-3(nl-link(3, nl-empty))`, which is a normal call to `contains-3`;
    it could even be a test case on its own. The implementation works by doing something
    (checking for equality with `3`) with the non-recursive parts of the datum, and
    combining that result with the result of the same operation (`contains-3`) on
    the recursive part of the datum. This idea of doing recursion with the same function
    on self-recursive parts of the datatype lets us extend our template to handle
    recursive fields.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªè¯„ä¼°è¿‡ç¨‹ä¸­ï¼Œä¸€ä¸ªæœ‰è¶£çš„ç‰¹ç‚¹æ˜¯æˆ‘ä»¬è¾¾åˆ°äº†è¡¨è¾¾å¼ `contains-3(nl-link(3, nl-empty))`ï¼Œè¿™æ˜¯ä¸€ä¸ªå¯¹ `contains-3`
    çš„æ­£å¸¸è°ƒç”¨ï¼›å®ƒç”šè‡³å¯ä»¥ä½œä¸ºä¸€ä¸ªç‹¬ç«‹çš„æµ‹è¯•ç”¨ä¾‹ã€‚å®ç°æ–¹å¼æ˜¯é€šè¿‡å¯¹æ•°æ®çš„ä¸é€’å½’éƒ¨åˆ†è¿›è¡ŒæŸç§æ“ä½œï¼ˆæ£€æŸ¥ä¸ `3` æ˜¯å¦ç›¸ç­‰ï¼‰ï¼Œå¹¶å°†è¯¥ç»“æœä¸å¯¹æ•°æ®é€’å½’éƒ¨åˆ†è¿›è¡Œç›¸åŒæ“ä½œï¼ˆ`contains-3`ï¼‰çš„ç»“æœç›¸ç»“åˆã€‚è¿™ç§åœ¨æ•°æ®ç±»å‹çš„è‡ªé€’å½’éƒ¨åˆ†ä¸Šä½¿ç”¨ç›¸åŒå‡½æ•°è¿›è¡Œé€’å½’çš„æƒ³æ³•ä½¿æˆ‘ä»¬èƒ½å¤Ÿæ‰©å±•æˆ‘ä»¬çš„æ¨¡æ¿ä»¥å¤„ç†é€’å½’å­—æ®µã€‚
- en: 5.3.2Â A Template for Processing Recursive Data[ğŸ”—](#(part._.A_.Template_for_.Processing_.Recursive_.Data)
    "Link to here")
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.2Â å¤„ç†é€’å½’æ•°æ®çš„æ¨¡æ¿[ğŸ”—](#(part._.A_.Template_for_.Processing_.Recursive_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Stepping back, we have actually derived a new way to approach writing functions
    over recursive data. Back in [Processing Lists](processing-lists.html), we had
    you write functions over lists by writing a sequence of related examples, using
    substitution across examples to derive a program that called the function on the
    rest of the list. Here, we are deriving that structure from the shape of the data
    itself.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: å›é¡¾ä¸€ä¸‹ï¼Œæˆ‘ä»¬å®é™…ä¸Šæ¨å¯¼å‡ºäº†ä¸€ç§æ–°çš„æ–¹æ³•æ¥ç¼–å†™é€’å½’æ•°æ®ä¸Šçš„å‡½æ•°ã€‚åœ¨ [å¤„ç†åˆ—è¡¨](processing-lists.html) ä¸­ï¼Œæˆ‘ä»¬è®©ä½ é€šè¿‡ç¼–å†™ä¸€ç³»åˆ—ç›¸å…³ç¤ºä¾‹ï¼Œä½¿ç”¨ç¤ºä¾‹ä¹‹é—´çš„æ›¿æ¢æ¥æ¨å¯¼å‡ºä¸€ä¸ªè°ƒç”¨åˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„å‡½æ•°çš„ç¨‹åºæ¥ç¼–å†™åˆ—è¡¨ä¸Šçš„å‡½æ•°ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬æ˜¯æ ¹æ®æ•°æ®çš„å½¢çŠ¶æ¨å¯¼å‡ºè¿™ç§ç»“æ„çš„ã€‚
- en: 'In particular, we can develop a function over recursive data by breaking a
    datum into its variants (using `cases`), pulling out the fields of each variant
    (by listing the field names), then calling the function itself on any recursive
    fields (fields of the same type). For `NumList`, these steps yield the following
    code outline:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: å°¤å…¶æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†æ•°æ®åˆ†è§£ä¸ºå…¶å˜ä½“ï¼ˆä½¿ç”¨ `cases`ï¼‰ï¼Œæå–æ¯ä¸ªå˜ä½“çš„å­—æ®µï¼ˆé€šè¿‡åˆ—å‡ºå­—æ®µåç§°ï¼‰ï¼Œç„¶ååœ¨ä»»ä½•é€’å½’å­—æ®µï¼ˆåŒç±»å‹çš„å­—æ®µï¼‰ä¸Šè°ƒç”¨å‡½æ•°æœ¬èº«æ¥å¼€å‘ä¸€ä¸ªé€’å½’æ•°æ®ä¸Šçš„å‡½æ•°ã€‚å¯¹äº
    `NumList`ï¼Œè¿™äº›æ­¥éª¤äº§ç”Ÿä»¥ä¸‹ä»£ç æ¦‚è¦ï¼š
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we are using a generic function name, `num-list-fun`, to illustrate that
    this is the outline for any function that processes a `NumList`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªé€šç”¨å‡½æ•°å `num-list-fun` æ¥è¯´æ˜è¿™æ˜¯å¤„ç† `NumList` çš„ä»»ä½•å‡½æ•°çš„æ¦‚è¦ã€‚
- en: We refer to this code outline as a template. Every `data` definition has a corresponding
    template which captures how to break a value of that definition into cases, pull
    out the fields, and use the same function to process any recursive fields.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†è¿™ä¸ªä»£ç æ¦‚è¦ç§°ä¸ºæ¨¡æ¿ã€‚æ¯ä¸ª `data` å®šä¹‰éƒ½æœ‰ä¸€ä¸ªç›¸åº”çš„æ¨¡æ¿ï¼Œå®ƒæ•è·äº†å¦‚ä½•å°†å®šä¹‰çš„å€¼åˆ†è§£ä¸ºæ¡ˆä¾‹ï¼Œæå–å­—æ®µï¼Œå¹¶ä½¿ç”¨ç›¸åŒçš„å‡½æ•°å¤„ç†ä»»ä½•é€’å½’å­—æ®µã€‚
- en: 'Strategy: Writing a Template for Recursive Data'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç­–ç•¥ï¼šä¸ºé€’å½’æ•°æ®ç¼–å†™æ¨¡æ¿
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given a recursive data definition, use the following steps to create the (reusable)
    template for that definition:'
  id: totrans-70
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªé€’å½’æ•°æ®å®šä¹‰ï¼Œä½¿ç”¨ä»¥ä¸‹æ­¥éª¤åˆ›å»ºè¯¥å®šä¹‰çš„ï¼ˆå¯é‡ç”¨ï¼‰æ¨¡æ¿ï¼š
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a function header (using a general-purpose placeholder name if you arenâ€™t
    yet writing a specific function).
  id: totrans-72
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªå‡½æ•°å¤´ï¼ˆå¦‚æœä½ è¿˜æ²¡æœ‰ç¼–å†™ç‰¹å®šå‡½æ•°ï¼Œå¯ä»¥ä½¿ç”¨é€šç”¨å ä½ç¬¦åç§°ï¼‰ã€‚
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Use `cases` to break the recursive-data input into its variants.
  id: totrans-75
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ `cases` å°†é€’å½’æ•°æ®è¾“å…¥åˆ†è§£ä¸ºå…¶å˜ä½“ã€‚
- en: ''
  id: totrans-76
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: In each case, list each of its fields in the answer portion of the case.
  id: totrans-78
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨æ¯ç§æƒ…å†µä¸‹ï¼Œåˆ—å‡ºå…¶ç­”æ¡ˆéƒ¨åˆ†çš„æ¯ä¸ªå­—æ®µã€‚
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-80
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Call the function itself on any recursive fields.
  id: totrans-81
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨ä»»ä½•é€’å½’å­—æ®µä¸Šè°ƒç”¨å‡½æ•°æœ¬èº«ã€‚
- en: The power of the template lies in its universality. If you are asked to write
    a specific function (such as `contains-3`) over recursive data (`NumList`), you
    can reproduce or copy (if you already wrote it down) the template, replace the
    generic function name in the template with the one for your specific function,
    then fill in the ellipses to finish the function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: æ¨¡æ¿çš„åŠ›é‡åœ¨äºå…¶é€šç”¨æ€§ã€‚å¦‚æœä½ è¢«è¦æ±‚åœ¨é€’å½’æ•°æ®ï¼ˆå¦‚`NumList`ï¼‰ä¸Šç¼–å†™ä¸€ä¸ªç‰¹å®šå‡½æ•°ï¼ˆä¾‹å¦‚`contains-3`ï¼‰ï¼Œä½ å¯ä»¥å¤åˆ¶æˆ–å¤åˆ¶ï¼ˆå¦‚æœä½ å·²ç»å†™ä¸‹äº†å®ƒï¼‰æ¨¡æ¿ï¼Œå°†æ¨¡æ¿ä¸­çš„é€šç”¨å‡½æ•°åæ›¿æ¢ä¸ºä½ çš„ç‰¹å®šå‡½æ•°ï¼Œç„¶åå¡«å†™çœç•¥å·ä»¥å®Œæˆå‡½æ•°ã€‚
- en: When you see a recursive data definition (of which there will be many when programming
    in Pyret), you should naturally start thinking about what the recursive calls
    will return and how to combine their results with the other, non-recursive pieces
    of the datatype.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ çœ‹åˆ°é€’å½’æ•°æ®å®šä¹‰ï¼ˆåœ¨ç”¨Pyretç¼–ç¨‹æ—¶ä¼šæœ‰å¾ˆå¤šï¼‰æ—¶ï¼Œä½ åº”è¯¥è‡ªç„¶è€Œç„¶åœ°å¼€å§‹æ€è€ƒé€’å½’è°ƒç”¨å°†è¿”å›ä»€ä¹ˆï¼Œä»¥åŠå¦‚ä½•å°†å®ƒä»¬çš„ç»“æœä¸å…¶ä»–éé€’å½’çš„æ•°æ®ç±»å‹éƒ¨åˆ†ç»“åˆèµ·æ¥ã€‚
- en: 'You have now seen two approaches to writing functions on recursive data: working
    out a sequence of related examples and modifying the template. Both approaches
    get you to the same final function. The power of the template, however, is that
    it scales to more complicated data definitions (where writing examples by hand
    would prove tedious). We will see examples of this as our data get more complex
    in coming chapters.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ ç°åœ¨å·²ç»çœ‹åˆ°äº†ä¸¤ç§åœ¨é€’å½’æ•°æ®ä¸Šç¼–å†™å‡½æ•°çš„æ–¹æ³•ï¼šåˆ¶å®šä¸€ç³»åˆ—ç›¸å…³ç¤ºä¾‹å’Œä¿®æ”¹æ¨¡æ¿ã€‚è¿™ä¸¤ç§æ–¹æ³•éƒ½èƒ½è®©ä½ å¾—åˆ°ç›¸åŒçš„æœ€ç»ˆå‡½æ•°ã€‚ç„¶è€Œï¼Œæ¨¡æ¿çš„å¼ºå¤§ä¹‹å¤„åœ¨äºå®ƒèƒ½å¤Ÿæ‰©å±•åˆ°æ›´å¤æ‚çš„æ•°æ®å®šä¹‰ï¼ˆæ‰‹åŠ¨ç¼–å†™ç¤ºä¾‹å¯èƒ½ä¼šå˜å¾—ç¹çï¼‰ã€‚éšç€æˆ‘ä»¬åœ¨æ¥ä¸‹æ¥çš„ç« èŠ‚ä¸­æ•°æ®å˜å¾—æ›´åŠ å¤æ‚ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°è¿™æ–¹é¢çš„ä¾‹å­ã€‚
- en: 5.3.3Â The Design Recipe[ğŸ”—](#(part._.The_.Design_.Recipe) "Link to here")
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.3Â è®¾è®¡é£Ÿè°±[ğŸ”—](#(part._.The_.Design_.Recipe) "é“¾æ¥è‡³æ­¤")
- en: Weâ€™ve showed you many techniques to use while designing programs, including
    developing examples, writing tests, and now writing and using data templates.
    Putting the pieces together yields a design recipe, adapted from that in [How
    to Design Programs](https://htdp.org/), that we can follow for designing recursive
    functions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»å‘ä½ å±•ç¤ºäº†åœ¨è®¾è®¡ç¨‹åºæ—¶å¯ä»¥ä½¿ç”¨è®¸å¤šæŠ€æœ¯ï¼ŒåŒ…æ‹¬å¼€å‘ç¤ºä¾‹ã€ç¼–å†™æµ‹è¯•ï¼Œä»¥åŠç°åœ¨ç¼–å†™å’Œä½¿ç”¨æ•°æ®æ¨¡æ¿ã€‚å°†è¿™äº›éƒ¨åˆ†ç»„åˆèµ·æ¥ï¼Œæˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªè®¾è®¡é£Ÿè°±ï¼Œå®ƒæ”¹ç¼–è‡ª[å¦‚ä½•è®¾è®¡ç¨‹åº](https://htdp.org/)ä¸­çš„é£Ÿè°±ï¼Œæˆ‘ä»¬å¯ä»¥éµå¾ªå®ƒæ¥è®¾è®¡é€’å½’å‡½æ•°ã€‚
- en: 'Strategy: The Design Recipe'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç­–ç•¥ï¼šè®¾è®¡é£Ÿè°±
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given a programming problem over recursive data:'
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªå…³äºé€’å½’æ•°æ®çš„ç¼–ç¨‹é—®é¢˜ï¼š
- en: ''
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a function header, including the function name and contract. The name
    will be necessary to make recursive calls, while the contract guides the design
    of the body.
  id: totrans-91
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªå‡½æ•°å¤´ï¼ŒåŒ…æ‹¬å‡½æ•°åå’Œå¥‘çº¦ã€‚åç§°å¯¹äºè¿›è¡Œé€’å½’è°ƒç”¨æ˜¯å¿…è¦çš„ï¼Œè€Œå¥‘çº¦æŒ‡å¯¼ç€ä¸»ä½“çš„è®¾è®¡ã€‚
- en: ''
  id: totrans-92
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Aided by the contract, which tells you what kind of data to consume and produce,
    write several illustrative examples of the functionâ€™s input and outputs, using
    concrete data. Include examples in which the input data of one extends the input
    data of another. This will later help you fill in the function.
  id: totrans-94
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨å¥‘çº¦çš„å¸®åŠ©ä¸‹ï¼Œå®ƒå‘Šè¯‰ä½ åº”è¯¥æ¶ˆè´¹å’Œäº§ç”Ÿä»€ä¹ˆç±»å‹çš„æ•°æ®ï¼Œä½¿ç”¨å…·ä½“æ•°æ®ç¼–å†™å‡ ä¸ªè¯´æ˜æ€§çš„å‡½æ•°è¾“å…¥å’Œè¾“å‡ºç¤ºä¾‹ã€‚åŒ…æ‹¬é‚£äº›ä¸€ä¸ªè¾“å…¥æ•°æ®æ‰©å±•å¦ä¸€ä¸ªè¾“å…¥æ•°æ®çš„ç¤ºä¾‹ã€‚è¿™å°†åœ¨ä½ å¡«å……å‡½æ•°æ—¶æœ‰æ‰€å¸®åŠ©ã€‚
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-96
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The functionâ€™s contract tells you what kind of data you are processing. From
    the definition of the data, write out the template for it.
  id: totrans-97
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: å‡½æ•°çš„å¥‘çº¦å‘Šè¯‰ä½ ä½ æ­£åœ¨å¤„ç†ä»€ä¹ˆç±»å‹çš„æ•°æ®ã€‚ä»æ•°æ®çš„å®šä¹‰ä¸­ï¼Œä¸ºå®ƒç¼–å†™ä¸€ä¸ªæ¨¡æ¿ã€‚
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Adapt this template to the computation required by this specific problem. Use
    your examples to figure out how to fill in each case. You should have written
    an example for each case of data in the template. This is also where writing examples
    where input extended the other helps: the difference in output becomes the function
    body. See the several examples of this in [Processing Lists](processing-lists.html).'
  id: totrans-100
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: å°†æ­¤æ¨¡æ¿é€‚åº”äºè¯¥ç‰¹å®šé—®é¢˜çš„è®¡ç®—éœ€æ±‚ã€‚ä½¿ç”¨ä½ çš„ç¤ºä¾‹æ¥ç¡®å®šå¦‚ä½•å¡«å……æ¯ä¸ªæ¡ˆä¾‹ã€‚ä½ åº”è¯¥ä¸ºæ¨¡æ¿ä¸­çš„æ¯ä¸ªæ•°æ®æ¡ˆä¾‹ç¼–å†™äº†ä¸€ä¸ªç¤ºä¾‹ã€‚è¿™ä¹Ÿæ˜¯ç¼–å†™æ‰©å±•å…¶ä»–è¾“å…¥çš„ç¤ºä¾‹æœ‰å¸®åŠ©çš„åœ°æ–¹ï¼šè¾“å‡ºä¹‹é—´çš„å·®å¼‚å°±æ˜¯å‡½æ•°ä½“ã€‚è¯·å‚è§[å¤„ç†åˆ—è¡¨](processing-lists.html)ä¸­çš„å‡ ä¸ªæ­¤ç±»ç¤ºä¾‹ã€‚
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Run your examples to make sure your function behaves as you expect.
  id: totrans-103
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¿è¡Œä½ çš„ç¤ºä¾‹ä»¥ç¡®ä¿ä½ çš„å‡½æ•°è¡¨ç°å¦‚ä½ æ‰€é¢„æœŸã€‚
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Now start writing more fine-grained tests to confirm that you should be confident
    in your function. In particular, while the examples (which were written before
    you wrote the body of the function) focus on the expected â€œinput-outputâ€ behavior,
    now that you have a concrete implementation, you should write tests that focus
    on its details.
  id: totrans-106
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: ç°åœ¨å¼€å§‹ç¼–å†™æ›´ç²¾ç»†çš„æµ‹è¯•æ¥ç¡®è®¤ä½ åº”è¯¥å¯¹ä½ çš„å‡½æ•°æœ‰ä¿¡å¿ƒã€‚ç‰¹åˆ«æ˜¯ï¼Œè™½ç„¶ç¤ºä¾‹ï¼ˆåœ¨ä½ ç¼–å†™å‡½æ•°ä½“ä¹‹å‰ç¼–å†™ï¼‰ä¾§é‡äºé¢„æœŸçš„â€œè¾“å…¥-è¾“å‡ºâ€è¡Œä¸ºï¼Œä½†ç°åœ¨ä½ æœ‰äº†å…·ä½“çš„å®ç°ï¼Œä½ åº”è¯¥ç¼–å†™ä¾§é‡äºå…¶ç»†èŠ‚çš„æµ‹è¯•ã€‚
- en: Exercise
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the design recipe to write a function `contains-n` that takes a `NumList`
    and a `Number`, and returns whether that number is in the `NumList`.
  id: totrans-109
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è®¾è®¡é…æ–¹ç¼–å†™ä¸€ä¸ªå‡½æ•°`contains-n`ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ª`NumList`å’Œä¸€ä¸ª`Number`ï¼Œå¹¶è¿”å›è¯¥æ•°å­—æ˜¯å¦åœ¨`NumList`ä¸­ã€‚
- en: Exercise
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the design recipe to write a function `sum` that takes a `NumList`, and
    returns the sum of all the numbers in it. The sum of the empty list is `0`.
  id: totrans-112
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è®¾è®¡é…æ–¹ç¼–å†™ä¸€ä¸ªå‡½æ•°`sum`ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ª`NumList`ï¼Œå¹¶è¿”å›å…¶ä¸­æ‰€æœ‰æ•°å­—çš„æ€»å’Œã€‚ç©ºåˆ—è¡¨çš„æ€»å’Œæ˜¯`0`ã€‚
- en: Exercise
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the design recipe to write a function `remove-3` that takes a `NumList`,
    and returns a new `NumList` with any `3`â€™s removed. The remaining elements should
    all be in the list in the same order they were in the input.
  id: totrans-115
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è®¾è®¡é…æ–¹ç¼–å†™ä¸€ä¸ªå‡½æ•°`remove-3`ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ª`NumList`ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ–°`NumList`ï¼Œå…¶ä¸­ä»»ä½•`3`éƒ½è¢«ç§»é™¤ã€‚å‰©ä½™çš„å…ƒç´ åº”æŒ‰è¾“å…¥ä¸­çš„ç›¸åŒé¡ºåºæ’åˆ—ã€‚
- en: Exercise
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a data definition called `NumListList` that represents a list of `NumList`s,
    and use the design recipe to write a function `sum-of-lists` that takes a `NumListList`
    and produces a `NumList` containing the sums of the sub-lists.
  id: totrans-118
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªåä¸º`NumListList`çš„æ•°æ®å®šä¹‰ï¼Œè¡¨ç¤º`NumList`çš„åˆ—è¡¨ï¼Œå¹¶ä½¿ç”¨è®¾è®¡é…æ–¹ç¼–å†™ä¸€ä¸ªå‡½æ•°`sum-of-lists`ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ª`NumListList`å¹¶ç”Ÿæˆä¸€ä¸ªåŒ…å«å­åˆ—è¡¨æ€»å’Œçš„`NumList`ã€‚
- en: Exercise
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a data definition and corresponding template for `StrList`, which captures
    lists of strings.
  id: totrans-121
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªåä¸º`StrList`çš„æ•°æ®å®šä¹‰åŠå…¶ç›¸åº”çš„æ¨¡æ¿ï¼Œä»¥æ•è·å­—ç¬¦ä¸²åˆ—è¡¨ã€‚
- en: 5.3.1Â Functions to Process Recursive Data[ğŸ”—](#(part._.Functions_to_.Process_.Recursive_.Data)
    "Link to here")
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1Â å¤„ç†é€’å½’æ•°æ®å‡½æ•°[ğŸ”—](#(part._.Functions_to_.Process_.Recursive_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Letâ€™s try to write a function `contains-3`, which returns `true` if the `NumList`
    contains the value `3`, and `false` otherwise.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°è¯•ç¼–å†™ä¸€ä¸ªå‡½æ•°`contains-3`ï¼Œè¯¥å‡½æ•°è¿”å›`true`å¦‚æœ`NumList`åŒ…å«å€¼`3`ï¼Œå¦åˆ™è¿”å›`false`ã€‚
- en: 'First, our header:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬çš„æ ‡é¢˜ï¼š
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, some tests:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œè¿›è¡Œä¸€äº›æµ‹è¯•ï¼š
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As we did in [Processing Fields of Variants](intro-struct-data.html#%28part._process-fields-variants%29),
    we will use `cases` to distinguish the variants. In addition, since we are going
    to have to use the fields of `nl-link` to compute a result in that case, we will
    list those in the initial code outline:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬åœ¨[å¤„ç†å˜ä½“å­—æ®µ](intro-struct-data.html#%28part._process-fields-variants%29)ä¸­æ‰€åšçš„é‚£æ ·ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨`cases`æ¥åŒºåˆ†å˜ä½“ã€‚æ­¤å¤–ï¼Œç”±äºæˆ‘ä»¬å°†åœ¨é‚£ç§æƒ…å†µä¸‹ä½¿ç”¨`nl-link`çš„å­—æ®µæ¥è®¡ç®—ç»“æœï¼Œæˆ‘ä»¬å°†åœ¨åˆå§‹ä»£ç æ¦‚è¦ä¸­åˆ—å‡ºè¿™äº›å­—æ®µï¼š
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Following our examples, the answer must be false in the `nl-empty` case. In
    the `nl-link` case, if the `first` element is `3`, weâ€™ve successfully answered
    the question. That only leaves the case where the argument is an `nl-link` and
    the first element does not equal `3`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: æŒ‰ç…§æˆ‘ä»¬çš„ç¤ºä¾‹ï¼Œ`nl-empty`æƒ…å†µä¸‹çš„ç­”æ¡ˆå¿…é¡»æ˜¯é”™è¯¯çš„ã€‚åœ¨`nl-link`æƒ…å†µä¸‹ï¼Œå¦‚æœç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯`3`ï¼Œæˆ‘ä»¬å°±æˆåŠŸå›ç­”äº†é—®é¢˜ã€‚åªå‰©ä¸‹ä¸€ç§æƒ…å†µï¼Œå³å‚æ•°æ˜¯ä¸€ä¸ª`nl-link`ä¸”ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ç­‰äº`3`ï¼š
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since we know `rest` is a `NumList` (based on the data definition), we can
    use a `cases` expression to work with it. This is sort of like filling in a part
    of the template again:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæˆ‘ä»¬çŸ¥é“`rest`æ˜¯ä¸€ä¸ª`NumList`ï¼ˆåŸºäºæ•°æ®å®šä¹‰ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ª`cases`è¡¨è¾¾å¼æ¥å¤„ç†å®ƒã€‚è¿™æœ‰ç‚¹åƒå†æ¬¡å¡«å†™æ¨¡æ¿çš„ä¸€éƒ¨åˆ†ï¼š
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the `rest` was empty, then we havenâ€™t found `3` (just like when we checked
    the original argument, `nl`). If the `rest` was a `nl-link`, then we need to check
    if the first thing in the rest of the list is `3` or not:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœ`rest`ä¸ºç©ºï¼Œé‚£ä¹ˆæˆ‘ä»¬æ²¡æœ‰æ‰¾åˆ°`3`ï¼ˆå°±åƒå½“æˆ‘ä»¬æ£€æŸ¥åŸå§‹å‚æ•°`nl`æ—¶ä¸€æ ·ï¼‰ã€‚å¦‚æœ`rest`æ˜¯ä¸€ä¸ª`nl-link`ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦æ£€æŸ¥åˆ—è¡¨å‰©ä½™éƒ¨åˆ†ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¦æ˜¯`3`ï¼š
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since `rest-of-rest` is a `NumList`, we can fill in a `cases` for it again:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äº`rest-of-rest`æ˜¯ä¸€ä¸ª`NumList`ï¼Œæˆ‘ä»¬å¯ä»¥å†æ¬¡ä¸ºå®ƒå¡«å†™ä¸€ä¸ª`cases`ï¼š
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: See where this is going? Not anywhere good. We can copy this `cases` expression
    as many times as we want, but we can never answer the question for a list that
    is just one element longer than the number of times we copy the code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹çœ‹è¿™æ˜¯è¦å»å“ªé‡Œï¼Ÿæ ¹æœ¬ä¸æ˜¯ä»€ä¹ˆå¥½äº‹ã€‚æˆ‘ä»¬å¯ä»¥åƒæˆ‘ä»¬æƒ³è¦çš„é‚£æ ·å¤šæ¬¡å¤åˆ¶è¿™ä¸ª`cases`è¡¨è¾¾å¼ï¼Œä½†æˆ‘ä»¬æ°¸è¿œæ— æ³•å›ç­”æ¯”æˆ‘ä»¬å¤åˆ¶ä»£ç æ¬¡æ•°å¤šä¸€ä¸ªå…ƒç´ çš„åˆ—è¡¨çš„é—®é¢˜ã€‚
- en: So what to do? We tried this approach of using another copy of `cases` based
    on the observation that `rest` is a `NumList`, and `cases` provides a meaningful
    way to break apart a `NumList`; in fact, itâ€™s what the recipe seems to lead to
    naturally.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£è¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿæˆ‘ä»¬å°è¯•äº†è¿™ç§æ–¹æ³•ï¼Œå³ä½¿ç”¨å¦ä¸€ä¸ªåŸºäºè§‚å¯Ÿçš„`cases`å‰¯æœ¬ï¼Œè§‚å¯Ÿå‘ç°`rest`æ˜¯ä¸€ä¸ª`NumList`ï¼Œè€Œ`cases`æä¾›äº†ä¸€ç§æœ‰æ„ä¹‰çš„æ–¹å¼æ¥åˆ†è§£ä¸€ä¸ª`NumList`ï¼›å®é™…ä¸Šï¼Œè¿™æ­£æ˜¯é…æ–¹ä¼¼ä¹è‡ªç„¶å¼•å¯¼çš„æ–¹å‘ã€‚
- en: 'Letâ€™s go back to the step where the problem began, after filling in the template
    with the first check for `3`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å›åˆ°é—®é¢˜å¼€å§‹çš„åœ°æ–¹ï¼Œåœ¨ç”¨ç¬¬ä¸€ä¸ªå¯¹`3`çš„æ£€æŸ¥å¡«å†™æ¨¡æ¿ä¹‹åï¼š
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We need a way to compute whether or not the value `3` is contained in `rest`.
    Looking back at the data definition, we see that `rest` is a perfectly valid `NumList`,
    simply by the definition of `nl-link`. And we have a function (or, most of one)
    whose job is to figure out if a `NumList` contains `3` or not: `contains-3`. That
    ought to be something we can call with `rest` as an argument, and get back the
    value we want:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹æ³•æ¥è®¡ç®—å€¼`3`æ˜¯å¦åŒ…å«åœ¨`rest`ä¸­ã€‚å›é¡¾æ•°æ®å®šä¹‰ï¼Œæˆ‘ä»¬çœ‹åˆ°`rest`æ˜¯ä¸€ä¸ªå®Œå…¨æœ‰æ•ˆçš„`NumList`ï¼Œä»…é€šè¿‡`nl-link`çš„å®šä¹‰ã€‚æˆ‘ä»¬æœ‰ä¸€ä¸ªå‡½æ•°ï¼ˆæˆ–ï¼Œå¤§éƒ¨åˆ†æ˜¯ï¼‰çš„èŒè´£æ˜¯ç¡®å®š`NumList`æ˜¯å¦åŒ…å«`3`ï¼š`contains-3`ã€‚è¿™åº”è¯¥æ˜¯æˆ‘ä»¬å¯ä»¥ç”¨`rest`ä½œä¸ºå‚æ•°è°ƒç”¨çš„ä¸œè¥¿ï¼Œå¹¶å¾—åˆ°æˆ‘ä»¬æƒ³è¦çš„ä»·å€¼ï¼š
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And lo and behold, all of the tests defined above pass. Itâ€™s useful to step
    through whatâ€™s happening when this function is called. Letâ€™s look at an example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹çœ‹ï¼Œä¸Šé¢å®šä¹‰çš„æ‰€æœ‰æµ‹è¯•éƒ½é€šè¿‡äº†ã€‚å½“è¿™ä¸ªå‡½æ•°è¢«è°ƒç”¨æ—¶ï¼Œé€æ­¥æŸ¥çœ‹å‘ç”Ÿçš„äº‹æƒ…æ˜¯æœ‰ç”¨çš„ã€‚è®©æˆ‘ä»¬çœ‹çœ‹ä¸€ä¸ªä¾‹å­ï¼š
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, we substitute the argument value in place of `nl` everywhere it appears;
    thatâ€™s just the usual rule for function calls.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬å°†å‚æ•°å€¼æ›¿æ¢åˆ°`nl`å‡ºç°çš„æ‰€æœ‰åœ°æ–¹ï¼›è¿™åªæ˜¯å‡½æ•°è°ƒç”¨çš„å¸¸è§„è§„åˆ™ã€‚
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next, we find the case that matches the constructor `nl-link`, and substitute
    the corresponding pieces of the `nl-link` value for the `first` and `rest` identifiers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ç€ï¼Œæˆ‘ä»¬æ‰¾åˆ°ä¸æ„é€ å‡½æ•°`nl-link`åŒ¹é…çš„æƒ…å†µï¼Œå¹¶å°†ç›¸åº”çš„`nl-link`å€¼çš„éƒ¨åˆ†æ›¿æ¢åˆ°`first`å’Œ`rest`æ ‡è¯†ç¬¦ã€‚
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Since `1` isnâ€™t `3`, the comparison evaluates to `false`, and this whole expression
    evaluates to the contents of the `else` branch.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äº`1`ä¸ç­‰äº`3`ï¼Œæ¯”è¾ƒè¯„ä¼°ä¸º`false`ï¼Œæ•´ä¸ªè¡¨è¾¾å¼è¯„ä¼°ä¸º`else`åˆ†æ”¯çš„å†…å®¹ã€‚
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is another function call, so we substitute the value `nl-link(3, nl-empty)`,
    which was the `rest` field of the original input, into the body of `contains-3`
    this time.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åˆæ˜¯ä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿™æ¬¡å°†åŸå§‹è¾“å…¥çš„`rest`å­—æ®µå€¼`nl-link(3, nl-empty)`ä»£å…¥`contains-3`çš„ä¸»ä½“ä¸­ã€‚
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Again, we substitute into the `nl-link` branch.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡ï¼Œæˆ‘ä»¬å°†å€¼ä»£å…¥`nl-link`åˆ†æ”¯ã€‚
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This time, since `3` is `3`, we take the first branch of the `if` expression,
    and the whole original call evaluates to `true`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ¬¡ï¼Œç”±äº`3`ç­‰äº`3`ï¼Œæˆ‘ä»¬å–`if`è¡¨è¾¾å¼çš„ç¬¬ä¸€ä¸ªåˆ†æ”¯ï¼Œæ•´ä¸ªåŸå§‹è°ƒç”¨è¯„ä¼°ä¸º`true`ã€‚
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: An interesting feature of this trace through the evaluation is that we reached
    the expression `contains-3(nl-link(3, nl-empty))`, which is a normal call to `contains-3`;
    it could even be a test case on its own. The implementation works by doing something
    (checking for equality with `3`) with the non-recursive parts of the datum, and
    combining that result with the result of the same operation (`contains-3`) on
    the recursive part of the datum. This idea of doing recursion with the same function
    on self-recursive parts of the datatype lets us extend our template to handle
    recursive fields.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªè¯„ä¼°è¿‡ç¨‹ä¸­çš„ä¸€ä¸ªæœ‰è¶£ç‰¹ç‚¹æ˜¯ï¼Œæˆ‘ä»¬å¾—åˆ°äº†è¡¨è¾¾å¼`contains-3(nl-link(3, nl-empty))`ï¼Œè¿™æ˜¯ä¸€ä¸ªå¯¹`contains-3`çš„æ­£å¸¸è°ƒç”¨ï¼›å®ƒç”šè‡³å¯ä»¥ä½œä¸ºä¸€ä¸ªå•ç‹¬çš„æµ‹è¯•ç”¨ä¾‹ã€‚å®ç°æ–¹å¼æ˜¯é€šè¿‡å¯¹æ•°æ®çš„ä¸é€’å½’éƒ¨åˆ†è¿›è¡ŒæŸç§æ“ä½œï¼ˆæ£€æŸ¥ä¸`3`æ˜¯å¦ç›¸ç­‰ï¼‰ï¼Œå¹¶å°†è¯¥ç»“æœä¸å¯¹æ•°æ®é€’å½’éƒ¨åˆ†è¿›è¡Œç›¸åŒæ“ä½œï¼ˆ`contains-3`ï¼‰çš„ç»“æœç›¸ç»“åˆã€‚è¿™ç§åœ¨æ•°æ®ç±»å‹çš„è‡ªé€’å½’éƒ¨åˆ†ä¸Šä½¿ç”¨ç›¸åŒå‡½æ•°è¿›è¡Œé€’å½’çš„æƒ³æ³•ï¼Œä½¿æˆ‘ä»¬èƒ½å¤Ÿæ‰©å±•æˆ‘ä»¬çš„æ¨¡æ¿æ¥å¤„ç†é€’å½’å­—æ®µã€‚
- en: 5.3.2Â A Template for Processing Recursive Data[ğŸ”—](#(part._.A_.Template_for_.Processing_.Recursive_.Data)
    "Link to here")
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.2Â å¤„ç†é€’å½’æ•°æ®çš„æ¨¡æ¿[ğŸ”—](#(part._.A_.Template_for_.Processing_.Recursive_.Data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Stepping back, we have actually derived a new way to approach writing functions
    over recursive data. Back in [Processing Lists](processing-lists.html), we had
    you write functions over lists by writing a sequence of related examples, using
    substitution across examples to derive a program that called the function on the
    rest of the list. Here, we are deriving that structure from the shape of the data
    itself.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: å›é¡¾ä¸€ä¸‹ï¼Œæˆ‘ä»¬å®é™…ä¸Šæ¨å¯¼å‡ºäº†ä¸€ç§æ–°çš„æ–¹æ³•æ¥ç¼–å†™é€’å½’æ•°æ®ä¸Šçš„å‡½æ•°ã€‚åœ¨[å¤„ç†åˆ—è¡¨](processing-lists.html)ä¸­ï¼Œæˆ‘ä»¬è®©ä½ é€šè¿‡ç¼–å†™ä¸€ç³»åˆ—ç›¸å…³ç¤ºä¾‹æ¥ç¼–å†™åˆ—è¡¨ä¸Šçš„å‡½æ•°ï¼Œä½¿ç”¨ç¤ºä¾‹ä¹‹é—´çš„æ›¿æ¢æ¥æ¨å¯¼å‡ºä¸€ä¸ªè°ƒç”¨åˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„å‡½æ•°çš„ç¨‹åºã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬æ˜¯æ ¹æ®æ•°æ®çš„å½¢çŠ¶æ¨å¯¼å‡ºè¿™ç§ç»“æ„çš„ã€‚
- en: 'In particular, we can develop a function over recursive data by breaking a
    datum into its variants (using `cases`), pulling out the fields of each variant
    (by listing the field names), then calling the function itself on any recursive
    fields (fields of the same type). For `NumList`, these steps yield the following
    code outline:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å°†æ•°æ®åˆ†è§£ä¸ºå…¶å˜ä½“ï¼ˆä½¿ç”¨`cases`ï¼‰ï¼Œæå–æ¯ä¸ªå˜ä½“çš„å­—æ®µï¼ˆé€šè¿‡åˆ—å‡ºå­—æ®µåç§°ï¼‰ï¼Œç„¶ååœ¨ä»»ä½•é€’å½’å­—æ®µï¼ˆåŒç±»å‹çš„å­—æ®µï¼‰ä¸Šè°ƒç”¨å‡½æ•°æœ¬èº«æ¥å¼€å‘é€’å½’æ•°æ®ä¸Šçš„å‡½æ•°ã€‚å¯¹äº`NumList`ï¼Œè¿™äº›æ­¥éª¤äº§ç”Ÿä»¥ä¸‹ä»£ç æ¦‚è¦ï¼š
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we are using a generic function name, `num-list-fun`, to illustrate that
    this is the outline for any function that processes a `NumList`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªé€šç”¨çš„å‡½æ•°å`num-list-fun`æ¥è¯´æ˜ï¼Œè¿™æ˜¯ä»»ä½•å¤„ç†`NumList`çš„å‡½æ•°çš„æ¦‚è¦ã€‚
- en: We refer to this code outline as a template. Every `data` definition has a corresponding
    template which captures how to break a value of that definition into cases, pull
    out the fields, and use the same function to process any recursive fields.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†è¿™ä¸ªä»£ç è½®å»“ç§°ä¸ºæ¨¡æ¿ã€‚æ¯ä¸ª `data` å®šä¹‰éƒ½æœ‰ä¸€ä¸ªç›¸åº”çš„æ¨¡æ¿ï¼Œå®ƒæ•æ‰äº†å¦‚ä½•å°†å®šä¹‰çš„å€¼åˆ†è§£ä¸ºæ¡ˆä¾‹ï¼Œæå–å­—æ®µï¼Œå¹¶ä½¿ç”¨ç›¸åŒçš„å‡½æ•°å¤„ç†ä»»ä½•é€’å½’å­—æ®µã€‚
- en: 'Strategy: Writing a Template for Recursive Data'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç­–ç•¥ï¼šä¸ºé€’å½’æ•°æ®ç¼–å†™æ¨¡æ¿
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given a recursive data definition, use the following steps to create the (reusable)
    template for that definition:'
  id: totrans-167
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªé€’å½’æ•°æ®å®šä¹‰ï¼Œä½¿ç”¨ä»¥ä¸‹æ­¥éª¤ä¸ºè¯¥å®šä¹‰åˆ›å»ºï¼ˆå¯é‡ç”¨çš„ï¼‰æ¨¡æ¿ï¼š
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a function header (using a general-purpose placeholder name if you arenâ€™t
    yet writing a specific function).
  id: totrans-169
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªå‡½æ•°å¤´ï¼ˆå¦‚æœä½ è¿˜æ²¡æœ‰ç¼–å†™ç‰¹å®šçš„å‡½æ•°ï¼Œå¯ä»¥ä½¿ç”¨é€šç”¨å ä½ç¬¦åç§°ï¼‰ã€‚
- en: ''
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-171
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Use `cases` to break the recursive-data input into its variants.
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ `cases` å°†é€’å½’æ•°æ®è¾“å…¥åˆ†è§£ä¸ºå…¶å˜ä½“ã€‚
- en: ''
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: In each case, list each of its fields in the answer portion of the case.
  id: totrans-175
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨æ¯ç§æƒ…å†µä¸‹ï¼Œåˆ—å‡ºå…¶æ¯ä¸ªå­—æ®µåœ¨æ¡ˆä¾‹çš„ç­”æ¡ˆéƒ¨åˆ†ã€‚
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-177
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Call the function itself on any recursive fields.
  id: totrans-178
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨ä»»ä½•é€’å½’å­—æ®µä¸Šè°ƒç”¨å‡½æ•°æœ¬èº«ã€‚
- en: The power of the template lies in its universality. If you are asked to write
    a specific function (such as `contains-3`) over recursive data (`NumList`), you
    can reproduce or copy (if you already wrote it down) the template, replace the
    generic function name in the template with the one for your specific function,
    then fill in the ellipses to finish the function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: æ¨¡æ¿çš„åŠ›é‡åœ¨äºå…¶é€šç”¨æ€§ã€‚å¦‚æœä½ è¢«è¦æ±‚ç¼–å†™ä¸€ä¸ªç‰¹å®šçš„å‡½æ•°ï¼ˆä¾‹å¦‚ `contains-3`ï¼‰æ¥å¤„ç†é€’å½’æ•°æ®ï¼ˆ`NumList`ï¼‰ï¼Œä½ å¯ä»¥å¤åˆ¶æˆ–å¤åˆ¶ï¼ˆå¦‚æœä½ å·²ç»å†™ä¸‹äº†å®ƒï¼‰æ¨¡æ¿ï¼Œå°†æ¨¡æ¿ä¸­çš„é€šç”¨å‡½æ•°åç§°æ›¿æ¢ä¸ºä½ çš„ç‰¹å®šå‡½æ•°ï¼Œç„¶åå¡«å†™çœç•¥å·æ¥å®Œæˆå‡½æ•°ã€‚
- en: When you see a recursive data definition (of which there will be many when programming
    in Pyret), you should naturally start thinking about what the recursive calls
    will return and how to combine their results with the other, non-recursive pieces
    of the datatype.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ çœ‹åˆ°é€’å½’æ•°æ®å®šä¹‰ï¼ˆåœ¨ç”¨ Pyret ç¼–ç¨‹æ—¶ä¼šæœ‰å¾ˆå¤šï¼‰æ—¶ï¼Œä½ åº”è¯¥è‡ªç„¶è€Œç„¶åœ°å¼€å§‹æ€è€ƒé€’å½’è°ƒç”¨å°†è¿”å›ä»€ä¹ˆï¼Œä»¥åŠå¦‚ä½•å°†å®ƒä»¬çš„ç»“æœä¸å…¶ä»–éé€’å½’çš„æ•°æ®ç±»å‹éƒ¨åˆ†ç»“åˆèµ·æ¥ã€‚
- en: 'You have now seen two approaches to writing functions on recursive data: working
    out a sequence of related examples and modifying the template. Both approaches
    get you to the same final function. The power of the template, however, is that
    it scales to more complicated data definitions (where writing examples by hand
    would prove tedious). We will see examples of this as our data get more complex
    in coming chapters.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ ç°åœ¨å·²ç»çœ‹åˆ°äº†ä¸¤ç§åœ¨é€’å½’æ•°æ®ä¸Šç¼–å†™å‡½æ•°çš„æ–¹æ³•ï¼šåˆ¶å®šä¸€ç³»åˆ—ç›¸å…³ç¤ºä¾‹å’Œä¿®æ”¹æ¨¡æ¿ã€‚è¿™ä¸¤ç§æ–¹æ³•éƒ½ä¼šè®©ä½ å¾—åˆ°ç›¸åŒçš„æœ€ç»ˆå‡½æ•°ã€‚ç„¶è€Œï¼Œæ¨¡æ¿çš„åŠ›é‡åœ¨äºå®ƒå¯ä»¥æ‰©å±•åˆ°æ›´å¤æ‚çš„æ•°æ®å®šä¹‰ï¼ˆæ‰‹åŠ¨ç¼–å†™ç¤ºä¾‹å¯èƒ½ä¼šå˜å¾—ç¹çï¼‰ã€‚éšç€æˆ‘ä»¬åœ¨æ¥ä¸‹æ¥çš„ç« èŠ‚ä¸­æ•°æ®å˜å¾—æ›´åŠ å¤æ‚ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°è¿™æ–¹é¢çš„ä¾‹å­ã€‚
- en: 5.3.3Â The Design Recipe[ğŸ”—](#(part._.The_.Design_.Recipe) "Link to here")
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.3Â è®¾è®¡é…æ–¹[ğŸ”—](#(part._.The_.Design_.Recipe) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Weâ€™ve showed you many techniques to use while designing programs, including
    developing examples, writing tests, and now writing and using data templates.
    Putting the pieces together yields a design recipe, adapted from that in [How
    to Design Programs](https://htdp.org/), that we can follow for designing recursive
    functions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»å‘æ‚¨å±•ç¤ºäº†åœ¨è®¾è®¡ç¨‹åºæ—¶å¯ä»¥ä½¿ç”¨çš„æŠ€æœ¯ï¼ŒåŒ…æ‹¬å¼€å‘ç¤ºä¾‹ã€ç¼–å†™æµ‹è¯•ï¼Œä»¥åŠç°åœ¨ç¼–å†™å’Œä½¿ç”¨æ•°æ®æ¨¡æ¿ã€‚å°†è¿™äº›éƒ¨åˆ†ç»„åˆèµ·æ¥ï¼Œå¯ä»¥å¾—åˆ°ä¸€ä¸ªè®¾è®¡é…æ–¹ï¼Œè¯¥é…æ–¹æ˜¯ä»
    [How to Design Programs](https://htdp.org/) ä¸­çš„é…æ–¹æ”¹ç¼–è€Œæ¥ï¼Œæˆ‘ä»¬å¯ä»¥éµå¾ªå®ƒæ¥è®¾è®¡é€’å½’å‡½æ•°ã€‚
- en: 'Strategy: The Design Recipe'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç­–ç•¥ï¼šè®¾è®¡é…æ–¹
- en: ''
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given a programming problem over recursive data:'
  id: totrans-186
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªå…³äºé€’å½’æ•°æ®çš„ç¼–ç¨‹é—®é¢˜ï¼š
- en: ''
  id: totrans-187
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a function header, including the function name and contract. The name
    will be necessary to make recursive calls, while the contract guides the design
    of the body.
  id: totrans-188
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªå‡½æ•°å¤´ï¼ŒåŒ…æ‹¬å‡½æ•°åç§°å’Œå¥‘çº¦ã€‚åç§°å¯¹äºè¿›è¡Œé€’å½’è°ƒç”¨æ˜¯å¿…è¦çš„ï¼Œè€Œå¥‘çº¦æŒ‡å¯¼ç€å‡½æ•°ä½“çš„è®¾è®¡ã€‚
- en: ''
  id: totrans-189
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-190
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Aided by the contract, which tells you what kind of data to consume and produce,
    write several illustrative examples of the functionâ€™s input and outputs, using
    concrete data. Include examples in which the input data of one extends the input
    data of another. This will later help you fill in the function.
  id: totrans-191
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨å¥‘çº¦çš„å¸®åŠ©ä¸‹ï¼Œå¥‘çº¦å‘Šè¯‰ä½ éœ€è¦æ¶ˆè´¹å’Œäº§ç”Ÿå“ªç§ç±»å‹çš„æ•°æ®ï¼Œä½¿ç”¨å…·ä½“æ•°æ®ç¼–å†™å‡ ä¸ªå‡½æ•°è¾“å…¥å’Œè¾“å‡ºçš„è¯´æ˜æ€§ç¤ºä¾‹ã€‚åŒ…æ‹¬ä¸€ä¸ªç¤ºä¾‹ï¼Œå…¶ä¸­ä¸€ä¸ªè¾“å…¥æ•°æ®æ‰©å±•äº†å¦ä¸€ä¸ªè¾“å…¥æ•°æ®ã€‚è¿™å°†åœ¨ä»¥åå¸®åŠ©ä½ å¡«å†™å‡½æ•°ã€‚
- en: ''
  id: totrans-192
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-193
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The functionâ€™s contract tells you what kind of data you are processing. From
    the definition of the data, write out the template for it.
  id: totrans-194
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: å‡½æ•°çš„å¥‘çº¦å‘Šè¯‰ä½ æ­£åœ¨å¤„ç†å“ªç§ç±»å‹çš„æ•°æ®ã€‚ä»æ•°æ®çš„å®šä¹‰ä¸­ï¼Œå†™å‡ºå®ƒçš„æ¨¡æ¿ã€‚
- en: ''
  id: totrans-195
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Adapt this template to the computation required by this specific problem. Use
    your examples to figure out how to fill in each case. You should have written
    an example for each case of data in the template. This is also where writing examples
    where input extended the other helps: the difference in output becomes the function
    body. See the several examples of this in [Processing Lists](processing-lists.html).'
  id: totrans-197
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: å°†æ­¤æ¨¡æ¿é€‚åº”äºè¿™ä¸ªç‰¹å®šé—®é¢˜æ‰€éœ€çš„è®¡ç®—ã€‚ä½¿ç”¨ä½ çš„ç¤ºä¾‹æ¥ç¡®å®šå¦‚ä½•å¡«å†™æ¯ä¸ªæ¡ˆä¾‹ã€‚ä½ åº”è¯¥ä¸ºæ¨¡æ¿ä¸­çš„æ¯ä¸ªæ•°æ®æ¡ˆä¾‹ç¼–å†™ä¸€ä¸ªç¤ºä¾‹ã€‚è¿™ä¹Ÿæ˜¯ç¼–å†™è¾“å…¥æ‰©å±•å…¶ä»–æ¡ˆä¾‹çš„ç¤ºä¾‹çš„åœ°æ–¹ï¼šè¾“å‡ºçš„å·®å¼‚æˆä¸ºå‡½æ•°ä¸»ä½“ã€‚è¯·å‚è§[å¤„ç†åˆ—è¡¨](processing-lists.html)ä¸­çš„å‡ ä¸ªç¤ºä¾‹ã€‚
- en: ''
  id: totrans-198
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-199
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Run your examples to make sure your function behaves as you expect.
  id: totrans-200
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¿è¡Œä½ çš„ç¤ºä¾‹ä»¥ç¡®ä¿ä½ çš„å‡½æ•°è¡¨ç°å¦‚ä½ æ‰€é¢„æœŸã€‚
- en: ''
  id: totrans-201
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-202
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Now start writing more fine-grained tests to confirm that you should be confident
    in your function. In particular, while the examples (which were written before
    you wrote the body of the function) focus on the expected â€œinput-outputâ€ behavior,
    now that you have a concrete implementation, you should write tests that focus
    on its details.
  id: totrans-203
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: ç°åœ¨å¼€å§‹ç¼–å†™æ›´ç²¾ç»†çš„æµ‹è¯•æ¥ç¡®è®¤ä½ åº”è¯¥å¯¹ä½ çš„å‡½æ•°æœ‰ä¿¡å¿ƒã€‚ç‰¹åˆ«æ˜¯ï¼Œè™½ç„¶ç¤ºä¾‹ï¼ˆåœ¨ä½ ç¼–å†™å‡½æ•°ä¸»ä½“ä¹‹å‰ç¼–å†™çš„ï¼‰ä¾§é‡äºé¢„æœŸçš„â€œè¾“å…¥-è¾“å‡ºâ€è¡Œä¸ºï¼Œä½†ç°åœ¨ä½ æœ‰äº†å…·ä½“çš„å®ç°ï¼Œä½ åº”è¯¥ç¼–å†™ä¾§é‡äºå…¶ç»†èŠ‚çš„æµ‹è¯•ã€‚
- en: Exercise
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the design recipe to write a function `contains-n` that takes a `NumList`
    and a `Number`, and returns whether that number is in the `NumList`.
  id: totrans-206
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è®¾è®¡é£Ÿè°±ç¼–å†™ä¸€ä¸ªåä¸º`contains-n`çš„å‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ª`NumList`å’Œä¸€ä¸ª`Number`ï¼Œå¹¶è¿”å›è¯¥æ•°å­—æ˜¯å¦åœ¨`NumList`ä¸­ã€‚
- en: Exercise
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the design recipe to write a function `sum` that takes a `NumList`, and
    returns the sum of all the numbers in it. The sum of the empty list is `0`.
  id: totrans-209
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è®¾è®¡é£Ÿè°±ç¼–å†™ä¸€ä¸ªåä¸º`sum`çš„å‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ª`NumList`ï¼Œå¹¶è¿”å›å…¶ä¸­æ‰€æœ‰æ•°å­—çš„æ€»å’Œã€‚ç©ºåˆ—è¡¨çš„æ€»å’Œæ˜¯`0`ã€‚
- en: Exercise
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the design recipe to write a function `remove-3` that takes a `NumList`,
    and returns a new `NumList` with any `3`â€™s removed. The remaining elements should
    all be in the list in the same order they were in the input.
  id: totrans-212
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è®¾è®¡é£Ÿè°±ç¼–å†™ä¸€ä¸ªåä¸º`remove-3`çš„å‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ª`NumList`ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ–°`NumList`ï¼Œå…¶ä¸­ä»»ä½•`3`éƒ½è¢«ç§»é™¤ã€‚å‰©ä½™çš„å…ƒç´ åº”æŒ‰å…¶åœ¨è¾“å…¥ä¸­çš„ç›¸åŒé¡ºåºåœ¨åˆ—è¡¨ä¸­ã€‚
- en: Exercise
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a data definition called `NumListList` that represents a list of `NumList`s,
    and use the design recipe to write a function `sum-of-lists` that takes a `NumListList`
    and produces a `NumList` containing the sums of the sub-lists.
  id: totrans-215
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªåä¸º`NumListList`çš„æ•°æ®å®šä¹‰ï¼Œå®ƒè¡¨ç¤º`NumList`çš„åˆ—è¡¨ï¼Œå¹¶ä½¿ç”¨è®¾è®¡é£Ÿè°±ç¼–å†™ä¸€ä¸ªåä¸º`sum-of-lists`çš„å‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ª`NumListList`å¹¶ç”Ÿæˆä¸€ä¸ªåŒ…å«å­åˆ—è¡¨æ€»å’Œçš„`NumList`ã€‚
- en: Exercise
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a data definition and corresponding template for `StrList`, which captures
    lists of strings.
  id: totrans-218
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªæ•°æ®å®šä¹‰å’Œç›¸åº”çš„æ¨¡æ¿ï¼Œç”¨äº`StrList`ï¼Œå®ƒæ•è·å­—ç¬¦ä¸²åˆ—è¡¨ã€‚
