- en: 5.3¬†Recursive Dataüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/recursive-data.html](https://dcic-world.org/2025-08-27/recursive-data.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[5.3.1¬†Functions to Process Recursive Data](#%28part._.Functions_to_.Process_.Recursive_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[5.3.2¬†A Template for Processing Recursive Data](#%28part._.A_.Template_for_.Processing_.Recursive_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[5.3.3¬†The Design Recipe](#%28part._.The_.Design_.Recipe%29) |'
  prefs: []
  type: TYPE_TB
- en: In [Telling Apart Variants of Conditional Data](intro-struct-data.html#%28part._telling-apart-variants%29),
    we used `cases` to distinguish between different forms of conditional data. We
    had used `cases` earlier, specifically to distinguish between empty and non-empty
    lists in [Processing Lists](processing-lists.html). This suggests that lists are
    also a form of conditional data, just one that is built into Pyret. Indeed, this
    is the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand lists as conditional data, let‚Äôs create a data definition for
    a new type `NumList` which contains a list of numbers (this differs from built-in
    lists, which work with any type of element). To avoid conflicts with Pyret‚Äôs built-in
    `empty` value and `link` operator, we‚Äôll have `NumList` use `nl-empty` as its
    empty value and `nl-link` as the operator that builds new lists. Here‚Äôs a partial
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fill in the blank in the `nl-link` condition with the corresponding field(s)
    and corresponding types. The blank could contain anywhere from 0 through multiple
    fields.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'From working with lists earlier, hopefully you remembered that list constructors
    take two inputs: the first element of the list and a list to build on (the rest
    of the list). That suggests that we need two fields here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fill in the types for `first` and `rest` if you haven‚Äôt already.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since we‚Äôre making a list of numbers, the `first` field should contain type
    `Number`. What about the `rest` field? It needs to be a list of numbers, so its
    type should be `NumList`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice something interesting (and new) here: the type of the `rest` field is
    the same type (`NumList`) as the conditional data that we are defining. We can,
    quite literally, draw the arrows that show the self-referential part of the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8c8f0c1555bb84656f4e12c9faa58d32.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Does that actually work? Yes. Think about how we might build up a list with
    the numbers 2, 7, and 3 (in that order). We start with `nl-empty`, which is a
    valid `NumList`. We then use `nl-link` to add the numbers onto that list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In each case, the `rest` argument is itself a valid `NumList`. While defining
    data in terms of itself might seem problematic, it works fine because in order
    to build actual data, we had to start with the `nl-empty` condition, which does
    not refer to `NumList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data definitions that build on fields of the same type are called recursive
    data. Recursive data definitions are powerful because they permit us to create
    data that are unbounded or arbitrarily-sized. Given a `NumList`, there is an easy
    way to make a new, larger one: just use `nl-link`. So, we need to consider larger
    lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 5.3.1¬†Functions to Process Recursive Data[üîó](#(part._.Functions_to_.Process_.Recursive_.Data)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let‚Äôs try to write a function `contains-3`, which returns `true` if the `NumList`
    contains the value `3`, and `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, our header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, some tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did in [Processing Fields of Variants](intro-struct-data.html#%28part._process-fields-variants%29),
    we will use `cases` to distinguish the variants. In addition, since we are going
    to have to use the fields of `nl-link` to compute a result in that case, we will
    list those in the initial code outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Following our examples, the answer must be false in the `nl-empty` case. In
    the `nl-link` case, if the `first` element is `3`, we‚Äôve successfully answered
    the question. That only leaves the case where the argument is an `nl-link` and
    the first element does not equal `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we know `rest` is a `NumList` (based on the data definition), we can
    use a `cases` expression to work with it. This is sort of like filling in a part
    of the template again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `rest` was empty, then we haven‚Äôt found `3` (just like when we checked
    the original argument, `nl`). If the `rest` was a `nl-link`, then we need to check
    if the first thing in the rest of the list is `3` or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `rest-of-rest` is a `NumList`, we can fill in a `cases` for it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See where this is going? Not anywhere good. We can copy this `cases` expression
    as many times as we want, but we can never answer the question for a list that
    is just one element longer than the number of times we copy the code.
  prefs: []
  type: TYPE_NORMAL
- en: So what to do? We tried this approach of using another copy of `cases` based
    on the observation that `rest` is a `NumList`, and `cases` provides a meaningful
    way to break apart a `NumList`; in fact, it‚Äôs what the recipe seems to lead to
    naturally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs go back to the step where the problem began, after filling in the template
    with the first check for `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a way to compute whether or not the value `3` is contained in `rest`.
    Looking back at the data definition, we see that `rest` is a perfectly valid `NumList`,
    simply by the definition of `nl-link`. And we have a function (or, most of one)
    whose job is to figure out if a `NumList` contains `3` or not: `contains-3`. That
    ought to be something we can call with `rest` as an argument, and get back the
    value we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And lo and behold, all of the tests defined above pass. It‚Äôs useful to step
    through what‚Äôs happening when this function is called. Let‚Äôs look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we substitute the argument value in place of `nl` everywhere it appears;
    that‚Äôs just the usual rule for function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Next, we find the case that matches the constructor `nl-link`, and substitute
    the corresponding pieces of the `nl-link` value for the `first` and `rest` identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Since `1` isn‚Äôt `3`, the comparison evaluates to `false`, and this whole expression
    evaluates to the contents of the `else` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is another function call, so we substitute the value `nl-link(3, nl-empty)`,
    which was the `rest` field of the original input, into the body of `contains-3`
    this time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Again, we substitute into the `nl-link` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This time, since `3` is `3`, we take the first branch of the `if` expression,
    and the whole original call evaluates to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: An interesting feature of this trace through the evaluation is that we reached
    the expression `contains-3(nl-link(3, nl-empty))`, which is a normal call to `contains-3`;
    it could even be a test case on its own. The implementation works by doing something
    (checking for equality with `3`) with the non-recursive parts of the datum, and
    combining that result with the result of the same operation (`contains-3`) on
    the recursive part of the datum. This idea of doing recursion with the same function
    on self-recursive parts of the datatype lets us extend our template to handle
    recursive fields.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.2¬†A Template for Processing Recursive Data[üîó](#(part._.A_.Template_for_.Processing_.Recursive_.Data)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Stepping back, we have actually derived a new way to approach writing functions
    over recursive data. Back in [Processing Lists](processing-lists.html), we had
    you write functions over lists by writing a sequence of related examples, using
    substitution across examples to derive a program that called the function on the
    rest of the list. Here, we are deriving that structure from the shape of the data
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we can develop a function over recursive data by breaking a
    datum into its variants (using `cases`), pulling out the fields of each variant
    (by listing the field names), then calling the function itself on any recursive
    fields (fields of the same type). For `NumList`, these steps yield the following
    code outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using a generic function name, `num-list-fun`, to illustrate that
    this is the outline for any function that processes a `NumList`.
  prefs: []
  type: TYPE_NORMAL
- en: We refer to this code outline as a template. Every `data` definition has a corresponding
    template which captures how to break a value of that definition into cases, pull
    out the fields, and use the same function to process any recursive fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategy: Writing a Template for Recursive Data'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given a recursive data definition, use the following steps to create the (reusable)
    template for that definition:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a function header (using a general-purpose placeholder name if you aren‚Äôt
    yet writing a specific function).
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Use `cases` to break the recursive-data input into its variants.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: In each case, list each of its fields in the answer portion of the case.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Call the function itself on any recursive fields.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: The power of the template lies in its universality. If you are asked to write
    a specific function (such as `contains-3`) over recursive data (`NumList`), you
    can reproduce or copy (if you already wrote it down) the template, replace the
    generic function name in the template with the one for your specific function,
    then fill in the ellipses to finish the function.
  prefs: []
  type: TYPE_NORMAL
- en: When you see a recursive data definition (of which there will be many when programming
    in Pyret), you should naturally start thinking about what the recursive calls
    will return and how to combine their results with the other, non-recursive pieces
    of the datatype.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have now seen two approaches to writing functions on recursive data: working
    out a sequence of related examples and modifying the template. Both approaches
    get you to the same final function. The power of the template, however, is that
    it scales to more complicated data definitions (where writing examples by hand
    would prove tedious). We will see examples of this as our data get more complex
    in coming chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.3¬†The Design Recipe[üîó](#(part._.The_.Design_.Recipe) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We‚Äôve showed you many techniques to use while designing programs, including
    developing examples, writing tests, and now writing and using data templates.
    Putting the pieces together yields a design recipe, adapted from that in [How
    to Design Programs](https://htdp.org/), that we can follow for designing recursive
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategy: The Design Recipe'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given a programming problem over recursive data:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a function header, including the function name and contract. The name
    will be necessary to make recursive calls, while the contract guides the design
    of the body.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Aided by the contract, which tells you what kind of data to consume and produce,
    write several illustrative examples of the function‚Äôs input and outputs, using
    concrete data. Include examples in which the input data of one extends the input
    data of another. This will later help you fill in the function.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The function‚Äôs contract tells you what kind of data you are processing. From
    the definition of the data, write out the template for it.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Adapt this template to the computation required by this specific problem. Use
    your examples to figure out how to fill in each case. You should have written
    an example for each case of data in the template. This is also where writing examples
    where input extended the other helps: the difference in output becomes the function
    body. See the several examples of this in [Processing Lists](processing-lists.html).'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Run your examples to make sure your function behaves as you expect.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Now start writing more fine-grained tests to confirm that you should be confident
    in your function. In particular, while the examples (which were written before
    you wrote the body of the function) focus on the expected ‚Äúinput-output‚Äù behavior,
    now that you have a concrete implementation, you should write tests that focus
    on its details.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the design recipe to write a function `contains-n` that takes a `NumList`
    and a `Number`, and returns whether that number is in the `NumList`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the design recipe to write a function `sum` that takes a `NumList`, and
    returns the sum of all the numbers in it. The sum of the empty list is `0`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the design recipe to write a function `remove-3` that takes a `NumList`,
    and returns a new `NumList` with any `3`‚Äôs removed. The remaining elements should
    all be in the list in the same order they were in the input.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a data definition called `NumListList` that represents a list of `NumList`s,
    and use the design recipe to write a function `sum-of-lists` that takes a `NumListList`
    and produces a `NumList` containing the sums of the sub-lists.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a data definition and corresponding template for `StrList`, which captures
    lists of strings.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5.3.1¬†Functions to Process Recursive Data[üîó](#(part._.Functions_to_.Process_.Recursive_.Data)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let‚Äôs try to write a function `contains-3`, which returns `true` if the `NumList`
    contains the value `3`, and `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, our header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, some tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did in [Processing Fields of Variants](intro-struct-data.html#%28part._process-fields-variants%29),
    we will use `cases` to distinguish the variants. In addition, since we are going
    to have to use the fields of `nl-link` to compute a result in that case, we will
    list those in the initial code outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Following our examples, the answer must be false in the `nl-empty` case. In
    the `nl-link` case, if the `first` element is `3`, we‚Äôve successfully answered
    the question. That only leaves the case where the argument is an `nl-link` and
    the first element does not equal `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we know `rest` is a `NumList` (based on the data definition), we can
    use a `cases` expression to work with it. This is sort of like filling in a part
    of the template again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `rest` was empty, then we haven‚Äôt found `3` (just like when we checked
    the original argument, `nl`). If the `rest` was a `nl-link`, then we need to check
    if the first thing in the rest of the list is `3` or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `rest-of-rest` is a `NumList`, we can fill in a `cases` for it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: See where this is going? Not anywhere good. We can copy this `cases` expression
    as many times as we want, but we can never answer the question for a list that
    is just one element longer than the number of times we copy the code.
  prefs: []
  type: TYPE_NORMAL
- en: So what to do? We tried this approach of using another copy of `cases` based
    on the observation that `rest` is a `NumList`, and `cases` provides a meaningful
    way to break apart a `NumList`; in fact, it‚Äôs what the recipe seems to lead to
    naturally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs go back to the step where the problem began, after filling in the template
    with the first check for `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a way to compute whether or not the value `3` is contained in `rest`.
    Looking back at the data definition, we see that `rest` is a perfectly valid `NumList`,
    simply by the definition of `nl-link`. And we have a function (or, most of one)
    whose job is to figure out if a `NumList` contains `3` or not: `contains-3`. That
    ought to be something we can call with `rest` as an argument, and get back the
    value we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And lo and behold, all of the tests defined above pass. It‚Äôs useful to step
    through what‚Äôs happening when this function is called. Let‚Äôs look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: First, we substitute the argument value in place of `nl` everywhere it appears;
    that‚Äôs just the usual rule for function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Next, we find the case that matches the constructor `nl-link`, and substitute
    the corresponding pieces of the `nl-link` value for the `first` and `rest` identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Since `1` isn‚Äôt `3`, the comparison evaluates to `false`, and this whole expression
    evaluates to the contents of the `else` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is another function call, so we substitute the value `nl-link(3, nl-empty)`,
    which was the `rest` field of the original input, into the body of `contains-3`
    this time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Again, we substitute into the `nl-link` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This time, since `3` is `3`, we take the first branch of the `if` expression,
    and the whole original call evaluates to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: An interesting feature of this trace through the evaluation is that we reached
    the expression `contains-3(nl-link(3, nl-empty))`, which is a normal call to `contains-3`;
    it could even be a test case on its own. The implementation works by doing something
    (checking for equality with `3`) with the non-recursive parts of the datum, and
    combining that result with the result of the same operation (`contains-3`) on
    the recursive part of the datum. This idea of doing recursion with the same function
    on self-recursive parts of the datatype lets us extend our template to handle
    recursive fields.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.2¬†A Template for Processing Recursive Data[üîó](#(part._.A_.Template_for_.Processing_.Recursive_.Data)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Stepping back, we have actually derived a new way to approach writing functions
    over recursive data. Back in [Processing Lists](processing-lists.html), we had
    you write functions over lists by writing a sequence of related examples, using
    substitution across examples to derive a program that called the function on the
    rest of the list. Here, we are deriving that structure from the shape of the data
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we can develop a function over recursive data by breaking a
    datum into its variants (using `cases`), pulling out the fields of each variant
    (by listing the field names), then calling the function itself on any recursive
    fields (fields of the same type). For `NumList`, these steps yield the following
    code outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using a generic function name, `num-list-fun`, to illustrate that
    this is the outline for any function that processes a `NumList`.
  prefs: []
  type: TYPE_NORMAL
- en: We refer to this code outline as a template. Every `data` definition has a corresponding
    template which captures how to break a value of that definition into cases, pull
    out the fields, and use the same function to process any recursive fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategy: Writing a Template for Recursive Data'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given a recursive data definition, use the following steps to create the (reusable)
    template for that definition:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a function header (using a general-purpose placeholder name if you aren‚Äôt
    yet writing a specific function).
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Use `cases` to break the recursive-data input into its variants.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: In each case, list each of its fields in the answer portion of the case.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Call the function itself on any recursive fields.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: The power of the template lies in its universality. If you are asked to write
    a specific function (such as `contains-3`) over recursive data (`NumList`), you
    can reproduce or copy (if you already wrote it down) the template, replace the
    generic function name in the template with the one for your specific function,
    then fill in the ellipses to finish the function.
  prefs: []
  type: TYPE_NORMAL
- en: When you see a recursive data definition (of which there will be many when programming
    in Pyret), you should naturally start thinking about what the recursive calls
    will return and how to combine their results with the other, non-recursive pieces
    of the datatype.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have now seen two approaches to writing functions on recursive data: working
    out a sequence of related examples and modifying the template. Both approaches
    get you to the same final function. The power of the template, however, is that
    it scales to more complicated data definitions (where writing examples by hand
    would prove tedious). We will see examples of this as our data get more complex
    in coming chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.3¬†The Design Recipe[üîó](#(part._.The_.Design_.Recipe) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We‚Äôve showed you many techniques to use while designing programs, including
    developing examples, writing tests, and now writing and using data templates.
    Putting the pieces together yields a design recipe, adapted from that in [How
    to Design Programs](https://htdp.org/), that we can follow for designing recursive
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategy: The Design Recipe'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given a programming problem over recursive data:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a function header, including the function name and contract. The name
    will be necessary to make recursive calls, while the contract guides the design
    of the body.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Aided by the contract, which tells you what kind of data to consume and produce,
    write several illustrative examples of the function‚Äôs input and outputs, using
    concrete data. Include examples in which the input data of one extends the input
    data of another. This will later help you fill in the function.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The function‚Äôs contract tells you what kind of data you are processing. From
    the definition of the data, write out the template for it.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Adapt this template to the computation required by this specific problem. Use
    your examples to figure out how to fill in each case. You should have written
    an example for each case of data in the template. This is also where writing examples
    where input extended the other helps: the difference in output becomes the function
    body. See the several examples of this in [Processing Lists](processing-lists.html).'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Run your examples to make sure your function behaves as you expect.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Now start writing more fine-grained tests to confirm that you should be confident
    in your function. In particular, while the examples (which were written before
    you wrote the body of the function) focus on the expected ‚Äúinput-output‚Äù behavior,
    now that you have a concrete implementation, you should write tests that focus
    on its details.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the design recipe to write a function `contains-n` that takes a `NumList`
    and a `Number`, and returns whether that number is in the `NumList`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the design recipe to write a function `sum` that takes a `NumList`, and
    returns the sum of all the numbers in it. The sum of the empty list is `0`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the design recipe to write a function `remove-3` that takes a `NumList`,
    and returns a new `NumList` with any `3`‚Äôs removed. The remaining elements should
    all be in the list in the same order they were in the input.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a data definition called `NumListList` that represents a list of `NumList`s,
    and use the design recipe to write a function `sum-of-lists` that takes a `NumListList`
    and produces a `NumList` containing the sums of the sub-lists.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a data definition and corresponding template for `StrList`, which captures
    lists of strings.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
