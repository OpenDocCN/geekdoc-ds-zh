<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>24¬†Stagingüîó</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>24¬†Stagingüîó</h1>
<blockquote>ÂéüÊñáÔºö<a href="https://dcic-world.org/2025-08-27/staging.html">https://dcic-world.org/2025-08-27/staging.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>¬†¬†¬†¬†<a href="#%28part._.Problem_.Definition%29" class="toclink" data-pltdoc="x">24.1¬†Problem Definition</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._.Initial_.Solution%29" class="toclink" data-pltdoc="x">24.2¬†Initial Solution</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._.Refactoring%29" class="toclink" data-pltdoc="x">24.3¬†Refactoring</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._.Separating_.Parameters%29" class="toclink" data-pltdoc="x">24.4¬†Separating Parameters</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._.Context%29" class="toclink" data-pltdoc="x">24.5¬†Context</a></p></td></tr></table><section class="SsectionLevel3" id="section 24.1"><h3 class="heading">24.1¬†<a name="(part._.Problem_.Definition)"/>Problem Definition<a href="#(part._.Problem_.Definition)" class="heading-anchor" title="Link to here">üîó</a> </h3><p>Earlier, we saw a detailed development of binary trees representing ancestry
[<a href="trees.html#%28part._ancestor-tree%29" data-pltdoc="x">Creating a Datatype for Ancestor Trees</a>]. In what follows we don‚Äôt need a lot of detail, so
we will give ourselves a simplified version of essentially the same data definition:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ABT:
  | unknown
  | person(name :: String, bm :: ABT, bf :: ABT)
end</code></pre><p>We can then write functions over such as this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun abt-size(p :: ABT):
  doc: "Compute the number of known people in the ancestor tree"
  cases (ABT) p:
    | unknown =&gt; 0
    | person(n, p1, p2) =&gt; 1 + abt-size(p1) + abt-size(p2)
  end
end</code></pre><p>Now let‚Äôs think about a slightly different function:
<code data-lang="pyret" class="sourceCode">how-many-named</code>, which tells us how many people in a family have
a particular name. Not only can more than one person have the same
name, in some cultures it‚Äôs not uncommon to use the same name
across generations, either in successive generations or skipping one.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What is the contract for <code data-lang="pyret" class="sourceCode">how-many-named</code>? The contract for this function
will be crucial, so make sure you do this step!</p></blockquote></blockquote><p>Here is one meaningful contract:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">how-many-named :: ABT, String -&gt; Number</code></pre><p>It takes a tree in which to search, a name to search for, and returns a count.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Define <code data-lang="pyret" class="sourceCode">how-many-named</code>.</p></blockquote></blockquote></section><section class="SsectionLevel3" id="section 24.2"><h3 class="heading">24.2¬†<a name="(part._.Initial_.Solution)"/>Initial Solution<a href="#(part._.Initial_.Solution)" class="heading-anchor" title="Link to here">üîó</a> </h3><p>Presumably you ended up with something like this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun how-many-named(p, looking-for):
  cases (ABT) p:
    | unknown =&gt; 0
    | person(n, p1, p2) =&gt;
      if n == looking-for:
        1 + how-many-named(p1, looking-for) + how-many-named(p2, looking-for)
      else:
        how-many-named(p1, looking-for) + how-many-named(p2, looking-for)
      end
  end
end</code></pre><p>Let‚Äôs say you have defined this person:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p =
  person("A",
    person("B",
      person("A", unknown, unknown),
      person("C",
        person("A", unknown, unknown),
        person("B", unknown, unknown))),
    person("C", unknown, unknown))</code></pre><p>With that, we can write a test like
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  how-many-named(p, "A") is 3
end</code></pre></section><section class="SsectionLevel3" id="section 24.3"><h3 class="heading">24.3¬†<a name="(part._.Refactoring)"/>Refactoring<a href="#(part._.Refactoring)" class="heading-anchor" title="Link to here">üîó</a> </h3><p>Now let‚Äôs apply some transformations, sometimes called code refactorings,
to this function.</p><p>First, notice the repeated expression. What the whole conditional is
essentially saying is that we want to know how much this person is contributing
to the overall count; the rest of the count stays the same regardless.</p><p>One way to make this more explicit is to (perhaps surprisingly)
rewrite the <code data-lang="pyret" class="sourceCode">else</code> to make explicit that a person with a
different name contributes <code data-lang="pyret" class="sourceCode">0</code> to the count:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun how-many-named(p, looking-for):
  cases (ABT) p:
    | unknown =&gt; 0
    | person(n, p1, p2) =&gt;
      if n == looking-for:
        1 + how-many-named(p1, looking-for) + how-many-named(p2, looking-for)
      else:
        0 + how-many-named(p1, looking-for) + how-many-named(p2, looking-for)
      end
  end
end</code></pre><p>The reason for this somewhat odd rewrite is that it makes clear what
is common and what is different. What is common is looking in the two
parents. What changes is how much this person contributes, and only
that depends on the conditional. We can therefore express this
more concisely (and, if we know how to read such code,
more meaningfully) as the following instead:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun how-many-named(p, looking-for):
  cases (ABT) p:
    | unknown =&gt; 0
    | person(n, p1, p2) =&gt;
      (if n == looking-for: 1 else: 0 end)
      +
      how-many-named(p1, looking-for) +
      how-many-named(p2, looking-for)
  end
end</code></pre><p>If you have prior programming experience, this may look a bit odd to you, but
<code data-lang="pyret" class="sourceCode">if</code> is in fact an expression, which has a value; in this case the value
is either <code data-lang="pyret" class="sourceCode">0</code> or <code data-lang="pyret" class="sourceCode">1</code>. This value can then be used in an addition.</p><p>Now let‚Äôs look at this code even more closely. Notice something interesting. We
keep passing two parameters to <code data-lang="pyret" class="sourceCode">how-many-named</code>; however, only one of
those parameters (<code data-lang="pyret" class="sourceCode">p</code>) is actually changing. The name we are
looking for does not change, as we would expect: we are looking for the same
name in the entire tree. How can we reflect this in the code?</p><p>First, we‚Äôll do something that looks a little useless, but it‚Äôs also an
innocent change, so it shouldn‚Äôt irk us too much: we‚Äôll change the order of the
arguments. That is, our contract changes from
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">how-many-named :: ABT, String -&gt; Number</code></pre><p>to
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">how-many-named :: String, ABT -&gt; Number</code></pre><p>so the function correspondingly changes to
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun how-many-named(looking-for, p):
  cases (ABT) p:
    | unknown =&gt; 0
    | person(n, p1, p2) =&gt;
      (if n == looking-for: 1 else: 0 end)
      +
      how-many-named(p1, looking-for) +
      how-many-named(p2, looking-for)
  end
end</code></pre><p>What we have now done is put the ‚Äúconstant‚Äù argument first, and the
‚Äúvarying‚Äù argument second.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Try this and make sure it works!</p></blockquote></blockquote><p>It doesn‚Äôt! We have to change more than
just the function header: we have to also change how it‚Äôs called. Keep
in mind it‚Äôs called twice within the function body itself, and also
from the examples. Therefore, the function as a whole reads:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun how-many-named(looking-for, p):
  cases (ABT) p:
    | unknown =&gt; 0
    | person(n, p1, p2) =&gt;
      (if n == looking-for: 1 else: 0 end)
      +
      how-many-named(looking-for, p1) +
      how-many-named(looking-for, p2)
  end
end</code></pre><p>and the example reads <code data-lang="pyret" class="sourceCode">how-many-named("A", p)</code>
instead.</p></section><section class="SsectionLevel3" id="section 24.4"><h3 class="heading">24.4¬†<a name="(part._.Separating_.Parameters)"/>Separating Parameters<a href="#(part._.Separating_.Parameters)" class="heading-anchor" title="Link to here">üîó</a> </h3><p>This sets us up for the next stage. The parameters of functions are meant to
indicate what might vary in a function. Because the name we‚Äôre looking for is a
constant once we initially have it, we‚Äôd like the actual search function to
take only one argument: where in the tree we‚Äôre searching.</p><p>That is, we want the search function‚Äôs
contract to be <code data-lang="pyret" class="sourceCode">(ABT -&gt; Number)</code>. To achieve that, we need another
function that will take the <code data-lang="pyret" class="sourceCode">String</code> part.
Thus, the contract has to become
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">how-many-named :: String -&gt; (ABT -&gt; Number)</code></pre><p>where <code data-lang="pyret" class="sourceCode">how-many-named</code> consumes a name and returns a function that will
consume the actual tree to check.</p><p>This suggests the following function body:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun how-many-named(looking-for):
  lam(p :: ABT) -&gt; Number:
    cases (ABT) p:
      | unknown =&gt; 0
      | person(n, p1, p2) =&gt;
        (if n == looking-for: 1 else: 0 end)
        +
        how-many-named(looking-for, p1) +
        how-many-named(looking-for, p2)
    end
  end
end</code></pre><p>However, this function body is not okay: the Pyret type-checker will give us
type errors. That‚Äôs because <code data-lang="pyret" class="sourceCode">how-many-named</code> takes one parameter, not two,
as in the two recursive calls.</p><p>How do we fix this? Remember, the whole point of this change is we don‚Äôt want
to change the name, only the tree. That means we want to recur on the inner
function. We currently can‚Äôt do this because it doesn‚Äôt have a name! So we have
to give it a name and recur on it:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun how-many-named(looking-for):
  fun search-in(p :: ABT) -&gt; Number:
    cases (ABT) p:
      | unknown =&gt; 0
      | person(n, p1, p2) =&gt;
        (if n == looking-for: 1 else: 0 end)
        +
        search-in(p1) +
        search-in(p2)
    end
  end
end</code></pre><p>This now lets us recur on just the part that should vary, leaving the name
we‚Äôre looking for unchanged (and hence, fixed for the duration of the
search).</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Try the above and make sure it works.</p></blockquote></blockquote><p>It still doesn‚Äôt: the above body has a syntax error! This is because <code data-lang="pyret" class="sourceCode">how-many-named</code>
does not actually return any kind of value.</p><p>What should it return? Once we provide the function with a name, we should get
back a function that searches for that name in a tree. But we already
have exactly such a function: <code data-lang="pyret" class="sourceCode">search-in</code>. Therefore,
<code data-lang="pyret" class="sourceCode">how-many-named</code> should return just ‚Ä¶ <code data-lang="pyret" class="sourceCode">search-in</code>.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun how-many-named(looking-for):
  fun search-in(p :: ABT) -&gt; Number:
    cases (ABT) p:
      | unknown =&gt; 0
      | person(n, p1, p2) =&gt;
        (if n == looking-for: 1 else: 0 end)
        +
        search-in(p1) +
        search-in(p2)
    end
  end

  search-in
end</code></pre><p>This still won‚Äôt work, because we haven‚Äôt changed the example. Let‚Äôs
update that: how do we use <code data-lang="pyret" class="sourceCode">how-many-named</code>? We have to call it
with a name (like <code data-lang="pyret" class="sourceCode">"A"</code>); this returns a function‚Äî<wbr/>the
one bound to <code data-lang="pyret" class="sourceCode">search-in</code>‚Äî<wbr/>which expects a ancestor tree. Doing
so should return a count. Thus, the example should be rewritten as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">how-many-As = how-many-named("A")
how-many-As(p) is 3</code></pre><p>This is an instructive way to write the example. We can, however, also
write it more concisely. Notice that <code data-lang="pyret" class="sourceCode">how-many-named("A")</code>
returns a function, and the way we apply a function to arguments is
<code data-lang="pyret" class="sourceCode">(‚Ä¶)</code>. Thus, we can also write this as:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">how-many-named("A")(p) is 3</code></pre></section><section class="SsectionLevel3" id="section 24.5"><h3 class="heading">24.5¬†<a name="(part._.Context)"/>Context<a href="#(part._.Context)" class="heading-anchor" title="Link to here">üîó</a> </h3><p>The transformation we just applied is generally called currying, in honor
of Haskell Curry, who was one of the early people to describe it, though it was
earlier discovered by Moses Sch√∂nfinkel and even earlier by Gottlob Frege. The
particular use of currying here, where we move more ‚Äústatic‚Äù arguments
earlier and more ‚Äúdynamic‚Äù ones later, and split on the static-dynamic
divide, is called staging. It‚Äôs a very useful programming technique, and
furthermore, one that enables some compilers to produce more time-efficient
programs.</p><p>Even more subtly but importantly, the staged computation tells a different
story than the unstaged one, and we can read this off just from the contract:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">how-many-named :: String, ABT -&gt; Number
how-many-named :: String -&gt; (ABT -&gt; Number)</code></pre><p>The first one says the string could co-vary with the person. The second one
rules out that interpretation.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Is the former useful? When might we have the name also changing?</p></blockquote></blockquote><p>Imagine a slightly different problem: we want to know how often a child has the
same name as a parent. Then, as we traverse the tree, as the name of the person
(potentially) keeps changing, the name we‚Äôre looking for in the parent also
changes.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write this function.</p></blockquote></blockquote><p>In contrast, the staged type rules out that interpretation and that
behavior. In that way, it sends a signal to the reader about how the
computation might behave just from the type. In the same way, the unstaged type
can be read as giving the reader a hint that the behavior could depend on both
parameters changing, therefore accommodating a much broader range of behaviors
(e.g., checking for parent-child or grandparent-child name reuse).</p><p>There‚Äôs another very nice example of staging here:
<a href="func-as-data.html#%28part._fd-calculus%29" data-pltdoc="x">A Little Calculus</a>.</p><p>Finally, it‚Äôs worth knowing that some languages, like Haskell and
OCaml, do this transformation automatically. In fact, they don‚Äôt even
have multiple-parameter functions: what look like multiple arguments
are actually a sequence of staged functions. This can, in extremis,
lead to a very elegant and powerful programming style. Pyret chose to
not do this because, while this is a powerful tool in the hands of
advanced programmers, for less experienced programmers, finding out
about a mismatch in the number of parameters and arguments is very
useful.</p></section>&#13;
<h3 class="heading">24.1¬†<a name="(part._.Problem_.Definition)"/>Problem Definition<a href="#(part._.Problem_.Definition)" class="heading-anchor" title="Link to here">üîó</a> </h3><p>Earlier, we saw a detailed development of binary trees representing ancestry
[<a href="trees.html#%28part._ancestor-tree%29" data-pltdoc="x">Creating a Datatype for Ancestor Trees</a>]. In what follows we don‚Äôt need a lot of detail, so
we will give ourselves a simplified version of essentially the same data definition:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data ABT:
  | unknown
  | person(name :: String, bm :: ABT, bf :: ABT)
end</code></pre><p>We can then write functions over such as this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun abt-size(p :: ABT):
  doc: "Compute the number of known people in the ancestor tree"
  cases (ABT) p:
    | unknown =&gt; 0
    | person(n, p1, p2) =&gt; 1 + abt-size(p1) + abt-size(p2)
  end
end</code></pre><p>Now let‚Äôs think about a slightly different function:
<code data-lang="pyret" class="sourceCode">how-many-named</code>, which tells us how many people in a family have
a particular name. Not only can more than one person have the same
name, in some cultures it‚Äôs not uncommon to use the same name
across generations, either in successive generations or skipping one.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What is the contract for <code data-lang="pyret" class="sourceCode">how-many-named</code>? The contract for this function
will be crucial, so make sure you do this step!</p></blockquote></blockquote><p>Here is one meaningful contract:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">how-many-named :: ABT, String -&gt; Number</code></pre><p>It takes a tree in which to search, a name to search for, and returns a count.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Define <code data-lang="pyret" class="sourceCode">how-many-named</code>.</p></blockquote></blockquote>&#13;
<h3 class="heading">24.2¬†<a name="(part._.Initial_.Solution)"/>Initial Solution<a href="#(part._.Initial_.Solution)" class="heading-anchor" title="Link to here">üîó</a> </h3><p>Presumably you ended up with something like this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun how-many-named(p, looking-for):
  cases (ABT) p:
    | unknown =&gt; 0
    | person(n, p1, p2) =&gt;
      if n == looking-for:
        1 + how-many-named(p1, looking-for) + how-many-named(p2, looking-for)
      else:
        how-many-named(p1, looking-for) + how-many-named(p2, looking-for)
      end
  end
end</code></pre><p>Let‚Äôs say you have defined this person:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p =
  person("A",
    person("B",
      person("A", unknown, unknown),
      person("C",
        person("A", unknown, unknown),
        person("B", unknown, unknown))),
    person("C", unknown, unknown))</code></pre><p>With that, we can write a test like
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  how-many-named(p, "A") is 3
end</code></pre>&#13;
<h3 class="heading">24.3¬†<a name="(part._.Refactoring)"/>Refactoring<a href="#(part._.Refactoring)" class="heading-anchor" title="Link to here">üîó</a> </h3><p>Now let‚Äôs apply some transformations, sometimes called code refactorings,
to this function.</p><p>First, notice the repeated expression. What the whole conditional is
essentially saying is that we want to know how much this person is contributing
to the overall count; the rest of the count stays the same regardless.</p><p>One way to make this more explicit is to (perhaps surprisingly)
rewrite the <code data-lang="pyret" class="sourceCode">else</code> to make explicit that a person with a
different name contributes <code data-lang="pyret" class="sourceCode">0</code> to the count:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun how-many-named(p, looking-for):
  cases (ABT) p:
    | unknown =&gt; 0
    | person(n, p1, p2) =&gt;
      if n == looking-for:
        1 + how-many-named(p1, looking-for) + how-many-named(p2, looking-for)
      else:
        0 + how-many-named(p1, looking-for) + how-many-named(p2, looking-for)
      end
  end
end</code></pre><p>The reason for this somewhat odd rewrite is that it makes clear what
is common and what is different. What is common is looking in the two
parents. What changes is how much this person contributes, and only
that depends on the conditional. We can therefore express this
more concisely (and, if we know how to read such code,
more meaningfully) as the following instead:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun how-many-named(p, looking-for):
  cases (ABT) p:
    | unknown =&gt; 0
    | person(n, p1, p2) =&gt;
      (if n == looking-for: 1 else: 0 end)
      +
      how-many-named(p1, looking-for) +
      how-many-named(p2, looking-for)
  end
end</code></pre><p>If you have prior programming experience, this may look a bit odd to you, but
<code data-lang="pyret" class="sourceCode">if</code> is in fact an expression, which has a value; in this case the value
is either <code data-lang="pyret" class="sourceCode">0</code> or <code data-lang="pyret" class="sourceCode">1</code>. This value can then be used in an addition.</p><p>Now let‚Äôs look at this code even more closely. Notice something interesting. We
keep passing two parameters to <code data-lang="pyret" class="sourceCode">how-many-named</code>; however, only one of
those parameters (<code data-lang="pyret" class="sourceCode">p</code>) is actually changing. The name we are
looking for does not change, as we would expect: we are looking for the same
name in the entire tree. How can we reflect this in the code?</p><p>First, we‚Äôll do something that looks a little useless, but it‚Äôs also an
innocent change, so it shouldn‚Äôt irk us too much: we‚Äôll change the order of the
arguments. That is, our contract changes from
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">how-many-named :: ABT, String -&gt; Number</code></pre><p>to
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">how-many-named :: String, ABT -&gt; Number</code></pre><p>so the function correspondingly changes to
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun how-many-named(looking-for, p):
  cases (ABT) p:
    | unknown =&gt; 0
    | person(n, p1, p2) =&gt;
      (if n == looking-for: 1 else: 0 end)
      +
      how-many-named(p1, looking-for) +
      how-many-named(p2, looking-for)
  end
end</code></pre><p>What we have now done is put the ‚Äúconstant‚Äù argument first, and the
‚Äúvarying‚Äù argument second.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Try this and make sure it works!</p></blockquote></blockquote><p>It doesn‚Äôt! We have to change more than
just the function header: we have to also change how it‚Äôs called. Keep
in mind it‚Äôs called twice within the function body itself, and also
from the examples. Therefore, the function as a whole reads:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun how-many-named(looking-for, p):
  cases (ABT) p:
    | unknown =&gt; 0
    | person(n, p1, p2) =&gt;
      (if n == looking-for: 1 else: 0 end)
      +
      how-many-named(looking-for, p1) +
      how-many-named(looking-for, p2)
  end
end</code></pre><p>and the example reads <code data-lang="pyret" class="sourceCode">how-many-named("A", p)</code>
instead.</p>&#13;
<h3 class="heading">24.4¬†<a name="(part._.Separating_.Parameters)"/>Separating Parameters<a href="#(part._.Separating_.Parameters)" class="heading-anchor" title="Link to here">üîó</a> </h3><p>This sets us up for the next stage. The parameters of functions are meant to
indicate what might vary in a function. Because the name we‚Äôre looking for is a
constant once we initially have it, we‚Äôd like the actual search function to
take only one argument: where in the tree we‚Äôre searching.</p><p>That is, we want the search function‚Äôs
contract to be <code data-lang="pyret" class="sourceCode">(ABT -&gt; Number)</code>. To achieve that, we need another
function that will take the <code data-lang="pyret" class="sourceCode">String</code> part.
Thus, the contract has to become
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">how-many-named :: String -&gt; (ABT -&gt; Number)</code></pre><p>where <code data-lang="pyret" class="sourceCode">how-many-named</code> consumes a name and returns a function that will
consume the actual tree to check.</p><p>This suggests the following function body:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun how-many-named(looking-for):
  lam(p :: ABT) -&gt; Number:
    cases (ABT) p:
      | unknown =&gt; 0
      | person(n, p1, p2) =&gt;
        (if n == looking-for: 1 else: 0 end)
        +
        how-many-named(looking-for, p1) +
        how-many-named(looking-for, p2)
    end
  end
end</code></pre><p>However, this function body is not okay: the Pyret type-checker will give us
type errors. That‚Äôs because <code data-lang="pyret" class="sourceCode">how-many-named</code> takes one parameter, not two,
as in the two recursive calls.</p><p>How do we fix this? Remember, the whole point of this change is we don‚Äôt want
to change the name, only the tree. That means we want to recur on the inner
function. We currently can‚Äôt do this because it doesn‚Äôt have a name! So we have
to give it a name and recur on it:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun how-many-named(looking-for):
  fun search-in(p :: ABT) -&gt; Number:
    cases (ABT) p:
      | unknown =&gt; 0
      | person(n, p1, p2) =&gt;
        (if n == looking-for: 1 else: 0 end)
        +
        search-in(p1) +
        search-in(p2)
    end
  end
end</code></pre><p>This now lets us recur on just the part that should vary, leaving the name
we‚Äôre looking for unchanged (and hence, fixed for the duration of the
search).</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Try the above and make sure it works.</p></blockquote></blockquote><p>It still doesn‚Äôt: the above body has a syntax error! This is because <code data-lang="pyret" class="sourceCode">how-many-named</code>
does not actually return any kind of value.</p><p>What should it return? Once we provide the function with a name, we should get
back a function that searches for that name in a tree. But we already
have exactly such a function: <code data-lang="pyret" class="sourceCode">search-in</code>. Therefore,
<code data-lang="pyret" class="sourceCode">how-many-named</code> should return just ‚Ä¶ <code data-lang="pyret" class="sourceCode">search-in</code>.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun how-many-named(looking-for):
  fun search-in(p :: ABT) -&gt; Number:
    cases (ABT) p:
      | unknown =&gt; 0
      | person(n, p1, p2) =&gt;
        (if n == looking-for: 1 else: 0 end)
        +
        search-in(p1) +
        search-in(p2)
    end
  end

  search-in
end</code></pre><p>This still won‚Äôt work, because we haven‚Äôt changed the example. Let‚Äôs
update that: how do we use <code data-lang="pyret" class="sourceCode">how-many-named</code>? We have to call it
with a name (like <code data-lang="pyret" class="sourceCode">"A"</code>); this returns a function‚Äî<wbr/>the
one bound to <code data-lang="pyret" class="sourceCode">search-in</code>‚Äî<wbr/>which expects a ancestor tree. Doing
so should return a count. Thus, the example should be rewritten as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">how-many-As = how-many-named("A")
how-many-As(p) is 3</code></pre><p>This is an instructive way to write the example. We can, however, also
write it more concisely. Notice that <code data-lang="pyret" class="sourceCode">how-many-named("A")</code>
returns a function, and the way we apply a function to arguments is
<code data-lang="pyret" class="sourceCode">(‚Ä¶)</code>. Thus, we can also write this as:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">how-many-named("A")(p) is 3</code></pre>&#13;
<h3 class="heading">24.5¬†<a name="(part._.Context)"/>Context<a href="#(part._.Context)" class="heading-anchor" title="Link to here">üîó</a> </h3><p>The transformation we just applied is generally called currying, in honor
of Haskell Curry, who was one of the early people to describe it, though it was
earlier discovered by Moses Sch√∂nfinkel and even earlier by Gottlob Frege. The
particular use of currying here, where we move more ‚Äústatic‚Äù arguments
earlier and more ‚Äúdynamic‚Äù ones later, and split on the static-dynamic
divide, is called staging. It‚Äôs a very useful programming technique, and
furthermore, one that enables some compilers to produce more time-efficient
programs.</p><p>Even more subtly but importantly, the staged computation tells a different
story than the unstaged one, and we can read this off just from the contract:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">how-many-named :: String, ABT -&gt; Number
how-many-named :: String -&gt; (ABT -&gt; Number)</code></pre><p>The first one says the string could co-vary with the person. The second one
rules out that interpretation.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Is the former useful? When might we have the name also changing?</p></blockquote></blockquote><p>Imagine a slightly different problem: we want to know how often a child has the
same name as a parent. Then, as we traverse the tree, as the name of the person
(potentially) keeps changing, the name we‚Äôre looking for in the parent also
changes.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write this function.</p></blockquote></blockquote><p>In contrast, the staged type rules out that interpretation and that
behavior. In that way, it sends a signal to the reader about how the
computation might behave just from the type. In the same way, the unstaged type
can be read as giving the reader a hint that the behavior could depend on both
parameters changing, therefore accommodating a much broader range of behaviors
(e.g., checking for parent-child or grandparent-child name reuse).</p><p>There‚Äôs another very nice example of staging here:
<a href="func-as-data.html#%28part._fd-calculus%29" data-pltdoc="x">A Little Calculus</a>.</p><p>Finally, it‚Äôs worth knowing that some languages, like Haskell and
OCaml, do this transformation automatically. In fact, they don‚Äôt even
have multiple-parameter functions: what look like multiple arguments
are actually a sequence of staged functions. This can, in extremis,
lead to a very elegant and powerful programming style. Pyret chose to
not do this because, while this is a powerful tool in the hands of
advanced programmers, for less experienced programmers, finding out
about a mismatch in the number of parameters and arguments is very
useful.</p>    
</body>
</html>