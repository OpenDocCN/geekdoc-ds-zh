- en: Affine Body Dynamics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://phys-sim-book.github.io/lec25.3-affine_body_dynamics.html](https://phys-sim-book.github.io/lec25.3-affine_body_dynamics.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we reviewed rigid body dynamics and implemented a simple solver
    using explicit integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with many rigid bodies — especially with complex geometry and
    dense contact — it’s natural to attempt IPC for contact resolution. However, representing
    a rigid body by its position x and rotation q creates a challenge: step size filtering
    in Newton’s method becomes nonlinear in α, due to the nonlinearity of quaternion
    update.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let the state of a rigid body be denoted by y=(x,q), where x is the center
    of mass and q is a unit quaternion representing orientation. During a Newton iteration,
    let the update direction be p=(px​,pq​) with step size α, so that the updated
    state is given by y~​=y+αp. The position of a vertex initially located at xv(0)​
    is then transformed to:'
  prefs: []
  type: TYPE_NORMAL
- en: xv​=q​(xv(0)​−x(0))q​−1+x
  prefs: []
  type: TYPE_NORMAL
- en: 'Expanding this shows x~v​ is nonlinear in α:'
  prefs: []
  type: TYPE_NORMAL
- en: xv​=(q+αpq​)(xv(0)​−x(0))(q+αpq​)−1+x+αpx​ and since q​ depends nonlinearly
    on α, so does x~v​. Hence, linear CCD may fail to guarantee intersection-free
    motion.
  prefs: []
  type: TYPE_NORMAL
- en: We could model rigid bodies as very stiff soft bodies (e.g., mass-spring or
    hyperelastic), but this is inefficient and negates the DOF-reduction benefit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Affine Body Dynamics (ABD) [[Lan et al. 2022]](bibliography.html#lan2022affine)
    addresses this: instead of strict rigidity, we allow tiny affine deformations
    xˉ↦x=Ax+b for each vertex x of the body where xˉ denotes the rest position. The
    body state is y=(bT,a1T​,a2T​,a3T​) where A=(a1​,a2​,a3​)T, so the vertex position
    x becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: x=Jy​
  prefs: []
  type: TYPE_NORMAL
- en: with J=(I3×3​,I3×3​⊗xˉT) where ⊗ denotes the Kronecker product.
  prefs: []
  type: TYPE_NORMAL
- en: This linearity makes x linearly dependent on the optimization step size α, enabling
    robust linear CCD.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let E(x) be the augmented IPC energy. Original IPC solves: ∇x​E(x)=0​'
  prefs: []
  type: TYPE_NORMAL
- en: 'ABD solves in a reduced subspace:'
  prefs: []
  type: TYPE_NORMAL
- en: ∇y​E(Jy)=0​
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the chain rule:'
  prefs: []
  type: TYPE_NORMAL
- en: ∇y​E(Jy)Dy2​E(Jy)​=JT∇x​E(x)=JTDx2​E(x)J​(25.3.1) , we can solve Newton Optimization
    direction by solving the linear system JTDx2​E(x)J=−JT∇x​E(x).
  prefs: []
  type: TYPE_NORMAL
- en: With these, we can implement ABD using implicit Euler integration for a simple
    2D case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before implementation, consider this geometric view: in 2D, an affine transformation
    is determined by 3 points. Choosing a triangle per rigid body, we can interpolate
    all vertices via barycentric coordinates. The triangle drives the simulation;
    the original mesh is used for collisions. This yields a reduced DOF system where
    the triangle controls motion—essentially what ABD does.'
  prefs: []
  type: TYPE_NORMAL
