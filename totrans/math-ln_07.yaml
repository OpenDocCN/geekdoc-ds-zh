- en: 7\. Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C07_Structures.html](https://leanprover-community.github.io/mathematics_in_lean/C07_Structures.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*[Mathematics in Lean](index.html)* **   7\. Structures'
  prefs: []
  type: TYPE_NORMAL
- en: '[View page source](_sources/C07_Structures.rst.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Modern mathematics makes essential use of algebraic structures, which encapsulate
    patterns that can be instantiated in multiple settings. The subject provides various
    ways of defining such structures and constructing particular instances.
  prefs: []
  type: TYPE_NORMAL
- en: Lean therefore provides corresponding ways of defining structures formally and
    working with them. You have already seen examples of algebraic structures in Lean,
    such as rings and lattices, which were discussed in [Chapter 2](C02_Basics.html#basics).
    This chapter will explain the mysterious square bracket annotations that you saw
    there, `[Ring α]` and `[Lattice α]`. It will also show you how to define and use
    algebraic structures on your own.
  prefs: []
  type: TYPE_NORMAL
- en: For more technical detail, you can consult [Theorem Proving in Lean](https://leanprover.github.io/theorem_proving_in_lean/),
    and a paper by Anne Baanen, [Use and abuse of instance parameters in the Lean
    mathematical library](https://arxiv.org/abs/2202.01629).
  prefs: []
  type: TYPE_NORMAL
- en: '## 7.1\. Defining structures[](#defining-structures "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the broadest sense of the term, a *structure* is a specification of a collection
    of data, possibly with constraints that the data is required to satisfy. An *instance*
    of the structure is a particular bundle of data satisfying the constraints. For
    example, we can specify that a point is a tuple of three real numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `@[ext]` annotation tells Lean to automatically generate theorems that can
    be used to prove that two instances of a structure are equal when their components
    are equal, a property known as *extensionality*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can then define particular instances of the `Point` structure. Lean provides
    multiple ways of doing that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, the fields of the structure are named explicitly. The
    function `Point.mk` referred to in the definition of `myPoint3` is known as the
    *constructor* for the `Point` structure, because it serves to construct elements.
    You can specify a different name if you want, like `build`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The next two examples show how to define functions on structures. Whereas the
    second example makes the `Point.mk` constructor explicit, the first example uses
    an anonymous constructor for brevity. Lean can infer the relevant constructor
    from the indicated type of `add`. It is conventional to put definitions and theorems
    associated with a structure like `Point` in a namespace with the same name. In
    the example below, because we have opened the `Point` namespace, the full name
    of `add` is `Point.add`. When the namespace is not open, we have to use the full
    name. But remember that it is often convenient to use anonymous projection notation,
    which allows us to write `a.add b` instead of `Point.add a b`. Lean interprets
    the former as the latter because `a` has type `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Below we will continue to put definitions in the relevant namespace, but we
    will leave the namespacing commands out of the quoted snippets. To prove properties
    of the addition function, we can use `rw` to expand the definition and `ext` to
    reduce an equation between two elements of the structure to equations between
    the components. Below we use the `protected` keyword so that the name of the theorem
    is `Point.add_comm`, even when the namespace is open. This is helpful when we
    want to avoid ambiguity with a generic theorem like `add_comm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Because Lean can unfold definitions and simplify projections internally, sometimes
    the equations we want hold definitionally.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to define functions on structures using pattern matching,
    in a manner similar to the way we defined recursive functions in [Section 5.2](C05_Elementary_Number_Theory.html#section-induction-and-recursion).
    The definitions `addAlt` and `addAlt'` below are essentially the same; the only
    difference is that we use anonymous constructor notation in the second. Although
    it is sometimes convenient to define functions this way, and structural eta-reduction
    makes this alternative definitionally equivalent, it can make things less convenient
    in later proofs. In particular, `rw [addAlt]` leaves us with a messier goal view
    containing a `match` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Mathematical constructions often involve taking apart bundled information and
    putting it together again in different ways. It therefore makes sense that Lean
    and Mathlib offer so many ways of doing this efficiently. As an exercise, try
    proving that `Point.add` is associative. Then define scalar multiplication for
    a point and show that it distributes over addition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using structures is only the first step on the road to algebraic abstraction.
    We don’t yet have a way to link `Point.add` to the generic `+` symbol, or to connect
    `Point.add_comm` and `Point.add_assoc` to the generic `add_comm` and `add_assoc`
    theorems. These tasks belong to the *algebraic* aspect of using structures, and
    we will explain how to carry them out in the next section. For now, just think
    of a structure as a way of bundling together objects and information.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is especially useful that a structure can specify not only data types but
    also constraints that the data must satisfy. In Lean, the latter are represented
    as fields of type `Prop`. For example, the *standard 2-simplex* is defined to
    be the set of points \((x, y, z)\) satisfying \(x ≥ 0\), \(y ≥ 0\), \(z ≥ 0\),
    and \(x + y + z = 1\). If you are not familiar with the notion, you should draw
    a picture, and convince yourself that this set is the equilateral triangle in
    three-space with vertices \((1, 0, 0)\), \((0, 1, 0)\), and \((0, 0, 1)\), together
    with its interior. We can represent it in Lean as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the last four fields refer to `x`, `y`, and `z`, that is, the first
    three fields. We can define a map from the two-simplex to itself that swaps `x`
    and `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: More interestingly, we can compute the midpoint of two points on the simplex.
    We have added the phrase `noncomputable section` at the beginning of this file
    in order to use division on the real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here we have established `x_nonneg`, `y_nonneg`, and `z_nonneg` with concise
    proof terms, but establish `sum_eq` in tactic mode, using `by`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a parameter \(\lambda\) satisfying \(0 \le \lambda \le 1\), we can take
    the weighted average \(\lambda a + (1 - \lambda) b\) of two points \(a\) and \(b\)
    in the standard 2-simplex. We challenge you to define that function, in analogy
    to the `midpoint` function above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Structures can depend on parameters. For example, we can generalize the standard
    2-simplex to the standard \(n\)-simplex for any \(n\). At this stage, you don’t
    have to know anything about the type `Fin n` except that it has \(n\) elements,
    and that Lean knows how to sum over it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, see if you can define the weighted average of two points in
    the standard \(n\)-simplex. You can use `Finset.sum_add_distrib` and `Finset.mul_sum`
    to manipulate the relevant sums.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that structures can be used to bundle together data and properties.
    Interestingly, they can also be used to bundle together properties without the
    data. For example, the next structure, `IsLinear`, bundles together the two components
    of linearity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is worth pointing out that structures are not the only way to bundle together
    data. The `Point` data structure can be defined using the generic type product,
    and `IsLinear` can be defined with a simple `and`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Generic type constructions can even be used in place of structures with dependencies
    between their components. For example, the *subtype* construction combines a piece
    of data with a property. You can think of the type `PReal` in the next example
    as being the type of positive real numbers. Any `x : PReal` has two components:
    the value, and the property of being positive. You can access these components
    as `x.val`, which has type `ℝ`, and `x.property`, which represents the fact `0
    < x.val`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We could have used subtypes to define the standard 2-simplex, as well as the
    standard \(n\)-simplex for an arbitrary \(n\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, *Sigma types* are generalizations of ordered pairs, whereby the type
    of the second component depends on the type of the first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Given `s : StdSimplex`, the first component `s.fst` is a natural number, and
    the second component is an element of the corresponding simplex `StandardSimplex
    s.fst`. The difference between a Sigma type and a subtype is that the second component
    of a Sigma type is data rather than a proposition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But even though we can use products, subtypes, and Sigma types instead of structures,
    using structures has a number of advantages. Defining a structure abstracts away
    the underlying representation and provides custom names for the functions that
    access the components. This makes proofs more robust: proofs that rely only on
    the interface to a structure will generally continue to work when we change the
    definition, as long as we redefine the old accessors in terms of the new definition.
    Moreover, as we are about to see, Lean provides support for weaving structures
    together into a rich, interconnected hierarchy, and for managing the interactions
    between them.  ## 7.2\. Algebraic Structures[](#algebraic-structures "Link to
    this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: To clarify what we mean by the phrase *algebraic structure*, it will help to
    consider some examples.
  prefs: []
  type: TYPE_NORMAL
- en: A *partially ordered set* consists of a set \(P\) and a binary relation \(\le\)
    on \(P\) that is transitive and reflexive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A *group* consists of a set \(G\) with an associative binary operation, an identity
    element \(1\), and a function \(g \mapsto g^{-1}\) that returns an inverse for
    each \(g\) in \(G\). A group is *abelian* or *commutative* if the operation is
    commutative.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A *lattice* is a partially ordered set with meets and joins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A *ring* consists of an (additively written) abelian group \((R, +, 0, x \mapsto
    -x)\) together with an associative multiplication operation \(\cdot\) and an identity
    \(1\), such that multiplication distributes over addition. A ring is *commutative*
    if the multiplication is commutative.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An *ordered ring* \((R, +, 0, -, \cdot, 1, \le)\) consists of a ring together
    with a partial order on its elements, such that \(a \le b\) implies \(a + c \le
    b + c\) for every \(a\), \(b\), and \(c\) in \(R\), and \(0 \le a\) and \(0 \le
    b\) implies \(0 \le a b\) for every \(a\) and \(b\) in \(R\).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A *metric space* consists of a set \(X\) and a function \(d : X \times X \to
    \mathbb{R}\) such that the following hold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \(d(x, y) \ge 0\) for every \(x\) and \(y\) in \(X\).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: \(d(x, y) = 0\) if and only if \(x = y\).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: \(d(x, y) = d(y, x)\) for every \(x\) and \(y\) in \(X\).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: \(d(x, z) \le d(x, y) + d(y, z)\) for every \(x\), \(y\), and \(z\) in \(X\).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A *topological space* consists of a set \(X\) and a collection \(\mathcal T\)
    of subsets of \(X\), called the *open subsets of* \(X\), such that the following
    hold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The empty set and \(X\) are open.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The intersection of two open sets is open.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An arbitrary union of open sets is open.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In each of these examples, the elements of the structure belong to a set, the
    *carrier set*, that sometimes stands proxy for the entire structure. For example,
    when we say “let \(G\) be a group” and then “let \(g \in G\),” we are using \(G\)
    to stand for both the structure and its carrier. Not every algebraic structure
    is associated with a single carrier set in this way. For example, a *bipartite
    graph* involves a relation between two sets, as does a *Galois connection*, A
    *category* also involves two sets of interest, commonly called the *objects* and
    the *morphisms*.
  prefs: []
  type: TYPE_NORMAL
- en: The examples indicate some of the things that a proof assistant has to do in
    order to support algebraic reasoning. First, it needs to recognize concrete instances
    of structures. The number systems \(\mathbb{Z}\), \(\mathbb{Q}\), and \(\mathbb{R}\)
    are all ordered rings, and we should be able to apply a generic theorem about
    ordered rings in any of these instances. Sometimes a concrete set may be an instance
    of a structure in more than one way. For example, in addition to the usual topology
    on \(\mathbb{R}\), which forms the basis for real analysis, we can also consider
    the *discrete* topology on \(\mathbb{R}\), in which every set is open.
  prefs: []
  type: TYPE_NORMAL
- en: Second, a proof assistant needs to support generic notation on structures. In
    Lean, the notation `*` is used for multiplication in all the usual number systems,
    as well as for multiplication in generic groups and rings. When we use an expression
    like `f x * y`, Lean has to use information about the types of `f`, `x`, and `y`
    to determine which multiplication we have in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Third, it needs to deal with the fact that structures can inherit definitions,
    theorems, and notation from other structures in various ways. Some structures
    extend others by adding more axioms. A commutative ring is still a ring, so any
    definition that makes sense in a ring also makes sense in a commutative ring,
    and any theorem that holds in a ring also holds in a commutative ring. Some structures
    extend others by adding more data. For example, the additive part of any ring
    is an additive group. The ring structure adds a multiplication and an identity,
    as well as axioms that govern them and relate them to the additive part. Sometimes
    we can define one structure in terms of another. Any metric space has a canonical
    topology associated with it, the *metric space topology*, and there are various
    topologies that can be associated with any linear ordering.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is important to keep in mind that mathematics allows us to use functions
    and operations to define structures in the same way we use functions and operations
    to define numbers. Products and powers of groups are again groups. For every \(n\),
    the integers modulo \(n\) form a ring, and for every \(k > 0\), the \(k \times
    k\) matrices of polynomials with coefficients in that ring again form a ring.
    Thus we can calculate with structures just as easily as we can calculate with
    their elements. This means that algebraic structures lead dual lives in mathematics,
    as containers for collections of objects and as objects in their own right. A
    proof assistant has to accommodate this dual role.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with elements of a type that has an algebraic structure associated
    with it, a proof assistant needs to recognize the structure and find the relevant
    definitions, theorems, and notation. All this should sound like a lot of work,
    and it is. But Lean uses a small collection of fundamental mechanisms to carry
    out these tasks. The goal of this section is to explain these mechanisms and show
    you how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first ingredient is almost too obvious to mention: formally speaking, algebraic
    structures are structures in the sense of [Section 7.1](#section-structures).
    An algebraic structure is a specification of a bundle of data satisfying some
    axiomatic hypotheses, and we saw in [Section 7.1](#section-structures) that this
    is exactly what the `structure` command is designed to accommodate. It’s a marriage
    made in heaven!'
  prefs: []
  type: TYPE_NORMAL
- en: Given a data type `α`, we can define the group structure on `α` as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the type `α` is a *parameter* in the definition of `Group₁`. So
    you should think of an object `struc : Group₁ α` as being a group structure on
    `α`. We saw in [Section 2.2](C02_Basics.html#proving-identities-in-algebraic-structures)
    that the counterpart `mul_inv_cancel` to `inv_mul_cancel` follows from the other
    group axioms, so there is no need to add it to the definition.'
  prefs: []
  type: TYPE_NORMAL
- en: This definition of a group is similar to the definition of `Group` in Mathlib,
    and we have chosen the name `Group₁` to distinguish our version. If you write
    `#check Group` and ctrl-click on the definition, you will see that the Mathlib
    version of `Group` is defined to extend another structure; we will explain how
    to do that later. If you type `#print Group` you will also see that the Mathlib
    version of `Group` has a number of extra fields. For reasons we will explain later,
    sometimes it is useful to add redundant information to a structure, so that there
    are additional fields for objects and functions that can be defined from the core
    data. Don’t worry about that for now. Rest assured that our simplified version
    `Group₁` is morally the same as the definition of a group that Mathlib uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is sometimes useful to bundle the type together with the structure, and
    Mathlib also contains a definition of a `Grp` structure that is equivalent to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The Mathlib version is found in `Mathlib.Algebra.Category.Grp.Basic`, and you
    can `#check` it if you add this to the imports at the beginning of the examples
    file.
  prefs: []
  type: TYPE_NORMAL
- en: For reasons that will become clearer below, it is more often useful to keep
    the type `α` separate from the structure `Group α`. We refer to the two objects
    together as a *partially bundled structure*, since the representation combines
    most, but not all, of the components into one structure. It is common in Mathlib
    to use capital roman letters like `G` for a type when it is used as the carrier
    type for a group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s construct a group, which is to say, an element of the `Group₁` type.
    For any pair of types `α` and `β`, Mathlib defines the type `Equiv α β` of *equivalences*
    between `α` and `β`. Mathlib also defines the suggestive notation `α ≃ β` for
    this type. An element `f : α ≃ β` is a bijection between `α` and `β` represented
    by four components: a function `f.toFun` from `α` to `β`, the inverse function
    `f.invFun` from `β` to `α`, and two properties that specify these functions are
    indeed inverse to one another.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice the creative naming of the last three constructions. We think of the
    identity function `Equiv.refl`, the inverse operation `Equiv.symm`, and the composition
    operation `Equiv.trans` as explicit evidence that the property of being in bijective
    correspondence is an equivalence relation.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that `f.trans g` requires composing the forward functions in reverse
    order. Mathlib has declared a *coercion* from `Equiv α β` to the function type
    `α → β`, so we can omit writing `.toFun` and have Lean insert it for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Mathlib also defines the type `perm α` of equivalences between `α` and itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be clear that `Equiv.Perm α` forms a group under composition of equivalences.
    We orient things so that `mul f g` is equal to `g.trans f`, whose forward function
    is `f ∘ g`. In other words, multiplication is what we ordinarily think of as composition
    of the bijections. Here we define this group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In fact, Mathlib defines exactly this `Group` structure on `Equiv.Perm α` in
    the file `Algebra.Group.End`. As always, you can hover over the theorems used
    in the definition of `permGroup` to see their statements, and you can jump to
    their definitions in the original file to learn more about how they are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: In ordinary mathematics, we generally think of notation as independent of structure.
    For example, we can consider groups \((G_1, \cdot, 1, \cdot^{-1})\), \((G_2, \circ,
    e, i(\cdot))\), and \((G_3, +, 0, -)\). In the first case, we write the binary
    operation as \(\cdot\), the identity as \(1\), and the inverse function as \(x
    \mapsto x^{-1}\). In the second and third cases, we use the notational alternatives
    shown. When we formalize the notion of a group in Lean, however, the notation
    is more tightly linked to the structure. In Lean, the components of any `Group`
    are named `mul`, `one`, and `inv`, and in a moment we will see how multiplicative
    notation is set up to refer to them. If we want to use additive notation, we instead
    use an isomorphic structure `AddGroup` (the structure underlying additive groups).
    Its components are named `add`, `zero`, and `neg`, and the associated notation
    is what you would expect it to be.
  prefs: []
  type: TYPE_NORMAL
- en: Recall the type `Point` that we defined in [Section 7.1](#section-structures),
    and the addition function that we defined there. These definitions are reproduced
    in the examples file that accompanies this section. As an exercise, define an
    `AddGroup₁` structure that is similar to the `Group₁` structure we defined above,
    except that it uses the additive naming scheme just described. Define negation
    and a zero on the `Point` data type, and define the `AddGroup₁` structure on `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We are making progress. Now we know how to define algebraic structures in Lean,
    and we know how to define instances of those structures. But we also want to associate
    notation with structures so that we can use it with each instance. Moreover, we
    want to arrange it so that we can define an operation on a structure and use it
    with any particular instance, and we want to arrange it so that we can prove a
    theorem about a structure and use it with any instance.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, Mathlib is already set up to use generic group notation, definitions,
    and theorems for `Equiv.Perm α`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can check that this is not the case for the additive group structure on
    `Point` that we asked you to define above. Our task now is to understand that
    magic that goes on under the hood in order to make the examples for `Equiv.Perm
    α` work the way they do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The issue is that Lean needs to be able to *find* the relevant notation and
    the implicit group structure, using the information that is found in the expressions
    that we type. Similarly, when we write `x + y` with expressions `x` and `y` that
    have type `ℝ`, Lean needs to interpret the `+` symbol as the relevant addition
    function on the reals. It also has to recognize the type `ℝ` as an instance of
    a commutative ring, so that all the definitions and theorems for a commutative
    ring are available. For another example, continuity is defined in Lean relative
    to any two topological spaces. When we have `f : ℝ → ℂ` and we write `Continuous
    f`, Lean has to find the relevant topologies on `ℝ` and `ℂ`.'
  prefs: []
  type: TYPE_NORMAL
- en: The magic is achieved with a combination of three things.
  prefs: []
  type: TYPE_NORMAL
- en: '*Logic.* A definition that should be interpreted in any group takes, as arguments,
    the type of the group and the group structure as arguments. Similarly, a theorem
    about the elements of an arbitrary group begins with universal quantifiers over
    the type of the group and the group structure.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Implicit arguments.* The arguments for the type and the structure are generally
    left implicit, so that we do not have to write them or see them in the Lean information
    window. Lean fills the information in for us silently.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Type class inference.* Also known as *class inference*, this is a simple but
    powerful mechanism that enables us to register information for Lean to use later
    on. When Lean is called on to fill in implicit arguments to a definition, theorem,
    or piece of notation, it can make use of information that has been registered.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Whereas an annotation `(grp : Group G)` tells Lean that it should expect to
    be given that argument explicitly and the annotation `{grp : Group G}` tells Lean
    that it should try to figure it out from contextual cues in the expression, the
    annotation `[grp : Group G]` tells Lean that the corresponding argument should
    be synthesized using type class inference. Since the whole point to the use of
    such arguments is that we generally do not need to refer to them explicitly, Lean
    allows us to write `[Group G]` and leave the name anonymous. You have probably
    already noticed that Lean chooses names like `_inst_1` automatically. When we
    use the anonymous square-bracket annotation with the `variables` command, then
    as long as the variables are still in scope, Lean automatically adds the argument
    `[Group G]` to any definition or theorem that mentions `G`.'
  prefs: []
  type: TYPE_NORMAL
- en: How do we register the information that Lean needs to use to carry out the search?
    Returning to our group example, we need only make two changes. First, instead
    of using the `structure` command to define the group structure, we use the keyword
    `class` to indicate that it is a candidate for class inference. Second, instead
    of defining particular instances with `def`, we use the keyword `instance` to
    register the particular instance with Lean. As with the names of class variables,
    we are allowed to leave the name of an instance definition anonymous, since in
    general we intend Lean to find it and put it to use without troubling us with
    the details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The following illustrates their use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#check` command shows that `Group₂.mul` has an implicit argument `[Group₂
    α]` that we expect to be found by class inference, where `α` is the type of the
    arguments to `Group₂.mul`. In other words, `{α : Type*}` is the implicit argument
    for the type of the group elements and `[Group₂ α]` is the implicit argument for
    the group structure on `α`. Similarly, when we define a generic squaring function
    `my_square` for `Group₂`, we use an implicit argument `{α : Type*}` for the type
    of the elements and an implicit argument `[Group₂ α]` for the `Group₂` structure.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, when we write `Group₂.mul f g`, the type of `f` and `g`
    tells Lean that in the argument `α` to `Group₂.mul` has to be instantiated to
    `Equiv.Perm β`. That means that Lean has to find an element of `Group₂ (Equiv.Perm
    β)`. The previous `instance` declaration tells Lean exactly how to do that. Problem
    solved!
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple mechanism for registering information so that Lean can find it
    when it needs it is remarkably useful. Here is one way it comes up. In Lean’s
    foundation, a data type `α` may be empty. In a number of applications, however,
    it is useful to know that a type has at least one element. For example, the function
    `List.headI`, which returns the first element of a list, can return the default
    value when the list is empty. To make that work, the Lean library defines a class
    `Inhabited α`, which does nothing more than store a default value. We can show
    that the `Point` type is an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The class inference mechanism is also used for generic notation. The expression
    `x + y` is an abbreviation for `Add.add x y` where—you guessed it—`Add α` is a
    class that stores a binary function on `α`. Writing `x + y` tells Lean to find
    a registered instance of `[Add.add α]` and use the corresponding function. Below,
    we register the addition function for `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we can assign the notation `+` to binary operations on other types
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can do even better. We have seen that `*` can be used in any group,
    `+` can be used in any additive group, and both can be used in any ring. When
    we define a new instance of a ring in Lean, we don’t have to define `+` and `*`
    for that instance, because Lean knows that these are defined for every ring. We
    can use this method to specify notation for our `Group₂` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: What makes this approach work is that Lean carries out a recursive search. According
    to the instances we have declared, Lean can find an instance of `Mul (Equiv.Perm
    α)` by finding an instance of `Group₂ (Equiv.Perm α)`, and it can find an instance
    of `Group₂ (Equiv.Perm α)` because we have provided one. Lean is capable of finding
    these two facts and chaining them together.
  prefs: []
  type: TYPE_NORMAL
- en: The example we have just given is dangerous, because Lean’s library also has
    an instance of `Group (Equiv.Perm α)`, and multiplication is defined on any group.
    So it is ambiguous as to which instance is found. In fact, Lean favors more recent
    declarations unless you explicitly specify a different priority. Also, there is
    another way to tell Lean that one structure is an instance of another, using the
    `extends` keyword. This is how Mathlib specifies that, for example, every commutative
    ring is a ring. You can find more information in [Section 8](C08_Hierarchies.html#hierarchies)
    and in a [section on class inference](https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#managing-type-class-inference)
    in *Theorem Proving in Lean*.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is a bad idea to specify a value of `*` for an instance of an
    algebraic structure that already has the notation defined. Redefining the notion
    of `Group` in Lean is an artificial example. In this case, however, both interpretations
    of the group notation unfold to `Equiv.trans`, `Equiv.refl`, and `Equiv.symm`,
    in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: As a similarly artificial exercise, define a class `AddGroup₂` in analogy to
    `Group₂`. Define the usual notation for addition, negation, and zero on any `AddGroup₂`
    using the classes `Add`, `Neg`, and `Zero`. Then show `Point` is an instance of
    `AddGroup₂`. Try it out and make sure that the additive group notation works for
    elements of `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It is not a big problem that we have already declared instances `Add`, `Neg`,
    and `Zero` for `Point` above. Once again, the two ways of synthesizing the notation
    should come up with the same answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class inference is subtle, and you have to be careful when using it, because
    it configures automation that invisibly governs the interpretation of the expressions
    we type. When used wisely, however, class inference is a powerful tool. It is
    what makes algebraic reasoning possible in Lean.  ## 7.3\. Building the Gaussian
    Integers[](#building-the-gaussian-integers "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: We will now illustrate the use of the algebraic hierarchy in Lean by building
    an important mathematical object, the *Gaussian integers*, and showing that it
    is a Euclidean domain. In other words, according to the terminology we have been
    using, we will define the Gaussian integers and show that they are an instance
    of the Euclidean domain structure.
  prefs: []
  type: TYPE_NORMAL
- en: In ordinary mathematical terms, the set of Gaussian integers \(\Bbb{Z}[i]\)
    is the set of complex numbers \(\{ a + b i \mid a, b \in \Bbb{Z}\}\). But rather
    than define them as a subset of the complex numbers, our goal here is to define
    them as a data type in their own right. We do this by representing a Gaussian
    integer as a pair of integers, which we think of as the *real* and *imaginary*
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We first show that the Gaussian integers have the structure of a ring, with
    `0` defined to be `⟨0, 0⟩`, `1` defined to be `⟨1, 0⟩`, and addition defined pointwise.
    To work out the definition of multiplication, remember that we want the element
    \(i\), represented by `⟨0, 1⟩`, to be a square root of \(-1\). Thus we want
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}(a + bi) (c + di) & = ac + bci + adi + bd i^2 \\ & = (ac - bd)
    + (bc + ad)i.\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: This explains the definition of `Mul` below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As noted in [Section 7.1](#section-structures), it is a good idea to put all
    the definitions related to a data type in a namespace with the same name. Thus
    in the Lean files associated with this chapter, these definitions are made in
    the `GaussInt` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that here we are defining the interpretations of the notation `0`, `1`,
    `+`, `-`, and `*` directly, rather than naming them `GaussInt.zero` and the like
    and assigning the notation to those. It is often useful to have an explicit name
    for the definitions, for example, to use with `simp` and `rw`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It is also useful to name the rules that compute the real and imaginary parts,
    and to declare them to the simplifier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: It is now surprisingly easy to show that the Gaussian integers are an instance
    of a commutative ring. We are putting the structure concept to good use. Each
    particular Gaussian integer is an instance of the `GaussInt` structure, whereas
    the type `GaussInt` itself, together with the relevant operations, is an instance
    of the `CommRing` structure. The `CommRing` structure, in turn, extends the notational
    structures `Zero`, `One`, `Add`, `Neg`, and `Mul`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you type `instance : CommRing GaussInt := _`, click on the light bulb that
    appears in VS Code, and then ask Lean to fill in a skeleton for the structure
    definition, you will see a scary number of entries. Jumping to the definition
    of the structure, however, shows that many of the fields have default definitions
    that Lean will fill in for you automatically. The essential ones appear in the
    definition below. A special case are `nsmul` and `zsmul` which should be ignored
    for now and will be explained in the next chapter. In each case, the relevant
    identity is proved by unfolding definitions, using the `ext` tactic to reduce
    the identities to their real and imaginary components, simplifying, and, if necessary,
    carrying out the relevant ring calculation in the integers. Note that we could
    easily avoid repeating all this code, but this is not the topic of the current
    discussion.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Lean’s library defines the class of *nontrivial* types to be types with at least
    two distinct elements. In the context of a ring, this is equivalent to saying
    that the zero is not equal to the one. Since some common theorems depend on that
    fact, we may as well establish it now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now show that the Gaussian integers have an important additional property.
    A *Euclidean domain* is a ring \(R\) equipped with a *norm* function \(N : R \to
    \mathbb{N}\) with the following two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: For every \(a\) and \(b \ne 0\) in \(R\), there are \(q\) and \(r\) in \(R\)
    such that \(a = bq + r\) and either \(r = 0\) or \(N(r) < N(b)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every \(a\) and \(b \ne 0\), \(N(a) \le N(ab)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ring of integers \(\Bbb{Z}\) with \(N(a) = |a|\) is an archetypal example
    of a Euclidean domain. In that case, we can take \(q\) to be the result of integer
    division of \(a\) by \(b\) and \(r\) to be the remainder. These functions are
    defined in Lean so that the satisfy the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In an arbitrary ring, an element \(a\) is said to be a *unit* if it divides
    \(1\). A nonzero element \(a\) is said to be *irreducible* if it cannot be written
    in the form \(a = bc\) where neither \(b\) nor \(c\) is a unit. In the integers,
    every irreducible element \(a\) is *prime*, which is to say, whenever \(a\) divides
    a product \(bc\), it divides either \(b\) or \(c\). But in other rings this property
    can fail. In the ring \(\Bbb{Z}[\sqrt{-5}]\), we have
  prefs: []
  type: TYPE_NORMAL
- en: \[6 = 2 \cdot 3 = (1 + \sqrt{-5})(1 - \sqrt{-5}),\]
  prefs: []
  type: TYPE_NORMAL
- en: 'and the elements \(2\), \(3\), \(1 + \sqrt{-5}\), and \(1 - \sqrt{-5}\) are
    all irreducible, but they are not prime. For example, \(2\) divides the product
    \((1 + \sqrt{-5})(1 - \sqrt{-5})\), but it does not divide either factor. In particular,
    we no longer have unique factorization: the number \(6\) can be factored into
    irreducible elements in more than one way.'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, every Euclidean domain is a unique factorization domain, which
    implies that every irreducible element is prime. The axioms for a Euclidean domain
    imply that one can write any nonzero element as a finite product of irreducible
    elements. They also imply that one can use the Euclidean algorithm to find a greatest
    common divisor of any two nonzero elements `a` and `b`, i.e. an element that is
    divisible by any other common divisor. This, in turn, implies that factorization
    into irreducible elements is unique up to multiplication by units.
  prefs: []
  type: TYPE_NORMAL
- en: We now show that the Gaussian integers are a Euclidean domain with the norm
    defined by \(N(a + bi) = (a + bi)(a - bi) = a^2 + b^2\). The Gaussian integer
    \(a - bi\) is called the *conjugate* of \(a + bi\). It is not hard to check that
    for any complex numbers \(x\) and \(y\), we have \(N(xy) = N(x)N(y)\).
  prefs: []
  type: TYPE_NORMAL
- en: To see that this definition of the norm makes the Gaussian integers a Euclidean
    domain, only the first property is challenging. Suppose we want to write \(a +
    bi = (c + di) q + r\) for suitable \(q\) and \(r\). Treating \(a + bi\) and \(c
    + di\) as complex numbers, carry out the division
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{a + bi}{c + di} = \frac{(a + bi)(c - di)}{(c + di)(c-di)} = \frac{ac
    + bd}{c^2 + d^2} + \frac{bc -ad}{c^2+d^2} i.\]
  prefs: []
  type: TYPE_NORMAL
- en: The real and imaginary parts might not be integers, but we can round them to
    the nearest integers \(u\) and \(v\). We can then express the right-hand side
    as \((u + vi) + (u' + v'i)\), where \(u' + v'i\) is the part left over. Note that
    we have \(|u'| \le 1/2\) and \(|v'| \le 1/2\), and hence
  prefs: []
  type: TYPE_NORMAL
- en: \[N(u' + v' i) = (u')^2 + (v')^2 \le 1/4 + 1/4 \le 1/2.\]
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying through by \(c + di\), we have
  prefs: []
  type: TYPE_NORMAL
- en: \[a + bi = (c + di) (u + vi) + (c + di) (u' + v'i).\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting \(q = u + vi\) and \(r = (c + di) (u'' + v''i)\), we have \(a + bi
    = (c + di) q + r\), and we only need to bound \(N(r)\):'
  prefs: []
  type: TYPE_NORMAL
- en: \[N(r) = N(c + di)N(u' + v'i) \le N(c + di) \cdot 1/2 < N(c + di).\]
  prefs: []
  type: TYPE_NORMAL
- en: The argument we just carried out requires viewing the Gaussian integers as a
    subset of the complex numbers. One option for formalizing it in Lean is therefore
    to embed the Gaussian integers in the complex numbers, embed the integers in the
    Gaussian integers, define the rounding function from the real numbers to the integers,
    and take great care to pass back and forth between these number systems appropriately.
    In fact, this is exactly the approach that is followed in Mathlib, where the Gaussian
    integers themselves are constructed as a special case of a ring of *quadratic
    integers*. See the file [GaussianInt.lean](https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we will instead carry out an argument that stays in the integers. This
    illustrates a choice one commonly faces when formalizing mathematics. Given an
    argument that requires concepts or machinery that is not already in the library,
    one has two choices: either formalize the concepts and machinery needed, or adapt
    the argument to make use of concepts and machinery you already have. The first
    choice is generally a good investment of time when the results can be used in
    other contexts. Pragmatically speaking, however, sometimes seeking a more elementary
    proof is more efficient.'
  prefs: []
  type: TYPE_NORMAL
- en: The usual quotient-remainder theorem for the integers says that for every \(a\)
    and nonzero \(b\), there are \(q\) and \(r\) such that \(a = b q + r\) and \(0
    \le r < b\). Here we will make use of the following variation, which says that
    there are \(q'\) and \(r'\) such that \(a = b q' + r'\) and \(|r'| \le b/2\).
    You can check that if the value of \(r\) in the first statement satisfies \(r
    \le b/2\), we can take \(q' = q\) and \(r' = r\), and otherwise we can take \(q'
    = q + 1\) and \(r' = r - b\). We are grateful to Heather Macbeth for suggesting
    the following more elegant approach, which avoids definition by cases. We simply
    add `b / 2` to `a` before dividing and then subtract it from the remainder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of our old friend, `linarith`. We will also need to express `mod'`
    in terms of `div'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We will use the fact that \(x^2 + y^2\) is equal to zero if and only if \(x\)
    and \(y\) are both zero. As an exercise, we ask you to prove that this holds in
    any ordered ring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We will put all the remaining definitions and theorems in this section in the
    `GaussInt` namespace. First, we define the `norm` function and ask you to establish
    some of its properties. The proofs are all short.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we define the conjugate function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we define division for the Gaussian integers with the notation `x /
    y`, that rounds the complex quotient to the nearest Gaussian integer. We use our
    bespoke `Int.div'` for that purpose. As we calculated above, if `x` is \(a + bi\)
    and `y` is \(c + di\), then the real and imaginary parts of `x / y` are the nearest
    integers to
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{ac + bd}{c^2 + d^2} \quad \text{and} \quad \frac{bc -ad}{c^2+d^2},\]
  prefs: []
  type: TYPE_NORMAL
- en: respectively. Here the numerators are the real and imaginary parts of \((a +
    bi) (c - di)\), and the denominators are both equal to the norm of \(c + di\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Having defined `x / y`, We define `x % y` to be the remainder, `x - (x / y)
    * y`. As above, we record the definitions in the theorems `div_def` and `mod_def`
    so that we can use them with `simp` and `rw`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: These definitions immediately yield `x = y * (x / y) + x % y` for every `x`
    and `y`, so all we need to do is show that the norm of `x % y` is less than the
    norm of `y` when `y` is not zero.
  prefs: []
  type: TYPE_NORMAL
- en: We just defined the real and imaginary parts of `x / y` to be `div' (x * conj
    y).re (norm y)` and `div' (x * conj y).im (norm y)`, respectively. Calculating,
    we have
  prefs: []
  type: TYPE_NORMAL
- en: '`(x % y) * conj y = (x - x / y * y) * conj y = x * conj y - x / y * (y * conj
    y)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The real and imaginary parts of the right-hand side are exactly `mod' (x * conj
    y).re (norm y)` and `mod' (x * conj y).im (norm y)`. By the properties of `div'`
    and `mod'`, these are guaranteed to be less than or equal to `norm y / 2`. So
    we have
  prefs: []
  type: TYPE_NORMAL
- en: '`norm ((x % y) * conj y) ≤ (norm y / 2)^2 + (norm y / 2)^2 ≤ (norm y / 2) *
    norm y`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On the other hand, we have
  prefs: []
  type: TYPE_NORMAL
- en: '`norm ((x % y) * conj y) = norm (x % y) * norm (conj y) = norm (x % y) * norm
    y`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dividing through by `norm y` we have `norm (x % y) ≤ (norm y) / 2 < norm y`,
    as required.
  prefs: []
  type: TYPE_NORMAL
- en: This messy calculation is carried out in the next proof. We encourage you to
    step through the details and see if you can find a nicer argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We are in the home stretch. Our `norm` function maps Gaussian integers to nonnegative
    integers. We need a function that maps Gaussian integers to natural numbers, and
    we obtain that by composing `norm` with the function `Int.natAbs`, which maps
    integers to the natural numbers. The first of the next two lemmas establishes
    that mapping the norm to the natural numbers and back to the integers does not
    change the value. The second one re-expresses the fact that the norm is decreasing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We also need to establish the second key property of the norm function on a
    Euclidean domain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We can now put it together to show that the Gaussian integers are an instance
    of a Euclidean domain. We use the quotient and remainder function we have defined.
    The Mathlib definition of a Euclidean domain is more general than the one above
    in that it allows us to show that remainder decreases with respect to any well-founded
    measure. Comparing the values of a norm function that returns natural numbers
    is just one instance of such a measure, and in that case, the required properties
    are the theorems `natAbs_norm_mod_lt` and `not_norm_mul_left_lt_norm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: An immediate payoff is that we now know that, in the Gaussian integers, the
    notions of being prime and being irreducible coincide.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51] [Previous](C06_Discrete_Mathematics.html "6\. Discrete Mathematics")
    [Next](C08_Hierarchies.html "8\. Hierarchies")'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: © Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). Modern mathematics makes
    essential use of algebraic structures, which encapsulate patterns that can be
    instantiated in multiple settings. The subject provides various ways of defining
    such structures and constructing particular instances.
  prefs: []
  type: TYPE_NORMAL
- en: Lean therefore provides corresponding ways of defining structures formally and
    working with them. You have already seen examples of algebraic structures in Lean,
    such as rings and lattices, which were discussed in [Chapter 2](C02_Basics.html#basics).
    This chapter will explain the mysterious square bracket annotations that you saw
    there, `[Ring α]` and `[Lattice α]`. It will also show you how to define and use
    algebraic structures on your own.
  prefs: []
  type: TYPE_NORMAL
- en: For more technical detail, you can consult [Theorem Proving in Lean](https://leanprover.github.io/theorem_proving_in_lean/),
    and a paper by Anne Baanen, [Use and abuse of instance parameters in the Lean
    mathematical library](https://arxiv.org/abs/2202.01629).
  prefs: []
  type: TYPE_NORMAL
- en: '## 7.1\. Defining structures[](#defining-structures "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the broadest sense of the term, a *structure* is a specification of a collection
    of data, possibly with constraints that the data is required to satisfy. An *instance*
    of the structure is a particular bundle of data satisfying the constraints. For
    example, we can specify that a point is a tuple of three real numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `@[ext]` annotation tells Lean to automatically generate theorems that can
    be used to prove that two instances of a structure are equal when their components
    are equal, a property known as *extensionality*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We can then define particular instances of the `Point` structure. Lean provides
    multiple ways of doing that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, the fields of the structure are named explicitly. The
    function `Point.mk` referred to in the definition of `myPoint3` is known as the
    *constructor* for the `Point` structure, because it serves to construct elements.
    You can specify a different name if you want, like `build`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The next two examples show how to define functions on structures. Whereas the
    second example makes the `Point.mk` constructor explicit, the first example uses
    an anonymous constructor for brevity. Lean can infer the relevant constructor
    from the indicated type of `add`. It is conventional to put definitions and theorems
    associated with a structure like `Point` in a namespace with the same name. In
    the example below, because we have opened the `Point` namespace, the full name
    of `add` is `Point.add`. When the namespace is not open, we have to use the full
    name. But remember that it is often convenient to use anonymous projection notation,
    which allows us to write `a.add b` instead of `Point.add a b`. Lean interprets
    the former as the latter because `a` has type `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Below we will continue to put definitions in the relevant namespace, but we
    will leave the namespacing commands out of the quoted snippets. To prove properties
    of the addition function, we can use `rw` to expand the definition and `ext` to
    reduce an equation between two elements of the structure to equations between
    the components. Below we use the `protected` keyword so that the name of the theorem
    is `Point.add_comm`, even when the namespace is open. This is helpful when we
    want to avoid ambiguity with a generic theorem like `add_comm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Because Lean can unfold definitions and simplify projections internally, sometimes
    the equations we want hold definitionally.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to define functions on structures using pattern matching,
    in a manner similar to the way we defined recursive functions in [Section 5.2](C05_Elementary_Number_Theory.html#section-induction-and-recursion).
    The definitions `addAlt` and `addAlt'` below are essentially the same; the only
    difference is that we use anonymous constructor notation in the second. Although
    it is sometimes convenient to define functions this way, and structural eta-reduction
    makes this alternative definitionally equivalent, it can make things less convenient
    in later proofs. In particular, `rw [addAlt]` leaves us with a messier goal view
    containing a `match` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Mathematical constructions often involve taking apart bundled information and
    putting it together again in different ways. It therefore makes sense that Lean
    and Mathlib offer so many ways of doing this efficiently. As an exercise, try
    proving that `Point.add` is associative. Then define scalar multiplication for
    a point and show that it distributes over addition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Using structures is only the first step on the road to algebraic abstraction.
    We don’t yet have a way to link `Point.add` to the generic `+` symbol, or to connect
    `Point.add_comm` and `Point.add_assoc` to the generic `add_comm` and `add_assoc`
    theorems. These tasks belong to the *algebraic* aspect of using structures, and
    we will explain how to carry them out in the next section. For now, just think
    of a structure as a way of bundling together objects and information.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is especially useful that a structure can specify not only data types but
    also constraints that the data must satisfy. In Lean, the latter are represented
    as fields of type `Prop`. For example, the *standard 2-simplex* is defined to
    be the set of points \((x, y, z)\) satisfying \(x ≥ 0\), \(y ≥ 0\), \(z ≥ 0\),
    and \(x + y + z = 1\). If you are not familiar with the notion, you should draw
    a picture, and convince yourself that this set is the equilateral triangle in
    three-space with vertices \((1, 0, 0)\), \((0, 1, 0)\), and \((0, 0, 1)\), together
    with its interior. We can represent it in Lean as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the last four fields refer to `x`, `y`, and `z`, that is, the first
    three fields. We can define a map from the two-simplex to itself that swaps `x`
    and `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: More interestingly, we can compute the midpoint of two points on the simplex.
    We have added the phrase `noncomputable section` at the beginning of this file
    in order to use division on the real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here we have established `x_nonneg`, `y_nonneg`, and `z_nonneg` with concise
    proof terms, but establish `sum_eq` in tactic mode, using `by`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a parameter \(\lambda\) satisfying \(0 \le \lambda \le 1\), we can take
    the weighted average \(\lambda a + (1 - \lambda) b\) of two points \(a\) and \(b\)
    in the standard 2-simplex. We challenge you to define that function, in analogy
    to the `midpoint` function above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Structures can depend on parameters. For example, we can generalize the standard
    2-simplex to the standard \(n\)-simplex for any \(n\). At this stage, you don’t
    have to know anything about the type `Fin n` except that it has \(n\) elements,
    and that Lean knows how to sum over it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, see if you can define the weighted average of two points in
    the standard \(n\)-simplex. You can use `Finset.sum_add_distrib` and `Finset.mul_sum`
    to manipulate the relevant sums.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that structures can be used to bundle together data and properties.
    Interestingly, they can also be used to bundle together properties without the
    data. For example, the next structure, `IsLinear`, bundles together the two components
    of linearity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: It is worth pointing out that structures are not the only way to bundle together
    data. The `Point` data structure can be defined using the generic type product,
    and `IsLinear` can be defined with a simple `and`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Generic type constructions can even be used in place of structures with dependencies
    between their components. For example, the *subtype* construction combines a piece
    of data with a property. You can think of the type `PReal` in the next example
    as being the type of positive real numbers. Any `x : PReal` has two components:
    the value, and the property of being positive. You can access these components
    as `x.val`, which has type `ℝ`, and `x.property`, which represents the fact `0
    < x.val`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We could have used subtypes to define the standard 2-simplex, as well as the
    standard \(n\)-simplex for an arbitrary \(n\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, *Sigma types* are generalizations of ordered pairs, whereby the type
    of the second component depends on the type of the first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Given `s : StdSimplex`, the first component `s.fst` is a natural number, and
    the second component is an element of the corresponding simplex `StandardSimplex
    s.fst`. The difference between a Sigma type and a subtype is that the second component
    of a Sigma type is data rather than a proposition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But even though we can use products, subtypes, and Sigma types instead of structures,
    using structures has a number of advantages. Defining a structure abstracts away
    the underlying representation and provides custom names for the functions that
    access the components. This makes proofs more robust: proofs that rely only on
    the interface to a structure will generally continue to work when we change the
    definition, as long as we redefine the old accessors in terms of the new definition.
    Moreover, as we are about to see, Lean provides support for weaving structures
    together into a rich, interconnected hierarchy, and for managing the interactions
    between them.  ## 7.2\. Algebraic Structures[](#algebraic-structures "Link to
    this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: To clarify what we mean by the phrase *algebraic structure*, it will help to
    consider some examples.
  prefs: []
  type: TYPE_NORMAL
- en: A *partially ordered set* consists of a set \(P\) and a binary relation \(\le\)
    on \(P\) that is transitive and reflexive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A *group* consists of a set \(G\) with an associative binary operation, an identity
    element \(1\), and a function \(g \mapsto g^{-1}\) that returns an inverse for
    each \(g\) in \(G\). A group is *abelian* or *commutative* if the operation is
    commutative.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A *lattice* is a partially ordered set with meets and joins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A *ring* consists of an (additively written) abelian group \((R, +, 0, x \mapsto
    -x)\) together with an associative multiplication operation \(\cdot\) and an identity
    \(1\), such that multiplication distributes over addition. A ring is *commutative*
    if the multiplication is commutative.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An *ordered ring* \((R, +, 0, -, \cdot, 1, \le)\) consists of a ring together
    with a partial order on its elements, such that \(a \le b\) implies \(a + c \le
    b + c\) for every \(a\), \(b\), and \(c\) in \(R\), and \(0 \le a\) and \(0 \le
    b\) implies \(0 \le a b\) for every \(a\) and \(b\) in \(R\).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A *metric space* consists of a set \(X\) and a function \(d : X \times X \to
    \mathbb{R}\) such that the following hold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \(d(x, y) \ge 0\) for every \(x\) and \(y\) in \(X\).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: \(d(x, y) = 0\) if and only if \(x = y\).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: \(d(x, y) = d(y, x)\) for every \(x\) and \(y\) in \(X\).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: \(d(x, z) \le d(x, y) + d(y, z)\) for every \(x\), \(y\), and \(z\) in \(X\).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A *topological space* consists of a set \(X\) and a collection \(\mathcal T\)
    of subsets of \(X\), called the *open subsets of* \(X\), such that the following
    hold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The empty set and \(X\) are open.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The intersection of two open sets is open.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An arbitrary union of open sets is open.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In each of these examples, the elements of the structure belong to a set, the
    *carrier set*, that sometimes stands proxy for the entire structure. For example,
    when we say “let \(G\) be a group” and then “let \(g \in G\),” we are using \(G\)
    to stand for both the structure and its carrier. Not every algebraic structure
    is associated with a single carrier set in this way. For example, a *bipartite
    graph* involves a relation between two sets, as does a *Galois connection*, A
    *category* also involves two sets of interest, commonly called the *objects* and
    the *morphisms*.
  prefs: []
  type: TYPE_NORMAL
- en: The examples indicate some of the things that a proof assistant has to do in
    order to support algebraic reasoning. First, it needs to recognize concrete instances
    of structures. The number systems \(\mathbb{Z}\), \(\mathbb{Q}\), and \(\mathbb{R}\)
    are all ordered rings, and we should be able to apply a generic theorem about
    ordered rings in any of these instances. Sometimes a concrete set may be an instance
    of a structure in more than one way. For example, in addition to the usual topology
    on \(\mathbb{R}\), which forms the basis for real analysis, we can also consider
    the *discrete* topology on \(\mathbb{R}\), in which every set is open.
  prefs: []
  type: TYPE_NORMAL
- en: Second, a proof assistant needs to support generic notation on structures. In
    Lean, the notation `*` is used for multiplication in all the usual number systems,
    as well as for multiplication in generic groups and rings. When we use an expression
    like `f x * y`, Lean has to use information about the types of `f`, `x`, and `y`
    to determine which multiplication we have in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Third, it needs to deal with the fact that structures can inherit definitions,
    theorems, and notation from other structures in various ways. Some structures
    extend others by adding more axioms. A commutative ring is still a ring, so any
    definition that makes sense in a ring also makes sense in a commutative ring,
    and any theorem that holds in a ring also holds in a commutative ring. Some structures
    extend others by adding more data. For example, the additive part of any ring
    is an additive group. The ring structure adds a multiplication and an identity,
    as well as axioms that govern them and relate them to the additive part. Sometimes
    we can define one structure in terms of another. Any metric space has a canonical
    topology associated with it, the *metric space topology*, and there are various
    topologies that can be associated with any linear ordering.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is important to keep in mind that mathematics allows us to use functions
    and operations to define structures in the same way we use functions and operations
    to define numbers. Products and powers of groups are again groups. For every \(n\),
    the integers modulo \(n\) form a ring, and for every \(k > 0\), the \(k \times
    k\) matrices of polynomials with coefficients in that ring again form a ring.
    Thus we can calculate with structures just as easily as we can calculate with
    their elements. This means that algebraic structures lead dual lives in mathematics,
    as containers for collections of objects and as objects in their own right. A
    proof assistant has to accommodate this dual role.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with elements of a type that has an algebraic structure associated
    with it, a proof assistant needs to recognize the structure and find the relevant
    definitions, theorems, and notation. All this should sound like a lot of work,
    and it is. But Lean uses a small collection of fundamental mechanisms to carry
    out these tasks. The goal of this section is to explain these mechanisms and show
    you how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first ingredient is almost too obvious to mention: formally speaking, algebraic
    structures are structures in the sense of [Section 7.1](#section-structures).
    An algebraic structure is a specification of a bundle of data satisfying some
    axiomatic hypotheses, and we saw in [Section 7.1](#section-structures) that this
    is exactly what the `structure` command is designed to accommodate. It’s a marriage
    made in heaven!'
  prefs: []
  type: TYPE_NORMAL
- en: Given a data type `α`, we can define the group structure on `α` as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the type `α` is a *parameter* in the definition of `Group₁`. So
    you should think of an object `struc : Group₁ α` as being a group structure on
    `α`. We saw in [Section 2.2](C02_Basics.html#proving-identities-in-algebraic-structures)
    that the counterpart `mul_inv_cancel` to `inv_mul_cancel` follows from the other
    group axioms, so there is no need to add it to the definition.'
  prefs: []
  type: TYPE_NORMAL
- en: This definition of a group is similar to the definition of `Group` in Mathlib,
    and we have chosen the name `Group₁` to distinguish our version. If you write
    `#check Group` and ctrl-click on the definition, you will see that the Mathlib
    version of `Group` is defined to extend another structure; we will explain how
    to do that later. If you type `#print Group` you will also see that the Mathlib
    version of `Group` has a number of extra fields. For reasons we will explain later,
    sometimes it is useful to add redundant information to a structure, so that there
    are additional fields for objects and functions that can be defined from the core
    data. Don’t worry about that for now. Rest assured that our simplified version
    `Group₁` is morally the same as the definition of a group that Mathlib uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is sometimes useful to bundle the type together with the structure, and
    Mathlib also contains a definition of a `Grp` structure that is equivalent to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The Mathlib version is found in `Mathlib.Algebra.Category.Grp.Basic`, and you
    can `#check` it if you add this to the imports at the beginning of the examples
    file.
  prefs: []
  type: TYPE_NORMAL
- en: For reasons that will become clearer below, it is more often useful to keep
    the type `α` separate from the structure `Group α`. We refer to the two objects
    together as a *partially bundled structure*, since the representation combines
    most, but not all, of the components into one structure. It is common in Mathlib
    to use capital roman letters like `G` for a type when it is used as the carrier
    type for a group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s construct a group, which is to say, an element of the `Group₁` type.
    For any pair of types `α` and `β`, Mathlib defines the type `Equiv α β` of *equivalences*
    between `α` and `β`. Mathlib also defines the suggestive notation `α ≃ β` for
    this type. An element `f : α ≃ β` is a bijection between `α` and `β` represented
    by four components: a function `f.toFun` from `α` to `β`, the inverse function
    `f.invFun` from `β` to `α`, and two properties that specify these functions are
    indeed inverse to one another.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Notice the creative naming of the last three constructions. We think of the
    identity function `Equiv.refl`, the inverse operation `Equiv.symm`, and the composition
    operation `Equiv.trans` as explicit evidence that the property of being in bijective
    correspondence is an equivalence relation.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that `f.trans g` requires composing the forward functions in reverse
    order. Mathlib has declared a *coercion* from `Equiv α β` to the function type
    `α → β`, so we can omit writing `.toFun` and have Lean insert it for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Mathlib also defines the type `perm α` of equivalences between `α` and itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be clear that `Equiv.Perm α` forms a group under composition of equivalences.
    We orient things so that `mul f g` is equal to `g.trans f`, whose forward function
    is `f ∘ g`. In other words, multiplication is what we ordinarily think of as composition
    of the bijections. Here we define this group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In fact, Mathlib defines exactly this `Group` structure on `Equiv.Perm α` in
    the file `Algebra.Group.End`. As always, you can hover over the theorems used
    in the definition of `permGroup` to see their statements, and you can jump to
    their definitions in the original file to learn more about how they are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: In ordinary mathematics, we generally think of notation as independent of structure.
    For example, we can consider groups \((G_1, \cdot, 1, \cdot^{-1})\), \((G_2, \circ,
    e, i(\cdot))\), and \((G_3, +, 0, -)\). In the first case, we write the binary
    operation as \(\cdot\), the identity as \(1\), and the inverse function as \(x
    \mapsto x^{-1}\). In the second and third cases, we use the notational alternatives
    shown. When we formalize the notion of a group in Lean, however, the notation
    is more tightly linked to the structure. In Lean, the components of any `Group`
    are named `mul`, `one`, and `inv`, and in a moment we will see how multiplicative
    notation is set up to refer to them. If we want to use additive notation, we instead
    use an isomorphic structure `AddGroup` (the structure underlying additive groups).
    Its components are named `add`, `zero`, and `neg`, and the associated notation
    is what you would expect it to be.
  prefs: []
  type: TYPE_NORMAL
- en: Recall the type `Point` that we defined in [Section 7.1](#section-structures),
    and the addition function that we defined there. These definitions are reproduced
    in the examples file that accompanies this section. As an exercise, define an
    `AddGroup₁` structure that is similar to the `Group₁` structure we defined above,
    except that it uses the additive naming scheme just described. Define negation
    and a zero on the `Point` data type, and define the `AddGroup₁` structure on `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We are making progress. Now we know how to define algebraic structures in Lean,
    and we know how to define instances of those structures. But we also want to associate
    notation with structures so that we can use it with each instance. Moreover, we
    want to arrange it so that we can define an operation on a structure and use it
    with any particular instance, and we want to arrange it so that we can prove a
    theorem about a structure and use it with any instance.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, Mathlib is already set up to use generic group notation, definitions,
    and theorems for `Equiv.Perm α`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: You can check that this is not the case for the additive group structure on
    `Point` that we asked you to define above. Our task now is to understand that
    magic that goes on under the hood in order to make the examples for `Equiv.Perm
    α` work the way they do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The issue is that Lean needs to be able to *find* the relevant notation and
    the implicit group structure, using the information that is found in the expressions
    that we type. Similarly, when we write `x + y` with expressions `x` and `y` that
    have type `ℝ`, Lean needs to interpret the `+` symbol as the relevant addition
    function on the reals. It also has to recognize the type `ℝ` as an instance of
    a commutative ring, so that all the definitions and theorems for a commutative
    ring are available. For another example, continuity is defined in Lean relative
    to any two topological spaces. When we have `f : ℝ → ℂ` and we write `Continuous
    f`, Lean has to find the relevant topologies on `ℝ` and `ℂ`.'
  prefs: []
  type: TYPE_NORMAL
- en: The magic is achieved with a combination of three things.
  prefs: []
  type: TYPE_NORMAL
- en: '*Logic.* A definition that should be interpreted in any group takes, as arguments,
    the type of the group and the group structure as arguments. Similarly, a theorem
    about the elements of an arbitrary group begins with universal quantifiers over
    the type of the group and the group structure.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Implicit arguments.* The arguments for the type and the structure are generally
    left implicit, so that we do not have to write them or see them in the Lean information
    window. Lean fills the information in for us silently.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Type class inference.* Also known as *class inference*, this is a simple but
    powerful mechanism that enables us to register information for Lean to use later
    on. When Lean is called on to fill in implicit arguments to a definition, theorem,
    or piece of notation, it can make use of information that has been registered.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Whereas an annotation `(grp : Group G)` tells Lean that it should expect to
    be given that argument explicitly and the annotation `{grp : Group G}` tells Lean
    that it should try to figure it out from contextual cues in the expression, the
    annotation `[grp : Group G]` tells Lean that the corresponding argument should
    be synthesized using type class inference. Since the whole point to the use of
    such arguments is that we generally do not need to refer to them explicitly, Lean
    allows us to write `[Group G]` and leave the name anonymous. You have probably
    already noticed that Lean chooses names like `_inst_1` automatically. When we
    use the anonymous square-bracket annotation with the `variables` command, then
    as long as the variables are still in scope, Lean automatically adds the argument
    `[Group G]` to any definition or theorem that mentions `G`.'
  prefs: []
  type: TYPE_NORMAL
- en: How do we register the information that Lean needs to use to carry out the search?
    Returning to our group example, we need only make two changes. First, instead
    of using the `structure` command to define the group structure, we use the keyword
    `class` to indicate that it is a candidate for class inference. Second, instead
    of defining particular instances with `def`, we use the keyword `instance` to
    register the particular instance with Lean. As with the names of class variables,
    we are allowed to leave the name of an instance definition anonymous, since in
    general we intend Lean to find it and put it to use without troubling us with
    the details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The following illustrates their use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#check` command shows that `Group₂.mul` has an implicit argument `[Group₂
    α]` that we expect to be found by class inference, where `α` is the type of the
    arguments to `Group₂.mul`. In other words, `{α : Type*}` is the implicit argument
    for the type of the group elements and `[Group₂ α]` is the implicit argument for
    the group structure on `α`. Similarly, when we define a generic squaring function
    `my_square` for `Group₂`, we use an implicit argument `{α : Type*}` for the type
    of the elements and an implicit argument `[Group₂ α]` for the `Group₂` structure.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, when we write `Group₂.mul f g`, the type of `f` and `g`
    tells Lean that in the argument `α` to `Group₂.mul` has to be instantiated to
    `Equiv.Perm β`. That means that Lean has to find an element of `Group₂ (Equiv.Perm
    β)`. The previous `instance` declaration tells Lean exactly how to do that. Problem
    solved!
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple mechanism for registering information so that Lean can find it
    when it needs it is remarkably useful. Here is one way it comes up. In Lean’s
    foundation, a data type `α` may be empty. In a number of applications, however,
    it is useful to know that a type has at least one element. For example, the function
    `List.headI`, which returns the first element of a list, can return the default
    value when the list is empty. To make that work, the Lean library defines a class
    `Inhabited α`, which does nothing more than store a default value. We can show
    that the `Point` type is an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The class inference mechanism is also used for generic notation. The expression
    `x + y` is an abbreviation for `Add.add x y` where—you guessed it—`Add α` is a
    class that stores a binary function on `α`. Writing `x + y` tells Lean to find
    a registered instance of `[Add.add α]` and use the corresponding function. Below,
    we register the addition function for `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we can assign the notation `+` to binary operations on other types
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can do even better. We have seen that `*` can be used in any group,
    `+` can be used in any additive group, and both can be used in any ring. When
    we define a new instance of a ring in Lean, we don’t have to define `+` and `*`
    for that instance, because Lean knows that these are defined for every ring. We
    can use this method to specify notation for our `Group₂` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: What makes this approach work is that Lean carries out a recursive search. According
    to the instances we have declared, Lean can find an instance of `Mul (Equiv.Perm
    α)` by finding an instance of `Group₂ (Equiv.Perm α)`, and it can find an instance
    of `Group₂ (Equiv.Perm α)` because we have provided one. Lean is capable of finding
    these two facts and chaining them together.
  prefs: []
  type: TYPE_NORMAL
- en: The example we have just given is dangerous, because Lean’s library also has
    an instance of `Group (Equiv.Perm α)`, and multiplication is defined on any group.
    So it is ambiguous as to which instance is found. In fact, Lean favors more recent
    declarations unless you explicitly specify a different priority. Also, there is
    another way to tell Lean that one structure is an instance of another, using the
    `extends` keyword. This is how Mathlib specifies that, for example, every commutative
    ring is a ring. You can find more information in [Section 8](C08_Hierarchies.html#hierarchies)
    and in a [section on class inference](https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#managing-type-class-inference)
    in *Theorem Proving in Lean*.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is a bad idea to specify a value of `*` for an instance of an
    algebraic structure that already has the notation defined. Redefining the notion
    of `Group` in Lean is an artificial example. In this case, however, both interpretations
    of the group notation unfold to `Equiv.trans`, `Equiv.refl`, and `Equiv.symm`,
    in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: As a similarly artificial exercise, define a class `AddGroup₂` in analogy to
    `Group₂`. Define the usual notation for addition, negation, and zero on any `AddGroup₂`
    using the classes `Add`, `Neg`, and `Zero`. Then show `Point` is an instance of
    `AddGroup₂`. Try it out and make sure that the additive group notation works for
    elements of `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: It is not a big problem that we have already declared instances `Add`, `Neg`,
    and `Zero` for `Point` above. Once again, the two ways of synthesizing the notation
    should come up with the same answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class inference is subtle, and you have to be careful when using it, because
    it configures automation that invisibly governs the interpretation of the expressions
    we type. When used wisely, however, class inference is a powerful tool. It is
    what makes algebraic reasoning possible in Lean.  ## 7.3\. Building the Gaussian
    Integers[](#building-the-gaussian-integers "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: We will now illustrate the use of the algebraic hierarchy in Lean by building
    an important mathematical object, the *Gaussian integers*, and showing that it
    is a Euclidean domain. In other words, according to the terminology we have been
    using, we will define the Gaussian integers and show that they are an instance
    of the Euclidean domain structure.
  prefs: []
  type: TYPE_NORMAL
- en: In ordinary mathematical terms, the set of Gaussian integers \(\Bbb{Z}[i]\)
    is the set of complex numbers \(\{ a + b i \mid a, b \in \Bbb{Z}\}\). But rather
    than define them as a subset of the complex numbers, our goal here is to define
    them as a data type in their own right. We do this by representing a Gaussian
    integer as a pair of integers, which we think of as the *real* and *imaginary*
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We first show that the Gaussian integers have the structure of a ring, with
    `0` defined to be `⟨0, 0⟩`, `1` defined to be `⟨1, 0⟩`, and addition defined pointwise.
    To work out the definition of multiplication, remember that we want the element
    \(i\), represented by `⟨0, 1⟩`, to be a square root of \(-1\). Thus we want
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}(a + bi) (c + di) & = ac + bci + adi + bd i^2 \\ & = (ac - bd)
    + (bc + ad)i.\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: This explains the definition of `Mul` below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: As noted in [Section 7.1](#section-structures), it is a good idea to put all
    the definitions related to a data type in a namespace with the same name. Thus
    in the Lean files associated with this chapter, these definitions are made in
    the `GaussInt` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that here we are defining the interpretations of the notation `0`, `1`,
    `+`, `-`, and `*` directly, rather than naming them `GaussInt.zero` and the like
    and assigning the notation to those. It is often useful to have an explicit name
    for the definitions, for example, to use with `simp` and `rw`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: It is also useful to name the rules that compute the real and imaginary parts,
    and to declare them to the simplifier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: It is now surprisingly easy to show that the Gaussian integers are an instance
    of a commutative ring. We are putting the structure concept to good use. Each
    particular Gaussian integer is an instance of the `GaussInt` structure, whereas
    the type `GaussInt` itself, together with the relevant operations, is an instance
    of the `CommRing` structure. The `CommRing` structure, in turn, extends the notational
    structures `Zero`, `One`, `Add`, `Neg`, and `Mul`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you type `instance : CommRing GaussInt := _`, click on the light bulb that
    appears in VS Code, and then ask Lean to fill in a skeleton for the structure
    definition, you will see a scary number of entries. Jumping to the definition
    of the structure, however, shows that many of the fields have default definitions
    that Lean will fill in for you automatically. The essential ones appear in the
    definition below. A special case are `nsmul` and `zsmul` which should be ignored
    for now and will be explained in the next chapter. In each case, the relevant
    identity is proved by unfolding definitions, using the `ext` tactic to reduce
    the identities to their real and imaginary components, simplifying, and, if necessary,
    carrying out the relevant ring calculation in the integers. Note that we could
    easily avoid repeating all this code, but this is not the topic of the current
    discussion.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Lean’s library defines the class of *nontrivial* types to be types with at least
    two distinct elements. In the context of a ring, this is equivalent to saying
    that the zero is not equal to the one. Since some common theorems depend on that
    fact, we may as well establish it now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now show that the Gaussian integers have an important additional property.
    A *Euclidean domain* is a ring \(R\) equipped with a *norm* function \(N : R \to
    \mathbb{N}\) with the following two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: For every \(a\) and \(b \ne 0\) in \(R\), there are \(q\) and \(r\) in \(R\)
    such that \(a = bq + r\) and either \(r = 0\) or \(N(r) < N(b)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every \(a\) and \(b \ne 0\), \(N(a) \le N(ab)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ring of integers \(\Bbb{Z}\) with \(N(a) = |a|\) is an archetypal example
    of a Euclidean domain. In that case, we can take \(q\) to be the result of integer
    division of \(a\) by \(b\) and \(r\) to be the remainder. These functions are
    defined in Lean so that the satisfy the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: In an arbitrary ring, an element \(a\) is said to be a *unit* if it divides
    \(1\). A nonzero element \(a\) is said to be *irreducible* if it cannot be written
    in the form \(a = bc\) where neither \(b\) nor \(c\) is a unit. In the integers,
    every irreducible element \(a\) is *prime*, which is to say, whenever \(a\) divides
    a product \(bc\), it divides either \(b\) or \(c\). But in other rings this property
    can fail. In the ring \(\Bbb{Z}[\sqrt{-5}]\), we have
  prefs: []
  type: TYPE_NORMAL
- en: \[6 = 2 \cdot 3 = (1 + \sqrt{-5})(1 - \sqrt{-5}),\]
  prefs: []
  type: TYPE_NORMAL
- en: 'and the elements \(2\), \(3\), \(1 + \sqrt{-5}\), and \(1 - \sqrt{-5}\) are
    all irreducible, but they are not prime. For example, \(2\) divides the product
    \((1 + \sqrt{-5})(1 - \sqrt{-5})\), but it does not divide either factor. In particular,
    we no longer have unique factorization: the number \(6\) can be factored into
    irreducible elements in more than one way.'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, every Euclidean domain is a unique factorization domain, which
    implies that every irreducible element is prime. The axioms for a Euclidean domain
    imply that one can write any nonzero element as a finite product of irreducible
    elements. They also imply that one can use the Euclidean algorithm to find a greatest
    common divisor of any two nonzero elements `a` and `b`, i.e. an element that is
    divisible by any other common divisor. This, in turn, implies that factorization
    into irreducible elements is unique up to multiplication by units.
  prefs: []
  type: TYPE_NORMAL
- en: We now show that the Gaussian integers are a Euclidean domain with the norm
    defined by \(N(a + bi) = (a + bi)(a - bi) = a^2 + b^2\). The Gaussian integer
    \(a - bi\) is called the *conjugate* of \(a + bi\). It is not hard to check that
    for any complex numbers \(x\) and \(y\), we have \(N(xy) = N(x)N(y)\).
  prefs: []
  type: TYPE_NORMAL
- en: To see that this definition of the norm makes the Gaussian integers a Euclidean
    domain, only the first property is challenging. Suppose we want to write \(a +
    bi = (c + di) q + r\) for suitable \(q\) and \(r\). Treating \(a + bi\) and \(c
    + di\) as complex numbers, carry out the division
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{a + bi}{c + di} = \frac{(a + bi)(c - di)}{(c + di)(c-di)} = \frac{ac
    + bd}{c^2 + d^2} + \frac{bc -ad}{c^2+d^2} i.\]
  prefs: []
  type: TYPE_NORMAL
- en: The real and imaginary parts might not be integers, but we can round them to
    the nearest integers \(u\) and \(v\). We can then express the right-hand side
    as \((u + vi) + (u' + v'i)\), where \(u' + v'i\) is the part left over. Note that
    we have \(|u'| \le 1/2\) and \(|v'| \le 1/2\), and hence
  prefs: []
  type: TYPE_NORMAL
- en: \[N(u' + v' i) = (u')^2 + (v')^2 \le 1/4 + 1/4 \le 1/2.\]
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying through by \(c + di\), we have
  prefs: []
  type: TYPE_NORMAL
- en: \[a + bi = (c + di) (u + vi) + (c + di) (u' + v'i).\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting \(q = u + vi\) and \(r = (c + di) (u'' + v''i)\), we have \(a + bi
    = (c + di) q + r\), and we only need to bound \(N(r)\):'
  prefs: []
  type: TYPE_NORMAL
- en: \[N(r) = N(c + di)N(u' + v'i) \le N(c + di) \cdot 1/2 < N(c + di).\]
  prefs: []
  type: TYPE_NORMAL
- en: The argument we just carried out requires viewing the Gaussian integers as a
    subset of the complex numbers. One option for formalizing it in Lean is therefore
    to embed the Gaussian integers in the complex numbers, embed the integers in the
    Gaussian integers, define the rounding function from the real numbers to the integers,
    and take great care to pass back and forth between these number systems appropriately.
    In fact, this is exactly the approach that is followed in Mathlib, where the Gaussian
    integers themselves are constructed as a special case of a ring of *quadratic
    integers*. See the file [GaussianInt.lean](https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we will instead carry out an argument that stays in the integers. This
    illustrates a choice one commonly faces when formalizing mathematics. Given an
    argument that requires concepts or machinery that is not already in the library,
    one has two choices: either formalize the concepts and machinery needed, or adapt
    the argument to make use of concepts and machinery you already have. The first
    choice is generally a good investment of time when the results can be used in
    other contexts. Pragmatically speaking, however, sometimes seeking a more elementary
    proof is more efficient.'
  prefs: []
  type: TYPE_NORMAL
- en: The usual quotient-remainder theorem for the integers says that for every \(a\)
    and nonzero \(b\), there are \(q\) and \(r\) such that \(a = b q + r\) and \(0
    \le r < b\). Here we will make use of the following variation, which says that
    there are \(q'\) and \(r'\) such that \(a = b q' + r'\) and \(|r'| \le b/2\).
    You can check that if the value of \(r\) in the first statement satisfies \(r
    \le b/2\), we can take \(q' = q\) and \(r' = r\), and otherwise we can take \(q'
    = q + 1\) and \(r' = r - b\). We are grateful to Heather Macbeth for suggesting
    the following more elegant approach, which avoids definition by cases. We simply
    add `b / 2` to `a` before dividing and then subtract it from the remainder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of our old friend, `linarith`. We will also need to express `mod'`
    in terms of `div'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: We will use the fact that \(x^2 + y^2\) is equal to zero if and only if \(x\)
    and \(y\) are both zero. As an exercise, we ask you to prove that this holds in
    any ordered ring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We will put all the remaining definitions and theorems in this section in the
    `GaussInt` namespace. First, we define the `norm` function and ask you to establish
    some of its properties. The proofs are all short.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we define the conjugate function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we define division for the Gaussian integers with the notation `x /
    y`, that rounds the complex quotient to the nearest Gaussian integer. We use our
    bespoke `Int.div'` for that purpose. As we calculated above, if `x` is \(a + bi\)
    and `y` is \(c + di\), then the real and imaginary parts of `x / y` are the nearest
    integers to
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{ac + bd}{c^2 + d^2} \quad \text{and} \quad \frac{bc -ad}{c^2+d^2},\]
  prefs: []
  type: TYPE_NORMAL
- en: respectively. Here the numerators are the real and imaginary parts of \((a +
    bi) (c - di)\), and the denominators are both equal to the norm of \(c + di\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Having defined `x / y`, We define `x % y` to be the remainder, `x - (x / y)
    * y`. As above, we record the definitions in the theorems `div_def` and `mod_def`
    so that we can use them with `simp` and `rw`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: These definitions immediately yield `x = y * (x / y) + x % y` for every `x`
    and `y`, so all we need to do is show that the norm of `x % y` is less than the
    norm of `y` when `y` is not zero.
  prefs: []
  type: TYPE_NORMAL
- en: We just defined the real and imaginary parts of `x / y` to be `div' (x * conj
    y).re (norm y)` and `div' (x * conj y).im (norm y)`, respectively. Calculating,
    we have
  prefs: []
  type: TYPE_NORMAL
- en: '`(x % y) * conj y = (x - x / y * y) * conj y = x * conj y - x / y * (y * conj
    y)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The real and imaginary parts of the right-hand side are exactly `mod' (x * conj
    y).re (norm y)` and `mod' (x * conj y).im (norm y)`. By the properties of `div'`
    and `mod'`, these are guaranteed to be less than or equal to `norm y / 2`. So
    we have
  prefs: []
  type: TYPE_NORMAL
- en: '`norm ((x % y) * conj y) ≤ (norm y / 2)^2 + (norm y / 2)^2 ≤ (norm y / 2) *
    norm y`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On the other hand, we have
  prefs: []
  type: TYPE_NORMAL
- en: '`norm ((x % y) * conj y) = norm (x % y) * norm (conj y) = norm (x % y) * norm
    y`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dividing through by `norm y` we have `norm (x % y) ≤ (norm y) / 2 < norm y`,
    as required.
  prefs: []
  type: TYPE_NORMAL
- en: This messy calculation is carried out in the next proof. We encourage you to
    step through the details and see if you can find a nicer argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: We are in the home stretch. Our `norm` function maps Gaussian integers to nonnegative
    integers. We need a function that maps Gaussian integers to natural numbers, and
    we obtain that by composing `norm` with the function `Int.natAbs`, which maps
    integers to the natural numbers. The first of the next two lemmas establishes
    that mapping the norm to the natural numbers and back to the integers does not
    change the value. The second one re-expresses the fact that the norm is decreasing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: We also need to establish the second key property of the norm function on a
    Euclidean domain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: We can now put it together to show that the Gaussian integers are an instance
    of a Euclidean domain. We use the quotient and remainder function we have defined.
    The Mathlib definition of a Euclidean domain is more general than the one above
    in that it allows us to show that remainder decreases with respect to any well-founded
    measure. Comparing the values of a norm function that returns natural numbers
    is just one instance of such a measure, and in that case, the required properties
    are the theorems `natAbs_norm_mod_lt` and `not_norm_mul_left_lt_norm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: An immediate payoff is that we now know that, in the Gaussian integers, the
    notions of being prime and being irreducible coincide.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]  ## 7.1\. Defining structures[](#defining-structures "Link to this
    heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the broadest sense of the term, a *structure* is a specification of a collection
    of data, possibly with constraints that the data is required to satisfy. An *instance*
    of the structure is a particular bundle of data satisfying the constraints. For
    example, we can specify that a point is a tuple of three real numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The `@[ext]` annotation tells Lean to automatically generate theorems that can
    be used to prove that two instances of a structure are equal when their components
    are equal, a property known as *extensionality*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: We can then define particular instances of the `Point` structure. Lean provides
    multiple ways of doing that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, the fields of the structure are named explicitly. The
    function `Point.mk` referred to in the definition of `myPoint3` is known as the
    *constructor* for the `Point` structure, because it serves to construct elements.
    You can specify a different name if you want, like `build`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The next two examples show how to define functions on structures. Whereas the
    second example makes the `Point.mk` constructor explicit, the first example uses
    an anonymous constructor for brevity. Lean can infer the relevant constructor
    from the indicated type of `add`. It is conventional to put definitions and theorems
    associated with a structure like `Point` in a namespace with the same name. In
    the example below, because we have opened the `Point` namespace, the full name
    of `add` is `Point.add`. When the namespace is not open, we have to use the full
    name. But remember that it is often convenient to use anonymous projection notation,
    which allows us to write `a.add b` instead of `Point.add a b`. Lean interprets
    the former as the latter because `a` has type `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Below we will continue to put definitions in the relevant namespace, but we
    will leave the namespacing commands out of the quoted snippets. To prove properties
    of the addition function, we can use `rw` to expand the definition and `ext` to
    reduce an equation between two elements of the structure to equations between
    the components. Below we use the `protected` keyword so that the name of the theorem
    is `Point.add_comm`, even when the namespace is open. This is helpful when we
    want to avoid ambiguity with a generic theorem like `add_comm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Because Lean can unfold definitions and simplify projections internally, sometimes
    the equations we want hold definitionally.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to define functions on structures using pattern matching,
    in a manner similar to the way we defined recursive functions in [Section 5.2](C05_Elementary_Number_Theory.html#section-induction-and-recursion).
    The definitions `addAlt` and `addAlt'` below are essentially the same; the only
    difference is that we use anonymous constructor notation in the second. Although
    it is sometimes convenient to define functions this way, and structural eta-reduction
    makes this alternative definitionally equivalent, it can make things less convenient
    in later proofs. In particular, `rw [addAlt]` leaves us with a messier goal view
    containing a `match` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Mathematical constructions often involve taking apart bundled information and
    putting it together again in different ways. It therefore makes sense that Lean
    and Mathlib offer so many ways of doing this efficiently. As an exercise, try
    proving that `Point.add` is associative. Then define scalar multiplication for
    a point and show that it distributes over addition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Using structures is only the first step on the road to algebraic abstraction.
    We don’t yet have a way to link `Point.add` to the generic `+` symbol, or to connect
    `Point.add_comm` and `Point.add_assoc` to the generic `add_comm` and `add_assoc`
    theorems. These tasks belong to the *algebraic* aspect of using structures, and
    we will explain how to carry them out in the next section. For now, just think
    of a structure as a way of bundling together objects and information.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is especially useful that a structure can specify not only data types but
    also constraints that the data must satisfy. In Lean, the latter are represented
    as fields of type `Prop`. For example, the *standard 2-simplex* is defined to
    be the set of points \((x, y, z)\) satisfying \(x ≥ 0\), \(y ≥ 0\), \(z ≥ 0\),
    and \(x + y + z = 1\). If you are not familiar with the notion, you should draw
    a picture, and convince yourself that this set is the equilateral triangle in
    three-space with vertices \((1, 0, 0)\), \((0, 1, 0)\), and \((0, 0, 1)\), together
    with its interior. We can represent it in Lean as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the last four fields refer to `x`, `y`, and `z`, that is, the first
    three fields. We can define a map from the two-simplex to itself that swaps `x`
    and `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: More interestingly, we can compute the midpoint of two points on the simplex.
    We have added the phrase `noncomputable section` at the beginning of this file
    in order to use division on the real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Here we have established `x_nonneg`, `y_nonneg`, and `z_nonneg` with concise
    proof terms, but establish `sum_eq` in tactic mode, using `by`.
  prefs: []
  type: TYPE_NORMAL
- en: Given a parameter \(\lambda\) satisfying \(0 \le \lambda \le 1\), we can take
    the weighted average \(\lambda a + (1 - \lambda) b\) of two points \(a\) and \(b\)
    in the standard 2-simplex. We challenge you to define that function, in analogy
    to the `midpoint` function above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Structures can depend on parameters. For example, we can generalize the standard
    2-simplex to the standard \(n\)-simplex for any \(n\). At this stage, you don’t
    have to know anything about the type `Fin n` except that it has \(n\) elements,
    and that Lean knows how to sum over it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, see if you can define the weighted average of two points in
    the standard \(n\)-simplex. You can use `Finset.sum_add_distrib` and `Finset.mul_sum`
    to manipulate the relevant sums.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that structures can be used to bundle together data and properties.
    Interestingly, they can also be used to bundle together properties without the
    data. For example, the next structure, `IsLinear`, bundles together the two components
    of linearity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: It is worth pointing out that structures are not the only way to bundle together
    data. The `Point` data structure can be defined using the generic type product,
    and `IsLinear` can be defined with a simple `and`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Generic type constructions can even be used in place of structures with dependencies
    between their components. For example, the *subtype* construction combines a piece
    of data with a property. You can think of the type `PReal` in the next example
    as being the type of positive real numbers. Any `x : PReal` has two components:
    the value, and the property of being positive. You can access these components
    as `x.val`, which has type `ℝ`, and `x.property`, which represents the fact `0
    < x.val`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: We could have used subtypes to define the standard 2-simplex, as well as the
    standard \(n\)-simplex for an arbitrary \(n\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, *Sigma types* are generalizations of ordered pairs, whereby the type
    of the second component depends on the type of the first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Given `s : StdSimplex`, the first component `s.fst` is a natural number, and
    the second component is an element of the corresponding simplex `StandardSimplex
    s.fst`. The difference between a Sigma type and a subtype is that the second component
    of a Sigma type is data rather than a proposition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But even though we can use products, subtypes, and Sigma types instead of structures,
    using structures has a number of advantages. Defining a structure abstracts away
    the underlying representation and provides custom names for the functions that
    access the components. This makes proofs more robust: proofs that rely only on
    the interface to a structure will generally continue to work when we change the
    definition, as long as we redefine the old accessors in terms of the new definition.
    Moreover, as we are about to see, Lean provides support for weaving structures
    together into a rich, interconnected hierarchy, and for managing the interactions
    between them.'
  prefs: []
  type: TYPE_NORMAL
- en: '## 7.2\. Algebraic Structures[](#algebraic-structures "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: To clarify what we mean by the phrase *algebraic structure*, it will help to
    consider some examples.
  prefs: []
  type: TYPE_NORMAL
- en: A *partially ordered set* consists of a set \(P\) and a binary relation \(\le\)
    on \(P\) that is transitive and reflexive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A *group* consists of a set \(G\) with an associative binary operation, an identity
    element \(1\), and a function \(g \mapsto g^{-1}\) that returns an inverse for
    each \(g\) in \(G\). A group is *abelian* or *commutative* if the operation is
    commutative.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A *lattice* is a partially ordered set with meets and joins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A *ring* consists of an (additively written) abelian group \((R, +, 0, x \mapsto
    -x)\) together with an associative multiplication operation \(\cdot\) and an identity
    \(1\), such that multiplication distributes over addition. A ring is *commutative*
    if the multiplication is commutative.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An *ordered ring* \((R, +, 0, -, \cdot, 1, \le)\) consists of a ring together
    with a partial order on its elements, such that \(a \le b\) implies \(a + c \le
    b + c\) for every \(a\), \(b\), and \(c\) in \(R\), and \(0 \le a\) and \(0 \le
    b\) implies \(0 \le a b\) for every \(a\) and \(b\) in \(R\).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A *metric space* consists of a set \(X\) and a function \(d : X \times X \to
    \mathbb{R}\) such that the following hold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \(d(x, y) \ge 0\) for every \(x\) and \(y\) in \(X\).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: \(d(x, y) = 0\) if and only if \(x = y\).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: \(d(x, y) = d(y, x)\) for every \(x\) and \(y\) in \(X\).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: \(d(x, z) \le d(x, y) + d(y, z)\) for every \(x\), \(y\), and \(z\) in \(X\).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A *topological space* consists of a set \(X\) and a collection \(\mathcal T\)
    of subsets of \(X\), called the *open subsets of* \(X\), such that the following
    hold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The empty set and \(X\) are open.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The intersection of two open sets is open.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An arbitrary union of open sets is open.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In each of these examples, the elements of the structure belong to a set, the
    *carrier set*, that sometimes stands proxy for the entire structure. For example,
    when we say “let \(G\) be a group” and then “let \(g \in G\),” we are using \(G\)
    to stand for both the structure and its carrier. Not every algebraic structure
    is associated with a single carrier set in this way. For example, a *bipartite
    graph* involves a relation between two sets, as does a *Galois connection*, A
    *category* also involves two sets of interest, commonly called the *objects* and
    the *morphisms*.
  prefs: []
  type: TYPE_NORMAL
- en: The examples indicate some of the things that a proof assistant has to do in
    order to support algebraic reasoning. First, it needs to recognize concrete instances
    of structures. The number systems \(\mathbb{Z}\), \(\mathbb{Q}\), and \(\mathbb{R}\)
    are all ordered rings, and we should be able to apply a generic theorem about
    ordered rings in any of these instances. Sometimes a concrete set may be an instance
    of a structure in more than one way. For example, in addition to the usual topology
    on \(\mathbb{R}\), which forms the basis for real analysis, we can also consider
    the *discrete* topology on \(\mathbb{R}\), in which every set is open.
  prefs: []
  type: TYPE_NORMAL
- en: Second, a proof assistant needs to support generic notation on structures. In
    Lean, the notation `*` is used for multiplication in all the usual number systems,
    as well as for multiplication in generic groups and rings. When we use an expression
    like `f x * y`, Lean has to use information about the types of `f`, `x`, and `y`
    to determine which multiplication we have in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Third, it needs to deal with the fact that structures can inherit definitions,
    theorems, and notation from other structures in various ways. Some structures
    extend others by adding more axioms. A commutative ring is still a ring, so any
    definition that makes sense in a ring also makes sense in a commutative ring,
    and any theorem that holds in a ring also holds in a commutative ring. Some structures
    extend others by adding more data. For example, the additive part of any ring
    is an additive group. The ring structure adds a multiplication and an identity,
    as well as axioms that govern them and relate them to the additive part. Sometimes
    we can define one structure in terms of another. Any metric space has a canonical
    topology associated with it, the *metric space topology*, and there are various
    topologies that can be associated with any linear ordering.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is important to keep in mind that mathematics allows us to use functions
    and operations to define structures in the same way we use functions and operations
    to define numbers. Products and powers of groups are again groups. For every \(n\),
    the integers modulo \(n\) form a ring, and for every \(k > 0\), the \(k \times
    k\) matrices of polynomials with coefficients in that ring again form a ring.
    Thus we can calculate with structures just as easily as we can calculate with
    their elements. This means that algebraic structures lead dual lives in mathematics,
    as containers for collections of objects and as objects in their own right. A
    proof assistant has to accommodate this dual role.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with elements of a type that has an algebraic structure associated
    with it, a proof assistant needs to recognize the structure and find the relevant
    definitions, theorems, and notation. All this should sound like a lot of work,
    and it is. But Lean uses a small collection of fundamental mechanisms to carry
    out these tasks. The goal of this section is to explain these mechanisms and show
    you how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first ingredient is almost too obvious to mention: formally speaking, algebraic
    structures are structures in the sense of [Section 7.1](#section-structures).
    An algebraic structure is a specification of a bundle of data satisfying some
    axiomatic hypotheses, and we saw in [Section 7.1](#section-structures) that this
    is exactly what the `structure` command is designed to accommodate. It’s a marriage
    made in heaven!'
  prefs: []
  type: TYPE_NORMAL
- en: Given a data type `α`, we can define the group structure on `α` as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the type `α` is a *parameter* in the definition of `Group₁`. So
    you should think of an object `struc : Group₁ α` as being a group structure on
    `α`. We saw in [Section 2.2](C02_Basics.html#proving-identities-in-algebraic-structures)
    that the counterpart `mul_inv_cancel` to `inv_mul_cancel` follows from the other
    group axioms, so there is no need to add it to the definition.'
  prefs: []
  type: TYPE_NORMAL
- en: This definition of a group is similar to the definition of `Group` in Mathlib,
    and we have chosen the name `Group₁` to distinguish our version. If you write
    `#check Group` and ctrl-click on the definition, you will see that the Mathlib
    version of `Group` is defined to extend another structure; we will explain how
    to do that later. If you type `#print Group` you will also see that the Mathlib
    version of `Group` has a number of extra fields. For reasons we will explain later,
    sometimes it is useful to add redundant information to a structure, so that there
    are additional fields for objects and functions that can be defined from the core
    data. Don’t worry about that for now. Rest assured that our simplified version
    `Group₁` is morally the same as the definition of a group that Mathlib uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is sometimes useful to bundle the type together with the structure, and
    Mathlib also contains a definition of a `Grp` structure that is equivalent to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: The Mathlib version is found in `Mathlib.Algebra.Category.Grp.Basic`, and you
    can `#check` it if you add this to the imports at the beginning of the examples
    file.
  prefs: []
  type: TYPE_NORMAL
- en: For reasons that will become clearer below, it is more often useful to keep
    the type `α` separate from the structure `Group α`. We refer to the two objects
    together as a *partially bundled structure*, since the representation combines
    most, but not all, of the components into one structure. It is common in Mathlib
    to use capital roman letters like `G` for a type when it is used as the carrier
    type for a group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s construct a group, which is to say, an element of the `Group₁` type.
    For any pair of types `α` and `β`, Mathlib defines the type `Equiv α β` of *equivalences*
    between `α` and `β`. Mathlib also defines the suggestive notation `α ≃ β` for
    this type. An element `f : α ≃ β` is a bijection between `α` and `β` represented
    by four components: a function `f.toFun` from `α` to `β`, the inverse function
    `f.invFun` from `β` to `α`, and two properties that specify these functions are
    indeed inverse to one another.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Notice the creative naming of the last three constructions. We think of the
    identity function `Equiv.refl`, the inverse operation `Equiv.symm`, and the composition
    operation `Equiv.trans` as explicit evidence that the property of being in bijective
    correspondence is an equivalence relation.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that `f.trans g` requires composing the forward functions in reverse
    order. Mathlib has declared a *coercion* from `Equiv α β` to the function type
    `α → β`, so we can omit writing `.toFun` and have Lean insert it for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Mathlib also defines the type `perm α` of equivalences between `α` and itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be clear that `Equiv.Perm α` forms a group under composition of equivalences.
    We orient things so that `mul f g` is equal to `g.trans f`, whose forward function
    is `f ∘ g`. In other words, multiplication is what we ordinarily think of as composition
    of the bijections. Here we define this group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: In fact, Mathlib defines exactly this `Group` structure on `Equiv.Perm α` in
    the file `Algebra.Group.End`. As always, you can hover over the theorems used
    in the definition of `permGroup` to see their statements, and you can jump to
    their definitions in the original file to learn more about how they are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: In ordinary mathematics, we generally think of notation as independent of structure.
    For example, we can consider groups \((G_1, \cdot, 1, \cdot^{-1})\), \((G_2, \circ,
    e, i(\cdot))\), and \((G_3, +, 0, -)\). In the first case, we write the binary
    operation as \(\cdot\), the identity as \(1\), and the inverse function as \(x
    \mapsto x^{-1}\). In the second and third cases, we use the notational alternatives
    shown. When we formalize the notion of a group in Lean, however, the notation
    is more tightly linked to the structure. In Lean, the components of any `Group`
    are named `mul`, `one`, and `inv`, and in a moment we will see how multiplicative
    notation is set up to refer to them. If we want to use additive notation, we instead
    use an isomorphic structure `AddGroup` (the structure underlying additive groups).
    Its components are named `add`, `zero`, and `neg`, and the associated notation
    is what you would expect it to be.
  prefs: []
  type: TYPE_NORMAL
- en: Recall the type `Point` that we defined in [Section 7.1](#section-structures),
    and the addition function that we defined there. These definitions are reproduced
    in the examples file that accompanies this section. As an exercise, define an
    `AddGroup₁` structure that is similar to the `Group₁` structure we defined above,
    except that it uses the additive naming scheme just described. Define negation
    and a zero on the `Point` data type, and define the `AddGroup₁` structure on `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: We are making progress. Now we know how to define algebraic structures in Lean,
    and we know how to define instances of those structures. But we also want to associate
    notation with structures so that we can use it with each instance. Moreover, we
    want to arrange it so that we can define an operation on a structure and use it
    with any particular instance, and we want to arrange it so that we can prove a
    theorem about a structure and use it with any instance.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, Mathlib is already set up to use generic group notation, definitions,
    and theorems for `Equiv.Perm α`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: You can check that this is not the case for the additive group structure on
    `Point` that we asked you to define above. Our task now is to understand that
    magic that goes on under the hood in order to make the examples for `Equiv.Perm
    α` work the way they do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The issue is that Lean needs to be able to *find* the relevant notation and
    the implicit group structure, using the information that is found in the expressions
    that we type. Similarly, when we write `x + y` with expressions `x` and `y` that
    have type `ℝ`, Lean needs to interpret the `+` symbol as the relevant addition
    function on the reals. It also has to recognize the type `ℝ` as an instance of
    a commutative ring, so that all the definitions and theorems for a commutative
    ring are available. For another example, continuity is defined in Lean relative
    to any two topological spaces. When we have `f : ℝ → ℂ` and we write `Continuous
    f`, Lean has to find the relevant topologies on `ℝ` and `ℂ`.'
  prefs: []
  type: TYPE_NORMAL
- en: The magic is achieved with a combination of three things.
  prefs: []
  type: TYPE_NORMAL
- en: '*Logic.* A definition that should be interpreted in any group takes, as arguments,
    the type of the group and the group structure as arguments. Similarly, a theorem
    about the elements of an arbitrary group begins with universal quantifiers over
    the type of the group and the group structure.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Implicit arguments.* The arguments for the type and the structure are generally
    left implicit, so that we do not have to write them or see them in the Lean information
    window. Lean fills the information in for us silently.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Type class inference.* Also known as *class inference*, this is a simple but
    powerful mechanism that enables us to register information for Lean to use later
    on. When Lean is called on to fill in implicit arguments to a definition, theorem,
    or piece of notation, it can make use of information that has been registered.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Whereas an annotation `(grp : Group G)` tells Lean that it should expect to
    be given that argument explicitly and the annotation `{grp : Group G}` tells Lean
    that it should try to figure it out from contextual cues in the expression, the
    annotation `[grp : Group G]` tells Lean that the corresponding argument should
    be synthesized using type class inference. Since the whole point to the use of
    such arguments is that we generally do not need to refer to them explicitly, Lean
    allows us to write `[Group G]` and leave the name anonymous. You have probably
    already noticed that Lean chooses names like `_inst_1` automatically. When we
    use the anonymous square-bracket annotation with the `variables` command, then
    as long as the variables are still in scope, Lean automatically adds the argument
    `[Group G]` to any definition or theorem that mentions `G`.'
  prefs: []
  type: TYPE_NORMAL
- en: How do we register the information that Lean needs to use to carry out the search?
    Returning to our group example, we need only make two changes. First, instead
    of using the `structure` command to define the group structure, we use the keyword
    `class` to indicate that it is a candidate for class inference. Second, instead
    of defining particular instances with `def`, we use the keyword `instance` to
    register the particular instance with Lean. As with the names of class variables,
    we are allowed to leave the name of an instance definition anonymous, since in
    general we intend Lean to find it and put it to use without troubling us with
    the details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The following illustrates their use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#check` command shows that `Group₂.mul` has an implicit argument `[Group₂
    α]` that we expect to be found by class inference, where `α` is the type of the
    arguments to `Group₂.mul`. In other words, `{α : Type*}` is the implicit argument
    for the type of the group elements and `[Group₂ α]` is the implicit argument for
    the group structure on `α`. Similarly, when we define a generic squaring function
    `my_square` for `Group₂`, we use an implicit argument `{α : Type*}` for the type
    of the elements and an implicit argument `[Group₂ α]` for the `Group₂` structure.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, when we write `Group₂.mul f g`, the type of `f` and `g`
    tells Lean that in the argument `α` to `Group₂.mul` has to be instantiated to
    `Equiv.Perm β`. That means that Lean has to find an element of `Group₂ (Equiv.Perm
    β)`. The previous `instance` declaration tells Lean exactly how to do that. Problem
    solved!
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple mechanism for registering information so that Lean can find it
    when it needs it is remarkably useful. Here is one way it comes up. In Lean’s
    foundation, a data type `α` may be empty. In a number of applications, however,
    it is useful to know that a type has at least one element. For example, the function
    `List.headI`, which returns the first element of a list, can return the default
    value when the list is empty. To make that work, the Lean library defines a class
    `Inhabited α`, which does nothing more than store a default value. We can show
    that the `Point` type is an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: The class inference mechanism is also used for generic notation. The expression
    `x + y` is an abbreviation for `Add.add x y` where—you guessed it—`Add α` is a
    class that stores a binary function on `α`. Writing `x + y` tells Lean to find
    a registered instance of `[Add.add α]` and use the corresponding function. Below,
    we register the addition function for `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we can assign the notation `+` to binary operations on other types
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can do even better. We have seen that `*` can be used in any group,
    `+` can be used in any additive group, and both can be used in any ring. When
    we define a new instance of a ring in Lean, we don’t have to define `+` and `*`
    for that instance, because Lean knows that these are defined for every ring. We
    can use this method to specify notation for our `Group₂` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: What makes this approach work is that Lean carries out a recursive search. According
    to the instances we have declared, Lean can find an instance of `Mul (Equiv.Perm
    α)` by finding an instance of `Group₂ (Equiv.Perm α)`, and it can find an instance
    of `Group₂ (Equiv.Perm α)` because we have provided one. Lean is capable of finding
    these two facts and chaining them together.
  prefs: []
  type: TYPE_NORMAL
- en: The example we have just given is dangerous, because Lean’s library also has
    an instance of `Group (Equiv.Perm α)`, and multiplication is defined on any group.
    So it is ambiguous as to which instance is found. In fact, Lean favors more recent
    declarations unless you explicitly specify a different priority. Also, there is
    another way to tell Lean that one structure is an instance of another, using the
    `extends` keyword. This is how Mathlib specifies that, for example, every commutative
    ring is a ring. You can find more information in [Section 8](C08_Hierarchies.html#hierarchies)
    and in a [section on class inference](https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#managing-type-class-inference)
    in *Theorem Proving in Lean*.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is a bad idea to specify a value of `*` for an instance of an
    algebraic structure that already has the notation defined. Redefining the notion
    of `Group` in Lean is an artificial example. In this case, however, both interpretations
    of the group notation unfold to `Equiv.trans`, `Equiv.refl`, and `Equiv.symm`,
    in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: As a similarly artificial exercise, define a class `AddGroup₂` in analogy to
    `Group₂`. Define the usual notation for addition, negation, and zero on any `AddGroup₂`
    using the classes `Add`, `Neg`, and `Zero`. Then show `Point` is an instance of
    `AddGroup₂`. Try it out and make sure that the additive group notation works for
    elements of `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: It is not a big problem that we have already declared instances `Add`, `Neg`,
    and `Zero` for `Point` above. Once again, the two ways of synthesizing the notation
    should come up with the same answer.
  prefs: []
  type: TYPE_NORMAL
- en: Class inference is subtle, and you have to be careful when using it, because
    it configures automation that invisibly governs the interpretation of the expressions
    we type. When used wisely, however, class inference is a powerful tool. It is
    what makes algebraic reasoning possible in Lean.
  prefs: []
  type: TYPE_NORMAL
- en: '## 7.3\. Building the Gaussian Integers[](#building-the-gaussian-integers
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: We will now illustrate the use of the algebraic hierarchy in Lean by building
    an important mathematical object, the *Gaussian integers*, and showing that it
    is a Euclidean domain. In other words, according to the terminology we have been
    using, we will define the Gaussian integers and show that they are an instance
    of the Euclidean domain structure.
  prefs: []
  type: TYPE_NORMAL
- en: In ordinary mathematical terms, the set of Gaussian integers \(\Bbb{Z}[i]\)
    is the set of complex numbers \(\{ a + b i \mid a, b \in \Bbb{Z}\}\). But rather
    than define them as a subset of the complex numbers, our goal here is to define
    them as a data type in their own right. We do this by representing a Gaussian
    integer as a pair of integers, which we think of as the *real* and *imaginary*
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: We first show that the Gaussian integers have the structure of a ring, with
    `0` defined to be `⟨0, 0⟩`, `1` defined to be `⟨1, 0⟩`, and addition defined pointwise.
    To work out the definition of multiplication, remember that we want the element
    \(i\), represented by `⟨0, 1⟩`, to be a square root of \(-1\). Thus we want
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}(a + bi) (c + di) & = ac + bci + adi + bd i^2 \\ & = (ac - bd)
    + (bc + ad)i.\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: This explains the definition of `Mul` below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: As noted in [Section 7.1](#section-structures), it is a good idea to put all
    the definitions related to a data type in a namespace with the same name. Thus
    in the Lean files associated with this chapter, these definitions are made in
    the `GaussInt` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that here we are defining the interpretations of the notation `0`, `1`,
    `+`, `-`, and `*` directly, rather than naming them `GaussInt.zero` and the like
    and assigning the notation to those. It is often useful to have an explicit name
    for the definitions, for example, to use with `simp` and `rw`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: It is also useful to name the rules that compute the real and imaginary parts,
    and to declare them to the simplifier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: It is now surprisingly easy to show that the Gaussian integers are an instance
    of a commutative ring. We are putting the structure concept to good use. Each
    particular Gaussian integer is an instance of the `GaussInt` structure, whereas
    the type `GaussInt` itself, together with the relevant operations, is an instance
    of the `CommRing` structure. The `CommRing` structure, in turn, extends the notational
    structures `Zero`, `One`, `Add`, `Neg`, and `Mul`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you type `instance : CommRing GaussInt := _`, click on the light bulb that
    appears in VS Code, and then ask Lean to fill in a skeleton for the structure
    definition, you will see a scary number of entries. Jumping to the definition
    of the structure, however, shows that many of the fields have default definitions
    that Lean will fill in for you automatically. The essential ones appear in the
    definition below. A special case are `nsmul` and `zsmul` which should be ignored
    for now and will be explained in the next chapter. In each case, the relevant
    identity is proved by unfolding definitions, using the `ext` tactic to reduce
    the identities to their real and imaginary components, simplifying, and, if necessary,
    carrying out the relevant ring calculation in the integers. Note that we could
    easily avoid repeating all this code, but this is not the topic of the current
    discussion.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Lean’s library defines the class of *nontrivial* types to be types with at least
    two distinct elements. In the context of a ring, this is equivalent to saying
    that the zero is not equal to the one. Since some common theorems depend on that
    fact, we may as well establish it now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now show that the Gaussian integers have an important additional property.
    A *Euclidean domain* is a ring \(R\) equipped with a *norm* function \(N : R \to
    \mathbb{N}\) with the following two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: For every \(a\) and \(b \ne 0\) in \(R\), there are \(q\) and \(r\) in \(R\)
    such that \(a = bq + r\) and either \(r = 0\) or \(N(r) < N(b)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every \(a\) and \(b \ne 0\), \(N(a) \le N(ab)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ring of integers \(\Bbb{Z}\) with \(N(a) = |a|\) is an archetypal example
    of a Euclidean domain. In that case, we can take \(q\) to be the result of integer
    division of \(a\) by \(b\) and \(r\) to be the remainder. These functions are
    defined in Lean so that the satisfy the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: In an arbitrary ring, an element \(a\) is said to be a *unit* if it divides
    \(1\). A nonzero element \(a\) is said to be *irreducible* if it cannot be written
    in the form \(a = bc\) where neither \(b\) nor \(c\) is a unit. In the integers,
    every irreducible element \(a\) is *prime*, which is to say, whenever \(a\) divides
    a product \(bc\), it divides either \(b\) or \(c\). But in other rings this property
    can fail. In the ring \(\Bbb{Z}[\sqrt{-5}]\), we have
  prefs: []
  type: TYPE_NORMAL
- en: \[6 = 2 \cdot 3 = (1 + \sqrt{-5})(1 - \sqrt{-5}),\]
  prefs: []
  type: TYPE_NORMAL
- en: 'and the elements \(2\), \(3\), \(1 + \sqrt{-5}\), and \(1 - \sqrt{-5}\) are
    all irreducible, but they are not prime. For example, \(2\) divides the product
    \((1 + \sqrt{-5})(1 - \sqrt{-5})\), but it does not divide either factor. In particular,
    we no longer have unique factorization: the number \(6\) can be factored into
    irreducible elements in more than one way.'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, every Euclidean domain is a unique factorization domain, which
    implies that every irreducible element is prime. The axioms for a Euclidean domain
    imply that one can write any nonzero element as a finite product of irreducible
    elements. They also imply that one can use the Euclidean algorithm to find a greatest
    common divisor of any two nonzero elements `a` and `b`, i.e. an element that is
    divisible by any other common divisor. This, in turn, implies that factorization
    into irreducible elements is unique up to multiplication by units.
  prefs: []
  type: TYPE_NORMAL
- en: We now show that the Gaussian integers are a Euclidean domain with the norm
    defined by \(N(a + bi) = (a + bi)(a - bi) = a^2 + b^2\). The Gaussian integer
    \(a - bi\) is called the *conjugate* of \(a + bi\). It is not hard to check that
    for any complex numbers \(x\) and \(y\), we have \(N(xy) = N(x)N(y)\).
  prefs: []
  type: TYPE_NORMAL
- en: To see that this definition of the norm makes the Gaussian integers a Euclidean
    domain, only the first property is challenging. Suppose we want to write \(a +
    bi = (c + di) q + r\) for suitable \(q\) and \(r\). Treating \(a + bi\) and \(c
    + di\) as complex numbers, carry out the division
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{a + bi}{c + di} = \frac{(a + bi)(c - di)}{(c + di)(c-di)} = \frac{ac
    + bd}{c^2 + d^2} + \frac{bc -ad}{c^2+d^2} i.\]
  prefs: []
  type: TYPE_NORMAL
- en: The real and imaginary parts might not be integers, but we can round them to
    the nearest integers \(u\) and \(v\). We can then express the right-hand side
    as \((u + vi) + (u' + v'i)\), where \(u' + v'i\) is the part left over. Note that
    we have \(|u'| \le 1/2\) and \(|v'| \le 1/2\), and hence
  prefs: []
  type: TYPE_NORMAL
- en: \[N(u' + v' i) = (u')^2 + (v')^2 \le 1/4 + 1/4 \le 1/2.\]
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying through by \(c + di\), we have
  prefs: []
  type: TYPE_NORMAL
- en: \[a + bi = (c + di) (u + vi) + (c + di) (u' + v'i).\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting \(q = u + vi\) and \(r = (c + di) (u'' + v''i)\), we have \(a + bi
    = (c + di) q + r\), and we only need to bound \(N(r)\):'
  prefs: []
  type: TYPE_NORMAL
- en: \[N(r) = N(c + di)N(u' + v'i) \le N(c + di) \cdot 1/2 < N(c + di).\]
  prefs: []
  type: TYPE_NORMAL
- en: The argument we just carried out requires viewing the Gaussian integers as a
    subset of the complex numbers. One option for formalizing it in Lean is therefore
    to embed the Gaussian integers in the complex numbers, embed the integers in the
    Gaussian integers, define the rounding function from the real numbers to the integers,
    and take great care to pass back and forth between these number systems appropriately.
    In fact, this is exactly the approach that is followed in Mathlib, where the Gaussian
    integers themselves are constructed as a special case of a ring of *quadratic
    integers*. See the file [GaussianInt.lean](https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we will instead carry out an argument that stays in the integers. This
    illustrates a choice one commonly faces when formalizing mathematics. Given an
    argument that requires concepts or machinery that is not already in the library,
    one has two choices: either formalize the concepts and machinery needed, or adapt
    the argument to make use of concepts and machinery you already have. The first
    choice is generally a good investment of time when the results can be used in
    other contexts. Pragmatically speaking, however, sometimes seeking a more elementary
    proof is more efficient.'
  prefs: []
  type: TYPE_NORMAL
- en: The usual quotient-remainder theorem for the integers says that for every \(a\)
    and nonzero \(b\), there are \(q\) and \(r\) such that \(a = b q + r\) and \(0
    \le r < b\). Here we will make use of the following variation, which says that
    there are \(q'\) and \(r'\) such that \(a = b q' + r'\) and \(|r'| \le b/2\).
    You can check that if the value of \(r\) in the first statement satisfies \(r
    \le b/2\), we can take \(q' = q\) and \(r' = r\), and otherwise we can take \(q'
    = q + 1\) and \(r' = r - b\). We are grateful to Heather Macbeth for suggesting
    the following more elegant approach, which avoids definition by cases. We simply
    add `b / 2` to `a` before dividing and then subtract it from the remainder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of our old friend, `linarith`. We will also need to express `mod'`
    in terms of `div'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: We will use the fact that \(x^2 + y^2\) is equal to zero if and only if \(x\)
    and \(y\) are both zero. As an exercise, we ask you to prove that this holds in
    any ordered ring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: We will put all the remaining definitions and theorems in this section in the
    `GaussInt` namespace. First, we define the `norm` function and ask you to establish
    some of its properties. The proofs are all short.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we define the conjugate function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we define division for the Gaussian integers with the notation `x /
    y`, that rounds the complex quotient to the nearest Gaussian integer. We use our
    bespoke `Int.div'` for that purpose. As we calculated above, if `x` is \(a + bi\)
    and `y` is \(c + di\), then the real and imaginary parts of `x / y` are the nearest
    integers to
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{ac + bd}{c^2 + d^2} \quad \text{and} \quad \frac{bc -ad}{c^2+d^2},\]
  prefs: []
  type: TYPE_NORMAL
- en: respectively. Here the numerators are the real and imaginary parts of \((a +
    bi) (c - di)\), and the denominators are both equal to the norm of \(c + di\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Having defined `x / y`, We define `x % y` to be the remainder, `x - (x / y)
    * y`. As above, we record the definitions in the theorems `div_def` and `mod_def`
    so that we can use them with `simp` and `rw`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: These definitions immediately yield `x = y * (x / y) + x % y` for every `x`
    and `y`, so all we need to do is show that the norm of `x % y` is less than the
    norm of `y` when `y` is not zero.
  prefs: []
  type: TYPE_NORMAL
- en: We just defined the real and imaginary parts of `x / y` to be `div' (x * conj
    y).re (norm y)` and `div' (x * conj y).im (norm y)`, respectively. Calculating,
    we have
  prefs: []
  type: TYPE_NORMAL
- en: '`(x % y) * conj y = (x - x / y * y) * conj y = x * conj y - x / y * (y * conj
    y)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The real and imaginary parts of the right-hand side are exactly `mod' (x * conj
    y).re (norm y)` and `mod' (x * conj y).im (norm y)`. By the properties of `div'`
    and `mod'`, these are guaranteed to be less than or equal to `norm y / 2`. So
    we have
  prefs: []
  type: TYPE_NORMAL
- en: '`norm ((x % y) * conj y) ≤ (norm y / 2)^2 + (norm y / 2)^2 ≤ (norm y / 2) *
    norm y`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On the other hand, we have
  prefs: []
  type: TYPE_NORMAL
- en: '`norm ((x % y) * conj y) = norm (x % y) * norm (conj y) = norm (x % y) * norm
    y`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dividing through by `norm y` we have `norm (x % y) ≤ (norm y) / 2 < norm y`,
    as required.
  prefs: []
  type: TYPE_NORMAL
- en: This messy calculation is carried out in the next proof. We encourage you to
    step through the details and see if you can find a nicer argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: We are in the home stretch. Our `norm` function maps Gaussian integers to nonnegative
    integers. We need a function that maps Gaussian integers to natural numbers, and
    we obtain that by composing `norm` with the function `Int.natAbs`, which maps
    integers to the natural numbers. The first of the next two lemmas establishes
    that mapping the norm to the natural numbers and back to the integers does not
    change the value. The second one re-expresses the fact that the norm is decreasing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: We also need to establish the second key property of the norm function on a
    Euclidean domain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: We can now put it together to show that the Gaussian integers are an instance
    of a Euclidean domain. We use the quotient and remainder function we have defined.
    The Mathlib definition of a Euclidean domain is more general than the one above
    in that it allows us to show that remainder decreases with respect to any well-founded
    measure. Comparing the values of a norm function that returns natural numbers
    is just one instance of such a measure, and in that case, the required properties
    are the theorems `natAbs_norm_mod_lt` and `not_norm_mul_left_lt_norm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: An immediate payoff is that we now know that, in the Gaussian integers, the
    notions of being prime and being irreducible coincide.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]*'
  prefs: []
  type: TYPE_NORMAL
