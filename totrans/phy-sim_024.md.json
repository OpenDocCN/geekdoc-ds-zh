["```py\nimport copy\nfrom cmath import inf\n\nimport numpy as np\nimport numpy.linalg as LA\nimport scipy.sparse as sparse\nfrom scipy.sparse.linalg import spsolve\n\nimport InertiaEnergy\nimport MassSpringEnergy\n\ndef step_forward(x, e, v, m, l2, k, h, tol):\n    x_tilde = x + v * h     # implicit Euler predictive position\n    x_n = copy.deepcopy(x)\n\n    # Newton loop\n    iter = 0\n    E_last = IP_val(x, e, x_tilde, m, l2, k, h)\n    p = search_dir(x, e, x_tilde, m, l2, k, h)\n    while LA.norm(p, inf) / h > tol:\n        print('Iteration', iter, ':')\n        print('residual =', LA.norm(p, inf) / h)\n\n        # line search\n        alpha = 1\n        while IP_val(x + alpha * p, e, x_tilde, m, l2, k, h) > E_last:\n            alpha /= 2\n        print('step size =', alpha)\n\n        x += alpha * p\n        E_last = IP_val(x, e, x_tilde, m, l2, k, h)\n        p = search_dir(x, e, x_tilde, m, l2, k, h)\n        iter += 1\n\n    v = (x - x_n) / h   # implicit Euler velocity update\n    return [x, v]\n\ndef IP_val(x, e, x_tilde, m, l2, k, h):\n    return InertiaEnergy.val(x, x_tilde, m) + h * h * MassSpringEnergy.val(x, e, l2, k)     # implicit Euler\n\ndef IP_grad(x, e, x_tilde, m, l2, k, h):\n    return InertiaEnergy.grad(x, x_tilde, m) + h * h * MassSpringEnergy.grad(x, e, l2, k)   # implicit Euler\n\ndef IP_hess(x, e, x_tilde, m, l2, k, h):\n    IJV_In = InertiaEnergy.hess(x, x_tilde, m)\n    IJV_MS = MassSpringEnergy.hess(x, e, l2, k)\n    IJV_MS[2] *= h * h    # implicit Euler\n    IJV = np.append(IJV_In, IJV_MS, axis=1)\n    H = sparse.coo_matrix((IJV[2], (IJV[0], IJV[1])), shape=(len(x) * 2, len(x) * 2)).tocsr()\n    return H\n\ndef search_dir(x, e, x_tilde, m, l2, k, h):\n    projected_hess = IP_hess(x, e, x_tilde, m, l2, k, h)\n    reshaped_grad = IP_grad(x, e, x_tilde, m, l2, k, h).reshape(len(x) * 2, 1)\n    return spsolve(projected_hess, -reshaped_grad).reshape(len(x), 2) \n```"]