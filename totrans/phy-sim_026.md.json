["```py\ntemplate <typename T, int dim>\nstruct MassSpringEnergy<T, dim>::Impl\n{\n\tDeviceBuffer<T> device_x;\n\tDeviceBuffer<T> device_l2, device_k;\n\tDeviceBuffer<int> device_e;\n\tint N;\n\tDeviceBuffer<T> device_grad;\n\tDeviceTripletMatrix<T, 1> device_hess;\n}; \n```", "```py\ntemplate <typename T, int dim>\nvoid MassSpringSimulator<T, dim>::Impl::step_forward()\n{\n    update_x_tilde(add_vector<T>(device_x, device_v, 1, h));\n    DeviceBuffer<T> device_x_n = device_x; // Copy current positions to device_x_n\n    int iter = 0;\n    T E_last = IP_val();\n    DeviceBuffer<T> device_p = search_direction();\n    T residual = max_vector(device_p) / h;\n    while (residual > tol)\n    {\n        std::cout << \"Iteration \" << iter << \" residual \" << residual << \"E_last\" << E_last << \"\\n\";\n        // Line search\n        T alpha = 1;\n        DeviceBuffer<T> device_x0 = device_x;\n        update_x(add_vector<T>(device_x0, device_p, 1.0, alpha));\n        while (IP_val() > E_last)\n        {\n            alpha /= 2;\n            update_x(add_vector<T>(device_x0, device_p, 1.0, alpha));\n        }\n        std::cout << \"step size = \" << alpha << \"\\n\";\n        E_last = IP_val();\n        device_p = search_direction();\n        residual = max_vector(device_p) / h;\n        iter += 1;\n    }\n    update_v(add_vector<T>(device_x, device_x_n, 1 / h, -1 / h));\n} \n```", "```py\ntemplate <typename T, int dim>\nvoid MassSpringSimulator<T, dim>::Impl::update_x(const DeviceBuffer<T> &new_x)\n{\n    inertialenergy.update_x(new_x);\n    massspringenergy.update_x(new_x);\n    device_x = new_x;\n} \n```", "```py\ntemplate <typename T, int dim>\nT MassSpringSimulator<T, dim>::Impl::IP_val()\n{\n\n    return inertialenergy.val() + massspringenergy.val() * h * h;\n} \n```", "```py\ntemplate <typename T, int dim>\nDeviceBuffer<T> MassSpringSimulator<T, dim>::Impl::IP_grad()\n{\n    return add_vector<T>(inertialenergy.grad(), massspringenergy.grad(), 1.0, h * h);\n}\n\ntemplate <typename T, int dim>\nDeviceTripletMatrix<T, 1> MassSpringSimulator<T, dim>::Impl::IP_hess()\n{\n    DeviceTripletMatrix<T, 1> inertial_hess = inertialenergy.hess();\n    DeviceTripletMatrix<T, 1> massspring_hess = massspringenergy.hess();\n    DeviceTripletMatrix<T, 1> hess = add_triplet<T>(inertial_hess, massspring_hess, 1.0, h * h);\n    return hess;\n} \n```", "```py\ntemplate <typename T, int dim>\nT MassSpringEnergy<T, dim>::val()\n{\n\tauto &device_x = pimpl_->device_x;\n\tauto &device_e = pimpl_->device_e;\n\tauto &device_l2 = pimpl_->device_l2;\n\tauto &device_k = pimpl_->device_k;\n\tint N = device_e.size() / 2;\n\tDeviceBuffer<T> device_val(N);\n\tParallelFor(256).apply(N, [device_val = device_val.viewer(), device_x = device_x.cviewer(), device_e = device_e.cviewer(), device_l2 = device_l2.cviewer(), device_k = device_k.cviewer()] __device__(int i) mutable\n\t\t\t\t\t\t   {\n\t\tint idx1= device_e(2 * i); // First node index\n\t\tint idx2 = device_e(2 * i + 1); // Second node index\n\t\tT diff = 0;\n\t\tfor (int d = 0; d < dim;d++){\n\t\t\tT diffi = device_x(dim * idx1 + d) - device_x(dim * idx2 + d);\n\t\t\tdiff += diffi * diffi;\n\t\t}\n\t\tdevice_val(i) = 0.5 * device_l2(i) * device_k(i) * (diff / device_l2(i) - 1) * (diff / device_l2(i) - 1); })\n\t\t.wait();\n\n\treturn devicesum(device_val);\n} // Calculate the energy \n```", "```py\ntemplate <typename T, int dim>\nconst DeviceBuffer<T> &MassSpringEnergy<T, dim>::grad()\n{\n\tauto &device_x = pimpl_->device_x;\n\tauto &device_e = pimpl_->device_e;\n\tauto &device_l2 = pimpl_->device_l2;\n\tauto &device_k = pimpl_->device_k;\n\tauto N = pimpl_->device_e.size() / 2;\n\tauto &device_grad = pimpl_->device_grad;\n\tdevice_grad.fill(0);\n\tParallelFor(256).apply(N, [device_x = device_x.cviewer(), device_e = device_e.cviewer(), device_l2 = device_l2.cviewer(), device_k = device_k.cviewer(), device_grad = device_grad.viewer()] __device__(int i) mutable\n\t\t\t\t\t\t   {\n\t\tint idx1= device_e(2 * i); // First node index\n\t\tint idx2 = device_e(2 * i + 1); // Second node index\n\t\tT diff = 0;\n\t\tT diffi[dim];\n\t\tfor (int d = 0; d < dim;d++){\n\t\t\tdiffi[d] = device_x(dim * idx1 + d) - device_x(dim * idx2 + d);\n\t\t\tdiff += diffi[d] * diffi[d];\n\t\t}\n\t\tT factor = 2 * device_k(i) * (diff / device_l2(i) -1);\n\t\tfor(int d=0;d<dim;d++){\n\t\t   atomicAdd(&device_grad(dim * idx1 + d), factor * diffi[d]);\n\t\t   atomicAdd(&device_grad(dim * idx2 + d), -factor * diffi[d]);\t  \n\t\t} })\n\t\t.wait();\n\t// display_vec(device_grad);\n\treturn device_grad;\n} \n```", "```py\ntemplate <typename T, int dim>\nconst DeviceTripletMatrix<T, 1> &MassSpringEnergy<T, dim>::hess()\n{\n\tauto &device_x = pimpl_->device_x;\n\tauto &device_e = pimpl_->device_e;\n\tauto &device_l2 = pimpl_->device_l2;\n\tauto &device_k = pimpl_->device_k;\n\tauto N = device_e.size() / 2;\n\tauto &device_hess = pimpl_->device_hess;\n\tauto device_hess_row_idx = device_hess.row_indices();\n\tauto device_hess_col_idx = device_hess.col_indices();\n\tauto device_hess_val = device_hess.values();\n\tdevice_hess_val.fill(0);\n\tParallelFor(256).apply(N, [device_x = device_x.cviewer(), device_e = device_e.cviewer(), device_l2 = device_l2.cviewer(), device_k = device_k.cviewer(), device_hess_val = device_hess_val.viewer(), device_hess_row_idx = device_hess_row_idx.viewer(), device_hess_col_idx = device_hess_col_idx.viewer(), N] __device__(int i) mutable\n\t\t\t\t\t\t   {\n\t\tint idx[2] = {device_e(2 * i), device_e(2 * i + 1)}; // First node index\n\t\tT diff = 0;\n\t\tT diffi[dim];\n\t\tfor (int d = 0; d < dim; d++)\n\t\t{\n\t\t\tdiffi[d] = device_x(dim * idx[0] + d) - device_x(dim * idx[1] + d);\n\t\t\tdiff += diffi[d] * diffi[d];\n\t\t}\n\t\tEigen::Matrix<T, dim, 1> diff_vec(diffi);\n\t\tEigen::Matrix<T, dim, dim> diff_outer = diff_vec * diff_vec.transpose();\n\t\tT scalar = 2 * device_k(i) / device_l2(i);\n\t\tEigen::Matrix<T, dim, dim> H_diff = scalar * (2 * diff_outer + (diff_vec.dot(diff_vec) - device_l2(i)) * Eigen::Matrix<T, dim, dim>::Identity());\n\t\tEigen::Matrix<T, dim * 2, dim * 2> H_block, H_local;\n\t\tH_block << H_diff, -H_diff,\n\t\t\t-H_diff, H_diff;\n\t\tmake_PSD(H_block, H_local);\n\t\t// add to global matrix\n\t\tfor (int ni = 0; ni < 2; ni++)\n\t\t\tfor (int nj = 0; nj < 2; nj++)\n\t\t\t{\n\t\t\t\tint indStart = i * 4*dim*dim + (ni * 2 + nj) * dim*dim;\n\t\t\t\tfor (int d1 = 0; d1 < dim; d1++)\n\t\t\t\t\tfor (int d2 = 0; d2 < dim; d2++){\n\t\t\t\t\t\tdevice_hess_row_idx(indStart + d1 * dim + d2)= idx[ni] * dim + d1;\n\t\t\t\t\t\tdevice_hess_col_idx(indStart + d1 * dim + d2)= idx[nj] * dim + d2;\n\t\t\t\t\t\tdevice_hess_val(indStart + d1 * dim + d2) = H_local(ni * dim + d1, nj * dim + d2);\n\t\t\t\t\t}\n\t\t\t} })\n\t\t.wait();\n\treturn device_hess;\n} // Calculate the Hessian of the energy \n```"]