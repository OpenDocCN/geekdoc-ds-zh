<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>9.3Â ArraysðŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>9.3Â ArraysðŸ”—</h1>
<blockquote>åŽŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/arrays.html">https://dcic-world.org/2025-08-27/arrays.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Two_.Memory_.Layouts_for_.Ordered_.Items%29" class="toclink" data-pltdoc="x">9.3.1<span class="hspace">Â </span>Two Memory Layouts for Ordered Items</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Iterating_.Partly_through_an_.Ordered_.Datum%29" class="toclink" data-pltdoc="x">9.3.2<span class="hspace">Â </span>Iterating Partly through an Ordered Datum</a></p></td></tr></table><p>We ended the last chapter with a question about how fast one can access a
specific element of a list.  Specifically, if you have a list called
<span class="emph">finishers</span> of Runners (our example from last time) and you
write:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">finishers[9]</code></pre></div></div><p>How long does it take to locate the Runner in 10th place (remember,
indices start at 0)?</p><p>It depends on how the list is laid out in memory.</p><section class="SsectionLevel4" id="section 9.3.1"><h4 class="heading">9.3.1<span class="stt">Â </span><a name="(part._.Two_.Memory_.Layouts_for_.Ordered_.Items)"/>Two Memory Layouts for Ordered Items<span class="button-group"><a href="#(part._.Two_.Memory_.Layouts_for_.Ordered_.Items)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>When we say "list", we usually mean simply: a collection of items with
order. How might a collection of ordered items be arranged in memory?
Here are two examples, using a list of course names:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">courses = ["CS111", "ENGN90", "VISA100"]</code></pre></div></div><p>In the first version, the elements are laid out in consecutive memory
locations (this is rougly how weâ€™ve shown lists up to now):</p><p/><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">Prog Directory</span><span class="hspace">Â Â Â Â Â Â Â Â Â Â Â </span><span class="stt">Memory</span></p></td></tr><tr><td><p><span class="stt">--------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="stt">courses --&gt; loc 1001</span><span class="hspace">Â Â Â Â Â Â </span><span class="stt">loc 1001 --&gt; [loc 1002, loc1003, loc 1004]</span></p></td></tr><tr><td><p><span class="stt"/><span class="hspace">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </span><span class="stt">loc 1002 --&gt; "CS111"</span></p></td></tr><tr><td><p><span class="stt"/><span class="hspace">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </span><span class="stt">loc 1003 --&gt; "ENGN90"</span></p></td></tr><tr><td><p><span class="stt"/><span class="hspace">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </span><span class="stt">loc 1004 --&gt; "VISA100"</span></p></td></tr></table><p>In the second version, each element is captured as a datatype
containing the element and the next list location. When we were in
Pyret, this datatype was called <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">link</code></span>.</p><p/><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">Prog Directory</span><span class="hspace">Â Â Â Â Â Â Â Â Â Â Â </span><span class="stt">Memory</span></p></td></tr><tr><td><p><span class="stt">--------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="stt">courses --&gt; loc 1001</span><span class="hspace">Â Â Â Â Â Â </span><span class="stt">loc 1001 --&gt; link("CS111", loc 1002)</span></p></td></tr><tr><td><p><span class="stt"/><span class="hspace">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </span><span class="stt">loc 1002 --&gt; link("ENGN90", loc 1003)</span></p></td></tr><tr><td><p><span class="stt"/><span class="hspace">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </span><span class="stt">loc 1003 --&gt; link("VISA100", loc 1004)</span></p></td></tr><tr><td><p><span class="stt"/><span class="hspace">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </span><span class="stt">loc 1004 --&gt; empty</span></p></td></tr></table><p>What are the tradeoffs between the two versions?  In the first, we can
access items by index in constant time, as we could for hashtables,
but changing the contents (adding or deleting) requires moving things
around in memory.  In the second, the size of the collection can grow
or shrink arbitrarily, but it takes time proportional to the index to
look up a specific value.  Each organization has its place in some
programs.</p><p>In data structures terms, the first organization is called an
<span class="emph">array</span>.  The second is called a <span class="emph">linked list</span>.  Pyret
implements linked lists, with arrays being a separate data type (with
a different notation from lists). Python implements lists as
arrays. When you approach a new programming language, you need to look
up whether its lists are linked lists or arrays if you care about the
run-time performance of the underlying operations.</p><p>Going back to our Runners discussion from the last chapter, we can simply
use Python lists (arrays) rather than a hashtable, and be able to
access the names of Runners who finished in particular positions. But
letâ€™s instead ask a different question.</p><p>How would we report the top finishers in each age category? In
particular, we want to write a function such as the following:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def top_5_range(runners: list, lo: int, high: int) -&gt; list:
    """get list of top 5 finishers with ages in
       the range given by lo to high, inclusive
    """</code></pre></div></div><p><span style="font-weight: bold">Think about how you would write this code.</span></p><p>Hereâ€™s our solution:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def top_5_range(runners: list, lo: int, high: int) -&gt; list:
    """get list of top 5 finishers with ages in
       the range given by lo to high, inclusive
    """

    # count of runners seen who are in age range
    in_range: int = 0
    # the list of finishers
    result: list = []

    for r in runners:
        if lo &lt;= r.age and r.age &lt;= high:
            in_range += 1
            result.append(r)
        if in_range == 5:
            return result
    print("Fewer than five in category")
    return result</code></pre></div></div><p>Here, rather than return only when we get to the end of the list, we
want to return once we have five runners in the list. So we set up an
additional variable (<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">in_range</code></span>) to help us track progress of the
computation. Once we have gotten to 5 runners, we return the list. If
we never get to 5 runners, we print a warning to the user then return
the results that we do have.</p><p>Couldnâ€™t we have just looked at the length of the list, rather than
maintain the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">in_range</code></span> variable?  Yes, we could have, though
this version sets up a contrast to our next example.</p></section><section class="SsectionLevel4" id="section 9.3.2"><h4 class="heading">9.3.2<span class="stt">Â </span><a name="(part._.Iterating_.Partly_through_an_.Ordered_.Datum)"/>Iterating Partly through an Ordered Datum<span class="button-group"><a href="#(part._.Iterating_.Partly_through_an_.Ordered_.Datum)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>What if instead we just wanted to print out the top 5 finishers,
rather than gather a list?  While in general it is usually better to
separate computing and displaying data, in practice we do sometimes
merge them, or do other operations (like write some data to file)
which wonâ€™t return anything. How do we modify the code to print the
names rather than build up a list of the runners?</p><p>The challenge here is how to stop the computation. When we are
building up a list, we stop a computation using return. But if our
code isnâ€™t returning, or otherwise needs to stop a loop before it
reaches the end of the data, what do we do?</p><p>We use a command called <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">break</code></span>, which says to terminate the loop
and continue the rest of the computation. Here, the break is in place
of the inner return statement:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def print_top_5_range(runners: list, lo: int, high: int):
    """print top 5 finishers with ages in
       the range given by lo to high, inclusive
    """

    # count of runners seen who are in age range
    in_range: int = 0

    for r in runners:
        if lo &lt;= r.age and r.age &lt;= high:
            in_range += 1
            print(r.name)
        if in_range == 5:
            break
    print("End of results")
</code></pre></div></div><p>If Python reaches the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">break</code></span> statement, it terminates the for
loop and goes to the next statement, which is the print at the end of
the function.</p></section>&#13;
<h4 class="heading">9.3.1<span class="stt">Â </span><a name="(part._.Two_.Memory_.Layouts_for_.Ordered_.Items)"/>Two Memory Layouts for Ordered Items<span class="button-group"><a href="#(part._.Two_.Memory_.Layouts_for_.Ordered_.Items)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>When we say "list", we usually mean simply: a collection of items with
order. How might a collection of ordered items be arranged in memory?
Here are two examples, using a list of course names:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">courses = ["CS111", "ENGN90", "VISA100"]</code></pre></div></div><p>In the first version, the elements are laid out in consecutive memory
locations (this is rougly how weâ€™ve shown lists up to now):</p><p/><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">Prog Directory</span><span class="hspace">Â Â Â Â Â Â Â Â Â Â Â </span><span class="stt">Memory</span></p></td></tr><tr><td><p><span class="stt">--------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="stt">courses --&gt; loc 1001</span><span class="hspace">Â Â Â Â Â Â </span><span class="stt">loc 1001 --&gt; [loc 1002, loc1003, loc 1004]</span></p></td></tr><tr><td><p><span class="stt"/><span class="hspace">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </span><span class="stt">loc 1002 --&gt; "CS111"</span></p></td></tr><tr><td><p><span class="stt"/><span class="hspace">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </span><span class="stt">loc 1003 --&gt; "ENGN90"</span></p></td></tr><tr><td><p><span class="stt"/><span class="hspace">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </span><span class="stt">loc 1004 --&gt; "VISA100"</span></p></td></tr></table><p>In the second version, each element is captured as a datatype
containing the element and the next list location. When we were in
Pyret, this datatype was called <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">link</code></span>.</p><p/><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">Prog Directory</span><span class="hspace">Â Â Â Â Â Â Â Â Â Â Â </span><span class="stt">Memory</span></p></td></tr><tr><td><p><span class="stt">--------------------------------------------------------------------</span></p></td></tr><tr><td><p><span class="stt">courses --&gt; loc 1001</span><span class="hspace">Â Â Â Â Â Â </span><span class="stt">loc 1001 --&gt; link("CS111", loc 1002)</span></p></td></tr><tr><td><p><span class="stt"/><span class="hspace">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </span><span class="stt">loc 1002 --&gt; link("ENGN90", loc 1003)</span></p></td></tr><tr><td><p><span class="stt"/><span class="hspace">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </span><span class="stt">loc 1003 --&gt; link("VISA100", loc 1004)</span></p></td></tr><tr><td><p><span class="stt"/><span class="hspace">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </span><span class="stt">loc 1004 --&gt; empty</span></p></td></tr></table><p>What are the tradeoffs between the two versions?  In the first, we can
access items by index in constant time, as we could for hashtables,
but changing the contents (adding or deleting) requires moving things
around in memory.  In the second, the size of the collection can grow
or shrink arbitrarily, but it takes time proportional to the index to
look up a specific value.  Each organization has its place in some
programs.</p><p>In data structures terms, the first organization is called an
<span class="emph">array</span>.  The second is called a <span class="emph">linked list</span>.  Pyret
implements linked lists, with arrays being a separate data type (with
a different notation from lists). Python implements lists as
arrays. When you approach a new programming language, you need to look
up whether its lists are linked lists or arrays if you care about the
run-time performance of the underlying operations.</p><p>Going back to our Runners discussion from the last chapter, we can simply
use Python lists (arrays) rather than a hashtable, and be able to
access the names of Runners who finished in particular positions. But
letâ€™s instead ask a different question.</p><p>How would we report the top finishers in each age category? In
particular, we want to write a function such as the following:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def top_5_range(runners: list, lo: int, high: int) -&gt; list:
    """get list of top 5 finishers with ages in
       the range given by lo to high, inclusive
    """</code></pre></div></div><p><span style="font-weight: bold">Think about how you would write this code.</span></p><p>Hereâ€™s our solution:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def top_5_range(runners: list, lo: int, high: int) -&gt; list:
    """get list of top 5 finishers with ages in
       the range given by lo to high, inclusive
    """

    # count of runners seen who are in age range
    in_range: int = 0
    # the list of finishers
    result: list = []

    for r in runners:
        if lo &lt;= r.age and r.age &lt;= high:
            in_range += 1
            result.append(r)
        if in_range == 5:
            return result
    print("Fewer than five in category")
    return result</code></pre></div></div><p>Here, rather than return only when we get to the end of the list, we
want to return once we have five runners in the list. So we set up an
additional variable (<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">in_range</code></span>) to help us track progress of the
computation. Once we have gotten to 5 runners, we return the list. If
we never get to 5 runners, we print a warning to the user then return
the results that we do have.</p><p>Couldnâ€™t we have just looked at the length of the list, rather than
maintain the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">in_range</code></span> variable?  Yes, we could have, though
this version sets up a contrast to our next example.</p>&#13;
<h4 class="heading">9.3.2<span class="stt">Â </span><a name="(part._.Iterating_.Partly_through_an_.Ordered_.Datum)"/>Iterating Partly through an Ordered Datum<span class="button-group"><a href="#(part._.Iterating_.Partly_through_an_.Ordered_.Datum)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>What if instead we just wanted to print out the top 5 finishers,
rather than gather a list?  While in general it is usually better to
separate computing and displaying data, in practice we do sometimes
merge them, or do other operations (like write some data to file)
which wonâ€™t return anything. How do we modify the code to print the
names rather than build up a list of the runners?</p><p>The challenge here is how to stop the computation. When we are
building up a list, we stop a computation using return. But if our
code isnâ€™t returning, or otherwise needs to stop a loop before it
reaches the end of the data, what do we do?</p><p>We use a command called <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">break</code></span>, which says to terminate the loop
and continue the rest of the computation. Here, the break is in place
of the inner return statement:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def print_top_5_range(runners: list, lo: int, high: int):
    """print top 5 finishers with ages in
       the range given by lo to high, inclusive
    """

    # count of runners seen who are in age range
    in_range: int = 0

    for r in runners:
        if lo &lt;= r.age and r.age &lt;= high:
            in_range += 1
            print(r.name)
        if in_range == 5:
            break
    print("End of results")
</code></pre></div></div><p>If Python reaches the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">break</code></span> statement, it terminates the for
loop and goes to the next statement, which is the print at the end of
the function.</p>    
</body>
</html>