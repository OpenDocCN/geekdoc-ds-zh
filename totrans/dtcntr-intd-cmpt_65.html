<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>20Â Recursion and Cycles from MutationğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>20Â Recursion and Cycles from MutationğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/rec-from-mut.html">https://dcic-world.org/2025-08-27/rec-from-mut.html</a></blockquote><p>Earlier [<a href="Sharing_and_Equality.html#%28part._acyc-to-cyc%29" data-pltdoc="x">From Acyclicity to Cycles</a>], we saw the difficulty of
constructing cyclic data, and saw how we could address this problem
using state [<a href="unified-cyclic-data.html" data-pltdoc="x">Cyclic Data</a>]. Let us now return to the
earlier example of creating a cyclic list of alternating colors. We
had tried to write:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web-colors = link("white", link("grey", web-colors))</code></pre><p>which, as we noted, does not pass muster because <code data-lang="pyret" class="sourceCode">web-colors</code> is
not bound on the right of the <code data-lang="pyret" class="sourceCode">=</code>. (Why not? Because otherwise,
if we try to substitute <code data-lang="pyret" class="sourceCode">web-colors</code> on the right, we would end
up in an infinite regress.)</p><p>Something about this should make you a little suspicious: we have been
able to write recursive functions all the time, without
difficulty. Why are they different? For two reasons:
</p><ul><li><p>The first reason is the fact that weâ€™re defining a
function. A functionâ€™s body is not evaluated right awayâ€”<wbr/>only
when we apply itâ€”<wbr/>so the language can wait for the body to finish
being defined. (Weâ€™ll see what this might mean in a moment.)</p></li><li><p>The second reason isnâ€™t actually a reason: function definitions
actually are special. But we are about to expose whatâ€™s so special
about themâ€”<wbr/>itâ€™s the use of a box! [<a href="state-in-pyret.html#%28part._boxes%29" data-pltdoc="x">Boxes: A Canonical Mutable Structure</a>]â€”<wbr/>so that any
definition can avail of it.</p></li></ul><p>Returning to our example above, recall that we canâ€™t make up our list
using <code data-lang="pyret" class="sourceCode">link</code>s, because we want the list to never
terminate. Therefore, let us first define a new datatype to hold an
cyclic list:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Pair: p(hd, tl) end</code></pre><p>You should think of this as analogous to a list, where <code data-lang="pyret" class="sourceCode">hd</code> is
the first element and <code data-lang="pyret" class="sourceCode">tl</code> is the rest.</p><p>Observe that we have carefully avoided writing type definitions for
the fields; we will instead try to figure them out as we go
along. Also, however, this definition as written cannot work.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Do you see why not?</p></blockquote></blockquote><p>Letâ€™s decompose the intended infinite list into two pieces: lists that
begin with white and ones that begin with grey. What follows white? A
grey list. What follows grey? A white list. It is clear we canâ€™t write
down these two definitions because one of them must precede the other,
but each one depends on the other. (This is the same problem as trying
to write a single definition above.)</p><section class="SsectionLevel3" id="section 20.1"><h3 class="heading">20.1Â <a name="(part._.Partial_.Definitions)"/>Partial Definitions<a href="#(part._.Partial_.Definitions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>What we need to instead do is to partially define each list,
and then complete the definition using the other one. However,
that is impossible using the above definition, because we cannot
change anything once it is constructed. Instead, therefore, we need:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Pair: p(hd, ref tl) end</code></pre><p>Note that this datatype lacks a base case, which should remind you of
definitions we saw in <a href="func-as-data.html#%28part._streams-from-funs%29" data-pltdoc="x">Streams From Functions</a>.</p><p>Using this, we can define:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">white-pair = p("white", "dummy")
grey-pair = p("grey", "dummy")</code></pre><p>Each of these definitions is quite useless by itself, but they each
represent what we want, and they have a mutable field for the
rest, currently holding a dummy value. Therefore, itâ€™s clear what we
must do next: update the mutable field.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">white-pair!{tl: grey-pair}
grey-pair!{tl: white-pair}</code></pre><p>Because we have ordained that our colors must alternate beginning with
white, this rounds up our definition:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web-colors = white-pair</code></pre><p>If we ask Pyret to inspect the value of <code data-lang="pyret" class="sourceCode">web-colors</code>, we notice
that it employs an algorithm to prevent traversing infinite
objects. You can learn more about how that works separately
[<a href="cycle-detection.html" data-pltdoc="x">Detecting Cycles</a>].</p><p>We can define a helper function, <code data-lang="pyret" class="sourceCode">take</code>, a variation of
which we saw for streams [<a href="func-as-data.html#%28part._streams-from-funs%29" data-pltdoc="x">Streams From Functions</a>], to inspect a
finite prefix of an infinite list:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ctake(n :: Number, il :: Pair) -&gt; List:
  if n == 0:
    empty
  else:
    link(il.hd, ctake(n - 1, il!tl))
  end
end</code></pre><p>such that:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ctake(4, web-colors) is
  [list: "white", "grey", "white", "grey"]
end</code></pre></section><section class="SsectionLevel3" id="section 20.2"><h3 class="heading">20.2Â <a name="(part._rec-for-recursive)"/>Recursive Functions<a href="#(part._rec-for-recursive)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Based on this, we can now understand recursive functions. Consider a
very simple example, such as this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum(n):
  if n &gt; 0:
    n + sum(n - 1)
  else:
    0
  end
end</code></pre><p>We might like to think this is equivalent to:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum =
  lam(n):
    if n &gt; 0:
      n + sum(n - 1)
    else:
      0
    end
  end</code></pre><p>but if you enter this, Pyret will complain that <code data-lang="pyret" class="sourceCode">sum</code> is not
bound. We must instead write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec sum =
  lam(n):
    if n &gt; 0:
      n + sum(n - 1)
    else:
      0
    end
  end</code></pre><p>What do you think <code data-lang="pyret" class="sourceCode">rec</code> does? It binds <code data-lang="pyret" class="sourceCode">sum</code> to a box
initially containing a dummy value; it then defines the function in
an environment where the name is bound, unboxing the use of the name;
and finally, it replaces the boxâ€™s content with the defined function,
following the same pattern we saw earlier for <code data-lang="pyret" class="sourceCode">web-colors</code>.</p></section><section class="SsectionLevel3" id="section 20.3"><h3 class="heading">20.3Â <a name="(part._premature-eval)"/>Premature Evaluation<a href="#(part._premature-eval)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Observe that the above description reveals that there is a time
between the creation of the name and the assignment of a value to
it. Can this intermediate state be observed? It sure can!</p><p>There are generally three solutions to this problem:
</p><ol><li><p>Make sure the value is sufficiently obscure so that it can never
be used in a meaningful context. This means values like 0 are
especially bad, and indeed most common datatypes should be
shunned. Indeed, there is no value already in use that can be used
here that might not be confusing in some context.</p></li><li><p>The language might create a new type of value just for use
here. For instance, imagine this definition of <code data-lang="pyret" class="sourceCode">CList</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data CList:
  | undef
  | clink(v, ref r)
end</code></pre><code data-lang="pyret" class="sourceCode">undef</code> appears to be a â€œbase caseâ€, thus
making <code data-lang="pyret" class="sourceCode">CList</code> very similar to <code data-lang="pyret" class="sourceCode">List</code>. In truth, however,
the <code data-lang="pyret" class="sourceCode">undef</code> is present only until the first mutation happens,
after which it will never again be present: the intent is that
<code data-lang="pyret" class="sourceCode">r</code> only contain a reference to other <code data-lang="pyret" class="sourceCode">clink</code>s.<p>The <code data-lang="pyret" class="sourceCode">undef</code> value can now be used by the language to check for
premature uses of a cyclic list. However, while this is
technically feasible, it imposes a run-time penalty. Therefore, this
check is usually only performed by languages focused on teaching;
professional programmers are assumed to be able to manage the
consequences of such premature use by themselves.</p></li><li><p>Allow the recursion constructor to be used only in the case of
binding functions, and then make sure that the right-hand side of the
binding is syntactically a function. This solution precludes some
reasonable programs, but is certainly safe.</p></li></ol></section><section class="SsectionLevel3" id="section 20.4"><h3 class="heading">20.4Â <a name="(part._.Cyclic_.Lists_.Versus_.Streams)"/>Cyclic Lists Versus Streams<a href="#(part._.Cyclic_.Lists_.Versus_.Streams)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>The color list example above is, as we have noted, very reminiscent of
stream examples. What is the relationship between the two ways of
defining infinite data?</p><p>Cyclic lists have on their side simplicity. The pattern of definition
used above can actually be encapsulated into a language construct,
so programmers do not
need to wrestle with mutable fields (as above) or thunks (as streams
demand). This simplicity, however, comes at a price: cyclic lists can
only represent strictly repeating data, i.e., you cannot define
<code data-lang="pyret" class="sourceCode">nats</code> or <code data-lang="pyret" class="sourceCode">fibs</code> as cyclic lists. In contrast, the function
abstraction in a stream makes it generative: each invocation
can create a truly novel datum (such as the next natural or Fibonacci
number). Therefore, it is straightforward to implement cyclic lists as
streams, but not vice versa.</p></section>&#13;
<h3 class="heading">20.1Â <a name="(part._.Partial_.Definitions)"/>Partial Definitions<a href="#(part._.Partial_.Definitions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>What we need to instead do is to partially define each list,
and then complete the definition using the other one. However,
that is impossible using the above definition, because we cannot
change anything once it is constructed. Instead, therefore, we need:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Pair: p(hd, ref tl) end</code></pre><p>Note that this datatype lacks a base case, which should remind you of
definitions we saw in <a href="func-as-data.html#%28part._streams-from-funs%29" data-pltdoc="x">Streams From Functions</a>.</p><p>Using this, we can define:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">white-pair = p("white", "dummy")
grey-pair = p("grey", "dummy")</code></pre><p>Each of these definitions is quite useless by itself, but they each
represent what we want, and they have a mutable field for the
rest, currently holding a dummy value. Therefore, itâ€™s clear what we
must do next: update the mutable field.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">white-pair!{tl: grey-pair}
grey-pair!{tl: white-pair}</code></pre><p>Because we have ordained that our colors must alternate beginning with
white, this rounds up our definition:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web-colors = white-pair</code></pre><p>If we ask Pyret to inspect the value of <code data-lang="pyret" class="sourceCode">web-colors</code>, we notice
that it employs an algorithm to prevent traversing infinite
objects. You can learn more about how that works separately
[<a href="cycle-detection.html" data-pltdoc="x">Detecting Cycles</a>].</p><p>We can define a helper function, <code data-lang="pyret" class="sourceCode">take</code>, a variation of
which we saw for streams [<a href="func-as-data.html#%28part._streams-from-funs%29" data-pltdoc="x">Streams From Functions</a>], to inspect a
finite prefix of an infinite list:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ctake(n :: Number, il :: Pair) -&gt; List:
  if n == 0:
    empty
  else:
    link(il.hd, ctake(n - 1, il!tl))
  end
end</code></pre><p>such that:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ctake(4, web-colors) is
  [list: "white", "grey", "white", "grey"]
end</code></pre>&#13;
<h3 class="heading">20.2Â <a name="(part._rec-for-recursive)"/>Recursive Functions<a href="#(part._rec-for-recursive)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Based on this, we can now understand recursive functions. Consider a
very simple example, such as this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum(n):
  if n &gt; 0:
    n + sum(n - 1)
  else:
    0
  end
end</code></pre><p>We might like to think this is equivalent to:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum =
  lam(n):
    if n &gt; 0:
      n + sum(n - 1)
    else:
      0
    end
  end</code></pre><p>but if you enter this, Pyret will complain that <code data-lang="pyret" class="sourceCode">sum</code> is not
bound. We must instead write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec sum =
  lam(n):
    if n &gt; 0:
      n + sum(n - 1)
    else:
      0
    end
  end</code></pre><p>What do you think <code data-lang="pyret" class="sourceCode">rec</code> does? It binds <code data-lang="pyret" class="sourceCode">sum</code> to a box
initially containing a dummy value; it then defines the function in
an environment where the name is bound, unboxing the use of the name;
and finally, it replaces the boxâ€™s content with the defined function,
following the same pattern we saw earlier for <code data-lang="pyret" class="sourceCode">web-colors</code>.</p>&#13;
<h3 class="heading">20.3Â <a name="(part._premature-eval)"/>Premature Evaluation<a href="#(part._premature-eval)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Observe that the above description reveals that there is a time
between the creation of the name and the assignment of a value to
it. Can this intermediate state be observed? It sure can!</p><p>There are generally three solutions to this problem:
</p><ol><li><p>Make sure the value is sufficiently obscure so that it can never
be used in a meaningful context. This means values like 0 are
especially bad, and indeed most common datatypes should be
shunned. Indeed, there is no value already in use that can be used
here that might not be confusing in some context.</p></li><li><p>The language might create a new type of value just for use
here. For instance, imagine this definition of <code data-lang="pyret" class="sourceCode">CList</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data CList:
  | undef
  | clink(v, ref r)
end</code></pre><code data-lang="pyret" class="sourceCode">undef</code> appears to be a â€œbase caseâ€, thus
making <code data-lang="pyret" class="sourceCode">CList</code> very similar to <code data-lang="pyret" class="sourceCode">List</code>. In truth, however,
the <code data-lang="pyret" class="sourceCode">undef</code> is present only until the first mutation happens,
after which it will never again be present: the intent is that
<code data-lang="pyret" class="sourceCode">r</code> only contain a reference to other <code data-lang="pyret" class="sourceCode">clink</code>s.<p>The <code data-lang="pyret" class="sourceCode">undef</code> value can now be used by the language to check for
premature uses of a cyclic list. However, while this is
technically feasible, it imposes a run-time penalty. Therefore, this
check is usually only performed by languages focused on teaching;
professional programmers are assumed to be able to manage the
consequences of such premature use by themselves.</p></li><li><p>Allow the recursion constructor to be used only in the case of
binding functions, and then make sure that the right-hand side of the
binding is syntactically a function. This solution precludes some
reasonable programs, but is certainly safe.</p></li></ol>&#13;
<h3 class="heading">20.4Â <a name="(part._.Cyclic_.Lists_.Versus_.Streams)"/>Cyclic Lists Versus Streams<a href="#(part._.Cyclic_.Lists_.Versus_.Streams)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>The color list example above is, as we have noted, very reminiscent of
stream examples. What is the relationship between the two ways of
defining infinite data?</p><p>Cyclic lists have on their side simplicity. The pattern of definition
used above can actually be encapsulated into a language construct,
so programmers do not
need to wrestle with mutable fields (as above) or thunks (as streams
demand). This simplicity, however, comes at a price: cyclic lists can
only represent strictly repeating data, i.e., you cannot define
<code data-lang="pyret" class="sourceCode">nats</code> or <code data-lang="pyret" class="sourceCode">fibs</code> as cyclic lists. In contrast, the function
abstraction in a stream makes it generative: each invocation
can create a truly novel datum (such as the next natural or Fibonacci
number). Therefore, it is straightforward to implement cyclic lists as
streams, but not vice versa.</p>    
</body>
</html>