<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>20Â Recursion and Cycles from MutationğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>20Â Recursion and Cycles from MutationğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/rec-from-mut.html">https://dcic-world.org/2025-08-27/rec-from-mut.html</a></blockquote><p/><div class="SIntrapara">Earlier [<a href="Sharing_and_Equality.html#%28part._acyc-to-cyc%29" data-pltdoc="x">From Acyclicity to Cycles</a>], we saw the difficulty of
constructing cyclic data, and saw how we could address this problem
using state [<a href="unified-cyclic-data.html" data-pltdoc="x">Cyclic Data</a>]. Let us now return to the
earlier example of creating a cyclic list of alternating colors. We
had tried to write:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web-colors = link("white", link("grey", web-colors))</code></pre></div></div></div><div class="SIntrapara">which, as we noted, does not pass muster because <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web-colors</code></span> is
not bound on the right of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=</code></span>. (Why not? Because otherwise,
if we try to substitute <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web-colors</code></span> on the right, we would end
up in an infinite regress.)</div><p/><div class="SIntrapara">Something about this should make you a little suspicious: we have been
able to write recursive <span class="emph">functions</span> all the time, without
difficulty. Why are they different? For two reasons:
</div><div class="SIntrapara"><ul><li><p>The first reason is the fact that weâ€™re defining a
<span class="emph">function</span>. A functionâ€™s body is not evaluated right awayâ€”<wbr/>only
when we apply itâ€”<wbr/>so the language can wait for the body to finish
being defined. (Weâ€™ll see what this might mean in a moment.)</p></li><li><p>The second reason isnâ€™t actually a reason: function definitions
actually are special. But we are about to expose whatâ€™s so special
about themâ€”<wbr/>itâ€™s the use of a box! [<a href="state-in-pyret.html#%28part._boxes%29" data-pltdoc="x">Boxes: A Canonical Mutable Structure</a>]â€”<wbr/>so that any
definition can avail of it.</p></li></ul></div><p/><div class="SIntrapara">Returning to our example above, recall that we canâ€™t make up our list
using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>s, because we want the list to never
terminate. Therefore, let us first define a new datatype to hold an
cyclic list:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Pair: p(hd, tl) end</code></pre></div></div></div><div class="SIntrapara">You should think of this as analogous to a list, where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hd</code></span> is
the first element and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tl</code></span> is the rest.</div><p>Observe that we have carefully avoided writing type definitions for
the fields; we will instead try to figure them out as we go
along. Also, however, this definition as written cannot work.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Do you see why not?</p></blockquote></blockquote><p>Letâ€™s decompose the intended infinite list into two pieces: lists that
begin with white and ones that begin with grey. What follows white? A
grey list. What follows grey? A white list. It is clear we canâ€™t write
down these two definitions because one of them must precede the other,
but each one depends on the other. (This is the same problem as trying
to write a single definition above.)</p><section class="SsectionLevel3" id="section 20.1"><h3 class="heading">20.1<span class="stt">Â </span><a name="(part._.Partial_.Definitions)"/>Partial Definitions<span class="button-group"><a href="#(part._.Partial_.Definitions)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">What we need to instead do is to <span class="emph">partially</span> define each list,
and then <span class="emph">complete</span> the definition using the other one. However,
that is impossible using the above definition, because we cannot
change anything once it is constructed. Instead, therefore, we need:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Pair: p(hd, ref tl) end</code></pre></div></div></div><div class="SIntrapara">Note that this datatype lacks a base case, which should remind you of
definitions we saw in <a href="func-as-data.html#%28part._streams-from-funs%29" data-pltdoc="x">Streams From Functions</a>.</div><p/><div class="SIntrapara">Using this, we can define:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">white-pair = p("white", "dummy")
grey-pair = p("grey", "dummy")</code></pre></div></div></div><div class="SIntrapara">Each of these definitions is quite useless by itself, but they each
represent what we want, and <span class="emph">they have a mutable field for the
rest, currently holding a dummy value</span>. Therefore, itâ€™s clear what we
must do next: update the mutable field.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">white-pair!{tl: grey-pair}
grey-pair!{tl: white-pair}</code></pre></div></div></div><div class="SIntrapara">Because we have ordained that our colors must alternate beginning with
white, this rounds up our definition:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web-colors = white-pair</code></pre></div></div></div><div class="SIntrapara">If we ask Pyret to inspect the value of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web-colors</code></span>, we notice
that it employs an algorithm to prevent traversing infinite
objects. You can learn more about how that works separately
[<a href="cycle-detection.html" data-pltdoc="x">Detecting Cycles</a>].</div><p/><div class="SIntrapara">We can define a helper function, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">take</code></span>, a variation of
which we saw for streams [<a href="func-as-data.html#%28part._streams-from-funs%29" data-pltdoc="x">Streams From Functions</a>], to inspect a
finite prefix of an infinite list:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ctake(n :: Number, il :: Pair) -&gt; List:
  if n == 0:
    empty
  else:
    link(il.hd, ctake(n - 1, il!tl))
  end
end</code></pre></div></div></div><div class="SIntrapara">such that:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ctake(4, web-colors) is
  [list: "white", "grey", "white", "grey"]
end</code></pre></div></div></div></section><section class="SsectionLevel3" id="section 20.2"><h3 class="heading">20.2<span class="stt">Â </span><a name="(part._rec-for-recursive)"/>Recursive Functions<span class="button-group"><a href="#(part._rec-for-recursive)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">Based on this, we can now understand recursive functions. Consider a
very simple example, such as this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum(n):
  if n &gt; 0:
    n + sum(n - 1)
  else:
    0
  end
end</code></pre></div></div></div><div class="SIntrapara">We might like to think this is equivalent to:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum =
  lam(n):
    if n &gt; 0:
      n + sum(n - 1)
    else:
      0
    end
  end</code></pre></div></div></div><div class="SIntrapara">but if you enter this, Pyret will complain that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum</code></span> is not
bound. We must instead write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec sum =
  lam(n):
    if n &gt; 0:
      n + sum(n - 1)
    else:
      0
    end
  end</code></pre></div></div></div><div class="SIntrapara">What do you think <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec</code></span> does? It binds <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum</code></span> to a box
initially containing a dummy value; it then defines the function in
an environment where the name is bound, unboxing the use of the name;
and finally, it replaces the boxâ€™s content with the defined function,
following the same pattern we saw earlier for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web-colors</code></span>.</div></section><section class="SsectionLevel3" id="section 20.3"><h3 class="heading">20.3<span class="stt">Â </span><a name="(part._premature-eval)"/>Premature Evaluation<span class="button-group"><a href="#(part._premature-eval)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Observe that the above description reveals that there is a time
between the creation of the name and the assignment of a value to
it. Can this intermediate state be observed? It sure can!</p><p/><div class="SIntrapara">There are generally three solutions to this problem:
</div><div class="SIntrapara"><ol><li><p>Make sure the value is sufficiently obscure so that it can never
be used in a meaningful context. This means values like <span class="stt">0</span> are
especially bad, and indeed most common datatypes should be
shunned. Indeed, there is no value already in use that can be used
here that might not be confusing in <span class="emph">some</span> context.</p></li><li><p/><div class="SIntrapara">The language might create a new type of value just for use
here. For instance, imagine this definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">CList</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data CList:
  | undef
  | clink(v, ref r)
end</code></pre></div></div></div><div class="SIntrapara"><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">undef</code></span> <span class="emph">appears</span> to be a â€œbase caseâ€, thus
making <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">CList</code></span> very similar to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">List</code></span>. In truth, however,
the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">undef</code></span> is present only until the first mutation happens,
after which it will never again be present: the intent is that
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> only contain a reference to other <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">clink</code></span>s.</div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">undef</code></span> value can now be used by the language to check for
premature uses of a cyclic list. However, while this is
technically feasible, it imposes a run-time penalty. Therefore, this
check is usually only performed by languages focused on teaching;
professional programmers are assumed to be able to manage the
consequences of such premature use by themselves.</p></li><li><p>Allow the recursion constructor to be used only in the case of
binding functions, and then make sure that the right-hand side of the
binding is syntactically a function. This solution precludes some
reasonable programs, but is certainly safe.</p></li></ol></div></section><section class="SsectionLevel3" id="section 20.4"><h3 class="heading">20.4<span class="stt">Â </span><a name="(part._.Cyclic_.Lists_.Versus_.Streams)"/>Cyclic Lists Versus Streams<span class="button-group"><a href="#(part._.Cyclic_.Lists_.Versus_.Streams)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>The color list example above is, as we have noted, very reminiscent of
stream examples. What is the relationship between the two ways of
defining infinite data?</p><p>Cyclic lists have on their side simplicity. The pattern of definition
used above can actually be encapsulated into a language construct,
so programmers do not
need to wrestle with mutable fields (as above) or thunks (as streams
demand). This simplicity, however, comes at a price: cyclic lists can
only represent strictly repeating data, i.e., you cannot define
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fibs</code></span> as cyclic lists. In contrast, the function
abstraction in a stream makes it <span class="emph">generative</span>: each invocation
can create a truly novel datum (such as the next natural or Fibonacci
number). Therefore, it is straightforward to implement cyclic lists as
streams, but not vice versa.</p></section>&#13;
<h3 class="heading">20.1<span class="stt">Â </span><a name="(part._.Partial_.Definitions)"/>Partial Definitions<span class="button-group"><a href="#(part._.Partial_.Definitions)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">What we need to instead do is to <span class="emph">partially</span> define each list,
and then <span class="emph">complete</span> the definition using the other one. However,
that is impossible using the above definition, because we cannot
change anything once it is constructed. Instead, therefore, we need:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Pair: p(hd, ref tl) end</code></pre></div></div></div><div class="SIntrapara">Note that this datatype lacks a base case, which should remind you of
definitions we saw in <a href="func-as-data.html#%28part._streams-from-funs%29" data-pltdoc="x">Streams From Functions</a>.</div><p/><div class="SIntrapara">Using this, we can define:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">white-pair = p("white", "dummy")
grey-pair = p("grey", "dummy")</code></pre></div></div></div><div class="SIntrapara">Each of these definitions is quite useless by itself, but they each
represent what we want, and <span class="emph">they have a mutable field for the
rest, currently holding a dummy value</span>. Therefore, itâ€™s clear what we
must do next: update the mutable field.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">white-pair!{tl: grey-pair}
grey-pair!{tl: white-pair}</code></pre></div></div></div><div class="SIntrapara">Because we have ordained that our colors must alternate beginning with
white, this rounds up our definition:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web-colors = white-pair</code></pre></div></div></div><div class="SIntrapara">If we ask Pyret to inspect the value of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web-colors</code></span>, we notice
that it employs an algorithm to prevent traversing infinite
objects. You can learn more about how that works separately
[<a href="cycle-detection.html" data-pltdoc="x">Detecting Cycles</a>].</div><p/><div class="SIntrapara">We can define a helper function, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">take</code></span>, a variation of
which we saw for streams [<a href="func-as-data.html#%28part._streams-from-funs%29" data-pltdoc="x">Streams From Functions</a>], to inspect a
finite prefix of an infinite list:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ctake(n :: Number, il :: Pair) -&gt; List:
  if n == 0:
    empty
  else:
    link(il.hd, ctake(n - 1, il!tl))
  end
end</code></pre></div></div></div><div class="SIntrapara">such that:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  ctake(4, web-colors) is
  [list: "white", "grey", "white", "grey"]
end</code></pre></div></div></div>&#13;
<h3 class="heading">20.2<span class="stt">Â </span><a name="(part._rec-for-recursive)"/>Recursive Functions<span class="button-group"><a href="#(part._rec-for-recursive)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">Based on this, we can now understand recursive functions. Consider a
very simple example, such as this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum(n):
  if n &gt; 0:
    n + sum(n - 1)
  else:
    0
  end
end</code></pre></div></div></div><div class="SIntrapara">We might like to think this is equivalent to:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum =
  lam(n):
    if n &gt; 0:
      n + sum(n - 1)
    else:
      0
    end
  end</code></pre></div></div></div><div class="SIntrapara">but if you enter this, Pyret will complain that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum</code></span> is not
bound. We must instead write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec sum =
  lam(n):
    if n &gt; 0:
      n + sum(n - 1)
    else:
      0
    end
  end</code></pre></div></div></div><div class="SIntrapara">What do you think <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec</code></span> does? It binds <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum</code></span> to a box
initially containing a dummy value; it then defines the function in
an environment where the name is bound, unboxing the use of the name;
and finally, it replaces the boxâ€™s content with the defined function,
following the same pattern we saw earlier for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web-colors</code></span>.</div>&#13;
<h3 class="heading">20.3<span class="stt">Â </span><a name="(part._premature-eval)"/>Premature Evaluation<span class="button-group"><a href="#(part._premature-eval)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Observe that the above description reveals that there is a time
between the creation of the name and the assignment of a value to
it. Can this intermediate state be observed? It sure can!</p><p/><div class="SIntrapara">There are generally three solutions to this problem:
</div><div class="SIntrapara"><ol><li><p>Make sure the value is sufficiently obscure so that it can never
be used in a meaningful context. This means values like <span class="stt">0</span> are
especially bad, and indeed most common datatypes should be
shunned. Indeed, there is no value already in use that can be used
here that might not be confusing in <span class="emph">some</span> context.</p></li><li><p/><div class="SIntrapara">The language might create a new type of value just for use
here. For instance, imagine this definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">CList</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data CList:
  | undef
  | clink(v, ref r)
end</code></pre></div></div></div><div class="SIntrapara"><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">undef</code></span> <span class="emph">appears</span> to be a â€œbase caseâ€, thus
making <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">CList</code></span> very similar to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">List</code></span>. In truth, however,
the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">undef</code></span> is present only until the first mutation happens,
after which it will never again be present: the intent is that
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> only contain a reference to other <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">clink</code></span>s.</div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">undef</code></span> value can now be used by the language to check for
premature uses of a cyclic list. However, while this is
technically feasible, it imposes a run-time penalty. Therefore, this
check is usually only performed by languages focused on teaching;
professional programmers are assumed to be able to manage the
consequences of such premature use by themselves.</p></li><li><p>Allow the recursion constructor to be used only in the case of
binding functions, and then make sure that the right-hand side of the
binding is syntactically a function. This solution precludes some
reasonable programs, but is certainly safe.</p></li></ol></div>&#13;
<h3 class="heading">20.4<span class="stt">Â </span><a name="(part._.Cyclic_.Lists_.Versus_.Streams)"/>Cyclic Lists Versus Streams<span class="button-group"><a href="#(part._.Cyclic_.Lists_.Versus_.Streams)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>The color list example above is, as we have noted, very reminiscent of
stream examples. What is the relationship between the two ways of
defining infinite data?</p><p>Cyclic lists have on their side simplicity. The pattern of definition
used above can actually be encapsulated into a language construct,
so programmers do not
need to wrestle with mutable fields (as above) or thunks (as streams
demand). This simplicity, however, comes at a price: cyclic lists can
only represent strictly repeating data, i.e., you cannot define
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nats</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fibs</code></span> as cyclic lists. In contrast, the function
abstraction in a stream makes it <span class="emph">generative</span>: each invocation
can create a truly novel datum (such as the next natural or Fibonacci
number). Therefore, it is straightforward to implement cyclic lists as
streams, but not vice versa.</p>    
</body>
</html>