["```cpp\nconst int B = 16;   int nblocks = (n + B - 1) / B; int btree[nblocks][B];   int go(int k, int i) { return k * (B + 1) + i + 1; } \n```", "```cpp\nvoid build(int k = 0) {  static int t = 0; if (k < nblocks) { for (int i = 0; i < B; i++) { build(go(k, i)); btree[k][i] = (t < n ? a[t++] : INT_MAX); } build(go(k, B)); } } \n```", "```cpp\nint mask = (1 << B);   for (int i = 0; i < B; i++)  mask |= (btree[k][i] >= x) << i;   int i = __builtin_ffs(mask) - 1; // now i is the number of the correct child node \n```", "```cpp\n       y = 4        17       65       103     \n       x = 42       42       42       42      \n   y ≥ x = 00000000 00000000 11111111 11111111\n           ├┬┬┬─────┴────────┴────────┘       \nmovemask = 0011                               \n           ┌─┘                                \n     ffs = 3                                  \n\n```", "```cpp\ntypedef __m256i reg;   int cmp(reg x_vec, int* y_ptr) {  reg y_vec = _mm256_load_si256((reg*) y_ptr); // load 8 sorted elements reg mask = _mm256_cmpgt_epi32(x_vec, y_vec); // compare against the key return _mm256_movemask_ps((__m256) mask);    // extract the 8-bit mask } \n```", "```cpp\nint mask = ~(  cmp(x, &btree[k][0]) + (cmp(x, &btree[k][8]) << 8) ); \n```", "```cpp\nint i = __builtin_ffs(mask) - 1; k = go(k, i); \n```", "```cpp\nint lower_bound(int _x) {  int k = 0, res = INT_MAX; reg x = _mm256_set1_epi32(_x); while (k < nblocks) { int mask = ~( cmp(x, &btree[k][0]) + (cmp(x, &btree[k][8]) << 8) ); int i = __builtin_ffs(mask) - 1; if (i < B) res = btree[k][i]; k = go(k, i); } return res; } \n```", "```cpp\nconst int P = 1 << 21;                        // page size in bytes (2MB) const int T = (64 * nblocks + P - 1) / P * P; // can only allocate whole number of pages btree = (int(*)[16]) std::aligned_alloc(P, T); madvise(btree, T, MADV_HUGEPAGE); \n```", "```cpp\nconstexpr int height(int n) {  // grow the tree until its size exceeds n elements int s = 0, // total size so far l = B, // size of the next layer h = 0; // height so far while (s + l - B < n) { s += l; l *= (B + 1); h++; } return h; }   const int H = height(N); \n```", "```cpp\nunsigned rank(reg x, int* y) {  reg a = _mm256_load_si256((reg*) y); reg b = _mm256_load_si256((reg*) (y + 8));   reg ca = _mm256_cmpgt_epi32(a, x); reg cb = _mm256_cmpgt_epi32(b, x);   reg c = _mm256_packs_epi32(ca, cb); int mask = _mm256_movemask_epi8(c);   // we need to divide the result by two because we call movemask_epi8 on 16-bit masks: return __tzcnt_u32(mask) >> 1; } \n```", "```cpp\nvoid permute(int *node) {  const reg perm = _mm256_setr_epi32(4, 5, 6, 7, 0, 1, 2, 3); reg* middle = (reg*) (node + 4); reg x = _mm256_loadu_si256(middle); x = _mm256_permutevar8x32_epi32(x, perm); _mm256_storeu_si256(middle, x); } \n```", "```cpp\nconst int translate[17] = {  0, 1, 2, 3, 8, 9, 10, 11, 4, 5, 6, 7, 12, 13, 14, 15, 0 };   void update(int &res, int* node, unsigned i) {  int val = node[translate[i]]; res = (i < B ? val : res); } \n```", "```cpp\nint lower_bound(int _x) {  int k = 0, res = INT_MAX; reg x = _mm256_set1_epi32(_x - 1); for (int h = 0; h < H - 1; h++) { unsigned i = rank(x, &btree[k]); update(res, &btree[k], i); k = go(k, i); } // the last branch: if (k < nblocks) { unsigned i = rank(x, btree[k]); update(res, &btree[k], i); } return res; } \n```", "```cpp\n// number of B-element blocks in a layer with n keys constexpr int blocks(int n) {  return (n + B - 1) / B; }   // number of keys on the layer previous to one with n keys constexpr int prev_keys(int n) {  return (blocks(n) + B) / (B + 1) * B; }   // height of a balanced n-key B+ tree constexpr int height(int n) {  return (n <= B ? 1 : height(prev_keys(n)) + 1); }   // where the layer h starts (layer 0 is the largest) constexpr int offset(int h) {  int k = 0, n = N; while (h--) { k += blocks(n) * B; n = prev_keys(n); } return k; }   const int H = height(N); const int S = offset(H); // the tree size is the offset of the (non-existent) layer H  int *btree; // the tree itself is stored in a single hugepage-aligned array of size S \n```", "```cpp\nmemcpy(btree, a, 4 * N);   for (int i = N; i < S; i++)  btree[i] = INT_MAX; \n```", "```cpp\nfor (int h = 1; h < H; h++) {  for (int i = 0; i < offset(h + 1) - offset(h); i++) { // i = k * B + j int k = i / B, j = i - k * B; k = k * (B + 1) + j + 1; // compare to the right of the key // and then always to the left for (int l = 0; l < h - 1; l++) k *= (B + 1); // pad the rest with infinities if the key doesn't exist btree[offset(h) + i] = (k * B < N ? btree[k * B] : INT_MAX); } } \n```", "```cpp\nfor (int i = offset(1); i < S; i += B)  permute(btree + i); \n```", "```cpp\nint lower_bound(int _x) {  unsigned k = 0; // we assume k already multiplied by B to optimize pointer arithmetic reg x = _mm256_set1_epi32(_x - 1); for (int h = H - 1; h > 0; h--) { unsigned i = permuted_rank(x, btree + offset(h) + k); k = k * (B + 1) + i * B; } unsigned i = direct_rank(x, btree + k); return btree[k + i]; } \n```", "```cpp\nclock_t start = clock();   for (int i = 0; i < m; i++)  checksum ^= lower_bound(q[i]);   float seconds = float(clock() - start) / CLOCKS_PER_SEC; printf(\"%.2f ns per query\\n\", 1e9 * seconds / m); \n```", "```cpp\nint last = 0;   for (int i = 0; i < m; i++) {  last = lower_bound(q[i] ^ last); checksum ^= last; } \n```"]