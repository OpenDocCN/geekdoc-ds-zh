["```py\ndef transition_from_adjacency(A):\n\n    n = A.shape[0]\n    sinks = (A @ np.ones(n)) == 0.\n    P = A.copy()\n    np.fill_diagonal(P, sinks)\n    out_deg = P @ np.ones(n)\n    P = P / out_deg[:, np.newaxis]\n\n    return P \n```", "```py\ndef add_damping(P, alpha, mu):\n    Q = alpha * P + (1-alpha) * mu\n    return Q \n```", "```py\ndef pagerank(A, alpha=0.85, max_iter=100):\n\n    n = A.shape[0]\n    mu = np.ones(n)/n\n    P = transition_from_adjacency(A)\n    Q = add_damping(P, alpha, mu)\n    v = mu\n    for _ in range(max_iter):\n        v = v @ Q\n\n    return v \n```", "```py\nn = 8\nG_outstar = nx.DiGraph()\nfor i in range(1,n):\n    G_outstar.add_edge(0,i)\n\nnx.draw_networkx(G_outstar, labels={i: i+1 for i in range(n)}, \n                 node_color='black', font_color='white')\nplt.axis('off')\nplt.show() \n```", "```py\nA_outstar = nx.adjacency_matrix(G_outstar).toarray()\nprint(A_outstar) \n```", "```py\n[[0 1 1 1 1 1 1 1]\n [0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0]] \n```", "```py\nP_outstar = transition_from_adjacency(A_outstar)\nnp.set_printoptions(formatter={'float': '{: 0.3f}'.format})\nprint(P_outstar) \n```", "```py\n[[ 0.000  0.143  0.143  0.143  0.143  0.143  0.143  0.143]\n [ 0.000  1.000  0.000  0.000  0.000  0.000  0.000  0.000]\n [ 0.000  0.000  1.000  0.000  0.000  0.000  0.000  0.000]\n [ 0.000  0.000  0.000  1.000  0.000  0.000  0.000  0.000]\n [ 0.000  0.000  0.000  0.000  1.000  0.000  0.000  0.000]\n [ 0.000  0.000  0.000  0.000  0.000  1.000  0.000  0.000]\n [ 0.000  0.000  0.000  0.000  0.000  0.000  1.000  0.000]\n [ 0.000  0.000  0.000  0.000  0.000  0.000  0.000  1.000]] \n```", "```py\nalpha = 0.85\nmu = np.ones(n)/n\nQ_outstar = add_damping(P_outstar, alpha, mu)\nprint(Q_outstar) \n```", "```py\n[[ 0.019  0.140  0.140  0.140  0.140  0.140  0.140  0.140]\n [ 0.019  0.869  0.019  0.019  0.019  0.019  0.019  0.019]\n [ 0.019  0.019  0.869  0.019  0.019  0.019  0.019  0.019]\n [ 0.019  0.019  0.019  0.869  0.019  0.019  0.019  0.019]\n [ 0.019  0.019  0.019  0.019  0.869  0.019  0.019  0.019]\n [ 0.019  0.019  0.019  0.019  0.019  0.869  0.019  0.019]\n [ 0.019  0.019  0.019  0.019  0.019  0.019  0.869  0.019]\n [ 0.019  0.019  0.019  0.019  0.019  0.019  0.019  0.869]] \n```", "```py\nprint(pagerank(A_outstar)) \n```", "```py\n[ 0.019  0.140  0.140  0.140  0.140  0.140  0.140  0.140] \n```", "```py\nn = 8\nG_instar = nx.DiGraph()\nG_instar.add_node(0)\nfor i in range(1,n):\n    G_instar.add_edge(i,0)\n\nnx.draw_networkx(G_instar, labels={i: i+1 for i in range(n)}, \n                 node_color='black', font_color='white')\nplt.axis('off')\nplt.show() \n```", "```py\nA_instar = nx.adjacency_matrix(G_instar).toarray()\nprint(A_instar) \n```", "```py\n[[0 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]] \n```", "```py\nP_instar = transition_from_adjacency(A_instar)\nprint(P_instar) \n```", "```py\n[[ 1.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000]\n [ 1.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000]\n [ 1.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000]\n [ 1.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000]\n [ 1.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000]\n [ 1.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000]\n [ 1.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000]\n [ 1.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000]] \n```", "```py\nQ_instar = add_damping(P_instar, alpha, mu)\nprint(Q_instar) \n```", "```py\n[[ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019]\n [ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019]\n [ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019]\n [ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019]\n [ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019]\n [ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019]\n [ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019]\n [ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019]] \n```", "```py\nprint(pagerank(A_instar)) \n```", "```py\n[ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019] \n```", "```py\nn = 8\nG_star = nx.Graph()\nfor i in range(1,n):\n    G_star.add_edge(0,i)\n\nnx.draw_networkx(G_star, labels={i: i+1 for i in range(n)}, \n                 node_color='black', font_color='white')\nplt.axis('off')\nplt.show() \n```", "```py\nA_star = nx.adjacency_matrix(G_star).toarray()\nprint(A_star) \n```", "```py\n[[0 1 1 1 1 1 1 1]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]] \n```", "```py\nprint(pagerank(A_star, max_iter=10000, alpha=0.999)) \n```", "```py\n[ 0.500  0.071  0.071  0.071  0.071  0.071  0.071  0.071] \n```", "```py\nprint(pagerank(A_star)) \n```", "```py\n[ 0.470  0.076  0.076  0.076  0.076  0.076  0.076  0.076] \n```", "```py\ndata_edges = pd.read_csv('mathworld-adjacency.csv')\ndata_edges.head() \n```", "```py\ndata_titles = pd.read_csv('mathworld-titles.csv')\ndata_titles.head() \n```", "```py\nedgelist = data_edges[['from','to']].to_numpy()\nprint(edgelist) \n```", "```py\n[[    0     2]\n [    1    47]\n [    1   404]\n ...\n [12361 12306]\n [12361 12310]\n [12361 12360]] \n```", "```py\nn = 12362\nG_mw = nx.empty_graph(n, create_using=nx.DiGraph)\nfor i in range(edgelist.shape[0]):\n    G_mw.add_edge(edgelist[i,0], edgelist[i,1]) \n```", "```py\nA_mw = nx.adjacency_matrix(G_mw).toarray()\ntitles_mw = data_titles['title'].to_numpy()\npr_mw = pagerank(A_mw) \n```", "```py\ntop_pages = np.argsort(-pr_mw) \n```", "```py\nprint(titles_mw[top_pages[:25]]) \n```", "```py\n['Sphere' 'Circle' 'Prime Number' 'Aleksandrov-Čech Cohomology'\n 'Centroid Hexagon' 'Group' 'Fourier Transform' 'Tree' 'Splitting Field'\n 'Archimedean Solid' 'Normal Distribution' 'Integer Sequence Primes'\n 'Perimeter Polynomial' 'Polygon' 'Finite Group' 'Large Number'\n 'Riemann Zeta Function' 'Chebyshev Approximation Formula' 'Vector' 'Ring'\n 'Fibonacci Number' 'Conic Section' 'Fourier Series' 'Derivative'\n 'Gamma Function'] \n```", "```py\ndef ppr(A, mu, alpha=0.85, max_iter=100):\n    n = A.shape[0]\n    P = transition_from_adjacency(A)\n    Q = add_damping(P, alpha, mu)\n    v = mu\n    for _ in range(max_iter):\n        v = v @ Q\n    return v \n```", "```py\nprint(np.argwhere(titles_mw == 'Normal Distribution')[0][0]) \n```", "```py\n1270 \n```", "```py\nmu = np.zeros(n)\nmu[1270] = 1 \n```", "```py\nppr_mw = ppr(A_mw, mu)\ntop_pers_pages = np.argsort(-ppr_mw) \n```", "```py\nprint(titles_mw[top_pers_pages[:25]]) \n```", "```py\n['Normal Distribution' 'Pearson System' 'Logit Transformation' 'z-Score'\n 'Erf' 'Central Limit Theorem' 'Bivariate Normal Distribution'\n 'Normal Ratio Distribution' 'Normal Sum Distribution'\n 'Normal Distribution Function' 'Gaussian Function'\n 'Standard Normal Distribution' 'Normal Product Distribution'\n 'Binomial Distribution' 'Tetrachoric Function' 'Ratio Distribution'\n 'Kolmogorov-Smirnov Test' 'Box-Muller Transformation' 'Galton Board'\n 'Fisher-Behrens Problem' 'Erfc' 'Normal Difference Distribution'\n 'Half-Normal Distribution' 'Inverse Gaussian Distribution'\n 'Error Function Distribution'] \n```", "```py\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 0)]) \n```", "```py\ndef transition_from_adjacency(A):\n\n    n = A.shape[0]\n    sinks = (A @ np.ones(n)) == 0.\n    P = A.copy()\n    np.fill_diagonal(P, sinks)\n    out_deg = P @ np.ones(n)\n    P = P / out_deg[:, np.newaxis]\n\n    return P \n```", "```py\ndef add_damping(P, alpha, mu):\n    Q = alpha * P + (1-alpha) * mu\n    return Q \n```", "```py\ndef pagerank(A, alpha=0.85, max_iter=100):\n\n    n = A.shape[0]\n    mu = np.ones(n)/n\n    P = transition_from_adjacency(A)\n    Q = add_damping(P, alpha, mu)\n    v = mu\n    for _ in range(max_iter):\n        v = v @ Q\n\n    return v \n```", "```py\nn = 8\nG_outstar = nx.DiGraph()\nfor i in range(1,n):\n    G_outstar.add_edge(0,i)\n\nnx.draw_networkx(G_outstar, labels={i: i+1 for i in range(n)}, \n                 node_color='black', font_color='white')\nplt.axis('off')\nplt.show() \n```", "```py\nA_outstar = nx.adjacency_matrix(G_outstar).toarray()\nprint(A_outstar) \n```", "```py\n[[0 1 1 1 1 1 1 1]\n [0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0]] \n```", "```py\nP_outstar = transition_from_adjacency(A_outstar)\nnp.set_printoptions(formatter={'float': '{: 0.3f}'.format})\nprint(P_outstar) \n```", "```py\n[[ 0.000  0.143  0.143  0.143  0.143  0.143  0.143  0.143]\n [ 0.000  1.000  0.000  0.000  0.000  0.000  0.000  0.000]\n [ 0.000  0.000  1.000  0.000  0.000  0.000  0.000  0.000]\n [ 0.000  0.000  0.000  1.000  0.000  0.000  0.000  0.000]\n [ 0.000  0.000  0.000  0.000  1.000  0.000  0.000  0.000]\n [ 0.000  0.000  0.000  0.000  0.000  1.000  0.000  0.000]\n [ 0.000  0.000  0.000  0.000  0.000  0.000  1.000  0.000]\n [ 0.000  0.000  0.000  0.000  0.000  0.000  0.000  1.000]] \n```", "```py\nalpha = 0.85\nmu = np.ones(n)/n\nQ_outstar = add_damping(P_outstar, alpha, mu)\nprint(Q_outstar) \n```", "```py\n[[ 0.019  0.140  0.140  0.140  0.140  0.140  0.140  0.140]\n [ 0.019  0.869  0.019  0.019  0.019  0.019  0.019  0.019]\n [ 0.019  0.019  0.869  0.019  0.019  0.019  0.019  0.019]\n [ 0.019  0.019  0.019  0.869  0.019  0.019  0.019  0.019]\n [ 0.019  0.019  0.019  0.019  0.869  0.019  0.019  0.019]\n [ 0.019  0.019  0.019  0.019  0.019  0.869  0.019  0.019]\n [ 0.019  0.019  0.019  0.019  0.019  0.019  0.869  0.019]\n [ 0.019  0.019  0.019  0.019  0.019  0.019  0.019  0.869]] \n```", "```py\nprint(pagerank(A_outstar)) \n```", "```py\n[ 0.019  0.140  0.140  0.140  0.140  0.140  0.140  0.140] \n```", "```py\nn = 8\nG_instar = nx.DiGraph()\nG_instar.add_node(0)\nfor i in range(1,n):\n    G_instar.add_edge(i,0)\n\nnx.draw_networkx(G_instar, labels={i: i+1 for i in range(n)}, \n                 node_color='black', font_color='white')\nplt.axis('off')\nplt.show() \n```", "```py\nA_instar = nx.adjacency_matrix(G_instar).toarray()\nprint(A_instar) \n```", "```py\n[[0 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]] \n```", "```py\nP_instar = transition_from_adjacency(A_instar)\nprint(P_instar) \n```", "```py\n[[ 1.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000]\n [ 1.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000]\n [ 1.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000]\n [ 1.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000]\n [ 1.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000]\n [ 1.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000]\n [ 1.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000]\n [ 1.000  0.000  0.000  0.000  0.000  0.000  0.000  0.000]] \n```", "```py\nQ_instar = add_damping(P_instar, alpha, mu)\nprint(Q_instar) \n```", "```py\n[[ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019]\n [ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019]\n [ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019]\n [ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019]\n [ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019]\n [ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019]\n [ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019]\n [ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019]] \n```", "```py\nprint(pagerank(A_instar)) \n```", "```py\n[ 0.869  0.019  0.019  0.019  0.019  0.019  0.019  0.019] \n```", "```py\nn = 8\nG_star = nx.Graph()\nfor i in range(1,n):\n    G_star.add_edge(0,i)\n\nnx.draw_networkx(G_star, labels={i: i+1 for i in range(n)}, \n                 node_color='black', font_color='white')\nplt.axis('off')\nplt.show() \n```", "```py\nA_star = nx.adjacency_matrix(G_star).toarray()\nprint(A_star) \n```", "```py\n[[0 1 1 1 1 1 1 1]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]\n [1 0 0 0 0 0 0 0]] \n```", "```py\nprint(pagerank(A_star, max_iter=10000, alpha=0.999)) \n```", "```py\n[ 0.500  0.071  0.071  0.071  0.071  0.071  0.071  0.071] \n```", "```py\nprint(pagerank(A_star)) \n```", "```py\n[ 0.470  0.076  0.076  0.076  0.076  0.076  0.076  0.076] \n```", "```py\ndata_edges = pd.read_csv('mathworld-adjacency.csv')\ndata_edges.head() \n```", "```py\ndata_titles = pd.read_csv('mathworld-titles.csv')\ndata_titles.head() \n```", "```py\nedgelist = data_edges[['from','to']].to_numpy()\nprint(edgelist) \n```", "```py\n[[    0     2]\n [    1    47]\n [    1   404]\n ...\n [12361 12306]\n [12361 12310]\n [12361 12360]] \n```", "```py\nn = 12362\nG_mw = nx.empty_graph(n, create_using=nx.DiGraph)\nfor i in range(edgelist.shape[0]):\n    G_mw.add_edge(edgelist[i,0], edgelist[i,1]) \n```", "```py\nA_mw = nx.adjacency_matrix(G_mw).toarray()\ntitles_mw = data_titles['title'].to_numpy()\npr_mw = pagerank(A_mw) \n```", "```py\ntop_pages = np.argsort(-pr_mw) \n```", "```py\nprint(titles_mw[top_pages[:25]]) \n```", "```py\n['Sphere' 'Circle' 'Prime Number' 'Aleksandrov-Čech Cohomology'\n 'Centroid Hexagon' 'Group' 'Fourier Transform' 'Tree' 'Splitting Field'\n 'Archimedean Solid' 'Normal Distribution' 'Integer Sequence Primes'\n 'Perimeter Polynomial' 'Polygon' 'Finite Group' 'Large Number'\n 'Riemann Zeta Function' 'Chebyshev Approximation Formula' 'Vector' 'Ring'\n 'Fibonacci Number' 'Conic Section' 'Fourier Series' 'Derivative'\n 'Gamma Function'] \n```", "```py\ndef ppr(A, mu, alpha=0.85, max_iter=100):\n    n = A.shape[0]\n    P = transition_from_adjacency(A)\n    Q = add_damping(P, alpha, mu)\n    v = mu\n    for _ in range(max_iter):\n        v = v @ Q\n    return v \n```", "```py\nprint(np.argwhere(titles_mw == 'Normal Distribution')[0][0]) \n```", "```py\n1270 \n```", "```py\nmu = np.zeros(n)\nmu[1270] = 1 \n```", "```py\nppr_mw = ppr(A_mw, mu)\ntop_pers_pages = np.argsort(-ppr_mw) \n```", "```py\nprint(titles_mw[top_pers_pages[:25]]) \n```", "```py\n['Normal Distribution' 'Pearson System' 'Logit Transformation' 'z-Score'\n 'Erf' 'Central Limit Theorem' 'Bivariate Normal Distribution'\n 'Normal Ratio Distribution' 'Normal Sum Distribution'\n 'Normal Distribution Function' 'Gaussian Function'\n 'Standard Normal Distribution' 'Normal Product Distribution'\n 'Binomial Distribution' 'Tetrachoric Function' 'Ratio Distribution'\n 'Kolmogorov-Smirnov Test' 'Box-Muller Transformation' 'Galton Board'\n 'Fisher-Behrens Problem' 'Erfc' 'Normal Difference Distribution'\n 'Half-Normal Distribution' 'Inverse Gaussian Distribution'\n 'Error Function Distribution'] \n```", "```py\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 0)]) \n```"]