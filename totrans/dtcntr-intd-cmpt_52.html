<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>17.2Â Basic Graph TraversalsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>17.2Â Basic Graph TraversalsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/basic-graph-trav.html">https://dcic-world.org/2025-08-27/basic-graph-trav.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._.Reachability%29" class="toclink" data-pltdoc="x">17.2.1Â Reachability</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Simple_.Recursion%29" class="toclink" data-pltdoc="x">17.2.1.1Â Simple Recursion</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Cleaning_up_the_.Loop%29" class="toclink" data-pltdoc="x">17.2.1.2Â Cleaning up the Loop</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Traversal_with_.Memory%29" class="toclink" data-pltdoc="x">17.2.1.3Â Traversal with Memory</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.A_.Better_.Interface%29" class="toclink" data-pltdoc="x">17.2.1.4Â A Better Interface</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._dfs-bfs%29" class="toclink" data-pltdoc="x">17.2.2Â Depth- and Breadth-First Traversals</a></p></td></tr></table><p>As with all the data we have seen so far, to process a datum we have
to traverse itâ€”<wbr/>i.e., visit the constituent data. With graphs, that
can be quite interesting!</p><section class="SsectionLevel4" id="section 17.2.1"><h4 class="heading">17.2.1Â <a name="(part._.Reachability)"/>Reachability<a href="#(part._.Reachability)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Many uses of graphs need to address reachability: whether we
can, using edges in the graph, get from one node to another. For
instance, a social network might suggest as contacts all those who are
reachable from existing contacts. On the Internet, traffic engineers
care about whether packets can get from one machine to another. On the
Web, we care about whether all public pages on a site are reachable
from the home page. We will study how to compute reachability using
our travel graph as a running example.</p><section class="SsectionLevel5" id="section 17.2.1.1"><h5 class="heading">17.2.1.1Â <a name="(part._.Simple_.Recursion)"/>Simple Recursion<a href="#(part._.Simple_.Recursion)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>At its simplest, reachability is easy. We want to know whether there
exists a pathA path is a sequence of zero or more
linked edges. between a pair of nodes, a source and a destination. (A
more sophisticated version of reachability might compute the actual
path, but weâ€™ll ignore this for now.) There are two possibilities: the
source and destintion nodes are the same, or theyâ€™re not.
</p><ul><li><p>If they are the same, then clearly reachability is trivially
satisfied.</p></li><li><p>If they are not, we have to iterate through the neighbors
of the source node and ask whether the destination is reachable from
each of those neighbors.</p></li></ul><p>This translates into the following function:
</p><a name="(elem._graph-reach-1-main)"/>&lt;graph-reach-1-main&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-1(src :: Key, dst :: Key, g :: Graph) -&gt; Boolean:
  if src == dst:
    true
  else:
    <a href="#%28elem._graph-reach-1-loop%29" data-pltdoc="x">&lt;graph-reach-1-loop&gt;</a>
    loop(neighbors(src, g))
  end
end</code></pre><p>where the loop through the neighbors of <code data-lang="pyret" class="sourceCode">src</code> is:
</p><a name="(elem._graph-reach-1-loop)"/>&lt;graph-reach-1-loop&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun loop(ns):
  cases (List) ns:
    | empty =&gt; false
    | link(f, r) =&gt;
      if reach-1(f, dst, g): true else: loop(r) end
  end
end</code></pre><p>We can test this as follows:
</p><a name="(elem._graph-reach-tests)"/>&lt;graph-reach-tests&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  reach = reach-1
  reach("was", "was", kn-cities) is true
  reach("was", "chi", kn-cities) is true
  reach("was", "bmg", kn-cities) is false
  reach("was", "hou", kn-cities) is true
  reach("was", "den", kn-cities) is true
  reach("was", "saf", kn-cities) is true
end</code></pre><p>Unfortunately, we donâ€™t find out about how these tests fare, because
some of them donâ€™t complete at all. Thatâ€™s because we have an infinite
loop, due to the cyclic nature of graphs!</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Which of the above examples leads to a cycle? Why?</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 17.2.1.2"><h5 class="heading">17.2.1.2Â <a name="(part._.Cleaning_up_the_.Loop)"/>Cleaning up the Loop<a href="#(part._.Cleaning_up_the_.Loop)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Before we continue, letâ€™s try to improve the expression of the
loop. While the nested function above is a perfectly reasonable
definition, we can use Pyretâ€™s <code data-lang="pyret" class="sourceCode">for</code> to improve its readability.</p><p>The essence of the above loop is to iterate over a list of boolean
values; if one of them is true, the entire loop evaluates to true; if
they are all false, then we havenâ€™t found a path to the destination
node, so the loop evaluates to false. Thus:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ormap(fun-body, l):
  cases (List) l:
    | empty =&gt; false
    | link(f, r) =&gt;
      if fun-body(f): true else: ormap(fun-body, r) end
  end
end</code></pre><p>With this, we can replace the loop definition and use with:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for ormap(n from neighbors(src, g)):
  reach-1(n, dst, g)
end</code></pre></section><section class="SsectionLevel5" id="section 17.2.1.3"><h5 class="heading">17.2.1.3Â <a name="(part._.Traversal_with_.Memory)"/>Traversal with Memory<a href="#(part._.Traversal_with_.Memory)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Because we have cyclic data, we have to remember what nodes weâ€™ve
already visited and avoid traversing them again. Then, every time we
begin traversing a new node, we add it to the set of nodes weâ€™ve
already started to visit so that. If we return to that node, because
we can assume the graph has not changed in the meanwhile, we know that
additional traversals from that node wonâ€™t make any difference to the
outcome.This property is known as
<a href="glossary.html#%28elem._glossary-idempotence%29" data-pltdoc="x">â˜› idempotence</a>.</p><p>We therefore define a second attempt at reachability that take an
extra argument: the set of nodes we have begun visiting (where the set
is represented as a graph). The key difference from
<a href="#%28elem._graph-reach-1-main%29" data-pltdoc="x">&lt;graph-reach-1-main&gt;</a> is, before we begin to traverse
edges, we should check whether weâ€™ve begun processing the node or
not. This results in the following definition:
</p><a name="(elem._graph-reach-2)"/>&lt;graph-reach-2&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-2(src :: Key, dst :: Key, g :: Graph, visited :: List&lt;Key&gt;) -&gt; Boolean:
  if visited.member(src):
    false
  else if src == dst:
    true
  else:
    new-visited = link(src, visited)
    for ormap(n from neighbors(src, g)):
      reach-2(n, dst, g, new-visited)
    end
  end
end</code></pre><p>In particular, note the extra new conditional: if the reachability
check has already visited this node before, there is no point
traversing further from here, so it returns
<code data-lang="pyret" class="sourceCode">false</code>. (There may still be other parts of the graph to explore,
which other recursive calls will do.)</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Does it matter if the first two conditions were swapped, i.e., the
beginning of <code data-lang="pyret" class="sourceCode">reach-2</code> began with
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if src == dst:
  true
else if visited.member(src):
  false</code></pre><p>? Explain concretely with examples.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>We repeatedly talk about remembering the nodes that we have
begun to visit, not the ones weâ€™ve finished
visiting. Does this distinction matter? How?</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 17.2.1.4"><h5 class="heading">17.2.1.4Â <a name="(part._.A_.Better_.Interface)"/>A Better Interface<a href="#(part._.A_.Better_.Interface)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>As the process of testing <code data-lang="pyret" class="sourceCode">reach-2</code> shows, we may have a better
implementation, but weâ€™ve changed the functionâ€™s interface; now it has
a needless extra argument, which is not only a nuisance but might also
result in errors if we accidentally misuse it. Therefore, we should
clean up our definition by moving the core code to an internal
function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-3(s :: Key, d :: Key, g :: Graph) -&gt; Boolean:
  fun reacher(src :: Key, dst :: Key, visited :: List&lt;Key&gt;) -&gt; Boolean:
    if visited.member(src):
      false
    else if src == dst:
      true
    else:
      new-visited = link(src, visited)
      for ormap(n from neighbors(src, g)):
        reacher(n, dst, new-visited)
      end
    end
  end
  reacher(s, d, empty)
end</code></pre><p>We have now restored the original interface while correctly
implementing reachability.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Does this really gives us a correct implementation? In particular,
does this address the problem that the <code data-lang="pyret" class="sourceCode">size</code> function above
addressed? Create a test case that demonstrates the problem, and then
fix it.</p></blockquote></blockquote></section></section><section class="SsectionLevel4" id="section 17.2.2"><h4 class="heading">17.2.2Â <a name="(part._dfs-bfs)"/>Depth- and Breadth-First Traversals<a href="#(part._dfs-bfs)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>It is
conventional for computer science texts to call these depth- and
breadth-first search. However, searching is just a specific
purpose; traversal is a general task that can be used for many
purposes.</p><p>The reachability algorithm we have seen above has a special
property. At every node it visits, there is usually a set of adjacent
nodes at which it can continue the traversal. It has at least two
choices: it can either visit each immediate neighbor first, then visit
all of the neighborsâ€™ neighbors; or it can choose a neighbor, recur,
and visit the next immediate neighbor only after that visit is
done. The former is known as breadth-first traversal, while the
latter is depth-first traversal.</p><p>The algorithm we have designed uses a depth-first strategy: inside
<a href="#%28elem._graph-reach-1-loop%29" data-pltdoc="x">&lt;graph-reach-1-loop&gt;</a>, we recur on the first element of the
list of neighbors before we visit the second neighbor, and so on. The
alternative would be to have a data structure into which we insert all
the neighbors, then pull out an element at a time such that we first
visit all the neighbors before their neighbors, and so on. This
naturally corresponds to a queue
[<a href="amortized-analysis.html#%28part._queue-data-structure%29" data-pltdoc="x">An Example: Queues from Lists</a>].</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Using a queue, implement breadth-first traversal.</p></blockquote></blockquote><p>If we correctly check to ensure we donâ€™t re-visit nodes, then both
breadth- and depth-first traversal will properly visit the entire
reachable graph without repetition (and hence not get into an infinite
loop). Each one traverses from a node only once, from which it
considers every single edge. Thus, if a graph has \(N\) nodes and
\(E\) edges, then a lower-bound on the complexity of traversal is
\(O([N, E \rightarrow N + E])\). We must also consider the cost of checking whether we
have already visited a node before (which is a set membership problem,
which we address elsewhere: <a href="part_sets.html" data-pltdoc="x">Several Variations on Sets</a>). Finally, we have to
consider the cost of maintaining the data structure that keeps track
of our traversal. In the case of depth-first traversal,
recursionâ€”<wbr/>which uses the machineâ€™s stackâ€”<wbr/>does it
automatically at constant overhead. In the case of breadth-first
traversal, the program must manage the queue, which can add more than
constant overhead.In practice, too, the stack will
usually perform much better than a queue, because it is supported by
machine hardware.</p><p>This would suggest that depth-first traversal is always better than
breadth-first traversal. However, breadth-first traversal has one very
important and valuable property. Starting from a node \(N\), when it
visits a node \(P\), count the number of edges taken to get to
\(P\). Breadth-first traversal guarantees that there cannot have been
a shorter path to \(P\): that is, it finds a shortest path to
\(P\).</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why â€œaâ€ rather than â€œtheâ€ shortest path?</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Prove that breadth-first traversal finds a shortest path.</p></blockquote></blockquote></section>&#13;
<h4 class="heading">17.2.1Â <a name="(part._.Reachability)"/>Reachability<a href="#(part._.Reachability)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Many uses of graphs need to address reachability: whether we
can, using edges in the graph, get from one node to another. For
instance, a social network might suggest as contacts all those who are
reachable from existing contacts. On the Internet, traffic engineers
care about whether packets can get from one machine to another. On the
Web, we care about whether all public pages on a site are reachable
from the home page. We will study how to compute reachability using
our travel graph as a running example.</p><section class="SsectionLevel5" id="section 17.2.1.1"><h5 class="heading">17.2.1.1Â <a name="(part._.Simple_.Recursion)"/>Simple Recursion<a href="#(part._.Simple_.Recursion)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>At its simplest, reachability is easy. We want to know whether there
exists a pathA path is a sequence of zero or more
linked edges. between a pair of nodes, a source and a destination. (A
more sophisticated version of reachability might compute the actual
path, but weâ€™ll ignore this for now.) There are two possibilities: the
source and destintion nodes are the same, or theyâ€™re not.
</p><ul><li><p>If they are the same, then clearly reachability is trivially
satisfied.</p></li><li><p>If they are not, we have to iterate through the neighbors
of the source node and ask whether the destination is reachable from
each of those neighbors.</p></li></ul><p>This translates into the following function:
</p><a name="(elem._graph-reach-1-main)"/>&lt;graph-reach-1-main&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-1(src :: Key, dst :: Key, g :: Graph) -&gt; Boolean:
  if src == dst:
    true
  else:
    <a href="#%28elem._graph-reach-1-loop%29" data-pltdoc="x">&lt;graph-reach-1-loop&gt;</a>
    loop(neighbors(src, g))
  end
end</code></pre><p>where the loop through the neighbors of <code data-lang="pyret" class="sourceCode">src</code> is:
</p><a name="(elem._graph-reach-1-loop)"/>&lt;graph-reach-1-loop&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun loop(ns):
  cases (List) ns:
    | empty =&gt; false
    | link(f, r) =&gt;
      if reach-1(f, dst, g): true else: loop(r) end
  end
end</code></pre><p>We can test this as follows:
</p><a name="(elem._graph-reach-tests)"/>&lt;graph-reach-tests&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  reach = reach-1
  reach("was", "was", kn-cities) is true
  reach("was", "chi", kn-cities) is true
  reach("was", "bmg", kn-cities) is false
  reach("was", "hou", kn-cities) is true
  reach("was", "den", kn-cities) is true
  reach("was", "saf", kn-cities) is true
end</code></pre><p>Unfortunately, we donâ€™t find out about how these tests fare, because
some of them donâ€™t complete at all. Thatâ€™s because we have an infinite
loop, due to the cyclic nature of graphs!</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Which of the above examples leads to a cycle? Why?</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 17.2.1.2"><h5 class="heading">17.2.1.2Â <a name="(part._.Cleaning_up_the_.Loop)"/>Cleaning up the Loop<a href="#(part._.Cleaning_up_the_.Loop)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Before we continue, letâ€™s try to improve the expression of the
loop. While the nested function above is a perfectly reasonable
definition, we can use Pyretâ€™s <code data-lang="pyret" class="sourceCode">for</code> to improve its readability.</p><p>The essence of the above loop is to iterate over a list of boolean
values; if one of them is true, the entire loop evaluates to true; if
they are all false, then we havenâ€™t found a path to the destination
node, so the loop evaluates to false. Thus:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ormap(fun-body, l):
  cases (List) l:
    | empty =&gt; false
    | link(f, r) =&gt;
      if fun-body(f): true else: ormap(fun-body, r) end
  end
end</code></pre><p>With this, we can replace the loop definition and use with:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for ormap(n from neighbors(src, g)):
  reach-1(n, dst, g)
end</code></pre></section><section class="SsectionLevel5" id="section 17.2.1.3"><h5 class="heading">17.2.1.3Â <a name="(part._.Traversal_with_.Memory)"/>Traversal with Memory<a href="#(part._.Traversal_with_.Memory)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Because we have cyclic data, we have to remember what nodes weâ€™ve
already visited and avoid traversing them again. Then, every time we
begin traversing a new node, we add it to the set of nodes weâ€™ve
already started to visit so that. If we return to that node, because
we can assume the graph has not changed in the meanwhile, we know that
additional traversals from that node wonâ€™t make any difference to the
outcome.This property is known as
<a href="glossary.html#%28elem._glossary-idempotence%29" data-pltdoc="x">â˜› idempotence</a>.</p><p>We therefore define a second attempt at reachability that take an
extra argument: the set of nodes we have begun visiting (where the set
is represented as a graph). The key difference from
<a href="#%28elem._graph-reach-1-main%29" data-pltdoc="x">&lt;graph-reach-1-main&gt;</a> is, before we begin to traverse
edges, we should check whether weâ€™ve begun processing the node or
not. This results in the following definition:
</p><a name="(elem._graph-reach-2)"/>&lt;graph-reach-2&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-2(src :: Key, dst :: Key, g :: Graph, visited :: List&lt;Key&gt;) -&gt; Boolean:
  if visited.member(src):
    false
  else if src == dst:
    true
  else:
    new-visited = link(src, visited)
    for ormap(n from neighbors(src, g)):
      reach-2(n, dst, g, new-visited)
    end
  end
end</code></pre><p>In particular, note the extra new conditional: if the reachability
check has already visited this node before, there is no point
traversing further from here, so it returns
<code data-lang="pyret" class="sourceCode">false</code>. (There may still be other parts of the graph to explore,
which other recursive calls will do.)</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Does it matter if the first two conditions were swapped, i.e., the
beginning of <code data-lang="pyret" class="sourceCode">reach-2</code> began with
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if src == dst:
  true
else if visited.member(src):
  false</code></pre><p>? Explain concretely with examples.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>We repeatedly talk about remembering the nodes that we have
begun to visit, not the ones weâ€™ve finished
visiting. Does this distinction matter? How?</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 17.2.1.4"><h5 class="heading">17.2.1.4Â <a name="(part._.A_.Better_.Interface)"/>A Better Interface<a href="#(part._.A_.Better_.Interface)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>As the process of testing <code data-lang="pyret" class="sourceCode">reach-2</code> shows, we may have a better
implementation, but weâ€™ve changed the functionâ€™s interface; now it has
a needless extra argument, which is not only a nuisance but might also
result in errors if we accidentally misuse it. Therefore, we should
clean up our definition by moving the core code to an internal
function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-3(s :: Key, d :: Key, g :: Graph) -&gt; Boolean:
  fun reacher(src :: Key, dst :: Key, visited :: List&lt;Key&gt;) -&gt; Boolean:
    if visited.member(src):
      false
    else if src == dst:
      true
    else:
      new-visited = link(src, visited)
      for ormap(n from neighbors(src, g)):
        reacher(n, dst, new-visited)
      end
    end
  end
  reacher(s, d, empty)
end</code></pre><p>We have now restored the original interface while correctly
implementing reachability.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Does this really gives us a correct implementation? In particular,
does this address the problem that the <code data-lang="pyret" class="sourceCode">size</code> function above
addressed? Create a test case that demonstrates the problem, and then
fix it.</p></blockquote></blockquote></section>&#13;
<h5 class="heading">17.2.1.1Â <a name="(part._.Simple_.Recursion)"/>Simple Recursion<a href="#(part._.Simple_.Recursion)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>At its simplest, reachability is easy. We want to know whether there
exists a pathA path is a sequence of zero or more
linked edges. between a pair of nodes, a source and a destination. (A
more sophisticated version of reachability might compute the actual
path, but weâ€™ll ignore this for now.) There are two possibilities: the
source and destintion nodes are the same, or theyâ€™re not.
</p><ul><li><p>If they are the same, then clearly reachability is trivially
satisfied.</p></li><li><p>If they are not, we have to iterate through the neighbors
of the source node and ask whether the destination is reachable from
each of those neighbors.</p></li></ul><p>This translates into the following function:
</p><a name="(elem._graph-reach-1-main)"/>&lt;graph-reach-1-main&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-1(src :: Key, dst :: Key, g :: Graph) -&gt; Boolean:
  if src == dst:
    true
  else:
    <a href="#%28elem._graph-reach-1-loop%29" data-pltdoc="x">&lt;graph-reach-1-loop&gt;</a>
    loop(neighbors(src, g))
  end
end</code></pre><p>where the loop through the neighbors of <code data-lang="pyret" class="sourceCode">src</code> is:
</p><a name="(elem._graph-reach-1-loop)"/>&lt;graph-reach-1-loop&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun loop(ns):
  cases (List) ns:
    | empty =&gt; false
    | link(f, r) =&gt;
      if reach-1(f, dst, g): true else: loop(r) end
  end
end</code></pre><p>We can test this as follows:
</p><a name="(elem._graph-reach-tests)"/>&lt;graph-reach-tests&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  reach = reach-1
  reach("was", "was", kn-cities) is true
  reach("was", "chi", kn-cities) is true
  reach("was", "bmg", kn-cities) is false
  reach("was", "hou", kn-cities) is true
  reach("was", "den", kn-cities) is true
  reach("was", "saf", kn-cities) is true
end</code></pre><p>Unfortunately, we donâ€™t find out about how these tests fare, because
some of them donâ€™t complete at all. Thatâ€™s because we have an infinite
loop, due to the cyclic nature of graphs!</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Which of the above examples leads to a cycle? Why?</p></blockquote></blockquote>&#13;
<h5 class="heading">17.2.1.2Â <a name="(part._.Cleaning_up_the_.Loop)"/>Cleaning up the Loop<a href="#(part._.Cleaning_up_the_.Loop)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Before we continue, letâ€™s try to improve the expression of the
loop. While the nested function above is a perfectly reasonable
definition, we can use Pyretâ€™s <code data-lang="pyret" class="sourceCode">for</code> to improve its readability.</p><p>The essence of the above loop is to iterate over a list of boolean
values; if one of them is true, the entire loop evaluates to true; if
they are all false, then we havenâ€™t found a path to the destination
node, so the loop evaluates to false. Thus:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ormap(fun-body, l):
  cases (List) l:
    | empty =&gt; false
    | link(f, r) =&gt;
      if fun-body(f): true else: ormap(fun-body, r) end
  end
end</code></pre><p>With this, we can replace the loop definition and use with:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for ormap(n from neighbors(src, g)):
  reach-1(n, dst, g)
end</code></pre>&#13;
<h5 class="heading">17.2.1.3Â <a name="(part._.Traversal_with_.Memory)"/>Traversal with Memory<a href="#(part._.Traversal_with_.Memory)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Because we have cyclic data, we have to remember what nodes weâ€™ve
already visited and avoid traversing them again. Then, every time we
begin traversing a new node, we add it to the set of nodes weâ€™ve
already started to visit so that. If we return to that node, because
we can assume the graph has not changed in the meanwhile, we know that
additional traversals from that node wonâ€™t make any difference to the
outcome.This property is known as
<a href="glossary.html#%28elem._glossary-idempotence%29" data-pltdoc="x">â˜› idempotence</a>.</p><p>We therefore define a second attempt at reachability that take an
extra argument: the set of nodes we have begun visiting (where the set
is represented as a graph). The key difference from
<a href="#%28elem._graph-reach-1-main%29" data-pltdoc="x">&lt;graph-reach-1-main&gt;</a> is, before we begin to traverse
edges, we should check whether weâ€™ve begun processing the node or
not. This results in the following definition:
</p><a name="(elem._graph-reach-2)"/>&lt;graph-reach-2&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-2(src :: Key, dst :: Key, g :: Graph, visited :: List&lt;Key&gt;) -&gt; Boolean:
  if visited.member(src):
    false
  else if src == dst:
    true
  else:
    new-visited = link(src, visited)
    for ormap(n from neighbors(src, g)):
      reach-2(n, dst, g, new-visited)
    end
  end
end</code></pre><p>In particular, note the extra new conditional: if the reachability
check has already visited this node before, there is no point
traversing further from here, so it returns
<code data-lang="pyret" class="sourceCode">false</code>. (There may still be other parts of the graph to explore,
which other recursive calls will do.)</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Does it matter if the first two conditions were swapped, i.e., the
beginning of <code data-lang="pyret" class="sourceCode">reach-2</code> began with
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if src == dst:
  true
else if visited.member(src):
  false</code></pre><p>? Explain concretely with examples.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>We repeatedly talk about remembering the nodes that we have
begun to visit, not the ones weâ€™ve finished
visiting. Does this distinction matter? How?</p></blockquote></blockquote>&#13;
<h5 class="heading">17.2.1.4Â <a name="(part._.A_.Better_.Interface)"/>A Better Interface<a href="#(part._.A_.Better_.Interface)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>As the process of testing <code data-lang="pyret" class="sourceCode">reach-2</code> shows, we may have a better
implementation, but weâ€™ve changed the functionâ€™s interface; now it has
a needless extra argument, which is not only a nuisance but might also
result in errors if we accidentally misuse it. Therefore, we should
clean up our definition by moving the core code to an internal
function:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-3(s :: Key, d :: Key, g :: Graph) -&gt; Boolean:
  fun reacher(src :: Key, dst :: Key, visited :: List&lt;Key&gt;) -&gt; Boolean:
    if visited.member(src):
      false
    else if src == dst:
      true
    else:
      new-visited = link(src, visited)
      for ormap(n from neighbors(src, g)):
        reacher(n, dst, new-visited)
      end
    end
  end
  reacher(s, d, empty)
end</code></pre><p>We have now restored the original interface while correctly
implementing reachability.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Does this really gives us a correct implementation? In particular,
does this address the problem that the <code data-lang="pyret" class="sourceCode">size</code> function above
addressed? Create a test case that demonstrates the problem, and then
fix it.</p></blockquote></blockquote>&#13;
<h4 class="heading">17.2.2Â <a name="(part._dfs-bfs)"/>Depth- and Breadth-First Traversals<a href="#(part._dfs-bfs)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>It is
conventional for computer science texts to call these depth- and
breadth-first search. However, searching is just a specific
purpose; traversal is a general task that can be used for many
purposes.</p><p>The reachability algorithm we have seen above has a special
property. At every node it visits, there is usually a set of adjacent
nodes at which it can continue the traversal. It has at least two
choices: it can either visit each immediate neighbor first, then visit
all of the neighborsâ€™ neighbors; or it can choose a neighbor, recur,
and visit the next immediate neighbor only after that visit is
done. The former is known as breadth-first traversal, while the
latter is depth-first traversal.</p><p>The algorithm we have designed uses a depth-first strategy: inside
<a href="#%28elem._graph-reach-1-loop%29" data-pltdoc="x">&lt;graph-reach-1-loop&gt;</a>, we recur on the first element of the
list of neighbors before we visit the second neighbor, and so on. The
alternative would be to have a data structure into which we insert all
the neighbors, then pull out an element at a time such that we first
visit all the neighbors before their neighbors, and so on. This
naturally corresponds to a queue
[<a href="amortized-analysis.html#%28part._queue-data-structure%29" data-pltdoc="x">An Example: Queues from Lists</a>].</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Using a queue, implement breadth-first traversal.</p></blockquote></blockquote><p>If we correctly check to ensure we donâ€™t re-visit nodes, then both
breadth- and depth-first traversal will properly visit the entire
reachable graph without repetition (and hence not get into an infinite
loop). Each one traverses from a node only once, from which it
considers every single edge. Thus, if a graph has \(N\) nodes and
\(E\) edges, then a lower-bound on the complexity of traversal is
\(O([N, E \rightarrow N + E])\). We must also consider the cost of checking whether we
have already visited a node before (which is a set membership problem,
which we address elsewhere: <a href="part_sets.html" data-pltdoc="x">Several Variations on Sets</a>). Finally, we have to
consider the cost of maintaining the data structure that keeps track
of our traversal. In the case of depth-first traversal,
recursionâ€”<wbr/>which uses the machineâ€™s stackâ€”<wbr/>does it
automatically at constant overhead. In the case of breadth-first
traversal, the program must manage the queue, which can add more than
constant overhead.In practice, too, the stack will
usually perform much better than a queue, because it is supported by
machine hardware.</p><p>This would suggest that depth-first traversal is always better than
breadth-first traversal. However, breadth-first traversal has one very
important and valuable property. Starting from a node \(N\), when it
visits a node \(P\), count the number of edges taken to get to
\(P\). Breadth-first traversal guarantees that there cannot have been
a shorter path to \(P\): that is, it finds a shortest path to
\(P\).</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why â€œaâ€ rather than â€œtheâ€ shortest path?</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Prove that breadth-first traversal finds a shortest path.</p></blockquote></blockquote>    
</body>
</html>