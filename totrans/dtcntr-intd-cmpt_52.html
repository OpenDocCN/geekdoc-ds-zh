<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>17.2Â Basic Graph TraversalsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>17.2Â Basic Graph TraversalsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/basic-graph-trav.html">https://dcic-world.org/2025-08-27/basic-graph-trav.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Reachability%29" class="toclink" data-pltdoc="x">17.2.1<span class="hspace">Â </span>Reachability</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Simple_.Recursion%29" class="toclink" data-pltdoc="x">17.2.1.1<span class="hspace">Â </span>Simple Recursion</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Cleaning_up_the_.Loop%29" class="toclink" data-pltdoc="x">17.2.1.2<span class="hspace">Â </span>Cleaning up the Loop</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Traversal_with_.Memory%29" class="toclink" data-pltdoc="x">17.2.1.3<span class="hspace">Â </span>Traversal with Memory</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.A_.Better_.Interface%29" class="toclink" data-pltdoc="x">17.2.1.4<span class="hspace">Â </span>A Better Interface</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._dfs-bfs%29" class="toclink" data-pltdoc="x">17.2.2<span class="hspace">Â </span>Depth- and Breadth-First Traversals</a></p></td></tr></table><p>As with all the data we have seen so far, to process a datum we have
to traverse itâ€”<wbr/>i.e., visit the constituent data. With graphs, that
can be quite interesting!</p><section class="SsectionLevel4" id="section 17.2.1"><h4 class="heading">17.2.1<span class="stt">Â </span><a name="(part._.Reachability)"/>Reachability<span class="button-group"><a href="#(part._.Reachability)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Many uses of graphs need to address <span class="emph">reachability</span>: whether we
can, using edges in the graph, get from one node to another. For
instance, a social network might suggest as contacts all those who are
reachable from existing contacts. On the Internet, traffic engineers
care about whether packets can get from one machine to another. On the
Web, we care about whether all public pages on a site are reachable
from the home page. We will study how to compute reachability using
our travel graph as a running example.</p><section class="SsectionLevel5" id="section 17.2.1.1"><h5 class="heading">17.2.1.1<span class="stt">Â </span><a name="(part._.Simple_.Recursion)"/>Simple Recursion<span class="button-group"><a href="#(part._.Simple_.Recursion)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">At its simplest, reachability is easy. We want to know whether there
exists a path<span class="refelem"><span class="refcolumn"><span class="refcontent">A <span style="font-style: italic">path</span> is a sequence of zero or more
linked edges.</span></span></span> between a pair of nodes, a source and a destination. (A
more sophisticated version of reachability might compute the actual
path, but weâ€™ll ignore this for now.) There are two possibilities: the
source and destintion nodes are the same, or theyâ€™re not.
</div><div class="SIntrapara"><ul><li><p>If they are the same, then clearly reachability is trivially
satisfied.</p></li><li><p>If they are not, we have to iterate through the neighbors
of the source node and ask whether the destination is reachable from
each of those neighbors.</p></li></ul></div><div class="SIntrapara">This translates into the following function:
</div><div class="SIntrapara"><a name="(elem._graph-reach-1-main)"/>&lt;<span style="font-style: italic">graph-reach-1-main</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-1(src :: Key, dst :: Key, g :: Graph) -&gt; Boolean:
  if src == dst:
    true
  else:
    <a href="#%28elem._graph-reach-1-loop%29" data-pltdoc="x">&lt;<span style="font-style: italic">graph-reach-1-loop</span>&gt;</a>
    loop(neighbors(src, g))
  end
end</code></pre></div></div></div><div class="SIntrapara">where the loop through the neighbors of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">src</code></span> is:
</div><div class="SIntrapara"><a name="(elem._graph-reach-1-loop)"/>&lt;<span style="font-style: italic">graph-reach-1-loop</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun loop(ns):
  cases (List) ns:
    | empty =&gt; false
    | link(f, r) =&gt;
      if reach-1(f, dst, g): true else: loop(r) end
  end
end</code></pre></div></div></div><div class="SIntrapara">We can test this as follows:
</div><div class="SIntrapara"><a name="(elem._graph-reach-tests)"/>&lt;<span style="font-style: italic">graph-reach-tests</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  reach = reach-1
  reach("was", "was", kn-cities) is true
  reach("was", "chi", kn-cities) is true
  reach("was", "bmg", kn-cities) is false
  reach("was", "hou", kn-cities) is true
  reach("was", "den", kn-cities) is true
  reach("was", "saf", kn-cities) is true
end</code></pre></div></div></div><div class="SIntrapara">Unfortunately, we donâ€™t find out about how these tests fare, because
some of them donâ€™t complete at all. Thatâ€™s because we have an infinite
loop, due to the cyclic nature of graphs!</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Which of the above examples leads to a cycle? Why?</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 17.2.1.2"><h5 class="heading">17.2.1.2<span class="stt">Â </span><a name="(part._.Cleaning_up_the_.Loop)"/>Cleaning up the Loop<span class="button-group"><a href="#(part._.Cleaning_up_the_.Loop)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Before we continue, letâ€™s try to improve the expression of the
loop. While the nested function above is a perfectly reasonable
definition, we can use Pyretâ€™s <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span> to improve its readability.</p><p/><div class="SIntrapara">The essence of the above loop is to iterate over a list of boolean
values; if one of them is true, the entire loop evaluates to true; if
they are all false, then we havenâ€™t found a path to the destination
node, so the loop evaluates to false. Thus:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ormap(fun-body, l):
  cases (List) l:
    | empty =&gt; false
    | link(f, r) =&gt;
      if fun-body(f): true else: ormap(fun-body, r) end
  end
end</code></pre></div></div></div><div class="SIntrapara">With this, we can replace the loop definition and use with:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for ormap(n from neighbors(src, g)):
  reach-1(n, dst, g)
end</code></pre></div></div></div></section><section class="SsectionLevel5" id="section 17.2.1.3"><h5 class="heading">17.2.1.3<span class="stt">Â </span><a name="(part._.Traversal_with_.Memory)"/>Traversal with Memory<span class="button-group"><a href="#(part._.Traversal_with_.Memory)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Because we have cyclic data, we have to remember what nodes weâ€™ve
already visited and avoid traversing them again. Then, every time we
begin traversing a new node, we add it to the set of nodes weâ€™ve
already started to visit so that. If we return to that node, because
we can assume the graph has not changed in the meanwhile, we know that
additional traversals from that node wonâ€™t make any difference to the
outcome.<span class="refelem"><span class="refcolumn"><span class="refcontent">This property is known as
<a href="glossary.html#%28elem._glossary-idempotence%29" data-pltdoc="x">â˜› <span style="font-style: italic">idempotence</span></a>.</span></span></span></p><p/><div class="SIntrapara">We therefore define a second attempt at reachability that take an
extra argument: the set of nodes we have begun visiting (where the set
is represented as a graph). The key difference from
<a href="#%28elem._graph-reach-1-main%29" data-pltdoc="x">&lt;<span style="font-style: italic">graph-reach-1-main</span>&gt;</a> is, before we begin to traverse
edges, we should check whether weâ€™ve begun processing the node or
not. This results in the following definition:
</div><div class="SIntrapara"><a name="(elem._graph-reach-2)"/>&lt;<span style="font-style: italic">graph-reach-2</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-2(src :: Key, dst :: Key, g :: Graph, visited :: List&lt;Key&gt;) -&gt; Boolean:
  if visited.member(src):
    false
  else if src == dst:
    true
  else:
    new-visited = link(src, visited)
    for ormap(n from neighbors(src, g)):
      reach-2(n, dst, g, new-visited)
    end
  end
end</code></pre></div></div></div><div class="SIntrapara">In particular, note the extra new conditional: if the reachability
check has already visited this node before, there is no point
traversing further <span class="emph">from here</span>, so it returns
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>. (There may still be other parts of the graph to explore,
which other recursive calls will do.)</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p/><div class="SIntrapara">Does it matter if the first two conditions were swapped, i.e., the
beginning of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">reach-2</code></span> began with
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if src == dst:
  true
else if visited.member(src):
  false</code></pre></div></div></div><div class="SIntrapara">? Explain concretely with examples.</div></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>We repeatedly talk about remembering the nodes that we have
<span class="emph">begun</span> to visit, not the ones weâ€™ve <span class="emph">finished</span>
visiting. Does this distinction matter? How?</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 17.2.1.4"><h5 class="heading">17.2.1.4<span class="stt">Â </span><a name="(part._.A_.Better_.Interface)"/>A Better Interface<span class="button-group"><a href="#(part._.A_.Better_.Interface)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">As the process of testing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">reach-2</code></span> shows, we may have a better
implementation, but weâ€™ve changed the functionâ€™s interface; now it has
a needless extra argument, which is not only a nuisance but might also
result in errors if we accidentally misuse it. Therefore, we should
clean up our definition by moving the core code to an internal
function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-3(s :: Key, d :: Key, g :: Graph) -&gt; Boolean:
  fun reacher(src :: Key, dst :: Key, visited :: List&lt;Key&gt;) -&gt; Boolean:
    if visited.member(src):
      false
    else if src == dst:
      true
    else:
      new-visited = link(src, visited)
      for ormap(n from neighbors(src, g)):
        reacher(n, dst, new-visited)
      end
    end
  end
  reacher(s, d, empty)
end</code></pre></div></div></div><div class="SIntrapara">We have now restored the original interface while correctly
implementing reachability.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Does this really gives us a correct implementation? In particular,
does this address the problem that the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> function above
addressed? Create a test case that demonstrates the problem, and then
fix it.</p></blockquote></blockquote></section></section><section class="SsectionLevel4" id="section 17.2.2"><h4 class="heading">17.2.2<span class="stt">Â </span><a name="(part._dfs-bfs)"/>Depth- and Breadth-First Traversals<span class="button-group"><a href="#(part._dfs-bfs)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><span class="refelem"><span class="refcolumn"><span class="refcontent">It is
conventional for computer science texts to call these depth- and
breadth-first <span class="emph">search</span>. However, searching is just a specific
purpose; traversal is a general task that can be used for many
purposes.</span></span></span></p><p>The reachability algorithm we have seen above has a special
property. At every node it visits, there is usually a set of adjacent
nodes at which it can continue the traversal. It has at least two
choices: it can either visit each immediate neighbor first, then visit
all of the neighborsâ€™ neighbors; or it can choose a neighbor, recur,
and visit the next immediate neighbor only after that visit is
done. The former is known as <span style="font-style: italic">breadth-first traversal</span>, while the
latter is <span style="font-style: italic">depth-first traversal</span>.</p><p>The algorithm we have designed uses a depth-first strategy: inside
<a href="#%28elem._graph-reach-1-loop%29" data-pltdoc="x">&lt;<span style="font-style: italic">graph-reach-1-loop</span>&gt;</a>, we recur on the first element of the
list of neighbors before we visit the second neighbor, and so on. The
alternative would be to have a data structure into which we insert all
the neighbors, then pull out an element at a time such that we first
visit all the neighbors before their neighbors, and so on. This
naturally corresponds to a <span style="font-style: italic">queue</span>
[<a href="amortized-analysis.html#%28part._queue-data-structure%29" data-pltdoc="x">An Example: Queues from Lists</a>].</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Using a queue, implement breadth-first traversal.</p></blockquote></blockquote><p>If we correctly check to ensure we donâ€™t re-visit nodes, then both
breadth- and depth-first traversal will properly visit the entire
reachable graph without repetition (and hence not get into an infinite
loop). Each one traverses from a node only once, from which it
considers every single edge. Thus, if a graph has \(N\) nodes and
\(E\) edges, then a lower-bound on the complexity of traversal is
\(O([N, E \rightarrow N + E])\). We must also consider the cost of checking whether we
have already visited a node before (which is a set membership problem,
which we address elsewhere: <a href="part_sets.html" data-pltdoc="x">Several Variations on Sets</a>). Finally, we have to
consider the cost of maintaining the data structure that keeps track
of our traversal. In the case of depth-first traversal,
recursionâ€”<wbr/>which uses the machineâ€™s <span style="font-style: italic">stack</span>â€”<wbr/>does it
automatically at constant overhead. In the case of breadth-first
traversal, the program must manage the queue, which can add more than
constant overhead.<span class="refelem"><span class="refcolumn"><span class="refcontent">In practice, too, the stack will
usually perform much better than a queue, because it is supported by
machine hardware.</span></span></span></p><p>This would suggest that depth-first traversal is always better than
breadth-first traversal. However, breadth-first traversal has one very
important and valuable property. Starting from a node \(N\), when it
visits a node \(P\), count the number of edges taken to get to
\(P\). Breadth-first traversal guarantees that there cannot have been
a shorter path to \(P\): that is, it finds a <span class="emph">shortest</span> path to
\(P\).</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why â€œaâ€ rather than â€œtheâ€ shortest path?</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Prove that breadth-first traversal finds a shortest path.</p></blockquote></blockquote></section>&#13;
<h4 class="heading">17.2.1<span class="stt">Â </span><a name="(part._.Reachability)"/>Reachability<span class="button-group"><a href="#(part._.Reachability)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Many uses of graphs need to address <span class="emph">reachability</span>: whether we
can, using edges in the graph, get from one node to another. For
instance, a social network might suggest as contacts all those who are
reachable from existing contacts. On the Internet, traffic engineers
care about whether packets can get from one machine to another. On the
Web, we care about whether all public pages on a site are reachable
from the home page. We will study how to compute reachability using
our travel graph as a running example.</p><section class="SsectionLevel5" id="section 17.2.1.1"><h5 class="heading">17.2.1.1<span class="stt">Â </span><a name="(part._.Simple_.Recursion)"/>Simple Recursion<span class="button-group"><a href="#(part._.Simple_.Recursion)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">At its simplest, reachability is easy. We want to know whether there
exists a path<span class="refelem"><span class="refcolumn"><span class="refcontent">A <span style="font-style: italic">path</span> is a sequence of zero or more
linked edges.</span></span></span> between a pair of nodes, a source and a destination. (A
more sophisticated version of reachability might compute the actual
path, but weâ€™ll ignore this for now.) There are two possibilities: the
source and destintion nodes are the same, or theyâ€™re not.
</div><div class="SIntrapara"><ul><li><p>If they are the same, then clearly reachability is trivially
satisfied.</p></li><li><p>If they are not, we have to iterate through the neighbors
of the source node and ask whether the destination is reachable from
each of those neighbors.</p></li></ul></div><div class="SIntrapara">This translates into the following function:
</div><div class="SIntrapara"><a name="(elem._graph-reach-1-main)"/>&lt;<span style="font-style: italic">graph-reach-1-main</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-1(src :: Key, dst :: Key, g :: Graph) -&gt; Boolean:
  if src == dst:
    true
  else:
    <a href="#%28elem._graph-reach-1-loop%29" data-pltdoc="x">&lt;<span style="font-style: italic">graph-reach-1-loop</span>&gt;</a>
    loop(neighbors(src, g))
  end
end</code></pre></div></div></div><div class="SIntrapara">where the loop through the neighbors of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">src</code></span> is:
</div><div class="SIntrapara"><a name="(elem._graph-reach-1-loop)"/>&lt;<span style="font-style: italic">graph-reach-1-loop</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun loop(ns):
  cases (List) ns:
    | empty =&gt; false
    | link(f, r) =&gt;
      if reach-1(f, dst, g): true else: loop(r) end
  end
end</code></pre></div></div></div><div class="SIntrapara">We can test this as follows:
</div><div class="SIntrapara"><a name="(elem._graph-reach-tests)"/>&lt;<span style="font-style: italic">graph-reach-tests</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  reach = reach-1
  reach("was", "was", kn-cities) is true
  reach("was", "chi", kn-cities) is true
  reach("was", "bmg", kn-cities) is false
  reach("was", "hou", kn-cities) is true
  reach("was", "den", kn-cities) is true
  reach("was", "saf", kn-cities) is true
end</code></pre></div></div></div><div class="SIntrapara">Unfortunately, we donâ€™t find out about how these tests fare, because
some of them donâ€™t complete at all. Thatâ€™s because we have an infinite
loop, due to the cyclic nature of graphs!</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Which of the above examples leads to a cycle? Why?</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 17.2.1.2"><h5 class="heading">17.2.1.2<span class="stt">Â </span><a name="(part._.Cleaning_up_the_.Loop)"/>Cleaning up the Loop<span class="button-group"><a href="#(part._.Cleaning_up_the_.Loop)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Before we continue, letâ€™s try to improve the expression of the
loop. While the nested function above is a perfectly reasonable
definition, we can use Pyretâ€™s <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span> to improve its readability.</p><p/><div class="SIntrapara">The essence of the above loop is to iterate over a list of boolean
values; if one of them is true, the entire loop evaluates to true; if
they are all false, then we havenâ€™t found a path to the destination
node, so the loop evaluates to false. Thus:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ormap(fun-body, l):
  cases (List) l:
    | empty =&gt; false
    | link(f, r) =&gt;
      if fun-body(f): true else: ormap(fun-body, r) end
  end
end</code></pre></div></div></div><div class="SIntrapara">With this, we can replace the loop definition and use with:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for ormap(n from neighbors(src, g)):
  reach-1(n, dst, g)
end</code></pre></div></div></div></section><section class="SsectionLevel5" id="section 17.2.1.3"><h5 class="heading">17.2.1.3<span class="stt">Â </span><a name="(part._.Traversal_with_.Memory)"/>Traversal with Memory<span class="button-group"><a href="#(part._.Traversal_with_.Memory)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Because we have cyclic data, we have to remember what nodes weâ€™ve
already visited and avoid traversing them again. Then, every time we
begin traversing a new node, we add it to the set of nodes weâ€™ve
already started to visit so that. If we return to that node, because
we can assume the graph has not changed in the meanwhile, we know that
additional traversals from that node wonâ€™t make any difference to the
outcome.<span class="refelem"><span class="refcolumn"><span class="refcontent">This property is known as
<a href="glossary.html#%28elem._glossary-idempotence%29" data-pltdoc="x">â˜› <span style="font-style: italic">idempotence</span></a>.</span></span></span></p><p/><div class="SIntrapara">We therefore define a second attempt at reachability that take an
extra argument: the set of nodes we have begun visiting (where the set
is represented as a graph). The key difference from
<a href="#%28elem._graph-reach-1-main%29" data-pltdoc="x">&lt;<span style="font-style: italic">graph-reach-1-main</span>&gt;</a> is, before we begin to traverse
edges, we should check whether weâ€™ve begun processing the node or
not. This results in the following definition:
</div><div class="SIntrapara"><a name="(elem._graph-reach-2)"/>&lt;<span style="font-style: italic">graph-reach-2</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-2(src :: Key, dst :: Key, g :: Graph, visited :: List&lt;Key&gt;) -&gt; Boolean:
  if visited.member(src):
    false
  else if src == dst:
    true
  else:
    new-visited = link(src, visited)
    for ormap(n from neighbors(src, g)):
      reach-2(n, dst, g, new-visited)
    end
  end
end</code></pre></div></div></div><div class="SIntrapara">In particular, note the extra new conditional: if the reachability
check has already visited this node before, there is no point
traversing further <span class="emph">from here</span>, so it returns
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>. (There may still be other parts of the graph to explore,
which other recursive calls will do.)</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p/><div class="SIntrapara">Does it matter if the first two conditions were swapped, i.e., the
beginning of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">reach-2</code></span> began with
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if src == dst:
  true
else if visited.member(src):
  false</code></pre></div></div></div><div class="SIntrapara">? Explain concretely with examples.</div></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>We repeatedly talk about remembering the nodes that we have
<span class="emph">begun</span> to visit, not the ones weâ€™ve <span class="emph">finished</span>
visiting. Does this distinction matter? How?</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 17.2.1.4"><h5 class="heading">17.2.1.4<span class="stt">Â </span><a name="(part._.A_.Better_.Interface)"/>A Better Interface<span class="button-group"><a href="#(part._.A_.Better_.Interface)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">As the process of testing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">reach-2</code></span> shows, we may have a better
implementation, but weâ€™ve changed the functionâ€™s interface; now it has
a needless extra argument, which is not only a nuisance but might also
result in errors if we accidentally misuse it. Therefore, we should
clean up our definition by moving the core code to an internal
function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-3(s :: Key, d :: Key, g :: Graph) -&gt; Boolean:
  fun reacher(src :: Key, dst :: Key, visited :: List&lt;Key&gt;) -&gt; Boolean:
    if visited.member(src):
      false
    else if src == dst:
      true
    else:
      new-visited = link(src, visited)
      for ormap(n from neighbors(src, g)):
        reacher(n, dst, new-visited)
      end
    end
  end
  reacher(s, d, empty)
end</code></pre></div></div></div><div class="SIntrapara">We have now restored the original interface while correctly
implementing reachability.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Does this really gives us a correct implementation? In particular,
does this address the problem that the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> function above
addressed? Create a test case that demonstrates the problem, and then
fix it.</p></blockquote></blockquote></section>&#13;
<h5 class="heading">17.2.1.1<span class="stt">Â </span><a name="(part._.Simple_.Recursion)"/>Simple Recursion<span class="button-group"><a href="#(part._.Simple_.Recursion)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">At its simplest, reachability is easy. We want to know whether there
exists a path<span class="refelem"><span class="refcolumn"><span class="refcontent">A <span style="font-style: italic">path</span> is a sequence of zero or more
linked edges.</span></span></span> between a pair of nodes, a source and a destination. (A
more sophisticated version of reachability might compute the actual
path, but weâ€™ll ignore this for now.) There are two possibilities: the
source and destintion nodes are the same, or theyâ€™re not.
</div><div class="SIntrapara"><ul><li><p>If they are the same, then clearly reachability is trivially
satisfied.</p></li><li><p>If they are not, we have to iterate through the neighbors
of the source node and ask whether the destination is reachable from
each of those neighbors.</p></li></ul></div><div class="SIntrapara">This translates into the following function:
</div><div class="SIntrapara"><a name="(elem._graph-reach-1-main)"/>&lt;<span style="font-style: italic">graph-reach-1-main</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-1(src :: Key, dst :: Key, g :: Graph) -&gt; Boolean:
  if src == dst:
    true
  else:
    <a href="#%28elem._graph-reach-1-loop%29" data-pltdoc="x">&lt;<span style="font-style: italic">graph-reach-1-loop</span>&gt;</a>
    loop(neighbors(src, g))
  end
end</code></pre></div></div></div><div class="SIntrapara">where the loop through the neighbors of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">src</code></span> is:
</div><div class="SIntrapara"><a name="(elem._graph-reach-1-loop)"/>&lt;<span style="font-style: italic">graph-reach-1-loop</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun loop(ns):
  cases (List) ns:
    | empty =&gt; false
    | link(f, r) =&gt;
      if reach-1(f, dst, g): true else: loop(r) end
  end
end</code></pre></div></div></div><div class="SIntrapara">We can test this as follows:
</div><div class="SIntrapara"><a name="(elem._graph-reach-tests)"/>&lt;<span style="font-style: italic">graph-reach-tests</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  reach = reach-1
  reach("was", "was", kn-cities) is true
  reach("was", "chi", kn-cities) is true
  reach("was", "bmg", kn-cities) is false
  reach("was", "hou", kn-cities) is true
  reach("was", "den", kn-cities) is true
  reach("was", "saf", kn-cities) is true
end</code></pre></div></div></div><div class="SIntrapara">Unfortunately, we donâ€™t find out about how these tests fare, because
some of them donâ€™t complete at all. Thatâ€™s because we have an infinite
loop, due to the cyclic nature of graphs!</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Which of the above examples leads to a cycle? Why?</p></blockquote></blockquote>&#13;
<h5 class="heading">17.2.1.2<span class="stt">Â </span><a name="(part._.Cleaning_up_the_.Loop)"/>Cleaning up the Loop<span class="button-group"><a href="#(part._.Cleaning_up_the_.Loop)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Before we continue, letâ€™s try to improve the expression of the
loop. While the nested function above is a perfectly reasonable
definition, we can use Pyretâ€™s <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for</code></span> to improve its readability.</p><p/><div class="SIntrapara">The essence of the above loop is to iterate over a list of boolean
values; if one of them is true, the entire loop evaluates to true; if
they are all false, then we havenâ€™t found a path to the destination
node, so the loop evaluates to false. Thus:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun ormap(fun-body, l):
  cases (List) l:
    | empty =&gt; false
    | link(f, r) =&gt;
      if fun-body(f): true else: ormap(fun-body, r) end
  end
end</code></pre></div></div></div><div class="SIntrapara">With this, we can replace the loop definition and use with:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for ormap(n from neighbors(src, g)):
  reach-1(n, dst, g)
end</code></pre></div></div></div>&#13;
<h5 class="heading">17.2.1.3<span class="stt">Â </span><a name="(part._.Traversal_with_.Memory)"/>Traversal with Memory<span class="button-group"><a href="#(part._.Traversal_with_.Memory)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Because we have cyclic data, we have to remember what nodes weâ€™ve
already visited and avoid traversing them again. Then, every time we
begin traversing a new node, we add it to the set of nodes weâ€™ve
already started to visit so that. If we return to that node, because
we can assume the graph has not changed in the meanwhile, we know that
additional traversals from that node wonâ€™t make any difference to the
outcome.<span class="refelem"><span class="refcolumn"><span class="refcontent">This property is known as
<a href="glossary.html#%28elem._glossary-idempotence%29" data-pltdoc="x">â˜› <span style="font-style: italic">idempotence</span></a>.</span></span></span></p><p/><div class="SIntrapara">We therefore define a second attempt at reachability that take an
extra argument: the set of nodes we have begun visiting (where the set
is represented as a graph). The key difference from
<a href="#%28elem._graph-reach-1-main%29" data-pltdoc="x">&lt;<span style="font-style: italic">graph-reach-1-main</span>&gt;</a> is, before we begin to traverse
edges, we should check whether weâ€™ve begun processing the node or
not. This results in the following definition:
</div><div class="SIntrapara"><a name="(elem._graph-reach-2)"/>&lt;<span style="font-style: italic">graph-reach-2</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-2(src :: Key, dst :: Key, g :: Graph, visited :: List&lt;Key&gt;) -&gt; Boolean:
  if visited.member(src):
    false
  else if src == dst:
    true
  else:
    new-visited = link(src, visited)
    for ormap(n from neighbors(src, g)):
      reach-2(n, dst, g, new-visited)
    end
  end
end</code></pre></div></div></div><div class="SIntrapara">In particular, note the extra new conditional: if the reachability
check has already visited this node before, there is no point
traversing further <span class="emph">from here</span>, so it returns
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>. (There may still be other parts of the graph to explore,
which other recursive calls will do.)</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p/><div class="SIntrapara">Does it matter if the first two conditions were swapped, i.e., the
beginning of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">reach-2</code></span> began with
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if src == dst:
  true
else if visited.member(src):
  false</code></pre></div></div></div><div class="SIntrapara">? Explain concretely with examples.</div></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>We repeatedly talk about remembering the nodes that we have
<span class="emph">begun</span> to visit, not the ones weâ€™ve <span class="emph">finished</span>
visiting. Does this distinction matter? How?</p></blockquote></blockquote>&#13;
<h5 class="heading">17.2.1.4<span class="stt">Â </span><a name="(part._.A_.Better_.Interface)"/>A Better Interface<span class="button-group"><a href="#(part._.A_.Better_.Interface)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">As the process of testing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">reach-2</code></span> shows, we may have a better
implementation, but weâ€™ve changed the functionâ€™s interface; now it has
a needless extra argument, which is not only a nuisance but might also
result in errors if we accidentally misuse it. Therefore, we should
clean up our definition by moving the core code to an internal
function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun reach-3(s :: Key, d :: Key, g :: Graph) -&gt; Boolean:
  fun reacher(src :: Key, dst :: Key, visited :: List&lt;Key&gt;) -&gt; Boolean:
    if visited.member(src):
      false
    else if src == dst:
      true
    else:
      new-visited = link(src, visited)
      for ormap(n from neighbors(src, g)):
        reacher(n, dst, new-visited)
      end
    end
  end
  reacher(s, d, empty)
end</code></pre></div></div></div><div class="SIntrapara">We have now restored the original interface while correctly
implementing reachability.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Does this really gives us a correct implementation? In particular,
does this address the problem that the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">size</code></span> function above
addressed? Create a test case that demonstrates the problem, and then
fix it.</p></blockquote></blockquote>&#13;
<h4 class="heading">17.2.2<span class="stt">Â </span><a name="(part._dfs-bfs)"/>Depth- and Breadth-First Traversals<span class="button-group"><a href="#(part._dfs-bfs)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><span class="refelem"><span class="refcolumn"><span class="refcontent">It is
conventional for computer science texts to call these depth- and
breadth-first <span class="emph">search</span>. However, searching is just a specific
purpose; traversal is a general task that can be used for many
purposes.</span></span></span></p><p>The reachability algorithm we have seen above has a special
property. At every node it visits, there is usually a set of adjacent
nodes at which it can continue the traversal. It has at least two
choices: it can either visit each immediate neighbor first, then visit
all of the neighborsâ€™ neighbors; or it can choose a neighbor, recur,
and visit the next immediate neighbor only after that visit is
done. The former is known as <span style="font-style: italic">breadth-first traversal</span>, while the
latter is <span style="font-style: italic">depth-first traversal</span>.</p><p>The algorithm we have designed uses a depth-first strategy: inside
<a href="#%28elem._graph-reach-1-loop%29" data-pltdoc="x">&lt;<span style="font-style: italic">graph-reach-1-loop</span>&gt;</a>, we recur on the first element of the
list of neighbors before we visit the second neighbor, and so on. The
alternative would be to have a data structure into which we insert all
the neighbors, then pull out an element at a time such that we first
visit all the neighbors before their neighbors, and so on. This
naturally corresponds to a <span style="font-style: italic">queue</span>
[<a href="amortized-analysis.html#%28part._queue-data-structure%29" data-pltdoc="x">An Example: Queues from Lists</a>].</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Using a queue, implement breadth-first traversal.</p></blockquote></blockquote><p>If we correctly check to ensure we donâ€™t re-visit nodes, then both
breadth- and depth-first traversal will properly visit the entire
reachable graph without repetition (and hence not get into an infinite
loop). Each one traverses from a node only once, from which it
considers every single edge. Thus, if a graph has \(N\) nodes and
\(E\) edges, then a lower-bound on the complexity of traversal is
\(O([N, E \rightarrow N + E])\). We must also consider the cost of checking whether we
have already visited a node before (which is a set membership problem,
which we address elsewhere: <a href="part_sets.html" data-pltdoc="x">Several Variations on Sets</a>). Finally, we have to
consider the cost of maintaining the data structure that keeps track
of our traversal. In the case of depth-first traversal,
recursionâ€”<wbr/>which uses the machineâ€™s <span style="font-style: italic">stack</span>â€”<wbr/>does it
automatically at constant overhead. In the case of breadth-first
traversal, the program must manage the queue, which can add more than
constant overhead.<span class="refelem"><span class="refcolumn"><span class="refcontent">In practice, too, the stack will
usually perform much better than a queue, because it is supported by
machine hardware.</span></span></span></p><p>This would suggest that depth-first traversal is always better than
breadth-first traversal. However, breadth-first traversal has one very
important and valuable property. Starting from a node \(N\), when it
visits a node \(P\), count the number of edges taken to get to
\(P\). Breadth-first traversal guarantees that there cannot have been
a shorter path to \(P\): that is, it finds a <span class="emph">shortest</span> path to
\(P\).</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why â€œaâ€ rather than â€œtheâ€ shortest path?</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Prove that breadth-first traversal finds a shortest path.</p></blockquote></blockquote>    
</body>
</html>