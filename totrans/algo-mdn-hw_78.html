<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Binary Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Binary Search</h1>
<blockquote>原文：<a href="https://en.algorithmica.org/hpc/data-structures/binary-search/">https://en.algorithmica.org/hpc/data-structures/binary-search/</a></blockquote><div id="search"><input id="search-bar" type="search" placeholder="Search this book…" oninput="search()"/><div id="search-count"/><div id="search-results"/></div><header><div class="info"/></header><article><p>While improving the speed of user-facing applications is the end goal of performance engineering, people don’t really get excited over 5-10% improvements in some databases. Yes, this is what software engineers are paid for, but these types of optimizations tend to be too intricate and system-specific to be readily generalized to other software.</p><p>Instead, the most fascinating showcases of performance engineering are multifold optimizations of textbook algorithms: the kinds that everybody knows and deemed so simple that it would never even occur to try to optimize them in the first place. These optimizations are simple and instructive and can very much be adopted elsewhere. And they are surprisingly not as rare as you’d think.</p><p>In this section, we focus on one such fundamental algorithm — <em>binary search</em> — and implement two of its variants that are, depending on the problem size, up to 4x faster than <code>std::lower_bound</code>, while being under just 15 lines of code.</p><p>The first algorithm achieves that by removing <a href="/hpc/pipelining/branching">branches</a>, and the second also optimizes the memory layout to achieve better <a href="/hpc/cpu-cache">cache system</a> performance. This technically disqualifies it from being a drop-in replacement for <code>std::lower_bound</code> as it needs to permute the elements of the array before it can start answering queries — but I can’t recall a lot of scenarios where you obtain a sorted array but can’t afford to spend linear time on preprocessing.</p><p>The usual disclaimer: the CPU is a <a href="https://www.7-cpu.com/cpu/Zen2.html">Zen 2</a>, the RAM is a <a href="/hpc/cpu-cache/">DDR4-2666</a>, and the compiler we will be using by default is Clang 10. The performance on your machine may be different, so I highly encourage to <a href="https://godbolt.org/z/14rd5Pnve">go and test it</a> for yourself.</p><span class="anchor" id="binary-search"/><h2><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/binary-search/#binary-search">#</a>Binary Search</h2><p>Here is the standard way of searching for the first element not less than <code>x</code> in a sorted array <code>t</code> of <code>n</code> integers that you can find in any introductory computer science textbook:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">r</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="n">l</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Find the middle element of the search range, compare it to <code>x</code>, shrink the range in half. Beautiful in its simplicity.</p><p>A similar approach is employed by <code>std::lower_bound</code>, except that it needs to be more generic to support containers with non-random-access iterators and thus uses the first element and the size of the search interval instead of the two of its ends. To this end, implementations from both <a href="https://github.com/llvm-mirror/libcxx/blob/78d6a7767ed57b50122a161b91f59f19c9bd0d19/include/algorithm#L4169">Clang</a> and <a href="https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algobase.h#L1023">GCC</a> use this metaprogramming monstrosity:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Compare</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_ForwardIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Tp</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">_LIBCPP_CONSTEXPR_AFTER_CXX17</span> <span class="n">_ForwardIterator</span>
</span></span><span class="line"><span class="cl"><span class="n">__lower_bound</span><span class="p">(</span><span class="n">_ForwardIterator</span> <span class="n">__first</span><span class="p">,</span> <span class="n">_ForwardIterator</span> <span class="n">__last</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__value_</span><span class="p">,</span> <span class="n">_Compare</span> <span class="n">__comp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">_ForwardIterator</span><span class="o">&gt;::</span><span class="n">difference_type</span> <span class="n">difference_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">difference_type</span> <span class="n">__len</span> <span class="o">=</span> <span class="n">_VSTD</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">__len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">difference_type</span> <span class="n">__l2</span> <span class="o">=</span> <span class="n">_VSTD</span><span class="o">::</span><span class="n">__half_positive</span><span class="p">(</span><span class="n">__len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">_ForwardIterator</span> <span class="n">__m</span> <span class="o">=</span> <span class="n">__first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">_VSTD</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">__m</span><span class="p">,</span> <span class="n">__l2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">__comp</span><span class="p">(</span><span class="o">*</span><span class="n">__m</span><span class="p">,</span> <span class="n">__value_</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">__first</span> <span class="o">=</span> <span class="o">++</span><span class="n">__m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">__len</span> <span class="o">-=</span> <span class="n">__l2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="n">__len</span> <span class="o">=</span> <span class="n">__l2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">__first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>If the compiler is successful in removing the abstractions, it compiles to roughly the same machine code and yields roughly the same average latency, which <a href="/hpc/cpu-cache/latency">expectedly</a> grows with the array size:</p><p><figure><img src="../Images/0d8b6b224cf1d3bc705727ef6612ae2a.png" data-original-src="https://en.algorithmica.org/hpc/data-structures/img/search-std.svg"/><figcaption/></figure></p><p>Since most people don’t implement binary search by hand, we will use <code>std::lower_bound</code> from Clang as the baseline.</p><span class="anchor" id="the-bottleneck"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/binary-search/#the-bottleneck">#</a>The Bottleneck</h3><p>Before jumping to the optimized implementations, let’s briefly discuss why binary search is slow in the first place.</p><p>If you run <code>std::lower_bound</code> with <a href="/hpc/profiling/events">perf</a>, you’ll see that it spends most of its time on a <a href="/hpc/architecture/loops">conditional jump</a> instruction:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl">       <span class="err">│35:</span>   <span class="nf">mov</span>    <span class="o">%</span><span class="nb">rax</span><span class="p">,</span><span class="o">%</span><span class="nb">rdx</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">.52</span> <span class="err">│</span>      <span class="nv">sar</span>    <span class="o">%</span><span class="nb">rdx</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">.33</span> <span class="err">│</span>      <span class="nv">lea</span>    <span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">,</span><span class="o">%</span><span class="nb">rdx</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="o">%</span><span class="nb">rcx</span>
</span></span><span class="line"><span class="cl">  <span class="err">4</span><span class="nf">.30</span> <span class="err">│</span>      <span class="nv">cmp</span>    <span class="p">(</span><span class="o">%</span><span class="nb">rcx</span><span class="p">),</span><span class="o">%</span><span class="nb">edi</span>
</span></span><span class="line"><span class="cl"> <span class="err">65</span><span class="nf">.39</span> <span class="err">│</span>    <span class="err">↓</span> <span class="nv">jle</span>    <span class="nv">b0</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">.07</span> <span class="err">│</span>      <span class="nv">sub</span>    <span class="o">%</span><span class="nb">rdx</span><span class="p">,</span><span class="o">%</span><span class="nb">rax</span>
</span></span><span class="line"><span class="cl">  <span class="err">9</span><span class="nf">.32</span> <span class="err">│</span>      <span class="nv">lea</span>    <span class="mh">0x4</span><span class="p">(</span><span class="o">%</span><span class="nb">rcx</span><span class="p">),</span><span class="o">%</span><span class="nb">rsi</span>
</span></span><span class="line"><span class="cl">  <span class="err">0</span><span class="nf">.06</span> <span class="err">│</span>      <span class="nv">dec</span>    <span class="o">%</span><span class="nb">rax</span>
</span></span><span class="line"><span class="cl">  <span class="err">1</span><span class="nf">.37</span> <span class="err">│</span>      <span class="nv">test</span>   <span class="o">%</span><span class="nb">rax</span><span class="p">,</span><span class="o">%</span><span class="nb">rax</span>
</span></span><span class="line"><span class="cl">  <span class="err">1</span><span class="nf">.11</span> <span class="err">│</span>    <span class="err">↑</span> <span class="nv">jg</span>     <span class="mi">35</span>
</span></span></code></pre></div><p>This <a href="/hpc/">pipeline stall</a> stops the search from progressing, and it is mainly caused by two <a href="/hpc/pipelining/hazards">factors</a>:</p><ul><li>We suffer a <em>control hazard</em> because we have a <a href="/hpc/pipelining/branching">branch</a> that is impossible to predict (queries and keys are drawn independently at random), and the processor has to halt for 10-15 cycles to flush the pipeline and fill it back on each branch mispredict.</li><li>We suffer a <em>data hazard</em> because we have to wait for the preceding comparison to complete, which in turn waits for one of its operands to be fetched from the memory — and it <a href="/hpc/cpu-cache/latency">may take</a> anywhere between 0 and 300 cycles, depending on where it is located.</li></ul><p>Now, let’s try to get rid of these obstacles one by one.</p><span class="anchor" id="removing-branches"/><h2><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/binary-search/#removing-branches">#</a>Removing Branches</h2><p>We can replace branching with <a href="/hpc/pipelining/branchless">predication</a>. To make the task easier, we can adopt the STL approach and rewrite the loop using the first element and the size of the search interval (instead of its first and last element):</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">half</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">half</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">base</span> <span class="o">+=</span> <span class="n">half</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">len</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">half</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">len</span> <span class="o">=</span> <span class="n">half</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Note that, on each iteration, <code>len</code> is essentially just halved and then either floored or ceiled, depending on how the comparison went. This conditional update seems unnecessary; to avoid it, we can simply say that it’s always ceiled:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">half</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">half</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">base</span> <span class="o">+=</span> <span class="n">half</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">len</span> <span class="o">-=</span> <span class="n">half</span><span class="p">;</span> <span class="c1">// = ceil(len / 2)
</span></span></span><span class="line"><span class="cl"><span class="c1"/>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This way, we only need to update the first element of the search interval with a <a href="/hpc/pipelining/branchless/">conditional move</a> and halve its size on each iteration:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">half</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">base</span> <span class="o">+=</span> <span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">half</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">half</span><span class="p">;</span> <span class="c1">// will be replaced with a "cmov"
</span></span></span><span class="line"><span class="cl"><span class="c1"/>        <span class="n">len</span> <span class="o">-=</span> <span class="n">half</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Note that this loop is not always equivalent to the standard binary search. Since it always rounds <em>up</em> the size of the search interval, it accesses slightly different elements and may perform one comparison more than needed. Apart from simplifying computations on each iteration, it also makes the number of iterations constant if the array size is constant, removing branch mispredictions completely.</p><p>As typical for predication, this trick is very fragile to compiler optimizations — depending on the compiler and how the function is invoked, it may still leave a branch or generate suboptimal code. It works fine on Clang 10, yielding a 2.5-3x improvement on small arrays:</p><p><figure><img src="../Images/d1de0a9e2468bfe1337d27ec18713602.png" data-original-src="https://en.algorithmica.org/hpc/data-structures/img/search-branchless.svg"/><figcaption/></figure></p><p>One interesting detail is that it performs worse on large arrays. It seems weird: the total delay is dominated by the RAM latency, and since it does roughly the same memory accesses as the standard binary search, it should be roughly the same or even slightly better.</p><p>The real question you need to ask is not why the branchless implementation is worse but why the branchy version is better. It happens because when you have branching, the CPU can <a href="/hpc/pipelining/branching/">speculate</a> on one of the branches and start fetching either the left or the right key before it can even confirm that it is the right one — which effectively acts as implicit <a href="/hpc/cpu-cache/prefetching">prefetching</a>.</p><p>For the branchless implementation, this doesn’t happen, as <code>cmov</code> is treated as every other instruction, and the branch predictor doesn’t try to peek into its operands to predict the future. To compensate for this, we can prefetch the data in software by explicitly requesting the left and right child key:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">half</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">len</span> <span class="o">-=</span> <span class="n">half</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">__builtin_prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="p">[</span><span class="n">len</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">__builtin_prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="p">[</span><span class="n">half</span> <span class="o">+</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">base</span> <span class="o">+=</span> <span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">half</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">half</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>With prefetching, the performance on large arrays becomes roughly the same:</p><p><figure><img src="../Images/daa69a5238a8e64bfaf7b75f8ce5111a.png" data-original-src="https://en.algorithmica.org/hpc/data-structures/img/search-branchless-prefetch.svg"/><figcaption/></figure></p><p>The graph still grows faster as the branchy version also prefetches “grandchildren,” “great-grandchildren,” and so on — although the usefulness of each new speculative read diminishes exponentially as the prediction is less and less likely to be correct.</p><p>In the branchless version, we could also fetch ahead by more than one layer, but the number of fetches we’d need also grows exponentially. Instead, we will try a different approach to optimize memory operations.</p><span class="anchor" id="optimizing-the-layout"/><h2><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/binary-search/#optimizing-the-layout">#</a>Optimizing the Layout</h2><p>The memory requests we perform during binary search form a very specific access pattern:</p><p><figure><img src="../Images/ba0f19f678d02d700f8434f1b6859735.png" data-original-src="https://en.algorithmica.org/hpc/data-structures/img/binary-search.png"/><figcaption/></figure></p><p>How likely is it that the elements on each request are cached? How good is their <a href="/hpc/external-memory/locality/">data locality</a>?</p><ul><li><em>Spatial locality</em> seems to be okay for the last 3 to 4 requests that are likely to be on the same <a href="/hpc/cpu-cache/cache-lines">cache line</a> — but all the previous requests require huge memory jumps.</li><li><em>Temporal locality</em> seems to be okay for the first dozen or so requests — there aren’t that many different comparison sequences of this length, so we will be comparing against the same middle elements over and over, which are likely to be cached.</li></ul><p>To illustrate how important the second type of cache sharing is, let’s try to pick the element we will compare to on each iteration randomly among the elements of the search interval, instead of the middle one:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">r</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="n">l</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><a href="#appendix-random-binary-search">Theoretically</a>, this randomized binary search is expected to do 30-40% more comparisons than the normal one, but on a real computer, the running time goes ~6x on large arrays:</p><p><figure><img src="../Images/3d703a992e5db0ba9b92db99c332f6ce.png" data-original-src="https://en.algorithmica.org/hpc/data-structures/img/search-random.svg"/><figcaption/></figure></p><p>This isn’t just caused by the <code>rand()</code> call being slow. You can clearly see the point on the L2-L3 boundary where memory latency outweighs the random number generation and <a href="/hpc/arithmetic/division">modulo</a>. The performance degrades because all of the fetched elements are unlikely to be cached and not just some small suffix of them.</p><p>Another potential negative effect is that of <a href="/hpc/cpu-cache/associativity">cache associativity</a>. If the array size is a multiple of a large power of two, then the indices of these “hot” elements will also be divisible by some large powers of two and map to the same cache line, kicking each other out. For example, binary searching over arrays of size $2^{20}$ takes about ~360ns per query while searching over arrays of size $(2^{20} + 123)$ takes ~300ns — a 20% difference. There are <a href="https://en.wikipedia.org/wiki/Fibonacci_search_technique">ways</a> to fix this problem, but to not get distracted from more pressing matters, we are just going to ignore it: all array sizes we use are in the form of $\lfloor 1.17^k \rfloor$ for integer $k$ so that any cache side effects are unlikely.</p><p>The real problem with our memory layout is that it doesn’t make the most efficient use of temporal locality because it groups hot and cold elements together. For example, we likely store the element $\lfloor n/2 \rfloor$, which we request the first thing on each query, in the same cache line with $\lfloor n/2 \rfloor + 1$, which we almost never request.</p><p>Here is the heatmap visualizing the expected frequency of comparisons for a 31-element array:</p><p><figure><img src="../Images/97149b2f72e5c7dd2e42f068f661650a.png" data-original-src="https://en.algorithmica.org/hpc/data-structures/img/binary-heat.png"/><figcaption/></figure></p><p>So, ideally, we’d want a memory layout where hot elements are grouped with hot elements, and cold elements are grouped with cold elements. And we can achieve this if we permute the array in a more cache-friendly way by renumbering them. The numeration we will use is actually half a millennium old, and chances are, you already know it.</p><span class="anchor" id="eytzinger-layout"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/binary-search/#eytzinger-layout">#</a>Eytzinger Layout</h3><p><strong>Michaël Eytzinger</strong> is a 16th-century Austrian nobleman known for his work on genealogy, particularly for a system for numbering ancestors called <em>ahnentafel</em> (German for “ancestor table”).</p><p>Ancestry mattered a lot back then, but writing down that data was expensive. <em>Ahnentafel</em> allows displaying a person’s genealogy compactly, without wasting extra space by drawing diagrams.</p><p>It lists a person’s direct ancestors in a fixed sequence of ascent. First, the person themselves is listed as number 1, and then, recursively, for each person numbered $k$, their father is listed as $2k$ and their mother as $(2k+1)$.</p><p>Here is the example for <a href="https://en.wikipedia.org/wiki/Paul_I_of_Russia">Paul I</a>, the great-grandson of <a href="https://en.wikipedia.org/wiki/Peter_the_Great">Peter the Great</a>:</p><ol><li>Paul I</li><li>Peter III (Paul’s father)</li><li><a href="https://en.wikipedia.org/wiki/Catherine_the_Great">Catherine II</a> (Paul’s mother)</li><li>Charles Frederick (Peter’s father, Paul’s paternal grandfather)</li><li>Anna Petrovna (Peter’s mother, Paul’s paternal grandmother)</li><li>Christian August (Catherine’s father, Paul’s maternal grandfather)</li><li>Johanna Elisabeth (Catherine’s mother, Paul’s maternal grandmother)</li></ol><p>Apart from being compact, it has some nice properties, like that all even-numbered persons are male and all odd-numbered (possibly except for 1) are female. One can also find the number of a particular ancestor only knowing the genders of their descendants. For example, Peter the Great’s bloodline is Paul I → Peter III → Anna Petrovna → Peter the Great, so his number should be $((1 \times 2) \times 2 + 1) \times 2 = 10$.</p><p><strong>In computer science</strong>, this enumeration has been widely used for implicit (pointer-free) implementations of heaps, segment trees, and other binary tree structures — where instead of names, it stores underlying array items.</p><p>Here is how this layout looks when applied to binary search:</p><p><figure><img src="../Images/e9da87bd9fd823f9afa85785500ce7a4.png" data-original-src="https://en.algorithmica.org/hpc/data-structures/img/eytzinger.png"/><figcaption>Note that the tree is slightly imbalanced (because of the last layer is continuous)</figcaption></figure></p><p>When searching in this layout, we just need to start from the first element of the array, and then on each iteration jump to either $2 k$ or $(2k + 1)$, depending on how the comparison went:</p><p><figure><img src="../Images/228f35b59f050f682d228f93babb8656.png" data-original-src="https://en.algorithmica.org/hpc/data-structures/img/eytzinger-search.png"/><figcaption/></figure></p><p>You can immediately see how its temporal locality is better (and, in fact, theoretically optimal) as the elements closer to the root are closer to the beginning of the array and thus are more likely to be fetched from the cache.</p><p><figure><img src="../Images/d7f49b3b16fdf4021d6bf5a913e91021.png" data-original-src="https://en.algorithmica.org/hpc/data-structures/img/eytzinger-heat.png"/><figcaption/></figure></p><p>Another way to look at it is that we write every even-indexed element to the end of the new array, then write every even-indexed element of the remaining ones right before them, and so on, until we place the root as the first element.</p><span class="anchor" id="construction"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/binary-search/#construction">#</a>Construction</h3><p>To construct the Eytzinger array, we could do this even-odd <a href="/hpc/simd/shuffling/#permutations-and-lookup-tables">filtering</a> $O(\log n)$ times — and, perhaps, this is the fastest approach — but for brevity, we will instead build it by traversing the original search tree:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// the original sorted array and the eytzinger array we build
</span></span></span><span class="line"><span class="cl"><span class="c1">//              ^ we need one element more because of one-based indexing
</span></span></span><span class="line"><span class="cl"><span class="c1"/>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">eytzinger</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// &lt;- careful running it on multiple arrays
</span></span></span><span class="line"><span class="cl"><span class="c1"/>    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">eytzinger</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">eytzinger</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This function takes the current node number <code>k</code>, recursively writes out all elements to the left of the middle of the search interval, writes out the current element we’d compare against, and then recursively writes out all the elements on the right. It seems a bit complicated, but to convince yourself that it works, you only need three observations:</p><ul><li>It writes exactly <code>n</code> elements as we enter the body of <code>if</code> for each <code>k</code> from <code>1</code> to <code>n</code> just once.</li><li>It writes out sequential elements from the original array as it increments the <code>i</code> pointer each time.</li><li>By the time we write the element at node <code>k</code>, we will have already written all the elements to its left (exactly <code>i</code>).</li></ul><p>Despite being recursive, it is actually quite fast as all the memory reads are sequential, and the memory writes are only in $O(\log n)$ different memory blocks at a time. Maintaining the permutation is both logically and computationally harder to maintain though: adding an element to a sorted array only requires shifting a suffix of its elements one position to the right, while Eytzinger array practically needs to be rebuilt from scratch.</p><p>Note that this traversal and the resulting permutation are not exactly equivalent to the “tree” of vanilla binary search: for example, the left child subtree may be larger than the right child subtree — up to twice as large — but it doesn’t matter much since both approaches result in the same $\lceil \log_2 n \rceil$ tree depth.</p><p>Also note that the Eytzinger array is one-indexed — this will be important for performance later. You can put in the zeroth element the value that you want to be returned in the case when the lower bound doesn’t exist (similar to <code>a.end()</code> for <code>std::lower_bound</code>).</p><span class="anchor" id="search-implementation"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/binary-search/#search-implementation">#</a>Search Implementation</h3><p>We can now descend this array using only indices: we just start with $k=1$ and execute $k := 2k$ if we need to go left and $k := 2k + 1$ if we need to go right. We don’t even need to store and recalculate the search boundaries anymore. This simplicity also lets us avoid branching:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">);</span>
</span></span></code></pre></div><p>The only problem arises when we need to restore the index of the resulting element, as $k$ does not directly point to it. Consider this example (its corresponding tree is listed above):</p><pre class="center-pre">
    array:  0 1 2 3 4 5 6 7 8 9                            
eytzinger:  <u>6</u> <u>3</u> 7 <u>1</u> 5 8 9 0 <u>2</u> 4                            
1st range:  ------------?------  k := 2*k     = 2   (6 ≥ 3)
2nd range:  ------?------        k := 2*k     = 4   (3 ≥ 3)
3rd range:  --?----              k := 2*k + 1 = 9   (1 &lt; 3)
4th range:      ?--              k := 2*k + 1 = 19  (2 &lt; 3)
5th range:        !                                        
</pre><p>Here we query the array of $[0, …, 9]$ for the lower bound of $x=3$. We compare it against $6$, $3$, $1$, and $2$, go left-left-right-right, and end up with $k = 19$, which isn’t even a valid array index.</p><p>The trick is to notice that, unless the answer is the last element of the array, we compare $x$ against it at some point, and after we’ve learned that it is not less than $x$, we go left exactly once and then keep going right until we reach a leaf (because we will only be comparing $x$ against lesser elements). Therefore, to restore the answer, we just need to “cancel” some number of right turns and then one more.</p><p>This can be done in an elegant way by observing that the right turns are recorded in the binary representation of $k$ as 1-bits, and so we just need to find the number of trailing 1s in the binary representation and right-shift $k$ by exactly that number of bits plus one. To do this, we can invert the number (<code>~k</code>) and call the “find first set” instruction:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">&gt;&gt;=</span> <span class="n">__builtin_ffs</span><span class="p">(</span><span class="o">~</span><span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>We run it, and… well, it doesn’t look <em>that</em> good:</p><p><figure><img src="../Images/968d4f0e9353467d25cbc991c2c23c85.png" data-original-src="https://en.algorithmica.org/hpc/data-structures/img/search-eytzinger.svg"/><figcaption/></figure></p><p>The latency on smaller arrays is on par with the branchless binary search implementation — which isn’t surprising as it is just two lines of code — but it starts taking off much sooner. The reason is that the Eytzinger binary search doesn’t get the advantage of spatial locality: the last 3-4 elements we compare against are not in the same cache line anymore, and we have to fetch them separately.</p><p>If you think about it deeper, you might object that the improved temporal locality should compensate for that. Before, we were using only about $\frac{1}{16}$-th of the cache line to store one hot element, and now we are using all of it, so the effective cache size is larger by a factor of 16, which lets us cover $\log_2 16 = 4$ more first requests.</p><p>But if you think about it more, you understand that this isn’t enough compensation. Caching the other 15 elements wasn’t completely useless, and also, the hardware prefetcher could fetch the neighboring cache lines of our requests. If this was one of our last requests, the rest of what we will be reading will probably be cached elements. So actually, the last 6-7 accesses are likely to be cached, not 3-4.</p><p>It seems like we did an overall stupid thing switching to this layout, but there is a way to make it worthwhile.</p><span class="anchor" id="prefetching"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/binary-search/#prefetching">#</a>Prefetching</h3><p>To hide the memory latency, we can use software prefetching similar to how we did for branchless binary search. But instead of issuing two separate prefetch instructions for the left and right child nodes, we can notice that they are neighbors in the Eytzinger array: one has index $2 k$ and the other $(2k + 1)$, so they are likely in the same cache line, and we can use just one instruction.</p><p>This observation extends to the grand-children of node $k$ — they are also stored sequentially:</p><pre tabindex="0"><code>2 * 2 * k           = 4 * k
2 * 2 * k + 1       = 4 * k + 1
2 * (2 * k + 1)     = 4 * k + 2
2 * (2 * k + 1) + 1 = 4 * k + 3
</code></pre><p>Their cache line can also be fetched with one instruction. Interesting… what if we continue this, and instead of fetching direct children, we fetch ahead as many descendants as we can cramp into one cache line? That would be $\frac{64}{4} = 16$ elements, our great-great-grandchildren with indices from $16k$ to $(16k + 15)$.</p><p>Now, if we prefetch just one of these 16 elements, we will probably only get some but not all of them, as they may cross a cache line boundary. We can prefetch the first <em>and</em> the last element, but to get away with just one memory request, we need to notice that the index of the first element, $16k$, is divisible by $16$, so its memory address will be the base address of the array plus something divisible by $16 \cdot 4 = 64$, the cache line size. If the array were to begin on a cache line, then these $16$ great-great-grandchildren elements will be guaranteed to be on a single cache line, which is just what we needed.</p><p>Therefore, we only need to <a href="/hpc/cpu-cache/alignment">align</a> the array:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">aligned_alloc</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</span></span></code></pre></div><p>And then prefetch the element indexed $16 k$ on each iteration:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">__builtin_prefetch</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="mi">16</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">&gt;&gt;=</span> <span class="n">__builtin_ffs</span><span class="p">(</span><span class="o">~</span><span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The performance on large arrays improves 3-4x from the previous version and ~2x compared to <code>std::lower_bound</code>. Not bad for just two more lines of code:</p><p><figure><img src="../Images/03052e594c2dc64bc4d19a90ee17b8cb.png" data-original-src="https://en.algorithmica.org/hpc/data-structures/img/search-eytzinger-prefetch.svg"/><figcaption/></figure></p><p>Essentially, what we do here is hide the latency by prefetching four steps ahead and overlapping memory requests. Theoretically, if the compute didn’t matter, we would expect a ~4x speedup, but in reality, we get a somewhat more moderate speedup.</p><p>We can also try to prefetch further than that four steps ahead, and we don’t even have to use more than one prefetch instruction for that: we can try to request only the first cache line and rely on the hardware to prefetch its neighbors. This trick may or may not improve actual performance — depends on the hardware:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">__builtin_prefetch</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="mi">32</span><span class="p">);</span>
</span></span></code></pre></div><p>Also, note that the last few prefetch requests are actually not needed, and in fact, they may even be outside the memory region allocated for the program. On most modern CPUs, invalid prefetch instructions get converted into no-ops, so it isn’t a problem, but on some platforms, this may cause a slowdown, so it may make sense, for example, to split off the last ~4 iterations from the loop to try to remove them.</p><p>This prefetching technique allows us to read up to four elements ahead, but it doesn’t really come for free — we are effectively trading off excess memory <a href="/hpc/cpu-cache/bandwidth">bandwidth</a> for reduced <a href="/hpc/cpu-cache/latency">latency</a>. If you run more than one instance at a time on separate hardware threads or just any other memory-intensive computation in the background, it will significantly <a href="/hpc/cpu-cache/sharing">affect</a> the benchmark performance.</p><p>But we can do better. Instead of fetching four cache lines at a time, we could fetch four times <em>fewer</em> cache lines. And in the <a href="../s-tree">next section</a>, we will explore the approach.</p><span class="anchor" id="removing-the-last-branch"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/binary-search/#removing-the-last-branch">#</a>Removing the Last Branch</h3><p>Just one finishing touch: did you notice the bumpiness of the Eytzinger search? This isn’t random noise — let’s zoom in:</p><p><figure><img src="../Images/98293c45b3cc644c79feae3d4ef2b8c9.png" data-original-src="https://en.algorithmica.org/hpc/data-structures/img/search-eytzinger-small.svg"/><figcaption/></figure></p><p>The latency is ~10ns higher for the array sizes in the form of $1.5 \cdot 2^k$. These are mispredicted branches from the loop itself — the last branch, to be exact. When the array size is far from a power of two, it is hard to predict whether the loop will make $\lfloor \log_2 n \rfloor$ or $\lfloor \log_2 n \rfloor + 1$ iterations, so we have a 50% chance to suffer exactly one branch mispredict.</p><p>One way to address it is to pad the array with infinities to the closest power of two, but this wastes memory. Instead, we get rid of that last branch by always executing a constant minimum number of iterations and then using predication to optionally make the last comparison against some dummy element — that is guaranteed to be less than $x$ so that its comparison will be canceled:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// an element that is less than x
</span></span></span><span class="line"><span class="cl"><span class="c1"/><span class="n">iters</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">__lg</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iters</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">loc</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">?</span> <span class="n">t</span> <span class="o">+</span> <span class="nl">k</span> <span class="p">:</span> <span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">loc</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">&gt;&gt;=</span> <span class="n">__builtin_ffs</span><span class="p">(</span><span class="o">~</span><span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The graph is now smooth, and on small arrays, it is just a couple of cycles slower than the branchless binary search:</p><p><figure><img src="../Images/361967de1a95a2729ca8023b6b8c060d.png" data-original-src="https://en.algorithmica.org/hpc/data-structures/img/search-eytzinger-branchless.svg"/><figcaption/></figure></p><p>Interestingly, now GCC fails to replace the branch with <code>cmov</code>, but Clang doesn’t. 1-1.</p><span class="anchor" id="appendix-random-binary-search"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/binary-search/#appendix-random-binary-search">#</a>Appendix: Random Binary Search</h3><p>By the way, finding the exact expected number of comparisons for random binary search is quite an interesting math problem in and of itself. Try solving it yourself first!</p><p>The way to compute it <em>algorithmically</em> is through dynamic programming. If we denote $f_n$ as the expected number of comparisons to find a random lower bound on a search interval of size $n$, it can be calculated from the previous $f_n$ by considering all the $(n - 1)$ possible splits:</p>$$
f_n = \sum_{l = 1}^{n - 1} \frac{1}{n-1} \cdot \left( f_l \cdot \frac{l}{n} + f_{n - l} \cdot \frac{n - l}{n} \right) + 1
$$
Directly applying this formula gives us an $O(n^2)$ algorithm, but we can optimize it by rearranging the sum like this:
$$
\begin{aligned}
f_n &amp;= \sum_{i = 1}^{n - 1} \frac{ f_i \cdot i + f_{n - i} \cdot (n - i) }{ n \cdot (n - 1) } + 1
\\ &amp;= \frac{2}{n \cdot (n - 1)} \cdot \sum_{i = 1}^{n - 1} f_i \cdot i + 1
\end{aligned}
$$
To update $f_n$, we only need to calculate the sum of $f_i \cdot i$ for all $i &lt; n$. To do that, let’s introduce two new variables:
$$
g_n = f_n \cdot n,
\;\;
s_n = \sum_{i=1}^{n} g_n
$$
Now they can be sequentially calculated as:
$$
\begin{aligned}
g_n &amp;= f_n \cdot n
     = \frac{2}{n-1} \cdot \sum_{i = 1}^{n - 1} g_i + n
= \frac{2}{n - 1} \cdot s_{n - 1} + n
\\ s_n &amp;= s_{n - 1} + g_n
\end{aligned}

 $$
This way we get an $O(n)$ algorithm, but we can do even better. Let’s substitute $g_n$ in the update formula for $s_n$:
$$
\begin{aligned}
s_n &amp;= s_{n - 1} + \frac{2}{n - 1} \cdot s_{n - 1} + n
\\ &amp;= (1 + \frac{2}{n - 1}) \cdot s_{n - 1} + n
\\ &amp;= \frac{n + 1}{n - 1} \cdot s_{n - 1} + n
\end{aligned}
$$<p>The next trick is more complicated. We define $r_n$ like this:
$$
\begin{aligned}
r_n &amp;= \frac{s_n}{n}
\\  &amp;= \frac{1}{n} \cdot \left(\frac{n + 1}{n - 1} \cdot s_{n - 1} + n\right)
\\ &amp;= \frac{n + 1}{n} \cdot \frac{s_{n - 1}}{n - 1} + 1
\\ &amp;= \left(1 + \frac{1}{n}\right) \cdot r_{n - 1} + 1
\end{aligned}
$$
We can substitute it into the formula we got for $g_n$ before:
$$
g_n = \frac{2}{n - 1} \cdot s_{n - 1} + n = 2 \cdot r_{n - 1} + n
$$
Recalling that $g_n = f_n \cdot n$, we can express $r_{n - 1}$ using $f_n$:
$$
f_n \cdot n = 2 \cdot r_{n - 1} + n
\implies
r_{n - 1} = \frac{(f_n - 1) \cdot n}{2}
$$
Final step. We’ve just expressed $r_n$ through $r_{n - 1}$ and $r_{n - 1}$ through $f_n$. This lets us express $f_{n + 1}$ through $f_n$:
$$
\begin{aligned}
&amp;&amp;\quad r_n &amp;= \left(1 + \frac{1}{n}\right) \cdot r_{n - 1} + 1
\\ &amp;\Rightarrow &amp; \frac{(f_{n + 1} - 1) \cdot (n + 1)}{2} &amp;= \left(1 + \frac{1}{n}\right) \cdot \frac{(f_n - 1) \cdot n}{2} + 1
\\ &amp;&amp;&amp;= \frac{n + 1}{2} \cdot (f_n - 1) + 1
\\ &amp;\Rightarrow &amp; (f_{n + 1} - 1) &amp;= (f_{n} - 1) + \frac{2}{n + 1}
\\ &amp;\Rightarrow &amp;f_{n + 1} &amp;= f_{n} + \frac{2}{n + 1}
\\ &amp;\Rightarrow &amp;f_{n} &amp;= f_{n - 1} + \frac{2}{n}
\\ &amp;\Rightarrow &amp;f_{n} &amp;= \sum_{k = 2}^{n} \frac{2}{k}
\end{aligned}
$$</p><p>The last expression is double the <a href="https://en.wikipedia.org/wiki/Harmonic_series_(mathematics)">harmonic series</a>, which is well known to approximate $\ln n$ as $n \to \infty$. Therefore, the random binary search will perform $\frac{2 \ln n}{\log_2 n} = 2 \ln 2 \approx 1.386$ more comparisons compared to the normal one.</p><span class="anchor" id="acknowledgements"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/data-structures/binary-search/#acknowledgements">#</a>Acknowledgements</h3><p>The article is loosely based on “<a href="https://arxiv.org/pdf/1509.05053.pdf">Array Layouts for Comparison-Based Searching</a>” by Paul-Virak Khuong and Pat Morin. It is 46 pages long and discusses these and many other (less successful) approaches in more detail. I highly recommend also checking it out — this is one of my favorite performance engineering papers.</p><p>Thanks to Marshall Lochbaum for <a href="https://github.com/algorithmica-org/algorithmica/issues/57">providing</a> the proof for the random binary search. No way I could do it myself.</p><p>I also stole these lovely layout visualizations from some blog a long time ago, but I don’t remember the name of the blog and what license they had, and inverse image search doesn’t find them anymore. If you don’t sue me, thank you, whoever you are!</p></article><div class="nextprev"><div class="left"><a href="https://en.algorithmica.org/hpc/data-structures/" id="prev-article">← ../Data Structures Case Studies</a></div><div class="right"><a href="https://en.algorithmica.org/hpc/data-structures/s-tree/" id="next-article">Static B-Trees →</a></div></div>    
</body>
</html>