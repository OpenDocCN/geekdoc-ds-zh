- en: 18.5Â Equality, Ordering, and HashingğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18.5 ç­‰ä»·æ€§ã€é¡ºåºå’Œå“ˆå¸ŒğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/orderability.html](https://dcic-world.org/2025-08-27/orderability.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/orderability.html](https://dcic-world.org/2025-08-27/orderability.html)
- en: '| Â Â Â Â [18.5.1Â Converting Values to Ordered Values](#%28part._hashing-values%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â [18.5.1 å°†å€¼è½¬æ¢ä¸ºæœ‰åºå€¼](#%28part._hashing-values%29) |'
- en: '| Â Â Â Â [18.5.2Â Hashing in Practice](#%28part._hash-in-practice%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â [18.5.2 å®è·µä¸­çš„å“ˆå¸Œ](#%28part._hash-in-practice%29) |'
- en: '| Â Â Â Â [18.5.3Â Equality and Ordering](#%28part._eq-ord%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â [18.5.3 ç­‰ä»·æ€§å’Œé¡ºåº](#%28part._eq-ord%29) |'
- en: 18.5.1Â Converting Values to Ordered Values[ğŸ”—](#(part._hashing-values) "Link
    to here")
  id: totrans-5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.5.1 å°†å€¼è½¬æ¢ä¸ºæœ‰åºå€¼[ğŸ”—](#(part._hashing-values) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'In [Making Sets Grow on Trees](sets-from-trees.html), we noted that a single
    comparison needs to eliminate an entire set of values. With numbers, we were able
    to accomplish that easily: every bigger or smaller number was excluded by a comparison.
    But what if the data in the set are not actually numbers? Then we have to convert
    an arbitrary datum into a datatype that permits such comparison. This is known
    as hashing.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[åœ¨æ ‘ä¸Šæ„å»ºé›†åˆ](sets-from-trees.html)ä¸­ï¼Œæˆ‘ä»¬æ³¨æ„åˆ°å•ä¸ªæ¯”è¾ƒéœ€è¦æ¶ˆé™¤æ•´ä¸ªå€¼é›†ã€‚å¯¹äºæ•°å­—ï¼Œæˆ‘ä»¬èƒ½å¤Ÿè½»æ¾åœ°åšåˆ°è¿™ä¸€ç‚¹ï¼šæ¯ä¸ªæ›´å¤§æˆ–æ›´å°çš„æ•°å­—éƒ½é€šè¿‡æ¯”è¾ƒè¢«æ’é™¤ã€‚ä½†å¦‚æœé›†åˆä¸­çš„æ•°æ®å®é™…ä¸Šä¸æ˜¯æ•°å­—å‘¢ï¼Ÿé‚£ä¹ˆæˆ‘ä»¬å¿…é¡»å°†ä»»æ„æ•°æ®è½¬æ¢ä¸ºå…è®¸è¿™ç§æ¯”è¾ƒçš„æ•°æ®ç±»å‹ã€‚è¿™è¢«ç§°ä¸ºå“ˆå¸Œã€‚
- en: 'A hash function consumes an arbitrary value and produces a comparable representation
    of it (its hash)â€”<wbr>most commonly (but not strictly necessarily), a number.
    A hash function must naturally be deterministic: a fixed value should always yield
    the same hash (otherwise, we might conclude that an element in the set is not
    actually in it, etc.). Particular uses may need additional properties, as we discuss
    in [Equality and Ordering](#%28part._eq-ord%29).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: å“ˆå¸Œå‡½æ•°æ¥å—ä»»æ„å€¼å¹¶äº§ç”Ÿå…¶å¯æ¯”è¾ƒçš„è¡¨ç¤ºï¼ˆå…¶å“ˆå¸Œå€¼ï¼‰â€”â€”æœ€å¸¸è§ï¼ˆä½†ä¸æ˜¯ä¸¥æ ¼å¿…è¦ï¼‰ï¼Œæ˜¯ä¸€ä¸ªæ•°å­—ã€‚å“ˆå¸Œå‡½æ•°å¿…é¡»æ˜¯ç¡®å®šçš„ï¼šå›ºå®šçš„å€¼åº”è¯¥æ€»æ˜¯äº§ç”Ÿç›¸åŒçš„å“ˆå¸Œå€¼ï¼ˆå¦åˆ™ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå¾—å‡ºç»“è®ºï¼Œé›†åˆä¸­çš„æŸä¸ªå…ƒç´ å®é™…ä¸Šä¸åœ¨å…¶ä¸­ï¼Œç­‰ç­‰ï¼‰ã€‚ç‰¹å®šçš„ç”¨é€”å¯èƒ½éœ€è¦é¢å¤–çš„å±æ€§ï¼Œæ­£å¦‚æˆ‘ä»¬åœ¨[ç­‰ä»·æ€§å’Œé¡ºåº](#%28part._eq-ord%29)ä¸­è®¨è®ºçš„é‚£æ ·ã€‚
- en: Let us now consider how one can compute hashes. If the input datatype is a number,
    it can serve as its own hash. Comparison simply uses numeric comparison (e.g.,
    `<`). Then, transitivity of `<` ensures that if an element \(A\) is less than
    another element \(B\), then \(A\) is also less than all the other elements bigger
    than \(B\).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹å¦‚ä½•è®¡ç®—å“ˆå¸Œå€¼ã€‚å¦‚æœè¾“å…¥çš„æ•°æ®ç±»å‹æ˜¯æ•°å­—ï¼Œå®ƒå¯ä»¥ä½œä¸ºè‡ªå·±çš„å“ˆå¸Œå€¼ã€‚æ¯”è¾ƒç®€å•åœ°ä½¿ç”¨æ•°å€¼æ¯”è¾ƒï¼ˆä¾‹å¦‚ï¼Œ`<`ï¼‰ã€‚ç„¶åï¼Œ`<` çš„ä¼ é€’æ€§ç¡®ä¿å¦‚æœä¸€ä¸ªå…ƒç´ 
    \(A\) å°äºå¦ä¸€ä¸ªå…ƒç´  \(B\)ï¼Œé‚£ä¹ˆ \(A\) ä¹Ÿå°äºæ‰€æœ‰æ¯” \(B\) å¤§çš„å…ƒç´ ã€‚
- en: 'Suppose instead the input is a string. We can of course use the principle above
    for strings: e.g., replacing number inequality with string inequality. Strings
    have a lexicographic (or â€œalphabeticâ€) ordering that permit them to be treated
    similar to numbers.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾è¾“å…¥æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚æˆ‘ä»¬å½“ç„¶å¯ä»¥ä½¿ç”¨ä¸Šé¢çš„åŸåˆ™æ¥å¤„ç†å­—ç¬¦ä¸²ï¼šä¾‹å¦‚ï¼Œç”¨å­—ç¬¦ä¸²ä¸ç­‰å¼æ›¿æ¢æ•°å­—ä¸ç­‰å¼ã€‚å­—ç¬¦ä¸²æœ‰å­—å…¸åºï¼ˆæˆ–â€œå­—æ¯â€ï¼‰é¡ºåºï¼Œè¿™ä½¿å¾—å®ƒä»¬å¯ä»¥åƒæ•°å­—ä¸€æ ·å¤„ç†ã€‚
- en: But what if we are handed more complex datatypes?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†å¦‚æœæˆ‘ä»¬é‡åˆ°æ›´å¤æ‚çš„æ•°æ®ç±»å‹æ€ä¹ˆåŠï¼Ÿ
- en: 'Before we answer that, consider that in practice numbers are more efficient
    to compare than strings (since comparing two numbers is very nearly constant time).
    Thus, although we could use strings directly, it may be convenient to find a numeric
    representation of strings. We convert each character of the string into a number,
    e.g., using its [code point](https://en.wikipedia.org/wiki/Code_point). Based
    on that, here are two different hash functions:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å›ç­”è¿™ä¸ªé—®é¢˜ä¹‹å‰ï¼Œè€ƒè™‘ä¸€ä¸‹åœ¨å®è·µä¸­æ•°å­—æ¯”å­—ç¬¦ä¸²æ›´é«˜æ•ˆï¼ˆå› ä¸ºæ¯”è¾ƒä¸¤ä¸ªæ•°å­—å‡ ä¹æ€»æ˜¯å¸¸æ•°æ—¶é—´ï¼‰ã€‚å› æ­¤ï¼Œå°½ç®¡æˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨å­—ç¬¦ä¸²ï¼Œä½†æ‰¾åˆ°å­—ç¬¦ä¸²çš„æ•°å€¼è¡¨ç¤ºå¯èƒ½æ›´æ–¹ä¾¿ã€‚æˆ‘ä»¬å°†å­—ç¬¦ä¸²çš„æ¯ä¸ªå­—ç¬¦è½¬æ¢ä¸ºæ•°å­—ï¼Œä¾‹å¦‚ä½¿ç”¨å…¶
    [ç ç‚¹](https://en.wikipedia.org/wiki/Code_point)ã€‚åŸºäºæ­¤ï¼Œè¿™é‡Œæœ‰ä¸¤ä¸ªä¸åŒçš„å“ˆå¸Œå‡½æ•°ï¼š
- en: Consider a list of primes as long as the string. Raise each prime by the corresponding
    number, and multiply the result. For instance, if the string is represented by
    the character codes `[6, 4, 5]` (the first character has code `6`, the second
    one `4`, and the third `5`), we get the hash
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è€ƒè™‘ä¸€ä¸ªä¸å­—ç¬¦ä¸²ä¸€æ ·é•¿çš„ç´ æ•°åˆ—è¡¨ã€‚å°†æ¯ä¸ªç´ æ•°ä¹˜ä»¥ç›¸åº”çš„æ•°å­—ï¼Œç„¶åä¹˜ä»¥ç»“æœã€‚ä¾‹å¦‚ï¼Œå¦‚æœå­—ç¬¦ä¸²ç”±å­—ç¬¦ä»£ç  `[6, 4, 5]` è¡¨ç¤ºï¼ˆç¬¬ä¸€ä¸ªå­—ç¬¦çš„ä»£ç æ˜¯
    `6`ï¼Œç¬¬äºŒä¸ªæ˜¯ `4`ï¼Œç¬¬ä¸‰ä¸ªæ˜¯ `5`ï¼‰ï¼Œæˆ‘ä»¬å¾—åˆ°çš„å“ˆå¸Œå€¼æ˜¯
- en: '[PRE0]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: or `16200000`.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æˆ– `16200000`ã€‚
- en: Simply add together all the character codes. For the above example, this would
    correspond to the has
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ç®€å•åœ°å°†æ‰€æœ‰å­—ç¬¦ä»£ç ç›¸åŠ ã€‚å¯¹äºä¸Šé¢çš„ä¾‹å­ï¼Œè¿™å¯¹åº”äºå“ˆå¸Œå€¼
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: or `15`.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æˆ– `15`ã€‚
- en: 'The first representation is invertible, using the [Fundamental Theorem of Arithmetic](http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic):
    given the resulting number, we can reconstruct the input unambiguously (i.e.,
    `16200000` can only map to the input above, and none other). This is also known
    as the GÃ¶del encoding. This is computationally expensive. The second encoding
    is, of course, not invertible (e.g., simply permute the characters and, by commutativity,
    the sum will be the same), but computationally much cheaper. It is also easy to
    implement:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ç§è¡¨ç¤ºæ˜¯å¯é€†çš„ï¼Œä½¿ç”¨[ç®—æœ¯åŸºæœ¬å®šç†](http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)ï¼šç»™å®šç»“æœæ•°å­—ï¼Œæˆ‘ä»¬å¯ä»¥æ— æ­§ä¹‰åœ°é‡å»ºè¾“å…¥ï¼ˆå³ï¼Œ`16200000`åªèƒ½æ˜ å°„åˆ°ä¸Šé¢çš„è¾“å…¥ï¼Œä¸èƒ½æ˜¯å…¶ä»–ä»»ä½•è¾“å…¥ï¼‰ã€‚è¿™ä¹Ÿè¢«ç§°ä¸ºå“¥å¾·å°”ç¼–ç ã€‚è¿™æ˜¯è®¡ç®—ä¸Šæ˜‚è´µçš„ã€‚ç¬¬äºŒç§ç¼–ç å½“ç„¶ä¸å¯é€†ï¼ˆä¾‹å¦‚ï¼Œç®€å•åœ°é‡æ–°æ’åˆ—å­—ç¬¦ï¼Œæ ¹æ®äº¤æ¢å¾‹ï¼Œå’Œå°†ä¿æŒä¸å˜ï¼‰ï¼Œä½†åœ¨è®¡ç®—ä¸Šè¦ä¾¿å®œå¾—å¤šã€‚å®ƒä¹Ÿå®¹æ˜“å®ç°ï¼š
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now let us consider more general datatypes. The principle of hashing will be
    similar. If we have a datatype with several variants, we can order the variants
    lexicographically, and use a numeric tag to represent the variants, and recursively
    encode the datum and the variant tag. For each field of a record, we need an ordering
    of the fieldsâ€”<wbr>the lexicographic ordering of the field names sufficesâ€”<wbr>and
    must hash their contents recursively; having done so, we get in effect a string
    of numbers, which we have shown how to handle.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬è€ƒè™‘æ›´ä¸€èˆ¬çš„æ•°æ®ç±»å‹ã€‚å“ˆå¸Œçš„åŸåˆ™å°†æ˜¯ç›¸ä¼¼çš„ã€‚å¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªå…·æœ‰å‡ ä¸ªå˜ä½“çš„æ•°æ®ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰å­—å…¸é¡ºåºå¯¹å˜ä½“è¿›è¡Œæ’åºï¼Œå¹¶ä½¿ç”¨ä¸€ä¸ªæ•°å­—æ ‡ç­¾æ¥è¡¨ç¤ºå˜ä½“ï¼Œç„¶åé€’å½’åœ°ç¼–ç æ•°æ®å’Œå˜ä½“æ ‡ç­¾ã€‚å¯¹äºè®°å½•çš„æ¯ä¸ªå­—æ®µï¼Œæˆ‘ä»¬éœ€è¦å­—æ®µçš„æ’åºâ€”â€”<wbr>å­—æ®µåç§°çš„å­—å…¸é¡ºåºå°±è¶³å¤Ÿäº†â€”â€”<wbr>å¹¶ä¸”å¿…é¡»é€’å½’åœ°å“ˆå¸Œå®ƒä»¬çš„å†…å®¹ï¼›è¿™æ ·åšä¹‹åï¼Œæˆ‘ä»¬å®é™…ä¸Šå¾—åˆ°ä¸€ä¸ªæ•°å­—å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬å·²ç»å±•ç¤ºäº†å¦‚ä½•å¤„ç†å®ƒã€‚
- en: The critical thing to remember is that we donâ€™t actually need a meaningful operation.Observe
    that GÃ¶del encodings are not â€œmeaningfulâ€, either. We donâ€™t actually care if a
    hash function concludes that the hash of `4` is less than the hash of `3`! All
    we need is a function that is
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: éœ€è¦è®°ä½çš„å…³é”®ç‚¹æ˜¯ï¼Œæˆ‘ä»¬å®é™…ä¸Šå¹¶ä¸éœ€è¦ä¸€ä¸ªæœ‰æ„ä¹‰çš„æ“ä½œã€‚è§‚å¯Ÿä¸€ä¸‹ï¼Œå“¥å¾·å°”ç¼–ç ä¹Ÿä¸æ˜¯â€œæœ‰æ„ä¹‰çš„â€ã€‚æˆ‘ä»¬å®é™…ä¸Šå¹¶ä¸å…³å¿ƒä¸€ä¸ªå“ˆå¸Œå‡½æ•°æ˜¯å¦å¾—å‡ºç»“è®ºè¯´`4`çš„å“ˆå¸Œå€¼å°äº`3`çš„å“ˆå¸Œå€¼ï¼æˆ‘ä»¬éœ€è¦çš„åªæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒ
- en: 'non-trivial: not everything should be equal; and'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: éå¹³å‡¡çš„ï¼šä¸æ˜¯æ‰€æœ‰ä¸œè¥¿éƒ½åº”è¯¥ç›¸ç­‰ï¼›å¹¶ä¸”
- en: 'deterministic: every time we ask for a hash, we should get the same answer.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¡®å®šçš„ï¼šæ¯æ¬¡æˆ‘ä»¬è¯·æ±‚ä¸€ä¸ªå“ˆå¸Œå€¼æ—¶ï¼Œæˆ‘ä»¬éƒ½åº”è¯¥å¾—åˆ°ç›¸åŒçš„ç­”æ¡ˆã€‚
- en: Exercise
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do we care about these two properties? Think about what would could go wrong
    if each one was violated.
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸ºä»€ä¹ˆå…³å¿ƒè¿™ä¸¤ä¸ªå±æ€§ï¼Ÿæƒ³æƒ³å¦‚æœæ¯ä¸ªå±æ€§è¢«è¿åä¼šå‘ç”Ÿä»€ä¹ˆã€‚
- en: 18.5.2Â Hashing in Practice[ğŸ”—](#(part._hash-in-practice) "Link to here")
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.5.2 å®é™…ä¸­çš„å“ˆå¸Œ[ğŸ”—](#(part._hash-in-practice) "é“¾æ¥åˆ°æ­¤å¤„")
- en: In practice, programmers do not want hash functions to do what we have described
    above. While GÃ¶del encoding is extremely expensive, even computing `hash-of` takes
    time linear in the size of a string, which can get quite expensive if strings
    are large or we compute hashes often or both.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®è·µä¸­ï¼Œç¨‹åºå‘˜ä¸å¸Œæœ›å“ˆå¸Œå‡½æ•°æ‰§è¡Œæˆ‘ä»¬ä¸Šé¢æè¿°çš„æ“ä½œã€‚è™½ç„¶å“¥å¾·å°”ç¼–ç éå¸¸æ˜‚è´µï¼Œå³ä½¿è®¡ç®—`hash-of`ä¹Ÿéœ€è¦ä¸å­—ç¬¦ä¸²å¤§å°æˆçº¿æ€§å…³ç³»çš„è®¡ç®—æ—¶é—´ï¼Œå¦‚æœå­—ç¬¦ä¸²å¾ˆå¤§æˆ–è€…æˆ‘ä»¬ç»å¸¸è®¡ç®—å“ˆå¸Œå€¼ï¼Œæˆ–è€…ä¸¤è€…å…¼è€Œæœ‰ä¹‹ï¼Œè¿™å¯èƒ½ä¼šç›¸å½“æ˜‚è´µã€‚
- en: Instead, many programming languages do something very pragmatic. They need a
    value that can be compared for equality and ordering [[Equality and Ordering](#%28part._eq-ord%29)].
    Integers, weâ€™ve already seen, already fit this bill very nicely. But how to obtain
    an integer out of arbitrary values, even datatype instances, quickly?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åï¼Œè®¸å¤šç¼–ç¨‹è¯­è¨€é‡‡å–äº†ä¸€ç§éå¸¸å®ç”¨ä¸»ä¹‰çš„æ–¹æ³•ã€‚å®ƒä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥ç”¨äºæ¯”è¾ƒç›¸ç­‰æ€§å’Œæ’åºçš„å€¼ [[ç›¸ç­‰æ€§å’Œæ’åº](#%28part._eq-ord%29)]ã€‚æˆ‘ä»¬å·²ç»çœ‹åˆ°ï¼Œæ•´æ•°å·²ç»éå¸¸å®Œç¾åœ°ç¬¦åˆè¿™ä¸ªè¦æ±‚ã€‚ä½†æ˜¯ï¼Œå¦‚ä½•ä»ä»»æ„å€¼ï¼Œç”šè‡³æ˜¯æ•°æ®ç±»å‹å®ä¾‹ä¸­å¿«é€Ÿè·å¾—ä¸€ä¸ªæ•´æ•°å‘¢ï¼Ÿ
- en: 'Simple: They just use the memory address of the datum. Every value has a memory
    address, and the language can obtain it in constant time by looking up the directory.
    Granted, these values may be allocated anywhere with respect to each other, but
    thatâ€™s okayâ€”<wbr>we only want consistency, not â€œmeaningfulnessâ€.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€å•ï¼šå®ƒä»¬åªæ˜¯ä½¿ç”¨æ•°æ®çš„å†…å­˜åœ°å€ã€‚æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå†…å­˜åœ°å€ï¼Œè¯­è¨€å¯ä»¥é€šè¿‡æŸ¥æ‰¾ç›®å½•åœ¨å¸¸æ•°æ—¶é—´å†…è·å¾—å®ƒã€‚å½“ç„¶ï¼Œè¿™äº›å€¼ç›¸å¯¹äºå½¼æ­¤å¯èƒ½è¢«åˆ†é…åœ¨ä»»ä½•åœ°æ–¹ï¼Œä½†è¿™æ²¡å…³ç³»â€”â€”æˆ‘ä»¬åªæƒ³è¦ä¸€è‡´æ€§ï¼Œè€Œä¸æ˜¯â€œæœ‰æ„ä¹‰æ€§â€ã€‚
- en: In practice, however, things are not quite so simple. For instance, suppose
    we want two structurally equivalent values to have the same hash. If they are
    allocated in different addresses, they will hash differently. Therefore, many
    languages that use such a strategy also allow programmers to write their own hashing
    functions, often to work in conjunction with this built-in notion of hashing.
    These end up looking not too different from the hashing strategies we described
    above. Therefore, some of that complexity is inescapable, especially if a programmer
    wants structural rather than reference equalityâ€”<wbr>which they very often do.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œåœ¨å®è·µä¸­ï¼Œäº‹æƒ…å¹¶ä¸é‚£ä¹ˆç®€å•ã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬å¸Œæœ›ä¸¤ä¸ªç»“æ„ä¸Šç­‰ä»·çš„ä»·å€¼å…·æœ‰ç›¸åŒçš„å“ˆå¸Œå€¼ã€‚å¦‚æœå®ƒä»¬åˆ†é…åœ¨ä¸åŒçš„åœ°å€ï¼Œå®ƒä»¬çš„å“ˆå¸Œå€¼å°†ä¸åŒã€‚å› æ­¤ï¼Œè®¸å¤šä½¿ç”¨è¿™ç§ç­–ç•¥çš„è¯­è¨€ä¹Ÿå…è®¸ç¨‹åºå‘˜ç¼–å†™è‡ªå·±çš„å“ˆå¸Œå‡½æ•°ï¼Œé€šå¸¸ä¸å†…ç½®çš„å“ˆå¸Œæ¦‚å¿µä¸€èµ·ä½¿ç”¨ã€‚è¿™äº›æœ€ç»ˆçœ‹èµ·æ¥ä¸æˆ‘ä»¬ä¸Šé¢æè¿°çš„å“ˆå¸Œç­–ç•¥æ²¡æœ‰å¤ªå¤§åŒºåˆ«ã€‚å› æ­¤ï¼Œä¸€äº›å¤æ‚æ€§æ˜¯ä¸å¯é¿å…çš„ï¼Œå°¤å…¶æ˜¯å¦‚æœç¨‹åºå‘˜æƒ³è¦ç»“æ„ç­‰ä»·è€Œä¸æ˜¯å¼•ç”¨ç­‰ä»·â€”â€”ä»–ä»¬é€šå¸¸æ˜¯è¿™æ ·åšçš„ã€‚
- en: In the rest of this material, we will therefore continue with the simple hash
    function above, for multiple reasons. First, it is sufficient to illustrate how
    hashing works. Second, in practice, when built-in hashing does not suffice, we
    do write (more complex versions of) functions like the above. And finally, because
    itâ€™s all laid bare, itâ€™s easy for us to experiment with.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œåœ¨æœ¬ææ–™çš„å…¶ä½™éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†ç»§ç»­ä½¿ç”¨ä¸Šé¢ç®€å•çš„å“ˆå¸Œå‡½æ•°ï¼Œæœ‰å¤šä¸ªåŸå› ã€‚é¦–å…ˆï¼Œå®ƒè¶³ä»¥è¯´æ˜å“ˆå¸Œæ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚å…¶æ¬¡ï¼Œåœ¨å®è·µä¸­ï¼Œå½“å†…ç½®å“ˆå¸Œä¸è¶³æ—¶ï¼Œæˆ‘ä»¬ç¡®å®ä¼šç¼–å†™ï¼ˆæ›´å¤æ‚çš„ç‰ˆæœ¬ï¼‰åƒä¸Šé¢é‚£æ ·çš„å‡½æ•°ã€‚æœ€åï¼Œå› ä¸ºæ‰€æœ‰è¿™äº›éƒ½æš´éœ²å‡ºæ¥ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“è¿›è¡Œå®éªŒã€‚
- en: 18.5.3Â Equality and Ordering[ğŸ”—](#(part._eq-ord) "Link to here")
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.5.3Â ç­‰ä»·ä¸æ’åº[ğŸ”—](#(part._eq-ord) "é“¾æ¥è‡³æ­¤")
- en: 'What weâ€™ve seen [[A Fine Balance: Tree Surgery](sets-from-trees.html#%28part._sets-from-balanced-trees%29)]
    for the construction of balanced binary search trees is that we need some way
    of putting elements in order. In the examples we used numbers because theyâ€™re
    a very friendly datatype: they have several properties that we take for granted.
    However, not all data have these properties.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨æ„å»ºå¹³è¡¡äºŒå‰æœç´¢æ ‘æ—¶çœ‹åˆ°çš„ [[ç²¾ç»†å¹³è¡¡ï¼šæ ‘æ‰‹æœ¯](sets-from-trees.html#%28part._sets-from-balanced-trees%29)]
    æ˜¯ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹å¼æ¥å¯¹å…ƒç´ è¿›è¡Œæ’åºã€‚åœ¨æˆ‘ä»¬ä½¿ç”¨çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†æ•°å­—ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ä¸€ä¸ªéå¸¸å‹å¥½çš„æ•°æ®ç±»å‹ï¼šå®ƒä»¬å…·æœ‰æˆ‘ä»¬è§†ä¸ºç†æ‰€å½“ç„¶çš„å‡ ä¸ªå±æ€§ã€‚ç„¶è€Œï¼Œå¹¶éæ‰€æœ‰æ•°æ®éƒ½å…·æœ‰è¿™äº›å±æ€§ã€‚
- en: 'The critical property that numbers have is that they are orderable. This follows
    because they are comparable, and the comparison is ternary: it produces three
    answers, â€œless thanâ€, â€œequal toâ€, and â€œgreater thanâ€.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°å­—çš„å…³é”®å±æ€§æ˜¯å®ƒä»¬æ˜¯å¯æ’åºçš„ã€‚è¿™æ˜¯å› ä¸ºå®ƒä»¬æ˜¯å¯æ¯”è¾ƒçš„ï¼Œæ¯”è¾ƒç»“æœæ˜¯ä¸‰å…ƒï¼šå®ƒäº§ç”Ÿä¸‰ä¸ªç­”æ¡ˆï¼Œâ€œå°äºâ€ã€â€œç­‰äºâ€å’Œâ€œå¤§äºâ€ã€‚
- en: 'However, not all data have this property. What are data that might not have
    these properties? Actually, there are multiple possible properties here: Is something
    orderable? Is something even comparable?'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œå¹¶éæ‰€æœ‰æ•°æ®éƒ½å…·æœ‰è¿™ç§å±æ€§ã€‚å“ªäº›æ•°æ®å¯èƒ½ä¸å…·æœ‰è¿™äº›å±æ€§ï¼Ÿå®é™…ä¸Šï¼Œè¿™é‡Œæœ‰å¤šç§å¯èƒ½çš„å±æ€§ï¼šæŸç‰©æ˜¯å¦å¯æ’åºï¼ŸæŸç‰©æ˜¯å¦å¯æ¯”è¾ƒï¼Ÿ
- en: '|  |  | Comparable |  | Orderable |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|  |  | å¯æ¯”è¾ƒ |  | å¯æ’åº |'
- en: '| Numbers |  | Yes (but not Roughnums!) |  | Yes |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| æ•°å­— |  | æ˜¯ï¼ˆä½†ä¸æ˜¯ç²—ç•¥æ•°ï¼ï¼‰ |  | æ˜¯ |'
- en: '| Booleans |  | Yes |  | Yes |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| å¸ƒå°”å€¼ |  | æ˜¯ |  | æ˜¯ |'
- en: '| Data instances |  | Yes |  | Not by default |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| æ•°æ®å®ä¾‹ |  | æ˜¯ |  | é»˜è®¤ä¸ |'
- en: '| Roughnums |  | No |  | Yes |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| ç²—ç•¥æ•° |  | å¦ |  | æ˜¯ |'
- en: '| Functions |  | Not really |  | No |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| å‡½æ•° |  | ä¸å¤ªæ˜¯ |  | å¦ |'
- en: Soâ€¦life is complicated.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥â€¦â€¦ç”Ÿæ´»å¾ˆå¤æ‚ã€‚
- en: That means you could potentially misuse a BBST on the wrong kind of data. Ideally,
    we would want to know if weâ€™re doing this. In Pyretâ€™s type system we chose not
    to build this in, but in some languages, the type system actually lets you capture
    these properties.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€ä½ å¯èƒ½ä¼šåœ¨é”™è¯¯ç±»å‹çš„æ•°æ®ä¸Šè¯¯ç”¨BBSTã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›çŸ¥é“æˆ‘ä»¬æ˜¯å¦åœ¨è¿›è¡Œè¿™é¡¹æ“ä½œã€‚åœ¨Pyretçš„ç±»å‹ç³»ç»Ÿä¸­ï¼Œæˆ‘ä»¬é€‰æ‹©ä¸å°†å…¶å†…ç½®ï¼Œä½†åœ¨æŸäº›è¯­è¨€ä¸­ï¼Œç±»å‹ç³»ç»Ÿå®é™…ä¸Šå…è®¸ä½ æ•è·è¿™äº›å±æ€§ã€‚
- en: In Haskell, for instance, thereâ€™s a mechanism called the type-class; in Java,
    there are interfaces. They arenâ€™t really the same, but theyâ€™re useful to conflate
    for our purposes. Only things that meet a particular interface or type class provide
    certain operations. For instance, in Haskell, if you want to use == or /= (not
    equal), you have to be in the Eq type-class. Thus the comparable datatypes above
    would be part of Eq. Similarly, thereâ€™s a type-class Ord, which ensures the availability
    of (and requires the implementation of) operations like <, >, <=, and >=. In Haskell,
    everything that is Ord must also be Eq, i.e., Eq is weaker than Ord (things can
    be Eq without being Ord). Pyretâ€™s Roughnums contradict thatâ€¦but Haskell is okay
    with it. But if you try to compare two functions in Haskell,
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œåœ¨ Haskell ä¸­ï¼Œæœ‰ä¸€ä¸ªç§°ä¸ºç±»å‹ç±»çš„æœºåˆ¶ï¼›åœ¨ Java ä¸­ï¼Œæœ‰æ¥å£ã€‚å®ƒä»¬å¹¶ä¸å®Œå…¨ç›¸åŒï¼Œä½†ä¸ºäº†æˆ‘ä»¬çš„ç›®çš„ï¼Œå°†å®ƒä»¬åˆå¹¶æ˜¯æœ‰ç”¨çš„ã€‚åªæœ‰æ»¡è¶³ç‰¹å®šæ¥å£æˆ–ç±»å‹ç±»çš„äº‹ç‰©æ‰æä¾›æŸäº›æ“ä½œã€‚ä¾‹å¦‚ï¼Œåœ¨
    Haskell ä¸­ï¼Œå¦‚æœä½ æƒ³ä½¿ç”¨ == æˆ– /=ï¼ˆä¸ç­‰ï¼‰ï¼Œä½ å¿…é¡»å¤„äº Eq ç±»å‹ç±»ä¸­ã€‚å› æ­¤ï¼Œä¸Šè¿°å¯æ¯”è¾ƒçš„æ•°æ®ç±»å‹å°†æ˜¯ Eq çš„ä¸€éƒ¨åˆ†ã€‚åŒæ ·ï¼Œè¿˜æœ‰ä¸€ä¸ªç±»å‹ç±»
    Ordï¼Œå®ƒç¡®ä¿äº† <ã€>ã€<= å’Œ >= ç­‰æ“ä½œçš„å¯ç”¨æ€§å’Œå®ç°ã€‚åœ¨ Haskell ä¸­ï¼Œæ‰€æœ‰æ˜¯ Ord çš„ä¸œè¥¿ä¹Ÿå¿…é¡»æ˜¯ Eqï¼Œå³ Eq æ¯” Ord å¼±ï¼ˆäº‹ç‰©å¯ä»¥æ˜¯
    Eq è€Œä¸æ˜¯ Ordï¼‰ã€‚Pyret çš„ Roughnums ä¸æ­¤ç›¸åâ€¦â€¦ä½† Haskell å¯ä»¥æ¥å—å®ƒã€‚ä½†æ˜¯ï¼Œå¦‚æœä½ å°è¯•åœ¨ Haskell ä¸­æ¯”è¾ƒä¸¤ä¸ªå‡½æ•°ï¼Œ
- en: '| (\x -> x + 1) < (\x -> x) |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| (\x -> x + 1) < (\x -> x) |'
- en: you get an error like
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½ä¼šé‡åˆ°å¦‚ä¸‹é”™è¯¯
- en: '| * No instance for (Ord (Integer -> Integer)) |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| * æ— æ³•å®ä¾‹åŒ– (Ord (Integer -> Integer)) |'
- en: '| Â Â Â Â arising from a use of `<'' |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|   ç”±ä½¿ç”¨`<`å¼•èµ·'
- en: 18.5.1Â Converting Values to Ordered Values[ğŸ”—](#(part._hashing-values) "Link
    to here")
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.5.1 å°†å€¼è½¬æ¢ä¸ºæœ‰åºå€¼[ğŸ”—](#(part._hashing-values) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'In [Making Sets Grow on Trees](sets-from-trees.html), we noted that a single
    comparison needs to eliminate an entire set of values. With numbers, we were able
    to accomplish that easily: every bigger or smaller number was excluded by a comparison.
    But what if the data in the set are not actually numbers? Then we have to convert
    an arbitrary datum into a datatype that permits such comparison. This is known
    as hashing.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[åœ¨æ ‘ä¸Šæ„å»ºé›†åˆ](sets-from-trees.html)ä¸­ï¼Œæˆ‘ä»¬æåˆ°ä¸€ä¸ªæ¯”è¾ƒéœ€è¦æ¶ˆé™¤ä¸€ä¸ªæ•´ä¸ªå€¼é›†ã€‚å¯¹äºæ•°å­—ï¼Œæˆ‘ä»¬èƒ½å¤Ÿè½»æ¾åœ°åšåˆ°è¿™ä¸€ç‚¹ï¼šæ¯ä¸ªæ¯”å®ƒå¤§æˆ–å°çš„æ•°å­—éƒ½ä¼šè¢«æ¯”è¾ƒæ’é™¤ã€‚ä½†æ˜¯ï¼Œå¦‚æœé›†åˆä¸­çš„æ•°æ®å®é™…ä¸Šä¸æ˜¯æ•°å­—å‘¢ï¼Ÿé‚£ä¹ˆæˆ‘ä»¬å¿…é¡»å°†ä»»æ„æ•°æ®è½¬æ¢ä¸ºå…è®¸è¿™ç§æ¯”è¾ƒçš„æ•°æ®ç±»å‹ã€‚è¿™è¢«ç§°ä¸ºå“ˆå¸Œã€‚
- en: 'A hash function consumes an arbitrary value and produces a comparable representation
    of it (its hash)â€”<wbr>most commonly (but not strictly necessarily), a number.
    A hash function must naturally be deterministic: a fixed value should always yield
    the same hash (otherwise, we might conclude that an element in the set is not
    actually in it, etc.). Particular uses may need additional properties, as we discuss
    in [Equality and Ordering](#%28part._eq-ord%29).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: å“ˆå¸Œå‡½æ•°æ¶ˆè€—ä¸€ä¸ªä»»æ„å€¼å¹¶äº§ç”Ÿå…¶å¯æ¯”è¾ƒçš„è¡¨ç¤ºï¼ˆå…¶å“ˆå¸Œå€¼ï¼‰â€”â€”æœ€å¸¸è§ï¼ˆä½†ä¸ä¸¥æ ¼å¿…è¦ï¼‰çš„æ˜¯æ•°å­—ã€‚å“ˆå¸Œå‡½æ•°å¿…é¡»æ˜¯è‡ªç„¶ç¡®å®šçš„ï¼šå›ºå®šå€¼åº”è¯¥æ€»æ˜¯äº§ç”Ÿç›¸åŒçš„å“ˆå¸Œå€¼ï¼ˆå¦åˆ™ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå¾—å‡ºç»“è®ºï¼Œé›†åˆä¸­çš„å…ƒç´ å®é™…ä¸Šä¸åœ¨å…¶ä¸­ç­‰ï¼‰ã€‚ç‰¹å®šçš„ç”¨é€”å¯èƒ½éœ€è¦é¢å¤–çš„å±æ€§ï¼Œæ­£å¦‚æˆ‘ä»¬åœ¨[ç­‰ä»·æ€§å’Œæ’åº](#%28part._eq-ord%29)ä¸­è®¨è®ºçš„é‚£æ ·ã€‚
- en: Let us now consider how one can compute hashes. If the input datatype is a number,
    it can serve as its own hash. Comparison simply uses numeric comparison (e.g.,
    `<`). Then, transitivity of `<` ensures that if an element \(A\) is less than
    another element \(B\), then \(A\) is also less than all the other elements bigger
    than \(B\).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬è€ƒè™‘å¦‚ä½•è®¡ç®—å“ˆå¸Œå€¼ã€‚å¦‚æœè¾“å…¥çš„æ•°æ®ç±»å‹æ˜¯æ•°å­—ï¼Œå®ƒå¯ä»¥ä½œä¸ºè‡ªå·±çš„å“ˆå¸Œå€¼ã€‚æ¯”è¾ƒä»…ä½¿ç”¨æ•°å€¼æ¯”è¾ƒï¼ˆä¾‹å¦‚ï¼Œ`<`ï¼‰ã€‚ç„¶åï¼Œ`<`çš„ä¼ é€’æ€§ç¡®ä¿å¦‚æœä¸€ä¸ªå…ƒç´ 
    \(A\) æ¯”å¦ä¸€ä¸ªå…ƒç´  \(B\) å°ï¼Œé‚£ä¹ˆ \(A\) ä¹Ÿæ¯”æ‰€æœ‰æ¯” \(B\) å¤§çš„å…ƒç´ å°ã€‚
- en: 'Suppose instead the input is a string. We can of course use the principle above
    for strings: e.g., replacing number inequality with string inequality. Strings
    have a lexicographic (or â€œalphabeticâ€) ordering that permit them to be treated
    similar to numbers.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾è¾“å…¥æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚æˆ‘ä»¬å½“ç„¶å¯ä»¥ä½¿ç”¨ä¸Šè¿°åŸåˆ™æ¥å¤„ç†å­—ç¬¦ä¸²ï¼šä¾‹å¦‚ï¼Œç”¨å­—ç¬¦ä¸²ä¸ç­‰å¼æ›¿æ¢æ•°å­—ä¸ç­‰å¼ã€‚å­—ç¬¦ä¸²æœ‰å­—å…¸åºï¼ˆæˆ–â€œå­—æ¯â€ï¼‰æ’åºï¼Œè¿™ä½¿å¾—å®ƒä»¬å¯ä»¥åƒæ•°å­—ä¸€æ ·å¤„ç†ã€‚
- en: But what if we are handed more complex datatypes?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†å¦‚æœæˆ‘ä»¬è¢« handed æ›´å¤æ‚çš„æ•°æ®ç±»å‹å‘¢ï¼Ÿ
- en: 'Before we answer that, consider that in practice numbers are more efficient
    to compare than strings (since comparing two numbers is very nearly constant time).
    Thus, although we could use strings directly, it may be convenient to find a numeric
    representation of strings. We convert each character of the string into a number,
    e.g., using its [code point](https://en.wikipedia.org/wiki/Code_point). Based
    on that, here are two different hash functions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬å›ç­”è¿™ä¸ªé—®é¢˜ä¹‹å‰ï¼Œè€ƒè™‘ä¸€ä¸‹åœ¨å®è·µä¸­ï¼Œæ•°å­—æ¯”å­—ç¬¦ä¸²æ›´é«˜æ•ˆåœ°è¿›è¡Œæ¯”è¾ƒï¼ˆå› ä¸ºæ¯”è¾ƒä¸¤ä¸ªæ•°å­—å‡ ä¹æ¥è¿‘å¸¸æ•°æ—¶é—´ï¼‰ã€‚å› æ­¤ï¼Œå°½ç®¡æˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨å­—ç¬¦ä¸²ï¼Œä½†æ‰¾åˆ°å­—ç¬¦ä¸²çš„æ•°å€¼è¡¨ç¤ºå¯èƒ½æ›´æ–¹ä¾¿ã€‚æˆ‘ä»¬å°†å­—ç¬¦ä¸²çš„æ¯ä¸ªå­—ç¬¦è½¬æ¢ä¸ºæ•°å­—ï¼Œä¾‹å¦‚ï¼Œä½¿ç”¨å…¶
    [ç ç‚¹](https://en.wikipedia.org/wiki/Code_point)ã€‚åŸºäºæ­¤ï¼Œè¿™é‡Œæœ‰ä¸¤ä¸ªä¸åŒçš„å“ˆå¸Œå‡½æ•°ï¼š
- en: Consider a list of primes as long as the string. Raise each prime by the corresponding
    number, and multiply the result. For instance, if the string is represented by
    the character codes `[6, 4, 5]` (the first character has code `6`, the second
    one `4`, and the third `5`), we get the hash
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è€ƒè™‘ä¸€ä¸ªä¸å­—ç¬¦ä¸²ä¸€æ ·é•¿çš„ç´ æ•°åˆ—è¡¨ã€‚å°†æ¯ä¸ªç´ æ•°æå‡åˆ°ç›¸åº”çš„æ•°å­—ï¼Œç„¶åä¹˜ä»¥ç»“æœã€‚ä¾‹å¦‚ï¼Œå¦‚æœå­—ç¬¦ä¸²ç”±å­—ç¬¦ä»£ç  `[6, 4, 5]` è¡¨ç¤ºï¼ˆç¬¬ä¸€ä¸ªå­—ç¬¦çš„ä»£ç æ˜¯
    `6`ï¼Œç¬¬äºŒä¸ªæ˜¯ `4`ï¼Œç¬¬ä¸‰ä¸ªæ˜¯ `5`ï¼‰ï¼Œæˆ‘ä»¬å¾—åˆ°çš„å“ˆå¸Œå€¼
- en: '[PRE3]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: or `16200000`.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æˆ–è€… `16200000`ã€‚
- en: Simply add together all the character codes. For the above example, this would
    correspond to the has
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ç®€å•åœ°å°†æ‰€æœ‰å­—ç¬¦ä»£ç ç›¸åŠ ã€‚å¯¹äºä¸Šé¢çš„ä¾‹å­ï¼Œè¿™å¯¹åº”äºå“ˆå¸Œ
- en: '[PRE4]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: or `15`.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æˆ–è€… `15`ã€‚
- en: 'The first representation is invertible, using the [Fundamental Theorem of Arithmetic](http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic):
    given the resulting number, we can reconstruct the input unambiguously (i.e.,
    `16200000` can only map to the input above, and none other). This is also known
    as the GÃ¶del encoding. This is computationally expensive. The second encoding
    is, of course, not invertible (e.g., simply permute the characters and, by commutativity,
    the sum will be the same), but computationally much cheaper. It is also easy to
    implement:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ç§è¡¨ç¤ºæ˜¯å¯é€†çš„ï¼Œä½¿ç”¨[ç®—æœ¯åŸºæœ¬å®šç†](http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)ï¼šç»™å®šç»“æœæ•°å­—ï¼Œæˆ‘ä»¬å¯ä»¥æ— æ­§ä¹‰åœ°é‡å»ºè¾“å…¥ï¼ˆå³ï¼Œ`16200000`
    åªèƒ½æ˜ å°„åˆ°ä¸Šé¢çš„è¾“å…¥ï¼Œä¸èƒ½æ˜¯å…¶ä»–ä»»ä½•è¾“å…¥ï¼‰ã€‚è¿™ä¹Ÿè¢«ç§°ä¸ºå“¥å¾·å°”ç¼–ç ã€‚è¿™æ˜¯è®¡ç®—ä¸Šæ˜‚è´µçš„ã€‚ç¬¬äºŒç§ç¼–ç å½“ç„¶ä¸å¯é€†ï¼ˆä¾‹å¦‚ï¼Œç®€å•åœ°é‡æ–°æ’åˆ—å­—ç¬¦ï¼Œæ ¹æ®äº¤æ¢å¾‹ï¼Œå’Œå°†ä¿æŒä¸å˜ï¼‰ï¼Œä½†è®¡ç®—ä¸Šè¦ä¾¿å®œå¾—å¤šã€‚å®ƒä¹Ÿå®¹æ˜“å®ç°ï¼š
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now let us consider more general datatypes. The principle of hashing will be
    similar. If we have a datatype with several variants, we can order the variants
    lexicographically, and use a numeric tag to represent the variants, and recursively
    encode the datum and the variant tag. For each field of a record, we need an ordering
    of the fieldsâ€”<wbr>the lexicographic ordering of the field names sufficesâ€”<wbr>and
    must hash their contents recursively; having done so, we get in effect a string
    of numbers, which we have shown how to handle.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬è€ƒè™‘æ›´ä¸€èˆ¬çš„æ•°æ®ç±»å‹ã€‚å“ˆå¸Œçš„åŸåˆ™å°†ç±»ä¼¼ã€‚å¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªå…·æœ‰å‡ ä¸ªå˜ä½“çš„æ•°æ®ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰å­—å…¸é¡ºåºå¯¹å˜ä½“è¿›è¡Œæ’åºï¼Œå¹¶ä½¿ç”¨ä¸€ä¸ªæ•°å­—æ ‡ç­¾æ¥è¡¨ç¤ºå˜ä½“ï¼Œç„¶åé€’å½’åœ°ç¼–ç æ•°æ®å’Œå˜ä½“æ ‡ç­¾ã€‚å¯¹äºè®°å½•çš„æ¯ä¸ªå­—æ®µï¼Œæˆ‘ä»¬éœ€è¦å­—æ®µçš„æ’åºâ€”â€”<wbr>å­—æ®µåç§°çš„å­—å…¸é¡ºåºå°±è¶³å¤Ÿäº†â€”â€”<wbr>å¹¶ä¸”å¿…é¡»é€’å½’åœ°å“ˆå¸Œå®ƒä»¬çš„å†…å®¹ï¼›è¿™æ ·åšä¹‹åï¼Œæˆ‘ä»¬å®é™…ä¸Šå¾—åˆ°ä¸€ä¸ªæ•°å­—å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬å·²ç»å±•ç¤ºäº†å¦‚ä½•å¤„ç†å®ƒã€‚
- en: The critical thing to remember is that we donâ€™t actually need a meaningful operation.Observe
    that GÃ¶del encodings are not â€œmeaningfulâ€, either. We donâ€™t actually care if a
    hash function concludes that the hash of `4` is less than the hash of `3`! All
    we need is a function that is
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: éœ€è¦è®°ä½çš„å…³é”®æ˜¯ï¼Œæˆ‘ä»¬å®é™…ä¸Šä¸éœ€è¦ä¸€ä¸ªæœ‰æ„ä¹‰çš„æ“ä½œã€‚è§‚å¯Ÿä¸€ä¸‹ï¼Œå“¥å¾·å°”ç¼–ç ä¹Ÿä¸æ˜¯â€œæœ‰æ„ä¹‰çš„â€ã€‚æˆ‘ä»¬å®é™…ä¸Šå¹¶ä¸å…³å¿ƒå“ˆå¸Œå‡½æ•°æ˜¯å¦å¾—å‡ºç»“è®ºè¯´ `4` çš„å“ˆå¸Œå€¼å°äº
    `3` çš„å“ˆå¸Œå€¼ï¼æˆ‘ä»¬éœ€è¦çš„åªæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ˜¯
- en: 'non-trivial: not everything should be equal; and'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: éå¹³å‡¡çš„ï¼šä¸æ˜¯æ‰€æœ‰ä¸œè¥¿éƒ½åº”è¯¥ç›¸ç­‰ï¼›
- en: 'deterministic: every time we ask for a hash, we should get the same answer.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¡®å®šæ€§ï¼šæ¯æ¬¡æˆ‘ä»¬è¯·æ±‚å“ˆå¸Œå€¼æ—¶ï¼Œéƒ½åº”è¯¥å¾—åˆ°ç›¸åŒçš„ç­”æ¡ˆã€‚
- en: Exercise
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do we care about these two properties? Think about what would could go wrong
    if each one was violated.
  id: totrans-71
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸ºä»€ä¹ˆå…³å¿ƒè¿™ä¸¤ä¸ªå±æ€§å‘¢ï¼Ÿæƒ³æƒ³å¦‚æœæ¯ä¸ªå±æ€§è¢«è¿åä¼šå‘ç”Ÿä»€ä¹ˆã€‚
- en: 18.5.2Â Hashing in Practice[ğŸ”—](#(part._hash-in-practice) "Link to here")
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.5.2 å®è·µä¸­çš„å“ˆå¸Œ[ğŸ”—](#(part._hash-in-practice) "é“¾æ¥åˆ°æ­¤å¤„")
- en: In practice, programmers do not want hash functions to do what we have described
    above. While GÃ¶del encoding is extremely expensive, even computing `hash-of` takes
    time linear in the size of a string, which can get quite expensive if strings
    are large or we compute hashes often or both.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®è·µä¸­ï¼Œç¨‹åºå‘˜ä¸å¸Œæœ›å“ˆå¸Œå‡½æ•°æ‰§è¡Œæˆ‘ä»¬ä¸Šé¢æè¿°çš„æ“ä½œã€‚è™½ç„¶å“¥å¾·å°”ç¼–ç éå¸¸æ˜‚è´µï¼Œå³ä½¿æ˜¯è®¡ç®— `hash-of` çš„æ—¶é—´ä¹Ÿæ˜¯ä¸å­—ç¬¦ä¸²å¤§å°æˆçº¿æ€§å…³ç³»çš„ï¼Œå¦‚æœå­—ç¬¦ä¸²å¾ˆå¤§æˆ–è€…æˆ‘ä»¬ç»å¸¸è®¡ç®—å“ˆå¸Œå€¼ï¼Œæˆ–è€…ä¸¤è€…å…¼è€Œæœ‰ä¹‹ï¼Œè¿™å¯èƒ½ä¼šç›¸å½“æ˜‚è´µã€‚
- en: Instead, many programming languages do something very pragmatic. They need a
    value that can be compared for equality and ordering [[Equality and Ordering](#%28part._eq-ord%29)].
    Integers, weâ€™ve already seen, already fit this bill very nicely. But how to obtain
    an integer out of arbitrary values, even datatype instances, quickly?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åï¼Œè®¸å¤šç¼–ç¨‹è¯­è¨€åšäº†ä¸€äº›éå¸¸å®ç”¨çš„å¤„ç†ã€‚å®ƒä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥ç”¨äºæ¯”è¾ƒç›¸ç­‰æ€§å’Œæ’åºçš„å€¼ [[ç›¸ç­‰æ€§å’Œæ’åº](#(part._eq-ord%29)]ï¼‰ã€‚æˆ‘ä»¬å·²ç»çœ‹åˆ°ï¼Œæ•´æ•°å·²ç»éå¸¸é€‚åˆè¿™ä¸ªè¦æ±‚ã€‚ä½†æ˜¯å¦‚ä½•ä»ä»»æ„å€¼ï¼Œç”šè‡³æ˜¯æ•°æ®ç±»å‹å®ä¾‹ä¸­å¿«é€Ÿè·å¾—ä¸€ä¸ªæ•´æ•°å‘¢ï¼Ÿ
- en: 'Simple: They just use the memory address of the datum. Every value has a memory
    address, and the language can obtain it in constant time by looking up the directory.
    Granted, these values may be allocated anywhere with respect to each other, but
    thatâ€™s okayâ€”<wbr>we only want consistency, not â€œmeaningfulnessâ€.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€å•ï¼šå®ƒä»¬åªæ˜¯ä½¿ç”¨æ•°æ®çš„å†…å­˜åœ°å€ã€‚æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå†…å­˜åœ°å€ï¼Œè¯­è¨€å¯ä»¥é€šè¿‡æŸ¥æ‰¾ç›®å½•åœ¨å¸¸æ•°æ—¶é—´å†…è·å¾—å®ƒã€‚å½“ç„¶ï¼Œè¿™äº›å€¼å¯èƒ½ç›¸å¯¹äºå½¼æ­¤åˆ†é…åœ¨ä»»ä½•åœ°æ–¹ï¼Œä½†è¿™æ²¡å…³ç³»â€”â€”æˆ‘ä»¬åªæƒ³è¦ä¸€è‡´æ€§ï¼Œè€Œä¸æ˜¯â€œæœ‰æ„ä¹‰â€ã€‚
- en: In practice, however, things are not quite so simple. For instance, suppose
    we want two structurally equivalent values to have the same hash. If they are
    allocated in different addresses, they will hash differently. Therefore, many
    languages that use such a strategy also allow programmers to write their own hashing
    functions, often to work in conjunction with this built-in notion of hashing.
    These end up looking not too different from the hashing strategies we described
    above. Therefore, some of that complexity is inescapable, especially if a programmer
    wants structural rather than reference equalityâ€”<wbr>which they very often do.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®è·µä¸­ï¼Œäº‹æƒ…å¹¶ä¸é‚£ä¹ˆç®€å•ã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬å¸Œæœ›ä¸¤ä¸ªç»“æ„ä¸Šç­‰ä»·çš„ä»·å€¼å…·æœ‰ç›¸åŒçš„å“ˆå¸Œå€¼ã€‚å¦‚æœå®ƒä»¬åˆ†é…åœ¨ä¸åŒçš„åœ°å€ï¼Œå®ƒä»¬çš„å“ˆå¸Œå€¼å°†ä¸åŒã€‚å› æ­¤ï¼Œè®¸å¤šä½¿ç”¨è¿™ç§ç­–ç•¥çš„è¯­è¨€ä¹Ÿå…è®¸ç¨‹åºå‘˜ç¼–å†™è‡ªå·±çš„å“ˆå¸Œå‡½æ•°ï¼Œé€šå¸¸æ˜¯ä¸ºäº†ä¸è¿™ç§å†…ç½®çš„å“ˆå¸Œæ¦‚å¿µååŒå·¥ä½œã€‚è¿™äº›æœ€ç»ˆçœ‹èµ·æ¥å¹¶ä¸å¤ªä¸åŒäºæˆ‘ä»¬ä¸Šé¢æè¿°çš„å“ˆå¸Œç­–ç•¥ã€‚å› æ­¤ï¼Œä¸€äº›å¤æ‚æ€§æ˜¯ä¸å¯é¿å…çš„ï¼Œå°¤å…¶æ˜¯å¦‚æœç¨‹åºå‘˜æƒ³è¦ç»“æ„ä¸Šçš„ç›¸ç­‰è€Œä¸æ˜¯å¼•ç”¨ç›¸ç­‰â€”â€”ä»–ä»¬é€šå¸¸æ˜¯è¿™æ ·åšçš„ã€‚
- en: In the rest of this material, we will therefore continue with the simple hash
    function above, for multiple reasons. First, it is sufficient to illustrate how
    hashing works. Second, in practice, when built-in hashing does not suffice, we
    do write (more complex versions of) functions like the above. And finally, because
    itâ€™s all laid bare, itâ€™s easy for us to experiment with.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œåœ¨æ¥ä¸‹æ¥çš„ææ–™ä¸­ï¼Œæˆ‘ä»¬å°†ç»§ç»­ä½¿ç”¨ä¸Šé¢ç®€å•çš„å“ˆå¸Œå‡½æ•°ï¼Œæœ‰å¤šä¸ªåŸå› ã€‚é¦–å…ˆï¼Œå®ƒè¶³ä»¥è¯´æ˜å“ˆå¸Œæ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚å…¶æ¬¡ï¼Œåœ¨å®è·µä¸­ï¼Œå½“å†…ç½®çš„å“ˆå¸Œä¸è¶³æ—¶ï¼Œæˆ‘ä»¬ç¡®å®ä¼šç¼–å†™ï¼ˆæ›´å¤æ‚ç‰ˆæœ¬çš„ï¼‰ä¸Šè¿°å‡½æ•°ã€‚æœ€åï¼Œå› ä¸ºä¸€åˆ‡éƒ½æš´éœ²å‡ºæ¥ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“è¿›è¡Œå®éªŒã€‚
- en: 18.5.3Â Equality and Ordering[ğŸ”—](#(part._eq-ord) "Link to here")
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.5.3Â ç›¸ç­‰ä¸æ’åº[ğŸ”—](#(part._eq-ord) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'What weâ€™ve seen [[A Fine Balance: Tree Surgery](sets-from-trees.html#%28part._sets-from-balanced-trees%29)]
    for the construction of balanced binary search trees is that we need some way
    of putting elements in order. In the examples we used numbers because theyâ€™re
    a very friendly datatype: they have several properties that we take for granted.
    However, not all data have these properties.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨æ„å»ºå¹³è¡¡äºŒå‰æœç´¢æ ‘æ—¶çœ‹åˆ°çš„[[è‰¯å¥½çš„å¹³è¡¡ï¼šæ ‘æ‰‹æœ¯](sets-from-trees.html#%28part._sets-from-balanced-trees%29)ã€‘è¡¨æ˜ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§å¯¹å…ƒç´ è¿›è¡Œæ’åºçš„æ–¹æ³•ã€‚åœ¨æˆ‘ä»¬ä½¿ç”¨çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†æ•°å­—ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ä¸€ä¸ªéå¸¸å‹å¥½çš„æ•°æ®ç±»å‹ï¼šå®ƒä»¬å…·æœ‰æˆ‘ä»¬è§†ä¸ºç†æ‰€å½“ç„¶çš„å‡ ä¸ªå±æ€§ã€‚ç„¶è€Œï¼Œå¹¶éæ‰€æœ‰æ•°æ®éƒ½å…·æœ‰è¿™äº›å±æ€§ã€‚
- en: 'The critical property that numbers have is that they are orderable. This follows
    because they are comparable, and the comparison is ternary: it produces three
    answers, â€œless thanâ€, â€œequal toâ€, and â€œgreater thanâ€.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°å­—çš„å…³é”®å±æ€§æ˜¯å®ƒä»¬æ˜¯å¯æ’åºçš„ã€‚è¿™æ˜¯å› ä¸ºå®ƒä»¬æ˜¯å¯æ¯”è¾ƒçš„ï¼Œæ¯”è¾ƒæ˜¯ä¸‰å…ƒçš„ï¼šå®ƒäº§ç”Ÿä¸‰ä¸ªç­”æ¡ˆï¼Œâ€œå°äºâ€ã€â€œç­‰äºâ€å’Œâ€œå¤§äºâ€ã€‚
- en: 'However, not all data have this property. What are data that might not have
    these properties? Actually, there are multiple possible properties here: Is something
    orderable? Is something even comparable?'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œå¹¶éæ‰€æœ‰æ•°æ®éƒ½å…·æœ‰è¿™ç§å±æ€§ã€‚å“ªäº›æ•°æ®å¯èƒ½ä¸å…·æœ‰è¿™äº›å±æ€§ï¼Ÿå®é™…ä¸Šï¼Œè¿™é‡Œæœ‰å¤šç§å¯èƒ½çš„å±æ€§ï¼šæŸç‰©æ˜¯å¦å¯æ’åºï¼ŸæŸç‰©ç”šè‡³æ˜¯å¦å¯æ¯”è¾ƒï¼Ÿ
- en: '|  |  | Comparable |  | Orderable |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  |  | å¯æ¯”è¾ƒ |  | å¯æ’åº |'
- en: '| Numbers |  | Yes (but not Roughnums!) |  | Yes |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| æ•°å­— |  | æ˜¯ï¼ˆä½†ä¸æ˜¯ç²—ç•¥æ•°ï¼ï¼‰ |  | æ˜¯ |'
- en: '| Booleans |  | Yes |  | Yes |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| å¸ƒå°”å€¼ |  | æ˜¯ |  | æ˜¯ |'
- en: '| Data instances |  | Yes |  | Not by default |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| æ•°æ®å®ä¾‹ |  | æ˜¯ |  | é»˜è®¤ä¸ |'
- en: '| Roughnums |  | No |  | Yes |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| ç²—ç•¥æ•° |  | å¦ |  | æ˜¯ |'
- en: '| Functions |  | Not really |  | No |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| å‡½æ•° |  | ä¸å¤ªæ˜¯ |  | å¦ |'
- en: Soâ€¦life is complicated.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥â€¦â€¦ç”Ÿæ´»å¾ˆå¤æ‚ã€‚
- en: That means you could potentially misuse a BBST on the wrong kind of data. Ideally,
    we would want to know if weâ€™re doing this. In Pyretâ€™s type system we chose not
    to build this in, but in some languages, the type system actually lets you capture
    these properties.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€ä½ å¯èƒ½ä¼šé”™è¯¯åœ°ä½¿ç”¨BBSTæ¥å¤„ç†é”™è¯¯ç±»å‹çš„æ•°æ®ã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›çŸ¥é“æˆ‘ä»¬æ˜¯å¦åœ¨è¿™æ ·åšã€‚åœ¨Pyretçš„ç±»å‹ç³»ç»Ÿä¸­ï¼Œæˆ‘ä»¬é€‰æ‹©ä¸å°†å…¶å†…ç½®ï¼Œä½†åœ¨æŸäº›è¯­è¨€ä¸­ï¼Œç±»å‹ç³»ç»Ÿå®é™…ä¸Šå…è®¸ä½ æ•è·è¿™äº›å±æ€§ã€‚
- en: In Haskell, for instance, thereâ€™s a mechanism called the type-class; in Java,
    there are interfaces. They arenâ€™t really the same, but theyâ€™re useful to conflate
    for our purposes. Only things that meet a particular interface or type class provide
    certain operations. For instance, in Haskell, if you want to use == or /= (not
    equal), you have to be in the Eq type-class. Thus the comparable datatypes above
    would be part of Eq. Similarly, thereâ€™s a type-class Ord, which ensures the availability
    of (and requires the implementation of) operations like <, >, <=, and >=. In Haskell,
    everything that is Ord must also be Eq, i.e., Eq is weaker than Ord (things can
    be Eq without being Ord). Pyretâ€™s Roughnums contradict thatâ€¦but Haskell is okay
    with it. But if you try to compare two functions in Haskell,
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Haskell ä¸­ï¼Œä¾‹å¦‚ï¼Œæœ‰ä¸€ä¸ªç§°ä¸ºç±»å‹ç±»çš„æœºåˆ¶ï¼›åœ¨ Java ä¸­ï¼Œæœ‰æ¥å£ã€‚å®ƒä»¬å¹¶ä¸å®Œå…¨ç›¸åŒï¼Œä½†ä¸ºäº†æˆ‘ä»¬çš„ç›®çš„ï¼Œå°†å®ƒä»¬åˆå¹¶ä½¿ç”¨æ˜¯æœ‰ç”¨çš„ã€‚åªæœ‰æ»¡è¶³ç‰¹å®šæ¥å£æˆ–ç±»å‹ç±»çš„äº‹ç‰©æ‰èƒ½æä¾›æŸäº›æ“ä½œã€‚ä¾‹å¦‚ï¼Œåœ¨
    Haskell ä¸­ï¼Œå¦‚æœä½ æƒ³ä½¿ç”¨ == æˆ– /=ï¼ˆä¸ç­‰äºï¼‰ï¼Œä½ å¿…é¡»å±äº Eq ç±»å‹ç±»ã€‚å› æ­¤ï¼Œä¸Šè¿°å¯æ¯”è¾ƒçš„æ•°æ®ç±»å‹å°†æ˜¯ Eq çš„ä¸€éƒ¨åˆ†ã€‚åŒæ ·ï¼Œè¿˜æœ‰ä¸€ä¸ªç±»å‹ç±»
    Ordï¼Œå®ƒç¡®ä¿äº† <ã€>ã€<= å’Œ >= ç­‰æ“ä½œçš„å¯ç”¨æ€§å¹¶è¦æ±‚å®ç°è¿™äº›æ“ä½œã€‚åœ¨ Haskell ä¸­ï¼Œæ‰€æœ‰å±äº Ord çš„ä¸œè¥¿ä¹Ÿå¿…é¡»æ˜¯ Eqï¼Œå³ Eq æ¯” Ord
    å¼±ï¼ˆäº‹ç‰©å¯ä»¥æ˜¯ Eq è€Œä¸æ˜¯ Ordï¼‰ã€‚Pyret çš„ Roughnums ä¸æ­¤ç›¸åâ€¦â€¦ä½† Haskell å¯¹æ­¤è¡¨ç¤ºå¯ä»¥æ¥å—ã€‚ä½†å¦‚æœä½ å°è¯•åœ¨ Haskell
    ä¸­æ¯”è¾ƒä¸¤ä¸ªå‡½æ•°ï¼Œ
- en: '| (\x -> x + 1) < (\x -> x) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| (\x -> x + 1) < (\x -> x) |'
- en: you get an error like
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ ä¼šå¾—åˆ°ä¸€ä¸ªé”™è¯¯ï¼Œç±»ä¼¼äº
- en: '| * No instance for (Ord (Integer -> Integer)) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| * æ²¡æœ‰é€‚ç”¨äº (Ord (Integer -> Integer)) çš„å®ä¾‹ |'
- en: '| Â Â Â Â arising from a use of `<'' |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|    ç”±ä½¿ç”¨ `<'' |'
