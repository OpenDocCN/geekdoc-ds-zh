- en: 18.5¬†Equality, Ordering, and Hashingüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/orderability.html](https://dcic-world.org/2025-08-27/orderability.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[18.5.1¬†Converting Values to Ordered Values](#%28part._hashing-values%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[18.5.2¬†Hashing in Practice](#%28part._hash-in-practice%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[18.5.3¬†Equality and Ordering](#%28part._eq-ord%29) |'
  prefs: []
  type: TYPE_TB
- en: 18.5.1¬†Converting Values to Ordered Values[üîó](#(part._hashing-values) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Making Sets Grow on Trees](sets-from-trees.html), we noted that a single
    comparison needs to eliminate an entire set of values. With numbers, we were able
    to accomplish that easily: every bigger or smaller number was excluded by a comparison.
    But what if the data in the set are not actually numbers? Then we have to convert
    an arbitrary datum into a datatype that permits such comparison. This is known
    as hashing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A hash function consumes an arbitrary value and produces a comparable representation
    of it (its hash)‚Äî<wbr>most commonly (but not strictly necessarily), a number.
    A hash function must naturally be deterministic: a fixed value should always yield
    the same hash (otherwise, we might conclude that an element in the set is not
    actually in it, etc.). Particular uses may need additional properties, as we discuss
    in [Equality and Ordering](#%28part._eq-ord%29).'
  prefs: []
  type: TYPE_NORMAL
- en: Let us now consider how one can compute hashes. If the input datatype is a number,
    it can serve as its own hash. Comparison simply uses numeric comparison (e.g.,
    `<`). Then, transitivity of `<` ensures that if an element \(A\) is less than
    another element \(B\), then \(A\) is also less than all the other elements bigger
    than \(B\).
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose instead the input is a string. We can of course use the principle above
    for strings: e.g., replacing number inequality with string inequality. Strings
    have a lexicographic (or ‚Äúalphabetic‚Äù) ordering that permit them to be treated
    similar to numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: But what if we are handed more complex datatypes?
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we answer that, consider that in practice numbers are more efficient
    to compare than strings (since comparing two numbers is very nearly constant time).
    Thus, although we could use strings directly, it may be convenient to find a numeric
    representation of strings. We convert each character of the string into a number,
    e.g., using its [code point](https://en.wikipedia.org/wiki/Code_point). Based
    on that, here are two different hash functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider a list of primes as long as the string. Raise each prime by the corresponding
    number, and multiply the result. For instance, if the string is represented by
    the character codes `[6, 4, 5]` (the first character has code `6`, the second
    one `4`, and the third `5`), we get the hash
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or `16200000`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Simply add together all the character codes. For the above example, this would
    correspond to the has
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or `15`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first representation is invertible, using the [Fundamental Theorem of Arithmetic](http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic):
    given the resulting number, we can reconstruct the input unambiguously (i.e.,
    `16200000` can only map to the input above, and none other). This is also known
    as the G√∂del encoding. This is computationally expensive. The second encoding
    is, of course, not invertible (e.g., simply permute the characters and, by commutativity,
    the sum will be the same), but computationally much cheaper. It is also easy to
    implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now let us consider more general datatypes. The principle of hashing will be
    similar. If we have a datatype with several variants, we can order the variants
    lexicographically, and use a numeric tag to represent the variants, and recursively
    encode the datum and the variant tag. For each field of a record, we need an ordering
    of the fields‚Äî<wbr>the lexicographic ordering of the field names suffices‚Äî<wbr>and
    must hash their contents recursively; having done so, we get in effect a string
    of numbers, which we have shown how to handle.
  prefs: []
  type: TYPE_NORMAL
- en: The critical thing to remember is that we don‚Äôt actually need a meaningful operation.Observe
    that G√∂del encodings are not ‚Äúmeaningful‚Äù, either. We don‚Äôt actually care if a
    hash function concludes that the hash of `4` is less than the hash of `3`! All
    we need is a function that is
  prefs: []
  type: TYPE_NORMAL
- en: 'non-trivial: not everything should be equal; and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'deterministic: every time we ask for a hash, we should get the same answer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do we care about these two properties? Think about what would could go wrong
    if each one was violated.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 18.5.2¬†Hashing in Practice[üîó](#(part._hash-in-practice) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In practice, programmers do not want hash functions to do what we have described
    above. While G√∂del encoding is extremely expensive, even computing `hash-of` takes
    time linear in the size of a string, which can get quite expensive if strings
    are large or we compute hashes often or both.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, many programming languages do something very pragmatic. They need a
    value that can be compared for equality and ordering [[Equality and Ordering](#%28part._eq-ord%29)].
    Integers, we‚Äôve already seen, already fit this bill very nicely. But how to obtain
    an integer out of arbitrary values, even datatype instances, quickly?
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple: They just use the memory address of the datum. Every value has a memory
    address, and the language can obtain it in constant time by looking up the directory.
    Granted, these values may be allocated anywhere with respect to each other, but
    that‚Äôs okay‚Äî<wbr>we only want consistency, not ‚Äúmeaningfulness‚Äù.'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, however, things are not quite so simple. For instance, suppose
    we want two structurally equivalent values to have the same hash. If they are
    allocated in different addresses, they will hash differently. Therefore, many
    languages that use such a strategy also allow programmers to write their own hashing
    functions, often to work in conjunction with this built-in notion of hashing.
    These end up looking not too different from the hashing strategies we described
    above. Therefore, some of that complexity is inescapable, especially if a programmer
    wants structural rather than reference equality‚Äî<wbr>which they very often do.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this material, we will therefore continue with the simple hash
    function above, for multiple reasons. First, it is sufficient to illustrate how
    hashing works. Second, in practice, when built-in hashing does not suffice, we
    do write (more complex versions of) functions like the above. And finally, because
    it‚Äôs all laid bare, it‚Äôs easy for us to experiment with.
  prefs: []
  type: TYPE_NORMAL
- en: 18.5.3¬†Equality and Ordering[üîó](#(part._eq-ord) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What we‚Äôve seen [[A Fine Balance: Tree Surgery](sets-from-trees.html#%28part._sets-from-balanced-trees%29)]
    for the construction of balanced binary search trees is that we need some way
    of putting elements in order. In the examples we used numbers because they‚Äôre
    a very friendly datatype: they have several properties that we take for granted.
    However, not all data have these properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The critical property that numbers have is that they are orderable. This follows
    because they are comparable, and the comparison is ternary: it produces three
    answers, ‚Äúless than‚Äù, ‚Äúequal to‚Äù, and ‚Äúgreater than‚Äù.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, not all data have this property. What are data that might not have
    these properties? Actually, there are multiple possible properties here: Is something
    orderable? Is something even comparable?'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | Comparable |  | Orderable |'
  prefs: []
  type: TYPE_TB
- en: '| Numbers |  | Yes (but not Roughnums!) |  | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Booleans |  | Yes |  | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Data instances |  | Yes |  | Not by default |'
  prefs: []
  type: TYPE_TB
- en: '| Roughnums |  | No |  | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Functions |  | Not really |  | No |'
  prefs: []
  type: TYPE_TB
- en: So‚Ä¶life is complicated.
  prefs: []
  type: TYPE_NORMAL
- en: That means you could potentially misuse a BBST on the wrong kind of data. Ideally,
    we would want to know if we‚Äôre doing this. In Pyret‚Äôs type system we chose not
    to build this in, but in some languages, the type system actually lets you capture
    these properties.
  prefs: []
  type: TYPE_NORMAL
- en: In Haskell, for instance, there‚Äôs a mechanism called the type-class; in Java,
    there are interfaces. They aren‚Äôt really the same, but they‚Äôre useful to conflate
    for our purposes. Only things that meet a particular interface or type class provide
    certain operations. For instance, in Haskell, if you want to use == or /= (not
    equal), you have to be in the Eq type-class. Thus the comparable datatypes above
    would be part of Eq. Similarly, there‚Äôs a type-class Ord, which ensures the availability
    of (and requires the implementation of) operations like <, >, <=, and >=. In Haskell,
    everything that is Ord must also be Eq, i.e., Eq is weaker than Ord (things can
    be Eq without being Ord). Pyret‚Äôs Roughnums contradict that‚Ä¶but Haskell is okay
    with it. But if you try to compare two functions in Haskell,
  prefs: []
  type: TYPE_NORMAL
- en: '| (\x -> x + 1) < (\x -> x) |'
  prefs: []
  type: TYPE_TB
- en: you get an error like
  prefs: []
  type: TYPE_NORMAL
- en: '| * No instance for (Ord (Integer -> Integer)) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†arising from a use of `<'' |'
  prefs: []
  type: TYPE_TB
- en: 18.5.1¬†Converting Values to Ordered Values[üîó](#(part._hashing-values) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Making Sets Grow on Trees](sets-from-trees.html), we noted that a single
    comparison needs to eliminate an entire set of values. With numbers, we were able
    to accomplish that easily: every bigger or smaller number was excluded by a comparison.
    But what if the data in the set are not actually numbers? Then we have to convert
    an arbitrary datum into a datatype that permits such comparison. This is known
    as hashing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A hash function consumes an arbitrary value and produces a comparable representation
    of it (its hash)‚Äî<wbr>most commonly (but not strictly necessarily), a number.
    A hash function must naturally be deterministic: a fixed value should always yield
    the same hash (otherwise, we might conclude that an element in the set is not
    actually in it, etc.). Particular uses may need additional properties, as we discuss
    in [Equality and Ordering](#%28part._eq-ord%29).'
  prefs: []
  type: TYPE_NORMAL
- en: Let us now consider how one can compute hashes. If the input datatype is a number,
    it can serve as its own hash. Comparison simply uses numeric comparison (e.g.,
    `<`). Then, transitivity of `<` ensures that if an element \(A\) is less than
    another element \(B\), then \(A\) is also less than all the other elements bigger
    than \(B\).
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose instead the input is a string. We can of course use the principle above
    for strings: e.g., replacing number inequality with string inequality. Strings
    have a lexicographic (or ‚Äúalphabetic‚Äù) ordering that permit them to be treated
    similar to numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: But what if we are handed more complex datatypes?
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we answer that, consider that in practice numbers are more efficient
    to compare than strings (since comparing two numbers is very nearly constant time).
    Thus, although we could use strings directly, it may be convenient to find a numeric
    representation of strings. We convert each character of the string into a number,
    e.g., using its [code point](https://en.wikipedia.org/wiki/Code_point). Based
    on that, here are two different hash functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider a list of primes as long as the string. Raise each prime by the corresponding
    number, and multiply the result. For instance, if the string is represented by
    the character codes `[6, 4, 5]` (the first character has code `6`, the second
    one `4`, and the third `5`), we get the hash
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or `16200000`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Simply add together all the character codes. For the above example, this would
    correspond to the has
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or `15`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first representation is invertible, using the [Fundamental Theorem of Arithmetic](http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic):
    given the resulting number, we can reconstruct the input unambiguously (i.e.,
    `16200000` can only map to the input above, and none other). This is also known
    as the G√∂del encoding. This is computationally expensive. The second encoding
    is, of course, not invertible (e.g., simply permute the characters and, by commutativity,
    the sum will be the same), but computationally much cheaper. It is also easy to
    implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now let us consider more general datatypes. The principle of hashing will be
    similar. If we have a datatype with several variants, we can order the variants
    lexicographically, and use a numeric tag to represent the variants, and recursively
    encode the datum and the variant tag. For each field of a record, we need an ordering
    of the fields‚Äî<wbr>the lexicographic ordering of the field names suffices‚Äî<wbr>and
    must hash their contents recursively; having done so, we get in effect a string
    of numbers, which we have shown how to handle.
  prefs: []
  type: TYPE_NORMAL
- en: The critical thing to remember is that we don‚Äôt actually need a meaningful operation.Observe
    that G√∂del encodings are not ‚Äúmeaningful‚Äù, either. We don‚Äôt actually care if a
    hash function concludes that the hash of `4` is less than the hash of `3`! All
    we need is a function that is
  prefs: []
  type: TYPE_NORMAL
- en: 'non-trivial: not everything should be equal; and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'deterministic: every time we ask for a hash, we should get the same answer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do we care about these two properties? Think about what would could go wrong
    if each one was violated.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 18.5.2¬†Hashing in Practice[üîó](#(part._hash-in-practice) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In practice, programmers do not want hash functions to do what we have described
    above. While G√∂del encoding is extremely expensive, even computing `hash-of` takes
    time linear in the size of a string, which can get quite expensive if strings
    are large or we compute hashes often or both.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, many programming languages do something very pragmatic. They need a
    value that can be compared for equality and ordering [[Equality and Ordering](#%28part._eq-ord%29)].
    Integers, we‚Äôve already seen, already fit this bill very nicely. But how to obtain
    an integer out of arbitrary values, even datatype instances, quickly?
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple: They just use the memory address of the datum. Every value has a memory
    address, and the language can obtain it in constant time by looking up the directory.
    Granted, these values may be allocated anywhere with respect to each other, but
    that‚Äôs okay‚Äî<wbr>we only want consistency, not ‚Äúmeaningfulness‚Äù.'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, however, things are not quite so simple. For instance, suppose
    we want two structurally equivalent values to have the same hash. If they are
    allocated in different addresses, they will hash differently. Therefore, many
    languages that use such a strategy also allow programmers to write their own hashing
    functions, often to work in conjunction with this built-in notion of hashing.
    These end up looking not too different from the hashing strategies we described
    above. Therefore, some of that complexity is inescapable, especially if a programmer
    wants structural rather than reference equality‚Äî<wbr>which they very often do.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this material, we will therefore continue with the simple hash
    function above, for multiple reasons. First, it is sufficient to illustrate how
    hashing works. Second, in practice, when built-in hashing does not suffice, we
    do write (more complex versions of) functions like the above. And finally, because
    it‚Äôs all laid bare, it‚Äôs easy for us to experiment with.
  prefs: []
  type: TYPE_NORMAL
- en: 18.5.3¬†Equality and Ordering[üîó](#(part._eq-ord) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What we‚Äôve seen [[A Fine Balance: Tree Surgery](sets-from-trees.html#%28part._sets-from-balanced-trees%29)]
    for the construction of balanced binary search trees is that we need some way
    of putting elements in order. In the examples we used numbers because they‚Äôre
    a very friendly datatype: they have several properties that we take for granted.
    However, not all data have these properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The critical property that numbers have is that they are orderable. This follows
    because they are comparable, and the comparison is ternary: it produces three
    answers, ‚Äúless than‚Äù, ‚Äúequal to‚Äù, and ‚Äúgreater than‚Äù.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, not all data have this property. What are data that might not have
    these properties? Actually, there are multiple possible properties here: Is something
    orderable? Is something even comparable?'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | Comparable |  | Orderable |'
  prefs: []
  type: TYPE_TB
- en: '| Numbers |  | Yes (but not Roughnums!) |  | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Booleans |  | Yes |  | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Data instances |  | Yes |  | Not by default |'
  prefs: []
  type: TYPE_TB
- en: '| Roughnums |  | No |  | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Functions |  | Not really |  | No |'
  prefs: []
  type: TYPE_TB
- en: So‚Ä¶life is complicated.
  prefs: []
  type: TYPE_NORMAL
- en: That means you could potentially misuse a BBST on the wrong kind of data. Ideally,
    we would want to know if we‚Äôre doing this. In Pyret‚Äôs type system we chose not
    to build this in, but in some languages, the type system actually lets you capture
    these properties.
  prefs: []
  type: TYPE_NORMAL
- en: In Haskell, for instance, there‚Äôs a mechanism called the type-class; in Java,
    there are interfaces. They aren‚Äôt really the same, but they‚Äôre useful to conflate
    for our purposes. Only things that meet a particular interface or type class provide
    certain operations. For instance, in Haskell, if you want to use == or /= (not
    equal), you have to be in the Eq type-class. Thus the comparable datatypes above
    would be part of Eq. Similarly, there‚Äôs a type-class Ord, which ensures the availability
    of (and requires the implementation of) operations like <, >, <=, and >=. In Haskell,
    everything that is Ord must also be Eq, i.e., Eq is weaker than Ord (things can
    be Eq without being Ord). Pyret‚Äôs Roughnums contradict that‚Ä¶but Haskell is okay
    with it. But if you try to compare two functions in Haskell,
  prefs: []
  type: TYPE_NORMAL
- en: '| (\x -> x + 1) < (\x -> x) |'
  prefs: []
  type: TYPE_TB
- en: you get an error like
  prefs: []
  type: TYPE_NORMAL
- en: '| * No instance for (Ord (Integer -> Integer)) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†arising from a use of `<'' |'
  prefs: []
  type: TYPE_TB
