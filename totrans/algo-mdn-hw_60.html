<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Pointer Alternatives</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Pointer Alternatives</h1>
<blockquote>原文：<a href="https://en.algorithmica.org/hpc/cpu-cache/pointers/">https://en.algorithmica.org/hpc/cpu-cache/pointers/</a></blockquote><div id="search"><input id="search-bar" type="search" placeholder="Search this book…" oninput="search()"/><div id="search-count"/><div id="search-results"/></div><header><div class="info"/></header><article><p>In the <a href="../latency">pointer chasing benchmark</a>, for simplicity, we didn’t use actual pointers, but integer indices relative to a base address:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span></code></pre></div><p><a href="/hpc/architecture/assembly#addressing-modes">The memory addressing operator</a> on x86 is fused with the address computation, so the <code>k = q[k]</code> line folds into just a single terse instruction that also does multiplication by 4 and addition under the hood:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="nv">q</span><span class="p">[</span><span class="mi">0</span><span class="o">+</span><span class="nb">rax</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>
</span></span></code></pre></div><p>Although fully fused, these additional computations add some delay to memory operations. The latency of an L1 fetch is either 4 or 5 cycles — the latter being the case if we need to perform a complex computation of the address. For this reason, the permutation benchmark measures 3ns or 6 cycles per jump: 4+1 for the read and address computation and another one to move the result to the right register.</p><span class="anchor" id="pointers"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/cpu-cache/pointers/#pointers">#</a>Pointers</h3><p>We can make our benchmark run slightly faster if we replace “fake pointers” — indices — with actual pointers.</p><p>There are some syntactical issues in getting “pointer to pointer to pointer…” constructions to work, so instead we will define a struct that just wraps a pointers to its own type — this is how most pointer chasing works anyway:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">node</span> <span class="p">{</span> <span class="n">node</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span> <span class="p">};</span>
</span></span></code></pre></div><p>Now we randomly fill our array with pointers and chase them instead:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">node</span><span class="o">*</span> <span class="n">k</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
</span></span></code></pre></div><p>This code now runs in 2ns / 4 cycles for arrays that fit in the L1 cache. Why not 4+1=5? Because Zen 2 <a href="https://www.agner.org/forum/viewtopic.php?t=41">has an interesting feature</a> that allows zero-latency reuse of data accessed just by address, so the “move” here is transparent, resulting in whole two cycles saved.</p><p>Unfortunately, there is a problem with it on 64-bit systems as the pointers become twice as large, making the array spill out of cache much sooner compared to using a 32-bit index. The latency-versus-size graph looks like if it was shifted by one power of two to the left — exactly like it should:</p><p><figure><img src="../Images/056a930394d7fd4f3950099f1a65dbaf.png" data-original-src="https://en.algorithmica.org/hpc/cpu-cache/img/permutation-p64.svg"/><figcaption/></figure></p><p>This problem is mitigated by switching to the 32-bit mode:</p><p><figure><img src="../Images/e7771d2e8d9297605c558166e3f8a705.png" data-original-src="https://en.algorithmica.org/hpc/cpu-cache/img/permutation-p32.svg"/><figcaption/></figure></p><p>You need to go <a href="https://askubuntu.com/questions/91909/trouble-compiling-a-32-bit-binary-on-a-64-bit-machine">through some trouble</a> getting 32-bit libs to get this running on a computer made in this century, but this shouldn’t pose other problems unless you need to interoperate with 64-bit software or access more than 4G of RAM</p><span class="anchor" id="bit-fields"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/cpu-cache/pointers/#bit-fields">#</a>Bit Fields</h3><p>The fact that on larger problem sizes the performance is bottlenecked by memory rather than CPU lets us try something even more strange: we can use less than 4 bytes for storing indices. This can be done with <a href="../alignment#bit-fields">bit fields</a>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">node</span> <span class="p">{</span> <span class="kt">int</span> <span class="nl">idx</span> <span class="p">:</span> <span class="mi">24</span><span class="p">;</span> <span class="p">};</span>
</span></span></code></pre></div><p>You don’t need to do anything else other than defining a structure for the bit field — the compiler handles the 3-byte integer all by itself:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">idx</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">idx</span><span class="p">;</span>
</span></span></code></pre></div><p>This code measures at 6.5ns for the L1 cache. There is some room for improvement as the default conversion procedure chosen by the compiler is suboptimal. We could manually load a 4-byte integer and truncate it ourselves (we also need to add one more element to the <code>q</code> array to ensure we own that extra one byte of memory):</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">k</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">q</span> <span class="o">+</span> <span class="n">k</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">k</span> <span class="o">&amp;=</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div><p>It now runs in 4ns, and produces the following graph:</p><p><figure><img src="../Images/d921de7b5200b975d35a4ba6e4b6053c.png" data-original-src="https://en.algorithmica.org/hpc/cpu-cache/img/permutation-bf-custom.svg"/><figcaption/></figure></p><p>If you zoom close enough (<a href="../img/permutation-bf-custom.svg">the graph is an svg</a>), you’ll see that the pointers win on very small arrays, then starting from around the L2-L3 cache boundary our custom bit fields take over, and for very large arrays it doesn’t matter because we never hit cache anyway.</p><p>This isn’t a kind of optimization that can give you a 5x improvement, but it’s still something to try when all the other resources are exhausted.</p></article><div class="nextprev"><div class="left"><a href="https://en.algorithmica.org/hpc/cpu-cache/alignment/" id="prev-article">← Alignment and Packing</a></div><div class="right"><a href="https://en.algorithmica.org/hpc/cpu-cache/associativity/" id="next-article">Cache Associativity →</a></div></div>    
</body>
</html>