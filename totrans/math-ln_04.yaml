- en: 4\. Sets and Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 集合与函数
- en: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C04_Sets_and_Functions.html](https://leanprover-community.github.io/mathematics_in_lean/C04_Sets_and_Functions.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C04_Sets_and_Functions.html](https://leanprover-community.github.io/mathematics_in_lean/C04_Sets_and_Functions.html)
- en: '*[Mathematics in Lean](index.html)* **   4\. Sets and Functions'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Lean中的数学](index.html)* **   4. 集合与函数'
- en: '[View page source](_sources/C04_Sets_and_Functions.rst.txt)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[查看页面源代码](_sources/C04_Sets_and_Functions.rst.txt)'
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The vocabulary of sets, relations, and functions provides a uniform language
    for carrying out constructions in all the branches of mathematics. Since functions
    and relations can be defined in terms of sets, axiomatic set theory can be used
    as a foundation for mathematics.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 集合、关系和函数的词汇为在数学的所有分支中进行构造提供了一个统一的语言。由于函数和关系可以用集合来定义，公理化集合论可以用作数学的基础。
- en: 'Lean’s foundation is based instead on the primitive notion of a *type*, and
    it includes ways of defining functions between types. Every expression in Lean
    has a type: there are natural numbers, real numbers, functions from reals to reals,
    groups, vector spaces, and so on. Some expressions *are* types, which is to say,
    their type is `Type`. Lean and Mathlib provide ways of defining new types, and
    ways of defining objects of those types.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 的基础建立在原始的 *类型* 概念之上，并且包括定义类型之间函数的方法。Lean 中的每个表达式都有一个类型：有自然数、实数、从实数到实数的函数、群、向量空间等等。一些表达式
    *是* 类型，也就是说，它们的类型是 `Type`。Lean 和 Mathlib 提供了定义新类型以及定义那些类型对象的方法。
- en: Conceptually, you can think of a type as just a set of objects. Requiring every
    object to have a type has some advantages. For example, it makes it possible to
    overload notation like `+`, and it sometimes makes input less verbose because
    Lean can infer a lot of information from an object’s type. The type system also
    enables Lean to flag errors when you apply a function to the wrong number of arguments,
    or apply a function to arguments of the wrong type.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，你可以将类型视为仅仅是对象集合。要求每个对象都有类型有一些优点。例如，它使得重载像 `+` 这样的符号成为可能，并且有时它使得输入更简洁，因为
    Lean 可以从对象类型中推断出很多信息。类型系统还使 Lean 能够在将函数应用于错误数量的参数或应用于错误类型的参数时标记错误。
- en: Lean’s library does define elementary set-theoretic notions. In contrast to
    set theory, in Lean a set is always a set of objects of some type, such as a set
    of natural numbers or a set of functions from real numbers to real numbers. The
    distinction between types and sets takes some getting used to, but this chapter
    will take you through the essentials.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 的库确实定义了基本的集合论概念。与集合论不同，在 Lean 中，集合始终是某些类型（如自然数集合或从实数到实数的函数集合）的对象的集合。类型和集合之间的区别需要一些习惯，但本章将带你了解其基本概念。
- en: '## 4.1\. Sets[](#sets "Link to this heading")'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '## 4.1. 集合[](#sets "链接到这个标题")'
- en: 'If `α` is any type, the type `Set α` consists of sets of elements of `α`. This
    type supports the usual set-theoretic operations and relations. For example, `s
    ⊆ t` says that `s` is a subset of `t`, `s ∩ t` denotes the intersection of `s`
    and `t`, and `s ∪ t` denotes their union. The subset relation can be typed with
    `\ss` or `\sub`, intersection can be typed with `\i` or `\cap`, and union can
    be typed with `\un` or `\cup`. The library also defines the set `univ`, which
    consists of all the elements of type `α`, and the empty set, `∅`, which can be
    typed as `\empty`. Given `x : α` and `s : Set α`, the expression `x ∈ s` says
    that `x` is a member of `s`. Theorems that mention set membership often include
    `mem` in their name. The expression `x ∉ s` abbreviates `¬ x ∈ s`. You can type
    `∈` as `\in` or `\mem` and `∉` as `\notin`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `α` 是任何类型，则类型 `Set α` 由 `α` 的元素组成的集合组成。此类型支持通常的集合论操作和关系。例如，`s ⊆ t` 表示 `s`
    是 `t` 的子集，`s ∩ t` 表示 `s` 和 `t` 的交集，而 `s ∪ t` 表示它们的并集。子集关系可以用 `\ss` 或 `\sub` 来表示，交集可以用
    `\i` 或 `\cap` 来表示，并集可以用 `\un` 或 `\cup` 来表示。库还定义了包含类型 `α` 所有元素的集合 `univ`，以及空集 `∅`，它可以表示为
    `\empty`。给定 `x : α` 和 `s : Set α`，表达式 `x ∈ s` 表示 `x` 是 `s` 的成员。提及集合成员关系的定理通常在其名称中包含
    `mem`。表达式 `x ∉ s` 简写为 `¬ x ∈ s`。你可以用 `\in` 或 `\mem` 来表示 `∈`，用 `\notin` 来表示 `∉`。'
- en: One way to prove things about sets is to use `rw` or the simplifier to expand
    the definitions. In the second example below, we use `simp only` to tell the simplifier
    to use only the list of identities we give it, and not its full database of identities.
    Unlike `rw`, `simp` can perform simplifications inside a universal or existential
    quantifier. If you step through the proof, you can see the effects of these commands.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 证明集合属性的一种方法是用 `rw` 或简化器来展开定义。在下面的第二个例子中，我们使用 `simp only` 来告诉简化器只使用我们给出的标识符列表，而不是其完整的标识符数据库。与
    `rw` 不同，`simp` 可以在全称量词或存在量词内部执行简化。如果你逐步进行证明，你可以看到这些命令的效果。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, we open the `set` namespace to have access to the shorter
    names for the theorems. But, in fact, we can delete the calls to `rw` and `simp`
    entirely:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们打开 `set` 命名空间以访问定理的简短名称。但实际上，我们可以完全删除对 `rw` 和 `simp` 的调用：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What is going on here is known as *definitional reduction*: to make sense of
    the `intro` command and the anonymous constructors Lean is forced to expand the
    definitions. The following example also illustrate the phenomenon:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情被称为*定义性简化*：为了理解 `intro` 命令和 Lean 强制展开的定义，匿名构造器。以下示例也说明了这种现象：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To deal with unions, we can use `Set.union_def` and `Set.mem_union`. Since `x
    ∈ s ∪ t` unfolds to `x ∈ s ∨ x ∈ t`, we can also use the `cases` tactic to force
    a definitional reduction.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理并集，我们可以使用 `Set.union_def` 和 `Set.mem_union`。由于 `x ∈ s ∪ t` 展开为 `x ∈ s ∨ x
    ∈ t`，我们也可以使用 `cases` 策略来强制进行定义性简化。
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since intersection binds tighter than union, the use of parentheses in the
    expression `(s ∩ t) ∪ (s ∩ u)` is unnecessary, but they make the meaning of the
    expression clearer. The following is a shorter proof of the same fact:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于交集比并集绑定更紧密，表达式 `(s ∩ t) ∪ (s ∩ u)` 中的括号是不必要的，但它们使表达式的含义更清晰。以下是对同一事实的更简短的证明：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As an exercise, try proving the other inclusion:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试证明另一个包含：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It might help to know that when using `rintro`, sometimes we need to use parentheses
    around a disjunctive pattern `h1 | h2` to get Lean to parse it correctly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有时使用 `rintro` 时，可能需要在析取模式 `h1 | h2` 的周围使用括号，以便 Lean 正确解析它。
- en: The library also defines set difference, `s \ t`, where the backslash is a special
    unicode character entered as `\\`. The expression `x ∈ s \ t` expands to `x ∈
    s ∧ x ∉ t`. (The `∉` can be entered as `\notin`.) It can be rewritten manually
    using `Set.diff_eq` and `dsimp` or `Set.mem_diff`, but the following two proofs
    of the same inclusion show how to avoid using them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该库还定义了集合差，`s \ t`，其中反斜杠是一个特殊的 unicode 字符，输入为 `\\`。表达式 `x ∈ s \ t` 展开为 `x ∈ s
    ∧ x ∉ t`。（`∉` 可以输入为 `\notin`。）可以使用 `Set.diff_eq` 和 `dsimp` 或 `Set.mem_diff` 手动重写，但以下两个包含同一性的证明显示了如何避免使用它们。
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As an exercise, prove the reverse inclusion:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，证明反向包含：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To prove that two sets are equal, it suffices to show that every element of
    one is an element of the other. This principle is known as “extensionality,” and,
    unsurprisingly, the `ext` tactic is equipped to handle it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明两个集合相等，只需证明一个集合的每个元素也是另一个集合的元素。这个原则被称为“扩展性”，而且不出所料，`ext` 策略被装备来处理它。
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once again, deleting the line `simp only [mem_inter_iff]` does not harm the
    proof. In fact, if you like inscrutable proof terms, the following one-line proof
    is for you:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，删除 `simp only [mem_inter_iff]` 行不会损害证明。事实上，如果你喜欢难以理解的证明项，以下是一行证明：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is an even shorter proof, using the simplifier:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个更简短的证明，使用了简化器：
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An alternative to using `ext` is to use the theorem `Subset.antisymm` which
    allows us to prove an equation `s = t` between sets by proving `s ⊆ t` and `t
    ⊆ s`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ext` 的一个替代方法是使用定理 `Subset.antisymm`，它允许我们通过证明 `s ⊆ t` 和 `t ⊆ s` 来证明集合之间的等式
    `s = t`。
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Try finishing this proof term:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试完成这个证明项：
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Remember that you can replace sorry by an underscore, and when you hover over
    it, Lean will show you what it expects at that point.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以用下划线替换 `sorry`，并且当你悬停在它上面时，Lean 会显示它在该点期望的内容。
- en: 'Here are some set-theoretic identities you might enjoy proving:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可能喜欢证明的集合论恒等式：
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When it comes to representing sets, here is what is going on underneath the
    hood. In type theory, a *property* or *predicate* on a type `α` is just a function
    `P : α → Prop`. This makes sense: given `a : α`, `P a` is just the proposition
    that `P` holds of `a`. In the library, `Set α` is defined to be `α → Prop` and
    `x ∈ s` is defined to be `s x`. In other words, sets are really properties, treated
    as objects.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '当涉及到表示集合时，以下是底层发生的事情。在类型论中，类型 `α` 上的 *属性* 或 *谓词* 只是一个函数 `P : α → Prop`。这是有意义的：给定
    `a : α`，`P a` 只是 `P` 对 `a` 成立的命题。在库中，`Set α` 被定义为 `α → Prop`，`x ∈ s` 被定义为 `s x`。换句话说，集合实际上是属性，被视为对象。'
- en: 'The library also defines set-builder notation. The expression `{ y | P y }`
    unfolds to `(fun y ↦ P y)`, so `x ∈ { y | P y }` reduces to `P x`. So we can turn
    the property of being even into the set of even numbers:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆还定义了集合构造器符号。表达式 `{ y | P y }` 展开为 `(fun y ↦ P y)`，因此 `x ∈ { y | P y }` 简化为
    `P x`。因此，我们可以将偶数的属性转换为偶数集合：
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should step through this proof and make sure you understand what is going
    on. Note we tell the simplifier to *not* use the lemma `Nat.not_even_iff` because
    we want to keep `¬ Even n` in our goal. Try deleting the line `rw [evens, odds]`
    and confirm that the proof still works.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该逐步进行这个证明，并确保你理解了正在进行的事情。注意，我们告诉简化器不要使用引理 `Nat.not_even_iff`，因为我们希望保留 `¬ Even
    n` 在我们的目标中。尝试删除 `rw [evens, odds]` 这一行，并确认证明仍然有效。
- en: In fact, set-builder notation is used to define
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，集合构造器符号用于定义
- en: '`s ∩ t` as `{x | x ∈ s ∧ x ∈ t}`,'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s ∩ t` 表示为 `{x | x ∈ s ∧ x ∈ t}`。'
- en: '`s ∪ t` as `{x | x ∈ s ∨ x ∈ t}`,'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s ∪ t` 表示为 `{x | x ∈ s ∨ x ∈ t}`,'
- en: '`∅` as `{x | False}`, and'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`∅` 表示为 `{x | False}`，'
- en: '`univ` as `{x | True}`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`univ` 表示为 `{x | True}`。'
- en: We often need to indicate the type of `∅` and `univ` explicitly, because Lean
    has trouble guessing which ones we mean. The following examples show how Lean
    unfolds the last two definitions when needed. In the second one, `trivial` is
    the canonical proof of `True` in the library.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要明确指出 `∅` 和 `univ` 的类型，因为 Lean 难以猜测我们指的是哪一个。以下示例显示了 Lean 在需要时如何展开最后两个定义。在第二个示例中，`trivial`
    是库中 `True` 的规范证明。
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As an exercise, prove the following inclusion. Use `intro n` to unfold the definition
    of subset, and use the simplifier to reduce the set-theoretic constructions to
    logic. We also recommend using the theorems `Nat.Prime.eq_two_or_odd` and `Nat.odd_iff`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，证明以下包含关系。使用 `intro n` 展开子集的定义，并使用简化器将集合论构造简化为逻辑。我们还建议使用定理 `Nat.Prime.eq_two_or_odd`
    和 `Nat.odd_iff`。
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Be careful: it is somewhat confusing that the library has multiple versions
    of the predicate `Prime`. The most general one makes sense in any commutative
    monoid with a zero element. The predicate `Nat.Prime` is specific to the natural
    numbers. Fortunately, there is a theorem that says that in the specific case,
    the two notions agree, so you can always rewrite one to the other.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意：图书馆中存在多个版本的谓词 `Prime`，这可能会有些令人困惑。最通用的一种在任何具有零元素的交换幺半群中都有意义。谓词 `Nat.Prime`
    专门针对自然数。幸运的是，有一个定理说明在特定情况下，这两个概念是一致的，因此你可以总是将一个重写为另一个。
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The rwa tactic follows a rewrite with the assumption tactic.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: rwa 策略遵循重写和假设策略。
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Lean introduces the notation `∀ x ∈ s, ...`, “for every `x` in `s` .,” as an
    abbreviation for `∀ x, x ∈ s → ...`. It also introduces the notation `∃ x ∈ s,
    ...,` “there exists an `x` in `s` such that ..” These are sometimes known as *bounded
    quantifiers*, because the construction serves to restrict their significance to
    the set `s`. As a result, theorems in the library that make use of them often
    contain `ball` or `bex` in the name. The theorem `bex_def` asserts that `∃ x ∈
    s, ...` is equivalent to `∃ x, x ∈ s ∧ ...,` but when they are used with `rintro`,
    `use`, and anonymous constructors, these two expressions behave roughly the same.
    As a result, we usually don’t need to use `bex_def` to transform them explicitly.
    Here are some examples of how they are used:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 引入了 `∀ x ∈ s, ...` 的符号，“对于 `s` 中的每个 `x` ...”，作为 `∀ x, x ∈ s → ...` 的缩写。它还引入了
    `∃ x ∈ s, ...,` 的符号，“存在一个 `s` 中的 `x` 使得 ...”，这些有时被称为 *有界量词*，因为它们的构造旨在将它们的含义限制在集合
    `s` 中。因此，使用它们的库中的定理通常包含 `ball` 或 `bex` 在其名称中。定理 `bex_def` 断言 `∃ x ∈ s, ...` 等价于
    `∃ x, x ∈ s ∧ ...,` 但当它们与 `rintro`、`use` 和匿名构造函数一起使用时，这两个表达式的行为大致相同。因此，我们通常不需要使用
    `bex_def` 来显式地转换它们。以下是一些它们如何使用的例子：
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'See if you can prove these slight variations:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否可以证明这些细微的变化：
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Indexed unions and intersections are another important set-theoretic construction.
    We can model a sequence \(A_0, A_1, A_2, \ldots\) of sets of elements of `α` as
    a function `A : ℕ → Set α`, in which case `⋃ i, A i` denotes their union, and
    `⋂ i, A i` denotes their intersection. There is nothing special about the natural
    numbers here, so `ℕ` can be replaced by any type `I` used to index the sets. The
    following illustrates their use.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '索引并集和交集是另一种重要的集合论构造。我们可以将元素类型 `α` 的集合序列 \(A_0, A_1, A_2, \ldots\) 模拟为一个函数 `A
    : ℕ → Set α`，在这种情况下，`⋃ i, A i` 表示它们的并集，`⋂ i, A i` 表示它们的交集。这里关于自然数没有什么特殊之处，所以 `ℕ`
    可以被任何用于索引集合的类型 `I` 替换。以下说明了它们的使用。'
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Parentheses are often needed with an indexed union or intersection because,
    as with the quantifiers, the scope of the bound variable extends as far as it
    can.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在有索引的并集或交集中，通常需要括号，因为，与量词一样，约束变量的作用域延伸到尽可能远的地方。
- en: 'Try proving the following identity. One direction requires classical logic!
    We recommend using `by_cases xs : x ∈ s` at an appropriate point in the proof.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '尝试证明以下恒等式。其中一个方向需要经典逻辑！我们建议在证明的适当位置使用 `by_cases xs : x ∈ s`。'
- en: '[PRE22]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Mathlib also has bounded unions and intersections, which are analogous to the
    bounded quantifiers. You can unpack their meaning with `mem_iUnion₂` and `mem_iInter₂`.
    As the following examples show, Lean’s simplifier carries out these replacements
    as well.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 还有限制并集和交集，它们与限制量词类似。你可以用 `mem_iUnion₂` 和 `mem_iInter₂` 来展开它们的含义。以下示例显示，Lean
    的简化器也会执行这些替换。
- en: '[PRE23]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Try solving the following example, which is similar. If you start typing `eq_univ`,
    tab completion will tell you that `apply eq_univ_of_forall` is a good way to start
    the proof. We also recommend using the theorem `Nat.exists_infinite_primes`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试解决以下示例，它与前面的示例类似。如果你开始输入 `eq_univ`，Tab 完成会告诉你 `apply eq_univ_of_forall` 是开始证明的好方法。我们还建议使用定理
    `Nat.exists_infinite_primes`。
- en: '[PRE24]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Give a collection of sets, `s : Set (Set α)`, their union, `⋃₀ s`, has type
    `Set α` and is defined as `{x | ∃ t ∈ s, x ∈ t}`. Similarly, their intersection,
    `⋂₀ s`, is defined as `{x | ∀ t ∈ s, x ∈ t}`. These operations are called `sUnion`
    and `sInter`, respectively. The following examples show their relationship to
    bounded union and intersection.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个集合的集合，`s : Set (Set α)`，它们的并集，`⋃₀ s`，具有类型 `Set α`，定义为 `{x | ∃ t ∈ s, x
    ∈ t}`。同样，它们的交集，`⋂₀ s`，定义为 `{x | ∀ t ∈ s, x ∈ t}`。这些操作分别称为 `sUnion` 和 `sInter`。以下示例展示了它们与有界并集和交集的关系。'
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the library, these identities are called `sUnion_eq_biUnion` and `sInter_eq_biInter`.  ##
    4.2\. Functions[](#functions "Link to this heading")'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '在库中，这些恒等性被称为 `sUnion_eq_biUnion` 和 `sInter_eq_biInter`。  ## 4.2\. 函数[](#functions
    "链接到这个标题")'
- en: 'If `f : α → β` is a function and `p` is a set of elements of type `β`, the
    library defines `preimage f p`, written `f ⁻¹'' p`, to be `{x | f x ∈ p}`. The
    expression `x ∈ f ⁻¹'' p` reduces to `f x ∈ p`. This is often convenient, as in
    the following example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `f : α → β` 是一个函数，且 `p` 是类型 `β` 的元素集合，库定义 `preimage f p`，写作 `f ⁻¹'' p`，为
    `{x | f x ∈ p}`。表达式 `x ∈ f ⁻¹'' p` 简化为 `f x ∈ p`。这通常很方便，以下是一个示例：'
- en: '[PRE26]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If `s` is a set of elements of type `α`, the library also defines `image f
    s`, written `f '''' s`, to be `{y | ∃ x, x ∈ s ∧ f x = y}`. So a hypothesis `y
    ∈ f '''' s` decomposes to a triple `⟨x, xs, xeq⟩` with `x : α` satisfying the
    hypotheses `xs : x ∈ s` and `xeq : f x = y`. The `rfl` tag in the `rintro` tactic
    (see [Section 3.2](C03_Logic.html#the-existential-quantifier)) was made precisely
    for this sort of situation.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `s` 是类型 `α` 的元素集合，库还定义了 `image f s`，写作 `f '''' s`，为 `{y | ∃ x, x ∈ s ∧ f
    x = y}`。因此，假设 `y ∈ f '''' s` 分解为一个三元组 `⟨x, xs, xeq⟩`，其中 `x : α` 满足假设 `xs : x ∈
    s` 和 `xeq : f x = y`。`rintro` 策略中的 `rfl` 标签（见 [第 3.2 节](C03_Logic.html#the-existential-quantifier)）正是为了这种情况而设计的。'
- en: '[PRE27]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice also that the `use` tactic applies `rfl` to close goals when it can.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当 `use` 策略可以时，它会应用 `rfl` 来关闭目标。
- en: 'Here is another example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个示例：
- en: '[PRE28]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can replace the line `use x, xs` by `apply mem_image_of_mem f xs` if we want
    to use a theorem specifically designed for that purpose. But knowing that the
    image is defined in terms of an existential quantifier is often convenient.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用专门为此目的设计的定理，我们可以将行 `use x, xs` 替换为 `apply mem_image_of_mem f xs`。但知道像这样的像是由存在量词定义的通常很方便。
- en: 'The following equivalence is a good exercise:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下等价性是一个很好的练习：
- en: '[PRE29]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It shows that `image f` and `preimage f` are an instance of what is known as
    a *Galois connection* between `Set α` and `Set β`, each partially ordered by the
    subset relation. In the library, this equivalence is named `image_subset_iff`.
    In practice, the right-hand side is often the more useful representation, because
    `y ∈ f ⁻¹' t` unfolds to `f y ∈ t` whereas working with `x ∈ f '' s` requires
    decomposing an existential quantifier.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它表明 `image f` 和 `preimage f` 是 `Set α` 和 `Set β` 之间所知的一种称为 *Galois 连接* 的实例，每个都是通过子集关系部分有序的。在库中，这个等价性被命名为
    `image_subset_iff`。在实践中，右侧通常是更有用的表示形式，因为 `y ∈ f ⁻¹' t` 展开为 `f y ∈ t`，而处理 `x ∈
    f '' s` 需要分解一个存在量词。
- en: Here is a long list of set-theoretic identities for you to enjoy. You don’t
    have to do all of them at once; do a few of them, and set the rest aside for a
    rainy day.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一长串的集合论恒等式供你欣赏。你不必一次性完成所有这些；做几个，把剩下的留到雨天再做。
- en: '[PRE30]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can also try your hand at the next group of exercises, which characterize
    the behavior of images and preimages with respect to indexed unions and intersections.
    In the third exercise, the argument `i : I` is needed to guarantee that the index
    set is nonempty. To prove any of these, we recommend using `ext` or `intro` to
    unfold the meaning of an equation or inclusion between sets, and then calling
    `simp` to unpack the conditions for membership.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '你也可以尝试下一组练习，这些练习描述了图像和前像在索引并集和交集方面的行为。在第三个练习中，需要参数 `i : I` 来保证索引集非空。为了证明这些中的任何一个，我们建议使用
    `ext` 或 `intro` 来展开方程或集合之间的包含关系，然后调用 `simp` 来展开成员资格的条件。'
- en: '[PRE31]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The library defines a predicate `InjOn f s` to say that `f` is injective on
    `s`. It is defined as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 库定义了一个谓词 `InjOn f s` 来表示 `f` 在 `s` 上是单射。它被定义为以下：
- en: '[PRE32]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The statement `Injective f` is provably equivalent to `InjOn f univ`. Similarly,
    the library defines `range f` to be `{x | ∃y, f y = x}`, so `range f` is provably
    equal to `f '''' univ`. This is a common theme in Mathlib: although many properties
    of functions are defined relative to their full domain, there are often relativized
    versions that restrict the statements to a subset of the domain type.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 声明 `Injective f` 可以证明等价于 `InjOn f univ`。同样，库定义 `range f` 为 `{x | ∃y, f y = x}`，因此
    `range f` 可以证明等于 `f '' univ`。这是 Mathlib 中的一个常见主题：尽管函数的许多属性是在它们的完整定义域上定义的，但通常存在相对化版本，这些版本将陈述限制在定义域类型的一个子集上。
- en: 'Here are some examples of `InjOn` and `range` in use:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `InjOn` 和 `range` 的使用示例：
- en: '[PRE33]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Try proving these:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试证明以下内容：
- en: '[PRE34]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To define the inverse of a function `f : α → β`, we will use two new ingredients.
    First, we need to deal with the fact that an arbitrary type in Lean may be empty.
    To define the inverse to `f` at `y` when there is no `x` satisfying `f x = y`,
    we want to assign a default value in `α`. Adding the annotation `[Inhabited α]`
    as a variable is tantamount to assuming that `α` has a preferred element, which
    is denoted `default`. Second, in the case where there is more than one `x` such
    that `f x = y`, the inverse function needs to *choose* one of them. This requires
    an appeal to the *axiom of choice*. Lean allows various ways of accessing it;
    one convenient method is to use the classical `choose` operator, illustrated below.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '要定义函数 `f : α → β` 的逆，我们将使用两个新元素。首先，我们需要处理这样一个事实：在 Lean 中，任意类型可能是空的。当没有 `x`
    满足 `f x = y` 时，我们想要在 `α` 中分配一个默认值。将注释 `[Inhabited α]` 作为变量添加相当于假设 `α` 有一个首选元素，用
    `default` 表示。其次，在存在多个 `x` 满足 `f x = y` 的情况下，逆函数需要 *选择* 其中一个。这需要诉诸于 *选择公理*。Lean
    允许以各种方式访问它；一种方便的方法是使用经典的 `choose` 操作符，如下所示。'
- en: '[PRE35]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Given `h : ∃ x, P x`, the value of `Classical.choose h` is some `x` satisfying
    `P x`. The theorem `Classical.choose_spec h` says that `Classical.choose h` meets
    this specification.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '给定 `h : ∃ x, P x`，`Classical.choose h` 的值是满足 `P x` 的某个 `x`。定理 `Classical.choose_spec
    h` 表示 `Classical.choose h` 满足这个指定。'
- en: 'With these in hand, we can define the inverse function as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些之后，我们可以定义逆函数如下：
- en: '[PRE36]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The lines `noncomputable section` and `open Classical` are needed because we
    are using classical logic in an essential way. On input `y`, the function `inverse
    f` returns some value of `x` satisfying `f x = y` if there is one, and a default
    element of `α` otherwise. This is an instance of a *dependent if* construction,
    since in the positive case, the value returned, `Classical.choose h`, depends
    on the assumption `h`. The identity `dif_pos h` rewrites `if h : e then a else
    b` to `a` given `h : e`, and, similarly, `dif_neg h` rewrites it to `b` given
    `h : ¬ e`. There are also versions `if_pos` and `if_neg` that works for non-dependent
    if constructions and will be used in the next section. The theorem `inverse_spec`
    says that `inverse f` meets the first part of this specification.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '需要的行 `noncomputable section` 和 `open Classical` 是因为我们正在以基本的方式使用经典逻辑。对于输入 `y`，函数
    `inverse f` 如果存在，则返回满足 `f x = y` 的某个 `x` 的值，否则返回 `α` 的默认元素。这是一个 *依赖if* 构造的实例，因为在正例中，返回的值
    `Classical.choose h` 依赖于假设 `h`。恒等式 `dif_pos h` 将 `if h : e then a else b` 重新写为
    `a` 给定 `h : e`，同样，`dif_neg h` 将它重新写为 `b` 给定 `h : ¬ e`。还有 `if_pos` 和 `if_neg` 版本，它们适用于非依赖if构造，将在下一节中使用。定理
    `inverse_spec` 表示 `inverse f` 满足这个规范的第一个部分。'
- en: Don’t worry if you do not fully understand how these work. The theorem `inverse_spec`
    alone should be enough to show that `inverse f` is a left inverse if and only
    if `f` is injective and a right inverse if and only if `f` is surjective. Look
    up the definition of `LeftInverse` and `RightInverse` by double-clicking or right-clicking
    on them in VS Code, or using the commands `#print LeftInverse` and `#print RightInverse`.
    Then try to prove the two theorems. They are tricky! It helps to do the proofs
    on paper before you start hacking through the details. You should be able to prove
    each of them with about a half-dozen short lines. If you are looking for an extra
    challenge, try to condense each proof to a single-line proof term.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不完全理解这些是如何工作的，请不要担心。仅定理 `inverse_spec` 就足以表明 `inverse f` 是一个左逆当且仅当 `f` 是单射，并且是一个右逆当且仅当
    `f` 是满射。通过在 VS Code 中双击或右击它们来查找 `LeftInverse` 和 `RightInverse` 的定义，或者使用命令 `#print
    LeftInverse` 和 `#print RightInverse`。然后尝试证明这两个定理。它们很棘手！在开始处理细节之前，在纸上做证明会有所帮助。您应该能够用大约六行简短的语句证明每一个。如果您在寻找额外的挑战，尝试将每个证明压缩成单行证明项。
- en: '[PRE37]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We close this section with a type-theoretic statement of Cantor’s famous theorem
    that there is no surjective function from a set to its power set. See if you can
    understand the proof, and then fill in the two lines that are missing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以类型论的形式陈述康托尔著名的定理：不存在从集合到其幂集的满射函数。看看您是否能理解这个证明，然后填写缺失的两行。
- en: '[PRE38]  ## 4.3\. The Schröder-Bernstein Theorem[](#the-schroder-bernstein-theorem
    "Link to this heading")'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE38]  ## 4.3. 施罗德-伯恩斯坦定理[](#the-schroder-bernstein-theorem "链接到这个标题")'
- en: 'We close this chapter with an elementary but nontrivial theorem of set theory.
    Let \(\alpha\) and \(\beta\) be sets. (In our formalization, they will actually
    be types.) Suppose \(f : \alpha → \beta\) and \(g : \beta → \alpha\) are both
    injective. Intuitively, this means that \(\alpha\) is no bigger than \(\beta\)
    and vice-versa. If \(\alpha\) and \(\beta\) are finite, this implies that they
    have the same cardinality, which is equivalent to saying that there is a bijection
    between them. In the nineteenth century, Cantor stated that same result holds
    even in the case where \(\alpha\) and \(\beta\) are infinite. This was eventually
    established by Dedekind, Schröder, and Bernstein independently.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '我们以集合论的一个基本但非平凡的定理结束这一章。设 \(\alpha\) 和 \(\beta\) 是集合。（在我们的形式化中，它们实际上将是类型。）假设
    \(f : \alpha → \beta\) 和 \(g : \beta → \alpha\) 都是单射。直观上，这意味着 \(\alpha\) 不比 \(\beta\)
    大，反之亦然。如果 \(\alpha\) 和 \(\beta\) 是有限的，这表明它们具有相同的基数，这等价于说它们之间存在双射。在19世纪，康托尔指出，即使
    \(\alpha\) 和 \(\beta\) 是无限的，同样的结果也成立。这最终由 Dedekind、Schröder 和 Bernstein 独立地建立。'
- en: Our formalization will introduce some new methods that we will explain in greater
    detail in chapters to come. Don’t worry if they go by too quickly here. Our goal
    is to show you that you already have the skills to contribute to the formal proof
    of a real mathematical result.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的形式化将引入一些新的方法，我们将在接下来的章节中更详细地解释。如果在这里它们出现得太快，请不要担心。我们的目标是向您展示您已经具备了对真实数学结果的正式证明做出贡献的技能。
- en: To understand the idea behind the proof, consider the image of the map \(g\)
    in \(\alpha\). On that image, the inverse of \(g\) is defined and is a bijection
    with \(\beta\).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解证明背后的思想，考虑映射 \(g\) 在 \(\alpha\) 中的图像。在该图像上，\(g\) 的逆映射被定义，并且与 \(\beta\) 是一个双射。
- en: '[![the Schröder Bernstein theorem](../Images/b9bd80157a93a7ba893a2f18cfdfed3b.png)](_images/schroeder_bernstein1.png)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![Schröder-Bernstein 定理](../Images/b9bd80157a93a7ba893a2f18cfdfed3b.png)'
- en: The problem is that the bijection does not include the shaded region in the
    diagram, which is nonempty if \(g\) is not surjective. Alternatively, we can use
    \(f\) to map all of \(\alpha\) to \(\beta\), but in that case the problem is that
    if \(f\) is not surjective, it will miss some elements of \(\beta\).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这个双射不包括图中的阴影区域，如果 \(g\) 不是满射，这个区域是非空的。或者，我们可以用 \(f\) 将所有的 \(\alpha\) 映射到
    \(\beta\)，但那样的问题在于如果 \(f\) 不是满射，它将错过 \(\beta\) 的某些元素。
- en: '[![the Schröder Bernstein theorem](../Images/3a2cb3f7312f2e87d498ab1df6ab3f1b.png)](_images/schroeder_bernstein2.png)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![Schröder-Bernstein 定理](../Images/3a2cb3f7312f2e87d498ab1df6ab3f1b.png)'
- en: But now consider the composition \(g \circ f\) from \(\alpha\) to itself. Because
    the composition is injective, it forms a bijection between \(\alpha\) and its
    image, yielding a scaled-down copy of \(\alpha\) inside itself.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在考虑从 \(\alpha\) 到自身的复合映射 \(g \circ f\)。因为复合是单射的，它形成了 \(\alpha\) 和其图像之间的双射，从而在自身内部产生了一个缩小版的
    \(\alpha\)。
- en: '[![the Schröder Bernstein theorem](../Images/1e07afa02f123c9afbedf2f6dd380690.png)](_images/schroeder_bernstein3.png)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![Schröder-Bernstein 定理](../Images/1e07afa02f123c9afbedf2f6dd380690.png)'
- en: This composition maps the inner shaded ring to yet another such set, which we
    can think of as an even smaller concentric shaded ring, and so on. This yields
    a concentric sequence of shaded rings, each of which is in bijective correspondence
    with the next. If we map each ring to the next and leave the unshaded parts of
    \(\alpha\) alone, we have a bijection of \(\alpha\) with the image of \(g\). Composing
    with \(g^{-1}\), this yields the desired bijection between \(\alpha\) and \(\beta\).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个复合映射将内部阴影环映射到另一个这样的集合，我们可以将其视为一个更小的同心阴影环，依此类推。这产生了一系列同心阴影环，每个环都与下一个环一一对应。如果我们将每个环映射到下一个环，并让
    \(\alpha\) 的非阴影部分保持不变，我们就得到了 \(\alpha\) 与 \(g\) 的像之间的双射。与 \(g^{-1}\) 组合，这就得到了
    \(\alpha\) 和 \(\beta\) 之间的所期望的双射。
- en: 'We can describe this bijection more simply. Let \(A\) be the union of the sequence
    of shaded regions, and define \(h : \alpha \to \beta\) as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以更简单地描述这个双射。令 \(A\) 为阴影区域的序列的并集，并定义 \(h : \alpha \to \beta\) 如下：'
- en: \[\begin{split}h(x) = \begin{cases} f(x) & \text{if $x \in A$} \\ g^{-1}(x)
    & \text{otherwise.} \end{cases}\end{split}\]
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}h(x) = \begin{cases} f(x) & \text{if } x \in A \\ g^{-1}(x) &
    \text{otherwise.} \end{cases}\end{split}\]
- en: In other words, we use \(f\) on the shaded parts, and we use the inverse of
    \(g\) everywhere else. The resulting map \(h\) is injective because each component
    is injective and the images of the two components are disjoint. To see that it
    is surjective, suppose we are given a \(y\) in \(\beta\), and consider \(g(y)\).
    If \(g(y)\) is in one of the shaded regions, it cannot be in the first ring, so
    we have \(g(y) = g(f(x))\) for some \(x\) is in the previous ring. By the injectivity
    of \(g\), we have \(h(x) = f(x) = y\). If \(g(y)\) is not in the shaded region,
    then by the definition of \(h\), we have \(h(g(y))= y\). Either way, \(y\) is
    in the image of \(h\).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们在阴影部分使用 \(f\)，在其他所有地方使用 \(g\) 的逆映射。结果映射 \(h\) 是单射的，因为每个组成部分都是单射的，并且两个组成部分的像是不相交的。为了证明它是满射的，假设我们给定了一个
    \(\beta\) 中的 \(y\)，并考虑 \(g(y)\)。如果 \(g(y)\) 在一个阴影区域内，它不能在第一个环内，所以我们有 \(g(y) =
    g(f(x))\) 对于某个 \(x\) 在前一个环中。根据 \(g\) 的单射性，我们有 \(h(x) = f(x) = y\)。如果 \(g(y)\)
    不在阴影区域内，那么根据 \(h\) 的定义，我们有 \(h(g(y)) = y\)。无论如何，\(y\) 都在 \(h\) 的像中。
- en: This argument should sound plausible, but the details are delicate. Formalizing
    the proof will not only improve our confidence in the result, but also help us
    understand it better. Because the proof uses classical logic, we tell Lean that
    our definitions will generally not be computable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个论点听起来应该是合理的，但细节很微妙。将证明形式化不仅会提高我们对结果的信心，而且有助于我们更好地理解它。因为证明使用了经典逻辑，我们告诉 Lean，我们的定义通常是不可计算的。
- en: '[PRE39]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The annotation `[Nonempty β]` specifies that `β` is nonempty. We use it because
    the Mathlib primitive that we will use to construct \(g^{-1}\) requires it. The
    case of the theorem where \(\beta\) is empty is trivial, and even though it would
    not be hard to generalize the formalization to cover that case as well, we will
    not bother. Specifically, we need the hypothesis `[Nonempty β]` for the operation
    `invFun` that is defined in Mathlib. Given `x : α`, `invFun g x` chooses a preimage
    of `x` in `β` if there is one, and returns an arbitrary element of `β` otherwise.
    The function `invFun g` is always a left inverse if `g` is injective and a right
    inverse if `g` is surjective.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '注释 `[Nonempty β]` 指定 `β` 是非空的。我们使用它是因为我们将使用的 Mathlib 原语构建 \(g^{-1}\) 需要它。当
    \(\beta\) 为空时，该定理的情况是平凡的，尽管将形式化推广到涵盖该情况也不难，但我们不会费心去做。具体来说，我们需要 `[Nonempty β]`
    假设用于在 Mathlib 中定义的操作 `invFun`。给定 `x : α`，`invFun g x` 如果存在，则选择 `x` 在 `β` 中的前像，否则返回
    `β` 的任意元素。如果 `g` 是单射的，那么函数 `invFun g` 总是左逆；如果 `g` 是满射的，那么它是右逆。'
- en: '[PRE40]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We define the set corresponding to the union of the shaded regions as follows.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下方式定义对应于阴影区域并集的集合。
- en: '[PRE41]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The definition `sbAux` is an example of a *recursive definition*, which we will
    explain in the next chapter. It defines a sequence of sets
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `sbAux` 是一个 *递归定义* 的例子，我们将在下一章中解释。它定义了一个集合序列
- en: \[\begin{split}S_0 &= \alpha ∖ g(\beta) \\ S_{n+1} &= g(f(S_n)).\end{split}\]
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}S_0 &= \alpha ∖ g(\beta) \\ S_{n+1} &= g(f(S_n)).\end{split}\]
- en: 'The definition `sbSet` corresponds to the set \(A = \bigcup_{n \in \mathbb{N}}
    S_n\) in our proof sketch. The function \(h\) described above is now defined as
    follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `sbSet` 对应于我们证明概要中的集合 \(A = \bigcup_{n \in \mathbb{N}} S_n\)。上面描述的函数 \(h\)
    现在定义如下：
- en: '[PRE42]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We will need the fact that our definition of \(g^{-1}\) is a right inverse on
    the complement of \(A\), which is to say, on the non-shaded regions of \(\alpha\).
    This is so because the outermost ring, \(S_0\), is equal to \(\alpha \setminus
    g(\beta)\), so the complement of \(A\) is contained in \(g(\beta)\). As a result,
    for every \(x\) in the complement of \(A\), there is a \(y\) such that \(g(y)
    = x\). (By the injectivity of \(g\), this \(y\) is unique, but next theorem says
    only that `invFun g x` returns some `y` such that `g y = x`.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 \(g^{-1}\) 的定义在 \(A\) 的补集上是右逆的事实，也就是说，在 \(\alpha\) 的非阴影区域上。这是因为最外层环 \(S_0\)
    等于 \(\alpha \setminus g(\beta)\)，所以 \(A\) 的补集包含在 \(g(\beta)\) 中。因此，对于 \(A\) 的补集中的每个
    \(x\)，都存在一个 \(y\) 使得 \(g(y) = x\)。（由于 \(g\) 的单射性，这个 \(y\) 是唯一的，但下一个定理只说 `invFun
    g x` 返回某个 `y` 使得 `g y = x`。）
- en: Step through the proof below, make sure you understand what is going on, and
    fill in the remaining parts. You will need to use `invFun_eq` at the end. Notice
    that rewriting with `sbAux` here replaces `sbAux f g 0` with the right-hand side
    of the corresponding defining equation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步通过下面的证明，确保你理解了正在发生的事情，并填写剩余的部分。你将需要在最后使用 `invFun_eq`。注意，在这里用 `sbAux` 重写将 `sbAux
    f g 0` 替换为相应定义方程的右侧。
- en: '[PRE43]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We now turn to the proof that \(h\) is injective. Informally, the proof goes
    as follows. First, suppose \(h(x_1) = h(x_2)\). If \(x_1\) is in \(A\), then \(h(x_1)
    = f(x_1)\), and we can show that \(x_2\) is in \(A\) as follows. If it isn’t,
    then we have \(h(x_2) = g^{-1}(x_2)\). From \(f(x_1) = h(x_1) = h(x_2)\) we have
    \(g(f(x_1)) = x_2\). From the definition of \(A\), since \(x_1\) is in \(A\),
    \(x_2\) is in \(A\) as well, a contradiction. Hence, if \(x_1\) is in \(A\), so
    is \(x_2\), in which case we have \(f(x_1) = h(x_1) = h(x_2) = f(x_2)\). The injectivity
    of \(f\) then implies \(x_1 = x_2\). The symmetric argument shows that if \(x_2\)
    is in \(A\), then so is \(x_1\), which again implies \(x_1 = x_2\).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在转向证明 \(h\) 是单射的证明。非正式地说，证明如下。首先，假设 \(h(x_1) = h(x_2)\)。如果 \(x_1\) 在 \(A\)
    中，那么 \(h(x_1) = f(x_1)\)，我们可以如下证明 \(x_2\) 在 \(A\) 中。如果它不在，那么我们有 \(h(x_2) = g^{-1}(x_2)\)。从
    \(f(x_1) = h(x_1) = h(x_2)\) 我们得到 \(g(f(x_1)) = x_2\)。从 \(A\) 的定义来看，由于 \(x_1\)
    在 \(A\) 中，\(x_2\) 也在 \(A\) 中，这是一个矛盾。因此，如果 \(x_1\) 在 \(A\) 中，那么 \(x_2\) 也在 \(A\)
    中，在这种情况下，我们有 \(f(x_1) = h(x_1) = h(x_2) = f(x_2)\)。\(f\) 的单射性然后意味着 \(x_1 = x_2\)。对称的论证表明，如果
    \(x_2\) 在 \(A\) 中，那么 \(x_1\) 也在 \(A\) 中，这再次意味着 \(x_1 = x_2\)。
- en: The only remaining possibility is that neither \(x_1\) nor \(x_2\) is in \(A\).
    In that case, we have \(g^{-1}(x_1) = h(x_1) = h(x_2) = g^{-1}(x_2)\). Applying
    \(g\) to both sides yields \(x_1 = x_2\).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一可能性是 \(x_1\) 和 \(x_2\) 都不在 \(A\) 中。在这种情况下，我们有 \(g^{-1}(x_1) = h(x_1) =
    h(x_2) = g^{-1}(x_2)\)。将 \(g\) 应用到两边得到 \(x_1 = x_2\)。
- en: Once again, we encourage you to step through the following proof to see how
    the argument plays out in Lean. See if you can finish off the proof using `sb_right_inv`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 再次鼓励你逐步通过以下证明，看看论证在 Lean 中的展开情况。看看你是否可以使用 `sb_right_inv` 完成证明。
- en: '[PRE44]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The proof introduces some new tactics. To start with, notice the `set` tactic,
    which introduces abbreviations `A` and `h` for `sbSet f g` and `sb_fun f g` respectively.
    We name the corresponding defining equations `A_def` and `h_def`. The abbreviations
    are definitional, which is to say, Lean will sometimes unfold them automatically
    when needed. But not always; for example, when using `rw`, we generally need to
    use `A_def` and `h_def` explicitly. So the definitions bring a tradeoff: they
    can make expressions shorter and more readable, but they sometimes require us
    to do more work.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 证明引入了一些新的策略。首先，注意 `set` 策略，它为 `sbSet f g` 和 `sb_fun f g` 分别引入了缩写 `A` 和 `h`。我们命名相应的定义方程为
    `A_def` 和 `h_def`。缩写是定义性的，也就是说，Lean 有时会根据需要自动展开它们。但并不总是这样；例如，当使用 `rw` 时，我们通常需要显式地使用
    `A_def` 和 `h_def`。因此，定义带来了一种权衡：它们可以使表达式更短、更易读，但有时需要我们做更多的工作。
- en: A more interesting tactic is the `wlog` tactic, which encapsulates the symmetry
    argument in the informal proof above. We will not dwell on it now, but notice
    that it does exactly what we want. If you hover over the tactic you can take a
    look at its documentation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有趣的策略是 `wlog` 策略，它封装了上述非正式证明中的对称性论证。我们现在不会过多讨论它，但请注意，它确实做了我们想要的事情。如果你悬停在策略上，你可以查看它的文档。
- en: The argument for surjectivity is even easier. Given \(y\) in \(\beta\), we consider
    two cases, depending on whether \(g(y)\) is in \(A\). If it is, it can’t be in
    \(S_0\), the outermost ring, because by definition that is disjoint from the image
    of \(g\). Thus it is an element of \(S_{n+1}\) for some \(n\). This means that
    it is of the form \(g(f(x))\) for some \(x\) in \(S_n\). By the injectivity of
    \(g\), we have \(f(x) = y\). In the case where \(g(y)\) is in the complement of
    \(A\), we immediately have \(h(g(y))= y\), and we are done.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 投射性的论证甚至更简单。给定 \(\beta\) 中的 \(y\)，我们考虑两种情况，取决于 \(g(y)\) 是否在 \(A\) 中。如果它在，它不能在
    \(S_0\) 中，即最外层环，因为根据定义，它与 \(g\) 的像不相交。因此，它是 \(S_{n+1}\) 中某个 \(n\) 的一个元素。这意味着它具有
    \(g(f(x))\) 的形式，其中 \(x\) 是 \(S_n\) 中的一个元素。根据 \(g\) 的单射性，我们有 \(f(x) = y\)。在 \(g(y)\)
    在 \(A\) 的补集中的情况下，我们立即得到 \(h(g(y))= y\)，这就完成了。
- en: Once again, we encourage you to step through the proof and fill in the missing
    parts. The tactic `rcases n with _ | n` splits on the cases `g y ∈ sbAux f g 0`
    and `g y ∈ sbAux f g (n + 1)`. In both cases, calling the simplifier with `simp
    [sbAux]` applies the corresponding defining equation of `sbAux`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 再次鼓励你逐步通过证明并填补缺失的部分。策略 `rcases n with _ | n` 在 `g y ∈ sbAux f g 0` 和 `g y ∈
    sbAux f g (n + 1)` 的情况下进行拆分。在这两种情况下，使用 `simp [sbAux]` 调用简化器应用 `sbAux` 的对应定义方程。
- en: '[PRE45]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We can now put it all together. The final statement is short and sweet, and
    the proof uses the fact that `Bijective h` unfolds to `Injective h ∧ Surjective
    h`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将所有这些放在一起。最终陈述简短而甜蜜，证明使用了 `Bijective h` 展开为 `Injective h ∧ Surjective
    h` 的事实。
- en: '[PRE46] [Previous](C03_Logic.html "3\. Logic") [Next](C05_Elementary_Number_Theory.html
    "5\. Elementary Number Theory")'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE46] [上一节](C03_Logic.html "3. 逻辑") [下一节](C05_Elementary_Number_Theory.html
    "5. 初等数论")'
- en: '* * *'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: © Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: © 版权所有 2020-2025，Jeremy Avigad，Patrick Massot。文本许可协议为 CC BY 4.0。
- en: Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). The vocabulary of sets,
    relations, and functions provides a uniform language for carrying out constructions
    in all the branches of mathematics. Since functions and relations can be defined
    in terms of sets, axiomatic set theory can be used as a foundation for mathematics.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [Sphinx](https://www.sphinx-doc.org/) 和由 [Read the Docs](https://readthedocs.org)
    提供的 [主题](https://github.com/readthedocs/sphinx_rtd_theme) 构建。集合、关系和函数的词汇为在数学的所有分支中进行构造提供了一个统一的语言。由于函数和关系可以用集合来定义，公理化集合论可以用作数学的基础。
- en: 'Lean’s foundation is based instead on the primitive notion of a *type*, and
    it includes ways of defining functions between types. Every expression in Lean
    has a type: there are natural numbers, real numbers, functions from reals to reals,
    groups, vector spaces, and so on. Some expressions *are* types, which is to say,
    their type is `Type`. Lean and Mathlib provide ways of defining new types, and
    ways of defining objects of those types.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 的基础建立在原始概念 *类型* 之上，并且包括定义类型之间函数的方法。Lean 中的每个表达式都有一个类型：有自然数、实数、从实数到实数的函数、群、向量空间等等。一些表达式
    *是* 类型，这意味着它们的类型是 `Type`。Lean 和 Mathlib 提供了定义新类型以及定义这些类型对象的方法。
- en: Conceptually, you can think of a type as just a set of objects. Requiring every
    object to have a type has some advantages. For example, it makes it possible to
    overload notation like `+`, and it sometimes makes input less verbose because
    Lean can infer a lot of information from an object’s type. The type system also
    enables Lean to flag errors when you apply a function to the wrong number of arguments,
    or apply a function to arguments of the wrong type.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，你可以将类型视为一组对象的集合。要求每个对象都具有类型有一些优点。例如，它使得重载符号（如`+`）成为可能，有时它还使得输入更加简洁，因为
    Lean 可以从对象的类型中推断出很多信息。类型系统还使 Lean 能够在将函数应用于错误数量的参数或应用于错误类型的参数时标记错误。
- en: Lean’s library does define elementary set-theoretic notions. In contrast to
    set theory, in Lean a set is always a set of objects of some type, such as a set
    of natural numbers or a set of functions from real numbers to real numbers. The
    distinction between types and sets takes some getting used to, but this chapter
    will take you through the essentials.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 的库确实定义了基本的集合论概念。与集合论不同，在 Lean 中，集合始终是一组具有某种类型的对象，例如自然数集合或从实数到实数的函数集合。类型与集合之间的区别需要一些习惯，但本章将带你了解其基本内容。
- en: '## 4.1\. Sets[](#sets "Link to this heading")'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '## 4.1\. 集合[](#sets "链接到本标题")'
- en: 'If `α` is any type, the type `Set α` consists of sets of elements of `α`. This
    type supports the usual set-theoretic operations and relations. For example, `s
    ⊆ t` says that `s` is a subset of `t`, `s ∩ t` denotes the intersection of `s`
    and `t`, and `s ∪ t` denotes their union. The subset relation can be typed with
    `\ss` or `\sub`, intersection can be typed with `\i` or `\cap`, and union can
    be typed with `\un` or `\cup`. The library also defines the set `univ`, which
    consists of all the elements of type `α`, and the empty set, `∅`, which can be
    typed as `\empty`. Given `x : α` and `s : Set α`, the expression `x ∈ s` says
    that `x` is a member of `s`. Theorems that mention set membership often include
    `mem` in their name. The expression `x ∉ s` abbreviates `¬ x ∈ s`. You can type
    `∈` as `\in` or `\mem` and `∉` as `\notin`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `α` 是任何类型，则类型 `Set α` 由 `α` 的元素集合组成。此类型支持通常的集合论操作和关系。例如，`s ⊆ t` 表示 `s` 是
    `t` 的子集，`s ∩ t` 表示 `s` 和 `t` 的交集，`s ∪ t` 表示它们的并集。子集关系可以用 `\ss` 或 `\sub` 来表示，交集可以用
    `\i` 或 `\cap` 来表示，并集可以用 `\un` 或 `\cup` 来表示。库还定义了包含类型 `α` 所有元素的集合 `univ` 和空集 `∅`，它可以表示为
    `\empty`。给定 `x : α` 和 `s : Set α`，表达式 `x ∈ s` 表示 `x` 是 `s` 的成员。提及集合成员关系的定理通常在其名称中包含
    `mem`。表达式 `x ∉ s` 简写为 `¬ x ∈ s`。你可以用 `\in` 或 `\mem` 来表示 `∈`，用 `\notin` 来表示 `∉`。'
- en: One way to prove things about sets is to use `rw` or the simplifier to expand
    the definitions. In the second example below, we use `simp only` to tell the simplifier
    to use only the list of identities we give it, and not its full database of identities.
    Unlike `rw`, `simp` can perform simplifications inside a universal or existential
    quantifier. If you step through the proof, you can see the effects of these commands.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 证明集合属性的一种方法是通过 `rw` 或简化器展开定义。在下面的第二个例子中，我们使用 `simp only` 来告诉简化器只使用我们给出的标识符列表，而不是其完整的标识符数据库。与
    `rw` 不同，`simp` 可以在全称量词或存在量词内部执行简化。如果你逐步查看证明，你可以看到这些命令的效果。
- en: '[PRE47]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In this example, we open the `set` namespace to have access to the shorter
    names for the theorems. But, in fact, we can delete the calls to `rw` and `simp`
    entirely:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们打开 `set` 命名空间以访问定理的简短名称。但实际上，我们可以完全删除对 `rw` 和 `simp` 的调用：
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'What is going on here is known as *definitional reduction*: to make sense of
    the `intro` command and the anonymous constructors Lean is forced to expand the
    definitions. The following example also illustrate the phenomenon:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情被称为 *定义性简化*：为了理解 `intro` 命令和匿名构造函数，Lean 被迫展开定义。以下示例也说明了这种现象：
- en: '[PRE49]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To deal with unions, we can use `Set.union_def` and `Set.mem_union`. Since `x
    ∈ s ∪ t` unfolds to `x ∈ s ∨ x ∈ t`, we can also use the `cases` tactic to force
    a definitional reduction.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理并集，我们可以使用 `Set.union_def` 和 `Set.mem_union`。由于 `x ∈ s ∪ t` 展开为 `x ∈ s ∨
    x ∈ t`，我们也可以使用 `cases` 策略来强制进行定义性简化。
- en: '[PRE50]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Since intersection binds tighter than union, the use of parentheses in the
    expression `(s ∩ t) ∪ (s ∩ u)` is unnecessary, but they make the meaning of the
    expression clearer. The following is a shorter proof of the same fact:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于交集比并集绑定更紧密，表达式 `(s ∩ t) ∪ (s ∩ u)` 中的括号是不必要的，但它们使表达式的含义更清晰。以下是对同一事实的更简短的证明：
- en: '[PRE51]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As an exercise, try proving the other inclusion:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试证明另一个包含关系：
- en: '[PRE52]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: It might help to know that when using `rintro`, sometimes we need to use parentheses
    around a disjunctive pattern `h1 | h2` to get Lean to parse it correctly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有时了解当使用 `rintro` 时，有时需要在析取模式 `h1 | h2` 的周围使用括号，以便 Lean 正确解析它。
- en: The library also defines set difference, `s \ t`, where the backslash is a special
    unicode character entered as `\\`. The expression `x ∈ s \ t` expands to `x ∈
    s ∧ x ∉ t`. (The `∉` can be entered as `\notin`.) It can be rewritten manually
    using `Set.diff_eq` and `dsimp` or `Set.mem_diff`, but the following two proofs
    of the same inclusion show how to avoid using them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 库还定义了集合差，`s \ t`，其中反斜杠是一个特殊的 Unicode 字符，输入为 `\\`。表达式 `x ∈ s \ t` 展开为 `x ∈ s
    ∧ x ∉ t`。（`∉` 可以输入为 `\notin`。）可以使用 `Set.diff_eq` 和 `dsimp` 或 `Set.mem_diff` 手动重写，但以下两个证明相同包含关系的例子显示了如何避免使用它们。
- en: '[PRE53]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As an exercise, prove the reverse inclusion:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，证明反向包含关系：
- en: '[PRE54]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: To prove that two sets are equal, it suffices to show that every element of
    one is an element of the other. This principle is known as “extensionality,” and,
    unsurprisingly, the `ext` tactic is equipped to handle it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明两个集合相等，只需证明一个集合的每个元素也是另一个集合的元素。这个原则被称为“外延性”，并且，不出所料，`ext` 策略被配置来处理它。
- en: '[PRE55]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once again, deleting the line `simp only [mem_inter_iff]` does not harm the
    proof. In fact, if you like inscrutable proof terms, the following one-line proof
    is for you:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，删除 `simp only [mem_inter_iff]` 这一行并不会损害证明。事实上，如果你喜欢难以理解的证明项，以下是一行证明：
- en: '[PRE56]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here is an even shorter proof, using the simplifier:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个更短的证明，使用简化器：
- en: '[PRE57]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: An alternative to using `ext` is to use the theorem `Subset.antisymm` which
    allows us to prove an equation `s = t` between sets by proving `s ⊆ t` and `t
    ⊆ s`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ext` 的另一种方法是使用定理 `Subset.antisymm`，它允许我们通过证明 `s ⊆ t` 和 `t ⊆ s` 来证明集合之间的等式
    `s = t`。
- en: '[PRE58]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Try finishing this proof term:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试完成这个证明项：
- en: '[PRE59]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Remember that you can replace sorry by an underscore, and when you hover over
    it, Lean will show you what it expects at that point.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以用下划线替换 `sorry`，当你悬停在它上面时，Lean 将显示它在那个点期望的内容。
- en: 'Here are some set-theoretic identities you might enjoy proving:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可能喜欢证明的集合论恒等式：
- en: '[PRE60]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When it comes to representing sets, here is what is going on underneath the
    hood. In type theory, a *property* or *predicate* on a type `α` is just a function
    `P : α → Prop`. This makes sense: given `a : α`, `P a` is just the proposition
    that `P` holds of `a`. In the library, `Set α` is defined to be `α → Prop` and
    `x ∈ s` is defined to be `s x`. In other words, sets are really properties, treated
    as objects.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '当涉及到表示集合时，以下是底层的操作。在类型论中，类型 `α` 上的一个 **属性** 或 **谓词** 只是一个函数 `P : α → Prop`。这很有意义：给定
    `a : α`，`P a` 只是 `P` 对 `a` 成立的命题。在库中，`Set α` 被定义为 `α → Prop`，`x ∈ s` 被定义为 `s x`。换句话说，集合实际上是属性，被视为对象。'
- en: 'The library also defines set-builder notation. The expression `{ y | P y }`
    unfolds to `(fun y ↦ P y)`, so `x ∈ { y | P y }` reduces to `P x`. So we can turn
    the property of being even into the set of even numbers:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 库还定义了集合构造表示法。表达式 `{ y | P y }` 展开为 `(fun y ↦ P y)`，因此 `x ∈ { y | P y }` 简化为
    `P x`。因此，我们可以将偶数的属性转换为偶数集合：
- en: '[PRE61]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You should step through this proof and make sure you understand what is going
    on. Note we tell the simplifier to *not* use the lemma `Nat.not_even_iff` because
    we want to keep `¬ Even n` in our goal. Try deleting the line `rw [evens, odds]`
    and confirm that the proof still works.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该逐步进行这个证明，并确保你理解发生了什么。注意我们告诉简化器**不要**使用引理 `Nat.not_even_iff`，因为我们想在目标中保留 `¬
    Even n`。尝试删除 `rw [evens, odds]` 这一行，并确认证明仍然有效。
- en: In fact, set-builder notation is used to define
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，集合构造表示法用于定义
- en: '`s ∩ t` as `{x | x ∈ s ∧ x ∈ t}`,'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s ∩ t` 作为 `{x | x ∈ s ∧ x ∈ t}`，'
- en: '`s ∪ t` as `{x | x ∈ s ∨ x ∈ t}`,'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s ∪ t` 作为 `{x | x ∈ s ∨ x ∈ t}`，'
- en: '`∅` as `{x | False}`, and'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`∅` 作为 `{x | False}`，并且'
- en: '`univ` as `{x | True}`.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`univ` 作为 `{x | True}`。'
- en: We often need to indicate the type of `∅` and `univ` explicitly, because Lean
    has trouble guessing which ones we mean. The following examples show how Lean
    unfolds the last two definitions when needed. In the second one, `trivial` is
    the canonical proof of `True` in the library.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要明确指出 `∅` 和 `univ` 的类型，因为 Lean 难以猜测我们指的是哪一个。以下示例显示 Lean 在需要时如何展开最后两个定义。在第二个示例中，`trivial`
    是库中 `True` 的标准证明。
- en: '[PRE62]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As an exercise, prove the following inclusion. Use `intro n` to unfold the definition
    of subset, and use the simplifier to reduce the set-theoretic constructions to
    logic. We also recommend using the theorems `Nat.Prime.eq_two_or_odd` and `Nat.odd_iff`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，证明以下包含关系。使用 `intro n` 展开子集的定义，并使用简化器将集合论构造简化为逻辑。我们还建议使用定理 `Nat.Prime.eq_two_or_odd`
    和 `Nat.odd_iff`。
- en: '[PRE63]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Be careful: it is somewhat confusing that the library has multiple versions
    of the predicate `Prime`. The most general one makes sense in any commutative
    monoid with a zero element. The predicate `Nat.Prime` is specific to the natural
    numbers. Fortunately, there is a theorem that says that in the specific case,
    the two notions agree, so you can always rewrite one to the other.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意：库中存在多个版本的谓词 `Prime`，这可能会有些令人困惑。最一般的一个在任何带有零元素的交换幺半群中都有意义。谓词 `Nat.Prime`
    专门针对自然数。幸运的是，有一个定理说明在特定情况下，这两个概念是一致的，因此你可以总是将一个重写为另一个。
- en: '[PRE64]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The rwa tactic follows a rewrite with the assumption tactic.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: rwa 策略遵循带有假设策略的重写。
- en: '[PRE65]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Lean introduces the notation `∀ x ∈ s, ...`, “for every `x` in `s` .,” as an
    abbreviation for `∀ x, x ∈ s → ...`. It also introduces the notation `∃ x ∈ s,
    ...,` “there exists an `x` in `s` such that ..” These are sometimes known as *bounded
    quantifiers*, because the construction serves to restrict their significance to
    the set `s`. As a result, theorems in the library that make use of them often
    contain `ball` or `bex` in the name. The theorem `bex_def` asserts that `∃ x ∈
    s, ...` is equivalent to `∃ x, x ∈ s ∧ ...,` but when they are used with `rintro`,
    `use`, and anonymous constructors, these two expressions behave roughly the same.
    As a result, we usually don’t need to use `bex_def` to transform them explicitly.
    Here are some examples of how they are used:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 引入符号 `∀ x ∈ s, ...`，表示“对于 `s` 中的每个 `x` ...”，作为 `∀ x, x ∈ s → ...` 的缩写。它还引入了符号
    `∃ x ∈ s, ...,`，表示“存在一个 `s` 中的 `x` 使得 ...”。这些有时被称为 *有界量词*，因为这种构造有助于将它们的含义限制在集合
    `s` 中。因此，使用它们的库中的定理通常包含 `ball` 或 `bex` 在其名称中。定理 `bex_def` 断言 `∃ x ∈ s, ...` 等价于
    `∃ x, x ∈ s ∧ ...,` 但当它们与 `rintro`、`use` 和匿名构造函数一起使用时，这两个表达式的行为大致相同。因此，我们通常不需要使用
    `bex_def` 来显式地转换它们。以下是一些它们的使用示例：
- en: '[PRE66]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'See if you can prove these slight variations:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能证明这些细微的变化：
- en: '[PRE67]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Indexed unions and intersections are another important set-theoretic construction.
    We can model a sequence \(A_0, A_1, A_2, \ldots\) of sets of elements of `α` as
    a function `A : ℕ → Set α`, in which case `⋃ i, A i` denotes their union, and
    `⋂ i, A i` denotes their intersection. There is nothing special about the natural
    numbers here, so `ℕ` can be replaced by any type `I` used to index the sets. The
    following illustrates their use.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '指数并集和交集是另一种重要的集合论构造。我们可以将元素 `α` 的集合序列 \(A_0, A_1, A_2, \ldots\) 模拟为一个函数 `A
    : ℕ → Set α`，在这种情况下，`⋃ i, A i` 表示它们的并集，而 `⋂ i, A i` 表示它们的交集。这里关于自然数没有什么特殊之处，因此
    `ℕ` 可以被任何用于索引集合的类型 `I` 替换。以下展示了它们的使用。'
- en: '[PRE68]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Parentheses are often needed with an indexed union or intersection because,
    as with the quantifiers, the scope of the bound variable extends as far as it
    can.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 指数并集或交集通常需要括号，因为，与量词一样，约束变量的作用域延伸到尽可能远的地方。
- en: 'Try proving the following identity. One direction requires classical logic!
    We recommend using `by_cases xs : x ∈ s` at an appropriate point in the proof.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '尝试证明以下恒等式。其中一个方向需要使用经典逻辑！我们建议在证明的适当位置使用 `by_cases xs : x ∈ s`。'
- en: '[PRE69]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Mathlib also has bounded unions and intersections, which are analogous to the
    bounded quantifiers. You can unpack their meaning with `mem_iUnion₂` and `mem_iInter₂`.
    As the following examples show, Lean’s simplifier carries out these replacements
    as well.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 还具有有界并集和交集，它们与有界量词类似。你可以使用 `mem_iUnion₂` 和 `mem_iInter₂` 来展开它们的意义。以下示例显示，Lean
    的简化器也会执行这些替换。
- en: '[PRE70]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Try solving the following example, which is similar. If you start typing `eq_univ`,
    tab completion will tell you that `apply eq_univ_of_forall` is a good way to start
    the proof. We also recommend using the theorem `Nat.exists_infinite_primes`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试解决以下类似示例，如果你开始输入 `eq_univ`，Tab 补全会告诉你 `apply eq_univ_of_forall` 是开始证明的好方法。我们还推荐使用定理
    `Nat.exists_infinite_primes`。
- en: '[PRE71]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Give a collection of sets, `s : Set (Set α)`, their union, `⋃₀ s`, has type
    `Set α` and is defined as `{x | ∃ t ∈ s, x ∈ t}`. Similarly, their intersection,
    `⋂₀ s`, is defined as `{x | ∀ t ∈ s, x ∈ t}`. These operations are called `sUnion`
    and `sInter`, respectively. The following examples show their relationship to
    bounded union and intersection.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个集合族，`s : Set (Set α)`，它们的并集 `⋃₀ s` 的类型为 `Set α`，定义为 `{x | ∃ t ∈ s, x ∈
    t}`。同样，它们的交集 `⋂₀ s` 定义为 `{x | ∀ t ∈ s, x ∈ t}`。这些操作分别称为 `sUnion` 和 `sInter`。以下示例展示了它们与有界并集和交集的关系。'
- en: '[PRE72]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the library, these identities are called `sUnion_eq_biUnion` and `sInter_eq_biInter`.  ##
    4.2\. Functions[](#functions "Link to this heading")'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在图书馆中，这些标识符被称为 `sUnion_eq_biUnion` 和 `sInter_eq_biInter`。## 4.2\. 函数[](#functions
    "链接到本标题")
- en: 'If `f : α → β` is a function and `p` is a set of elements of type `β`, the
    library defines `preimage f p`, written `f ⁻¹'' p`, to be `{x | f x ∈ p}`. The
    expression `x ∈ f ⁻¹'' p` reduces to `f x ∈ p`. This is often convenient, as in
    the following example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `f : α → β` 是一个函数，且 `p` 是类型 `β` 的元素集合，则图书馆定义 `preimage f p`，写作 `f ⁻¹'' p`，为
    `{x | f x ∈ p}`。表达式 `x ∈ f ⁻¹'' p` 简化为 `f x ∈ p`。这通常很方便，如下例所示：'
- en: '[PRE73]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If `s` is a set of elements of type `α`, the library also defines `image f
    s`, written `f '''' s`, to be `{y | ∃ x, x ∈ s ∧ f x = y}`. So a hypothesis `y
    ∈ f '''' s` decomposes to a triple `⟨x, xs, xeq⟩` with `x : α` satisfying the
    hypotheses `xs : x ∈ s` and `xeq : f x = y`. The `rfl` tag in the `rintro` tactic
    (see [Section 3.2](C03_Logic.html#the-existential-quantifier)) was made precisely
    for this sort of situation.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `s` 是类型 `α` 的元素集合，则图书馆还定义 `image f s`，写作 `f '''' s`，为 `{y | ∃ x, x ∈ s ∧
    f x = y}`。因此，假设 `y ∈ f '''' s` 分解为一个三元组 `⟨x, xs, xeq⟩`，其中 `x : α` 满足假设 `xs : x
    ∈ s` 和 `xeq : f x = y`。`rintro` 策略中的 `rfl` 标签（见 [第 3.2 节](C03_Logic.html#the-existential-quantifier)）正是为了这种情况而设计的。'
- en: '[PRE74]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Notice also that the `use` tactic applies `rfl` to close goals when it can.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当 `use` 策略可以时，它会应用 `rfl` 来关闭目标。
- en: 'Here is another example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子：
- en: '[PRE75]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We can replace the line `use x, xs` by `apply mem_image_of_mem f xs` if we want
    to use a theorem specifically designed for that purpose. But knowing that the
    image is defined in terms of an existential quantifier is often convenient.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用专门为此目的设计的定理，可以将行 `use x, xs` 替换为 `apply mem_image_of_mem f xs`。但知道像是由存在量词定义的通常很方便。
- en: 'The following equivalence is a good exercise:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下等价关系是一个很好的练习：
- en: '[PRE76]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: It shows that `image f` and `preimage f` are an instance of what is known as
    a *Galois connection* between `Set α` and `Set β`, each partially ordered by the
    subset relation. In the library, this equivalence is named `image_subset_iff`.
    In practice, the right-hand side is often the more useful representation, because
    `y ∈ f ⁻¹' t` unfolds to `f y ∈ t` whereas working with `x ∈ f '' s` requires
    decomposing an existential quantifier.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 它表明 `image f` 和 `preimage f` 是 `Set α` 和 `Set β` 之间所知的一种称为 *Galois 连接* 的实例，每个部分有序集由子集关系定义。在图书馆中，这个等价关系被称为
    `image_subset_iff`。在实践中，右侧通常更有用，因为 `y ∈ f ⁻¹' t` 展开为 `f y ∈ t`，而处理 `x ∈ f '' s`
    需要分解存在量词。
- en: Here is a long list of set-theoretic identities for you to enjoy. You don’t
    have to do all of them at once; do a few of them, and set the rest aside for a
    rainy day.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一长串的集合论恒等式供你欣赏。你不必一次做所有这些；做几个，把剩下的留到雨天再做。
- en: '[PRE77]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You can also try your hand at the next group of exercises, which characterize
    the behavior of images and preimages with respect to indexed unions and intersections.
    In the third exercise, the argument `i : I` is needed to guarantee that the index
    set is nonempty. To prove any of these, we recommend using `ext` or `intro` to
    unfold the meaning of an equation or inclusion between sets, and then calling
    `simp` to unpack the conditions for membership.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '你也可以尝试下一组练习，这些练习描述了与索引并集和交集相关的像和原像的行为。在第三个练习中，需要参数 `i : I` 来保证索引集非空。为了证明这些中的任何一个，我们建议使用
    `ext` 或 `intro` 来展开方程或集合之间的包含关系，然后调用 `simp` 来展开成员资格的条件。'
- en: '[PRE78]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The library defines a predicate `InjOn f s` to say that `f` is injective on
    `s`. It is defined as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆定义了一个谓词 `InjOn f s` 来表示 `f` 在 `s` 上是单射。它被定义为如下：
- en: '[PRE79]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The statement `Injective f` is provably equivalent to `InjOn f univ`. Similarly,
    the library defines `range f` to be `{x | ∃y, f y = x}`, so `range f` is provably
    equal to `f '''' univ`. This is a common theme in Mathlib: although many properties
    of functions are defined relative to their full domain, there are often relativized
    versions that restrict the statements to a subset of the domain type.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 声明 `Injective f` 可以被证明等价于 `InjOn f univ`。同样，库定义 `range f` 为 `{x | ∃y, f y =
    x}`，因此 `range f` 可以被证明等于 `f '' univ`。这是 Mathlib 中的一个常见主题：尽管函数的许多属性是在其完整域上定义的，但通常存在相对化版本，这些版本将陈述限制在域类型的一个子集上。
- en: 'Here are some examples of `InjOn` and `range` in use:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些 `InjOn` 和 `range` 的使用示例：
- en: '[PRE80]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Try proving these:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试证明以下内容：
- en: '[PRE81]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To define the inverse of a function `f : α → β`, we will use two new ingredients.
    First, we need to deal with the fact that an arbitrary type in Lean may be empty.
    To define the inverse to `f` at `y` when there is no `x` satisfying `f x = y`,
    we want to assign a default value in `α`. Adding the annotation `[Inhabited α]`
    as a variable is tantamount to assuming that `α` has a preferred element, which
    is denoted `default`. Second, in the case where there is more than one `x` such
    that `f x = y`, the inverse function needs to *choose* one of them. This requires
    an appeal to the *axiom of choice*. Lean allows various ways of accessing it;
    one convenient method is to use the classical `choose` operator, illustrated below.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '要定义函数 `f : α → β` 的逆，我们将使用两个新元素。首先，我们需要处理这样一个事实：在 Lean 中，任意类型可能是空的。当没有 `x`
    满足 `f x = y` 时，我们希望在 `α` 中分配一个默认值。将注释 `[Inhabited α]` 作为变量添加相当于假设 `α` 有一个首选元素，用
    `default` 表示。其次，在存在多个 `x` 满足 `f x = y` 的情况下，逆函数需要 *选择* 其中之一。这需要诉诸于 *选择公理*。Lean
    允许以各种方式访问它；一种方便的方法是使用经典的 `choose` 操作符，如下所示。'
- en: '[PRE82]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Given `h : ∃ x, P x`, the value of `Classical.choose h` is some `x` satisfying
    `P x`. The theorem `Classical.choose_spec h` says that `Classical.choose h` meets
    this specification.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '给定 `h : ∃ x, P x`，`Classical.choose h` 的值是满足 `P x` 的某个 `x`。定理 `Classical.choose_spec
    h` 表示 `Classical.choose h` 满足这一规范。'
- en: 'With these in hand, we can define the inverse function as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些之后，我们可以如下定义逆函数：
- en: '[PRE83]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The lines `noncomputable section` and `open Classical` are needed because we
    are using classical logic in an essential way. On input `y`, the function `inverse
    f` returns some value of `x` satisfying `f x = y` if there is one, and a default
    element of `α` otherwise. This is an instance of a *dependent if* construction,
    since in the positive case, the value returned, `Classical.choose h`, depends
    on the assumption `h`. The identity `dif_pos h` rewrites `if h : e then a else
    b` to `a` given `h : e`, and, similarly, `dif_neg h` rewrites it to `b` given
    `h : ¬ e`. There are also versions `if_pos` and `if_neg` that works for non-dependent
    if constructions and will be used in the next section. The theorem `inverse_spec`
    says that `inverse f` meets the first part of this specification.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '需要使用 `noncomputable section` 和 `open Classical` 这两行是因为我们在本质上使用了经典逻辑。对于输入 `y`，函数
    `inverse f` 如果存在满足 `f x = y` 的 `x`，则返回其某个值，否则返回 `α` 的默认元素。这是一个 *依赖条件* 构造的实例，因为在正面情况下，返回的值
    `Classical.choose h` 依赖于假设 `h`。恒等式 `dif_pos h` 将 `if h : e then a else b` 在 `h
    : e` 的情况下重写为 `a`，同样，`dif_neg h` 在 `h : ¬ e` 的情况下将其重写为 `b`。也存在 `if_pos` 和 `if_neg`
    版本，它们适用于非依赖条件构造，将在下一节中使用。定理 `inverse_spec` 表示 `inverse f` 满足这一规范的第一个部分。'
- en: Don’t worry if you do not fully understand how these work. The theorem `inverse_spec`
    alone should be enough to show that `inverse f` is a left inverse if and only
    if `f` is injective and a right inverse if and only if `f` is surjective. Look
    up the definition of `LeftInverse` and `RightInverse` by double-clicking or right-clicking
    on them in VS Code, or using the commands `#print LeftInverse` and `#print RightInverse`.
    Then try to prove the two theorems. They are tricky! It helps to do the proofs
    on paper before you start hacking through the details. You should be able to prove
    each of them with about a half-dozen short lines. If you are looking for an extra
    challenge, try to condense each proof to a single-line proof term.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不完全理解这些是如何工作的，不要担心。仅定理 `inverse_spec` 就足以表明 `inverse f` 是左逆当且仅当 `f` 是单射，并且是右逆当且仅当
    `f` 是满射。通过在 VS Code 中双击或右击它们来查找 `LeftInverse` 和 `RightInverse` 的定义，或使用命令 `#print
    LeftInverse` 和 `#print RightInverse`。然后尝试证明这两个定理。它们是有点棘手的！在开始处理细节之前，在纸上做证明会有所帮助。你应该能够用大约六行简短的代码证明每一个。如果你在寻找额外的挑战，尝试将每个证明压缩为单行证明项。
- en: '[PRE84]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We close this section with a type-theoretic statement of Cantor’s famous theorem
    that there is no surjective function from a set to its power set. See if you can
    understand the proof, and then fill in the two lines that are missing.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一个类型论陈述结束本节，即康托尔著名的定理：不存在从集合到其幂集的满射函数。看看你是否能理解证明，然后填写缺失的两行。
- en: '[PRE85]  ## 4.3\. The Schröder-Bernstein Theorem[](#the-schroder-bernstein-theorem
    "Link to this heading")'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE85]  ## 4.3. Schröder-Bernstein 定理[](#the-schroder-bernstein-theorem "链接到这个标题")'
- en: 'We close this chapter with an elementary but nontrivial theorem of set theory.
    Let \(\alpha\) and \(\beta\) be sets. (In our formalization, they will actually
    be types.) Suppose \(f : \alpha → \beta\) and \(g : \beta → \alpha\) are both
    injective. Intuitively, this means that \(\alpha\) is no bigger than \(\beta\)
    and vice-versa. If \(\alpha\) and \(\beta\) are finite, this implies that they
    have the same cardinality, which is equivalent to saying that there is a bijection
    between them. In the nineteenth century, Cantor stated that same result holds
    even in the case where \(\alpha\) and \(\beta\) are infinite. This was eventually
    established by Dedekind, Schröder, and Bernstein independently.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '我们以一个基本的但非平凡的集合论定理结束这一章。设 \(\alpha\) 和 \(\beta\) 是集合。（在我们的形式化中，它们实际上将是类型。）假设
    \(f : \alpha → \beta\) 和 \(g : \beta → \alpha\) 都是单射。直观上，这意味着 \(\alpha\) 不比 \(\beta\)
    大，反之亦然。如果 \(\alpha\) 和 \(\beta\) 是有限的，这表明它们有相同的基数，这等价于说它们之间存在双射。在19世纪，康托尔指出，即使
    \(\alpha\) 和 \(\beta\) 是无限的，同样的结果也成立。这最终由 Dedekind、Schröder 和 Bernstein 独立地建立。'
- en: Our formalization will introduce some new methods that we will explain in greater
    detail in chapters to come. Don’t worry if they go by too quickly here. Our goal
    is to show you that you already have the skills to contribute to the formal proof
    of a real mathematical result.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的形式化将引入一些新的方法，我们将在接下来的章节中更详细地解释。如果在这里它们进展得太快，请不要担心。我们的目标是向你展示，你已经拥有了为真实数学结果的形式证明做出贡献的技能。
- en: To understand the idea behind the proof, consider the image of the map \(g\)
    in \(\alpha\). On that image, the inverse of \(g\) is defined and is a bijection
    with \(\beta\).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解证明背后的思想，考虑映射 \(g\) 在 \(\alpha\) 中的像。在那个像上，\(g\) 的逆是定义好的，并且与 \(\beta\) 形成双射。
- en: '[![the Schröder Bernstein theorem](../Images/b9bd80157a93a7ba893a2f18cfdfed3b.png)](_images/schroeder_bernstein1.png)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![Schröder-Bernstein 定理](../Images/b9bd80157a93a7ba893a2f18cfdfed3b.png)'
- en: The problem is that the bijection does not include the shaded region in the
    diagram, which is nonempty if \(g\) is not surjective. Alternatively, we can use
    \(f\) to map all of \(\alpha\) to \(\beta\), but in that case the problem is that
    if \(f\) is not surjective, it will miss some elements of \(\beta\).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，双射不包括图中的阴影区域，如果 \(g\) 不是满射，则该区域非空。或者，我们可以使用 \(f\) 将所有的 \(\alpha\) 映射到 \(\beta\)，但那样的话，问题在于如果
    \(f\) 不是满射，它将错过 \(\beta\) 的某些元素。
- en: '[![the Schröder Bernstein theorem](../Images/3a2cb3f7312f2e87d498ab1df6ab3f1b.png)](_images/schroeder_bernstein2.png)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![Schröder-Bernstein 定理](../Images/3a2cb3f7312f2e87d498ab1df6ab3f1b.png)'
- en: But now consider the composition \(g \circ f\) from \(\alpha\) to itself. Because
    the composition is injective, it forms a bijection between \(\alpha\) and its
    image, yielding a scaled-down copy of \(\alpha\) inside itself.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在考虑从 \(\alpha\) 到自身的复合 \(g \circ f\)。因为复合是单射的，它形成了 \(\alpha\) 和其像之间的双射，从而在
    \(\alpha\) 内部产生了一个缩小的 \(\alpha\) 的副本。
- en: '[![the Schröder Bernstein theorem](../Images/1e07afa02f123c9afbedf2f6dd380690.png)](_images/schroeder_bernstein3.png)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![Schröder-Bernstein 定理](../Images/1e07afa02f123c9afbedf2f6dd380690.png)'
- en: This composition maps the inner shaded ring to yet another such set, which we
    can think of as an even smaller concentric shaded ring, and so on. This yields
    a concentric sequence of shaded rings, each of which is in bijective correspondence
    with the next. If we map each ring to the next and leave the unshaded parts of
    \(\alpha\) alone, we have a bijection of \(\alpha\) with the image of \(g\). Composing
    with \(g^{-1}\), this yields the desired bijection between \(\alpha\) and \(\beta\).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个复合将内部阴影环映射到另一个这样的集合，我们可以将其视为一个更小的同心阴影环，依此类推。这产生了一系列同心阴影环，每个环都与下一个环一一对应。如果我们将每个环映射到下一个环，并让
    \(\alpha\) 的非阴影部分保持不变，我们就得到了 \(\alpha\) 与 \(g\) 的像之间的双射。与 \(g^{-1}\) 组合，这就得到了
    \(\alpha\) 和 \(\beta\) 之间的所期望的双射。
- en: 'We can describe this bijection more simply. Let \(A\) be the union of the sequence
    of shaded regions, and define \(h : \alpha \to \beta\) as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以更简单地描述这个双射。令 \(A\) 为阴影区域序列的并集，并定义 \(h : \alpha \to \beta\) 如下：'
- en: \[\begin{split}h(x) = \begin{cases} f(x) & \text{if $x \in A$} \\ g^{-1}(x)
    & \text{otherwise.} \end{cases}\end{split}\]
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}h(x) = \begin{cases} f(x) & \text{if $x \in A$} \\ g^{-1}(x)
    & \text{otherwise.} \end{cases}\end{split}\]
- en: In other words, we use \(f\) on the shaded parts, and we use the inverse of
    \(g\) everywhere else. The resulting map \(h\) is injective because each component
    is injective and the images of the two components are disjoint. To see that it
    is surjective, suppose we are given a \(y\) in \(\beta\), and consider \(g(y)\).
    If \(g(y)\) is in one of the shaded regions, it cannot be in the first ring, so
    we have \(g(y) = g(f(x))\) for some \(x\) is in the previous ring. By the injectivity
    of \(g\), we have \(h(x) = f(x) = y\). If \(g(y)\) is not in the shaded region,
    then by the definition of \(h\), we have \(h(g(y))= y\). Either way, \(y\) is
    in the image of \(h\).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们在阴影部分使用 \(f\)，在其他所有地方使用 \(g\) 的逆。结果映射 \(h\) 是单射的，因为每个分量都是单射的，并且两个分量的像是不相交的。为了看到它是满射的，假设我们给定了一个在
    \(\beta\) 中的 \(y\)，并考虑 \(g(y)\)。如果 \(g(y)\) 在阴影区域的某个区域中，它不能在第一个环中，所以我们有 \(g(y)
    = g(f(x))\) 对于某个在先前环中的 \(x\)。根据 \(g\) 的单射性，我们有 \(h(x) = f(x) = y\)。如果 \(g(y)\)
    不在阴影区域中，那么根据 \(h\) 的定义，我们有 \(h(g(y))= y\)。无论如何，\(y\) 都在 \(h\) 的像中。
- en: This argument should sound plausible, but the details are delicate. Formalizing
    the proof will not only improve our confidence in the result, but also help us
    understand it better. Because the proof uses classical logic, we tell Lean that
    our definitions will generally not be computable.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个论点听起来似乎合理，但细节很微妙。形式化证明不仅会提高我们对结果的可信度，而且有助于我们更好地理解它。因为证明使用了经典逻辑，我们告诉 Lean 我们的定义通常是不可计算的。
- en: '[PRE86]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The annotation `[Nonempty β]` specifies that `β` is nonempty. We use it because
    the Mathlib primitive that we will use to construct \(g^{-1}\) requires it. The
    case of the theorem where \(\beta\) is empty is trivial, and even though it would
    not be hard to generalize the formalization to cover that case as well, we will
    not bother. Specifically, we need the hypothesis `[Nonempty β]` for the operation
    `invFun` that is defined in Mathlib. Given `x : α`, `invFun g x` chooses a preimage
    of `x` in `β` if there is one, and returns an arbitrary element of `β` otherwise.
    The function `invFun g` is always a left inverse if `g` is injective and a right
    inverse if `g` is surjective.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '注释 `[Nonempty β]` 指定 `β` 是非空的。我们使用它是因为我们将要使用的 Mathlib 原始操作来构造 \(g^{-1}\) 需要它。当
    \(\beta\) 为空的情况是平凡的，尽管将形式化推广到涵盖该情况并不困难，但我们不会费心去做。具体来说，我们需要 `[Nonempty β]` 假设来定义
    Mathlib 中的 `invFun` 操作。给定 `x : α`，`invFun g x` 如果存在，则选择 `x` 在 `β` 中的前像，否则返回 `β`
    的任意元素。如果 `g` 是单射的，则函数 `invFun g` 总是左逆；如果 `g` 是满射的，则它是右逆。'
- en: '[PRE87]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: We define the set corresponding to the union of the shaded regions as follows.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对应于阴影区域并集的集合定义为如下。
- en: '[PRE88]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The definition `sbAux` is an example of a *recursive definition*, which we will
    explain in the next chapter. It defines a sequence of sets
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `sbAux` 是一个 *递归定义* 的例子，我们将在下一章中解释。它定义了一系列集合
- en: \[\begin{split}S_0 &= \alpha ∖ g(\beta) \\ S_{n+1} &= g(f(S_n)).\end{split}\]
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}S_0 &= \alpha ∖ g(\beta) \\ S_{n+1} &= g(f(S_n)).\end{split}\]
- en: 'The definition `sbSet` corresponds to the set \(A = \bigcup_{n \in \mathbb{N}}
    S_n\) in our proof sketch. The function \(h\) described above is now defined as
    follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `sbSet` 对应于我们证明概要中的集合 \(A = \bigcup_{n \in \mathbb{N}} S_n\)。上面描述的函数 \(h\)
    现在定义如下：
- en: '[PRE89]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We will need the fact that our definition of \(g^{-1}\) is a right inverse on
    the complement of \(A\), which is to say, on the non-shaded regions of \(\alpha\).
    This is so because the outermost ring, \(S_0\), is equal to \(\alpha \setminus
    g(\beta)\), so the complement of \(A\) is contained in \(g(\beta)\). As a result,
    for every \(x\) in the complement of \(A\), there is a \(y\) such that \(g(y)
    = x\). (By the injectivity of \(g\), this \(y\) is unique, but next theorem says
    only that `invFun g x` returns some `y` such that `g y = x`.)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 \(g^{-1}\) 的定义在 \(A\) 的补集上是右逆的事实，也就是说，在 \(\alpha\) 的非阴影区域上。这是因为最外层的环 \(S_0\)
    等于 \(\alpha \setminus g(\beta)\)，所以 \(A\) 的补集包含在 \(g(\beta)\) 中。因此，对于 \(A\) 的补集中的每个
    \(x\)，都有一个 \(y\) 使得 \(g(y) = x\)。（根据 \(g\) 的单射性，这个 \(y\) 是唯一的，但下一个定理只说 `invFun
    g x` 返回某个 `y` 使得 `g y = x`。）
- en: Step through the proof below, make sure you understand what is going on, and
    fill in the remaining parts. You will need to use `invFun_eq` at the end. Notice
    that rewriting with `sbAux` here replaces `sbAux f g 0` with the right-hand side
    of the corresponding defining equation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步查看以下证明，确保你理解正在发生的事情，并填写剩余的部分。你将需要在最后使用`invFun_eq`。请注意，在这里使用`sbAux`重写将`sbAux
    f g 0`替换为相应定义方程的右侧。
- en: '[PRE90]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We now turn to the proof that \(h\) is injective. Informally, the proof goes
    as follows. First, suppose \(h(x_1) = h(x_2)\). If \(x_1\) is in \(A\), then \(h(x_1)
    = f(x_1)\), and we can show that \(x_2\) is in \(A\) as follows. If it isn’t,
    then we have \(h(x_2) = g^{-1}(x_2)\). From \(f(x_1) = h(x_1) = h(x_2)\) we have
    \(g(f(x_1)) = x_2\). From the definition of \(A\), since \(x_1\) is in \(A\),
    \(x_2\) is in \(A\) as well, a contradiction. Hence, if \(x_1\) is in \(A\), so
    is \(x_2\), in which case we have \(f(x_1) = h(x_1) = h(x_2) = f(x_2)\). The injectivity
    of \(f\) then implies \(x_1 = x_2\). The symmetric argument shows that if \(x_2\)
    is in \(A\), then so is \(x_1\), which again implies \(x_1 = x_2\).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在转向证明\(h\)是注入性的。非正式地说，证明如下。首先，假设\(h(x_1) = h(x_2)\)。如果\(x_1\)在\(A\)中，那么\(h(x_1)
    = f(x_1)\)，我们可以如下证明\(x_2\)在\(A\)中。如果它不在\(A\)中，那么我们有\(h(x_2) = g^{-1}(x_2)\)。从\(f(x_1)
    = h(x_1) = h(x_2)\)我们得到\(g(f(x_1)) = x_2\)。根据\(A\)的定义，由于\(x_1\)在\(A\)中，\(x_2\)也在\(A\)中，这是一个矛盾。因此，如果\(x_1\)在\(A\)中，那么\(x_2\)也在\(A\)中，在这种情况下，我们有\(f(x_1)
    = h(x_1) = h(x_2) = f(x_2)\)。\(f\)的注入性随后意味着\(x_1 = x_2\)。对称的论证表明，如果\(x_2\)在\(A\)中，那么\(x_1\)也在\(A\)中，这再次意味着\(x_1
    = x_2\)。
- en: The only remaining possibility is that neither \(x_1\) nor \(x_2\) is in \(A\).
    In that case, we have \(g^{-1}(x_1) = h(x_1) = h(x_2) = g^{-1}(x_2)\). Applying
    \(g\) to both sides yields \(x_1 = x_2\).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一可能性是\(x_1\)和\(x_2\)都不在\(A\)中。在这种情况下，我们有\(g^{-1}(x_1) = h(x_1) = h(x_2)
    = g^{-1}(x_2)\)。将\(g\)应用于两边得到\(x_1 = x_2\)。
- en: Once again, we encourage you to step through the following proof to see how
    the argument plays out in Lean. See if you can finish off the proof using `sb_right_inv`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们鼓励你逐步查看以下证明，以了解论证在Lean中的展开情况。看看你是否可以使用`sb_right_inv`来完成证明。
- en: '[PRE91]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The proof introduces some new tactics. To start with, notice the `set` tactic,
    which introduces abbreviations `A` and `h` for `sbSet f g` and `sb_fun f g` respectively.
    We name the corresponding defining equations `A_def` and `h_def`. The abbreviations
    are definitional, which is to say, Lean will sometimes unfold them automatically
    when needed. But not always; for example, when using `rw`, we generally need to
    use `A_def` and `h_def` explicitly. So the definitions bring a tradeoff: they
    can make expressions shorter and more readable, but they sometimes require us
    to do more work.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 证明引入了一些新的策略。首先，注意`set`策略，它为`sbSet f g`和`sb_fun f g`分别引入了缩写`A`和`h`。我们将相应的定义方程命名为`A_def`和`h_def`。这些缩写是定义性的，也就是说，当需要时，Lean有时会自动展开它们。但并非总是如此；例如，当使用`rw`时，我们通常需要显式地使用`A_def`和`h_def`。因此，这些定义带来了一种权衡：它们可以使表达式更短、更易读，但有时需要我们做更多的工作。
- en: A more interesting tactic is the `wlog` tactic, which encapsulates the symmetry
    argument in the informal proof above. We will not dwell on it now, but notice
    that it does exactly what we want. If you hover over the tactic you can take a
    look at its documentation.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有趣的策略是`wlog`策略，它封装了上述非正式证明中的对称论证。我们现在不会过多地讨论它，但请注意，它确实做了我们想要的事情。如果你悬停在策略上，你可以查看它的文档。
- en: The argument for surjectivity is even easier. Given \(y\) in \(\beta\), we consider
    two cases, depending on whether \(g(y)\) is in \(A\). If it is, it can’t be in
    \(S_0\), the outermost ring, because by definition that is disjoint from the image
    of \(g\). Thus it is an element of \(S_{n+1}\) for some \(n\). This means that
    it is of the form \(g(f(x))\) for some \(x\) in \(S_n\). By the injectivity of
    \(g\), we have \(f(x) = y\). In the case where \(g(y)\) is in the complement of
    \(A\), we immediately have \(h(g(y))= y\), and we are done.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于全射性的论证甚至更容易。给定\(\beta\)中的\(y\)，我们考虑两种情况，取决于\(g(y)\)是否在\(A\)中。如果它在\(A\)中，它不能在\(S_0\)中，即最外层环中，因为根据定义，它与\(g\)的像不相交。因此，它是某个\(n\)的\(S_{n+1}\)的元素。这意味着它是某种形式为\(g(f(x))\)的\(x\)在\(S_n\)中的形式。根据\(g\)的注入性，我们有\(f(x)
    = y\)。在\(g(y)\)在\(A\)的补集中时，我们立即得到\(h(g(y))= y\)，这就完成了。
- en: Once again, we encourage you to step through the proof and fill in the missing
    parts. The tactic `rcases n with _ | n` splits on the cases `g y ∈ sbAux f g 0`
    and `g y ∈ sbAux f g (n + 1)`. In both cases, calling the simplifier with `simp
    [sbAux]` applies the corresponding defining equation of `sbAux`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们鼓励你逐步通过证明并填补缺失的部分。策略 `rcases n with _ | n` 在情况 `g y ∈ sbAux f g 0` 和 `g
    y ∈ sbAux f g (n + 1)` 上进行分割。在这两种情况下，使用 `simp [sbAux]` 调用简化器应用 `sbAux` 的对应定义方程。
- en: '[PRE92]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We can now put it all together. The final statement is short and sweet, and
    the proof uses the fact that `Bijective h` unfolds to `Injective h ∧ Surjective
    h`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以把它们全部放在一起。最终的陈述简短而甜蜜，证明使用了 `Bijective h` 展开为 `Injective h ∧ Surjective
    h` 的事实。
- en: '[PRE93]  ## 4.1\. Sets[](#sets "Link to this heading")'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE93]  ## 4.1\. 集合[](#sets "链接到这个标题")'
- en: 'If `α` is any type, the type `Set α` consists of sets of elements of `α`. This
    type supports the usual set-theoretic operations and relations. For example, `s
    ⊆ t` says that `s` is a subset of `t`, `s ∩ t` denotes the intersection of `s`
    and `t`, and `s ∪ t` denotes their union. The subset relation can be typed with
    `\ss` or `\sub`, intersection can be typed with `\i` or `\cap`, and union can
    be typed with `\un` or `\cup`. The library also defines the set `univ`, which
    consists of all the elements of type `α`, and the empty set, `∅`, which can be
    typed as `\empty`. Given `x : α` and `s : Set α`, the expression `x ∈ s` says
    that `x` is a member of `s`. Theorems that mention set membership often include
    `mem` in their name. The expression `x ∉ s` abbreviates `¬ x ∈ s`. You can type
    `∈` as `\in` or `\mem` and `∉` as `\notin`.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `α` 是任何类型，类型 `Set α` 由 `α` 的元素组成的集合组成。此类型支持通常的集合论操作和关系。例如，`s ⊆ t` 表示 `s`
    是 `t` 的子集，`s ∩ t` 表示 `s` 和 `t` 的交集，`s ∪ t` 表示它们的并集。子集关系可以用 `\ss` 或 `\sub` 类型化，交集可以用
    `\i` 或 `\cap` 类型化，并集可以用 `\un` 或 `\cup` 类型化。库还定义了包含所有类型 `α` 的元素的集合 `univ`，以及空集
    `∅`，它可以被类型化为 `\empty`。给定 `x : α` 和 `s : Set α`，表达式 `x ∈ s` 表示 `x` 是 `s` 的成员。提到集合成员关系的定理通常在其名称中包含
    `mem`。表达式 `x ∉ s` 简写为 `¬ x ∈ s`。你可以将 `∈` 类型化为 `\in` 或 `\mem`，将 `∉` 类型化为 `\notin`。'
- en: One way to prove things about sets is to use `rw` or the simplifier to expand
    the definitions. In the second example below, we use `simp only` to tell the simplifier
    to use only the list of identities we give it, and not its full database of identities.
    Unlike `rw`, `simp` can perform simplifications inside a universal or existential
    quantifier. If you step through the proof, you can see the effects of these commands.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 证明关于集合的事情的一种方法是用 `rw` 或简化器展开定义。在下面的第二个例子中，我们使用 `simp only` 来告诉简化器只使用我们给出的标识符列表，而不是它的完整标识符数据库。与
    `rw` 不同，`simp` 可以在全称量词或存在量词内部执行简化。如果你逐步通过证明，你可以看到这些命令的效果。
- en: '[PRE94]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'In this example, we open the `set` namespace to have access to the shorter
    names for the theorems. But, in fact, we can delete the calls to `rw` and `simp`
    entirely:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们打开 `set` 命名空间以访问定理的简短名称。但实际上，我们可以完全删除对 `rw` 和 `simp` 的调用：
- en: '[PRE95]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'What is going on here is known as *definitional reduction*: to make sense of
    the `intro` command and the anonymous constructors Lean is forced to expand the
    definitions. The following example also illustrate the phenomenon:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情被称为*定义性约简*：为了理解 `intro` 命令和匿名构造函数，Lean 被迫展开定义。以下示例也说明了这种现象：
- en: '[PRE96]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: To deal with unions, we can use `Set.union_def` and `Set.mem_union`. Since `x
    ∈ s ∪ t` unfolds to `x ∈ s ∨ x ∈ t`, we can also use the `cases` tactic to force
    a definitional reduction.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理并集，我们可以使用 `Set.union_def` 和 `Set.mem_union`。由于 `x ∈ s ∪ t` 展开为 `x ∈ s ∨
    x ∈ t`，我们还可以使用 `cases` 策略强制进行定义性约简。
- en: '[PRE97]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Since intersection binds tighter than union, the use of parentheses in the
    expression `(s ∩ t) ∪ (s ∩ u)` is unnecessary, but they make the meaning of the
    expression clearer. The following is a shorter proof of the same fact:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于交集比并集绑定更紧密，表达式 `(s ∩ t) ∪ (s ∩ u)` 中的括号是不必要的，但它们使表达式的含义更清晰。以下是对同一事实的更简短的证明：
- en: '[PRE98]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'As an exercise, try proving the other inclusion:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试证明另一个包含关系：
- en: '[PRE99]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: It might help to know that when using `rintro`, sometimes we need to use parentheses
    around a disjunctive pattern `h1 | h2` to get Lean to parse it correctly.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 了解当使用 `rintro` 时，有时我们需要在析取模式 `h1 | h2` 的周围使用括号，以便 Lean 正确解析它可能会有所帮助。
- en: The library also defines set difference, `s \ t`, where the backslash is a special
    unicode character entered as `\\`. The expression `x ∈ s \ t` expands to `x ∈
    s ∧ x ∉ t`. (The `∉` can be entered as `\notin`.) It can be rewritten manually
    using `Set.diff_eq` and `dsimp` or `Set.mem_diff`, but the following two proofs
    of the same inclusion show how to avoid using them.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆还定义了集合差，`s \ t`，其中反斜杠是一个特殊的 Unicode 字符，输入为 `\\`。表达式 `x ∈ s \ t` 展开为 `x ∈
    s ∧ x ∉ t`。（`∉` 可以输入为 `\notin`。）可以使用 `Set.diff_eq` 和 `dsimp` 或 `Set.mem_diff`
    手动重写，但以下两个相同包含的证明显示了如何避免使用它们。
- en: '[PRE100]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'As an exercise, prove the reverse inclusion:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，证明反向包含：
- en: '[PRE101]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: To prove that two sets are equal, it suffices to show that every element of
    one is an element of the other. This principle is known as “extensionality,” and,
    unsurprisingly, the `ext` tactic is equipped to handle it.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明两个集合相等，只需证明一个集合的每个元素都是另一个集合的元素。这个原则被称为“扩展性”，而且不出所料，`ext` 策略被装备来处理它。
- en: '[PRE102]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Once again, deleting the line `simp only [mem_inter_iff]` does not harm the
    proof. In fact, if you like inscrutable proof terms, the following one-line proof
    is for you:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，删除 `simp only [mem_inter_iff]` 这一行不会损害证明。事实上，如果你喜欢难以理解的证明项，以下是一行证明：
- en: '[PRE103]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Here is an even shorter proof, using the simplifier:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更短的证明，使用了简化器：
- en: '[PRE104]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: An alternative to using `ext` is to use the theorem `Subset.antisymm` which
    allows us to prove an equation `s = t` between sets by proving `s ⊆ t` and `t
    ⊆ s`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ext` 的一个替代方法是使用定理 `Subset.antisymm`，它允许我们通过证明 `s ⊆ t` 和 `t ⊆ s` 来证明集合之间的等式
    `s = t`。
- en: '[PRE105]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Try finishing this proof term:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试完成这个证明项：
- en: '[PRE106]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Remember that you can replace sorry by an underscore, and when you hover over
    it, Lean will show you what it expects at that point.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以用下划线替换 sorry，当你悬停在它上面时，Lean 会显示它在该点的期望。
- en: 'Here are some set-theoretic identities you might enjoy proving:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可能喜欢证明的集合论恒等式：
- en: '[PRE107]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'When it comes to representing sets, here is what is going on underneath the
    hood. In type theory, a *property* or *predicate* on a type `α` is just a function
    `P : α → Prop`. This makes sense: given `a : α`, `P a` is just the proposition
    that `P` holds of `a`. In the library, `Set α` is defined to be `α → Prop` and
    `x ∈ s` is defined to be `s x`. In other words, sets are really properties, treated
    as objects.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '当涉及到表示集合时，以下是底层的操作。在类型论中，类型 `α` 上的一个 *属性* 或 *谓词* 只是一个函数 `P : α → Prop`。这很有意义：给定
    `a : α`，`P a` 只是 `P` 对 `a` 成立的命题。在库中，`Set α` 被定义为 `α → Prop`，`x ∈ s` 被定义为 `s x`。换句话说，集合实际上是属性，被视为对象。'
- en: 'The library also defines set-builder notation. The expression `{ y | P y }`
    unfolds to `(fun y ↦ P y)`, so `x ∈ { y | P y }` reduces to `P x`. So we can turn
    the property of being even into the set of even numbers:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆还定义了集合构造符号。表达式 `{ y | P y }` 展开为 `(fun y ↦ P y)`，因此 `x ∈ { y | P y }` 简化为
    `P x`。因此，我们可以将偶数的属性转换为偶数集合：
- en: '[PRE108]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: You should step through this proof and make sure you understand what is going
    on. Note we tell the simplifier to *not* use the lemma `Nat.not_even_iff` because
    we want to keep `¬ Even n` in our goal. Try deleting the line `rw [evens, odds]`
    and confirm that the proof still works.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该逐步进行这个证明，并确保你理解了正在发生的事情。注意，我们告诉简化器不要使用引理 `Nat.not_even_iff`，因为我们希望保留 `¬ Even
    n` 在我们的目标中。尝试删除 `rw [evens, odds]` 这一行，并确认证明仍然有效。
- en: In fact, set-builder notation is used to define
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，集合构造符号用于定义
- en: '`s ∩ t` as `{x | x ∈ s ∧ x ∈ t}`,'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s ∩ t` 作为 `{x | x ∈ s ∧ x ∈ t}`，'
- en: '`s ∪ t` as `{x | x ∈ s ∨ x ∈ t}`,'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s ∪ t` 作为 `{x | x ∈ s ∨ x ∈ t}`，'
- en: '`∅` as `{x | False}`, and'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`∅` 作为 `{x | False}`，并且'
- en: '`univ` as `{x | True}`.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`univ` 作为 `{x | True}`。'
- en: We often need to indicate the type of `∅` and `univ` explicitly, because Lean
    has trouble guessing which ones we mean. The following examples show how Lean
    unfolds the last two definitions when needed. In the second one, `trivial` is
    the canonical proof of `True` in the library.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要明确指出 `∅` 和 `univ` 的类型，因为 Lean 难以猜测我们指的是哪一个。以下示例显示了 Lean 在需要时如何展开最后两个定义。在第二个示例中，`trivial`
    是库中 `True` 的规范证明。
- en: '[PRE109]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: As an exercise, prove the following inclusion. Use `intro n` to unfold the definition
    of subset, and use the simplifier to reduce the set-theoretic constructions to
    logic. We also recommend using the theorems `Nat.Prime.eq_two_or_odd` and `Nat.odd_iff`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，证明以下包含。使用 `intro n` 展开子集的定义，并使用简化器将集合论构造简化为逻辑。我们还建议使用定理 `Nat.Prime.eq_two_or_odd`
    和 `Nat.odd_iff`。
- en: '[PRE110]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Be careful: it is somewhat confusing that the library has multiple versions
    of the predicate `Prime`. The most general one makes sense in any commutative
    monoid with a zero element. The predicate `Nat.Prime` is specific to the natural
    numbers. Fortunately, there is a theorem that says that in the specific case,
    the two notions agree, so you can always rewrite one to the other.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 小心：库中有多个版本的谓词 `Prime` 是有些令人困惑的。最通用的一种在任何具有零元素的交换幺半群中都有意义。谓词 `Nat.Prime` 专门针对自然数。幸运的是，有一个定理说在特定情况下，这两个概念是一致的，所以你可以总是将一个重写为另一个。
- en: '[PRE111]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The rwa tactic follows a rewrite with the assumption tactic.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: rwa 策略遵循重写与假设策略。
- en: '[PRE112]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Lean introduces the notation `∀ x ∈ s, ...`, “for every `x` in `s` .,” as an
    abbreviation for `∀ x, x ∈ s → ...`. It also introduces the notation `∃ x ∈ s,
    ...,` “there exists an `x` in `s` such that ..” These are sometimes known as *bounded
    quantifiers*, because the construction serves to restrict their significance to
    the set `s`. As a result, theorems in the library that make use of them often
    contain `ball` or `bex` in the name. The theorem `bex_def` asserts that `∃ x ∈
    s, ...` is equivalent to `∃ x, x ∈ s ∧ ...,` but when they are used with `rintro`,
    `use`, and anonymous constructors, these two expressions behave roughly the same.
    As a result, we usually don’t need to use `bex_def` to transform them explicitly.
    Here are some examples of how they are used:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Lean 引入了符号 `∀ x ∈ s, ...`，“对于 `s` 中的每个 `x` ...”，作为 `∀ x, x ∈ s → ...` 的缩写。它还引入了符号
    `∃ x ∈ s, ...,`，“存在一个 `s` 中的 `x` 使得 ...”。这些有时被称为 *有界量词*，因为这种构造有助于将它们的含义限制在集合 `s`
    中。因此，使用它们的库中的定理通常包含 `ball` 或 `bex` 在名称中。定理 `bex_def` 断言 `∃ x ∈ s, ...` 等价于 `∃
    x, x ∈ s ∧ ...,` 但当它们与 `rintro`、`use` 和匿名构造函数一起使用时，这两个表达式的行为大致相同。因此，我们通常不需要使用
    `bex_def` 来显式地转换它们。以下是一些它们的使用示例：
- en: '[PRE113]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'See if you can prove these slight variations:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能证明这些细微的变化：
- en: '[PRE114]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Indexed unions and intersections are another important set-theoretic construction.
    We can model a sequence \(A_0, A_1, A_2, \ldots\) of sets of elements of `α` as
    a function `A : ℕ → Set α`, in which case `⋃ i, A i` denotes their union, and
    `⋂ i, A i` denotes their intersection. There is nothing special about the natural
    numbers here, so `ℕ` can be replaced by any type `I` used to index the sets. The
    following illustrates their use.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '带索引的并集和交集是另一种重要的集合论构造。我们可以将元素 `α` 的集合序列 \(A_0, A_1, A_2, \ldots\) 模型化为函数 `A
    : ℕ → Set α`，在这种情况下，`⋃ i, A i` 表示它们的并集，`⋂ i, A i` 表示它们的交集。这里对自然数没有什么特殊之处，所以 `ℕ`
    可以被任何用于索引集合的类型 `I` 替换。以下说明了它们的使用。'
- en: '[PRE115]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Parentheses are often needed with an indexed union or intersection because,
    as with the quantifiers, the scope of the bound variable extends as far as it
    can.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 括号通常与带索引的并集或交集一起使用，因为，就像量词一样，约束变量的作用域延伸到尽可能远的地方。
- en: 'Try proving the following identity. One direction requires classical logic!
    We recommend using `by_cases xs : x ∈ s` at an appropriate point in the proof.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '尝试证明以下恒等式。其中一个方向需要经典逻辑！我们建议在证明的适当位置使用 `by_cases xs : x ∈ s`。'
- en: '[PRE116]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Mathlib also has bounded unions and intersections, which are analogous to the
    bounded quantifiers. You can unpack their meaning with `mem_iUnion₂` and `mem_iInter₂`.
    As the following examples show, Lean’s simplifier carries out these replacements
    as well.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 还具有有界并集和交集，它们与有界量词类似。你可以使用 `mem_iUnion₂` 和 `mem_iInter₂` 来展开它们的含义。以下示例显示，Lean
    的简化器也会执行这些替换。
- en: '[PRE117]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Try solving the following example, which is similar. If you start typing `eq_univ`,
    tab completion will tell you that `apply eq_univ_of_forall` is a good way to start
    the proof. We also recommend using the theorem `Nat.exists_infinite_primes`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试解决以下类似示例。如果你开始输入 `eq_univ`，Tab 完成会告诉你 `apply eq_univ_of_forall` 是开始证明的好方法。我们还建议使用定理
    `Nat.exists_infinite_primes`。
- en: '[PRE118]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Give a collection of sets, `s : Set (Set α)`, their union, `⋃₀ s`, has type
    `Set α` and is defined as `{x | ∃ t ∈ s, x ∈ t}`. Similarly, their intersection,
    `⋂₀ s`, is defined as `{x | ∀ t ∈ s, x ∈ t}`. These operations are called `sUnion`
    and `sInter`, respectively. The following examples show their relationship to
    bounded union and intersection.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个集合的集合，`s : Set (Set α)`，它们的并集，`⋃₀ s`，具有类型 `Set α`，定义为 `{x | ∃ t ∈ s, x
    ∈ t}`。同样，它们的交集，`⋂₀ s`，定义为 `{x | ∀ t ∈ s, x ∈ t}`。这些操作分别称为 `sUnion` 和 `sInter`。以下示例显示了它们与有界并集和交集的关系。'
- en: '[PRE119]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: In the library, these identities are called `sUnion_eq_biUnion` and `sInter_eq_biInter`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在库中，这些恒等式被称为 `sUnion_eq_biUnion` 和 `sInter_eq_biInter`。
- en: '## 4.2\. Functions[](#functions "Link to this heading")'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '## 4.2\. 函数[](#functions "链接到这个标题")'
- en: 'If `f : α → β` is a function and `p` is a set of elements of type `β`, the
    library defines `preimage f p`, written `f ⁻¹'' p`, to be `{x | f x ∈ p}`. The
    expression `x ∈ f ⁻¹'' p` reduces to `f x ∈ p`. This is often convenient, as in
    the following example:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `f : α → β` 是一个函数，且 `p` 是类型 `β` 的元素集合，则库定义了 `preimage f p`，写作 `f ⁻¹'' p`，表示
    `{x | f x ∈ p}`。表达式 `x ∈ f ⁻¹'' p` 简化为 `f x ∈ p`。这在以下例子中通常很方便：'
- en: '[PRE120]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'If `s` is a set of elements of type `α`, the library also defines `image f
    s`, written `f '''' s`, to be `{y | ∃ x, x ∈ s ∧ f x = y}`. So a hypothesis `y
    ∈ f '''' s` decomposes to a triple `⟨x, xs, xeq⟩` with `x : α` satisfying the
    hypotheses `xs : x ∈ s` and `xeq : f x = y`. The `rfl` tag in the `rintro` tactic
    (see [Section 3.2](C03_Logic.html#the-existential-quantifier)) was made precisely
    for this sort of situation.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `s` 是类型 `α` 的元素集合，则库还定义了 `image f s`，写作 `f '''' s`，表示 `{y | ∃ x, x ∈ s ∧
    f x = y}`。因此，假设 `y ∈ f '''' s` 分解为一个三元组 `⟨x, xs, xeq⟩`，其中 `x : α` 满足假设 `xs : x
    ∈ s` 和 `xeq : f x = y`。`rintro` 策略中的 `rfl` 标签（见 [第 3.2 节](C03_Logic.html#the-existential-quantifier)）正是为了这种情况而设计的。'
- en: '[PRE121]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Notice also that the `use` tactic applies `rfl` to close goals when it can.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当 `use` 策略可以时，它会应用 `rfl` 来关闭目标。
- en: 'Here is another example:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子：
- en: '[PRE122]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: We can replace the line `use x, xs` by `apply mem_image_of_mem f xs` if we want
    to use a theorem specifically designed for that purpose. But knowing that the
    image is defined in terms of an existential quantifier is often convenient.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用专门为此目的设计的定理，我们可以将 `use x, xs` 行替换为 `apply mem_image_of_mem f xs`。但知道图像是通过存在量词定义的通常很方便。
- en: 'The following equivalence is a good exercise:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 以下等价性是一个很好的练习：
- en: '[PRE123]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: It shows that `image f` and `preimage f` are an instance of what is known as
    a *Galois connection* between `Set α` and `Set β`, each partially ordered by the
    subset relation. In the library, this equivalence is named `image_subset_iff`.
    In practice, the right-hand side is often the more useful representation, because
    `y ∈ f ⁻¹' t` unfolds to `f y ∈ t` whereas working with `x ∈ f '' s` requires
    decomposing an existential quantifier.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 `image f` 和 `preimage f` 是 `Set α` 和 `Set β` 之间所知的一种称为 *Galois 连接* 的实例，每个部分有序集通过子集关系。在库中，这种等价性被命名为
    `image_subset_iff`。在实践中，右侧通常更有用，因为 `y ∈ f ⁻¹' t` 展开为 `f y ∈ t`，而处理 `x ∈ f '' s`
    需要分解存在量词。
- en: Here is a long list of set-theoretic identities for you to enjoy. You don’t
    have to do all of them at once; do a few of them, and set the rest aside for a
    rainy day.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一长串供你享受的集合论恒等式。你不必一次做所有这些；做几个，把剩下的留到雨天再处理。
- en: '[PRE124]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'You can also try your hand at the next group of exercises, which characterize
    the behavior of images and preimages with respect to indexed unions and intersections.
    In the third exercise, the argument `i : I` is needed to guarantee that the index
    set is nonempty. To prove any of these, we recommend using `ext` or `intro` to
    unfold the meaning of an equation or inclusion between sets, and then calling
    `simp` to unpack the conditions for membership.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '你也可以尝试下一组练习，这些练习描述了图像和前像在索引并集和交集方面的行为。在第三个练习中，需要 `i : I` 参数来保证索引集非空。为了证明这些，我们建议使用
    `ext` 或 `intro` 来展开方程或集合之间的包含关系，然后调用 `simp` 来展开成员资格的条件。'
- en: '[PRE125]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The library defines a predicate `InjOn f s` to say that `f` is injective on
    `s`. It is defined as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 库定义了一个谓词 `InjOn f s` 来表示 `f` 在 `s` 上是单射。它被定义为如下：
- en: '[PRE126]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The statement `Injective f` is provably equivalent to `InjOn f univ`. Similarly,
    the library defines `range f` to be `{x | ∃y, f y = x}`, so `range f` is provably
    equal to `f '''' univ`. This is a common theme in Mathlib: although many properties
    of functions are defined relative to their full domain, there are often relativized
    versions that restrict the statements to a subset of the domain type.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 声明 `Injective f` 可证明等价于 `InjOn f univ`。同样，库定义 `range f` 为 `{x | ∃y, f y = x}`，因此
    `range f` 可证明等于 `f '' univ`。这是 Mathlib 中的一个常见主题：尽管函数的许多属性都是相对于它们的完整定义域定义的，但通常存在相对化版本，这些版本将陈述限制在定义域类型的一个子集上。
- en: 'Here are some examples of `InjOn` and `range` in use:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些 `InjOn` 和 `range` 的使用示例：
- en: '[PRE127]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Try proving these:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试证明这些：
- en: '[PRE128]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'To define the inverse of a function `f : α → β`, we will use two new ingredients.
    First, we need to deal with the fact that an arbitrary type in Lean may be empty.
    To define the inverse to `f` at `y` when there is no `x` satisfying `f x = y`,
    we want to assign a default value in `α`. Adding the annotation `[Inhabited α]`
    as a variable is tantamount to assuming that `α` has a preferred element, which
    is denoted `default`. Second, in the case where there is more than one `x` such
    that `f x = y`, the inverse function needs to *choose* one of them. This requires
    an appeal to the *axiom of choice*. Lean allows various ways of accessing it;
    one convenient method is to use the classical `choose` operator, illustrated below.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '要定义函数 `f : α → β` 的逆，我们将使用两个新的元素。首先，我们需要处理这样一个事实：在 Lean 中，任意类型可能是空的。当没有 `x`
    满足 `f x = y` 时，我们想要在 `α` 中分配一个默认值。将注释 `[Inhabited α]` 作为变量相当于假设 `α` 有一个首选元素，用
    `default` 表示。其次，在存在多个 `x` 满足 `f x = y` 的情况下，逆函数需要 *选择* 其中之一。这需要诉诸于 *选择公理*。Lean
    允许以各种方式访问它；一种方便的方法是使用经典的 `choose` 操作符，如下所示。'
- en: '[PRE129]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Given `h : ∃ x, P x`, the value of `Classical.choose h` is some `x` satisfying
    `P x`. The theorem `Classical.choose_spec h` says that `Classical.choose h` meets
    this specification.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '给定 `h : ∃ x, P x`，`Classical.choose h` 的值是某个满足 `P x` 的 `x`。定理 `Classical.choose_spec
    h` 表示 `Classical.choose h` 满足这个规范。'
- en: 'With these in hand, we can define the inverse function as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些之后，我们可以如下定义逆函数：
- en: '[PRE130]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The lines `noncomputable section` and `open Classical` are needed because we
    are using classical logic in an essential way. On input `y`, the function `inverse
    f` returns some value of `x` satisfying `f x = y` if there is one, and a default
    element of `α` otherwise. This is an instance of a *dependent if* construction,
    since in the positive case, the value returned, `Classical.choose h`, depends
    on the assumption `h`. The identity `dif_pos h` rewrites `if h : e then a else
    b` to `a` given `h : e`, and, similarly, `dif_neg h` rewrites it to `b` given
    `h : ¬ e`. There are also versions `if_pos` and `if_neg` that works for non-dependent
    if constructions and will be used in the next section. The theorem `inverse_spec`
    says that `inverse f` meets the first part of this specification.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '需要使用 `noncomputable section` 和 `open Classical` 这两行，因为我们正在以基本的方式使用经典逻辑。对于输入
    `y`，函数 `inverse f` 如果存在满足 `f x = y` 的 `x`，则返回其某个值，否则返回 `α` 的默认元素。这是一个 *依赖条件* 构造的实例，因为在正面情况下，返回的值
    `Classical.choose h` 依赖于假设 `h`。恒等式 `dif_pos h` 将 `if h : e then a else b` 在 `h
    : e` 的情况下重写为 `a`，同样，`dif_neg h` 在 `h : ¬ e` 的情况下将其重写为 `b`。还有 `if_pos` 和 `if_neg`
    的版本，它们适用于非依赖条件构造，将在下一节中使用。定理 `inverse_spec` 表示 `inverse f` 满足这个规范的第一个部分。'
- en: Don’t worry if you do not fully understand how these work. The theorem `inverse_spec`
    alone should be enough to show that `inverse f` is a left inverse if and only
    if `f` is injective and a right inverse if and only if `f` is surjective. Look
    up the definition of `LeftInverse` and `RightInverse` by double-clicking or right-clicking
    on them in VS Code, or using the commands `#print LeftInverse` and `#print RightInverse`.
    Then try to prove the two theorems. They are tricky! It helps to do the proofs
    on paper before you start hacking through the details. You should be able to prove
    each of them with about a half-dozen short lines. If you are looking for an extra
    challenge, try to condense each proof to a single-line proof term.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不完全理解这些是如何工作的，不要担心。仅定理 `inverse_spec` 就足以表明 `inverse f` 是一个左逆当且仅当 `f` 是单射，并且是一个右逆当且仅当
    `f` 是满射。通过在 VS Code 中双击或右击它们来查找 `LeftInverse` 和 `RightInverse` 的定义，或者使用命令 `#print
    LeftInverse` 和 `#print RightInverse`。然后尝试证明这两个定理。它们很棘手！在开始处理细节之前，在纸上做证明是有帮助的。你应该能够用大约六行简短的语句证明每一个。如果你在寻找额外的挑战，尝试将每个证明压缩为单行证明项。
- en: '[PRE131]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: We close this section with a type-theoretic statement of Cantor’s famous theorem
    that there is no surjective function from a set to its power set. See if you can
    understand the proof, and then fill in the two lines that are missing.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一个类型论陈述结束本节，即康托尔著名的定理，即不存在从集合到其幂集的满射函数。看看你是否能理解证明，然后填写缺失的两行。
- en: '[PRE132]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '## 4.3\. The Schröder-Bernstein Theorem[](#the-schroder-bernstein-theorem
    "Link to this heading")'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '## 4.3. 施罗德-伯恩斯坦定理[](#the-schroder-bernstein-theorem "链接到这个标题")'
- en: 'We close this chapter with an elementary but nontrivial theorem of set theory.
    Let \(\alpha\) and \(\beta\) be sets. (In our formalization, they will actually
    be types.) Suppose \(f : \alpha → \beta\) and \(g : \beta → \alpha\) are both
    injective. Intuitively, this means that \(\alpha\) is no bigger than \(\beta\)
    and vice-versa. If \(\alpha\) and \(\beta\) are finite, this implies that they
    have the same cardinality, which is equivalent to saying that there is a bijection
    between them. In the nineteenth century, Cantor stated that same result holds
    even in the case where \(\alpha\) and \(\beta\) are infinite. This was eventually
    established by Dedekind, Schröder, and Bernstein independently.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '我们以集合论的一个基本但非平凡的定理结束这一章。令 \(\alpha\) 和 \(\beta\) 为集合。（在我们的形式化中，它们实际上将是类型。）假设
    \(f : \alpha → \beta\) 和 \(g : \beta → \alpha\) 都是单射。直观上，这意味着 \(\alpha\) 不大于 \(\beta\)，反之亦然。如果
    \(\alpha\) 和 \(\beta\) 是有限的，这表明它们具有相同的基数，这相当于说它们之间存在双射。在19世纪，康托尔指出，即使 \(\alpha\)
    和 \(\beta\) 是无限的，同样的结果也成立。这最终由 Dedekind、Schröder 和 Bernstein 独立地建立。'
- en: Our formalization will introduce some new methods that we will explain in greater
    detail in chapters to come. Don’t worry if they go by too quickly here. Our goal
    is to show you that you already have the skills to contribute to the formal proof
    of a real mathematical result.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的形式化将引入一些新的方法，我们将在接下来的章节中更详细地解释。如果在这里它们进展得太快，请不要担心。我们的目标是向您展示您已经具备为真实数学结果的形式证明做出贡献的技能。
- en: To understand the idea behind the proof, consider the image of the map \(g\)
    in \(\alpha\). On that image, the inverse of \(g\) is defined and is a bijection
    with \(\beta\).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解证明背后的思想，考虑 \(\alpha\) 中映射 \(g\) 的像。在那个像上，\(g\) 的逆是定义好的，并且与 \(\beta\) 是一一对应的。
- en: '[![the Schröder Bernstein theorem](../Images/b9bd80157a93a7ba893a2f18cfdfed3b.png)](_images/schroeder_bernstein1.png)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '![Schröder-Bernstein 定理](../Images/b9bd80157a93a7ba893a2f18cfdfed3b.png)'
- en: The problem is that the bijection does not include the shaded region in the
    diagram, which is nonempty if \(g\) is not surjective. Alternatively, we can use
    \(f\) to map all of \(\alpha\) to \(\beta\), but in that case the problem is that
    if \(f\) is not surjective, it will miss some elements of \(\beta\).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这个双射不包括图中的阴影区域，如果 \(g\) 不是满射，则该区域非空。或者，我们可以使用 \(f\) 将 \(\alpha\) 的所有元素映射到
    \(\beta\)，但在那种情况下，问题在于如果 \(f\) 不是满射，它将错过 \(\beta\) 的某些元素。
- en: '[![the Schröder Bernstein theorem](../Images/3a2cb3f7312f2e87d498ab1df6ab3f1b.png)](_images/schroeder_bernstein2.png)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '![Schröder-Bernstein 定理](../Images/3a2cb3f7312f2e87d498ab1df6ab3f1b.png)'
- en: But now consider the composition \(g \circ f\) from \(\alpha\) to itself. Because
    the composition is injective, it forms a bijection between \(\alpha\) and its
    image, yielding a scaled-down copy of \(\alpha\) inside itself.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在考虑从 \(\alpha\) 到自身的组合 \(g \circ f\)。因为组合是单射的，它形成了 \(\alpha\) 和其像之间的双射，从而在
    \(\alpha\) 内部产生了一个缩小的 \(\alpha\) 的副本。
- en: '[![the Schröder Bernstein theorem](../Images/1e07afa02f123c9afbedf2f6dd380690.png)](_images/schroeder_bernstein3.png)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![Schröder-Bernstein 定理](../Images/1e07afa02f123c9afbedf2f6dd380690.png)'
- en: This composition maps the inner shaded ring to yet another such set, which we
    can think of as an even smaller concentric shaded ring, and so on. This yields
    a concentric sequence of shaded rings, each of which is in bijective correspondence
    with the next. If we map each ring to the next and leave the unshaded parts of
    \(\alpha\) alone, we have a bijection of \(\alpha\) with the image of \(g\). Composing
    with \(g^{-1}\), this yields the desired bijection between \(\alpha\) and \(\beta\).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组合将内部阴影环映射到另一个这样的集合，我们可以将其视为一个更小的同心阴影环，依此类推。这产生了一个同心阴影环序列，每个环都与下一个环一一对应。如果我们将每个环映射到下一个环，并让
    \(\alpha\) 的非阴影部分保持不变，我们就得到了 \(\alpha\) 与 \(g\) 的像之间的双射。与 \(g^{-1}\) 组合，这就得到了
    \(\alpha\) 和 \(\beta\) 之间的所需双射。
- en: 'We can describe this bijection more simply. Let \(A\) be the union of the sequence
    of shaded regions, and define \(h : \alpha \to \beta\) as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以更简单地描述这个双射。令 \(A\) 为阴影区域的序列的并集，并定义 \(h : \alpha \to \beta\) 如下：'
- en: \[\begin{split}h(x) = \begin{cases} f(x) & \text{if $x \in A$} \\ g^{-1}(x)
    & \text{otherwise.} \end{cases}\end{split}\]
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}h(x) = \begin{cases} f(x) & \text{如果 $x \in A$} \\ g^{-1}(x)
    & \text{否则。} \end{cases}\end{split}\]
- en: In other words, we use \(f\) on the shaded parts, and we use the inverse of
    \(g\) everywhere else. The resulting map \(h\) is injective because each component
    is injective and the images of the two components are disjoint. To see that it
    is surjective, suppose we are given a \(y\) in \(\beta\), and consider \(g(y)\).
    If \(g(y)\) is in one of the shaded regions, it cannot be in the first ring, so
    we have \(g(y) = g(f(x))\) for some \(x\) is in the previous ring. By the injectivity
    of \(g\), we have \(h(x) = f(x) = y\). If \(g(y)\) is not in the shaded region,
    then by the definition of \(h\), we have \(h(g(y))= y\). Either way, \(y\) is
    in the image of \(h\).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们在阴影部分使用 \(f\)，在其他所有地方使用 \(g\) 的逆。结果映射 \(h\) 是单射的，因为每个分量都是单射的，并且两个分量的像是不相交的。为了看到它是满射的，假设我们给定了一个
    \(\beta\) 中的 \(y\)，并考虑 \(g(y)\)。如果 \(g(y)\) 在其中一个阴影区域中，它不能在第一个环中，所以我们有 \(g(y)
    = g(f(x))\) 对于某个 \(x\) 在前一个环中。根据 \(g\) 的单射性，我们有 \(h(x) = f(x) = y\)。如果 \(g(y)\)
    不在阴影区域中，那么根据 \(h\) 的定义，我们有 \(h(g(y))= y\)。无论如何，\(y\) 都在 \(h\) 的像中。
- en: This argument should sound plausible, but the details are delicate. Formalizing
    the proof will not only improve our confidence in the result, but also help us
    understand it better. Because the proof uses classical logic, we tell Lean that
    our definitions will generally not be computable.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这个论点听起来似乎合理，但细节很微妙。形式化证明不仅会提高我们对结果的信心，而且会帮助我们更好地理解它。因为证明使用了经典逻辑，我们告诉 Lean 我们的定义通常是不可计算的。
- en: '[PRE133]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The annotation `[Nonempty β]` specifies that `β` is nonempty. We use it because
    the Mathlib primitive that we will use to construct \(g^{-1}\) requires it. The
    case of the theorem where \(\beta\) is empty is trivial, and even though it would
    not be hard to generalize the formalization to cover that case as well, we will
    not bother. Specifically, we need the hypothesis `[Nonempty β]` for the operation
    `invFun` that is defined in Mathlib. Given `x : α`, `invFun g x` chooses a preimage
    of `x` in `β` if there is one, and returns an arbitrary element of `β` otherwise.
    The function `invFun g` is always a left inverse if `g` is injective and a right
    inverse if `g` is surjective.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '注释 `[Nonempty β]` 指定 `β` 是非空的。我们使用它是因为我们将要使用的 Mathlib 原始操作来构造 \(g^{-1}\) 需要它。当
    \(\beta\) 为空时，该定理的情况是平凡的，尽管将形式化推广到涵盖该情况也不难，但我们不会费心。具体来说，我们需要假设 `[Nonempty β]`
    对于在 Mathlib 中定义的操作 `invFun`。给定 `x : α`，`invFun g x` 如果存在，则选择 `x` 在 `β` 中的前像，否则返回
    `β` 的任意元素。如果 `g` 是单射的，则函数 `invFun g` 总是左逆；如果 `g` 是满射的，则它是右逆。'
- en: '[PRE134]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: We define the set corresponding to the union of the shaded regions as follows.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义与阴影区域并集对应的集合如下。
- en: '[PRE135]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The definition `sbAux` is an example of a *recursive definition*, which we will
    explain in the next chapter. It defines a sequence of sets
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `sbAux` 是一个 *递归定义* 的例子，我们将在下一章中解释。它定义了一个集合序列
- en: \[\begin{split}S_0 &= \alpha ∖ g(\beta) \\ S_{n+1} &= g(f(S_n)).\end{split}\]
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}S_0 &= \alpha ∖ g(\beta) \\ S_{n+1} &= g(f(S_n)).\end{split}\]
- en: 'The definition `sbSet` corresponds to the set \(A = \bigcup_{n \in \mathbb{N}}
    S_n\) in our proof sketch. The function \(h\) described above is now defined as
    follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `sbSet` 对应于我们证明草图中的集合 \(A = \bigcup_{n \in \mathbb{N}} S_n\)。上面描述的函数 \(h\)
    现在定义如下：
- en: '[PRE136]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: We will need the fact that our definition of \(g^{-1}\) is a right inverse on
    the complement of \(A\), which is to say, on the non-shaded regions of \(\alpha\).
    This is so because the outermost ring, \(S_0\), is equal to \(\alpha \setminus
    g(\beta)\), so the complement of \(A\) is contained in \(g(\beta)\). As a result,
    for every \(x\) in the complement of \(A\), there is a \(y\) such that \(g(y)
    = x\). (By the injectivity of \(g\), this \(y\) is unique, but next theorem says
    only that `invFun g x` returns some `y` such that `g y = x`.)
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 \(g^{-1}\) 在 \(A\) 的补集上的定义是右逆的事实，也就是说，在 \(\alpha\) 的非阴影区域上。这是因为最外层的环 \(S_0\)
    等于 \(\alpha \setminus g(\beta)\)，所以 \(A\) 的补集包含在 \(g(\beta)\) 中。因此，对于 \(A\) 的补集中的每个
    \(x\)，都有一个 \(y\) 使得 \(g(y) = x\)。（由于 \(g\) 的单射性，这个 \(y\) 是唯一的，但下一个定理只说 `invFun
    g x` 返回某个 `y` 使得 `g y = x`。）
- en: Step through the proof below, make sure you understand what is going on, and
    fill in the remaining parts. You will need to use `invFun_eq` at the end. Notice
    that rewriting with `sbAux` here replaces `sbAux f g 0` with the right-hand side
    of the corresponding defining equation.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步通过下面的证明，确保你理解了正在发生的事情，并填写剩余的部分。你将需要在最后使用 `invFun_eq`。注意，在这里用 `sbAux` 重写将 `sbAux
    f g 0` 替换为相应定义方程的右侧。
- en: '[PRE137]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: We now turn to the proof that \(h\) is injective. Informally, the proof goes
    as follows. First, suppose \(h(x_1) = h(x_2)\). If \(x_1\) is in \(A\), then \(h(x_1)
    = f(x_1)\), and we can show that \(x_2\) is in \(A\) as follows. If it isn’t,
    then we have \(h(x_2) = g^{-1}(x_2)\). From \(f(x_1) = h(x_1) = h(x_2)\) we have
    \(g(f(x_1)) = x_2\). From the definition of \(A\), since \(x_1\) is in \(A\),
    \(x_2\) is in \(A\) as well, a contradiction. Hence, if \(x_1\) is in \(A\), so
    is \(x_2\), in which case we have \(f(x_1) = h(x_1) = h(x_2) = f(x_2)\). The injectivity
    of \(f\) then implies \(x_1 = x_2\). The symmetric argument shows that if \(x_2\)
    is in \(A\), then so is \(x_1\), which again implies \(x_1 = x_2\).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们转向证明 \(h\) 是单射的证明。非正式地，证明如下。首先，假设 \(h(x_1) = h(x_2)\)。如果 \(x_1\) 在 \(A\)
    中，那么 \(h(x_1) = f(x_1)\)，我们可以如下证明 \(x_2\) 在 \(A\) 中。如果它不在 \(A\) 中，那么我们有 \(h(x_2)
    = g^{-1}(x_2)\)。从 \(f(x_1) = h(x_1) = h(x_2)\) 我们得到 \(g(f(x_1)) = x_2\)。根据 \(A\)
    的定义，由于 \(x_1\) 在 \(A\) 中，\(x_2\) 也在 \(A\) 中，这产生了矛盾。因此，如果 \(x_1\) 在 \(A\) 中，那么
    \(x_2\) 也在 \(A\) 中，在这种情况下，我们有 \(f(x_1) = h(x_1) = h(x_2) = f(x_2)\)。\(f\) 的单射性随后意味着
    \(x_1 = x_2\)。对称论证表明，如果 \(x_2\) 在 \(A\) 中，那么 \(x_1\) 也在 \(A\) 中，这再次意味着 \(x_1 =
    x_2\)。
- en: The only remaining possibility is that neither \(x_1\) nor \(x_2\) is in \(A\).
    In that case, we have \(g^{-1}(x_1) = h(x_1) = h(x_2) = g^{-1}(x_2)\). Applying
    \(g\) to both sides yields \(x_1 = x_2\).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一可能性是 \(x_1\) 和 \(x_2\) 都不在 \(A\) 中。在这种情况下，我们有 \(g^{-1}(x_1) = h(x_1) =
    h(x_2) = g^{-1}(x_2)\)。将 \(g\) 应用到两边得到 \(x_1 = x_2\)。
- en: Once again, we encourage you to step through the following proof to see how
    the argument plays out in Lean. See if you can finish off the proof using `sb_right_inv`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们鼓励您逐步通过以下证明，看看在 Lean 中论证是如何展开的。看看您是否能使用 `sb_right_inv` 完成证明。
- en: '[PRE138]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The proof introduces some new tactics. To start with, notice the `set` tactic,
    which introduces abbreviations `A` and `h` for `sbSet f g` and `sb_fun f g` respectively.
    We name the corresponding defining equations `A_def` and `h_def`. The abbreviations
    are definitional, which is to say, Lean will sometimes unfold them automatically
    when needed. But not always; for example, when using `rw`, we generally need to
    use `A_def` and `h_def` explicitly. So the definitions bring a tradeoff: they
    can make expressions shorter and more readable, but they sometimes require us
    to do more work.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 证明引入了一些新的策略。首先，注意 `set` 策略，它为 `sbSet f g` 和 `sb_fun f g` 分别引入了 `A` 和 `h` 的缩写。我们称相应的定义方程为
    `A_def` 和 `h_def`。这些缩写是定义性的，也就是说，Lean 有时会根据需要自动展开它们。但并非总是如此；例如，当使用 `rw` 时，我们通常需要显式地使用
    `A_def` 和 `h_def`。因此，这些定义带来了一种权衡：它们可以使表达式更短、更易读，但有时需要我们做更多的工作。
- en: A more interesting tactic is the `wlog` tactic, which encapsulates the symmetry
    argument in the informal proof above. We will not dwell on it now, but notice
    that it does exactly what we want. If you hover over the tactic you can take a
    look at its documentation.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有趣的策略是 `wlog` 策略，它封装了上述非正式证明中的对称论证。我们现在不会过多地讨论它，但请注意，它确实做了我们想要的事情。如果您将鼠标悬停在策略上，可以查看其文档。
- en: The argument for surjectivity is even easier. Given \(y\) in \(\beta\), we consider
    two cases, depending on whether \(g(y)\) is in \(A\). If it is, it can’t be in
    \(S_0\), the outermost ring, because by definition that is disjoint from the image
    of \(g\). Thus it is an element of \(S_{n+1}\) for some \(n\). This means that
    it is of the form \(g(f(x))\) for some \(x\) in \(S_n\). By the injectivity of
    \(g\), we have \(f(x) = y\). In the case where \(g(y)\) is in the complement of
    \(A\), we immediately have \(h(g(y))= y\), and we are done.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 对于满射性的论证甚至更容易。给定 \(\beta\) 中的 \(y\)，我们考虑两种情况，取决于 \(g(y)\) 是否在 \(A\) 中。如果它在 \(A\)
    中，它不能在 \(S_0\) 中，即最外层的环，因为根据定义，它与 \(g\) 的像不相交。因此，它是 \(S_{n+1}\) 中某个 \(n\) 的元素。这意味着它是某个
    \(S_n\) 中 \(x\) 的形式 \(g(f(x))\)。由于 \(g\) 的单射性，我们有 \(f(x) = y\)。在 \(g(y)\) 在 \(A\)
    的补集中的情况下，我们立即有 \(h(g(y))= y\)，这就完成了。
- en: Once again, we encourage you to step through the proof and fill in the missing
    parts. The tactic `rcases n with _ | n` splits on the cases `g y ∈ sbAux f g 0`
    and `g y ∈ sbAux f g (n + 1)`. In both cases, calling the simplifier with `simp
    [sbAux]` applies the corresponding defining equation of `sbAux`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们鼓励您逐步通过证明并填补缺失的部分。策略 `rcases n with _ | n` 在 `g y ∈ sbAux f g 0` 和 `g y
    ∈ sbAux f g (n + 1)` 的情况下进行分割。在两种情况下，使用 `simp [sbAux]` 调用简化器应用 `sbAux` 的相应定义方程。
- en: '[PRE139]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: We can now put it all together. The final statement is short and sweet, and
    the proof uses the fact that `Bijective h` unfolds to `Injective h ∧ Surjective
    h`.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将所有这些放在一起。最终陈述简短而清晰，证明使用了 `Bijective h` 展开为 `Injective h ∧ Surjective
    h` 的事实。
- en: '[PRE140]*'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE140]*'
