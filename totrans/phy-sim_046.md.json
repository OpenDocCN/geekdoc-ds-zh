["```py\nimport math\nimport numpy as np\n\ndhat = 0.01\nkappa = 1e5\n\ndef val(x, y_ground, contact_area):\n    sum = 0.0\n    for i in range(0, len(x)):\n        d = x[i][1] - y_ground\n        if d < dhat:\n            s = d / dhat\n            sum += contact_area[i] * dhat * kappa / 2 * (s - 1) * math.log(s)\n    return sum\n\ndef grad(x, y_ground, contact_area):\n    g = np.array([[0.0, 0.0]] * len(x))\n    for i in range(0, len(x)):\n        d = x[i][1] - y_ground\n        if d < dhat:\n            s = d / dhat\n            g[i][1] = contact_area[i] * dhat * (kappa / 2 * (math.log(s) / dhat + (s - 1) / d))\n    return g\n\ndef hess(x, y_ground, contact_area):\n    IJV = [[0] * len(x), [0] * len(x), np.array([0.0] * len(x))]\n    for i in range(0, len(x)):\n        IJV[0][i] = i * 2 + 1\n        IJV[1][i] = i * 2 + 1\n        d = x[i][1] - y_ground\n        if d < dhat:\n            IJV[2][i] = contact_area[i] * dhat * kappa / (2 * d * d * dhat) * (d + dhat)\n        else:\n            IJV[2][i] = 0.0\n    return IJV \n```", "```py\ndef init_step_size(x, y_ground, p):\n    alpha = 1\n    for i in range(0, len(x)):\n        if p[i][1] < 0:\n            alpha = min(alpha, 0.9 * (y_ground - x[i][1]) / p[i][1])\n    return alpha \n```", "```py\n # filter line search\n        alpha = BarrierEnergy.init_step_size(x, y_ground, p)  # avoid interpenetration and tunneling\n        while IP_val(x + alpha * p, e, x_tilde, m, l2, k, y_ground, contact_area, h) > E_last:\n            alpha /= 2 \n```", "```py\ncontact_area = [side_len / n_seg] * len(x)     # perimeter split to each node \n```"]