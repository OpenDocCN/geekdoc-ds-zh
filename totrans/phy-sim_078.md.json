["```py\ndef init_step_size(x, e, p):\n    alpha = 1\n    for i in range(0, len(e)):\n        x21 = x[e[i][1]] - x[e[i][0]]\n        x31 = x[e[i][2]] - x[e[i][0]]\n        p21 = p[e[i][1]] - p[e[i][0]]\n        p31 = p[e[i][2]] - p[e[i][0]]\n        detT = np.linalg.det(np.transpose([x21, x31]))\n        a = np.linalg.det(np.transpose([p21, p31])) / detT\n        b = (np.linalg.det(np.transpose([x21, p31])) + np.linalg.det(np.transpose([p21, x31]))) / detT\n        c = 0.9  # solve for alpha that first brings the new volume to 0.1x the old volume for slackness\n        critical_alpha = utils.smallest_positive_real_root_quad(a, b, c)\n        if critical_alpha > 0:\n            alpha = min(alpha, critical_alpha)\n    return alpha \n```", "```py\ndef smallest_positive_real_root_quad(a, b, c, tol = 1e-6):\n    # return negative value if no positive real root is found\n    t = 0\n    if abs(a) <= tol:\n        if abs(b) <= tol: # f(x) = c > 0 for all x\n            t = -1\n        else:\n            t = -c / b\n    else:\n        desc = b * b - 4 * a * c\n        if desc > 0:\n            t = (-b - math.sqrt(desc)) / (2 * a) # if a > 0, this is either the smaller positive root, or both roots are negative; \n            # if a < 0, there are 1 negative and 1 positive real roots, and we just need the positive one.\n            if t < 0:\n                t = (-b + math.sqrt(desc)) / (2 * a)\n        else: # desv<0 ==> imag, f(x) > 0 for all x > 0\n            t = -1\n    return t \n```", "```py\n alpha = min(BarrierEnergy.init_step_size(x, n, o, p), NeoHookeanEnergy.init_step_size(x, e, p))  # avoid interpenetration, tunneling, and inversion \n```"]