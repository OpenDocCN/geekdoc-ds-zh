- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: KNAPSACK AND GRAPH OPTIMIZATION PROBLEMS
  prefs: []
  type: TYPE_NORMAL
- en: The notion of an optimization problem provides a structured way to think about
    solving lots of computational problems. Whenever you set about solving a problem
    that involves finding the biggest, the smallest, the most, the fewest, the fastest,
    the least expensive, etc., there is a good chance that you can map the problem
    onto a classic optimization problem for which there is a known computational solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, an **optimization problem** has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An **objective function** to be maximized or minimized. For example, the airfare
    between Boston and Istanbul.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **set of constraints** (possibly empty) that must be honored. For example,
    an upper bound on the travel time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we introduce the notion of an optimization problem and give
    a few examples. We also provide some simple algorithms that solve them. In Chapter
    15, we discuss an efficient way of solving an important class of optimization
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main things to take away from this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Many problems of real importance can be formulated in a simple way that leads
    naturally to a computational solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing a seemingly new problem to an instance of a well-known problem allows
    you to use preexisting solutions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knapsack problems and graph problems are classes of problems to which other
    problems can often be reduced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exhaustive enumeration algorithms provide a simple, but usually computationally
    intractable, way to search for optimal solutions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A greedy algorithm is often a practical approach to finding a pretty good, but
    not always optimal, solution to an optimization problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As usual, we will supplement the material on computational thinking with a few
    bits of Python and some tips about programming.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1 Knapsack Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's not easy being a burglar. In addition to the obvious problems (making sure
    that a home is empty, picking locks, circumventing alarms, dealing with ethical
    quandaries, etc.), a burglar has to decide what to steal. The problem is that
    most homes contain more things of value than the average burglar can carry away.
    What's a poor burglar to do? He (or she) needs to find the set of things that
    provides the most value without exceeding his or her carrying capacity.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose, for example, a burglar who has a knapsack[^(87)](#c14-fn-0001) that
    can hold at most `20` pounds of loot breaks into a house and finds the items in
    [Figure 14-1](#c14-fig-0001). Clearly, he will not be able to fit them all in
    his knapsack, so he needs to decide what to take and what to leave behind.
  prefs: []
  type: TYPE_NORMAL
- en: '![c14-fig-0001.jpg](../images/c14-fig-0001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 14-1](#c14-fig-0001a) Table of items'
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.1 Greedy Algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest way to find an approximate solution to this problem is to use a
    **greedy algorithm**. The thief would choose the best item first, then the next
    best, and continue until he reached his limit. Of course, before doing this, the
    thief would have to decide what “best” should mean. Is the best item the most
    valuable, the least heavy, or maybe the item with the highest value-to-weight
    ratio? If he chose highest value, he would leave with just the computer, which
    he could fence for `$200`. If he chose lowest weight, he would take, in order,
    the book, the vase, the radio, and the painting—which would be worth a total of
    `$170`. Finally, if he decided that best meant highest value-to-weight ratio,
    he would start by taking the vase and the clock. That would leave three items
    with a value-to-weight ratio of `10`, but of those only the book would still fit
    in the knapsack. After taking the book, he would take the remaining item that
    still fit, the radio. The total value of his loot would be `$255`.
  prefs: []
  type: TYPE_NORMAL
- en: Though greedy-by-density (value-to-weight ratio) happens to yield the best result
    for this data set, there is no guarantee that a greedy-by-density algorithm always
    finds a better solution than greedy by weight or value. More generally, there
    is no guarantee that any solution to this kind of knapsack problem found by a
    greedy algorithm will be optimal.[^(88)](#c14-fn-0002) We will discuss this issue
    in more detail a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: The code in the next three figures implements all three of these greedy algorithms.
    In [Figure 14-2](#c14-fig-0002) we define class `Item`. Each `Item` has a `name`,
    `value`, and `weight` attribute. We also define three functions that can be bound
    to the argument `key_function` of our implementation of `greedy`; see [Figure
    14-3](#c14-fig-0003).
  prefs: []
  type: TYPE_NORMAL
- en: '![c14-fig-0002.jpg](../images/c14-fig-0002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 14-2](#c14-fig-0002a) Class `Item`'
  prefs: []
  type: TYPE_NORMAL
- en: '![c14-fig-0003.jpg](../images/c14-fig-0003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 14-3](#c14-fig-0003a) Implementation of a greedy algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: By introducing the parameter `key_function`, we make `greedy` independent of
    the order in which to consider the elements of the list. All that is required
    is that `key_function` defines an ordering on the elements in `items`. We then
    use this ordering to produce a sorted list containing the same elements as `items`.
    We use the built-in Python function `sorted` to do this. (We use `sorted` rather
    than `sort` because we want to generate a new list rather than mutate the list
    passed to the function.) We use the `reverse` parameter to indicate that we want
    the list sorted from largest (with respect to `key_function`) to smallest.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the algorithmic efficiency of `greedy`? There are two things to consider:
    the time complexity of the built-in function `sorted`, and the number of times
    through the `for` loop in the body of `greedy`. The number of iterations of the
    loop is bounded by the number of elements in `items`, i.e., it is *θ*`(n)`, where
    `n` is the length of `items`. However, the worst-case time for Python''s built-in
    sorting function is roughly order *θ*`(n log n)`, where `n` is the length of the
    list to be sorted.[^(89)](#c14-fn-0003) Therefore the running time of greedy is
    order *θ*`(n log n)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Figure 14-4](#c14-fig-0004) builds a list of items and then tests
    the function `greedy` using different ways of ordering the list.
  prefs: []
  type: TYPE_NORMAL
- en: '![c14-fig-0004.jpg](../images/c14-fig-0004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 14-4](#c14-fig-0004a) Using a greedy algorithm to choose items'
  prefs: []
  type: TYPE_NORMAL
- en: When `test_greedys()` is executed, it prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 14.1.2  An Optimal Solution to the 0/1 Knapsack Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose we decide that an approximation is not good enough, i.e., we want the
    best possible solution to this problem. Such a solution is called **optimal**,
    not surprising since we are solving an optimization problem. As it happens, the
    problem confronting our burglar is an instance of a classic optimization problem,
    called the **0/1 knapsack problem**. The 0/1 knapsack problem can be formalized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Each item is represented by a pair, <`*value, weight*`>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The knapsack can accommodate items with a total weight of no more than `w`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A vector, I, of length n, represents the set of available items. Each element
    of the vector is an item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A vector, V, of length n, is used to indicate whether or not each item is taken
    by the burglar. If V[i] = 1, item I[i] is taken. If V[i] = 0, item I[i] is not
    taken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a V that maximizes![c14-fig-5001.jpg](../images/c14-fig-5001.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: subject to the constraint that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![c14-fig-5002.jpg](../images/c14-fig-5002.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Let''s see what happens if we try to implement this formulation of the problem
    in a straightforward way:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Enumerate all possible combinations of items. That is to say, generate all
    subsets of the set of items.[^(90)](#c14-fn-0004) This is called the power set,
    and was discussed in Chapter 11.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Remove all of the combinations whose weight exceeds the allowed weight.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. From the remaining combinations, choose any one whose value is the largest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This approach will certainly find an optimal answer. However, if the original
    set of items is large, it will take a very long time to run, because, as we saw
    in Section 11.3.6, the number of subsets grows exceedingly quickly with the number
    of items.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-5](#c14-fig-0007) contains a straightforward implementation of this
    brute-force approach to solving the 0/1 knapsack problem. It uses the classes
    and functions defined in [Figure 14-2](#c14-fig-0002), [Figure 14-3](#c14-fig-0003),
    [Figure 14-4](#c14-fig-0004), and the function `gen_powerset` defined in Figure
    11-6.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c14-fig-0005.jpg](../images/c14-fig-0005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 14-5](#c14-fig-0007a) Brute-force optimal solution to the 0/1 knapsack
    problem'
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of this implementation is order *θ*`(n`*`2`^n`)`, where `n` is
    the length of `items`. The function `gen_powerset` returns a list of lists of
    `Item`s. This list is of length `2`^n, and the longest list in it is of length
    `n`. Therefore the outer loop in `choose_best` will be executed order *θ*`(2`^n`)`
    times, and the number of times the inner loop will be executed is bounded by `n`.
  prefs: []
  type: TYPE_NORMAL
- en: Many small optimizations can be applied to speed up this program. For example,
    `gen_powerset` could have had the header
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and returned only those combinations that meet the weight constraint. Alternatively,
    `choose_best` could exit the inner loop as soon as the weight constraint is exceeded.
    While these kinds of optimizations are often worth doing, they don't address the
    fundamental issue. The complexity of `choose_best` will still be order *θ*`(n`*`2`^n`)`,
    where `n` is the length of `items`, and `choose_best` will therefore still take
    a very long time to run when `items` is large.
  prefs: []
  type: TYPE_NORMAL
- en: In a theoretical sense, the problem is hopeless. The 0/1 knapsack problem is
    inherently exponential in the number of items. In a practical sense, however,
    the problem is far from hopeless, as we will discuss in Section 15.2.
  prefs: []
  type: TYPE_NORMAL
- en: When `test_best` is run, it prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this solution finds a combination of items with a higher total value
    than any of the solutions found by the greedy algorithms. The essence of a greedy
    algorithm is making the best (as defined by some metric) local choice at each
    step. It makes a choice that is **locally optimal**. However, as this example
    illustrates, a series of locally optimal decisions does not always lead to a solution
    that is **globally optimal**.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the fact that they do not always find the best solution, greedy algorithms
    are often used in practice. They are usually easier to implement and more efficient
    to run than algorithms guaranteed to find optimal solutions. As Ivan Boesky once
    said, “I think greed is healthy. You can be greedy and still feel good about yourself.”
    [^(91)](#c14-fn-0005)
  prefs: []
  type: TYPE_NORMAL
- en: 'For a variant of the knapsack problem, called the **fractional** (or **continuous**)
    **knapsack problem**, a greedy algorithm is guaranteed to find an optimal solution.
    Since the items in this variant are infinitely divisible, it always makes sense
    to take as much as possible of the item with the highest remaining value-to-weight
    ratio. Suppose, for example, that our burglar found only three things of value
    in the house: a sack of gold dust, a sack of silver dust, and a sack of raisins.
    In this case, a greedy-by-density algorithm will always find the optimal solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 14.2 Graph Optimization Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s think about another kind of optimization problem. Suppose you had a
    list of the prices of all of the airline flights between each pair of cities in
    the United States. Suppose also that for all cities, `A, B,` and `C`, the cost
    of flying from `A` to `C` by way of `B` was the cost of flying from `A` to `B`
    plus the cost of flying from `B` to `C`. A few questions you might like to ask
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the smallest number of stops between some pair of cities?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the least expensive airfare between some pair of cities?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the least expensive airfare between some pair of cities involving no
    more than two stops?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the least expensive way to visit some collection of cities?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these problems (and many others) can be easily formalized as graph problems.
  prefs: []
  type: TYPE_NORMAL
- en: A **graph**[^(92)](#c14-fn-0006) is a set of objects called **nodes** (or **vertices**)
    connected by a set of **edges** (or **arcs**). If the edges are unidirectional,
    the graph is called a **directed graph** or **digraph**. In a directed graph,
    if there is an edge from *n*1 to *n*2, we refer to *n*1 as the **source** or **parent
    node** and *n*`2` as the **destination** or **child node**.
  prefs: []
  type: TYPE_NORMAL
- en: A graph (or a digraph) is said to contain a **path** between two nodes, *n*1
    and *n*2, if there is a sequence of edges < *e*[0], … , *e[n]* > such that the
    source of *e*[0] is *n*1, the destination of *e[n]* is *n*2, and for all edges
    *e*[1] to *e[n]* in the sequence, the source of *e[i]* is the destination of *e[i]*[−1].
    A path from a node to itself is called a **cycle**. A graph containing a cycle
    is called **cyclic**, and a graph that contains no cycles is called **acyclic**.
  prefs: []
  type: TYPE_NORMAL
- en: Graphs are typically used to represent situations in which there are interesting
    relations among the parts. The first documented use of graphs in mathematics was
    in 1735 when the Swiss mathematician Leonhard Euler used what has come to be known
    as **graph theory** to formulate and solve the **Königsberg bridges problem**.
  prefs: []
  type: TYPE_NORMAL
- en: Königsberg, then the capital of East Prussia, was built at the intersection
    of two rivers that contained a number of islands. The islands were connected to
    each other and to the mainland by seven bridges, as shown on the map on the left
    side of [Figure 14-6](#c14-fig-0008). For some reason, the residents of the city
    were obsessed with the question of whether it was possible to take a walk that
    crossed each bridge exactly once.
  prefs: []
  type: TYPE_NORMAL
- en: '![c14-fig-0006.jpg](../images/c14-fig-0006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 14-6](#c14-fig-0008a) The bridges of Königsberg (left) and Euler''s
    simplified map (right)'
  prefs: []
  type: TYPE_NORMAL
- en: Euler's great insight was that the problem could be vastly simplified by viewing
    each separate landmass as a point (think “node”) and each bridge as a line (think
    “edge”) connecting two of these points. The map of the town could then be represented
    by the undirected graph to the right of the map in [Figure 14-6](#c14-fig-0008).
    Euler then reasoned that if a walk were to traverse each edge exactly once, it
    must be the case that each node in the middle of the walk (i.e., any island that
    is both entered and exited during the walk) must be connected by an even number
    of edges. Since none of the nodes in this graph has an even number of edges, Euler
    concluded that it is impossible to traverse each bridge exactly once.
  prefs: []
  type: TYPE_NORMAL
- en: Of greater interest than the Königsberg bridges problem, or even Euler's theorem
    (which generalizes his solution to the Königsberg bridges problem), is the whole
    idea of using graph theory to help understand problems.
  prefs: []
  type: TYPE_NORMAL
- en: For example, only one small extension to the kind of graph used by Euler is
    needed to model a country's highway system. If a weight is associated with each
    edge in a graph (or digraph), it is called a **weighted graph**. Using weighted
    graphs, the highway system can be represented as a graph in which cities are represented
    by nodes and the highways connecting them as edges, where each edge is labeled
    with the distance between the two nodes. More generally, we can represent any
    road map (including those with one-way streets) by a weighted digraph.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the structure of the World Wide Web can be represented as a digraph
    in which the nodes are webpages with an edge from node *A* to node *B* if and
    only if there is a link to page *B* on page *A*. Traffic patterns could be modeled
    by adding a weight to each edge indicating how often is it used.
  prefs: []
  type: TYPE_NORMAL
- en: There are also many less obvious uses of graphs. Biologists use graphs to model
    things ranging from the way proteins interact with each other to gene expression
    networks. Physicists use graphs to describe phase transitions. Epidemiologists
    use graphs to model disease trajectories. And so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-7](#c14-fig-0009) contains classes implementing abstract types corresponding
    to nodes, weighted edges, and edges.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c14-fig-0007.jpg](../images/c14-fig-0007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 14-7](#c14-fig-0009a) Nodes and edges'
  prefs: []
  type: TYPE_NORMAL
- en: Having a class for nodes may seem like overkill. After all, none of the methods
    in class `Node` perform any interesting computation. We introduced the class merely
    to give us the flexibility of deciding, perhaps at some later point, to introduce
    a subclass of `Node` with additional properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-8](#c14-fig-0010) contains implementations of the classes `Digraph`
    and `Graph`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c14-fig-0008.jpg](../images/c14-fig-0008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 14-8](#c14-fig-0010a) Classes `Graph` and `Digraph`'
  prefs: []
  type: TYPE_NORMAL
- en: One important decision is the choice of data structure used to represent a `Digraph`.
    One common representation is an `n × n` **adjacency matrix**, where `n` is the
    number of nodes in the graph. Each cell of the matrix contains information (e.g.,
    weights) about the edges connecting the pair of nodes `<*i*, *j*>`. If the edges
    are unweighted, each entry is `True` if and only if there is an edge from *i*
    to *j*.
  prefs: []
  type: TYPE_NORMAL
- en: Another common representation is an **adjacency list**, which we use here. Class
    `Digraph` has two instance variables. The variable `nodes` is a Python list containing
    the names of the nodes in the `Digraph`. The connectivity of the nodes is represented
    using an adjacency list implemented as a dictionary. The variable `edges` is a
    dictionary that maps each `Node` in the `Digraph` to a list of the children of
    that `Node`.
  prefs: []
  type: TYPE_NORMAL
- en: Class `Graph` is a subclass of `Digraph`. It inherits all of the methods of
    `Digraph` except `add_edge`, which it overrides. (This is not the most space-efficient
    way to implement `Graph`, since it stores each edge twice, once for each direction
    in the `Digraph`. But it has the virtue of simplicity.)
  prefs: []
  type: TYPE_NORMAL
- en: You might want to stop for a minute and think about why `Graph` is a subclass
    of `Digraph`, rather than the other way around. In many of the examples of subclassing
    we have looked at, the subclass adds attributes to the superclass. For example,
    class `Weighted_edge` added a `weight` attribute to class `Edge`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `Digraph` and `Graph` have the same attributes. The only difference is
    the implementation of the `add_edge` method. Either could have been easily implemented
    by inheriting methods from the other, but the choice of which to make the superclass
    was not arbitrary. In Chapter 10, we stressed the importance of obeying the substitution
    principle: If client code works correctly using an instance of the supertype,
    it should also work correctly when an instance of the subtype is substituted for
    the instance of the supertype.'
  prefs: []
  type: TYPE_NORMAL
- en: And indeed if client code works correctly using an instance of `Digraph`, it
    will work correctly if an instance of `Graph` is substituted for the instance
    of `Digraph`. The converse is not true. There are many algorithms that work on
    graphs (by exploiting the symmetry of edges) that do not work on directed graphs.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.1  Some Classic Graph-Theoretic Problems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the nice things about formulating a problem using graph theory is that
    there are well-known algorithms for solving many optimization problems on graphs.
    Some of the best-known graph optimization problems are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shortest path**. For some pair of nodes, *n*1 and *n*2, find the shortest
    sequence of edges `<*s[n], d[n]*`> (source node and destination node), such that'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ The source node in the first edge is *n*1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ The destination node of the last edge is *n*2.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ For all edges *e*1 and *e*2 in the sequence, if *e*2 follows *e*1 in the sequence,
    the source node of *e*2 is the destination node of *e*1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shortest weighted path**. This is like the shortest path, except instead
    of choosing the shortest sequence of edges that connects two nodes, we define
    some function on the weights of the edges in the sequence (e.g., their sum) and
    minimize that value. This is the kind of problem solved by Google and Apple Maps
    when asked to compute driving directions between two points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Min cut**. Given two sets of nodes in a graph, a **cut** is a set of edges
    whose removal eliminates all paths from each node in one set to each node in the
    other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maximum clique**. A **clique** is a set of nodes such that there is an edge
    between each pair of nodes in the set.[^(93)](#c14-fn-0007) A maximum clique is
    a clique of the largest size in a graph. The minimum cut is the smallest set of
    edges whose removal accomplishes this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '14.2.2 Shortest Path: Depth-First Search and Breadth-First Search'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Social networks are made up of individuals and relationships between individuals.
    These are typically modeled as graphs in which the individuals are nodes and the
    edges relationships. If the relationships are symmetric, the edges are undirected;
    if the relationships are asymmetric, the edges are directed. Some social networks
    model multiple kinds of relationships, in which case labels on the edges indicate
    the kind of relationship.
  prefs: []
  type: TYPE_NORMAL
- en: In 1990 the playwright John Guare wrote *Six Degrees of Separation*. The dubious
    premise underlying the play is that “everybody on this planet is separated by
    only six other people.” By this he meant that if we built a social network including
    every person on the Earth using the relation “knows,” the shortest path between
    any two individuals would pass through at most six other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: A less hypothetical question is the distance using the “friend” relation between
    pairs of people on Facebook. For example, you might wonder if you have a friend
    who has a friend who has a friend who is a friend of Lady Gaga. Let's think about
    designing a program to answer such questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The friend relation (at least on Facebook) is symmetric, e.g., if Sam is a
    friend of Andrea, Andrea is a friend of Sam. We will, therefore, implement the
    social network using type `Graph`. We can then define the problem of finding the
    shortest connection between you and Lady Gaga as:'
  prefs: []
  type: TYPE_NORMAL
- en: Let `*G*` be the graph representing the friend relation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `*G*`, find the shortest sequence of nodes, [You, …, Lady Gaga], such that
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *n[i]* and *n[i]*[+1] are consecutive nodes in the sequence, there is an
    edge in `G` connecting *n[i]*and *n[i]*[+1].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 14-9](#c14-fig-0011) contains a recursive function that finds the shortest
    path between two nodes, `start` and `end`, in a `Digraph`. Since `Graph` is a
    subclass of `Digraph`, it will work for our Facebook problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c14-fig-0009.jpg](../images/c14-fig-0009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 14-9](#c14-fig-0011a) Depth-first-search shortest-path algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm implemented by `DFS` is an example of a recursive **depth-first-search
    (DFS)** algorithm. In general, a depth-first-search algorithm begins by choosing
    one child of the start node. It then chooses one child of that node and so on,
    going deeper and deeper until it either reaches the goal node or a node with no
    children. The search then **backtracks**, returning to the most recent node with
    children that it has not yet visited. When all paths have been explored, it chooses
    the shortest path (assuming that there is one) from the start to the goal.
  prefs: []
  type: TYPE_NORMAL
- en: The code is more complicated than the algorithm we just described because it
    has to deal with the possibility of the graph containing cycles. It also avoids
    exploring paths longer than the shortest path that it has already found.
  prefs: []
  type: TYPE_NORMAL
- en: The function `shortest_path` calls `DFS` with `path == []` (to indicate that
    the current path being explored is empty) and `shortest == None` (to indicate
    that no path from `start` to `end` has yet been found).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DFS` begins by choosing one child of `start`. It then chooses one child of
    that node and so on, until either it reaches the node `end` or a node with no
    unvisited children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ The check `if node not in path` prevents the program from getting caught in
    a cycle.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ The check `if shortest == None or len(path) < len(shortest)` is used to decide
    if it is possible that continuing to search this path might yield a shorter path
    than the best path found so far.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ If so, `DFS` is called recursively. If it finds a path to `end` that is no
    longer than the best found so far, `shortest` is updated.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ○ When the last node on `path` has no children left to visit, the program backtracks
    to the previously visited node and visits the next child of that node.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The function returns when all possible shortest paths from `start` to `end`
    have been explored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 14-10](#c14-fig-0012) contains some code that runs the code in [Figure
    14-9](#c14-fig-0011). The function `test_SP` in [Figure 14-10](#c14-fig-0012)
    first builds a directed graph like the one pictured in the figure, and then searches
    for a shortest path between node 0 and node 5.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c14-fig-0010.jpg](../images/c14-fig-0010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 14-10](#c14-fig-0012a) Test depth-first-search code'
  prefs: []
  type: TYPE_NORMAL
- en: When executed, `test_SP` produces the output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after exploring the path `0->1->2->3->4`, it backs up to node `3`
    and explores the path `0->1->2->3->5`. After saving that as the shortest successful
    path so far, it backs up to node `2` and explores the path `0->1->2->4`. When
    it reaches the end of that path (node `4`), it backs up all the way to node `0`
    and investigates the path starting with the edge from `0` to `2`. And so on.
  prefs: []
  type: TYPE_NORMAL
- en: The DFS algorithm implemented in [Figure 14-9](#c14-fig-0011) finds the path
    with the minimum number of edges. If the edges have weights, it will not necessarily
    find the path that minimizes the sum of the weights of the edges. However, it
    is easily modified to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** Modify the DFS algorithm to find a path that minimizes
    the sum of the weights. Assume that all weights are positive integers.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are other ways to traverse a graph than depth-first. Another
    common approach is breadth-first search (BFS). A breadth-first traversal first
    visits all children of the start node. If none of those is the end node, it visits
    all children of each of those nodes. And so on. Unlike depth-first search, which
    is often implemented recursively, breadth-first search is usually implemented
    iteratively. BFS explores many paths simultaneously, adding one node to each path
    on each iteration. Since it generates the paths in ascending order of length,
    the first path found with the goal as its last node is guaranteed to have a minimum
    number of edges.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-11](#c14-fig-0013) contains code that uses a breadth-first search
    to find the shortest path in a directed graph. The variable `path_queue` is used
    to store all of the paths currently being explored. Each iteration starts by removing
    a path from `path_queu`e and assigning that path to `tmp_path`. If the last node
    in `tmp_path` is `end`, `tmp_path` is a shortest path and is returned. Otherwise,
    a set of new paths is created, each of which extends `tmp_path` by adding one
    of its children. Each of these new paths is then added to `path_queue`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c14-fig-0011.jpg](../images/c14-fig-0011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 14-11](#c14-fig-0013a) Breadth-first-search shortest path algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: When the lines
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: are added at the end of `test_SP` and the function is executed, it prints the
    additional lines
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Comfortingly, each algorithm found a path of the same length. In this case,
    they found the same path. However, if a graph contains more than one shortest
    path between a pair of nodes, DFS and BFS will not necessarily find the same shortest
    path.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned above, BFS is a convenient way to search for a path with the fewest
    edges because the first time a path is found, it is guaranteed to be such a path.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** Consider a digraph with weighted edges. Is the first path
    found by BFS guaranteed to minimize the sum of the weights of the edges?'
  prefs: []
  type: TYPE_NORMAL
- en: 14.3 Terms Introduced in Chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: optimization problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: objective function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: set of constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: knapsack problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: greedy algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: optimal solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0/1 knapsack problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: locally optimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: globally optimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: continuous knapsack problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: node (vertex)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: edge (arc)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: directed graph (digraph)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: source (parent) node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: destination (child) node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cyclic graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: acyclic graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: graph theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: weighted graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: adjacency matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: adjacency list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: shortest path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: shortest weighted path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: min cut
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: maximum clique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: depth-first search (DFS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: backtracking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: breadth-first search (BFS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
