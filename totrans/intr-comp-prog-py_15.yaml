- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: KNAPSACK AND GRAPH OPTIMIZATION PROBLEMS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 背包和图优化问题
- en: The notion of an optimization problem provides a structured way to think about
    solving lots of computational problems. Whenever you set about solving a problem
    that involves finding the biggest, the smallest, the most, the fewest, the fastest,
    the least expensive, etc., there is a good chance that you can map the problem
    onto a classic optimization problem for which there is a known computational solution.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 优化问题的概念提供了一种结构化的方式来思考解决许多计算问题。每当你开始解决一个涉及寻找最大、最小、最多、最少、最快、最便宜等的问题时，很可能可以将该问题映射到一个经典的优化问题上，而这个问题有已知的计算解决方案。
- en: 'In general, an **optimization problem** has two parts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，**优化问题**有两个部分：
- en: An **objective function** to be maximized or minimized. For example, the airfare
    between Boston and Istanbul.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个需要最大化或最小化的**目标函数**。例如，波士顿和伊斯坦布尔之间的机票费用。
- en: A **set of constraints** (possibly empty) that must be honored. For example,
    an upper bound on the travel time.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组必须遵循的**约束条件**（可能为空）。例如，旅行时间的上限。
- en: In this chapter, we introduce the notion of an optimization problem and give
    a few examples. We also provide some simple algorithms that solve them. In Chapter
    15, we discuss an efficient way of solving an important class of optimization
    problems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们引入了优化问题的概念并给出了一些例子。我们还提供了一些解决这些问题的简单算法。在第15章中，我们讨论了一种有效解决重要类别优化问题的方法。
- en: 'The main things to take away from this chapter are:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要点包括：
- en: Many problems of real importance can be formulated in a simple way that leads
    naturally to a computational solution.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多重要的问题可以用一种简单的方式表述，自然引导到计算解决方案。
- en: Reducing a seemingly new problem to an instance of a well-known problem allows
    you to use preexisting solutions.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个看似新颖的问题简化为一个已知问题的实例，可以让你利用现有的解决方案。
- en: Knapsack problems and graph problems are classes of problems to which other
    problems can often be reduced.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背包问题和图问题是可以将其他问题简化为的类别。
- en: Exhaustive enumeration algorithms provide a simple, but usually computationally
    intractable, way to search for optimal solutions.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 穷举枚举算法提供了一种简单但通常在计算上不可行的方式来寻找最佳解决方案。
- en: A greedy algorithm is often a practical approach to finding a pretty good, but
    not always optimal, solution to an optimization problem.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贪婪算法通常是寻找一个相当不错但不总是最佳的优化问题解决方案的实用方法。
- en: As usual, we will supplement the material on computational thinking with a few
    bits of Python and some tips about programming.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将用一些Python代码和编程技巧补充计算思维的材料。
- en: 14.1 Knapsack Problems
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 背包问题
- en: It's not easy being a burglar. In addition to the obvious problems (making sure
    that a home is empty, picking locks, circumventing alarms, dealing with ethical
    quandaries, etc.), a burglar has to decide what to steal. The problem is that
    most homes contain more things of value than the average burglar can carry away.
    What's a poor burglar to do? He (or she) needs to find the set of things that
    provides the most value without exceeding his or her carrying capacity.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小偷并不容易。除了显而易见的问题（确保家中空无一人、撬锁、规避警报、处理伦理困境等），小偷还必须决定偷什么。问题在于，大多数家庭的有价值物品超出一般小偷能携带的数量。一个可怜的小偷该怎么办？他（或她）需要找到提供最大价值的物品集合，同时不超过他的携带能力。
- en: Suppose, for example, a burglar who has a knapsack[^(87)](#c14-fn-0001) that
    can hold at most `20` pounds of loot breaks into a house and finds the items in
    [Figure 14-1](#c14-fig-0001). Clearly, he will not be able to fit them all in
    his knapsack, so he needs to decide what to take and what to leave behind.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，一个小偷有一个最多能装`20`磅战利品的背包[^(87)](#c14-fn-0001)，他闯入一所房子，发现[图14-1](#c14-fig-0001)中的物品。显然，他无法将所有物品放入背包，因此他需要决定带走什么，留下什么。
- en: '![c14-fig-0001.jpg](../images/c14-fig-0001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![c14-fig-0001.jpg](../images/c14-fig-0001.jpg)'
- en: '[Figure 14-1](#c14-fig-0001a) Table of items'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-1](#c14-fig-0001a) 物品表'
- en: 14.1.1 Greedy Algorithms
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1 贪婪算法
- en: The simplest way to find an approximate solution to this problem is to use a
    **greedy algorithm**. The thief would choose the best item first, then the next
    best, and continue until he reached his limit. Of course, before doing this, the
    thief would have to decide what “best” should mean. Is the best item the most
    valuable, the least heavy, or maybe the item with the highest value-to-weight
    ratio? If he chose highest value, he would leave with just the computer, which
    he could fence for `$200`. If he chose lowest weight, he would take, in order,
    the book, the vase, the radio, and the painting—which would be worth a total of
    `$170`. Finally, if he decided that best meant highest value-to-weight ratio,
    he would start by taking the vase and the clock. That would leave three items
    with a value-to-weight ratio of `10`, but of those only the book would still fit
    in the knapsack. After taking the book, he would take the remaining item that
    still fit, the radio. The total value of his loot would be `$255`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 找到这个问题的近似解的最简单方法是使用**贪心算法**。小偷会先选择最好的物品，然后是下一个最好的，持续进行直到他达到极限。当然，在这样做之前，小偷必须决定什么是“最好”。最好的物品是最有价值的，最轻的，还是可能是价值与重量比最高的物品？如果他选择最高价值，他将只拿走电脑，可以以`$200`变卖。如果他选择最低重量，他将依次拿走书、花瓶、收音机和画作，总价值为`$170`。最后，如果他决定最好的意味着价值与重量比最高，他将首先拿走花瓶和时钟。这将留下三个价值与重量比为`10`的物品，但其中只有书能放进背包。拿走书后，他将拿走仍能放进去的剩余物品，即收音机。他的战利品总价值将为`$255`。
- en: Though greedy-by-density (value-to-weight ratio) happens to yield the best result
    for this data set, there is no guarantee that a greedy-by-density algorithm always
    finds a better solution than greedy by weight or value. More generally, there
    is no guarantee that any solution to this kind of knapsack problem found by a
    greedy algorithm will be optimal.[^(88)](#c14-fn-0002) We will discuss this issue
    in more detail a bit later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管按密度贪心（价值与重量比）恰好为这个数据集提供了最佳结果，但没有保证贪心按密度算法总能找到比按重量或价值贪心算法更好的解决方案。更一般来说，任何通过贪心算法找到的这类背包问题的解决方案都不一定是最优的。[^(88)](#c14-fn-0002)我们稍后会更详细地讨论这个问题。
- en: The code in the next three figures implements all three of these greedy algorithms.
    In [Figure 14-2](#c14-fig-0002) we define class `Item`. Each `Item` has a `name`,
    `value`, and `weight` attribute. We also define three functions that can be bound
    to the argument `key_function` of our implementation of `greedy`; see [Figure
    14-3](#c14-fig-0003).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来三幅图中的代码实现了这三种贪心算法。在[图14-2](#c14-fig-0002)中，我们定义了类`Item`。每个`Item`都有一个`name`、`value`和`weight`属性。我们还定义了三个可以绑定到我们实现的`greedy`的参数`key_function`的函数；见[图14-3](#c14-fig-0003)。
- en: '![c14-fig-0002.jpg](../images/c14-fig-0002.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![c14-fig-0002.jpg](../images/c14-fig-0002.jpg)'
- en: '[Figure 14-2](#c14-fig-0002a) Class `Item`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-2](#c14-fig-0002a) 类`Item`'
- en: '![c14-fig-0003.jpg](../images/c14-fig-0003.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![c14-fig-0003.jpg](../images/c14-fig-0003.jpg)'
- en: '[Figure 14-3](#c14-fig-0003a) Implementation of a greedy algorithm'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-3](#c14-fig-0003a) 贪心算法的实现'
- en: By introducing the parameter `key_function`, we make `greedy` independent of
    the order in which to consider the elements of the list. All that is required
    is that `key_function` defines an ordering on the elements in `items`. We then
    use this ordering to produce a sorted list containing the same elements as `items`.
    We use the built-in Python function `sorted` to do this. (We use `sorted` rather
    than `sort` because we want to generate a new list rather than mutate the list
    passed to the function.) We use the `reverse` parameter to indicate that we want
    the list sorted from largest (with respect to `key_function`) to smallest.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入参数`key_function`，我们使得`greedy`不再依赖于考虑列表元素的顺序。所需的只是`key_function`定义了`items`中元素的排序。然后，我们使用这个排序生成一个包含与`items`相同元素的排序列表。我们使用内置的Python函数`sorted`来实现这一点。（我们使用`sorted`而不是`sort`，因为我们希望生成一个新列表，而不是改变传入函数的列表。）我们使用`reverse`参数来表示我们希望列表从最大（根据`key_function`）排序到最小。
- en: 'What is the algorithmic efficiency of `greedy`? There are two things to consider:
    the time complexity of the built-in function `sorted`, and the number of times
    through the `for` loop in the body of `greedy`. The number of iterations of the
    loop is bounded by the number of elements in `items`, i.e., it is *θ*`(n)`, where
    `n` is the length of `items`. However, the worst-case time for Python''s built-in
    sorting function is roughly order *θ*`(n log n)`, where `n` is the length of the
    list to be sorted.[^(89)](#c14-fn-0003) Therefore the running time of greedy is
    order *θ*`(n log n)`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`greedy`的算法效率如何？需要考虑两件事：内置函数`sorted`的时间复杂度，以及在`greedy`主体中`for`循环的执行次数。循环的迭代次数受限于`items`中的元素数量，即为*θ*`(n)`，其中`n`是`items`的长度。然而，Python内置排序函数的最坏情况时间大致为*θ*`(n
    log n)`，其中`n`是待排序列表的长度。[^(89)](#c14-fn-0003)因此，greedy的运行时间为*θ*`(n log n)`。'
- en: The code in [Figure 14-4](#c14-fig-0004) builds a list of items and then tests
    the function `greedy` using different ways of ordering the list.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-4](#c14-fig-0004) 中的代码构建了一项列表，然后使用不同的排序方式测试函数`greedy`。'
- en: '![c14-fig-0004.jpg](../images/c14-fig-0004.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![c14-fig-0004.jpg](../images/c14-fig-0004.jpg)'
- en: '[Figure 14-4](#c14-fig-0004a) Using a greedy algorithm to choose items'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-4](#c14-fig-0004a) 使用贪心算法选择项目'
- en: When `test_greedys()` is executed, it prints
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`test_greedys()`时，它会打印
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 14.1.2  An Optimal Solution to the 0/1 Knapsack Problem
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2  0/1 背包问题的最优解决方案
- en: 'Suppose we decide that an approximation is not good enough, i.e., we want the
    best possible solution to this problem. Such a solution is called **optimal**,
    not surprising since we are solving an optimization problem. As it happens, the
    problem confronting our burglar is an instance of a classic optimization problem,
    called the **0/1 knapsack problem**. The 0/1 knapsack problem can be formalized
    as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们决定近似解不够好，即我们希望这个问题的最佳可能解决方案。这样的解决方案称为**最优**，这并不奇怪，因为我们正在解决一个优化问题。恰好，我们的盗贼面临的问题是经典优化问题的一个实例，称为**0/1
    背包问题**。0/1 背包问题可以形式化如下：
- en: Each item is represented by a pair, <`*value, weight*`>.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个项目由一对表示，<`*value, weight*`>。
- en: The knapsack can accommodate items with a total weight of no more than `w`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背包可以容纳总重量不超过`w`的项目。
- en: A vector, I, of length n, represents the set of available items. Each element
    of the vector is an item.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长度为n的向量I表示可用项目的集合。向量的每个元素都是一个项目。
- en: A vector, V, of length n, is used to indicate whether or not each item is taken
    by the burglar. If V[i] = 1, item I[i] is taken. If V[i] = 0, item I[i] is not
    taken.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长度为n的向量V用于指示每个项目是否被盗贼拿走。如果V[i] = 1，则项目I[i]被拿走。如果V[i] = 0，则项目I[i]未被拿走。
- en: Find a V that maximizes![c14-fig-5001.jpg](../images/c14-fig-5001.jpg)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到一个最大化的V![c14-fig-5001.jpg](../images/c14-fig-5001.jpg)
- en: subject to the constraint that
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 受限于以下约束条件
- en: '![c14-fig-5002.jpg](../images/c14-fig-5002.jpg)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![c14-fig-5002.jpg](../images/c14-fig-5002.jpg)'
- en: 'Let''s see what happens if we try to implement this formulation of the problem
    in a straightforward way:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果尝试以直接方式实现此问题的公式会发生什么：
- en: 1\. Enumerate all possible combinations of items. That is to say, generate all
    subsets of the set of items.[^(90)](#c14-fn-0004) This is called the power set,
    and was discussed in Chapter 11.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 列举所有可能的项目组合。也就是说，生成项目集的所有子集。[^(90)](#c14-fn-0004)这称为幂集，已在第11章讨论过。
- en: 2\. Remove all of the combinations whose weight exceeds the allowed weight.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 移除所有重量超过允许重量的组合。
- en: 3\. From the remaining combinations, choose any one whose value is the largest.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 从剩余组合中选择一个价值最大的组合。
- en: This approach will certainly find an optimal answer. However, if the original
    set of items is large, it will take a very long time to run, because, as we saw
    in Section 11.3.6, the number of subsets grows exceedingly quickly with the number
    of items.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法肯定能找到一个**最佳**答案。然而，如果原始项目集很大，运行将需要很长时间，因为正如我们在第 11.3.6 节看到的，子集的数量随着项目数量的增加而迅速增长。
- en: '[Figure 14-5](#c14-fig-0007) contains a straightforward implementation of this
    brute-force approach to solving the 0/1 knapsack problem. It uses the classes
    and functions defined in [Figure 14-2](#c14-fig-0002), [Figure 14-3](#c14-fig-0003),
    [Figure 14-4](#c14-fig-0004), and the function `gen_powerset` defined in Figure
    11-6.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-5](#c14-fig-0007)包含了这种暴力解决0/1背包问题的直接实现。它使用了在[图 14-2](#c14-fig-0002)、[图
    14-3](#c14-fig-0003)、[图 14-4](#c14-fig-0004)中定义的类和函数，以及在图 11-6 中定义的函数`gen_powerset`。'
- en: '![c14-fig-0005.jpg](../images/c14-fig-0005.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![c14-fig-0005.jpg](../images/c14-fig-0005.jpg)'
- en: '[Figure 14-5](#c14-fig-0007a) Brute-force optimal solution to the 0/1 knapsack
    problem'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-5](#c14-fig-0007a) 暴力求解0/1背包问题的最优解'
- en: The complexity of this implementation is order *θ*`(n`*`2`^n`)`, where `n` is
    the length of `items`. The function `gen_powerset` returns a list of lists of
    `Item`s. This list is of length `2`^n, and the longest list in it is of length
    `n`. Therefore the outer loop in `choose_best` will be executed order *θ*`(2`^n`)`
    times, and the number of times the inner loop will be executed is bounded by `n`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的复杂度是*θ*`(n`*`2`^n`)`，其中`n`是`items`的长度。函数`gen_powerset`返回一个包含`Item`的列表的列表。这个列表的长度为`2`^n，其中最长的列表的长度为`n`。因此，`choose_best`中的外部循环将执行*θ*`(2`^n`)`次，内部循环的执行次数由`n`限制。
- en: Many small optimizations can be applied to speed up this program. For example,
    `gen_powerset` could have had the header
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 许多小的优化可以应用于加速这个程序。例如，`gen_powerset`可以有如下头部
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: and returned only those combinations that meet the weight constraint. Alternatively,
    `choose_best` could exit the inner loop as soon as the weight constraint is exceeded.
    While these kinds of optimizations are often worth doing, they don't address the
    fundamental issue. The complexity of `choose_best` will still be order *θ*`(n`*`2`^n`)`,
    where `n` is the length of `items`, and `choose_best` will therefore still take
    a very long time to run when `items` is large.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 并且只返回那些符合重量约束的组合。或者，`choose_best`可以在超过重量约束时立即退出内部循环。虽然这些类型的优化通常是值得做的，但它们并没有解决根本问题。`choose_best`的复杂度仍然是*θ*`(n`*`2`^n`)`，因此当`items`很大时，`choose_best`仍然会运行很长时间。
- en: In a theoretical sense, the problem is hopeless. The 0/1 knapsack problem is
    inherently exponential in the number of items. In a practical sense, however,
    the problem is far from hopeless, as we will discuss in Section 15.2.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，这个问题是绝望的。0/1背包问题在物品数量上本质上是指数级的。然而，从实践的角度来看，这个问题远非绝望，正如我们将在15.2节中讨论的那样。
- en: When `test_best` is run, it prints
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行`test_best`时，它会打印
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that this solution finds a combination of items with a higher total value
    than any of the solutions found by the greedy algorithms. The essence of a greedy
    algorithm is making the best (as defined by some metric) local choice at each
    step. It makes a choice that is **locally optimal**. However, as this example
    illustrates, a series of locally optimal decisions does not always lead to a solution
    that is **globally optimal**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个解决方案找到了总价值高于贪心算法找到的任何解决方案的物品组合。贪心算法的本质是在每一步做出最佳（由某种标准定义的）局部选择。它做出了一个**局部最优**的选择。然而，正如这个例子所示，一系列局部最优的决策并不总是会导致一个**全局最优**的解决方案。
- en: Despite the fact that they do not always find the best solution, greedy algorithms
    are often used in practice. They are usually easier to implement and more efficient
    to run than algorithms guaranteed to find optimal solutions. As Ivan Boesky once
    said, “I think greed is healthy. You can be greedy and still feel good about yourself.”
    [^(91)](#c14-fn-0005)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管贪心算法并不总是找到最佳解决方案，但它们在实践中经常被使用。通常情况下，它们比保证找到最优解的算法更容易实现且更高效。正如伊万·博斯基曾经说过的：“我认为贪婪是健康的。你可以贪婪，但仍然对自己感觉良好。”
    [^(91)](#c14-fn-0005)
- en: 'For a variant of the knapsack problem, called the **fractional** (or **continuous**)
    **knapsack problem**, a greedy algorithm is guaranteed to find an optimal solution.
    Since the items in this variant are infinitely divisible, it always makes sense
    to take as much as possible of the item with the highest remaining value-to-weight
    ratio. Suppose, for example, that our burglar found only three things of value
    in the house: a sack of gold dust, a sack of silver dust, and a sack of raisins.
    In this case, a greedy-by-density algorithm will always find the optimal solution.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个称为**分数**（或**连续**）**背包问题**的背包问题变体，贪心算法可以保证找到一个最优解。由于这个变体中的物品可以无限分割，因此总是选择尽可能多的具有最高剩余价值与重量比的物品是有意义的。假设，例如，我们的窃贼在房子里只发现了三样有价值的东西：一袋金粉、一袋银粉和一袋葡萄干。在这种情况下，贪婪密度算法将始终找到最优解。
- en: 14.2 Graph Optimization Problems
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 图优化问题
- en: 'Let''s think about another kind of optimization problem. Suppose you had a
    list of the prices of all of the airline flights between each pair of cities in
    the United States. Suppose also that for all cities, `A, B,` and `C`, the cost
    of flying from `A` to `C` by way of `B` was the cost of flying from `A` to `B`
    plus the cost of flying from `B` to `C`. A few questions you might like to ask
    are:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一种优化问题。假设你有一份美国各城市之间所有航空航班价格的清单。假设对于所有城市 `A, B,` 和 `C`，从 `A` 经 `B` 飞往
    `C` 的费用是从 `A` 飞往 `B` 的费用加上从 `B` 飞往 `C` 的费用。你可能会想问的几个问题是：
- en: What is the smallest number of stops between some pair of cities?
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个城市之间的最少停留次数是多少？
- en: What is the least expensive airfare between some pair of cities?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个城市之间的最低机票价格是多少？
- en: What is the least expensive airfare between some pair of cities involving no
    more than two stops?
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不超过两次停留的情况下，两个城市之间的最低机票价格是多少？
- en: What is the least expensive way to visit some collection of cities?
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问某些城市集合的最低费用是什么？
- en: All of these problems (and many others) can be easily formalized as graph problems.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题（以及其他许多问题）都可以很容易地形式化为图问题。
- en: A **graph**[^(92)](#c14-fn-0006) is a set of objects called **nodes** (or **vertices**)
    connected by a set of **edges** (or **arcs**). If the edges are unidirectional,
    the graph is called a **directed graph** or **digraph**. In a directed graph,
    if there is an edge from *n*1 to *n*2, we refer to *n*1 as the **source** or **parent
    node** and *n*`2` as the **destination** or **child node**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**图**[^(92)](#c14-fn-0006)是由称为 **节点**（或 **顶点**）的对象构成的一组对象，这些对象通过一组 **边**（或
    **弧**）连接。如果边是单向的，则该图称为 **有向图** 或 **有向图**。在有向图中，如果存在一条从 *n*1 到 *n*2 的边，我们称 *n*1
    为 **源节点** 或 **父节点**，而 *n*2 为 **目标节点** 或 **子节点**。'
- en: A graph (or a digraph) is said to contain a **path** between two nodes, *n*1
    and *n*2, if there is a sequence of edges < *e*[0], … , *e[n]* > such that the
    source of *e*[0] is *n*1, the destination of *e[n]* is *n*2, and for all edges
    *e*[1] to *e[n]* in the sequence, the source of *e[i]* is the destination of *e[i]*[−1].
    A path from a node to itself is called a **cycle**. A graph containing a cycle
    is called **cyclic**, and a graph that contains no cycles is called **acyclic**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在一系列边 < *e*[0], … , *e[n]* >，使得 *e*[0] 的起点是 *n*1，*e[n]* 的终点是 *n*2，并且在序列中所有边
    *e*[1] 到 *e[n]* 的起点是 *e*[i]* 的终点 *e*[i][−1]，那么称图中包含 **路径** 从 *n*1 到 *n*2。一个从节点到自身的路径称为
    **循环**。包含循环的图称为 **有向图**，而不包含循环的图称为 **无向图**。
- en: Graphs are typically used to represent situations in which there are interesting
    relations among the parts. The first documented use of graphs in mathematics was
    in 1735 when the Swiss mathematician Leonhard Euler used what has come to be known
    as **graph theory** to formulate and solve the **Königsberg bridges problem**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图通常用于表示各部分之间存在有趣关系的情况。图在数学中首次被记录的使用是在1735年，当时瑞士数学家莱昂哈德·欧拉使用了后来被称为 **图论** 的方法来制定和解决
    **柯尼斯堡桥问题**。
- en: Königsberg, then the capital of East Prussia, was built at the intersection
    of two rivers that contained a number of islands. The islands were connected to
    each other and to the mainland by seven bridges, as shown on the map on the left
    side of [Figure 14-6](#c14-fig-0008). For some reason, the residents of the city
    were obsessed with the question of whether it was possible to take a walk that
    crossed each bridge exactly once.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 柯尼斯堡，当时是东普鲁士的首都，建于两条河流的交汇处，河流中有多个岛屿。岛屿通过七座桥相互连接，并与大陆相连，如 [图 14-6](#c14-fig-0008)
    左侧的地图所示。出于某种原因，市民们对是否能进行一次恰好经过每座桥一次的散步这个问题产生了浓厚的兴趣。
- en: '![c14-fig-0006.jpg](../images/c14-fig-0006.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![c14-fig-0006.jpg](../images/c14-fig-0006.jpg)'
- en: '[Figure 14-6](#c14-fig-0008a) The bridges of Königsberg (left) and Euler''s
    simplified map (right)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-6](#c14-fig-0008) 左侧是柯尼斯堡的桥，右侧是欧拉简化后的地图'
- en: Euler's great insight was that the problem could be vastly simplified by viewing
    each separate landmass as a point (think “node”) and each bridge as a line (think
    “edge”) connecting two of these points. The map of the town could then be represented
    by the undirected graph to the right of the map in [Figure 14-6](#c14-fig-0008).
    Euler then reasoned that if a walk were to traverse each edge exactly once, it
    must be the case that each node in the middle of the walk (i.e., any island that
    is both entered and exited during the walk) must be connected by an even number
    of edges. Since none of the nodes in this graph has an even number of edges, Euler
    concluded that it is impossible to traverse each bridge exactly once.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉的伟大见解在于，通过将每个独立的陆地块视为一个点（想想“节点”），每座桥视为连接这两个点的线（想想“边”），可以大大简化问题。镇的地图可以用右侧的无向图表示，如[图
    14-6](#c14-fig-0008)所示。欧拉推理，如果一次走遍每条边，走的过程中每个节点（即在行走过程中被进入和退出的任何岛屿）必须由偶数条边连接。由于这个图中的节点没有偶数条边，欧拉得出结论，不可能每座桥恰好走一次。
- en: Of greater interest than the Königsberg bridges problem, or even Euler's theorem
    (which generalizes his solution to the Königsberg bridges problem), is the whole
    idea of using graph theory to help understand problems.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 比起柯尼斯堡桥问题，甚至比欧拉定理（它将欧拉对柯尼斯堡桥问题的解决方案进行了推广）更有趣的是，使用图论来帮助理解问题的整个想法。
- en: For example, only one small extension to the kind of graph used by Euler is
    needed to model a country's highway system. If a weight is associated with each
    edge in a graph (or digraph), it is called a **weighted graph**. Using weighted
    graphs, the highway system can be represented as a graph in which cities are represented
    by nodes and the highways connecting them as edges, where each edge is labeled
    with the distance between the two nodes. More generally, we can represent any
    road map (including those with one-way streets) by a weighted digraph.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，仅需要对欧拉使用的那种图形进行一个小的扩展，就可以建模一个国家的高速公路系统。如果图（或有向图）中的每条边都有一个权重，则称之为**加权图**。使用加权图，高速公路系统可以表示为一个图，其中城市由节点表示，连接它们的高速公路作为边，每条边标记为两个节点之间的距离。更一般来说，我们可以通过加权有向图表示任何道路地图（包括单行街道的地图）。
- en: Similarly, the structure of the World Wide Web can be represented as a digraph
    in which the nodes are webpages with an edge from node *A* to node *B* if and
    only if there is a link to page *B* on page *A*. Traffic patterns could be modeled
    by adding a weight to each edge indicating how often is it used.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，万维网的结构可以表示为一个有向图，其中节点是网页，只有在页面*A*上有指向页面*B*的链接时，节点*A*到节点*B*之间才会有一条边。流量模式可以通过为每条边添加一个权重来建模，以指示使用频率。
- en: There are also many less obvious uses of graphs. Biologists use graphs to model
    things ranging from the way proteins interact with each other to gene expression
    networks. Physicists use graphs to describe phase transitions. Epidemiologists
    use graphs to model disease trajectories. And so on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图形还有许多不太明显的用途。生物学家使用图来建模从蛋白质相互作用到基因表达网络的各种现象。物理学家使用图来描述相变。流行病学家使用图来建模疾病轨迹，等等。
- en: '[Figure 14-7](#c14-fig-0009) contains classes implementing abstract types corresponding
    to nodes, weighted edges, and edges.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-7](#c14-fig-0009)包含实现与节点、加权边和边对应的抽象类型的类。'
- en: '![c14-fig-0007.jpg](../images/c14-fig-0007.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![c14-fig-0007.jpg](../images/c14-fig-0007.jpg)'
- en: '[Figure 14-7](#c14-fig-0009a) Nodes and edges'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-7](#c14-fig-0009) 节点和边'
- en: Having a class for nodes may seem like overkill. After all, none of the methods
    in class `Node` perform any interesting computation. We introduced the class merely
    to give us the flexibility of deciding, perhaps at some later point, to introduce
    a subclass of `Node` with additional properties.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个节点类可能看起来有些多余。毕竟，`Node`类中的任何方法都没有执行任何有趣的计算。我们引入这个类只是为了给我们灵活性，以便在某些时刻决定引入一个具有附加属性的`Node`子类。
- en: '[Figure 14-8](#c14-fig-0010) contains implementations of the classes `Digraph`
    and `Graph`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-8](#c14-fig-0010)包含`Digraph`和`Graph`类的实现。'
- en: '![c14-fig-0008.jpg](../images/c14-fig-0008.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![c14-fig-0008.jpg](../images/c14-fig-0008.jpg)'
- en: '[Figure 14-8](#c14-fig-0010a) Classes `Graph` and `Digraph`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-8](#c14-fig-0010a) 类`Graph`和`Digraph`'
- en: One important decision is the choice of data structure used to represent a `Digraph`.
    One common representation is an `n × n` **adjacency matrix**, where `n` is the
    number of nodes in the graph. Each cell of the matrix contains information (e.g.,
    weights) about the edges connecting the pair of nodes `<*i*, *j*>`. If the edges
    are unweighted, each entry is `True` if and only if there is an edge from *i*
    to *j*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的决定是用于表示`Digraph`的数据结构选择。一个常见的表示方式是`n × n` **邻接矩阵**，其中`n`是图中节点的数量。矩阵的每个单元格包含关于连接节点对`<*i*,
    *j*>`的边的信息（例如，权重）。如果边是无权的，则只有在存在从*i*到*j*的边时，每个条目为`True`。
- en: Another common representation is an **adjacency list**, which we use here. Class
    `Digraph` has two instance variables. The variable `nodes` is a Python list containing
    the names of the nodes in the `Digraph`. The connectivity of the nodes is represented
    using an adjacency list implemented as a dictionary. The variable `edges` is a
    dictionary that maps each `Node` in the `Digraph` to a list of the children of
    that `Node`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的表示方式是**邻接表**，我们在这里使用。类`Digraph`有两个实例变量。变量`nodes`是一个包含`Digraph`中节点名称的Python列表。节点的连通性使用实现为字典的邻接表表示。变量`edges`是一个字典，将`Digraph`中的每个`Node`映射到该`Node`的子节点列表。
- en: Class `Graph` is a subclass of `Digraph`. It inherits all of the methods of
    `Digraph` except `add_edge`, which it overrides. (This is not the most space-efficient
    way to implement `Graph`, since it stores each edge twice, once for each direction
    in the `Digraph`. But it has the virtue of simplicity.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Graph`是`Digraph`的子类。它继承了`Digraph`的所有方法，除了重写的`add_edge`方法。（这并不是实现`Graph`的最节省空间的方式，因为它每条边存储了两次，一次用于`Digraph`的每个方向。但它的优点在于简单。）
- en: You might want to stop for a minute and think about why `Graph` is a subclass
    of `Digraph`, rather than the other way around. In many of the examples of subclassing
    we have looked at, the subclass adds attributes to the superclass. For example,
    class `Weighted_edge` added a `weight` attribute to class `Edge`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想停下来思考一下，为什么`Graph`是`Digraph`的子类，而不是反过来。在我们观察的许多子类化示例中，子类为超类添加了属性。例如，类`Weighted_edge`向类`Edge`添加了一个`weight`属性。
- en: 'Here, `Digraph` and `Graph` have the same attributes. The only difference is
    the implementation of the `add_edge` method. Either could have been easily implemented
    by inheriting methods from the other, but the choice of which to make the superclass
    was not arbitrary. In Chapter 10, we stressed the importance of obeying the substitution
    principle: If client code works correctly using an instance of the supertype,
    it should also work correctly when an instance of the subtype is substituted for
    the instance of the supertype.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Digraph`和`Graph`具有相同的属性。唯一的区别是`add_edge`方法的实现。任一类都可以通过继承另一类的方法轻松实现，但选择哪个作为超类并不是任意的。在第10章中，我们强调了遵循替代原则的重要性：如果客户端代码使用超类的实例正常工作，那么当用子类的实例替代超类的实例时，它也应正常工作。
- en: And indeed if client code works correctly using an instance of `Digraph`, it
    will work correctly if an instance of `Graph` is substituted for the instance
    of `Digraph`. The converse is not true. There are many algorithms that work on
    graphs (by exploiting the symmetry of edges) that do not work on directed graphs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，如果客户端代码使用`Digraph`的实例工作正常，那么如果用`Graph`的实例替代`Digraph`的实例，它也会正常工作。反之则不然。有许多算法适用于图（通过利用边的对称性），而这些算法在有向图上并不适用。
- en: 14.2.1  Some Classic Graph-Theoretic Problems
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.1 一些经典的图论问题
- en: 'One of the nice things about formulating a problem using graph theory is that
    there are well-known algorithms for solving many optimization problems on graphs.
    Some of the best-known graph optimization problems are:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图论来制定问题的一个好处是，有众所周知的算法可以解决许多图上的优化问题。一些最著名的图优化问题包括：
- en: '**Shortest path**. For some pair of nodes, *n*1 and *n*2, find the shortest
    sequence of edges `<*s[n], d[n]*`> (source node and destination node), such that'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最短路径**。对于某一对节点*n*1和*n*2，找到边的最短序列`<*s[n], d[n]*>`（源节点和目标节点），使得'
- en: ○ The source node in the first edge is *n*1.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 第一条边中的源节点是*n*1。
- en: ○ The destination node of the last edge is *n*2.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 最后一条边的目标节点是*n*2。
- en: ○ For all edges *e*1 and *e*2 in the sequence, if *e*2 follows *e*1 in the sequence,
    the source node of *e*2 is the destination node of *e*1.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 对于序列中的所有边*e*1和*e*2，如果*e*2在序列中跟随*e*1，则*e*2的源节点是*e*1的目标节点。
- en: '**Shortest weighted path**. This is like the shortest path, except instead
    of choosing the shortest sequence of edges that connects two nodes, we define
    some function on the weights of the edges in the sequence (e.g., their sum) and
    minimize that value. This is the kind of problem solved by Google and Apple Maps
    when asked to compute driving directions between two points.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最短加权路径**。这类似于最短路径，但我们不是选择连接两个节点的最短边序列，而是定义某个函数来计算序列中边的权重（例如，它们的总和），并最小化该值。这就是谷歌和苹果地图在计算两个点之间的驾驶路线时所解决的那种问题。'
- en: '**Min cut**. Given two sets of nodes in a graph, a **cut** is a set of edges
    whose removal eliminates all paths from each node in one set to each node in the
    other.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小割**。给定图中两个节点集，**割**是一组边，去除这些边会消除从一个集合中的每个节点到另一个集合中每个节点的所有路径。'
- en: '**Maximum clique**. A **clique** is a set of nodes such that there is an edge
    between each pair of nodes in the set.[^(93)](#c14-fn-0007) A maximum clique is
    a clique of the largest size in a graph. The minimum cut is the smallest set of
    edges whose removal accomplishes this.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大团**。**团**是一组节点，集合中的每对节点之间都有一条边。[^(93)](#c14-fn-0007) 最大团是图中最大规模的团。最小割是去除这些边后能实现这一点的最小边集。'
- en: '14.2.2 Shortest Path: Depth-First Search and Breadth-First Search'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.2 最短路径：深度优先搜索和广度优先搜索
- en: Social networks are made up of individuals and relationships between individuals.
    These are typically modeled as graphs in which the individuals are nodes and the
    edges relationships. If the relationships are symmetric, the edges are undirected;
    if the relationships are asymmetric, the edges are directed. Some social networks
    model multiple kinds of relationships, in which case labels on the edges indicate
    the kind of relationship.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 社交网络由个体和个体之间的关系组成。这些通常被建模为图，其中个体为节点，边为关系。如果关系是对称的，边是无向的；如果关系是非对称的，边是有向的。一些社交网络建模多种类型的关系，在这种情况下，边上的标签指示关系的类型。
- en: In 1990 the playwright John Guare wrote *Six Degrees of Separation*. The dubious
    premise underlying the play is that “everybody on this planet is separated by
    only six other people.” By this he meant that if we built a social network including
    every person on the Earth using the relation “knows,” the shortest path between
    any two individuals would pass through at most six other nodes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在1990年，剧作家约翰·古埃尔写了《六度分隔》。该剧的可疑前提是“这个星球上的每个人仅被其他六个人隔开。”他的意思是，如果我们利用“认识”的关系建立一个包含地球上每个人的社交网络，那么任何两个个体之间的最短路径至多会经过六个其他节点。
- en: A less hypothetical question is the distance using the “friend” relation between
    pairs of people on Facebook. For example, you might wonder if you have a friend
    who has a friend who has a friend who is a friend of Lady Gaga. Let's think about
    designing a program to answer such questions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个较少假设性的问题是，使用Facebook上“朋友”关系的两个人之间的距离。例如，你可能想知道你是否有一个朋友，他有一个朋友，而那个朋友是嘎嘎女士的朋友。让我们考虑设计一个程序来回答这样的问题。
- en: 'The friend relation (at least on Facebook) is symmetric, e.g., if Sam is a
    friend of Andrea, Andrea is a friend of Sam. We will, therefore, implement the
    social network using type `Graph`. We can then define the problem of finding the
    shortest connection between you and Lady Gaga as:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 朋友关系（至少在Facebook上）是对称的，例如，如果萨姆是安德烈亚的朋友，安德烈亚也是萨姆的朋友。因此，我们将使用类型为 `Graph` 的社交网络来实现。然后我们可以将寻找你与嘎嘎女士之间最短连接的问题定义为：
- en: Let `*G*` be the graph representing the friend relation.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让 `*G*` 表示朋友关系的图。
- en: For `*G*`, find the shortest sequence of nodes, [You, …, Lady Gaga], such that
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `*G*`，寻找最短节点序列，[你，…，嘎嘎女士]，使得
- en: If *n[i]* and *n[i]*[+1] are consecutive nodes in the sequence, there is an
    edge in `G` connecting *n[i]*and *n[i]*[+1].
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *n[i]* 和 *n[i]*[+1] 是序列中的连续节点，则在 `G` 中有一条边连接 *n[i]* 和 *n[i]*[+1]。
- en: '[Figure 14-9](#c14-fig-0011) contains a recursive function that finds the shortest
    path between two nodes, `start` and `end`, in a `Digraph`. Since `Graph` is a
    subclass of `Digraph`, it will work for our Facebook problem.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-9](#c14-fig-0011) 包含一个递归函数，该函数找到 `Digraph` 中两个节点 `start` 和 `end` 之间的最短路径。由于
    `Graph` 是 `Digraph` 的子类，因此它适用于我们的Facebook问题。'
- en: '![c14-fig-0009.jpg](../images/c14-fig-0009.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![c14-fig-0009.jpg](../images/c14-fig-0009.jpg)'
- en: '[Figure 14-9](#c14-fig-0011a) Depth-first-search shortest-path algorithm'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-9](#c14-fig-0011a) 深度优先搜索最短路径算法'
- en: The algorithm implemented by `DFS` is an example of a recursive **depth-first-search
    (DFS)** algorithm. In general, a depth-first-search algorithm begins by choosing
    one child of the start node. It then chooses one child of that node and so on,
    going deeper and deeper until it either reaches the goal node or a node with no
    children. The search then **backtracks**, returning to the most recent node with
    children that it has not yet visited. When all paths have been explored, it chooses
    the shortest path (assuming that there is one) from the start to the goal.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`DFS`实现的算法是递归**深度优先搜索（DFS）**算法的一个示例。一般来说，深度优先搜索算法通过选择起始节点的一个子节点开始。然后它选择该节点的一个子节点，依此类推，越来越深入，直到它达到目标节点或一个没有子节点的节点。然后搜索**回溯**，返回到最近的尚未访问的有子节点的节点。当所有路径都被探索完毕时，它选择从起点到目标的最短路径（假设存在这样一条路径）。'
- en: The code is more complicated than the algorithm we just described because it
    has to deal with the possibility of the graph containing cycles. It also avoids
    exploring paths longer than the shortest path that it has already found.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码比我们刚刚描述的算法更复杂，因为它必须处理图中包含循环的可能性。它还避免探索比已找到的最短路径更长的路径。
- en: The function `shortest_path` calls `DFS` with `path == []` (to indicate that
    the current path being explored is empty) and `shortest == None` (to indicate
    that no path from `start` to `end` has yet been found).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数`shortest_path`以`path == []`（表示当前探索的路径为空）和`shortest == None`（表示尚未找到从`start`到`end`的路径）调用`DFS`。
- en: '`DFS` begins by choosing one child of `start`. It then chooses one child of
    that node and so on, until either it reaches the node `end` or a node with no
    unvisited children.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DFS`开始时选择`start`的一个子节点。然后它选择该节点的一个子节点，依此类推，直到到达节点`end`或一个没有未访问子节点的节点。'
- en: ○ The check `if node not in path` prevents the program from getting caught in
    a cycle.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 检查`if node not in path`防止程序陷入循环。
- en: ○ The check `if shortest == None or len(path) < len(shortest)` is used to decide
    if it is possible that continuing to search this path might yield a shorter path
    than the best path found so far.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 检查`if shortest == None or len(path) < len(shortest)`用于决定继续搜索该路径是否可能产生比当前找到的最佳路径更短的路径。
- en: ○ If so, `DFS` is called recursively. If it finds a path to `end` that is no
    longer than the best found so far, `shortest` is updated.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 如果是这样，`DFS`被递归调用。如果它找到一条到`end`的路径，其长度不超过目前为止找到的最佳路径，则更新`shortest`。
- en: ○ When the last node on `path` has no children left to visit, the program backtracks
    to the previously visited node and visits the next child of that node.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ○ 当`path`中的最后一个节点没有子节点可供访问时，程序回溯到之前访问过的节点，并访问该节点的下一个子节点。
- en: The function returns when all possible shortest paths from `start` to `end`
    have been explored.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从`start`到`end`的所有可能的最短路径都被探索后，函数返回。
- en: '[Figure 14-10](#c14-fig-0012) contains some code that runs the code in [Figure
    14-9](#c14-fig-0011). The function `test_SP` in [Figure 14-10](#c14-fig-0012)
    first builds a directed graph like the one pictured in the figure, and then searches
    for a shortest path between node 0 and node 5.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-10](#c14-fig-0012)包含一些代码，该代码运行[图 14-9](#c14-fig-0011)中的代码。[图 14-10](#c14-fig-0012)中的函数`test_SP`首先构建一个有向图，如图中所示，然后在节点0和节点5之间搜索最短路径。'
- en: '![c14-fig-0010.jpg](../images/c14-fig-0010.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![c14-fig-0010.jpg](../images/c14-fig-0010.jpg)'
- en: '[Figure 14-10](#c14-fig-0012a) Test depth-first-search code'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-10](#c14-fig-0012a) 测试深度优先搜索代码'
- en: When executed, `test_SP` produces the output
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，`test_SP`生成的输出是
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that after exploring the path `0->1->2->3->4`, it backs up to node `3`
    and explores the path `0->1->2->3->5`. After saving that as the shortest successful
    path so far, it backs up to node `2` and explores the path `0->1->2->4`. When
    it reaches the end of that path (node `4`), it backs up all the way to node `0`
    and investigates the path starting with the edge from `0` to `2`. And so on.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在探索路径`0->1->2->3->4`后，它回退到节点`3`并探索路径`0->1->2->3->5`。在将其保存为迄今为止的最短成功路径后，它回退到节点`2`并探索路径`0->1->2->4`。当到达该路径的尽头（节点`4`）时，它回退到节点`0`并调查从`0`到`2`的边开始的路径。依此类推。
- en: The DFS algorithm implemented in [Figure 14-9](#c14-fig-0011) finds the path
    with the minimum number of edges. If the edges have weights, it will not necessarily
    find the path that minimizes the sum of the weights of the edges. However, it
    is easily modified to do so.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-9](#c14-fig-0011)中实现的DFS算法找到边数最少的路径。如果边具有权重，它不一定找到最小化边权重和的路径。不过，它可以很容易地修改以实现此目的。
- en: '**Finger exercise:** Modify the DFS algorithm to find a path that minimizes
    the sum of the weights. Assume that all weights are positive integers.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：** 修改深度优先搜索算法以找到使权重总和最小的路径。假设所有权重都是正整数。'
- en: Of course, there are other ways to traverse a graph than depth-first. Another
    common approach is breadth-first search (BFS). A breadth-first traversal first
    visits all children of the start node. If none of those is the end node, it visits
    all children of each of those nodes. And so on. Unlike depth-first search, which
    is often implemented recursively, breadth-first search is usually implemented
    iteratively. BFS explores many paths simultaneously, adding one node to each path
    on each iteration. Since it generates the paths in ascending order of length,
    the first path found with the goal as its last node is guaranteed to have a minimum
    number of edges.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了深度优先搜索之外，还有其他遍历图的方法。另一种常见的方法是广度优先搜索（BFS）。广度优先遍历首先访问起始节点的所有子节点。如果其中没有一个是结束节点，则访问每个子节点的所有子节点，依此类推。与通常递归实现的深度优先搜索不同，广度优先搜索通常是迭代实现的。BFS同时探索多条路径，每次迭代为每条路径添加一个节点。由于它以长度递增的顺序生成路径，第一次找到以目标节点为最后节点的路径保证边数最少。
- en: '[Figure 14-11](#c14-fig-0013) contains code that uses a breadth-first search
    to find the shortest path in a directed graph. The variable `path_queue` is used
    to store all of the paths currently being explored. Each iteration starts by removing
    a path from `path_queu`e and assigning that path to `tmp_path`. If the last node
    in `tmp_path` is `end`, `tmp_path` is a shortest path and is returned. Otherwise,
    a set of new paths is created, each of which extends `tmp_path` by adding one
    of its children. Each of these new paths is then added to `path_queue`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-11](#c14-fig-0013)包含使用广度优先搜索在有向图中找到最短路径的代码。变量`path_queue`用于存储当前正在探索的所有路径。每次迭代开始时，从`path_queue`中移除一条路径并将其分配给`tmp_path`。如果`tmp_path`的最后一个节点是`end`，则`tmp_path`是最短路径并被返回。否则，创建一组新路径，每条路径通过添加其子节点扩展`tmp_path`。这些新路径随后被添加到`path_queue`中。'
- en: '![c14-fig-0011.jpg](../images/c14-fig-0011.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![c14-fig-0011.jpg](../images/c14-fig-0011.jpg)'
- en: '[Figure 14-11](#c14-fig-0013a) Breadth-first-search shortest path algorithm'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-11](#c14-fig-0013a) 广度优先搜索最短路径算法'
- en: When the lines
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些线
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: are added at the end of `test_SP` and the function is executed, it prints the
    additional lines
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到`test_SP`末尾并执行函数时，它会打印附加行
- en: '[PRE5]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Comfortingly, each algorithm found a path of the same length. In this case,
    they found the same path. However, if a graph contains more than one shortest
    path between a pair of nodes, DFS and BFS will not necessarily find the same shortest
    path.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 令人安心的是，每个算法找到的路径长度相同。在这种情况下，它们找到的是相同的路径。然而，如果图中存在多条最短路径，DFS和BFS不一定找到相同的最短路径。
- en: As mentioned above, BFS is a convenient way to search for a path with the fewest
    edges because the first time a path is found, it is guaranteed to be such a path.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，广度优先搜索是一种方便的搜索路径的方式，因为第一次找到的路径保证是最少边数的路径。
- en: '**Finger exercise:** Consider a digraph with weighted edges. Is the first path
    found by BFS guaranteed to minimize the sum of the weights of the edges?'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：** 考虑一个带权边的有向图。BFS找到的第一条路径是否保证能够最小化边的权重总和？'
- en: 14.3 Terms Introduced in Chapter
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 本章引入的术语
- en: optimization problem
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化问题
- en: objective function
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标函数
- en: set of constraints
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约束集
- en: knapsack problem
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背包问题
- en: greedy algorithm
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贪心算法
- en: optimal solution
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最优解
- en: 0/1 knapsack problem
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0/1背包问题
- en: locally optimal
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部最优
- en: globally optimal
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局最优
- en: continuous knapsack problem
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续背包问题
- en: graph
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图
- en: node (vertex)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点（顶点）
- en: edge (arc)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边（弧）
- en: directed graph (digraph)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有向图（digraph）
- en: source (parent) node
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源（父）节点
- en: destination (child) node
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标（子）节点
- en: path
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径
- en: cycle
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环
- en: cyclic graph
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有环图
- en: acyclic graph
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无环图
- en: graph theory
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图论
- en: weighted graph
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带权图
- en: adjacency matrix
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邻接矩阵
- en: adjacency list
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邻接表
- en: shortest path
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最短路径
- en: shortest weighted path
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最短带权路径
- en: min cut
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小割
- en: maximum clique
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大团
- en: depth-first search (DFS)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度优先搜索（DFS）
- en: backtracking
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回溯法
- en: breadth-first search (BFS)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广度优先搜索（BFS）
