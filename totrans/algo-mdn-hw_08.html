<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Functions and Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Functions and Recursion</h1>
<blockquote>原文：<a href="https://en.algorithmica.org/hpc/architecture/functions/">https://en.algorithmica.org/hpc/architecture/functions/</a></blockquote><div id="search"><input id="search-bar" type="search" placeholder="Search this book…" oninput="search()"/><div id="search-count"/><div id="search-results"/></div><header><div class="info"/></header><article><p>To “call a function” in assembly, you need to <a href="../loops">jump</a> to its beginning and then jump back. But then two important problems arise:</p><ol><li>What if the caller stores data in the same registers as the callee?</li><li>Where is “back”?</li></ol><p>Both of these concerns can be solved by having a dedicated location in memory where we can write all the information we need to return from the function before calling it. This location is called <em>the stack</em>.</p><span class="anchor" id="the-stack"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/architecture/functions/#the-stack">#</a>The Stack</h3><p>The hardware stack works the same way software stacks do and is similarly implemented as just two pointers:</p><ul><li>The <em>base pointer</em> marks the start of the stack and is conventionally stored in <code>rbp</code>.</li><li>The <em>stack pointer</em> marks the last element of the stack and is conventionally stored in <code>rsp</code>.</li></ul><p>When you need to call a function, you push all your local variables onto the stack (which you can also do in other circumstances; e.g., when you run out of registers), push the current instruction pointer, and then jump to the beginning of the function. When exiting from a function, you look at the pointer stored on top of the stack, jump there, and then carefully read all the variables stored on the stack back into their registers.</p><p>You can implement all that with the usual memory operations and jumps, but because of how frequently it is used, there are 4 special instructions for doing this:</p><ul><li><code>push</code> writes data at the stack pointer and decrements it.</li><li><code>pop</code> reads data from the stack pointer and increments it.</li><li><code>call</code> puts the address of the following instruction on top of the stack and jumps to a label.</li><li><code>ret</code> reads the return address from the top of the stack and jumps to it.</li></ul><p>You would call them “syntactic sugar” if they weren’t actual hardware instructions — they are just fused equivalents of these two-instruction snippets:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="c1">; "push rax"</span>
</span></span><span class="line"><span class="cl"><span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="kt">QWORD</span> <span class="nv">PTR</span><span class="p">[</span><span class="nb">rsp</span><span class="p">],</span> <span class="nb">rax</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">; "pop rax"</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">QWORD</span> <span class="nv">PTR</span><span class="p">[</span><span class="nb">rsp</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">; "call func"</span>
</span></span><span class="line"><span class="cl"><span class="nf">push</span> <span class="nv">rip</span> <span class="c1">; &lt;- instruction pointer (although accessing it like that is probably illegal)</span>
</span></span><span class="line"><span class="cl"><span class="nf">jmp</span> <span class="nv">func</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">; "ret"</span>
</span></span><span class="line"><span class="cl"><span class="nf">pop</span>  <span class="nb">rcx</span> <span class="c1">; &lt;- choose any unused register</span>
</span></span><span class="line"><span class="cl"><span class="nf">jmp</span> <span class="nb">rcx</span>
</span></span></code></pre></div><p>The memory region between <code>rbp</code> and <code>rsp</code> is called a <em>stack frame</em>, and this is where local variables of functions are typically stored. It is pre-allocated at the start of the program, and if you push more data on the stack than its capacity (8MB by default on Linux), you encounter a <em>stack overflow</em> error. Because modern operating systems don’t actually give you memory pages until you read or write to their address space, you can freely specify a very large stack size, which acts more like a limit on how much stack memory can be used, and not a fixed amount every program has to use.</p><span class="anchor" id="calling-conventions"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/architecture/functions/#calling-conventions">#</a>Calling Conventions</h3><p>The people who develop compilers and operating systems eventually came up with <a href="https://wiki.osdev.org/Calling_Conventions">conventions</a> on how to write and call functions. These conventions enable some important <a href="/hpc/compilation/stages/">software engineering marvels</a> such as splitting compilation into separate units, reusing already-compiled libraries, and even writing them in different programming languages.</p><p>Consider the following example in C:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">distance</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">square</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>By convention, a function should take its arguments in <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code> (and the rest in the stack if those weren’t enough), put the return value into <code>rax</code>, and then return. Thus, <code>square</code>, being a simple one-argument function, can be implemented like this:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nl">square:</span>             <span class="c1">; x = edi, ret = eax</span>
</span></span><span class="line"><span class="cl">    <span class="nf">imul</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">edi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ret</span>
</span></span></code></pre></div><p>Each time we call it from <code>distance</code>, we just need to go through some trouble preserving its local variables:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nl">distance:</span>           <span class="c1">; x = rdi/edi, y = rsi/esi, ret = rax/eax</span>
</span></span><span class="line"><span class="cl">    <span class="nf">push</span> <span class="nb">rdi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">push</span> <span class="nb">rsi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">call</span> <span class="nv">square</span>     <span class="c1">; eax = square(x)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pop</span>  <span class="nb">rsi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pop</span>  <span class="nb">rdi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>   <span class="c1">; save x^2</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>  <span class="nb">rdi</span><span class="p">,</span> <span class="nb">rsi</span>   <span class="c1">; move new x=y</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">push</span> <span class="nb">rdi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">push</span> <span class="nb">rsi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">call</span> <span class="nv">square</span>     <span class="c1">; eax = square(x=y)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pop</span>  <span class="nb">rsi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pop</span>  <span class="nb">rdi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">add</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>   <span class="c1">; x^2 + y^2</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ret</span>
</span></span></code></pre></div><p>There are a lot more nuances, but we won’t go into detail here because this book is about performance, and the best way to deal with functions calls is actually to avoid making them in the first place.</p><span class="anchor" id="inlining"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/architecture/functions/#inlining">#</a>Inlining</h3><p>Moving data to and from the stack creates noticeable overhead for small functions like these. The reason you have to do this is that, in general, you don’t know whether the callee is modifying the registers where you store your local variables. But when you have access to the code of <code>square</code>, you can solve this problem by stashing the data in registers that you know won’t be modified.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nl">distance:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">call</span> <span class="nv">square</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>  <span class="nb">edi</span><span class="p">,</span> <span class="nb">esi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">call</span> <span class="nv">square</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ret</span>
</span></span></code></pre></div><p>This is better, but we are still implicitly accessing stack memory: you need to push and pop the instruction pointer on each function call. In simple cases like this, we can <em>inline</em> function calls by stitching the callee’s code into the caller and resolving conflicts over registers. In our example:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nl">distance:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">imul</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>       <span class="c1">; edi = x^2</span>
</span></span><span class="line"><span class="cl">    <span class="nf">imul</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">esi</span>       <span class="c1">; esi = y^2</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add</span>  <span class="nb">edi</span><span class="p">,</span> <span class="nb">esi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">edi</span>       <span class="c1">; there is no "add eax, edi, esi", so we need a separate mov</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ret</span>
</span></span></code></pre></div><p>This is fairly close to what optimizing compilers produce out of this snippet — only they use the <a href="../assembly">lea trick</a> to make the resulting machine code sequence a few bytes smaller:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nl">distance:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">imul</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>       <span class="c1">; edi = x^2</span>
</span></span><span class="line"><span class="cl">    <span class="nf">imul</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">esi</span>       <span class="c1">; esi = y^2</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lea</span>  <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rdi</span><span class="o">+</span><span class="nb">rsi</span><span class="p">]</span> <span class="c1">; eax = x^2 + y^2</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ret</span>
</span></span></code></pre></div><p>In situations like these, function inlining is clearly beneficial, and compilers mostly do it <a href="/hpc/compilation/situational">automatically</a>, but there are cases when it’s not — and we will talk about them <a href="../layout">in a bit</a>.</p><span class="anchor" id="tail-call-elimination"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/architecture/functions/#tail-call-elimination">#</a>Tail Call Elimination</h3><p>Inlining is straightforward to do when the callee doesn’t make any other function calls, or at least if these calls are not recursive. Let’s move on to a more complex example. Consider this recursive computation of a factorial:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Equivalent assembly:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="c1">; n = edi, ret = eax</span>
</span></span><span class="line"><span class="cl"><span class="nl">factorial:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">test</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>   <span class="c1">; test if a value is zero</span>
</span></span><span class="line"><span class="cl">    <span class="nf">jne</span>  <span class="nv">nonzero</span>    <span class="c1">; (the machine code of "cmp rax, 0" would be one byte longer)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>  <span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>     <span class="c1">; return 1</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ret</span>
</span></span><span class="line"><span class="cl"><span class="nl">nonzero:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">push</span> <span class="nb">edi</span>        <span class="c1">; save n to use later in multiplication</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sub</span>  <span class="nb">edi</span><span class="p">,</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nf">call</span> <span class="nv">factorial</span>  <span class="c1">; call f(n - 1)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pop</span>  <span class="nb">edi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">imul</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">edi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ret</span>
</span></span></code></pre></div><p>If the function is recursive, it is still often possible to make it “call-less” by restructuring it. This is the case when the function is <em>tail recursive</em>, that is, it returns right after making a recursive call. Since no actions are required after the call, there is also no need for storing anything on the stack, and a recursive call can be safely replaced with a jump to the beginning — effectively turning the function into a loop.</p><p>To make our <code>factorial</code> function tail-recursive, we can pass a “current product” argument to it:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Then this function can be easily folded into a loop:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="c1">; assuming n &gt; 0</span>
</span></span><span class="line"><span class="cl"><span class="nl">factorial:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>  <span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="nl">loop:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">imul</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">edi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sub</span>  <span class="nb">edi</span><span class="p">,</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nf">jne</span>  <span class="nv">loop</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ret</span>
</span></span></code></pre></div><p>The primary reason why recursion can be slow is that it needs to read and write data to the stack, while iterative and tail-recursive algorithms do not. This concept is very important in functional programming, where there are no loops and all you can use are functions. Without tail call elimination, functional programs would require way more time and memory to execute.</p></article><div class="nextprev"><div class="left"><a href="https://en.algorithmica.org/hpc/architecture/loops/" id="prev-article">← Loops and Conditionals</a></div><div class="right"><a href="https://en.algorithmica.org/hpc/architecture/indirect/" id="next-article">Indirect Branching →</a></div></div>    
</body>
</html>