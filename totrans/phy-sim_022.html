<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Inertia Term</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Inertia Term</h1>
<blockquote>原文：<a href="https://phys-sim-book.github.io/lec4.2-inertia.html">https://phys-sim-book.github.io/lec4.2-inertia.html</a></blockquote>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"/>

<p>For the inertia term, with \(\tilde{x}^n = x^n + h v^n\), we have
\[
E_I(x) = \frac{1}{2}\|x - \tilde{x}^n \|_M^2, \quad \nabla E_I(x) = M(x - \tilde{x}^n), \quad \text{and} \quad \nabla^2 E_I(x) = M,
\]
which is straightforward to implement:</p>
<p><a name="imp:lec4:inertia_energy"/>
<strong>Implementation 4.2.1 (InertiaEnergy.py).</strong></p>
<pre><code class="language-python">import numpy as np

def val(x, x_tilde, m):
    sum = 0.0
    for i in range(0, len(x)):
        diff = x[i] - x_tilde[i]
        sum += 0.5 * m[i] * diff.dot(diff)
    return sum

def grad(x, x_tilde, m):
    g = np.array([[0.0, 0.0]] * len(x))
    for i in range(0, len(x)):
        g[i] = m[i] * (x[i] - x_tilde[i])
    return g

def hess(x, x_tilde, m):
    IJV = [[0] * (len(x) * 2), [0] * (len(x) * 2), np.array([0.0] * (len(x) * 2))]
    for i in range(0, len(x)):
        for d in range(0, 2):
            IJV[0][i * 2 + d] = i * 2 + d
            IJV[1][i * 2 + d] = i * 2 + d
            IJV[2][i * 2 + d] = m[i]
    return IJV
</code></pre>
<p>The functions <code>val()</code>, <code>grad()</code>, and <code>hess()</code> are designed to compute different components of the inertia term. Specifically:</p>
<ul>
<li><code>val()</code>: Computes the value of the inertia term.</li>
<li><code>grad()</code>: Calculates the gradient of the inertia term.</li>
<li><code>hess()</code>: Determines the Hessian of the inertia term.</li>
</ul>
<p>Regarding the Hessian matrix, a memory-efficient approach is employed. Rather than allocating a large two-dimensional array to store all entries of the Hessian matrix, only the nonzero entries are kept. This is achieved using the <code>IJV</code> structure, which consists of three lists:</p>
<ol>
<li><strong>Row Index</strong>: Identifies the row position of each nonzero entry.</li>
<li><strong>Column Index</strong>: Indicates the column position of each nonzero entry.</li>
<li><strong>Value</strong>: The actual nonzero value at the specified row and column.</li>
</ol>
<p>This method significantly reduces memory usage and computational costs associated with downstream processing.</p>

                        
</body>
</html>