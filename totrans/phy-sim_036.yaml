- en: General Slip DBC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般滑移 DBC
- en: 原文：[https://phys-sim-book.github.io/lec6.3-general_slip_DBC.html](https://phys-sim-book.github.io/lec6.3-general_slip_DBC.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://phys-sim-book.github.io/lec6.3-general_slip_DBC.html](https://phys-sim-book.github.io/lec6.3-general_slip_DBC.html)'
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
- en: Fortunately, for constraints like slip DBCs that are decoupled per node, SVD
    simply results in block-diagonal U and V which could be constructed procedurally
    in an efficient way. 3D planar slip DBC at node i can be expressed as niT​(xi​−xi′​)=0,
    where ni​ is the normal of the plane that node i is slipping, and xi′​ is an arbitrary
    point on that plane. As discussed near Equation [(5.1.2)](lec5.1-equality_constraints.html#eq:lec5:BC_dx),
    if at the beginning of the time step node i is already on the plane, the constraint
    simplifies to niT​Δxi​=0. Then performing SVD on the row vector niT​, we obtain
    niT​=Ui​Si​ViT​=1[1​0​0​]​niT​miT​liT​​​,(6.3.1) where unit vectors ni​, mi​,
    and li​ together form an orthonormal basis in 3D.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于像滑移 DBC 这样的节点解耦约束，奇异值分解简单地得到分块对角矩阵 U 和 V，这可以通过程序以高效的方式构建。节点 i 的 3D 平面滑移
    DBC 可以表示为 niT(xi−xi′)=0，其中 ni 是节点 i 滑移的平面的法线，xi′ 是该平面上的任意一点。如方程 [(5.1.2)](lec5.1-equality_constraints.html#eq:lec5:BC_dx)
    所讨论的，如果在时间步的初始时刻节点 i 已经在平面上，则约束简化为 niTΔxi=0。然后对行向量 niT 进行奇异值分解，我们得到 niT=UiSiViT=1[1
    0 0]niTmiTliT，(6.3.1) 其中单位向量 ni、mi 和 li 一起在 3D 中形成一个正交归一基。
- en: Then it becomes clear that globally, U is simply a m×m identity matrix, S is
    a m×dn matrix where every row contains exactly one unit-valued entry in the column
    corresponding to the first DOF of the slip BC node, and V is a dn×dn block-diagonal
    matrix with the d×d orthonormal blocks only on those corresponding to BC nodes,
    and d×d identity matrix elsewhere.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 那么就变得明显了，全局上，U 是一个 m×m 的单位矩阵，S 是一个 m×dn 矩阵，其中每一行在对应于滑移边界条件节点第一个自由度的列中恰好有一个单位值，V
    是一个 dn×dn 的分块对角矩阵，其中只有对应于边界条件节点的 d×d 正交归一矩阵，其他位置是 d×d 的单位矩阵。
- en: To compute mi​ and li​ from ni​, we first note that there are an infinite number
    of possible solutions. Therefore, we can simply first construct mi​=ni​×[1​0​0​]T,
    or mi​=ni​×[0​1​0​]T if ni​ is almost colinear with [1​0​0​]T, and then construct
    li​=ni​×mi​. To obtain VT(−g), one only needs to left-multiply each ViT​=​niT​miT​liT​​​
    to −gi​. As for VTHV, first left-multiply each ViT​ to every block on the i-th
    block row of H to obtain VTH. Then for the i-th block column of VTH, right-multiply
    Vi​=[ni​​mi​​li​​] to every block. Finally, after solving for y by applying the
    DOF elimination method on the modified system (Equation [(6.2.3)](lec6.2-change_of_vars.html#eq:lec6:BC_KKT_SVD)),
    that is, solving (I−STS)VTHVy=(I−STS)(−VTg),(6.3.2) Δx can be obtained by Δx=Vy
    with similar block(node)-wise operations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 ni 计算出 mi 和 li，我们首先注意到存在无限多种可能的解。因此，我们可以简单地首先构造 mi=ni×[1 0 0]T，或者如果 ni 几乎与
    [1 0 0]T 共线，则构造 mi=ni×[0 1 0]T，然后构造 li=ni×mi。要获得 VT(−g)，只需将每个 ViT=niT×miT×liT
    左乘以 −gi。至于 VTHV，首先将每个 ViT 左乘以 H 的第 i 块行上的每个块以获得 VTH。然后对于 VTH 的第 i 块列，将 Vi=[ni
    mi li] 右乘以每个块。最后，通过在修改后的系统（方程式 [(6.2.3)](lec6.2-change_of_vars.html#eq:lec6:BC_KKT_SVD)）上应用自由度消除方法求解
    y，即求解 (I−STS)VTHVy=(I−STS)(−VTg)，(6.3.2) Δx 可以通过 Δx=Vy 以类似的块（节点）操作获得。
- en: '**Example 6.3.1 (General Slip DBC).** For the same two-node system in 2D as
    mentioned in the slip DBC example ([Example 5.1.2](lec5.1-equality_constraints.html#exp:lec5:slip)),
    to constrain the first node (x11​,x12​) inside the 3x+4y=2 line, the slip DBC
    can be expressed as [3​4​0​0​]​x11​x12​x21​x22​​​=2 and we can build U=1, S=[1​0​0​0​], VT=​0.6−0.8​0.80.6​1​1​​
    for changing the basis. Then in a time step where this slip DBC is already satisfied,
    assume we have H=​4−1−1−1​−14−1−1​−1−14−1​−1−1−14​​,andg=​1234​​, we can compute
    VTHV=​3.040.28−1.4−1.4​0.284.960.20.2​−1.40.24−1​−1.40.2−14​​,andVTg=​2.20.434​​,
    and solve the system ​1000​04.960.20.2​00.24−1​00.2−14​​​y11​y12​y21​y22​​​=​0−0.4−3−4​​
    for y. Then the search direction can be obtained by Δx=Vy so that 3Δx11​+4Δx12​=0
    and so the first node will stay on the 3x+4y=2 line for arbitrary step size.'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**示例 6.3.1 (一般滑动DBC)**。对于与滑动DBC示例中提到的二维两个节点系统相同的情况（[示例 5.1.2](lec5.1-equality_constraints.html#exp:lec5:slip)），为了约束第一个节点（x11、x12）在3x+4y=2直线上，滑动DBC可以表示为[3
    4 0 0] x11 x12 x21 x22 = 2，并且我们可以构建U=1，S=[1 0 0 0]，VT=0.6−0.8 0.8 0.6 1 1，用于改变基。然后在一个满足此滑动DBC的时间步长中，假设我们已有H=4−1−1−1
    −1 4−1−1 −1−1 4−1 −1−1−1 4，g=1234，我们可以计算VTHV=3.040.28−1.4−1.4 0.284.960.20.2 −1.40.24−1
    −1.40.2−1 4，VTg=2.20.43 4，并解系统1000 04.960.20.2 00.24−1 00.2−1 4 y11 y12 y21 y22
    = 0−0.4−3−4 y。然后通过Δx=Vy得到搜索方向，因此3Δx11+4Δx12=0，这样第一个节点将保持在3x+4y=2直线上，对于任意步长。'
