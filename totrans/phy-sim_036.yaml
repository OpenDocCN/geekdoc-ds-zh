- en: General Slip DBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://phys-sim-book.github.io/lec6.3-general_slip_DBC.html](https://phys-sim-book.github.io/lec6.3-general_slip_DBC.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, for constraints like slip DBCs that are decoupled per node, SVD
    simply results in block-diagonal U and V which could be constructed procedurally
    in an efficient way. 3D planar slip DBC at node i can be expressed as niT​(xi​−xi′​)=0,
    where ni​ is the normal of the plane that node i is slipping, and xi′​ is an arbitrary
    point on that plane. As discussed near Equation [(5.1.2)](lec5.1-equality_constraints.html#eq:lec5:BC_dx),
    if at the beginning of the time step node i is already on the plane, the constraint
    simplifies to niT​Δxi​=0. Then performing SVD on the row vector niT​, we obtain
    niT​=Ui​Si​ViT​=1[1​0​0​]​niT​miT​liT​​​,(6.3.1) where unit vectors ni​, mi​,
    and li​ together form an orthonormal basis in 3D.
  prefs: []
  type: TYPE_NORMAL
- en: Then it becomes clear that globally, U is simply a m×m identity matrix, S is
    a m×dn matrix where every row contains exactly one unit-valued entry in the column
    corresponding to the first DOF of the slip BC node, and V is a dn×dn block-diagonal
    matrix with the d×d orthonormal blocks only on those corresponding to BC nodes,
    and d×d identity matrix elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: To compute mi​ and li​ from ni​, we first note that there are an infinite number
    of possible solutions. Therefore, we can simply first construct mi​=ni​×[1​0​0​]T,
    or mi​=ni​×[0​1​0​]T if ni​ is almost colinear with [1​0​0​]T, and then construct
    li​=ni​×mi​. To obtain VT(−g), one only needs to left-multiply each ViT​=​niT​miT​liT​​​
    to −gi​. As for VTHV, first left-multiply each ViT​ to every block on the i-th
    block row of H to obtain VTH. Then for the i-th block column of VTH, right-multiply
    Vi​=[ni​​mi​​li​​] to every block. Finally, after solving for y by applying the
    DOF elimination method on the modified system (Equation [(6.2.3)](lec6.2-change_of_vars.html#eq:lec6:BC_KKT_SVD)),
    that is, solving (I−STS)VTHVy=(I−STS)(−VTg),(6.3.2) Δx can be obtained by Δx=Vy
    with similar block(node)-wise operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 6.3.1 (General Slip DBC).** For the same two-node system in 2D as
    mentioned in the slip DBC example ([Example 5.1.2](lec5.1-equality_constraints.html#exp:lec5:slip)),
    to constrain the first node (x11​,x12​) inside the 3x+4y=2 line, the slip DBC
    can be expressed as [3​4​0​0​]​x11​x12​x21​x22​​​=2 and we can build U=1, S=[1​0​0​0​], VT=​0.6−0.8​0.80.6​1​1​​
    for changing the basis. Then in a time step where this slip DBC is already satisfied,
    assume we have H=​4−1−1−1​−14−1−1​−1−14−1​−1−1−14​​,andg=​1234​​, we can compute
    VTHV=​3.040.28−1.4−1.4​0.284.960.20.2​−1.40.24−1​−1.40.2−14​​,andVTg=​2.20.434​​,
    and solve the system ​1000​04.960.20.2​00.24−1​00.2−14​​​y11​y12​y21​y22​​​=​0−0.4−3−4​​
    for y. Then the search direction can be obtained by Δx=Vy so that 3Δx11​+4Δx12​=0
    and so the first node will stay on the 3x+4y=2 line for arbitrary step size.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
