["```py\ndef gramschmidt(A):\n    (n,m) = A.shape\n    Q = np.zeros((n,m))\n    R = np.zeros((m,m))\n    for j in range(m):\n        v = np.copy(A[:,j])\n        for i in range(j):\n            R[i,j] = np.dot(Q[:,i], A[:,j])\n            v -= R[i,j]*Q[:,i]\n        R[j,j] = LA.norm(v)\n        Q[:,j] = v/R[j,j]\n    return Q, R \n```", "```py\nw1 = np.array([1., 0., 1.])\nw2 = np.array([0., 1., 1.])\nA = np.stack((w1, w2),axis=-1)\nprint(A) \n```", "```py\n[[1\\. 0.]\n [0\\. 1.]\n [1\\. 1.]] \n```", "```py\nQ, R = gramschmidt(A)\nprint(Q) \n```", "```py\n[[ 0.70710678 -0.40824829]\n [ 0\\.          0.81649658]\n [ 0.70710678  0.40824829]] \n```", "```py\nprint(R) \n```", "```py\n[[1.41421356 0.70710678]\n [0\\.         1.22474487]] \n```", "```py\ndef backsubs(R,b):\n    m = b.shape[0]\n    x = np.zeros(m)\n    for i in reversed(range(m)):\n        x[i] = (b[i] - np.dot(R[i,i+1:m],x[i+1:m]))/R[i,i]\n    return x \n```", "```py\ndef forwardsubs(L,b):\n    m = b.shape[0]\n    x = np.zeros(m)\n    for i in range(m):\n        x[i] = (b[i] - np.dot(L[i,0:i],x[0:i]))/L[i,i]\n    return x \n```", "```py\ndef ls_by_qr(A, b):\n    Q, R = gramschmidt(A)\n    return backsubs(R, Q.T @ b) \n```", "```py\nw1 = np.array([1., 0., 1.])\nw2 = np.array([0., 1., 1.])\nA = np.stack((w1, w2),axis=-1)\nb = np.array([0., 0., 2.])\n\nx = ls_by_qr(A, b)\nprint(x) \n```", "```py\n[0.66666667 0.66666667] \n```", "```py\ndef householder(A, b):\n    n, m = A.shape\n    R = np.copy(A)\n    Qtb = np.copy(b)\n    for k in range(m):\n\n        y = R[k:n,k]\n        e1 = np.zeros(n-k)\n        e1[0] = 1\n        z = np.sign(y[0]) * LA.norm(y) * e1 + y\n        z = z / LA.norm(z)\n\n        R[k:n,k:m] = R[k:n,k:m] - 2 * np.outer(z, z) @ R[k:n,k:m]\n        Qtb[k:n] = Qtb[k:n] - 2 * np.outer(z, z) @ Qtb[k:n]\n\n    return R[0:m,0:m], Qtb[0:m] \n```", "```py\nw1 = np.array([1., 0., 1.])\nw2 = np.array([0., 1., 1.])\nA = np.stack((w1, w2),axis=-1)\nb = np.array([0., 0., 2.])\nR, Qtb = householder(A, b)\nx = backsubs(R, Qtb)\nprint(x) \n```", "```py\n[0.66666667 0.66666667] \n```", "```py\nseed = 535\nrng = np.random.default_rng(seed)\n\nn = 50\nU, W = LA.qr(rng.normal(0,1,(n,n)))\nV, W = LA.qr(rng.normal(0,1,(n,n)))\nS = np.diag((1/2) ** np.arange(1,n+1))\nA = U @ S @ V.T\n\nQgs, Rgs = gramschmidt(A)\nprint(LA.norm(A - Qgs @ Rgs))\nprint(LA.norm(Qgs.T @ Qgs - np.identity(n))) \n```", "```py\n1.4369568046009742e-16\n19.745599060592102 \n```", "```py\nQhh, Rhh = LA.qr(A)\nprint(LA.norm(A - Qhh @ Rhh))\nprint(LA.norm(Qhh.T @ Qhh - np.identity(n))) \n```", "```py\n4.739138228891714e-16\n5.33506987519293e-15 \n```", "```py\ndef gramschmidt(A):\n    (n,m) = A.shape\n    Q = np.zeros((n,m))\n    R = np.zeros((m,m))\n    for j in range(m):\n        v = np.copy(A[:,j])\n        for i in range(j):\n            R[i,j] = np.dot(Q[:,i], A[:,j])\n            v -= R[i,j]*Q[:,i]\n        R[j,j] = LA.norm(v)\n        Q[:,j] = v/R[j,j]\n    return Q, R \n```", "```py\nw1 = np.array([1., 0., 1.])\nw2 = np.array([0., 1., 1.])\nA = np.stack((w1, w2),axis=-1)\nprint(A) \n```", "```py\n[[1\\. 0.]\n [0\\. 1.]\n [1\\. 1.]] \n```", "```py\nQ, R = gramschmidt(A)\nprint(Q) \n```", "```py\n[[ 0.70710678 -0.40824829]\n [ 0\\.          0.81649658]\n [ 0.70710678  0.40824829]] \n```", "```py\nprint(R) \n```", "```py\n[[1.41421356 0.70710678]\n [0\\.         1.22474487]] \n```", "```py\ndef backsubs(R,b):\n    m = b.shape[0]\n    x = np.zeros(m)\n    for i in reversed(range(m)):\n        x[i] = (b[i] - np.dot(R[i,i+1:m],x[i+1:m]))/R[i,i]\n    return x \n```", "```py\ndef forwardsubs(L,b):\n    m = b.shape[0]\n    x = np.zeros(m)\n    for i in range(m):\n        x[i] = (b[i] - np.dot(L[i,0:i],x[0:i]))/L[i,i]\n    return x \n```", "```py\ndef ls_by_qr(A, b):\n    Q, R = gramschmidt(A)\n    return backsubs(R, Q.T @ b) \n```", "```py\nw1 = np.array([1., 0., 1.])\nw2 = np.array([0., 1., 1.])\nA = np.stack((w1, w2),axis=-1)\nb = np.array([0., 0., 2.])\n\nx = ls_by_qr(A, b)\nprint(x) \n```", "```py\n[0.66666667 0.66666667] \n```", "```py\ndef householder(A, b):\n    n, m = A.shape\n    R = np.copy(A)\n    Qtb = np.copy(b)\n    for k in range(m):\n\n        y = R[k:n,k]\n        e1 = np.zeros(n-k)\n        e1[0] = 1\n        z = np.sign(y[0]) * LA.norm(y) * e1 + y\n        z = z / LA.norm(z)\n\n        R[k:n,k:m] = R[k:n,k:m] - 2 * np.outer(z, z) @ R[k:n,k:m]\n        Qtb[k:n] = Qtb[k:n] - 2 * np.outer(z, z) @ Qtb[k:n]\n\n    return R[0:m,0:m], Qtb[0:m] \n```", "```py\nw1 = np.array([1., 0., 1.])\nw2 = np.array([0., 1., 1.])\nA = np.stack((w1, w2),axis=-1)\nb = np.array([0., 0., 2.])\nR, Qtb = householder(A, b)\nx = backsubs(R, Qtb)\nprint(x) \n```", "```py\n[0.66666667 0.66666667] \n```", "```py\nseed = 535\nrng = np.random.default_rng(seed)\n\nn = 50\nU, W = LA.qr(rng.normal(0,1,(n,n)))\nV, W = LA.qr(rng.normal(0,1,(n,n)))\nS = np.diag((1/2) ** np.arange(1,n+1))\nA = U @ S @ V.T\n\nQgs, Rgs = gramschmidt(A)\nprint(LA.norm(A - Qgs @ Rgs))\nprint(LA.norm(Qgs.T @ Qgs - np.identity(n))) \n```", "```py\n1.4369568046009742e-16\n19.745599060592102 \n```", "```py\nQhh, Rhh = LA.qr(A)\nprint(LA.norm(A - Qhh @ Rhh))\nprint(LA.norm(Qhh.T @ Qhh - np.identity(n))) \n```", "```py\n4.739138228891714e-16\n5.33506987519293e-15 \n```"]