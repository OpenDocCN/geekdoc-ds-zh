- en: 10\. Linear algebra
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 线性代数
- en: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C10_Linear_Algebra.html](https://leanprover-community.github.io/mathematics_in_lean/C10_Linear_Algebra.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C10_Linear_Algebra.html](https://leanprover-community.github.io/mathematics_in_lean/C10_Linear_Algebra.html)
- en: '*[Mathematics in Lean](index.html)* **   10\. Linear algebra'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Lean中的数学](index.html)* **   10. 线性代数'
- en: '[View page source](_sources/C10_Linear_Algebra.rst.txt)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[查看页面源代码](_sources/C10_Linear_Algebra.rst.txt)'
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '## 10.1\. Vector spaces and linear maps[](#vector-spaces-and-linear-maps "Link
    to this heading")'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '## 10.1. 向量空间和线性映射[](#vector-spaces-and-linear-maps "链接到本标题")'
- en: 10.1.1\. Vector spaces[](#vector-spaces "Link to this heading")
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1. 向量空间[](#vector-spaces "链接到本标题")
- en: We will start directly abstract linear algebra, taking place in a vector space
    over any field. However you can find information about matrices in [Section 10.4.1](#matrices)
    which does not logically depend on this abstract theory. Mathlib actually deals
    with a more general version of linear algebra involving the word module, but for
    now we will pretend this is only an eccentric spelling habit.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接从任何域上的向量空间开始抽象线性代数。然而，你可以在[第10.4.1节](#matrices)中找到有关矩阵的信息，这部分内容与抽象理论无关。Mathlib
    实际上处理的是涉及“模块”一词的更一般版本的线性代数，但到目前为止，我们将假装这只是一个古怪的拼写习惯。
- en: 'The way to say “let \(K\) be a field and let \(V\) be a vector space over \(K\)”
    (and make them implicit arguments to later results) is:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 表达“设 \(K\) 为一个域，设 \(V\) 为 \(K\) 上的向量空间”（并将它们作为后续结果的隐含参数）的方式是：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We explained in [Chapter 8](C08_Hierarchies.html#hierarchies) why we need two
    separate typeclasses `[AddCommGroup V] [Module K V]`. The short version is the
    following. Mathematically we want to say that having a \(K\)-vector space structure
    implies having an additive commutative group structure. We could tell this to
    Lean. But then whenever Lean would need to find such a group structure on a type
    \(V\), it would go hunting for vector space structures using a *completely unspecified*
    field \(K\) that cannot be inferred from \(V\). This would be very bad for the
    type class synthesis system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第8章](C08_Hierarchies.html#hierarchies)中解释了为什么我们需要两个独立的类型类 `[AddCommGroup
    V] [Module K V]`。简而言之，从数学上讲，我们想要表达拥有 \(K\) 向量空间结构意味着拥有加法交换群结构。我们可以将这一点告诉 Lean。但这样一来，每当
    Lean 需要在类型 \(V\) 上找到这样的群结构时，它就会使用一个*完全未指定的*域 \(K\) 来寻找向量空间结构，而这个 \(K\) 无法从 \(V\)
    中推断出来。这对类型类综合系统来说是非常糟糕的。
- en: The multiplication of a vector v by a scalar a is denoted by a • v. We list
    a couple of algebraic rules about the interaction of this operation with addition
    in the following examples. Of course simp or apply? would find those proofs. There
    is also a module tactic that solves goals following from the axioms of vector
    spaces and fields, in the same way the ring tactic is used in commutative rings
    or the group tactic is used in groups. But it is still useful to remember that
    scalar multiplication is abbreviated smul in lemma names.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 \(v\) 与标量 \(a\) 的乘积表示为 a • v。以下列出了关于此操作与加法交互的几个代数规则。当然，simp 或 apply? 会找到这些证明。还有一个模块策略，它可以解决从向量空间和域公理得出的目标，就像在交换环中使用
    ring 策略或在群中使用 group 策略一样。但记住标量乘法在引理名称中缩写为 smul 仍然是有用的。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As a quick note for more advanced readers, let us point out that, as suggested
    by terminology, Mathlib’s linear algebra also covers modules over (not necessarily
    commutative) rings. In fact it even covers semi-modules over semi-rings. If you
    think you do not need this level of generality, you can meditate the following
    example that nicely captures a lot of algebraic rules about ideals acting on submodules:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对更高级读者的快速提示，让我们指出，正如术语所暗示的，Mathlib 的线性代数还涵盖了（不一定交换的）环上的模块。事实上，它甚至涵盖了半环上的半模。如果你认为你不需要这种程度的普遍性，你可以冥想以下示例，它很好地捕捉了关于理想在子模块上作用的许多代数规则：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 10.1.2\. Linear maps[](#linear-maps "Link to this heading")
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2. 线性映射[](#linear-maps "链接到本标题")
- en: Next we need linear maps. Like group morphisms, linear maps in Mathlib are bundled
    maps, i.e. packages made of a map and proofs of its linearity properties. Those
    bundled maps are converted to ordinary functions when applied. See [Chapter 8](C08_Hierarchies.html#hierarchies)
    for more information about this design.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要线性映射。与群同态一样，Mathlib 中的线性映射是捆绑映射，即由映射及其线性性质证明组成的包。当应用这些捆绑映射时，它们会被转换为普通函数。有关此设计的更多信息，请参阅[第8章](C08_Hierarchies.html#hierarchies)。
- en: The type of linear maps between two `K`-vector spaces `V` and `W` is denoted
    by `V →ₗ[K] W`. The subscript l stands for linear. At first it may feel odd to
    specify `K` in this notation. But this is crucial when several fields come into
    play. For instance real-linear maps from \(ℂ\) to \(ℂ\) are every map \(z ↦ az
    + b\bar{z}\) while only the maps \(z ↦ az\) are complex linear, and this difference
    is crucial in complex analysis.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`K`-向量空间`V`和`W`之间的线性映射类型表示为`V →ₗ[K] W`。下标l代表线性。一开始，指定`K`在这个符号中可能感觉有点奇怪。但这是几个字段同时出现时的关键。例如，从\(ℂ\)到\(ℂ\)的实线性映射是每个映射\(z
    ↦ az + b\bar{z}\)，而只有映射\(z ↦ az\)是复线性，这种差异在复分析中是至关重要的。
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that `V →ₗ[K] W` itself carries interesting algebraic structures (this
    is part of the motivation for bundling those maps). It is a `K`-vector space so
    we can add linear maps and multiply them by scalars.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`V →ₗ[K] W`本身携带有趣的代数结构（这是捆绑那些映射的部分动机）。它是一个`K`-向量空间，因此我们可以对线性映射进行加法，并用标量乘以它们。
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: One downside of using bundled maps is that we cannot use ordinary function composition.
    We need to use `LinearMap.comp` or the notation `∘ₗ`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用捆绑映射的一个缺点是我们不能使用普通函数复合。我们需要使用`LinearMap.comp`或符号`∘ₗ`。
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are two main ways to construct linear maps. First we can build the structure
    by providing the function and the linearity proof. As usual, this is facilitated
    by the structure code action: you can type `example : V →ₗ[K] V := _` and use
    the code action “Generate a skeleton” attached to the underscore.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '构造线性映射有两种主要方法。首先，我们可以通过提供函数和线性证明来构建结构。像往常一样，这是通过结构代码操作来实现的：你可以输入`example :
    V →ₗ[K] V := _`并使用附加在下划线上的代码操作“生成骨架”。'
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You may wonder why the proof fields of `LinearMap` have names ending with a
    prime. This is because they are defined before the coercion to functions is defined,
    hence they are phrased in terms of `LinearMap.toFun`. Then they are restated as
    `LinearMap.map_add` and `LinearMap.map_smul` in terms of the coercion to function.
    This is not yet the end of the story. One also wants a version of `map_add` that
    applies to any (bundled) map preserving addition, such as additive group morphisms,
    linear maps, continuous linear maps, `K`-algebra maps etc… This one is `map_add`
    (in the root namespace). The intermediate version, `LinearMap.map_add` is a bit
    redundant but allows to use dot notation, which can be nice sometimes. A similar
    story exists for `map_smul`, and the general framework is explained in [Chapter
    8](C08_Hierarchies.html#hierarchies).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇为什么`LinearMap`的证明域以一个撇号结尾。这是因为它们是在定义函数转换之前定义的，因此它们是以`LinearMap.toFun`为术语来表述的。然后，它们被重新表述为`LinearMap.map_add`和`LinearMap.map_smul`，以函数转换的术语来表述。但这还不是故事的结束。人们还希望有一个适用于任何（捆绑的）保持加法的映射的`map_add`版本，例如加法群同态、线性映射、连续线性映射、`K`-代数映射等。这个版本是根命名空间中的`map_add`。中间版本`LinearMap.map_add`有点冗余，但允许使用点符号，这在某些时候可能很方便。对于`map_smul`也有类似的故事，而通用框架在[第8章](C08_Hierarchies.html#hierarchies)中得到了解释。
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One can also build linear maps from the ones that are already defined in Mathlib
    using various combinators. For instance the above example is already known as
    `LinearMap.lsmul K V 3`. There are several reason why `K` and `V` are explicit
    arguments here. The most pressing one is that from a bare `LinearMap.lsmul 3`
    there would be no way for Lean to infer `V` or even `K`. But also `LinearMap.lsmul
    K V` is an interesting object by itself: it has type `K →ₗ[K] V →ₗ[K] V`, meaning
    it is a `K`-linear map from `K` —seen as a vector space over itself— to the space
    of `K`-linear maps from `V` to `V`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用Mathlib中已定义的各种组合子从已定义的线性映射构建线性映射。例如，上面的例子已经知道是`LinearMap.lsmul K V 3`。为什么`K`和`V`在这里是显式参数有几个原因。最紧迫的一个原因是，从裸`LinearMap.lsmul
    3`中，Lean无法推断出`V`甚至`K`。但`LinearMap.lsmul K V`本身也是一个有趣的对象：它具有类型`K →ₗ[K] V →ₗ[K]
    V`，这意味着它是一个从`K`（被视为其自身的向量空间）到从`V`到`V`的`K`-线性映射的`K`-线性映射。
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There is also a type `LinearEquiv` of linear isomorphisms denoted by `V ≃ₗ[K]
    W`. The inverse of `f : V ≃ₗ[K] W` is `f.symm : W ≃ₗ[K] V`, composition of `f`
    and `g` is `f.trans g` also denoted by `f ≪≫ₗ g`, and the identity isomorphism
    of `V` is `LinearEquiv.refl K V`. Elements of this type are automatically coerced
    to morphisms and functions when necessary.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，还有一个表示为`V ≃ₗ[K] W`的线性同构类型`LinearEquiv`。`f : V ≃ₗ[K] W`的逆是`f.symm : W ≃ₗ[K]
    V`，`f`和`g`的复合是`f.trans g`，也记作`f ≪≫ₗ g`，而`V`的恒等同构是`LinearEquiv.refl K V`。当需要时，此类型中的元素会自动转换为形态和函数。'
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: One can use `LinearEquiv.ofBijective` to build an isomorphism from a bijective
    morphism. Doing so makes the inverse function noncomputable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `LinearEquiv.ofBijective` 从双射态射构建同构。这样做会使逆函数不可计算。
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that in the above example, Lean uses the announced type to understand that
    `.ofBijective` refers to `LinearEquiv.ofBijective` (without needing to open any
    namespace).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上面的例子中，Lean 使用宣布的类型来理解 `.ofBijective` 指的是 `LinearEquiv.ofBijective`（无需打开任何命名空间）。
- en: 10.1.3\. Sums and products of vector spaces[](#sums-and-products-of-vector-spaces
    "Link to this heading")
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3\. 向量空间的和与积[](#sums-and-products-of-vector-spaces "链接到本标题")
- en: We can build new vector spaces out of old ones using direct sums and direct
    products. Let us start with two vectors spaces. In this case there is no difference
    between sum and product, and we can simply use the product type. In the following
    snippet of code we simply show how to get all the structure maps (inclusions and
    projections) as linear maps, as well as the universal properties constructing
    linear maps into products and out of sums (if you are not familiar with the category-theoretic
    distinction between sums and products, you can simply ignore the universal property
    vocabulary and focus on the types of the following examples).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用直接和与直接积从旧向量空间构建新的向量空间。让我们从两个向量空间开始。在这种情况下，和与积之间没有区别，我们可以简单地使用积类型。在下面的代码片段中，我们简单地展示了如何将所有结构映射（包含和投射）作为线性映射来获取，以及构建线性映射到积和从和的通用性质（如果您不熟悉关于和与积的范畴论区别，您可以简单地忽略通用性质词汇，并关注以下示例的类型）。
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let us now turn to sums and products of arbitrary families of vector spaces.
    Here we will simply see how to define a family of vector spaces and access the
    universal properties of sums and products. Note that the direct sum notation is
    scoped to the `DirectSum` namespace, and that the universal property of direct
    sums requires decidable equality on the indexing type (this is somehow an implementation
    accident).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向任意向量空间族的和与积。在这里，我们将简单地看看如何定义一个向量空间族并访问和与积的通用性质。请注意，直接和的符号范围限定在 `DirectSum`
    命名空间内，并且直接和的通用性质要求索引类型的可判定等价性（这某种程度上是一个实现上的意外）。
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '## 10.2\. Subspaces and quotients[](#subspaces-and-quotients "Link to this
    heading")'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '## 10.2\. 子空间与商[](#subspaces-and-quotients "链接到本标题")'
- en: 10.2.1\. Subspaces[](#subspaces "Link to this heading")
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1\. 子空间[](#subspaces "链接到本标题")
- en: Just as linear maps are bundled, a linear subspace of `V` is also a bundled
    structure consisting of a set in `V`, called the carrier of the subspace, with
    the relevant closure properties. Again the word module appears instead of vector
    space because of the more general context that Mathlib actually uses for linear
    algebra.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '正如线性映射是打包的，`V` 的线性子空间也是一个打包的结构，由 `V` 中的一个集合组成，称为子空间的载体，具有相关的闭包性质。由于 Mathlib
    实际上用于线性代数的更一般上下文，所以这里出现的是“模块”一词而不是向量空间。 '
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the example above, it is important to understand that `Submodule K V` is
    the type of `K`-linear subspaces of `V`, rather than a predicate `IsSubmodule
    U` where `U` is an element of `Set V`. `Submodule K V` is endowed with a coercion
    to `Set V` and a membership predicate on `V`. See [Section 8.3](C08_Hierarchies.html#section-hierarchies-subobjects)
    for an explanation of how and why this is done.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，重要的是要理解 `Submodule K V` 是 `V` 的 `K`-线性子空间的类型，而不是一个 `IsSubmodule U` 的谓词，其中
    `U` 是 `Set V` 的一个元素。`Submodule K V` 被赋予了到 `Set V` 的强制转换和 `V` 上的成员谓词。有关如何以及为什么这样做，请参见
    [第 8.3 节](C08_Hierarchies.html#section-hierarchies-subobjects) 的解释。
- en: Of course, two subspaces are the same if and only if they have the same elements.
    This fact is registered for use with the `ext` tactic, which can be used to prove
    two subspaces are equal in the same way it is used to prove that two sets are
    equal.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果两个子空间具有相同的元素，则它们是相同的。这一事实被注册用于与 `ext` 策略一起使用，该策略可以用来证明两个子空间相等，就像它被用来证明两个集合相等一样。
- en: To state and prove, for example, that `ℝ` is a `ℝ`-linear subspace of `ℂ`, what
    we really want is to construct a term of type `Submodule ℝ ℂ` whose projection
    to `Set ℂ` is `ℝ`, or, more precisely, the image of `ℝ` in `ℂ`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了陈述和证明 `ℝ` 是 `ℂ` 的 `ℝ`-线性子空间，我们真正想要的是构造一个类型为 `Submodule ℝ ℂ` 的项，其投影到 `Set
    ℂ` 是 `ℝ`，或者更精确地说，是 `ℝ` 在 `ℂ` 中的像。
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The prime at the end of proof fields in `Submodule` are analogous to the one
    in `LinearMap`. Those fields are stated in terms of the `carrier` field because
    they are defined before the `MemberShip` instance. They are then superseded by
    `Submodule.add_mem`, `Submodule.zero_mem` and `Submodule.smul_mem` that we saw
    above.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Submodule` 中证明字段末尾的素数与 `LinearMap` 中的素数类似。这些字段是以 `carrier` 字段为依据声明的，因为它们是在
    `MemberShip` 实例之前定义的。然后，它们被上面提到的 `Submodule.add_mem`、`Submodule.zero_mem` 和 `Submodule.smul_mem`
    所取代。'
- en: As an exercise in manipulating subspaces and linear maps, you will define the
    pre-image of a subspace by a linear map (of course we will see below that Mathlib
    already knows about this). Remember that `Set.mem_preimage` can be used to rewrite
    a statement involving membership and preimage. This is the only lemma you will
    need in addition to the lemmas discussed above about `LinearMap` and `Submodule`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作子空间和线性映射的练习，你将定义由线性映射（当然，我们将在下面看到 Mathlib 已经知道这一点）生成的子空间的逆像。记住，可以使用 `Set.mem_preimage`
    重写涉及成员资格和逆像的陈述。这是除了上面讨论的关于 `LinearMap` 和 `Submodule` 的引理之外，你需要的唯一引理。
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using type classes, Mathlib knows that a subspace of a vector space inherits
    a vector space structure.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型类，Mathlib 知道向量空间的子空间继承了向量空间的结构。
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This example is subtle. The object `U` is not a type, but Lean automatically
    coerces it to a type by interpreting it as a subtype of `V`. So the above example
    can be restated more explicitly as:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很微妙。对象 `U` 不是一个类型，但 Lean 会自动将其解释为 `V` 的子类型，从而将其转换为类型。因此，上述例子可以更明确地表述为：
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 10.2.2\. Complete lattice structure and internal direct sums[](#complete-lattice-structure-and-internal-direct-sums
    "Link to this heading")
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2\. 完备格结构和内部直和[](#complete-lattice-structure-and-internal-direct-sums
    "链接到本标题")
- en: 'An important benefit of having a type `Submodule K V` instead of a predicate
    `IsSubmodule : Set V → Prop` is that one can easily endow `Submodule K V` with
    additional structure. Importantly, it has the structure of a complete lattice
    structure with respect to inclusion. For instance, instead of having a lemma stating
    that an intersection of two subspaces of `V` is again a subspace, we use the lattice
    operation `⊓` to construct the intersection. We can then apply arbitrary lemmas
    about lattices to the construction.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '拥有类型 `Submodule K V` 而不是谓词 `IsSubmodule : Set V → Prop` 的重要好处是，可以轻松地为 `Submodule
    K V` 赋予额外的结构。重要的是，它具有关于包含的完备格结构。例如，我们不是用一条定理来声明 `V` 的两个子空间的交集仍然是子空间，而是使用格运算 `⊓`
    来构造交集。然后我们可以将关于格的任意引理应用于构造。'
- en: Let us check that the set underlying the infimum of two subspaces is indeed,
    by definition, their intersection.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证两个子空间下确界的底层集合确实按照定义是它们的交集。
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It may look strange to have a different notation for what amounts to the intersection
    of the underlying sets, but the correspondence does not carry over to the supremum
    operation and set union, since a union of subspaces is not, in general, a subspace.
    Instead one needs to use the subspace generated by the union, which is done using
    `Submodule.span`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于底层集合的交集使用不同的符号可能看起来很奇怪，但这种对应关系并不适用于上确界运算和集合的并集，因为子空间的并集在一般情况下不是子空间。相反，需要使用由并集生成的子空间，这是通过
    `Submodule.span` 实现的。
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Another subtlety is that `V` itself does not have type `Submodule K V`, so
    we need a way to talk about `V` seen as a subspace of `V`. This is also provided
    by the lattice structure: the full subspace is the top element of this lattice.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个微妙之处在于，`V` 本身没有类型 `Submodule K V`，因此我们需要一种方式来谈论 `V` 作为 `V` 的子空间。这也由格结构提供：全子空间是这个格的顶元素。
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Similarly the bottom element of this lattice is the subspace whose only element
    is the zero element.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个格的底元素是只包含零元素的子空间。
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In particular we can discuss the case of subspaces that are in (internal) direct
    sum. In the case of two subspaces, we use the general purpose predicate `IsCompl`
    which makes sense for any bounded partially ordered type. In the case of general
    families of subspaces we use `DirectSum.IsInternal`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们可以讨论（内部）直和的子空间的情况。在两个子空间的情况下，我们使用适用于任何有界偏序类型的通用谓词 `IsCompl`。在一般子空间族的情况下，我们使用
    `DirectSum.IsInternal`。
- en: '[PRE22]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 10.2.3\. Subspace spanned by a set[](#subspace-spanned-by-a-set "Link to this
    heading")
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3\. 由一组生成的子空间[](#subspace-spanned-by-a-set "链接到本标题")
- en: In addition to building subspaces out of existing subspaces, we can build them
    out of any set `s` using `Submodule.span K s` which builds the smallest subspace
    containing `s`. On paper it is common to use that this space is made of all linear
    combinations of elements of `s`. But it is often more efficient to use its universal
    property expressed by `Submodule.span_le`, and the whole theory of Galois connections.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从现有子空间构建子空间之外，我们还可以使用 `Submodule.span K s` 从任何集合 `s` 中构建它们，该函数构建包含 `s` 的最小子空间。在纸上，通常使用这种空间由
    `s` 的所有线性组合元素构成。但通常更有效的是使用其通过 `Submodule.span_le` 表达的泛性质，以及伽罗瓦连接的整个理论。
- en: '[PRE23]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When those are not enough, one can use the relevant induction principle `Submodule.span_induction`
    which ensures a property holds for every element of the span of `s` as long as
    it holds on `zero` and elements of `s` and is stable under sum and scalar multiplication.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些还不够时，可以使用相关的归纳原理 `Submodule.span_induction`，该原理确保只要在 `zero` 和 `s` 的元素上成立，并且对加法和标量乘法稳定，那么
    `s` 的张量中的每个元素都保持该性质。
- en: As an exercise, let us reprove one implication of `Submodule.mem_sup`. Remember
    that you can use the module tactic to close goals that follow from the axioms
    relating the various algebraic operations on `V`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，让我们重新证明 `Submodule.mem_sup` 的一个蕴含。记住，你可以使用模块策略来关闭由与 `V` 上的各种代数操作相关的公理得出的目标。
- en: '[PRE24]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 10.2.4\. Pushing and pulling subspaces[](#pushing-and-pulling-subspaces "Link
    to this heading")
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4. 推拉子空间[](#pushing-and-pulling-subspaces "链接到这个标题")
- en: As promised earlier, we now describe how to push and pull subspaces by linear
    maps. As usual in Mathlib, the first operation is called `map` and the second
    one is called `comap`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们现在描述如何通过线性映射推拉子空间。在 Mathlib 中，第一个操作称为 `map`，第二个操作称为 `comap`。
- en: '[PRE25]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note those live in the `Submodule` namespace so one can use dot notation and
    write `E.map φ` instead of `Submodule.map φ E`, but this is pretty awkward to
    read (although some Mathlib contributors use this spelling).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这些位于 `Submodule` 命名空间中，因此可以使用点符号，并编写 `E.map φ` 而不是 `Submodule.map φ E`，但这很不容易阅读（尽管一些
    Mathlib 贡献者使用这种拼写）。
- en: In particular the range and kernel of a linear map are subspaces. Those special
    cases are important enough to get declarations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，线性映射的范围和核是子空间。这些特殊情况很重要，足以得到声明。
- en: '[PRE26]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that we cannot write `φ.ker` instead of `LinearMap.ker φ` because `LinearMap.ker`
    also applies to classes of maps preserving more structure, hence it does not expect
    an argument whose type starts with `LinearMap`, hence dot notation doesn’t work
    here. However we were able to use the other flavor of dot notation in the right-hand
    side. Because Lean expects a term with type `Submodule K V` after elaborating
    the left-hand side, it interprets `.comap` as `Submodule.comap`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不能写 `φ.ker` 而不是 `LinearMap.ker φ`，因为 `LinearMap.ker` 也适用于保持更多结构的映射类，因此它不期望一个以
    `LinearMap` 开头的类型的参数，因此点符号在这里不起作用。然而，我们能够在右侧使用另一种点符号。因为 Lean 在展开左侧后期望一个类型为 `Submodule
    K V` 的项，它将 `.comap` 解释为 `Submodule.comap`。
- en: The following lemmas give the key relations between those submodule and the
    properties of `φ`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下引理给出了这些子模块与 `φ` 的性质之间的关键关系。
- en: '[PRE27]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As an exercise, let us prove the Galois connection property for `map` and `comap`.
    One can use the following lemmas but this is not required since they are true
    by definition.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，让我们证明 `map` 和 `comap` 的伽罗瓦连接性质。可以使用以下引理，但这不是必需的，因为它们根据定义是正确的。
- en: '[PRE28]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 10.2.5\. Quotient spaces[](#quotient-spaces "Link to this heading")
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.5. 商空间[](#quotient-spaces "链接到这个标题")
- en: Quotient vector spaces use the general quotient notation (typed with `\quot`,
    not the ordinary `/`). The projection onto a quotient space is `Submodule.mkQ`
    and the universal property is `Submodule.liftQ`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 商向量空间使用通用商符号（使用 `\quot` 打印，而不是普通 `/`）。商空间的投影是 `Submodule.mkQ`，其泛性质是 `Submodule.liftQ`。
- en: '[PRE29]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As an exercise, let us prove the correspondence theorem for subspaces of quotient
    spaces. Mathlib knows a slightly more precise version as `Submodule.comapMkQRelIso`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，让我们证明商空间子空间的对应定理。Mathlib 知道一个稍微更精确的版本，称为 `Submodule.comapMkQRelIso`。
- en: '[PRE30]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 10.3\. Endomorphisms[](#endomorphisms "Link to this heading")
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3. 内射[](#endomorphisms "链接到这个标题")
- en: 'An important special case of linear maps are endomorphisms: linear maps from
    a vector space to itself. They are interesting because they form a `K`-algebra.
    In particular we can evaluate polynomials with coefficients in `K` on them, and
    they can have eigenvalues and eigenvectors.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 线性映射的一个重要特殊情况是内射映射：从向量空间到自身的线性映射。它们很有趣，因为它们构成一个`K`-代数。特别是，我们可以对它们上的系数在`K`中的多项式进行评估，并且它们可以有特征值和特征向量。
- en: Mathlib uses the abbreviation `Module.End K V := V →ₗ[K] V` which is convenient
    when using a lot of these (especially after opening the `Module` namespace).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib使用缩写`Module.End K V := V →ₗ[K] V`，这在使用大量此类映射时很方便（尤其是在打开`Module`命名空间之后）。
- en: '[PRE31]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As an exercise manipulating endomorphisms, subspaces and polynomials, let us
    prove the (binary) kernels lemma: for any endomorphism \(φ\) and any two relatively
    prime polynomials \(P\) and \(Q\), we have \(\ker P(φ) ⊕ \ker Q(φ) = \ker \big(PQ(φ)\big)\).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作内射映射、子空间和多项式的练习，让我们证明（二元的）核引理：对于任何内射映射\(φ\)和任何两个互质的二次多项式\(P\)和\(Q\)，我们有\(\ker
    P(φ) ⊕ \ker Q(φ) = \ker \big(PQ(φ)\big)\)。
- en: Note that `IsCoprime x y` is defined as `∃ a b, a * x + b * y = 1`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`IsCoprime x y`被定义为`∃ a b, a * x + b * y = 1`。
- en: '[PRE32]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We now move to the discussions of eigenspaces and eigenvalues. The eigenspace
    associated to an endomorphism \(φ\) and a scalar \(a\) is the kernel of \(φ -
    aId\). Eigenspaces are defined for all values of `a`, although they are interesting
    only when they are non-zero. However an eigenvector is, by definition, a non-zero
    element of an eigenspace. The corresponding predicate is `End.HasEigenvector`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在转向对特征空间和特征值的讨论。与内射映射\(φ\)和标量\(a\)相关的特征空间是\(φ - aId\)的核。特征空间对所有`a`的值都有定义，尽管它们只有在非零时才有趣。然而，根据定义，特征向量是特征空间中的非零元素。相应的谓词是`End.HasEigenvector`。
- en: '[PRE33]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Then there is a predicate `End.HasEigenvalue` and the corresponding subtype
    `End.Eigenvalues`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后有一个谓词`End.HasEigenvalue`和相应的子类型`End.Eigenvalues`。
- en: '[PRE34]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '## 10.4\. Matrices, bases and dimension[](#matrices-bases-and-dimension "Link
    to this heading")'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '## 10.4. 矩阵、基和维度[](#matrices-bases-and-dimension "链接到这个标题")'
- en: '### 10.4.1\. Matrices[](#matrices "Link to this heading")'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '### 10.4.1. 矩阵[](#matrices "链接到这个标题")'
- en: Before introducing bases for abstract vector spaces, we go back to the much
    more elementary setup of linear algebra in \(K^n\) for some field \(K\). Here
    the main objects are vectors and matrices. For concrete vectors, one can use the
    `![…]` notation, where components are separated by commas. For concrete matrices
    we can use the `!![…]` notation, lines are separated by semi-colons and components
    of lines are separated by colons. When entries have a computable type such as
    `ℕ` or `ℚ`, we can use the `eval` command to play with basic operations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍抽象向量空间的基之前，我们回到更基础的线性代数设置，即对于某个域\(K\)的\(K^n\)。在这里，主要对象是向量和矩阵。对于具体的向量，可以使用`![…]`表示法，其中分量由逗号分隔。对于具体的矩阵，我们可以使用`!![…]`表示法，行由分号分隔，行的分量由冒号分隔。当条目具有可计算的类型，如`ℕ`或`ℚ`时，我们可以使用`eval`命令进行基本操作。
- en: '[PRE35]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It is important to understand that this use of `#eval` is interesting only for
    exploration, it is not meant to replace a computer algebra system such as Sage.
    The data representation used here for matrices is *not* computationally efficient
    in any way. It uses functions instead of arrays and is optimized for proving,
    not computing. The virtual machine used by `#eval` is also not optimized for this
    use.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，这种`#eval`的使用仅对探索有意义，它并不打算取代Sage这样的计算机代数系统。这里用于矩阵的数据表示在计算上并不高效。它使用函数而不是数组，并且优化用于证明而不是计算。`#eval`使用的虚拟机也没有为此用途进行优化。
- en: Beware the matrix notation list rows but the vector notation is neither a row
    vector nor a column vector. Multiplication of a matrix with a vector from the
    left (resp. right) interprets the vector as a row (resp. column) vector. This
    corresponds to operations `Matrix.vecMul`, with notation `ᵥ*` and `Matrix.mulVec`,
    with notation ` *ᵥ`. Those notations are scoped in the `Matrix` namespace that
    we therefore need to open.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当心矩阵表示法列表行，但向量表示法既不是行向量也不是列向量。从左（分别）乘以矩阵的向量将向量解释为行（分别）向量。这对应于`Matrix.vecMul`操作，符号为`ᵥ*`，以及`Matrix.mulVec`操作，符号为`
    *ᵥ`。这些符号在`Matrix`命名空间中定义，因此我们需要打开该命名空间。
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In order to generate matrices with identical rows or columns specified by a
    vector, we use `Matrix.replicateRow` and `Matrix.replicateCol`, with arguments
    the type indexing the rows or columns and the vector. For instance one can get
    single row or single column matrixes (more precisely matrices whose rows or columns
    are indexed by `Fin 1`).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成具有由向量指定的相同行或列的矩阵，我们使用 `Matrix.replicateRow` 和 `Matrix.replicateCol`，其中参数是索引行或列的类型和向量。例如，可以得到单行或单列矩阵（更精确地说，行或列由
    `Fin 1` 索引的矩阵）。
- en: '[PRE37]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Other familiar operations include the vector dot product, matrix transpose,
    and, for square matrices, determinant and trace.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 其他熟悉的操作包括向量点积、矩阵转置，对于方阵，还有行列式和迹。
- en: '[PRE38]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When entries do not have a computable type, for instance if they are real numbers,
    we cannot hope that `#eval` can help. Also this kind of evaluation cannot be used
    in proofs without considerably expanding the trusted code base (i.e. the part
    of Lean that you need to trust when checking proofs).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当条目没有可计算的类型时，例如如果它们是实数，我们无法期望 `#eval` 能有所帮助。此外，这种评估不能在没有显著扩大可信代码库（即检查证明时需要信任的
    Lean 的部分）的情况下用于证明。
- en: So it is good to also use the `simp` and `norm_num` tactics in proofs, or their
    command counter-part for quick exploration.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在证明中也使用 `simp` 和 `norm_num` 策略，或者它们的命令对应物进行快速探索是很好的。
- en: '[PRE39]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The next important operation on square matrices is inversion. In the same way
    as division of numbers is always defined and returns the artificial value zero
    for division by zero, the inversion operation is defined on all matrices and returns
    the zero matrix for non-invertible matrices.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 方阵上的下一个重要操作是求逆。与数的除法总是定义并返回除以零的人工值零一样，求逆操作在所有矩阵上定义，并在不可逆矩阵上返回零矩阵。
- en: More precisely, there is general function `Ring.inverse` that does this in any
    ring, and, for any matrix `A`, `A⁻¹` is defined as `Ring.inverse A.det • A.adjugate`.
    According to Cramer’s rule, this is indeed the inverse of `A` when the determinant
    of `A` is not zero.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，存在一个通用的函数 `Ring.inverse`，它在任何环中执行此操作，并且对于任何矩阵 `A`，`A⁻¹` 被定义为 `Ring.inverse
    A.det • A.adjugate`。根据克莱姆法则，当 `A` 的行列式不为零时，这确实是 `A` 的逆。
- en: '[PRE40]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Of course this definition is really useful only for invertible matrices. There
    is a general type class `Invertible` that helps recording this. For instance,
    the `simp` call in the next example will use the `inv_mul_of_invertible` lemma
    which has an `Invertible` type-class assumption, so it will trigger only if this
    can be found by the type-class synthesis system. Here we make this fact available
    using a `have` statement.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个定义对于可逆矩阵来说非常有用。存在一个通用的类型类 `Invertible`，它有助于记录这一点。例如，下一个示例中的 `simp` 调用将使用具有
    `Invertible` 类型类假设的 `inv_mul_of_invertible` 公理，因此只有在类型类合成系统可以找到它时才会触发。在这里，我们使用
    `have` 语句使这一事实可用。
- en: '[PRE41]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this fully concrete case, we could also use the `norm_num` machinery, and
    `apply?` to find the final line:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个完全具体的情况下，我们也可以使用 `norm_num` 机制和 `apply?` 来找到最终的行：
- en: '[PRE42]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: All the concrete matrices above have their rows and columns indexed by `Fin
    n` for some `n` (not necessarily the same for rows and columns). But sometimes
    it is more convenient to index matrices using arbitrary finite types. For instance
    the adjacency matrix of a finite graph has rows and columns naturally indexed
    by the vertices of the graph.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的具体矩阵都有它们的行和列由 `Fin n` 索引，对于某个 `n`（行和列不一定相同）。但有时使用任意有限类型索引矩阵更方便。例如，有限图的邻接矩阵的行和列自然由图的顶点索引。
- en: In fact when simply wants to define matrices without defining any operation
    on them, finiteness of the indexing types are not even needed, and coefficients
    can have any type, without any algebraic structure. So Mathlib simply defines
    `Matrix m n α` to be `m → n → α` for any types `m`, `n` and `α`, and the matrices
    we have been using so far had types such as `Matrix (Fin 2) (Fin 2) ℝ`. Of course
    algebraic operations require more assumptions on `m`, `n` and `α`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当仅仅想要定义矩阵而不在它们上定义任何操作时，索引类型的有限性甚至都不需要，系数可以有任何类型，而不需要任何代数结构。因此，Mathlib 简单地将
    `Matrix m n α` 定义为 `m → n → α`，对于任何类型 `m`、`n` 和 `α`，而我们迄今为止所使用的矩阵类型如 `Matrix (Fin
    2) (Fin 2) ℝ`。当然，代数操作需要对 `m`、`n` 和 `α` 有更多的假设。
- en: Note the main reason why we do not use `m → n → α` directly is to allow the
    type class system to understand what we want. For instance, for a ring `R`, the
    type `n → R` is endowed with the point-wise multiplication operation, and similarly
    `m → n → R` has this operation which is *not* the multiplication we want on matrices.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们不直接使用`m → n → α`的主要原因是为了让类型类系统理解我们的意图。例如，对于一个环`R`，类型`n → R`被赋予了点乘操作，同样`m
    → n → R`也有这种操作，但这不是我们在矩阵上想要的乘法。
- en: In the first example below, we force Lean to see through the definition of `Matrix`
    and accept the statement as meaningful, and then prove it by checking all entries.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的第一个例子中，我们迫使Lean看穿`Matrix`的定义，并接受这个陈述是有意义的，然后通过检查所有项来证明它。
- en: But then the next two examples reveal that Lean uses the point-wise multiplication
    on `Fin 2 → Fin 2 → ℤ` but the matrix multiplication on `Matrix (Fin 2) (Fin 2)
    ℤ`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但接下来的两个例子揭示了Lean在`Fin 2 → Fin 2 → ℤ`上使用点乘，而在`Matrix (Fin 2) (Fin 2) ℤ`上使用矩阵乘法。
- en: '[PRE43]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In order to define matrices as functions without losing the benefits of `Matrix`
    for type class synthesis, we can use the equivalence `Matrix.of` between functions
    and matrices. This equivalence is secretly defined using `Equiv.refl`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将矩阵定义为函数而不失去`Matrix`在类型类合成中的优势，我们可以使用函数和矩阵之间的等价性`Matrix.of`。这种等价性实际上是通过`Equiv.refl`秘密定义的。
- en: For instance we can define Vandermonde matrices corresponding to a vector `v`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义与向量`v`对应的Vandermonde矩阵。
- en: '[PRE44]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 10.4.2\. Bases[](#bases "Link to this heading")
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2. 基[](#bases "链接到这个标题")
- en: We now want to discuss bases of vector spaces. Informally there are many ways
    to define this notion. One can use a universal property. One can say a basis is
    a family of vectors that is linearly independent and spanning. Or one can combine
    those properties and directly say that a basis is a family of vectors such that
    every vectors can be written uniquely as a linear combination of bases vectors.
    Yet another way to say it is that a basis provides a linear isomorphism with a
    power of the base field `K`, seen as a vector space over `K`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想讨论向量空间的基。非正式地说，有许多定义这种概念的方法。可以使用一个泛性质。可以说基是一组线性无关且张成的向量。或者可以将这些性质结合起来，直接说基是一组向量，每个向量都可以唯一地表示为基向量的线性组合。另一种说法是，基提供了一个与基域`K`的幂的线性同构，其中`K`被视为`K`上的向量空间。
- en: 'This isomorphism version is actually the one that Mathlib uses as a definition
    under the hood, and other characterizations are proven from it. One must be slightly
    careful with the “power of `K`” idea in the case of infinite bases. Indeed only
    finite linear combinations make sense in this algebraic context. So what we need
    as a reference vector space is not a direct product of copies of `K` but a direct
    sum. We could use `⨁ i : ι, K` for some type `ι` indexing the basis But we rather
    use the more specialized spelling `ι →₀ K` which means “functions from `ι` to
    `K` with finite support”, i.e. functions which vanish outside a finite set in
    `ι` (this finite set is not fixed, it depends on the function). Evaluating such
    a function coming from a basis `B` at a vector `v` and `i : ι` returns the component
    (or coordinate) of `v` on the `i`-th basis vector.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '这个同构版本实际上是Mathlib在底层用作定义的版本，其他特征化都是从这个证明的。在无限基的情况下，必须对“`K`的幂”这个想法稍加小心。确实，在这个代数背景下，只有有限线性组合才有意义。因此，作为参考向量空间，我们需要的不是`K`的副本的直接积，而是一个直接和。我们可以使用`⨁
    i : ι, K`对于某些索引基的类型`ι`，但我们更倾向于使用更专业的拼写`ι →₀ K`，这意味着“从`ι`到`K`的有限支持函数”，即函数在`ι`的有限集合外为零（这个有限集合不是固定的，它依赖于函数）。将来自基`B`的这样一个函数在向量`v`和`ι`上求值，返回`v`在`ι`-th基向量上的分量（或坐标）。'
- en: The type of bases indexed by a type `ι` of `V` as a `K` vector space is `Basis
    ι K V`. The isomorphism is called `Basis.repr`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由`V`中类型`ι`的`K`向量空间基的索引类型是`Basis ι K V`。这种同构称为`Basis.repr`。
- en: '[PRE45]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Instead of starting with such an isomorphism, one can start with a family `b`
    of vectors that is linearly independent and spanning, this is `Basis.mk`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是从一个这样的同构开始，可以开始于一个线性无关且张成的向量族`b`，这是`Basis.mk`。
- en: The assumption that the family is spanning is spelled out as `⊤ ≤ Submodule.span
    K (Set.range b)`. Here `⊤` is the top submodule of `V`, i.e. `V` seen as submodule
    of itself. This spelling looks a bit tortuous, but we will see below that it is
    almost equivalent by definition to the more readable `∀ v, v ∈ Submodule.span
    K (Set.range b)` (the underscores in the snippet below refers to the useless information
    `v ∈ ⊤`).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设家庭是跨越的，这一假设被表述为 `⊤ ≤ Submodule.span K (Set.range b)`。这里的 `⊤` 是 `V` 的上子模块，即
    `V` 作为自身的子模块来看待。这种表述看起来有点复杂，但下面我们将看到，它几乎在定义上等同于更易读的 `∀ v, v ∈ Submodule.span K
    (Set.range b)`（下面片段中的下划线指的是无用的信息 `v ∈ ⊤`）。
- en: '[PRE46]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In particular the model vector space `ι →₀ K` has a so-called canonical basis
    whose `repr` function evaluated on any vector is the identity isomorphism. It
    is called `Finsupp.basisSingleOne` where `Finsupp` means function with finite
    support and `basisSingleOne` refers to the fact that basis vectors are functions
    which vanish expect for a single input value. More precisely the basis vector
    indexed by `i : ι` is `Finsupp.single i 1` which is the finitely supported function
    taking value `1` at `i` and `0` everywhere else.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '尤其是模型向量空间 `ι →₀ K` 有一个所谓的规范基，其 `repr` 函数在任意向量上的评估是恒等同构。它被称为 `Finsupp.basisSingleOne`，其中
    `Finsupp` 表示有限支撑的函数，而 `basisSingleOne` 指的是基向量是除了单个输入值外其他地方都为零的函数。更精确地说，由 `i :
    ι` 索引的基向量是 `Finsupp.single i 1`，这是一个有限支撑的函数，在 `i` 处取值为 `1`，在其他地方取值为 `0`。'
- en: '[PRE47]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The story of finitely supported functions is unneeded when the indexing type
    is finite. In this case we can use the simpler `Pi.basisFun` which gives a basis
    of the whole `ι → K`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当索引类型是有限的时候，有限支撑函数的故事是不必要的。在这种情况下，我们可以使用更简单的 `Pi.basisFun`，它给出了整个 `ι → K` 的基。
- en: '[PRE49]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Going back to the general case of bases of abstract vector spaces, we can express
    any vector as a linear combination of basis vectors. Let us first see the easy
    case of finite bases.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 回到抽象向量空间基的一般情况，我们可以将任何向量表示为基向量的线性组合。让我们先看看有限基的简单情况。
- en: '[PRE50]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When `ι` is not finite, the above statement makes no sense a priori: we cannot
    take a sum over `ι`. However the support of the function being summed is finite
    (it is the support of `B.repr v`). But we need to apply a construction that takes
    this into account. Here Mathlib uses a special purpose function that requires
    some time to get used to: `Finsupp.linearCombination` (which is built on top of
    the more general `Finsupp.sum`). Given a finitely supported function `c` from
    a type `ι` to the base field `K` and any function `f` from `ι` to `V`, `Finsupp.linearCombination
    K f c` is the sum over the support of `c` of the scalar multiplication `c • f`.
    In particular, we can replace it by a sum over any finite set containing the support
    of `c`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `ι` 不是有限时，上述陈述在先验上没有意义：我们不能在 `ι` 上取和。然而，被求和的函数的支撑是有限的（它是 `B.repr v` 的支撑）。但是我们需要应用一个考虑到这一点的构造。在这里，Mathlib
    使用了一个特殊目的的函数，需要一些时间来习惯：`Finsupp.linearCombination`（它是建立在更一般的 `Finsupp.sum` 之上的）。给定一个有限支撑的函数
    `c` 从类型 `ι` 到基域 `K` 以及任何从 `ι` 到 `V` 的函数 `f`，`Finsupp.linearCombination K f c`
    是 `c` 的支撑上的标量乘积 `c • f` 的和。特别是，我们可以将其替换为包含 `c` 的支撑的任何有限集上的和。
- en: '[PRE51]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: One could also assume that `f` is finitely supported and still get a well defined
    sum. But the choice made by `Finsupp.linearCombination` is the one relevant to
    our basis discussion since it allows to state the generalization of `Basis.sum_repr`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以假设 `f` 是有限支撑的，并且仍然可以得到一个定义良好的和。但是 `Finsupp.linearCombination` 所做的选择与我们的基讨论相关，因为它允许我们陈述
    `Basis.sum_repr` 的一般化。
- en: '[PRE52]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: One could wonder why `K` is an explicit argument here, despite the fact it can
    be inferred from the type of `c`. The point is that the partially applied `Finsupp.linearCombination
    K f` is interesting in itself. It is not a bare function from `ι →₀ K` to `V`
    but a `K`-linear map.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人可能会想知道为什么 `K` 在这里是一个显式的参数，尽管它可以从 `c` 的类型中推断出来。关键是部分应用 `Finsupp.linearCombination
    K f` 本身是有趣的。它不是一个从 `ι →₀ K` 到 `V` 的裸函数，而是一个 `K`-线性映射。
- en: '[PRE53]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Returning to the mathematical discussion, it is important to understand that
    the representation of vectors in a basis is less useful in formalized mathematics
    than you may think. Indeed it is very often more efficient to directly use more
    abstract properties of bases. In particular the universal property of bases connecting
    them to other free objects in algebra allows to construct linear maps by specifying
    the images of basis vectors. This is `Basis.constr`. For any `K`-vector space
    `W`, our basis `B` gives a linear isomorphism `Basis.constr B K` from `ι → W`
    to `V →ₗ[K] W`. This isomorphism is characterized by the fact that it sends any
    function `u : ι → W` to a linear map sending the basis vector `B i` to `u i`,
    for every `i : ι`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '回到数学讨论，重要的是要理解，在形式化数学中，基中向量的表示可能没有你想象的那么有用。事实上，直接使用基的更抽象性质通常更有效。特别是，基的普遍性质将它们与其他代数中的自由对象连接起来，允许通过指定基向量的像来构造线性映射。这是
    `Basis.constr`。对于任何 `K`-向量空间 `W`，我们的基 `B` 给出一个线性同构 `Basis.constr B K`，从 `ι → W`
    到 `V →ₗ[K] W`。这个同构的特点是它将任何函数 `u : ι → W` 映射到一个线性映射，该映射将基向量 `B i` 映射到 `u i`，对于每个
    `i : ι`。'
- en: '[PRE54]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This property is indeed characteristic because linear maps are determined by
    their values on bases:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性确实是特征性的，因为线性映射由它们在基上的值确定：
- en: '[PRE55]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If we also have a basis `B'` on the target space then we can identify linear
    maps with matrices. This identification is a `K`-linear isomorphism.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在目标空间上也有一个基 `B'`，那么我们可以将线性映射与矩阵相识别。这种识别是一个 `K`-线性同构。
- en: '[PRE56]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As an exercise on this topic, we will prove part of the theorem which guarantees
    that endomorphisms have a well-defined determinant. Namely we want to prove that
    when two bases are indexed by the same type, the matrices they attach to any endomorphism
    have the same determinant. This would then need to be complemented using that
    bases all have isomorphic indexing types to get the full result.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个主题的练习，我们将证明定理的一部分，该定理保证了内射有明确定义的行列式。具体来说，我们想要证明当两个基由相同的类型索引时，它们附加到任何内射上的矩阵具有相同的行列式。然后需要使用这些基都具有同构的索引类型来补充，以得到完整的结果。
- en: Of course Mathlib already knows this, and `simp` can close the goal immediately,
    so you shouldn’t use it too soon, but rather use the provided lemmas.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Mathlib 已经知道这一点，`simp` 可以立即关闭目标，所以你不应该太早使用它，而应该使用提供的引理。
- en: '[PRE57]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 10.4.3\. Dimension[](#dimension "Link to this heading")
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3\. 维度[](#dimension "链接到这个标题")
- en: Returning to the case of a single vector space, bases are also useful to define
    the concept of dimension. Here again, there is the elementary case of finite-dimensional
    vector spaces. For such spaces we expect a dimension which is a natural number.
    This is `Module.finrank`. It takes the base field as an explicit argument since
    a given abelian group can be a vector space over different fields.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 回到单个向量空间的情况，基也有助于定义维度的概念。在这里，也有有限维向量空间的基本情况。对于这样的空间，我们期望维度是一个自然数。这是 `Module.finrank`。它将基域作为显式参数，因为给定的阿贝尔群可以是在不同域上的向量空间。
- en: '[PRE58]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that `Module.finrank` is defined for any vector space. It returns zero
    for infinite dimensional vector spaces, just as division by zero returns zero.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Module.finrank` 定义适用于任何向量空间。对于无限维向量空间，它返回零，就像除以零返回零一样。
- en: Of course many lemmas require a finite dimension assumption. This is the role
    of the `FiniteDimensional` typeclass. For instance, think about how the next example
    fails without this assumption.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，许多引理需要有限维度的假设。这就是 `FiniteDimensional` 类型类的作用。例如，考虑如果没有这个假设，下一个例子会如何失败。
- en: '[PRE59]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the above statement, `Nontrivial V` means `V` has at least two different
    elements. Note that `Module.finrank_pos_iff` has no explicit argument. This is
    fine when using it from left to right, but not when using it from right to left
    because Lean has no way to guess `K` from the statement `Nontrivial V`. In that
    case it is useful to use the name argument syntax, after checking that the lemma
    is stated over a ring named `R`. So we can write:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述陈述中，`Nontrivial V` 表示 `V` 至少有两个不同的元素。注意，`Module.finrank_pos_iff` 没有显式的参数。当从左到右使用它时这是可以的，但不是从右到左使用时，因为
    Lean 没有从陈述 `Nontrivial V` 中猜测 `K` 的方法。在这种情况下，使用名称参数语法是有用的，在检查引理是在名为 `R` 的环上陈述之后。因此，我们可以写出：
- en: '[PRE60]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The above spelling is strange because we already have `h` as an assumption,
    so we could just as well give the full proof `Module.finrank_pos_iff.1 h` but
    it is good to know for more complicated cases.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上述拼写很奇怪，因为我们已经有了 `h` 作为假设，所以我们完全可以给出完整的证明 `Module.finrank_pos_iff.1 h`，但对于更复杂的情况来说，了解这一点是好的。
- en: By definition, `FiniteDimensional K V` can be read from any basis.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，`有限维 K V` 可以从任何基中读取。
- en: '[PRE61]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Using that the subtype corresponding to a linear subspace has a vector space
    structure, we can talk about the dimension of a subspace.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 利用对应于线性子空间的子类型具有向量空间结构，我们可以讨论子空间的维度。
- en: '[PRE62]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the first statement above, the purpose of the type ascriptions is to make
    sure that coercion to `Type*` does not trigger too early.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述第一个陈述中，类型赋值的目的是确保将 `Type*` 的强制转换不会触发得太早。
- en: We are now ready for an exercise about `finrank` and subspaces.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以准备一个关于 `finrank` 和子空间的练习。
- en: '[PRE63]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Let us now move to the general case of dimension theory. In this case `finrank`
    is useless, but we still have that, for any two bases of the same vector space,
    there is a bijection between the types indexing those bases. So we can still hope
    to define the rank as a cardinal, i.e. an element of the “quotient of the collection
    of types under the existence of a bijection equivalence relation”.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在转向维度理论的通用情况。在这种情况下，`finrank` 是无用的，但我们仍然有，对于任何两个相同向量空间的基，它们之间的类型存在双射。因此，我们仍然可以希望将秩定义为基数，即“存在双射等价关系下类型集合的商”中的一个元素。
- en: When discussing cardinal, it gets harder to ignore foundational issues around
    Russel’s paradox like we do everywhere else in this book. There is no type of
    all types because it would lead to logical inconsistencies. This issue is solved
    by the hierarchy of universes that we usually try to ignore.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论基数时，就像在这本书的其他地方一样，很难忽视围绕罗素悖论的基础性问题。没有所有类型的类型，因为这会导致逻辑上的不一致。这个问题通过我们通常试图忽略的宇宙层次结构得到解决。
- en: Each type has a universe level, and those levels behave similarly to natural
    numbers. In particular there is zeroth level, and the corresponding universe `Type
    0` is simply denoted by `Type`. This universe is enough to hold almost all of
    classical mathematics. For instance `ℕ` and `ℝ` have type `Type`. Each level `u`
    has a successor denoted by `u + 1`, and `Type u` has type `Type (u+1)`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型都有一个宇宙级别，这些级别的行为类似于自然数。特别是存在零级，相应的宇宙 `Type 0` 简单地表示为 `Type`。这个宇宙足以容纳几乎所有经典数学。例如
    `ℕ` 和 `ℝ` 有类型 `Type`。每个级别 `u` 有一个后继者，表示为 `u + 1`，并且 `Type u` 有类型 `Type (u+1)`。
- en: But universe levels are not natural numbers, they have a really different nature
    and don’t have a type. In particular you cannot state in Lean something like `u
    ≠ u + 1`. There is simply no type where this would take place. Even stating `Type
    u ≠ Type (u+1)` does not make any sense since `Type u` and `Type (u+1)` have different
    types.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但宇宙级别不是自然数，它们具有非常不同的性质，并且没有类型。特别是你无法在 Lean 中陈述类似于 `u ≠ u + 1` 的内容。根本不存在这样的类型。甚至陈述
    `Type u ≠ Type (u+1)` 也没有任何意义，因为 `Type u` 和 `Type (u+1)` 具有不同的类型。
- en: Whenever we write `Type*`, Lean inserts a universe level variable named `u_n`
    where `n` is a number. This allows definitions and statements to live in all universes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们书写 `Type*` 时，Lean 会插入一个名为 `u_n` 的宇宙级别变量，其中 `n` 是一个数字。这允许定义和陈述存在于所有宇宙中。
- en: 'Given a universe level `u`, we can define an equivalence relation on `Type
    u` saying two types `α` and `β` are equivalent if there is a bijection between
    them. The quotient type `Cardinal.{u}` lives in `Type (u+1)`. The curly braces
    denote a universe variable. The image of `α : Type u` in this quotient is `Cardinal.mk
    α : Cardinal.{u}`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个宇宙级别 `u`，我们可以在 `Type u` 上定义一个等价关系，即如果两个类型 `α` 和 `β` 之间存在双射，则这两个类型 `α` 和
    `β` 是等价的。商类型 `Cardinal.{u}` 位于 `Type (u+1)` 中。大括号表示一个宇宙变量。在这个商类型中，`α : Type u`
    的像为 `Cardinal.mk α : Cardinal.{u}`。'
- en: But we cannot directly compare cardinals in different universes. So technically
    we cannot define the rank of a vector space `V` as the cardinal of all types indexing
    a basis of `V`. So instead it is defined as the supremum `Module.rank K V` of
    cardinals of all linearly independent sets in `V`. If `V` has universe level `u`
    then its rank has type `Cardinal.{u}`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们无法直接比较不同宇宙中的基数。因此，技术上我们无法将向量空间 `V` 的秩定义为索引 `V` 的基的所有类型的基数。因此，它被定义为 `V` 中所有线性无关集的基数
    `Module.rank K V` 的上确界。如果 `V` 的宇宙级别为 `u`，则其秩的类型为 `Cardinal.{u}`。
- en: '[PRE64]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'One can still relate this definition to bases. Indeed there is also a commutative
    `max` operation on universe levels, and given two universe levels `u` and `v`
    there is an operation `Cardinal.lift.{u, v} : Cardinal.{v} → Cardinal.{max v u}`
    that allows to put cardinals in a common universe and state the dimension theorem.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管如此，我们仍然可以将这个定义与基联系起来。事实上，在宇宙级别上也有一个交换的 `max` 操作，并且对于两个宇宙级别 `u` 和 `v`，存在一个操作
    `Cardinal.lift.{u, v} : Cardinal.{v} → Cardinal.{max v u}`，它允许将基数放入一个共同的宇宙，并陈述维度定理。'
- en: '[PRE65]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We can relate the finite dimensional case to this discussion using the coercion
    from natural numbers to finite cardinals (or more precisely the finite cardinals
    which live in `Cardinal.{v}` where `v` is the universe level of `V`).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用自然数到有限基数（或更精确地说，生活在 `Cardinal.{v}` 中的有限基数，其中 `v` 是 `V` 的宇宙级别）的强制转换将有限维情况与这次讨论联系起来。
- en: '[PRE66] [Previous](C09_Groups_and_Rings.html "9\. Groups and Rings") [Next](C11_Topology.html
    "11\. Topology")'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE66] [上一节](C09_Groups_and_Rings.html "9. 群和环") [下一节](C11_Topology.html "11.
    拓扑")'
- en: '* * *'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: © Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: © 版权所有 2020-2025，Jeremy Avigad，Patrick Massot。文本许可协议为 CC BY 4.0。
- en: 'Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). ## 10.1\. Vector spaces
    and linear maps[](#vector-spaces-and-linear-maps "Link to this heading")'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [Sphinx](https://www.sphinx-doc.org/) 和由 [Read the Docs](https://readthedocs.org)
    提供的 [主题](https://github.com/readthedocs/sphinx_rtd_theme) 构建。## 10.1. 向量空间和线性映射[](#vector-spaces-and-linear-maps
    "链接到这个标题")
- en: 10.1.1\. Vector spaces[](#vector-spaces "Link to this heading")
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1. 向量空间[](#vector-spaces "链接到这个标题")
- en: We will start directly abstract linear algebra, taking place in a vector space
    over any field. However you can find information about matrices in [Section 10.4.1](#matrices)
    which does not logically depend on this abstract theory. Mathlib actually deals
    with a more general version of linear algebra involving the word module, but for
    now we will pretend this is only an eccentric spelling habit.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接从抽象线性代数开始，它发生在任何域上的向量空间中。然而，你可以在[第10.4.1节](#matrices)中找到有关矩阵的信息，这部分内容与抽象理论没有逻辑上的依赖。Mathlib
    实际上处理的是一个更通用的线性代数版本，涉及“模块”一词，但到目前为止，我们将假装这只是一个古怪的拼写习惯。
- en: 'The way to say “let \(K\) be a field and let \(V\) be a vector space over \(K\)”
    (and make them implicit arguments to later results) is:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 表达“设 \(K\) 为一个域，\(V\) 为 \(K\) 上的向量空间”（并将它们作为后续结果的隐含参数）的方式是：
- en: '[PRE67]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We explained in [Chapter 8](C08_Hierarchies.html#hierarchies) why we need two
    separate typeclasses `[AddCommGroup V] [Module K V]`. The short version is the
    following. Mathematically we want to say that having a \(K\)-vector space structure
    implies having an additive commutative group structure. We could tell this to
    Lean. But then whenever Lean would need to find such a group structure on a type
    \(V\), it would go hunting for vector space structures using a *completely unspecified*
    field \(K\) that cannot be inferred from \(V\). This would be very bad for the
    type class synthesis system.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第8章](C08_Hierarchies.html#hierarchies)中解释了为什么我们需要两个独立的类型类 `[AddCommGroup
    V] [Module K V]`。简而言之，从数学上讲，我们想要表达拥有 \(K\) 向量空间结构意味着拥有加法交换群结构。我们可以告诉 Lean。但这样一来，每当
    Lean 需要在类型 \(V\) 上找到这样的群结构时，它就会使用一个*完全未指定的*域 \(K\) 来寻找向量空间结构，而这个 \(K\) 无法从 \(V\)
    中推断出来。这对类型类综合系统来说是非常糟糕的。
- en: The multiplication of a vector v by a scalar a is denoted by a • v. We list
    a couple of algebraic rules about the interaction of this operation with addition
    in the following examples. Of course simp or apply? would find those proofs. There
    is also a module tactic that solves goals following from the axioms of vector
    spaces and fields, in the same way the ring tactic is used in commutative rings
    or the group tactic is used in groups. But it is still useful to remember that
    scalar multiplication is abbreviated smul in lemma names.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 \(v\) 与标量 \(a\) 的乘积表示为 a • v。我们在以下示例中列出了一些关于此操作与加法交互的代数规则。当然，simp 或 apply?
    会找到这些证明。还有一个模块策略，它解决从向量空间和域的公理中得出的目标，就像在交换环中使用 ring 策略或在群中使用 group 策略一样。但仍然有用的是记住标量乘法在引理名称中简写为
    smul。
- en: '[PRE68]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As a quick note for more advanced readers, let us point out that, as suggested
    by terminology, Mathlib’s linear algebra also covers modules over (not necessarily
    commutative) rings. In fact it even covers semi-modules over semi-rings. If you
    think you do not need this level of generality, you can meditate the following
    example that nicely captures a lot of algebraic rules about ideals acting on submodules:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对更高级读者的快速提示，让我们指出，正如术语所暗示的，Mathlib 的线性代数也涵盖了（不一定交换的）环上的模。实际上，它甚至涵盖了半环上的半模。如果你认为你不需要这种程度的普遍性，你可以冥想以下示例，它很好地捕捉了关于理想在子模上作用的许多代数规则：
- en: '[PRE69]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 10.1.2\. Linear maps[](#linear-maps "Link to this heading")
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2\. 线性映射[](#linear-maps "链接到这个标题")
- en: Next we need linear maps. Like group morphisms, linear maps in Mathlib are bundled
    maps, i.e. packages made of a map and proofs of its linearity properties. Those
    bundled maps are converted to ordinary functions when applied. See [Chapter 8](C08_Hierarchies.html#hierarchies)
    for more information about this design.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要线性映射。像群同态一样，Mathlib 中的线性映射是捆绑映射，即由映射及其线性性质证明组成的包。这些捆绑映射在应用时被转换为普通函数。有关此设计的更多信息，请参阅
    [第 8 章](C08_Hierarchies.html#hierarchies)。
- en: The type of linear maps between two `K`-vector spaces `V` and `W` is denoted
    by `V →ₗ[K] W`. The subscript l stands for linear. At first it may feel odd to
    specify `K` in this notation. But this is crucial when several fields come into
    play. For instance real-linear maps from \(ℂ\) to \(ℂ\) are every map \(z ↦ az
    + b\bar{z}\) while only the maps \(z ↦ az\) are complex linear, and this difference
    is crucial in complex analysis.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `K`-向量空间 `V` 和 `W` 之间线性映射的类型表示为 `V →ₗ[K] W`。下标 l 代表线性。一开始可能觉得在这个符号中指定 `K`
    很奇怪。但这是几个领域同时存在时的关键。例如，从 \(ℂ\) 到 \(ℂ\) 的实线性映射是每个映射 \(z ↦ az + b\bar{z}\)，而只有映射
    \(z ↦ az\) 是复线性，这种差异在复分析中至关重要。
- en: '[PRE70]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note that `V →ₗ[K] W` itself carries interesting algebraic structures (this
    is part of the motivation for bundling those maps). It is a `K`-vector space so
    we can add linear maps and multiply them by scalars.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`V →ₗ[K] W` 本身就带有有趣的代数结构（这是捆绑那些映射的部分动机）。它是一个 `K`-向量空间，因此我们可以添加线性映射并乘以标量。
- en: '[PRE71]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: One downside of using bundled maps is that we cannot use ordinary function composition.
    We need to use `LinearMap.comp` or the notation `∘ₗ`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用捆绑映射的一个缺点是我们不能使用普通函数组合。我们需要使用 `LinearMap.comp` 或 `∘ₗ` 的符号。
- en: '[PRE72]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'There are two main ways to construct linear maps. First we can build the structure
    by providing the function and the linearity proof. As usual, this is facilitated
    by the structure code action: you can type `example : V →ₗ[K] V := _` and use
    the code action “Generate a skeleton” attached to the underscore.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '构造线性映射有两种主要方式。首先，我们可以通过提供函数和线性证明来构建结构。像往常一样，这是通过结构代码操作实现的：你可以输入 `example :
    V →ₗ[K] V := _` 并使用附加到下划线的“生成骨架”代码操作。'
- en: '[PRE73]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You may wonder why the proof fields of `LinearMap` have names ending with a
    prime. This is because they are defined before the coercion to functions is defined,
    hence they are phrased in terms of `LinearMap.toFun`. Then they are restated as
    `LinearMap.map_add` and `LinearMap.map_smul` in terms of the coercion to function.
    This is not yet the end of the story. One also wants a version of `map_add` that
    applies to any (bundled) map preserving addition, such as additive group morphisms,
    linear maps, continuous linear maps, `K`-algebra maps etc… This one is `map_add`
    (in the root namespace). The intermediate version, `LinearMap.map_add` is a bit
    redundant but allows to use dot notation, which can be nice sometimes. A similar
    story exists for `map_smul`, and the general framework is explained in [Chapter
    8](C08_Hierarchies.html#hierarchies).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么 `LinearMap` 的证明字段以撇号结尾。这是因为它们在定义函数强制转换之前就已经定义了，因此它们是用 `LinearMap.toFun`
    表述的。然后它们被重新表述为 `LinearMap.map_add` 和 `LinearMap.map_smul`，以函数强制转换的形式。但这还不是故事的结尾。人们还想要一个适用于任何（捆绑的）保持加法的映射的
    `map_add` 版本，例如加法群同态、线性映射、连续线性映射、`K`-代数映射等。这个版本是 `map_add`（在根命名空间中）。中间版本 `LinearMap.map_add`
    有点冗余，但允许使用点符号，这在某些时候可能很方便。对于 `map_smul` 也有类似的故事，一般框架在 [第 8 章](C08_Hierarchies.html#hierarchies)
    中解释。
- en: '[PRE74]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'One can also build linear maps from the ones that are already defined in Mathlib
    using various combinators. For instance the above example is already known as
    `LinearMap.lsmul K V 3`. There are several reason why `K` and `V` are explicit
    arguments here. The most pressing one is that from a bare `LinearMap.lsmul 3`
    there would be no way for Lean to infer `V` or even `K`. But also `LinearMap.lsmul
    K V` is an interesting object by itself: it has type `K →ₗ[K] V →ₗ[K] V`, meaning
    it is a `K`-linear map from `K` —seen as a vector space over itself— to the space
    of `K`-linear maps from `V` to `V`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用各种组合子从 Mathlib 中已定义的线性映射中构建线性映射。例如，上面的例子已经知道为 `LinearMap.lsmul K V 3`。`K`
    和 `V` 在这里作为显式参数有几个原因。最紧迫的一个原因是，从裸的 `LinearMap.lsmul 3` 中，Lean 无法推断出 `V` 或甚至 `K`。但
    `LinearMap.lsmul K V` 本身也是一个有趣的对象：它具有类型 `K →ₗ[K] V →ₗ[K] V`，这意味着它是一个从 `K`（被视为自身的向量空间）到
    `V` 到 `V` 的 `K`-线性映射。
- en: '[PRE75]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'There is also a type `LinearEquiv` of linear isomorphisms denoted by `V ≃ₗ[K]
    W`. The inverse of `f : V ≃ₗ[K] W` is `f.symm : W ≃ₗ[K] V`, composition of `f`
    and `g` is `f.trans g` also denoted by `f ≪≫ₗ g`, and the identity isomorphism
    of `V` is `LinearEquiv.refl K V`. Elements of this type are automatically coerced
    to morphisms and functions when necessary.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '还有表示为 `V ≃ₗ[K] W` 的线性同构类型 `LinearEquiv`。`f : V ≃ₗ[K] W` 的逆是 `f.symm : W ≃ₗ[K]
    V`，`f` 和 `g` 的组合是 `f.trans g`，也记作 `f ≪≫ₗ g`，恒等同构是 `V` 的 `LinearEquiv.refl K V`。此类型中的元素在必要时自动转换为形态和函数。'
- en: '[PRE76]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: One can use `LinearEquiv.ofBijective` to build an isomorphism from a bijective
    morphism. Doing so makes the inverse function noncomputable.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `LinearEquiv.ofBijective` 从双射形态构建同构。这样做会使逆函数不可计算。
- en: '[PRE77]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that in the above example, Lean uses the announced type to understand that
    `.ofBijective` refers to `LinearEquiv.ofBijective` (without needing to open any
    namespace).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上面的例子中，Lean 使用宣布的类型来理解 `.ofBijective` 指的是 `LinearEquiv.ofBijective`（无需打开任何命名空间）。
- en: 10.1.3\. Sums and products of vector spaces[](#sums-and-products-of-vector-spaces
    "Link to this heading")
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3. 向量空间的和与积[](#sums-and-products-of-vector-spaces "链接到本标题")
- en: We can build new vector spaces out of old ones using direct sums and direct
    products. Let us start with two vectors spaces. In this case there is no difference
    between sum and product, and we can simply use the product type. In the following
    snippet of code we simply show how to get all the structure maps (inclusions and
    projections) as linear maps, as well as the universal properties constructing
    linear maps into products and out of sums (if you are not familiar with the category-theoretic
    distinction between sums and products, you can simply ignore the universal property
    vocabulary and focus on the types of the following examples).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用直接和和直接积从旧的向量空间中构建新的向量空间。让我们从两个向量空间开始。在这种情况下，和与积之间没有区别，我们可以简单地使用积类型。在下面的代码片段中，我们简单地展示了如何将所有结构映射（包含和投射）作为线性映射来获取，以及构建线性映射到积和从和中构造的通用性质（如果你不熟悉加法和积之间的范畴论区别，你可以简单地忽略通用性质词汇，并关注以下示例的类型）。
- en: '[PRE78]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Let us now turn to sums and products of arbitrary families of vector spaces.
    Here we will simply see how to define a family of vector spaces and access the
    universal properties of sums and products. Note that the direct sum notation is
    scoped to the `DirectSum` namespace, and that the universal property of direct
    sums requires decidable equality on the indexing type (this is somehow an implementation
    accident).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向任意向量空间族的和与积。在这里，我们将简单地看到如何定义一个向量空间族并访问和与积的通用性质。请注意，直接和的符号范围限定在 `DirectSum`
    命名空间中，并且直接和的通用性质要求索引类型上的可判定等价性（这某种程度上是一个实现上的意外）。
- en: '[PRE79]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '## 10.2\. Subspaces and quotients[](#subspaces-and-quotients "Link to this
    heading")'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '## 10.2. 子空间和商[](#subspaces-and-quotients "链接到本标题")'
- en: 10.2.1\. Subspaces[](#subspaces "Link to this heading")
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1. 子空间[](#subspaces "链接到本标题")
- en: Just as linear maps are bundled, a linear subspace of `V` is also a bundled
    structure consisting of a set in `V`, called the carrier of the subspace, with
    the relevant closure properties. Again the word module appears instead of vector
    space because of the more general context that Mathlib actually uses for linear
    algebra.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如线性映射是捆绑在一起的，`V` 的线性子空间也是一个由 `V` 中的集合组成的捆绑结构，称为子空间的载体，并具有相关的闭包性质。由于 Mathlib
    实际上用于线性代数的更一般上下文，所以这里出现的是“模块”一词而不是向量空间。
- en: '[PRE80]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In the example above, it is important to understand that `Submodule K V` is
    the type of `K`-linear subspaces of `V`, rather than a predicate `IsSubmodule
    U` where `U` is an element of `Set V`. `Submodule K V` is endowed with a coercion
    to `Set V` and a membership predicate on `V`. See [Section 8.3](C08_Hierarchies.html#section-hierarchies-subobjects)
    for an explanation of how and why this is done.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，重要的是要理解`Submodule K V`是`V`的`K`-线性子空间类型，而不是一个`IsSubmodule U`谓词，其中`U`是`Set
    V`的元素。`Submodule K V`被赋予了到`Set V`的转换和`V`上的成员谓词。参见[第8.3节](C08_Hierarchies.html#section-hierarchies-subobjects)以了解如何以及为什么这样做。
- en: Of course, two subspaces are the same if and only if they have the same elements.
    This fact is registered for use with the `ext` tactic, which can be used to prove
    two subspaces are equal in the same way it is used to prove that two sets are
    equal.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果两个子空间具有相同的元素，则它们是相同的。这一事实被注册用于与`ext`策略一起使用，该策略可以用来证明两个子空间相等，就像它被用来证明两个集合相等一样。
- en: To state and prove, for example, that `ℝ` is a `ℝ`-linear subspace of `ℂ`, what
    we really want is to construct a term of type `Submodule ℝ ℂ` whose projection
    to `Set ℂ` is `ℝ`, or, more precisely, the image of `ℝ` in `ℂ`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了表述和证明`ℝ`是`ℂ`的`ℝ`-线性子空间，我们真正想要的是构造一个类型为`Submodule ℝ ℂ`的项，其投影到`Set ℂ`是`ℝ`，或者更精确地说，是`ℝ`在`ℂ`中的像。
- en: '[PRE81]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The prime at the end of proof fields in `Submodule` are analogous to the one
    in `LinearMap`. Those fields are stated in terms of the `carrier` field because
    they are defined before the `MemberShip` instance. They are then superseded by
    `Submodule.add_mem`, `Submodule.zero_mem` and `Submodule.smul_mem` that we saw
    above.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Submodule`中证明字段末尾的素数与`LinearMap`中的素数类似。这些字段是用`carrier`字段来表述的，因为它们是在`MemberShip`实例之前定义的。然后，它们被上面看到的`Submodule.add_mem`、`Submodule.zero_mem`和`Submodule.smul_mem`所取代。
- en: As an exercise in manipulating subspaces and linear maps, you will define the
    pre-image of a subspace by a linear map (of course we will see below that Mathlib
    already knows about this). Remember that `Set.mem_preimage` can be used to rewrite
    a statement involving membership and preimage. This is the only lemma you will
    need in addition to the lemmas discussed above about `LinearMap` and `Submodule`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作子空间和线性映射的练习，你将通过一个线性映射定义子空间的逆映射（当然，我们将在下面看到Mathlib已经知道这一点）。记住，可以使用`Set.mem_preimage`来重写涉及成员和逆映射的陈述。这是除了上面讨论的关于`LinearMap`和`Submodule`的引理之外，你将需要的唯一引理。
- en: '[PRE82]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Using type classes, Mathlib knows that a subspace of a vector space inherits
    a vector space structure.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型类，Mathlib知道向量空间的子空间继承了向量空间结构。
- en: '[PRE83]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This example is subtle. The object `U` is not a type, but Lean automatically
    coerces it to a type by interpreting it as a subtype of `V`. So the above example
    can be restated more explicitly as:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很微妙。对象`U`不是一个类型，但Lean会自动将其解释为`V`的子类型，从而将其转换为类型。因此，上面的例子可以更明确地表述为：
- en: '[PRE84]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 10.2.2\. Complete lattice structure and internal direct sums[](#complete-lattice-structure-and-internal-direct-sums
    "Link to this heading")
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2. 完全格结构和内部直和[](#complete-lattice-structure-and-internal-direct-sums "链接到这个标题")
- en: 'An important benefit of having a type `Submodule K V` instead of a predicate
    `IsSubmodule : Set V → Prop` is that one can easily endow `Submodule K V` with
    additional structure. Importantly, it has the structure of a complete lattice
    structure with respect to inclusion. For instance, instead of having a lemma stating
    that an intersection of two subspaces of `V` is again a subspace, we use the lattice
    operation `⊓` to construct the intersection. We can then apply arbitrary lemmas
    about lattices to the construction.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '拥有类型`Submodule K V`而不是谓词`IsSubmodule : Set V → Prop`的一个重要好处是，可以很容易地为`Submodule
    K V`赋予额外的结构。重要的是，它具有关于包含的完全格结构。例如，我们不是用说明两个`V`的子空间交集仍然是子空间的引理，而是使用格运算`⊓`来构造交集。然后，我们可以将任意关于格的引理应用于构造。'
- en: Let us check that the set underlying the infimum of two subspaces is indeed,
    by definition, their intersection.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查两个子空间下确界所对应的集合确实，按照定义，是它们的交集。
- en: '[PRE85]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: It may look strange to have a different notation for what amounts to the intersection
    of the underlying sets, but the correspondence does not carry over to the supremum
    operation and set union, since a union of subspaces is not, in general, a subspace.
    Instead one needs to use the subspace generated by the union, which is done using
    `Submodule.span`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相当于底层集合交集的符号可能看起来很奇怪，但对应关系并不适用于上确界操作和集合并集，因为子空间的并集在一般情况下不是子空间。相反，需要使用由并集生成的子空间，这可以通过`Submodule.span`来完成。
- en: '[PRE86]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Another subtlety is that `V` itself does not have type `Submodule K V`, so
    we need a way to talk about `V` seen as a subspace of `V`. This is also provided
    by the lattice structure: the full subspace is the top element of this lattice.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个微妙之处在于，`V`本身不具有类型`Submodule K V`，因此我们需要一种方式来谈论`V`作为`V`的子空间。这也由格结构提供：整个子空间是这个格的最高元素。
- en: '[PRE87]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Similarly the bottom element of this lattice is the subspace whose only element
    is the zero element.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个格的最低元素是只包含零元素的子空间。
- en: '[PRE88]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In particular we can discuss the case of subspaces that are in (internal) direct
    sum. In the case of two subspaces, we use the general purpose predicate `IsCompl`
    which makes sense for any bounded partially ordered type. In the case of general
    families of subspaces we use `DirectSum.IsInternal`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，我们可以讨论那些在（内部）直和中的子空间的情况。在两个子空间的情况下，我们使用通用谓词`IsCompl`，它对任何有界偏序类型都有意义。在一般子空间族的情况下，我们使用`DirectSum.IsInternal`。
- en: '[PRE89]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 10.2.3\. Subspace spanned by a set[](#subspace-spanned-by-a-set "Link to this
    heading")
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3\. 由集合生成的子空间[](#subspace-spanned-by-a-set "链接到本标题")
- en: In addition to building subspaces out of existing subspaces, we can build them
    out of any set `s` using `Submodule.span K s` which builds the smallest subspace
    containing `s`. On paper it is common to use that this space is made of all linear
    combinations of elements of `s`. But it is often more efficient to use its universal
    property expressed by `Submodule.span_le`, and the whole theory of Galois connections.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从现有子空间构建子空间之外，我们还可以使用`Submodule.span K s`从任何集合`s`构建子空间，它构建包含`s`的最小子空间。在纸上，通常使用这个空间由`s`的元素的所有线性组合构成。但通常更有效的是使用其由`Submodule.span_le`表达的通用性质，以及整个Galois连接理论。
- en: '[PRE90]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: When those are not enough, one can use the relevant induction principle `Submodule.span_induction`
    which ensures a property holds for every element of the span of `s` as long as
    it holds on `zero` and elements of `s` and is stable under sum and scalar multiplication.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些还不够时，可以使用相关的归纳原理`Submodule.span_induction`，该原理确保只要在`zero`和`s`的元素上成立，并且对加法和数乘稳定，那么`s`的生成空间中的每个元素都满足该性质。
- en: As an exercise, let us reprove one implication of `Submodule.mem_sup`. Remember
    that you can use the module tactic to close goals that follow from the axioms
    relating the various algebraic operations on `V`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，让我们重新证明`Submodule.mem_sup`的一个蕴含。记住，你可以使用模块策略来关闭由与`V`上各种代数操作相关的公理得出的目标。
- en: '[PRE91]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 10.2.4\. Pushing and pulling subspaces[](#pushing-and-pulling-subspaces "Link
    to this heading")
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4\. 推拉子空间[](#pushing-and-pulling-subspaces "链接到本标题")
- en: As promised earlier, we now describe how to push and pull subspaces by linear
    maps. As usual in Mathlib, the first operation is called `map` and the second
    one is called `comap`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们现在描述如何通过线性映射推拉子空间。在Mathlib中，通常第一个操作称为`map`，第二个操作称为`comap`。
- en: '[PRE92]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Note those live in the `Submodule` namespace so one can use dot notation and
    write `E.map φ` instead of `Submodule.map φ E`, but this is pretty awkward to
    read (although some Mathlib contributors use this spelling).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意那些位于`Submodule`命名空间中的元素，因此可以使用点符号并写作`E.map φ`而不是`Submodule.map φ E`，但这在阅读上相当尴尬（尽管一些Mathlib贡献者使用这种拼写）。
- en: In particular the range and kernel of a linear map are subspaces. Those special
    cases are important enough to get declarations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，线性映射的范围和核是子空间。这些特殊情况很重要，足以得到声明。
- en: '[PRE93]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Note that we cannot write `φ.ker` instead of `LinearMap.ker φ` because `LinearMap.ker`
    also applies to classes of maps preserving more structure, hence it does not expect
    an argument whose type starts with `LinearMap`, hence dot notation doesn’t work
    here. However we were able to use the other flavor of dot notation in the right-hand
    side. Because Lean expects a term with type `Submodule K V` after elaborating
    the left-hand side, it interprets `.comap` as `Submodule.comap`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不能写`φ.ker`代替`LinearMap.ker φ`，因为`LinearMap.ker`也适用于保持更多结构的映射类，因此它不期望一个以`LinearMap`开头的类型作为参数，因此点符号在这里不起作用。然而，我们能够在右侧使用另一种点符号。因为Lean在展开左侧后期望一个类型为`Submodule
    K V`的项，它将`.comap`解释为`Submodule.comap`。
- en: The following lemmas give the key relations between those submodule and the
    properties of `φ`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下引理给出了这些子模块与`φ`的性质之间的关键关系。
- en: '[PRE94]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: As an exercise, let us prove the Galois connection property for `map` and `comap`.
    One can use the following lemmas but this is not required since they are true
    by definition.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，让我们证明`map`和`comap`的伽罗瓦连接性质。可以使用以下引理，但这不是必需的，因为它们是按定义成立的。
- en: '[PRE95]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 10.2.5\. Quotient spaces[](#quotient-spaces "Link to this heading")
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.5\. 商空间[](#quotient-spaces "链接到本标题")
- en: Quotient vector spaces use the general quotient notation (typed with `\quot`,
    not the ordinary `/`). The projection onto a quotient space is `Submodule.mkQ`
    and the universal property is `Submodule.liftQ`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 商向量空间使用通用的商记号（使用`\quot`输入，而不是普通`/`）。商空间的投影是`Submodule.mkQ`，其通用性质是`Submodule.liftQ`。
- en: '[PRE96]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: As an exercise, let us prove the correspondence theorem for subspaces of quotient
    spaces. Mathlib knows a slightly more precise version as `Submodule.comapMkQRelIso`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，让我们证明商空间子空间的对应定理。Mathlib知道一个稍微更精确的版本，即`Submodule.comapMkQRelIso`。
- en: '[PRE97]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 10.3\. Endomorphisms[](#endomorphisms "Link to this heading")
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3\. 内射[](#endomorphisms "链接到本标题")
- en: 'An important special case of linear maps are endomorphisms: linear maps from
    a vector space to itself. They are interesting because they form a `K`-algebra.
    In particular we can evaluate polynomials with coefficients in `K` on them, and
    they can have eigenvalues and eigenvectors.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 线性映射的一个重要特殊情况是内射：从向量空间到自身的线性映射。它们很有趣，因为它们形成一个`K`-代数。特别是，我们可以在它们上评估系数在`K`中的多项式，并且它们可以有特征值和特征向量。
- en: Mathlib uses the abbreviation `Module.End K V := V →ₗ[K] V` which is convenient
    when using a lot of these (especially after opening the `Module` namespace).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib使用缩写`Module.End K V := V →ₗ[K] V`，这在使用很多这些（尤其是在打开`Module`命名空间之后）时很方便。
- en: '[PRE98]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'As an exercise manipulating endomorphisms, subspaces and polynomials, let us
    prove the (binary) kernels lemma: for any endomorphism \(φ\) and any two relatively
    prime polynomials \(P\) and \(Q\), we have \(\ker P(φ) ⊕ \ker Q(φ) = \ker \big(PQ(φ)\big)\).'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作内射、子空间和多项式的练习，让我们证明（二元的）核引理：对于任何内射\(φ\)和任意两个互质的聚合物\(P\)和\(Q\)，我们有\(\ker
    P(φ) ⊕ \ker Q(φ) = \ker \big(PQ(φ)\big)\)。
- en: Note that `IsCoprime x y` is defined as `∃ a b, a * x + b * y = 1`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`IsCoprime x y`被定义为`∃ a b, a * x + b * y = 1`。
- en: '[PRE99]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We now move to the discussions of eigenspaces and eigenvalues. The eigenspace
    associated to an endomorphism \(φ\) and a scalar \(a\) is the kernel of \(φ -
    aId\). Eigenspaces are defined for all values of `a`, although they are interesting
    only when they are non-zero. However an eigenvector is, by definition, a non-zero
    element of an eigenspace. The corresponding predicate is `End.HasEigenvector`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向对特征空间和特征值的讨论。与内射\(φ\)和标量\(a\)相关的特征空间是\(φ - aId\)的核。特征空间对所有`a`的值都定义，尽管它们只有在非零时才有趣。然而，根据定义，特征向量是特征空间中的非零元素。相应的谓词是`End.HasEigenvector`。
- en: '[PRE100]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Then there is a predicate `End.HasEigenvalue` and the corresponding subtype
    `End.Eigenvalues`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后存在一个谓词`End.HasEigenvalue`和相应的子类型`End.Eigenvalues`。
- en: '[PRE101]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '## 10.4\. Matrices, bases and dimension[](#matrices-bases-and-dimension "Link
    to this heading")'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '## 10.4\. 矩阵、基和维度[](#matrices-bases-and-dimension "链接到本标题")'
- en: '### 10.4.1\. Matrices[](#matrices "Link to this heading")'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '### 10.4.1\. 矩阵[](#matrices "链接到本标题")'
- en: Before introducing bases for abstract vector spaces, we go back to the much
    more elementary setup of linear algebra in \(K^n\) for some field \(K\). Here
    the main objects are vectors and matrices. For concrete vectors, one can use the
    `![…]` notation, where components are separated by commas. For concrete matrices
    we can use the `!![…]` notation, lines are separated by semi-colons and components
    of lines are separated by colons. When entries have a computable type such as
    `ℕ` or `ℚ`, we can use the `eval` command to play with basic operations.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍抽象向量空间的基之前，我们回到更基础的线性代数设置，即某个域 \(K\) 的 \(K^n\)。在这里，主要对象是向量和矩阵。对于具体向量，可以使用
    `![…]` 符号，其中分量由逗号分隔。对于具体矩阵，我们可以使用 `!![…]` 符号，行由分号分隔，行的分量由冒号分隔。当条目具有可计算类型，如 `ℕ`
    或 `ℚ` 时，我们可以使用 `eval` 命令进行基本操作。
- en: '[PRE102]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: It is important to understand that this use of `#eval` is interesting only for
    exploration, it is not meant to replace a computer algebra system such as Sage.
    The data representation used here for matrices is *not* computationally efficient
    in any way. It uses functions instead of arrays and is optimized for proving,
    not computing. The virtual machine used by `#eval` is also not optimized for this
    use.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，这种 `#eval` 的使用仅对探索有趣，它不是用来取代计算机代数系统，如 Sage。这里用于矩阵的数据表示在计算效率方面没有任何优势。它使用函数而不是数组，并且优化用于证明，而不是计算。`#eval`
    所使用的虚拟机也不是为此用途优化的。
- en: Beware the matrix notation list rows but the vector notation is neither a row
    vector nor a column vector. Multiplication of a matrix with a vector from the
    left (resp. right) interprets the vector as a row (resp. column) vector. This
    corresponds to operations `Matrix.vecMul`, with notation `ᵥ*` and `Matrix.mulVec`,
    with notation ` *ᵥ`. Those notations are scoped in the `Matrix` namespace that
    we therefore need to open.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意矩阵表示法列出行，但向量表示法既不是行向量也不是列向量。从左（分别）乘以矩阵的向量解释为行（分别）向量。这对应于 `Matrix.vecMul` 操作，符号为
    `ᵥ*`，以及 `Matrix.mulVec` 操作，符号为 ` *ᵥ`。这些符号在 `Matrix` 命名空间中定义，因此我们需要打开它。
- en: '[PRE103]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: In order to generate matrices with identical rows or columns specified by a
    vector, we use `Matrix.replicateRow` and `Matrix.replicateCol`, with arguments
    the type indexing the rows or columns and the vector. For instance one can get
    single row or single column matrixes (more precisely matrices whose rows or columns
    are indexed by `Fin 1`).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成具有由向量指定的相同行或列的矩阵，我们使用 `Matrix.replicateRow` 和 `Matrix.replicateCol`，其中参数是索引行或列的类型和向量。例如，可以得到单行或单列矩阵（更精确地说，行或列由
    `Fin 1` 索引的矩阵）。
- en: '[PRE104]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Other familiar operations include the vector dot product, matrix transpose,
    and, for square matrices, determinant and trace.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 其他熟悉的操作包括向量点积、矩阵转置，以及对于方阵，行列式和迹。
- en: '[PRE105]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: When entries do not have a computable type, for instance if they are real numbers,
    we cannot hope that `#eval` can help. Also this kind of evaluation cannot be used
    in proofs without considerably expanding the trusted code base (i.e. the part
    of Lean that you need to trust when checking proofs).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当条目没有可计算的类型时，例如如果它们是实数，我们无法期望 `#eval` 能有所帮助。此外，这种评估在没有显著扩大可信代码库（即检查证明时需要信任的
    Lean 的部分）的情况下不能用于证明。
- en: So it is good to also use the `simp` and `norm_num` tactics in proofs, or their
    command counter-part for quick exploration.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在证明中也使用 `simp` 和 `norm_num` 策略，或者它们的命令对应物进行快速探索是很好的。
- en: '[PRE106]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The next important operation on square matrices is inversion. In the same way
    as division of numbers is always defined and returns the artificial value zero
    for division by zero, the inversion operation is defined on all matrices and returns
    the zero matrix for non-invertible matrices.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方阵来说，下一个重要的操作是求逆。与数的除法总是定义且在除以零时返回人工值零一样，求逆操作在所有矩阵上定义，并在不可逆矩阵上返回零矩阵。
- en: More precisely, there is general function `Ring.inverse` that does this in any
    ring, and, for any matrix `A`, `A⁻¹` is defined as `Ring.inverse A.det • A.adjugate`.
    According to Cramer’s rule, this is indeed the inverse of `A` when the determinant
    of `A` is not zero.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，存在一个通用函数 `Ring.inverse`，它在任何环中执行此操作，并且对于任何矩阵 `A`，`A⁻¹` 被定义为 `Ring.inverse
    A.det • A.adjugate`。根据克莱默法则，当 `A` 的行列式不为零时，这确实是 `A` 的逆。
- en: '[PRE107]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Of course this definition is really useful only for invertible matrices. There
    is a general type class `Invertible` that helps recording this. For instance,
    the `simp` call in the next example will use the `inv_mul_of_invertible` lemma
    which has an `Invertible` type-class assumption, so it will trigger only if this
    can be found by the type-class synthesis system. Here we make this fact available
    using a `have` statement.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个定义对于可逆矩阵来说非常有用。有一个通用的类型类`Invertible`有助于记录这一点。例如，下一个例子中的`simp`调用将使用具有`Invertible`类型类假设的`inv_mul_of_invertible`引理，因此只有在类型类合成系统可以找到它的情况下才会触发。在这里，我们使用`have`语句使这一事实可用。
- en: '[PRE108]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'In this fully concrete case, we could also use the `norm_num` machinery, and
    `apply?` to find the final line:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个完全具体的例子中，我们也可以使用`norm_num`机制和`apply?`来找到最终的行：
- en: '[PRE109]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: All the concrete matrices above have their rows and columns indexed by `Fin
    n` for some `n` (not necessarily the same for rows and columns). But sometimes
    it is more convenient to index matrices using arbitrary finite types. For instance
    the adjacency matrix of a finite graph has rows and columns naturally indexed
    by the vertices of the graph.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的具体矩阵都有它们的行和列由`Fin n`索引，其中`n`是某个值（行和列不一定相同）。但有时使用任意有限类型索引矩阵更方便。例如，有限图的邻接矩阵的行和列自然由图的顶点索引。
- en: In fact when simply wants to define matrices without defining any operation
    on them, finiteness of the indexing types are not even needed, and coefficients
    can have any type, without any algebraic structure. So Mathlib simply defines
    `Matrix m n α` to be `m → n → α` for any types `m`, `n` and `α`, and the matrices
    we have been using so far had types such as `Matrix (Fin 2) (Fin 2) ℝ`. Of course
    algebraic operations require more assumptions on `m`, `n` and `α`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当仅仅想要定义矩阵而不在它们上定义任何操作时，索引类型的有限性甚至都不需要，系数可以有任何类型，而不需要任何代数结构。因此，Mathlib简单地定义`Matrix
    m n α`为`m → n → α`，对于任何类型`m`、`n`和`α`，我们迄今为止所使用的矩阵类型如`Matrix (Fin 2) (Fin 2) ℝ`。当然，代数运算需要对`m`、`n`和`α`有更多的假设。
- en: Note the main reason why we do not use `m → n → α` directly is to allow the
    type class system to understand what we want. For instance, for a ring `R`, the
    type `n → R` is endowed with the point-wise multiplication operation, and similarly
    `m → n → R` has this operation which is *not* the multiplication we want on matrices.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不直接使用`m → n → α`的主要原因是为了让类型类系统理解我们的意图。例如，对于一个环`R`，类型`n → R`被赋予了点乘操作，同样`m
    → n → R`也有这种操作，但这并不是我们在矩阵上想要的乘法。
- en: In the first example below, we force Lean to see through the definition of `Matrix`
    and accept the statement as meaningful, and then prove it by checking all entries.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的第一个例子中，我们迫使Lean理解`Matrix`的定义，并接受这个陈述是有意义的，然后通过检查所有项来证明它。
- en: But then the next two examples reveal that Lean uses the point-wise multiplication
    on `Fin 2 → Fin 2 → ℤ` but the matrix multiplication on `Matrix (Fin 2) (Fin 2)
    ℤ`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 但接下来的两个例子揭示，Lean在`Fin 2 → Fin 2 → ℤ`上使用点乘，但在`Matrix (Fin 2) (Fin 2) ℤ`上使用矩阵乘法。
- en: '[PRE110]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: In order to define matrices as functions without losing the benefits of `Matrix`
    for type class synthesis, we can use the equivalence `Matrix.of` between functions
    and matrices. This equivalence is secretly defined using `Equiv.refl`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将矩阵定义为函数而不失去`Matrix`在类型类合成中的优势，我们可以使用函数和矩阵之间的等价性`Matrix.of`。这个等价性是秘密地使用`Equiv.refl`定义的。
- en: For instance we can define Vandermonde matrices corresponding to a vector `v`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义与向量`v`对应的Vandermonde矩阵。
- en: '[PRE111]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 10.4.2\. Bases[](#bases "Link to this heading")
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2. 基[](#bases "链接到这个标题")
- en: We now want to discuss bases of vector spaces. Informally there are many ways
    to define this notion. One can use a universal property. One can say a basis is
    a family of vectors that is linearly independent and spanning. Or one can combine
    those properties and directly say that a basis is a family of vectors such that
    every vectors can be written uniquely as a linear combination of bases vectors.
    Yet another way to say it is that a basis provides a linear isomorphism with a
    power of the base field `K`, seen as a vector space over `K`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要讨论向量空间的基。非正式地说，有许多定义这个概念的方法。可以使用一个通用性质。可以说基是一组线性无关且张成的向量族。或者可以将这些性质结合起来，直接说基是一组向量，每个向量都可以唯一地表示为基向量的线性组合。还有一种说法是，基提供了一个与基域`K`的幂的线性同构，将`K`视为`K`上的向量空间。
- en: 'This isomorphism version is actually the one that Mathlib uses as a definition
    under the hood, and other characterizations are proven from it. One must be slightly
    careful with the “power of `K`” idea in the case of infinite bases. Indeed only
    finite linear combinations make sense in this algebraic context. So what we need
    as a reference vector space is not a direct product of copies of `K` but a direct
    sum. We could use `⨁ i : ι, K` for some type `ι` indexing the basis But we rather
    use the more specialized spelling `ι →₀ K` which means “functions from `ι` to
    `K` with finite support”, i.e. functions which vanish outside a finite set in
    `ι` (this finite set is not fixed, it depends on the function). Evaluating such
    a function coming from a basis `B` at a vector `v` and `i : ι` returns the component
    (or coordinate) of `v` on the `i`-th basis vector.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '这个同构版本实际上是 Mathlib 在底层用作定义的版本，其他特征化都是从这个版本证明出来的。在无限基的情况下，必须对“`K` 的幂”这个概念稍加小心。确实，在这个代数背景下，只有有限线性组合才有意义。因此，我们需要作为参考向量空间的不应该是
    `K` 的直接积，而是一个直接和。我们可以用 `⨁ i : ι, K` 表示某个索引基的 `ι` 类型，但我们更倾向于使用更专业的表示 `ι →₀ K`，这意味着“从
    `ι` 到 `K` 的有限支撑函数”，即函数在 `ι` 的有限集合之外为零（这个有限集合不是固定的，它取决于函数）。将来自基 `B` 的这样一个函数在向量
    `v` 和 `i : ι` 上进行评估，返回 `v` 在第 `i` 个基向量上的分量（或坐标）。'
- en: The type of bases indexed by a type `ι` of `V` as a `K` vector space is `Basis
    ι K V`. The isomorphism is called `Basis.repr`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `V` 作为 `K` 向量空间的基的索引类型 `ι` 的类型是 `Basis ι K V`。这个同构被称为 `Basis.repr`。
- en: '[PRE112]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Instead of starting with such an isomorphism, one can start with a family `b`
    of vectors that is linearly independent and spanning, this is `Basis.mk`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从这样一个同构开始，也可以从一个线性无关且生成的一组向量 `b` 开始，这就是 `Basis.mk`。
- en: The assumption that the family is spanning is spelled out as `⊤ ≤ Submodule.span
    K (Set.range b)`. Here `⊤` is the top submodule of `V`, i.e. `V` seen as submodule
    of itself. This spelling looks a bit tortuous, but we will see below that it is
    almost equivalent by definition to the more readable `∀ v, v ∈ Submodule.span
    K (Set.range b)` (the underscores in the snippet below refers to the useless information
    `v ∈ ⊤`).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 将族是生成性的假设表述为 `⊤ ≤ Submodule.span K (Set.range b)`。这里 `⊤` 是 `V` 的上子模，即 `V` 作为自身的子模来看待。这种表述看起来有点复杂，但下面我们将看到它几乎等同于更易读的
    `∀ v, v ∈ Submodule.span K (Set.range b)`（下面片段中的下划线指的是无用的信息 `v ∈ ⊤`）。
- en: '[PRE113]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'In particular the model vector space `ι →₀ K` has a so-called canonical basis
    whose `repr` function evaluated on any vector is the identity isomorphism. It
    is called `Finsupp.basisSingleOne` where `Finsupp` means function with finite
    support and `basisSingleOne` refers to the fact that basis vectors are functions
    which vanish expect for a single input value. More precisely the basis vector
    indexed by `i : ι` is `Finsupp.single i 1` which is the finitely supported function
    taking value `1` at `i` and `0` everywhere else.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '特别地，模型向量空间 `ι →₀ K` 有一个所谓的规范基，其 `repr` 函数在任意向量上的评估是恒等同构。它被称为 `Finsupp.basisSingleOne`，其中
    `Finsupp` 表示具有有限支撑的函数，而 `basisSingleOne` 指的是基向量是除了单个输入值外都为零的函数。更精确地说，由 `i : ι`
    索引的基向量是 `Finsupp.single i 1`，这是一个在 `i` 处取值为 `1` 而在其他所有地方取值为 `0` 的有限支撑函数。'
- en: '[PRE114]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The story of finitely supported functions is unneeded when the indexing type
    is finite. In this case we can use the simpler `Pi.basisFun` which gives a basis
    of the whole `ι → K`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当索引类型是有限的时候，有限支撑函数的故事是不必要的。在这种情况下，我们可以使用更简单的 `Pi.basisFun`，它给出整个 `ι → K` 的基。
- en: '[PRE116]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Going back to the general case of bases of abstract vector spaces, we can express
    any vector as a linear combination of basis vectors. Let us first see the easy
    case of finite bases.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 回到抽象向量空间基的一般情况，我们可以将任何向量表示为基向量的线性组合。让我们先看看有限基的简单情况。
- en: '[PRE117]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'When `ι` is not finite, the above statement makes no sense a priori: we cannot
    take a sum over `ι`. However the support of the function being summed is finite
    (it is the support of `B.repr v`). But we need to apply a construction that takes
    this into account. Here Mathlib uses a special purpose function that requires
    some time to get used to: `Finsupp.linearCombination` (which is built on top of
    the more general `Finsupp.sum`). Given a finitely supported function `c` from
    a type `ι` to the base field `K` and any function `f` from `ι` to `V`, `Finsupp.linearCombination
    K f c` is the sum over the support of `c` of the scalar multiplication `c • f`.
    In particular, we can replace it by a sum over any finite set containing the support
    of `c`.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `ι` 不是有限时，上述陈述在先验上没有意义：我们不能对 `ι` 进行求和。然而，被求和函数的支持是有限的（它是 `B.repr v` 的支持）。但是我们需要应用一个考虑这一点的构造。在这里，Mathlib
    使用了一个特殊目的的函数，需要一些时间来习惯：`Finsupp.linearCombination`（它建立在更一般的 `Finsupp.sum` 之上）。给定一个有限支持的函数
    `c` 从类型 `ι` 到基域 `K` 以及任何从 `ι` 到 `V` 的函数 `f`，`Finsupp.linearCombination K f c`
    是对 `c` 的支持上的标量乘积 `c • f` 的求和。特别是，我们可以将其替换为包含 `c` 的支持中的任何有限集上的求和。
- en: '[PRE118]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: One could also assume that `f` is finitely supported and still get a well defined
    sum. But the choice made by `Finsupp.linearCombination` is the one relevant to
    our basis discussion since it allows to state the generalization of `Basis.sum_repr`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以假设 `f` 是有限支持的，并且仍然得到一个定义良好的和。但是 `Finsupp.linearCombination` 所做的选择与我们的基讨论相关，因为它允许陈述
    `Basis.sum_repr` 的一般化。
- en: '[PRE119]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: One could wonder why `K` is an explicit argument here, despite the fact it can
    be inferred from the type of `c`. The point is that the partially applied `Finsupp.linearCombination
    K f` is interesting in itself. It is not a bare function from `ι →₀ K` to `V`
    but a `K`-linear map.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 也有人可能会想知道为什么 `K` 是一个显式的参数，尽管它可以从 `c` 的类型中推断出来。关键是部分应用 `Finsupp.linearCombination
    K f` 本身就很有趣。它不是一个从 `ι →₀ K` 到 `V` 的裸函数，而是一个 `K`-线性映射。
- en: '[PRE120]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Returning to the mathematical discussion, it is important to understand that
    the representation of vectors in a basis is less useful in formalized mathematics
    than you may think. Indeed it is very often more efficient to directly use more
    abstract properties of bases. In particular the universal property of bases connecting
    them to other free objects in algebra allows to construct linear maps by specifying
    the images of basis vectors. This is `Basis.constr`. For any `K`-vector space
    `W`, our basis `B` gives a linear isomorphism `Basis.constr B K` from `ι → W`
    to `V →ₗ[K] W`. This isomorphism is characterized by the fact that it sends any
    function `u : ι → W` to a linear map sending the basis vector `B i` to `u i`,
    for every `i : ι`.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '回到数学讨论，重要的是要理解，在形式化数学中，基中向量的表示不如你可能想象的那么有用。事实上，直接使用基的更抽象性质通常更有效。特别是，基的普遍性质将它们与其他代数中的自由对象连接起来，允许通过指定基向量的像来构造线性映射。这是
    `Basis.constr`。对于任何 `K`-向量空间 `W`，我们的基 `B` 给出一个线性同构 `Basis.constr B K` 从 `ι → W`
    到 `V →ₗ[K] W`。这个同构的特点是它将任何函数 `u : ι → W` 映射到一个线性映射，该映射将基向量 `B i` 映射到 `u i`，对于每个
    `i : ι`。'
- en: '[PRE121]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'This property is indeed characteristic because linear maps are determined by
    their values on bases:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性确实是特征性的，因为线性映射由其在基上的值决定：
- en: '[PRE122]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: If we also have a basis `B'` on the target space then we can identify linear
    maps with matrices. This identification is a `K`-linear isomorphism.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还在目标空间上有基 `B'`，那么我们可以将线性映射与矩阵相识别。这种识别是一个 `K`-线性同构。
- en: '[PRE123]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: As an exercise on this topic, we will prove part of the theorem which guarantees
    that endomorphisms have a well-defined determinant. Namely we want to prove that
    when two bases are indexed by the same type, the matrices they attach to any endomorphism
    have the same determinant. This would then need to be complemented using that
    bases all have isomorphic indexing types to get the full result.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个主题的练习，我们将证明定理的一部分，该定理保证了内射映射有一个定义良好的行列式。具体来说，我们想要证明当两个基由相同的类型索引时，它们附加到任何内射映射上的矩阵具有相同的行列式。然后需要使用所有基都具有同构索引类型的事实来补充这一结果。
- en: Of course Mathlib already knows this, and `simp` can close the goal immediately,
    so you shouldn’t use it too soon, but rather use the provided lemmas.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Mathlib 已经知道这一点，`simp` 可以立即关闭目标，所以你不应该过早地使用它，而应该使用提供的引理。
- en: '[PRE124]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 10.4.3\. Dimension[](#dimension "Link to this heading")
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3\. 维度[](#dimension "链接到这个标题")
- en: Returning to the case of a single vector space, bases are also useful to define
    the concept of dimension. Here again, there is the elementary case of finite-dimensional
    vector spaces. For such spaces we expect a dimension which is a natural number.
    This is `Module.finrank`. It takes the base field as an explicit argument since
    a given abelian group can be a vector space over different fields.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 回到单个向量空间的情况，基也用于定义维度概念。在这里，有限维向量空间是基本的情况。对于这样的空间，我们期望维度是一个自然数。这是 `Module.finrank`。它将基域作为显式参数，因为一个给定的阿贝尔群可以是在不同域上的向量空间。
- en: '[PRE125]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Note that `Module.finrank` is defined for any vector space. It returns zero
    for infinite dimensional vector spaces, just as division by zero returns zero.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Module.finrank` 定义了任何向量空间。对于无限维向量空间，它返回零，就像除以零返回零一样。
- en: Of course many lemmas require a finite dimension assumption. This is the role
    of the `FiniteDimensional` typeclass. For instance, think about how the next example
    fails without this assumption.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，许多引理需要有限维度的假设。这就是 `FiniteDimensional` 类型类的作用。例如，考虑下一个例子在没有这个假设的情况下是如何失败的。
- en: '[PRE126]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'In the above statement, `Nontrivial V` means `V` has at least two different
    elements. Note that `Module.finrank_pos_iff` has no explicit argument. This is
    fine when using it from left to right, but not when using it from right to left
    because Lean has no way to guess `K` from the statement `Nontrivial V`. In that
    case it is useful to use the name argument syntax, after checking that the lemma
    is stated over a ring named `R`. So we can write:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述陈述中，`Nontrivial V` 表示 `V` 至少有两个不同的元素。请注意，`Module.finrank_pos_iff` 没有显式的参数。当从左到右使用它时这是可以的，但不是从右到左，因为
    Lean 没有从 `Nontrivial V` 这个陈述中猜测 `K` 的方法。在这种情况下，使用名称参数语法是有用的，前提是已经确认引理是在一个名为 `R`
    的环上声明的。因此，我们可以写出：
- en: '[PRE127]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The above spelling is strange because we already have `h` as an assumption,
    so we could just as well give the full proof `Module.finrank_pos_iff.1 h` but
    it is good to know for more complicated cases.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 上述拼写很奇怪，因为我们已经有了 `h` 作为假设，所以我们完全可以给出完整的证明 `Module.finrank_pos_iff.1 h`，但在更复杂的情况下了解这一点是好的。
- en: By definition, `FiniteDimensional K V` can be read from any basis.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，`FiniteDimensional K V` 可以从任何基中读取。
- en: '[PRE128]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Using that the subtype corresponding to a linear subspace has a vector space
    structure, we can talk about the dimension of a subspace.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 利用对应于线性子空间的子类型具有向量空间结构，我们可以讨论子空间的维度。
- en: '[PRE129]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: In the first statement above, the purpose of the type ascriptions is to make
    sure that coercion to `Type*` does not trigger too early.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述第一个陈述中，类型赋值的目的是确保将强制转换为 `Type*` 不会太早触发。
- en: We are now ready for an exercise about `finrank` and subspaces.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以准备一个关于 `finrank` 和子空间的练习。
- en: '[PRE130]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Let us now move to the general case of dimension theory. In this case `finrank`
    is useless, but we still have that, for any two bases of the same vector space,
    there is a bijection between the types indexing those bases. So we can still hope
    to define the rank as a cardinal, i.e. an element of the “quotient of the collection
    of types under the existence of a bijection equivalence relation”.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向维度理论的一般情况。在这种情况下，`finrank` 是无用的，但我们仍然有，对于同一向量空间的两个基，它们之间的类型索引存在一个双射。因此，我们仍然可以希望将秩定义为基数，即“在存在双射等价关系下的类型集合的商”中的一个元素。
- en: When discussing cardinal, it gets harder to ignore foundational issues around
    Russel’s paradox like we do everywhere else in this book. There is no type of
    all types because it would lead to logical inconsistencies. This issue is solved
    by the hierarchy of universes that we usually try to ignore.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论基数时，就像在这本书的其他地方一样，很难忽视围绕 Russell 的悖论的基础性问题。没有所有类型的类型，因为这会导致逻辑不一致。这个问题通过我们通常试图忽略的宇宙层次结构得到解决。
- en: Each type has a universe level, and those levels behave similarly to natural
    numbers. In particular there is zeroth level, and the corresponding universe `Type
    0` is simply denoted by `Type`. This universe is enough to hold almost all of
    classical mathematics. For instance `ℕ` and `ℝ` have type `Type`. Each level `u`
    has a successor denoted by `u + 1`, and `Type u` has type `Type (u+1)`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型都有一个宇宙级别，这些级别的行为类似于自然数。特别是有一个零级，相应的宇宙 `Type 0` 简单地表示为 `Type`。这个宇宙足以容纳几乎所有经典数学。例如
    `ℕ` 和 `ℝ` 有 `Type` 类型。每个级别 `u` 有一个后继，表示为 `u + 1`，而 `Type u` 有 `Type (u+1)` 类型。
- en: But universe levels are not natural numbers, they have a really different nature
    and don’t have a type. In particular you cannot state in Lean something like `u
    ≠ u + 1`. There is simply no type where this would take place. Even stating `Type
    u ≠ Type (u+1)` does not make any sense since `Type u` and `Type (u+1)` have different
    types.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 但宇宙级别不是自然数，它们具有非常不同的性质，并且没有类型。特别是，你无法在Lean中陈述类似于`u ≠ u + 1`的东西。根本不存在这样的类型。甚至陈述`Type
    u ≠ Type (u+1)`也没有意义，因为`Type u`和`Type (u+1)`具有不同的类型。
- en: Whenever we write `Type*`, Lean inserts a universe level variable named `u_n`
    where `n` is a number. This allows definitions and statements to live in all universes.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们写`Type*`时，Lean会插入一个名为`u_n`的宇宙级别变量，其中`n`是一个数字。这允许定义和陈述存在于所有宇宙中。
- en: 'Given a universe level `u`, we can define an equivalence relation on `Type
    u` saying two types `α` and `β` are equivalent if there is a bijection between
    them. The quotient type `Cardinal.{u}` lives in `Type (u+1)`. The curly braces
    denote a universe variable. The image of `α : Type u` in this quotient is `Cardinal.mk
    α : Cardinal.{u}`.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个宇宙级别`u`，我们可以在`Type u`上定义一个等价关系，如果两个类型`α`和`β`之间存在双射，则称这两个类型`α`和`β`是等价的。商类型`Cardinal.{u}`生活在`Type
    (u+1)`中。大括号表示一个宇宙变量。在这个商中，`α : Type u`的像是`Cardinal.mk α : Cardinal.{u}`。'
- en: But we cannot directly compare cardinals in different universes. So technically
    we cannot define the rank of a vector space `V` as the cardinal of all types indexing
    a basis of `V`. So instead it is defined as the supremum `Module.rank K V` of
    cardinals of all linearly independent sets in `V`. If `V` has universe level `u`
    then its rank has type `Cardinal.{u}`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们无法直接比较不同宇宙中的基数。因此，技术上我们无法将向量空间`V`的秩定义为所有索引`V`的基的类型集合的基数。因此，它被定义为`V`中所有线性无关集合的基数`Module.rank
    K V`的上确界。如果`V`的宇宙级别为`u`，则其秩具有类型`Cardinal.{u}`。
- en: '[PRE131]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'One can still relate this definition to bases. Indeed there is also a commutative
    `max` operation on universe levels, and given two universe levels `u` and `v`
    there is an operation `Cardinal.lift.{u, v} : Cardinal.{v} → Cardinal.{max v u}`
    that allows to put cardinals in a common universe and state the dimension theorem.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管如此，我们仍然可以将这个定义与基联系起来。确实，在宇宙级别上也有一个交换的`max`操作，并且对于两个宇宙级别`u`和`v`，存在一个操作`Cardinal.lift.{u,
    v} : Cardinal.{v} → Cardinal.{max v u}`，它允许将基数放入一个共同的宇宙中并陈述维度定理。'
- en: '[PRE132]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: We can relate the finite dimensional case to this discussion using the coercion
    from natural numbers to finite cardinals (or more precisely the finite cardinals
    which live in `Cardinal.{v}` where `v` is the universe level of `V`).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用从自然数到有限基数的强制转换（或者更精确地说，是生活在`Cardinal.{v}`中的有限基数，其中`v`是`V`的宇宙级别）将有限维情况与这次讨论联系起来。
- en: '[PRE133]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 10.1\. Vector spaces and linear maps[](#vector-spaces-and-linear-maps "Link
    to this heading")
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1\. 向量空间和线性映射[](#vector-spaces-and-linear-maps "链接到本标题")
- en: 10.1.1\. Vector spaces[](#vector-spaces "Link to this heading")
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1\. 向量空间[](#vector-spaces "链接到本标题")
- en: We will start directly abstract linear algebra, taking place in a vector space
    over any field. However you can find information about matrices in [Section 10.4.1](#matrices)
    which does not logically depend on this abstract theory. Mathlib actually deals
    with a more general version of linear algebra involving the word module, but for
    now we will pretend this is only an eccentric spelling habit.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接从抽象线性代数开始，它发生在任何域上的向量空间中。然而，你可以在[第10.4.1节](#matrices)中找到有关矩阵的信息，这部分内容与抽象理论无关。Mathlib实际上处理的是涉及模块一词的更一般版本的线性代数，但就目前而言，我们将假装这仅仅是一种古怪的拼写习惯。
- en: 'The way to say “let \(K\) be a field and let \(V\) be a vector space over \(K\)”
    (and make them implicit arguments to later results) is:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 要说“设\(K\)为一个域，设\(V\)为\(K\)上的向量空间”（并将它们作为后续结果的隐含参数）的方式是：
- en: '[PRE134]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: We explained in [Chapter 8](C08_Hierarchies.html#hierarchies) why we need two
    separate typeclasses `[AddCommGroup V] [Module K V]`. The short version is the
    following. Mathematically we want to say that having a \(K\)-vector space structure
    implies having an additive commutative group structure. We could tell this to
    Lean. But then whenever Lean would need to find such a group structure on a type
    \(V\), it would go hunting for vector space structures using a *completely unspecified*
    field \(K\) that cannot be inferred from \(V\). This would be very bad for the
    type class synthesis system.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 8 章](C08_Hierarchies.html#hierarchies)中解释了为什么我们需要两个单独的类型类 `[AddCommGroup
    V] [Module K V]`。简而言之，数学上我们想要表达的是，具有 \(K\) 向量空间结构意味着具有加法交换群结构。我们可以告诉 Lean。但然后每当
    Lean 需要在类型 \(V\) 上找到这样的群结构时，它就会使用一个*完全未指定的*字段 \(K\) 来寻找向量空间结构，而这个字段无法从 \(V\) 推断出来。这对类型类综合系统来说是非常糟糕的。
- en: The multiplication of a vector v by a scalar a is denoted by a • v. We list
    a couple of algebraic rules about the interaction of this operation with addition
    in the following examples. Of course simp or apply? would find those proofs. There
    is also a module tactic that solves goals following from the axioms of vector
    spaces and fields, in the same way the ring tactic is used in commutative rings
    or the group tactic is used in groups. But it is still useful to remember that
    scalar multiplication is abbreviated smul in lemma names.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 \(v\) 与标量 \(a\) 的乘积表示为 a • v。我们在以下示例中列出了一些关于此操作与加法交互的代数规则。当然，simp 或 apply?
    会找到这些证明。还有一个模块策略，它解决从向量空间和域的公理中得出的目标，就像在交换环中使用环策略或在群中使用群策略一样。但仍然有用的是记住标量乘法在引理名称中简写为
    smul。
- en: '[PRE135]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'As a quick note for more advanced readers, let us point out that, as suggested
    by terminology, Mathlib’s linear algebra also covers modules over (not necessarily
    commutative) rings. In fact it even covers semi-modules over semi-rings. If you
    think you do not need this level of generality, you can meditate the following
    example that nicely captures a lot of algebraic rules about ideals acting on submodules:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对更高级读者的快速提示，让我们指出，正如术语所暗示的，Mathlib 的线性代数也涵盖了（不一定交换的）环上的模。实际上，它甚至涵盖了半环上的半模。如果你认为你不需要这种程度的普遍性，你可以冥想以下示例，它很好地捕捉了许多关于理想在子模上作用的代数规则：
- en: '[PRE136]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 10.1.2\. Linear maps[](#linear-maps "Link to this heading")
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2\. 线性映射[](#linear-maps "链接到这个标题")
- en: Next we need linear maps. Like group morphisms, linear maps in Mathlib are bundled
    maps, i.e. packages made of a map and proofs of its linearity properties. Those
    bundled maps are converted to ordinary functions when applied. See [Chapter 8](C08_Hierarchies.html#hierarchies)
    for more information about this design.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要线性映射。像群同态一样，Mathlib 中的线性映射是打包映射，即由映射及其线性性质证明组成的包。这些打包映射在应用时被转换为普通函数。有关此设计的更多信息，请参阅[第
    8 章](C08_Hierarchies.html#hierarchies)。
- en: The type of linear maps between two `K`-vector spaces `V` and `W` is denoted
    by `V →ₗ[K] W`. The subscript l stands for linear. At first it may feel odd to
    specify `K` in this notation. But this is crucial when several fields come into
    play. For instance real-linear maps from \(ℂ\) to \(ℂ\) are every map \(z ↦ az
    + b\bar{z}\) while only the maps \(z ↦ az\) are complex linear, and this difference
    is crucial in complex analysis.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `K` 向量空间 `V` 和 `W` 之间线性映射的类型表示为 `V →ₗ[K] W`。下标 l 代表线性。一开始可能觉得在这个符号中指定 `K`
    很奇怪。但这是几个领域同时出现时的关键。例如，从 \(ℂ\) 到 \(ℂ\) 的实线性映射是每个映射 \(z ↦ az + b\bar{z}\)，而只有映射
    \(z ↦ az\) 是复线性，这种差异在复分析中是至关重要的。
- en: '[PRE137]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Note that `V →ₗ[K] W` itself carries interesting algebraic structures (this
    is part of the motivation for bundling those maps). It is a `K`-vector space so
    we can add linear maps and multiply them by scalars.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`V →ₗ[K] W` 本身承载着有趣的代数结构（这是打包这些映射的部分动机）。它是一个 \(K\) 向量空间，因此我们可以添加线性映射并乘以标量。
- en: '[PRE138]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: One downside of using bundled maps is that we cannot use ordinary function composition.
    We need to use `LinearMap.comp` or the notation `∘ₗ`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 使用打包映射的一个缺点是我们不能使用普通函数组合。我们需要使用 `LinearMap.comp` 或 `∘ₗ` 的符号。
- en: '[PRE139]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'There are two main ways to construct linear maps. First we can build the structure
    by providing the function and the linearity proof. As usual, this is facilitated
    by the structure code action: you can type `example : V →ₗ[K] V := _` and use
    the code action “Generate a skeleton” attached to the underscore.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '构建线性映射主要有两种方法。首先，我们可以通过提供函数和线性证明来构建结构。通常，这可以通过结构代码操作来实现：你可以输入 `example : V
    →ₗ[K] V := _` 并使用附加在下划线上的“生成骨架”代码操作。'
- en: '[PRE140]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: You may wonder why the proof fields of `LinearMap` have names ending with a
    prime. This is because they are defined before the coercion to functions is defined,
    hence they are phrased in terms of `LinearMap.toFun`. Then they are restated as
    `LinearMap.map_add` and `LinearMap.map_smul` in terms of the coercion to function.
    This is not yet the end of the story. One also wants a version of `map_add` that
    applies to any (bundled) map preserving addition, such as additive group morphisms,
    linear maps, continuous linear maps, `K`-algebra maps etc… This one is `map_add`
    (in the root namespace). The intermediate version, `LinearMap.map_add` is a bit
    redundant but allows to use dot notation, which can be nice sometimes. A similar
    story exists for `map_smul`, and the general framework is explained in [Chapter
    8](C08_Hierarchies.html#hierarchies).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么 `LinearMap` 的证明字段以撇号结尾。这是因为它们在定义函数强制转换之前就已经定义了，因此它们是以 `LinearMap.toFun`
    为术语表述的。然后，它们被重新表述为 `LinearMap.map_add` 和 `LinearMap.map_smul`，以函数强制转换的术语表述。但这还不是故事的结尾。人们还希望有一个适用于任何（捆绑的）保持加法的映射的
    `map_add` 版本，例如加法群同态、线性映射、连续线性映射、`K`-代数映射等。这个版本是 `map_add`（在根命名空间中）。中间版本 `LinearMap.map_add`
    有点冗余，但允许使用点符号，这在某些时候可能很方便。对于 `map_smul` 也有类似的故事，并且通用框架在[第8章](C08_Hierarchies.html#hierarchies)中解释。
- en: '[PRE141]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'One can also build linear maps from the ones that are already defined in Mathlib
    using various combinators. For instance the above example is already known as
    `LinearMap.lsmul K V 3`. There are several reason why `K` and `V` are explicit
    arguments here. The most pressing one is that from a bare `LinearMap.lsmul 3`
    there would be no way for Lean to infer `V` or even `K`. But also `LinearMap.lsmul
    K V` is an interesting object by itself: it has type `K →ₗ[K] V →ₗ[K] V`, meaning
    it is a `K`-linear map from `K` —seen as a vector space over itself— to the space
    of `K`-linear maps from `V` to `V`.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以从 Mathlib 中已定义的映射使用各种组合器构建线性映射。例如，上面的例子已经知道是 `LinearMap.lsmul K V 3`。`K`
    和 `V` 在这里作为显式参数有几个原因。最紧迫的一个原因是，从裸 `LinearMap.lsmul 3` 中，Lean 无法推断出 `V` 或甚至 `K`。但
    `LinearMap.lsmul K V` 本身也是一个有趣的对象：它具有类型 `K →ₗ[K] V →ₗ[K] V`，这意味着它是一个从 `K`（被视为自身的向量空间）到
    `V` 到 `V` 的 `K`-线性映射。
- en: '[PRE142]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'There is also a type `LinearEquiv` of linear isomorphisms denoted by `V ≃ₗ[K]
    W`. The inverse of `f : V ≃ₗ[K] W` is `f.symm : W ≃ₗ[K] V`, composition of `f`
    and `g` is `f.trans g` also denoted by `f ≪≫ₗ g`, and the identity isomorphism
    of `V` is `LinearEquiv.refl K V`. Elements of this type are automatically coerced
    to morphisms and functions when necessary.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '还有一个表示线性同构的 `LinearEquiv` 类型，表示为 `V ≃ₗ[K] W`。`f : V ≃ₗ[K] W` 的逆是 `f.symm :
    W ≃ₗ[K] V`，`f` 和 `g` 的组合是 `f.trans g`，也称为 `f ≪≫ₗ g`，恒等同构是 `V` 的 `LinearEquiv.refl
    K V`。当需要时，此类型的元素会自动转换为形态和函数。'
- en: '[PRE143]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: One can use `LinearEquiv.ofBijective` to build an isomorphism from a bijective
    morphism. Doing so makes the inverse function noncomputable.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `LinearEquiv.ofBijective` 从双射映射构建同构。这样做会使逆函数不可计算。
- en: '[PRE144]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Note that in the above example, Lean uses the announced type to understand that
    `.ofBijective` refers to `LinearEquiv.ofBijective` (without needing to open any
    namespace).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上面的例子中，Lean 使用宣布的类型来理解 `.ofBijective` 指的是 `LinearEquiv.ofBijective`（无需打开任何命名空间）。
- en: 10.1.3\. Sums and products of vector spaces[](#sums-and-products-of-vector-spaces
    "Link to this heading")
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3. 向量空间的和与积[](#sums-and-products-of-vector-spaces "链接到这个标题")
- en: We can build new vector spaces out of old ones using direct sums and direct
    products. Let us start with two vectors spaces. In this case there is no difference
    between sum and product, and we can simply use the product type. In the following
    snippet of code we simply show how to get all the structure maps (inclusions and
    projections) as linear maps, as well as the universal properties constructing
    linear maps into products and out of sums (if you are not familiar with the category-theoretic
    distinction between sums and products, you can simply ignore the universal property
    vocabulary and focus on the types of the following examples).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用直接和和直接积从旧向量空间构建新的向量空间。让我们从两个向量空间开始。在这种情况下，和与积之间没有区别，我们可以简单地使用积类型。在下面的代码片段中，我们简单地展示了如何将所有结构映射（包含和投射）作为线性映射来获取，以及构建线性映射到积和从和的通用性质（如果你不熟悉加和与积之间的范畴论区别，你可以简单地忽略通用性质词汇，并关注以下示例的类型）。
- en: '[PRE145]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Let us now turn to sums and products of arbitrary families of vector spaces.
    Here we will simply see how to define a family of vector spaces and access the
    universal properties of sums and products. Note that the direct sum notation is
    scoped to the `DirectSum` namespace, and that the universal property of direct
    sums requires decidable equality on the indexing type (this is somehow an implementation
    accident).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向任意向量空间族的和与积。在这里，我们将简单地看到如何定义一个向量空间族，并访问和与积的通用性质。请注意，直接和的表示法是作用域在`DirectSum`命名空间中，并且直接和的通用性质要求索引类型的可判定等价性（这某种程度上是一个实现上的意外）。
- en: '[PRE146]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 10.1.1\. Vector spaces[](#vector-spaces "Link to this heading")
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1\. 向量空间[](#vector-spaces "链接到这个标题")
- en: We will start directly abstract linear algebra, taking place in a vector space
    over any field. However you can find information about matrices in [Section 10.4.1](#matrices)
    which does not logically depend on this abstract theory. Mathlib actually deals
    with a more general version of linear algebra involving the word module, but for
    now we will pretend this is only an eccentric spelling habit.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接开始抽象线性代数，它发生在任何域上的向量空间中。然而，你可以在[第10.4.1节](#matrices)中找到有关矩阵的信息，这部分内容逻辑上不依赖于这个抽象理论。Mathlib实际上处理的是一个更通用的线性代数版本，涉及到“module”这个词，但到目前为止，我们将假装这仅仅是一个古怪的拼写习惯。
- en: 'The way to say “let \(K\) be a field and let \(V\) be a vector space over \(K\)”
    (and make them implicit arguments to later results) is:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 要说“让\(K\)成为一个域，让\(V\)成为\(K\)上的向量空间”（并将它们作为后续结果的隐含参数）的方式是：
- en: '[PRE147]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: We explained in [Chapter 8](C08_Hierarchies.html#hierarchies) why we need two
    separate typeclasses `[AddCommGroup V] [Module K V]`. The short version is the
    following. Mathematically we want to say that having a \(K\)-vector space structure
    implies having an additive commutative group structure. We could tell this to
    Lean. But then whenever Lean would need to find such a group structure on a type
    \(V\), it would go hunting for vector space structures using a *completely unspecified*
    field \(K\) that cannot be inferred from \(V\). This would be very bad for the
    type class synthesis system.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第8章](C08_Hierarchies.html#hierarchies)中解释了为什么我们需要两个独立的类型类`[AddCommGroup
    V] [Module K V]`。简而言之，从数学上讲，我们想要表达拥有\(K\)-向量空间结构意味着拥有加法交换群结构。我们可以告诉Lean。但然后每当Lean需要在一个类型\(V\)上找到这样的群结构时，它就会使用一个*完全未指定*的域\(K\)来寻找向量空间结构，而这个域\(K\)无法从\(V\)中推断出来。这对类型类综合系统来说是非常糟糕的。
- en: The multiplication of a vector v by a scalar a is denoted by a • v. We list
    a couple of algebraic rules about the interaction of this operation with addition
    in the following examples. Of course simp or apply? would find those proofs. There
    is also a module tactic that solves goals following from the axioms of vector
    spaces and fields, in the same way the ring tactic is used in commutative rings
    or the group tactic is used in groups. But it is still useful to remember that
    scalar multiplication is abbreviated smul in lemma names.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 向量v乘以标量a表示为a • v。我们在以下示例中列出了一些关于此操作与加法交互的代数规则。当然，simp或apply?会找到那些证明。还有一个模块策略，它解决从向量空间和域的公理得出的目标，就像在交换环中使用ring策略或在群中使用group策略一样。但记住标量乘法在引理名称中缩写为smul仍然是有用的。
- en: '[PRE148]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'As a quick note for more advanced readers, let us point out that, as suggested
    by terminology, Mathlib’s linear algebra also covers modules over (not necessarily
    commutative) rings. In fact it even covers semi-modules over semi-rings. If you
    think you do not need this level of generality, you can meditate the following
    example that nicely captures a lot of algebraic rules about ideals acting on submodules:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对更高级读者的快速提示，让我们指出，正如术语所暗示的，Mathlib 的线性代数也涵盖了（不一定交换的）环上的模块。事实上，它甚至涵盖了半环上的半模。如果你认为你不需要这种泛化程度，你可以思考以下示例，它很好地捕捉了关于理想在子模上作用的许多代数规则：
- en: '[PRE149]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 10.1.2\. Linear maps[](#linear-maps "Link to this heading")
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2\. 线性映射[](#linear-maps "链接到本标题")
- en: Next we need linear maps. Like group morphisms, linear maps in Mathlib are bundled
    maps, i.e. packages made of a map and proofs of its linearity properties. Those
    bundled maps are converted to ordinary functions when applied. See [Chapter 8](C08_Hierarchies.html#hierarchies)
    for more information about this design.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要线性映射。与群同态类似，Mathlib 中的线性映射是打包映射，即由映射及其线性性质证明组成的包。当应用时，这些打包映射会被转换为普通函数。有关此设计的更多信息，请参阅[第8章](C08_Hierarchies.html#hierarchies)。
- en: The type of linear maps between two `K`-vector spaces `V` and `W` is denoted
    by `V →ₗ[K] W`. The subscript l stands for linear. At first it may feel odd to
    specify `K` in this notation. But this is crucial when several fields come into
    play. For instance real-linear maps from \(ℂ\) to \(ℂ\) are every map \(z ↦ az
    + b\bar{z}\) while only the maps \(z ↦ az\) are complex linear, and this difference
    is crucial in complex analysis.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `K`-向量空间 `V` 和 `W` 之间的线性映射类型表示为 `V →ₗ[K] W`。下标 l 代表线性。一开始可能觉得在这个符号中指定 `K`
    很奇怪。但这是至关重要的，当涉及多个域时。例如，从 \(ℂ\) 到 \(ℂ\) 的实线性映射是所有形式为 \(z ↦ az + b\bar{z}\) 的映射，而只有形式为
    \(z ↦ az\) 的映射是复线性，这种差异在复分析中至关重要。
- en: '[PRE150]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Note that `V →ₗ[K] W` itself carries interesting algebraic structures (this
    is part of the motivation for bundling those maps). It is a `K`-vector space so
    we can add linear maps and multiply them by scalars.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`V →ₗ[K] W` 本身承载着有趣的代数结构（这是打包这些映射的部分动机）。它是一个 `K`-向量空间，因此我们可以添加线性映射并乘以标量。
- en: '[PRE151]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: One downside of using bundled maps is that we cannot use ordinary function composition.
    We need to use `LinearMap.comp` or the notation `∘ₗ`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 使用打包映射的一个缺点是我们不能使用普通函数组合。我们需要使用 `LinearMap.comp` 或 `∘ₗ` 符号。
- en: '[PRE152]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'There are two main ways to construct linear maps. First we can build the structure
    by providing the function and the linearity proof. As usual, this is facilitated
    by the structure code action: you can type `example : V →ₗ[K] V := _` and use
    the code action “Generate a skeleton” attached to the underscore.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '构建线性映射主要有两种方式。首先，我们可以通过提供函数和线性证明来构建结构。像往常一样，这可以通过结构代码操作来实现：你可以输入 `example :
    V →ₗ[K] V := _` 并使用附加在下划线上的“生成骨架”代码操作。'
- en: '[PRE153]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: You may wonder why the proof fields of `LinearMap` have names ending with a
    prime. This is because they are defined before the coercion to functions is defined,
    hence they are phrased in terms of `LinearMap.toFun`. Then they are restated as
    `LinearMap.map_add` and `LinearMap.map_smul` in terms of the coercion to function.
    This is not yet the end of the story. One also wants a version of `map_add` that
    applies to any (bundled) map preserving addition, such as additive group morphisms,
    linear maps, continuous linear maps, `K`-algebra maps etc… This one is `map_add`
    (in the root namespace). The intermediate version, `LinearMap.map_add` is a bit
    redundant but allows to use dot notation, which can be nice sometimes. A similar
    story exists for `map_smul`, and the general framework is explained in [Chapter
    8](C08_Hierarchies.html#hierarchies).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么 `LinearMap` 的证明字段以撇号结尾。这是因为它们在定义函数强制转换之前就已经定义了，因此它们是以 `LinearMap.toFun`
    为术语表述的。然后，它们被重新表述为 `LinearMap.map_add` 和 `LinearMap.map_smul`，以函数强制转换的术语表述。但这还不是故事的结束。人们还希望有一个适用于任何（打包）保持加法的映射的
    `map_add` 版本，例如加法群同态、线性映射、连续线性映射、`K`-代数映射等。这个版本是 `map_add`（在根命名空间中）。中间版本 `LinearMap.map_add`
    有点冗余，但允许使用点符号，这在某些时候可能很方便。对于 `map_smul` 也有类似的故事，而通用框架在[第8章](C08_Hierarchies.html#hierarchies)中得到了解释。
- en: '[PRE154]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'One can also build linear maps from the ones that are already defined in Mathlib
    using various combinators. For instance the above example is already known as
    `LinearMap.lsmul K V 3`. There are several reason why `K` and `V` are explicit
    arguments here. The most pressing one is that from a bare `LinearMap.lsmul 3`
    there would be no way for Lean to infer `V` or even `K`. But also `LinearMap.lsmul
    K V` is an interesting object by itself: it has type `K →ₗ[K] V →ₗ[K] V`, meaning
    it is a `K`-linear map from `K` —seen as a vector space over itself— to the space
    of `K`-linear maps from `V` to `V`.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以从 Mathlib 中已定义的线性映射中使用各种组合子构建线性映射。例如，上面的例子已经众所周知为 `LinearMap.lsmul K V 3`。`K`
    和 `V` 在这里作为显式参数有几个原因。最紧迫的一个原因是，从裸的 `LinearMap.lsmul 3` 中，Lean 无法推断出 `V` 或甚至 `K`。但
    `LinearMap.lsmul K V` 本身也是一个有趣的对象：它具有类型 `K →ₗ[K] V →ₗ[K] V`，这意味着它是一个从 `K`（被视为自身的向量空间）到
    `V` 到 `V` 的 `K`-线性映射。
- en: '[PRE155]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'There is also a type `LinearEquiv` of linear isomorphisms denoted by `V ≃ₗ[K]
    W`. The inverse of `f : V ≃ₗ[K] W` is `f.symm : W ≃ₗ[K] V`, composition of `f`
    and `g` is `f.trans g` also denoted by `f ≪≫ₗ g`, and the identity isomorphism
    of `V` is `LinearEquiv.refl K V`. Elements of this type are automatically coerced
    to morphisms and functions when necessary.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '还有一个表示为 `V ≃ₗ[K] W` 的线性同构类型 `LinearEquiv`。`f : V ≃ₗ[K] W` 的逆是 `f.symm : W ≃ₗ[K]
    V`，`f` 和 `g` 的组合是 `f.trans g`，也记作 `f ≪≫ₗ g`，恒等同构是 `V` 的 `LinearEquiv.refl K V`。当需要时，此类型元素会自动转换为形态和函数。'
- en: '[PRE156]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: One can use `LinearEquiv.ofBijective` to build an isomorphism from a bijective
    morphism. Doing so makes the inverse function noncomputable.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `LinearEquiv.ofBijective` 从双射形态构建同构。这样做会使逆函数不可计算。
- en: '[PRE157]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Note that in the above example, Lean uses the announced type to understand that
    `.ofBijective` refers to `LinearEquiv.ofBijective` (without needing to open any
    namespace).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上面的例子中，Lean 使用宣布的类型来理解 `.ofBijective` 指的是 `LinearEquiv.ofBijective`（无需打开任何命名空间）。
- en: 10.1.3\. Sums and products of vector spaces[](#sums-and-products-of-vector-spaces
    "Link to this heading")
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3\. 向量空间的和与积[](#sums-and-products-of-vector-spaces "链接到本标题")
- en: We can build new vector spaces out of old ones using direct sums and direct
    products. Let us start with two vectors spaces. In this case there is no difference
    between sum and product, and we can simply use the product type. In the following
    snippet of code we simply show how to get all the structure maps (inclusions and
    projections) as linear maps, as well as the universal properties constructing
    linear maps into products and out of sums (if you are not familiar with the category-theoretic
    distinction between sums and products, you can simply ignore the universal property
    vocabulary and focus on the types of the following examples).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用直接和与直接积从旧向量空间构建新的向量空间。让我们从两个向量空间开始。在这种情况下，和与积之间没有区别，我们可以简单地使用积类型。在下面的代码片段中，我们简单地展示了如何将所有结构映射（包含和投射）作为线性映射来获取，以及构建线性映射到积和从和的通用性质（如果你不熟悉和与积之间的范畴论区别，你可以简单地忽略通用性质词汇，并关注以下示例的类型）。
- en: '[PRE158]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Let us now turn to sums and products of arbitrary families of vector spaces.
    Here we will simply see how to define a family of vector spaces and access the
    universal properties of sums and products. Note that the direct sum notation is
    scoped to the `DirectSum` namespace, and that the universal property of direct
    sums requires decidable equality on the indexing type (this is somehow an implementation
    accident).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在转向任意向量空间族的和与积。在这里，我们将简单地看到如何定义一个向量空间族，并访问和与积的通用性质。请注意，直接和的符号范围限定在 `DirectSum`
    命名空间内，并且直接和的通用性质要求索引类型的可判定等价（这某种程度上是一个实现上的意外）。
- en: '[PRE159]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '## 10.2\. Subspaces and quotients[](#subspaces-and-quotients "Link to this
    heading")'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '## 10.2\. 子空间和商[](#subspaces-and-quotients "链接到本标题")'
- en: 10.2.1\. Subspaces[](#subspaces "Link to this heading")
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1\. 子空间[](#subspaces "链接到本标题")
- en: Just as linear maps are bundled, a linear subspace of `V` is also a bundled
    structure consisting of a set in `V`, called the carrier of the subspace, with
    the relevant closure properties. Again the word module appears instead of vector
    space because of the more general context that Mathlib actually uses for linear
    algebra.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 正如线性映射是打包的，`V` 的线性子空间也是一个打包结构，由 `V` 中的一个集合组成，称为子空间的载体，并具有相关的闭包性质。再次，由于 Mathlib
    实际使用的线性代数更一般的环境，这里出现的是“模块”一词而不是向量空间。
- en: '[PRE160]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: In the example above, it is important to understand that `Submodule K V` is
    the type of `K`-linear subspaces of `V`, rather than a predicate `IsSubmodule
    U` where `U` is an element of `Set V`. `Submodule K V` is endowed with a coercion
    to `Set V` and a membership predicate on `V`. See [Section 8.3](C08_Hierarchies.html#section-hierarchies-subobjects)
    for an explanation of how and why this is done.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，重要的是要理解`Submodule K V`是`V`的`K`-线性子空间类型，而不是一个谓词`IsSubmodule U`，其中`U`是`Set
    V`的一个元素。`Submodule K V`被赋予了到`Set V`的强制转换和`V`上的成员谓词。参见[第8.3节](C08_Hierarchies.html#section-hierarchies-subobjects)以了解如何以及为什么这样做。
- en: Of course, two subspaces are the same if and only if they have the same elements.
    This fact is registered for use with the `ext` tactic, which can be used to prove
    two subspaces are equal in the same way it is used to prove that two sets are
    equal.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果两个子空间具有相同的元素，则它们是相同的。这个事实被注册用于与`ext`策略一起使用，该策略可以用来证明两个子空间相等，就像它被用来证明两个集合相等一样。
- en: To state and prove, for example, that `ℝ` is a `ℝ`-linear subspace of `ℂ`, what
    we really want is to construct a term of type `Submodule ℝ ℂ` whose projection
    to `Set ℂ` is `ℝ`, or, more precisely, the image of `ℝ` in `ℂ`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 要陈述和证明，例如，`ℝ`是`ℂ`的`ℝ`-线性子空间，我们真正想要的是构造一个类型为`Submodule ℝ ℂ`的项，其投影到`Set ℂ`是`ℝ`，或者更精确地说，是`ℝ`在`ℂ`中的像。
- en: '[PRE161]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The prime at the end of proof fields in `Submodule` are analogous to the one
    in `LinearMap`. Those fields are stated in terms of the `carrier` field because
    they are defined before the `MemberShip` instance. They are then superseded by
    `Submodule.add_mem`, `Submodule.zero_mem` and `Submodule.smul_mem` that we saw
    above.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`Submodule`中证明字段末尾的素数与`LinearMap`中的素数类似。这些字段是用`carrier`字段来表述的，因为它们是在`MemberShip`实例之前定义的。然后，它们被上面看到的`Submodule.add_mem`、`Submodule.zero_mem`和`Submodule.smul_mem`所取代。'
- en: As an exercise in manipulating subspaces and linear maps, you will define the
    pre-image of a subspace by a linear map (of course we will see below that Mathlib
    already knows about this). Remember that `Set.mem_preimage` can be used to rewrite
    a statement involving membership and preimage. This is the only lemma you will
    need in addition to the lemmas discussed above about `LinearMap` and `Submodule`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作子空间和线性映射的练习，你将通过线性映射定义子空间的逆像（当然，我们将在下面看到Mathlib已经知道这一点）。记住，`Set.mem_preimage`可以用来重写涉及成员和逆像的陈述。除了上面讨论的关于`LinearMap`和`Submodule`的引理之外，你只需要这个引理。
- en: '[PRE162]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Using type classes, Mathlib knows that a subspace of a vector space inherits
    a vector space structure.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型类，Mathlib知道向量空间的子空间继承了向量空间结构。
- en: '[PRE163]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'This example is subtle. The object `U` is not a type, but Lean automatically
    coerces it to a type by interpreting it as a subtype of `V`. So the above example
    can be restated more explicitly as:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很微妙。对象`U`不是一个类型，但Lean会自动将其解释为`V`的子类型，从而将其强制转换为类型。因此，上面的例子可以更明确地重述如下：
- en: '[PRE164]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 10.2.2\. Complete lattice structure and internal direct sums[](#complete-lattice-structure-and-internal-direct-sums
    "Link to this heading")
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2. 完备格结构和内部直和[](#complete-lattice-structure-and-internal-direct-sums "链接到本标题")
- en: 'An important benefit of having a type `Submodule K V` instead of a predicate
    `IsSubmodule : Set V → Prop` is that one can easily endow `Submodule K V` with
    additional structure. Importantly, it has the structure of a complete lattice
    structure with respect to inclusion. For instance, instead of having a lemma stating
    that an intersection of two subspaces of `V` is again a subspace, we use the lattice
    operation `⊓` to construct the intersection. We can then apply arbitrary lemmas
    about lattices to the construction.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '使用类型`Submodule K V`而不是谓词`IsSubmodule : Set V → Prop`的一个重要好处是，可以轻松地为`Submodule
    K V`赋予额外的结构。重要的是，它具有关于包含的完备格结构。例如，我们不是通过一个引理来声明`V`的两个子空间交集仍然是子空间，而是使用格运算`⊓`来构造交集。然后我们可以将关于格的任意引理应用于构造过程。'
- en: Let us check that the set underlying the infimum of two subspaces is indeed,
    by definition, their intersection.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证两个子空间下确界所对应的集合确实，按照定义，是它们的交集。
- en: '[PRE165]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: It may look strange to have a different notation for what amounts to the intersection
    of the underlying sets, but the correspondence does not carry over to the supremum
    operation and set union, since a union of subspaces is not, in general, a subspace.
    Instead one needs to use the subspace generated by the union, which is done using
    `Submodule.span`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 对于底层集合的交集，使用不同的符号可能看起来有些奇怪，但这种对应关系并不适用于上确界操作和集合的并集，因为子空间的并集在一般情况下不是子空间。相反，需要使用由并集生成的子空间，这可以通过`Submodule.span`来实现。
- en: '[PRE166]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Another subtlety is that `V` itself does not have type `Submodule K V`, so
    we need a way to talk about `V` seen as a subspace of `V`. This is also provided
    by the lattice structure: the full subspace is the top element of this lattice.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个微妙之处在于`V`本身不具有类型`Submodule K V`，因此我们需要一种方式来谈论`V`作为`V`的子空间。这也由格结构提供：整个子空间是这个格的顶部元素。
- en: '[PRE167]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Similarly the bottom element of this lattice is the subspace whose only element
    is the zero element.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个格的底部元素是只包含零元素的子空间。
- en: '[PRE168]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: In particular we can discuss the case of subspaces that are in (internal) direct
    sum. In the case of two subspaces, we use the general purpose predicate `IsCompl`
    which makes sense for any bounded partially ordered type. In the case of general
    families of subspaces we use `DirectSum.IsInternal`.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，我们可以讨论那些在（内部）直和中的子空间的情况。在两个子空间的情况下，我们使用通用谓词`IsCompl`，它对任何有界偏序类型都有意义。在一般子空间族的情况下，我们使用`DirectSum.IsInternal`。
- en: '[PRE169]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 10.2.3\. Subspace spanned by a set[](#subspace-spanned-by-a-set "Link to this
    heading")
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3\. 由一组基生成的子空间[](#subspace-spanned-by-a-set "链接到本标题")
- en: In addition to building subspaces out of existing subspaces, we can build them
    out of any set `s` using `Submodule.span K s` which builds the smallest subspace
    containing `s`. On paper it is common to use that this space is made of all linear
    combinations of elements of `s`. But it is often more efficient to use its universal
    property expressed by `Submodule.span_le`, and the whole theory of Galois connections.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从现有的子空间构建子空间之外，我们还可以使用`Submodule.span K s`从任何集合`s`构建子空间，它构建包含`s`的最小子空间。在纸上，通常使用这个空间由`s`的元素的所有线性组合构成。但通常更有效的是使用其由`Submodule.span_le`表达的通用性质，以及整个Galois连接理论。
- en: '[PRE170]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: When those are not enough, one can use the relevant induction principle `Submodule.span_induction`
    which ensures a property holds for every element of the span of `s` as long as
    it holds on `zero` and elements of `s` and is stable under sum and scalar multiplication.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些还不够时，可以使用相关的归纳原理`Submodule.span_induction`，它确保只要在`zero`和`s`的元素上成立，并且对加法和数乘稳定，那么对于`s`的生成空间中的每个元素都成立该性质。
- en: As an exercise, let us reprove one implication of `Submodule.mem_sup`. Remember
    that you can use the module tactic to close goals that follow from the axioms
    relating the various algebraic operations on `V`.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，让我们重新证明`Submodule.mem_sup`的一个蕴含。记住，你可以使用模块策略来关闭由与`V`上各种代数操作相关的公理得出的目标。
- en: '[PRE171]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 10.2.4\. Pushing and pulling subspaces[](#pushing-and-pulling-subspaces "Link
    to this heading")
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4\. 推拉子空间[](#pushing-and-pulling-subspaces "链接到本标题")
- en: As promised earlier, we now describe how to push and pull subspaces by linear
    maps. As usual in Mathlib, the first operation is called `map` and the second
    one is called `comap`.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们现在描述如何通过线性映射来推拉子空间。在Mathlib中，通常第一个操作称为`map`，第二个操作称为`comap`。
- en: '[PRE172]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Note those live in the `Submodule` namespace so one can use dot notation and
    write `E.map φ` instead of `Submodule.map φ E`, but this is pretty awkward to
    read (although some Mathlib contributors use this spelling).
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这些操作位于`Submodule`命名空间中，因此可以使用点符号，并可以写作`E.map φ`而不是`Submodule.map φ E`，但这读起来相当笨拙（尽管一些Mathlib贡献者使用这种拼写）。
- en: In particular the range and kernel of a linear map are subspaces. Those special
    cases are important enough to get declarations.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，线性映射的范围和核是子空间。这些特殊情况很重要，足以得到声明。
- en: '[PRE173]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Note that we cannot write `φ.ker` instead of `LinearMap.ker φ` because `LinearMap.ker`
    also applies to classes of maps preserving more structure, hence it does not expect
    an argument whose type starts with `LinearMap`, hence dot notation doesn’t work
    here. However we were able to use the other flavor of dot notation in the right-hand
    side. Because Lean expects a term with type `Submodule K V` after elaborating
    the left-hand side, it interprets `.comap` as `Submodule.comap`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不能用 `φ.ker` 代替 `LinearMap.ker φ`，因为 `LinearMap.ker` 也适用于保持更多结构的映射类，因此它不期望一个以
    `LinearMap` 开头的类型的参数，因此点符号在这里不适用。然而，我们能够在右侧使用另一种点符号。因为 Lean 在展开左侧之后期望一个类型为 `Submodule
    K V` 的项，它将 `.comap` 解释为 `Submodule.comap`。
- en: The following lemmas give the key relations between those submodule and the
    properties of `φ`.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 以下引理给出了这些子模块与 `φ` 的性质之间的关键关系。
- en: '[PRE174]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: As an exercise, let us prove the Galois connection property for `map` and `comap`.
    One can use the following lemmas but this is not required since they are true
    by definition.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，让我们证明 `map` 和 `comap` 的伽罗瓦连接性质。可以使用以下引理，但这不是必需的，因为它们是按定义成立的。
- en: '[PRE175]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 10.2.5\. Quotient spaces[](#quotient-spaces "Link to this heading")
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.5\. 商空间[](#quotient-spaces "链接到这个标题")
- en: Quotient vector spaces use the general quotient notation (typed with `\quot`,
    not the ordinary `/`). The projection onto a quotient space is `Submodule.mkQ`
    and the universal property is `Submodule.liftQ`.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 商向量空间使用通用的商符号（使用 `\quot` 输入，而不是普通的 `/`）。商空间的投影是 `Submodule.mkQ`，而其泛性质是 `Submodule.liftQ`。
- en: '[PRE176]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: As an exercise, let us prove the correspondence theorem for subspaces of quotient
    spaces. Mathlib knows a slightly more precise version as `Submodule.comapMkQRelIso`.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，让我们证明商空间的子空间的对应定理。Mathlib 知道一个稍微更精确的版本，作为 `Submodule.comapMkQRelIso`。
- en: '[PRE177]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 10.2.1\. Subspaces[](#subspaces "Link to this heading")
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1\. 子空间[](#subspaces "链接到这个标题")
- en: Just as linear maps are bundled, a linear subspace of `V` is also a bundled
    structure consisting of a set in `V`, called the carrier of the subspace, with
    the relevant closure properties. Again the word module appears instead of vector
    space because of the more general context that Mathlib actually uses for linear
    algebra.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 正如线性映射被封装一样，`V` 的线性子空间也是一个封装的结构，由 `V` 中的一个集合组成，称为子空间的载体，并具有相关的闭包性质。再次使用“模块”这个词而不是向量空间，是因为
    Mathlib 实际上用于线性代数的更一般上下文。
- en: '[PRE178]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: In the example above, it is important to understand that `Submodule K V` is
    the type of `K`-linear subspaces of `V`, rather than a predicate `IsSubmodule
    U` where `U` is an element of `Set V`. `Submodule K V` is endowed with a coercion
    to `Set V` and a membership predicate on `V`. See [Section 8.3](C08_Hierarchies.html#section-hierarchies-subobjects)
    for an explanation of how and why this is done.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，重要的是要理解 `Submodule K V` 是 `V` 的 `K`-线性子空间的类型，而不是一个 `IsSubmodule U` 的谓词，其中
    `U` 是 `Set V` 的一个元素。`Submodule K V` 被赋予了到 `Set V` 的强制转换和 `V` 上的成员谓词。参见 [第 8.3
    节](C08_Hierarchies.html#section-hierarchies-subobjects) 了解如何以及为什么这样做。
- en: Of course, two subspaces are the same if and only if they have the same elements.
    This fact is registered for use with the `ext` tactic, which can be used to prove
    two subspaces are equal in the same way it is used to prove that two sets are
    equal.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果两个子空间具有相同的元素，则它们是相同的。这个事实被注册用于 `ext` 策略，它可以用来证明两个子空间相等，就像它被用来证明两个集合相等一样。
- en: To state and prove, for example, that `ℝ` is a `ℝ`-linear subspace of `ℂ`, what
    we really want is to construct a term of type `Submodule ℝ ℂ` whose projection
    to `Set ℂ` is `ℝ`, or, more precisely, the image of `ℝ` in `ℂ`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了陈述和证明 `ℝ` 是 `ℂ` 的 `ℝ`-线性子空间，我们真正想要的是构造一个类型为 `Submodule ℝ ℂ` 的项，其投影到 `Set
    ℂ` 是 `ℝ`，或者更精确地说，是 `ℝ` 在 `ℂ` 中的像。
- en: '[PRE179]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: The prime at the end of proof fields in `Submodule` are analogous to the one
    in `LinearMap`. Those fields are stated in terms of the `carrier` field because
    they are defined before the `MemberShip` instance. They are then superseded by
    `Submodule.add_mem`, `Submodule.zero_mem` and `Submodule.smul_mem` that we saw
    above.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`Submodule` 中证明字段末尾的素数与 `LinearMap` 中的类似。这些字段是用 `carrier` 字段来表述的，因为它们是在 `MemberShip`
    实例之前定义的。然后，它们被我们上面看到的 `Submodule.add_mem`、`Submodule.zero_mem` 和 `Submodule.smul_mem`
    所取代。'
- en: As an exercise in manipulating subspaces and linear maps, you will define the
    pre-image of a subspace by a linear map (of course we will see below that Mathlib
    already knows about this). Remember that `Set.mem_preimage` can be used to rewrite
    a statement involving membership and preimage. This is the only lemma you will
    need in addition to the lemmas discussed above about `LinearMap` and `Submodule`.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作子空间和线性映射的练习，你将定义由线性映射（当然，我们将在下面看到Mathlib已经知道这一点）生成的子空间的逆像。记住，可以使用`Set.mem_preimage`来重写涉及成员和逆像的陈述。这是除了上面讨论的关于`LinearMap`和`Submodule`的引理之外，你将需要的唯一引理。
- en: '[PRE180]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Using type classes, Mathlib knows that a subspace of a vector space inherits
    a vector space structure.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型类，Mathlib知道向量空间的子空间继承了向量空间的结构。
- en: '[PRE181]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'This example is subtle. The object `U` is not a type, but Lean automatically
    coerces it to a type by interpreting it as a subtype of `V`. So the above example
    can be restated more explicitly as:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很微妙。对象`U`不是一个类型，但Lean会自动将其解释为`V`的子类型，将其转换为类型。因此，上面的例子可以更明确地表述为：
- en: '[PRE182]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 10.2.2\. Complete lattice structure and internal direct sums[](#complete-lattice-structure-and-internal-direct-sums
    "Link to this heading")
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2\. 完全格结构和内部直接和[](#complete-lattice-structure-and-internal-direct-sums
    "链接到本标题")
- en: 'An important benefit of having a type `Submodule K V` instead of a predicate
    `IsSubmodule : Set V → Prop` is that one can easily endow `Submodule K V` with
    additional structure. Importantly, it has the structure of a complete lattice
    structure with respect to inclusion. For instance, instead of having a lemma stating
    that an intersection of two subspaces of `V` is again a subspace, we use the lattice
    operation `⊓` to construct the intersection. We can then apply arbitrary lemmas
    about lattices to the construction.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '使用类型`Submodule K V`而不是谓词`IsSubmodule : Set V → Prop`的一个重要好处是，可以轻松地为`Submodule
    K V`赋予额外的结构。重要的是，它具有关于包含的完全格结构。例如，我们不是用一条断言两个`V`的子空间的交集仍然是子空间的引理，而是使用格运算`⊓`来构造交集。然后我们可以将关于格的任意引理应用于构造过程。'
- en: Let us check that the set underlying the infimum of two subspaces is indeed,
    by definition, their intersection.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证两个子空间下确界的底层集合确实按照定义是它们的交集。
- en: '[PRE183]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: It may look strange to have a different notation for what amounts to the intersection
    of the underlying sets, but the correspondence does not carry over to the supremum
    operation and set union, since a union of subspaces is not, in general, a subspace.
    Instead one needs to use the subspace generated by the union, which is done using
    `Submodule.span`.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 对于底层集合的交集使用不同的符号可能看起来有些奇怪，但这种对应关系并不适用于上确界运算和集合的并集，因为子空间的并集在一般情况下不是子空间。相反，需要使用由并集生成的子空间，这可以通过使用`Submodule.span`来完成。
- en: '[PRE184]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Another subtlety is that `V` itself does not have type `Submodule K V`, so
    we need a way to talk about `V` seen as a subspace of `V`. This is also provided
    by the lattice structure: the full subspace is the top element of this lattice.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个微妙之处在于`V`本身不具有类型`Submodule K V`，因此我们需要一种方式来谈论`V`作为`V`的子空间。这也由格结构提供：整个子空间是这个格的顶元素。
- en: '[PRE185]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Similarly the bottom element of this lattice is the subspace whose only element
    is the zero element.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，这个格的底元素是只包含零元素的子空间。
- en: '[PRE186]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: In particular we can discuss the case of subspaces that are in (internal) direct
    sum. In the case of two subspaces, we use the general purpose predicate `IsCompl`
    which makes sense for any bounded partially ordered type. In the case of general
    families of subspaces we use `DirectSum.IsInternal`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们可以讨论（内部）直接和的子空间的情况。在两个子空间的情况下，我们使用适用于任何有界偏序类型的通用谓词`IsCompl`。在一般子空间族的情况下，我们使用`DirectSum.IsInternal`。
- en: '[PRE187]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 10.2.3\. Subspace spanned by a set[](#subspace-spanned-by-a-set "Link to this
    heading")
  id: totrans-513
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3\. 由集合生成的子空间[](#subspace-spanned-by-a-set "链接到本标题")
- en: In addition to building subspaces out of existing subspaces, we can build them
    out of any set `s` using `Submodule.span K s` which builds the smallest subspace
    containing `s`. On paper it is common to use that this space is made of all linear
    combinations of elements of `s`. But it is often more efficient to use its universal
    property expressed by `Submodule.span_le`, and the whole theory of Galois connections.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从现有的子空间构建子空间之外，我们还可以使用`Submodule.span K s`从任何集合`s`构建子空间，它构建包含`s`的最小子空间。在纸上，通常使用这个空间由`s`的元素的所有线性组合构成。但通常更有效的是使用其通过`Submodule.span_le`表达的通用性质，以及Galois连接的全套理论。
- en: '[PRE188]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: When those are not enough, one can use the relevant induction principle `Submodule.span_induction`
    which ensures a property holds for every element of the span of `s` as long as
    it holds on `zero` and elements of `s` and is stable under sum and scalar multiplication.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些不够用时，可以使用相关的归纳原理 `Submodule.span_induction`，该原理确保只要在 `zero` 和 `s` 的元素上成立，并且对和以及标量乘法稳定，那么该性质就适用于
    `s` 的张量积的每个元素。
- en: As an exercise, let us reprove one implication of `Submodule.mem_sup`. Remember
    that you can use the module tactic to close goals that follow from the axioms
    relating the various algebraic operations on `V`.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，让我们重新证明 `Submodule.mem_sup` 的一个推论。记住，你可以使用模块策略来关闭由与 `V` 上的各种代数操作相关的公理得出的目标。
- en: '[PRE189]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 10.2.4\. Pushing and pulling subspaces[](#pushing-and-pulling-subspaces "Link
    to this heading")
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4\. 推进和拉回子空间[](#pushing-and-pulling-subspaces "链接到本标题")
- en: As promised earlier, we now describe how to push and pull subspaces by linear
    maps. As usual in Mathlib, the first operation is called `map` and the second
    one is called `comap`.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们现在描述如何通过线性映射推进和拉回子空间。在 Mathlib 中，通常第一个操作称为 `map`，第二个操作称为 `comap`。
- en: '[PRE190]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Note those live in the `Submodule` namespace so one can use dot notation and
    write `E.map φ` instead of `Submodule.map φ E`, but this is pretty awkward to
    read (although some Mathlib contributors use this spelling).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些位于 `Submodule` 命名空间中，因此可以使用点符号，并可以写 `E.map φ` 而不是 `Submodule.map φ E`，但这读起来相当笨拙（尽管一些
    Mathlib 贡献者使用这种拼写）。
- en: In particular the range and kernel of a linear map are subspaces. Those special
    cases are important enough to get declarations.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，线性映射的值域和核是子空间。这些特殊情况很重要，足以获得声明。
- en: '[PRE191]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Note that we cannot write `φ.ker` instead of `LinearMap.ker φ` because `LinearMap.ker`
    also applies to classes of maps preserving more structure, hence it does not expect
    an argument whose type starts with `LinearMap`, hence dot notation doesn’t work
    here. However we were able to use the other flavor of dot notation in the right-hand
    side. Because Lean expects a term with type `Submodule K V` after elaborating
    the left-hand side, it interprets `.comap` as `Submodule.comap`.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不能写 `φ.ker` 而不是 `LinearMap.ker φ`，因为 `LinearMap.ker` 也适用于保持更多结构的映射类，因此它不期望一个以
    `LinearMap` 开头的类型作为参数，因此点符号在这里不适用。然而，我们能够在右侧使用另一种点符号。因为 Lean 预期在展开左侧之后，有一个类型为
    `Submodule K V` 的项，它将 `.comap` 解释为 `Submodule.comap`。
- en: The following lemmas give the key relations between those submodule and the
    properties of `φ`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 以下引理给出了这些子模块与 `φ` 的性质之间的关键关系。
- en: '[PRE192]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: As an exercise, let us prove the Galois connection property for `map` and `comap`.
    One can use the following lemmas but this is not required since they are true
    by definition.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，让我们证明 `map` 和 `comap` 的 Galois 关联性质。可以使用以下引理，但这不是必需的，因为它们是按定义成立的。
- en: '[PRE193]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 10.2.5\. Quotient spaces[](#quotient-spaces "Link to this heading")
  id: totrans-530
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.5\. 商空间[](#quotient-spaces "链接到本标题")
- en: Quotient vector spaces use the general quotient notation (typed with `\quot`,
    not the ordinary `/`). The projection onto a quotient space is `Submodule.mkQ`
    and the universal property is `Submodule.liftQ`.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 商向量空间使用通用的商符号（使用 `\quot` 打印，而不是普通 `/`）。商空间的投影是 `Submodule.mkQ`，其通用性质是 `Submodule.liftQ`。
- en: '[PRE194]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: As an exercise, let us prove the correspondence theorem for subspaces of quotient
    spaces. Mathlib knows a slightly more precise version as `Submodule.comapMkQRelIso`.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，让我们证明商空间子空间的对应定理。Mathlib 知道一个稍微更精确的版本，即 `Submodule.comapMkQRelIso`。
- en: '[PRE195]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 10.3\. Endomorphisms[](#endomorphisms "Link to this heading")
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3\. 内射[](#endomorphisms "链接到本标题")
- en: 'An important special case of linear maps are endomorphisms: linear maps from
    a vector space to itself. They are interesting because they form a `K`-algebra.
    In particular we can evaluate polynomials with coefficients in `K` on them, and
    they can have eigenvalues and eigenvectors.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 线性映射的一个重要特殊情况是内射：从向量空间到自身的线性映射。它们很有趣，因为它们形成一个 `K`-代数。特别是，我们可以在它们上评估系数在 `K` 中的多项式，并且它们可以有特征值和特征向量。
- en: Mathlib uses the abbreviation `Module.End K V := V →ₗ[K] V` which is convenient
    when using a lot of these (especially after opening the `Module` namespace).
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: Mathlib 使用缩写 `Module.End K V := V →ₗ[K] V`，这在使用很多这些（特别是在打开 `Module` 命名空间之后）时很方便。
- en: '[PRE196]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'As an exercise manipulating endomorphisms, subspaces and polynomials, let us
    prove the (binary) kernels lemma: for any endomorphism \(φ\) and any two relatively
    prime polynomials \(P\) and \(Q\), we have \(\ker P(φ) ⊕ \ker Q(φ) = \ker \big(PQ(φ)\big)\).'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作内射、子空间和多项式的练习，让我们证明（二元的）核引理：对于任何内射 \(φ\) 和任意两个互质的代数多项式 \(P\) 和 \(Q\)，我们有
    \(\ker P(φ) ⊕ \ker Q(φ) = \ker \big(PQ(φ)\big)\)。
- en: Note that `IsCoprime x y` is defined as `∃ a b, a * x + b * y = 1`.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`IsCoprime x y` 被定义为 `∃ a b, a * x + b * y = 1`。
- en: '[PRE197]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: We now move to the discussions of eigenspaces and eigenvalues. The eigenspace
    associated to an endomorphism \(φ\) and a scalar \(a\) is the kernel of \(φ -
    aId\). Eigenspaces are defined for all values of `a`, although they are interesting
    only when they are non-zero. However an eigenvector is, by definition, a non-zero
    element of an eigenspace. The corresponding predicate is `End.HasEigenvector`.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在转向对特征空间和特征值的讨论。与内射 \(φ\) 和标量 \(a\) 相关的特征空间是 \(φ - aId\) 的核。特征空间对所有 `a` 的值都定义，尽管它们只有在非零时才有意义。然而，根据定义，特征向量是特征空间中的非零元素。相应的谓词是
    `End.HasEigenvector`。
- en: '[PRE198]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Then there is a predicate `End.HasEigenvalue` and the corresponding subtype
    `End.Eigenvalues`.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 然后有一个谓词 `End.HasEigenvalue` 和相应的子类型 `End.Eigenvalues`。
- en: '[PRE199]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '## 10.4\. Matrices, bases and dimension[](#matrices-bases-and-dimension "Link
    to this heading")'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '## 10.4\. 矩阵、基和维度[](#matrices-bases-and-dimension "链接到这个标题")'
- en: '### 10.4.1\. Matrices[](#matrices "Link to this heading")'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '### 10.4.1\. 矩阵[](#matrices "链接到这个标题")'
- en: Before introducing bases for abstract vector spaces, we go back to the much
    more elementary setup of linear algebra in \(K^n\) for some field \(K\). Here
    the main objects are vectors and matrices. For concrete vectors, one can use the
    `![…]` notation, where components are separated by commas. For concrete matrices
    we can use the `!![…]` notation, lines are separated by semi-colons and components
    of lines are separated by colons. When entries have a computable type such as
    `ℕ` or `ℚ`, we can use the `eval` command to play with basic operations.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍抽象向量空间的基之前，我们回顾一下对于某个域 \(K\) 的 \(K^n\) 中的线性代数的基础设置。在这里，主要对象是向量和矩阵。对于具体的向量，可以使用
    `![…]` 符号，其中分量由逗号分隔。对于具体的矩阵，我们可以使用 `!![…]` 符号，行由分号分隔，而行内的分量由冒号分隔。当项具有可计算类型，如 `ℕ`
    或 `ℚ` 时，我们可以使用 `eval` 命令来进行基本操作。
- en: '[PRE200]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: It is important to understand that this use of `#eval` is interesting only for
    exploration, it is not meant to replace a computer algebra system such as Sage.
    The data representation used here for matrices is *not* computationally efficient
    in any way. It uses functions instead of arrays and is optimized for proving,
    not computing. The virtual machine used by `#eval` is also not optimized for this
    use.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解这种 `#eval` 的使用仅对探索有趣，它不是用来取代像 Sage 这样的计算机代数系统的。这里用于矩阵的数据表示在任何方面都不是计算高效的。它使用函数而不是数组，并且优化于证明，而不是计算。`#eval`
    所使用的虚拟机也不是为此用途优化的。
- en: Beware the matrix notation list rows but the vector notation is neither a row
    vector nor a column vector. Multiplication of a matrix with a vector from the
    left (resp. right) interprets the vector as a row (resp. column) vector. This
    corresponds to operations `Matrix.vecMul`, with notation `ᵥ*` and `Matrix.mulVec`,
    with notation ` *ᵥ`. Those notations are scoped in the `Matrix` namespace that
    we therefore need to open.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 警惕矩阵表示法列表行，但向量表示法既不是行向量也不是列向量。从左（分别）乘以矩阵的向量将向量解释为行（分别）向量。这对应于 `Matrix.vecMul`
    操作，符号为 `ᵥ*`，以及 `Matrix.mulVec` 操作，符号为 ` *ᵥ`。这些符号在 `Matrix` 命名空间中定义，因此我们需要打开它。
- en: '[PRE201]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: In order to generate matrices with identical rows or columns specified by a
    vector, we use `Matrix.replicateRow` and `Matrix.replicateCol`, with arguments
    the type indexing the rows or columns and the vector. For instance one can get
    single row or single column matrixes (more precisely matrices whose rows or columns
    are indexed by `Fin 1`).
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成具有由向量指定的相同行或列的矩阵，我们使用 `Matrix.replicateRow` 和 `Matrix.replicateCol`，其中参数是索引行或列的类型和向量。例如，可以得到单行或单列矩阵（更精确地说，行或列由
    `Fin 1` 索引的矩阵）。
- en: '[PRE202]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Other familiar operations include the vector dot product, matrix transpose,
    and, for square matrices, determinant and trace.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 其他熟悉的操作包括向量点积、矩阵转置，对于方阵，还有行列式和迹。
- en: '[PRE203]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: When entries do not have a computable type, for instance if they are real numbers,
    we cannot hope that `#eval` can help. Also this kind of evaluation cannot be used
    in proofs without considerably expanding the trusted code base (i.e. the part
    of Lean that you need to trust when checking proofs).
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 当条目没有可计算的类型时，例如如果它们是实数，我们无法期望 `#eval` 能有所帮助。此外，这种评估不能在没有显著扩大可信代码库（即检查证明时需要信任的
    Lean 的部分）的情况下用于证明。
- en: So it is good to also use the `simp` and `norm_num` tactics in proofs, or their
    command counter-part for quick exploration.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在证明中也使用 `simp` 和 `norm_num` 策略，或者它们的命令对应物进行快速探索是很好的。
- en: '[PRE204]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: The next important operation on square matrices is inversion. In the same way
    as division of numbers is always defined and returns the artificial value zero
    for division by zero, the inversion operation is defined on all matrices and returns
    the zero matrix for non-invertible matrices.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 平方矩阵上的下一个重要操作是求逆。与数的除法总是定义并返回除以零的人工值零一样，求逆操作在所有矩阵上定义，对于不可逆矩阵返回零矩阵。
- en: More precisely, there is general function `Ring.inverse` that does this in any
    ring, and, for any matrix `A`, `A⁻¹` is defined as `Ring.inverse A.det • A.adjugate`.
    According to Cramer’s rule, this is indeed the inverse of `A` when the determinant
    of `A` is not zero.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，有一个通用的函数 `Ring.inverse` 在任何环中执行此操作，并且对于任何矩阵 `A`，`A⁻¹` 被定义为 `Ring.inverse
    A.det • A.adjugate`。根据克莱姆法则，当 `A` 的行列式不为零时，这确实是 `A` 的逆。
- en: '[PRE205]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Of course this definition is really useful only for invertible matrices. There
    is a general type class `Invertible` that helps recording this. For instance,
    the `simp` call in the next example will use the `inv_mul_of_invertible` lemma
    which has an `Invertible` type-class assumption, so it will trigger only if this
    can be found by the type-class synthesis system. Here we make this fact available
    using a `have` statement.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种定义真正有用的只有对于可逆矩阵。有一个通用的类型类 `Invertible` 帮助记录这一点。例如，下一个例子中的 `simp` 调用将使用具有
    `Invertible` 类型类假设的 `inv_mul_of_invertible` 引理，因此只有在类型类合成系统可以找到它的情况下才会触发。在这里，我们使用
    `have` 陈述使这一事实可用。
- en: '[PRE206]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'In this fully concrete case, we could also use the `norm_num` machinery, and
    `apply?` to find the final line:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个完全具体的情况下，我们也可以使用 `norm_num` 机制和 `apply?` 来找到最终行：
- en: '[PRE207]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: All the concrete matrices above have their rows and columns indexed by `Fin
    n` for some `n` (not necessarily the same for rows and columns). But sometimes
    it is more convenient to index matrices using arbitrary finite types. For instance
    the adjacency matrix of a finite graph has rows and columns naturally indexed
    by the vertices of the graph.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的所有具体矩阵都有它们的行和列由 `Fin n`（对于某个 `n`，行和列不一定相同）索引。但有时使用任意有限类型索引矩阵更为方便。例如，有限图的邻接矩阵的行和列自然由图的顶点索引。
- en: In fact when simply wants to define matrices without defining any operation
    on them, finiteness of the indexing types are not even needed, and coefficients
    can have any type, without any algebraic structure. So Mathlib simply defines
    `Matrix m n α` to be `m → n → α` for any types `m`, `n` and `α`, and the matrices
    we have been using so far had types such as `Matrix (Fin 2) (Fin 2) ℝ`. Of course
    algebraic operations require more assumptions on `m`, `n` and `α`.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当仅仅想要定义矩阵而不在它们上定义任何操作时，索引类型的有限性甚至都不需要，系数可以有任何类型，而不需要任何代数结构。因此，Mathlib 简单地将
    `Matrix m n α` 定义为 `m → n → α`，对于任何类型 `m`、`n` 和 `α`，而我们迄今为止所使用的矩阵类型如 `Matrix (Fin
    2) (Fin 2) ℝ`。当然，代数操作需要对 `m`、`n` 和 `α` 有更多的假设。
- en: Note the main reason why we do not use `m → n → α` directly is to allow the
    type class system to understand what we want. For instance, for a ring `R`, the
    type `n → R` is endowed with the point-wise multiplication operation, and similarly
    `m → n → R` has this operation which is *not* the multiplication we want on matrices.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们不直接使用 `m → n → α` 的主要原因是为了让类型类系统理解我们的意图。例如，对于环 `R`，类型 `n → R` 被赋予了点积乘法操作，同样
    `m → n → R` 也有这种操作，但这不是我们在矩阵上想要的乘法。
- en: In the first example below, we force Lean to see through the definition of `Matrix`
    and accept the statement as meaningful, and then prove it by checking all entries.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的第一个例子中，我们迫使 Lean 看透 `Matrix` 的定义，并接受该陈述是有意义的，然后通过检查所有条目来证明它。
- en: But then the next two examples reveal that Lean uses the point-wise multiplication
    on `Fin 2 → Fin 2 → ℤ` but the matrix multiplication on `Matrix (Fin 2) (Fin 2)
    ℤ`.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 但接下来的两个例子揭示了 Lean 在 `Fin 2 → Fin 2 → ℤ` 上使用点积乘法，但在 `Matrix (Fin 2) (Fin 2) ℤ`
    上使用矩阵乘法。
- en: '[PRE208]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: In order to define matrices as functions without losing the benefits of `Matrix`
    for type class synthesis, we can use the equivalence `Matrix.of` between functions
    and matrices. This equivalence is secretly defined using `Equiv.refl`.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义矩阵作为函数而不失去 `Matrix` 类型类综合的好处，我们可以使用函数和矩阵之间的等价性 `Matrix.of`。这个等价性实际上是通过使用
    `Equiv.refl` 来秘密定义的。
- en: For instance we can define Vandermonde matrices corresponding to a vector `v`.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义与向量 `v` 对应的范德蒙德矩阵。
- en: '[PRE209]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 10.4.2\. Bases[](#bases "Link to this heading")
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2\. 基[](#bases "链接到这个标题")
- en: We now want to discuss bases of vector spaces. Informally there are many ways
    to define this notion. One can use a universal property. One can say a basis is
    a family of vectors that is linearly independent and spanning. Or one can combine
    those properties and directly say that a basis is a family of vectors such that
    every vectors can be written uniquely as a linear combination of bases vectors.
    Yet another way to say it is that a basis provides a linear isomorphism with a
    power of the base field `K`, seen as a vector space over `K`.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想讨论向量空间的基。非正式地说，有定义这个概念的好几种方法。人们可以使用一个通用属性。人们可以说一个基是一组线性无关且张成的向量。或者人们可以结合这些属性，直接说一个基是一组向量，每个向量都可以唯一地表示为基向量的线性组合。还有一种说法是，基提供了一个与基域
    `K` 的幂的线性同构，`K` 被视为 `K` 上的向量空间。
- en: 'This isomorphism version is actually the one that Mathlib uses as a definition
    under the hood, and other characterizations are proven from it. One must be slightly
    careful with the “power of `K`” idea in the case of infinite bases. Indeed only
    finite linear combinations make sense in this algebraic context. So what we need
    as a reference vector space is not a direct product of copies of `K` but a direct
    sum. We could use `⨁ i : ι, K` for some type `ι` indexing the basis But we rather
    use the more specialized spelling `ι →₀ K` which means “functions from `ι` to
    `K` with finite support”, i.e. functions which vanish outside a finite set in
    `ι` (this finite set is not fixed, it depends on the function). Evaluating such
    a function coming from a basis `B` at a vector `v` and `i : ι` returns the component
    (or coordinate) of `v` on the `i`-th basis vector.'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '这个同构版本实际上是 Mathlib 在底层用作定义的版本，其他特征化都是从这个版本证明出来的。在无限基的情况下，必须对“`K` 的幂”这个概念稍加小心。确实，在这个代数背景下，只有有限线性组合才有意义。因此，我们需要作为参考的向量空间不是
    `K` 的副本的直接积，而是一个直接和。我们可以使用 `⨁ i : ι, K` 对于某些类型 `ι` 来索引基，但我们更倾向于使用更专业的表示 `ι →₀
    K`，这意味着“从 `ι` 到 `K` 的具有有限支撑的函数”，即除了在 `ι` 中的有限集合外都为零的函数（这个有限集合不是固定的，它依赖于函数）。在一个基
    `B` 中评估来自基的这样一个函数在向量 `v` 和 `i : ι` 上的值，返回 `v` 在第 `i` 个基向量上的分量（或坐标）。'
- en: The type of bases indexed by a type `ι` of `V` as a `K` vector space is `Basis
    ι K V`. The isomorphism is called `Basis.repr`.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `K` 向量空间 `V` 的类型 `ι` 的基的类型是 `Basis ι K V`。这个同构被称为 `Basis.repr`。
- en: '[PRE210]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: Instead of starting with such an isomorphism, one can start with a family `b`
    of vectors that is linearly independent and spanning, this is `Basis.mk`.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是从一个这样的同构开始，人们可以从一组线性无关且张成的向量 `b` 开始，这就是 `Basis.mk`。
- en: The assumption that the family is spanning is spelled out as `⊤ ≤ Submodule.span
    K (Set.range b)`. Here `⊤` is the top submodule of `V`, i.e. `V` seen as submodule
    of itself. This spelling looks a bit tortuous, but we will see below that it is
    almost equivalent by definition to the more readable `∀ v, v ∈ Submodule.span
    K (Set.range b)` (the underscores in the snippet below refers to the useless information
    `v ∈ ⊤`).
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个族是张成的，表示为 `⊤ ≤ Submodule.span K (Set.range b)`。这里 `⊤` 是 `V` 的上子模，即 `V` 作为自身的子模来看待。这种表示看起来有点扭曲，但下面我们将看到它几乎等同于更易读的
    `∀ v, v ∈ Submodule.span K (Set.range b)`（下面片段中的下划线指的是无用的信息 `v ∈ ⊤`）。
- en: '[PRE211]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'In particular the model vector space `ι →₀ K` has a so-called canonical basis
    whose `repr` function evaluated on any vector is the identity isomorphism. It
    is called `Finsupp.basisSingleOne` where `Finsupp` means function with finite
    support and `basisSingleOne` refers to the fact that basis vectors are functions
    which vanish expect for a single input value. More precisely the basis vector
    indexed by `i : ι` is `Finsupp.single i 1` which is the finitely supported function
    taking value `1` at `i` and `0` everywhere else.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '特别地，模型向量空间 `ι →₀ K` 有一个所谓的规范基，其 `repr` 函数在任意向量上的评估是恒等同构。它被称为 `Finsupp.basisSingleOne`，其中
    `Finsupp` 表示具有有限支撑的函数，而 `basisSingleOne` 指的是基向量是除了单个输入值外都为零的函数。更精确地说，由 `i : ι`
    索引的基向量是 `Finsupp.single i 1`，这是一个在 `i` 处取值为 `1` 而在其他所有地方取值为 `0` 的有限支撑函数。'
- en: '[PRE212]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: The story of finitely supported functions is unneeded when the indexing type
    is finite. In this case we can use the simpler `Pi.basisFun` which gives a basis
    of the whole `ι → K`.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 当索引类型是有限的时，有限支撑函数的故事是不必要的。在这种情况下，我们可以使用更简单的`Pi.basisFun`，它给出整个`ι → K`的基。
- en: '[PRE214]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: Going back to the general case of bases of abstract vector spaces, we can express
    any vector as a linear combination of basis vectors. Let us first see the easy
    case of finite bases.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 回到抽象向量空间基的一般情况，我们可以将任何向量表示为基向量的线性组合。让我们首先看看有限基的简单情况。
- en: '[PRE215]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'When `ι` is not finite, the above statement makes no sense a priori: we cannot
    take a sum over `ι`. However the support of the function being summed is finite
    (it is the support of `B.repr v`). But we need to apply a construction that takes
    this into account. Here Mathlib uses a special purpose function that requires
    some time to get used to: `Finsupp.linearCombination` (which is built on top of
    the more general `Finsupp.sum`). Given a finitely supported function `c` from
    a type `ι` to the base field `K` and any function `f` from `ι` to `V`, `Finsupp.linearCombination
    K f c` is the sum over the support of `c` of the scalar multiplication `c • f`.
    In particular, we can replace it by a sum over any finite set containing the support
    of `c`.'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ι`不是有限的时，上述陈述在先验上没有意义：我们不能在`ι`上取和。然而，被求和函数的支持是有限的（它是`B.repr v`的支持）。但是我们需要应用一个考虑到这一点的构造。在这里，Mathlib使用了一个特殊目的的函数，需要一些时间来习惯：`Finsupp.linearCombination`（它建立在更一般的`Finsupp.sum`之上）。给定一个从类型`ι`到基域`K`的有限支撑函数`c`和任何从`ι`到`V`的函数`f`，`Finsupp.linearCombination
    K f c`是`c`的支持上的标量乘积`c • f`的和。特别是，我们可以用包含`c`的支持的任何有限集上的和来替换它。
- en: '[PRE216]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: One could also assume that `f` is finitely supported and still get a well defined
    sum. But the choice made by `Finsupp.linearCombination` is the one relevant to
    our basis discussion since it allows to state the generalization of `Basis.sum_repr`.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以假设`f`是有限支撑的，并且仍然可以得到一个定义良好的和。但`Finsupp.linearCombination`所做的选择与我们的基讨论相关，因为它允许我们陈述`Basis.sum_repr`的推广。
- en: '[PRE217]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: One could wonder why `K` is an explicit argument here, despite the fact it can
    be inferred from the type of `c`. The point is that the partially applied `Finsupp.linearCombination
    K f` is interesting in itself. It is not a bare function from `ι →₀ K` to `V`
    but a `K`-linear map.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会想知道为什么`K`在这里是一个显式的参数，尽管它可以从`c`的类型中推断出来。关键是部分应用`Finsupp.linearCombination
    K f`本身是有趣的。它不是一个从`ι →₀ K`到`V`的裸函数，而是一个`K`-线性映射。
- en: '[PRE218]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Returning to the mathematical discussion, it is important to understand that
    the representation of vectors in a basis is less useful in formalized mathematics
    than you may think. Indeed it is very often more efficient to directly use more
    abstract properties of bases. In particular the universal property of bases connecting
    them to other free objects in algebra allows to construct linear maps by specifying
    the images of basis vectors. This is `Basis.constr`. For any `K`-vector space
    `W`, our basis `B` gives a linear isomorphism `Basis.constr B K` from `ι → W`
    to `V →ₗ[K] W`. This isomorphism is characterized by the fact that it sends any
    function `u : ι → W` to a linear map sending the basis vector `B i` to `u i`,
    for every `i : ι`.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '回到数学讨论，重要的是要理解，在形式化的数学中，基中向量的表示可能没有你想象的那么有用。事实上，直接使用基的更抽象性质通常更有效。特别是，基的普遍性质将它们与代数中的其他自由对象联系起来，允许通过指定基向量的像来构造线性映射。这是`Basis.constr`。对于任何`K`-向量空间`W`，我们的基`B`给出了一个线性同构`Basis.constr
    B K`，从`ι → W`到`V →ₗ[K] W`。这个同构的特点是它将任何函数`u : ι → W`映射到一个线性映射，该映射将基向量`B i`映射到`u
    i`，对于每个`i : ι`。'
- en: '[PRE219]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'This property is indeed characteristic because linear maps are determined by
    their values on bases:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 这个性质确实是特征性的，因为线性映射由其在基上的值确定：
- en: '[PRE220]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: If we also have a basis `B'` on the target space then we can identify linear
    maps with matrices. This identification is a `K`-linear isomorphism.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在目标空间上也有一个基`B'`，那么我们可以将线性映射与矩阵相识别。这种识别是一个`K`-线性同构。
- en: '[PRE221]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: As an exercise on this topic, we will prove part of the theorem which guarantees
    that endomorphisms have a well-defined determinant. Namely we want to prove that
    when two bases are indexed by the same type, the matrices they attach to any endomorphism
    have the same determinant. This would then need to be complemented using that
    bases all have isomorphic indexing types to get the full result.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个主题的练习，我们将证明保证内射有良好定义的行列式的定理的一部分。也就是说，我们想要证明当两个基由相同的类型索引时，它们附加到任何内射上的矩阵具有相同的行列式。然后需要使用基都具有同构索引类型来补充这一点，以得到完整的结果。
- en: Of course Mathlib already knows this, and `simp` can close the goal immediately,
    so you shouldn’t use it too soon, but rather use the provided lemmas.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Mathlib已经知道这一点，`simp`可以立即关闭目标，所以你不应该太早使用它，而应该使用提供的引理。
- en: '[PRE222]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 10.4.3\. Dimension[](#dimension "Link to this heading")
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3. 维度[](#dimension "链接到本标题")
- en: Returning to the case of a single vector space, bases are also useful to define
    the concept of dimension. Here again, there is the elementary case of finite-dimensional
    vector spaces. For such spaces we expect a dimension which is a natural number.
    This is `Module.finrank`. It takes the base field as an explicit argument since
    a given abelian group can be a vector space over different fields.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到单个向量空间的情况，基对于定义维度概念也是有用的。在这里，有限维向量空间是基本的情况。对于这样的空间，我们期望维度是一个自然数。这是`Module.finrank`。它将基域作为显式参数，因为给定的阿贝尔群可以是在不同域上的向量空间。
- en: '[PRE223]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: Note that `Module.finrank` is defined for any vector space. It returns zero
    for infinite dimensional vector spaces, just as division by zero returns zero.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Module.finrank`为任何向量空间定义。对于无限维向量空间，它返回零，就像除以零返回零一样。
- en: Of course many lemmas require a finite dimension assumption. This is the role
    of the `FiniteDimensional` typeclass. For instance, think about how the next example
    fails without this assumption.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，许多引理需要有限维度的假设。这就是`FiniteDimensional`类型类的作用。例如，考虑如果没有这个假设，下一个例子会如何失败。
- en: '[PRE224]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'In the above statement, `Nontrivial V` means `V` has at least two different
    elements. Note that `Module.finrank_pos_iff` has no explicit argument. This is
    fine when using it from left to right, but not when using it from right to left
    because Lean has no way to guess `K` from the statement `Nontrivial V`. In that
    case it is useful to use the name argument syntax, after checking that the lemma
    is stated over a ring named `R`. So we can write:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述陈述中，`Nontrivial V`表示`V`至少有两个不同的元素。请注意，`Module.finrank_pos_iff`没有显式的参数。当从左到右使用它时这是可以的，但当你从右到左使用它时就不行了，因为Lean无法从陈述`Nontrivial
    V`中猜测`K`。在这种情况下，使用名称参数语法是有用的，在检查引理是在名为`R`的环上陈述之后。因此，我们可以写出：
- en: '[PRE225]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: The above spelling is strange because we already have `h` as an assumption,
    so we could just as well give the full proof `Module.finrank_pos_iff.1 h` but
    it is good to know for more complicated cases.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 上述拼写很奇怪，因为我们已经有了`h`作为假设，所以我们完全可以给出完整的证明`Module.finrank_pos_iff.1 h`，但对于更复杂的情况来说，了解这一点是好的。
- en: By definition, `FiniteDimensional K V` can be read from any basis.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，`FiniteDimensional K V`可以从任何基中读取。
- en: '[PRE226]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: Using that the subtype corresponding to a linear subspace has a vector space
    structure, we can talk about the dimension of a subspace.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 利用对应于线性子空间的子类型具有向量空间结构，我们可以谈论子空间的维度。
- en: '[PRE227]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: In the first statement above, the purpose of the type ascriptions is to make
    sure that coercion to `Type*` does not trigger too early.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述第一个陈述中，类型注解的目的是确保将强制转换为`Type*`不会太早触发。
- en: We are now ready for an exercise about `finrank` and subspaces.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以准备一个关于`finrank`和子空间的练习。
- en: '[PRE228]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Let us now move to the general case of dimension theory. In this case `finrank`
    is useless, but we still have that, for any two bases of the same vector space,
    there is a bijection between the types indexing those bases. So we can still hope
    to define the rank as a cardinal, i.e. an element of the “quotient of the collection
    of types under the existence of a bijection equivalence relation”.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向维度理论的一般情况。在这种情况下，`finrank`是无用的，但我们仍然有，对于任何相同向量空间的两个基，它们索引的类型之间存在一个双射。因此，我们仍然可以希望将秩定义为基数，即“在存在双射等价关系下的类型集合的商”中的一个元素。
- en: When discussing cardinal, it gets harder to ignore foundational issues around
    Russel’s paradox like we do everywhere else in this book. There is no type of
    all types because it would lead to logical inconsistencies. This issue is solved
    by the hierarchy of universes that we usually try to ignore.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论基数时，就像我们在本书的其他地方所做的那样，很难忽视围绕罗素悖论的基础性问题。没有所有类型的类型，因为这会导致逻辑上的不一致。这个问题通过我们通常试图忽略的宇宙层次结构得到解决。
- en: Each type has a universe level, and those levels behave similarly to natural
    numbers. In particular there is zeroth level, and the corresponding universe `Type
    0` is simply denoted by `Type`. This universe is enough to hold almost all of
    classical mathematics. For instance `ℕ` and `ℝ` have type `Type`. Each level `u`
    has a successor denoted by `u + 1`, and `Type u` has type `Type (u+1)`.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型都有一个宇宙级别，这些级别的行为类似于自然数。特别是存在零级，相应的宇宙`Type 0`简单地表示为`Type`。这个宇宙足以容纳几乎所有经典数学。例如`ℕ`和`ℝ`具有`Type`类型。每个级别`u`都有一个后继，表示为`u
    + 1`，并且`Type u`具有类型`Type (u+1)`。
- en: But universe levels are not natural numbers, they have a really different nature
    and don’t have a type. In particular you cannot state in Lean something like `u
    ≠ u + 1`. There is simply no type where this would take place. Even stating `Type
    u ≠ Type (u+1)` does not make any sense since `Type u` and `Type (u+1)` have different
    types.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 但宇宙级别不是自然数，它们具有非常不同的性质，并且没有类型。特别是你无法在Lean中声明类似于`u ≠ u + 1`的东西。根本不存在这样的类型。甚至声明`Type
    u ≠ Type (u+1)`也没有任何意义，因为`Type u`和`Type (u+1)`具有不同的类型。
- en: Whenever we write `Type*`, Lean inserts a universe level variable named `u_n`
    where `n` is a number. This allows definitions and statements to live in all universes.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们写`Type*`，Lean都会插入一个名为`u_n`的宇宙级别变量，其中`n`是一个数字。这允许定义和陈述存在于所有宇宙中。
- en: 'Given a universe level `u`, we can define an equivalence relation on `Type
    u` saying two types `α` and `β` are equivalent if there is a bijection between
    them. The quotient type `Cardinal.{u}` lives in `Type (u+1)`. The curly braces
    denote a universe variable. The image of `α : Type u` in this quotient is `Cardinal.mk
    α : Cardinal.{u}`.'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个宇宙级别`u`，我们可以在`Type u`上定义一个等价关系，即如果存在两个类型`α`和`β`之间的双射，则这两个类型`α`和`β`是等价的。商类型`Cardinal.{u}`生活在`Type
    (u+1)`中。大括号表示一个宇宙变量。在这个商中`α : Type u`的像是`Cardinal.mk α : Cardinal.{u}`。'
- en: But we cannot directly compare cardinals in different universes. So technically
    we cannot define the rank of a vector space `V` as the cardinal of all types indexing
    a basis of `V`. So instead it is defined as the supremum `Module.rank K V` of
    cardinals of all linearly independent sets in `V`. If `V` has universe level `u`
    then its rank has type `Cardinal.{u}`.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们无法直接比较不同宇宙中的基数。因此，技术上我们无法将向量空间`V`的秩定义为所有类型索引`V`的基的基数。因此，它被定义为所有线性无关集合的基数`Module.rank
    K V`的上确界。如果`V`的宇宙级别为`u`，则其秩具有类型`Cardinal.{u}`。
- en: '[PRE229]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'One can still relate this definition to bases. Indeed there is also a commutative
    `max` operation on universe levels, and given two universe levels `u` and `v`
    there is an operation `Cardinal.lift.{u, v} : Cardinal.{v} → Cardinal.{max v u}`
    that allows to put cardinals in a common universe and state the dimension theorem.'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '仍然可以将这个定义与基数相关联。确实，在宇宙级别上也有一个交换的`max`操作，并且给定两个宇宙级别`u`和`v`，存在一个操作`Cardinal.lift.{u,
    v} : Cardinal.{v} → Cardinal.{max v u}`，它允许将基数放入一个共同的宇宙并陈述维度定理。'
- en: '[PRE230]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: We can relate the finite dimensional case to this discussion using the coercion
    from natural numbers to finite cardinals (or more precisely the finite cardinals
    which live in `Cardinal.{v}` where `v` is the universe level of `V`).
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用从自然数到有限基数的强制转换（或者更精确地说，是生活在`Cardinal.{v}`中的有限基数，其中`v`是`V`的宇宙级别）将有限维情况与这个讨论联系起来。
- en: '[PRE231]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '### 10.4.1\. Matrices[](#matrices "Link to this heading")'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '### 10.4.1\. 矩阵[](#matrices "链接到这个标题")'
- en: Before introducing bases for abstract vector spaces, we go back to the much
    more elementary setup of linear algebra in \(K^n\) for some field \(K\). Here
    the main objects are vectors and matrices. For concrete vectors, one can use the
    `![…]` notation, where components are separated by commas. For concrete matrices
    we can use the `!![…]` notation, lines are separated by semi-colons and components
    of lines are separated by colons. When entries have a computable type such as
    `ℕ` or `ℚ`, we can use the `eval` command to play with basic operations.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍抽象向量空间的基之前，我们回到更基础的线性代数设置，即对于某个域\(K\)的\(K^n\)。在这里，主要对象是向量和矩阵。对于具体的向量，可以使用`![…]`表示法，其中分量由逗号分隔。对于具体的矩阵，我们可以使用`!![…]`表示法，行由分号分隔，行的分量由冒号分隔。当条目具有可计算类型，如`ℕ`或`ℚ`时，我们可以使用`eval`命令进行基本操作。
- en: '[PRE232]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: It is important to understand that this use of `#eval` is interesting only for
    exploration, it is not meant to replace a computer algebra system such as Sage.
    The data representation used here for matrices is *not* computationally efficient
    in any way. It uses functions instead of arrays and is optimized for proving,
    not computing. The virtual machine used by `#eval` is also not optimized for this
    use.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解这种`#eval`的使用仅对探索有趣，它不是用来替换计算机代数系统，如Sage。这里用于矩阵的数据表示在计算上没有任何效率。它使用函数而不是数组，并且优化用于证明，而不是计算。`#eval`使用的虚拟机也不是为此用途优化的。
- en: Beware the matrix notation list rows but the vector notation is neither a row
    vector nor a column vector. Multiplication of a matrix with a vector from the
    left (resp. right) interprets the vector as a row (resp. column) vector. This
    corresponds to operations `Matrix.vecMul`, with notation `ᵥ*` and `Matrix.mulVec`,
    with notation ` *ᵥ`. Those notations are scoped in the `Matrix` namespace that
    we therefore need to open.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 注意矩阵表示法列表行，但向量表示法既不是行向量也不是列向量。从左（分别）乘以矩阵的向量将向量解释为行（分别）向量。这对应于`Matrix.vecMul`操作，表示为`ᵥ*`，以及`Matrix.mulVec`操作，表示为`
    *ᵥ`。这些表示法在`Matrix`命名空间中定义，因此我们需要打开它。
- en: '[PRE233]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: In order to generate matrices with identical rows or columns specified by a
    vector, we use `Matrix.replicateRow` and `Matrix.replicateCol`, with arguments
    the type indexing the rows or columns and the vector. For instance one can get
    single row or single column matrixes (more precisely matrices whose rows or columns
    are indexed by `Fin 1`).
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成具有由向量指定的相同行或列的矩阵，我们使用`Matrix.replicateRow`和`Matrix.replicateCol`，其中参数是索引行或列的类型和向量。例如，可以得到单行或单列矩阵（更精确地说，行或列由`Fin
    1`索引的矩阵）。
- en: '[PRE234]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Other familiar operations include the vector dot product, matrix transpose,
    and, for square matrices, determinant and trace.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 其他熟悉的操作包括向量点积、矩阵转置，对于方阵，还有行列式和迹。
- en: '[PRE235]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: When entries do not have a computable type, for instance if they are real numbers,
    we cannot hope that `#eval` can help. Also this kind of evaluation cannot be used
    in proofs without considerably expanding the trusted code base (i.e. the part
    of Lean that you need to trust when checking proofs).
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 当条目没有可计算类型时，例如如果它们是实数，我们无法期望`#eval`能有所帮助。此外，这种评估不能在没有显著扩大可信代码库的情况下用于证明（即检查证明时需要信任的Lean的部分）。
- en: So it is good to also use the `simp` and `norm_num` tactics in proofs, or their
    command counter-part for quick exploration.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在证明中也很好使用`simp`和`norm_num`策略，或者它们的命令对应部分进行快速探索。
- en: '[PRE236]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: The next important operation on square matrices is inversion. In the same way
    as division of numbers is always defined and returns the artificial value zero
    for division by zero, the inversion operation is defined on all matrices and returns
    the zero matrix for non-invertible matrices.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 方阵上的下一个重要操作是求逆。与数的除法总是定义并返回除以零的人工值零一样，求逆操作在所有矩阵上定义，对于不可逆矩阵返回零矩阵。
- en: More precisely, there is general function `Ring.inverse` that does this in any
    ring, and, for any matrix `A`, `A⁻¹` is defined as `Ring.inverse A.det • A.adjugate`.
    According to Cramer’s rule, this is indeed the inverse of `A` when the determinant
    of `A` is not zero.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 更确切地说，有一个通用的函数`Ring.inverse`在任意环中执行此操作，并且对于任何矩阵`A`，`A⁻¹`定义为`Ring.inverse A.det
    • A.adjugate`。根据克莱姆法则，当`A`的行列式不为零时，这确实是`A`的逆。
- en: '[PRE237]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Of course this definition is really useful only for invertible matrices. There
    is a general type class `Invertible` that helps recording this. For instance,
    the `simp` call in the next example will use the `inv_mul_of_invertible` lemma
    which has an `Invertible` type-class assumption, so it will trigger only if this
    can be found by the type-class synthesis system. Here we make this fact available
    using a `have` statement.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个定义对于可逆矩阵来说非常有用。有一个通用的类型类 `Invertible` 帮助记录这一点。例如，在下一个例子中的 `simp` 调用将使用具有
    `Invertible` 类型类假设的 `inv_mul_of_invertible` 引理，因此只有在类型类合成系统可以找到它的情况下才会触发。在这里，我们使用
    `have` 语句使这一事实可用。
- en: '[PRE238]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'In this fully concrete case, we could also use the `norm_num` machinery, and
    `apply?` to find the final line:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个完全具体的例子中，我们也可以使用 `norm_num` 机制和 `apply?` 来找到最终的行：
- en: '[PRE239]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: All the concrete matrices above have their rows and columns indexed by `Fin
    n` for some `n` (not necessarily the same for rows and columns). But sometimes
    it is more convenient to index matrices using arbitrary finite types. For instance
    the adjacency matrix of a finite graph has rows and columns naturally indexed
    by the vertices of the graph.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述的矩阵都具有它们的行和列通过 `Fin n`（对于某个 `n`）进行索引，对于行和列不一定是相同的。但有时使用任意的有限类型来索引矩阵会更方便。例如，有限图的邻接矩阵的行和列自然地通过图的顶点进行索引。
- en: In fact when simply wants to define matrices without defining any operation
    on them, finiteness of the indexing types are not even needed, and coefficients
    can have any type, without any algebraic structure. So Mathlib simply defines
    `Matrix m n α` to be `m → n → α` for any types `m`, `n` and `α`, and the matrices
    we have been using so far had types such as `Matrix (Fin 2) (Fin 2) ℝ`. Of course
    algebraic operations require more assumptions on `m`, `n` and `α`.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当仅仅想要定义矩阵而不在它们上定义任何操作时，索引类型的有限性甚至不是必需的，系数可以有任何类型，而不需要任何代数结构。因此，Mathlib 简单地将
    `Matrix m n α` 定义为 `m → n → α`，对于任何类型 `m`、`n` 和 `α`，而我们迄今为止使用的矩阵具有如 `Matrix (Fin
    2) (Fin 2) ℝ` 这样的类型。当然，代数运算需要对 `m`、`n` 和 `α` 有更多的假设。
- en: Note the main reason why we do not use `m → n → α` directly is to allow the
    type class system to understand what we want. For instance, for a ring `R`, the
    type `n → R` is endowed with the point-wise multiplication operation, and similarly
    `m → n → R` has this operation which is *not* the multiplication we want on matrices.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们不直接使用 `m → n → α` 的主要原因是为了让类型类系统理解我们的意图。例如，对于一个环 `R`，类型 `n → R` 被赋予了点乘运算，同样地
    `m → n → R` 也有这种运算，但这并不是我们在矩阵上想要的乘法。
- en: In the first example below, we force Lean to see through the definition of `Matrix`
    and accept the statement as meaningful, and then prove it by checking all entries.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的第一个例子中，我们迫使 Lean 看透 `Matrix` 的定义，并接受这个陈述是有意义的，然后通过检查所有项来证明它。
- en: But then the next two examples reveal that Lean uses the point-wise multiplication
    on `Fin 2 → Fin 2 → ℤ` but the matrix multiplication on `Matrix (Fin 2) (Fin 2)
    ℤ`.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 但接下来的两个例子揭示了 Lean 使用 `Fin 2 → Fin 2 → ℤ` 上的点乘，但使用 `Matrix (Fin 2) (Fin 2) ℤ`
    上的矩阵乘法。
- en: '[PRE240]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: In order to define matrices as functions without losing the benefits of `Matrix`
    for type class synthesis, we can use the equivalence `Matrix.of` between functions
    and matrices. This equivalence is secretly defined using `Equiv.refl`.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义矩阵作为函数而不失去 `Matrix` 在类型类合成中的好处，我们可以使用函数和矩阵之间的等价性 `Matrix.of`。这个等价性是秘密地使用
    `Equiv.refl` 定义的。
- en: For instance we can define Vandermonde matrices corresponding to a vector `v`.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义与向量 `v` 对应的范德蒙德矩阵。
- en: '[PRE241]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 10.4.2\. Bases[](#bases "Link to this heading")
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2\. 基[](#bases "链接到这个标题")
- en: We now want to discuss bases of vector spaces. Informally there are many ways
    to define this notion. One can use a universal property. One can say a basis is
    a family of vectors that is linearly independent and spanning. Or one can combine
    those properties and directly say that a basis is a family of vectors such that
    every vectors can be written uniquely as a linear combination of bases vectors.
    Yet another way to say it is that a basis provides a linear isomorphism with a
    power of the base field `K`, seen as a vector space over `K`.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要讨论向量空间的基。非正式地说，有许多定义这个概念的方法。可以使用一个通用性质。可以说基是一组线性无关且张成的向量族。或者可以将这些性质结合起来，直接说基是一组向量，使得每个向量都可以唯一地表示为基向量的线性组合。还有一种说法是，基提供了一个与基域
    `K` 的幂的线性同构，将 `K` 视为 `K` 上的向量空间。
- en: 'This isomorphism version is actually the one that Mathlib uses as a definition
    under the hood, and other characterizations are proven from it. One must be slightly
    careful with the “power of `K`” idea in the case of infinite bases. Indeed only
    finite linear combinations make sense in this algebraic context. So what we need
    as a reference vector space is not a direct product of copies of `K` but a direct
    sum. We could use `⨁ i : ι, K` for some type `ι` indexing the basis But we rather
    use the more specialized spelling `ι →₀ K` which means “functions from `ι` to
    `K` with finite support”, i.e. functions which vanish outside a finite set in
    `ι` (this finite set is not fixed, it depends on the function). Evaluating such
    a function coming from a basis `B` at a vector `v` and `i : ι` returns the component
    (or coordinate) of `v` on the `i`-th basis vector.'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '这种同构版本实际上是Mathlib在底层用作定义的版本，其他特征化都是从这个版本证明出来的。在无限基的情况下，必须对“`K`的幂”这一概念稍加小心。实际上，在这个代数背景下，只有有限线性组合才有意义。因此，我们需要作为参考的向量空间不是`K`的副本的直接积，而是一个直接和。我们可以用`⨁
    i : ι, K`来表示某个类型`ι`索引基，但我们更倾向于使用更专业的拼写`ι →₀ K`，这意味着“从`ι`到`K`的有限支撑函数”，即函数在`ι`的有限集合外为零（这个有限集合不是固定的，它依赖于函数）。将来自基`B`的这样一个函数在向量`v`和`i
    : ι`上求值，返回`v`在`i`-th基向量上的分量（或坐标）。'
- en: The type of bases indexed by a type `ι` of `V` as a `K` vector space is `Basis
    ι K V`. The isomorphism is called `Basis.repr`.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '`V`作为`K`向量空间的类型`ι`的基的类型是`Basis ι K V`。这个同构被称为`Basis.repr`。'
- en: '[PRE242]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: Instead of starting with such an isomorphism, one can start with a family `b`
    of vectors that is linearly independent and spanning, this is `Basis.mk`.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人可以从一个线性无关且生成向量的集合`b`开始，而不是从这样的同构开始，这就是`Basis.mk`。
- en: The assumption that the family is spanning is spelled out as `⊤ ≤ Submodule.span
    K (Set.range b)`. Here `⊤` is the top submodule of `V`, i.e. `V` seen as submodule
    of itself. This spelling looks a bit tortuous, but we will see below that it is
    almost equivalent by definition to the more readable `∀ v, v ∈ Submodule.span
    K (Set.range b)` (the underscores in the snippet below refers to the useless information
    `v ∈ ⊤`).
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 家庭是生成集的假设被表述为`⊤ ≤ Submodule.span K (Set.range b)`。这里`⊤`是`V`的顶子模，即`V`作为自身的子模。这种表述看起来有点复杂，但下面我们将看到它几乎等同于更易读的`∀
    v, v ∈ Submodule.span K (Set.range b)`（下面片段中的下划线指的是无用的信息`v ∈ ⊤`）。
- en: '[PRE243]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'In particular the model vector space `ι →₀ K` has a so-called canonical basis
    whose `repr` function evaluated on any vector is the identity isomorphism. It
    is called `Finsupp.basisSingleOne` where `Finsupp` means function with finite
    support and `basisSingleOne` refers to the fact that basis vectors are functions
    which vanish expect for a single input value. More precisely the basis vector
    indexed by `i : ι` is `Finsupp.single i 1` which is the finitely supported function
    taking value `1` at `i` and `0` everywhere else.'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '特别是模型向量空间`ι →₀ K`有一个所谓的规范基，其`repr`函数在任意向量上的求值是恒等同构。它被称为`Finsupp.basisSingleOne`，其中`Finsupp`表示有限支撑函数，`basisSingleOne`指的是基向量是除了单个输入值外其他地方为零的函数。更精确地说，由`i
    : ι`索引的基向量是`Finsupp.single i 1`，这是一个有限支撑函数，在`i`处取值为`1`，在其他所有地方取值为`0`。'
- en: '[PRE244]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: The story of finitely supported functions is unneeded when the indexing type
    is finite. In this case we can use the simpler `Pi.basisFun` which gives a basis
    of the whole `ι → K`.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 当索引类型是有限的时候，有限支撑函数的故事是不必要的。在这种情况下，我们可以使用更简单的`Pi.basisFun`，它给出整个`ι → K`的基。
- en: '[PRE246]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: Going back to the general case of bases of abstract vector spaces, we can express
    any vector as a linear combination of basis vectors. Let us first see the easy
    case of finite bases.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 回到抽象向量空间基的一般情况，我们可以将任何向量表示为基向量的线性组合。让我们先看看有限基的简单情况。
- en: '[PRE247]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'When `ι` is not finite, the above statement makes no sense a priori: we cannot
    take a sum over `ι`. However the support of the function being summed is finite
    (it is the support of `B.repr v`). But we need to apply a construction that takes
    this into account. Here Mathlib uses a special purpose function that requires
    some time to get used to: `Finsupp.linearCombination` (which is built on top of
    the more general `Finsupp.sum`). Given a finitely supported function `c` from
    a type `ι` to the base field `K` and any function `f` from `ι` to `V`, `Finsupp.linearCombination
    K f c` is the sum over the support of `c` of the scalar multiplication `c • f`.
    In particular, we can replace it by a sum over any finite set containing the support
    of `c`.'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ι`不是有限时，上述陈述在先验上没有意义：我们无法对`ι`进行求和。然而，被求和函数的支持集是有限的（它是`B.repr v`的支持集）。但是，我们需要应用一个考虑到这一点的构造。在这里，Mathlib使用了一个特殊目的的函数，需要一些时间来习惯：`Finsupp.linearCombination`（它建立在更一般的`Finsupp.sum`之上）。给定一个从类型`ι`到基域`K`的有限支持函数`c`以及从`ι`到`V`的任何函数`f`，`Finsupp.linearCombination
    K f c`是对`c`的支持集上标量乘积`c • f`的求和。特别是，我们可以用包含`c`的支持集的任何有限集上的求和来替换它。
- en: '[PRE248]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: One could also assume that `f` is finitely supported and still get a well defined
    sum. But the choice made by `Finsupp.linearCombination` is the one relevant to
    our basis discussion since it allows to state the generalization of `Basis.sum_repr`.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以假设`f`是有限支持的，并且仍然可以得到一个定义良好的求和。但是，`Finsupp.linearCombination`所做的选择与我们的基讨论相关，因为它允许我们陈述`Basis.sum_repr`的推广。
- en: '[PRE249]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: One could wonder why `K` is an explicit argument here, despite the fact it can
    be inferred from the type of `c`. The point is that the partially applied `Finsupp.linearCombination
    K f` is interesting in itself. It is not a bare function from `ι →₀ K` to `V`
    but a `K`-linear map.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以想知道为什么`K`在这里是一个显式的参数，尽管它可以从`c`的类型中推断出来。关键是部分应用`Finsupp.linearCombination
    K f`本身是有趣的。它不是一个从`ι →₀ K`到`V`的裸函数，而是一个`K`-线性映射。
- en: '[PRE250]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'Returning to the mathematical discussion, it is important to understand that
    the representation of vectors in a basis is less useful in formalized mathematics
    than you may think. Indeed it is very often more efficient to directly use more
    abstract properties of bases. In particular the universal property of bases connecting
    them to other free objects in algebra allows to construct linear maps by specifying
    the images of basis vectors. This is `Basis.constr`. For any `K`-vector space
    `W`, our basis `B` gives a linear isomorphism `Basis.constr B K` from `ι → W`
    to `V →ₗ[K] W`. This isomorphism is characterized by the fact that it sends any
    function `u : ι → W` to a linear map sending the basis vector `B i` to `u i`,
    for every `i : ι`.'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '返回到数学讨论，重要的是要理解，在形式化数学中，基中向量的表示可能没有你想象的那么有用。事实上，直接使用基的更抽象性质通常更有效。特别是，基的普遍性质将它们与其他代数中的自由对象联系起来，允许通过指定基向量的像来构造线性映射。这是`Basis.constr`。对于任何`K`-向量空间`W`，我们的基`B`给出一个线性同构`Basis.constr
    B K`，从`ι → W`到`V →ₗ[K] W`。这个同构的特点是它将任何函数`u : ι → W`映射到一个线性映射，该映射将基向量`B i`映射到`u
    i`，对于每个`i : ι`。'
- en: '[PRE251]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'This property is indeed characteristic because linear maps are determined by
    their values on bases:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 这个性质确实是特征性的，因为线性映射由其在基上的值确定：
- en: '[PRE252]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: If we also have a basis `B'` on the target space then we can identify linear
    maps with matrices. This identification is a `K`-linear isomorphism.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在目标空间上也有一个基`B'`，那么我们可以将线性映射与矩阵相识别。这种识别是一个`K`-线性同构。
- en: '[PRE253]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: As an exercise on this topic, we will prove part of the theorem which guarantees
    that endomorphisms have a well-defined determinant. Namely we want to prove that
    when two bases are indexed by the same type, the matrices they attach to any endomorphism
    have the same determinant. This would then need to be complemented using that
    bases all have isomorphic indexing types to get the full result.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个主题的练习，我们将证明定理的一部分，该定理保证了内射有定义良好的行列式。具体来说，我们想要证明当两个基由相同的类型索引时，它们附加到任何内射上的矩阵有相同的行列式。这需要使用所有基都有同构索引类型来补充，以得到完整的结果。
- en: Of course Mathlib already knows this, and `simp` can close the goal immediately,
    so you shouldn’t use it too soon, but rather use the provided lemmas.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Mathlib已经知道这一点，`simp`可以立即关闭目标，所以你不应该太早使用它，而应该使用提供的引理。
- en: '[PRE254]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 10.4.3\. Dimension[](#dimension "Link to this heading")
  id: totrans-693
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3\. 维度[](#dimension "链接到这个标题")
- en: Returning to the case of a single vector space, bases are also useful to define
    the concept of dimension. Here again, there is the elementary case of finite-dimensional
    vector spaces. For such spaces we expect a dimension which is a natural number.
    This is `Module.finrank`. It takes the base field as an explicit argument since
    a given abelian group can be a vector space over different fields.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 回到单个向量空间的情况，基对于定义维度概念也是有用的。在这里，也存在有限维向量空间的基本情况。对于这样的空间，我们期望维度是一个自然数。这是`Module.finrank`。它将基域作为显式参数，因为一个给定的阿贝尔群可以是在不同域上的向量空间。
- en: '[PRE255]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: Note that `Module.finrank` is defined for any vector space. It returns zero
    for infinite dimensional vector spaces, just as division by zero returns zero.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Module.finrank`为任何向量空间定义。对于无限维向量空间，它返回零，就像除以零返回零一样。
- en: Of course many lemmas require a finite dimension assumption. This is the role
    of the `FiniteDimensional` typeclass. For instance, think about how the next example
    fails without this assumption.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，许多引理需要有限维度的假设。这就是`FiniteDimensional`类型类的作用。例如，想想如果没有这个假设，下一个例子会如何失败。
- en: '[PRE256]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'In the above statement, `Nontrivial V` means `V` has at least two different
    elements. Note that `Module.finrank_pos_iff` has no explicit argument. This is
    fine when using it from left to right, but not when using it from right to left
    because Lean has no way to guess `K` from the statement `Nontrivial V`. In that
    case it is useful to use the name argument syntax, after checking that the lemma
    is stated over a ring named `R`. So we can write:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述陈述中，`Nontrivial V`意味着`V`至少有两个不同的元素。请注意，`Module.finrank_pos_iff`没有显式参数。当从左到右使用它时这是可以的，但不是从右到左使用时，因为Lean无法从陈述`Nontrivial
    V`中猜测`K`。在这种情况下，在确认引理是在一个名为`R`的环上陈述之后，使用名称参数语法是有用的。因此，我们可以写出：
- en: '[PRE257]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: The above spelling is strange because we already have `h` as an assumption,
    so we could just as well give the full proof `Module.finrank_pos_iff.1 h` but
    it is good to know for more complicated cases.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 上述拼写很奇怪，因为我们已经有了`h`作为假设，所以我们完全可以给出完整的证明`Module.finrank_pos_iff.1 h`，但在更复杂的情况下了解这一点是好的。
- en: By definition, `FiniteDimensional K V` can be read from any basis.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，`FiniteDimensional K V`可以从任何基中读取。
- en: '[PRE258]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: Using that the subtype corresponding to a linear subspace has a vector space
    structure, we can talk about the dimension of a subspace.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 利用对应于线性子空间的子类型具有向量空间结构，我们可以谈论子空间的维度。
- en: '[PRE259]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: In the first statement above, the purpose of the type ascriptions is to make
    sure that coercion to `Type*` does not trigger too early.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述第一个陈述中，类型注解的目的是确保将`Type*`的强制转换不会太早触发。
- en: We are now ready for an exercise about `finrank` and subspaces.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好进行关于`finrank`和子空间的练习了。
- en: '[PRE260]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: Let us now move to the general case of dimension theory. In this case `finrank`
    is useless, but we still have that, for any two bases of the same vector space,
    there is a bijection between the types indexing those bases. So we can still hope
    to define the rank as a cardinal, i.e. an element of the “quotient of the collection
    of types under the existence of a bijection equivalence relation”.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向维度理论的通用情况。在这种情况下，`finrank`是无用的，但我们仍然有这样一个事实：对于同一向量空间中的任意两个基，这些基的类型之间存在一一对应关系。因此，我们仍然可以希望将秩定义为基数，即“在存在一一对应等价关系下的类型集合的商”中的一个元素。
- en: When discussing cardinal, it gets harder to ignore foundational issues around
    Russel’s paradox like we do everywhere else in this book. There is no type of
    all types because it would lead to logical inconsistencies. This issue is solved
    by the hierarchy of universes that we usually try to ignore.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论基数时，就像在这本书的其他地方一样，很难忽视围绕Russel悖论的基础性问题。没有所有类型的类型，因为这会导致逻辑不一致。这个问题通过我们通常试图忽略的宇宙层次结构得到解决。
- en: Each type has a universe level, and those levels behave similarly to natural
    numbers. In particular there is zeroth level, and the corresponding universe `Type
    0` is simply denoted by `Type`. This universe is enough to hold almost all of
    classical mathematics. For instance `ℕ` and `ℝ` have type `Type`. Each level `u`
    has a successor denoted by `u + 1`, and `Type u` has type `Type (u+1)`.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型都有一个宇宙级别，这些级别与自然数的行为相似。特别是有一个零级，相应的宇宙`Type 0`简单地表示为`Type`。这个宇宙足以容纳几乎所有经典数学。例如`ℕ`和`ℝ`的类型是`Type`。每个级别`u`都有一个后继，表示为`u
    + 1`，而`Type u`的类型是`Type (u+1)`。
- en: But universe levels are not natural numbers, they have a really different nature
    and don’t have a type. In particular you cannot state in Lean something like `u
    ≠ u + 1`. There is simply no type where this would take place. Even stating `Type
    u ≠ Type (u+1)` does not make any sense since `Type u` and `Type (u+1)` have different
    types.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 但是宇宙级别不是自然数，它们具有非常不同的性质，并且没有类型。特别是你无法在 Lean 中声明类似于 `u ≠ u + 1` 的内容。根本不存在这样的类型。甚至声明
    `Type u ≠ Type (u+1)` 也没有意义，因为 `Type u` 和 `Type (u+1)` 具有不同的类型。
- en: Whenever we write `Type*`, Lean inserts a universe level variable named `u_n`
    where `n` is a number. This allows definitions and statements to live in all universes.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们写 `Type*` 时，Lean 会插入一个名为 `u_n` 的宇宙级别变量，其中 `n` 是一个数字。这允许定义和陈述存在于所有宇宙中。
- en: 'Given a universe level `u`, we can define an equivalence relation on `Type
    u` saying two types `α` and `β` are equivalent if there is a bijection between
    them. The quotient type `Cardinal.{u}` lives in `Type (u+1)`. The curly braces
    denote a universe variable. The image of `α : Type u` in this quotient is `Cardinal.mk
    α : Cardinal.{u}`.'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个宇宙级别 `u`，我们可以在 `Type u` 上定义一个等价关系，即如果存在两个类型 `α` 和 `β` 之间的双射，则这两个类型 `α`
    和 `β` 是等价的。商类型 `Cardinal.{u}` 居于 `Type (u+1)` 中。大括号表示一个宇宙变量。在这个商中，`α : Type u`
    的像为 `Cardinal.mk α : Cardinal.{u}`。'
- en: But we cannot directly compare cardinals in different universes. So technically
    we cannot define the rank of a vector space `V` as the cardinal of all types indexing
    a basis of `V`. So instead it is defined as the supremum `Module.rank K V` of
    cardinals of all linearly independent sets in `V`. If `V` has universe level `u`
    then its rank has type `Cardinal.{u}`.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们无法直接比较不同宇宙中的基数。因此，技术上我们无法将向量空间 `V` 的秩定义为所有基索引类型的基数。因此，它被定义为 `V` 中所有线性无关集的基数
    `Module.rank K V` 的上确界。如果 `V` 的宇宙级别为 `u`，则其秩具有类型 `Cardinal.{u}`。
- en: '[PRE261]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'One can still relate this definition to bases. Indeed there is also a commutative
    `max` operation on universe levels, and given two universe levels `u` and `v`
    there is an operation `Cardinal.lift.{u, v} : Cardinal.{v} → Cardinal.{max v u}`
    that allows to put cardinals in a common universe and state the dimension theorem.'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管如此，我们仍然可以将这个定义与基联系起来。确实，在宇宙级别上也有一个交换的 `max` 操作，并且对于两个宇宙级别 `u` 和 `v`，存在一个操作
    `Cardinal.lift.{u, v} : Cardinal.{v} → Cardinal.{max v u}`，它允许将基数放入一个共同的宇宙中并陈述维度定理。'
- en: '[PRE262]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: We can relate the finite dimensional case to this discussion using the coercion
    from natural numbers to finite cardinals (or more precisely the finite cardinals
    which live in `Cardinal.{v}` where `v` is the universe level of `V`).
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用从自然数到有限基数（或者更精确地说，居住在 `Cardinal.{v}` 中的有限基数，其中 `v` 是 `V` 的宇宙级别）的强制转换将有限维情况与这次讨论联系起来。
- en: '[PRE263]*'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE263]*'
