- en: 'Case Study: Square Drop'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://phys-sim-book.github.io/lec8.3-square_drop.html](https://phys-sim-book.github.io/lec8.3-square_drop.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, let's consider a case study where we simulate a square dropped
    onto a fixed planar ground. Building on our previous mass-spring model for an
    elastic square, we augment a barrier potential into its Incremental Potential
    and apply the filter line search scheme to manage the contact between the square's
    degrees of freedom (DOFs) and the ground.
  prefs: []
  type: TYPE_NORMAL
- en: The excutable Python project for this section can be found at [https://github.com/phys-sim-book/solid-sim-tutorial](https://github.com/phys-sim-book/solid-sim-tutorial)
    under the `3_contact` folder. [MUDA](https://github.com/MuGdxy/muda) GPU implementations
    can be found at [https://github.com/phys-sim-book/solid-sim-tutorial-gpu](https://github.com/phys-sim-book/solid-sim-tutorial-gpu)
    under the `simulators/3_contact` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we further limit the planar ground to be horizontal, e.g. at \(y=y_0\),
    its signed distance function can be made even simpler than Equation [(7.1.1)](lec7.1-signed_dists.html#eq:lec7:half_space_dist):
    d(x)=xy​−y0​,∇d(x)=[01​],∇2d(x)=0.(8.3.1) Combining it with Equation [(7.2.4)](lec7.2-dist_barrier_formulation.html#eq:lec7:barrier_grad)
    and Equation [(7.2.5)](lec7.2-dist_barrier_formulation.html#eq:lec7:barrier_hess),
    we can conveniently implement the gradient and Hessian computation for the barrier
    potential of this horizontal ground:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 8.3.1 (Barrier energy value, gradient, and Hessian, BarrierEnergy.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For the filter line search, with the position in the last iteration \(\mathbf{x}\)
    and a search direction \(\mathbf{p}\) of a specific node, the signed distance
    function is simply \[ d(\mathbf{x} + \alpha \mathbf{p}) = \mathbf{x}_y + \alpha
    \mathbf{p}_y - y_0, \] where \(\alpha\) is the step size, and there is only one
    positive real root \(\alpha = (y_0 - \mathbf{x}_y) / \mathbf{p}_y\) when \(\mathbf{p}_y
    < 0\) since \(\mathbf{x}_y > y_0\) (no interpenetration up to current iteration).
    Taking the minimum of the positive real root per node then gives us the step size
    upper bound \(\alpha_C\) defined in Equation [(8.2.1)](lec8.2-nonpenetration_traj.html#eq:lec8:alpha_CCD):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 8.3.2 (Ground CCD, BarrierEnergy.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here we scale the upper bound by \(0.9\times\) so that exact touching configurations
    with \(d=0\) and \(b = \infty\) (floating-point number overflow) can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Then once we make sure the step size upper bound is used to initialize the line
    search
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 8.3.3 (Filter line search, time_integrator.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: and that the contact area weights for all nodes are calculated
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 8.3.4 (Contact area, simulator.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: and passed to our simulator, we can simulate the square drop with mass-spring
    stiffness `k=2e4` and time step size `h=0.01` as shown in [Figure 8.3.1](#fig:lec8:square_drop).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fe71ac94bc531fb47471684d96a9cc21.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8.3.1.** A mass-spring elastic square is dropped onto the ground with
    0 initial velocity under gravity. Here we show the frames when the square is:
    just dropped, first touching the ground, compressed to the maximum in this simulation,
    and becoming static.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Remark 8.3.1 (Contact Layer Integration).*** Since in practice, contact
    forces are only exerted on the boundary of the solids, the barrier potential should
    be integrated only on the boundary as well. This also explains why in our case
    study the contact area weight per node is simply calculated as the diameter of
    the square evenly distributed onto each boundary node. However, as mass-spring
    elasticity cannot guarantee that all interior nodes will stay inside the boundary
    of the solid, we simply apply the barrier potential to all nodal DOFs of the square.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
