["```py\n@ti.func\ndef Drucker_Prager_return_mapping(F, diff_log_J):\n    dim = ti.static(F.n)\n    sin_phi = ti.sin(friction_angle_in_degrees/ 180.0 * ti.math.pi)\n    friction_alpha = ti.sqrt(2.0 / 3.0) * 2.0 * sin_phi / (3.0 - sin_phi)\n    U, sig_diag, V = ti.svd(F)\n    sig = ti.Vector([ti.max(sig_diag[i,i], 0.05) for i in ti.static(range(dim))])\n    epsilon = ti.log(sig)\n    epsilon += diff_log_J / dim # volume correction treatment\n    trace_epsilon = epsilon.sum()\n    shifted_trace = trace_epsilon\n    if shifted_trace >= 0:\n        for d in ti.static(range(dim)):\n            epsilon[d] = 0.\n    else:\n        epsilon_hat = epsilon - (trace_epsilon / dim)\n        epsilon_hat_norm = ti.sqrt(epsilon_hat.dot(epsilon_hat)+1e-8)\n        delta_gamma = epsilon_hat_norm + (dim * lam + 2\\. * mu) / (2\\. * mu) * (shifted_trace) * friction_alpha\n        epsilon -= (ti.max(delta_gamma, 0) / epsilon_hat_norm) * epsilon_hat\n    sig_out = ti.exp(epsilon)\n    for d in ti.static(range(dim)):\n        sig_diag[d,d] = sig_out[d]\n    return U @ sig_diag @ V.transpose() \n```", "```py\n@ti.kernel\ndef update_particle_state():\n    for p in range(N_particles):\n        # trial elastic deformation gradient\n        F_tr = F[p]\n        # apply return mapping to correct the trial elastic state, projecting the stress induced by F_tr\n        # back onto the yield surface, following the direction specified by the plastic flow rule.\n        new_F = Drucker_Prager_return_mapping(F_tr, diff_log_J[p])\n        # track the volume change incurred by return mapping to correct volume, following https://dl.acm.org/doi/10.1145/3072959.3073651 sec 4.3.4\n        diff_log_J[p] += -ti.log(new_F.determinant()) + ti.log(F_tr.determinant()) \n        F[p] = new_F\n        # advection\n        x[p] += dt * v[p] \n```"]