<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Collision Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Collision Detection</h1>
<blockquote>原文：<a href="https://phys-sim-book.github.io/lec24.2-collision_detection.html">https://phys-sim-book.github.io/lec24.2-collision_detection.html</a></blockquote>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"/>

<p>Collision detection in 3D can be significantly more computationally intensive than in 2D due to the larger number of surface primitives involved. Thankfully, spatial data structures like spatial hashing and bounding volume hierarchies (BVH) help efficiently reduce the number of candidate primitive pairs, making continuous collision detection (CCD) more manageable.</p>
<h3 id="spatial-hashing"><a class="header" href="#spatial-hashing">Spatial Hashing</a></h3>
<p>The core idea of spatial hashing is to partition the space into a uniform grid and assign each grid cell an array to store the indices of primitives whose bounding boxes intersect with that cell. To find the nearby primitives of a given primitive <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal">A</span></span></span></span> (e.g., a point), we identify the grid cells intersecting with <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord mathnormal">A</span></span></span></span>'s bounding box and retrieve the primitive indices stored in these cells. This approach ensures that only nearby primitives are checked for collisions using CCD, eliminating the need for a nested loop to examine all primitive pairs.</p>
<h3 id="bounding-volume-hierarchies-bvh"><a class="header" href="#bounding-volume-hierarchies-bvh">Bounding Volume Hierarchies (BVH)</a></h3>
<p>BVH is another effective method for broad-phase collision detection. It organizes primitives into a hierarchy of bounding volumes, allowing for efficient pruning of the search space when detecting potential collisions.</p>
<h3 id="accd-method"><a class="header" href="#accd-method">ACCD Method</a></h3>
<p>The ACCD (Adaptive Continuous Collision Detection) method, as discussed in <a href="./lec21.4-ccd.html">Continuous Collision Detection</a>, is applicable in 3D. In this context, the distance calculations need to be adapted for point-triangle and edge-edge pairs.</p>
<h3 id="broad-phase-collision-detection"><a class="header" href="#broad-phase-collision-detection">Broad Phase Collision Detection</a></h3>
<p>For computing the barrier potential energy, gradient, and Hessian, it is faster and essential to first gather a set of nearby candidate primitive pairs. Then, we compute their distances to determine if they are active (i.e., within a distance <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9579em;"/><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"/><span class="mord mathnormal">d</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"/><span class="accent-body" style="left:-0.0833em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span>). This filtering process is part of the broad-phase collision detection and can be efficiently implemented using spatial hashing or BVH.</p>
<p>By employing these spatial data structures, we significantly reduce the computational load, focusing our detailed collision checks on a manageable subset of nearby primitives.</p>

                        
</body>
</html>