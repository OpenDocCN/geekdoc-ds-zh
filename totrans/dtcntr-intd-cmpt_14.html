<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>5.3¬†Recursive Dataüîó</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>5.3¬†Recursive Dataüîó</h1>
<blockquote>ÂéüÊñáÔºö<a href="https://dcic-world.org/2025-08-27/recursive-data.html">https://dcic-world.org/2025-08-27/recursive-data.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">¬†¬†¬†¬†</span><a href="#%28part._.Functions_to_.Process_.Recursive_.Data%29" class="toclink" data-pltdoc="x">5.3.1<span class="hspace">¬†</span>Functions to Process Recursive Data</a></p></td></tr><tr><td><p><span class="hspace">¬†¬†¬†¬†</span><a href="#%28part._.A_.Template_for_.Processing_.Recursive_.Data%29" class="toclink" data-pltdoc="x">5.3.2<span class="hspace">¬†</span>A Template for Processing Recursive Data</a></p></td></tr><tr><td><p><span class="hspace">¬†¬†¬†¬†</span><a href="#%28part._.The_.Design_.Recipe%29" class="toclink" data-pltdoc="x">5.3.3<span class="hspace">¬†</span>The Design Recipe</a></p></td></tr></table><p>In <a href="intro-struct-data.html#%28part._telling-apart-variants%29" data-pltdoc="x">Telling Apart Variants of Conditional Data</a>, we used <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> to distinguish
between different forms of conditional data. We had used <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>
earlier, specifically to distinguish between empty and non-empty lists
in <a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>. This suggests that lists are also a
form of conditional data, just one that is built into Pyret. Indeed,
this is the case.</p><p>To understand lists as conditional data, let‚Äôs create a data
definition for a new type <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span> which contains a list of
numbers (this differs from built-in lists, which work with any type of
element). To avoid conflicts with Pyret‚Äôs built-in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> value
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> operator, we‚Äôll have <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span> use
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-empty</code></span> as its empty value and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span> as the operator
that builds new lists. Here‚Äôs a partial definition:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data NumList:
  | nl-empty
  | nl-link( _________ )
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Fill in the blank in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span> condition with the
corresponding field(s) and corresponding types. The blank could
contain anywhere from 0 through multiple fields.</p></blockquote></blockquote><p>From working with lists earlier, hopefully you remembered that list
constructors take two inputs: the first element of the list and a list
to build on (the rest of the list). That suggests that we need two
fields here:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data NumList:
  | nl-empty
  | nl-link(first :: _________, rest :: _________ )
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Fill in the types for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> if you haven‚Äôt already.</p></blockquote></blockquote><p>Since we‚Äôre making a list of numbers, the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> field should
contain type <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>. What about the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> field? It needs
to be a list of numbers, so its type should be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data NumList:
  | nl-empty
  | nl-link(first :: Number, rest :: NumList)
end</code></pre></div></div><p>Notice something interesting (and new) here: the type of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> field is the same type (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>) as the conditional
data that we are defining. We can, quite literally, draw the arrows that show the self-referential part of
the definition:</p><p><img src="../Images/8c8f0c1555bb84656f4e12c9faa58d32.png" alt="" width="436" height="199" data-original-src="https://dcic-world.org/2025-08-27/data-defn-arrows.png"/></p><p>Does that actually work? Yes. Think about
how we might build up a list with the numbers 2, 7, and 3 (in that
order). We start with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-empty</code></span>, which is a valid
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>. We then use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span> to add the numbers onto
that list, as follows:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-empty
nl-link(3, nl-empty)
nl-link(7, nl-link(3, nl-empty))
nl-link(2, nl-link(7, nl-link(3, nl-empty)))</code></pre></div></div><p>In each case, the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> argument is itself a valid
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>. While defining data in terms of itself might seem
problematic, it works fine because in order to build actual data, we had to start
with the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-empty</code></span> condition, which does not refer to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>.</p><p>Data definitions that build on fields of the same type are called
<span style="font-style: italic">recursive data</span>. Recursive data definitions are powerful because
they permit us to create data that are
<span class="emph">unbounded</span> or <span class="emph">arbitrarily-sized</span>.  Given a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>, there
is an easy way to make a new, larger one: just use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span>.  So, we
need to consider larger lists:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link(1,
  nl-link(2,
    nl-link(3,
      nl-link(4,
        nl-link(5,
          nl-link(6,
            nl-link(7,
              nl-link(8,
                nl-empty))))</code></pre></div></div><section class="SsectionLevel4" id="section 5.3.1"><h4 class="heading">5.3.1<span class="stt">¬†</span><a name="(part._.Functions_to_.Process_.Recursive_.Data)"/>Functions to Process Recursive Data<span class="button-group"><a href="#(part._.Functions_to_.Process_.Recursive_.Data)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span></h4><p>Let‚Äôs try to write a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3</code></span>, which returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> if
the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span> contains the value <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span> otherwise.</p><p>First, our header:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  doc: "Produces true if the list contains 3, false otherwise"
end</code></pre></div></div><p>Next, some tests:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  doc: "Produces true if the list contains 3, false otherwise"
where:
  contains-3(nl-empty) is false
  contains-3(nl-link(3, nl-empty)) is true
  contains-3(nl-link(1, nl-link(3, nl-empty))) is true
  contains-3(nl-link(1, nl-link(2, nl-link(3, nl-link(4, nl-empty))))) is true
  contains-3(nl-link(1, nl-link(2, nl-link(5, nl-link(4, nl-empty))))) is false
end</code></pre></div></div><p>As we did in <a href="intro-struct-data.html#%28part._process-fields-variants%29" data-pltdoc="x">Processing Fields of Variants</a>, we will use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> to
distinguish the variants. In addition, since we are going to have to
use the fields of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span> to compute a result in that case, we
will list those in the initial code outline:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  doc: "Produces true if the list contains 3, false otherwise"
  cases (NumList) nl:
    | nl-empty =&gt; ...
    | nl-link(first, rest) =&gt;
      ... first ...
      ... rest ...
  end
end</code></pre></div></div><p>Following our examples, the answer must be false in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-empty</code></span> case.  In the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span> case, if the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span>
element is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>, we‚Äôve successfully answered the question.  That
only leaves the case where the argument is an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span> and the
first element does not equal <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        # handle rest here
      end
  end
end</code></pre></div></div><p>Since we know <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> is a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span> (based on the data definition),
we can use a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expression to work with it.  This is sort of like
filling in a part of the template again:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        cases (NumList) rest:
          | nl-empty =&gt; ...
          | nl-link(first-of-rest, rest-of-rest) =&gt;
            ... first-of-rest ...
            ... rest-of-rest ...
        end
      end
  end
end</code></pre></div></div><p>If the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> was empty, then we haven‚Äôt found <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> (just like when
we checked the original argument, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl</code></span>).  If the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> was a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span>, then we need to check if the first thing in the rest of the
list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> or not:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        cases (NumList) rest:
          | nl-empty =&gt; false
          | nl-link(first-of-rest, rest-of-rest) =&gt;
            if first-of-rest == 3:
              true
            else:
              # fill in here ...
            end
        end
      end
  end
end</code></pre></div></div><p>Since <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest-of-rest</code></span> is a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>, we can fill in a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>
for it again:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        cases (NumList) rest:
          | nl-empty =&gt; false
          | nl-link(first-of-rest, rest-of-rest) =&gt;
            if first-of-rest == 3:
              true
            else:
              cases (NumList) rest-of-rest:
                | nl-empty =&gt; ...
                | nl-link(first-of-rest-of-rest, rest-of-rest-of-rest) =&gt;
                  ... first-of-rest-of-rest ...
                  ... rest-of-rest-of-rest ...
              end
            end
        end
      end
  end
end</code></pre></div></div><p>See where this is going?  Not anywhere good.  We can copy this <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>
expression as many times as we want, but we can never answer the question for a
list that is just one element longer than the number of times we copy the code.</p><p>So what to do?  We tried this approach of using another copy of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>
based on the observation that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> is a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>, and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> provides a meaningful way to break apart a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>; in
fact, it‚Äôs what the recipe seems to lead to naturally.</p><p>Let‚Äôs go back to the step where the problem began, after filling in the
template with the first check for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        # what to do with rest?
      end
  end
end</code></pre></div></div><p>We need a way to compute whether or not the value <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> is contained in
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span>.  Looking back at the data definition, we see that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> is
a perfectly valid <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>, simply by the definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span>.
And we have a function (or, most of one) whose job is to figure out if a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span> contains <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> or not: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3</code></span>.  That ought to
be something we can call with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> as an argument, and get back the
value we want:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        contains-3(rest)
      end
  end
end</code></pre></div></div><p>And lo and behold, all of the tests defined above pass.  It‚Äôs useful to step
through what‚Äôs happening when this function is called.  Let‚Äôs look at an
example:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3(nl-link(1, nl-link(3, nl-empty)))</code></pre></div></div><p>First, we substitute the argument value in place of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl</code></span> everywhere
it appears; that‚Äôs just the usual rule for function calls.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  cases (NumList) nl-link(1, nl-link(3, nl-empty)):
       | nl-empty =&gt; false
       | nl-link(first, rest) =&gt;
         if first == 3:
           true
         else:
           contains-3(rest)
         end
     end</code></pre></div></div><p>Next, we find the case that matches the constructor <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span>, and
substitute the corresponding pieces of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span> value for the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> identifiers.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if 1 == 3:
      true
    else:
      contains-3(nl-link(3, nl-empty))
    end</code></pre></div></div><p>Since <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> isn‚Äôt <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>, the comparison evaluates to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>, and this whole expression evaluates to the contents of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">else</code></span> branch.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if false:
      true
    else:
      contains-3(nl-link(3, nl-empty))
    end

=&gt;  contains-3(nl-link(3, nl-empty))</code></pre></div></div><p>This is another function call, so we substitute the value
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link(3, nl-empty)</code></span>, which was the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> field of the original
input, into the body of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3</code></span> this time.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  cases (NumList) nl-link(3, nl-empty):
      | nl-empty =&gt; false
      | nl-link(first, rest) =&gt;
        if first == 3:
          true
        else:
          contains-3(rest)
        end
    end</code></pre></div></div><p>Again, we substitute into the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span> branch.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if 3 == 3:
      true
    else:
      contains-3(nl-empty)
    end</code></pre></div></div><p>This time, since <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>, we take the first branch of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression, and the whole original call evaluates to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if true:
      true
    else:
      contains-3(nl-empty)
    end

=&gt; true</code></pre></div></div><p>An interesting feature of this trace through the evaluation is that we reached
the expression <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3(nl-link(3, nl-empty))</code></span>, which is a normal call
to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3</code></span>; it could even be a test case on its own.  The
implementation works by doing something (checking for equality with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>)
with the non-recursive parts of the datum, and combining that result with the
result of the same operation (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3</code></span>) on the recursive part of the
datum.  This idea of doing recursion with the same function on self-recursive
parts of the datatype lets us extend our template to handle recursive
fields.</p></section><section class="SsectionLevel4" id="section 5.3.2"><h4 class="heading">5.3.2<span class="stt">¬†</span><a name="(part._.A_.Template_for_.Processing_.Recursive_.Data)"/>A Template for Processing Recursive Data<span class="button-group"><a href="#(part._.A_.Template_for_.Processing_.Recursive_.Data)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span></h4><p>Stepping back, we have actually derived a new way to approach writing
functions over recursive data. Back in <a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>, we
had you write functions over lists by writing a sequence of related
examples, using substitution across examples to derive a program that
called the function on the rest of the list. Here, we are deriving
that structure <span class="emph">from the shape of the data itself</span>.</p><p>In particular, we can develop a function over recursive data by
breaking a datum into its variants (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>), pulling out
the fields of each variant (by listing the field names), then calling
the function itself on any recursive fields (fields of the same
type). For <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>, these steps yield the following code outline:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">#|
fun num-list-fun(nl :: NumList) -&gt; ???:
  cases (NumList) nl:
    | nl-empty =&gt; ...
    | nl-link(first, rest) =&gt;
      ... first ...
      ... num-list-fun(rest) ...
  end
end
|#</code></pre></div></div></div><div class="SIntrapara">Here, we are using a generic function name, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-list-fun</code></span>, to
illustrate that this is the outline for <span class="emph">any</span> function that
processes a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>.</div><p>We refer to this code outline as a <span style="font-style: italic">template</span>. Every <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data</code></span>
definition has a corresponding template which captures how to break
a value of that definition into cases, pull out the fields, and use
the same function to process any recursive fields.</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Writing a Template for Recursive Data</p><blockquote class="StrategyBody"><p>Given a recursive data definition, use the following steps to create
the (reusable) template for that definition:</p><ol><li><p>Create a function header (using a general-purpose
placeholder name if you aren‚Äôt yet writing a specific function).</p></li><li><p>Use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> to break the recursive-data input into its
variants.</p></li><li><p>In each case, list each of its fields in the answer portion of
the case.</p></li><li><p>Call the function itself on any recursive fields.</p></li></ol></blockquote></blockquote><p>The power of the template lies in its universality. If you are asked
to write a specific function (such as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3</code></span>) over
recursive data (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>), you can reproduce or copy (if you
already wrote it down) the template, replace the generic function name
in the template with the one for your specific function, then fill in
the ellipses to finish the function.</p><p>When you see a recursive data definition (of which
there will be <span class="emph">many</span> when programming in Pyret), you should naturally start thinking
about what the recursive calls will return and how to combine their results
with the other, non-recursive pieces of the datatype.</p><p>You have now seen two approaches to writing functions on recursive data:
working out a sequence of related examples and modifying the
template. Both approaches get you to the same final function. The
power of the template, however, is that it scales to more complicated
data definitions (where writing examples by hand would prove
tedious). We will see examples of this as our data get more complex in
coming chapters.</p></section><section class="SsectionLevel4" id="section 5.3.3"><h4 class="heading">5.3.3<span class="stt">¬†</span><a name="(part._.The_.Design_.Recipe)"/>The Design Recipe<span class="button-group"><a href="#(part._.The_.Design_.Recipe)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span></h4><p>We‚Äôve showed you many techniques to use while designing programs,
including developing examples, writing tests, and now writing and
using data templates. Putting the pieces together yields a
<span class="emph">design recipe</span>, adapted from that in
<a href="https://htdp.org/"><span class="emph">How to Design Programs</span></a>,
that we can follow for designing recursive
functions.</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: The Design Recipe</p><blockquote class="StrategyBody"><p>Given a programming problem over recursive data:</p><ol><li><p>Create a function header, including the function name and
contract. The name will be necessary to make recursive calls, while
the contract guides the design of the body.</p></li><li><p>Aided by the contract, which tells you what <span class="emph">kind</span> of data
to consume and produce, write several illustrative examples of the
function‚Äôs input and outputs, using <span class="emph">concrete</span> data. Include
examples in which the input data of one extends the input data of
another. This will later help you fill in the function.</p></li><li><p>The function‚Äôs contract tells you what kind of data you are
processing. From the definition of the data, write out the template
for it.</p></li><li><p>Adapt this template to the computation required by this specific
problem. Use your examples to figure out how to fill in each case. You
should have written an example for each case of data in the
template. This is also where writing examples where input extended the
other helps: the difference in output becomes the function
body. See the several examples of this in <a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>.</p></li><li><p>Run your examples to make sure your function behaves as you expect.</p></li><li><p>Now start writing more fine-grained tests to confirm that you
should be confident in your function. In particular, while the
examples (which were written before you wrote the body of the
function) focus on the expected ‚Äúinput-output‚Äù behavior, now that
you have a concrete implementation, you should write tests that focus
on its details.</p></li></ol></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Use the design recipe to write a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-n</code></span> that takes a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span> and a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>, and returns whether that number is in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Use the design recipe to write a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum</code></span> that takes a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>, and returns the sum of all the numbers in it.  The sum of the
empty list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Use the design recipe to write a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">remove-3</code></span> that takes a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>, and returns a new <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span> with any <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>‚Äôs
removed.  The remaining elements should all be in the list in the same order
they were in the input.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a data definition called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumListList</code></span> that represents a list
of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>s, and use the design recipe to write a function
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-of-lists</code></span> that takes a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumListList</code></span> and produces a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span> containing the sums of the sub-lists.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a data definition and corresponding template for
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">StrList</code></span>, which captures lists of strings.</p></blockquote></blockquote></section>&#13;
<h4 class="heading">5.3.1<span class="stt">¬†</span><a name="(part._.Functions_to_.Process_.Recursive_.Data)"/>Functions to Process Recursive Data<span class="button-group"><a href="#(part._.Functions_to_.Process_.Recursive_.Data)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span></h4><p>Let‚Äôs try to write a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3</code></span>, which returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> if
the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span> contains the value <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span> otherwise.</p><p>First, our header:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  doc: "Produces true if the list contains 3, false otherwise"
end</code></pre></div></div><p>Next, some tests:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  doc: "Produces true if the list contains 3, false otherwise"
where:
  contains-3(nl-empty) is false
  contains-3(nl-link(3, nl-empty)) is true
  contains-3(nl-link(1, nl-link(3, nl-empty))) is true
  contains-3(nl-link(1, nl-link(2, nl-link(3, nl-link(4, nl-empty))))) is true
  contains-3(nl-link(1, nl-link(2, nl-link(5, nl-link(4, nl-empty))))) is false
end</code></pre></div></div><p>As we did in <a href="intro-struct-data.html#%28part._process-fields-variants%29" data-pltdoc="x">Processing Fields of Variants</a>, we will use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> to
distinguish the variants. In addition, since we are going to have to
use the fields of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span> to compute a result in that case, we
will list those in the initial code outline:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  doc: "Produces true if the list contains 3, false otherwise"
  cases (NumList) nl:
    | nl-empty =&gt; ...
    | nl-link(first, rest) =&gt;
      ... first ...
      ... rest ...
  end
end</code></pre></div></div><p>Following our examples, the answer must be false in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-empty</code></span> case.  In the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span> case, if the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span>
element is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>, we‚Äôve successfully answered the question.  That
only leaves the case where the argument is an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span> and the
first element does not equal <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        # handle rest here
      end
  end
end</code></pre></div></div><p>Since we know <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> is a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span> (based on the data definition),
we can use a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expression to work with it.  This is sort of like
filling in a part of the template again:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        cases (NumList) rest:
          | nl-empty =&gt; ...
          | nl-link(first-of-rest, rest-of-rest) =&gt;
            ... first-of-rest ...
            ... rest-of-rest ...
        end
      end
  end
end</code></pre></div></div><p>If the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> was empty, then we haven‚Äôt found <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> (just like when
we checked the original argument, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl</code></span>).  If the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> was a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span>, then we need to check if the first thing in the rest of the
list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> or not:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        cases (NumList) rest:
          | nl-empty =&gt; false
          | nl-link(first-of-rest, rest-of-rest) =&gt;
            if first-of-rest == 3:
              true
            else:
              # fill in here ...
            end
        end
      end
  end
end</code></pre></div></div><p>Since <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest-of-rest</code></span> is a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>, we can fill in a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>
for it again:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        cases (NumList) rest:
          | nl-empty =&gt; false
          | nl-link(first-of-rest, rest-of-rest) =&gt;
            if first-of-rest == 3:
              true
            else:
              cases (NumList) rest-of-rest:
                | nl-empty =&gt; ...
                | nl-link(first-of-rest-of-rest, rest-of-rest-of-rest) =&gt;
                  ... first-of-rest-of-rest ...
                  ... rest-of-rest-of-rest ...
              end
            end
        end
      end
  end
end</code></pre></div></div><p>See where this is going?  Not anywhere good.  We can copy this <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>
expression as many times as we want, but we can never answer the question for a
list that is just one element longer than the number of times we copy the code.</p><p>So what to do?  We tried this approach of using another copy of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>
based on the observation that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> is a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>, and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> provides a meaningful way to break apart a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>; in
fact, it‚Äôs what the recipe seems to lead to naturally.</p><p>Let‚Äôs go back to the step where the problem began, after filling in the
template with the first check for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        # what to do with rest?
      end
  end
end</code></pre></div></div><p>We need a way to compute whether or not the value <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> is contained in
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span>.  Looking back at the data definition, we see that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> is
a perfectly valid <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>, simply by the definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span>.
And we have a function (or, most of one) whose job is to figure out if a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span> contains <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> or not: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3</code></span>.  That ought to
be something we can call with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> as an argument, and get back the
value we want:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        contains-3(rest)
      end
  end
end</code></pre></div></div><p>And lo and behold, all of the tests defined above pass.  It‚Äôs useful to step
through what‚Äôs happening when this function is called.  Let‚Äôs look at an
example:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3(nl-link(1, nl-link(3, nl-empty)))</code></pre></div></div><p>First, we substitute the argument value in place of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl</code></span> everywhere
it appears; that‚Äôs just the usual rule for function calls.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  cases (NumList) nl-link(1, nl-link(3, nl-empty)):
       | nl-empty =&gt; false
       | nl-link(first, rest) =&gt;
         if first == 3:
           true
         else:
           contains-3(rest)
         end
     end</code></pre></div></div><p>Next, we find the case that matches the constructor <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span>, and
substitute the corresponding pieces of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span> value for the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> identifiers.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if 1 == 3:
      true
    else:
      contains-3(nl-link(3, nl-empty))
    end</code></pre></div></div><p>Since <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> isn‚Äôt <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>, the comparison evaluates to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>, and this whole expression evaluates to the contents of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">else</code></span> branch.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if false:
      true
    else:
      contains-3(nl-link(3, nl-empty))
    end

=&gt;  contains-3(nl-link(3, nl-empty))</code></pre></div></div><p>This is another function call, so we substitute the value
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link(3, nl-empty)</code></span>, which was the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> field of the original
input, into the body of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3</code></span> this time.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  cases (NumList) nl-link(3, nl-empty):
      | nl-empty =&gt; false
      | nl-link(first, rest) =&gt;
        if first == 3:
          true
        else:
          contains-3(rest)
        end
    end</code></pre></div></div><p>Again, we substitute into the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link</code></span> branch.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if 3 == 3:
      true
    else:
      contains-3(nl-empty)
    end</code></pre></div></div><p>This time, since <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>, we take the first branch of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression, and the whole original call evaluates to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if true:
      true
    else:
      contains-3(nl-empty)
    end

=&gt; true</code></pre></div></div><p>An interesting feature of this trace through the evaluation is that we reached
the expression <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3(nl-link(3, nl-empty))</code></span>, which is a normal call
to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3</code></span>; it could even be a test case on its own.  The
implementation works by doing something (checking for equality with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>)
with the non-recursive parts of the datum, and combining that result with the
result of the same operation (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3</code></span>) on the recursive part of the
datum.  This idea of doing recursion with the same function on self-recursive
parts of the datatype lets us extend our template to handle recursive
fields.</p>&#13;
<h4 class="heading">5.3.2<span class="stt">¬†</span><a name="(part._.A_.Template_for_.Processing_.Recursive_.Data)"/>A Template for Processing Recursive Data<span class="button-group"><a href="#(part._.A_.Template_for_.Processing_.Recursive_.Data)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span></h4><p>Stepping back, we have actually derived a new way to approach writing
functions over recursive data. Back in <a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>, we
had you write functions over lists by writing a sequence of related
examples, using substitution across examples to derive a program that
called the function on the rest of the list. Here, we are deriving
that structure <span class="emph">from the shape of the data itself</span>.</p><p>In particular, we can develop a function over recursive data by
breaking a datum into its variants (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>), pulling out
the fields of each variant (by listing the field names), then calling
the function itself on any recursive fields (fields of the same
type). For <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>, these steps yield the following code outline:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">#|
fun num-list-fun(nl :: NumList) -&gt; ???:
  cases (NumList) nl:
    | nl-empty =&gt; ...
    | nl-link(first, rest) =&gt;
      ... first ...
      ... num-list-fun(rest) ...
  end
end
|#</code></pre></div></div></div><div class="SIntrapara">Here, we are using a generic function name, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-list-fun</code></span>, to
illustrate that this is the outline for <span class="emph">any</span> function that
processes a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>.</div><p>We refer to this code outline as a <span style="font-style: italic">template</span>. Every <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data</code></span>
definition has a corresponding template which captures how to break
a value of that definition into cases, pull out the fields, and use
the same function to process any recursive fields.</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Writing a Template for Recursive Data</p><blockquote class="StrategyBody"><p>Given a recursive data definition, use the following steps to create
the (reusable) template for that definition:</p><ol><li><p>Create a function header (using a general-purpose
placeholder name if you aren‚Äôt yet writing a specific function).</p></li><li><p>Use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> to break the recursive-data input into its
variants.</p></li><li><p>In each case, list each of its fields in the answer portion of
the case.</p></li><li><p>Call the function itself on any recursive fields.</p></li></ol></blockquote></blockquote><p>The power of the template lies in its universality. If you are asked
to write a specific function (such as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3</code></span>) over
recursive data (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>), you can reproduce or copy (if you
already wrote it down) the template, replace the generic function name
in the template with the one for your specific function, then fill in
the ellipses to finish the function.</p><p>When you see a recursive data definition (of which
there will be <span class="emph">many</span> when programming in Pyret), you should naturally start thinking
about what the recursive calls will return and how to combine their results
with the other, non-recursive pieces of the datatype.</p><p>You have now seen two approaches to writing functions on recursive data:
working out a sequence of related examples and modifying the
template. Both approaches get you to the same final function. The
power of the template, however, is that it scales to more complicated
data definitions (where writing examples by hand would prove
tedious). We will see examples of this as our data get more complex in
coming chapters.</p>&#13;
<h4 class="heading">5.3.3<span class="stt">¬†</span><a name="(part._.The_.Design_.Recipe)"/>The Design Recipe<span class="button-group"><a href="#(part._.The_.Design_.Recipe)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span></h4><p>We‚Äôve showed you many techniques to use while designing programs,
including developing examples, writing tests, and now writing and
using data templates. Putting the pieces together yields a
<span class="emph">design recipe</span>, adapted from that in
<a href="https://htdp.org/"><span class="emph">How to Design Programs</span></a>,
that we can follow for designing recursive
functions.</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: The Design Recipe</p><blockquote class="StrategyBody"><p>Given a programming problem over recursive data:</p><ol><li><p>Create a function header, including the function name and
contract. The name will be necessary to make recursive calls, while
the contract guides the design of the body.</p></li><li><p>Aided by the contract, which tells you what <span class="emph">kind</span> of data
to consume and produce, write several illustrative examples of the
function‚Äôs input and outputs, using <span class="emph">concrete</span> data. Include
examples in which the input data of one extends the input data of
another. This will later help you fill in the function.</p></li><li><p>The function‚Äôs contract tells you what kind of data you are
processing. From the definition of the data, write out the template
for it.</p></li><li><p>Adapt this template to the computation required by this specific
problem. Use your examples to figure out how to fill in each case. You
should have written an example for each case of data in the
template. This is also where writing examples where input extended the
other helps: the difference in output becomes the function
body. See the several examples of this in <a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>.</p></li><li><p>Run your examples to make sure your function behaves as you expect.</p></li><li><p>Now start writing more fine-grained tests to confirm that you
should be confident in your function. In particular, while the
examples (which were written before you wrote the body of the
function) focus on the expected ‚Äúinput-output‚Äù behavior, now that
you have a concrete implementation, you should write tests that focus
on its details.</p></li></ol></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Use the design recipe to write a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-n</code></span> that takes a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span> and a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>, and returns whether that number is in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Use the design recipe to write a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum</code></span> that takes a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>, and returns the sum of all the numbers in it.  The sum of the
empty list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Use the design recipe to write a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">remove-3</code></span> that takes a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>, and returns a new <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span> with any <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>‚Äôs
removed.  The remaining elements should all be in the list in the same order
they were in the input.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a data definition called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumListList</code></span> that represents a list
of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span>s, and use the design recipe to write a function
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum-of-lists</code></span> that takes a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumListList</code></span> and produces a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">NumList</code></span> containing the sums of the sub-lists.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a data definition and corresponding template for
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">StrList</code></span>, which captures lists of strings.</p></blockquote></blockquote>    
</body>
</html>