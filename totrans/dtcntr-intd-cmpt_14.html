<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>5.3¬†Recursive Dataüîó</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>5.3¬†Recursive Dataüîó</h1>
<blockquote>ÂéüÊñáÔºö<a href="https://dcic-world.org/2025-08-27/recursive-data.html">https://dcic-world.org/2025-08-27/recursive-data.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>¬†¬†¬†¬†<a href="#%28part._.Functions_to_.Process_.Recursive_.Data%29" class="toclink" data-pltdoc="x">5.3.1¬†Functions to Process Recursive Data</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._.A_.Template_for_.Processing_.Recursive_.Data%29" class="toclink" data-pltdoc="x">5.3.2¬†A Template for Processing Recursive Data</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._.The_.Design_.Recipe%29" class="toclink" data-pltdoc="x">5.3.3¬†The Design Recipe</a></p></td></tr></table><p>In <a href="intro-struct-data.html#%28part._telling-apart-variants%29" data-pltdoc="x">Telling Apart Variants of Conditional Data</a>, we used <code data-lang="pyret" class="sourceCode">cases</code> to distinguish
between different forms of conditional data. We had used <code data-lang="pyret" class="sourceCode">cases</code>
earlier, specifically to distinguish between empty and non-empty lists
in <a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>. This suggests that lists are also a
form of conditional data, just one that is built into Pyret. Indeed,
this is the case.</p><p>To understand lists as conditional data, let‚Äôs create a data
definition for a new type <code data-lang="pyret" class="sourceCode">NumList</code> which contains a list of
numbers (this differs from built-in lists, which work with any type of
element). To avoid conflicts with Pyret‚Äôs built-in <code data-lang="pyret" class="sourceCode">empty</code> value
and <code data-lang="pyret" class="sourceCode">link</code> operator, we‚Äôll have <code data-lang="pyret" class="sourceCode">NumList</code> use
<code data-lang="pyret" class="sourceCode">nl-empty</code> as its empty value and <code data-lang="pyret" class="sourceCode">nl-link</code> as the operator
that builds new lists. Here‚Äôs a partial definition:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data NumList:
  | nl-empty
  | nl-link( _________ )
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Fill in the blank in the <code data-lang="pyret" class="sourceCode">nl-link</code> condition with the
corresponding field(s) and corresponding types. The blank could
contain anywhere from 0 through multiple fields.</p></blockquote></blockquote><p>From working with lists earlier, hopefully you remembered that list
constructors take two inputs: the first element of the list and a list
to build on (the rest of the list). That suggests that we need two
fields here:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data NumList:
  | nl-empty
  | nl-link(first :: _________, rest :: _________ )
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Fill in the types for <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> if you haven‚Äôt already.</p></blockquote></blockquote><p>Since we‚Äôre making a list of numbers, the <code data-lang="pyret" class="sourceCode">first</code> field should
contain type <code data-lang="pyret" class="sourceCode">Number</code>. What about the <code data-lang="pyret" class="sourceCode">rest</code> field? It needs
to be a list of numbers, so its type should be <code data-lang="pyret" class="sourceCode">NumList</code>.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data NumList:
  | nl-empty
  | nl-link(first :: Number, rest :: NumList)
end</code></pre><p>Notice something interesting (and new) here: the type of the
<code data-lang="pyret" class="sourceCode">rest</code> field is the same type (<code data-lang="pyret" class="sourceCode">NumList</code>) as the conditional
data that we are defining. We can, quite literally, draw the arrows that show the self-referential part of
the definition:</p><p><img src="../Images/8c8f0c1555bb84656f4e12c9faa58d32.png" alt="" width="436" height="199" data-original-src="https://dcic-world.org/2025-08-27/data-defn-arrows.png"/></p><p>Does that actually work? Yes. Think about
how we might build up a list with the numbers 2, 7, and 3 (in that
order). We start with <code data-lang="pyret" class="sourceCode">nl-empty</code>, which is a valid
<code data-lang="pyret" class="sourceCode">NumList</code>. We then use <code data-lang="pyret" class="sourceCode">nl-link</code> to add the numbers onto
that list, as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-empty
nl-link(3, nl-empty)
nl-link(7, nl-link(3, nl-empty))
nl-link(2, nl-link(7, nl-link(3, nl-empty)))</code></pre><p>In each case, the <code data-lang="pyret" class="sourceCode">rest</code> argument is itself a valid
<code data-lang="pyret" class="sourceCode">NumList</code>. While defining data in terms of itself might seem
problematic, it works fine because in order to build actual data, we had to start
with the <code data-lang="pyret" class="sourceCode">nl-empty</code> condition, which does not refer to
<code data-lang="pyret" class="sourceCode">NumList</code>.</p><p>Data definitions that build on fields of the same type are called
recursive data. Recursive data definitions are powerful because
they permit us to create data that are
unbounded or arbitrarily-sized.  Given a <code data-lang="pyret" class="sourceCode">NumList</code>, there
is an easy way to make a new, larger one: just use <code data-lang="pyret" class="sourceCode">nl-link</code>.  So, we
need to consider larger lists:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nl-link(1,
  nl-link(2,
    nl-link(3,
      nl-link(4,
        nl-link(5,
          nl-link(6,
            nl-link(7,
              nl-link(8,
                nl-empty))))</code></pre><section class="SsectionLevel4" id="section 5.3.1"><h4 class="heading">5.3.1¬†<a name="(part._.Functions_to_.Process_.Recursive_.Data)"/>Functions to Process Recursive Data<a href="#(part._.Functions_to_.Process_.Recursive_.Data)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Let‚Äôs try to write a function <code data-lang="pyret" class="sourceCode">contains-3</code>, which returns <code data-lang="pyret" class="sourceCode">true</code> if
the <code data-lang="pyret" class="sourceCode">NumList</code> contains the value <code data-lang="pyret" class="sourceCode">3</code>, and <code data-lang="pyret" class="sourceCode">false</code> otherwise.</p><p>First, our header:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  doc: "Produces true if the list contains 3, false otherwise"
end</code></pre><p>Next, some tests:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  doc: "Produces true if the list contains 3, false otherwise"
where:
  contains-3(nl-empty) is false
  contains-3(nl-link(3, nl-empty)) is true
  contains-3(nl-link(1, nl-link(3, nl-empty))) is true
  contains-3(nl-link(1, nl-link(2, nl-link(3, nl-link(4, nl-empty))))) is true
  contains-3(nl-link(1, nl-link(2, nl-link(5, nl-link(4, nl-empty))))) is false
end</code></pre><p>As we did in <a href="intro-struct-data.html#%28part._process-fields-variants%29" data-pltdoc="x">Processing Fields of Variants</a>, we will use <code data-lang="pyret" class="sourceCode">cases</code> to
distinguish the variants. In addition, since we are going to have to
use the fields of <code data-lang="pyret" class="sourceCode">nl-link</code> to compute a result in that case, we
will list those in the initial code outline:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  doc: "Produces true if the list contains 3, false otherwise"
  cases (NumList) nl:
    | nl-empty =&gt; ...
    | nl-link(first, rest) =&gt;
      ... first ...
      ... rest ...
  end
end</code></pre><p>Following our examples, the answer must be false in the
<code data-lang="pyret" class="sourceCode">nl-empty</code> case.  In the <code data-lang="pyret" class="sourceCode">nl-link</code> case, if the <code data-lang="pyret" class="sourceCode">first</code>
element is <code data-lang="pyret" class="sourceCode">3</code>, we‚Äôve successfully answered the question.  That
only leaves the case where the argument is an <code data-lang="pyret" class="sourceCode">nl-link</code> and the
first element does not equal <code data-lang="pyret" class="sourceCode">3</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        # handle rest here
      end
  end
end</code></pre><p>Since we know <code data-lang="pyret" class="sourceCode">rest</code> is a <code data-lang="pyret" class="sourceCode">NumList</code> (based on the data definition),
we can use a <code data-lang="pyret" class="sourceCode">cases</code> expression to work with it.  This is sort of like
filling in a part of the template again:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        cases (NumList) rest:
          | nl-empty =&gt; ...
          | nl-link(first-of-rest, rest-of-rest) =&gt;
            ... first-of-rest ...
            ... rest-of-rest ...
        end
      end
  end
end</code></pre><p>If the <code data-lang="pyret" class="sourceCode">rest</code> was empty, then we haven‚Äôt found <code data-lang="pyret" class="sourceCode">3</code> (just like when
we checked the original argument, <code data-lang="pyret" class="sourceCode">nl</code>).  If the <code data-lang="pyret" class="sourceCode">rest</code> was a
<code data-lang="pyret" class="sourceCode">nl-link</code>, then we need to check if the first thing in the rest of the
list is <code data-lang="pyret" class="sourceCode">3</code> or not:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        cases (NumList) rest:
          | nl-empty =&gt; false
          | nl-link(first-of-rest, rest-of-rest) =&gt;
            if first-of-rest == 3:
              true
            else:
              # fill in here ...
            end
        end
      end
  end
end</code></pre><p>Since <code data-lang="pyret" class="sourceCode">rest-of-rest</code> is a <code data-lang="pyret" class="sourceCode">NumList</code>, we can fill in a <code data-lang="pyret" class="sourceCode">cases</code>
for it again:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        cases (NumList) rest:
          | nl-empty =&gt; false
          | nl-link(first-of-rest, rest-of-rest) =&gt;
            if first-of-rest == 3:
              true
            else:
              cases (NumList) rest-of-rest:
                | nl-empty =&gt; ...
                | nl-link(first-of-rest-of-rest, rest-of-rest-of-rest) =&gt;
                  ... first-of-rest-of-rest ...
                  ... rest-of-rest-of-rest ...
              end
            end
        end
      end
  end
end</code></pre><p>See where this is going?  Not anywhere good.  We can copy this <code data-lang="pyret" class="sourceCode">cases</code>
expression as many times as we want, but we can never answer the question for a
list that is just one element longer than the number of times we copy the code.</p><p>So what to do?  We tried this approach of using another copy of <code data-lang="pyret" class="sourceCode">cases</code>
based on the observation that <code data-lang="pyret" class="sourceCode">rest</code> is a <code data-lang="pyret" class="sourceCode">NumList</code>, and
<code data-lang="pyret" class="sourceCode">cases</code> provides a meaningful way to break apart a <code data-lang="pyret" class="sourceCode">NumList</code>; in
fact, it‚Äôs what the recipe seems to lead to naturally.</p><p>Let‚Äôs go back to the step where the problem began, after filling in the
template with the first check for <code data-lang="pyret" class="sourceCode">3</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        # what to do with rest?
      end
  end
end</code></pre><p>We need a way to compute whether or not the value <code data-lang="pyret" class="sourceCode">3</code> is contained in
<code data-lang="pyret" class="sourceCode">rest</code>.  Looking back at the data definition, we see that <code data-lang="pyret" class="sourceCode">rest</code> is
a perfectly valid <code data-lang="pyret" class="sourceCode">NumList</code>, simply by the definition of <code data-lang="pyret" class="sourceCode">nl-link</code>.
And we have a function (or, most of one) whose job is to figure out if a
<code data-lang="pyret" class="sourceCode">NumList</code> contains <code data-lang="pyret" class="sourceCode">3</code> or not: <code data-lang="pyret" class="sourceCode">contains-3</code>.  That ought to
be something we can call with <code data-lang="pyret" class="sourceCode">rest</code> as an argument, and get back the
value we want:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        contains-3(rest)
      end
  end
end</code></pre><p>And lo and behold, all of the tests defined above pass.  It‚Äôs useful to step
through what‚Äôs happening when this function is called.  Let‚Äôs look at an
example:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3(nl-link(1, nl-link(3, nl-empty)))</code></pre><p>First, we substitute the argument value in place of <code data-lang="pyret" class="sourceCode">nl</code> everywhere
it appears; that‚Äôs just the usual rule for function calls.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  cases (NumList) nl-link(1, nl-link(3, nl-empty)):
       | nl-empty =&gt; false
       | nl-link(first, rest) =&gt;
         if first == 3:
           true
         else:
           contains-3(rest)
         end
     end</code></pre><p>Next, we find the case that matches the constructor <code data-lang="pyret" class="sourceCode">nl-link</code>, and
substitute the corresponding pieces of the <code data-lang="pyret" class="sourceCode">nl-link</code> value for the
<code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> identifiers.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if 1 == 3:
      true
    else:
      contains-3(nl-link(3, nl-empty))
    end</code></pre><p>Since <code data-lang="pyret" class="sourceCode">1</code> isn‚Äôt <code data-lang="pyret" class="sourceCode">3</code>, the comparison evaluates to
<code data-lang="pyret" class="sourceCode">false</code>, and this whole expression evaluates to the contents of the
<code data-lang="pyret" class="sourceCode">else</code> branch.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if false:
      true
    else:
      contains-3(nl-link(3, nl-empty))
    end

=&gt;  contains-3(nl-link(3, nl-empty))</code></pre><p>This is another function call, so we substitute the value
<code data-lang="pyret" class="sourceCode">nl-link(3, nl-empty)</code>, which was the <code data-lang="pyret" class="sourceCode">rest</code> field of the original
input, into the body of <code data-lang="pyret" class="sourceCode">contains-3</code> this time.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  cases (NumList) nl-link(3, nl-empty):
      | nl-empty =&gt; false
      | nl-link(first, rest) =&gt;
        if first == 3:
          true
        else:
          contains-3(rest)
        end
    end</code></pre><p>Again, we substitute into the <code data-lang="pyret" class="sourceCode">nl-link</code> branch.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if 3 == 3:
      true
    else:
      contains-3(nl-empty)
    end</code></pre><p>This time, since <code data-lang="pyret" class="sourceCode">3</code> is <code data-lang="pyret" class="sourceCode">3</code>, we take the first branch of the
<code data-lang="pyret" class="sourceCode">if</code> expression, and the whole original call evaluates to <code data-lang="pyret" class="sourceCode">true</code>.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if true:
      true
    else:
      contains-3(nl-empty)
    end

=&gt; true</code></pre><p>An interesting feature of this trace through the evaluation is that we reached
the expression <code data-lang="pyret" class="sourceCode">contains-3(nl-link(3, nl-empty))</code>, which is a normal call
to <code data-lang="pyret" class="sourceCode">contains-3</code>; it could even be a test case on its own.  The
implementation works by doing something (checking for equality with <code data-lang="pyret" class="sourceCode">3</code>)
with the non-recursive parts of the datum, and combining that result with the
result of the same operation (<code data-lang="pyret" class="sourceCode">contains-3</code>) on the recursive part of the
datum.  This idea of doing recursion with the same function on self-recursive
parts of the datatype lets us extend our template to handle recursive
fields.</p></section><section class="SsectionLevel4" id="section 5.3.2"><h4 class="heading">5.3.2¬†<a name="(part._.A_.Template_for_.Processing_.Recursive_.Data)"/>A Template for Processing Recursive Data<a href="#(part._.A_.Template_for_.Processing_.Recursive_.Data)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Stepping back, we have actually derived a new way to approach writing
functions over recursive data. Back in <a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>, we
had you write functions over lists by writing a sequence of related
examples, using substitution across examples to derive a program that
called the function on the rest of the list. Here, we are deriving
that structure from the shape of the data itself.</p><p>In particular, we can develop a function over recursive data by
breaking a datum into its variants (using <code data-lang="pyret" class="sourceCode">cases</code>), pulling out
the fields of each variant (by listing the field names), then calling
the function itself on any recursive fields (fields of the same
type). For <code data-lang="pyret" class="sourceCode">NumList</code>, these steps yield the following code outline:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">#|
fun num-list-fun(nl :: NumList) -&gt; ???:
  cases (NumList) nl:
    | nl-empty =&gt; ...
    | nl-link(first, rest) =&gt;
      ... first ...
      ... num-list-fun(rest) ...
  end
end
|#</code></pre><p>Here, we are using a generic function name, <code data-lang="pyret" class="sourceCode">num-list-fun</code>, to
illustrate that this is the outline for any function that
processes a <code data-lang="pyret" class="sourceCode">NumList</code>.</p><p>We refer to this code outline as a template. Every <code data-lang="pyret" class="sourceCode">data</code>
definition has a corresponding template which captures how to break
a value of that definition into cases, pull out the fields, and use
the same function to process any recursive fields.</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Writing a Template for Recursive Data</p><blockquote class="StrategyBody"><p>Given a recursive data definition, use the following steps to create
the (reusable) template for that definition:</p><ol><li><p>Create a function header (using a general-purpose
placeholder name if you aren‚Äôt yet writing a specific function).</p></li><li><p>Use <code data-lang="pyret" class="sourceCode">cases</code> to break the recursive-data input into its
variants.</p></li><li><p>In each case, list each of its fields in the answer portion of
the case.</p></li><li><p>Call the function itself on any recursive fields.</p></li></ol></blockquote></blockquote><p>The power of the template lies in its universality. If you are asked
to write a specific function (such as <code data-lang="pyret" class="sourceCode">contains-3</code>) over
recursive data (<code data-lang="pyret" class="sourceCode">NumList</code>), you can reproduce or copy (if you
already wrote it down) the template, replace the generic function name
in the template with the one for your specific function, then fill in
the ellipses to finish the function.</p><p>When you see a recursive data definition (of which
there will be many when programming in Pyret), you should naturally start thinking
about what the recursive calls will return and how to combine their results
with the other, non-recursive pieces of the datatype.</p><p>You have now seen two approaches to writing functions on recursive data:
working out a sequence of related examples and modifying the
template. Both approaches get you to the same final function. The
power of the template, however, is that it scales to more complicated
data definitions (where writing examples by hand would prove
tedious). We will see examples of this as our data get more complex in
coming chapters.</p></section><section class="SsectionLevel4" id="section 5.3.3"><h4 class="heading">5.3.3¬†<a name="(part._.The_.Design_.Recipe)"/>The Design Recipe<a href="#(part._.The_.Design_.Recipe)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>We‚Äôve showed you many techniques to use while designing programs,
including developing examples, writing tests, and now writing and
using data templates. Putting the pieces together yields a
design recipe, adapted from that in
<a href="https://htdp.org/">How to Design Programs</a>,
that we can follow for designing recursive
functions.</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: The Design Recipe</p><blockquote class="StrategyBody"><p>Given a programming problem over recursive data:</p><ol><li><p>Create a function header, including the function name and
contract. The name will be necessary to make recursive calls, while
the contract guides the design of the body.</p></li><li><p>Aided by the contract, which tells you what kind of data
to consume and produce, write several illustrative examples of the
function‚Äôs input and outputs, using concrete data. Include
examples in which the input data of one extends the input data of
another. This will later help you fill in the function.</p></li><li><p>The function‚Äôs contract tells you what kind of data you are
processing. From the definition of the data, write out the template
for it.</p></li><li><p>Adapt this template to the computation required by this specific
problem. Use your examples to figure out how to fill in each case. You
should have written an example for each case of data in the
template. This is also where writing examples where input extended the
other helps: the difference in output becomes the function
body. See the several examples of this in <a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>.</p></li><li><p>Run your examples to make sure your function behaves as you expect.</p></li><li><p>Now start writing more fine-grained tests to confirm that you
should be confident in your function. In particular, while the
examples (which were written before you wrote the body of the
function) focus on the expected ‚Äúinput-output‚Äù behavior, now that
you have a concrete implementation, you should write tests that focus
on its details.</p></li></ol></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Use the design recipe to write a function <code data-lang="pyret" class="sourceCode">contains-n</code> that takes a
<code data-lang="pyret" class="sourceCode">NumList</code> and a <code data-lang="pyret" class="sourceCode">Number</code>, and returns whether that number is in the
<code data-lang="pyret" class="sourceCode">NumList</code>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Use the design recipe to write a function <code data-lang="pyret" class="sourceCode">sum</code> that takes a
<code data-lang="pyret" class="sourceCode">NumList</code>, and returns the sum of all the numbers in it.  The sum of the
empty list is <code data-lang="pyret" class="sourceCode">0</code>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Use the design recipe to write a function <code data-lang="pyret" class="sourceCode">remove-3</code> that takes a
<code data-lang="pyret" class="sourceCode">NumList</code>, and returns a new <code data-lang="pyret" class="sourceCode">NumList</code> with any <code data-lang="pyret" class="sourceCode">3</code>‚Äôs
removed.  The remaining elements should all be in the list in the same order
they were in the input.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a data definition called <code data-lang="pyret" class="sourceCode">NumListList</code> that represents a list
of <code data-lang="pyret" class="sourceCode">NumList</code>s, and use the design recipe to write a function
<code data-lang="pyret" class="sourceCode">sum-of-lists</code> that takes a <code data-lang="pyret" class="sourceCode">NumListList</code> and produces a
<code data-lang="pyret" class="sourceCode">NumList</code> containing the sums of the sub-lists.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a data definition and corresponding template for
<code data-lang="pyret" class="sourceCode">StrList</code>, which captures lists of strings.</p></blockquote></blockquote></section>&#13;
<h4 class="heading">5.3.1¬†<a name="(part._.Functions_to_.Process_.Recursive_.Data)"/>Functions to Process Recursive Data<a href="#(part._.Functions_to_.Process_.Recursive_.Data)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Let‚Äôs try to write a function <code data-lang="pyret" class="sourceCode">contains-3</code>, which returns <code data-lang="pyret" class="sourceCode">true</code> if
the <code data-lang="pyret" class="sourceCode">NumList</code> contains the value <code data-lang="pyret" class="sourceCode">3</code>, and <code data-lang="pyret" class="sourceCode">false</code> otherwise.</p><p>First, our header:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  doc: "Produces true if the list contains 3, false otherwise"
end</code></pre><p>Next, some tests:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  doc: "Produces true if the list contains 3, false otherwise"
where:
  contains-3(nl-empty) is false
  contains-3(nl-link(3, nl-empty)) is true
  contains-3(nl-link(1, nl-link(3, nl-empty))) is true
  contains-3(nl-link(1, nl-link(2, nl-link(3, nl-link(4, nl-empty))))) is true
  contains-3(nl-link(1, nl-link(2, nl-link(5, nl-link(4, nl-empty))))) is false
end</code></pre><p>As we did in <a href="intro-struct-data.html#%28part._process-fields-variants%29" data-pltdoc="x">Processing Fields of Variants</a>, we will use <code data-lang="pyret" class="sourceCode">cases</code> to
distinguish the variants. In addition, since we are going to have to
use the fields of <code data-lang="pyret" class="sourceCode">nl-link</code> to compute a result in that case, we
will list those in the initial code outline:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  doc: "Produces true if the list contains 3, false otherwise"
  cases (NumList) nl:
    | nl-empty =&gt; ...
    | nl-link(first, rest) =&gt;
      ... first ...
      ... rest ...
  end
end</code></pre><p>Following our examples, the answer must be false in the
<code data-lang="pyret" class="sourceCode">nl-empty</code> case.  In the <code data-lang="pyret" class="sourceCode">nl-link</code> case, if the <code data-lang="pyret" class="sourceCode">first</code>
element is <code data-lang="pyret" class="sourceCode">3</code>, we‚Äôve successfully answered the question.  That
only leaves the case where the argument is an <code data-lang="pyret" class="sourceCode">nl-link</code> and the
first element does not equal <code data-lang="pyret" class="sourceCode">3</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        # handle rest here
      end
  end
end</code></pre><p>Since we know <code data-lang="pyret" class="sourceCode">rest</code> is a <code data-lang="pyret" class="sourceCode">NumList</code> (based on the data definition),
we can use a <code data-lang="pyret" class="sourceCode">cases</code> expression to work with it.  This is sort of like
filling in a part of the template again:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        cases (NumList) rest:
          | nl-empty =&gt; ...
          | nl-link(first-of-rest, rest-of-rest) =&gt;
            ... first-of-rest ...
            ... rest-of-rest ...
        end
      end
  end
end</code></pre><p>If the <code data-lang="pyret" class="sourceCode">rest</code> was empty, then we haven‚Äôt found <code data-lang="pyret" class="sourceCode">3</code> (just like when
we checked the original argument, <code data-lang="pyret" class="sourceCode">nl</code>).  If the <code data-lang="pyret" class="sourceCode">rest</code> was a
<code data-lang="pyret" class="sourceCode">nl-link</code>, then we need to check if the first thing in the rest of the
list is <code data-lang="pyret" class="sourceCode">3</code> or not:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        cases (NumList) rest:
          | nl-empty =&gt; false
          | nl-link(first-of-rest, rest-of-rest) =&gt;
            if first-of-rest == 3:
              true
            else:
              # fill in here ...
            end
        end
      end
  end
end</code></pre><p>Since <code data-lang="pyret" class="sourceCode">rest-of-rest</code> is a <code data-lang="pyret" class="sourceCode">NumList</code>, we can fill in a <code data-lang="pyret" class="sourceCode">cases</code>
for it again:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        cases (NumList) rest:
          | nl-empty =&gt; false
          | nl-link(first-of-rest, rest-of-rest) =&gt;
            if first-of-rest == 3:
              true
            else:
              cases (NumList) rest-of-rest:
                | nl-empty =&gt; ...
                | nl-link(first-of-rest-of-rest, rest-of-rest-of-rest) =&gt;
                  ... first-of-rest-of-rest ...
                  ... rest-of-rest-of-rest ...
              end
            end
        end
      end
  end
end</code></pre><p>See where this is going?  Not anywhere good.  We can copy this <code data-lang="pyret" class="sourceCode">cases</code>
expression as many times as we want, but we can never answer the question for a
list that is just one element longer than the number of times we copy the code.</p><p>So what to do?  We tried this approach of using another copy of <code data-lang="pyret" class="sourceCode">cases</code>
based on the observation that <code data-lang="pyret" class="sourceCode">rest</code> is a <code data-lang="pyret" class="sourceCode">NumList</code>, and
<code data-lang="pyret" class="sourceCode">cases</code> provides a meaningful way to break apart a <code data-lang="pyret" class="sourceCode">NumList</code>; in
fact, it‚Äôs what the recipe seems to lead to naturally.</p><p>Let‚Äôs go back to the step where the problem began, after filling in the
template with the first check for <code data-lang="pyret" class="sourceCode">3</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        # what to do with rest?
      end
  end
end</code></pre><p>We need a way to compute whether or not the value <code data-lang="pyret" class="sourceCode">3</code> is contained in
<code data-lang="pyret" class="sourceCode">rest</code>.  Looking back at the data definition, we see that <code data-lang="pyret" class="sourceCode">rest</code> is
a perfectly valid <code data-lang="pyret" class="sourceCode">NumList</code>, simply by the definition of <code data-lang="pyret" class="sourceCode">nl-link</code>.
And we have a function (or, most of one) whose job is to figure out if a
<code data-lang="pyret" class="sourceCode">NumList</code> contains <code data-lang="pyret" class="sourceCode">3</code> or not: <code data-lang="pyret" class="sourceCode">contains-3</code>.  That ought to
be something we can call with <code data-lang="pyret" class="sourceCode">rest</code> as an argument, and get back the
value we want:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun contains-3(nl :: NumList) -&gt; Boolean:
  cases (NumList) nl:
    | nl-empty =&gt; false
    | nl-link(first, rest) =&gt;
      if first == 3:
        true
      else:
        contains-3(rest)
      end
  end
end</code></pre><p>And lo and behold, all of the tests defined above pass.  It‚Äôs useful to step
through what‚Äôs happening when this function is called.  Let‚Äôs look at an
example:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">contains-3(nl-link(1, nl-link(3, nl-empty)))</code></pre><p>First, we substitute the argument value in place of <code data-lang="pyret" class="sourceCode">nl</code> everywhere
it appears; that‚Äôs just the usual rule for function calls.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  cases (NumList) nl-link(1, nl-link(3, nl-empty)):
       | nl-empty =&gt; false
       | nl-link(first, rest) =&gt;
         if first == 3:
           true
         else:
           contains-3(rest)
         end
     end</code></pre><p>Next, we find the case that matches the constructor <code data-lang="pyret" class="sourceCode">nl-link</code>, and
substitute the corresponding pieces of the <code data-lang="pyret" class="sourceCode">nl-link</code> value for the
<code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> identifiers.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if 1 == 3:
      true
    else:
      contains-3(nl-link(3, nl-empty))
    end</code></pre><p>Since <code data-lang="pyret" class="sourceCode">1</code> isn‚Äôt <code data-lang="pyret" class="sourceCode">3</code>, the comparison evaluates to
<code data-lang="pyret" class="sourceCode">false</code>, and this whole expression evaluates to the contents of the
<code data-lang="pyret" class="sourceCode">else</code> branch.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if false:
      true
    else:
      contains-3(nl-link(3, nl-empty))
    end

=&gt;  contains-3(nl-link(3, nl-empty))</code></pre><p>This is another function call, so we substitute the value
<code data-lang="pyret" class="sourceCode">nl-link(3, nl-empty)</code>, which was the <code data-lang="pyret" class="sourceCode">rest</code> field of the original
input, into the body of <code data-lang="pyret" class="sourceCode">contains-3</code> this time.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  cases (NumList) nl-link(3, nl-empty):
      | nl-empty =&gt; false
      | nl-link(first, rest) =&gt;
        if first == 3:
          true
        else:
          contains-3(rest)
        end
    end</code></pre><p>Again, we substitute into the <code data-lang="pyret" class="sourceCode">nl-link</code> branch.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if 3 == 3:
      true
    else:
      contains-3(nl-empty)
    end</code></pre><p>This time, since <code data-lang="pyret" class="sourceCode">3</code> is <code data-lang="pyret" class="sourceCode">3</code>, we take the first branch of the
<code data-lang="pyret" class="sourceCode">if</code> expression, and the whole original call evaluates to <code data-lang="pyret" class="sourceCode">true</code>.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;  if true:
      true
    else:
      contains-3(nl-empty)
    end

=&gt; true</code></pre><p>An interesting feature of this trace through the evaluation is that we reached
the expression <code data-lang="pyret" class="sourceCode">contains-3(nl-link(3, nl-empty))</code>, which is a normal call
to <code data-lang="pyret" class="sourceCode">contains-3</code>; it could even be a test case on its own.  The
implementation works by doing something (checking for equality with <code data-lang="pyret" class="sourceCode">3</code>)
with the non-recursive parts of the datum, and combining that result with the
result of the same operation (<code data-lang="pyret" class="sourceCode">contains-3</code>) on the recursive part of the
datum.  This idea of doing recursion with the same function on self-recursive
parts of the datatype lets us extend our template to handle recursive
fields.</p>&#13;
<h4 class="heading">5.3.2¬†<a name="(part._.A_.Template_for_.Processing_.Recursive_.Data)"/>A Template for Processing Recursive Data<a href="#(part._.A_.Template_for_.Processing_.Recursive_.Data)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Stepping back, we have actually derived a new way to approach writing
functions over recursive data. Back in <a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>, we
had you write functions over lists by writing a sequence of related
examples, using substitution across examples to derive a program that
called the function on the rest of the list. Here, we are deriving
that structure from the shape of the data itself.</p><p>In particular, we can develop a function over recursive data by
breaking a datum into its variants (using <code data-lang="pyret" class="sourceCode">cases</code>), pulling out
the fields of each variant (by listing the field names), then calling
the function itself on any recursive fields (fields of the same
type). For <code data-lang="pyret" class="sourceCode">NumList</code>, these steps yield the following code outline:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">#|
fun num-list-fun(nl :: NumList) -&gt; ???:
  cases (NumList) nl:
    | nl-empty =&gt; ...
    | nl-link(first, rest) =&gt;
      ... first ...
      ... num-list-fun(rest) ...
  end
end
|#</code></pre><p>Here, we are using a generic function name, <code data-lang="pyret" class="sourceCode">num-list-fun</code>, to
illustrate that this is the outline for any function that
processes a <code data-lang="pyret" class="sourceCode">NumList</code>.</p><p>We refer to this code outline as a template. Every <code data-lang="pyret" class="sourceCode">data</code>
definition has a corresponding template which captures how to break
a value of that definition into cases, pull out the fields, and use
the same function to process any recursive fields.</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Writing a Template for Recursive Data</p><blockquote class="StrategyBody"><p>Given a recursive data definition, use the following steps to create
the (reusable) template for that definition:</p><ol><li><p>Create a function header (using a general-purpose
placeholder name if you aren‚Äôt yet writing a specific function).</p></li><li><p>Use <code data-lang="pyret" class="sourceCode">cases</code> to break the recursive-data input into its
variants.</p></li><li><p>In each case, list each of its fields in the answer portion of
the case.</p></li><li><p>Call the function itself on any recursive fields.</p></li></ol></blockquote></blockquote><p>The power of the template lies in its universality. If you are asked
to write a specific function (such as <code data-lang="pyret" class="sourceCode">contains-3</code>) over
recursive data (<code data-lang="pyret" class="sourceCode">NumList</code>), you can reproduce or copy (if you
already wrote it down) the template, replace the generic function name
in the template with the one for your specific function, then fill in
the ellipses to finish the function.</p><p>When you see a recursive data definition (of which
there will be many when programming in Pyret), you should naturally start thinking
about what the recursive calls will return and how to combine their results
with the other, non-recursive pieces of the datatype.</p><p>You have now seen two approaches to writing functions on recursive data:
working out a sequence of related examples and modifying the
template. Both approaches get you to the same final function. The
power of the template, however, is that it scales to more complicated
data definitions (where writing examples by hand would prove
tedious). We will see examples of this as our data get more complex in
coming chapters.</p>&#13;
<h4 class="heading">5.3.3¬†<a name="(part._.The_.Design_.Recipe)"/>The Design Recipe<a href="#(part._.The_.Design_.Recipe)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>We‚Äôve showed you many techniques to use while designing programs,
including developing examples, writing tests, and now writing and
using data templates. Putting the pieces together yields a
design recipe, adapted from that in
<a href="https://htdp.org/">How to Design Programs</a>,
that we can follow for designing recursive
functions.</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: The Design Recipe</p><blockquote class="StrategyBody"><p>Given a programming problem over recursive data:</p><ol><li><p>Create a function header, including the function name and
contract. The name will be necessary to make recursive calls, while
the contract guides the design of the body.</p></li><li><p>Aided by the contract, which tells you what kind of data
to consume and produce, write several illustrative examples of the
function‚Äôs input and outputs, using concrete data. Include
examples in which the input data of one extends the input data of
another. This will later help you fill in the function.</p></li><li><p>The function‚Äôs contract tells you what kind of data you are
processing. From the definition of the data, write out the template
for it.</p></li><li><p>Adapt this template to the computation required by this specific
problem. Use your examples to figure out how to fill in each case. You
should have written an example for each case of data in the
template. This is also where writing examples where input extended the
other helps: the difference in output becomes the function
body. See the several examples of this in <a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>.</p></li><li><p>Run your examples to make sure your function behaves as you expect.</p></li><li><p>Now start writing more fine-grained tests to confirm that you
should be confident in your function. In particular, while the
examples (which were written before you wrote the body of the
function) focus on the expected ‚Äúinput-output‚Äù behavior, now that
you have a concrete implementation, you should write tests that focus
on its details.</p></li></ol></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Use the design recipe to write a function <code data-lang="pyret" class="sourceCode">contains-n</code> that takes a
<code data-lang="pyret" class="sourceCode">NumList</code> and a <code data-lang="pyret" class="sourceCode">Number</code>, and returns whether that number is in the
<code data-lang="pyret" class="sourceCode">NumList</code>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Use the design recipe to write a function <code data-lang="pyret" class="sourceCode">sum</code> that takes a
<code data-lang="pyret" class="sourceCode">NumList</code>, and returns the sum of all the numbers in it.  The sum of the
empty list is <code data-lang="pyret" class="sourceCode">0</code>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Use the design recipe to write a function <code data-lang="pyret" class="sourceCode">remove-3</code> that takes a
<code data-lang="pyret" class="sourceCode">NumList</code>, and returns a new <code data-lang="pyret" class="sourceCode">NumList</code> with any <code data-lang="pyret" class="sourceCode">3</code>‚Äôs
removed.  The remaining elements should all be in the list in the same order
they were in the input.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a data definition called <code data-lang="pyret" class="sourceCode">NumListList</code> that represents a list
of <code data-lang="pyret" class="sourceCode">NumList</code>s, and use the design recipe to write a function
<code data-lang="pyret" class="sourceCode">sum-of-lists</code> that takes a <code data-lang="pyret" class="sourceCode">NumListList</code> and produces a
<code data-lang="pyret" class="sourceCode">NumList</code> containing the sums of the sub-lists.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a data definition and corresponding template for
<code data-lang="pyret" class="sourceCode">StrList</code>, which captures lists of strings.</p></blockquote></blockquote>    
</body>
</html>