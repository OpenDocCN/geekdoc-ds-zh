- en: 26¬†Deconstructing Loopsüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/deconstructing-loops.html](https://dcic-world.org/2025-08-27/deconstructing-loops.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[26.1¬†Setup: Two Functions](#%28part._.Setup__.Two_.Functions%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[26.2¬†Abstracting a Loop](#%28part._.Abstracting_a_.Loop%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[26.3¬†Is It Really a Loop?](#%28part._.Is_.It_.Really_a_.Loop_%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[26.4¬†Re-Examining `for`](#%28part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[26.5¬†Rewriting Pollard-Rho](#%28part._.Rewriting_.Pollard-.Rho%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[26.6¬†Nested Loops](#%28part._.Nested_.Loops%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[26.7¬†Loops, Values, and Customization](#%28part._.Loops__.Values__and_.Customization%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '26.1¬†Setup: Two Functions[üîó](#(part._.Setup__.Two_.Functions) "Link to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let‚Äôs look at two functions we wrote earlier in [Factoring Numbers](factoring-numbers.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We‚Äôve written both recursively: `gcd` by calling itself and `pr` with recursion
    on its inner function. But if you‚Äôve programmed before, you‚Äôve probably written
    similar programs with loops.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because we don‚Äôt have loops in Pyret, the best we can do is to use a higher-order
    function; which ones would you use?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: But let‚Äôs see if we can do something ‚Äúbetter‚Äù, i.e., get closer to a traditional-looking
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start changing any code, let‚Äôs make sure we have some tests for `gcd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 26.2¬†Abstracting a Loop[üîó](#(part._.Abstracting_a_.Loop) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let‚Äôs think about how we can create a loop. At each iteration, a loop has
    a status: whether it‚Äôs done or whether it should continue. Since we have two parameters
    here, let‚Äôs record two parameters for continuing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write a function that does the actual iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is completely generic: it has nothing to do with `gcd`. (It
    is generic in the same way that higher-order functions like `map` and `filter`
    are generic.) It just repeats if `f` says to repeat, stops if `f` says to stop.
    This is the essence of a loop.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe also that we could, if we wanted, stage [[Staging](staging.html)] `loop-2`,
    because `f` never changes. Rewrite it that way.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With `loop-2`, we can rewrite `gcd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now it might seem to you we haven‚Äôt done anything useful at all. In fact, this
    looks like a significant step backward. At least before we just had simple, clean
    recursion, the way Euclid intended it. Now we have a higher-order function and
    we‚Äôre passing it the erstwhile `gcd` code as a function and there‚Äôs this `LoopStatus`
    datatype and‚Ä¶everything‚Äôs gotten much more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, not really. The reason we put it in this form is because we‚Äôre about to
    exploit a feature of Pyret. The `for` construct in Pyret actually rewrites as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: gets rewritten to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For example, if we write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: this becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now you may see why we rewrote `gcd`. Going in reverse, we can rewrite
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: so the function becomes just
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: and now closely resembles a traditional ‚Äúloop‚Äù program.
  prefs: []
  type: TYPE_NORMAL
- en: 26.3¬†Is It Really a Loop?[üîó](#(part._.Is_.It_.Really_a_.Loop_) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This whole section should be considered an aside for people with more advanced
    computing knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know something about language implementation, you may know that loops
    have the property that the iteration does not consume extra space (beyond what
    the program already needs), and the repetition takes place very quickly (a ‚Äújump
    instruction‚Äù). In principle, our `loop-2` function does not have this property:
    every iteration is a function call, which is more expensive and builds additional
    stack context. However, one or both of these does not actually occur in practice.'
  prefs: []
  type: TYPE_NORMAL
- en: In terms of space, the recursive call to `loop-2` is the last thing that a call
    to `loop-2` does. Furthermore, nothing in `loop-2` consumes and manipulates the
    return from that recursive call. This is therefore called a tail call. Pyret‚Äî<wbr>like
    some other languages‚Äî<wbr>causes tail calls to not take any extra stack space.
    In principle, Pyret can also turn some tail calls into jumps. Therefore, this
    version has close to the same performance as a traditional loop.
  prefs: []
  type: TYPE_NORMAL
- en: 26.4¬†Re-Examining `for`[üîó](#(part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__)
    "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The definition of `for` given above should make you suspicious: Where‚Äôs the
    loop?!? In fact, Pyret‚Äôs `for` does not do any looping at all: it‚Äôs simply a fancy
    way of writing `lam`. Any ‚Äúlooping‚Äù behavior is in the function written after
    `for`. To see that, let‚Äôs use for with a non-looping function.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: gets rewritten to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, suppose we have this function (from [Functions as Data](func-as-data.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call it like this to get approximately 20:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'That means we can also call it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since `d-dx-at` has no iterative behavior, no iteration occurs. The looping
    behavior is given entirely by the function specified after `for`, such as `map`,
    `filter`, or `loop-2` above.
  prefs: []
  type: TYPE_NORMAL
- en: 26.5¬†Rewriting Pollard-Rho[üîó](#(part._.Rewriting_.Pollard-.Rho) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let‚Äôs tackle Pollard-rho. Notice that it‚Äôs a three-parameter function,
    so we can‚Äôt use the `loop-2` we had before: that‚Äôs only a suitable loop when we
    have two arguments that change on each iteration (often the iteration variable
    and an accumulator). It would be easy to design a 3-argument version of loop,
    say `loop-3`, but we could also have a more general solution, using a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: where `t` is a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we can rewrite `pr`. Let‚Äôs first rename the old `pr` function as `pr-old`
    so we can keep it around for testing. Now we can define a ‚Äúloop‚Äù-based `pr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, we can test that the two behave in exactly the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 26.6¬†Nested Loops[üîó](#(part._.Nested_.Loops) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also write a nested loop this way. Suppose we have a list like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'and we want to sum the whole thing by summing each sub-list. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simplify this by writing it as two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the two functions are remarkably similar. This suggests an abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this, we can rewrite the two previous functions as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With the annotations, it becomes clear what each function does. In `sum-a-lon`,
    each element is a number, so it ‚Äúcontributes itself‚Äù to the overall sum. In `sum-a-lolon`,
    each element is a list of numbers, so it ‚Äúcontributes its `sum-a-lon`‚Äù to the
    overall sum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to bring this full circle, we can rewrite the above the functions
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Arguably this makes even clearer what each element contributes. In `sum-a-lon`
    each element is a number, so it contributes just that number. In `sum-a-lolon`,
    each element is a list of numbers, so it must contribute `sum-a-lon` of that list.
  prefs: []
  type: TYPE_NORMAL
- en: 26.7¬†Loops, Values, and Customization[üîó](#(part._.Loops__.Values__and_.Customization)
    "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Observe two important ways in which the loops above differ from traditional
    loops:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every loop produces a value. This is consistent with the rest of the language,
    where‚Äî<wbr>as much as possible‚Äî<wbr>computations try to produce answers. We don‚Äôt
    have to produce a value; for instance, the following program, reminiscent of looping
    programs in many other languages, will work just fine in Pyret:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, this is the unusual case. In general, we want expressions to produce
    values so that we can compose them together.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Many languages have strong opinions on exactly how many looping constructs
    there should be: two? three? four? In Pyret, there are no built-in looping constructs
    at all; there‚Äôs just a syntax (`for`) that serves as a proxy for creating a specific
    `lam`. With it, we can reuse existing iterative functions (like `map` and `filter`),
    but also define new ones. Some can be very generic, like `loop-2` or `loop-n`,
    but others can be very specific, like `sum-a-list`. The language designers don‚Äôt
    prevent you from writing a loop that is useful to your situation, and sometimes
    the loop can be very expressive, as we see from rewriting `sum-a-lon` and `sum-a-lolon`
    atop `for` and `sum-a-list`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '26.1¬†Setup: Two Functions[üîó](#(part._.Setup__.Two_.Functions) "Link to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let‚Äôs look at two functions we wrote earlier in [Factoring Numbers](factoring-numbers.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We‚Äôve written both recursively: `gcd` by calling itself and `pr` with recursion
    on its inner function. But if you‚Äôve programmed before, you‚Äôve probably written
    similar programs with loops.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because we don‚Äôt have loops in Pyret, the best we can do is to use a higher-order
    function; which ones would you use?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: But let‚Äôs see if we can do something ‚Äúbetter‚Äù, i.e., get closer to a traditional-looking
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start changing any code, let‚Äôs make sure we have some tests for `gcd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 26.2¬†Abstracting a Loop[üîó](#(part._.Abstracting_a_.Loop) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let‚Äôs think about how we can create a loop. At each iteration, a loop has
    a status: whether it‚Äôs done or whether it should continue. Since we have two parameters
    here, let‚Äôs record two parameters for continuing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write a function that does the actual iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is completely generic: it has nothing to do with `gcd`. (It
    is generic in the same way that higher-order functions like `map` and `filter`
    are generic.) It just repeats if `f` says to repeat, stops if `f` says to stop.
    This is the essence of a loop.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe also that we could, if we wanted, stage [[Staging](staging.html)] `loop-2`,
    because `f` never changes. Rewrite it that way.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With `loop-2`, we can rewrite `gcd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now it might seem to you we haven‚Äôt done anything useful at all. In fact, this
    looks like a significant step backward. At least before we just had simple, clean
    recursion, the way Euclid intended it. Now we have a higher-order function and
    we‚Äôre passing it the erstwhile `gcd` code as a function and there‚Äôs this `LoopStatus`
    datatype and‚Ä¶everything‚Äôs gotten much more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, not really. The reason we put it in this form is because we‚Äôre about to
    exploit a feature of Pyret. The `for` construct in Pyret actually rewrites as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: gets rewritten to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: For example, if we write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: this becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now you may see why we rewrote `gcd`. Going in reverse, we can rewrite
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: so the function becomes just
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: and now closely resembles a traditional ‚Äúloop‚Äù program.
  prefs: []
  type: TYPE_NORMAL
- en: 26.3¬†Is It Really a Loop?[üîó](#(part._.Is_.It_.Really_a_.Loop_) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This whole section should be considered an aside for people with more advanced
    computing knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know something about language implementation, you may know that loops
    have the property that the iteration does not consume extra space (beyond what
    the program already needs), and the repetition takes place very quickly (a ‚Äújump
    instruction‚Äù). In principle, our `loop-2` function does not have this property:
    every iteration is a function call, which is more expensive and builds additional
    stack context. However, one or both of these does not actually occur in practice.'
  prefs: []
  type: TYPE_NORMAL
- en: In terms of space, the recursive call to `loop-2` is the last thing that a call
    to `loop-2` does. Furthermore, nothing in `loop-2` consumes and manipulates the
    return from that recursive call. This is therefore called a tail call. Pyret‚Äî<wbr>like
    some other languages‚Äî<wbr>causes tail calls to not take any extra stack space.
    In principle, Pyret can also turn some tail calls into jumps. Therefore, this
    version has close to the same performance as a traditional loop.
  prefs: []
  type: TYPE_NORMAL
- en: 26.4¬†Re-Examining `for`[üîó](#(part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__)
    "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The definition of `for` given above should make you suspicious: Where‚Äôs the
    loop?!? In fact, Pyret‚Äôs `for` does not do any looping at all: it‚Äôs simply a fancy
    way of writing `lam`. Any ‚Äúlooping‚Äù behavior is in the function written after
    `for`. To see that, let‚Äôs use for with a non-looping function.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: gets rewritten to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, suppose we have this function (from [Functions as Data](func-as-data.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call it like this to get approximately 20:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'That means we can also call it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Since `d-dx-at` has no iterative behavior, no iteration occurs. The looping
    behavior is given entirely by the function specified after `for`, such as `map`,
    `filter`, or `loop-2` above.
  prefs: []
  type: TYPE_NORMAL
- en: 26.5¬†Rewriting Pollard-Rho[üîó](#(part._.Rewriting_.Pollard-.Rho) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let‚Äôs tackle Pollard-rho. Notice that it‚Äôs a three-parameter function,
    so we can‚Äôt use the `loop-2` we had before: that‚Äôs only a suitable loop when we
    have two arguments that change on each iteration (often the iteration variable
    and an accumulator). It would be easy to design a 3-argument version of loop,
    say `loop-3`, but we could also have a more general solution, using a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: where `t` is a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we can rewrite `pr`. Let‚Äôs first rename the old `pr` function as `pr-old`
    so we can keep it around for testing. Now we can define a ‚Äúloop‚Äù-based `pr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, we can test that the two behave in exactly the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 26.6¬†Nested Loops[üîó](#(part._.Nested_.Loops) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also write a nested loop this way. Suppose we have a list like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'and we want to sum the whole thing by summing each sub-list. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simplify this by writing it as two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the two functions are remarkably similar. This suggests an abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this, we can rewrite the two previous functions as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: With the annotations, it becomes clear what each function does. In `sum-a-lon`,
    each element is a number, so it ‚Äúcontributes itself‚Äù to the overall sum. In `sum-a-lolon`,
    each element is a list of numbers, so it ‚Äúcontributes its `sum-a-lon`‚Äù to the
    overall sum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to bring this full circle, we can rewrite the above the functions
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Arguably this makes even clearer what each element contributes. In `sum-a-lon`
    each element is a number, so it contributes just that number. In `sum-a-lolon`,
    each element is a list of numbers, so it must contribute `sum-a-lon` of that list.
  prefs: []
  type: TYPE_NORMAL
- en: 26.7¬†Loops, Values, and Customization[üîó](#(part._.Loops__.Values__and_.Customization)
    "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Observe two important ways in which the loops above differ from traditional
    loops:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every loop produces a value. This is consistent with the rest of the language,
    where‚Äî<wbr>as much as possible‚Äî<wbr>computations try to produce answers. We don‚Äôt
    have to produce a value; for instance, the following program, reminiscent of looping
    programs in many other languages, will work just fine in Pyret:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, this is the unusual case. In general, we want expressions to produce
    values so that we can compose them together.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Many languages have strong opinions on exactly how many looping constructs
    there should be: two? three? four? In Pyret, there are no built-in looping constructs
    at all; there‚Äôs just a syntax (`for`) that serves as a proxy for creating a specific
    `lam`. With it, we can reuse existing iterative functions (like `map` and `filter`),
    but also define new ones. Some can be very generic, like `loop-2` or `loop-n`,
    but others can be very specific, like `sum-a-list`. The language designers don‚Äôt
    prevent you from writing a loop that is useful to your situation, and sometimes
    the loop can be very expressive, as we see from rewriting `sum-a-lon` and `sum-a-lolon`
    atop `for` and `sum-a-list`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
