- en: 26Â Deconstructing LoopsğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/deconstructing-loops.html](https://dcic-world.org/2025-08-27/deconstructing-loops.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Â Â Â Â [26.1Â Setup: Two Functions](#%28part._.Setup__.Two_.Functions%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [26.2Â Abstracting a Loop](#%28part._.Abstracting_a_.Loop%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [26.3Â Is It Really a Loop?](#%28part._.Is_.It_.Really_a_.Loop_%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [26.4Â Re-Examining `for`](#%28part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [26.5Â Rewriting Pollard-Rho](#%28part._.Rewriting_.Pollard-.Rho%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [26.6Â Nested Loops](#%28part._.Nested_.Loops%29) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [26.7Â Loops, Values, and Customization](#%28part._.Loops__.Values__and_.Customization%29)
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
- en: '26.1Â Setup: Two Functions[ğŸ”—](#(part._.Setup__.Two_.Functions) "Link to here")'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Letâ€™s look at two functions we wrote earlier in [Factoring Numbers](factoring-numbers.html):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Weâ€™ve written both recursively: `gcd` by calling itself and `pr` with recursion
    on its inner function. But if youâ€™ve programmed before, youâ€™ve probably written
    similar programs with loops.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because we donâ€™t have loops in Pyret, the best we can do is to use a higher-order
    function; which ones would you use?
  id: totrans-15
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: But letâ€™s see if we can do something â€œbetterâ€, i.e., get closer to a traditional-looking
    program.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start changing any code, letâ€™s make sure we have some tests for `gcd`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 26.2Â Abstracting a Loop[ğŸ”—](#(part._.Abstracting_a_.Loop) "Link to here")
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now letâ€™s think about how we can create a loop. At each iteration, a loop has
    a status: whether itâ€™s done or whether it should continue. Since we have two parameters
    here, letâ€™s record two parameters for continuing:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we can write a function that does the actual iteration:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that this is completely generic: it has nothing to do with `gcd`. (It
    is generic in the same way that higher-order functions like `map` and `filter`
    are generic.) It just repeats if `f` says to repeat, stops if `f` says to stop.
    This is the essence of a loop.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe also that we could, if we wanted, stage [[Staging](staging.html)] `loop-2`,
    because `f` never changes. Rewrite it that way.
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With `loop-2`, we can rewrite `gcd`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now it might seem to you we havenâ€™t done anything useful at all. In fact, this
    looks like a significant step backward. At least before we just had simple, clean
    recursion, the way Euclid intended it. Now we have a higher-order function and
    weâ€™re passing it the erstwhile `gcd` code as a function and thereâ€™s this `LoopStatus`
    datatype andâ€¦everythingâ€™s gotten much more complicated.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'But, not really. The reason we put it in this form is because weâ€™re about to
    exploit a feature of Pyret. The `for` construct in Pyret actually rewrites as
    follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: gets rewritten to
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For example, if we write
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: this becomes
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now you may see why we rewrote `gcd`. Going in reverse, we can rewrite
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: as
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: so the function becomes just
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: and now closely resembles a traditional â€œloopâ€ program.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 26.3Â Is It Really a Loop?[ğŸ”—](#(part._.Is_.It_.Really_a_.Loop_) "Link to here")
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This whole section should be considered an aside for people with more advanced
    computing knowledge.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know something about language implementation, you may know that loops
    have the property that the iteration does not consume extra space (beyond what
    the program already needs), and the repetition takes place very quickly (a â€œjump
    instructionâ€). In principle, our `loop-2` function does not have this property:
    every iteration is a function call, which is more expensive and builds additional
    stack context. However, one or both of these does not actually occur in practice.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: In terms of space, the recursive call to `loop-2` is the last thing that a call
    to `loop-2` does. Furthermore, nothing in `loop-2` consumes and manipulates the
    return from that recursive call. This is therefore called a tail call. Pyretâ€”<wbr>like
    some other languagesâ€”<wbr>causes tail calls to not take any extra stack space.
    In principle, Pyret can also turn some tail calls into jumps. Therefore, this
    version has close to the same performance as a traditional loop.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 26.4Â Re-Examining `for`[ğŸ”—](#(part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__)
    "Link to here")
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The definition of `for` given above should make you suspicious: Whereâ€™s the
    loop?!? In fact, Pyretâ€™s `for` does not do any looping at all: itâ€™s simply a fancy
    way of writing `lam`. Any â€œloopingâ€ behavior is in the function written after
    `for`. To see that, letâ€™s use for with a non-looping function.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Recall that
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: gets rewritten to
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Thus, suppose we have this function (from [Functions as Data](func-as-data.html)):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can call it like this to get approximately 20:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That means we can also call it like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Indeed:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since `d-dx-at` has no iterative behavior, no iteration occurs. The looping
    behavior is given entirely by the function specified after `for`, such as `map`,
    `filter`, or `loop-2` above.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 26.5Â Rewriting Pollard-Rho[ğŸ”—](#(part._.Rewriting_.Pollard-.Rho) "Link to here")
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now letâ€™s tackle Pollard-rho. Notice that itâ€™s a three-parameter function,
    so we canâ€™t use the `loop-2` we had before: thatâ€™s only a suitable loop when we
    have two arguments that change on each iteration (often the iteration variable
    and an accumulator). It would be easy to design a 3-argument version of loop,
    say `loop-3`, but we could also have a more general solution, using a tuple:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: where `t` is a tuple.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we can rewrite `pr`. Letâ€™s first rename the old `pr` function as `pr-old`
    so we can keep it around for testing. Now we can define a â€œloopâ€-based `pr`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Indeed, we can test that the two behave in exactly the same way:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 26.6Â Nested Loops[ğŸ”—](#(part._.Nested_.Loops) "Link to here")
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also write a nested loop this way. Suppose we have a list like
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'and we want to sum the whole thing by summing each sub-list. Here it is:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can simplify this by writing it as two functions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice that the two functions are remarkably similar. This suggests an abstraction:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using this, we can rewrite the two previous functions as:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With the annotations, it becomes clear what each function does. In `sum-a-lon`,
    each element is a number, so it â€œcontributes itselfâ€ to the overall sum. In `sum-a-lolon`,
    each element is a list of numbers, so it â€œcontributes its `sum-a-lon`â€ to the
    overall sum.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to bring this full circle, we can rewrite the above the functions
    as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Arguably this makes even clearer what each element contributes. In `sum-a-lon`
    each element is a number, so it contributes just that number. In `sum-a-lolon`,
    each element is a list of numbers, so it must contribute `sum-a-lon` of that list.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 26.7Â Loops, Values, and Customization[ğŸ”—](#(part._.Loops__.Values__and_.Customization)
    "Link to here")
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Observe two important ways in which the loops above differ from traditional
    loops:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Every loop produces a value. This is consistent with the rest of the language,
    whereâ€”<wbr>as much as possibleâ€”<wbr>computations try to produce answers. We donâ€™t
    have to produce a value; for instance, the following program, reminiscent of looping
    programs in many other languages, will work just fine in Pyret:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: However, this is the unusual case. In general, we want expressions to produce
    values so that we can compose them together.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Many languages have strong opinions on exactly how many looping constructs
    there should be: two? three? four? In Pyret, there are no built-in looping constructs
    at all; thereâ€™s just a syntax (`for`) that serves as a proxy for creating a specific
    `lam`. With it, we can reuse existing iterative functions (like `map` and `filter`),
    but also define new ones. Some can be very generic, like `loop-2` or `loop-n`,
    but others can be very specific, like `sum-a-list`. The language designers donâ€™t
    prevent you from writing a loop that is useful to your situation, and sometimes
    the loop can be very expressive, as we see from rewriting `sum-a-lon` and `sum-a-lolon`
    atop `for` and `sum-a-list`.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '26.1Â Setup: Two Functions[ğŸ”—](#(part._.Setup__.Two_.Functions) "Link to here")'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Letâ€™s look at two functions we wrote earlier in [Factoring Numbers](factoring-numbers.html):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Weâ€™ve written both recursively: `gcd` by calling itself and `pr` with recursion
    on its inner function. But if youâ€™ve programmed before, youâ€™ve probably written
    similar programs with loops.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because we donâ€™t have loops in Pyret, the best we can do is to use a higher-order
    function; which ones would you use?
  id: totrans-100
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: But letâ€™s see if we can do something â€œbetterâ€, i.e., get closer to a traditional-looking
    program.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start changing any code, letâ€™s make sure we have some tests for `gcd`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 26.2Â Abstracting a Loop[ğŸ”—](#(part._.Abstracting_a_.Loop) "Link to here")
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now letâ€™s think about how we can create a loop. At each iteration, a loop has
    a status: whether itâ€™s done or whether it should continue. Since we have two parameters
    here, letâ€™s record two parameters for continuing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we can write a function that does the actual iteration:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that this is completely generic: it has nothing to do with `gcd`. (It
    is generic in the same way that higher-order functions like `map` and `filter`
    are generic.) It just repeats if `f` says to repeat, stops if `f` says to stop.
    This is the essence of a loop.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe also that we could, if we wanted, stage [[Staging](staging.html)] `loop-2`,
    because `f` never changes. Rewrite it that way.
  id: totrans-112
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With `loop-2`, we can rewrite `gcd`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now it might seem to you we havenâ€™t done anything useful at all. In fact, this
    looks like a significant step backward. At least before we just had simple, clean
    recursion, the way Euclid intended it. Now we have a higher-order function and
    weâ€™re passing it the erstwhile `gcd` code as a function and thereâ€™s this `LoopStatus`
    datatype andâ€¦everythingâ€™s gotten much more complicated.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'But, not really. The reason we put it in this form is because weâ€™re about to
    exploit a feature of Pyret. The `for` construct in Pyret actually rewrites as
    follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: gets rewritten to
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For example, if we write
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: this becomes
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now you may see why we rewrote `gcd`. Going in reverse, we can rewrite
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: as
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: so the function becomes just
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: and now closely resembles a traditional â€œloopâ€ program.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 26.3Â Is It Really a Loop?[ğŸ”—](#(part._.Is_.It_.Really_a_.Loop_) "Link to here")
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This whole section should be considered an aside for people with more advanced
    computing knowledge.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know something about language implementation, you may know that loops
    have the property that the iteration does not consume extra space (beyond what
    the program already needs), and the repetition takes place very quickly (a â€œjump
    instructionâ€). In principle, our `loop-2` function does not have this property:
    every iteration is a function call, which is more expensive and builds additional
    stack context. However, one or both of these does not actually occur in practice.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: In terms of space, the recursive call to `loop-2` is the last thing that a call
    to `loop-2` does. Furthermore, nothing in `loop-2` consumes and manipulates the
    return from that recursive call. This is therefore called a tail call. Pyretâ€”<wbr>like
    some other languagesâ€”<wbr>causes tail calls to not take any extra stack space.
    In principle, Pyret can also turn some tail calls into jumps. Therefore, this
    version has close to the same performance as a traditional loop.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 26.4Â Re-Examining `for`[ğŸ”—](#(part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__)
    "Link to here")
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The definition of `for` given above should make you suspicious: Whereâ€™s the
    loop?!? In fact, Pyretâ€™s `for` does not do any looping at all: itâ€™s simply a fancy
    way of writing `lam`. Any â€œloopingâ€ behavior is in the function written after
    `for`. To see that, letâ€™s use for with a non-looping function.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Recall that
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: gets rewritten to
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Thus, suppose we have this function (from [Functions as Data](func-as-data.html)):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can call it like this to get approximately 20:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'That means we can also call it like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Indeed:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Since `d-dx-at` has no iterative behavior, no iteration occurs. The looping
    behavior is given entirely by the function specified after `for`, such as `map`,
    `filter`, or `loop-2` above.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 26.5Â Rewriting Pollard-Rho[ğŸ”—](#(part._.Rewriting_.Pollard-.Rho) "Link to here")
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now letâ€™s tackle Pollard-rho. Notice that itâ€™s a three-parameter function,
    so we canâ€™t use the `loop-2` we had before: thatâ€™s only a suitable loop when we
    have two arguments that change on each iteration (often the iteration variable
    and an accumulator). It would be easy to design a 3-argument version of loop,
    say `loop-3`, but we could also have a more general solution, using a tuple:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: where `t` is a tuple.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we can rewrite `pr`. Letâ€™s first rename the old `pr` function as `pr-old`
    so we can keep it around for testing. Now we can define a â€œloopâ€-based `pr`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Indeed, we can test that the two behave in exactly the same way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 26.6Â Nested Loops[ğŸ”—](#(part._.Nested_.Loops) "Link to here")
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also write a nested loop this way. Suppose we have a list like
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'and we want to sum the whole thing by summing each sub-list. Here it is:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can simplify this by writing it as two functions:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Notice that the two functions are remarkably similar. This suggests an abstraction:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Using this, we can rewrite the two previous functions as:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: With the annotations, it becomes clear what each function does. In `sum-a-lon`,
    each element is a number, so it â€œcontributes itselfâ€ to the overall sum. In `sum-a-lolon`,
    each element is a list of numbers, so it â€œcontributes its `sum-a-lon`â€ to the
    overall sum.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to bring this full circle, we can rewrite the above the functions
    as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Arguably this makes even clearer what each element contributes. In `sum-a-lon`
    each element is a number, so it contributes just that number. In `sum-a-lolon`,
    each element is a list of numbers, so it must contribute `sum-a-lon` of that list.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 26.7Â Loops, Values, and Customization[ğŸ”—](#(part._.Loops__.Values__and_.Customization)
    "Link to here")
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Observe two important ways in which the loops above differ from traditional
    loops:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Every loop produces a value. This is consistent with the rest of the language,
    whereâ€”<wbr>as much as possibleâ€”<wbr>computations try to produce answers. We donâ€™t
    have to produce a value; for instance, the following program, reminiscent of looping
    programs in many other languages, will work just fine in Pyret:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: However, this is the unusual case. In general, we want expressions to produce
    values so that we can compose them together.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Many languages have strong opinions on exactly how many looping constructs
    there should be: two? three? four? In Pyret, there are no built-in looping constructs
    at all; thereâ€™s just a syntax (`for`) that serves as a proxy for creating a specific
    `lam`. With it, we can reuse existing iterative functions (like `map` and `filter`),
    but also define new ones. Some can be very generic, like `loop-2` or `loop-n`,
    but others can be very specific, like `sum-a-list`. The language designers donâ€™t
    prevent you from writing a loop that is useful to your situation, and sometimes
    the loop can be very expressive, as we see from rewriting `sum-a-lon` and `sum-a-lolon`
    atop `for` and `sum-a-list`.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è®¸å¤šè¯­è¨€å¯¹åº”è¯¥æœ‰å¤šå°‘ä¸ªå¾ªç¯ç»“æ„æœ‰ç€å¼ºçƒˆçš„çœ‹æ³•ï¼šä¸¤ä¸ªï¼Ÿä¸‰ä¸ªï¼Ÿå››ä¸ªï¼Ÿåœ¨Pyretä¸­ï¼Œæ ¹æœ¬æ²¡æœ‰ä»»ä½•å†…ç½®çš„å¾ªç¯ç»“æ„ï¼›åªæœ‰ä¸€ä¸ªè¯­æ³•ï¼ˆ`for`ï¼‰ï¼Œå®ƒä½œä¸ºåˆ›å»ºç‰¹å®š`lam`çš„ä»£ç†ã€‚æœ‰äº†å®ƒï¼Œæˆ‘ä»¬å¯ä»¥é‡ç”¨ç°æœ‰çš„è¿­ä»£å‡½æ•°ï¼ˆå¦‚`map`å’Œ`filter`ï¼‰ï¼Œä¹Ÿå¯ä»¥å®šä¹‰æ–°çš„å‡½æ•°ã€‚æœ‰äº›å¯ä»¥éå¸¸é€šç”¨ï¼Œæ¯”å¦‚`loop-2`æˆ–`loop-n`ï¼Œä½†æœ‰äº›åˆ™éå¸¸å…·ä½“ï¼Œæ¯”å¦‚`sum-a-list`ã€‚è¯­è¨€è®¾è®¡è€…ä¸ä¼šé˜»æ­¢ä½ ç¼–å†™é€‚åˆä½ æƒ…å†µçš„å¾ªç¯ï¼Œæœ‰æ—¶å¾ªç¯å¯ä»¥éå¸¸å…·æœ‰è¡¨ç°åŠ›ï¼Œæ­£å¦‚æˆ‘ä»¬ä»åœ¨`for`å’Œ`sum-a-list`ä¹‹ä¸Šé‡å†™`sum-a-lon`å’Œ`sum-a-lolon`ä¸­çœ‹åˆ°çš„é‚£æ ·ã€‚
