- en: 26Â Deconstructing LoopsğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 26Â å¾ªç¯çš„è§£æ„ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/deconstructing-loops.html](https://dcic-world.org/2025-08-27/deconstructing-loops.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/deconstructing-loops.html](https://dcic-world.org/2025-08-27/deconstructing-loops.html)
- en: '| Â Â Â Â [26.1Â Setup: Two Functions](#%28part._.Setup__.Two_.Functions%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [26.1Â è®¾ç½®ï¼šä¸¤ä¸ªå‡½æ•°](#%28part._.Setup__.Two_.Functions%29) |'
- en: '| Â Â Â Â [26.2Â Abstracting a Loop](#%28part._.Abstracting_a_.Loop%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [26.2Â æŠ½è±¡åŒ–å¾ªç¯](#%28part._.Abstracting_a_.Loop%29) |'
- en: '| Â Â Â Â [26.3Â Is It Really a Loop?](#%28part._.Is_.It_.Really_a_.Loop_%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [26.3Â å®ƒçœŸçš„æ˜¯ä¸€ä¸ªå¾ªç¯å—ï¼Ÿ](#%28part._.Is_.It_.Really_a_.Loop_%29) |'
- en: '| Â Â Â Â [26.4Â Re-Examining `for`](#%28part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [26.4Â é‡æ–°å®¡è§†`for`](#%28part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__%29)
    |'
- en: '| Â Â Â Â [26.5Â Rewriting Pollard-Rho](#%28part._.Rewriting_.Pollard-.Rho%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [26.5Â é‡å†™Pollard-Rho](#%28part._.Rewriting_.Pollard-.Rho%29) |'
- en: '| Â Â Â Â [26.6Â Nested Loops](#%28part._.Nested_.Loops%29) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [26.6Â åµŒå¥—å¾ªç¯](#%28part._.Nested_.Loops%29) |'
- en: '| Â Â Â Â [26.7Â Loops, Values, and Customization](#%28part._.Loops__.Values__and_.Customization%29)
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [26.7Â å¾ªç¯ã€å€¼å’Œå®šåˆ¶](#%28part._.Loops__.Values__and_.Customization%29) |'
- en: '26.1Â Setup: Two Functions[ğŸ”—](#(part._.Setup__.Two_.Functions) "Link to here")'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.1Â è®¾ç½®ï¼šä¸¤ä¸ªå‡½æ•°[ğŸ”—](#(part._.Setup__.Two_.Functions) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Letâ€™s look at two functions we wrote earlier in [Factoring Numbers](factoring-numbers.html):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬åœ¨[å› æ•°åˆ†è§£æ•°å­—](factoring-numbers.html)ä¸­å†™è¿‡çš„ä¸¤ä¸ªå‡½æ•°ï¼š
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Weâ€™ve written both recursively: `gcd` by calling itself and `pr` with recursion
    on its inner function. But if youâ€™ve programmed before, youâ€™ve probably written
    similar programs with loops.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éƒ½é€šè¿‡é€’å½’æ¥ç¼–å†™ï¼š`gcd`é€šè¿‡è°ƒç”¨è‡ªèº«ï¼Œ`pr`é€šè¿‡å¯¹å…¶å†…éƒ¨å‡½æ•°çš„é€’å½’ã€‚ä½†å¦‚æœä½ ä¹‹å‰ç¼–ç¨‹è¿‡ï¼Œä½ å¯èƒ½å·²ç»ç”¨å¾ªç¯ç¼–å†™è¿‡ç±»ä¼¼çš„ç¨‹åºã€‚
- en: Exercise
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because we donâ€™t have loops in Pyret, the best we can do is to use a higher-order
    function; which ones would you use?
  id: totrans-15
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å› ä¸ºåœ¨Pyretä¸­æ²¡æœ‰å¾ªç¯ï¼Œæˆ‘ä»¬èƒ½åšçš„æœ€å¥½çš„äº‹æƒ…å°±æ˜¯ä½¿ç”¨ä¸€ä¸ªé«˜é˜¶å‡½æ•°ï¼›ä½ ä»¬ä¼šä½¿ç”¨å“ªäº›ï¼Ÿ
- en: But letâ€™s see if we can do something â€œbetterâ€, i.e., get closer to a traditional-looking
    program.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬æ˜¯å¦å¯ä»¥åšåˆ°â€œæ›´å¥½â€ï¼Œå³æ›´æ¥è¿‘ä¼ ç»Ÿç¨‹åºçš„å¤–è§‚ã€‚
- en: 'Before we start changing any code, letâ€™s make sure we have some tests for `gcd`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬å¼€å§‹æ›´æ”¹ä»»ä½•ä»£ç ä¹‹å‰ï¼Œè®©æˆ‘ä»¬ç¡®ä¿æˆ‘ä»¬å¯¹`gcd`æœ‰ä¸€äº›æµ‹è¯•ï¼š
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 26.2Â Abstracting a Loop[ğŸ”—](#(part._.Abstracting_a_.Loop) "Link to here")
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.2Â æŠ½è±¡åŒ–å¾ªç¯[ğŸ”—](#(part._.Abstracting_a_.Loop) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Now letâ€™s think about how we can create a loop. At each iteration, a loop has
    a status: whether itâ€™s done or whether it should continue. Since we have two parameters
    here, letâ€™s record two parameters for continuing:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ¥è€ƒè™‘å¦‚ä½•åˆ›å»ºä¸€ä¸ªå¾ªç¯ã€‚åœ¨æ¯æ¬¡è¿­ä»£ä¸­ï¼Œå¾ªç¯éƒ½æœ‰ä¸€ä¸ªçŠ¶æ€ï¼šå®ƒæ˜¯å¦å®Œæˆï¼Œæˆ–è€…å®ƒæ˜¯å¦åº”è¯¥ç»§ç»­ã€‚ç”±äºæˆ‘ä»¬è¿™é‡Œæœ‰ä¸¤ä¸ªå‚æ•°ï¼Œè®©æˆ‘ä»¬è®°å½•ä¸¤ä¸ªå‚æ•°ä»¥ç»§ç»­ï¼š
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we can write a function that does the actual iteration:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥ç¼–å†™ä¸€ä¸ªæ‰§è¡Œå®é™…è¿­ä»£çš„å‡½æ•°ï¼š
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that this is completely generic: it has nothing to do with `gcd`. (It
    is generic in the same way that higher-order functions like `map` and `filter`
    are generic.) It just repeats if `f` says to repeat, stops if `f` says to stop.
    This is the essence of a loop.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™å®Œå…¨æ˜¯é€šç”¨çš„ï¼šå®ƒä¸`gcd`æ— å…³ã€‚ï¼ˆå®ƒä»¥ä¸é«˜é˜¶å‡½æ•°å¦‚`map`å’Œ`filter`ç›¸åŒçš„æ–¹å¼æ˜¯é€šç”¨çš„ã€‚ï¼‰å®ƒåªæ˜¯å¦‚æœ`f`æŒ‡ç¤ºé‡å¤å°±é‡å¤ï¼Œå¦‚æœ`f`æŒ‡ç¤ºåœæ­¢å°±åœæ­¢ã€‚è¿™å°±æ˜¯å¾ªç¯çš„æœ¬è´¨ã€‚
- en: Exercise
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe also that we could, if we wanted, stage [[Staging](staging.html)] `loop-2`,
    because `f` never changes. Rewrite it that way.
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¦‚æœæˆ‘ä»¬æ„¿æ„ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å°†[[Staging](staging.html)] `loop-2`åˆ†é˜¶æ®µè¿›è¡Œï¼Œå› ä¸º`f`æ°¸è¿œä¸ä¼šæ”¹å˜ã€‚ä»¥è¿™ç§æ–¹å¼é‡å†™å®ƒã€‚
- en: 'With `loop-2`, we can rewrite `gcd`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`loop-2`ï¼Œæˆ‘ä»¬å¯ä»¥é‡å†™`gcd`ï¼š
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now it might seem to you we havenâ€™t done anything useful at all. In fact, this
    looks like a significant step backward. At least before we just had simple, clean
    recursion, the way Euclid intended it. Now we have a higher-order function and
    weâ€™re passing it the erstwhile `gcd` code as a function and thereâ€™s this `LoopStatus`
    datatype andâ€¦everythingâ€™s gotten much more complicated.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ä½ å¯èƒ½è§‰å¾—æˆ‘ä»¬ä¸€ç‚¹æœ‰ç”¨çš„ä¸œè¥¿éƒ½æ²¡åšã€‚å®é™…ä¸Šï¼Œè¿™çœ‹èµ·æ¥åƒæ˜¯ä¸€ä¸ªé‡å¤§çš„å€’é€€ã€‚è‡³å°‘åœ¨æˆ‘ä»¬ä¹‹å‰ï¼Œæˆ‘ä»¬åªæœ‰ç®€å•ã€å¹²å‡€çš„é€’å½’ï¼Œè¿™æ­£æ˜¯æ¬§å‡ é‡Œå¾—æ‰€æœŸæœ›çš„ã€‚ç°åœ¨æˆ‘ä»¬æœ‰ä¸€ä¸ªé«˜é˜¶å‡½æ•°ï¼Œæˆ‘ä»¬æŠŠå®ƒä½œä¸ºå‡½æ•°ä¼ é€’äº†åŸæ¥çš„`gcd`ä»£ç ï¼Œè¿˜æœ‰ä¸€ä¸ª`LoopStatus`æ•°æ®ç±»å‹ï¼Œâ€¦â€¦ä¸€åˆ‡å˜å¾—å¤æ‚å¤šäº†ã€‚
- en: 'But, not really. The reason we put it in this form is because weâ€™re about to
    exploit a feature of Pyret. The `for` construct in Pyret actually rewrites as
    follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†ï¼Œå®é™…ä¸Šå¹¶ä¸æ˜¯è¿™æ ·ã€‚æˆ‘ä»¬ä¹‹æ‰€ä»¥ä»¥è¿™ç§å½¢å¼ç¼–å†™å®ƒï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬å³å°†åˆ©ç”¨Pyretçš„ä¸€ä¸ªç‰¹æ€§ã€‚Pyretä¸­çš„`for`æ„é€ å®é™…ä¸Šè¢«é‡å†™ä¸ºä»¥ä¸‹å½¢å¼ï¼š
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: gets rewritten to
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: è¢«é‡å†™ä¸º
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For example, if we write
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬å†™
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: this becomes
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å˜æˆ
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now you may see why we rewrote `gcd`. Going in reverse, we can rewrite
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ä½ å¯èƒ½æ˜ç™½ä¸ºä»€ä¹ˆæˆ‘ä»¬é‡å†™äº†`gcd`ã€‚ä»åå¾€å‰çœ‹ï¼Œæˆ‘ä»¬å¯ä»¥é‡å†™
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: as
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶å
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: so the function becomes just
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆå‡½æ•°å°±å˜æˆäº†
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: and now closely resembles a traditional â€œloopâ€ program.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨å®ƒéå¸¸æ¥è¿‘ä¼ ç»Ÿçš„â€œå¾ªç¯â€ç¨‹åºã€‚
- en: 26.3Â Is It Really a Loop?[ğŸ”—](#(part._.Is_.It_.Really_a_.Loop_) "Link to here")
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.3 å®ƒçœŸçš„æ˜¯ä¸€ä¸ªå¾ªç¯å—ï¼Ÿ[ğŸ”—](#(part._.Is_.It_.Really_a_.Loop_) "é“¾æ¥è‡³æ­¤")
- en: This whole section should be considered an aside for people with more advanced
    computing knowledge.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: æ•´ä¸ªè¿™ä¸€èŠ‚åº”è¯¥è¢«è§†ä¸ºå¯¹å…·æœ‰æ›´é«˜çº§è®¡ç®—çŸ¥è¯†çš„äººçš„æ—ç™½ã€‚
- en: 'If you know something about language implementation, you may know that loops
    have the property that the iteration does not consume extra space (beyond what
    the program already needs), and the repetition takes place very quickly (a â€œjump
    instructionâ€). In principle, our `loop-2` function does not have this property:
    every iteration is a function call, which is more expensive and builds additional
    stack context. However, one or both of these does not actually occur in practice.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ äº†è§£ä¸€äº›è¯­è¨€å®ç°çš„çŸ¥è¯†ï¼Œä½ å¯èƒ½çŸ¥é“å¾ªç¯å…·æœ‰è¿­ä»£ä¸æ¶ˆè€—é¢å¤–ç©ºé—´ï¼ˆé™¤ç¨‹åºæœ¬èº«éœ€è¦çš„ç©ºé—´å¤–ï¼‰çš„æ€§è´¨ï¼Œå¹¶ä¸”é‡å¤æ‰§è¡Œéå¸¸å¿«ï¼ˆä¸€ä¸ªâ€œè·³è½¬æŒ‡ä»¤â€ï¼‰ã€‚åŸåˆ™ä¸Šï¼Œæˆ‘ä»¬çš„
    `loop-2` å‡½æ•°æ²¡æœ‰è¿™ä¸ªç‰¹æ€§ï¼šæ¯ä¸ªè¿­ä»£éƒ½æ˜¯ä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼Œè¿™æ›´æ˜‚è´µï¼Œå¹¶æ„å»ºäº†é¢å¤–çš„æ ˆä¸Šä¸‹æ–‡ã€‚ç„¶è€Œï¼Œå®é™…ä¸Šè¿™äº›å¹¶ä¸ä¸€å®šå‘ç”Ÿã€‚
- en: In terms of space, the recursive call to `loop-2` is the last thing that a call
    to `loop-2` does. Furthermore, nothing in `loop-2` consumes and manipulates the
    return from that recursive call. This is therefore called a tail call. Pyretâ€”<wbr>like
    some other languagesâ€”<wbr>causes tail calls to not take any extra stack space.
    In principle, Pyret can also turn some tail calls into jumps. Therefore, this
    version has close to the same performance as a traditional loop.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç©ºé—´æ–¹é¢ï¼Œå¯¹ `loop-2` çš„é€’å½’è°ƒç”¨æ˜¯ `loop-2` è°ƒç”¨çš„æœ€åä¸€ä»¶äº‹ã€‚æ­¤å¤–ï¼Œ`loop-2` ä¸­çš„ä»»ä½•å†…å®¹éƒ½ä¸ä¼šæ¶ˆè€—å’Œæ“ä½œé‚£ä¸ªé€’å½’è°ƒç”¨çš„è¿”å›å€¼ã€‚å› æ­¤ï¼Œè¿™è¢«ç§°ä¸ºå°¾é€’å½’ã€‚Pyretâ€”<wbr>åƒä¸€äº›å…¶ä»–è¯­è¨€â€”<wbr>å¯¼è‡´å°¾é€’å½’ä¸å ç”¨ä»»ä½•é¢å¤–çš„æ ˆç©ºé—´ã€‚åŸåˆ™ä¸Šï¼ŒPyret
    ä¹Ÿå¯ä»¥å°†ä¸€äº›å°¾é€’å½’è½¬æ¢ä¸ºè·³è½¬ã€‚å› æ­¤ï¼Œè¿™ä¸ªç‰ˆæœ¬çš„æ€§èƒ½å‡ ä¹ä¸ä¼ ç»Ÿå¾ªç¯ç›¸åŒã€‚
- en: 26.4Â Re-Examining `for`[ğŸ”—](#(part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__)
    "Link to here")
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.4 é‡æ–°å®¡è§† `for`[ğŸ”—](#(part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__)
    "é“¾æ¥è‡³æ­¤")
- en: 'The definition of `for` given above should make you suspicious: Whereâ€™s the
    loop?!? In fact, Pyretâ€™s `for` does not do any looping at all: itâ€™s simply a fancy
    way of writing `lam`. Any â€œloopingâ€ behavior is in the function written after
    `for`. To see that, letâ€™s use for with a non-looping function.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šæ–‡ç»™å‡ºçš„ `for` çš„å®šä¹‰åº”è¯¥è®©ä½ æ€€ç–‘ï¼šå¾ªç¯åœ¨å“ªé‡Œï¼Ÿï¼ï¼Ÿäº‹å®ä¸Šï¼ŒPyret çš„ `for` å®Œå…¨ä¸åšä»»ä½•å¾ªç¯ï¼šå®ƒåªæ˜¯ `lam` çš„ä¸€ä¸ªèŠ±å“¨çš„å†™æ³•ã€‚ä»»ä½•â€œå¾ªç¯â€è¡Œä¸ºéƒ½åœ¨
    `for` åé¢çš„å‡½æ•°ä¸­ã€‚ä¸ºäº†è¯æ˜è¿™ä¸€ç‚¹ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªéå¾ªç¯å‡½æ•°æ¥ä½¿ç”¨ `for`ã€‚
- en: Recall that
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: gets rewritten to
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: è¢«é‡å†™ä¸º
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Thus, suppose we have this function (from [Functions as Data](func-as-data.html)):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªè¿™æ ·çš„å‡½æ•°ï¼ˆæ¥è‡ª [å‡½æ•°ä½œä¸ºæ•°æ®](func-as-data.html)ï¼‰ï¼š
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can call it like this to get approximately 20:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥è¿™æ ·ç§°å‘¼å®ƒä»¥å¾—åˆ°å¤§çº¦ 20ï¼š
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That means we can also call it like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€æˆ‘ä»¬ä¹Ÿå¯ä»¥è¿™æ ·ç§°å‘¼å®ƒï¼š
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Indeed:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼š
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since `d-dx-at` has no iterative behavior, no iteration occurs. The looping
    behavior is given entirely by the function specified after `for`, such as `map`,
    `filter`, or `loop-2` above.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äº `d-dx-at` æ²¡æœ‰è¿­ä»£è¡Œä¸ºï¼Œæ²¡æœ‰å‘ç”Ÿè¿­ä»£ã€‚å¾ªç¯è¡Œä¸ºå®Œå…¨ç”± `for` åæŒ‡å®šçš„å‡½æ•°ç»™å‡ºï¼Œä¾‹å¦‚ `map`ã€`filter` æˆ–ä¸Šé¢çš„ `loop-2`ã€‚
- en: 26.5Â Rewriting Pollard-Rho[ğŸ”—](#(part._.Rewriting_.Pollard-.Rho) "Link to here")
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.5 é‡æ–°ç¼–å†™ Pollard-Rho[ğŸ”—](#(part._.Rewriting_.Pollard-.Rho) "é“¾æ¥è‡³æ­¤")
- en: 'Now letâ€™s tackle Pollard-rho. Notice that itâ€™s a three-parameter function,
    so we canâ€™t use the `loop-2` we had before: thatâ€™s only a suitable loop when we
    have two arguments that change on each iteration (often the iteration variable
    and an accumulator). It would be easy to design a 3-argument version of loop,
    say `loop-3`, but we could also have a more general solution, using a tuple:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬æ¥å¤„ç† Pollard-rhoã€‚æ³¨æ„ï¼Œå®ƒæ˜¯ä¸€ä¸ªä¸‰å‚æ•°å‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸èƒ½ä½¿ç”¨ä¹‹å‰æœ‰çš„ `loop-2`ï¼šå½“æ¯ä¸ªè¿­ä»£æœ‰ä¸¤ä¸ªå‚æ•°æ”¹å˜æ—¶ï¼ˆé€šå¸¸æ˜¯è¿­ä»£å˜é‡å’Œç´¯åŠ å™¨ï¼‰ï¼Œè¿™ä¸ªå¾ªç¯æ‰é€‚ç”¨ã€‚æˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°è®¾è®¡ä¸€ä¸ª
    3-å‚æ•°ç‰ˆæœ¬çš„å¾ªç¯ï¼Œæ¯”å¦‚ `loop-3`ï¼Œä½†æˆ‘ä»¬ä¹Ÿå¯ä»¥æœ‰ä¸€ä¸ªæ›´é€šç”¨çš„è§£å†³æ–¹æ¡ˆï¼Œä½¿ç”¨ä¸€ä¸ªå…ƒç»„ï¼š
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: where `t` is a tuple.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ `t` æ˜¯ä¸€ä¸ªå…ƒç»„ã€‚
- en: 'So now we can rewrite `pr`. Letâ€™s first rename the old `pr` function as `pr-old`
    so we can keep it around for testing. Now we can define a â€œloopâ€-based `pr`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥é‡å†™ `pr`ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å°†æ—§çš„ `pr` å‡½æ•°é‡å‘½åä¸º `pr-old`ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ä¿ç•™å®ƒä»¥ä¾›æµ‹è¯•ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªåŸºäºâ€œå¾ªç¯â€çš„
    `pr`ï¼š
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Indeed, we can test that the two behave in exactly the same way:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥æµ‹è¯•è¿™ä¸¤ä¸ªå‡½æ•°çš„è¡Œä¸ºå®Œå…¨ç›¸åŒï¼š
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 26.6Â Nested Loops[ğŸ”—](#(part._.Nested_.Loops) "Link to here")
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.6 åµŒå¥—å¾ªç¯[ğŸ”—](#(part._.Nested_.Loops) "é“¾æ¥è‡³æ­¤")
- en: We can also write a nested loop this way. Suppose we have a list like
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹Ÿå¯ä»¥è¿™æ ·å†™ä¸€ä¸ªåµŒå¥—å¾ªç¯ã€‚å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªåˆ—è¡¨å¦‚ä¸‹
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'and we want to sum the whole thing by summing each sub-list. Here it is:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æƒ³é€šè¿‡æ±‚å’Œæ¯ä¸ªå­åˆ—è¡¨æ¥æ±‚å’Œæ•´ä¸ªåˆ—è¡¨ã€‚è¿™é‡Œå°±æ˜¯ï¼š
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can simplify this by writing it as two functions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†å…¶å†™æˆä¸¤ä¸ªå‡½æ•°æ¥ç®€åŒ–å®ƒï¼š
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice that the two functions are remarkably similar. This suggests an abstraction:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°è¿™ä¸¤ä¸ªå‡½æ•°éå¸¸ç›¸ä¼¼ã€‚è¿™è¡¨æ˜ä¸€ä¸ªæŠ½è±¡ï¼š
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using this, we can rewrite the two previous functions as:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥å°†å‰é¢ä¸¤ä¸ªå‡½æ•°é‡å†™ä¸ºï¼š
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With the annotations, it becomes clear what each function does. In `sum-a-lon`,
    each element is a number, so it â€œcontributes itselfâ€ to the overall sum. In `sum-a-lolon`,
    each element is a list of numbers, so it â€œcontributes its `sum-a-lon`â€ to the
    overall sum.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡æ³¨é‡Šï¼Œå¯ä»¥æ¸…æ¥šåœ°äº†è§£æ¯ä¸ªå‡½æ•°çš„ä½œç”¨ã€‚åœ¨`sum-a-lon`ä¸­ï¼Œæ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œæ‰€ä»¥å®ƒâ€œè´¡çŒ®äº†è‡ªå·±â€åˆ°æ€»å’Œä¸­ã€‚åœ¨`sum-a-lolon`ä¸­ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œæ‰€ä»¥å®ƒâ€œè´¡çŒ®äº†å…¶`sum-a-lon`â€åˆ°æ€»å’Œä¸­ã€‚
- en: 'Finally, to bring this full circle, we can rewrite the above the functions
    as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œä¸ºäº†ä½¿è¿™ä¸ªå¾ªç¯å®Œæ•´ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸Šè¿°å‡½æ•°é‡å†™å¦‚ä¸‹ï¼š
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Arguably this makes even clearer what each element contributes. In `sum-a-lon`
    each element is a number, so it contributes just that number. In `sum-a-lolon`,
    each element is a list of numbers, so it must contribute `sum-a-lon` of that list.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯èƒ½ä½¿æ¯ä¸ªå…ƒç´ è´¡çŒ®çš„æ›´æ¸…æ™°ã€‚åœ¨`sum-a-lon`ä¸­ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œæ‰€ä»¥å®ƒåªè´¡çŒ®é‚£ä¸ªæ•°å­—ã€‚åœ¨`sum-a-lolon`ä¸­ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œæ‰€ä»¥å®ƒå¿…é¡»è´¡çŒ®è¯¥åˆ—è¡¨çš„`sum-a-lon`ã€‚
- en: 26.7Â Loops, Values, and Customization[ğŸ”—](#(part._.Loops__.Values__and_.Customization)
    "Link to here")
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.7 å¾ªç¯ã€å€¼å’Œå®šåˆ¶[ğŸ”—](#(part._.Loops__.Values__and_.Customization) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Observe two important ways in which the loops above differ from traditional
    loops:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿä¸Šè¿°å¾ªç¯ä¸ä¼ ç»Ÿå¾ªç¯åœ¨ä»¥ä¸‹ä¸¤ä¸ªé‡è¦æ–¹é¢çš„ä¸åŒï¼š
- en: 'Every loop produces a value. This is consistent with the rest of the language,
    whereâ€”<wbr>as much as possibleâ€”<wbr>computations try to produce answers. We donâ€™t
    have to produce a value; for instance, the following program, reminiscent of looping
    programs in many other languages, will work just fine in Pyret:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ¯ä¸ªå¾ªç¯éƒ½äº§ç”Ÿä¸€ä¸ªå€¼ã€‚è¿™ä¸è¯­è¨€çš„å…¶ä½™éƒ¨åˆ†ä¸€è‡´ï¼Œå…¶ä¸­â€”â€”å°½å¯èƒ½â€”â€”è®¡ç®—è¯•å›¾äº§ç”Ÿç­”æ¡ˆã€‚æˆ‘ä»¬ä¸å¿…äº§ç”Ÿä¸€ä¸ªå€¼ï¼›ä¾‹å¦‚ï¼Œä»¥ä¸‹ç¨‹åºï¼Œç±»ä¼¼äºè®¸å¤šå…¶ä»–è¯­è¨€ä¸­çš„å¾ªç¯ç¨‹åºï¼Œåœ¨Pyretä¸­è¿è¡Œå¾—å¾ˆå¥½ï¼š
- en: '[PRE27]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: However, this is the unusual case. In general, we want expressions to produce
    values so that we can compose them together.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¿™æ˜¯ä¸€ä¸ªä¸å¯»å¸¸çš„æƒ…å†µã€‚é€šå¸¸ï¼Œæˆ‘ä»¬å¸Œæœ›è¡¨è¾¾å¼äº§ç”Ÿå€¼ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥å°†å®ƒä»¬ç»„åˆåœ¨ä¸€èµ·ã€‚
- en: 'Many languages have strong opinions on exactly how many looping constructs
    there should be: two? three? four? In Pyret, there are no built-in looping constructs
    at all; thereâ€™s just a syntax (`for`) that serves as a proxy for creating a specific
    `lam`. With it, we can reuse existing iterative functions (like `map` and `filter`),
    but also define new ones. Some can be very generic, like `loop-2` or `loop-n`,
    but others can be very specific, like `sum-a-list`. The language designers donâ€™t
    prevent you from writing a loop that is useful to your situation, and sometimes
    the loop can be very expressive, as we see from rewriting `sum-a-lon` and `sum-a-lolon`
    atop `for` and `sum-a-list`.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è®¸å¤šè¯­è¨€å¯¹åº”è¯¥æœ‰å¤šå°‘ä¸ªå¾ªç¯ç»“æ„æœ‰å¼ºçƒˆçš„çœ‹æ³•ï¼šä¸¤ä¸ªï¼Ÿä¸‰ä¸ªï¼Ÿå››ä¸ªï¼Ÿåœ¨Pyretä¸­ï¼Œæ ¹æœ¬æ²¡æœ‰å†…ç½®çš„å¾ªç¯ç»“æ„ï¼›åªæœ‰ä¸€ä¸ªè¯­æ³•ï¼ˆ`for`ï¼‰ï¼Œå®ƒä½œä¸ºåˆ›å»ºç‰¹å®š`lam`çš„ä»£ç†ã€‚æœ‰äº†å®ƒï¼Œæˆ‘ä»¬å¯ä»¥é‡ç”¨ç°æœ‰çš„è¿­ä»£å‡½æ•°ï¼ˆå¦‚`map`å’Œ`filter`ï¼‰ï¼Œä¹Ÿå¯ä»¥å®šä¹‰æ–°çš„å‡½æ•°ã€‚æœ‰äº›å¯ä»¥éå¸¸é€šç”¨ï¼Œå¦‚`loop-2`æˆ–`loop-n`ï¼Œä½†æœ‰äº›å¯ä»¥éå¸¸å…·ä½“ï¼Œå¦‚`sum-a-list`ã€‚è¯­è¨€è®¾è®¡è€…ä¸ä¼šé˜»æ­¢ä½ ç¼–å†™å¯¹ä½ æœ‰ç”¨çš„å¾ªç¯ï¼Œæœ‰æ—¶å¾ªç¯å¯ä»¥éå¸¸å…·æœ‰è¡¨ç°åŠ›ï¼Œæ­£å¦‚æˆ‘ä»¬ä»é‡å†™`sum-a-lon`å’Œ`sum-a-lolon`åœ¨`for`å’Œ`sum-a-list`ä¹‹ä¸Šæ‰€çœ‹åˆ°çš„é‚£æ ·ã€‚
- en: '26.1Â Setup: Two Functions[ğŸ”—](#(part._.Setup__.Two_.Functions) "Link to here")'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.1 è®¾ç½®ï¼šä¸¤ä¸ªå‡½æ•°[ğŸ”—](#(part._.Setup__.Two_.Functions) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Letâ€™s look at two functions we wrote earlier in [Factoring Numbers](factoring-numbers.html):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬åœ¨[å› å¼åˆ†è§£æ•°å­—](factoring-numbers.html)ä¸­ç¼–å†™çš„ä¸¤ä¸ªå‡½æ•°ï¼š
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Weâ€™ve written both recursively: `gcd` by calling itself and `pr` with recursion
    on its inner function. But if youâ€™ve programmed before, youâ€™ve probably written
    similar programs with loops.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»é€’å½’åœ°ç¼–å†™äº†ä¸¤ä¸ªå‡½æ•°ï¼š`gcd`é€šè¿‡è°ƒç”¨è‡ªèº«ï¼Œ`pr`é€šè¿‡å¯¹å…¶å†…éƒ¨å‡½æ•°çš„é€’å½’ã€‚ä½†å¦‚æœä½ ä¹‹å‰ç¼–ç¨‹è¿‡ï¼Œä½ å¯èƒ½å·²ç»ç”¨å¾ªç¯ç¼–å†™è¿‡ç±»ä¼¼çš„ç¨‹åºã€‚
- en: Exercise
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because we donâ€™t have loops in Pyret, the best we can do is to use a higher-order
    function; which ones would you use?
  id: totrans-100
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç”±äºPyretä¸­æ²¡æœ‰å¾ªç¯ï¼Œæˆ‘ä»¬èƒ½åšçš„æœ€å¥½çš„æ˜¯ä½¿ç”¨ä¸€ä¸ªé«˜é˜¶å‡½æ•°ï¼›ä½ ä¼šä½¿ç”¨å“ªäº›ï¼Ÿ
- en: But letâ€™s see if we can do something â€œbetterâ€, i.e., get closer to a traditional-looking
    program.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬æ˜¯å¦å¯ä»¥åšä¸€äº›â€œæ›´å¥½çš„â€ï¼Œå³æ›´æ¥è¿‘ä¼ ç»Ÿå¤–è§‚çš„ç¨‹åºã€‚
- en: 'Before we start changing any code, letâ€™s make sure we have some tests for `gcd`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬å¼€å§‹æ›´æ”¹ä»»ä½•ä»£ç ä¹‹å‰ï¼Œè®©æˆ‘ä»¬ç¡®ä¿æˆ‘ä»¬æœ‰é’ˆå¯¹`gcd`çš„æµ‹è¯•ï¼š
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 26.2Â Abstracting a Loop[ğŸ”—](#(part._.Abstracting_a_.Loop) "Link to here")
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.2 æŠ½è±¡å¾ªç¯[ğŸ”—](#(part._.Abstracting_a_.Loop) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Now letâ€™s think about how we can create a loop. At each iteration, a loop has
    a status: whether itâ€™s done or whether it should continue. Since we have two parameters
    here, letâ€™s record two parameters for continuing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬æ€è€ƒä¸€ä¸‹å¦‚ä½•åˆ›å»ºä¸€ä¸ªå¾ªç¯ã€‚åœ¨æ¯æ¬¡è¿­ä»£ä¸­ï¼Œå¾ªç¯éƒ½æœ‰ä¸€ä¸ªçŠ¶æ€ï¼šæ˜¯å¦å®Œæˆæˆ–è€…æ˜¯å¦åº”è¯¥ç»§ç»­ã€‚ç”±äºæˆ‘ä»¬è¿™é‡Œæœ‰ä¸¤ä¸ªå‚æ•°ï¼Œè®©æˆ‘ä»¬è®°å½•ä¸¤ä¸ªå‚æ•°ä»¥ç»§ç»­ï¼š
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we can write a function that does the actual iteration:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥ç¼–å†™ä¸€ä¸ªæ‰§è¡Œå®é™…è¿­ä»£çš„å‡½æ•°ï¼š
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that this is completely generic: it has nothing to do with `gcd`. (It
    is generic in the same way that higher-order functions like `map` and `filter`
    are generic.) It just repeats if `f` says to repeat, stops if `f` says to stop.
    This is the essence of a loop.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™å®Œå…¨æ˜¯é€šç”¨çš„ï¼šå®ƒä¸ `gcd` æ²¡æœ‰å…³ç³»ã€‚ï¼ˆå®ƒä»¥ä¸ `map` å’Œ `filter` ç­‰é«˜é˜¶å‡½æ•°ç›¸åŒçš„æ–¹å¼æ˜¯é€šç”¨çš„ã€‚ï¼‰å®ƒåªæ˜¯å¦‚æœ `f` æŒ‡ç¤ºé‡å¤å°±é‡å¤ï¼Œå¦‚æœ
    `f` æŒ‡ç¤ºåœæ­¢å°±åœæ­¢ã€‚è¿™å°±æ˜¯å¾ªç¯çš„æœ¬è´¨ã€‚
- en: Exercise
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe also that we could, if we wanted, stage [[Staging](staging.html)] `loop-2`,
    because `f` never changes. Rewrite it that way.
  id: totrans-112
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¦‚æœæˆ‘ä»¬æ„¿æ„ï¼Œå¯ä»¥å®‰æ’ [[Staging](staging.html)] `loop-2`ï¼Œå› ä¸º `f` ä»æœªæ”¹å˜ã€‚ä»¥è¿™ç§æ–¹å¼é‡å†™å®ƒã€‚
- en: 'With `loop-2`, we can rewrite `gcd`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ `loop-2`ï¼Œæˆ‘ä»¬å¯ä»¥é‡æ–°ç¼–å†™ `gcd`ï¼š
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now it might seem to you we havenâ€™t done anything useful at all. In fact, this
    looks like a significant step backward. At least before we just had simple, clean
    recursion, the way Euclid intended it. Now we have a higher-order function and
    weâ€™re passing it the erstwhile `gcd` code as a function and thereâ€™s this `LoopStatus`
    datatype andâ€¦everythingâ€™s gotten much more complicated.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ä½ å¯èƒ½è§‰å¾—æˆ‘ä»¬æ ¹æœ¬æ²¡åšä»»ä½•æœ‰ç”¨çš„äº‹æƒ…ã€‚äº‹å®ä¸Šï¼Œè¿™çœ‹èµ·æ¥åƒæ˜¯ä¸€ä¸ªé‡å¤§çš„å€’é€€ã€‚è‡³å°‘åœ¨æˆ‘ä»¬ä¹‹å‰ï¼Œæˆ‘ä»¬åªæœ‰ç®€å•ã€å¹²å‡€çš„é€’å½’ï¼Œè¿™æ­£æ˜¯æ¬§å‡ é‡Œå¾—æ‰€æœŸæœ›çš„ã€‚ç°åœ¨æˆ‘ä»¬æœ‰ä¸€ä¸ªé«˜é˜¶å‡½æ•°ï¼Œæˆ‘ä»¬å°†å…¶ä½œä¸ºå‡½æ•°ä¼ é€’äº†ä¹‹å‰çš„
    `gcd` ä»£ç ï¼Œè¿˜æœ‰ä¸€ä¸ª `LoopStatus` æ•°æ®ç±»å‹ï¼Œâ€¦â€¦ä¸€åˆ‡å˜å¾—æ›´åŠ å¤æ‚ã€‚
- en: 'But, not really. The reason we put it in this form is because weâ€™re about to
    exploit a feature of Pyret. The `for` construct in Pyret actually rewrites as
    follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†ï¼Œå¹¶éå¦‚æ­¤ã€‚æˆ‘ä»¬ä¹‹æ‰€ä»¥ä»¥è¿™ç§å½¢å¼å‘ˆç°ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬å³å°†åˆ©ç”¨ Pyret çš„ä¸€ä¸ªç‰¹æ€§ã€‚Pyret ä¸­çš„ `for` æ„é€ å®é™…ä¸Šè¢«é‡å†™ä¸ºä»¥ä¸‹å½¢å¼ï¼š
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: gets rewritten to
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: è¢«é‡æ–°ç¼–å†™ä¸º
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For example, if we write
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬å†™
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: this becomes
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å˜æˆäº†
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now you may see why we rewrote `gcd`. Going in reverse, we can rewrite
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ä½ å¯èƒ½æ˜ç™½æˆ‘ä»¬ä¸ºä»€ä¹ˆè¦é‡æ–°ç¼–å†™ `gcd`ã€‚ä»åå¾€å‰ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·é‡æ–°ç¼–å†™
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: as
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸º
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: so the function becomes just
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œå‡½æ•°å°±å˜æˆäº†è¿™æ ·
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: and now closely resembles a traditional â€œloopâ€ program.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨å®ƒéå¸¸ç±»ä¼¼äºä¼ ç»Ÿçš„â€œå¾ªç¯â€ç¨‹åºã€‚
- en: 26.3Â Is It Really a Loop?[ğŸ”—](#(part._.Is_.It_.Really_a_.Loop_) "Link to here")
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.3 çœŸçš„æ˜¯å¾ªç¯å—ï¼Ÿ[ğŸ”—](#(part._.Is_.It_.Really_a_.Loop_) "é“¾æ¥åˆ°æ­¤å¤„")
- en: This whole section should be considered an aside for people with more advanced
    computing knowledge.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: æ•´ä¸ªè¿™ä¸€éƒ¨åˆ†åº”è¢«è§†ä¸ºå¯¹å…·æœ‰æ›´é«˜çº§è®¡ç®—çŸ¥è¯†çš„äººçš„æ—ç™½ã€‚
- en: 'If you know something about language implementation, you may know that loops
    have the property that the iteration does not consume extra space (beyond what
    the program already needs), and the repetition takes place very quickly (a â€œjump
    instructionâ€). In principle, our `loop-2` function does not have this property:
    every iteration is a function call, which is more expensive and builds additional
    stack context. However, one or both of these does not actually occur in practice.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ äº†è§£ä¸€äº›è¯­è¨€å®ç°çš„çŸ¥è¯†ï¼Œä½ å¯èƒ½çŸ¥é“å¾ªç¯å…·æœ‰è¿™æ ·çš„å±æ€§ï¼šè¿­ä»£ä¸ä¼šæ¶ˆè€—é¢å¤–çš„ç©ºé—´ï¼ˆé™¤äº†ç¨‹åºå·²ç»éœ€è¦çš„ç©ºé—´ï¼‰ï¼Œé‡å¤è¿›è¡Œå¾—éå¸¸å¿«ï¼ˆä¸€ä¸ªâ€œè·³è½¬æŒ‡ä»¤â€ï¼‰ã€‚åŸåˆ™ä¸Šï¼Œæˆ‘ä»¬çš„
    `loop-2` å‡½æ•°ä¸å…·æœ‰è¿™ä¸ªå±æ€§ï¼šæ¯æ¬¡è¿­ä»£éƒ½æ˜¯ä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼Œè¿™æ›´æ˜‚è´µï¼Œå¹¶ä¸”æ„å»ºäº†é¢å¤–çš„å †æ ˆä¸Šä¸‹æ–‡ã€‚ç„¶è€Œï¼Œå®é™…ä¸Šè¿™äº›å¹¶æ²¡æœ‰çœŸæ­£å‘ç”Ÿã€‚
- en: In terms of space, the recursive call to `loop-2` is the last thing that a call
    to `loop-2` does. Furthermore, nothing in `loop-2` consumes and manipulates the
    return from that recursive call. This is therefore called a tail call. Pyretâ€”<wbr>like
    some other languagesâ€”<wbr>causes tail calls to not take any extra stack space.
    In principle, Pyret can also turn some tail calls into jumps. Therefore, this
    version has close to the same performance as a traditional loop.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç©ºé—´æ–¹é¢ï¼Œå¯¹ `loop-2` çš„é€’å½’è°ƒç”¨æ˜¯ `loop-2` è°ƒç”¨çš„æœ€åä¸€ä»¶äº‹ã€‚æ­¤å¤–ï¼Œ`loop-2` ä¸­æ²¡æœ‰ä»»ä½•ä¸œè¥¿æ¶ˆè€—å¹¶æ“ä½œé‚£ä¸ªé€’å½’è°ƒç”¨çš„è¿”å›å€¼ã€‚å› æ­¤ï¼Œè¿™è¢«ç§°ä¸ºå°¾è°ƒç”¨ã€‚Pyretï¼ˆå°±åƒä¸€äº›å…¶ä»–è¯­è¨€ä¸€æ ·ï¼‰å¯¼è‡´å°¾è°ƒç”¨ä¸å ç”¨ä»»ä½•é¢å¤–çš„å †æ ˆç©ºé—´ã€‚åŸåˆ™ä¸Šï¼ŒPyret
    ä¹Ÿå¯ä»¥å°†ä¸€äº›å°¾è°ƒç”¨è½¬æ¢ä¸ºè·³è½¬ã€‚å› æ­¤ï¼Œè¿™ä¸ªç‰ˆæœ¬çš„æ€§èƒ½å‡ ä¹ä¸ä¼ ç»Ÿå¾ªç¯ç›¸åŒã€‚
- en: 26.4Â Re-Examining `for`[ğŸ”—](#(part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__)
    "Link to here")
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.4 é‡æ–°å®¡è§† `for`[ğŸ”—](#(part._.Re-.Examining___struct_traverse-element___procedure____lib_render-cond_rkt_38_12__)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'The definition of `for` given above should make you suspicious: Whereâ€™s the
    loop?!? In fact, Pyretâ€™s `for` does not do any looping at all: itâ€™s simply a fancy
    way of writing `lam`. Any â€œloopingâ€ behavior is in the function written after
    `for`. To see that, letâ€™s use for with a non-looping function.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šæ–‡ç»™å‡ºçš„ `for` çš„å®šä¹‰å¯èƒ½ä¼šè®©ä½ æ€€ç–‘ï¼šå¾ªç¯åœ¨å“ªé‡Œï¼Ÿï¼ï¼Ÿäº‹å®ä¸Šï¼ŒPyret çš„ `for` å®é™…ä¸Šæ ¹æœ¬ä¸åšä»»ä½•å¾ªç¯ï¼šå®ƒåªæ˜¯ä»¥æ›´èŠ±å“¨çš„æ–¹å¼ç¼–å†™ `lam`ã€‚ä»»ä½•â€œå¾ªç¯â€è¡Œä¸ºéƒ½åœ¨
    `for` åé¢ç¼–å†™çš„å‡½æ•°ä¸­ã€‚ä¸ºäº†è¯æ˜è¿™ä¸€ç‚¹ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªéå¾ªç¯å‡½æ•°æ¥ä½¿ç”¨ `for`ã€‚
- en: Recall that
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: gets rewritten to
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: è¢«é‡æ–°ç¼–å†™ä¸º
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Thus, suppose we have this function (from [Functions as Data](func-as-data.html)):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªè¿™æ ·çš„å‡½æ•°ï¼ˆæ¥è‡ª [å‡½æ•°ä½œä¸ºæ•°æ®](func-as-data.html)ï¼‰ï¼š
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can call it like this to get approximately 20:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥è¿™æ ·è°ƒç”¨å®ƒæ¥å¾—åˆ°å¤§çº¦ 20ï¼š
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'That means we can also call it like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€æˆ‘ä»¬ä¹Ÿå¯ä»¥è¿™æ ·è°ƒç”¨å®ƒï¼š
- en: '[PRE44]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Indeed:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼š
- en: '[PRE45]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Since `d-dx-at` has no iterative behavior, no iteration occurs. The looping
    behavior is given entirely by the function specified after `for`, such as `map`,
    `filter`, or `loop-2` above.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äº `d-dx-at` æ²¡æœ‰è¿­ä»£è¡Œä¸ºï¼Œå› æ­¤æ²¡æœ‰å‘ç”Ÿè¿­ä»£ã€‚å¾ªç¯è¡Œä¸ºå®Œå…¨ç”± `for` åæŒ‡å®šçš„å‡½æ•°ç»™å‡ºï¼Œä¾‹å¦‚ä¸Šé¢çš„ `map`ã€`filter` æˆ– `loop-2`ã€‚
- en: 26.5Â Rewriting Pollard-Rho[ğŸ”—](#(part._.Rewriting_.Pollard-.Rho) "Link to here")
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.5 é‡å†™ Pollard-Rho[ğŸ”—](#(part._.Rewriting_.Pollard-.Rho) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Now letâ€™s tackle Pollard-rho. Notice that itâ€™s a three-parameter function,
    so we canâ€™t use the `loop-2` we had before: thatâ€™s only a suitable loop when we
    have two arguments that change on each iteration (often the iteration variable
    and an accumulator). It would be easy to design a 3-argument version of loop,
    say `loop-3`, but we could also have a more general solution, using a tuple:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥å¤„ç† Pollard-rhoã€‚æ³¨æ„ï¼Œå®ƒæ˜¯ä¸€ä¸ªä¸‰å‚æ•°å‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸èƒ½ä½¿ç”¨ä¹‹å‰ä½¿ç”¨çš„ `loop-2`ï¼šå½“æ¯ä¸ªè¿­ä»£ä¸­éƒ½æœ‰ä¸¤ä¸ªå‚æ•°å˜åŒ–æ—¶ï¼ˆé€šå¸¸æ˜¯è¿­ä»£å˜é‡å’Œç´¯åŠ å™¨ï¼‰ï¼Œè¿™ä¸ªå¾ªç¯æ‰é€‚ç”¨ã€‚æˆ‘ä»¬å¯ä»¥è½»æ¾è®¾è®¡ä¸€ä¸ª
    3 å‚æ•°ç‰ˆæœ¬çš„å¾ªç¯ï¼Œæ¯”å¦‚ `loop-3`ï¼Œä½†æˆ‘ä»¬ä¹Ÿå¯ä»¥æœ‰ä¸€ä¸ªæ›´é€šç”¨çš„è§£å†³æ–¹æ¡ˆï¼Œä½¿ç”¨å…ƒç»„ï¼š
- en: '[PRE46]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: where `t` is a tuple.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ `t` æ˜¯ä¸€ä¸ªå…ƒç»„ã€‚
- en: 'So now we can rewrite `pr`. Letâ€™s first rename the old `pr` function as `pr-old`
    so we can keep it around for testing. Now we can define a â€œloopâ€-based `pr`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ç°åœ¨æˆ‘ä»¬å¯ä»¥é‡å†™ `pr`ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å°†æ—§çš„ `pr` å‡½æ•°é‡å‘½åä¸º `pr-old`ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ä¿ç•™å®ƒä»¥ä¾¿äºæµ‹è¯•ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªåŸºäºâ€œå¾ªç¯â€çš„
    `pr`ï¼š
- en: '[PRE47]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Indeed, we can test that the two behave in exactly the same way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥æµ‹è¯•è¿™ä¸¤ä¸ªå‡½æ•°çš„è¡Œä¸ºå®Œå…¨ç›¸åŒï¼š
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 26.6Â Nested Loops[ğŸ”—](#(part._.Nested_.Loops) "Link to here")
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.6 åµŒå¥—å¾ªç¯[ğŸ”—](#(part._.Nested_.Loops) "é“¾æ¥åˆ°æ­¤å¤„")
- en: We can also write a nested loop this way. Suppose we have a list like
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨è¿™ç§æ–¹å¼å†™åµŒå¥—å¾ªç¯ã€‚å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªåˆ—è¡¨å¦‚ä¸‹
- en: '[PRE49]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'and we want to sum the whole thing by summing each sub-list. Here it is:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¸Œæœ›é€šè¿‡æ±‚å’Œæ¯ä¸ªå­åˆ—è¡¨æ¥æ±‚å’Œæ•´ä¸ªå†…å®¹ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE50]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can simplify this by writing it as two functions:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†å…¶å†™æˆä¸¤ä¸ªå‡½æ•°æ¥ç®€åŒ–è¿™ä¸€ç‚¹ï¼š
- en: '[PRE51]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Notice that the two functions are remarkably similar. This suggests an abstraction:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°è¿™ä¸¤ä¸ªå‡½æ•°éå¸¸ç›¸ä¼¼ã€‚è¿™è¡¨æ˜äº†ä¸€ç§æŠ½è±¡ï¼š
- en: '[PRE52]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Using this, we can rewrite the two previous functions as:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¹‹å‰çš„ä¸¤ä¸ªå‡½æ•°é‡å†™ä¸ºï¼š
- en: '[PRE53]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: With the annotations, it becomes clear what each function does. In `sum-a-lon`,
    each element is a number, so it â€œcontributes itselfâ€ to the overall sum. In `sum-a-lolon`,
    each element is a list of numbers, so it â€œcontributes its `sum-a-lon`â€ to the
    overall sum.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡æ³¨é‡Šï¼Œæˆ‘ä»¬å¯ä»¥æ¸…æ¥šåœ°äº†è§£æ¯ä¸ªå‡½æ•°çš„ä½œç”¨ã€‚åœ¨ `sum-a-lon` ä¸­ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œå› æ­¤å®ƒâ€œè´¡çŒ®è‡ªèº«â€åˆ°æ€»å’Œä¸­ã€‚åœ¨ `sum-a-lolon`
    ä¸­ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¸€ç»„æ•°å­—çš„åˆ—è¡¨ï¼Œå› æ­¤å®ƒâ€œè´¡çŒ®å…¶ `sum-a-lon`â€åˆ°æ€»å’Œä¸­ã€‚
- en: 'Finally, to bring this full circle, we can rewrite the above the functions
    as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œä¸ºäº†ä½¿è¿™ä¸ªå¾ªç¯å®Œæ•´ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸Šè¿°å‡½æ•°é‡å†™å¦‚ä¸‹ï¼š
- en: '[PRE54]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Arguably this makes even clearer what each element contributes. In `sum-a-lon`
    each element is a number, so it contributes just that number. In `sum-a-lolon`,
    each element is a list of numbers, so it must contribute `sum-a-lon` of that list.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä½¿å¾—æ¯ä¸ªå…ƒç´ è´¡çŒ®çš„å†…å®¹æ›´åŠ æ¸…æ™°ã€‚åœ¨ `sum-a-lon` ä¸­ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œå› æ­¤å®ƒåªè´¡çŒ®é‚£ä¸ªæ•°å­—ã€‚åœ¨ `sum-a-lolon` ä¸­ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¸€ç»„æ•°å­—çš„åˆ—è¡¨ï¼Œå› æ­¤å®ƒå¿…é¡»è´¡çŒ®è¯¥åˆ—è¡¨çš„
    `sum-a-lon`ã€‚
- en: 26.7Â Loops, Values, and Customization[ğŸ”—](#(part._.Loops__.Values__and_.Customization)
    "Link to here")
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.7 å¾ªç¯ã€å€¼å’Œå®šåˆ¶[ğŸ”—](#(part._.Loops__.Values__and_.Customization) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Observe two important ways in which the loops above differ from traditional
    loops:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿä¸Šè¿°å¾ªç¯ä¸ä¼ ç»Ÿå¾ªç¯åœ¨ä¸¤ä¸ªé‡è¦æ–¹é¢çš„ä¸åŒï¼š
- en: 'Every loop produces a value. This is consistent with the rest of the language,
    whereâ€”<wbr>as much as possibleâ€”<wbr>computations try to produce answers. We donâ€™t
    have to produce a value; for instance, the following program, reminiscent of looping
    programs in many other languages, will work just fine in Pyret:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ¯ä¸ªå¾ªç¯éƒ½ä¼šäº§ç”Ÿä¸€ä¸ªå€¼ã€‚è¿™ä¸è¯­è¨€çš„å…¶ä»–éƒ¨åˆ†ä¸€è‡´ï¼Œå…¶ä¸­â€”â€”å°½å¯èƒ½â€”â€”è®¡ç®—è¯•å›¾äº§ç”Ÿç­”æ¡ˆã€‚æˆ‘ä»¬ä¸å¿…äº§ç”Ÿä¸€ä¸ªå€¼ï¼›ä¾‹å¦‚ï¼Œä»¥ä¸‹ç¨‹åºï¼Œç±»ä¼¼äºè®¸å¤šå…¶ä»–è¯­è¨€ä¸­çš„å¾ªç¯ç¨‹åºï¼Œå°†è¿è¡Œå¾—å¾ˆå¥½ï¼š
- en: '[PRE55]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: However, this is the unusual case. In general, we want expressions to produce
    values so that we can compose them together.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¿™æ˜¯ä¸€ä¸ªç‰¹æ®Šæƒ…å†µã€‚é€šå¸¸ï¼Œæˆ‘ä»¬å¸Œæœ›è¡¨è¾¾å¼äº§ç”Ÿå€¼ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å°†å®ƒä»¬ç»„åˆåœ¨ä¸€èµ·ã€‚
- en: 'Many languages have strong opinions on exactly how many looping constructs
    there should be: two? three? four? In Pyret, there are no built-in looping constructs
    at all; thereâ€™s just a syntax (`for`) that serves as a proxy for creating a specific
    `lam`. With it, we can reuse existing iterative functions (like `map` and `filter`),
    but also define new ones. Some can be very generic, like `loop-2` or `loop-n`,
    but others can be very specific, like `sum-a-list`. The language designers donâ€™t
    prevent you from writing a loop that is useful to your situation, and sometimes
    the loop can be very expressive, as we see from rewriting `sum-a-lon` and `sum-a-lolon`
    atop `for` and `sum-a-list`.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è®¸å¤šè¯­è¨€å¯¹åº”è¯¥æœ‰å¤šå°‘ä¸ªå¾ªç¯ç»“æ„æœ‰ç€å¼ºçƒˆçš„çœ‹æ³•ï¼šä¸¤ä¸ªï¼Ÿä¸‰ä¸ªï¼Ÿå››ä¸ªï¼Ÿåœ¨Pyretä¸­ï¼Œæ ¹æœ¬æ²¡æœ‰ä»»ä½•å†…ç½®çš„å¾ªç¯ç»“æ„ï¼›åªæœ‰ä¸€ä¸ªè¯­æ³•ï¼ˆ`for`ï¼‰ï¼Œå®ƒä½œä¸ºåˆ›å»ºç‰¹å®š`lam`çš„ä»£ç†ã€‚æœ‰äº†å®ƒï¼Œæˆ‘ä»¬å¯ä»¥é‡ç”¨ç°æœ‰çš„è¿­ä»£å‡½æ•°ï¼ˆå¦‚`map`å’Œ`filter`ï¼‰ï¼Œä¹Ÿå¯ä»¥å®šä¹‰æ–°çš„å‡½æ•°ã€‚æœ‰äº›å¯ä»¥éå¸¸é€šç”¨ï¼Œæ¯”å¦‚`loop-2`æˆ–`loop-n`ï¼Œä½†æœ‰äº›åˆ™éå¸¸å…·ä½“ï¼Œæ¯”å¦‚`sum-a-list`ã€‚è¯­è¨€è®¾è®¡è€…ä¸ä¼šé˜»æ­¢ä½ ç¼–å†™é€‚åˆä½ æƒ…å†µçš„å¾ªç¯ï¼Œæœ‰æ—¶å¾ªç¯å¯ä»¥éå¸¸å…·æœ‰è¡¨ç°åŠ›ï¼Œæ­£å¦‚æˆ‘ä»¬ä»åœ¨`for`å’Œ`sum-a-list`ä¹‹ä¸Šé‡å†™`sum-a-lon`å’Œ`sum-a-lolon`ä¸­çœ‹åˆ°çš„é‚£æ ·ã€‚
