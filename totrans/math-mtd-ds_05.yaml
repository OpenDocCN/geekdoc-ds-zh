- en: '1.3\. Clustering: an objective, an algorithm and a guarantee#'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3\. 聚类：一个目标、一个算法和一个保证#
- en: 原文：[https://mmids-textbook.github.io/chap01_intro/03_clustering/roch-mmids-intro-clustering.html](https://mmids-textbook.github.io/chap01_intro/03_clustering/roch-mmids-intro-clustering.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://mmids-textbook.github.io/chap01_intro/03_clustering/roch-mmids-intro-clustering.html](https://mmids-textbook.github.io/chap01_intro/03_clustering/roch-mmids-intro-clustering.html)
- en: Consider the following fundamental problem in data science.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑数据科学中的以下基本问题。
- en: '*The input:* We are given \(n\) vectors \(\mathbf{x}_1,\ldots,\mathbf{x}_n\)
    in \(\mathbb{R}^d\).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入:* 我们被给出 \(n\) 个在 \(\mathbb{R}^d\) 中的向量 \(\mathbf{x}_1,\ldots,\mathbf{x}_n\).'
- en: 'Our goal is to find a good clustering\(\idx{clustering}\xdi\): loosely speaking,
    we want to partition these data points into \(k\) disjoint subsets – or clusters
    – with small pairwise distances within clusters and large pairwise distances across
    clusters. To make this rather vague problem more precise, we consider a specific
    objective function known as the \(k\)-means objective. Our approach here will
    be typical of how one might approach a mathematical data science problem. We will
    first formulate the problem as an optimization problem, then derive an algorithm
    to solve it, and finally provide some rigorous guarantees about the output.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是找到一个好的聚类\(\idx{clustering}\xdi\)：通俗地说，我们希望将这些数据点划分为 \(k\) 个不相交的子集——或聚类——在聚类内部有小的成对距离，在聚类之间有大的成对距离。为了使这个问题更加明确，我们考虑一个特定的目标函数，称为
    \(k\)-均值目标。我们在这里的方法将是一个典型的数学数据科学问题的处理方法。我们首先将问题表述为一个优化问题，然后推导出一个算法来解决它，最后提供一些关于输出的严格保证。
- en: '**Figure:** Data points forming three clusters ([Source](https://commons.wikimedia.org/wiki/File:Cluster-2.svg))'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**图:** 形成三个聚类的数据点 ([来源](https://commons.wikimedia.org/wiki/File:Cluster-2.svg))'
- en: '![Data points forming three clusters](../Images/c4d356b8ecee59d522f94bb3d77cd0e9.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![形成三个聚类的数据点](../Images/c4d356b8ecee59d522f94bb3d77cd0e9.png)'
- en: \(\bowtie\)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: \(\bowtie\)
- en: '*The output:* But first, we need to define precisely what we are trying to
    extract from the data. What is the mathematical structure of the solution sought?
    Fix a number of clusters \(k\). Formally, we define a clustering as a partition.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*输出:* 但首先，我们需要精确地定义我们试图从数据中提取的内容。所求解的数学结构是什么？固定一个聚类的数量 \(k\)。形式上，我们定义聚类为一个划分。'
- en: '**DEFINITION** **(Partition)** \(\idx{partition}\xdi\) A partition of \([n]
    = \{1,\ldots,n\}\) of size \(k\) is a collection of non-empty subsets \(C_1,\ldots,C_k
    \subseteq [n]\) that:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** **(划分)** \(\idx{partition}\xdi\) \([n] = \{1,\ldots,n\}\) 的一个大小为 \(k\)
    的划分是一个非空子集的集合 \(C_1,\ldots,C_k \subseteq [n]\)，它：'
- en: are pairwise disjoint, i.e., \(C_i \cap C_j = \emptyset\), \(\forall i \neq
    j\)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是成对不相交的，即 \(C_i \cap C_j = \emptyset\)，\(\forall i \neq j\)
- en: cover all of \([n]\), i.e., \(\cup_{i=1}^k C_i = [n]\).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖所有 \([n]\)，即 \(\cup_{i=1}^k C_i = [n]\).
- en: \(\natural\)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: \(\natural\)
- en: '**EXAMPLE:** Suppose we are given \(8\) data points in \(\mathbb{R}^2\) as
    follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例:** 假设我们被给出 \(\mathbb{R}^2\) 中的 \(8\) 个数据点，如下所示：'
- en: \[\begin{align*} &\mathbf{x}_1 = \begin{pmatrix}1\\0\end{pmatrix}, \mathbf{x}_2
    = \begin{pmatrix}-2\\0\end{pmatrix}, \mathbf{x}_3 = \begin{pmatrix}-2\\1\end{pmatrix},
    \mathbf{x}_4 = \begin{pmatrix}1\\-3\end{pmatrix},\\ &\mathbf{x}_5 = \begin{pmatrix}-10\\10\end{pmatrix},
    \mathbf{x}_6 = \begin{pmatrix}2\\-2\end{pmatrix}, \mathbf{x}_7 = \begin{pmatrix}-3\\1\end{pmatrix},
    \mathbf{x}_8 = \begin{pmatrix}3\\-1\end{pmatrix}. \end{align*}\]
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{align*} &\mathbf{x}_1 = \begin{pmatrix}1\\0\end{pmatrix}, \mathbf{x}_2
    = \begin{pmatrix}-2\\0\end{pmatrix}, \mathbf{x}_3 = \begin{pmatrix}-2\\1\end{pmatrix},
    \mathbf{x}_4 = \begin{pmatrix}1\\-3\end{pmatrix},\\ &\mathbf{x}_5 = \begin{pmatrix}-10\\10\end{pmatrix},
    \mathbf{x}_6 = \begin{pmatrix}2\\-2\end{pmatrix}, \mathbf{x}_7 = \begin{pmatrix}-3\\1\end{pmatrix},
    \mathbf{x}_8 = \begin{pmatrix}3\\-1\end{pmatrix}. \end{align*}\]
- en: 'So here \(n=8\) and \(d = 2\). Assume we look for \(k = 3\) clusters. Then
    a valid clustering would be for instance:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此这里 \(n=8\) 且 \(d = 2\)。假设我们寻找 \(k = 3\) 个聚类。那么一个有效的聚类可以是例如：
- en: \[ C_1 = \{1, 4, 6, 8\}, C_2 = \{2, 3, 7\}, C_3 = \{5\}, \]
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: \[ C_1 = \{1, 4, 6, 8\}, C_2 = \{2, 3, 7\}, C_3 = \{5\}, \]
- en: which corresponds to assigning data points \(\mathbf{x}_1, \mathbf{x}_4, \mathbf{x}_6,
    \mathbf{x}_8\) to the first cluster, data points \(\mathbf{x}_2, \mathbf{x}_3,
    \mathbf{x}_7\) to the second cluster and data point \(\mathbf{x}_5\) to the third
    cluster. Note in particular that the sets \(C_1, C_2, C_3\) satisfy the conditions
    of a partition, i.e., they are disjoint and cover all of \([8] = \{1,2,\ldots,8\}\).
    Or put differently, each data point is assigned to one and exactly one cluster.
    \(\lhd\)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于将数据点\(\mathbf{x}_1, \mathbf{x}_4, \mathbf{x}_6, \mathbf{x}_8\)分配到第一个簇，数据点\(\mathbf{x}_2,
    \mathbf{x}_3, \mathbf{x}_7\)分配到第二个簇，数据点\(\mathbf{x}_5\)分配到第三个簇。特别注意的是，集合\(C_1,
    C_2, C_3\)满足划分的条件，即它们是互斥的，并且覆盖了所有\([8] = \{1,2,\ldots,8\}\)。或者换句话说，每个数据点被分配到且仅分配到一个簇。\(\lhd\)
- en: We number the clusters \(C_1,\ldots,C_k\) for notational convenience, but their
    order is meaningless. Two partitions are the same if they are the same family
    of subsets. E.g., in the previous example, \(C_1 = \{1, 4, 6, 8\}, C_2 = \{2,
    3, 7\}, C_3 = \{5\}\) and \(C_1 = \{5\}, C_2 = \{1, 4, 6, 8\}, C_3 = \{2, 3, 7\}\)
    are equivalent clusterings.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便表示，我们给簇编号为\(C_1,\ldots,C_k\)，但它们的顺序是没有意义的。如果两个划分具有相同的子集族，则它们是相同的。例如，在前面的例子中，\(C_1
    = \{1, 4, 6, 8\}, C_2 = \{2, 3, 7\}, C_3 = \{5\}\)和\(C_1 = \{5\}, C_2 = \{1, 4,
    6, 8\}, C_3 = \{2, 3, 7\}\)是等效的聚类。
- en: 1.3.1\. The k-means objective[#](#the-k-means-objective "Link to this heading")
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3.1\. \(k\)-means目标函数[#](#the-k-means-objective "链接到这个标题")
- en: Under the \(k\)-means objective\(\idx{k-means objective}\xdi\), the “cost” of
    \(C_1,\ldots,C_k\) is defined as
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在\(k\)-means目标函数\(\idx{k-means objective}\xdi\)下，\(C_1,\ldots,C_k\)的“成本”定义为
- en: \[ \mathcal{G}(C_1,\ldots,C_k) = \min_{\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k
    \in \mathbb{R}^d} \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2.
    \]
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \mathcal{G}(C_1,\ldots,C_k) = \min_{\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k
    \in \mathbb{R}^d} \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2.
    \]
- en: Here \(\boldsymbol{\mu}_i \in \mathbb{R}^d\) is the representative – or center
    – of cluster \(C_i\). Note that \(\boldsymbol{\mu}_i\) need not be one of the
    \(\mathbf{x}_j\)’s.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里\(\boldsymbol{\mu}_i \in \mathbb{R}^d\)是簇\(C_i\)的代表或中心。注意\(\boldsymbol{\mu}_i\)不必是\(\mathbf{x}_j\)之一。
- en: Our goal is to find a partition \(C_1,\ldots,C_k\) that minimizes \(\mathcal{G}(C_1,\ldots,C_k)\),
    i.e., solves the problem
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是找到一个划分\(C_1,\ldots,C_k\)，使得\(\mathcal{G}(C_1,\ldots,C_k)\)最小化，即解决以下问题
- en: \[ \min_{C_1,\ldots,C_k} \mathcal{G}(C_1,\ldots,C_k) \]
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \min_{C_1,\ldots,C_k} \mathcal{G}(C_1,\ldots,C_k) \]
- en: over all partitions of \([n]\) of size \(k\). This is a finite optimization
    problem, as there are only a finite number of such partitions. Note, however,
    that the objective function itself is an optimization problem over \(\mathbb{R}^d
    \times \cdots \times \mathbb{R}^{d}\), that is, \(k\) copies of \(\mathbb{R}^d\).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在\([n]\)的所有大小为\(k\)的划分中。这是一个有限的优化问题，因为这样的划分数量是有限的。然而，需要注意的是，目标函数本身是在\(\mathbb{R}^d
    \times \cdots \times \mathbb{R}^{d}\)上的优化问题，即\(d\)个\(\mathbb{R}^d\)的副本。
- en: 'To quote [Wikipedia](https://en.wikipedia.org/wiki/Cluster_analysis#Centroid-based_clustering):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '引用[Wikipedia](https://en.wikipedia.org/wiki/Cluster_analysis#Centroid-based_clustering):'
- en: 'In centroid-based clustering, clusters are represented by a central vector,
    which may not necessarily be a member of the data set. When the number of clusters
    is fixed to k, k-means clustering gives a formal definition as an optimization
    problem: find the k cluster centers and assign the objects to the nearest cluster
    center, such that the squared distances from the cluster are minimized.'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在基于质心的聚类中，簇由一个中心向量表示，这个向量不一定必须是数据集的成员。当簇的数量固定为k时，\(k\)-means聚类给出了一个形式化的定义，即一个优化问题：找到k个簇中心并将对象分配到最近的簇中心，使得簇之间的平方距离最小化。
- en: '**KNOWLEDGE CHECK:** Is it possible for a global solution of the \(k\)-means
    clustering problem to contain an empty cluster? \(\checkmark\)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**知识检查:** \(k\)-means聚类问题的全局解是否可能包含一个空簇？\(\checkmark\)'
- en: 'In general, the problem is [NP-hard](https://en.wikipedia.org/wiki/NP-hardness)\(\idx{NP-hardness}\xdi\),
    that is, roughly speaking no “fast” algorithm is expected to exist to solve it.
    Lloyd’s algorithm (also referred to as the \(k\)-means algorithm) is a popular
    heuristic. It is based on the idea that the following two sub-problems are easy
    to solve:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，这个问题是[NP-hard](https://en.wikipedia.org/wiki/NP-hardness)\(\idx{NP-hardness}\xdi\),
    即粗略地说，没有期望存在一个“快速”的算法来解决这个问题。Lloyd算法（也称为\(k\)-means算法）是一种流行的启发式算法。它基于以下两个子问题容易解决的观念：
- en: finding the optimal representatives for a fixed partition;
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于一个固定的划分找到最优的代表；
- en: finding the optimal partition for a fixed set of representatives.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于一组固定的代表找到最优划分。
- en: One then alternates between the two (perhaps until progress falls below a tolerance).
    This is reasonable since our goal, as we pointed out above, is to solve the minimization
    problem
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后交替进行两次（或许直到进步低于容差）。这是合理的，因为我们的目标，如我们上面指出的，是解决最小化问题
- en: \[ \min_{C_1,\ldots,C_k} \min_{\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k
    \in \mathbb{R}^d} \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2
    \]
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \min_{C_1,\ldots,C_k} \min_{\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k
    \in \mathbb{R}^d} \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2
    \]
- en: where \(C_1,\ldots,C_k\) ranges over all partitions of \([n]\) of size \(k\).
    Fixing partition \(C_1,\ldots,C_k\) and miniminizing over \(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k
    \in \mathbb{R}^d\) corresponds to solving the first problem above, while fixing
    \(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k \in \mathbb{R}^d\) and miniminizing
    over partitions \(C_1,\ldots,C_k\) corresponds to solving the second problem.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(C_1,\ldots,C_k\) 范围是 \([n]\) 的所有大小为 \(k\) 的划分。固定划分 \(C_1,\ldots,C_k\) 并在
    \(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k \in \mathbb{R}^d\) 上进行最小化对应于解决上面的问题，而固定
    \(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k \in \mathbb{R}^d\) 并在划分 \(C_1,\ldots,C_k\)
    上进行最小化对应于解决第二个问题。
- en: '**CHAT & LEARN** Ask your favorite AI chatbot about the differences between
    \(k\)-means, \(k\)-medians, and \(k\)-medoids clustering. \(\ddagger\)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**CHAT & LEARN** 向你最喜欢的 AI 聊天机器人询问 \(k\)-means、\(k\)-medians 和 \(k\)-medoids
    聚类之间的区别。 \(\ddagger\)'
- en: '**Some useful optimization results** To analyze the Lloyd’s algorithm, we will
    rely on a few basic observations.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**一些有用的优化结果** 为了分析 Lloyd 算法，我们将依赖几个基本观察。'
- en: '*Minimizing a quadratic function:* To elaborate on the first step above, we
    review an elementary fact about [quadratic functions](https://en.wikipedia.org/wiki/Quadratic_function).Consider
    the function'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*最小化二次函数*: 为了阐述上面的第一步，我们回顾一个关于[二次函数](https://en.wikipedia.org/wiki/Quadratic_function)的基本事实。考虑函数'
- en: \[ q(x) = a x^2 + b x + c. \]
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: \[ q(x) = a x^2 + b x + c. \]
- en: When \(a > 0\), \(q\) has a unique minimum.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当 \(a > 0\) 时，\(q\) 有一个唯一的极小值。
- en: '**LEMMA** **(Minimum of a Quadratic Function)** \(\idx{minimum of a quadratic
    function}\xdi\) Let \(q(x) = a x^2 + b x + c\) where \(a > 0\) and \(x \in \mathbb{R}\).
    The unique global minimum of \(q\) is attained at'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**引理** **(二次函数的最小值)** \(\idx{二次函数的最小值}\xdi\) 设 \(q(x) = a x^2 + b x + c\)，其中
    \(a > 0\) 且 \(x \in \mathbb{R}\)。\(q\) 的唯一全局最小值在'
- en: \[ x^* = -\frac{b}{2a}. \]
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x^* = -\frac{b}{2a}. \]
- en: \(\flat\)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: \(\flat\)
- en: '*Proof:* By the *First-Order Necessary Optimality Condition*, a global minimizer
    of \(q\) (which is necessarily a local minimizer) satisfies the condition'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明*: 根据*一阶必要最优性条件*，\(q\) 的全局极小化器（必然是局部极小化器）满足条件'
- en: \[ \frac{\mathrm{d}}{\mathrm{d}x} q(x) = 2 a x + b = 0, \]
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \frac{\mathrm{d}}{\mathrm{d}x} q(x) = 2 a x + b = 0, \]
- en: whose unique solution is
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 其唯一的解是
- en: \[ x^*= -\frac{b}{2a}. \]
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x^*= -\frac{b}{2a}. \]
- en: To see that \(x^*\) is indeed a global minimizer, we re-write \(q\) as
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看出 \(x^*\) 确实是一个全局极小化器，我们将 \(q\) 重新写为
- en: \[\begin{align*} q(x) &= a \left(x^2 + 2 \left[\frac{b}{2a}\right] x\right)
    + c\\ &= a \left(x^2 + 2 \left[\frac{b}{2a}\right] x + \left[\frac{b}{2a}\right]^2\right)
    - a \left[\frac{b}{2a}\right]^2 + c\\ &= a (x - x^*)^2 + \left[c - \frac{b^2}{4a}\right].
    \end{align*}\]
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{align*} q(x) &= a \left(x^2 + 2 \left[\frac{b}{2a}\right] x\right)
    + c\\ &= a \left(x^2 + 2 \left[\frac{b}{2a}\right] x + \left[\frac{b}{2a}\right]^2\right)
    - a \left[\frac{b}{2a}\right]^2 + c\\ &= a (x - x^*)^2 + \left[c - \frac{b^2}{4a}\right].
    \end{align*}\]
- en: Clearly, any other \(x\) gives a higher value for \(q\). The step on the second
    line above is called [*Completing the Square*](https://en.wikipedia.org/wiki/Completing_the_square).
    \(\square\)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，任何其他的 \(x\) 都会给 \(q\) 带来更高的值。上面第二行的步骤被称为[*完成平方*](https://en.wikipedia.org/wiki/Completing_the_square)。
    \(\square\)
- en: '**NUMERICAL CORNER:** Here’s a numerical example. We first define a quadratic
    function.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**数值角**: 这里有一个数值示例。我们首先定义一个二次函数。'
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We plot it for different values of the coefficients. Note that the \(x\) and
    \(y\) axes are on different scales.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为不同的系数值绘制它。注意 \(x\) 轴和 \(y\) 轴的刻度不同。
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![../../_images/61bc7fdbb91557152ddeef0b81d381a6bfd002c537f7992efa581d8504d503a5.png](../Images/eae4bc2fb4c7aab683b47a1a195867e9.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/61bc7fdbb91557152ddeef0b81d381a6bfd002c537f7992efa581d8504d503a5.png](../Images/eae4bc2fb4c7aab683b47a1a195867e9.png)'
- en: \(\unlhd\)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: \(\unlhd\)
- en: '*Optimizing an additively separable function:* Functions that can be written
    as the sum of disjoint sets of coordinates arise commonly in optimization and
    have convenient “separability” properties.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*优化可加分离函数*: 可以写成坐标集合的并集之和的函数在优化中很常见，并且具有方便的“可分离”性质。'
- en: For vectors \(\mathbf{x}_i \in \mathbb{R}^{d_i}\), \(i \in [\ell]\), with \(\sum_{i=1}^\ell
    d_i = d\), their concatenation is denoted as \((\mathbf{x}_1, \ldots, \mathbf{x}_\ell)
    \in \mathbb{R}^d\). That is the vector obtained by concatenating the coordinates
    of \(\mathbf{x}_1, \ldots, \mathbf{x}_\ell\) into a single vector. A different
    way to see this is that \((\mathbf{x}_1, \ldots, \mathbf{x}_\ell)\) is a block
    vector with blocks \(\mathbf{x}_1, \ldots, \mathbf{x}_\ell\). For example, if
    \(\mathbf{x}_1 = (1, 2)\) and \(\mathbf{x}_2 = (-1, -3, -5)\), then \((\mathbf{x}_1,\mathbf{x}_2)
    = (1, 2, -1, -3, -5)\).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于向量 \(\mathbf{x}_i \in \mathbb{R}^{d_i}\)，其中 \(i \in [\ell]\)，且 \(\sum_{i=1}^\ell
    d_i = d\)，它们的连接表示为 \((\mathbf{x}_1, \ldots, \mathbf{x}_\ell) \in \mathbb{R}^d\)。这就是通过将
    \(\mathbf{x}_1, \ldots, \mathbf{x}_\ell\) 的坐标连接成一个单一向量得到的向量。另一种看待它的方法是，\((\mathbf{x}_1,
    \ldots, \mathbf{x}_\ell)\) 是一个由 \(\mathbf{x}_1, \ldots, \mathbf{x}_\ell\) 组成的块向量。例如，如果
    \(\mathbf{x}_1 = (1, 2)\) 和 \(\mathbf{x}_2 = (-1, -3, -5)\)，那么 \((\mathbf{x}_1,\mathbf{x}_2)
    = (1, 2, -1, -3, -5)\)。
- en: '**LEMMA** **(Optimizing a Separable Function)** \(\idx{optimizing a separable
    function lemma}\xdi\) Assume that \(\mathbf{z} \in \mathbb{R}^d\) can be broken
    up into subvectors \(\mathbf{x}_i \in \mathbb{R}^{d_i}\), \(i \in [\ell]\), with
    \(\sum_{i=1}^\ell d_i = d\) as follows \(\mathbf{z} = (\mathbf{x}_1, \ldots, \mathbf{x}_\ell)\).
    Suppose that the real-valued function \(h : \mathbb{R}^d \to \mathbb{R}\) can
    be written in the additively separable form'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**引理** **(优化可分离函数)** \(\idx{优化可分离函数引理}\xdi\) 假设 \(\mathbf{z} \in \mathbb{R}^d\)
    可以分解为子向量 \(\mathbf{x}_i \in \mathbb{R}^{d_i}\)，其中 \(i \in [\ell]\)，且 \(\sum_{i=1}^\ell
    d_i = d\)，如下所示 \(\mathbf{z} = (\mathbf{x}_1, \ldots, \mathbf{x}_\ell)\)。假设实值函数
    \(h : \mathbb{R}^d \to \mathbb{R}\) 可以写成加性可分离的形式'
- en: \[ h(\mathbf{z}) = f_1(\mathbf{x}_1) + \cdots + f_\ell(\mathbf{x}_\ell), \]
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: \[ h(\mathbf{z}) = f_1(\mathbf{x}_1) + \cdots + f_\ell(\mathbf{x}_\ell), \]
- en: 'for a collection of functions \(f_i : \mathbb{R}^{d_i} \to \mathbb{R}\), \(i
    \in [\ell]\). If, for each \(i \in [\ell]\), \(\mathbf{x}_i^*\) is a global minimum
    of \(f_i\), then \(\mathbf{z}^* = (\mathbf{x}_1^*, \ldots, \mathbf{x}_\ell^*)\)
    is a global minimum of \(h\). \(\flat\)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '对于函数集合 \(f_i : \mathbb{R}^{d_i} \to \mathbb{R}\)，其中 \(i \in [\ell]\)。如果对于每个
    \(i \in [\ell]\)，\(\mathbf{x}_i^*\) 是 \(f_i\) 的全局最小值，那么 \(\mathbf{z}^* = (\mathbf{x}_1^*,
    \ldots, \mathbf{x}_\ell^*)\) 是 \(h\) 的全局最小值。 \(\flat\)'
- en: '*Proof idea:* Each term in the sum defining \(h\) depends on a separate set
    of coordinates and therefore is unaffected by the choices made in other terms.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明思路：* \(h\) 定义中的每一项都依赖于一组独立的坐标，因此不受其他项选择的影响。'
- en: '*Proof:* Let \(\mathbf{z} = (\mathbf{x}_1, \ldots, \mathbf{x}_\ell)\). Since
    \(\mathbf{x}_i^*\) is a global minimum of \(f_i\), it holds that \(f_i(\mathbf{x}_i^*)
    \leq f_i(\mathbf{x}_i)\), for all \(i\). Hence,'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明：* 设 \(\mathbf{z} = (\mathbf{x}_1, \ldots, \mathbf{x}_\ell)\)。由于 \(\mathbf{x}_i^*\)
    是 \(f_i\) 的全局最小值，因此对于所有 \(i\)，有 \(f_i(\mathbf{x}_i^*) \leq f_i(\mathbf{x}_i)\)。因此，'
- en: \[ h(\mathbf{z}^*) = f_1(\mathbf{x}_1^*) + \cdots + f_\ell(\mathbf{x}_\ell^*)
    \leq f_1(\mathbf{x}_1) + \cdots + f_\ell(\mathbf{x}_\ell) = h(\mathbf{z}). \]
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: \[ h(\mathbf{z}^*) = f_1(\mathbf{x}_1^*) + \cdots + f_\ell(\mathbf{x}_\ell^*)
    \leq f_1(\mathbf{x}_1) + \cdots + f_\ell(\mathbf{x}_\ell) = h(\mathbf{z}). \]
- en: Since \(\mathbf{z}\) is arbitrary, we have proved the claim. \(\square\)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 \(\mathbf{z}\) 是任意的，我们已经证明了该命题。 \(\square\)
- en: '*Composing with a non-decreasing function:* Recall that a real-valued function
    \(f\) of a single variable is non-decreasing if'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*与非递减函数组合：* 回想一下，一个单变量实值函数 \(f\) 如果满足'
- en: \[ x \leq y \implies f(x) \leq f(y). \]
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x \leq y \implies f(x) \leq f(y). \]
- en: '**LEMMA** **(Composing with a Non-Decreasing Function)** \(\idx{composing with
    a non-decreasing function lemma}\xdi\) Let \(f : \mathbb{R} \to \mathbb{R}\) be
    non-decreasing, let \(g : \mathbb{R}^d \to \mathbb{R}\), and define \(h(\mathbf{x})
    = f(g(\mathbf{x}))\). If \(\mathbf{x}^*\) is a global minimum of \(g\), then it
    is also a global minimum of \(h\). \(\flat\)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**引理** **(与非递减函数组合)** \(\idx{与非递减函数组合引理}\xdi\) 设 \(f : \mathbb{R} \to \mathbb{R}\)
    是非递减的，设 \(g : \mathbb{R}^d \to \mathbb{R}\)，并定义 \(h(\mathbf{x}) = f(g(\mathbf{x}))\)。如果
    \(\mathbf{x}^*\) 是 \(g\) 的全局最小值，那么它也是 \(h\) 的全局最小值。 \(\flat\)'
- en: '*Proof idea:* This just follows from applying the definitions.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明思路：* 这只是应用定义的结果。'
- en: '*Proof:* Let \(\mathbf{x} \in \mathbb{R}^d\). Because \(\mathbf{x}^*\) is a
    global minimum of \(g\), \(g(\mathbf{x}^*) \leq g(\mathbf{x})\). Further, since
    \(f\) is non-decreasing,'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明：* 设 \(\mathbf{x} \in \mathbb{R}^d\)。因为 \(\mathbf{x}^*\) 是 \(g\) 的全局最小值，所以
    \(g(\mathbf{x}^*) \leq g(\mathbf{x})\)。进一步地，由于 \(f\) 是非递减的，'
- en: \[ h(\mathbf{x}^*) = f(g(\mathbf{x}^*)) \leq f(g(\mathbf{x})) = h(\mathbf{x}).
    \]
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: \[ h(\mathbf{x}^*) = f(g(\mathbf{x}^*)) \leq f(g(\mathbf{x})) = h(\mathbf{x}).
    \]
- en: Since \(\mathbf{x}\) is arbitrary, we have proved the claim. \(\square\)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 \(\mathbf{x}\) 是任意的，我们已经证明了该命题。 \(\square\)
- en: '**Sub-problem 1: finding the optimal representatives** We denote by \(|C_i|\)
    the number of elements in \(C_i\).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**子问题 1：寻找最优代表** 我们用 \(|C_i|\) 表示 \(C_i\) 中的元素数量。'
- en: '**EXAMPLE:** **(continued)** Continuing the example above, the sizes of the
    clusters are respectively \(|C_1| = 4, |C_2| = 3, |C_3| = 1\). Note in particulat
    that \(|C_1| + |C_2| + |C_3| = 8 = n\), as follows from the fact that \(C_1, C_2,
    C_3\) is a partition. \(\lhd\)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：** **(继续)** 继续上面的示例，簇的大小分别为 \(|C_1| = 4, |C_2| = 3, |C_3| = 1\)。特别注意的是
    \(|C_1| + |C_2| + |C_3| = 8 = n\)，这是由于 \(C_1, C_2, C_3\) 是一个划分。 \(\lhd\)'
- en: '**LEMMA** **(Optimal Representatives)** \(\idx{optimal representatives lemma}\xdi\)
    Fix a partition \(C_1,\ldots,C_k\). The optimal representatives under the objective'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**引理** **(最优代表)** \(\idx{optimal representatives lemma}\xdi\) 固定一个划分 \(C_1,\ldots,C_k\)。在目标'
- en: \[ G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k) = \sum_{i=1}^k
    \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2, \]
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: \[ G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k) = \sum_{i=1}^k
    \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2, \]
- en: are the [centroids](https://en.wikipedia.org/wiki/Centroid)\(\idx{centroid}\xdi\)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 是 [质心](https://en.wikipedia.org/wiki/Centroid)\(\idx{centroid}\xdi\)
- en: \[ \boldsymbol{\mu}_i^* = \frac{1}{|C_i|} \sum_{j\in C_i} \mathbf{x}_j. \]
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \boldsymbol{\mu}_i^* = \frac{1}{|C_i|} \sum_{j\in C_i} \mathbf{x}_j. \]
- en: \(\flat\)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: \(\flat\)
- en: '*Proof idea:* The objective \(G\) can be written as a sum, where each term
    is a quadratic function in one component of one of the \(\boldsymbol{\mu}_i\)’s.
    Each of these terms is minimized by the average of the corresponding components
    of the \(\mathbf{x}_j\)’s belonging \(C_i\).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明思路：* 目标 \(G\) 可以写成求和的形式，其中每一项是 \(\boldsymbol{\mu}_i\) 的一个分量上的二次函数。这些项中的每一项都通过
    \(C_i\) 中属于 \(\mathbf{x}_j\) 的相应分量的平均值来最小化。'
- en: '**EXAMPLE:** **(continued)** Continuing with the previous example, we compute
    the optimal representatives for the fixed partition \(C_1, C_2, C_3\) above. We
    get'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：** **(继续)** 继续上一个示例，我们计算固定划分 \(C_1, C_2, C_3\) 的最优代表。我们得到'
- en: \[\begin{align*} \boldsymbol{\mu}_1^* &= \frac{1}{4}[\mathbf{x}_1 + \mathbf{x}_4
    + \mathbf{x}_6 + \mathbf{x}_8]\\ &= \frac{1}{4}\left[\begin{pmatrix}1\\0\end{pmatrix}
    + \begin{pmatrix}1\\-3\end{pmatrix} + \begin{pmatrix}2\\-2\end{pmatrix} + \begin{pmatrix}3\\-1\end{pmatrix}
    \right] = \begin{pmatrix}7/4\\-3/2\end{pmatrix},\\ \boldsymbol{\mu}_2^* &= \frac{1}{3}[\mathbf{x}_2
    + \mathbf{x}_3 + \mathbf{x}_7]\\ &= \frac{1}{3}\left[\begin{pmatrix}-2\\0\end{pmatrix}+
    \begin{pmatrix}-2\\1\end{pmatrix}+ \begin{pmatrix}-3\\1\end{pmatrix} \right] =
    \begin{pmatrix}-7/3\\2/3\end{pmatrix},\\ \boldsymbol{\mu}_3^* &= \frac{1}{1}[\mathbf{x}_5]
    = \begin{pmatrix}-10\\10\end{pmatrix}. \end{align*}\]
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{align*} \boldsymbol{\mu}_1^* &= \frac{1}{4}[\mathbf{x}_1 + \mathbf{x}_4
    + \mathbf{x}_6 + \mathbf{x}_8]\\ &= \frac{1}{4}\left[\begin{pmatrix}1\\0\end{pmatrix}
    + \begin{pmatrix}1\\-3\end{pmatrix} + \begin{pmatrix}2\\-2\end{pmatrix} + \begin{pmatrix}3\\-1\end{pmatrix}
    \right] = \begin{pmatrix}7/4\\-3/2\end{pmatrix},\\ \boldsymbol{\mu}_2^* &= \frac{1}{3}[\mathbf{x}_2
    + \mathbf{x}_3 + \mathbf{x}_7]\\ &= \frac{1}{3}\left[\begin{pmatrix}-2\\0\end{pmatrix}+
    \begin{pmatrix}-2\\1\end{pmatrix}+ \begin{pmatrix}-3\\1\end{pmatrix} \right] =
    \begin{pmatrix}-7/3\\2/3\end{pmatrix},\\ \boldsymbol{\mu}_3^* &= \frac{1}{1}[\mathbf{x}_5]
    = \begin{pmatrix}-10\\10\end{pmatrix}. \end{align*}\]
- en: \(\lhd\)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: \(\lhd\)
- en: '*Proof:* *(Optimal Representatives)* Using the notation \(\mathbf{x}_j = (x_{j1},\ldots,x_{jd})\)
    and similarly for \(\boldsymbol{\mu}_i\), note that we can expand the \(k\)-means
    objective as'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明：* *(最优代表)* 使用符号 \(\mathbf{x}_j = (x_{j1},\ldots,x_{jd})\) 以及类似地对于 \(\boldsymbol{\mu}_i\)，注意我们可以将
    \(k\)-means 目标函数展开为'
- en: \[\begin{align*} \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2
    &= \sum_{i=1}^k \sum_{j \in C_i} \sum_{m=1}^d (x_{jm} - \mu_{im})^2\\ &= \sum_{i=1}^k
    \sum_{m=1}^d \left[\sum_{j \in C_i} (x_{jm} - \mu_{im})^2\right]. \end{align*}\]
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{align*} \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2
    &= \sum_{i=1}^k \sum_{j \in C_i} \sum_{m=1}^d (x_{jm} - \mu_{im})^2\\ &= \sum_{i=1}^k
    \sum_{m=1}^d \left[\sum_{j \in C_i} (x_{jm} - \mu_{im})^2\right]. \end{align*}\]
- en: The expression in square brackets is a quadratic function in \(\mu_{im}\)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号中的表达式是 \(\mu_{im}\) 上的二次函数
- en: \[\begin{align*} q_{im}(\mu_{im}) &= \sum_{j \in C_i} (x_{jm} - \mu_{im})^2\\
    &= \left\{\sum_{j \in C_i} x_{jm}^2\right\} + \left\{- 2 \sum_{j \in C_i} x_{jm}\right\}
    \mu_{im} + \left\{|C_i| \right\} \mu_{im}^2. \end{align*}\]
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{align*} q_{im}(\mu_{im}) &= \sum_{j \in C_i} (x_{jm} - \mu_{im})^2\\
    &= \left\{\sum_{j \in C_i} x_{jm}^2\right\} + \left\{- 2 \sum_{j \in C_i} x_{jm}\right\}
    \mu_{im} + \left\{|C_i| \right\} \mu_{im}^2. \end{align*}\]
- en: Therefore, by the formula for the *Minimum of a Quadratic Function*, is minimized
    at
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据二次函数的最小值公式，最小值在
- en: \[ \mu_{im}^* = - \frac{- 2 \sum_{j \in C_i} x_{jm}}{2 |C_i|} = \frac{1}{|C_i|}
    \sum_{j \in C_i} x_{jm}. \]
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \mu_{im}^* = - \frac{- 2 \sum_{j \in C_i} x_{jm}}{2 |C_i|} = \frac{1}{|C_i|}
    \sum_{j \in C_i} x_{jm}. \]
- en: Since each term \(q_{im}(\mu_{im})\) in the sum over \(i, m\) making up the
    objective function \(G\) is minimized at \(\boldsymbol{\mu}_1^*,\ldots, \boldsymbol{\mu}_k^*\),
    so is \(G\) by *Optimizing a Separable Function*. \(\square\)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目标函数 \(G\) 中由 \(i, m\) 组成的求和中的每个项 \(q_{im}(\mu_{im})\) 都在 \(\boldsymbol{\mu}_1^*,\ldots,
    \boldsymbol{\mu}_k^*\) 处最小化，因此根据 *可分离函数优化*，\(G\) 也最小化。\(\square\)
- en: That the squared norm decomposes into a sum over the coordinates (which the
    norm itself doesn’t because of the square root) is one reason why it is convenient
    to use here, as was hopefully apparent in this last proof.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于平方范数分解为坐标之和（由于平方根，范数本身并不分解），这是在这里使用它的一个原因，这在最后的证明中应该是显而易见的。
- en: '**Sub-problem 2: finding the optimal partition** Given \(n\) vectors \(\mathbf{x}_1,\ldots,\mathbf{x}_n\)
    in \(\mathbb{R}^d\) and a partition \(C_1, \ldots, C_k \subseteq [n]\), it will
    be useful to have some notation for the corresponding cluster assignment: we define
    \(c(j) = i\) if \(j \in C_i\).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**子问题 2：寻找最优划分** 给定 \(\mathbb{R}^d\) 中的 \(n\) 个向量 \(\mathbf{x}_1,\ldots,\mathbf{x}_n\)
    和一个划分 \(C_1, \ldots, C_k \subseteq [n]\)，对于相应的簇分配，将会有一些符号是有用的：我们定义 \(c(j) = i\)
    如果 \(j \in C_i\)。'
- en: '**EXAMPLE:** **(continued)** Continuing the example above, the clusters \(C_1
    = \{1, 4, 6, 8\}, C_2 = \{2, 3, 7\}, C_3 = \{5\}\) correspond to the assignment'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：** **（继续）** 继续上面的例子，簇 \(C_1 = \{1, 4, 6, 8\}, C_2 = \{2, 3, 7\}, C_3 =
    \{5\}\) 对应的分配为'
- en: \[ c(1) = 1, c(2) = 2, c(3) = 2, c(4) = 1, c(5) = 3, c(6) = 1, c(7) = (2), c(8)
    = 1\. \]
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: \[ c(1) = 1, c(2) = 2, c(3) = 2, c(4) = 1, c(5) = 3, c(6) = 1, c(7) = (2), c(8)
    = 1\. \]
- en: \(\lhd\)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: \(\lhd\)
- en: '**LEMMA** **(Optimal Clustering)** \(\idx{optimal clustering lemma}\xdi\) Fix
    the representatives \(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k\). An optimal
    partition under the objective'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**引理** **（最优聚类）** \(\idx{optimal clustering lemma}\xdi\) 固定代表 \(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k\)。在目标函数下找到一个最优划分'
- en: \[ G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k) = \sum_{i=1}^k
    \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2, \]
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: \[ G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k) = \sum_{i=1}^k
    \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2, \]
- en: is obtained as follows. For each \(j\), find the \(\boldsymbol{\mu}_i\) that
    minimizes \(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|\) (picking one arbitrarily in
    the case of ties) and assign \(\mathbf{x}_j\) to \(C_i\) (i.e., add \(j\) to \(C_i\)).
    \(\flat\)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如下获得。对于每个 \(j\)，找到使 \(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|\) 最小的 \(\boldsymbol{\mu}_i\)（在存在平局的情况下任意选择一个）并将
    \(\mathbf{x}_j\) 分配给 \(C_i\)（即，将 \(j\) 添加到 \(C_i\)）。\(\flat\)
- en: '*Proof:* If \(c\) is the cluster assignment associated to \(C_1,\ldots,C_k\),
    then we can re-write the objective as'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明：* 如果 \(c\) 是与 \(C_1,\ldots,C_k\) 相关的簇分配，那么我们可以将目标函数重新写为'
- en: \[ \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2 = \sum_{j=1}^n
    \|\mathbf{x}_j - \boldsymbol{\mu}_{c(j)}\|^2, \]
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2 = \sum_{j=1}^n
    \|\mathbf{x}_j - \boldsymbol{\mu}_{c(j)}\|^2, \]
- en: By definition, when the \(\boldsymbol{\mu}_i\)’s are fixed, each term in the
    sum on the right-hand side is minimized separately by the assignment in the statement.
    Hence so is the sum itself by the *Optimizing a Separable Function Lemma*. Note
    that we used the fact that the square root (and the square) is non-decreasing
    to conclude that minimizing \(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2\) or its
    square root \(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|\) are equivalent by the *Composing
    with a Non-Decreasing Function Lemma*. \(\square\)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，当 \(\boldsymbol{\mu}_i\) 固定时，右侧求和中的每一项都通过陈述中的分配单独最小化。因此，根据 *可分离函数优化引理*，总和本身也最小化。注意，我们使用了平方根（以及平方）是非递减的事实，根据
    *与一个非递减函数组合引理*，得出最小化 \(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2\) 或其平方根 \(\|\mathbf{x}_j
    - \boldsymbol{\mu}_i\|\) 是等价的。\(\square\)
- en: '**EXAMPLE:** **(continued)** Continuing the example above, suppose that we
    choose representatives'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：** **（继续）** 继续上面的例子，假设我们选择了代表'
- en: \[\begin{split} \boldsymbol{\mu}_1 = \begin{pmatrix}-2\\1\end{pmatrix}, \boldsymbol{\mu}_2
    = \begin{pmatrix}2\\-1\end{pmatrix}, \boldsymbol{\mu}_3 = \begin{pmatrix}-10\\10\end{pmatrix}.
    \end{split}\]
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} \boldsymbol{\mu}_1 = \begin{pmatrix}-2\\1\end{pmatrix}, \boldsymbol{\mu}_2
    = \begin{pmatrix}2\\-1\end{pmatrix}, \boldsymbol{\mu}_3 = \begin{pmatrix}-10\\10\end{pmatrix}.
    \end{split}\]
- en: 'Then we find the cluster assignment of \(\mathbf{x}_1\) by computing its squared
    distance to each representative:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过计算 \(\mathbf{x}_1\) 与每个代表之间的平方距离来找到其簇分配：
- en: \[\begin{split} \|\mathbf{x}_1 - \boldsymbol{\mu}_1\| = \left\|\begin{pmatrix}1\\0\end{pmatrix}
    - \begin{pmatrix}-2\\1\end{pmatrix}\right\| = \sqrt{(1-(-2))^2 + (0-1)^2} = \sqrt{10},
    \end{split}\]\[\begin{split} \|\mathbf{x}_1 - \boldsymbol{\mu}_2\| = \left\|\begin{pmatrix}1\\0\end{pmatrix}
    - \begin{pmatrix}2\\-1\end{pmatrix}\right\| = \sqrt{(1-2)^2 + (0-(-1))^2} = \sqrt{2},
    \end{split}\]\[\begin{split} \|\mathbf{x}_1 - \boldsymbol{\mu}_3\| = \left\|\begin{pmatrix}1\\0\end{pmatrix}
    - \begin{pmatrix}-10\\10\end{pmatrix}\right\| = \sqrt{(1-(-10))^2 + (0-10)^2}
    = \sqrt{221}. \end{split}\]
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} \|\mathbf{x}_1 - \boldsymbol{\mu}_1\| = \left\|\begin{pmatrix}1\\0\end{pmatrix}
    - \begin{pmatrix}-2\\1\end{pmatrix}\right\| = \sqrt{(1-(-2))^2 + (0-1)^2} = \sqrt{10},
    \end{split}\]\[\begin{split} \|\mathbf{x}_1 - \boldsymbol{\mu}_2\| = \left\|\begin{pmatrix}1\\0\end{pmatrix}
    - \begin{pmatrix}2\\-1\end{pmatrix}\right\| = \sqrt{(1-2)^2 + (0-(-1))^2} = \sqrt{2},
    \end{split}\]\[\begin{split} \|\mathbf{x}_1 - \boldsymbol{\mu}_3\| = \left\|\begin{pmatrix}1\\0\end{pmatrix}
    - \begin{pmatrix}-10\\10\end{pmatrix}\right\| = \sqrt{(1-(-10))^2 + (0-10)^2}
    = \sqrt{221}. \end{split}\]
- en: The minimum is achieved for \(\boldsymbol{\mu}_2\) so we assign \(\mathbf{x}_1\)
    to \(C_2\), i.e., \(1 \in C_2\) and \(c(1) = 2\). \(\lhd\)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值是在 \(\boldsymbol{\mu}_2\) 处实现的，因此我们将 \(\mathbf{x}_1\) 分配给 \(C_2\)，即 \(1 \in
    C_2\) 且 \(c(1) = 2\)。\(\lhd\)
- en: 1.3.2\. Lloyd’s algorithm and its analysis[#](#lloyds-algorithm-and-its-analysis
    "Link to this heading")
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3.2. Lloyd算法及其分析[#](#lloyds-algorithm-and-its-analysis "链接到这个标题")
- en: We are now ready to describe Lloyd’s algorithm\(\idx{Lloyd's algorithm}\xdi\).
    We start from a random assignment of clusters. (An alternative [initialization
    strategy](https://en.wikipedia.org/wiki/K-means_clustering#Initialization_methods)
    is to choose \(k\) representatives at random among the data points.) We then alternate
    between the optimal choices in the lemmas. In lieu of pseudo-code, we write out
    the algorithm in Python. We will use this approach throughout the book.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备描述 Lloyd 算法\(\idx{Lloyd's algorithm}\xdi\)。我们从随机分配的簇开始。 (另一种 [初始化策略](https://en.wikipedia.org/wiki/K-means_clustering#Initialization_methods)
    是在数据点中随机选择 \(k\) 个代表。) 然后，我们在引理中的最优选择之间交替。代替伪代码，我们用 Python 写出算法。我们将在整个书中使用这种方法。
- en: The input `X` is assumed to be a collection of \(n\) vectors \(\mathbf{x}_1,
    \ldots, \mathbf{x}_n \in \mathbb{R}^d\) stacked into a matrix, with one row for
    each data point. The other input, `k`, is the desired number of clusters. There
    is an optional input `maxiter` for the maximum number of iterations, which is
    set to \(5\) by default.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `X` 假设是一组 \(n\) 个向量 \(\mathbf{x}_1, \ldots, \mathbf{x}_n \in \mathbb{R}^d\)，堆叠成一个矩阵，每行一个数据点。另一个输入
    `k` 是期望的簇数。有一个可选输入 `maxiter` 用于最大迭代次数，默认设置为 \(5\)。
- en: We first define separate functions for the two main steps. To find the minimum
    of an array, we use the function [`numpy.argmin`](https://numpy.org/doc/stable/reference/generated/numpy.argmin.html).
    We also use [`numpy.linalg.norm`](https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.html)
    to compute the Euclidean distance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为两个主要步骤定义了单独的函数。为了找到数组的最小值，我们使用函数 `numpy.argmin`。我们还使用 `numpy.linalg.norm`
    来计算欧几里得距离。
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The main function follows. Below, `rng.integers(0,k,n)` is an array of `n` uniformly
    chosen integers between `0` and `k-1` (inclusive). See [random.Generator.integers](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.integers.html)
    for details. Recall that throughout, when defining a function that uses a random
    number generator (RNG), we initialize the RNG outside the function and pass the
    RNG to it. It allows us to maintain control over the random number generation
    process at a higher level and ensures consistent results across multiple runs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 主要函数如下。下面，`rng.integers(0,k,n)` 是一个包含 `n` 个在 `0` 和 `k-1` 之间（包括两端）均匀选择的整数的数组。有关详细信息，请参阅
    [random.Generator.integers](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.integers.html)。回想一下，在整个过程中，当定义一个使用随机数生成器
    (RNG) 的函数时，我们将在函数外部初始化 RNG 并将其传递给它。这允许我们在更高层次上控制随机数生成过程，并确保多次运行的结果一致。
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**NUMERICAL CORNER:** We apply our implementation of \(k\)-means to the example
    above. We fix `k` to \(3\). Here the data matrix `X` is the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**数值角**: 我们将我们的 \(k\)-means 实现应用于上面的例子。我们将 `k` 固定为 \(3\)。在这里，数据矩阵 `X` 如下所示：'
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We vizualize the output by coloring the points according to their cluster assignment.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过根据它们的簇分配给点着色来可视化输出。
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![../../_images/cde50ddf06949815c7068a094c7184fa364e644fe65b83769400c3925c47ee23.png](../Images/27a0e5cd18c1654cf2e8093cd3d127f6.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/cde50ddf06949815c7068a094c7184fa364e644fe65b83769400c3925c47ee23.png](../Images/27a0e5cd18c1654cf2e8093cd3d127f6.png)'
- en: We can compute the final representatives (optimal for the final assignment)
    by using the subroutine `opt_reps`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用子例程 `opt_reps` 来计算最终的代表（对于最终分配是最优的）。
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each row is the center of the corresponding cluster. Note these match with the
    ones we previously computed. Indeed, the clustering is the same (although not
    necessarily in the same order).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行是对应聚类的中心。注意这些与之前计算出的相匹配。确实，聚类是相同的（尽管不一定按相同的顺序）。
- en: '**TRY IT!** Modify `kmeans` to take a tolerance `tol` as input and stop when
    the improvement in objective value `G` falls below the tolerance. ([Open in Colab](https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_intro_notebook.ipynb))'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下！**修改 `kmeans` 以接受一个容差 `tol` 作为输入，并在目标值 `G` 的改进低于容差时停止。([在Colab中打开](https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_intro_notebook.ipynb))'
- en: \(\unlhd\)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: \(\unlhd\)
- en: '![Evolution of the assignment for -means clustering on data generated by a
    mixture of spherical Gaussians with variance  and respective means  and . The
    crosses show the cluster representatives. The objective value is shown as . (With
    help from Claude; inspired by (Source).)](../Images/2c9ccfca527fcd49962e30d8a67f4fdb.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![由具有方差和相应均值  和  的球状高斯混合生成的数据上的-means 聚类任务演变。十字表示聚类代表。目标值显示为 。（得益于Claude的帮助；灵感来源于（来源））](../Images/2c9ccfca527fcd49962e30d8a67f4fdb.png)'
- en: '**KNOWLEDGE CHECK:** Suppose we have infinite computational resources and run
    Lloyd’s algorithm forever, do you think it will necessarily converge to a global
    minimum? If your answer is no, can you think of an alternative algorithm that
    is guaranteed to output a global minimum provided enough computational resources?
    \(\checkmark\)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**知识检查**：假设我们有无限的计算资源并且无限期地运行Lloyd算法，你认为它一定会收敛到全局最小值吗？如果你的答案是“不”，你能想到一个算法，该算法在足够的计算资源下保证输出全局最小值？\(\checkmark\)'
- en: Lloyd’s algorithm is only a heuristic. In particular, it is not guaranteed to
    find the global minimum of the \(k\)-means objective. However, it is guaranteed
    to improve the objective at every iteration, or more precisely, not to make it
    worse.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Lloyd算法只是一个启发式算法。特别是，它不能保证找到 \(k\)-means 目标的全局最小值。然而，它保证在每次迭代中改进目标值，或者更精确地说，不会使其变得更差。
- en: '**THEOREM** **(Convergence of \(k\)-means cost)** \(\idx{convergence of k-means
    cost theorem}\xdi\) The sequence of objective function values produced by the
    \(k\)-means algorithm is non-increasing. \(\sharp\)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**定理** **(k-means 成本收敛)** \(\idx{convergence of k-means cost theorem}\xdi\)
    \(k\)-means算法产生的目标函数值序列是非递增的。\(\sharp\)'
- en: '*Proof idea:* By the *Optimal Representatives Lemma* and the *Optimal Clustering
    Lemma*, each step does not increase the objective.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明思路*：根据**最优代表引理**和**最优聚类引理**，每一步都不会增加目标值。'
- en: '*Proof:* Let \(C_1'',\ldots,C_k''\) be the current clusters, with representatives
    \(\boldsymbol{\mu}_1'',\ldots,\boldsymbol{\mu}_k''\). After Step 1, the new representatives
    are \(\boldsymbol{\mu}_1'''',\ldots,\boldsymbol{\mu}_k''''\). By the *Optimal
    Representatives Lemma*, they satisfy'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明*：设 \(C_1'',\ldots,C_k''\) 是当前的聚类，其代表为 \(\boldsymbol{\mu}_1'',\ldots,\boldsymbol{\mu}_k''\)。在步骤1之后，新的代表是
    \(\boldsymbol{\mu}_1'''',\ldots,\boldsymbol{\mu}_k''''\)。根据**最优代表引理**，它们满足'
- en: \[ \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
    \leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i'\|^2.
    \]
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
    \leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i'\|^2.
    \]
- en: After Step 2, the new clusters are \(C_1'',\ldots,C_k''\). By the *Optimal Clustering
    Lemma*, they satisfy
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2之后，新的聚类是 \(C_1'',\ldots,C_k''\)。根据**最优聚类引理**，它们满足
- en: \[ \sum_{i=1}^k \sum_{j \in C_i''} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
    \leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2.
    \]
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \sum_{i=1}^k \sum_{j \in C_i''} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
    \leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2.
    \]
- en: Combining these two inequalities gives
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这两个不等式得到
- en: \[ \sum_{i=1}^k \sum_{j \in C_i''} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
    \leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i'\|^2,
    \]
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \sum_{i=1}^k \sum_{j \in C_i''} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
    \leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i'\|^2,
    \]
- en: as claimed. \(\square\)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期所示。\(\square\)
- en: The sequence of objective values is monotone and bounded from below by \(0\).
    [Hence it converges](https://en.wikipedia.org/wiki/Monotone_convergence_theorem#Convergence_of_a_monotone_sequence_of_real_numbers).
    Note that the limit depends on the starting point.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 目标值的序列是单调的，并且从下方由\(0\)界定。[因此它收敛](https://en.wikipedia.org/wiki/Monotone_convergence_theorem#Convergence_of_a_monotone_sequence_of_real_numbers)。请注意，极限取决于起点。
- en: '**CHAT & LEARN** AI chatbots can serve as great personal tutors, especially
    when it comes to coding which they often excel at. In particular, they can provide
    additional information about the code in this book. Just copy-paste a piece of
    code and ask “What is this code doing?” Don’t hesitate to ask follow-up questions.
    [Here is an example using ChatGPT](https://chat.openai.com/share/66f9e704-c8e8-4489-9ab6-8e57740cab3b).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**CHAT & LEARN** AI聊天机器人可以成为优秀的个人导师，尤其是在编程方面，他们通常表现出色。特别是，他们可以提供关于本书中代码的额外信息。只需复制粘贴一段代码，然后问“这段代码在做什么？”不要犹豫，继续提问。[这里是一个使用ChatGPT的例子](https://chat.openai.com/share/66f9e704-c8e8-4489-9ab6-8e57740cab3b)。'
- en: '*Warning:* As you probably know, AI chatbots can be wrong so assess what they
    tell you with a critical mind and/or double-check with other sources (e.g., package
    documentation).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：正如你可能知道的，AI聊天机器人可能会出错，所以用批判性的思维评估他们告诉你的内容，并/或其他来源（例如，包文档）进行双重检查。'
- en: '*Prompt engineering:* [Finding the right prompt](https://en.wikipedia.org/wiki/Prompt_engineering),
    or series of prompts, can make a big difference. It can also be used to produce
    more interesting answers. Here is an explanation of the \(k\)-means algorithm
    in the style of Shakespeare via ChatGPT:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示工程**：[找到正确的提示](https://en.wikipedia.org/wiki/Prompt_engineering)，或一系列提示，可以产生重大影响。它也可以用来产生更有趣的答案。以下是通过ChatGPT用莎士比亚风格解释\(k\)-均值算法的例子：'
- en: '**Scene: The Realm of Numerica, in the Enchanted Forest of Analysis**'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**场景：数值领域，在分析的魔法森林**'
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Enter LORD VECTOR, LADY PARTITION, and an assembly of WHISPERING WINDS*'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**进入向量大人，划分女士，以及一群低语的风**。'
- en: ''
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LORD VECTOR (a majestic entity):'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**向量大人（一个庄严的存在）**：'
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hearken, Whispering Winds, scattered far and wide,
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 倾听，低语的风，散布得远远的，
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I am Lord Vector, your anchor and your guide.
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我是向量大人，你的锚和你的向导。
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In clusters, you must settle, by my call and by my side,
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在簇中，你必须听从我的召唤，站在我的身边，
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To me, you’ll draw nigh, in unity, abide.
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你将靠近我，在统一中停留。
- en: ''
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LADY PARTITION (a sage enchantress):'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**划分女士（一位睿智的女巫）**：'
- en: ''
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And I, Lady Partition, with vision clear and keen,
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我，划分女士，有着清晰敏锐的视野，
- en: ''
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Determine where amongst the clusters each of you shall lean.
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确定你们每个人将在哪个簇中倾斜。
- en: ''
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With Lord Vector, a ballet we compose, with steps so fine,
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与向量大人一起，我们编排一场芭蕾，舞步如此精致，
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To sort, to gather, to align, under a sign divine.
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 分类，聚集，对齐，在神圣的标志下。
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'WHISPERING WIND 1:'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**第一低语风**：'
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: But how, noble Vector, wilt thou find thy rightful stead?
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但是，高贵的向量大人，你将如何找到你的正确位置？
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this expanse diverse, how set thy bed?
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这片多样化的空间，你如何安放你的床？
- en: ''
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LORD VECTOR:'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**向量大人**：'
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Through cycles and through wisdom, I seek my sacred ground,
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过循环和智慧，我寻求我的神圣之地，
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Where the sum of all distances to me is least found.
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在我这里所有距离之和最少的地点。
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From your essence, I emerge, an average pure and sound,
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从你的本质中，我浮现，一个平均纯粹而响亮，
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A beacon most true, by which I am crowned.
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一座最真实的光标，我以此加冕。
- en: ''
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'WHISPERING WIND 2:'
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**第二低语风**：'
- en: ''
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And Lady Partition, how do we seek our kin,
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们如何寻找我们的亲人，划分女士，
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this multitude, how does our journey begin?
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这众多之中，我们的旅程如何开始？
- en: ''
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LADY PARTITION:'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**划分女士**：'
- en: ''
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By measure and affinity, to your closest Lord Vector, you’ll gravitate,
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过度量亲和力，你会向最近的向量大人靠近，
- en: ''
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To him, your allegiance, you’ll consecrate.
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对他，你的忠诚，你将奉献。
- en: ''
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In groups, you’ll assemble, by likeness you’re drawn,
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在群体中，你会聚集，因为相似而吸引，
- en: ''
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A collective symphony, from dusk till dawn.
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一场集体交响乐，从黄昏到黎明。
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*LORD VECTOR and LADY PARTITION assume their roles, guiding the WHISPERING
    WINDS to move and regroup.*'
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**向量大人和划分女士扮演他们的角色，引导低语的风们移动和重组**。'
- en: ''
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LORD VECTOR:'
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**向量大人**：'
- en: ''
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe now how I traverse, as your allegiances refine,
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在观察我是如何穿越的，随着你的忠诚变得更加精细，
- en: ''
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A center more apt, in this spell of mine.
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在我的咒语中，一个更合适的中心。
- en: ''
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LADY PARTITION:'
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**划分女士**：'
- en: ''
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And as you drift, dear winds, to your Lords true,
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你飘荡，亲爱的风，到你真正的领主那里，
- en: ''
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A closer union we construe, a balance anew.
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们构建一个更紧密的联盟，一种新的平衡。
- en: ''
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The WHISPERING WINDS shuffle and align, moving from one cluster to another,
    as LORD VECTOR adjusts his position with grace.*'
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**低语的风们重新排列并对齐，从一个簇移动到另一个簇，随着向量大人优雅地调整他的位置**。'
- en: ''
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'WHISPERING WIND 3:'
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**第三低语风**：'
- en: ''
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At length, I perceive, where I am to dwell,
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，我看到了我将居住的地方，
- en: ''
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With peers akin, in cluster well.
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与同伴相似，在良好的聚类中。
- en: ''
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LORD VECTOR:'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: LORD VECTOR：
- en: ''
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So we dance and weave, ‘til stillness we achieve,
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，我们跳舞和编织，直到达到静止，
- en: ''
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When each wind has settled, and we, in relief.
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当每一阵风都平息下来，我们如释重负。
- en: ''
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LADY PARTITION:'
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: LADY PARTITION：
- en: ''
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Thus, optimal clusters come forth, vivid and serene,
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，最优的聚类出现，生动而宁静，
- en: ''
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With centers well placed, a sight unseen.
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 中心位置良好，景象难见。
- en: ''
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The WHISPERING WINDS now rest peacefully in clusters around their LORD VECTORS,
    the Enchanted Forest of Analysis a testament to their orderly ballet.*'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*低语的风现在在他们的主向量周围平静地休息在聚类中，分析的魔法森林是他们对有序芭蕾的见证。*'
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LORD VECTOR & LADY PARTITION (together):'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: LORD VECTOR & LADY PARTITION（一起）：
- en: ''
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Our task here concludes, with harmony and grace,
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们的任务在这里结束，和谐而优雅，
- en: ''
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The K-means enchantment, a solution embraced.
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: K-means 神奇效果，一个受欢迎的解决方案。
- en: ''
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Exeunt omnes, as the WHISPERING WINDS repose in unity around their LORD VECTORS,
    the realm of Numerica reflecting their harmonious dance.*'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*所有人退出，随着低语的风在他们的主向量周围统一，数字领域的反映他们和谐的舞蹈。*'
- en: ''
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**End of Scene**'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**场景结束**'
- en: \(\ddagger\)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: \(\ddagger\)
- en: '**NUMERICAL CORNER:** We will test our implementation of \(k\)-means on the
    penguins dataset introduced earlier in the chapter. We first extract the columns
    and combine them into a data matrix `X`. As we did previously, we also remove
    the rows with missing values.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**数值角落：** 我们将在本章前面介绍的企鹅数据集上测试我们的 \(k\)-means 实现。我们首先提取列并将它们组合成一个数据矩阵 `X`。像之前一样，我们也移除了有缺失值的行。'
- en: '**Figure:** Which penguin species? (*Credit:* Made with [Midjourney](https://www.midjourney.com/))'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**图：** 哪种企鹅物种？(*来源：[Midjourney](https://www.midjourney.com/))'
- en: '![Penguins on a glacier](../Images/bb7e8602c95a01b1185de572b4c55ec8.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![冰川上的企鹅](../Images/bb7e8602c95a01b1185de572b4c55ec8.png)'
- en: \(\bowtie\)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: \(\bowtie\)
- en: '[PRE9]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We visualize a two-dimensional slice of the data.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可视化了数据的二维切片。
- en: '[PRE10]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![../../_images/024d26811e4631ac8dcb5acb1d23f5c577193d3217b2493260af97e706f2b329.png](../Images/e75683392ec1e758370886f76273bfb6.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/024d26811e4631ac8dcb5acb1d23f5c577193d3217b2493260af97e706f2b329.png](../Images/e75683392ec1e758370886f76273bfb6.png)'
- en: Observe that the features have quite different scales (tens versus thousands
    in the plot above). In such a case, it is common to standardize the data so that
    each feature has roughly the same scale. For each column of `X`, we subtract its
    empirical mean and divide by its empirical standard deviation.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到特征具有相当不同的尺度（上图中的十与千）。在这种情况下，通常会对数据进行标准化，以便每个特征大致具有相同的尺度。对于 `X` 的每一列，我们减去其实验均值，然后除以其实验标准差。
- en: '[PRE11]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we run Lloyd’s algorithm with \(k=2\) clusters.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用 \(k=2\) 个聚类运行 Lloyd 算法。
- en: '[PRE12]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We vizualize the output as we did before, but this time coloring the data points
    by their cluster assignment.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像之前一样可视化输出，但这次根据它们的聚类分配给数据点着色。
- en: '[PRE14]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![../../_images/c8ce542a010e33ab2c018c7c7624c391c5b57fa97d97a1146013f2c8d77068de.png](../Images/828f36ddad8cd4ead1a7000754909d59.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/c8ce542a010e33ab2c018c7c7624c391c5b57fa97d97a1146013f2c8d77068de.png](../Images/828f36ddad8cd4ead1a7000754909d59.png)'
- en: 'This clustering looks quite good. Nevertheless recall that:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这种聚类看起来相当好。尽管如此，请记住：
- en: in this plot we are looking at only two of the four variables while \(k\)-means
    uses all of them,
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个图中，我们只查看四个变量中的两个，而 \(k\)-means 使用了所有这些变量，
- en: we are not guaranteed to find the best solution,
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能保证找到最佳解决方案，
- en: our objective function is somewhat arbitrary, and
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的目标函数有些任意，并且
- en: it is not clear what the right choice of \(k\) is.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不清楚 \(k\) 的正确选择是什么。
- en: In fact, the original dataset contained the correct answer, as provided by biologists.
    Despite what the figure above may lead us to believe, there are in reality three
    separate species. So let us try with \(k=3\) clusters.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，原始数据集包含了生物学家提供的正确答案。尽管上图可能让我们相信，实际上有三个不同的物种。所以让我们尝试 \(k=3\) 个聚类。
- en: '[PRE15]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The output does not seem quite right.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来并不完全正确。
- en: '[PRE17]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![../../_images/7383cabd085a8a7eba9545c89a27d27d31401b0dc50cd001fbe5cfc405e9131c.png](../Images/0cf53aabbe4e2f47806ce1ae1b6cde65.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/7383cabd085a8a7eba9545c89a27d27d31401b0dc50cd001fbe5cfc405e9131c.png](../Images/0cf53aabbe4e2f47806ce1ae1b6cde65.png)'
- en: But, remembering the warnings mentioned previously, let us look at a different
    two-dimensional slice.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，记住之前提到的警告，让我们看看不同的二维切片。
- en: '[PRE18]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![../../_images/62dde40d80824421548718832e220f969d2f9a28a560918552424440517b225e.png](../Images/9702034e7031f67493cefa19852b584d.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/62dde40d80824421548718832e220f969d2f9a28a560918552424440517b225e.png](../Images/9702034e7031f67493cefa19852b584d.png)'
- en: Let us load up the truth and compare. We only keep those samples that were not
    removed because of missing values (see [`pandas.DataFrame.iloc`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html)).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加载真实数据并进行比较。我们只保留那些没有因为缺失值而被移除的样本（参见 [pandas.DataFrame.iloc](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html)）。
- en: '[PRE19]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|  | species |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|  | 物种 |'
- en: '| --- | --- |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | Adelie |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 0 | Adelie |'
- en: '| 1 | Adelie |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Adelie |'
- en: '| 2 | Adelie |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Adelie |'
- en: '| 4 | Adelie |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Adelie |'
- en: '| 5 | Adelie |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 5 | Adelie |'
- en: 'The species are:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 物种如下：
- en: '[PRE20]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To plot the outcome, we color the species blue-green-red using a [dictionary](https://docs.python.org/3/tutorial/datastructures.html#dictionaries).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制结果，我们使用 [字典](https://docs.python.org/3/tutorial/datastructures.html#dictionaries)
    将物种颜色设置为蓝绿色-红色。
- en: '[PRE22]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, we can compare the output to the truth. The match is quite good – but
    certainly not perfect.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将输出与真实数据进行比较。匹配度相当好——但当然不是完美的。
- en: '[PRE23]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![../../_images/00f2abf0740c5bf6a562d8f607ab3a6d116d7ba0e1b03f9e035f875e36954e86.png](../Images/1de9d394fa9649dc467bc539e8b0de94.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/00f2abf0740c5bf6a562d8f607ab3a6d116d7ba0e1b03f9e035f875e36954e86.png](../Images/1de9d394fa9649dc467bc539e8b0de94.png)'
- en: 'Determining the appropriate number of clusters is not a straighforward problem.
    To quote [Wikipedia](https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 确定合适的聚类数量不是一个简单的问题。引用 [维基百科](https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set)：
- en: The correct choice of \(k\) is often ambiguous, with interpretations depending
    on the shape and scale of the distribution of points in a data set and the desired
    clustering resolution of the user. In addition, increasing \(k\) without penalty
    will always reduce the amount of error in the resulting clustering, to the extreme
    case of zero error if each data point is considered its own cluster (i.e., when
    \(k\) equals the number of data points, \(n\)). Intuitively then, the optimal
    choice of \(k\) will strike a balance between maximum compression of the data
    using a single cluster, and maximum accuracy by assigning each data point to its
    own cluster. If an appropriate value of \(k\) is not apparent from prior knowledge
    of the properties of the data set, it must be chosen somehow. There are several
    categories of methods for making this decision.
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正确选择 \(k\) 常常是模糊的，其解释取决于数据集中点的形状和尺度以及用户期望的聚类分辨率。此外，不进行惩罚地增加 \(k\) 将始终减少结果聚类的错误量，在极端情况下，如果每个数据点被视为自己的聚类（即当
    \(k\) 等于数据点的数量 \(n\) 时），错误量将降至零。因此，从数据集的性质的先验知识中不明显地选择 \(k\) 的最佳值时，必须以某种方式选择。有几种方法类别用于做出这个决定。
- en: In practice, [several heuristics](https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set)
    are in use. Other approaches to clustering, e.g. [DBSCAN](https://en.wikipedia.org/wiki/DBSCAN)
    and [hierarchical clustering](https://en.wikipedia.org/wiki/Hierarchical_clustering),
    do not require a number of clusters as input.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，[几种启发式方法](https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set)正在使用。其他聚类方法，例如
    [DBSCAN](https://en.wikipedia.org/wiki/DBSCAN) 和 [层次聚类](https://en.wikipedia.org/wiki/Hierarchical_clustering)，不需要输入聚类数量。
- en: '**TRY IT!** Run the analysis again, but this time *without the standardization
    step*. What do you observe? Is one feature more influential on the final output
    than the others? Why do you think that is? ([Open in Colab](https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_intro_notebook.ipynb))'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**TRY IT!** 再次运行分析，但这次 *不进行标准化步骤*。你观察到了什么？是否有某个特征比其他特征对最终输出更有影响？你为什么这么认为？([在
    Colab 中打开](https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_intro_notebook.ipynb))'
- en: \(\unlhd\)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: \(\unlhd\)
- en: 1.3.3\. Matrix form of k-means clustering[#](#matrix-form-of-k-means-clustering
    "Link to this heading")
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3.3\. k-means 聚类的矩阵形式[#](#matrix-form-of-k-means-clustering "链接到本标题")
- en: In this section, we show that the \(k\)-means clustering objective can be written
    in matrix form. We start with some notation and definitions that will be useful
    throughout.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示 \(k\)-means 聚类目标可以写成矩阵形式。我们首先介绍一些在整个过程中将非常有用的符号和定义。
- en: As we indicated before, for a collection of \(n\) data vectors \(\mathbf{x}_1,
    \ldots, \mathbf{x}_n\) in \(\mathbb{R}^d\), it is often convenient to stack them
    up into a matrix
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，对于 \(\mathbb{R}^d\) 中的 \(n\) 个数据向量 \(\mathbf{x}_1, \ldots, \mathbf{x}_n\)，将它们堆叠成一个矩阵通常很方便。
- en: \[\begin{split} X = \begin{bmatrix} \mathbf{x}_1^T \\ \mathbf{x}_2^T \\ \vdots
    \\ \mathbf{x}_n^T \\ \end{bmatrix} = \begin{bmatrix} x_{11} & x_{12} & \cdots
    & x_{1d} \\ x_{21} & x_{22} & \cdots & x_{2d} \\ \vdots & \vdots & \ddots & \vdots
    \\ x_{n1} & x_{n2} & \cdots & x_{nd} \\ \end{bmatrix}. \end{split}\]
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} X = \begin{bmatrix} \mathbf{x}_1^T \\ \mathbf{x}_2^T \\ \vdots
    \\ \mathbf{x}_n^T \\ \end{bmatrix} = \begin{bmatrix} x_{11} & x_{12} & \cdots
    & x_{1d} \\ x_{21} & x_{22} & \cdots & x_{2d} \\ \vdots & \vdots & \ddots & \vdots
    \\ x_{n1} & x_{n2} & \cdots & x_{nd} \\ \end{bmatrix}. \end{split}\]
- en: We can do the same with cluster representatives. Given \(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k\)
    also in \(\mathbb{R}^d\), we form the matrix
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用同样的方法处理簇代表。给定 \(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k\) 也位于 \(\mathbb{R}^d\)
    中，我们形成矩阵
- en: \[\begin{split} U = \begin{bmatrix} \boldsymbol{\mu}_1^T \\ \boldsymbol{\mu}_2^T
    \\ \vdots \\ \boldsymbol{\mu}_k^T \\ \end{bmatrix} = \begin{bmatrix} \mu_{11}
    & \mu_{12} & \cdots & \mu_{1d} \\ \mu_{21} & \mu_{22} & \cdots & \mu_{2d} \\ \vdots
    & \vdots & \ddots & \vdots \\ \mu_{k1} & \mu_{k2} & \cdots & \mu_{kd} \\ \end{bmatrix}.
    \end{split}\]
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} U = \begin{bmatrix} \boldsymbol{\mu}_1^T \\ \boldsymbol{\mu}_2^T
    \\ \vdots \\ \boldsymbol{\mu}_k^T \\ \end{bmatrix} = \begin{bmatrix} \mu_{11}
    & \mu_{12} & \cdots & \mu_{1d} \\ \mu_{21} & \mu_{22} & \cdots & \mu_{2d} \\ \vdots
    & \vdots & \ddots & \vdots \\ \mu_{k1} & \mu_{k2} & \cdots & \mu_{kd} \\ \end{bmatrix}.
    \end{split}\]
- en: Perhaps less obviously, cluster assignments can also be encoded in matrix form.
    Recall that, given a partition \(C_1,\ldots,C_k\) of \([n]\), we define \(c(j)
    = i\) if \(j \in C_i\). For \(j=1,\ldots,n\) and \(\ell=1,\ldots,k\), set \(Z_{j\ell}
    = 1\) if \(c(j) = \ell\) and \(0\) otherwise, and let \(Z\) be the \(n \times
    k\) matrix with entries \(Z = [Z_{j\ell}]_{j,\ell}\). That is, row \(j\) has exactly
    one entry with value \(1\), corresponding to the assigned cluster \(c(j)\) of
    data point \(\mathbf{x}_j\), and all other entries \(0\).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 也许不那么明显的是，簇分配也可以用矩阵形式表示。回想一下，给定 \([n]\) 的划分 \(C_1,\ldots,C_k\)，我们定义 \(c(j) =
    i\) 如果 \(j \in C_i\)。对于 \(j=1,\ldots,n\) 和 \(\ell=1,\ldots,k\)，如果 \(c(j) = \ell\)
    则设置 \(Z_{j\ell} = 1\)，否则为 \(0\)，并让 \(Z\) 是一个 \(n \times k\) 的矩阵，其元素 \(Z = [Z_{j\ell}]_{j,\ell}\)。也就是说，行
    \(j\) 有且仅有一个值为 \(1\) 的元素，对应于数据点 \(\mathbf{x}_j\) 分配的簇 \(c(j)\)，其他所有元素为 \(0\)。
- en: With this notation, the representative of the cluster assigned to data point
    \(\mathbf{x}_j\) is obtained through a matrix product
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个记号，数据点 \(\mathbf{x}_j\) 分配的簇的代表通过矩阵乘积得到
- en: \[ \boldsymbol{\mu}_{c(j)}^T = \sum_{\ell = 1}^k Z_{j\ell} \boldsymbol{\mu}_{\ell}^T
    = \sum_{\ell = 1}^k Z_{j\ell} U_{\ell,\cdot} = \left(Z U\right)_{j,\cdot} \]
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \boldsymbol{\mu}_{c(j)}^T = \sum_{\ell = 1}^k Z_{j\ell} \boldsymbol{\mu}_{\ell}^T
    = \sum_{\ell = 1}^k Z_{j\ell} U_{\ell,\cdot} = \left(Z U\right)_{j,\cdot} \]
- en: where we used that the \(j\)-th row of a matrix product is a linear combination
    of the rows of the second matrix, where the coefficients are the entries on the
    \(j\)-th row of the first one.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 其中我们使用了矩阵乘积的第 \(j\) 行是第二个矩阵行的线性组合的性质，其中系数是第一个矩阵第 \(j\) 行的元素。
- en: '**EXAMPLE:** **(continued)** Continuing with our previous example, the clusters
    \(C_1 = \{1, 4, 6, 8\}, C_2 = \{2, 3, 7\}, C_3 = \{5\}\) are encoded as the matrix'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**EXAMPLE:** **(continued)** 继续我们之前的例子，簇 \(C_1 = \{1, 4, 6, 8\}, C_2 = \{2,
    3, 7\}, C_3 = \{5\}\) 被编码为矩阵'
- en: \[\begin{split} Z = \begin{bmatrix} 1 & 0 & 0\\ 0 & 1 & 0\\ 0 & 1 & 0\\ 1 &
    0 & 0\\ 0 & 0 & 1\\ 1 & 0 & 0\\ 0 & 1 & 0\\ 1 & 0 & 0 \end{bmatrix}. \end{split}\]
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} Z = \begin{bmatrix} 1 & 0 & 0\\ 0 & 1 & 0\\ 0 & 1 & 0\\ 1 &
    0 & 0\\ 0 & 0 & 1\\ 1 & 0 & 0\\ 0 & 1 & 0\\ 1 & 0 & 0 \end{bmatrix}. \end{split}\]
- en: Suppose again that the representatives are
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 假设再次，代表是
- en: \[\begin{split} \boldsymbol{\mu}_1 = \begin{pmatrix}-2\\1\end{pmatrix}, \boldsymbol{\mu}_2
    = \begin{pmatrix}2\\-1\end{pmatrix}, \boldsymbol{\mu}_3 = \begin{pmatrix}-10\\10\end{pmatrix}.
    \end{split}\]
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} \boldsymbol{\mu}_1 = \begin{pmatrix}-2\\1\end{pmatrix}, \boldsymbol{\mu}_2
    = \begin{pmatrix}2\\-1\end{pmatrix}, \boldsymbol{\mu}_3 = \begin{pmatrix}-10\\10\end{pmatrix}.
    \end{split}\]
- en: The corresponding matrix \(U\) is then
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的矩阵 \(U\) 是
- en: \[\begin{split} U = \begin{bmatrix} -2 & 1\\ 2 & -1\\ -10 & 10 \end{bmatrix}.
    \end{split}\]
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} U = \begin{bmatrix} -2 & 1\\ 2 & -1\\ -10 & 10 \end{bmatrix}.
    \end{split}\]
- en: Hence multiplying \(Z\) and \(U\) produces a matrix where each row is the representative
    of the assigned cluster of the corresponding data point
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，乘以 \(Z\) 和 \(U\) 得到的矩阵中，每一行都是对应数据点分配簇的代表
- en: \[\begin{split} ZU = \begin{bmatrix} 1 & 0 & 0\\ 0 & 1 & 0\\ 0 & 1 & 0\\ 1 &
    0 & 0\\ 0 & 0 & 1\\ 1 & 0 & 0\\ 0 & 1 & 0\\ 1 & 0 & 0 \end{bmatrix} \, \begin{bmatrix}
    -2 & 1\\ 2 & -1\\ -10 & 10 \end{bmatrix} = \begin{bmatrix} -2 & 1\\ 2 & -1\\ 2
    & -1\\ -2 & 1\\ -10 & 10\\ -2 & 1\\ 2 & -1\\ -2 & 1 \end{bmatrix}. \end{split}\]
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} ZU = \begin{bmatrix} 1 & 0 & 0\\ 0 & 1 & 0\\ 0 & 1 & 0\\ 1 &
    0 & 0\\ 0 & 0 & 1\\ 1 & 0 & 0\\ 0 & 1 & 0\\ 1 & 0 & 0 \end{bmatrix} \, \begin{bmatrix}
    -2 & 1\\ 2 & -1\\ -10 & 10 \end{bmatrix} = \begin{bmatrix} -2 & 1\\ 2 & -1\\ 2
    & -1\\ -2 & 1\\ -10 & 10\\ -2 & 1\\ 2 & -1\\ -2 & 1 \end{bmatrix}. \end{split}\]
- en: \(\lhd\)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: \(\lhd\)
- en: Recall that the Frobenius norm of an \(n \times m\) matrix \(A \in \mathbb{R}^{n
    \times m}\) is defined as
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，\(n \times m\) 矩阵 \(A \in \mathbb{R}^{n \times m}\) 的 Frobenius 范数定义为
- en: \[ \|A\|_F = \sqrt{\sum_{i=1}^n \sum_{j=1}^m A_{ij}^2}. \]
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \|A\|_F = \sqrt{\sum_{i=1}^n \sum_{j=1}^m A_{ij}^2}. \]
- en: Using row notation, it can be written as the sum of the squared Euclidean norms
    of the rows
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用行表示法，它可以写成行欧几里得范数的平方和
- en: \[ \|A\|_F^2 = \sum_{i=1}^n \|A_{i,\cdot}\|^2. \]
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \|A\|_F^2 = \sum_{i=1}^n \|A_{i,\cdot}\|^2. \]
- en: For two matrices \(A, B \in \mathbb{R}^{n \times m}\), the Frobenius norm of
    their difference \(\|A - B\|_F\) can be interpreted as a distance between \(A\)
    and \(B\), that is, a measure of how dissimilar they are.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个矩阵 \(A, B \in \mathbb{R}^{n \times m}\)，它们的差 \(\|A - B\|_F\) 的 Frobenius
    范数可以解释为 \(A\) 和 \(B\) 之间的距离，即它们差异的度量。
- en: Finally, we return to the \(k\)-means objective. Using the notation introduced
    in this section and the equivalent formula for the objective \(G\) derived in
    the proof of the *Optimal Clustering Lemma*, we note that
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回到 \(k\)-means 目标函数。使用本节中引入的符号和证明 *最优聚类引理* 中推导出的目标 \(G\) 的等价公式，我们注意到
- en: \[\begin{align*} G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k)
    &= \sum_{i=1}^n \|\mathbf{x}_i - \boldsymbol{\mu}_{c(i)}\|^2\\ &= \sum_{i=1}^n
    \sum_{\ell=1}^d \left(x_{i\ell} - (Z U)_{i\ell}\right)^2\\ &= \|X - Z U \|^2_F,
    \end{align*}\]
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{align*} G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k)
    &= \sum_{i=1}^n \|\mathbf{x}_i - \boldsymbol{\mu}_{c(i)}\|^2\\ &= \sum_{i=1}^n
    \sum_{\ell=1}^d \left(x_{i\ell} - (Z U)_{i\ell}\right)^2\\ &= \|X - Z U \|^2_F,
    \end{align*}\]
- en: where we used the definition of the Frobenius norm.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 其中我们使用了 Frobenius 范数的定义。
- en: In other words, minimizing the \(k\)-means objective is equivalent to finding
    a matrix factorization of the form \(ZU\) that is a good fit to the data matrix
    \(X\) in Frobenius norm. This formulation expresses in a more compact form the
    idea of representing \(X\) as a combination of a small number of representatives.
    Matrix factorization will come back repeatedly in this course.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，最小化 \(k\)-means 目标函数等同于找到一个形式为 \(ZU\) 的矩阵分解，使其在 Frobenius 范数上很好地拟合数据矩阵
    \(X\)。这种公式以更紧凑的形式表达了将 \(X\) 表示为少数几个代表者的想法。矩阵分解将在本课程中反复出现。
- en: '***Self-assessment quiz*** *(with help from Claude, Gemini, and ChatGPT)*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '***自我评估测验*** *(有 Claude、Gemini 和 ChatGPT 的帮助)*'
- en: '**1** Which of these is NOT a property of a valid partition \(C_1, \ldots,
    C_k\) in the context of \(k\)-means?'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**1** 在 \(k\)-means 的上下文中，以下哪个不是有效分区 \(C_1, \ldots, C_k\) 的属性？'
- en: a) The subsets are pairwise disjoint
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: a) 子集是两两不相交的
- en: b) The subsets cover all data points
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: b) 子集覆盖所有数据点
- en: c) Each subset is non-empty
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: c) 每个子集非空
- en: d) Each subset contains an equal number of points
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: d) 每个子集包含相同数量的点
- en: '**2** In the \(k\)-means objective function, what does the variable \(\boldsymbol{\mu}_i\)
    represent?'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**2** 在 \(k\)-means 目标函数中，变量 \(\boldsymbol{\mu}_i\) 代表什么？'
- en: a) The centroid of cluster \(i\)
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: a) 聚类 \(i\) 的质心
- en: b) The number of points in cluster \(i\)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: b) 聚类 \(i\) 中的点数
- en: c) The distance between clusters \(i\) and \(j\)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: c) 聚类 \(i\) 和 \(j\) 之间的距离
- en: d) The assignment of point \(j\) to a cluster
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: d) 点 \(j\) 分配到聚类
- en: '**3** The \(k\)-means objective function is a measure of what?'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**3** \(k\)-means 目标函数衡量的是什么？'
- en: a) The total number of clusters.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: a) 聚类的总数。
- en: b) The average distance between data points.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: b) 数据点之间的平均距离。
- en: c) The sum of squared distances between each data point and its assigned cluster
    center.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: c) 每个数据点与其分配的聚类中心之间的平方距离之和。
- en: d) The maximum distance between any two cluster centers.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: d) 任意两个聚类中心之间的最大距离。
- en: '**4** What is a key property of the sequence of objective function values produced
    by the \(k\)-means algorithm?'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**4** \(k\)-means 算法产生的目标函数值序列的关键属性是什么？'
- en: a) It is strictly decreasing
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: a) 它是严格递减的
- en: b) It is non-increasing
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: b) 它是非递增的
- en: c) It is strictly increasing
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: c) 它是严格递增的
- en: d) It alternates between two values
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: d) 它在两个值之间交替。
- en: '**5** What is the interpretation of the matrix \(Z\) in the matrix formulation
    of \(k\)-means?'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**5** 在 \(k\)-means 的矩阵公式中，矩阵 \(Z\) 的解释是什么？'
- en: a) It represents the cluster centers.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: a) 它代表聚类中心。
- en: b) It represents the distances between data points.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: b) 它代表数据点之间的距离。
- en: c) It encodes the cluster assignments of each data point.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: c) 它编码了每个数据点的聚类分配。
- en: d) It represents the covariance matrix of the data.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: d) 它代表数据的协方差矩阵。
- en: 'Answer for 1: d. Justification: “Formally, we define a clustering as a partition.
    A partition of \([n] = {1,\ldots,n}\) of size \(k\) is a collection of non-empty
    subsets \(C_1,\ldots,C_k \subseteq [n]\) that: are pairwise disjoint, i.e., \(C_i
    \cap C_j = \emptyset\), \(\forall i \neq j\); cover all of \([n]\), i.e., \(\cup_{i=1}^k
    C_i = [n]\).” No requirement for equal-sized subsets is mentioned.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 1 的答案：d. 证明：“形式上，我们定义聚类为一个划分。大小为 \(k\) 的 \([n] = {1,\ldots,n}\) 的划分是一组非空子集 \(C_1,\ldots,C_k
    \subseteq [n]\)，它们是两两不相交的，即 \(C_i \cap C_j = \emptyset\)，\(\forall i \neq j\)；覆盖了
    \([n]\)，即 \(\cup_{i=1}^k C_i = [n]\)。” 没有提到子集大小必须相等的要求。
- en: 'Answer for 2: a. Justification: “Here \(\boldsymbol{\mu}_i \in \mathbb{R}^d\)
    is the representative – or center – of cluster \(C_i\).”'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 2 的答案：a. 证明：“这里 \(\boldsymbol{\mu}_i \in \mathbb{R}^d\) 是簇 \(C_i\) 的代表或中心。”
- en: 'Answer for 3: c. Justification: The \(k\)-means objective is defined in the
    text as minimizing the sum of squared distances between data points and their
    assigned cluster centers.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 3 的答案：c. 证明：文本中将 k-means 目标函数定义为最小化数据点与其分配的簇中心之间的平方距离之和。
- en: 'Answer for 4: b. Justification: “The sequence of objective function values
    produced by the \(k\)-means algorithm is non-increasing.”'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 4 的答案：b. 证明：“k-means 算法产生的目标函数值序列是非递增的。”
- en: 'Answer for 5: c. Justification: The text defines \(Z\) as a matrix where “each
    row has exactly one entry with value 1, corresponding to the assigned cluster
    of data point.”'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 5 的答案：c. 证明：文本中将 \(Z\) 定义为一个矩阵，其中“每一行恰好有一个值为 1 的条目，对应于数据点的分配簇。”
- en: 1.3.1\. The k-means objective[#](#the-k-means-objective "Link to this heading")
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3.1\. K-means 目标函数[#](#the-k-means-objective "链接到这个标题")
- en: Under the \(k\)-means objective\(\idx{k-means objective}\xdi\), the “cost” of
    \(C_1,\ldots,C_k\) is defined as
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在 k-means 目标函数\(\idx{k-means objective}\xdi\) 下，\(C_1,\ldots,C_k\) 的“成本”定义为
- en: \[ \mathcal{G}(C_1,\ldots,C_k) = \min_{\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k
    \in \mathbb{R}^d} \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2.
    \]
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \mathcal{G}(C_1,\ldots,C_k) = \min_{\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k
    \in \mathbb{R}^d} \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2.
    \]
- en: Here \(\boldsymbol{\mu}_i \in \mathbb{R}^d\) is the representative – or center
    – of cluster \(C_i\). Note that \(\boldsymbol{\mu}_i\) need not be one of the
    \(\mathbf{x}_j\)’s.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 \(\boldsymbol{\mu}_i \in \mathbb{R}^d\) 是簇 \(C_i\) 的代表或中心。注意，\(\boldsymbol{\mu}_i\)
    不一定是 \(\mathbf{x}_j\) 中的一个。
- en: Our goal is to find a partition \(C_1,\ldots,C_k\) that minimizes \(\mathcal{G}(C_1,\ldots,C_k)\),
    i.e., solves the problem
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是找到一个划分 \(C_1,\ldots,C_k\)，使得 \(\mathcal{G}(C_1,\ldots,C_k)\) 最小化，即解决以下问题
- en: \[ \min_{C_1,\ldots,C_k} \mathcal{G}(C_1,\ldots,C_k) \]
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \min_{C_1,\ldots,C_k} \mathcal{G}(C_1,\ldots,C_k) \]
- en: over all partitions of \([n]\) of size \(k\). This is a finite optimization
    problem, as there are only a finite number of such partitions. Note, however,
    that the objective function itself is an optimization problem over \(\mathbb{R}^d
    \times \cdots \times \mathbb{R}^{d}\), that is, \(k\) copies of \(\mathbb{R}^d\).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有大小为 \(k\) 的 \([n]\) 的划分中。这是一个有限优化问题，因为这样的划分数量是有限的。然而，请注意，目标函数本身是在 \(\mathbb{R}^d
    \times \cdots \times \mathbb{R}^{d}\) 上的优化问题，即 \(k\) 个 \(\mathbb{R}^d\) 的副本。
- en: 'To quote [Wikipedia](https://en.wikipedia.org/wiki/Cluster_analysis#Centroid-based_clustering):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 引用 [维基百科](https://en.wikipedia.org/wiki/Cluster_analysis#Centroid-based_clustering)：
- en: 'In centroid-based clustering, clusters are represented by a central vector,
    which may not necessarily be a member of the data set. When the number of clusters
    is fixed to k, k-means clustering gives a formal definition as an optimization
    problem: find the k cluster centers and assign the objects to the nearest cluster
    center, such that the squared distances from the cluster are minimized.'
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在基于质心的聚类中，簇由一个中心向量表示，这个向量不一定是数据集的成员。当簇的数量固定为 \(k\) 时，k-means 聚类给出了一个形式化的定义，即优化问题：找到
    \(k\) 个簇中心并将对象分配到最近的簇中心，使得从簇到簇的平方距离最小化。
- en: '**KNOWLEDGE CHECK:** Is it possible for a global solution of the \(k\)-means
    clustering problem to contain an empty cluster? \(\checkmark\)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**知识检查：** \(k\)-means 聚类问题的全局解是否可能包含一个空簇？\(\checkmark\)'
- en: 'In general, the problem is [NP-hard](https://en.wikipedia.org/wiki/NP-hardness)\(\idx{NP-hardness}\xdi\),
    that is, roughly speaking no “fast” algorithm is expected to exist to solve it.
    Lloyd’s algorithm (also referred to as the \(k\)-means algorithm) is a popular
    heuristic. It is based on the idea that the following two sub-problems are easy
    to solve:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般情况下，该问题是[NP-hard](https://en.wikipedia.org/wiki/NP-hardness)\(\idx{NP-hardness}\xdi\)，也就是说，粗略地说，没有“快速”算法被期望能解决它。Lloyd算法（也称为\(k\)-means算法）是一种流行的启发式算法。它基于以下两个子问题容易解决的观念：
- en: finding the optimal representatives for a fixed partition;
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找固定划分的最优代表；
- en: finding the optimal partition for a fixed set of representatives.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找固定代表集的最优划分。
- en: One then alternates between the two (perhaps until progress falls below a tolerance).
    This is reasonable since our goal, as we pointed out above, is to solve the minimization
    problem
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在两个子问题之间交替（可能直到进步低于容差）。这是合理的，因为我们的目标，如我们上面所指出的，是解决最小化问题
- en: \[ \min_{C_1,\ldots,C_k} \min_{\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k
    \in \mathbb{R}^d} \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2
    \]
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \min_{C_1,\ldots,C_k} \min_{\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k
    \in \mathbb{R}^d} \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2
    \]
- en: where \(C_1,\ldots,C_k\) ranges over all partitions of \([n]\) of size \(k\).
    Fixing partition \(C_1,\ldots,C_k\) and miniminizing over \(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k
    \in \mathbb{R}^d\) corresponds to solving the first problem above, while fixing
    \(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k \in \mathbb{R}^d\) and miniminizing
    over partitions \(C_1,\ldots,C_k\) corresponds to solving the second problem.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(C_1,\ldots,C_k\) 范围涵盖所有大小为\(k\)的\([n]\)的划分。固定划分 \(C_1,\ldots,C_k\) 并在 \(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k
    \in \mathbb{R}^d\) 上进行最小化对应于解决上述第一个问题，而固定 \(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k
    \in \mathbb{R}^d\) 并在划分 \(C_1,\ldots,C_k\) 上进行最小化对应于解决第二个问题。
- en: '**CHAT & LEARN** Ask your favorite AI chatbot about the differences between
    \(k\)-means, \(k\)-medians, and \(k\)-medoids clustering. \(\ddagger\)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**CHAT & LEARN** 向你最喜欢的AI聊天机器人询问\(k\)-means、\(k\)-medians和\(k\)-medoids聚类的区别。\(\ddagger\)'
- en: '**Some useful optimization results** To analyze the Lloyd’s algorithm, we will
    rely on a few basic observations.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**一些有用的优化结果** 为了分析Lloyd算法，我们将依赖于几个基本观察。'
- en: '*Minimizing a quadratic function:* To elaborate on the first step above, we
    review an elementary fact about [quadratic functions](https://en.wikipedia.org/wiki/Quadratic_function).Consider
    the function'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*最小化二次函数:* 为了详细说明上述第一步，我们回顾关于[二次函数](https://en.wikipedia.org/wiki/Quadratic_function)的一个基本事实。考虑函数'
- en: \[ q(x) = a x^2 + b x + c. \]
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: \[ q(x) = a x^2 + b x + c. \]
- en: When \(a > 0\), \(q\) has a unique minimum.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当 \(a > 0\) 时，\(q\) 有一个唯一的极小值。
- en: '**LEMMA** **(Minimum of a Quadratic Function)** \(\idx{minimum of a quadratic
    function}\xdi\) Let \(q(x) = a x^2 + b x + c\) where \(a > 0\) and \(x \in \mathbb{R}\).
    The unique global minimum of \(q\) is attained at'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**引理** **（二次函数的最小值）** \(\idx{二次函数的最小值}\xdi\) 设 \(q(x) = a x^2 + b x + c\)，其中
    \(a > 0\) 且 \(x \in \mathbb{R}\)。\(q\) 的唯一全局最小值在'
- en: \[ x^* = -\frac{b}{2a}. \]
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x^* = -\frac{b}{2a}. \]
- en: \(\flat\)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: \(\flat\)
- en: '*Proof:* By the *First-Order Necessary Optimality Condition*, a global minimizer
    of \(q\) (which is necessarily a local minimizer) satisfies the condition'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明:* 根据**一阶必要最优性条件**，\(q\)的全局最小值（必然是局部最小值）满足该条件'
- en: \[ \frac{\mathrm{d}}{\mathrm{d}x} q(x) = 2 a x + b = 0, \]
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \frac{\mathrm{d}}{\mathrm{d}x} q(x) = 2 a x + b = 0, \]
- en: whose unique solution is
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 其唯一解为
- en: \[ x^*= -\frac{b}{2a}. \]
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x^*= -\frac{b}{2a}. \]
- en: To see that \(x^*\) is indeed a global minimizer, we re-write \(q\) as
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明\(x^*\)确实是一个全局最小值，我们将\(q\)重新写为
- en: \[\begin{align*} q(x) &= a \left(x^2 + 2 \left[\frac{b}{2a}\right] x\right)
    + c\\ &= a \left(x^2 + 2 \left[\frac{b}{2a}\right] x + \left[\frac{b}{2a}\right]^2\right)
    - a \left[\frac{b}{2a}\right]^2 + c\\ &= a (x - x^*)^2 + \left[c - \frac{b^2}{4a}\right].
    \end{align*}\]
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{align*} q(x) &= a \left(x^2 + 2 \left[\frac{b}{2a}\right] x\right)
    + c\\ &= a \left(x^2 + 2 \left[\frac{b}{2a}\right] x + \left[\frac{b}{2a}\right]^2\right)
    - a \left[\frac{b}{2a}\right]^2 + c\\ &= a (x - x^*)^2 + \left[c - \frac{b^2}{4a}\right].
    \end{align*}\]
- en: Clearly, any other \(x\) gives a higher value for \(q\). The step on the second
    line above is called [*Completing the Square*](https://en.wikipedia.org/wiki/Completing_the_square).
    \(\square\)
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，任何其他的 \(x\) 都会给 \(q\) 带来更高的值。上面第二行的步骤被称为[*配方法*](https://en.wikipedia.org/wiki/Completing_the_square)。\(\square\)
- en: '**NUMERICAL CORNER:** Here’s a numerical example. We first define a quadratic
    function.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**数值角:** 这里有一个数值示例。我们首先定义一个二次函数。'
- en: '[PRE24]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We plot it for different values of the coefficients. Note that the \(x\) and
    \(y\) axes are on different scales.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为不同的系数值绘制了图形。注意，\(x\) 轴和 \(y\) 轴的刻度不同。
- en: '[PRE25]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![../../_images/61bc7fdbb91557152ddeef0b81d381a6bfd002c537f7992efa581d8504d503a5.png](../Images/eae4bc2fb4c7aab683b47a1a195867e9.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/61bc7fdbb91557152ddeef0b81d381a6bfd002c537f7992efa581d8504d503a5.png](../Images/eae4bc2fb4c7aab683b47a1a195867e9.png)'
- en: \(\unlhd\)
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: \(\unlhd\)
- en: '*Optimizing an additively separable function:* Functions that can be written
    as the sum of disjoint sets of coordinates arise commonly in optimization and
    have convenient “separability” properties.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '*优化可加分离函数：* 在优化中，可以表示为坐标集合之和的函数很常见，并且具有方便的“可分离”性质。'
- en: For vectors \(\mathbf{x}_i \in \mathbb{R}^{d_i}\), \(i \in [\ell]\), with \(\sum_{i=1}^\ell
    d_i = d\), their concatenation is denoted as \((\mathbf{x}_1, \ldots, \mathbf{x}_\ell)
    \in \mathbb{R}^d\). That is the vector obtained by concatenating the coordinates
    of \(\mathbf{x}_1, \ldots, \mathbf{x}_\ell\) into a single vector. A different
    way to see this is that \((\mathbf{x}_1, \ldots, \mathbf{x}_\ell)\) is a block
    vector with blocks \(\mathbf{x}_1, \ldots, \mathbf{x}_\ell\). For example, if
    \(\mathbf{x}_1 = (1, 2)\) and \(\mathbf{x}_2 = (-1, -3, -5)\), then \((\mathbf{x}_1,\mathbf{x}_2)
    = (1, 2, -1, -3, -5)\).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 对于向量 \(\mathbf{x}_i \in \mathbb{R}^{d_i}\)，\(i \in [\ell]\)，且 \(\sum_{i=1}^\ell
    d_i = d\)，它们的连接表示为 \((\mathbf{x}_1, \ldots, \mathbf{x}_\ell) \in \mathbb{R}^d\)。也就是说，通过将
    \(\mathbf{x}_1, \ldots, \mathbf{x}_\ell\) 的坐标连接成一个单一向量得到的向量。另一种看待它的方式是，\((\mathbf{x}_1,
    \ldots, \mathbf{x}_\ell)\) 是一个由 \(\mathbf{x}_1, \ldots, \mathbf{x}_\ell\) 组成的块向量。例如，如果
    \(\mathbf{x}_1 = (1, 2)\) 和 \(\mathbf{x}_2 = (-1, -3, -5)\)，那么 \((\mathbf{x}_1,\mathbf{x}_2)
    = (1, 2, -1, -3, -5)\)。
- en: '**LEMMA** **(Optimizing a Separable Function)** \(\idx{optimizing a separable
    function lemma}\xdi\) Assume that \(\mathbf{z} \in \mathbb{R}^d\) can be broken
    up into subvectors \(\mathbf{x}_i \in \mathbb{R}^{d_i}\), \(i \in [\ell]\), with
    \(\sum_{i=1}^\ell d_i = d\) as follows \(\mathbf{z} = (\mathbf{x}_1, \ldots, \mathbf{x}_\ell)\).
    Suppose that the real-valued function \(h : \mathbb{R}^d \to \mathbb{R}\) can
    be written in the additively separable form'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**引理** **(优化可分离函数)** \(\idx{optimizing a separable function lemma}\xdi\) 假设
    \(\mathbf{z} \in \mathbb{R}^d\) 可以分解为子向量 \(\mathbf{x}_i \in \mathbb{R}^{d_i}\)，\(i
    \in [\ell]\)，且 \(\sum_{i=1}^\ell d_i = d\)，如下所示 \(\mathbf{z} = (\mathbf{x}_1,
    \ldots, \mathbf{x}_\ell)\)。假设实值函数 \(h : \mathbb{R}^d \to \mathbb{R}\) 可以写成可加分离形式'
- en: \[ h(\mathbf{z}) = f_1(\mathbf{x}_1) + \cdots + f_\ell(\mathbf{x}_\ell), \]
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: \[ h(\mathbf{z}) = f_1(\mathbf{x}_1) + \cdots + f_\ell(\mathbf{x}_\ell), \]
- en: 'for a collection of functions \(f_i : \mathbb{R}^{d_i} \to \mathbb{R}\), \(i
    \in [\ell]\). If, for each \(i \in [\ell]\), \(\mathbf{x}_i^*\) is a global minimum
    of \(f_i\), then \(\mathbf{z}^* = (\mathbf{x}_1^*, \ldots, \mathbf{x}_\ell^*)\)
    is a global minimum of \(h\). \(\flat\)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '对于一个函数集合 \(f_i : \mathbb{R}^{d_i} \to \mathbb{R}\)，\(i \in [\ell]\)。如果对于每个
    \(i \in [\ell]\)，\(\mathbf{x}_i^*\) 是 \(f_i\) 的全局最小值，那么 \(\mathbf{z}^* = (\mathbf{x}_1^*,
    \ldots, \mathbf{x}_\ell^*)\) 是 \(h\) 的全局最小值。 \(\flat\)'
- en: '*Proof idea:* Each term in the sum defining \(h\) depends on a separate set
    of coordinates and therefore is unaffected by the choices made in other terms.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明思路：* \(h\) 的定义中的每一项都依赖于一组独立的坐标，因此不受其他项中做出的选择的影响。'
- en: '*Proof:* Let \(\mathbf{z} = (\mathbf{x}_1, \ldots, \mathbf{x}_\ell)\). Since
    \(\mathbf{x}_i^*\) is a global minimum of \(f_i\), it holds that \(f_i(\mathbf{x}_i^*)
    \leq f_i(\mathbf{x}_i)\), for all \(i\). Hence,'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明：* 令 \(\mathbf{z} = (\mathbf{x}_1, \ldots, \mathbf{x}_\ell)\)。由于 \(\mathbf{x}_i^*\)
    是 \(f_i\) 的全局最小值，因此对于所有 \(i\)，有 \(f_i(\mathbf{x}_i^*) \leq f_i(\mathbf{x}_i)\)。因此，'
- en: \[ h(\mathbf{z}^*) = f_1(\mathbf{x}_1^*) + \cdots + f_\ell(\mathbf{x}_\ell^*)
    \leq f_1(\mathbf{x}_1) + \cdots + f_\ell(\mathbf{x}_\ell) = h(\mathbf{z}). \]
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: \[ h(\mathbf{z}^*) = f_1(\mathbf{x}_1^*) + \cdots + f_\ell(\mathbf{x}_\ell^*)
    \leq f_1(\mathbf{x}_1) + \cdots + f_\ell(\mathbf{x}_\ell) = h(\mathbf{z}). \]
- en: Since \(\mathbf{z}\) is arbitrary, we have proved the claim. \(\square\)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 \(\mathbf{z}\) 是任意的，我们已经证明了该命题。 \(\square\)
- en: '*Composing with a non-decreasing function:* Recall that a real-valued function
    \(f\) of a single variable is non-decreasing if'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用非递减函数进行创作：* 回想一下，一个单变量实值函数 \(f\) 如果满足以下条件，则称为非递减函数：'
- en: \[ x \leq y \implies f(x) \leq f(y). \]
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: \[ x \leq y \implies f(x) \leq f(y). \]
- en: '**LEMMA** **(Composing with a Non-Decreasing Function)** \(\idx{composing with
    a non-decreasing function lemma}\xdi\) Let \(f : \mathbb{R} \to \mathbb{R}\) be
    non-decreasing, let \(g : \mathbb{R}^d \to \mathbb{R}\), and define \(h(\mathbf{x})
    = f(g(\mathbf{x}))\). If \(\mathbf{x}^*\) is a global minimum of \(g\), then it
    is also a global minimum of \(h\). \(\flat\)'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**引理** **(与非递减函数的组合)** \(\idx{composing with a non-decreasing function lemma}\xdi\)
    设 \(f : \mathbb{R} \to \mathbb{R}\) 是非递减的，设 \(g : \mathbb{R}^d \to \mathbb{R}\)，并定义
    \(h(\mathbf{x}) = f(g(\mathbf{x}))\)。如果 \(\mathbf{x}^*\) 是 \(g\) 的全局最小值，那么它也是
    \(h\) 的全局最小值。\(\flat\)'
- en: '*Proof idea:* This just follows from applying the definitions.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明思路:* 这只是应用定义的结果。'
- en: '*Proof:* Let \(\mathbf{x} \in \mathbb{R}^d\). Because \(\mathbf{x}^*\) is a
    global minimum of \(g\), \(g(\mathbf{x}^*) \leq g(\mathbf{x})\). Further, since
    \(f\) is non-decreasing,'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明:* 设 \(\mathbf{x} \in \mathbb{R}^d\)。因为 \(\mathbf{x}^*\) 是 \(g\) 的全局最小值，所以
    \(g(\mathbf{x}^*) \leq g(\mathbf{x})\)。进一步，由于 \(f\) 是非递减的，'
- en: \[ h(\mathbf{x}^*) = f(g(\mathbf{x}^*)) \leq f(g(\mathbf{x})) = h(\mathbf{x}).
    \]
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: \[ h(\mathbf{x}^*) = f(g(\mathbf{x}^*)) \leq f(g(\mathbf{x})) = h(\mathbf{x}).
    \]
- en: Since \(\mathbf{x}\) is arbitrary, we have proved the claim. \(\square\)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 \(\mathbf{x}\) 是任意的，我们已经证明了该命题。\(\square\)
- en: '**Sub-problem 1: finding the optimal representatives** We denote by \(|C_i|\)
    the number of elements in \(C_i\).'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**子问题 1: 寻找最优代表** 我们用 \(|C_i|\) 表示 \(C_i\) 中的元素数量。'
- en: '**EXAMPLE:** **(continued)** Continuing the example above, the sizes of the
    clusters are respectively \(|C_1| = 4, |C_2| = 3, |C_3| = 1\). Note in particulat
    that \(|C_1| + |C_2| + |C_3| = 8 = n\), as follows from the fact that \(C_1, C_2,
    C_3\) is a partition. \(\lhd\)'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例:** **(继续)** 继续上面的示例，簇的大小分别为 \(|C_1| = 4, |C_2| = 3, |C_3| = 1\)。特别注意的是
    \(|C_1| + |C_2| + |C_3| = 8 = n\)，这是由于 \(C_1, C_2, C_3\) 是一个划分。\(\lhd\)'
- en: '**LEMMA** **(Optimal Representatives)** \(\idx{optimal representatives lemma}\xdi\)
    Fix a partition \(C_1,\ldots,C_k\). The optimal representatives under the objective'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**引理** **(最优代表)** \(\idx{optimal representatives lemma}\xdi\) 固定一个划分 \(C_1,\ldots,C_k\)。在目标函数下，最优代表是'
- en: \[ G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k) = \sum_{i=1}^k
    \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2, \]
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: \[ G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k) = \sum_{i=1}^k
    \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2, \]
- en: are the [centroids](https://en.wikipedia.org/wiki/Centroid)\(\idx{centroid}\xdi\)
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 是 [质心](https://en.wikipedia.org/wiki/Centroid)\(\idx{centroid}\xdi\)
- en: \[ \boldsymbol{\mu}_i^* = \frac{1}{|C_i|} \sum_{j\in C_i} \mathbf{x}_j. \]
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \boldsymbol{\mu}_i^* = \frac{1}{|C_i|} \sum_{j\in C_i} \mathbf{x}_j. \]
- en: \(\flat\)
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: \(\flat\)
- en: '*Proof idea:* The objective \(G\) can be written as a sum, where each term
    is a quadratic function in one component of one of the \(\boldsymbol{\mu}_i\)’s.
    Each of these terms is minimized by the average of the corresponding components
    of the \(\mathbf{x}_j\)’s belonging \(C_i\).'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明思路:* 目标 \(G\) 可以写成求和的形式，其中每一项是 \(\boldsymbol{\mu}_i\) 的一个分量上的二次函数。这些项中的每一项都通过
    \(C_i\) 中属于 \(\mathbf{x}_j\) 的对应分量的平均值来最小化。'
- en: '**EXAMPLE:** **(continued)** Continuing with the previous example, we compute
    the optimal representatives for the fixed partition \(C_1, C_2, C_3\) above. We
    get'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例:** **(继续)** 继续上一个示例，我们计算固定划分 \(C_1, C_2, C_3\) 的最优代表。我们得到'
- en: \[\begin{align*} \boldsymbol{\mu}_1^* &= \frac{1}{4}[\mathbf{x}_1 + \mathbf{x}_4
    + \mathbf{x}_6 + \mathbf{x}_8]\\ &= \frac{1}{4}\left[\begin{pmatrix}1\\0\end{pmatrix}
    + \begin{pmatrix}1\\-3\end{pmatrix} + \begin{pmatrix}2\\-2\end{pmatrix} + \begin{pmatrix}3\\-1\end{pmatrix}
    \right] = \begin{pmatrix}7/4\\-3/2\end{pmatrix},\\ \boldsymbol{\mu}_2^* &= \frac{1}{3}[\mathbf{x}_2
    + \mathbf{x}_3 + \mathbf{x}_7]\\ &= \frac{1}{3}\left[\begin{pmatrix}-2\\0\end{pmatrix}+
    \begin{pmatrix}-2\\1\end{pmatrix}+ \begin{pmatrix}-3\\1\end{pmatrix} \right] =
    \begin{pmatrix}-7/3\\2/3\end{pmatrix},\\ \boldsymbol{\mu}_3^* &= \frac{1}{1}[\mathbf{x}_5]
    = \begin{pmatrix}-10\\10\end{pmatrix}. \end{align*}\]
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{align*} \boldsymbol{\mu}_1^* &= \frac{1}{4}[\mathbf{x}_1 + \mathbf{x}_4
    + \mathbf{x}_6 + \mathbf{x}_8]\\ &= \frac{1}{4}\left[\begin{pmatrix}1\\0\end{pmatrix}
    + \begin{pmatrix}1\\-3\end{pmatrix} + \begin{pmatrix}2\\-2\end{pmatrix} + \begin{pmatrix}3\\-1\end{pmatrix}
    \right] = \begin{pmatrix}7/4\\-3/2\end{pmatrix},\\ \boldsymbol{\mu}_2^* &= \frac{1}{3}[\mathbf{x}_2
    + \mathbf{x}_3 + \mathbf{x}_7]\\ &= \frac{1}{3}\left[\begin{pmatrix}-2\\0\end{pmatrix}+
    \begin{pmatrix}-2\\1\end{pmatrix}+ \begin{pmatrix}-3\\1\end{pmatrix} \right] =
    \begin{pmatrix}-7/3\\2/3\end{pmatrix},\\ \boldsymbol{\mu}_3^* &= \frac{1}{1}[\mathbf{x}_5]
    = \begin{pmatrix}-10\\10\end{pmatrix}. \end{align*}\]
- en: \(\lhd\)
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: \(\lhd\)
- en: '*Proof:* *(Optimal Representatives)* Using the notation \(\mathbf{x}_j = (x_{j1},\ldots,x_{jd})\)
    and similarly for \(\boldsymbol{\mu}_i\), note that we can expand the \(k\)-means
    objective as'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明:* *(最优代表)* 使用符号 \(\mathbf{x}_j = (x_{j1},\ldots,x_{jd})\) 和类似地对于 \(\boldsymbol{\mu}_i\)，注意我们可以将
    \(k\)-means 目标展开为'
- en: \[\begin{align*} \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2
    &= \sum_{i=1}^k \sum_{j \in C_i} \sum_{m=1}^d (x_{jm} - \mu_{im})^2\\ &= \sum_{i=1}^k
    \sum_{m=1}^d \left[\sum_{j \in C_i} (x_{jm} - \mu_{im})^2\right]. \end{align*}\]
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{align*} \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2
    &= \sum_{i=1}^k \sum_{j \in C_i} \sum_{m=1}^d (x_{jm} - \mu_{im})^2\\ &= \sum_{i=1}^k
    \sum_{m=1}^d \left[\sum_{j \in C_i} (x_{jm} - \mu_{im})^2\right]. \end{align*}\]
- en: The expression in square brackets is a quadratic function in \(\mu_{im}\)
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号中的表达式是 \(\mu_{im}\) 的二次函数
- en: \[\begin{align*} q_{im}(\mu_{im}) &= \sum_{j \in C_i} (x_{jm} - \mu_{im})^2\\
    &= \left\{\sum_{j \in C_i} x_{jm}^2\right\} + \left\{- 2 \sum_{j \in C_i} x_{jm}\right\}
    \mu_{im} + \left\{|C_i| \right\} \mu_{im}^2. \end{align*}\]
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{align*} q_{im}(\mu_{im}) &= \sum_{j \in C_i} (x_{jm} - \mu_{im})^2\\
    &= \left\{\sum_{j \in C_i} x_{jm}^2\right\} + \left\{- 2 \sum_{j \in C_i} x_{jm}\right\}
    \mu_{im} + \left\{|C_i| \right\} \mu_{im}^2. \end{align*}\]
- en: Therefore, by the formula for the *Minimum of a Quadratic Function*, is minimized
    at
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据**二次函数最小值**的公式，最小值在
- en: \[ \mu_{im}^* = - \frac{- 2 \sum_{j \in C_i} x_{jm}}{2 |C_i|} = \frac{1}{|C_i|}
    \sum_{j \in C_i} x_{jm}. \]
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \mu_{im}^* = - \frac{- 2 \sum_{j \in C_i} x_{jm}}{2 |C_i|} = \frac{1}{|C_i|}
    \sum_{j \in C_i} x_{jm}. \]
- en: Since each term \(q_{im}(\mu_{im})\) in the sum over \(i, m\) making up the
    objective function \(G\) is minimized at \(\boldsymbol{\mu}_1^*,\ldots, \boldsymbol{\mu}_k^*\),
    so is \(G\) by *Optimizing a Separable Function*. \(\square\)
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目标函数 \(G\) 中构成总和的每个项 \(q_{im}(\mu_{im})\) 都在 \(\boldsymbol{\mu}_1^*,\ldots,
    \boldsymbol{\mu}_k^*\) 处最小化，因此通过**优化可分离函数**，\(G\) 也最小化。 \(\square\)
- en: That the squared norm decomposes into a sum over the coordinates (which the
    norm itself doesn’t because of the square root) is one reason why it is convenient
    to use here, as was hopefully apparent in this last proof.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 由于平方范数分解为坐标的总和（由于平方根，范数本身并不这样做），这是在这里使用它的一个原因，这在最后的证明中应该是显而易见的。
- en: '**Sub-problem 2: finding the optimal partition** Given \(n\) vectors \(\mathbf{x}_1,\ldots,\mathbf{x}_n\)
    in \(\mathbb{R}^d\) and a partition \(C_1, \ldots, C_k \subseteq [n]\), it will
    be useful to have some notation for the corresponding cluster assignment: we define
    \(c(j) = i\) if \(j \in C_i\).'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**子问题 2：寻找最优划分** 给定 \(\mathbb{R}^d\) 中的 \(n\) 个向量 \(\mathbf{x}_1,\ldots,\mathbf{x}_n\)
    和划分 \(C_1, \ldots, C_k \subseteq [n]\)，对于相应的聚类分配，将会有一些符号很有用：我们定义 \(c(j) = i\)
    如果 \(j \in C_i\)。'
- en: '**EXAMPLE:** **(continued)** Continuing the example above, the clusters \(C_1
    = \{1, 4, 6, 8\}, C_2 = \{2, 3, 7\}, C_3 = \{5\}\) correspond to the assignment'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：** **（继续）** 继续上面的例子，聚类 \(C_1 = \{1, 4, 6, 8\}, C_2 = \{2, 3, 7\}, C_3
    = \{5\}\) 对应的分配'
- en: \[ c(1) = 1, c(2) = 2, c(3) = 2, c(4) = 1, c(5) = 3, c(6) = 1, c(7) = (2), c(8)
    = 1\. \]
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: \[ c(1) = 1, c(2) = 2, c(3) = 2, c(4) = 1, c(5) = 3, c(6) = 1, c(7) = (2), c(8)
    = 1\. \]
- en: \(\lhd\)
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: \(\lhd\)
- en: '**LEMMA** **(Optimal Clustering)** \(\idx{optimal clustering lemma}\xdi\) Fix
    the representatives \(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k\). An optimal
    partition under the objective'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '**引理** **（最优聚类）** \(\idx{optimal clustering lemma}\xdi\) 固定代表 \(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k\)。在目标'
- en: \[ G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k) = \sum_{i=1}^k
    \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2, \]
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: \[ G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k) = \sum_{i=1}^k
    \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2, \]
- en: is obtained as follows. For each \(j\), find the \(\boldsymbol{\mu}_i\) that
    minimizes \(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|\) (picking one arbitrarily in
    the case of ties) and assign \(\mathbf{x}_j\) to \(C_i\) (i.e., add \(j\) to \(C_i\)).
    \(\flat\)
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 获得如下。对于每个 \(j\)，找到使 \(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|\) 最小的 \(\boldsymbol{\mu}_i\)（在存在平局时任意选择一个）并将
    \(\mathbf{x}_j\) 分配给 \(C_i\)（即，将 \(j\) 添加到 \(C_i\) 中）。\(\flat\)
- en: '*Proof:* If \(c\) is the cluster assignment associated to \(C_1,\ldots,C_k\),
    then we can re-write the objective as'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明：* 如果 \(c\) 是与 \(C_1,\ldots,C_k\) 相关的聚类分配，那么我们可以将目标重新写为'
- en: \[ \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2 = \sum_{j=1}^n
    \|\mathbf{x}_j - \boldsymbol{\mu}_{c(j)}\|^2, \]
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2 = \sum_{j=1}^n
    \|\mathbf{x}_j - \boldsymbol{\mu}_{c(j)}\|^2, \]
- en: By definition, when the \(\boldsymbol{\mu}_i\)’s are fixed, each term in the
    sum on the right-hand side is minimized separately by the assignment in the statement.
    Hence so is the sum itself by the *Optimizing a Separable Function Lemma*. Note
    that we used the fact that the square root (and the square) is non-decreasing
    to conclude that minimizing \(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2\) or its
    square root \(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|\) are equivalent by the *Composing
    with a Non-Decreasing Function Lemma*. \(\square\)
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，当 \(\boldsymbol{\mu}_i\) 固定时，右侧求和中的每一项都通过语句中的分配单独最小化。因此，根据*可分离函数优化引理*，求和本身也是最小化的。注意，我们使用了平方根（以及平方）是非递减的事实，根据*与非递减函数组合引理*，得出最小化
    \(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2\) 或其平方根 \(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|\)
    是等价的。\(\square\)
- en: '**EXAMPLE:** **(continued)** Continuing the example above, suppose that we
    choose representatives'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：** **（继续）** 继续上面的例子，假设我们选择代表'
- en: \[\begin{split} \boldsymbol{\mu}_1 = \begin{pmatrix}-2\\1\end{pmatrix}, \boldsymbol{\mu}_2
    = \begin{pmatrix}2\\-1\end{pmatrix}, \boldsymbol{\mu}_3 = \begin{pmatrix}-10\\10\end{pmatrix}.
    \end{split}\]
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} \boldsymbol{\mu}_1 = \begin{pmatrix}-2\\1\end{pmatrix}, \boldsymbol{\mu}_2
    = \begin{pmatrix}2\\-1\end{pmatrix}, \boldsymbol{\mu}_3 = \begin{pmatrix}-10\\10\end{pmatrix}.
    \end{split}\]
- en: 'Then we find the cluster assignment of \(\mathbf{x}_1\) by computing its squared
    distance to each representative:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过计算 \(\mathbf{x}_1\) 与每个代表之间的平方距离来找到其簇分配：
- en: \[\begin{split} \|\mathbf{x}_1 - \boldsymbol{\mu}_1\| = \left\|\begin{pmatrix}1\\0\end{pmatrix}
    - \begin{pmatrix}-2\\1\end{pmatrix}\right\| = \sqrt{(1-(-2))^2 + (0-1)^2} = \sqrt{10},
    \end{split}\]\[\begin{split} \|\mathbf{x}_1 - \boldsymbol{\mu}_2\| = \left\|\begin{pmatrix}1\\0\end{pmatrix}
    - \begin{pmatrix}2\\-1\end{pmatrix}\right\| = \sqrt{(1-2)^2 + (0-(-1))^2} = \sqrt{2},
    \end{split}\]\[\begin{split} \|\mathbf{x}_1 - \boldsymbol{\mu}_3\| = \left\|\begin{pmatrix}1\\0\end{pmatrix}
    - \begin{pmatrix}-10\\10\end{pmatrix}\right\| = \sqrt{(1-(-10))^2 + (0-10)^2}
    = \sqrt{221}. \end{split}\]
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} \|\mathbf{x}_1 - \boldsymbol{\mu}_1\| = \left\|\begin{pmatrix}1\\0\end{pmatrix}
    - \begin{pmatrix}-2\\1\end{pmatrix}\right\| = \sqrt{(1-(-2))^2 + (0-1)^2} = \sqrt{10},
    \end{split}\]\[\begin{split} \|\mathbf{x}_1 - \boldsymbol{\mu}_2\| = \left\|\begin{pmatrix}1\\0\end{pmatrix}
    - \begin{pmatrix}2\\-1\end{pmatrix}\right\| = \sqrt{(1-2)^2 + (0-(-1))^2} = \sqrt{2},
    \end{split}\]\[\begin{split} \|\mathbf{x}_1 - \boldsymbol{\mu}_3\| = \left\|\begin{pmatrix}1\\0\end{pmatrix}
    - \begin{pmatrix}-10\\10\end{pmatrix}\right\| = \sqrt{(1-(-10))^2 + (0-10)^2}
    = \sqrt{221}. \end{split}\]
- en: The minimum is achieved for \(\boldsymbol{\mu}_2\) so we assign \(\mathbf{x}_1\)
    to \(C_2\), i.e., \(1 \in C_2\) and \(c(1) = 2\). \(\lhd\)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值对应于 \(\boldsymbol{\mu}_2\)，因此我们将 \(\mathbf{x}_1\) 分配给 \(C_2\)，即 \(1 \in C_2\)
    且 \(c(1) = 2\)。 \(\lhd\)
- en: 1.3.2\. Lloyd’s algorithm and its analysis[#](#lloyds-algorithm-and-its-analysis
    "Link to this heading")
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3.2. Lloyd 算法及其分析[#](#lloyds-algorithm-and-its-analysis "链接到本标题")
- en: We are now ready to describe Lloyd’s algorithm\(\idx{Lloyd's algorithm}\xdi\).
    We start from a random assignment of clusters. (An alternative [initialization
    strategy](https://en.wikipedia.org/wiki/K-means_clustering#Initialization_methods)
    is to choose \(k\) representatives at random among the data points.) We then alternate
    between the optimal choices in the lemmas. In lieu of pseudo-code, we write out
    the algorithm in Python. We will use this approach throughout the book.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备描述 Lloyd 算法\(\idx{Lloyd's algorithm}\xdi\)。我们从随机分配的簇开始。（另一种[初始化策略](https://en.wikipedia.org/wiki/K-means_clustering#Initialization_methods)是在数据点中随机选择
    \(k\) 个代表。）然后我们在引理中的最优选择之间交替。代替伪代码，我们用 Python 写出算法。我们将在整个书中使用这种方法。
- en: The input `X` is assumed to be a collection of \(n\) vectors \(\mathbf{x}_1,
    \ldots, \mathbf{x}_n \in \mathbb{R}^d\) stacked into a matrix, with one row for
    each data point. The other input, `k`, is the desired number of clusters. There
    is an optional input `maxiter` for the maximum number of iterations, which is
    set to \(5\) by default.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `X` 假设是一个由 \(n\) 个向量 \(\mathbf{x}_1, \ldots, \mathbf{x}_n \in \mathbb{R}^d\)
    组成的集合，堆叠成一个矩阵，每行代表一个数据点。另一个输入 `k` 是期望的簇数。有一个可选输入 `maxiter` 用于最大迭代次数，默认设置为 \(5\)。
- en: We first define separate functions for the two main steps. To find the minimum
    of an array, we use the function [`numpy.argmin`](https://numpy.org/doc/stable/reference/generated/numpy.argmin.html).
    We also use [`numpy.linalg.norm`](https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.html)
    to compute the Euclidean distance.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为两个主要步骤定义单独的函数。为了找到数组的最小值，我们使用函数 `numpy.argmin`。我们还使用 `numpy.linalg.norm`
    来计算欧几里得距离。
- en: '[PRE26]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The main function follows. Below, `rng.integers(0,k,n)` is an array of `n` uniformly
    chosen integers between `0` and `k-1` (inclusive). See [random.Generator.integers](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.integers.html)
    for details. Recall that throughout, when defining a function that uses a random
    number generator (RNG), we initialize the RNG outside the function and pass the
    RNG to it. It allows us to maintain control over the random number generation
    process at a higher level and ensures consistent results across multiple runs.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 主要函数如下。下面，`rng.integers(0,k,n)`是一个包含`n`个在`0`和`k-1`之间（包含）均匀选择的整数的数组。有关详细信息，请参阅[随机生成器.integers](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.integers.html)。回想一下，在整个过程中，当定义一个使用随机数生成器（RNG）的函数时，我们初始化RNG并在函数外部传递它。这允许我们在更高层次上控制随机数生成过程，并确保多次运行的结果一致。
- en: '[PRE27]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**NUMERICAL CORNER:** We apply our implementation of \(k\)-means to the example
    above. We fix `k` to \(3\). Here the data matrix `X` is the following:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**数值角落:** 我们将我们的\(k\)-means实现应用于上面的例子。我们将`k`固定为\(3\)。这里的数据矩阵`X`如下：'
- en: '[PRE28]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We vizualize the output by coloring the points according to their cluster assignment.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过根据点的聚类分配给点着色来可视化输出。
- en: '[PRE30]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![../../_images/cde50ddf06949815c7068a094c7184fa364e644fe65b83769400c3925c47ee23.png](../Images/27a0e5cd18c1654cf2e8093cd3d127f6.png)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/cde50ddf06949815c7068a094c7184fa364e644fe65b83769400c3925c47ee23.png](../Images/27a0e5cd18c1654cf2e8093cd3d127f6.png)'
- en: We can compute the final representatives (optimal for the final assignment)
    by using the subroutine `opt_reps`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用子例程`opt_reps`来计算最终的代表（对于最终分配而言是最优的）。
- en: '[PRE31]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Each row is the center of the corresponding cluster. Note these match with the
    ones we previously computed. Indeed, the clustering is the same (although not
    necessarily in the same order).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行是相应聚类的中心。注意这些与之前计算出的匹配。确实，聚类是相同的（尽管不一定按相同的顺序）。
- en: '**TRY IT!** Modify `kmeans` to take a tolerance `tol` as input and stop when
    the improvement in objective value `G` falls below the tolerance. ([Open in Colab](https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_intro_notebook.ipynb))'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下!** 修改`kmeans`以接受一个容差`tol`作为输入，并在目标值`G`的改进低于容差时停止。([在Colab中打开](https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_intro_notebook.ipynb))'
- en: \(\unlhd\)
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: \(\unlhd\)
- en: '![Evolution of the assignment for -means clustering on data generated by a
    mixture of spherical Gaussians with variance  and respective means  and . The
    crosses show the cluster representatives. The objective value is shown as . (With
    help from Claude; inspired by (Source).)](../Images/2c9ccfca527fcd49962e30d8a67f4fdb.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![由球面高斯混合生成的数据上的-means聚类分配的演变，方差为，相应的均值为和。交叉点表示聚类代表。目标值显示为。 (由Claude协助；受(SOURCE)启发)](../Images/2c9ccfca527fcd49962e30d8a67f4fdb.png)'
- en: '**KNOWLEDGE CHECK:** Suppose we have infinite computational resources and run
    Lloyd’s algorithm forever, do you think it will necessarily converge to a global
    minimum? If your answer is no, can you think of an alternative algorithm that
    is guaranteed to output a global minimum provided enough computational resources?
    \(\checkmark\)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '**知识检查:** 假设我们拥有无限的计算资源并且无限期地运行Lloyd算法，你认为它一定会收敛到全局最小值吗？如果你的答案是“不”，你能想到一个在足够计算资源下保证输出全局最小值的替代算法吗？
    \(\checkmark\)'
- en: Lloyd’s algorithm is only a heuristic. In particular, it is not guaranteed to
    find the global minimum of the \(k\)-means objective. However, it is guaranteed
    to improve the objective at every iteration, or more precisely, not to make it
    worse.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: Lloyd算法只是一个启发式算法。特别是，它不能保证找到\(k\)-means目标函数的全局最小值。然而，它保证在每次迭代中改进目标函数，或者更精确地说，不会使其变得更糟。
- en: '**THEOREM** **(Convergence of \(k\)-means cost)** \(\idx{convergence of k-means
    cost theorem}\xdi\) The sequence of objective function values produced by the
    \(k\)-means algorithm is non-increasing. \(\sharp\)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**定理** **(\(k\)-means成本的收敛)** \(\idx{convergence of k-means cost theorem}\xdi\)
    \(k\)-means算法产生的目标函数值序列是非递增的。 \(\sharp\)'
- en: '*Proof idea:* By the *Optimal Representatives Lemma* and the *Optimal Clustering
    Lemma*, each step does not increase the objective.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明思路:* 通过*最优代表引理*和*最优聚类引理*，每一步都不会增加目标函数。'
- en: '*Proof:* Let \(C_1'',\ldots,C_k''\) be the current clusters, with representatives
    \(\boldsymbol{\mu}_1'',\ldots,\boldsymbol{\mu}_k''\). After Step 1, the new representatives
    are \(\boldsymbol{\mu}_1'''',\ldots,\boldsymbol{\mu}_k''''\). By the *Optimal
    Representatives Lemma*, they satisfy'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '*证明*：设 \(C_1'',\ldots,C_k''\) 为当前聚类，其代表为 \(\boldsymbol{\mu}_1'',\ldots,\boldsymbol{\mu}_k''\)。在第一步之后，新的代表为
    \(\boldsymbol{\mu}_1'''',\ldots,\boldsymbol{\mu}_k''''\)。根据*最优代表引理*，它们满足'
- en: \[ \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
    \leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i'\|^2.
    \]
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
    \leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i'\|^2.
    \]
- en: After Step 2, the new clusters are \(C_1'',\ldots,C_k''\). By the *Optimal Clustering
    Lemma*, they satisfy
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步之后，新的聚类为 \(C_1'',\ldots,C_k''\)。根据*最优聚类引理*，它们满足
- en: \[ \sum_{i=1}^k \sum_{j \in C_i''} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
    \leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2.
    \]
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \sum_{i=1}^k \sum_{j \in C_i''} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
    \leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2.
    \]
- en: Combining these two inequalities gives
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个不等式结合给出
- en: \[ \sum_{i=1}^k \sum_{j \in C_i''} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
    \leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i'\|^2,
    \]
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \sum_{i=1}^k \sum_{j \in C_i''} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
    \leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i'\|^2,
    \]
- en: as claimed. \(\square\)
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如所声称。 \(\square\)
- en: The sequence of objective values is monotone and bounded from below by \(0\).
    [Hence it converges](https://en.wikipedia.org/wiki/Monotone_convergence_theorem#Convergence_of_a_monotone_sequence_of_real_numbers).
    Note that the limit depends on the starting point.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 目标值的序列是单调的，并且从下限 \(0\) 有界。[因此它收敛](https://en.wikipedia.org/wiki/Monotone_convergence_theorem#Convergence_of_a_monotone_sequence_of_real_numbers)。请注意，极限取决于起点。
- en: '**CHAT & LEARN** AI chatbots can serve as great personal tutors, especially
    when it comes to coding which they often excel at. In particular, they can provide
    additional information about the code in this book. Just copy-paste a piece of
    code and ask “What is this code doing?” Don’t hesitate to ask follow-up questions.
    [Here is an example using ChatGPT](https://chat.openai.com/share/66f9e704-c8e8-4489-9ab6-8e57740cab3b).'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '**聊天与学习** AI 聊天机器人可以成为优秀的个人导师，尤其是在编程方面，它们通常表现出色。特别是，它们可以提供关于本书中代码的额外信息。只需复制粘贴一段代码并询问“这段代码在做什么？”不要犹豫继续提问。[这里是一个使用
    ChatGPT 的例子](https://chat.openai.com/share/66f9e704-c8e8-4489-9ab6-8e57740cab3b)。'
- en: '*Warning:* As you probably know, AI chatbots can be wrong so assess what they
    tell you with a critical mind and/or double-check with other sources (e.g., package
    documentation).'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '*警告*：正如你可能知道的，AI 聊天机器人可能会出错，所以用批判性的思维评估他们告诉你的内容，并且/或者用其他来源（例如，包文档）进行双重检查。'
- en: '*Prompt engineering:* [Finding the right prompt](https://en.wikipedia.org/wiki/Prompt_engineering),
    or series of prompts, can make a big difference. It can also be used to produce
    more interesting answers. Here is an explanation of the \(k\)-means algorithm
    in the style of Shakespeare via ChatGPT:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示工程*：[寻找正确的提示](https://en.wikipedia.org/wiki/Prompt_engineering)，或一系列提示，可以产生重大影响。它也可以用来产生更有趣的答案。以下是通过
    ChatGPT 以莎士比亚风格解释 \(k\)-均值算法的说明：'
- en: '**Scene: The Realm of Numerica, in the Enchanted Forest of Analysis**'
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**场景：数值领域，在分析的魔法森林中**'
- en: ''
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Enter LORD VECTOR, LADY PARTITION, and an assembly of WHISPERING WINDS*'
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*向量大人，分区女士，以及一群窃窃私语的微风*'
- en: ''
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LORD VECTOR (a majestic entity):'
  id: totrans-480
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**向量大人（一个庄严的存在）**：'
- en: ''
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hearken, Whispering Winds, scattered far and wide,
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 倾听，远处的窃窃私语的微风，
- en: ''
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I am Lord Vector, your anchor and your guide.
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我是向量大人，你的锚和你的向导。
- en: ''
  id: totrans-485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In clusters, you must settle, by my call and by my side,
  id: totrans-486
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在聚类中，你必须根据我的召唤和我的陪伴定居，
- en: ''
  id: totrans-487
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To me, you’ll draw nigh, in unity, abide.
  id: totrans-488
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对我来说，你将靠近，在统一中居住。
- en: ''
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LADY PARTITION (a sage enchantress):'
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**分区女士（一位睿智的魔法女巫）**：'
- en: ''
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And I, Lady Partition, with vision clear and keen,
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我，分区女士，目光清晰而敏锐，
- en: ''
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Determine where amongst the clusters each of you shall lean.
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确定你们每个人在聚类中应该偏向何处。
- en: ''
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With Lord Vector, a ballet we compose, with steps so fine,
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与向量大人一起，我们编排了一支芭蕾舞，舞步如此精致，
- en: ''
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To sort, to gather, to align, under a sign divine.
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要排序，要聚集，要对齐，在神圣的标志下。
- en: ''
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'WHISPERING WIND 1:'
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**窃窃私语的微风 1**：'
- en: ''
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: But how, noble Vector, wilt thou find thy rightful stead?
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但是，尊贵的向量，你将如何找到你的正确位置？
- en: ''
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this expanse diverse, how set thy bed?
  id: totrans-504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这片广阔的土地上，你将如何安放你的床？
- en: ''
  id: totrans-505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LORD VECTOR:'
  id: totrans-506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**向量大人**：'
- en: ''
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Through cycles and through wisdom, I seek my sacred ground,
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过循环和智慧，我寻求我的神圣之地，
- en: ''
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Where the sum of all distances to me is least found.
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在我这里找到所有距离之和最少的地点。
- en: ''
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From your essence, I emerge, an average pure and sound,
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从你们的本质中，我浮现，一个纯粹而平均的存在，
- en: ''
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A beacon most true, by which I am crowned.
  id: totrans-514
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一座最真实的灯塔，我以此加冕。
- en: ''
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'WHISPERING WIND 2:'
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'WHISPERING WIND 2:'
- en: ''
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And Lady Partition, how do we seek our kin,
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 而LADY PARTITION，我们如何寻找我们的亲人，
- en: ''
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this multitude, how does our journey begin?
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这众多之中，我们的旅程如何开始？
- en: ''
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LADY PARTITION:'
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'LADY PARTITION:'
- en: ''
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By measure and affinity, to your closest Lord Vector, you’ll gravitate,
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过度量与亲和力，你们将向你们最近的LORD VECTORS引力，
- en: ''
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To him, your allegiance, you’ll consecrate.
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 向他，你们将奉献你们的忠诚。
- en: ''
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In groups, you’ll assemble, by likeness you’re drawn,
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在群体中，你们将聚集，因相似而吸引，
- en: ''
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A collective symphony, from dusk till dawn.
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从黄昏到黎明的集体交响乐。
- en: ''
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*LORD VECTOR and LADY PARTITION assume their roles, guiding the WHISPERING
    WINDS to move and regroup.*'
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*LORD VECTOR和LADY PARTITION扮演他们的角色，引导轻声细语的风移动和重组。*'
- en: ''
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LORD VECTOR:'
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'LORD VECTOR:'
- en: ''
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe now how I traverse, as your allegiances refine,
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，我观察我如何穿越，随着你们的忠诚细化，
- en: ''
  id: totrans-537
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A center more apt, in this spell of mine.
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在我的咒语中，一个更合适的中心。
- en: ''
  id: totrans-539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LADY PARTITION:'
  id: totrans-540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'LADY PARTITION:'
- en: ''
  id: totrans-541
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And as you drift, dear winds, to your Lords true,
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你们飘向，亲爱的风，你们真正的君主，
- en: ''
  id: totrans-543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A closer union we construe, a balance anew.
  id: totrans-544
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们构建更紧密的联盟，重新平衡。
- en: ''
  id: totrans-545
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The WHISPERING WINDS shuffle and align, moving from one cluster to another,
    as LORD VECTOR adjusts his position with grace.*'
  id: totrans-546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*轻声细语的风在LORD VECTOR优雅地调整位置的同时，从一个聚类移动到另一个聚类，重新排列。*'
- en: ''
  id: totrans-547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'WHISPERING WIND 3:'
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'WHISPERING WIND 3:'
- en: ''
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At length, I perceive, where I am to dwell,
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，我意识到我将居住在哪里，
- en: ''
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With peers akin, in cluster well.
  id: totrans-552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与相似者一起，在良好的聚类中。
- en: ''
  id: totrans-553
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LORD VECTOR:'
  id: totrans-554
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'LORD VECTOR:'
- en: ''
  id: totrans-555
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So we dance and weave, ‘til stillness we achieve,
  id: totrans-556
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，我们跳舞和编织，直到我们达到静止，
- en: ''
  id: totrans-557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When each wind has settled, and we, in relief.
  id: totrans-558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当每一阵风都平静下来，我们，在放松中。
- en: ''
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LADY PARTITION:'
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'LADY PARTITION:'
- en: ''
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Thus, optimal clusters come forth, vivid and serene,
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，最优的聚类出现，生动而宁静，
- en: ''
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With centers well placed, a sight unseen.
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 中心位置良好，景象未见。
- en: ''
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The WHISPERING WINDS now rest peacefully in clusters around their LORD VECTORS,
    the Enchanted Forest of Analysis a testament to their orderly ballet.*'
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*现在，轻声细语的风在它们的主向量周围平静地休息，分析的魔幻森林是它们有序芭蕾的见证。*'
- en: ''
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'LORD VECTOR & LADY PARTITION (together):'
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: LORD VECTOR & LADY PARTITION（一起）：
- en: ''
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Our task here concludes, with harmony and grace,
  id: totrans-570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们的任务在这里结束，和谐而优雅，
- en: ''
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The K-means enchantment, a solution embraced.
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: K-means魔法，一个被接受的解决方案。
- en: ''
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Exeunt omnes, as the WHISPERING WINDS repose in unity around their LORD VECTORS,
    the realm of Numerica reflecting their harmonious dance.*'
  id: totrans-574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*所有人退出，当轻声细语的风在它们的主向量周围统一休息时，数字领域反映了它们和谐的舞蹈。*'
- en: ''
  id: totrans-575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**End of Scene**'
  id: totrans-576
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**场景结束**'
- en: \(\ddagger\)
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: \(\ddagger\)
- en: '**NUMERICAL CORNER:** We will test our implementation of \(k\)-means on the
    penguins dataset introduced earlier in the chapter. We first extract the columns
    and combine them into a data matrix `X`. As we did previously, we also remove
    the rows with missing values.'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '**数值角落：**我们将测试我们在本章早期引入的企鹅数据集上对k-means的实现。我们首先提取列并将它们组合成一个数据矩阵`X`。像之前一样，我们也移除了有缺失值的行。'
- en: '**Figure:** Which penguin species? (*Credit:* Made with [Midjourney](https://www.midjourney.com/))'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '**图示：哪种企鹅物种？(*来源：Midjourney制作*)**'
- en: '![Penguins on a glacier](../Images/bb7e8602c95a01b1185de572b4c55ec8.png)'
  id: totrans-580
  prefs: []
  type: TYPE_IMG
  zh: '![冰川上的企鹅](../Images/bb7e8602c95a01b1185de572b4c55ec8.png)'
- en: \(\bowtie\)
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: \(\bowtie\)
- en: '[PRE33]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We visualize a two-dimensional slice of the data.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可视化数据的二维切片。
- en: '[PRE34]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![../../_images/024d26811e4631ac8dcb5acb1d23f5c577193d3217b2493260af97e706f2b329.png](../Images/e75683392ec1e758370886f76273bfb6.png)'
  id: totrans-585
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/024d26811e4631ac8dcb5acb1d23f5c577193d3217b2493260af97e706f2b329.png](../Images/e75683392ec1e758370886f76273bfb6.png)'
- en: Observe that the features have quite different scales (tens versus thousands
    in the plot above). In such a case, it is common to standardize the data so that
    each feature has roughly the same scale. For each column of `X`, we subtract its
    empirical mean and divide by its empirical standard deviation.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到特征具有相当不同的尺度（上图中的十与千）。在这种情况下，通常会对数据进行标准化，以便每个特征大致具有相同的尺度。对于`X`的每一列，我们减去其实验均值，然后除以其实验标准差。
- en: '[PRE35]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now we run Lloyd’s algorithm with \(k=2\) clusters.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行Lloyd算法，有2个聚类。
- en: '[PRE36]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We vizualize the output as we did before, but this time coloring the data points
    by their cluster assignment.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像之前一样可视化输出，但这次根据它们的聚类分配给数据点着色。
- en: '[PRE38]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![../../_images/c8ce542a010e33ab2c018c7c7624c391c5b57fa97d97a1146013f2c8d77068de.png](../Images/828f36ddad8cd4ead1a7000754909d59.png)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/c8ce542a010e33ab2c018c7c7624c391c5b57fa97d97a1146013f2c8d77068de.png](../Images/828f36ddad8cd4ead1a7000754909d59.png)'
- en: 'This clustering looks quite good. Nevertheless recall that:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 这种聚类看起来相当不错。然而，请记住：
- en: in this plot we are looking at only two of the four variables while \(k\)-means
    uses all of them,
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个图中，我们只查看四个变量中的两个，而 \(k\)-means 使用所有这些变量，
- en: we are not guaranteed to find the best solution,
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能保证找到最佳解决方案，
- en: our objective function is somewhat arbitrary, and
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的目标函数有些随意，
- en: it is not clear what the right choice of \(k\) is.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并不清楚正确的 \(k\) 值选择是什么。
- en: In fact, the original dataset contained the correct answer, as provided by biologists.
    Despite what the figure above may lead us to believe, there are in reality three
    separate species. So let us try with \(k=3\) clusters.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，原始数据集中包含了生物学家提供的正确答案。尽管上面的图可能让我们相信，实际上有三个不同的物种。所以让我们尝试使用 \(k=3\) 个聚类。
- en: '[PRE39]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The output does not seem quite right.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来并不完全正确。
- en: '[PRE41]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![../../_images/7383cabd085a8a7eba9545c89a27d27d31401b0dc50cd001fbe5cfc405e9131c.png](../Images/0cf53aabbe4e2f47806ce1ae1b6cde65.png)'
  id: totrans-604
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/7383cabd085a8a7eba9545c89a27d27d31401b0dc50cd001fbe5cfc405e9131c.png](../Images/0cf53aabbe4e2f47806ce1ae1b6cde65.png)'
- en: But, remembering the warnings mentioned previously, let us look at a different
    two-dimensional slice.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，记住之前提到的警告，让我们看看不同的二维切片。
- en: '[PRE42]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![../../_images/62dde40d80824421548718832e220f969d2f9a28a560918552424440517b225e.png](../Images/9702034e7031f67493cefa19852b584d.png)'
  id: totrans-607
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/62dde40d80824421548718832e220f969d2f9a28a560918552424440517b225e.png](../Images/9702034e7031f67493cefa19852b584d.png)'
- en: Let us load up the truth and compare. We only keep those samples that were not
    removed because of missing values (see [`pandas.DataFrame.iloc`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html)).
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加载真实情况并比较。我们只保留那些由于缺失值而没有被移除的样本（参见[`pandas.DataFrame.iloc`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html)）。
- en: '[PRE43]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|  | species |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '|  | 物种 |'
- en: '| --- | --- |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | Adelie |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 阿黛利企鹅 |'
- en: '| 1 | Adelie |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 阿黛利企鹅 |'
- en: '| 2 | Adelie |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 阿黛利企鹅 |'
- en: '| 4 | Adelie |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 阿黛利企鹅 |'
- en: '| 5 | Adelie |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 阿黛利企鹅 |'
- en: 'The species are:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 物种是：
- en: '[PRE44]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: To plot the outcome, we color the species blue-green-red using a [dictionary](https://docs.python.org/3/tutorial/datastructures.html#dictionaries).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制结果，我们使用[字典](https://docs.python.org/3/tutorial/datastructures.html#dictionaries)将物种颜色设置为蓝绿色-红色。
- en: '[PRE46]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finally, we can compare the output to the truth. The match is quite good – but
    certainly not perfect.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将输出与真实情况进行比较。匹配度相当好——但当然不是完美的。
- en: '[PRE47]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![../../_images/00f2abf0740c5bf6a562d8f607ab3a6d116d7ba0e1b03f9e035f875e36954e86.png](../Images/1de9d394fa9649dc467bc539e8b0de94.png)'
  id: totrans-624
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/00f2abf0740c5bf6a562d8f607ab3a6d116d7ba0e1b03f9e035f875e36954e86.png](../Images/1de9d394fa9649dc467bc539e8b0de94.png)'
- en: 'Determining the appropriate number of clusters is not a straighforward problem.
    To quote [Wikipedia](https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set):'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 确定合适的聚类数量不是一个简单的问题。引用[维基百科](https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set)：
- en: The correct choice of \(k\) is often ambiguous, with interpretations depending
    on the shape and scale of the distribution of points in a data set and the desired
    clustering resolution of the user. In addition, increasing \(k\) without penalty
    will always reduce the amount of error in the resulting clustering, to the extreme
    case of zero error if each data point is considered its own cluster (i.e., when
    \(k\) equals the number of data points, \(n\)). Intuitively then, the optimal
    choice of \(k\) will strike a balance between maximum compression of the data
    using a single cluster, and maximum accuracy by assigning each data point to its
    own cluster. If an appropriate value of \(k\) is not apparent from prior knowledge
    of the properties of the data set, it must be chosen somehow. There are several
    categories of methods for making this decision.
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正确选择 \(k\) 值通常是不明确的，其解释取决于数据集中点的形状和尺度以及用户期望的聚类分辨率。此外，不进行惩罚地增加 \(k\) 值将始终减少结果聚类的错误量，在极端情况下，如果每个数据点被视为自己的聚类（即当
    \(k\) 等于数据点的数量 \(n\) 时），错误量将降至零。因此，从数据集属性的前知知识中不明显地选择 \(k\) 值时，必须以某种方式选择。有几种方法类别用于做出这个决定。
- en: In practice, [several heuristics](https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set)
    are in use. Other approaches to clustering, e.g. [DBSCAN](https://en.wikipedia.org/wiki/DBSCAN)
    and [hierarchical clustering](https://en.wikipedia.org/wiki/Hierarchical_clustering),
    do not require a number of clusters as input.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，[几种启发式方法](https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set)正在使用。其他聚类方法，例如[DBSCAN](https://en.wikipedia.org/wiki/DBSCAN)和[层次聚类](https://en.wikipedia.org/wiki/Hierarchical_clustering)，不需要输入聚类数量。
- en: '**TRY IT!** Run the analysis again, but this time *without the standardization
    step*. What do you observe? Is one feature more influential on the final output
    than the others? Why do you think that is? ([Open in Colab](https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_intro_notebook.ipynb))'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下！** 再次运行分析，但这次 *不进行标准化步骤*。你观察到了什么？是否有某个特征比其他特征对最终输出更有影响？你为什么这么认为？([在
    Colab 中打开](https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_intro_notebook.ipynb))'
- en: \(\unlhd\)
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: \(\unlhd\)
- en: 1.3.3\. Matrix form of k-means clustering[#](#matrix-form-of-k-means-clustering
    "Link to this heading")
  id: totrans-630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3.3\. k-均值聚类的矩阵形式[#](#matrix-form-of-k-means-clustering "链接到本标题")
- en: In this section, we show that the \(k\)-means clustering objective can be written
    in matrix form. We start with some notation and definitions that will be useful
    throughout.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示 \(k\)-均值聚类的目标可以写成矩阵形式。我们首先介绍一些在整个过程中都会用到的符号和定义。
- en: As we indicated before, for a collection of \(n\) data vectors \(\mathbf{x}_1,
    \ldots, \mathbf{x}_n\) in \(\mathbb{R}^d\), it is often convenient to stack them
    up into a matrix
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所指示的，对于一组 \(n\) 个数据向量 \(\mathbf{x}_1, \ldots, \mathbf{x}_n\) 在 \(\mathbb{R}^d\)
    中，将它们堆叠成一个矩阵通常很方便
- en: \[\begin{split} X = \begin{bmatrix} \mathbf{x}_1^T \\ \mathbf{x}_2^T \\ \vdots
    \\ \mathbf{x}_n^T \\ \end{bmatrix} = \begin{bmatrix} x_{11} & x_{12} & \cdots
    & x_{1d} \\ x_{21} & x_{22} & \cdots & x_{2d} \\ \vdots & \vdots & \ddots & \vdots
    \\ x_{n1} & x_{n2} & \cdots & x_{nd} \\ \end{bmatrix}. \end{split}\]
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} X = \begin{bmatrix} \mathbf{x}_1^T \\ \mathbf{x}_2^T \\ \vdots
    \\ \mathbf{x}_n^T \\ \end{bmatrix} = \begin{bmatrix} x_{11} & x_{12} & \cdots
    & x_{1d} \\ x_{21} & x_{22} & \cdots & x_{2d} \\ \vdots & \vdots & \ddots & \vdots
    \\ x_{n1} & x_{n2} & \cdots & x_{nd} \\ \end{bmatrix}. \end{split}\]
- en: We can do the same with cluster representatives. Given \(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k\)
    also in \(\mathbb{R}^d\), we form the matrix
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用簇代表来做同样的事情。给定 \(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k\) 也位于 \(\mathbb{R}^d\)
    中，我们形成矩阵
- en: \[\begin{split} U = \begin{bmatrix} \boldsymbol{\mu}_1^T \\ \boldsymbol{\mu}_2^T
    \\ \vdots \\ \boldsymbol{\mu}_k^T \\ \end{bmatrix} = \begin{bmatrix} \mu_{11}
    & \mu_{12} & \cdots & \mu_{1d} \\ \mu_{21} & \mu_{22} & \cdots & \mu_{2d} \\ \vdots
    & \vdots & \ddots & \vdots \\ \mu_{k1} & \mu_{k2} & \cdots & \mu_{kd} \\ \end{bmatrix}.
    \end{split}\]
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} U = \begin{bmatrix} \boldsymbol{\mu}_1^T \\ \boldsymbol{\mu}_2^T
    \\ \vdots \\ \boldsymbol{\mu}_k^T \\ \end{bmatrix} = \begin{bmatrix} \mu_{11}
    & \mu_{12} & \cdots & \mu_{1d} \\ \mu_{21} & \mu_{22} & \cdots & \mu_{2d} \\ \vdots
    & \vdots & \ddots & \vdots \\ \mu_{k1} & \mu_{k2} & \cdots & \mu_{kd} \\ \end{bmatrix}.
    \end{split}\]
- en: Perhaps less obviously, cluster assignments can also be encoded in matrix form.
    Recall that, given a partition \(C_1,\ldots,C_k\) of \([n]\), we define \(c(j)
    = i\) if \(j \in C_i\). For \(j=1,\ldots,n\) and \(\ell=1,\ldots,k\), set \(Z_{j\ell}
    = 1\) if \(c(j) = \ell\) and \(0\) otherwise, and let \(Z\) be the \(n \times
    k\) matrix with entries \(Z = [Z_{j\ell}]_{j,\ell}\). That is, row \(j\) has exactly
    one entry with value \(1\), corresponding to the assigned cluster \(c(j)\) of
    data point \(\mathbf{x}_j\), and all other entries \(0\).
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不那么明显的是，簇分配也可以用矩阵形式表示。回想一下，给定 \([n]\) 的划分 \(C_1,\ldots,C_k\)，我们定义 \(c(j) =
    i\) 如果 \(j \in C_i\)。对于 \(j=1,\ldots,n\) 和 \(\ell=1,\ldots,k\)，如果 \(c(j) = \ell\)
    则设置 \(Z_{j\ell} = 1\)，否则为 \(0\)，让 \(Z\) 是一个 \(n \times k\) 的矩阵，其元素 \(Z = [Z_{j\ell}]_{j,\ell}\)。也就是说，行
    \(j\) 有且只有一个值为 \(1\) 的元素，对应于数据点 \(\mathbf{x}_j\) 分配的簇 \(c(j)\)，其他所有元素为 \(0\)。
- en: With this notation, the representative of the cluster assigned to data point
    \(\mathbf{x}_j\) is obtained through a matrix product
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个符号，分配给数据点 \(\mathbf{x}_j\) 的簇的代表通过矩阵乘积获得
- en: \[ \boldsymbol{\mu}_{c(j)}^T = \sum_{\ell = 1}^k Z_{j\ell} \boldsymbol{\mu}_{\ell}^T
    = \sum_{\ell = 1}^k Z_{j\ell} U_{\ell,\cdot} = \left(Z U\right)_{j,\cdot} \]
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \boldsymbol{\mu}_{c(j)}^T = \sum_{\ell = 1}^k Z_{j\ell} \boldsymbol{\mu}_{\ell}^T
    = \sum_{\ell = 1}^k Z_{j\ell} U_{\ell,\cdot} = \left(Z U\right)_{j,\cdot} \]
- en: where we used that the \(j\)-th row of a matrix product is a linear combination
    of the rows of the second matrix, where the coefficients are the entries on the
    \(j\)-th row of the first one.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 其中我们使用了矩阵乘积的第 \(j\) 行是第二个矩阵的行的线性组合的性质，其中系数是第一个矩阵第 \(j\) 行的元素。
- en: '**EXAMPLE:** **(continued)** Continuing with our previous example, the clusters
    \(C_1 = \{1, 4, 6, 8\}, C_2 = \{2, 3, 7\}, C_3 = \{5\}\) are encoded as the matrix'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：** **（继续）** 继续使用我们之前的例子，簇 \(C_1 = \{1, 4, 6, 8\}, C_2 = \{2, 3, 7\}, C_3
    = \{5\}\) 被编码为矩阵'
- en: \[\begin{split} Z = \begin{bmatrix} 1 & 0 & 0\\ 0 & 1 & 0\\ 0 & 1 & 0\\ 1 &
    0 & 0\\ 0 & 0 & 1\\ 1 & 0 & 0\\ 0 & 1 & 0\\ 1 & 0 & 0 \end{bmatrix}. \end{split}\]
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} Z = \begin{bmatrix} 1 & 0 & 0\\ 0 & 1 & 0\\ 0 & 1 & 0\\ 1 &
    0 & 0\\ 0 & 0 & 1\\ 1 & 0 & 0\\ 0 & 1 & 0\\ 1 & 0 & 0 \end{bmatrix}. \end{split}\]
- en: Suppose again that the representatives are
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 再次假设代表者是
- en: \[\begin{split} \boldsymbol{\mu}_1 = \begin{pmatrix}-2\\1\end{pmatrix}, \boldsymbol{\mu}_2
    = \begin{pmatrix}2\\-1\end{pmatrix}, \boldsymbol{\mu}_3 = \begin{pmatrix}-10\\10\end{pmatrix}.
    \end{split}\]
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} \boldsymbol{\mu}_1 = \begin{pmatrix}-2\\1\end{pmatrix}, \boldsymbol{\mu}_2
    = \begin{pmatrix}2\\-1\end{pmatrix}, \boldsymbol{\mu}_3 = \begin{pmatrix}-10\\10\end{pmatrix}.
    \end{split}\]
- en: The corresponding matrix \(U\) is then
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 那么相应的矩阵 \(U\) 是
- en: \[\begin{split} U = \begin{bmatrix} -2 & 1\\ 2 & -1\\ -10 & 10 \end{bmatrix}.
    \end{split}\]
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} U = \begin{bmatrix} -2 & 1\\ 2 & -1\\ -10 & 10 \end{bmatrix}.
    \end{split}\]
- en: Hence multiplying \(Z\) and \(U\) produces a matrix where each row is the representative
    of the assigned cluster of the corresponding data point
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，乘以 \(Z\) 和 \(U\) 产生一个矩阵，其中每一行是相应数据点分配的簇的代表
- en: \[\begin{split} ZU = \begin{bmatrix} 1 & 0 & 0\\ 0 & 1 & 0\\ 0 & 1 & 0\\ 1 &
    0 & 0\\ 0 & 0 & 1\\ 1 & 0 & 0\\ 0 & 1 & 0\\ 1 & 0 & 0 \end{bmatrix} \, \begin{bmatrix}
    -2 & 1\\ 2 & -1\\ -10 & 10 \end{bmatrix} = \begin{bmatrix} -2 & 1\\ 2 & -1\\ 2
    & -1\\ -2 & 1\\ -10 & 10\\ -2 & 1\\ 2 & -1\\ -2 & 1 \end{bmatrix}. \end{split}\]
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} ZU = \begin{bmatrix} 1 & 0 & 0\\ 0 & 1 & 0\\ 0 & 1 & 0\\ 1 &
    0 & 0\\ 0 & 0 & 1\\ 1 & 0 & 0\\ 0 & 1 & 0\\ 1 & 0 & 0 \end{bmatrix} \, \begin{bmatrix}
    -2 & 1\\ 2 & -1\\ -10 & 10 \end{bmatrix} = \begin{bmatrix} -2 & 1\\ 2 & -1\\ 2
    & -1\\ -2 & 1\\ -10 & 10\\ -2 & 1\\ 2 & -1\\ -2 & 1 \end{bmatrix}. \end{split}\]
- en: \(\lhd\)
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: \(\lhd\)
- en: Recall that the Frobenius norm of an \(n \times m\) matrix \(A \in \mathbb{R}^{n
    \times m}\) is defined as
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，\(n \times m\) 矩阵 \(A \in \mathbb{R}^{n \times m}\) 的Frobenius范数定义为
- en: \[ \|A\|_F = \sqrt{\sum_{i=1}^n \sum_{j=1}^m A_{ij}^2}. \]
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \|A\|_F = \sqrt{\sum_{i=1}^n \sum_{j=1}^m A_{ij}^2}. \]
- en: Using row notation, it can be written as the sum of the squared Euclidean norms
    of the rows
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 使用行表示法，它可以写成行平方欧几里得范数的和
- en: \[ \|A\|_F^2 = \sum_{i=1}^n \|A_{i,\cdot}\|^2. \]
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \|A\|_F^2 = \sum_{i=1}^n \|A_{i,\cdot}\|^2. \]
- en: For two matrices \(A, B \in \mathbb{R}^{n \times m}\), the Frobenius norm of
    their difference \(\|A - B\|_F\) can be interpreted as a distance between \(A\)
    and \(B\), that is, a measure of how dissimilar they are.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个矩阵 \(A, B \in \mathbb{R}^{n \times m}\)，它们的差 \(A - B\) 的Frobenius范数 \(\|A
    - B\|_F\) 可以解释为 \(A\) 和 \(B\) 之间的距离，即它们差异的度量。
- en: Finally, we return to the \(k\)-means objective. Using the notation introduced
    in this section and the equivalent formula for the objective \(G\) derived in
    the proof of the *Optimal Clustering Lemma*, we note that
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回到 \(k\)-means 目标。使用本节中引入的符号和证明 *最优聚类引理* 中推导出的目标 \(G\) 的等价公式，我们注意到
- en: \[\begin{align*} G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k)
    &= \sum_{i=1}^n \|\mathbf{x}_i - \boldsymbol{\mu}_{c(i)}\|^2\\ &= \sum_{i=1}^n
    \sum_{\ell=1}^d \left(x_{i\ell} - (Z U)_{i\ell}\right)^2\\ &= \|X - Z U \|^2_F,
    \end{align*}\]
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{align*} G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k)
    &= \sum_{i=1}^n \|\mathbf{x}_i - \boldsymbol{\mu}_{c(i)}\|^2\\ &= \sum_{i=1}^n
    \sum_{\ell=1}^d \left(x_{i\ell} - (Z U)_{i\ell}\right)^2\\ &= \|X - Z U \|^2_F,
    \end{align*}\]
- en: where we used the definition of the Frobenius norm.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 其中我们使用了Frobenius范数的定义。
- en: In other words, minimizing the \(k\)-means objective is equivalent to finding
    a matrix factorization of the form \(ZU\) that is a good fit to the data matrix
    \(X\) in Frobenius norm. This formulation expresses in a more compact form the
    idea of representing \(X\) as a combination of a small number of representatives.
    Matrix factorization will come back repeatedly in this course.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，最小化 \(k\)-means 目标等价于找到一个形式为 \(ZU\) 的矩阵分解，使其与数据矩阵 \(X\) 在Frobenius范数下拟合良好。这种公式以更紧凑的形式表达了将
    \(X\) 表示为少数几个代表者的想法。矩阵分解将在本课程中反复出现。
- en: '***Self-assessment quiz*** *(with help from Claude, Gemini, and ChatGPT)*'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '***自我评估测验*** *(在克劳德、双子星和ChatGPT的帮助下)*'
- en: '**1** Which of these is NOT a property of a valid partition \(C_1, \ldots,
    C_k\) in the context of \(k\)-means?'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '**1** 以下哪项不是 \(k\)-means 上下文中有效划分 \(C_1, \ldots, C_k\) 的属性？'
- en: a) The subsets are pairwise disjoint
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: a) 子集是两两不相交的
- en: b) The subsets cover all data points
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: b) 子集覆盖所有数据点
- en: c) Each subset is non-empty
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: c) 每个子集非空
- en: d) Each subset contains an equal number of points
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: d) 每个子集包含相同数量的点
- en: '**2** In the \(k\)-means objective function, what does the variable \(\boldsymbol{\mu}_i\)
    represent?'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '**2** 在 \(k\)-means 目标函数中，变量 \(\boldsymbol{\mu}_i\) 代表什么？'
- en: a) The centroid of cluster \(i\)
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: a) 簇 \(i\) 的质心
- en: b) The number of points in cluster \(i\)
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: b) 簇 \(i\) 中的点数
- en: c) The distance between clusters \(i\) and \(j\)
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: c) 簇 \(i\) 和 \(j\) 之间的距离
- en: d) The assignment of point \(j\) to a cluster
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: d) 将点 \(j\) 分配到簇中
- en: '**3** The \(k\)-means objective function is a measure of what?'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '**3** \(k\)-means 目标函数是衡量什么的？'
- en: a) The total number of clusters.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: a) 簇的总数。
- en: b) The average distance between data points.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: b) 数据点之间的平均距离。
- en: c) The sum of squared distances between each data point and its assigned cluster
    center.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: c) 每个数据点到其分配的簇中心的平方距离之和。
- en: d) The maximum distance between any two cluster centers.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: d) 任何两个簇中心之间的最大距离。
- en: '**4** What is a key property of the sequence of objective function values produced
    by the \(k\)-means algorithm?'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '**4** \(k\)-means 算法产生的目标函数值序列的关键属性是什么？'
- en: a) It is strictly decreasing
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: a) 它是严格递减的
- en: b) It is non-increasing
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: b) 它是非递增的
- en: c) It is strictly increasing
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: c) 它是严格递增的
- en: d) It alternates between two values
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: d) 它在两个值之间交替
- en: '**5** What is the interpretation of the matrix \(Z\) in the matrix formulation
    of \(k\)-means?'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '**5** 在 \(k\)-means 的矩阵公式中，矩阵 \(Z\) 的解释是什么？'
- en: a) It represents the cluster centers.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: a) 它表示簇中心。
- en: b) It represents the distances between data points.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: b) 它表示数据点之间的距离。
- en: c) It encodes the cluster assignments of each data point.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: c) 它编码了每个数据点的簇分配。
- en: d) It represents the covariance matrix of the data.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: d) 它表示数据的协方差矩阵。
- en: 'Answer for 1: d. Justification: “Formally, we define a clustering as a partition.
    A partition of \([n] = {1,\ldots,n}\) of size \(k\) is a collection of non-empty
    subsets \(C_1,\ldots,C_k \subseteq [n]\) that: are pairwise disjoint, i.e., \(C_i
    \cap C_j = \emptyset\), \(\forall i \neq j\); cover all of \([n]\), i.e., \(\cup_{i=1}^k
    C_i = [n]\).” No requirement for equal-sized subsets is mentioned.'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 1 的答案：d. 理由：“形式上，我们定义聚类为一个划分。大小为 \(k\) 的 \([n] = {1,\ldots,n}\) 的划分是一组非空子集 \(C_1,\ldots,C_k
    \subseteq [n]\)，它们：两两不相交，即 \(C_i \cap C_j = \emptyset\)，\(\forall i \neq j\)；覆盖所有
    \([n]\)，即 \(\cup_{i=1}^k C_i = [n]\)。” 没有提到子集大小必须相等的要求。
- en: 'Answer for 2: a. Justification: “Here \(\boldsymbol{\mu}_i \in \mathbb{R}^d\)
    is the representative – or center – of cluster \(C_i\).”'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 2 的答案：a. 理由：“这里 \(\boldsymbol{\mu}_i \in \mathbb{R}^d\) 是簇 \(C_i\) 的代表——或中心。”
- en: 'Answer for 3: c. Justification: The \(k\)-means objective is defined in the
    text as minimizing the sum of squared distances between data points and their
    assigned cluster centers.'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 3 的答案：c. 理由：文本中将 \(k\)-means 的目标定义为最小化数据点到其分配的簇中心的平方距离之和。
- en: 'Answer for 4: b. Justification: “The sequence of objective function values
    produced by the \(k\)-means algorithm is non-increasing.”'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 4 的答案：b. 理由：“\(k\)-means 算法产生的目标函数值序列是非递减的。”
- en: 'Answer for 5: c. Justification: The text defines \(Z\) as a matrix where “each
    row has exactly one entry with value 1, corresponding to the assigned cluster
    of data point.”'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 5 的答案：c. 理由：文本将 \(Z\) 定义为一个矩阵，其中“每一行恰好有一个值为 1 的条目，对应于数据点的分配簇。”
