- en: Machine Code Analyzers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://en.algorithmica.org/hpc/profiling/mca/](https://en.algorithmica.org/hpc/profiling/mca/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A *machine code analyzer* is a program that takes a small snippet of assembly
    code and [simulates](../simulation) its execution on a particular microarchitecture
    using information available to compilers, and outputs the latency and throughput
    of the whole block, as well as cycle-perfect utilization of various resources
    within the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/profiling/mca/#using-llvm-mca)Using
    `llvm-mca`'
  prefs: []
  type: TYPE_NORMAL
- en: There are many different machine code analyzers, but I personally prefer `llvm-mca`,
    which you can probably install via a package manager together with `clang`. You
    can also access it through a web-based tool called [UICA](https://uica.uops.info)
    or in the [Compiler Explorer](https://godbolt.org/) by selecting “Analysis” as
    the language.
  prefs: []
  type: TYPE_NORMAL
- en: What `llvm-mca` does is it runs a set number of iterations of a given assembly
    snippet and computes statistics about the resource usage of each instruction,
    which is useful for finding out where the bottleneck is.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will consider the array sum as our simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is its analysis with `llvm-mca` for the Skylake microarchitecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'First, it outputs general information about the loop and the hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: It “ran” the loop 100 times, executing 400 instructions in total in 108 cycles,
    which is the same as executing $\frac{400}{108} \approx 3.7$ [instructions per
    cycle](/hpc/complexity/hardware) on average (IPC).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CPU is theoretically capable of executing up to 6 instructions per cycle
    ([dispatch width](/hpc/architecture/layout)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each cycle in theory can be executed in 0.8 cycles on average ([block reciprocal
    throughput](/hpc/pipelining/tables)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “uOps” here are the micro-operations that the CPU splits each instruction
    into (e.g., fused load-add is composed of two uOps).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then it proceeds to give information about each individual instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing there that there isn’t in the [instruction tables](/hpc/pipelining/tables):'
  prefs: []
  type: TYPE_NORMAL
- en: how many uOps each instruction is split into;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how many cycles each instruction takes to complete (latency);
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how many cycles each instruction takes to complete in the amortized sense (reciprocal
    throughput), considering that several copies of it can be executed simultaneously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then it outputs probably the most important part — which instructions are executing
    when and where:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As the contention for execution ports causes [structural hazards](/hpc/pipelining/hazards),
    ports often become the bottleneck for throughput-oriented loops, and this chart
    helps diagnose why. It does not give you a cycle-perfect Gantt chart of something
    like that, but it gives you the aggregate statistics of the execution ports used
    for each instruction, which lets you find which one is overloaded. [← Program
    Simulation](https://en.algorithmica.org/hpc/profiling/simulation/)[Benchmarking
    →](https://en.algorithmica.org/hpc/profiling/benchmarking/)
  prefs: []
  type: TYPE_NORMAL
