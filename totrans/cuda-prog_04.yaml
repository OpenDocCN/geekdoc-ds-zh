- en: Chapter 4
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章
- en: Setting Up CUDA
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置CUDA
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter is here for anyone who is completely new to CUDA. We look at how
    to install CUDA on the various OSs, what tools you can use, and how CUDA compiles.
    Finally, we look at how to have the API help you identify the coding and API errors
    everyone makes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为那些完全不了解CUDA的人提供帮助。我们将介绍如何在不同操作系统上安装CUDA、可以使用的工具以及CUDA如何进行编译。最后，我们会看看如何利用API帮助你识别每个人都会犯的编码和API错误。
- en: 'CUDA is supported on three major OSs: Windows, Mac, and Linux. By far the easiest
    platform to use and learn CUDA with is the OS you are most familiar with using
    for programming development. For an absolute beginner, the Windows OS in conjunction
    with Microsoft Visual C++ is likely to be the best choice. Both the Windows and
    Mac installations are fairly much point and click. Both provide fairly standard
    integrated development environments that work well with CUDA.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: CUDA支持三个主要操作系统：Windows、Mac和Linux。到目前为止，最容易使用和学习CUDA的平台是你最熟悉的编程开发操作系统。对于完全的初学者，Windows操作系统配合Microsoft
    Visual C++可能是最佳选择。Windows和Mac的安装过程都相当简单，只需点击几下即可。两者都提供了相当标准的集成开发环境，能够很好地与CUDA配合使用。
- en: Installing the Sdk Under Windows
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows下安装SDK
- en: To install CUDA onto a PC running Windows, you’ll need to download the following
    components from the NVIDIA developer portal at [*http://developer.nvidia.com/cuda-toolkit-41*](http://developer.nvidia.com/cuda-toolkit-41).
    Note by the time this book hit the press release 5 of the toolkit was in its release
    candidate phase. Please check the NVIDIA website for the latest version.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行Windows的PC上安装CUDA，你需要从NVIDIA开发者门户网站下载以下组件，网址为[*http://developer.nvidia.com/cuda-toolkit-41*](http://developer.nvidia.com/cuda-toolkit-41)。需要注意的是，本书发布时，CUDA工具包的第5个版本已经进入候选发布阶段。请访问NVIDIA官网查看最新版本。
- en: 'You will need an already installed version of Microsoft Visual Studio 2005,
    2008, or 2010\. The first step is to download and install the latest set of NVIDIA
    development drivers for your relevant operating system from the previous link.
    Then you will need either the 32- or 64-bit version of the CUDA toolkit and GPU
    computing and SDK code samples. Make sure you pick the correct version for your
    OS. Install them in this order:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要预先安装Microsoft Visual Studio 2005、2008或2010版本。第一步是从上述链接下载并安装适用于你操作系统的最新NVIDIA开发驱动。接下来，你需要下载32位或64位版本的CUDA工具包、GPU计算以及SDK代码示例。确保选择与你的操作系统兼容的版本。按照以下顺序进行安装：
- en: 1. NVIDIA development drivers
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 1. NVIDIA开发驱动
- en: 2. CUDA toolkit
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 2. CUDA工具包
- en: 3. CUDA SDK
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 3. CUDA SDK
- en: 4. GPU computing SDK
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 4. GPU计算SDK
- en: 5. Parallel Nsight debugger
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 5. Parallel Nsight调试器
- en: Under Windows 7, the SDK installs all of its files into “ProgramData,” which
    is a hidden directory of the C drive. To view the files you either need to always
    go via the CUDA SDK icon created on the desktop or go to “Folder Options” in Windows
    and tell it to show hidden files ([Figure 4.1](#F0010)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows 7下，SDK会将所有文件安装到“ProgramData”文件夹中，这是C盘中的一个隐藏目录。要查看这些文件，你需要始终通过桌面上创建的CUDA
    SDK图标来访问，或者进入Windows的“文件夹选项”，并设置显示隐藏文件（见[图4.1](#F0010)）。
- en: '![image](../images/F000041f04-01-9780124159334.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/F000041f04-01-9780124159334.jpg)'
- en: Figure 4.1 “Folder Options” to see hidden files.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 “文件夹选项”以查看隐藏文件。
- en: Visual Studio
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio
- en: CUDA supports Visual Studio versions from 2005 to 2010 including, for the most
    part, the express versions. The express versions are available free of charge
    from Microsoft. The professional versions are also available to registered students
    free of charge via the DreamSpark program at [*https://www.dreamspark.com*](https://www.dreamspark.com).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: CUDA支持从2005年到2010年的Visual Studio版本，包括大部分的express版本。express版本可以从Microsoft官方网站免费获得。专业版本也可以通过DreamSpark计划免费提供给注册学生，访问地址为[*https://www.dreamspark.com*](https://www.dreamspark.com)。
- en: To register all you need to do is supply your university or college details
    and identification numbers and you can download Visual Studio and many other programming
    tools. The program is also not just restricted to U.S.-based academic institutions,
    but available to students worldwide.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册，你只需要提供你的大学或学院的详细信息和身份证明号码，就可以下载Visual Studio以及许多其他编程工具。这个计划不仅限于美国的学术机构，全球的学生都可以使用。
- en: On the whole, Visual Studio 2008 has the best support for CUDA and compiles
    somewhat quicker than Visual Studio 2010\. Visual Studio 2010 has, however, one
    very useful feature, which is automatic syntax checking of source code. Thus,
    if you use a type that is not defined, it underlines the error in red, just as
    Microsoft Word underlines spelling errors. This is an incredibly useful feature
    as it saves a lot of unnecessary compilation cycles for obvious issues. Thus,
    I’d recommend the 2010 version, especially if you can download it for free from
    DreamSpark.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，Visual Studio 2008对CUDA的支持最好，并且比Visual Studio 2010编译速度稍快。然而，Visual Studio
    2010有一个非常有用的功能，即自动语法检查源代码。因此，如果你使用了未定义的类型，它会像Microsoft Word一样将错误用红色下划线标出。这是一个非常有用的功能，因为它可以节省很多因为明显问题而不必要的编译周期。因此，我推荐2010版本，特别是如果你可以通过DreamSpark免费下载安装的话。
- en: Projects
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目
- en: One quick way of creating a project is to take one of the SDK examples, remove
    all the unnecessary project files, and insert your own source files. Note your
    CUDA source code should have a “.cu” extension so that it will be compiled by
    the NVIDIA compiler instead of Visual C. However, as we see later, you can also
    simply create a basic project framework using the project template wizard.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目的一种快速方法是取一个SDK示例，删除所有不必要的项目文件，并插入你自己的源文件。请注意，你的CUDA源代码应该有“.cu”扩展名，这样它会被NVIDIA编译器编译，而不是Visual
    C。不过，正如我们稍后所看到的，你也可以简单地使用项目模板向导创建一个基本的项目框架。
- en: 64-bit users
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 64位用户
- en: 'When using Windows 64-bit version, be aware that some of the project files
    are set up to run as 32-bit applications by default. Thus, when you try to build
    them you may get the error message: Fatal Error LNK1181: cannot open input file
    ‘cutil32D.lib’.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Windows 64位版本时，请注意，一些项目文件默认设置为作为32位应用程序运行。因此，当你尝试构建它们时，可能会收到错误信息：致命错误LNK1181：无法打开输入文件‘cutil32D.lib’。
- en: This was not installed, as you most likely installed only the 64-bit version
    of the SDK along with the 64-bit version of Windows. To correct this issue all
    we have to do is set the target from 64 bits to 32 bits, which we do using the
    Build menu in Visual Studio, and then change the platform to X64 as shown in [Figure
    4.2](#F0015).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这未被安装，因为你很可能只安装了64位版本的SDK和64位版本的Windows。为了解决这个问题，我们只需将目标从64位设置为32位，方法是通过Visual
    Studio中的“生成”菜单，然后将平台更改为X64，如[图4.2](#F0015)所示。
- en: '![image](../images/F000041f04-02-9780124159334.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/F000041f04-02-9780124159334.jpg)'
- en: Figure 4.2 Visual C platform selection.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 Visual C平台选择。
- en: You may be prompted at the point you initiate a rebuild to save the project.
    Just add “_X86” to the end of the project name and save. The project will then
    build under a 64-bit environment and link in the correct library files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动重建时，系统可能会提示你保存项目。只需在项目名称后添加“_X86”并保存。然后，项目将在64位环境下构建并链接到正确的库文件。
- en: 'You may also find an issue with a missing library, such as “cutil32.lib,” for
    example. When the SDK is installed, it sets an environment variable, `$(CUDA_LIB_PATH)`.
    This is usually set to: C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v4.1\lib\X64.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会遇到缺少库的问题，例如“cutil32.lib”。当SDK安装时，它会设置一个环境变量`$(CUDA_LIB_PATH)`。通常这个变量的值为：C:\Program
    Files\NVIDIA GPU Computing Toolkit\CUDA\v4.1\lib\X64。
- en: You may find the path setup in the default project files may not have `$(CUDA_LIB_PATH)`
    as one of the entries. To add it, click on the project and then select “Project→Properties.”
    This brings up the dialog box shown in [Figure 4.3](#F0020).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现默认项目文件中的路径设置没有将`$(CUDA_LIB_PATH)`作为其中之一。要添加它，请点击项目，然后选择“项目→属性”。这将弹出如[图4.3](#F0020)所示的对话框。
- en: '![image](../images/F000041f04-03-9780124159334.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/F000041f04-03-9780124159334.jpg)'
- en: Figure 4.3 Additional library path.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 额外的库路径。
- en: Clicking on the “…” button on the far right brings up a dialog where you can
    add the library path ([Figure 4.4](#F0025)). Simply add “$(CUDA_LIB_PATH)” as
    a new line and the project should now link.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 点击最右侧的“…”按钮会弹出一个对话框，你可以在其中添加库路径（[图4.4](#F0025)）。只需将“$(CUDA_LIB_PATH)”作为新的一行添加，项目应该就可以链接了。
- en: '![image](../images/F000041f04-04-9780124159334.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/F000041f04-04-9780124159334.jpg)'
- en: Figure 4.4 Adding library directories.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 添加库目录。
- en: If you wish to build both 64-bit CUDA applications and 32-bit CUDA applications,
    both the 32- and 64-bit CUDA toolkits need to be installed. The samples from the
    SDK also require both the 32- and 64-bit versions of the SDK to be installed to
    be able to build both 32- and 64-bit versions of the samples.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望构建64位和32位的CUDA应用程序，则需要同时安装32位和64位CUDA工具包。SDK中的示例也要求安装32位和64位版本的SDK，以便能够构建32位和64位版本的示例。
- en: 'You can build the necessary libraries by going to the following directories
    and building the solution files:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问以下目录并构建解决方案文件来构建所需的库：
- en: C:\ProgramData\NVIDIA Corporation\NVIDIA GPU Computing SDK 4.1\C\common
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: C:\ProgramData\NVIDIA Corporation\NVIDIA GPU Computing SDK 4.1\C\common
- en: C:\ProgramData\NVIDIA Corporation\NVIDIA GPU Computing SDK 4.1\shared
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: C:\ProgramData\NVIDIA Corporation\NVIDIA GPU Computing SDK 4.1\shared
- en: You will find the necessary libraries in
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到所需的库
- en: C:\ProgramData\NVIDIA Corporation\NVIDIA GPU Computing SDK 4.1\C\common\lib\X64.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: C:\ProgramData\NVIDIA Corporation\NVIDIA GPU Computing SDK 4.1\C\common\lib\X64。
- en: You can also add these manually to any project that is missing them. Unfortunately,
    the SDK samples are not set up so they automatically build the necessary libraries
    when needed. The binaries for the libraries also are not supplied, which makes
    actually building the SDK samples a little frustrating.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以手动将这些库添加到任何缺少它们的项目中。不幸的是，SDK示例没有设置自动构建必要库的功能。库的二进制文件也没有提供，这使得构建SDK示例变得有些令人沮丧。
- en: Creating projects
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建项目
- en: To create a new CUDA-enabled application, simply create a CUDA application using
    the “File→New→Project Wizard” as shown in [Figure 4.5](#F0030). The wizard will
    then create a single project containing the file “kernel.cu,” which contains a
    mix of code, some of which executes on the CPU and some of which executes on the
    GPU. The GPU code is contained in the function `addKernel`. This function simply
    takes a pointer to a destination array, `c`, and a couple of pointers to two input
    arrays, `a` and `b`. It then adds the contents of the `a` and `b` arrays together
    and stores the result in the destination array, `c`. It’s a very simple example
    of the framework needed to execute a CUDA program.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的CUDA启用应用程序，只需使用“文件→新建→项目向导”创建一个CUDA应用程序，如[图4.5](#F0030)所示。向导将创建一个包含文件“kernel.cu”的单一项目，文件中包含一部分在CPU上执行的代码和一部分在GPU上执行的代码。GPU代码包含在`addKernel`函数中。此函数简单地接受指向目标数组`c`的指针，以及指向两个输入数组`a`和`b`的指针。然后，它将`a`和`b`数组的内容相加，并将结果存储在目标数组`c`中。这是执行CUDA程序所需框架的一个非常简单的示例。
- en: '![image](../images/F000041f04-05-9780124159334.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/F000041f04-05-9780124159334.jpg)'
- en: Figure 4.5 CUDA Project Wizard.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 CUDA项目向导。
- en: Also included is the basic code to copy data to a device, invoke the kernel,
    and copy data back from the device to the host. It’s a very useful starter project
    to get you compiling something under CUDA. We cover the standard framework needed
    to get a CUDA program working later in the text. It’s useful to look at the code
    and try to understand it if you can. However, don’t worry at this stage if it
    doesn’t make sense as we’ll build gradually on how to write programs for CUDA.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 还包含了将数据复制到设备、调用内核并将数据从设备复制回主机的基本代码。这是一个非常有用的起始项目，可以帮助您在CUDA下进行编译。我们将在后面的文字中介绍使CUDA程序正常工作的标准框架。查看代码并尝试理解它是很有帮助的。如果您能理解的话，但在这个阶段，如果它不太明白也不用担心，我们会逐步介绍如何编写CUDA程序。
- en: Linux
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux
- en: CUDA is supported for the following Linux distributions. The supported versions
    will vary depending on which version of the CUDA toolkit you are installing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: CUDA支持以下Linux发行版。支持的版本将根据您安装的CUDA工具包版本而有所不同。
- en: • Fedora 14
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: • Fedora 14
- en: • Redhat 6.0 and 5.5/CentOS 6.2 (the free version of Redhat)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: • Redhat 6.0 和 5.5/CentOS 6.2（Redhat的免费版本）
- en: • Ubuntu 11.04
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: • Ubuntu 11.04
- en: • OpenSUSE 11.2
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: • OpenSUSE 11.2
- en: 'The first step in installing CUDA on a Linux platform is to make sure you have
    the latest set of kernel software. Use the following command from a terminal window
    to do this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux平台上安装CUDA的第一步是确保您拥有最新版本的内核软件。可以在终端窗口中使用以下命令进行操作：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `sudo` command will log you in as the administrator. The `yum` command is
    the standard installation tool for the Linux RPM package. You are simply asking
    it to check for all installed packages and see if any updates are available. This
    ensures your system is fully up to date before installing any drivers. Many of
    the GUI-based installations also have GUI-based versions of the software updates
    that replace the older command line update interface.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo`命令将以管理员身份登录。`yum`命令是Linux RPM包的标准安装工具。你只是让它检查所有已安装的软件包，并查看是否有更新可用。这可以确保在安装任何驱动程序之前，你的系统已完全更新。许多基于GUI的安装也有GUI版本的软件更新，取代了较旧的命令行更新界面。'
- en: 'Once the kernel has been updated to the latest level, run the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦内核更新到最新版本，运行以下命令：
- en: '`sudo yum install gcc-c++ kernel-devel`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo yum install gcc-c++ kernel-devel`'
- en: This will install the standard GNU C++ environment as well as the kernel source
    you’ll need to rebuild the kernel. Be aware that package names are case-sensitive.
    This will prompt you for around a 21 MB download and take a couple of minutes
    to install. Again, if you prefer, you can install the package via the GUI software
    installer for the particular OS.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装标准的GNU C++环境以及你需要重建内核的内核源代码。请注意，软件包名称区分大小写。这将提示你进行大约21MB的下载，并花费几分钟时间安装。如果你愿意，也可以通过特定操作系统的GUI软件安装程序安装此软件包。
- en: 'Finally, as you are likely to be drawing some graphical output, you’ll need
    an OpenGL development environment. Install this with the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于你可能需要绘制一些图形输出，你需要一个OpenGL开发环境。使用以下命令安装：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now you’re ready to install the CUDA drivers. Make sure you install at least
    version 4.1 of the CUDA toolkit. There are a number of ways to install the updated
    NVIDIA drivers. NVIDIA does not release the source code to the drivers, so by
    default most Linux distributions install a very basic graphics driver.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你准备好安装CUDA驱动程序了。确保你安装至少版本为4.1的CUDA工具包。有多种方法可以安装更新的NVIDIA驱动程序。NVIDIA没有发布驱动程序的源代码，因此默认情况下，大多数Linux发行版会安装一个非常基础的图形驱动程序。
- en: Kernel base driver installation (CentOS, Ubuntu 10.4)
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内核基础驱动程序安装（CentOS，Ubuntu 10.4）
- en: The CUDA releases should be used with a specific set of *development* drivers.
    Installing drivers by methods other than the one listed here may result in CUDA
    not working. Note the versions of the OS supported for the given version of the
    CUDA toolkit. These may not be the latest version of the particular Linux distribution.
    Using a later distribution will likely *not* work. Thus, the first installation
    step is to replace any existing drivers with the version specified for your specific
    Linux distribution. See [Figure 4.6](#F0035).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: CUDA发布版本应与特定的*开发*驱动程序一起使用。通过其他方式安装驱动程序可能会导致CUDA无法正常工作。请注意，给定版本的CUDA工具包支持的操作系统版本。这些可能不是特定Linux发行版的最新版本。使用更新的发行版可能*无法*正常工作。因此，第一步安装是用适合你特定Linux发行版的版本替换现有的驱动程序。请参见[图4.6](#F0035)。
- en: '![image](../images/F000041f04-06-9780124159334.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/F000041f04-06-9780124159334.jpg)'
- en: Figure 4.6 Supported Linux downloads and supported driver versions as of September
    2012.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 支持的Linux下载和截至2012年9月的支持驱动程序版本。
- en: 'Once the download is complete, you need to boot Linux in text-only mode. Unlike
    Windows, which is always in graphics mode, text mode is required to install the
    drivers under Linux. You can make the system boot into text on most distributions
    using the following command from a Terminal window (usually under the Systems
    menu in the GUI):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，你需要以文本模式启动Linux。与Windows不同，Windows始终处于图形模式，Linux安装驱动程序时需要文本模式。你可以通过终端窗口（通常位于GUI的系统菜单下）使用以下命令让系统启动到文本模式：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will reboot the Linux machine and bring it back up in text mode. You can
    use `sudo init 5` to restore the graphics mode later.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重启Linux机器，并以文本模式重新启动。你可以稍后使用`sudo init 5`恢复图形模式。
- en: 'If you get an error such as “User <user_name> is not in sudoers file,” login
    as root using the `su` command. Edit the “/etc/sudoers” file and append the following
    line:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现类似“User <user_name> is not in sudoers file”的错误，使用`su`命令以root身份登录。编辑“/etc/sudoers”文件并附加以下行：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Be careful to replace `your_user_name` with your login name.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 小心将`your_user_name`替换为你的登录名。
- en: 'Certain distributions (e.g., Ubuntu) insist on booting to the GUI, regardless
    of the `init` mode. One method of resolving is as follows, from a text window.
    Edit the grub startup file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 某些发行版（例如 Ubuntu）坚持使用 GUI 启动，无论 `init` 模式如何。解决方法之一是通过文本窗口进行操作。编辑 grub 启动文件：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Change the following lines:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 修改以下几行：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: to
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`GRUB_CMDLINE_LINUX_DEFAULT="text"`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`GRUB_CMDLINE_LINUX_DEFAULT="text"`'
- en: Now update grub using
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用以下命令更新 grub：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, reboot your machine and it should come up in text-only mode. Use the
    original lines to boot to the GUI again once the drivers are installed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重启你的机器，它应该会以文本模式启动。一旦驱动程序安装完成，使用原始命令再次启动到 GUI 模式。
- en: Now navigate to the area you stored the “.run” file you downloaded from the
    NVIDIA website. Then type
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入你存放从NVIDIA网站下载的“.run”文件的目录。然后输入
- en: '`sudo sh NVIDIA-Linux-x86_64-285.05.33.run`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo sh NVIDIA-Linux-x86_64-285.05.33.run`'
- en: The exact version of the driver you download will of course be different. You
    will be asked to agree to the NVIDIA license and will then have to wait a few
    minutes while everything installs. During this process the installer will attempt
    to replace the default Nouveau driver with the necessary NVIDIA drivers. If asked
    if you want to do this, select “Yes.” This is an error-prone process and not every
    distribution works out of the box. If the NVIDIA installer is unable to remove
    the Nouveau driver then it may be necessary to blacklist the driver so the NVIDIA
    installer can install the correct drivers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你下载的驱动版本当然会有所不同。你将被要求同意 NVIDIA 的许可协议，然后需要等待几分钟，直到所有内容安装完成。在此过程中，安装程序会尝试将默认的
    Nouveau 驱动替换为所需的 NVIDIA 驱动。如果安装程序询问是否要执行此操作，选择“是”。这是一个容易出错的过程，并不是所有的发行版都能开箱即用。如果
    NVIDIA 安装程序无法删除 Nouveau 驱动，那么可能需要将其加入黑名单，以便 NVIDIA 安装程序可以安装正确的驱动。
- en: When you have the NVIDIA drivers installed correctly, type
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你正确安装 NVIDIA 驱动程序后，输入
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The machine will then reboot into the regular graphics mode. See earlier for
    Ubuntu.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 机器随后将重新启动进入常规的图形模式。有关 Ubuntu 的内容请参见前文。
- en: The next task is to install the toolkit. There are a number available—select
    Fedora, Red Hat, Ubuntu, OpenSUSE, or SUSE depending on your distribution. As
    before, simply navigate to where you installed the SDK and run it by typing
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是安装工具包。根据你的发行版，有多个可选工具包—选择 Fedora、Red Hat、Ubuntu、OpenSUSE 或 SUSE。如前所述，只需导航到你安装
    SDK 的目录并运行它，输入
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'where `<sdk_version>` is the file you downloaded. It will then install all
    the tools needed and print a message saying the installation was successful. It
    then mentions you have to update the `PATH` and `LD_LIBRARY_PATH` environment
    variables, which you have to do by hand. To do this, you need to edit the “/etc/profile”
    startup file. Add the following lines:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `<sdk_version>` 是你下载的文件。接下来，它将安装所有所需的工具，并打印一条消息，表示安装成功。然后，它会提到你需要手动更新 `PATH`
    和 `LD_LIBRARY_PATH` 环境变量。为此，你需要编辑“/etc/profile”启动文件。添加以下几行：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the file has to be writable. Use the “sudo chmod +w /etc/profile”
    to make it writable if required. You can edit this file with your favorite editor
    using such a command as “sudo nano/etc/profile”.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，文件必须具有写入权限。如果需要，可以使用“sudo chmod +w /etc/profile”使其可写。你可以使用喜欢的编辑器编辑该文件，例如使用“sudo
    nano /etc/profile”命令。
- en: Now log out and log back in again and type
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在登出并重新登录，然后输入
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will list all of the current environment variable settings. Check for the
    two new entries you just amended. CUDA is now installed into the “/usr/local/bin”
    directory.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出所有当前的环境变量设置。检查你刚刚修改的两个新条目。CUDA 现在已安装到“/usr/local/bin”目录中。
- en: Next we’ll need the GNU C++ compiler. Install the package “g++” from whatever
    software installer you are using on your system.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装 GNU C++ 编译器。从你系统中使用的任何软件安装器安装“g++”包。
- en: The next step is to install the SDK sample codes, so we have something to build
    and test. Download these from the NVIDIA site and run them, again using the `sh
    sdk_version.run` command (replace `sdk_version` with the actual one you download).
    Do *not* run this install as root as you will otherwise have to be logged in as
    root to build any of the samples.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是安装 SDK 示例代码，这样我们就有东西可以构建和测试了。从 NVIDIA 网站下载这些示例并运行它们，再次使用 `sh sdk_version.run`
    命令（将 `sdk_version` 替换为你下载的实际版本）。*不要*以 root 用户身份运行此安装，否则你将必须以 root 用户登录才能构建任何示例。
- en: By default the SDK will install to a subdirectory of your user account area.
    It may complain it can’t find the CUDA installation and will use the default directory
    (the same one CUDA was installed to earlier). You can safely ignore this message.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SDK 会安装到用户账户区域的子目录中。它可能会抱怨找不到 CUDA 安装，并使用默认目录（即之前安装 CUDA 时使用的目录）。您可以安全地忽略此消息。
- en: Once the GPU computing SDK is installed, you then need to go to the “Common”
    subdirectory and run `make` to create a set of libraries.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 GPU 计算 SDK 后，您需要进入“Common”子目录，并运行 `make` 以创建一组库。
- en: Once this is done the SDK samples should build, allowing you to execute your
    first CUDA program in Linux and of course see if the driver is working correctly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完成上述步骤后，SDK 示例应该能正常构建，您可以在 Linux 中执行您的第一个 CUDA 程序，并检查驱动程序是否正常工作。
- en: Mac
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mac
- en: 'The Macintosh version is available, as with the other versions, from [*http://developer.nvidia.com/cuda-toolkit-41*](http://developer.nvidia.com/cuda-toolkit-41).
    Simply download and install the packages in the following order:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Macintosh 版本可在 [*http://developer.nvidia.com/cuda-toolkit-41*](http://developer.nvidia.com/cuda-toolkit-41)
    处下载，与其他版本一样。只需按以下顺序下载并安装软件包：
- en: • Development drivers
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: • 开发驱动程序
- en: • CUDA toolkit
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: • CUDA 工具包
- en: • CUDA tools SDK and code samples
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: • CUDA 工具 SDK 和代码示例
- en: CUDA 4.1 requires Mac OS release 10.6.8 (Snow Leopard) or later. The latest
    release (10.7.x) or Lion release is available as a download from the Apple store
    or via a separate purchase from Apple.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: CUDA 4.1 需要 Mac OS 版本 10.6.8（Snow Leopard）或更高版本。最新版本（10.7.x）或 Lion 版本可以从 Apple
    Store 下载，或通过单独购买获取。
- en: The SDK installs into the “GPU Computing” directory under the “Developer” higher-level
    directory. Simply browse the “Developer/GPU Computing/C/bin/darwin/release” directory
    and you will find precompiled executables. Running the `deviceQuery` tool is useful
    to verify you have correctly installed the drivers and runtime environment.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 安装到“Developer”高层目录下的“GPU Computing”目录中。只需浏览“Developer/GPU Computing/C/bin/darwin/release”目录，您将找到预编译的可执行文件。运行
    `deviceQuery` 工具可以帮助验证驱动程序和运行时环境是否正确安装。
- en: To compile the samples, you will need XCode installed. This is the equivalent
    of GCC (GNU C Compiler) for the Mac. XCode can be downloaded from the Apple store.
    It’s not a free product, but is available free of charge to anyone on the Apple
    Developer program, which includes both development of Macintosh and iPhone/iPad
    applications. It was also released shortly after the Lion OS as a free download
    for Lion OS owners.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译示例，您需要安装 XCode。它是 Mac 系统中类似于 GCC（GNU C 编译器）的工具。XCode 可以从 Apple Store 下载。虽然这不是免费的产品，但对任何在
    Apple Developer 程序中的用户来说，XCode 是免费的，该程序包括 Mac 和 iPhone/iPad 应用的开发。此外，它在 Lion OS
    发布后不久，作为免费的下载供 Lion OS 用户使用。
- en: 'Once XCode is installed, simply open a terminal window. To do this, go to Finder,
    open Utilities, and then double-click on the Terminal window. Type the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 XCode 后，只需打开一个终端窗口。操作步骤是：打开 Finder，进入 Utilities 文件夹，然后双击 Terminal 窗口。输入以下命令：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Replace `project` with the name of the particular SDK application you wish to
    compile. If you receive compilation errors, you have either not downloaded the
    XCode package or have an older version than is required.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `project` 替换为您希望编译的特定 SDK 应用程序的名称。如果收到编译错误，说明您未下载 XCode 包或安装的版本较旧。
- en: Installing a Debugger
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装调试器
- en: CUDA provides a debug environment called Parallel Nsight on the Windows platform.
    This provides support for debugging CPU and GPU code and highlights areas where
    things are working less than efficiently. It also helps tremendously when trying
    to debug multithreaded applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: CUDA 提供了一种名为 Parallel Nsight 的调试环境，适用于 Windows 平台。它支持调试 CPU 和 GPU 代码，并突出显示效率较低的地方。它在调试多线程应用程序时也非常有帮助。
- en: Nsight is completely free and is a hugely useful tool. All it requires is that
    you register as a CUDA-registered developer, which is again entirely free. Once
    registered, you will be able to download the tool from the NVIDIA website.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Nsight 完全免费，并且是一个极为有用的工具。它要求您注册为 CUDA 注册开发者，注册过程同样完全免费。注册后，您可以从 NVIDIA 网站下载该工具。
- en: Note that you must have Visual Studio 2008 or later (not the express version)
    and you must have installed Service Pack 1\. There is a link within the release
    notes of Nsight to the SP1 download you need to install.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您必须安装 Visual Studio 2008 或更高版本（非简化版），并且必须安装 Service Pack 1。在 Nsight 的发布说明中，有一个链接指向您需要安装的
    SP1 下载。
- en: Parallel Nsight comes as two parts, an application that integrates itself into
    Visual Studio as shown in [Figure 4.7](#F0040), and a separate monitoring application.
    The monitoring application works in conjunction with the main application. The
    monitor is usually resident, but does not have to be, on the same machine as the
    Visual Studio environment. Parallel Nsight works best with two CUDA capable GPUs,
    a dedicated GPU to run the code on and one to use as the regular display. Thus,
    the GPU running the target code cannot be used to run a second display. As most
    GPU cards have dual-monitor outputs, you can simply run two monitors off the display
    card should you have a dual-monitor setup. Note in the latest release, 2.2, the
    need for two GPUs was dropped.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Parallel Nsight 分为两部分，一部分是集成到 Visual Studio 中的应用程序，如[图 4.7](#F0040)所示，另一部分是独立的监视应用程序。监视应用程序与主应用程序协同工作。监视器通常驻留在与
    Visual Studio 环境相同的机器上，但也不一定非要如此。Parallel Nsight 最佳配置是两块支持 CUDA 的 GPU，一块用于运行代码，另一块作为常规显示使用。因此，运行目标代码的
    GPU 不能用于驱动第二个显示器。由于大多数 GPU 卡具有双显示输出，如果你有双显示器设置，可以简单地使用显示卡来连接两个显示器。注意，在最新的 2.2
    版本中，不再要求使用两块 GPU。
- en: '![image](../images/F000041f04-07-9780124159334.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/F000041f04-07-9780124159334.jpg)'
- en: Figure 4.7 Nsight integrated into Microsoft Visual Studio.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 Nsight 集成到 Microsoft Visual Studio 中。
- en: It’s also possible to set up the tool to acquire data from a remote GPU. However,
    in most cases it’s easier to buy a low-end GPU and install it into your PC or
    workstation. The first step needed to set up Parallel Nsight on Windows is to
    disable TDR ([Figure 4.8](#F0045)). TDR (Timeout Detection and Recovery) is a
    mechanism in Windows that detects crashes in the driver-level code. If the driver
    stops responding to events, Windows resets the driver. As the driver will halt
    when you define a breakpoint, this feature needs to be disabled.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以设置工具从远程 GPU 获取数据。然而，在大多数情况下，购买一块低端 GPU 并将其安装到你的 PC 或工作站中更为简单。在 Windows 上设置
    Parallel Nsight 的第一步是禁用 TDR（[图 4.8](#F0045)）。TDR（超时检测与恢复）是 Windows 中的一种机制，用于检测驱动程序级代码中的崩溃。如果驱动程序停止响应事件，Windows
    将重置驱动程序。由于在定义断点时驱动程序会停止，因此需要禁用此功能。
- en: '![image](../images/F000041f04-08-9780124159334.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/F000041f04-08-9780124159334.jpg)'
- en: Figure 4.8 Disabling Windows kernel timeout.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 禁用 Windows 内核超时。
- en: To set the value, simply run the monitor and click on the “Nsight Monitor Options”
    hyperlink at the bottom right of the monitor dialog box. This will bring up the
    dialog shown in [Figure 4.8](#F0045). Setting the “WDDM TDR enabled” will modify
    the registry to disable this feature. Reboot your PC, and Parallel Nsight will
    no longer warn you TDR is enabled.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置该值，只需运行监视器并点击监视器对话框右下角的“Nsight Monitor Options”超链接。这将打开[图 4.8](#F0045)所示的对话框。设置“WDDM
    TDR 启用”将修改注册表以禁用此功能。重启你的 PC，Parallel Nsight 将不再警告 TDR 已启用。
- en: To use Parallel Nsight on a remote machine, simply install the monitor package
    only on the remote Windows PC. When you first run the monitor, it will warn you
    Windows Firewall has blocked “Public network” (Internet based) access to the monitor,
    which is entirely what you want. However, the tool needs to have access to the
    local network, so allow this exception to any firewall rules you have set up on
    the monitor machine. As with a local node, you will have to fix the TDR issue
    and reboot once installed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要在远程机器上使用 Parallel Nsight，只需在远程 Windows PC 上安装监视器包。当你第一次运行监视器时，它会警告你 Windows
    防火墙阻止了对监视器的“公共网络”（基于 Internet）访问，这正是你所希望的。然而，工具需要访问本地网络，因此需要允许此防火墙规则例外。与本地节点一样，安装后你还需要解决
    TDR 问题并重启。
- en: The next step is to run Visual Studio on the host PC and select a new analysis
    activity. You will see a section near the top of the window that looks like [Figure
    4.9](#F0050). Notice the “Connection Name” says `localhost`, which just means
    your local machine. Open Windows Explorer and browse the local network to see
    the name of the Windows PC you would like to use to remotely debug. Replace `localhost`
    with the name shown in Windows Explorer. Then press the “Connect” button. You
    should see two confirmations that the connection has been made as shown in [Figure
    4.10](#F0055).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在主机 PC 上运行 Visual Studio，并选择一个新的分析活动。你会看到窗口顶部附近有一个部分，类似于[图 4.9](#F0050)。注意，“连接名称”显示为`localhost`，这意味着你的本地机器。打开
    Windows 文件资源管理器并浏览本地网络，查看你想要用来进行远程调试的 Windows PC 的名称。将`localhost`替换为在 Windows
    文件资源管理器中显示的名称。然后点击“连接”按钮。你应该会看到两次确认，表明连接已建立，如[图 4.10](#F0055)所示。
- en: '![image](../images/F000041f04-09-9780124159334.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/F000041f04-09-9780124159334.jpg)'
- en: Figure 4.9 Parallel Nsight remote connection.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 Parallel Nsight 远程连接。
- en: '![image](../images/F000041f04-10-9780124159334.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/F000041f04-10-9780124159334.jpg)'
- en: Figure 4.10 Parallel Nsight connected remotely.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 Parallel Nsight 远程连接状态。
- en: First, the “Connect” button will change to a “Disconnect.” Second, the “Connection
    Status” box should turn green and show all the possible GPUs on the target machine
    ([Figure 4.11](#F0060)). In this case we’re connecting to a test PC that has five
    GTX470 GPU cards set up on it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，“连接”按钮会变成“断开连接”。其次，“连接状态”框应该变为绿色，并显示目标机器上的所有可用 GPU（[图 4.11](#F0060)）。在这种情况下，我们正在连接到一台测试
    PC，测试机上安装了五张 GTX470 GPU 卡。
- en: '![image](../images/F000041f04-11-9780124159334.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/F000041f04-11-9780124159334.jpg)'
- en: Figure 4.11 Parallel Nsight connection status.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 Parallel Nsight 连接状态。
- en: Clicking on the “Launch” button on the “Application Control” panel next to the
    “Connection Status” panel will remotely launch the application on the target machine.
    However, prior to this all the necessary files need to be copied to the remote
    machine. This takes a few seconds or so, but is all automatic. Overall, it’s a
    remarkably simple way of analyzing/debugging a remote application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“应用程序控制”面板上位于“连接状态”面板旁边的“启动”按钮将远程启动目标机器上的应用程序。不过，在此之前，所有必要的文件需要被复制到远程机器。这大约需要几秒钟，但这一切都是自动完成的。总体来说，这是分析/调试远程应用程序的一个非常简单的方法。
- en: You may wish to set up Parallel Nsight in this manner if, for example, you have
    a laptop and wish to debug, or simply remotely run, an application that will run
    on a GPU server. Such usage includes when a GPU server or servers are shared by
    people who use it at different times, teaching classes, for example. You may also
    have remote developers who need to run code on specially set up test servers,
    perhaps because those servers also contain huge quantities of data and it’s not
    practical or desirable to transfer that data to a local development machine. It
    also means you don’t need to install Visual C++ on each of the remote servers
    you might have.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一台笔记本电脑并希望调试或仅仅是远程运行将在 GPU 服务器上运行的应用程序，你可能希望以这种方式设置 Parallel Nsight。例如，这种用法包括当
    GPU 服务器或服务器被多人在不同时间共享使用时，比如教学课程。你也可能有远程开发者需要在特别设置的测试服务器上运行代码，可能是因为这些服务器还包含大量数据，将数据传输到本地开发机器并不实际或不可取。这也意味着你不需要在每一台远程服务器上安装
    Visual C++。
- en: On the Linux and Mac side the debugger environment is CUDA-GDB. This provides
    an extended GNU debugger package. As with Parallel Nsight it allows debugging
    of both host and CUDA code, which includes setting a breakpoint in the CUDA code,
    single step, select a debug thread, etc. Both CUDA-GDB and the Visual Profiler
    tools are installed by default when you install the SDK, rather than being a separate
    download as with Parallel Nsight. As of 2012, Parallel Nsight was also released
    under the Eclipse environment for Linux.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 和 Mac 系统上，调试器环境是 CUDA-GDB。这提供了一个扩展的 GNU 调试器包。与 Parallel Nsight 一样，它允许调试主机和
    CUDA 代码，包括在 CUDA 代码中设置断点、单步调试、选择调试线程等。CUDA-GDB 和 Visual Profiler 工具在安装 SDK 时默认安装，而不是像
    Parallel Nsight 那样需要单独下载。自 2012 年起，Parallel Nsight 也在 Linux 的 Eclipse 环境下发布。
- en: The major difference between Windows and Mac/Linux was the profiling tool support.
    The Parallel Nsight tool is in this respect vastly superior to the Visual Profiler.
    The Visual Profiler is also available on Windows. It provides a fairly high-level
    overview and recommendations as to what to address in the code, and therefore
    is very suited to those starting out using CUDA. Parallel Nsight, by contrast,
    is aimed at a far more advanced user. We cover usage of both Parallel Nsight and
    Visual Profiler later in subsequent chapters. However, the focus throughout this
    text is on the use of Parallel Nsight as the primary debugging/analysis tool for
    GPU development.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 和 Mac/Linux 之间的主要区别在于分析工具的支持。Parallel Nsight 在这方面远远优于 Visual Profiler。Visual
    Profiler 在 Windows 上也可以使用。它提供了一个相当高层次的概览，并给出关于代码中需要关注的地方的建议，因此非常适合刚开始使用 CUDA 的用户。相比之下，Parallel
    Nsight 面向的是更为高级的用户。我们将在后续章节中讨论 Parallel Nsight 和 Visual Profiler 的使用。不过，本书的重点是将
    Parallel Nsight 作为 GPU 开发的主要调试/分析工具。
- en: For advanced CUDA development I’d strongly recommend using Parallel Nsight for
    debugging and analysis. For most people new to CUDA the combination of the Visual
    Profiler and CUDA-GDB work well enough to allow for development.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级 CUDA 开发，我强烈建议使用 Parallel Nsight 进行调试和分析。对于大多数 CUDA 新手来说，Visual Profiler
    和 CUDA-GDB 的组合足以支持开发工作。
- en: Compilation Model
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译模型
- en: The NVIDIA compiler, NVCC, sits in the background and is invoked when a CUDA
    source file needs to be compiled. The file extensions shown in [Table 4.1](#T0010)
    are used to define files as with CUDA source files or regular source files. This
    determines which compiler will be invoked, NVCC or the host compiler.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: NVIDIA 编译器 NVCC 在后台运行，当需要编译一个 CUDA 源文件时会被调用。[表 4.1](#T0010) 中展示的文件扩展名用于定义文件类型，区分
    CUDA 源文件和常规源文件。这决定了将调用哪个编译器：NVCC 还是主机编译器。
- en: Table 4.1 Different CUDA File Types
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 不同的 CUDA 文件类型
- en: '| File Extension | Meaning | Processed By |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 文件扩展名 | 含义 | 处理工具 |'
- en: '| --- | --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| .cu | Mixed host and device source file. | NVCC |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| .cu | 混合主机和设备源文件。 | NVCC |'
- en: '| .cup | A preprocessed expanded version of .cu file. | NVCC |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| .cup | .cu 文件的预处理扩展版本。 | NVCC |'
- en: '| .c, .cc, .cpp | A host C or C++ source file. | Host compiler |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| .c, .cc, .cpp | 主机 C 或 C++ 源文件。 | 主机编译器 |'
- en: '| .ptx, .gpu | Intermediate virtual assembly files. | NVCC |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| .ptx, .gpu | 中间虚拟汇编文件。 | NVCC |'
- en: '| .cubin | Binary image of GPU code. | NVCC |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| .cubin | GPU 代码的二进制镜像。 | NVCC |'
- en: The generated executable file, or fat binary, contains one or more binary executable
    images for the different GPU generations. It also contains a PTX image, allowing
    the CUDA runtime to do just-in-time (JIT) compilation. This is very similar to
    Java byte code where the target is a virtual architecture, and this is compiled
    to the actual target hardware at the point the program is invoked. The PTX JIT
    compilation only happens if the executable does not contain a binary image that
    is identical to the GPU in use. Consequently, all future architectures are backward
    compatible with the basic-level virtual architecture. Even GPUs for which the
    program was not compiled will execute legacy GPU code by simply compiling at runtime
    the PTX code embedded in the executable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的可执行文件，或称为 fat binary，包含针对不同 GPU 代际的一个或多个二进制可执行镜像。它还包含一个 PTX 镜像，使得 CUDA 运行时可以进行即时（JIT）编译。这非常类似于
    Java 字节码，其中目标是虚拟架构，并在程序调用时编译为实际的目标硬件。只有当可执行文件不包含与当前使用的 GPU 完全相同的二进制镜像时，才会进行 PTX
    的 JIT 编译。因此，所有未来的架构都向下兼容基本的虚拟架构。即使是程序没有为其编译的 GPU，也会通过在运行时编译嵌入可执行文件中的 PTX 代码来执行遗留
    GPU 代码。
- en: Just as with Java, code depositories are supported. Defining the environment
    variable `CUDA_DEVCODE_CACHE` to point to a directory will cause the runtime to
    save the compiled binary for later use, thus avoiding the startup delay necessary
    to compile the PTX code for the unknown GPU variant every time it is invoked.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Java 一样，支持代码仓库。定义环境变量 `CUDA_DEVCODE_CACHE` 指向一个目录，将导致运行时保存已编译的二进制文件以供以后使用，从而避免每次调用时都需要为未知的
    GPU 变种编译 PTX 代码而产生的启动延迟。
- en: We cover in the later chapters how you can view the real target assembly code,
    the result of the PTX to target translation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中讲解如何查看实际的目标汇编代码，即 PTX 到目标翻译的结果。
- en: Error Handling
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: Error handling in CUDA, as with C in general, is not as good as it could be.
    There are few runtime checks performed, and if you do something stupid, the runtime
    will usually allow it. This results in GPU programs that exit strangely. If you
    are lucky, you will get an error message which, like compiler errors, you learn
    to interpret over time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: CUDA 中的错误处理和 C 语言一样，并没有做到最好。运行时检查很少，如果你做了些愚蠢的事，运行时通常会允许它。这导致 GPU 程序可能会异常退出。如果你幸运的话，可能会收到一个错误信息，像编译器错误一样，你会随着时间的推移学会如何解读这些错误信息。
- en: Almost all function calls in CUDA return the error type `cudaError_t`, which
    is simply an integer value. Any value other than `cudaSuccess` will indicate a
    fatal error. This is usually caused by your program not setting up something correctly
    prior to use, or using an object after it has been destroyed. It can also be caused
    by the GPU kernel timeout present in Microsoft Windows if the kernel runs for
    more than a few seconds and you have not disabled this when installing tools such
    as Parallel Nsight (see previous section). Out-of-bounds memory accesses may generate
    exceptions that will often print various error messages to `stderr` (standard
    error output).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的 CUDA 函数调用都返回错误类型 `cudaError_t`，它只是一个整数值。任何非 `cudaSuccess` 的值都表示发生了致命错误。通常这是因为你的程序在使用之前没有正确设置某些内容，或者在对象被销毁后仍然使用它。它也可能是由于
    Microsoft Windows 中存在的 GPU 内核超时问题引起的，如果内核运行超过几秒钟，并且在安装像 Parallel Nsight 这样的工具时没有禁用此功能（见前一节）。越界的内存访问可能会生成异常，通常会将各种错误信息打印到
    `stderr`（标准错误输出）。
- en: As every function returns an error code, every function call must be checked
    and some handler written. This makes for very tiresome and highly indented programming.
    For example,
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个函数都返回一个错误代码，因此每个函数调用都必须检查并编写一些处理程序。这会导致非常繁琐且高度缩进的编程。例如，
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To avoid this type of repetitive programming, throughout the book we will use
    the following macro definition to making calls to the CUDA API:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种重复的编程，本书中将使用以下宏定义来进行 CUDA API 的调用：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What this macro does is to allow you to specify `x` as some function call, for
    example,
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏的作用是允许你指定 `x` 为某个函数调用，例如，
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This then creates a temporary variable `a` and assigns to it the return value
    of the function, which is of type `cudaError_t`. It then checks if this is not
    equal to `cudaSuccess`, that is, the call encountered some error. If there was
    an error detected, it prints to the screen the error returned plus a short description
    of what the error means. It also uses the assert macro, which identifies the source
    file and line in which the error occurs so you can easily track down the point
    at which the error is being detected.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个临时变量 `a`，并将函数的返回值（类型为 `cudaError_t`）赋给它。然后，它检查该值是否不等于 `cudaSuccess`，也就是说，调用遇到了一些错误。如果检测到错误，它会在屏幕上打印出返回的错误以及对该错误的简短描述。它还使用了
    assert 宏，这会标识出错误发生的源文件和行号，从而帮助你轻松追踪错误被检测到的点。
- en: 'This technique works for all the CUDA calls except for the invocation of kernels.
    Kernels are the programs you write to run on the GPU. These are executed using
    the `<<<` and `>>>` operators as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术适用于所有 CUDA 调用，除了内核的调用。内核是你编写的在 GPU 上运行的程序。它们通过如下的 `<<<` 和 `>>>` 操作符执行：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For error checking of kernels, we’ll use the following function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内核的错误检查，我们将使用以下函数：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function should be called immediately after executing the kernel call.
    It checks for any immediate errors, and if so, prints an error message, resets
    the GPU, optionally waits for a key press via the `wait_exit` function, and then
    exits the program.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数应该在执行内核调用后立即调用。它检查任何即时错误，如果有的话，会打印错误信息，重置 GPU，选择性地通过 `wait_exit` 函数等待按键，并退出程序。
- en: Note that this is not foolproof, as the kernel call is asynchronous with the
    CPU code. That is, the GPU code is running in the background at the time we call
    `cudaPeekAtLastError`. If there has been no error detected *at this time*, then
    we see no error printed and the function continues to the next code line. Often
    that next code line will be a copy back from GPU memory to CPU memory. The error
    in the kernel may cause a subsequent API call to fail, which is almost always
    the next API call after the kernel call. Surrounding all calls to the API with
    the `CUDA_CALL` macro will flag the error at this point.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这并不是万无一失的，因为内核调用是与 CPU 代码异步的。也就是说，当我们调用 `cudaPeekAtLastError` 时，GPU 代码正在后台运行。如果此时没有检测到错误，那么我们就看不到任何错误信息，函数会继续执行到下一行代码。通常，下一行代码会是将数据从
    GPU 内存复制回 CPU 内存。内核中的错误可能会导致随后的 API 调用失败，这几乎总是发生在内核调用之后的下一个 API 调用。将所有 API 调用都用
    `CUDA_CALL` 宏包围起来，将在这一点标记错误。
- en: You can also force the kernel to complete prior to the error checking by simply
    inserting a call to `cudaDeviceSynchronize` prior to the `cudaPeekAtLastError`
    call. However, only do this on the debug version of the program or where you want
    the CPU to idle while the GPU is busy. As you should understand by the end of
    this text, such synchronous operation is good for debugging, but will harm performance,
    so you should be careful these calls do not remain in production code if they
    were inserted solely for debugging.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在`cudaPeekAtLastError`调用之前插入`cudaDeviceSynchronize`调用，强制内核在错误检查之前完成。然而，只有在调试版本的程序中或当你希望
    CPU 在 GPU 忙碌时处于空闲状态时才这么做。正如你在阅读完本文后应该理解的那样，这种同步操作有利于调试，但会损害性能，因此你应该小心，确保这些调用不会在生产代码中保留下来，除非它们是专门为调试插入的。
- en: Conclusion
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: You should now have a working installation of the CUDA SDK, including the GPU
    computing SDK samples and a debugging environment. You should be able to build
    a simple GPU SDK sample, such as the `deviceQuery` project, and have it identify
    the GPUs in your system when run.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该已经成功安装了 CUDA SDK，包括 GPU 计算 SDK 示例和调试环境。你应该能够构建一个简单的 GPU SDK 示例，例如 `deviceQuery`
    项目，并且能够在运行时识别你系统中的 GPU。
