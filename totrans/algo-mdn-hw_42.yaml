- en: Montgomery Multiplication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Montgomery 乘法
- en: 原文：[https://en.algorithmica.org/hpc/number-theory/montgomery/](https://en.algorithmica.org/hpc/number-theory/montgomery/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/number-theory/montgomery/](https://en.algorithmica.org/hpc/number-theory/montgomery/)
- en: Unsurprisingly, a large fraction of computation in [modular arithmetic](../modular)
    is often spent on calculating the modulo operation, which is as slow as [general
    integer division](/hpc/arithmetic/division/) and typically takes 15-20 cycles,
    depending on the operand size.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，[模运算](../modular)中的大量计算通常花费在计算模运算上，这和 [一般整数除法](/hpc/arithmetic/division/)一样慢，通常需要
    15-20 个周期，具体取决于操作数的大小。
- en: 'The best way to deal this nuisance is to avoid modulo operation altogether,
    delaying or replacing it with [predication](/hpc/pipelining/branchless), which
    can be done, for example, when calculating modular sums:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种麻烦的最佳方式是完全避免模运算，推迟或用 [预测](/hpc/pipelining/branchless) 来替换它，这可以在计算模和时做到，例如：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, sometimes you only have a chain of modular multiplications, and there
    is no good way to eel out of computing the remainder of the division — other than
    with the [integer division tricks](../hpc/arithmetic/division/) requiring a constant
    modulo and some precomputation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你只有一系列模乘法，没有好的方法可以避免计算除法的余数——除了使用 [整数除法技巧](../hpc/arithmetic/division/)，这需要一个常数模数和一些预计算。
- en: But there is another technique designed specifically for modular arithmetic,
    called *Montgomery multiplication*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有一种专门为模运算设计的技巧，称为 *Montgomery 乘法*。
- en: '### [#](https://en.algorithmica.org/hpc/number-theory/montgomery/#montgomery-space)Montgomery
    Space'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/number-theory/montgomery/#montgomery-space)Montgomery
    空间'
- en: Montgomery multiplication works by first transforming the multipliers into *Montgomery
    space*, where modular multiplication can be performed cheaply, and then transforming
    them back when their actual values are needed. Unlike general integer division
    methods, Montgomery multiplication is not efficient for performing just one modular
    reduction and only becomes worthwhile when there is a chain of modular operations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Montgomery 乘法通过首先将乘数转换到 *Montgomery 空间*，在那里模乘法可以以较低的成本进行，然后在需要它们的实际值时再转换回来。与一般的整数除法方法不同，Montgomery
    乘法在执行单个模数减少时并不高效，只有在存在一系列模运算时才变得有价值。
- en: The space is defined by the modulo $n$ and a positive integer $r \ge n$ coprime
    to $n$. The algorithm involves modulo and division by $r$, so in practice, $r$
    is chosen to be $2^{32}$ or $2^{64}$, so that these operations can be done with
    a right-shift and a bitwise AND respectively.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 该空间由模数 $n$ 和一个与 $n$ 互质的正整数 $r \ge n$ 定义。该算法涉及模运算和除以 $r$，因此实际上，$r$ 被选择为 $2^{32}$
    或 $2^{64}$，这样这些操作可以通过右移和位与来完成。
- en: '**Definition.** The *representative* $\bar x$ of a number $x$ in the Montgomery
    space is defined as'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义**。Montgomery 空间中一个数 $x$ 的 *代表* $\bar x$ 定义为'
- en: $$ \bar{x} = x \cdot r \bmod n $$
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: $$ \bar{x} = x \cdot r \bmod n $$
- en: Computing this transformation involves a multiplication and a modulo — an expensive
    operation that we wanted to optimize away in the first place — which is why we
    only use this method when the overhead of transforming numbers to and from the
    Montgomery space is worth it and not for general modular multiplication.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 计算这种转换涉及到一个乘法和模运算——这是一个昂贵的操作，我们最初就想优化掉，这就是为什么我们只在将数字转换到和从 Montgomery 空间转换的开销值得时才使用这种方法，而不是用于一般的模乘法。
- en: 'Inside the Montgomery space, addition, substraction, and checking for equality
    is performed as usual:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Montgomery 空间内，加法、减法和检查相等性是按常规进行的：
- en: '$$ x \cdot r + y \cdot r \equiv (x + y) \cdot r \bmod n $$ However, this is
    not the case for multiplication. Denoting multiplication in the Montgomery space
    as $*$ and the “normal” multiplication as $\cdot$, we expect the result to be:
    $$ \bar{x} * \bar{y} = \overline{x \cdot y} = (x \cdot y) \cdot r \bmod n $$ But
    the normal multiplication in the Montgomery space yields: $$ \bar{x} \cdot \bar{y}
    = (x \cdot y) \cdot r \cdot r \bmod n $$ Therefore, the multiplication in the
    Montgomery space is defined as $$ \bar{x} * \bar{y} = \bar{x} \cdot \bar{y} \cdot
    r^{-1} \bmod n $$'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: $$ x \cdot r + y \cdot r \equiv (x + y) \cdot r \bmod n $$ 然而，这在乘法中并不成立。将 Montgomery
    空间中的乘法表示为 $*$，将“常规”乘法表示为 $\cdot$，我们期望的结果是：$$ \bar{x} * \bar{y} = \overline{x \cdot
    y} = (x \cdot y) \cdot r \bmod n $$ 但在 Montgomery 空间中的常规乘法结果是：$$ \bar{x} \cdot
    \bar{y} = (x \cdot y) \cdot r \cdot r \bmod n $$ 因此，Montgomery 空间中的乘法定义为 $$ \bar{x}
    * \bar{y} = \bar{x} \cdot \bar{y} \cdot r^{-1} \bmod n $$
- en: This means that, after we normally multiply two numbers in the Montgomery space,
    we need to *reduce* the result by multiplying it by $r^{-1}$ and taking the modulo
    — and there is an efficent way to do this particular operation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，在我们在 Montgomery 空间中正常乘以两个数之后，我们需要通过乘以 $r^{-1}$ 并取模来 *化简* 结果——并且有一种有效的方法来完成这个特定的操作。
- en: '### [#](https://en.algorithmica.org/hpc/number-theory/montgomery/#montgomery-reduction)Montgomery
    reduction'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/number-theory/montgomery/#montgomery-reduction)Montgomery
    reduction'
- en: Assume that $r=2^{32}$, the modulo $n$ is 32-bit, and the number $x$ we need
    to reduce is 64-bit (the product of two 32-bit numbers). Our goal is to calculate
    $y = x \cdot r^{-1} \bmod n$.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 $r=2^{32}$，模 $n$ 是 32 位，而我们需要化简的数 $x$ 是 64 位（两个 32 位数的乘积）。我们的目标是计算 $y = x
    \cdot r^{-1} \bmod n$。
- en: Since $r$ is coprime with $n$, we know that there are two numbers $r^{-1}$ and
    $n^\prime$ in the $[0, n)$ range such that
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 $r$ 与 $n$ 互质，我们知道在 $[0, n)$ 范围内存在两个数 $r^{-1}$ 和 $n^\prime$，使得
- en: $$ r \cdot r^{-1} + n \cdot n^\prime = 1 $$
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: $$ r \cdot r^{-1} + n \cdot n^\prime = 1 $$
- en: and both $r^{-1}$ and $n^\prime$ can be computed, e.g., using the [extended
    Euclidean algorithm](../euclid-extended).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 $r^{-1}$ 和 $n^\prime$ 都可以计算，例如，使用 [扩展欧几里得算法](../euclid-extended)。
- en: Using this identity, we can express $r \cdot r^{-1}$ as $(1 - n \cdot n^\prime)$
    and write $x \cdot r^{-1}$ as
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个恒等式，我们可以将 $r \cdot r^{-1}$ 表示为 $(1 - n \cdot n^\prime)$，并将 $x \cdot r^{-1}$
    写作
- en: '$$ \begin{aligned} x \cdot r^{-1} &= x \cdot r \cdot r^{-1} / r \\ &= x \cdot
    (1 - n \cdot n^{\prime}) / r \\ &= (x - x \cdot n \cdot n^{\prime} ) / r \\ &\equiv
    (x - x \cdot n \cdot n^{\prime} + k \cdot r \cdot n) / r &\pmod n &\;\;\text{(for
    any integer $k$)} \\ &\equiv (x - (x \cdot n^{\prime} - k \cdot r) \cdot n) /
    r &\pmod n \end{aligned} $$ Now, if we choose $k$ to be $\lfloor x \cdot n^\prime
    / r \rfloor$ (the upper 64 bits of the $x \cdot n^\prime$ product), it will cancel
    out, and $(k \cdot r - x \cdot n^{\prime})$ will simply be equal to $x \cdot n^{\prime}
    \bmod r$ (the lower 32 bits of $x \cdot n^\prime$), implying: $$ x \cdot r^{-1}
    \equiv (x - x \cdot n^{\prime} \bmod r \cdot n) / r $$'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: $$ \begin{aligned} x \cdot r^{-1} &= x \cdot r \cdot r^{-1} / r \\ &= x \cdot
    (1 - n \cdot n^{\prime}) / r \\ &= (x - x \cdot n \cdot n^{\prime} ) / r \\ &\equiv
    (x - x \cdot n \cdot n^{\prime} + k \cdot r \cdot n) / r &\pmod n &\;\;\text{(对于任何整数
    $k$)} \\ &\equiv (x - (x \cdot n^{\prime} - k \cdot r) \cdot n) / r &\pmod n \end{aligned}
    $$ 现在，如果我们选择 $k$ 为 $\lfloor x \cdot n^\prime / r \rfloor$（$x \cdot n^\prime$ 乘积的上
    64 位），它将相互抵消，而 $(k \cdot r - x \cdot n^{\prime})$ 将简单地等于 $x \cdot n^{\prime} \bmod
    r$（$x \cdot n^\prime$ 的下 32 位），这意味着：$$ x \cdot r^{-1} \equiv (x - x \cdot n^{\prime}
    \bmod r \cdot n) / r $$
- en: The algorithm itself just evaluates this formula, performing two multiplications
    to calculate $q = x \cdot n^{\prime} \bmod r$ and $m = q \cdot n$, and then subtracts
    it from $x$ and right-shifts the result to divide it by $r$.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 算法本身只是评估这个公式，执行两次乘法来计算 $q = x \cdot n^{\prime} \bmod r$ 和 $m = q \cdot n$，然后从
    $x$ 中减去它，并将结果右移以除以 $r$。
- en: The only remaining thing to handle is that the result may not be in the $[0,
    n)$ range; but since
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 需要处理的是，结果可能不在 $[0, n)$ 的范围内；但既然
- en: $$ x < n \cdot n < r \cdot n \implies x / r < n $$ and $$ m = q \cdot n < r
    \cdot n \implies m / r < n $$ it is guaranteed that $$ -n < (x - m) / r < n $$
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: $$ x < n \cdot n < r \cdot n \implies x / r < n $$ 和 $$ m = q \cdot n < r \cdot
    n \implies m / r < n $$ 确保了 $$ -n < (x - m) / r < n $$
- en: 'Therefore, we can simply check if the result is negative and in that case,
    add $n$ to it, giving the following algorithm:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需检查结果是否为负，如果是，则将其加上 $n$，得到以下算法：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This last check is relatively cheap, but it is still on the critical path.
    If we are fine with the result being in the $[0, 2 \cdot n - 2]$ range instead
    of $[0, n)$, we can remove it and add $n$ to the result unconditionally:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这个检查相对便宜，但仍然在关键路径上。如果我们对结果在 $[0, 2 \cdot n - 2]$ 范围内而不是 $[0, n)$ 范围内没有问题，我们可以将其删除，并无条件地将
    $n$ 添加到结果中：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can also move the `>> 32` operation one step earlier in the computation graph
    and compute $\lfloor x / r \rfloor - \lfloor m / r \rfloor$ instead of $(x - m)
    / r$. This is correct because the lower 32 bits of $x$ and $m$ are equal anyway
    since
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将计算图中的 `>> 32` 操作提前一步，并计算 $\lfloor x / r \rfloor - \lfloor m / r \rfloor$
    而不是 $(x - m) / r$。这是正确的，因为 $x$ 和 $m$ 的低 32 位无论如何都是相同的
- en: $$ m = x \cdot n^\prime \cdot n \equiv x \pmod r $$
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: $$ m = x \cdot n^\prime \cdot n \equiv x \pmod r $$
- en: But why would we voluntarily choose to perfom two right-shifts instead of just
    one? This is beneficial because for `((u64) q * n) >> 32` we need to do a 32-by-32
    multiplication and take the upper 32 bits of the result (which the x86 `mul` instruction
    [already writes](../hpc/arithmetic/integer/#128-bit-integers) in a separate register,
    so it doesn’t cost anything), and the other right-shift `x >> 32` is not on the
    critical path.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么我们自愿选择执行两次右移而不是一次呢？这是因为对于`((u64) q * n) >> 32`，我们需要执行一个32位乘法并取结果的最高32位（x86的`mul`指令[已经写入](../hpc/arithmetic/integer/#128-bit-integers)一个单独的寄存器，所以这并不需要任何开销），而另一个右移`x
    >> 32`不在关键路径上。
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'One of the main advantages of Montgomery multiplication over other modular
    reduction methods is that it doesn’t require very large data types: it only needs
    a $r \times r$ multiplication that extracts the lower and higher $r$ bits of the
    result, which [has special support](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#ig_expand=7395,7392,7269,4868,7269,7269,1820,1835,6385,5051,4909,4918,5051,7269,6423,7410,150,2138,1829,1944,3009,1029,7077,519,5183,4462,4490,1944,5055,5012,5055&techs=AVX,AVX2&text=mul)
    on most hardware also makes it easily generalizable to [SIMD](../hpc/simd/) and
    larger data types:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Montgomery乘法相较于其他模数缩减方法的主要优势之一是它不需要非常大的数据类型：它只需要一个$r \times r$的乘法，该乘法提取结果的下$r$位和上$r$位，这在大多数硬件上[有特殊支持](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#ig_expand=7395,7392,7269,4868,7269,7269,1820,1835,6385,5051,4909,4918,5051,7269,6423,7410,150,2138,1829,1944,3009,1029,7077,519,5183,4462,4490,1944,5055,5012,5055&techs=AVX,AVX2&text=mul)，这也使得它很容易推广到[SIMD](../hpc/simd/)和更大的数据类型：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that a 128-by-64 modulo is not possible with general integer division
    tricks: the compiler [falls back](https://godbolt.org/z/fbEE4v4qr) to calling
    a slow [long arithmetic library function](https://github.com/llvm-mirror/compiler-rt/blob/69445f095c22aac2388f939bedebf224a6efcdaf/lib/builtins/udivmodti4.c#L22)
    to support it.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用通用的整数除法技巧无法进行128位对64位的模数运算：编译器[回退](https://godbolt.org/z/fbEE4v4qr)到调用一个慢速的[长算术库函数](https://github.com/llvm-mirror/compiler-rt/blob/69445f095c22aac2388f939bedebf224a6efcdaf/lib/builtins/udivmodti4.c#L22)来支持它。
- en: '### [#](https://en.algorithmica.org/hpc/number-theory/montgomery/#faster-inverse-and-transform)Faster
    Inverse and Transform'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/number-theory/montgomery/#faster-inverse-and-transform)
    更快的逆运算和转换'
- en: 'Montgomery multiplication itself is fast, but it requires some precomputation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Montgomery乘法本身很快，但它需要一些预计算：
- en: inverting $n$ modulo $r$ to compute $n^\prime$,
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算$n$对$r$取模以得到$n'$，
- en: transforming a number *to* the Montgomery space,
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个数*转换*到Montgomery空间，
- en: transforming a number *from* the Montgomery space.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个数从Montgomery空间*转换*出来。
- en: The last operation is already efficiently performed with the `reduce` procedure
    we just implemented, but the first two can be slightly optimized.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个操作已经通过我们刚刚实现的`reduce`过程高效地执行了，但前两个操作可以稍微优化。
- en: '**Computing the inverse** $n^\prime = n^{-1} \bmod r$ can be done faster than
    with the extended Euclidean algorithm by taking advantage of the fact that $r$
    is a power of two and using the following identity:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算逆元** $n'' = n^{-1} \bmod r$ 可以通过利用$r$是2的幂的事实，并使用以下恒等式来更快地完成，而不是使用扩展欧几里得算法：'
- en: '$$ a \cdot x \equiv 1 \bmod 2^k \implies a \cdot x \cdot (2 - a \cdot x) \equiv
    1 \bmod 2^{2k} $$ Proof: $$ \begin{aligned} a \cdot x \cdot (2 - a \cdot x) &=
    2 \cdot a \cdot x - (a \cdot x)^2 \\ &= 2 \cdot (1 + m \cdot 2^k) - (1 + m \cdot
    2^k)^2 \\ &= 2 + 2 \cdot m \cdot 2^k - 1 - 2 \cdot m \cdot 2^k - m^2 \cdot 2^{2k}
    \\ &= 1 - m^2 \cdot 2^{2k} \\ &\equiv 1 \bmod 2^{2k}. \end{aligned} $$'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: $$ a \cdot x \equiv 1 \bmod 2^k \implies a \cdot x \cdot (2 - a \cdot x) \equiv
    1 \bmod 2^{2k} $$ 证明：$$ \begin{aligned} a \cdot x \cdot (2 - a \cdot x) &= 2 \cdot
    a \cdot x - (a \cdot x)^2 \\ &= 2 \cdot (1 + m \cdot 2^k) - (1 + m \cdot 2^k)^2
    \\ &= 2 + 2 \cdot m \cdot 2^k - 1 - 2 \cdot m \cdot 2^k - m^2 \cdot 2^{2k} \\
    &= 1 - m^2 \cdot 2^{2k} \\ &\equiv 1 \bmod 2^{2k}. \end{aligned} $$
- en: We can start with $x = 1$ as the inverse of $a$ modulo $2^1$ and apply this
    identity exactly $\log_2 r$ times, each time doubling the number of bits in the
    inverse — somewhat reminiscent of [the Newton’s method](../hpc/arithmetic/newton/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从$x = 1$作为$a$模$2^1$的逆元开始，并应用这个恒等式正好$\log_2 r$次，每次将逆元的位数翻倍——这有点类似于[牛顿法](../hpc/arithmetic/newton/)。
- en: '**Transforming** a number into the Montgomery space can be done by multiplying
    it by $r$ and computing modulo [the usual way](../hpc/arithmetic/division/), but
    we can also take advantage of this relation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换**一个数到Montgomery空间可以通过乘以$r$并按[通常的方式](../hpc/arithmetic/division/)计算模数来完成，但我们可以利用这个关系：'
- en: $$ \bar{x} = x \cdot r \bmod n = x * r^2 $$
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: $$ \bar{x} = x \cdot r \bmod n = x \cdot r^2 $$
- en: Transforming a number into the space is just a multiplication by $r^2$. Therefore,
    we can precompute $r^2 \bmod n$ and perform a multiplication and reduction instead
    — which may or may not be actually faster because multiplying a number by $r=2^{k}$
    can be implemented with a left-shift, while multiplication by $r^2 \bmod n$ can
    not.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个数转换到该空间中只是一个乘以$r^2$的操作。因此，我们可以预先计算$r^2 \bmod n$并执行乘法和减少操作——这实际上可能更快或更慢，因为将一个数乘以$r=2^{k}$可以通过左移实现，而乘以$r^2
    \bmod n$则不能。
- en: '### [#](https://en.algorithmica.org/hpc/number-theory/montgomery/#complete-implementation)Complete
    Implementation'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '### [完整实现](https://en.algorithmica.org/hpc/number-theory/montgomery/#complete-implementation)'
- en: 'It is convenient to wrap everything into a single `constexpr` structure:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容包装在一个单独的`constexpr`结构体中是很方便的：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To test its performance, we can plug Montgomery multiplication into the [binary
    exponentiation](../hpc/number-theory/exponentiation/):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试其性能，我们可以将蒙哥马利乘法插入到[二进制指数运算](../hpc/number-theory/exponentiation/)中：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While vanilla binary exponentiation with a compiler-generated fast modulo trick
    requires ~170ns per `inverse` call, this implementation takes ~166ns, going down
    to ~158ns we omit `transform` and `reduce` (a reasonable use case is for `inverse`
    to be used as a subprocedure in a bigger modular computation). This is a small
    improvement, but Montgomery multiplication becomes much more advantageous for
    SIMD applications and larger data types.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 而使用编译器生成的快速模运算技巧的普通二进制指数运算每次`inverse`调用需要大约170ns，这个实现需要大约166ns，如果我们省略`transform`和`reduce`，则可以降低到大约158ns（一个合理的用例是将`inverse`用作更大模运算子程序的一部分）。这是一个小的改进，但蒙哥马利乘法对于SIMD应用和更大的数据类型变得更加有利。
- en: '**Exercise.** Implement efficient *modular* [matix multiplication](/hpc/algorithms/matmul).
    [← Extended Euclidean Algorithm](https://en.algorithmica.org/hpc/number-theory/euclid-extended/)[../External
    Memory →](https://en.algorithmica.org/hpc/external-memory/)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习。** 实现高效的*模*矩阵乘法[矩阵乘法](/hpc/algorithms/matmul)。[← 扩展欧几里得算法](https://en.algorithmica.org/hpc/number-theory/euclid-extended/)[→
    外部存储](https://en.algorithmica.org/hpc/external-memory/)'
