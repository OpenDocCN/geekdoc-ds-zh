- en: Montgomery Multiplication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://en.algorithmica.org/hpc/number-theory/montgomery/](https://en.algorithmica.org/hpc/number-theory/montgomery/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unsurprisingly, a large fraction of computation in [modular arithmetic](../modular)
    is often spent on calculating the modulo operation, which is as slow as [general
    integer division](/hpc/arithmetic/division/) and typically takes 15-20 cycles,
    depending on the operand size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to deal this nuisance is to avoid modulo operation altogether,
    delaying or replacing it with [predication](/hpc/pipelining/branchless), which
    can be done, for example, when calculating modular sums:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, sometimes you only have a chain of modular multiplications, and there
    is no good way to eel out of computing the remainder of the division — other than
    with the [integer division tricks](../hpc/arithmetic/division/) requiring a constant
    modulo and some precomputation.
  prefs: []
  type: TYPE_NORMAL
- en: But there is another technique designed specifically for modular arithmetic,
    called *Montgomery multiplication*.
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/number-theory/montgomery/#montgomery-space)Montgomery
    Space'
  prefs: []
  type: TYPE_NORMAL
- en: Montgomery multiplication works by first transforming the multipliers into *Montgomery
    space*, where modular multiplication can be performed cheaply, and then transforming
    them back when their actual values are needed. Unlike general integer division
    methods, Montgomery multiplication is not efficient for performing just one modular
    reduction and only becomes worthwhile when there is a chain of modular operations.
  prefs: []
  type: TYPE_NORMAL
- en: The space is defined by the modulo $n$ and a positive integer $r \ge n$ coprime
    to $n$. The algorithm involves modulo and division by $r$, so in practice, $r$
    is chosen to be $2^{32}$ or $2^{64}$, so that these operations can be done with
    a right-shift and a bitwise AND respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition.** The *representative* $\bar x$ of a number $x$ in the Montgomery
    space is defined as'
  prefs: []
  type: TYPE_NORMAL
- en: $$ \bar{x} = x \cdot r \bmod n $$
  prefs: []
  type: TYPE_NORMAL
- en: Computing this transformation involves a multiplication and a modulo — an expensive
    operation that we wanted to optimize away in the first place — which is why we
    only use this method when the overhead of transforming numbers to and from the
    Montgomery space is worth it and not for general modular multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the Montgomery space, addition, substraction, and checking for equality
    is performed as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '$$ x \cdot r + y \cdot r \equiv (x + y) \cdot r \bmod n $$ However, this is
    not the case for multiplication. Denoting multiplication in the Montgomery space
    as $*$ and the “normal” multiplication as $\cdot$, we expect the result to be:
    $$ \bar{x} * \bar{y} = \overline{x \cdot y} = (x \cdot y) \cdot r \bmod n $$ But
    the normal multiplication in the Montgomery space yields: $$ \bar{x} \cdot \bar{y}
    = (x \cdot y) \cdot r \cdot r \bmod n $$ Therefore, the multiplication in the
    Montgomery space is defined as $$ \bar{x} * \bar{y} = \bar{x} \cdot \bar{y} \cdot
    r^{-1} \bmod n $$'
  prefs: []
  type: TYPE_NORMAL
- en: This means that, after we normally multiply two numbers in the Montgomery space,
    we need to *reduce* the result by multiplying it by $r^{-1}$ and taking the modulo
    — and there is an efficent way to do this particular operation.
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/number-theory/montgomery/#montgomery-reduction)Montgomery
    reduction'
  prefs: []
  type: TYPE_NORMAL
- en: Assume that $r=2^{32}$, the modulo $n$ is 32-bit, and the number $x$ we need
    to reduce is 64-bit (the product of two 32-bit numbers). Our goal is to calculate
    $y = x \cdot r^{-1} \bmod n$.
  prefs: []
  type: TYPE_NORMAL
- en: Since $r$ is coprime with $n$, we know that there are two numbers $r^{-1}$ and
    $n^\prime$ in the $[0, n)$ range such that
  prefs: []
  type: TYPE_NORMAL
- en: $$ r \cdot r^{-1} + n \cdot n^\prime = 1 $$
  prefs: []
  type: TYPE_NORMAL
- en: and both $r^{-1}$ and $n^\prime$ can be computed, e.g., using the [extended
    Euclidean algorithm](../euclid-extended).
  prefs: []
  type: TYPE_NORMAL
- en: Using this identity, we can express $r \cdot r^{-1}$ as $(1 - n \cdot n^\prime)$
    and write $x \cdot r^{-1}$ as
  prefs: []
  type: TYPE_NORMAL
- en: '$$ \begin{aligned} x \cdot r^{-1} &= x \cdot r \cdot r^{-1} / r \\ &= x \cdot
    (1 - n \cdot n^{\prime}) / r \\ &= (x - x \cdot n \cdot n^{\prime} ) / r \\ &\equiv
    (x - x \cdot n \cdot n^{\prime} + k \cdot r \cdot n) / r &\pmod n &\;\;\text{(for
    any integer $k$)} \\ &\equiv (x - (x \cdot n^{\prime} - k \cdot r) \cdot n) /
    r &\pmod n \end{aligned} $$ Now, if we choose $k$ to be $\lfloor x \cdot n^\prime
    / r \rfloor$ (the upper 64 bits of the $x \cdot n^\prime$ product), it will cancel
    out, and $(k \cdot r - x \cdot n^{\prime})$ will simply be equal to $x \cdot n^{\prime}
    \bmod r$ (the lower 32 bits of $x \cdot n^\prime$), implying: $$ x \cdot r^{-1}
    \equiv (x - x \cdot n^{\prime} \bmod r \cdot n) / r $$'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm itself just evaluates this formula, performing two multiplications
    to calculate $q = x \cdot n^{\prime} \bmod r$ and $m = q \cdot n$, and then subtracts
    it from $x$ and right-shifts the result to divide it by $r$.
  prefs: []
  type: TYPE_NORMAL
- en: The only remaining thing to handle is that the result may not be in the $[0,
    n)$ range; but since
  prefs: []
  type: TYPE_NORMAL
- en: $$ x < n \cdot n < r \cdot n \implies x / r < n $$ and $$ m = q \cdot n < r
    \cdot n \implies m / r < n $$ it is guaranteed that $$ -n < (x - m) / r < n $$
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can simply check if the result is negative and in that case,
    add $n$ to it, giving the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This last check is relatively cheap, but it is still on the critical path.
    If we are fine with the result being in the $[0, 2 \cdot n - 2]$ range instead
    of $[0, n)$, we can remove it and add $n$ to the result unconditionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can also move the `>> 32` operation one step earlier in the computation graph
    and compute $\lfloor x / r \rfloor - \lfloor m / r \rfloor$ instead of $(x - m)
    / r$. This is correct because the lower 32 bits of $x$ and $m$ are equal anyway
    since
  prefs: []
  type: TYPE_NORMAL
- en: $$ m = x \cdot n^\prime \cdot n \equiv x \pmod r $$
  prefs: []
  type: TYPE_NORMAL
- en: But why would we voluntarily choose to perfom two right-shifts instead of just
    one? This is beneficial because for `((u64) q * n) >> 32` we need to do a 32-by-32
    multiplication and take the upper 32 bits of the result (which the x86 `mul` instruction
    [already writes](../hpc/arithmetic/integer/#128-bit-integers) in a separate register,
    so it doesn’t cost anything), and the other right-shift `x >> 32` is not on the
    critical path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the main advantages of Montgomery multiplication over other modular
    reduction methods is that it doesn’t require very large data types: it only needs
    a $r \times r$ multiplication that extracts the lower and higher $r$ bits of the
    result, which [has special support](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#ig_expand=7395,7392,7269,4868,7269,7269,1820,1835,6385,5051,4909,4918,5051,7269,6423,7410,150,2138,1829,1944,3009,1029,7077,519,5183,4462,4490,1944,5055,5012,5055&techs=AVX,AVX2&text=mul)
    on most hardware also makes it easily generalizable to [SIMD](../hpc/simd/) and
    larger data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that a 128-by-64 modulo is not possible with general integer division
    tricks: the compiler [falls back](https://godbolt.org/z/fbEE4v4qr) to calling
    a slow [long arithmetic library function](https://github.com/llvm-mirror/compiler-rt/blob/69445f095c22aac2388f939bedebf224a6efcdaf/lib/builtins/udivmodti4.c#L22)
    to support it.'
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/number-theory/montgomery/#faster-inverse-and-transform)Faster
    Inverse and Transform'
  prefs: []
  type: TYPE_NORMAL
- en: 'Montgomery multiplication itself is fast, but it requires some precomputation:'
  prefs: []
  type: TYPE_NORMAL
- en: inverting $n$ modulo $r$ to compute $n^\prime$,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: transforming a number *to* the Montgomery space,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: transforming a number *from* the Montgomery space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last operation is already efficiently performed with the `reduce` procedure
    we just implemented, but the first two can be slightly optimized.
  prefs: []
  type: TYPE_NORMAL
- en: '**Computing the inverse** $n^\prime = n^{-1} \bmod r$ can be done faster than
    with the extended Euclidean algorithm by taking advantage of the fact that $r$
    is a power of two and using the following identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '$$ a \cdot x \equiv 1 \bmod 2^k \implies a \cdot x \cdot (2 - a \cdot x) \equiv
    1 \bmod 2^{2k} $$ Proof: $$ \begin{aligned} a \cdot x \cdot (2 - a \cdot x) &=
    2 \cdot a \cdot x - (a \cdot x)^2 \\ &= 2 \cdot (1 + m \cdot 2^k) - (1 + m \cdot
    2^k)^2 \\ &= 2 + 2 \cdot m \cdot 2^k - 1 - 2 \cdot m \cdot 2^k - m^2 \cdot 2^{2k}
    \\ &= 1 - m^2 \cdot 2^{2k} \\ &\equiv 1 \bmod 2^{2k}. \end{aligned} $$'
  prefs: []
  type: TYPE_NORMAL
- en: We can start with $x = 1$ as the inverse of $a$ modulo $2^1$ and apply this
    identity exactly $\log_2 r$ times, each time doubling the number of bits in the
    inverse — somewhat reminiscent of [the Newton’s method](../hpc/arithmetic/newton/).
  prefs: []
  type: TYPE_NORMAL
- en: '**Transforming** a number into the Montgomery space can be done by multiplying
    it by $r$ and computing modulo [the usual way](../hpc/arithmetic/division/), but
    we can also take advantage of this relation:'
  prefs: []
  type: TYPE_NORMAL
- en: $$ \bar{x} = x \cdot r \bmod n = x * r^2 $$
  prefs: []
  type: TYPE_NORMAL
- en: Transforming a number into the space is just a multiplication by $r^2$. Therefore,
    we can precompute $r^2 \bmod n$ and perform a multiplication and reduction instead
    — which may or may not be actually faster because multiplying a number by $r=2^{k}$
    can be implemented with a left-shift, while multiplication by $r^2 \bmod n$ can
    not.
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/number-theory/montgomery/#complete-implementation)Complete
    Implementation'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is convenient to wrap everything into a single `constexpr` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To test its performance, we can plug Montgomery multiplication into the [binary
    exponentiation](../hpc/number-theory/exponentiation/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While vanilla binary exponentiation with a compiler-generated fast modulo trick
    requires ~170ns per `inverse` call, this implementation takes ~166ns, going down
    to ~158ns we omit `transform` and `reduce` (a reasonable use case is for `inverse`
    to be used as a subprocedure in a bigger modular computation). This is a small
    improvement, but Montgomery multiplication becomes much more advantageous for
    SIMD applications and larger data types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise.** Implement efficient *modular* [matix multiplication](/hpc/algorithms/matmul).
    [← Extended Euclidean Algorithm](https://en.algorithmica.org/hpc/number-theory/euclid-extended/)[../External
    Memory →](https://en.algorithmica.org/hpc/external-memory/)'
  prefs: []
  type: TYPE_NORMAL
