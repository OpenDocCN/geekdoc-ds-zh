- en: Indirect Branching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接分支
- en: 原文：[https://en.algorithmica.org/hpc/architecture/indirect/](https://en.algorithmica.org/hpc/architecture/indirect/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/architecture/indirect/](https://en.algorithmica.org/hpc/architecture/indirect/)
- en: During assembly, all labels are converted to addresses (absolute or relative)
    and then encoded into jump instructions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编过程中，所有标签都被转换为地址（绝对或相对），然后编码成跳转指令。
- en: 'You can also jump by a non-constant value stored inside a register, which is
    called a *computed jump*:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过存储在寄存器中的非常量值进行跳转，这被称为*计算跳转*：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This has a few interesting applications related to dynamic languages and implementing
    more complex control flow.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这有几个与动态语言和实现更复杂控制流相关的有趣应用。
- en: '### [#](https://en.algorithmica.org/hpc/architecture/indirect/#multiway-branch)Multiway
    Branch'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/architecture/indirect/#multiway-branch)多路分支'
- en: 'If you have already forgotten what a `switch` statement does, here is a little
    subroutine for calculating GPA in the American grading system:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经忘记了`switch`语句的作用，这里有一个用于计算美国评分系统GPA的小子程序：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I personally don’t remember the last time I used a switch in a non-educational
    context. In general, switch statements are equivalent to a sequence of “if, else
    if, else if, else if…” and so on, and for this reason many languages don’t even
    have them. Nonetheless, such control flow structures are important for implementing
    parsers, interpreters, and other state machines, which are often comprised of
    a single `while (true)` loop and a `switch (state)` statement inside.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人不记得上一次在非教育环境中使用`switch`语句是什么时候了。一般来说，`switch`语句相当于一系列的“if, else if, else
    if, else if...”等等，因此许多语言甚至没有它们。尽管如此，这样的控制流结构对于实现解析器、解释器和其它状态机来说是非常重要的，这些通常由一个`while
    (true)`循环和一个`switch (state)`语句组成。
- en: When we have control over the range of values that the variable can take, we
    can use the following trick utilizing computed jumps. Instead of making $n$ conditional
    branches, we can create a *branch table* that contains pointers/offsets to possible
    jump locations, and then just index it with the `state` variable taking values
    in the $[0, n)$ range.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们控制变量可以取的值的范围时，我们可以使用以下技巧，利用计算跳转。我们不是创建$n$个条件分支，而是创建一个*分支表*，其中包含指向可能的跳转位置的指针/偏移量，然后只需用`state`变量索引它，该变量在$[0,
    n)$范围内取值。
- en: 'Compilers use this technique when the values are densely packed together (not
    necessarily strictly sequentially, but it has to be worth having blank fields
    in the table). It can also be implemented explicitly with a *computed goto*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当值密集地打包在一起时（不一定严格按顺序，但表格中必须有空白字段是值得的），编译器会使用这种技术。它也可以通过*计算跳转*显式实现：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Switch-based code is not always straightforward for compilers to optimize, so
    in the context of state machines, `goto` statements are often used directly. The
    I/O-related part of `glibc` is full of examples.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`switch`的代码并不总是对编译器优化来说简单直接，因此在状态机的上下文中，`goto`语句经常被直接使用。`glibc`的I/O相关部分充满了这样的例子。
- en: '### [#](https://en.algorithmica.org/hpc/architecture/indirect/#dynamic-dispatch)Dynamic
    Dispatch'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/architecture/indirect/#dynamic-dispatch)动态分派'
- en: Indirect branching is also instrumental in implementing runtime polymorphism.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 间接分支对于实现运行时多态也是非常重要的。
- en: 'Consider the cliché example when we have an abstract class of `Animal` with
    a virtual `.speak()` method, and two concrete implementations: a `Dog` that barks
    and a `Cat` that meows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个陈词滥调的例子，当我们有一个具有虚拟`.speak()`方法的`Animal`抽象类，以及两个具体实现：一个吠叫的`Dog`和一个喵喵叫的`Cat`：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We want to create an animal and, without knowing its type in advance, call
    its `.speak()` method, which should somehow invoke the right implementation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建一个动物，并且在不事先知道其类型的情况下，调用其`.speak()`方法，该方法应该以某种方式调用正确的实现：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are many ways to implement this behavior, but C++ does it using a *virtual
    method table*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种行为有许多方法，但C++使用*虚方法表*来实现。
- en: For all concrete implementations of `Animal`, compiler pads all their methods
    (that is, their instruction sequences) so that they have the exact same length
    for all classes (by inserting some [filler instructions](../layout) after `ret`)
    and then just writes them sequentially somewhere in the instruction memory. Then
    it adds a *run-time type information* field to the structure (that is, to all
    its instances), which is essentially just the offset in the memory region that
    points to the right implementation of the virtual methods of the class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Animal`的所有具体实现，编译器都会填充它们的所有方法（即它们的指令序列），以确保所有类都具有相同的长度（通过在`ret`指令后插入一些[填充指令](../layout)来实现），然后只需将它们顺序地写入指令内存中的某个位置。然后，它会在结构体（即所有实例）中添加一个*运行时类型信息*字段，这本质上只是指向类虚拟方法的正确实现的内存区域中的偏移量。
- en: With a virtual method call, that offset field is fetched from the instance of
    a structure and a normal function call is made with it, using the fact that all
    methods and other fields of every derived class have exactly the same offsets.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟方法调用时，该偏移字段是从结构体的实例中获取的，然后使用它进行常规函数调用，利用的事实是每个派生类的所有方法和其他字段都具有完全相同的偏移量。
- en: 'Of course, this adds some overhead:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这会增加一些开销：
- en: You may need to spend another 15 cycles or so for the same pipeline flushing
    reasons as for [branch misprediction](/hpc/pipelining).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能还需要额外花费大约15个周期，原因与[分支预测错误](/hpc/pipelining)相同。
- en: The compiler most likely won’t be able to inline the function call itself.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器很可能无法内联函数调用本身。
- en: Class size increases by a couple of bytes or so (this is implementation-specific).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的大小会增加几个字节左右（这取决于具体实现）。
- en: The binary size itself increases a little bit.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制文件本身会稍微增大一点。
- en: For these reasons, runtime polymorphism is usually avoided in performance-critical
    applications. [← Functions and Recursion](https://en.algorithmica.org/hpc/architecture/functions/)[Machine
    Code Layout →](https://en.algorithmica.org/hpc/architecture/layout/)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，在性能关键的应用中通常避免使用运行时多态。[← 函数和递归](https://en.algorithmica.org/hpc/architecture/functions/)[机器代码布局
    →](https://en.algorithmica.org/hpc/architecture/layout/)
