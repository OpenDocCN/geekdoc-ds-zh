- en: 22Â Avoiding Recomputation by Remembering AnswersğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 22 é¿å…é‡å¤è®¡ç®—é€šè¿‡è®°ä½ç­”æ¡ˆğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/avoid-recomp.html](https://dcic-world.org/2025-08-27/avoid-recomp.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/avoid-recomp.html](https://dcic-world.org/2025-08-27/avoid-recomp.html)
- en: '| Â Â Â Â [22.1Â An Interesting Numeric Sequence](#%28part._.An_.Interesting_.Numeric_.Sequence%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| [22.1 ä¸€ä¸ªæœ‰è¶£çš„æ•°å­—åºåˆ—](#%28part._.An_.Interesting_.Numeric_.Sequence%29) |'
- en: '| Â Â Â Â Â Â [22.1.1Â Using State to Remember Past Answers](#%28part._.Using_.State_to_.Remember_.Past_.Answers%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| [22.1.1 ä½¿ç”¨çŠ¶æ€æ¥è®°ä½è¿‡å»çš„ç­”æ¡ˆ](#%28part._.Using_.State_to_.Remember_.Past_.Answers%29)
    |'
- en: '| Â Â Â Â Â Â [22.1.2Â From a Tree of Computation to a DAG](#%28part._.From_a_.Tree_of_.Computation_to_a_.D.A.G%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| [22.1.2 ä»è®¡ç®—æ ‘åˆ°æœ‰å‘æ— ç¯å›¾](#%28part._.From_a_.Tree_of_.Computation_to_a_.D.A.G%29)
    |'
- en: '| Â Â Â Â Â Â [22.1.3Â The Complexity of Numbers](#%28part._numbers-not-constant%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| [22.1.3 æ•°å­—å¤æ‚æ€§](#%28part._numbers-not-constant%29) |'
- en: '| Â Â Â Â Â Â [22.1.4Â Abstracting Memoization](#%28part._.Abstracting_.Memoization%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| [22.1.4 æŠ½è±¡è®°å¿†åŒ–](#%28part._.Abstracting_.Memoization%29) |'
- en: '| Â Â Â Â [22.2Â Edit-Distance for Spelling Correction](#%28part._levenshtein%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| [22.2 ç¼–è¾‘è·ç¦»ç”¨äºæ‹¼å†™çº æ­£](#%28part._levenshtein%29) |'
- en: '| Â Â Â Â [22.3Â Nature as a Fat-Fingered Typist](#%28part._smith-waterman%29) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| [22.3 è‡ªç„¶ä½œä¸ºç¬¨æ‹™çš„æ‰“å­—å‘˜](#%28part._smith-waterman%29) |'
- en: '| Â Â Â Â [22.4Â Dynamic Programming](#%28part._.Dynamic_.Programming%29) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| [22.4 åŠ¨æ€è§„åˆ’](#%28part._.Dynamic_.Programming%29) |'
- en: '| Â Â Â Â Â Â [22.4.1Â Catalan Numbers with Dynamic Programming](#%28part._.Catalan_.Numbers_with_.Dynamic_.Programming%29)
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| [22.4.1 ä½¿ç”¨åŠ¨æ€è§„åˆ’çš„ Catalan æ•°](#%28part._.Catalan_.Numbers_with_.Dynamic_.Programming%29)
    |'
- en: '| Â Â Â Â Â Â [22.4.2Â Levenshtein Distance and Dynamic Programming](#%28part._.Levenshtein_.Distance_and_.Dynamic_.Programming%29)
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| [22.4.2 Levenshtein è·ç¦»ä¸åŠ¨æ€è§„åˆ’](#%28part._.Levenshtein_.Distance_and_.Dynamic_.Programming%29)
    |'
- en: '| Â Â Â Â [22.5Â Contrasting Memoization and Dynamic Programming](#%28part._memo-vs-dp%29)
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| [22.5 å¯¹æ¯”è®°å¿†åŒ–å’ŒåŠ¨æ€è§„åˆ’](#%28part._memo-vs-dp%29) |'
- en: We have on several instances already referred to a [â˜› space-time tradeoff](glossary.html#%28elem._glossary-space-time._tradeoff%29).
    The most obvious tradeoff is when a computation â€œremembersâ€ prior results and,
    instead of recomputing them, looks them up and returns the answers. This is an
    instance of the tradeoff because it uses space (to remember prior answers) in
    place of time (recomputing the answer). Letâ€™s see how we can write such computations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»åœ¨å‡ ä¸ªå®ä¾‹ä¸­æåˆ°äº†[â˜› ç©ºé—´-æ—¶é—´æƒè¡¡](glossary.html#%28elem._glossary-space-time._tradeoff%29)ã€‚æœ€æ˜æ˜¾çš„æƒè¡¡æ˜¯åœ¨è®¡ç®—â€œè®°ä½â€å…ˆå‰ç»“æœçš„æƒ…å†µä¸‹ï¼Œè€Œä¸æ˜¯é‡æ–°è®¡ç®—å®ƒä»¬ï¼Œè€Œæ˜¯æŸ¥æ‰¾å¹¶è¿”å›ç­”æ¡ˆã€‚è¿™æ˜¯ä¸€ä¸ªæƒè¡¡çš„ä¾‹å­ï¼Œå› ä¸ºå®ƒä½¿ç”¨ç©ºé—´ï¼ˆè®°ä½å…ˆå‰ç­”æ¡ˆï¼‰æ¥ä»£æ›¿æ—¶é—´ï¼ˆé‡æ–°è®¡ç®—ç­”æ¡ˆï¼‰ã€‚è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬å¦‚ä½•ç¼–å†™è¿™æ ·çš„è®¡ç®—ã€‚
- en: 22.1Â An Interesting Numeric Sequence[ğŸ”—](#(part._.An_.Interesting_.Numeric_.Sequence)
    "Link to here")
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.1 ä¸€ä¸ªæœ‰è¶£çš„æ•°å­—åºåˆ—[ğŸ”—](#(part._.An_.Interesting_.Numeric_.Sequence) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Suppose we want to create properly-parenthesized expressions, and ignore all
    non-parenthetical symbols. How many ways are there of creating parenthesized expressions
    given a certain number of opening (equivalently, closing) parentheses?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æƒ³è¦åˆ›å»ºæ­£ç¡®æ‹¬å·çš„è¡¨è¾¾å¼ï¼Œå¹¶å¿½ç•¥æ‰€æœ‰éæ‹¬å·ç¬¦å·ã€‚ç»™å®šä¸€å®šæ•°é‡çš„å¼€æ‹¬å·ï¼ˆç­‰ä»·äºé—­æ‹¬å·ï¼‰ï¼Œæœ‰å¤šå°‘ç§åˆ›å»ºæ‹¬å·è¡¨è¾¾å¼çš„å¯èƒ½æ€§ï¼Ÿ
- en: If we have zero opening parentheses, the only expression we can create is the
    empty expression. If we have one opening parenthesis, the only one we can construct
    is â€œ()â€ (there must be a closing parenthesis since weâ€™re interested only in properly-parenthesized
    expressions). If we have two opening parentheses, we can construct â€œ(())â€ and
    â€œ()()â€. Given three, we can construct â€œ((()))â€, â€œ(())()â€, â€œ()(())â€, â€œ()()()â€,
    and â€œ(()())â€, for a total of five. And so on. Observe that the solutions at each
    level use all the possible solutions at one level lower, combined in all the possible
    ways.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æ²¡æœ‰ä»»ä½•å¼€æ‹¬å·ï¼Œæˆ‘ä»¬èƒ½åˆ›å»ºçš„å”¯ä¸€è¡¨è¾¾å¼æ˜¯ç©ºè¡¨è¾¾å¼ã€‚å¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªå¼€æ‹¬å·ï¼Œæˆ‘ä»¬èƒ½æ„é€ çš„åªæœ‰â€œ()â€ï¼ˆç”±äºæˆ‘ä»¬åªå¯¹æ­£ç¡®æ‹¬å·çš„è¡¨è¾¾å¼æ„Ÿå…´è¶£ï¼Œæ‰€ä»¥å¿…é¡»æœ‰é—­æ‹¬å·ï¼‰ã€‚å¦‚æœæˆ‘ä»¬æœ‰ä¸¤ä¸ªå¼€æ‹¬å·ï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ â€œ(())â€å’Œâ€œ()()â€ã€‚ç»™å®šä¸‰ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ â€œ((()))â€ï¼Œâ€œ(())()â€ï¼Œâ€œ()(())â€ï¼Œâ€œ()()()â€å’Œâ€œ(()())â€ï¼Œæ€»å…±äº”ç§ã€‚ä»¥æ­¤ç±»æ¨ã€‚è§‚å¯Ÿæ¯ä¸ªçº§åˆ«çš„è§£å†³æ–¹æ¡ˆéƒ½ä½¿ç”¨äº†è¾ƒä½ä¸€çº§åˆ«æ‰€æœ‰å¯èƒ½çš„è§£å†³æ–¹æ¡ˆï¼Œå¹¶ä»¥æ‰€æœ‰å¯èƒ½çš„æ–¹å¼ç»„åˆã€‚
- en: 'There is actually a famous mathematical sequence that corresponds to the number
    of such expressions, called the [Catalan sequence](http://en.wikipedia.org/wiki/Catalan_number).
    It has the property of growing quite large very quickly: starting from the modest
    origins above, the tenth Catalan number (i.e., tenth element of the Catalan sequence)
    is 16796\. A simple recurrence formula gives us the Catalan number, which we can
    turn into a simple program:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šæœ‰ä¸€ä¸ªè‘—åçš„æ•°å­¦åºåˆ—å¯¹åº”äºè¿™ç§è¡¨è¾¾å¼çš„æ•°é‡ï¼Œç§°ä¸º[åŠ æ³°ç½—å°¼äºšæ•°åˆ—](http://en.wikipedia.org/wiki/Catalan_number)ã€‚å®ƒå…·æœ‰å¿«é€Ÿå¢é•¿çš„ç‰¹æ€§ï¼šä»ä¸Šé¢ä¸èµ·çœ¼çš„èµ·æºå¼€å§‹ï¼Œç¬¬åä¸ªåŠ æ³°ç½—å°¼äºšæ•°ï¼ˆå³åŠ æ³°ç½—å°¼äºšæ•°åˆ—çš„ç¬¬åä¸ªå…ƒç´ ï¼‰æ˜¯16796ã€‚ä¸€ä¸ªç®€å•çš„é€’å½’å…¬å¼ç»™å‡ºäº†åŠ æ³°ç½—å°¼äºšæ•°ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶è½¬åŒ–ä¸ºä¸€ä¸ªç®€å•çš„ç¨‹åºï¼š
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This functionâ€™s tests look as followsâ€”<wbr>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå‡½æ•°çš„æµ‹è¯•çœ‹èµ·æ¥å¦‚ä¸‹â€”â€”<wbr>
- en: <catalan-tests> ::=
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <catalan-tests> ::=
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: but beware! When we time the functionâ€™s execution, we find that the first few
    tests run very quickly, but somewhere between a value of `10` and `20`â€”<wbr>depending
    on your machine and programming language implementationâ€”<wbr>you ought to see
    things start to slow down, first a little, then with extreme effect.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è¦å°å¿ƒï¼å½“æˆ‘ä»¬è®¡æ—¶å‡½æ•°çš„æ‰§è¡Œæ—¶ï¼Œæˆ‘ä»¬å‘ç°å‰å‡ ä¸ªæµ‹è¯•è¿è¡Œå¾—éå¸¸å¿«ï¼Œä½†å¤§çº¦åœ¨`10`åˆ°`20`ä¹‹é—´â€”â€”<wbr>è¿™å–å†³äºä½ çš„æœºå™¨å’Œç¼–ç¨‹è¯­è¨€å®ç°â€”â€”<wbr>ä½ åº”è¯¥çœ‹åˆ°äº‹æƒ…å¼€å§‹å˜æ…¢ï¼Œå…ˆæ˜¯ç¨å¾®æ…¢ä¸€äº›ï¼Œç„¶åæ•ˆæœéå¸¸æ˜æ˜¾ã€‚
- en: Do Now!
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check at what value you start to observe a significant slowdown on your machine.
    Plot the graph of running time against input size. What does this suggest?
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ£€æŸ¥åœ¨ä»€ä¹ˆå€¼æ—¶ä½ å¼€å§‹è§‚å¯Ÿåˆ°æœºå™¨ä¸Šçš„æ˜¾è‘—å‡é€Ÿã€‚ç»˜åˆ¶è¿è¡Œæ—¶é—´ä¸è¾“å…¥å¤§å°çš„å›¾è¡¨ã€‚è¿™è¡¨æ˜äº†ä»€ä¹ˆï¼Ÿ
- en: 'The reason the Catalan computation takes so long is precisely because of what
    we alluded to earlier: at each level, we depend on computing the Catalan number
    of all the smaller levels; this computation in turn needs the numbers of all of
    its smaller levels; and so on down the road.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: åŠ æ³°ç½—å°¼äºšè®¡ç®—ä¹‹æ‰€ä»¥è€—æ—¶å¦‚æ­¤ä¹‹é•¿ï¼Œæ­£æ˜¯å› ä¸ºæˆ‘ä»¬ä¹‹å‰æåˆ°çš„ï¼šåœ¨æ¯ä¸€çº§ï¼Œæˆ‘ä»¬ä¾èµ–äºè®¡ç®—æ‰€æœ‰è¾ƒå°çº§åˆ«çš„åŠ æ³°ç½—å°¼äºšæ•°ï¼›è¿™ä¸€è®¡ç®—åè¿‡æ¥åˆéœ€è¦æ‰€æœ‰è¾ƒå°çº§åˆ«çš„æ•°ï¼›ä»¥æ­¤ç±»æ¨ã€‚
- en: Exercise
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Map the subcomputations of `catalan` to see why the computation time explodes
    as it does. What is the worst-case time complexity of this function?
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°†`catalan`çš„å­è®¡ç®—æ˜ å°„ï¼Œä»¥äº†è§£ä¸ºä»€ä¹ˆè®¡ç®—æ—¶é—´ä¼šå¦‚æ­¤çˆ†ç‚¸ã€‚è¿™ä¸ªå‡½æ•°çš„æœ€åæƒ…å†µæ—¶é—´å¤æ‚åº¦æ˜¯å¤šå°‘ï¼Ÿ
- en: 'Here is a graphical representation of all the sub-computations the Catalan
    function does for input `3`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯åŠ æ³°ç½—å°¼äºšå‡½æ•°ä¸ºè¾“å…¥`3`æ‰€åšçš„æ‰€æœ‰å­è®¡ç®—çš„å›¾å½¢è¡¨ç¤ºï¼š
- en: '![](../Images/79fbf0941364e29afa9e7ce828c8b1ec.png)'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../Images/79fbf0941364e29afa9e7ce828c8b1ec.png)'
- en: Observe the very symmetric computation, reflecting the formula.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿåˆ°éå¸¸å¯¹ç§°çš„è®¡ç®—ï¼Œåæ˜ äº†å…¬å¼ã€‚
- en: 22.1.1Â Using State to Remember Past Answers[ğŸ”—](#(part._.Using_.State_to_.Remember_.Past_.Answers)
    "Link to here")
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.1.1 ä½¿ç”¨çŠ¶æ€æ¥è®°ä½è¿‡å»çš„ç­”æ¡ˆ[ğŸ”—](#(part._.Using_.State_to_.Remember_.Past_.Answers) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Therefore, this is clearly a case where trading space for time is likely to
    be of help. How do we do this? We need a notion of memory that records all previous
    answers and, on subsequent attempts to compute them, checks whether they are already
    known and, if so, just returns them instead of recomputing them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œè¿™æ˜¾ç„¶æ˜¯ä¸€ä¸ªé€šè¿‡ä»¥ç©ºé—´æ¢æ—¶é—´å¯èƒ½æœ‰æ‰€å¸®åŠ©çš„æ¡ˆä¾‹ã€‚æˆ‘ä»¬å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹ï¼Ÿæˆ‘ä»¬éœ€è¦ä¸€ä¸ªè®°å½•æ‰€æœ‰å…ˆå‰ç­”æ¡ˆçš„è®°å¿†æ¦‚å¿µï¼Œåœ¨éšåçš„å°è¯•è®¡ç®—å®ƒä»¬æ—¶ï¼Œæ£€æŸ¥å®ƒä»¬æ˜¯å¦å·²çŸ¥ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™ç›´æ¥è¿”å›å®ƒä»¬è€Œä¸æ˜¯é‡æ–°è®¡ç®—ã€‚
- en: Do Now!
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What critical assumption is this based on?
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå‡è®¾åŸºäºä»€ä¹ˆå…³é”®å‡è®¾ï¼Ÿ
- en: Naturally, this assumes that for a given input, the answer will always be the
    same. As we have seen, functions with state violate this liberally, so typical
    stateful functions cannot utilize this optimization. Ironically, we will use state
    to implement this optimization, so we will have a stateful function that always
    returns the same answer on a given inputâ€”<wbr>and thereby use state in a stateful
    function to simulate a stateless one. Groovy, dude!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: è‡ªç„¶åœ°ï¼Œè¿™å‡è®¾å¯¹äºç»™å®šçš„è¾“å…¥ï¼Œç­”æ¡ˆæ€»æ˜¯ç›¸åŒçš„ã€‚æ­£å¦‚æˆ‘ä»¬æ‰€è§ï¼Œå…·æœ‰çŠ¶æ€çš„å‡½æ•°ä¼šè‡ªç”±åœ°è¿åè¿™ä¸€å‡è®¾ï¼Œå› æ­¤å…¸å‹çš„çŠ¶æ€å‡½æ•°æ— æ³•åˆ©ç”¨è¿™ç§ä¼˜åŒ–ã€‚è®½åˆºçš„æ˜¯ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨çŠ¶æ€æ¥å®ç°è¿™ç§ä¼˜åŒ–ï¼Œå› æ­¤æˆ‘ä»¬å°†æœ‰ä¸€ä¸ªåœ¨ç»™å®šè¾“å…¥ä¸Šæ€»æ˜¯è¿”å›ç›¸åŒç­”æ¡ˆçš„çŠ¶æ€å‡½æ•°â€”â€”å¹¶ä¸”å› æ­¤åœ¨ä¸€ä¸ªçŠ¶æ€å‡½æ•°ä¸­ä½¿ç”¨çŠ¶æ€æ¥æ¨¡æ‹Ÿä¸€ä¸ªæ— çŠ¶æ€å‡½æ•°ã€‚Groovyï¼Œä¼™è®¡ï¼
- en: 'First, then, we need some representation of memory. We can imagine several,
    but hereâ€™s a simple one:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€äº›å†…å­˜çš„è¡¨ç¤ºã€‚æˆ‘ä»¬å¯ä»¥æƒ³è±¡å‡ ä¸ªï¼Œä½†è¿™é‡Œæœ‰ä¸€ä¸ªç®€å•çš„ï¼š
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now how does `catalan` need to change? We have to first look for whether the
    value is already in `memory`; if it is, we return it without any further computation,
    but if it isnâ€™t, then we compute the result, store it in `memory`, and then return
    it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨å¦‚ä½•ä¿®æ”¹`catalan`ï¼Ÿæˆ‘ä»¬å¿…é¡»é¦–å…ˆæŸ¥æ‰¾è¯¥å€¼æ˜¯å¦å·²ç»åœ¨`memory`ä¸­ï¼›å¦‚æœæ˜¯ï¼Œæˆ‘ä»¬è¿”å›å®ƒè€Œæ— éœ€ä»»ä½•è¿›ä¸€æ­¥çš„è®¡ç®—ï¼Œä½†å¦‚æœæ²¡æœ‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬è®¡ç®—ç»“æœï¼Œå°†å…¶å­˜å‚¨åœ¨`memory`ä¸­ï¼Œç„¶åè¿”å›å®ƒï¼š
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: And thatâ€™s it! Now running our previous tests will reveal that the answer computes
    much quicker, but in addition we can dare to run bigger computations such as `catalan(50)`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: å°±è¿™æ ·ï¼ç°åœ¨è¿è¡Œæˆ‘ä»¬ä¹‹å‰çš„æµ‹è¯•å°†æ­ç¤ºç­”æ¡ˆè®¡ç®—å¾—æ›´å¿«ï¼Œä½†é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥å¤§èƒ†åœ°è¿è¡Œæ›´å¤§çš„è®¡ç®—ï¼Œä¾‹å¦‚`catalan(50)`ã€‚
- en: Do Now!
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Trace through a call of this revised function and see how many calls it makes.
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿½è¸ªè¿™ä¸ªä¿®æ”¹åçš„å‡½æ•°çš„è°ƒç”¨ï¼Œçœ‹çœ‹å®ƒæ‰§è¡Œäº†å¤šå°‘æ¬¡è°ƒç”¨ã€‚
- en: 'Here is a revised visualization of computing for input `3`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯è¾“å…¥`3`çš„ä¿®æ”¹åçš„è®¡ç®—å¯è§†åŒ–ï¼š
- en: '![](../Images/31c17fe6a16bbf3f25e501c178869546.png)'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../Images/31c17fe6a16bbf3f25e501c178869546.png)'
- en: 'Observe the asymmetric computation: the early calls perform the computations,
    while the latter calls simply look up the results.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿéå¯¹ç§°è®¡ç®—ï¼šæ—©æœŸçš„è°ƒç”¨æ‰§è¡Œè®¡ç®—ï¼Œè€Œåç»­çš„è°ƒç”¨åªæ˜¯ç®€å•åœ°æŸ¥æ‰¾ç»“æœã€‚
- en: This process, of converting a function into a version that remembers its past
    answers, is called memoization.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè¿‡ç¨‹ï¼Œå°†ä¸€ä¸ªå‡½æ•°è½¬æ¢æˆä¸€ä¸ªèƒ½å¤Ÿè®°ä½å…¶è¿‡å»ç­”æ¡ˆçš„ç‰ˆæœ¬ï¼Œè¢«ç§°ä¸ºè®°å¿†åŒ–ã€‚
- en: 22.1.2Â From a Tree of Computation to a DAG[ğŸ”—](#(part._.From_a_.Tree_of_.Computation_to_a_.D.A.G)
    "Link to here")
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.1.2Â ä»è®¡ç®—æ ‘åˆ°DAG[ğŸ”—](#(part._.From_a_.Tree_of_.Computation_to_a_.D.A.G) "é“¾æ¥è‡³æ­¤")
- en: What we have subtly done is to convert a tree of computation into a DAG over
    the same computation, with equivalent calls being reused. Whereas previously each
    call was generating lots of recursive calls, which induced still more recursive
    calls, now we are reusing previous recursive callsâ€”<wbr>i.e., sharing the results
    computed earlier. This, in effect, points the recursive call to one that had occurred
    earlier. Thus, the shape of computation converts from a tree to a DAG of calls.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¾®å¦™åœ°åšçš„æ˜¯å°†è®¡ç®—æ ‘è½¬æ¢ä¸ºåŒä¸€è®¡ç®—çš„DAGï¼Œå…¶ä¸­ç­‰æ•ˆè°ƒç”¨è¢«é‡ç”¨ã€‚ä»¥å‰æ¯ä¸ªè°ƒç”¨éƒ½ä¼šç”Ÿæˆå¤§é‡çš„é€’å½’è°ƒç”¨ï¼Œè¿™åˆå¼•å‘äº†æ›´å¤šçš„é€’å½’è°ƒç”¨ï¼Œè€Œç°åœ¨æˆ‘ä»¬æ­£åœ¨é‡ç”¨ä¹‹å‰çš„é€’å½’è°ƒç”¨â€”â€”å³ï¼Œå…±äº«ä¹‹å‰è®¡ç®—çš„ç»“æœã€‚è¿™å®é™…ä¸Šæ˜¯æŒ‡å‘ä¹‹å‰å‘ç”Ÿè¿‡çš„é€’å½’è°ƒç”¨ã€‚å› æ­¤ï¼Œè®¡ç®—çš„å½¢çŠ¶ä»æ ‘è½¬æ¢ä¸ºè°ƒç”¨DAGã€‚
- en: This has an important complexity benefit. Whereas previously we were performing
    a super-exponential number of calls, now we perform only one call per input and
    share all previous callsâ€”<wbr>thereby reducing `catalan(n)` to take a number of
    fresh calls proportional to `n`. Looking up the result of a previous call takes
    time proportional to the size of `memory` (because weâ€™ve represented it as a list;
    better representations would improve on that), but that only contributes another
    linear multiplicative factor, reducing the overall complexity to quadratic in
    the size of the input. This is a dramatic reduction in overall complexity. In
    contrast, other uses of memoization may result in much less dramatic improvements,
    turning the use of this technique into a true engineering trade-off.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æœ‰ä¸€ä¸ªé‡è¦çš„å¤æ‚åº¦ä¼˜åŠ¿ã€‚ä»¥å‰æˆ‘ä»¬æ‰§è¡Œçš„æ˜¯è¶…æŒ‡æ•°æ•°é‡çš„è°ƒç”¨ï¼Œè€Œç°åœ¨æˆ‘ä»¬åªå¯¹æ¯ä¸ªè¾“å…¥æ‰§è¡Œä¸€ä¸ªè°ƒç”¨ï¼Œå¹¶å…±äº«æ‰€æœ‰ä¹‹å‰çš„è°ƒç”¨â€”â€”å› æ­¤å°†`catalan(n)`çš„è°ƒç”¨æ¬¡æ•°å‡å°‘åˆ°ä¸`n`æˆæ¯”ä¾‹ã€‚æŸ¥æ‰¾ä¹‹å‰è°ƒç”¨çš„ç»“æœéœ€è¦ä¸`memory`çš„å¤§å°æˆæ¯”ä¾‹çš„æ—¶é—´ï¼ˆå› ä¸ºæˆ‘ä»¬å°†å…¶è¡¨ç¤ºä¸ºåˆ—è¡¨ï¼›æ›´å¥½çš„è¡¨ç¤ºä¼šæ”¹è¿›è¿™ä¸€ç‚¹ï¼‰ï¼Œä½†è¿™åªå¢åŠ äº†ä¸€ä¸ªçº¿æ€§ä¹˜æ³•å› å­ï¼Œå°†æ•´ä½“å¤æ‚åº¦é™ä½åˆ°è¾“å…¥å¤§å°çš„äºŒæ¬¡æ–¹ã€‚è¿™æ˜¯æ•´ä½“å¤æ‚åº¦çš„æ˜¾è‘—é™ä½ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œå…¶ä»–è®°å¿†åŒ–çš„åº”ç”¨å¯èƒ½åªä¼šå¸¦æ¥ä¸é‚£ä¹ˆæ˜¾è‘—çš„æ”¹è¿›ï¼Œä½¿è¿™ç§æŠ€æœ¯çš„ä½¿ç”¨æˆä¸ºä¸€ä¸ªçœŸæ­£çš„å·¥ç¨‹æƒè¡¡ã€‚
- en: 22.1.3Â The Complexity of Numbers[ğŸ”—](#(part._numbers-not-constant) "Link to here")
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.1.3Â æ•°å­—çš„å¤æ‚åº¦[ğŸ”—](#(part._numbers-not-constant) "é“¾æ¥è‡³æ­¤")
- en: As we start to run larger computations, however, we may start to notice that
    our computations are starting to take longer than linear growth. This is because
    our numbers are growing arbitrarily largeâ€”<wbr>for instance, `catalan(100)` is
    `896519947090131496687170070074100632420837521538745909320`â€”<wbr>and computations
    on numbers can no longer be constant time, contrary to what we said earlier [[The
    Size of the Input](predicting-growth.html#%28part._size-of-input%29)]. Indeed,
    when working on cryptographic problems, the fact that operations on numbers do
    not take constant time are absolutely critical to fundamental complexity results
    (and, for instance, the presumed unbreakability of contemporary cryptography).
    (See also [Factoring Numbers](factoring-numbers.html).)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œå½“æˆ‘ä»¬å¼€å§‹è¿è¡Œæ›´å¤§çš„è®¡ç®—æ—¶ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå¼€å§‹æ³¨æ„åˆ°æˆ‘ä»¬çš„è®¡ç®—å¼€å§‹æ¯”çº¿æ€§å¢é•¿æ›´é•¿ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬çš„æ•°å­—æ­£åœ¨ä»»æ„å¢å¤§â€”â€”ä¾‹å¦‚ï¼Œ`catalan(100)`æ˜¯`896519947090131496687170070074100632420837521538745909320`â€”â€”è®¡ç®—æ•°å­—ä¸å†èƒ½æ˜¯å¸¸æ•°æ—¶é—´ï¼Œè¿™ä¸æˆ‘ä»¬ä¹‹å‰æ‰€è¯´çš„ç›¸å
    [[è¾“å…¥çš„å¤§å°](predicting-growth.html#%28part._size-of-input%29)]ã€‚å®é™…ä¸Šï¼Œåœ¨å¤„ç†å¯†ç å­¦é—®é¢˜æ—¶ï¼Œæ“ä½œæ•°å­—ä¸èŠ±è´¹å¸¸æ•°æ—¶é—´æ˜¯åŸºæœ¬å¤æ‚åº¦ç»“æœçš„å…³é”®ï¼ˆä¾‹å¦‚ï¼Œç°ä»£å¯†ç å­¦çš„å‡è®¾ä¸å¯ç ´è§£æ€§ï¼‰ã€‚ï¼ˆå¦è§
    [å› æ•°åˆ†è§£æ•°å­—](factoring-numbers.html)ï¼‰
- en: 22.1.4Â Abstracting Memoization[ğŸ”—](#(part._.Abstracting_.Memoization) "Link to
    here")
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.1.4Â æŠ½è±¡è®°å¿†åŒ–[ğŸ”—](#(part._.Abstracting_.Memoization) "é“¾æ¥è‡³æ­¤")
- en: 'Now weâ€™ve achieved the desired complexity improvement, but there is still something
    unsatisfactory about the structure of our revised definition of `catalan`: the
    act of memoization is deeply intertwined with the definition of a Catalan number,
    even though these should be intellectually distinct. Letâ€™s do that next.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»å®ç°äº†æ‰€éœ€çš„å¤æ‚æ€§æ”¹è¿›ï¼Œä½†æˆ‘ä»¬çš„`catalan`ä¿®è®¢å®šä¹‰çš„ç»“æ„ä»ç„¶æœ‰äº›ä»¤äººä¸æ»¡æ„ï¼šè®°å¿†åŒ–çš„è¡Œä¸ºä¸å¡å¡”å…°æ•°çš„å®šä¹‰ç´§å¯†äº¤ç»‡åœ¨ä¸€èµ·ï¼Œå°½ç®¡è¿™äº›åœ¨æ™ºåŠ›ä¸Šåº”è¯¥æ˜¯ä¸åŒçš„ã€‚è®©æˆ‘ä»¬æ¥ä¸‹æ¥åšè¿™ä»¶äº‹ã€‚
- en: In effect, we want to separate our program into two parts. One part defines
    a general notion of memoization, while the other defines `catalan` in terms of
    this general notion.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼Œæˆ‘ä»¬å¸Œæœ›å°†æˆ‘ä»¬çš„ç¨‹åºåˆ†æˆä¸¤éƒ¨åˆ†ã€‚ä¸€éƒ¨åˆ†å®šä¹‰äº†ä¸€ä¸ªé€šç”¨çš„è®°å¿†åŒ–æ¦‚å¿µï¼Œè€Œå¦ä¸€éƒ¨åˆ†åˆ™æ ¹æ®è¿™ä¸ªé€šç”¨æ¦‚å¿µå®šä¹‰`catalan`ã€‚
- en: 'What does the former mean? We want to encapsulate the idea of â€œmemoryâ€ (since
    we presumably donâ€™t want this stored in a variable that any old part of the program
    can modify). This should result in a function that takes the input we want to
    check; if it is found in the memory we return that answer, otherwise we compute
    the answer, store it, and return it. To compute the answer, we need a function
    that determines how to do so. Putting together these pieces:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: å‰è€…æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿæˆ‘ä»¬å¸Œæœ›å°è£…â€œè®°å¿†â€çš„æ¦‚å¿µï¼ˆå› ä¸ºæˆ‘ä»¬å¯èƒ½ä¸å¸Œæœ›å°†å…¶å­˜å‚¨åœ¨ä»»ä½•æ—§ç¨‹åºéƒ¨åˆ†éƒ½å¯ä»¥ä¿®æ”¹çš„å˜é‡ä¸­ï¼‰ã€‚è¿™åº”è¯¥å¯¼è‡´ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥å—æˆ‘ä»¬æƒ³è¦æ£€æŸ¥çš„è¾“å…¥ï¼›å¦‚æœå®ƒåœ¨è®°å¿†ä¸­æ‰¾åˆ°ï¼Œæˆ‘ä»¬è¿”å›é‚£ä¸ªç­”æ¡ˆï¼Œå¦åˆ™æˆ‘ä»¬è®¡ç®—ç­”æ¡ˆï¼Œå­˜å‚¨å®ƒï¼Œå¹¶è¿”å›å®ƒã€‚ä¸ºäº†è®¡ç®—ç­”æ¡ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå‡½æ•°æ¥ç¡®å®šå¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹ã€‚å°†è¿™äº›éƒ¨åˆ†ç»„åˆèµ·æ¥ï¼š
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We use the name `memoize-1` to indicate that this is a memoizer for single-argument
    functions. Observe that the code above is virtually identical to what we had before,
    except where we had the logic of Catalan number computation, we now have the parameter
    `f` determining what to do.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä½¿ç”¨`memoize-1`è¿™ä¸ªåå­—æ¥è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªä¸ºå•å‚æ•°å‡½æ•°è®¾è®¡çš„è®°å¿†åŒ–å™¨ã€‚è§‚å¯Ÿä¸Šé¢çš„ä»£ç å‡ ä¹ä¸æˆ‘ä»¬ä¹‹å‰çš„ä¸€æ ·ï¼Œé™¤äº†æˆ‘ä»¬ä¹‹å‰æœ‰å¡å¡”å…°æ•°è®¡ç®—çš„é€»è¾‘ï¼Œæˆ‘ä»¬ç°åœ¨æœ‰å‚æ•°`f`å†³å®šè¦åšä»€ä¹ˆã€‚
- en: 'With this, we can now define `catalan` as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰`catalan`å¦‚ä¸‹ï¼š
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note several things about this definition:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„è¿™ä¸ªå®šä¹‰çš„å‡ ä¸ªæ–¹é¢ï¼š
- en: 'We donâ€™t write `fun catalan(...): ...;` because the procedure bound to `catalan`
    is produced by `memoize-1`.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬ä¸å†™`fun catalan(...): ...;`ï¼Œå› ä¸ºç»‘å®šåˆ°`catalan`çš„è¿‡ç¨‹æ˜¯ç”±`memoize-1`äº§ç”Ÿçš„ã€‚'
- en: Note carefully that the recursive calls to `catalan` have to be to the function
    bound to the result of memoization, thereby behaving like an object. Failing to
    refer to this same shared procedure means the recursive calls will not be memoized,
    thereby losing the benefit of this process.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä»”ç»†æ³¨æ„ï¼Œå¯¹`catalan`çš„é€’å½’è°ƒç”¨å¿…é¡»æ˜¯å¯¹ç»‘å®šåˆ°è®°å¿†åŒ–ç»“æœçš„å‡½æ•°çš„è°ƒç”¨ï¼Œå› æ­¤è¡¨ç°å¾—åƒä¸€ä¸ªå¯¹è±¡ã€‚æœªèƒ½å¼•ç”¨è¿™ä¸ªç›¸åŒçš„å…±äº«è¿‡ç¨‹æ„å‘³ç€é€’å½’è°ƒç”¨å°†ä¸ä¼šè¢«è®°å¿†åŒ–ï¼Œä»è€Œå¤±å»äº†è¿™ä¸ªè¿‡ç¨‹çš„å¥½å¤„ã€‚
- en: We need to use `rec` for reasons we saw earlier [[Streams From Functions](func-as-data.html#%28part._streams-from-funs%29)].
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦ä½¿ç”¨`rec`çš„åŸå› æ˜¯æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„ [[ä»å‡½æ•°ä¸­è·å–æµ](func-as-data.html#%28part._streams-from-funs%29)]ã€‚
- en: Each invocation of `memoize-1` creates a new table of stored results. Therefore
    the memoization of different functions will each get their own tables rather than
    sharing tables, which is a bad idea!
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ¯æ¬¡è°ƒç”¨`memoize-1`éƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å­˜å‚¨ç»“æœè¡¨ã€‚å› æ­¤ï¼Œä¸åŒå‡½æ•°çš„è®°å¿†åŒ–å°†å„è‡ªè·å¾—è‡ªå·±çš„è¡¨ï¼Œè€Œä¸æ˜¯å…±äº«è¡¨ï¼Œè¿™æ˜¯ä¸€ä¸ªåä¸»æ„ï¼
- en: Exercise
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is sharing memoization tables a bad idea? Be concrete.
  id: totrans-71
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆå…±äº«è®°å¿†åŒ–è¡¨æ˜¯ä¸€ä¸ªåä¸»æ„ï¼Ÿè¯·å…·ä½“è¯´æ˜ã€‚
- en: 22.2Â Edit-Distance for Spelling Correction[ğŸ”—](#(part._levenshtein) "Link to
    here")
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.2Â æ‹¼å†™çº æ­£çš„ç¼–è¾‘è·ç¦»[ğŸ”—](#(part._levenshtein) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Text editors, word processors, mobile phones, and various other devices now
    routinely implement spelling correction or offer suggestions on (mis-)spellings.
    How do they do this? Doing so requires two capabilities: computing the distance
    between words, and finding words that are nearby according to this metric. In
    this section we will study the first of these questions. (For the purposes of
    this discussion, we will not dwell on the exact definition of what a â€œwordâ€ is,
    and just deal with strings instead. A real system would need to focus on this
    definition in considerable detail.)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: æ–‡æœ¬ç¼–è¾‘å™¨ã€æ–‡å­—å¤„ç†å™¨ã€ç§»åŠ¨ç”µè¯ä»¥åŠå„ç§å…¶ä»–è®¾å¤‡ç°åœ¨é€šå¸¸éƒ½ä¼šå®ç°æ‹¼å†™æ£€æŸ¥æˆ–æä¾›æ‹¼å†™ï¼ˆè¯¯ï¼‰å»ºè®®ã€‚å®ƒä»¬æ˜¯å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹çš„å‘¢ï¼Ÿè¿™æ ·åšéœ€è¦ä¸¤ç§èƒ½åŠ›ï¼šè®¡ç®—å•è¯ä¹‹é—´çš„è·ç¦»ï¼Œä»¥åŠæ ¹æ®è¿™ä¸ªåº¦é‡æ ‡å‡†æ‰¾åˆ°é™„è¿‘çš„å•è¯ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ç ”ç©¶è¿™äº›é—®é¢˜çš„ç¬¬ä¸€ä¸ªã€‚
    ï¼ˆä¸ºäº†è®¨è®ºçš„ç›®çš„ï¼Œæˆ‘ä»¬ä¸ä¼šæ·±å…¥æ¢è®¨â€œå•è¯â€çš„ç¡®åˆ‡å®šä¹‰ï¼Œè€Œæ˜¯åªå¤„ç†å­—ç¬¦ä¸²ã€‚ä¸€ä¸ªçœŸæ­£çš„ç³»ç»Ÿéœ€è¦ç›¸å½“è¯¦ç»†åœ°å…³æ³¨è¿™ä¸ªå®šä¹‰ã€‚ï¼‰
- en: Do Now!
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Think about how you might define the â€œdistance between two wordsâ€. Does it define
    a [metric space](http://en.wikipedia.org/wiki/Metric_space)?
  id: totrans-76
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æƒ³æƒ³ä½ æ˜¯å¦‚ä½•å®šä¹‰â€œä¸¤ä¸ªå•è¯ä¹‹é—´çš„è·ç¦»â€çš„ã€‚å®ƒå®šä¹‰äº†ä¸€ä¸ª[åº¦é‡ç©ºé—´](http://en.wikipedia.org/wiki/Metric_space)å—ï¼Ÿ
- en: Exercise
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Will the definition we give below define a metric space over the set of words?
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç»™å‡ºçš„å®šä¹‰å°†å®šä¹‰ä¸€ä¸ªå…³äºå•è¯é›†çš„åº¦é‡ç©ºé—´å—ï¼Ÿ
- en: 'Though there may be several legitimate ways to define distances between words,
    here we care about the distance in the very specific context of spelling mistakes.
    Given the distance measure, one use might be to compute the distance of a given
    word from all the words in a dictionary, and offer the closest word (i.e., the
    one with the least distance) as a proposed correction.Obviously, we canâ€™t compute
    the distance to every word in a large dictionary on every single entered word.
    Making this process efficient constitutes the other half of this problem. Briefly,
    we need to quickly discard most words as unlikely to be close enough, for which
    a representation such as a [bag-of-words](http://en.wikipedia.org/wiki/Bag-of-words_model)
    (here, a bag of characters) can greatly help. Given such an intended use, we would
    like at least the following to hold:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: å°½ç®¡å®šä¹‰å•è¯ä¹‹é—´è·ç¦»çš„åˆæ³•æ–¹å¼å¯èƒ½æœ‰å¾ˆå¤šï¼Œä½†åœ¨è¿™é‡Œæˆ‘ä»¬å…³æ³¨çš„æ˜¯æ‹¼å†™é”™è¯¯çš„å…·ä½“æƒ…å¢ƒä¸­çš„è·ç¦»ã€‚ç»™å®šè·ç¦»åº¦é‡ï¼Œä¸€ä¸ªå¯èƒ½çš„ç”¨é€”æ˜¯è®¡ç®—ç»™å®šå•è¯ä¸å­—å…¸ä¸­æ‰€æœ‰å•è¯çš„è·ç¦»ï¼Œå¹¶æä¾›æœ€æ¥è¿‘çš„å•è¯ï¼ˆå³è·ç¦»æœ€å°çš„å•è¯ï¼‰ä½œä¸ºå»ºè®®çš„æ›´æ­£ã€‚æ˜¾ç„¶ï¼Œæˆ‘ä»¬æ— æ³•åœ¨æ¯æ¬¡è¾“å…¥å•è¯æ—¶éƒ½è®¡ç®—å¤§å‹å­—å…¸ä¸­æ¯ä¸ªå•è¯çš„è·ç¦»ã€‚ä½¿æ­¤è¿‡ç¨‹é«˜æ•ˆæ„æˆäº†æ­¤é—®é¢˜çš„ä¸€åŠã€‚ç®€è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬éœ€è¦å¿«é€Ÿæ’é™¤å¤§å¤šæ•°ä¸å¤ªå¯èƒ½è¶³å¤Ÿæ¥è¿‘çš„å•è¯ï¼Œä¸ºæ­¤ï¼Œä¸€ç§å¦‚[è¯è¢‹æ¨¡å‹](http://en.wikipedia.org/wiki/Bag-of-words_model)ï¼ˆåœ¨æ­¤ï¼Œä¸ºå­—ç¬¦è¢‹ï¼‰çš„è¡¨ç¤ºå¯ä»¥å¤§å¤§å¸®åŠ©ã€‚è€ƒè™‘åˆ°è¿™ç§é¢„æœŸç”¨é€”ï¼Œæˆ‘ä»¬å¸Œæœ›è‡³å°‘ä»¥ä¸‹æ¡ä»¶æˆç«‹ï¼š
- en: That the distance from a word to itself be zero.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å•è¯åˆ°è‡ªèº«çš„è·ç¦»ä¸ºé›¶ã€‚
- en: That the distance from a word to any word other than itself be strictly positive.
    (Otherwise, given a word that is already in the dictionary, the â€œcorrectionâ€ might
    be a different dictionary word.)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å•è¯åˆ°ä»»ä½•éè‡ªèº«çš„å•è¯çš„è·ç¦»å¿…é¡»æ˜¯ä¸¥æ ¼æ­£çš„ã€‚ï¼ˆå¦åˆ™ï¼Œç»™å®šä¸€ä¸ªå·²ç»åœ¨å­—å…¸ä¸­çš„å•è¯ï¼Œâ€œæ›´æ­£â€å¯èƒ½æ˜¯ä¸€ä¸ªä¸åŒçš„å­—å…¸å•è¯ã€‚ï¼‰
- en: That the distance between two words be symmetric, i.e., it shouldnâ€™t matter
    in which order we pass arguments.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸¤ä¸ªå•è¯ä¹‹é—´çš„è·ç¦»æ˜¯å¯¹ç§°çš„ï¼Œå³ä¼ é€’å‚æ•°çš„é¡ºåºä¸åº”è¯¥å½±å“ç»“æœã€‚
- en: Exercise
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that we have not included the triangle inequality relative to the properties
    of a metric. Why not? If we donâ€™t need the triangle inequality, does this let
    us define more interesting distance functions that are not metrics?
  id: totrans-86
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬æ²¡æœ‰åŒ…æ‹¬ä¸åº¦é‡æ€§è´¨ç›¸å…³çš„ä¸‰è§’ä¸ç­‰å¼ã€‚ä¸ºä»€ä¹ˆï¼Ÿå¦‚æœæˆ‘ä»¬ä¸éœ€è¦ä¸‰è§’ä¸ç­‰å¼ï¼Œè¿™éš¾é“è®©æˆ‘ä»¬èƒ½å¤Ÿå®šä¹‰æ›´å¤šæœ‰è¶£çš„éåº¦é‡è·ç¦»å‡½æ•°å—ï¼Ÿ
- en: 'Given a pair of words, the assumption is that we meant to type one but actually
    typed the other. Here, too, there are several possible definitions, but a popular
    one considers that there are three ways to be fat-fingered:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€å¯¹å•è¯ï¼Œå‡è®¾æˆ‘ä»¬æœ¬æ„æƒ³è¾“å…¥ä¸€ä¸ªå•è¯ä½†å®é™…ä¸Šè¾“å…¥äº†å¦ä¸€ä¸ªå•è¯ã€‚åœ¨è¿™é‡Œï¼Œä¹Ÿæœ‰å‡ ç§å¯èƒ½çš„å®šä¹‰ï¼Œä½†ä¸€ç§æµè¡Œçš„å®šä¹‰è€ƒè™‘äº†ä¸‰ç§æ‰“å­—é”™è¯¯çš„æƒ…å†µï¼š
- en: we left out a character;
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ¼æ‰äº†ä¸€ä¸ªå­—ç¬¦ï¼›
- en: we typed a character twice; or,
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¾“å…¥äº†ä¸€ä¸ªå­—ç¬¦ä¸¤æ¬¡ï¼›
- en: we typed one character when we meant another.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬æœ¬æ„æƒ³è¾“å…¥ä¸€ä¸ªå­—ç¬¦å´è¾“å…¥äº†å¦ä¸€ä¸ªå­—ç¬¦æ—¶ã€‚
- en: In particular, we are interested in the fewest edits of these forms that need
    to be performed to get from one word to the other. For natural reasons, this notion
    of distance is called the edit distance or, in honor of its creator, the Levenshtein
    distance.See more on [Wikipedia](http://en.wikipedia.org/wiki/Levenshtein_distance).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: å°¤å…¶æ˜¯æˆ‘ä»¬å¯¹å°†ä¸€ä¸ªå•è¯è½¬æ¢æˆå¦ä¸€ä¸ªå•è¯æ‰€éœ€çš„æœ€å°‘ç¼–è¾‘æ¬¡æ•°æ„Ÿå…´è¶£ã€‚ç”±äºè‡ªç„¶åŸå› ï¼Œè¿™ç§è·ç¦»çš„æ¦‚å¿µè¢«ç§°ä¸ºç¼–è¾‘è·ç¦»ï¼Œæˆ–è€…ä¸ºäº†çºªå¿µå…¶åˆ›é€ è€…ï¼Œè¢«ç§°ä¸ºè±æ–‡æ–¯å¦è·ç¦»ã€‚æ›´å¤šå†…å®¹è¯·å‚é˜…[Wikipedia](http://en.wikipedia.org/wiki/Levenshtein_distance)ã€‚
- en: There are several variations of this definition possible. For now, we will consider
    the simplest one, which assumes that each of these errors has equal cost. For
    certain input devices, we may want to assign different costs to these mistakes;
    we might also assign different costs depending on what wrong character was typed
    (two characters adjacent on a keyboard are much more likely to be a legitimate
    error than two that are far apart). We will return briefly to some of these considerations
    later [[Nature as a Fat-Fingered Typist](#%28part._smith-waterman%29)].
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§å®šä¹‰æœ‰å‡ ç§å¯èƒ½çš„å˜ä½“ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å°†è€ƒè™‘æœ€ç®€å•çš„ä¸€ç§ï¼Œå®ƒå‡è®¾è¿™äº›é”™è¯¯ä¸­çš„æ¯ä¸€ä¸ªéƒ½æœ‰ç›¸åŒçš„æˆæœ¬ã€‚å¯¹äºæŸäº›è¾“å…¥è®¾å¤‡ï¼Œæˆ‘ä»¬å¯èƒ½æƒ³è¦ä¸ºè¿™äº›é”™è¯¯åˆ†é…ä¸åŒçš„æˆæœ¬ï¼›æˆ‘ä»¬å¯èƒ½è¿˜ä¼šæ ¹æ®è¾“å…¥äº†å“ªä¸ªé”™è¯¯çš„å­—ç¬¦åˆ†é…ä¸åŒçš„æˆæœ¬ï¼ˆé”®ç›˜ä¸Šç›¸é‚»çš„ä¸¤ä¸ªå­—ç¬¦æ¯”ç›¸è·è¾ƒè¿œçš„ä¸¤ä¸ªå­—ç¬¦æ›´æœ‰å¯èƒ½æ˜¯åˆæ³•çš„é”™è¯¯ï¼‰ã€‚æˆ‘ä»¬å°†åœ¨ç¨åç®€è¦å›é¡¾ä¸€äº›è¿™äº›è€ƒè™‘[[è‡ªç„¶ä½œä¸ºç¬¨æ‹™çš„æ‰“å­—å‘˜](#%28part._smith-waterman%29)]ã€‚
- en: 'Under this metric, the distance between â€œkittenâ€ and â€œsittingâ€ is 3 because
    we have to replace â€œkâ€ with â€œsâ€, replace â€œeâ€ with â€œiâ€, and insert â€œgâ€ (or symmetrically,
    perform the opposite replacements and delete â€œgâ€). Here are more examples:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªåº¦é‡ä¸‹ï¼Œâ€œkittenâ€å’Œâ€œsittingâ€ä¹‹é—´çš„è·ç¦»æ˜¯3ï¼Œå› ä¸ºæˆ‘ä»¬å¿…é¡»å°†â€œkâ€æ›¿æ¢ä¸ºâ€œsâ€ï¼Œå°†â€œeâ€æ›¿æ¢ä¸ºâ€œiâ€ï¼Œå¹¶æ’å…¥â€œgâ€ï¼ˆæˆ–è€…å¯¹ç§°åœ°ï¼Œæ‰§è¡Œç›¸åçš„æ›¿æ¢å¹¶åˆ é™¤â€œgâ€ï¼‰ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›æ›´å¤šç¤ºä¾‹ï¼š
- en: <levenshtein-tests> ::=
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`<levenshtein-tests>` ::= '
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The basic algorithm is in fact very simple:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºæœ¬ç®—æ³•å®é™…ä¸Šéå¸¸ç®€å•ï¼š
- en: <levenshtein> ::=
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`<levenshtein>` ::= '
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'where, because there are two list inputs, there are four cases, of which two
    are symmetric:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ï¼Œç”±äºæœ‰ä¸¤ä¸ªåˆ—è¡¨è¾“å…¥ï¼Œæœ‰å››ç§æƒ…å†µï¼Œå…¶ä¸­ä¸¤ç§æ˜¯å¯¹ç§°çš„ï¼š
- en: <levenshtein-body> ::=
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`<levenshtein-body>` ::= '
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If both inputs are empty, the answer is simple:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä¸¤ä¸ªè¾“å…¥éƒ½ä¸ºç©ºï¼Œç­”æ¡ˆå¾ˆç®€å•ï¼š
- en: <levenshtein-both-empty> ::=
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`<levenshtein-both-empty>` ::= '
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When one is empty, then the edit distance corresponds to the length of the
    other, which needs to inserted (or deleted) in its entirety (so we charge a cost
    of one per character):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: å½“å…¶ä¸­ä¸€ä¸ªä¸ºç©ºæ—¶ï¼Œç¼–è¾‘è·ç¦»å¯¹åº”äºå¦ä¸€ä¸ªçš„é•¿åº¦ï¼Œéœ€è¦å®Œæ•´åœ°æ’å…¥ï¼ˆæˆ–åˆ é™¤ï¼‰åˆ°å…¶ä¸­ï¼ˆå› æ­¤æˆ‘ä»¬æŒ‰æ¯ä¸ªå­—ç¬¦è®¡è´¹ä¸€ä¸ªæˆæœ¬ï¼‰ï¼š
- en: <levenshtein-one-empty> ::=
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`<levenshtein-one-empty>` ::= '
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If neither is empty, then each has a first character. If they are the same,
    then there is no edit cost associated with this character (which we reflect by
    recurring on the rest of the words without adding to the edit cost). If they are
    not the same, however, we consider each of the possible edits:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä¸¤è€…éƒ½ä¸ä¸ºç©ºï¼Œé‚£ä¹ˆæ¯ä¸ªéƒ½æœ‰ç¬¬ä¸€ä¸ªå­—ç¬¦ã€‚å¦‚æœå®ƒä»¬ç›¸åŒï¼Œé‚£ä¹ˆä¸è¿™ä¸ªå­—ç¬¦ç›¸å…³çš„ç¼–è¾‘æˆæœ¬ä¸ºé›¶ï¼ˆæˆ‘ä»¬é€šè¿‡é€’å½’å¤„ç†å‰©ä½™çš„å•è¯è€Œä¸å¢åŠ ç¼–è¾‘æˆæœ¬æ¥åæ˜ è¿™ä¸€ç‚¹ï¼‰ã€‚å¦‚æœå®ƒä»¬ä¸ç›¸åŒï¼Œç„¶è€Œï¼Œæˆ‘ä»¬è€ƒè™‘æ¯ç§å¯èƒ½çš„ç¼–è¾‘ï¼š
- en: <levenshtein-neither-empty> ::=
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`<levenshtein-neither-empty>` ::= '
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the first case, we assume `s` has one too many characters, so we compute
    the cost as if weâ€™re deleting it and finding the lowest cost for the rest of the
    strings (but charging one for this deletion); in the second case, we symmetrically
    assume `t` has one too many; and in the third case, we assume one character got
    replaced by another, so we charge one but consider the rest of both words (e.g.,
    assume â€œsâ€ was typed for â€œkâ€ and continue with â€œittenâ€ and â€œittingâ€). This uses
    the following helper function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç¬¬ä¸€ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å‡è®¾`s`æœ‰å¤šä¸€ä¸ªå­—ç¬¦ï¼Œæ‰€ä»¥æˆ‘ä»¬è®¡ç®—æˆæœ¬å°±åƒæˆ‘ä»¬åœ¨åˆ é™¤å®ƒå¹¶æ‰¾åˆ°å‰©ä½™å­—ç¬¦ä¸²çš„æœ€ä½æˆæœ¬ä¸€æ ·ï¼ˆä½†ä¸ºæ­¤åˆ é™¤è®¡è´¹ä¸€ä¸ªæˆæœ¬ï¼‰ï¼›åœ¨ç¬¬äºŒç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯¹ç§°åœ°å‡è®¾`t`æœ‰å¤šä¸€ä¸ªå­—ç¬¦ï¼›åœ¨ç¬¬ä¸‰ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å‡è®¾ä¸€ä¸ªå­—ç¬¦è¢«å¦ä¸€ä¸ªå­—ç¬¦æ›¿æ¢ï¼Œæ‰€ä»¥æˆ‘ä»¬è®¡è´¹ä¸€ä¸ªï¼Œä½†è€ƒè™‘ä¸¤ä¸ªå•è¯çš„å…¶ä½™éƒ¨åˆ†ï¼ˆä¾‹å¦‚ï¼Œå‡è®¾â€œsâ€è¢«è¯¯è¾“å…¥ä¸ºâ€œkâ€ï¼Œç„¶åç»§ç»­ä½¿ç”¨â€œittenâ€å’Œâ€œittingâ€ï¼‰ã€‚è¿™ä½¿ç”¨äº†ä»¥ä¸‹è¾…åŠ©å‡½æ•°ï¼š
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This algorithm will indeed pass all the tests we have written above, but with
    a problem: the running time grows exponentially. That is because, each time we
    find a mismatch, we recur on three subproblems. In principle, therefore, the algorithm
    takes time proportional to three to the power of the length of the shorter word.
    In practice, any prefix that matches causes no branching, so it is mismatches
    that incur branching (thus, confirming that the distance of a word with itself
    is zero only takes time linear in the size of the word).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç®—æ³•ç¡®å®ä¼šé€šè¿‡æˆ‘ä»¬ä¸Šé¢ç¼–å†™çš„æ‰€æœ‰æµ‹è¯•ï¼Œä½†æœ‰ä¸€ä¸ªé—®é¢˜ï¼šè¿è¡Œæ—¶é—´å‘ˆæŒ‡æ•°å¢é•¿ã€‚è¿™æ˜¯å› ä¸ºï¼Œæ¯æ¬¡æˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ªä¸åŒ¹é…ï¼Œæˆ‘ä»¬éƒ½ä¼šåœ¨ä¸‰ä¸ªå­é—®é¢˜ä¸Šè¿›è¡Œé€’å½’ã€‚å› æ­¤ï¼Œä»åŸåˆ™ä¸Šè®²ï¼Œç®—æ³•çš„æ—¶é—´ä¸è¾ƒçŸ­å•è¯é•¿åº¦çš„ä¸‰æ¬¡æ–¹æˆæ­£æ¯”ã€‚åœ¨å®è·µä¸­ï¼Œä»»ä½•åŒ¹é…çš„è¯ç¼€éƒ½ä¸ä¼šå¯¼è‡´åˆ†æ”¯ï¼Œå› æ­¤æ˜¯åŒ¹é…å¯¼è‡´åˆ†æ”¯ï¼ˆè¿™è¯å®äº†å•è¯ä¸å…¶è‡ªèº«è·ç¦»ä¸ºé›¶çš„è®¡ç®—ä»…éœ€è¦ä¸å•è¯å¤§å°æˆçº¿æ€§æ—¶é—´çš„è®¡ç®—ï¼‰ã€‚
- en: Observe, however, that many of these subproblems are the same. For instance,
    given â€œkittenâ€ and â€œsittingâ€, the mismatch on the initial character will cause
    the algorithm to compute the distance of â€œittenâ€ from â€œittingâ€ but also â€œittenâ€
    from â€œsittingâ€ and â€œkittenâ€ from â€œittingâ€. Those latter two distance computations
    will also involve matching â€œittenâ€ against â€œittingâ€. Thus, again, we want the
    computation tree to turn into a DAG of expressions that are actually evaluated.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè§‚å¯Ÿå‘ç°ï¼Œè®¸å¤šè¿™äº›å­é—®é¢˜å®é™…ä¸Šæ˜¯ç›¸åŒçš„ã€‚ä¾‹å¦‚ï¼Œç»™å®šâ€œkittenâ€å’Œâ€œsittingâ€ï¼Œåˆå§‹å­—ç¬¦çš„ä¸åŒ¹é…å°†å¯¼è‡´ç®—æ³•è®¡ç®—â€œittenâ€ä¸â€œittingâ€çš„è·ç¦»ï¼Œä½†ä¹Ÿä¼šè®¡ç®—â€œittenâ€ä¸â€œsittingâ€ä»¥åŠâ€œkittenâ€ä¸â€œittingâ€çš„è·ç¦»ã€‚åä¸¤ä¸ªè·ç¦»è®¡ç®—ä¹Ÿå°†æ¶‰åŠå°†â€œittenâ€ä¸â€œittingâ€è¿›è¡ŒåŒ¹é…ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å†æ¬¡å¸Œæœ›è®¡ç®—æ ‘å˜æˆä¸€ä¸ªå®é™…è¯„ä¼°çš„è¡¨è¾¾å¼çš„DAGï¼ˆæœ‰å‘æ— ç¯å›¾ï¼‰ã€‚
- en: 'The solution, therefore, is naturally to memoize. First, we need a memoizer
    that works over two arguments rather than one:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œè§£å†³æ–¹æ¡ˆè‡ªç„¶æ˜¯ä½¿ç”¨è®°å¿†åŒ–ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥å¤„ç†ä¸¤ä¸ªå‚æ•°è€Œä¸æ˜¯ä¸€ä¸ªçš„è®°å¿†åŒ–å™¨ï¼š
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Most of the code is unchanged, except that we store two arguments rather than
    one, and correspondingly look up both.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: å¤§éƒ¨åˆ†ä»£ç æ²¡æœ‰å˜åŒ–ï¼Œé™¤äº†æˆ‘ä»¬å­˜å‚¨ä¸¤ä¸ªå‚æ•°è€Œä¸æ˜¯ä¸€ä¸ªï¼Œå¹¶ä¸”ç›¸åº”åœ°æŸ¥æ‰¾ä¸¤ä¸ªã€‚
- en: 'With this, we can redefine `levenshtein` to use memoization:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥é‡æ–°å®šä¹‰`levenshtein`ä»¥ä½¿ç”¨è®°å¿†åŒ–ï¼š
- en: <levenshtein-memo> ::=
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`<levenshtein-memo>` ::= '
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: where the argument to `memoize-2` is precisely what we saw earlier as [<levenshtein-body>](#%28elem._levenshtein-body%29)
    (and now you know why we defined `levenshtein` slightly oddly, not using `fun`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ï¼Œ`memoize-2`çš„å‚æ•°æ­£æ˜¯æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„ [<levenshtein-body>](#%28elem._levenshtein-body%29)ï¼ˆç°åœ¨ä½ çŸ¥é“ä¸ºä»€ä¹ˆæˆ‘ä»¬å®šä¹‰`levenshtein`æœ‰äº›å¥‡æ€ªï¼Œæ²¡æœ‰ä½¿ç”¨`fun`ï¼‰ã€‚
- en: 'The complexity of this algorithm is still non-trivial. First, letâ€™s introduce
    the term suffix: the suffix of a string is the rest of the string starting from
    any point in the string. (Thus â€œkittenâ€, â€œittenâ€, â€œtenâ€, â€œnâ€, and â€œâ€ are all suffixes
    of â€œkittenâ€.) Now, observe that in the worst case, starting with every suffix
    in the first word, we may need to perform a comparison against every suffix in
    the second word. Fortunately, for each of these suffixes we perform a constant
    computation relative to the recursion. Therefore, the overall time complexity
    of computing the distance between strings of length \(m\) and \(n\) is \(O([m,
    n \rightarrow m \cdot n])\). (We will return to space consumption later [[Contrasting
    Memoization and Dynamic Programming](#%28part._memo-vs-dp%29)].)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç®—æ³•çš„å¤æ‚åº¦ä»ç„¶æ˜¯éå¹³å‡¡çš„ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬ä»‹ç»æœ¯è¯­åç¼€ï¼šä¸€ä¸ªå­—ç¬¦ä¸²çš„åç¼€æ˜¯ä»å­—ç¬¦ä¸²ä¸­çš„ä»»ä½•ç‚¹å¼€å§‹åˆ°å­—ç¬¦ä¸²æœ«å°¾çš„æ‰€æœ‰å­—ç¬¦ã€‚ï¼ˆå› æ­¤ï¼Œâ€œkittenâ€ï¼Œâ€œittenâ€ï¼Œâ€œtenâ€ï¼Œâ€œnâ€ï¼Œå’Œâ€œâ€éƒ½æ˜¯â€œkittenâ€çš„åç¼€ã€‚ï¼‰ç°åœ¨ï¼Œè§‚å¯Ÿåœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œä»ç¬¬ä¸€ä¸ªå•è¯çš„æ¯ä¸ªåç¼€å¼€å§‹ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦ä¸ç¬¬äºŒä¸ªå•è¯çš„æ¯ä¸ªåç¼€è¿›è¡Œæ¯”è¾ƒã€‚å¹¸è¿çš„æ˜¯ï¼Œå¯¹äºè¿™äº›åç¼€ä¸­çš„æ¯ä¸€ä¸ªï¼Œæˆ‘ä»¬ç›¸å¯¹äºé€’å½’æ‰§è¡Œä¸€ä¸ªå¸¸é‡è®¡ç®—ã€‚å› æ­¤ï¼Œè®¡ç®—é•¿åº¦ä¸º
    \(m\) å’Œ \(n\) çš„å­—ç¬¦ä¸²ä¹‹é—´è·ç¦»çš„æ•´ä½“æ—¶é—´å¤æ‚åº¦æ˜¯ \(O([m, n \rightarrow m \cdot n])\)ã€‚ï¼ˆæˆ‘ä»¬ç¨åä¼šå›åˆ°ç©ºé—´æ¶ˆè€—[[å¯¹æ¯”è®°å¿†åŒ–å’ŒåŠ¨æ€è§„åˆ’](#%28part._memo-vs-dp%29)]ã€‚ï¼‰ã€‚
- en: Exercise
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify the above algorithm to produce an actual (optimal) sequence of edit operations.
    This is sometimes known as the traceback.
  id: totrans-125
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¿®æ”¹ä¸Šè¿°ç®—æ³•ä»¥ç”Ÿæˆå®é™…çš„ï¼ˆæœ€ä¼˜ï¼‰ç¼–è¾‘æ“ä½œåºåˆ—ã€‚è¿™æœ‰æ—¶è¢«ç§°ä¸ºå›æº¯ã€‚
- en: 22.3Â Nature as a Fat-Fingered Typist[ğŸ”—](#(part._smith-waterman) "Link to here")
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.3 è‡ªç„¶ç•Œä½œä¸ºä¸€ä¸ªç²—å¿ƒçš„æ‰“å­—å‘˜[ğŸ”—](#(part._smith-waterman) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'We have talked about how to address mistakes made by humans. However, humans
    are not the only bad typists: nature is one, too!'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»è®¨è®ºäº†å¦‚ä½•å¤„ç†äººç±»çŠ¯çš„é”™è¯¯ã€‚ç„¶è€Œï¼Œäººç±»å¹¶éå”¯ä¸€çš„ç³Ÿç³•æ‰“å­—å‘˜ï¼šè‡ªç„¶ç•Œä¹Ÿæ˜¯å…¶ä¸­ä¹‹ä¸€ï¼
- en: 'When studying living matter we obtain sequences of amino acids and other such
    chemicals that comprise molecules, such as DNA, that hold important and potentially
    determinative information about the organism. These sequences consist of similar
    fragments that we wish to identify because they represent relationships in the
    organismâ€™s behavior or evolution.This section may need to be skipped in [some
    states and countries](http://en.wikipedia.org/wiki/Creation_and_evolution_in_public_education).
    Unfortunately, these sequences are never identical: like all low-level programmers,
    nature slips up and sometimes makes mistakes in copying (calledâ€”<wbr>wait for
    itâ€”<wbr>mutations). Therefore, looking for strict equality would rule out too
    many sequences that are almost certainly equivalent. Instead, we must perform
    an alignment step to find these equivalent sequences. As you might have guessed,
    this process is very much a process of computing an edit distance, and using some
    threshold to determine whether the edit is small enough.To be precise, we are
    performing local [sequence alignment](http://en.wikipedia.org/wiki/Sequence_alignment).
    This algorithm is named, after its creators, Smith-Waterman, and because it is
    essentially identical, has the same complexity as the Levenshtein algorithm.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç ”ç©¶ç”Ÿç‰©ç‰©è´¨æ—¶ï¼Œæˆ‘ä»¬è·å¾—ç”±æ°¨åŸºé…¸å’Œå…¶ä»–ç±»ä¼¼åŒ–å­¦ç‰©è´¨ç»„æˆçš„åºåˆ—ï¼Œè¿™äº›åŒ–å­¦ç‰©è´¨æ„æˆäº†åˆ†å­ï¼Œå¦‚DNAï¼Œå®ƒä»¬åŒ…å«æœ‰å…³ç”Ÿç‰©ä½“çš„é‡è¦å’Œå¯èƒ½å†³å®šæ€§çš„ä¿¡æ¯ã€‚è¿™äº›åºåˆ—ç”±æˆ‘ä»¬å¸Œæœ›è¯†åˆ«çš„ç›¸ä¼¼ç‰‡æ®µç»„æˆï¼Œå› ä¸ºè¿™äº›ç‰‡æ®µä»£è¡¨äº†ç”Ÿç‰©ä½“è¡Œä¸ºæˆ–è¿›åŒ–çš„å…³ç³»ã€‚æœ¬èŠ‚åœ¨æŸäº›å·å’Œå›½å®¶å¯èƒ½éœ€è¦è·³è¿‡[ä¸€äº›å·å’Œå›½å®¶](http://en.wikipedia.org/wiki/Creation_and_evolution_in_public_education)ã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿™äº›åºåˆ—æ°¸è¿œä¸ä¼šå®Œå…¨ç›¸åŒï¼šå°±åƒæ‰€æœ‰ä½çº§ç¨‹åºå‘˜ä¸€æ ·ï¼Œè‡ªç„¶ç•Œä¹Ÿä¼šçŠ¯é”™ï¼Œæœ‰æ—¶åœ¨å¤åˆ¶è¿‡ç¨‹ä¸­ï¼ˆç§°ä¸ºâ€”â€”<wbr>ç­‰ä¸€ä¸‹â€”â€”<wbr>çªå˜ï¼‰ã€‚å› æ­¤ï¼Œå¯»æ‰¾ä¸¥æ ¼çš„ç›¸ç­‰æ€§ä¼šæ’é™¤å¤ªå¤šå‡ ä¹è‚¯å®šç­‰æ•ˆçš„åºåˆ—ã€‚ç›¸åï¼Œæˆ‘ä»¬å¿…é¡»æ‰§è¡Œä¸€ä¸ªå¯¹é½æ­¥éª¤æ¥æ‰¾åˆ°è¿™äº›ç­‰æ•ˆåºåˆ—ã€‚æ­£å¦‚ä½ å¯èƒ½å·²ç»çŒœåˆ°çš„ï¼Œè¿™ä¸ªè¿‡ç¨‹éå¸¸ç±»ä¼¼äºè®¡ç®—ç¼–è¾‘è·ç¦»ï¼Œå¹¶ä½¿ç”¨æŸä¸ªé˜ˆå€¼æ¥ç¡®å®šç¼–è¾‘æ˜¯å¦è¶³å¤Ÿå°ã€‚ä¸ºäº†ç²¾ç¡®èµ·è§ï¼Œæˆ‘ä»¬æ­£åœ¨æ‰§è¡Œå±€éƒ¨[åºåˆ—å¯¹é½](http://en.wikipedia.org/wiki/Sequence_alignment)ã€‚è¿™ä¸ªç®—æ³•ä»¥å®ƒçš„åˆ›é€ è€…å‘½åï¼Œç§°ä¸ºSmith-Watermanï¼Œå› ä¸ºå®ƒæœ¬è´¨ä¸Šç›¸åŒï¼Œå…·æœ‰ä¸Levenshteinç®—æ³•ç›¸åŒçš„å¤æ‚åº¦ã€‚
- en: 'The only difference between traditional presentations of Levenshtein and Smith-Waterman
    is something we alluded to earlier: why is every edit given a distance of one?
    Instead, in the Smith-Waterman presentation, we assume that we have a function
    that gives us the gap score, i.e., the value to assign every characterâ€™s alignment,
    i.e., scores for both matches and edits, with scores driven by biological considerations.
    Of course, as we have already noted, this need is not peculiar to biology; we
    could just as well use a â€œgap scoreâ€ to reflect the likelihood of a substitution
    based on keyboard characteristics.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Levenshteinå’ŒSmith-Watermançš„ä¼ ç»Ÿè¡¨è¿°ä¹‹é—´çš„å”¯ä¸€åŒºåˆ«æ˜¯æˆ‘ä»¬ä¹‹å‰æåˆ°çš„ï¼šä¸ºä»€ä¹ˆæ¯ä¸ªç¼–è¾‘éƒ½ç»™äº†ä¸€ä¸ªè·ç¦»ä¸ºä¸€çš„å€¼ï¼Ÿç›¸åï¼Œåœ¨Smith-Watermançš„è¡¨è¿°ä¸­ï¼Œæˆ‘ä»¬å‡è®¾æœ‰ä¸€ä¸ªå‡½æ•°å¯ä»¥ç»™æˆ‘ä»¬é—´éš™åˆ†æ•°ï¼Œå³åˆ†é…ç»™æ¯ä¸ªå­—ç¬¦å¯¹é½çš„å€¼ï¼Œå³åŒ¹é…å’Œç¼–è¾‘çš„åˆ†æ•°ï¼Œåˆ†æ•°ç”±ç”Ÿç‰©è€ƒè™‘é©±åŠ¨ã€‚å½“ç„¶ï¼Œæ­£å¦‚æˆ‘ä»¬ä¹‹å‰å·²ç»æŒ‡å‡ºçš„ï¼Œè¿™ç§éœ€æ±‚å¹¶ä¸å±€é™äºç”Ÿç‰©å­¦ï¼›æˆ‘ä»¬åŒæ ·å¯ä»¥ä½¿ç”¨â€œé—´éš™åˆ†æ•°â€æ¥åæ˜ åŸºäºé”®ç›˜ç‰¹æ€§çš„æ›¿æ¢å¯èƒ½æ€§ã€‚
- en: 22.4Â Dynamic Programming[ğŸ”—](#(part._.Dynamic_.Programming) "Link to here")
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.4 åŠ¨æ€è§„åˆ’[ğŸ”—](#(part._.Dynamic_.Programming) "é“¾æ¥è‡³æ­¤")
- en: We have used memoization as our canonical means of saving the values of past
    computations to reuse later. There is another popular technique for doing this
    called dynamic programming. This technique is closely related to memoization;
    indeed, it can be viewed as the dual method for achieving the same end. First
    we will see dynamic programming at work, then discuss how it differs from memoization.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»ä½¿ç”¨è®°å¿†åŒ–ä½œä¸ºæˆ‘ä»¬ä¿å­˜è¿‡å»è®¡ç®—å€¼ä»¥ä¾›ä»¥åé‡ç”¨çš„æ ‡å‡†æ–¹æ³•ã€‚è¿˜æœ‰ä¸€ç§ç§°ä¸ºåŠ¨æ€è§„åˆ’çš„æµè¡ŒæŠ€æœ¯æ¥åšè¿™ä»¶äº‹ã€‚è¿™ç§æŠ€æœ¯ä¸è®°å¿†åŒ–å¯†åˆ‡ç›¸å…³ï¼›å®é™…ä¸Šï¼Œå®ƒå¯ä»¥è¢«è§†ä¸ºå®ç°ç›¸åŒç›®æ ‡çš„å¯¹å¶æ–¹æ³•ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å°†çœ‹åˆ°åŠ¨æ€è§„åˆ’æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œç„¶åè®¨è®ºå®ƒä¸è®°å¿†åŒ–çš„åŒºåˆ«ã€‚
- en: Dynamic programming also proceeds by building up a memory of answers, and looking
    them up instead of recomputing them. As such, it too is a process for turning
    a computationâ€™s shape from a tree to a DAG of actual calls. The key difference
    is that instead of starting with the largest computation and recurring to smaller
    ones, it starts with the smallest computations and builds outward to larger ones.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: åŠ¨æ€è§„åˆ’ä¹Ÿæ˜¯é€šè¿‡æ„å»ºç­”æ¡ˆçš„è®°å¿†æ¥è¿›è¡Œçš„ï¼Œå¹¶æŸ¥æ‰¾å®ƒä»¬è€Œä¸æ˜¯é‡æ–°è®¡ç®—ã€‚å› æ­¤ï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ªå°†è®¡ç®—å½¢çŠ¶ä»æ ‘è½¬æ¢ä¸ºå®é™…è°ƒç”¨æœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰çš„è¿‡ç¨‹ã€‚å…³é”®çš„åŒºåˆ«æ˜¯ï¼Œå®ƒä¸æ˜¯ä»æœ€å¤§çš„è®¡ç®—å¼€å§‹ï¼Œé€’å½’åˆ°è¾ƒå°çš„è®¡ç®—ï¼Œè€Œæ˜¯ä»æœ€å°çš„è®¡ç®—å¼€å§‹ï¼Œå‘å¤–æ‰©å±•åˆ°è¾ƒå¤§çš„è®¡ç®—ã€‚
- en: We will revisit our previous examples in light of this approach.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†æ ¹æ®è¿™ç§æ–¹æ³•é‡æ–°å®¡è§†æˆ‘ä»¬ä¹‹å‰çš„ä¾‹å­ã€‚
- en: 22.4.1Â Catalan Numbers with Dynamic Programming[ğŸ”—](#(part._.Catalan_.Numbers_with_.Dynamic_.Programming)
    "Link to here")
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.4.1 ä½¿ç”¨åŠ¨æ€è§„åˆ’çš„Catalanæ•°[ğŸ”—](#(part._.Catalan_.Numbers_with_.Dynamic_.Programming)
    "é“¾æ¥è‡³æ­¤")
- en: To begin with, we need to define a data structure to hold answers. Following
    convention, we will use an array.What happens when we run out of space? We can
    use the doubling technique we studied for [Halloween Analysis](amortized-analysis.html).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€ä¸ªæ•°æ®ç»“æ„æ¥å­˜å‚¨ç­”æ¡ˆã€‚æŒ‰ç…§æƒ¯ä¾‹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨æ•°ç»„ã€‚å½“æˆ‘ä»¬ç”¨å®Œç©ºé—´æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æˆ‘ä»¬ä¸º[ä¸‡åœ£èŠ‚åˆ†æ](amortized-analysis.html)å­¦ä¹ è¿‡çš„åŠ å€æŠ€æœ¯ã€‚
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, the `catalan` function simply looks up the answer in this array:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œ`catalan`å‡½æ•°ç®€å•åœ°åœ¨è¿™ä¸ªæ•°ç»„ä¸­æŸ¥æ‰¾ç­”æ¡ˆï¼š
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But how do we fill the array? We initialize the one known value, and use the
    formula to compute the rest in incremental order. Because we have multiple things
    to do in the body, we use `block`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æˆ‘ä»¬å¦‚ä½•å¡«å……è¿™ä¸ªæ•°ç»„å‘¢ï¼Ÿæˆ‘ä»¬åˆå§‹åŒ–ä¸€ä¸ªå·²çŸ¥çš„å€¼ï¼Œå¹¶ä½¿ç”¨å…¬å¼æŒ‰å¢é‡é¡ºåºè®¡ç®—å…¶ä½™éƒ¨åˆ†ã€‚å› ä¸ºæˆ‘ä»¬åœ¨ä¸»ä½“ä¸­è¦åšå¾ˆå¤šäº‹æƒ…ï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨`block`ï¼š
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The resulting program obeys the tests in [<catalan-tests>](#%28elem._catalan-tests%29).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ç”Ÿæˆçš„ç¨‹åºéµå¾ª[<catalan-tests>](#%28elem._catalan-tests%29)ä¸­çš„æµ‹è¯•ã€‚
- en: Notice that we have had to undo the natural recursive definitionâ€”<wbr>which
    proceeds from bigger values to smaller onesâ€”<wbr>to instead use a loop that goes
    from smaller values to larger ones. In principle, the program has the danger that
    when we apply `catalan` to some value, that index of `answers` will have not yet
    been initialized, resultingin an error. In fact, however, we know that because
    we fill all smaller indices in `answers` before computing the next larger one,
    we will never actually encounter this error. Note that this requires careful reasoning
    about our program, which we did not need to perform when using memoization because
    there we made precisely the recursive call we needed, which either looked up the
    value or computed it afresh.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬ä¸å¾—ä¸æ’¤é”€è‡ªç„¶çš„é€’å½’å®šä¹‰â€”â€”<wbr>å®ƒä»è¾ƒå¤§çš„å€¼å¼€å§‹é€’å‡åˆ°è¾ƒå°çš„å€¼â€”â€”<wbr>è€Œæ˜¯ä½¿ç”¨ä¸€ä¸ªä»è¾ƒå°çš„å€¼é€’å¢åˆ°è¾ƒå¤§çš„å€¼çš„å¾ªç¯ã€‚åŸåˆ™ä¸Šï¼Œç¨‹åºå­˜åœ¨è¿™æ ·çš„å±é™©ï¼šå½“æˆ‘ä»¬å¯¹æŸä¸ªå€¼åº”ç”¨
    `catalan` æ—¶ï¼Œ`answers` çš„é‚£ä¸ªç´¢å¼•å¯èƒ½å°šæœªåˆå§‹åŒ–ï¼Œä»è€Œå¯¼è‡´é”™è¯¯ã€‚ç„¶è€Œï¼Œå®é™…ä¸Šï¼Œæˆ‘ä»¬çŸ¥é“å› ä¸ºæˆ‘ä»¬æ˜¯åœ¨è®¡ç®—ä¸‹ä¸€ä¸ªè¾ƒå¤§çš„å€¼ä¹‹å‰å¡«å…… `answers`
    ä¸­æ‰€æœ‰è¾ƒå°çš„ç´¢å¼•ï¼Œæ‰€ä»¥æˆ‘ä»¬å®é™…ä¸Šæ°¸è¿œä¸ä¼šé‡åˆ°è¿™ä¸ªé”™è¯¯ã€‚è¯·æ³¨æ„ï¼Œè¿™éœ€è¦æˆ‘ä»¬å¯¹ç¨‹åºè¿›è¡Œä»”ç»†çš„æ¨ç†ï¼Œè€Œåœ¨ä½¿ç”¨è®°å¿†åŒ–æ—¶æˆ‘ä»¬ä¸éœ€è¦è¿™æ ·åšï¼Œå› ä¸ºåœ¨é‚£é‡Œæˆ‘ä»¬åšäº†ç²¾ç¡®çš„é€’å½’è°ƒç”¨ï¼Œè¦ä¹ˆæŸ¥æ‰¾å€¼ï¼Œè¦ä¹ˆé‡æ–°è®¡ç®—ã€‚
- en: 22.4.2Â Levenshtein Distance and Dynamic Programming[ğŸ”—](#(part._.Levenshtein_.Distance_and_.Dynamic_.Programming)
    "Link to here")
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.4.2Â Levenshtein è·ç¦»ä¸åŠ¨æ€è§„åˆ’[ğŸ”—](#(part._.Levenshtein_.Distance_and_.Dynamic_.Programming)
    "é“¾æ¥è‡³æ­¤")
- en: 'Now letâ€™s take on rewriting the Levenshtein distance computation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬ç€æ‰‹é‡å†™ Levenshtein è·ç¦»è®¡ç®—ï¼š
- en: <levenshtein-dp> ::=
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp> ::=
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will use a table representing the edit distance for each prefix of each word.
    That is, we will have a two-dimensional table with as many rows as the length
    of `s1` and as many columns as the length of `s2`. At each position, we will record
    the edit distance for the prefixes of `s1` and `s2` up to the indices represented
    by that position in the table.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªè¡¨æ¥è¡¨ç¤ºæ¯ä¸ªå•è¯æ¯ä¸ªå‰ç¼€çš„ç¼–è¾‘è·ç¦»ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å°†æœ‰ä¸€ä¸ªäºŒç»´è¡¨ï¼Œè¡Œæ•°ä¸ `s1` çš„é•¿åº¦ç›¸åŒï¼Œåˆ—æ•°ä¸ `s2` çš„é•¿åº¦ç›¸åŒã€‚åœ¨æ¯ä¸€ä¸ªä½ç½®ï¼Œæˆ‘ä»¬å°†è®°å½•
    `s1` å’Œ `s2` çš„å‰ç¼€çš„ç¼–è¾‘è·ç¦»ï¼Œç›´åˆ°ç”±è¡¨ä¸­è¯¥ä½ç½®è¡¨ç¤ºçš„ç´¢å¼•ã€‚
- en: 'Note that index arithmetic will be a constant burden: if a word is of length
    \(n\), we have to record the edit distance to its \(n + 1\) positions, the extra
    one corresponding to the empty word. This will hold for both words:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œç´¢å¼•è¿ç®—å°†æ˜¯ä¸€ä¸ªæ’å®šçš„è´Ÿæ‹…ï¼šå¦‚æœä¸€ä¸ªå•è¯çš„é•¿åº¦ä¸º \(n\)ï¼Œæˆ‘ä»¬å¿…é¡»è®°å½•å…¶ \(n + 1\) ä¸ªä½ç½®çš„ç¼–è¾‘è·ç¦»ï¼Œé¢å¤–çš„é‚£ä¸ªå¯¹åº”äºç©ºå•è¯ã€‚è¿™é€‚ç”¨äºä¸¤ä¸ªå•è¯ï¼š
- en: <levenshtein-dp/1> ::=
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/1> ::=
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Observe that by creating `answers` inside `levenshtein`, we can determine the
    exact size it needs to be based on the inputs, rather than having to over-allocate
    or dynamically grow the array.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œé€šè¿‡åœ¨ `levenshtein` ä¸­åˆ›å»º `answers`ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®è¾“å…¥ç¡®å®šå…¶ç¡®åˆ‡å¤§å°ï¼Œè€Œä¸æ˜¯å¿…é¡»è¿›è¡Œè¿‡åº¦åˆ†é…æˆ–åŠ¨æ€å¢é•¿æ•°ç»„ã€‚
- en: Exercise
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define the functions
  id: totrans-154
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®šä¹‰å‡½æ•°
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-156
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have initialized the table with `none`, so we will get an error if we accidentally
    try to use an uninitialized entry.Which proved to be necessary when writing and
    debugging this code! It will therefore be convenient to create helper functions
    that let us pretend the table contains only numbers:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»ç”¨ `none` åˆå§‹åŒ–äº†è¡¨ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬ä¸å°å¿ƒå°è¯•ä½¿ç”¨æœªåˆå§‹åŒ–çš„æ¡ç›®ï¼Œå°†ä¼šå¾—åˆ°é”™è¯¯ã€‚è¿™åœ¨ç¼–å†™å’Œè°ƒè¯•æ­¤ä»£ç æ—¶è¢«è¯æ˜æ˜¯å¿…è¦çš„ï¼å› æ­¤ï¼Œåˆ›å»ºè¾…åŠ©å‡½æ•°æ¥è®©æˆ‘ä»¬å‡è£…è¡¨åªåŒ…å«æ•°å­—å°†ä¼šå¾ˆæ–¹ä¾¿ï¼š
- en: <levenshtein-dp/2> ::=
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/2> ::=
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we have to populate the array. First, we initialize the row representing
    the edit distances when `s2` is empty, and the column where `s1` is empty. At
    \((0, 0)\), the edit distance is zero; at every position thereafter, it is the
    distance of that position from zero, because that many characters must be added
    to one or deleted from the other word for the two to coincide:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¿…é¡»å¡«å……æ•°ç»„ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬åˆå§‹åŒ–è¡¨ç¤ºå½“ `s2` ä¸ºç©ºæ—¶çš„ç¼–è¾‘è·ç¦»çš„è¡Œï¼Œä»¥åŠå½“ `s1` ä¸ºç©ºæ—¶çš„åˆ—ã€‚åœ¨ \((0, 0)\)ï¼Œç¼–è¾‘è·ç¦»ä¸ºé›¶ï¼›åœ¨æ­¤ä¹‹åæ¯ä¸ªä½ç½®ï¼Œå®ƒéƒ½æ˜¯è¯¥ä½ç½®ä¸é›¶çš„è·ç¦»ï¼Œå› ä¸ºå¿…é¡»å‘ä¸€ä¸ªå•è¯æ·»åŠ é‚£ä¹ˆå¤šå­—ç¬¦æˆ–ä»å¦ä¸€ä¸ªå•è¯ä¸­åˆ é™¤é‚£ä¹ˆå¤šå­—ç¬¦ï¼Œä»¥ä¾¿ä¸¤ä¸ªå•è¯ç›¸åŒ¹é…ï¼š
- en: <levenshtein-dp/3> ::=
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/3> ::=
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we finally get to the heart of the computation. We need to iterate over
    every character in each word. these characters are at indices `0` to `s1-len -
    1` and `s2-len - 1`, which are precisely the ranges of values produced by `range(0,
    s1-len)` and `range(0, s2-len)`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬ç»ˆäºåˆ°è¾¾äº†è®¡ç®—çš„ç²¾é«“ã€‚æˆ‘ä»¬éœ€è¦éå†æ¯ä¸ªå•è¯ä¸­çš„æ¯ä¸ªå­—ç¬¦ã€‚è¿™äº›å­—ç¬¦çš„ç´¢å¼•æ˜¯ `0` åˆ° `s1-len - 1` å’Œ `s2-len - 1`ï¼Œè¿™æ­£æ˜¯
    `range(0, s1-len)` å’Œ `range(0, s2-len)` ç”Ÿæˆçš„å€¼çš„èŒƒå›´ã€‚
- en: <levenshtein-dp/4> ::=
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/4> ::=
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that weâ€™re building our way â€œoutâ€ from small cases to large ones, rather
    than starting with the large input and working our way â€œdownâ€, recursively, to
    small ones.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬æ˜¯ä»¥ä»å°åˆ°å¤§æ„å»ºçš„æ–¹å¼ï¼Œè€Œä¸æ˜¯ä»å¤§è¾“å…¥å¼€å§‹ï¼Œé€’å½’åœ°å‘ä¸‹å·¥ä½œåˆ°å°è¾“å…¥ã€‚
- en: Do Now!
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is this strictly true?
  id: totrans-169
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸¥æ ¼æ­£ç¡®å—ï¼Ÿ
- en: No, it isnâ€™t. We did first fill in values for the â€œbordersâ€ of the table. This
    is because doing so in the midst of [<levenshtein-dp/compute-dist>](#%28elem._levenshtein-dp%2Fcompute-dist%29)
    would be much more annoying. By initializing all the known values, we keep the
    core computation cleaner. But it does mean the order in which we fill in the table
    is fairly complex.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ï¼Œä¸æ˜¯è¿™æ ·çš„ã€‚æˆ‘ä»¬é¦–å…ˆä¸ºè¡¨æ ¼çš„â€œè¾¹ç•Œâ€å¡«å……äº†å€¼ã€‚è¿™æ˜¯å› ä¸ºåœ¨ä¸­é€”è¿›è¡Œ[<levenshtein-dp/compute-dist>](#%28elem._levenshtein-dp%2Fcompute-dist%29)ä¼šéå¸¸éº»çƒ¦ã€‚é€šè¿‡åˆå§‹åŒ–æ‰€æœ‰å·²çŸ¥å€¼ï¼Œæˆ‘ä»¬ä½¿æ ¸å¿ƒè®¡ç®—æ›´åŠ æ¸…æ™°ã€‚ä½†è¿™ç¡®å®æ„å‘³ç€æˆ‘ä»¬å¡«å……è¡¨æ ¼çš„é¡ºåºç›¸å½“å¤æ‚ã€‚
- en: 'Now, letâ€™s return to computing the distance. For each pair of positions, we
    want the edit distance between the pair of words up to and including those positions.
    This distance is given by checking whether the characters at the pair of positions
    are identical. If they are, then the distance is the same as it was for the previous
    pair of prefixes; otherwise we have to try the three different kinds of edits:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬å›åˆ°è®¡ç®—è·ç¦»ã€‚å¯¹äºæ¯ä¸€å¯¹ä½ç½®ï¼Œæˆ‘ä»¬æƒ³è¦è®¡ç®—è¿™ä¸¤ä¸ªå•è¯ä¹‹é—´çš„ç¼–è¾‘è·ç¦»ï¼ŒåŒ…æ‹¬å¹¶åˆ°è¾¾è¿™äº›ä½ç½®ã€‚è¿™ä¸ªè·ç¦»æ˜¯é€šè¿‡æ£€æŸ¥è¿™å¯¹ä½ç½®ä¸Šçš„å­—ç¬¦æ˜¯å¦ç›¸åŒæ¥ç»™å‡ºçš„ã€‚å¦‚æœå®ƒä»¬ç›¸åŒï¼Œé‚£ä¹ˆè·ç¦»ä¸ä¹‹å‰çš„å‰ç¼€å¯¹ç›¸åŒï¼›å¦åˆ™ï¼Œæˆ‘ä»¬å¿…é¡»å°è¯•ä¸‰ç§ä¸åŒçš„ç¼–è¾‘æ–¹å¼ï¼š
- en: <levenshtein-dp/compute-dist> ::=
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/compute-dist> ::=
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As an aside, this sort of â€œoff-by-oneâ€ coordinate arithmetic is traditional
    when using tabular representations, because we write code in terms of elements
    that are not inherently present, and therefore have to create a padded table to
    hold values for the boundary conditions. The alternative would be to allow the
    table to begin its addressing from `-1` so that the main computation looks traditional.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæ—æ³¨ï¼Œè¿™ç§â€œåç§»ä¸€ä½â€çš„åæ ‡ç®—æœ¯åœ¨è¡¨æ ¼è¡¨ç¤ºæ³•ä¸­æ˜¯ä¼ ç»Ÿçš„ï¼Œå› ä¸ºæˆ‘ä»¬ç”¨ä¸å›ºæœ‰çš„å…ƒç´ æ¥ç¼–å†™ä»£ç ï¼Œå› æ­¤å¿…é¡»åˆ›å»ºå¡«å……è¡¨æ ¼æ¥ä¿å­˜è¾¹ç•Œæ¡ä»¶çš„å€¼ã€‚å¦ä¸€ç§é€‰æ‹©æ˜¯å…è®¸è¡¨æ ¼ä»
    `-1` å¼€å§‹å¯»å€ï¼Œè¿™æ ·ä¸»è¦è®¡ç®—çœ‹èµ·æ¥æ›´ä¼ ç»Ÿã€‚
- en: 'At any rate, when this computation is done, the entire table has been filled
    with values. We still have to read out the answer, with lies at the end of the
    table:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: æ— è®ºå¦‚ä½•ï¼Œå½“è¿™ä¸ªè®¡ç®—å®Œæˆæ—¶ï¼Œæ•´ä¸ªè¡¨æ ¼å·²ç»å¡«å……äº†å€¼ã€‚æˆ‘ä»¬ä»ç„¶éœ€è¦è¯»å–ç­”æ¡ˆï¼Œä½äºè¡¨æ ¼çš„æœ«å°¾ï¼š
- en: <levenshtein-dp/get-result> ::=
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/get-result> ::=
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Even putting aside the helper functions we wrote to satiate our paranoia about
    using undefined values, we end up with:As of this writing, the [current version](http://en.wikipedia.org/w/index.php?title=Levenshtein_distance&oldid=581406185#Iterative_with_full_matrix)
    of the [Wikipedia page](http://en.wikipedia.org/wiki/Levenshtein_distance) on
    the Levenshtein distance features a dynamic programming version that is very similar
    to the code above. By writing in pseudocode, it avoids address arithmetic issues
    (observe how the words are indexed starting from 1 instead of 0, which enables
    the body of the code to look more â€œnormalâ€), and by initializing all elements
    to zero it permits subtle bugs because an uninitialized table element is indistinguishable
    from a legitimate entry with edit distance of zero. The page also shows the [recursive](http://en.wikipedia.org/w/index.php?title=Levenshtein_distance&oldid=581406185#Recursive)
    solution and alludes to memoization, but does not show it in code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: å³ä½¿æŠ›å¼€æˆ‘ä»¬ç¼–å†™çš„è¾…åŠ©å‡½æ•°æ¥æ»¡è¶³æˆ‘ä»¬å¯¹ä½¿ç”¨æœªå®šä¹‰å€¼çš„æ‹…å¿§ï¼Œæˆ‘ä»¬æœ€ç»ˆå¾—åˆ°ï¼šæˆªè‡³æœ¬æ–‡å†™ä½œæ—¶ï¼Œ[ç»´åŸºç™¾ç§‘é¡µé¢](http://en.wikipedia.org/w/index.php?title=Levenshtein_distance&oldid=581406185#Iterative_with_full_matrix)ä¸Šçš„Levenshteinè·ç¦»çš„å½“å‰ç‰ˆæœ¬æä¾›äº†ä¸€ä¸ªä¸ä¸Šè¿°ä»£ç éå¸¸ç›¸ä¼¼çš„åŠ¨æ€è§„åˆ’ç‰ˆæœ¬ã€‚é€šè¿‡ç¼–å†™ä¼ªä»£ç ï¼Œå®ƒé¿å…äº†åœ°å€ç®—æœ¯é—®é¢˜ï¼ˆè§‚å¯Ÿå•è¯æ˜¯å¦‚ä½•ä»1å¼€å§‹ç´¢å¼•è€Œä¸æ˜¯0ï¼Œè¿™ä½¿å¾—ä»£ç çš„ä¸»ä½“çœ‹èµ·æ¥æ›´â€œæ­£å¸¸â€ï¼‰ï¼Œå¹¶ä¸”é€šè¿‡å°†æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºé›¶ï¼Œå®ƒå…è®¸å¾®å¦™çš„é”™è¯¯ï¼Œå› ä¸ºæœªåˆå§‹åŒ–çš„è¡¨æ ¼å…ƒç´ ä¸ç¼–è¾‘è·ç¦»ä¸ºé›¶çš„æœ‰æ•ˆæ¡ç›®æ— æ³•åŒºåˆ†ã€‚è¯¥é¡µé¢è¿˜å±•ç¤ºäº†[é€’å½’](http://en.wikipedia.org/w/index.php?title=Levenshtein_distance&oldid=581406185#Recursive)è§£å†³æ–¹æ¡ˆå¹¶æš—ç¤ºäº†è®°å¿†åŒ–ï¼Œä½†å¹¶æœªåœ¨ä»£ç ä¸­å±•ç¤ºã€‚
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: which is worth contrasting with the memoized version ([<levenshtein-memo>](#%28elem._levenshtein-memo%29)).For
    more examples of canonical dynamic programming problems, see [this page](http://people.csail.mit.edu/bdean/6.046/dp/)
    and think about how each can be expressed as a direct recursion.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸è®°å¿†åŒ–ç‰ˆæœ¬([<levenshtein-memo>](#%28elem._levenshtein-memo%29))å€¼å¾—å¯¹æ¯”ã€‚æ›´å¤šç»å…¸çš„åŠ¨æ€è§„åˆ’é—®é¢˜ç¤ºä¾‹ï¼Œè¯·å‚é˜…[è¿™ä¸ªé¡µé¢](http://people.csail.mit.edu/bdean/6.046/dp/)ï¼Œå¹¶æ€è€ƒæ¯ä¸ªé—®é¢˜å¦‚ä½•ç›´æ¥é€’å½’è¡¨è¾¾ã€‚
- en: 22.5Â Contrasting Memoization and Dynamic Programming[ğŸ”—](#(part._memo-vs-dp)
    "Link to here")
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.5 å¯¹æ¯”è®°å¿†åŒ–å’ŒåŠ¨æ€è§„åˆ’[ğŸ”—](#(part._memo-vs-dp) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Now that weâ€™ve seen two very different techniques for avoiding recomputation,
    itâ€™s worth contrasting them. The important thing to note is that memoization is
    a much simpler technique: write the natural recursive definition; determine its
    time complexity; decide whether this is problematic enough to warrant a space-time
    trade-off; and if it is, apply memoization. The code remains clean, and subsequent
    readers and maintainers will be grateful for that. In contrast, dynamic programming
    requires a reorganization of the algorithm to work bottom-up, which can often
    make the code harder to follow and full of subtle invariants about boundary conditions
    and computation order.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†ä¸¤ç§é¿å…é‡å¤è®¡ç®—çš„ä¸åŒæŠ€æœ¯ï¼Œå€¼å¾—å¯¹æ¯”å®ƒä»¬ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè®°å¿†åŒ–æ˜¯ä¸€ä¸ªæ›´ç®€å•çš„æŠ€æœ¯ï¼šå†™å‡ºè‡ªç„¶çš„é€’å½’å®šä¹‰ï¼›ç¡®å®šå…¶æ—¶é—´å¤æ‚åº¦ï¼›åˆ¤æ–­è¿™æ˜¯å¦è¶³å¤Ÿæˆé—®é¢˜ï¼Œéœ€è¦æƒè¡¡æ—¶é—´å’Œç©ºé—´ï¼›å¦‚æœæ˜¯çš„è¯ï¼Œåº”ç”¨è®°å¿†åŒ–ã€‚ä»£ç ä¿æŒæ•´æ´ï¼Œåç»­çš„é˜…è¯»è€…å’Œç»´æŠ¤è€…ä¼šä¸ºæ­¤æ„Ÿåˆ°æ„Ÿæ¿€ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼ŒåŠ¨æ€è§„åˆ’éœ€è¦é‡æ–°ç»„ç»‡ç®—æ³•ä»¥è‡ªåº•å‘ä¸Šå·¥ä½œï¼Œè¿™é€šå¸¸ä¼šä½¿ä»£ç æ›´éš¾ä»¥ç†è§£ï¼Œå¹¶å……æ»¡å…³äºè¾¹ç•Œæ¡ä»¶å’Œè®¡ç®—é¡ºåºçš„å¾®å¦™ä¸å˜é‡ã€‚
- en: That said, the dynamic programming solution can sometimes be more computationally
    efficient. For instance, in the Levenshtein case, observe that at each table element,
    we (at most) only ever use the ones that are from the previous row and column.
    That means we never need to store the entire table; we can retain just the fringe
    of the table, which reduces space to being proportional to the sum, rather than
    product, of the length of the words. In a computational biology setting (when
    using Smith-Waterman), for instance, this saving can be substantial. This optimization
    is essentially impossible for memoization.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: è¯è™½å¦‚æ­¤ï¼ŒåŠ¨æ€è§„åˆ’è§£å†³æ–¹æ¡ˆæœ‰æ—¶å¯èƒ½æ›´é«˜æ•ˆã€‚ä¾‹å¦‚ï¼Œåœ¨Levenshteinçš„æƒ…å†µä¸‹ï¼Œè§‚å¯Ÿæ¯ä¸ªè¡¨å…ƒç´ ï¼Œæˆ‘ä»¬ï¼ˆæœ€å¤šï¼‰åªä½¿ç”¨æ¥è‡ªä¸Šä¸€è¡Œå’Œåˆ—çš„å…ƒç´ ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬æ°¸è¿œä¸éœ€è¦å­˜å‚¨æ•´ä¸ªè¡¨ï¼›æˆ‘ä»¬åªéœ€ä¿ç•™è¡¨çš„è¾¹ç¼˜ï¼Œè¿™æ ·ç©ºé—´å°±ä¸å•è¯é•¿åº¦çš„å’Œæˆæ¯”ä¾‹ï¼Œè€Œä¸æ˜¯ä¹˜ç§¯ã€‚åœ¨è®¡ç®—ç”Ÿç‰©å­¦ç¯å¢ƒä¸­ï¼ˆä¾‹å¦‚ä½¿ç”¨Smith-Watermanï¼‰ï¼Œè¿™ç§èŠ‚çœå¯èƒ½æ˜¯å®è´¨æ€§çš„ã€‚è¿™ç§ä¼˜åŒ–å¯¹äºè®°å¿†åŒ–æ¥è¯´åŸºæœ¬ä¸Šæ˜¯ä¸å¯èƒ½çš„ã€‚
- en: 'In more detail, hereâ€™s the contrast:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´è¯¦ç»†åœ°è¯´ï¼Œè¿™é‡Œæ˜¯å¯¹æ¯”ï¼š
- en: '| Memoization |  | Dynamic Programming |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| è®°å¿†åŒ– |  | åŠ¨æ€è§„åˆ’ |'
- en: '| Top-down |  | Bottom-up |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| è‡ªé¡¶å‘ä¸‹ |  | è‡ªåº•å‘ä¸Š |'
- en: '| Depth-first |  | Breadth-first |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| æ·±åº¦ä¼˜å…ˆ |  | å¹¿åº¦ä¼˜å…ˆ |'
- en: '| Black-box |  | Requires code reorganization |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| é»‘ç›’ |  | éœ€è¦ä»£ç é‡æ„ |'
- en: '| All stored calls are necessary |  | May do unnecessary computation |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| æ‰€æœ‰å­˜å‚¨çš„è°ƒç”¨éƒ½æ˜¯å¿…è¦çš„ |  | å¯èƒ½è¿›è¡Œä¸å¿…è¦çš„è®¡ç®— |'
- en: '| Cannot easily get rid of unnecessary data |  | Can more easily get rid of
    unnecessary data |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| æ— æ³•è½»æ˜“å»é™¤ä¸å¿…è¦çš„æ•°æ® |  | å¯ä»¥æ›´è½»æ˜“åœ°å»é™¤ä¸å¿…è¦çš„æ•°æ® |'
- en: '| Can never accidentally use an uninitialized answer |  | Can accidentally
    use an uninitialized answer |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| æ°¸è¿œä¸ä¼šæ„å¤–ä½¿ç”¨æœªåˆå§‹åŒ–çš„ç­”æ¡ˆ |  | å¯èƒ½æ„å¤–ä½¿ç”¨æœªåˆå§‹åŒ–çš„ç­”æ¡ˆ |'
- en: '| Needs to check for the presence of an answer |  | Can be designed to not
    need to check for the presence of an answer |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| éœ€è¦æ£€æŸ¥ç­”æ¡ˆçš„å­˜åœ¨ |  | å¯ä»¥è®¾è®¡ä¸ºä¸éœ€è¦æ£€æŸ¥ç­”æ¡ˆçš„å­˜åœ¨ |'
- en: As this table should make clear, these are essentialy dual approaches. What
    is perhaps left unstated in most dynamic programming descriptions is that it,
    too, is predicated on the computation always producing the same answer for a given
    inputâ€”<wbr>i.e., being a pure function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æ­¤è¡¨æ ¼åº”æ¸…æ¥šåœ°è¡¨æ˜ï¼Œè¿™äº›åŸºæœ¬ä¸Šæ˜¯ä¸¤ç§å¯¹å¶æ–¹æ³•ã€‚åœ¨å¤§å¤šæ•°åŠ¨æ€è§„åˆ’æè¿°ä¸­å¯èƒ½æ²¡æœ‰æ˜ç¡®æŒ‡å‡ºçš„æ˜¯ï¼Œå®ƒä¹ŸåŸºäºå¯¹äºç»™å®šè¾“å…¥æ€»æ˜¯äº§ç”Ÿç›¸åŒç­”æ¡ˆçš„è®¡ç®—â€”â€”å³ï¼Œå®ƒæ˜¯ä¸€ä¸ªçº¯å‡½æ•°ã€‚
- en: From a software design perspective, there are two more considerations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è½¯ä»¶è®¾è®¡çš„è§’åº¦æ¥çœ‹ï¼Œè¿˜æœ‰ä¸¤ä¸ªé¢å¤–çš„è€ƒè™‘å› ç´ ã€‚
- en: 'First, the performance of a memoized solution can trail that of dynamic programming
    when the memoized solution uses a generic data structure to store the memo table,
    whereas a dynamic programming solution will invariably use a custom data structure
    (since the code needs to be rewritten against it anyway). Therefore, before switching
    to dynamic programming for performance reasons, it makes sense to try to create
    a custom memoizer for the problem: the same knowledge embodied in the dynamic
    programming version can often be encoded in this custom memoizer (e.g., using
    an array instead of list to improve access times). This way, the program can enjoy
    speed comparable to that of dynamic programming while retaining readability and
    maintainability.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œå½“è®°å¿†åŒ–è§£å†³æ–¹æ¡ˆä½¿ç”¨é€šç”¨æ•°æ®ç»“æ„æ¥å­˜å‚¨è®°å¿†è¡¨æ—¶ï¼Œå…¶æ€§èƒ½å¯èƒ½ä½äºåŠ¨æ€è§„åˆ’è§£å†³æ–¹æ¡ˆï¼Œè€ŒåŠ¨æ€è§„åˆ’è§£å†³æ–¹æ¡ˆå°†ä¸å¯é¿å…åœ°ä½¿ç”¨è‡ªå®šä¹‰æ•°æ®ç»“æ„ï¼ˆå› ä¸ºä»£ç éœ€è¦é’ˆå¯¹å®ƒè¿›è¡Œé‡å†™ï¼‰ã€‚å› æ­¤ï¼Œåœ¨å‡ºäºæ€§èƒ½åŸå› åˆ‡æ¢åˆ°åŠ¨æ€è§„åˆ’ä¹‹å‰ï¼Œå°è¯•ä¸ºé—®é¢˜åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰çš„è®°å¿†åŒ–å™¨æ˜¯æœ‰æ„ä¹‰çš„ï¼šåŠ¨æ€è§„åˆ’ç‰ˆæœ¬ä¸­ä½“ç°çš„ç›¸åŒçŸ¥è¯†é€šå¸¸å¯ä»¥ç¼–ç åœ¨è¿™ä¸ªè‡ªå®šä¹‰è®°å¿†åŒ–å™¨ä¸­ï¼ˆä¾‹å¦‚ï¼Œä½¿ç”¨æ•°ç»„è€Œä¸æ˜¯åˆ—è¡¨æ¥æé«˜è®¿é—®æ—¶é—´ï¼‰ã€‚è¿™æ ·ï¼Œç¨‹åºå¯ä»¥äº«å—ä¸åŠ¨æ€è§„åˆ’ç›¸å½“çš„é€Ÿåº¦ï¼ŒåŒæ—¶ä¿æŒå¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚
- en: Second, suppose space is an important consideration and the dynamic programming
    version can make use of significantly less space. Then it does make sense to employ
    dynamic programming instead. Does this mean the memoized version is useless?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒï¼Œå‡è®¾ç©ºé—´æ˜¯ä¸€ä¸ªé‡è¦çš„è€ƒè™‘å› ç´ ï¼Œå¹¶ä¸”åŠ¨æ€è§„åˆ’ç‰ˆæœ¬å¯ä»¥æ˜¾è‘—å‡å°‘ç©ºé—´ä½¿ç”¨ã€‚é‚£ä¹ˆï¼Œä½¿ç”¨åŠ¨æ€è§„åˆ’æ˜¯æœ‰æ„ä¹‰çš„ã€‚è¿™æ„å‘³ç€è®°å¿†åŒ–ç‰ˆæœ¬å°±æ— ç”¨äº†å—ï¼Ÿ
- en: Do Now!
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think? Do we still have use for the memoized version?
  id: totrans-199
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ è®¤ä¸ºå‘¢ï¼Ÿæˆ‘ä»¬æ˜¯å¦ä»ç„¶éœ€è¦è®°å¿†åŒ–ç‰ˆæœ¬ï¼Ÿ
- en: Yes, of course we do! It can serve as an oracle [[Oracles for Testing](testing.html#%28part._test-oracle%29)]
    for the dynamic programming version, since the two are supposed to produce identical
    answers anywayâ€”<wbr>and the memoized version would be a much more efficient oracle
    than the purely recursive implemenation, and can therefore be used to test the
    dynamic programming version on much larger inputs.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œæˆ‘ä»¬ç¡®å®éœ€è¦ï¼å®ƒå¯ä»¥ä½œä¸ºåŠ¨æ€è§„åˆ’ç‰ˆæœ¬çš„å ä½ç¬¦[[æµ‹è¯•çš„å ä½ç¬¦](testing.html#%28part._test-oracle%29)]ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªç‰ˆæœ¬åº”è¯¥äº§ç”Ÿç›¸åŒçš„ç­”æ¡ˆâ€”â€”<wbr>è€Œä¸”è®°å¿†åŒ–ç‰ˆæœ¬å°†æ˜¯ä¸€ä¸ªæ›´é«˜æ•ˆçš„å ä½ç¬¦ï¼Œæ¯”çº¯é€’å½’å®ç°æ›´é«˜æ•ˆï¼Œå› æ­¤å¯ä»¥ç”¨äºæµ‹è¯•åŠ¨æ€è§„åˆ’ç‰ˆæœ¬åœ¨æ›´å¤§çš„è¾“å…¥ä¸Šã€‚
- en: In short, always first produce the memoized version. If you need more performance,
    consider customizing the memoizerâ€™s data structure. If you need to also save space,
    and can arrive at a more space-efficient dynamic programming solution, then keep
    both versions around, using the former to test the latter (the person who inherits
    your code and needs to alter it will thank you!).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€è€Œè¨€ä¹‹ï¼Œé¦–å…ˆäº§ç”Ÿè®°å¿†åŒ–ç‰ˆæœ¬ã€‚å¦‚æœä½ éœ€è¦æ›´å¤šçš„æ€§èƒ½ï¼Œè€ƒè™‘å®šåˆ¶è®°å¿†åŒ–å™¨çš„æ•°æ®ç»“æ„ã€‚å¦‚æœä½ éœ€è¦èŠ‚çœç©ºé—´ï¼Œå¹¶ä¸”å¯ä»¥åˆ°è¾¾ä¸€ä¸ªæ›´èŠ‚çœç©ºé—´çš„åŠ¨æ€è§„åˆ’è§£å†³æ–¹æ¡ˆï¼Œé‚£ä¹ˆä¿ç•™ä¸¤ä¸ªç‰ˆæœ¬ï¼Œä½¿ç”¨å‰è€…æµ‹è¯•åè€…ï¼ˆç»§æ‰¿ä½ ä»£ç å¹¶éœ€è¦ä¿®æ”¹å®ƒçš„äººä¼šæ„Ÿè°¢ä½ ï¼ï¼‰ã€‚
- en: Exercise
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We have characterized the fundamental difference between memoization and dynamic
    programming as that between top-down, depth-first and bottom-up, breadth-first
    computation. This should naturally raise the question, what about:'
  id: totrans-204
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†è®°å¿†åŒ–ä¸åŠ¨æ€è§„åˆ’ä¹‹é—´çš„åŸºæœ¬åŒºåˆ«æè¿°ä¸ºè‡ªé¡¶å‘ä¸‹ã€æ·±åº¦ä¼˜å…ˆä¸è‡ªåº•å‘ä¸Šã€å¹¿åº¦ä¼˜å…ˆè®¡ç®—çš„å·®å¼‚ã€‚è¿™è‡ªç„¶ä¼šå¼•å‘ä¸€ä¸ªé—®é¢˜ï¼Œé‚£ä¹ˆï¼š
- en: ''
  id: totrans-205
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: top-down, breadth-first
  id: totrans-206
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: è‡ªé¡¶å‘ä¸‹ï¼Œå¹¿åº¦ä¼˜å…ˆ
- en: ''
  id: totrans-207
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-208
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: bottom-up, depth-first
  id: totrans-209
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: è‡ªåº•å‘ä¸Šï¼Œæ·±åº¦ä¼˜å…ˆ
- en: ''
  id: totrans-210
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-211
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-212
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: orders of computation. Do they also have special names that we just happen to
    not know? Are they uninteresting? Or do they not get discussed for a reason?
  id: totrans-213
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è®¡ç®—é¡ºåºã€‚å®ƒä»¬ä¹Ÿæœ‰ç‰¹æ®Šåç§°ï¼Œæˆ‘ä»¬åªæ˜¯ä¸çŸ¥é“å—ï¼Ÿå®ƒä»¬æ˜¯å¦æ— è¶£ï¼Ÿæˆ–è€…æ˜¯å› ä¸ºæŸç§åŸå› æ²¡æœ‰è®¨è®ºï¼Ÿ
- en: 22.1Â An Interesting Numeric Sequence[ğŸ”—](#(part._.An_.Interesting_.Numeric_.Sequence)
    "Link to here")
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.1 ä¸€ä¸ªæœ‰è¶£çš„æ•°å­—åºåˆ—[ğŸ”—](#(part._.An_.Interesting_.Numeric_.Sequence) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Suppose we want to create properly-parenthesized expressions, and ignore all
    non-parenthetical symbols. How many ways are there of creating parenthesized expressions
    given a certain number of opening (equivalently, closing) parentheses?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æƒ³è¦åˆ›å»ºæ­£ç¡®æ‹¬å·çš„è¡¨è¾¾å¼ï¼Œå¹¶å¿½ç•¥æ‰€æœ‰éæ‹¬å·ç¬¦å·ã€‚ç»™å®šä¸€å®šæ•°é‡çš„å¼€æ‹¬å·ï¼ˆç­‰ä»·äºé—­æ‹¬å·ï¼‰ï¼Œæœ‰å¤šå°‘ç§åˆ›å»ºæ‹¬å·è¡¨è¾¾å¼çš„å¯èƒ½æ€§ï¼Ÿ
- en: If we have zero opening parentheses, the only expression we can create is the
    empty expression. If we have one opening parenthesis, the only one we can construct
    is â€œ()â€ (there must be a closing parenthesis since weâ€™re interested only in properly-parenthesized
    expressions). If we have two opening parentheses, we can construct â€œ(())â€ and
    â€œ()()â€. Given three, we can construct â€œ((()))â€, â€œ(())()â€, â€œ()(())â€, â€œ()()()â€,
    and â€œ(()())â€, for a total of five. And so on. Observe that the solutions at each
    level use all the possible solutions at one level lower, combined in all the possible
    ways.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æ²¡æœ‰ä»»ä½•å¼€æ‹¬å·ï¼Œæˆ‘ä»¬èƒ½åˆ›å»ºçš„å”¯ä¸€è¡¨è¾¾å¼æ˜¯ç©ºè¡¨è¾¾å¼ã€‚å¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªå¼€æ‹¬å·ï¼Œæˆ‘ä»¬èƒ½æ„é€ çš„åªæœ‰â€œ()â€ï¼ˆç”±äºæˆ‘ä»¬åªå¯¹æ­£ç¡®æ‹¬å·çš„è¡¨è¾¾å¼æ„Ÿå…´è¶£ï¼Œæ‰€ä»¥å¿…é¡»æœ‰é—­æ‹¬å·ï¼‰ã€‚å¦‚æœæˆ‘ä»¬æœ‰ä¸¤ä¸ªå¼€æ‹¬å·ï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ â€œ(())â€å’Œâ€œ()()â€ã€‚ç»™å®šä¸‰ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ â€œ((()))â€ï¼Œâ€œ(())()â€ï¼Œâ€œ()(())â€ï¼Œâ€œ()()()â€å’Œâ€œ(()())â€ï¼Œæ€»å…±äº”ä¸ªã€‚ä»¥æ­¤ç±»æ¨ã€‚è§‚å¯Ÿæ¯ä¸ªçº§åˆ«çš„è§£å†³æ–¹æ¡ˆéƒ½ä½¿ç”¨äº†è¾ƒä½çº§åˆ«æ‰€æœ‰å¯èƒ½çš„è§£å†³æ–¹æ¡ˆï¼Œä»¥æ‰€æœ‰å¯èƒ½çš„æ–¹å¼ç»„åˆã€‚
- en: 'There is actually a famous mathematical sequence that corresponds to the number
    of such expressions, called the [Catalan sequence](http://en.wikipedia.org/wiki/Catalan_number).
    It has the property of growing quite large very quickly: starting from the modest
    origins above, the tenth Catalan number (i.e., tenth element of the Catalan sequence)
    is 16796\. A simple recurrence formula gives us the Catalan number, which we can
    turn into a simple program:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šå­˜åœ¨ä¸€ä¸ªè‘—åçš„æ•°å­¦åºåˆ—ï¼Œå¯¹åº”äºè¿™ç§è¡¨è¾¾å¼çš„æ•°é‡ï¼Œç§°ä¸º[Catalanåºåˆ—](http://en.wikipedia.org/wiki/Catalan_number)ã€‚å®ƒå…·æœ‰å¢é•¿éå¸¸å¿«çš„ç‰¹æ€§ï¼šä»ä¸Šè¿°ä¸èµ·çœ¼çš„èµ·æºå¼€å§‹ï¼Œç¬¬åä¸ªCatalanæ•°ï¼ˆå³Catalanåºåˆ—çš„ç¬¬åä¸ªå…ƒç´ ï¼‰æ˜¯16796ã€‚ä¸€ä¸ªç®€å•çš„é€’å½’å…¬å¼ç»™å‡ºäº†Catalanæ•°ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶è½¬åŒ–ä¸ºä¸€ä¸ªç®€å•çš„ç¨‹åºï¼š
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This functionâ€™s tests look as followsâ€”<wbr>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå‡½æ•°çš„æµ‹è¯•å¦‚ä¸‹â€”â€”<wbr>
- en: <catalan-tests> ::=
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <catalan-tests> ::=
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: but beware! When we time the functionâ€™s execution, we find that the first few
    tests run very quickly, but somewhere between a value of `10` and `20`â€”<wbr>depending
    on your machine and programming language implementationâ€”<wbr>you ought to see
    things start to slow down, first a little, then with extreme effect.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è¦å°å¿ƒï¼å½“æˆ‘ä»¬æµ‹é‡å‡½æ•°çš„æ‰§è¡Œæ—¶é—´æ—¶ï¼Œæˆ‘ä»¬å‘ç°å‰å‡ ä¸ªæµ‹è¯•è¿è¡Œå¾—éå¸¸å¿«ï¼Œä½†å¤§çº¦åœ¨`10`åˆ°`20`ä¹‹é—´â€”â€”è¿™å–å†³äºä½ çš„æœºå™¨å’Œç¼–ç¨‹è¯­è¨€å®ç°â€”â€”ä½ åº”è¯¥çœ‹åˆ°äº‹æƒ…å¼€å§‹å˜æ…¢ï¼Œå…ˆæ˜¯ç¨å¾®æ…¢ä¸€äº›ï¼Œç„¶åæ•ˆæœéå¸¸æ˜æ˜¾ã€‚
- en: Do Now!
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check at what value you start to observe a significant slowdown on your machine.
    Plot the graph of running time against input size. What does this suggest?
  id: totrans-225
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ£€æŸ¥åœ¨ä»€ä¹ˆå€¼æ—¶ä½ å¼€å§‹åœ¨ä½ çš„æœºå™¨ä¸Šè§‚å¯Ÿåˆ°æ˜¾è‘—çš„å‡é€Ÿã€‚ç»˜åˆ¶è¿è¡Œæ—¶é—´ä¸è¾“å…¥å¤§å°çš„å›¾è¡¨ã€‚è¿™è¡¨æ˜äº†ä»€ä¹ˆï¼Ÿ
- en: 'The reason the Catalan computation takes so long is precisely because of what
    we alluded to earlier: at each level, we depend on computing the Catalan number
    of all the smaller levels; this computation in turn needs the numbers of all of
    its smaller levels; and so on down the road.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: å¡å¡”å…°è®¡ç®—ä¹‹æ‰€ä»¥è€—æ—¶å¦‚æ­¤ä¹‹é•¿ï¼Œæ­£æ˜¯å› ä¸ºæˆ‘ä»¬ä¹‹å‰æåˆ°çš„ï¼šåœ¨æ¯ä¸€çº§ï¼Œæˆ‘ä»¬éƒ½ä¾èµ–äºè®¡ç®—æ‰€æœ‰è¾ƒå°çº§åˆ«çš„å¡å¡”å…°æ•°ï¼›è¿™ä¸ªè®¡ç®—åè¿‡æ¥åˆéœ€è¦æ‰€æœ‰è¾ƒå°çº§åˆ«çš„æ•°å­—ï¼›ä»¥æ­¤ç±»æ¨ã€‚
- en: Exercise
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Map the subcomputations of `catalan` to see why the computation time explodes
    as it does. What is the worst-case time complexity of this function?
  id: totrans-229
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°†`catalan`çš„å­è®¡ç®—æ˜ å°„å‡ºæ¥ï¼Œçœ‹çœ‹ä¸ºä»€ä¹ˆè®¡ç®—æ—¶é—´ä¼šå¦‚æ­¤çˆ†ç‚¸ã€‚è¿™ä¸ªå‡½æ•°çš„æœ€åæƒ…å†µæ—¶é—´å¤æ‚åº¦æ˜¯å¤šå°‘ï¼Ÿ
- en: 'Here is a graphical representation of all the sub-computations the Catalan
    function does for input `3`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯å¡å¡”å…°å‡½æ•°ä¸ºè¾“å…¥`3`æ‰€åšçš„æ‰€æœ‰å­è®¡ç®—çš„å›¾å½¢è¡¨ç¤ºï¼š
- en: '![](../Images/79fbf0941364e29afa9e7ce828c8b1ec.png)'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/79fbf0941364e29afa9e7ce828c8b1ec.png)'
- en: Observe the very symmetric computation, reflecting the formula.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿéå¸¸å¯¹ç§°çš„è®¡ç®—ï¼Œå®ƒåæ˜ äº†å…¬å¼ã€‚
- en: 22.1.1Â Using State to Remember Past Answers[ğŸ”—](#(part._.Using_.State_to_.Remember_.Past_.Answers)
    "Link to here")
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.1.1 ä½¿ç”¨çŠ¶æ€æ¥è®°ä½è¿‡å»çš„ç­”æ¡ˆ[ğŸ”—](#(part._.Using_.State_to_.Remember_.Past_.Answers) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Therefore, this is clearly a case where trading space for time is likely to
    be of help. How do we do this? We need a notion of memory that records all previous
    answers and, on subsequent attempts to compute them, checks whether they are already
    known and, if so, just returns them instead of recomputing them.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œè¿™æ˜¾ç„¶æ˜¯ä¸€ä¸ªé€šè¿‡ç‰ºç‰²ç©ºé—´æ¥æ¢å–æ—¶é—´å¯èƒ½æœ‰æ‰€å¸®åŠ©çš„æ¡ˆä¾‹ã€‚æˆ‘ä»¬å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹ï¼Ÿæˆ‘ä»¬éœ€è¦ä¸€ä¸ªèƒ½å¤Ÿè®°å½•æ‰€æœ‰å…ˆå‰ç­”æ¡ˆçš„è®°å¿†æ¦‚å¿µï¼Œå¹¶åœ¨éšåçš„å°è¯•è®¡ç®—å®ƒä»¬æ—¶ï¼Œæ£€æŸ¥å®ƒä»¬æ˜¯å¦å·²ç»çŸ¥é“ï¼Œå¦‚æœæ˜¯è¿™æ ·ï¼Œå°±åªéœ€è¿”å›å®ƒä»¬è€Œä¸æ˜¯é‡æ–°è®¡ç®—ã€‚
- en: Do Now!
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What critical assumption is this based on?
  id: totrans-237
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå‡è®¾åŸºäºä»€ä¹ˆå…³é”®å‡è®¾ï¼Ÿ
- en: Naturally, this assumes that for a given input, the answer will always be the
    same. As we have seen, functions with state violate this liberally, so typical
    stateful functions cannot utilize this optimization. Ironically, we will use state
    to implement this optimization, so we will have a stateful function that always
    returns the same answer on a given inputâ€”<wbr>and thereby use state in a stateful
    function to simulate a stateless one. Groovy, dude!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: è‡ªç„¶ï¼Œè¿™å‡è®¾å¯¹äºç»™å®šçš„è¾“å…¥ï¼Œç­”æ¡ˆæ€»æ˜¯ç›¸åŒçš„ã€‚æ­£å¦‚æˆ‘ä»¬æ‰€è§ï¼Œå…·æœ‰çŠ¶æ€çš„å‡½æ•°ä¼šè‡ªç”±åœ°è¿åè¿™ä¸€å‡è®¾ï¼Œå› æ­¤å…¸å‹çš„æœ‰çŠ¶æ€å‡½æ•°æ— æ³•åˆ©ç”¨è¿™ç§ä¼˜åŒ–ã€‚å…·æœ‰è®½åˆºæ„å‘³çš„æ˜¯ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨çŠ¶æ€æ¥å®ç°è¿™ç§ä¼˜åŒ–ï¼Œå› æ­¤æˆ‘ä»¬å°†æœ‰ä¸€ä¸ªåœ¨ç»™å®šè¾“å…¥ä¸Šæ€»æ˜¯è¿”å›ç›¸åŒç­”æ¡ˆçš„æœ‰çŠ¶æ€å‡½æ•°â€”â€”å¹¶ä¸”å› æ­¤åœ¨ä¸€ä¸ªæœ‰çŠ¶æ€å‡½æ•°ä¸­ä½¿ç”¨çŠ¶æ€æ¥æ¨¡æ‹Ÿä¸€ä¸ªæ— çŠ¶æ€å‡½æ•°ã€‚Groovyï¼Œä¼™è®¡ï¼
- en: 'First, then, we need some representation of memory. We can imagine several,
    but hereâ€™s a simple one:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦æŸç§å½¢å¼çš„è®°å¿†è¡¨ç¤ºã€‚æˆ‘ä»¬å¯ä»¥æƒ³è±¡å‡ ç§ï¼Œä½†è¿™é‡Œæœ‰ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼š
- en: '[PRE29]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now how does `catalan` need to change? We have to first look for whether the
    value is already in `memory`; if it is, we return it without any further computation,
    but if it isnâ€™t, then we compute the result, store it in `memory`, and then return
    it:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨å¦‚ä½•ä¿®æ”¹`catalan`ï¼Ÿæˆ‘ä»¬é¦–å…ˆéœ€è¦æŸ¥æ‰¾å€¼æ˜¯å¦å·²ç»åœ¨`memory`ä¸­ï¼›å¦‚æœæ˜¯ï¼Œæˆ‘ä»¬æ— éœ€è¿›ä¸€æ­¥è®¡ç®—å°±è¿”å›å®ƒï¼Œä½†å¦‚æœæ²¡æœ‰ï¼Œæˆ‘ä»¬å°±è®¡ç®—ç»“æœï¼Œå°†å…¶å­˜å‚¨åœ¨`memory`ä¸­ï¼Œç„¶åè¿”å›å®ƒï¼š
- en: '[PRE30]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: And thatâ€™s it! Now running our previous tests will reveal that the answer computes
    much quicker, but in addition we can dare to run bigger computations such as `catalan(50)`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: å°±è¿™æ ·ï¼ç°åœ¨è¿è¡Œæˆ‘ä»¬ä¹‹å‰çš„æµ‹è¯•å°†æ­ç¤ºç­”æ¡ˆè®¡ç®—å¾—æ›´å¿«ï¼Œä½†é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥å¤§èƒ†åœ°è¿è¡Œæ›´å¤§çš„è®¡ç®—ï¼Œä¾‹å¦‚`catalan(50)`ã€‚
- en: Do Now!
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Trace through a call of this revised function and see how many calls it makes.
  id: totrans-246
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è·Ÿè¸ªè¿™ä¸ªæ”¹è¿›å‡½æ•°çš„è°ƒç”¨ï¼Œçœ‹çœ‹å®ƒè°ƒç”¨äº†å¤šå°‘æ¬¡ã€‚
- en: 'Here is a revised visualization of computing for input `3`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯é’ˆå¯¹è¾“å…¥`3`çš„æ”¹è¿›åçš„è®¡ç®—å¯è§†åŒ–ï¼š
- en: '![](../Images/31c17fe6a16bbf3f25e501c178869546.png)'
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/31c17fe6a16bbf3f25e501c178869546.png)'
- en: 'Observe the asymmetric computation: the early calls perform the computations,
    while the latter calls simply look up the results.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿä¸å¯¹ç§°çš„è®¡ç®—ï¼šæ—©æœŸçš„è°ƒç”¨æ‰§è¡Œè®¡ç®—ï¼Œè€Œåç»­çš„è°ƒç”¨åªæ˜¯æŸ¥æ‰¾ç»“æœã€‚
- en: This process, of converting a function into a version that remembers its past
    answers, is called memoization.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè¿‡ç¨‹ï¼Œå°†ä¸€ä¸ªå‡½æ•°è½¬æ¢ä¸ºä¸€ä¸ªèƒ½å¤Ÿè®°ä½å…¶è¿‡å»ç­”æ¡ˆçš„ç‰ˆæœ¬ï¼Œè¢«ç§°ä¸ºè®°å¿†åŒ–ã€‚
- en: 22.1.2Â From a Tree of Computation to a DAG[ğŸ”—](#(part._.From_a_.Tree_of_.Computation_to_a_.D.A.G)
    "Link to here")
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.1.2 ä»è®¡ç®—æ ‘åˆ°æœ‰å‘æ— ç¯å›¾[ğŸ”—](#(part._.From_a_.Tree_of_.Computation_to_a_.D.A.G) "é“¾æ¥è‡³æ­¤")
- en: What we have subtly done is to convert a tree of computation into a DAG over
    the same computation, with equivalent calls being reused. Whereas previously each
    call was generating lots of recursive calls, which induced still more recursive
    calls, now we are reusing previous recursive callsâ€”<wbr>i.e., sharing the results
    computed earlier. This, in effect, points the recursive call to one that had occurred
    earlier. Thus, the shape of computation converts from a tree to a DAG of calls.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·§å¦™åœ°åšçš„æ˜¯å°†è®¡ç®—æ ‘è½¬æ¢ä¸ºåŒä¸€è®¡ç®—ä¸Šçš„æœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰ï¼Œå…¶ä¸­ç­‰æ•ˆè°ƒç”¨è¢«é‡å¤ä½¿ç”¨ã€‚è€Œä¹‹å‰æ¯ä¸ªè°ƒç”¨éƒ½ä¼šç”Ÿæˆå¤§é‡çš„é€’å½’è°ƒç”¨ï¼Œè¿™åˆå¼•å‘äº†æ›´å¤šçš„é€’å½’è°ƒç”¨ï¼Œç°åœ¨æˆ‘ä»¬æ­£åœ¨é‡å¤ä½¿ç”¨ä¹‹å‰çš„é€’å½’è°ƒç”¨â€”â€”å³ï¼Œå…±äº«ä¹‹å‰è®¡ç®—çš„ç»“æœã€‚å®é™…ä¸Šï¼Œè¿™æŒ‡å‘äº†ä¹‹å‰å‘ç”Ÿè¿‡çš„é€’å½’è°ƒç”¨ã€‚å› æ­¤ï¼Œè®¡ç®—çš„å½¢çŠ¶ä»æ ‘è½¬æ¢ä¸ºè°ƒç”¨å›¾çš„æœ‰å‘æ— ç¯å›¾ã€‚
- en: This has an important complexity benefit. Whereas previously we were performing
    a super-exponential number of calls, now we perform only one call per input and
    share all previous callsâ€”<wbr>thereby reducing `catalan(n)` to take a number of
    fresh calls proportional to `n`. Looking up the result of a previous call takes
    time proportional to the size of `memory` (because weâ€™ve represented it as a list;
    better representations would improve on that), but that only contributes another
    linear multiplicative factor, reducing the overall complexity to quadratic in
    the size of the input. This is a dramatic reduction in overall complexity. In
    contrast, other uses of memoization may result in much less dramatic improvements,
    turning the use of this technique into a true engineering trade-off.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¸¦æ¥äº†é‡è¦çš„å¤æ‚æ€§ä¼˜åŠ¿ã€‚ä¹‹å‰æˆ‘ä»¬æ‰§è¡Œçš„æ˜¯è¶…æŒ‡æ•°æ•°é‡çš„è°ƒç”¨ï¼Œè€Œç°åœ¨æˆ‘ä»¬åªå¯¹æ¯ä¸ªè¾“å…¥æ‰§è¡Œä¸€ä¸ªè°ƒç”¨å¹¶å…±äº«æ‰€æœ‰ä¹‹å‰çš„è°ƒç”¨â€”â€”å› æ­¤å°†`catalan(n)`çš„è°ƒç”¨æ¬¡æ•°å‡å°‘åˆ°ä¸`n`æˆæ¯”ä¾‹çš„æ–°è°ƒç”¨ã€‚æŸ¥æ‰¾ä¹‹å‰è°ƒç”¨çš„ç»“æœéœ€è¦ä¸`memory`çš„å¤§å°æˆæ¯”ä¾‹çš„æ—¶é—´ï¼ˆå› ä¸ºæˆ‘ä»¬å·²ç»å°†å…¶è¡¨ç¤ºä¸ºåˆ—è¡¨ï¼›æ›´å¥½çš„è¡¨ç¤ºä¼šæ”¹è¿›è¿™ä¸€ç‚¹ï¼‰ï¼Œä½†è¿™åªé¢å¤–è´¡çŒ®äº†ä¸€ä¸ªçº¿æ€§ä¹˜æ³•å› å­ï¼Œå°†æ•´ä½“å¤æ‚æ€§é™ä½åˆ°è¾“å…¥å¤§å°çš„äºŒæ¬¡æ–¹ã€‚è¿™æ˜¯ä¸€ä¸ªåœ¨æ•´ä½“å¤æ‚æ€§ä¸Šçš„æ˜¾è‘—é™ä½ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œå…¶ä»–è®°å¿†åŒ–çš„åº”ç”¨å¯èƒ½åªä¼šå¸¦æ¥ä¸é‚£ä¹ˆæ˜¾è‘—çš„æ”¹è¿›ï¼Œä½¿è¿™ç§æŠ€æœ¯çš„ä½¿ç”¨æˆä¸ºä¸€ä¸ªçœŸæ­£çš„å·¥ç¨‹æƒè¡¡ã€‚
- en: 22.1.3Â The Complexity of Numbers[ğŸ”—](#(part._numbers-not-constant) "Link to here")
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.1.3 æ•°å­—å¤æ‚æ€§[ğŸ”—](#(part._numbers-not-constant) "é“¾æ¥è‡³æ­¤")
- en: As we start to run larger computations, however, we may start to notice that
    our computations are starting to take longer than linear growth. This is because
    our numbers are growing arbitrarily largeâ€”<wbr>for instance, `catalan(100)` is
    `896519947090131496687170070074100632420837521538745909320`â€”<wbr>and computations
    on numbers can no longer be constant time, contrary to what we said earlier [[The
    Size of the Input](predicting-growth.html#%28part._size-of-input%29)]. Indeed,
    when working on cryptographic problems, the fact that operations on numbers do
    not take constant time are absolutely critical to fundamental complexity results
    (and, for instance, the presumed unbreakability of contemporary cryptography).
    (See also [Factoring Numbers](factoring-numbers.html).)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œå½“æˆ‘ä»¬å¼€å§‹è¿è¡Œæ›´å¤§çš„è®¡ç®—æ—¶ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå¼€å§‹æ³¨æ„åˆ°æˆ‘ä»¬çš„è®¡ç®—å¼€å§‹æ¯”çº¿æ€§å¢é•¿èŠ±è´¹æ›´é•¿çš„æ—¶é—´ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬çš„æ•°å­—æ­£åœ¨ä»»æ„å¢å¤§â€”â€”ä¾‹å¦‚ï¼Œ`catalan(100)`æ˜¯`896519947090131496687170070074100632420837521538745909320`â€”â€”å¹¶ä¸”æ•°å­—ä¸Šçš„è®¡ç®—ä¸å†èƒ½æ˜¯å¸¸æ•°æ—¶é—´ï¼Œè¿™ä¸æˆ‘ä»¬ä¹‹å‰æ‰€è¯´çš„ç›¸å
    [[è¾“å…¥å¤§å°](predicting-growth.html#%28part._size-of-input%29)]ã€‚å®é™…ä¸Šï¼Œåœ¨å¤„ç†å¯†ç å­¦é—®é¢˜æ—¶ï¼Œæ“ä½œæ•°å­—ä¸èŠ±è´¹å¸¸æ•°æ—¶é—´çš„äº‹å®å¯¹äºåŸºæœ¬å¤æ‚æ€§ç»“æœè‡³å…³é‡è¦ï¼ˆä¾‹å¦‚ï¼Œç°ä»£å¯†ç å­¦çš„å‡è®¾ä¸å¯ç ´è§£æ€§ï¼‰ã€‚ï¼ˆå‚è§[åˆ†è§£æ•°å­—](factoring-numbers.html)ã€‚ï¼‰
- en: 22.1.4Â Abstracting Memoization[ğŸ”—](#(part._.Abstracting_.Memoization) "Link to
    here")
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.1.4 æŠ½è±¡åŒ–è®°å¿†åŒ–[ğŸ”—](#(part._.Abstracting_.Memoization) "é“¾æ¥è‡³æ­¤")
- en: 'Now weâ€™ve achieved the desired complexity improvement, but there is still something
    unsatisfactory about the structure of our revised definition of `catalan`: the
    act of memoization is deeply intertwined with the definition of a Catalan number,
    even though these should be intellectually distinct. Letâ€™s do that next.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»å®ç°äº†æ‰€éœ€çš„å¤æ‚æ€§æ”¹è¿›ï¼Œä½†å…³äºæˆ‘ä»¬ä¿®è®¢çš„`catalan`å®šä¹‰çš„ç»“æ„ï¼Œä»ç„¶æœ‰ä¸€äº›ä»¤äººä¸æ»¡æ„çš„åœ°æ–¹ï¼šè®°å¿†åŒ–çš„è¡Œä¸ºä¸Catalanæ•°çš„å®šä¹‰ç´§å¯†ç›¸è¿ï¼Œå°½ç®¡å®ƒä»¬åœ¨æ™ºåŠ›ä¸Šåº”è¯¥æ˜¯ä¸åŒçš„ã€‚è®©æˆ‘ä»¬æ¥ä¸‹æ¥åšè¿™ä»¶äº‹ã€‚
- en: In effect, we want to separate our program into two parts. One part defines
    a general notion of memoization, while the other defines `catalan` in terms of
    this general notion.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼Œæˆ‘ä»¬å¸Œæœ›å°†æˆ‘ä»¬çš„ç¨‹åºåˆ†æˆä¸¤éƒ¨åˆ†ã€‚ä¸€éƒ¨åˆ†å®šä¹‰äº†ä¸€ä¸ªé€šç”¨çš„è®°å¿†åŒ–æ¦‚å¿µï¼Œè€Œå¦ä¸€éƒ¨åˆ†åˆ™ä½¿ç”¨è¿™ä¸ªé€šç”¨æ¦‚å¿µæ¥å®šä¹‰`catalan`ã€‚
- en: 'What does the former mean? We want to encapsulate the idea of â€œmemoryâ€ (since
    we presumably donâ€™t want this stored in a variable that any old part of the program
    can modify). This should result in a function that takes the input we want to
    check; if it is found in the memory we return that answer, otherwise we compute
    the answer, store it, and return it. To compute the answer, we need a function
    that determines how to do so. Putting together these pieces:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: å‰è€…æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿæˆ‘ä»¬æƒ³è¦å°è£…â€œè®°å¿†â€çš„æ¦‚å¿µï¼ˆå› ä¸ºæˆ‘ä»¬å¯èƒ½ä¸å¸Œæœ›å®ƒå­˜å‚¨åœ¨ä»»ä½•æ—§çš„éƒ¨åˆ†ç¨‹åºéƒ½å¯ä»¥ä¿®æ”¹çš„å˜é‡ä¸­ï¼‰ã€‚è¿™åº”è¯¥å¯¼è‡´ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥å—æˆ‘ä»¬æƒ³è¦æ£€æŸ¥çš„è¾“å…¥ï¼›å¦‚æœå®ƒåœ¨å†…å­˜ä¸­æ‰¾åˆ°ï¼Œæˆ‘ä»¬è¿”å›é‚£ä¸ªç­”æ¡ˆï¼Œå¦åˆ™æˆ‘ä»¬è®¡ç®—ç­”æ¡ˆï¼Œå­˜å‚¨å®ƒï¼Œç„¶åè¿”å›å®ƒã€‚ä¸ºäº†è®¡ç®—ç­”æ¡ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå‡½æ•°æ¥ç¡®å®šå¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹ã€‚å°†è¿™äº›éƒ¨åˆ†æ”¾åœ¨ä¸€èµ·ï¼š
- en: '[PRE31]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We use the name `memoize-1` to indicate that this is a memoizer for single-argument
    functions. Observe that the code above is virtually identical to what we had before,
    except where we had the logic of Catalan number computation, we now have the parameter
    `f` determining what to do.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä½¿ç”¨åç§° `memoize-1` æ¥è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªé’ˆå¯¹å•å‚æ•°å‡½æ•°çš„ç¼“å­˜å™¨ã€‚è§‚å¯Ÿä¸Šé¢çš„ä»£ç ï¼Œå®ƒä¸ä¹‹å‰çš„ä»£ç å‡ ä¹ç›¸åŒï¼Œåªæ˜¯åœ¨ä¹‹å‰æœ‰è®¡ç®— Catalan æ•°çš„é€»è¾‘çš„åœ°æ–¹ï¼Œæˆ‘ä»¬ç°åœ¨æœ‰äº†å‚æ•°
    `f` æ¥ç¡®å®šè¦åšä»€ä¹ˆã€‚
- en: 'With this, we can now define `catalan` as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥å®šä¹‰ `catalan` å¦‚ä¸‹ï¼š
- en: '[PRE32]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note several things about this definition:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„è¿™ä¸ªå®šä¹‰ä¸­çš„å‡ ä¸ªè¦ç‚¹ï¼š
- en: 'We donâ€™t write `fun catalan(...): ...;` because the procedure bound to `catalan`
    is produced by `memoize-1`.'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬ä¸å†™ `fun catalan(...): ...;` å› ä¸ºç»‘å®šåˆ° `catalan` çš„è¿‡ç¨‹æ˜¯ç”± `memoize-1` ç”Ÿæˆçš„ã€‚'
- en: Note carefully that the recursive calls to `catalan` have to be to the function
    bound to the result of memoization, thereby behaving like an object. Failing to
    refer to this same shared procedure means the recursive calls will not be memoized,
    thereby losing the benefit of this process.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä»”ç»†æ³¨æ„ï¼Œå¯¹ `catalan` çš„é€’å½’è°ƒç”¨å¿…é¡»æ˜¯å¯¹ç»‘å®šåˆ°ç¼“å­˜ç»“æœçš„å‡½æ•°çš„è°ƒç”¨ï¼Œå› æ­¤è¡¨ç°å¾—åƒä¸€ä¸ªå¯¹è±¡ã€‚æœªèƒ½å¼•ç”¨è¿™ä¸ªç›¸åŒçš„å…±äº«è¿‡ç¨‹æ„å‘³ç€é€’å½’è°ƒç”¨å°†ä¸ä¼šè¢«ç¼“å­˜ï¼Œä»è€Œå¤±å»äº†è¿™ä¸ªè¿‡ç¨‹çš„å¥½å¤„ã€‚
- en: We need to use `rec` for reasons we saw earlier [[Streams From Functions](func-as-data.html#%28part._streams-from-funs%29)].
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦ä½¿ç”¨ `rec` æ˜¯å› ä¸ºæˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„åŸå›  [[ä»å‡½æ•°ä¸­è·å–æµ](func-as-data.html#%28part._streams-from-funs%29)]ã€‚
- en: Each invocation of `memoize-1` creates a new table of stored results. Therefore
    the memoization of different functions will each get their own tables rather than
    sharing tables, which is a bad idea!
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ¯æ¬¡è°ƒç”¨ `memoize-1` éƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å­˜å‚¨ç»“æœè¡¨ã€‚å› æ­¤ï¼Œä¸åŒå‡½æ•°çš„ç¼“å­˜å°†å„è‡ªè·å¾—è‡ªå·±çš„è¡¨ï¼Œè€Œä¸æ˜¯å…±äº«è¡¨ï¼Œè¿™æ˜¯ä¸€ä¸ªåä¸»æ„ï¼
- en: Exercise
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is sharing memoization tables a bad idea? Be concrete.
  id: totrans-271
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆå…±äº«ç¼“å­˜è¡¨æ˜¯ä¸€ä¸ªåä¸»æ„ï¼Ÿè¦å…·ä½“è¯´æ˜ã€‚
- en: 22.1.1Â Using State to Remember Past Answers[ğŸ”—](#(part._.Using_.State_to_.Remember_.Past_.Answers)
    "Link to here")
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.1.1 ä½¿ç”¨çŠ¶æ€æ¥è®°ä½è¿‡å»çš„ç­”æ¡ˆ[ğŸ”—](#(part._.Using_.State_to_.Remember_.Past_.Answers) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Therefore, this is clearly a case where trading space for time is likely to
    be of help. How do we do this? We need a notion of memory that records all previous
    answers and, on subsequent attempts to compute them, checks whether they are already
    known and, if so, just returns them instead of recomputing them.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œè¿™æ˜¾ç„¶æ˜¯ä¸€ä¸ªé€šè¿‡ç‰ºç‰²ç©ºé—´æ¥æ¢å–æ—¶é—´å¯èƒ½æœ‰æ‰€å¸®åŠ©çš„æƒ…å†µã€‚æˆ‘ä»¬å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹ï¼Ÿæˆ‘ä»¬éœ€è¦ä¸€ä¸ªè®°å½•æ‰€æœ‰å…ˆå‰ç­”æ¡ˆçš„å†…å­˜æ¦‚å¿µï¼Œåœ¨éšåçš„å°è¯•è®¡ç®—å®ƒä»¬æ—¶ï¼Œæ£€æŸ¥å®ƒä»¬æ˜¯å¦å·²çŸ¥ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™ç›´æ¥è¿”å›å®ƒä»¬è€Œä¸æ˜¯é‡æ–°è®¡ç®—ã€‚
- en: Do Now!
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What critical assumption is this based on?
  id: totrans-276
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå®šä¹‰åŸºäºä»€ä¹ˆå…³é”®å‡è®¾ï¼Ÿ
- en: Naturally, this assumes that for a given input, the answer will always be the
    same. As we have seen, functions with state violate this liberally, so typical
    stateful functions cannot utilize this optimization. Ironically, we will use state
    to implement this optimization, so we will have a stateful function that always
    returns the same answer on a given inputâ€”<wbr>and thereby use state in a stateful
    function to simulate a stateless one. Groovy, dude!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: è‡ªç„¶åœ°ï¼Œè¿™å‡è®¾å¯¹äºç»™å®šçš„è¾“å…¥ï¼Œç­”æ¡ˆæ€»æ˜¯ç›¸åŒçš„ã€‚æ­£å¦‚æˆ‘ä»¬æ‰€çœ‹åˆ°çš„ï¼Œå…·æœ‰çŠ¶æ€çš„å‡½æ•°ä¼šè‡ªç”±åœ°è¿åè¿™ä¸€å‡è®¾ï¼Œå› æ­¤å…¸å‹çš„çŠ¶æ€å‡½æ•°æ— æ³•åˆ©ç”¨è¿™ç§ä¼˜åŒ–ã€‚è®½åˆºçš„æ˜¯ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨çŠ¶æ€æ¥å®ç°è¿™ç§ä¼˜åŒ–ï¼Œå› æ­¤æˆ‘ä»¬å°†æœ‰ä¸€ä¸ªåœ¨ç»™å®šè¾“å…¥ä¸Šæ€»æ˜¯è¿”å›ç›¸åŒç­”æ¡ˆçš„çŠ¶æ€å‡½æ•°â€”â€”å¹¶ä¸”å› æ­¤åœ¨ä¸€ä¸ªçŠ¶æ€å‡½æ•°ä¸­ä½¿ç”¨çŠ¶æ€æ¥æ¨¡æ‹Ÿä¸€ä¸ªæ— çŠ¶æ€å‡½æ•°ã€‚Groovyï¼Œä¼™è®¡ï¼
- en: 'First, then, we need some representation of memory. We can imagine several,
    but hereâ€™s a simple one:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€äº›å†…å­˜çš„è¡¨ç¤ºã€‚æˆ‘ä»¬å¯ä»¥æƒ³è±¡å‡ ä¸ªï¼Œä½†è¿™é‡Œæœ‰ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼š
- en: '[PRE33]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now how does `catalan` need to change? We have to first look for whether the
    value is already in `memory`; if it is, we return it without any further computation,
    but if it isnâ€™t, then we compute the result, store it in `memory`, and then return
    it:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨å¦‚ä½•ä¿®æ”¹ `catalan`ï¼Ÿæˆ‘ä»¬å¿…é¡»é¦–å…ˆæŸ¥æ‰¾å€¼æ˜¯å¦å·²ç»åœ¨ `memory` ä¸­ï¼›å¦‚æœæ˜¯ï¼Œæˆ‘ä»¬è¿”å›å®ƒè€Œæ— éœ€ä»»ä½•è¿›ä¸€æ­¥çš„è®¡ç®—ï¼Œä½†å¦‚æœæ²¡æœ‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬è®¡ç®—ç»“æœï¼Œå°†å…¶å­˜å‚¨åœ¨
    `memory` ä¸­ï¼Œç„¶åè¿”å›å®ƒï¼š
- en: '[PRE34]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And thatâ€™s it! Now running our previous tests will reveal that the answer computes
    much quicker, but in addition we can dare to run bigger computations such as `catalan(50)`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: å°±è¿™æ ·ï¼ç°åœ¨è¿è¡Œæˆ‘ä»¬ä¹‹å‰çš„æµ‹è¯•å°†æ­ç¤ºç­”æ¡ˆè®¡ç®—å¾—æ›´å¿«ï¼Œä½†é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥å°è¯•è¿è¡Œæ›´å¤§çš„è®¡ç®—ï¼Œä¾‹å¦‚`catalan(50)`ã€‚
- en: Do Now!
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Trace through a call of this revised function and see how many calls it makes.
  id: totrans-285
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è·Ÿè¸ªè¿™ä¸ªä¿®æ”¹åçš„å‡½æ•°çš„è°ƒç”¨è¿‡ç¨‹ï¼Œçœ‹çœ‹å®ƒè°ƒç”¨äº†å¤šå°‘æ¬¡ã€‚
- en: 'Here is a revised visualization of computing for input `3`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯é’ˆå¯¹è¾“å…¥`3`çš„ä¿®æ”¹åçš„è®¡ç®—å¯è§†åŒ–ï¼š
- en: '![](../Images/31c17fe6a16bbf3f25e501c178869546.png)'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../Images/31c17fe6a16bbf3f25e501c178869546.png)'
- en: 'Observe the asymmetric computation: the early calls perform the computations,
    while the latter calls simply look up the results.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿä¸å¯¹ç§°çš„è®¡ç®—ï¼šæ—©æœŸçš„è°ƒç”¨æ‰§è¡Œè®¡ç®—ï¼Œè€Œåç»­çš„è°ƒç”¨åªæ˜¯æŸ¥æ‰¾ç»“æœã€‚
- en: This process, of converting a function into a version that remembers its past
    answers, is called memoization.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè¿‡ç¨‹ï¼Œå³å°†å‡½æ•°è½¬æ¢ä¸ºè®°ä½å…¶è¿‡å»ç­”æ¡ˆçš„ç‰ˆæœ¬ï¼Œè¢«ç§°ä¸ºè®°å¿†åŒ–ã€‚
- en: 22.1.2Â From a Tree of Computation to a DAG[ğŸ”—](#(part._.From_a_.Tree_of_.Computation_to_a_.D.A.G)
    "Link to here")
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.1.2 ä»è®¡ç®—æ ‘åˆ°æœ‰å‘æ— ç¯å›¾[ğŸ”—](#(part._.From_a_.Tree_of_.Computation_to_a_.D.A.G) "é“¾æ¥è‡³æ­¤")
- en: What we have subtly done is to convert a tree of computation into a DAG over
    the same computation, with equivalent calls being reused. Whereas previously each
    call was generating lots of recursive calls, which induced still more recursive
    calls, now we are reusing previous recursive callsâ€”<wbr>i.e., sharing the results
    computed earlier. This, in effect, points the recursive call to one that had occurred
    earlier. Thus, the shape of computation converts from a tree to a DAG of calls.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¾®å¦™åœ°åšçš„æ˜¯å°†è®¡ç®—æ ‘è½¬æ¢ä¸ºåŒä¸€è®¡ç®—ä¸Šçš„æœ‰å‘æ— ç¯å›¾ï¼Œå…¶ä¸­ç­‰æ•ˆçš„è°ƒç”¨è¢«é‡ç”¨ã€‚ä»¥å‰æ¯æ¬¡è°ƒç”¨éƒ½ä¼šç”Ÿæˆå¤§é‡çš„é€’å½’è°ƒç”¨ï¼Œè¿™åˆå¼•å‘äº†æ›´å¤šçš„é€’å½’è°ƒç”¨ï¼Œè€Œç°åœ¨æˆ‘ä»¬æ­£åœ¨é‡ç”¨ä¹‹å‰çš„é€’å½’è°ƒç”¨â€”â€”å³ï¼Œå…±äº«ä¹‹å‰è®¡ç®—çš„ç»“æœã€‚è¿™å®é™…ä¸Šæ˜¯æŒ‡å‘ä¹‹å‰å‘ç”Ÿè¿‡çš„é€’å½’è°ƒç”¨ã€‚å› æ­¤ï¼Œè®¡ç®—çš„å½¢çŠ¶ä»æ ‘è½¬æ¢ä¸ºè°ƒç”¨æœ‰å‘æ— ç¯å›¾ã€‚
- en: This has an important complexity benefit. Whereas previously we were performing
    a super-exponential number of calls, now we perform only one call per input and
    share all previous callsâ€”<wbr>thereby reducing `catalan(n)` to take a number of
    fresh calls proportional to `n`. Looking up the result of a previous call takes
    time proportional to the size of `memory` (because weâ€™ve represented it as a list;
    better representations would improve on that), but that only contributes another
    linear multiplicative factor, reducing the overall complexity to quadratic in
    the size of the input. This is a dramatic reduction in overall complexity. In
    contrast, other uses of memoization may result in much less dramatic improvements,
    turning the use of this technique into a true engineering trade-off.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æœ‰ä¸€ä¸ªé‡è¦çš„å¤æ‚åº¦ä¼˜åŠ¿ã€‚ä»¥å‰æˆ‘ä»¬æ‰§è¡Œäº†è¶…çº§æŒ‡æ•°çº§çš„è°ƒç”¨æ¬¡æ•°ï¼Œè€Œç°åœ¨æˆ‘ä»¬åªå¯¹æ¯ä¸ªè¾“å…¥æ‰§è¡Œä¸€æ¬¡è°ƒç”¨ï¼Œå¹¶å…±äº«æ‰€æœ‰ä¹‹å‰çš„è°ƒç”¨â€”â€”å› æ­¤å°†`catalan(n)`çš„è°ƒç”¨æ¬¡æ•°å‡å°‘åˆ°ä¸`n`æˆæ¯”ä¾‹ã€‚æŸ¥æ‰¾ä¹‹å‰è°ƒç”¨çš„ç»“æœéœ€è¦ä¸`memory`çš„å¤§å°æˆæ¯”ä¾‹çš„æ—¶é—´ï¼ˆå› ä¸ºæˆ‘ä»¬å°†å…¶è¡¨ç¤ºä¸ºåˆ—è¡¨ï¼›æ›´å¥½çš„è¡¨ç¤ºä¼šæ”¹è¿›è¿™ä¸€ç‚¹ï¼‰ï¼Œä½†è¿™åªé¢å¤–è´¡çŒ®äº†ä¸€ä¸ªçº¿æ€§ä¹˜æ³•å› å­ï¼Œå°†æ•´ä½“å¤æ‚åº¦é™ä½åˆ°è¾“å…¥å¤§å°çš„äºŒæ¬¡æ–¹ã€‚è¿™æ˜¯æ•´ä½“å¤æ‚åº¦çš„æ˜¾è‘—é™ä½ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œå…¶ä»–è®°å¿†åŒ–çš„åº”ç”¨å¯èƒ½åªä¼šå¸¦æ¥ä¸é‚£ä¹ˆæ˜¾è‘—çš„æ”¹è¿›ï¼Œä½¿è¿™ç§æŠ€æœ¯çš„ä½¿ç”¨æˆä¸ºä¸€ä¸ªçœŸæ­£çš„å·¥ç¨‹æƒè¡¡ã€‚
- en: 22.1.3Â The Complexity of Numbers[ğŸ”—](#(part._numbers-not-constant) "Link to here")
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.1.3 æ•°å­—å¤æ‚åº¦[ğŸ”—](#(part._numbers-not-constant) "é“¾æ¥è‡³æ­¤")
- en: As we start to run larger computations, however, we may start to notice that
    our computations are starting to take longer than linear growth. This is because
    our numbers are growing arbitrarily largeâ€”<wbr>for instance, `catalan(100)` is
    `896519947090131496687170070074100632420837521538745909320`â€”<wbr>and computations
    on numbers can no longer be constant time, contrary to what we said earlier [[The
    Size of the Input](predicting-growth.html#%28part._size-of-input%29)]. Indeed,
    when working on cryptographic problems, the fact that operations on numbers do
    not take constant time are absolutely critical to fundamental complexity results
    (and, for instance, the presumed unbreakability of contemporary cryptography).
    (See also [Factoring Numbers](factoring-numbers.html).)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œå½“æˆ‘ä»¬å¼€å§‹è¿è¡Œæ›´å¤§çš„è®¡ç®—æ—¶ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå¼€å§‹æ³¨æ„åˆ°æˆ‘ä»¬çš„è®¡ç®—æ—¶é—´å¼€å§‹è¶…è¿‡çº¿æ€§å¢é•¿ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬çš„æ•°å­—å˜å¾—ä»»æ„å¤§â€”â€”ä¾‹å¦‚ï¼Œ`catalan(100)`æ˜¯`896519947090131496687170070074100632420837521538745909320`â€”â€”å¹¶ä¸”å¯¹æ•°å­—çš„è®¡ç®—ä¸å†èƒ½æ˜¯å¸¸æ•°æ—¶é—´ï¼Œè¿™ä¸æˆ‘ä»¬ä¹‹å‰æ‰€è¯´çš„ç›¸å
    [[è¾“å…¥å¤§å°](predicting-growth.html#%28part._size-of-input%29)]ã€‚å®é™…ä¸Šï¼Œåœ¨å¤„ç†å¯†ç å­¦é—®é¢˜æ—¶ï¼Œæ“ä½œæ•°å­—ä¸èŠ±è´¹å¸¸æ•°æ—¶é—´çš„äº‹å®å¯¹äºåŸºæœ¬å¤æ‚åº¦ç»“æœè‡³å…³é‡è¦ï¼ˆä¾‹å¦‚ï¼Œç°ä»£å¯†ç å­¦çš„å‡è®¾ä¸å¯ç ´è§£æ€§ï¼‰ã€‚ï¼ˆå‚è§[åˆ†è§£æ•°å­—](factoring-numbers.html)ã€‚ï¼‰
- en: 22.1.4Â Abstracting Memoization[ğŸ”—](#(part._.Abstracting_.Memoization) "Link to
    here")
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.1.4 æŠ½è±¡åŒ–è®°å¿†åŒ–[ğŸ”—](#(part._.Abstracting_.Memoization) "é“¾æ¥è‡³æ­¤")
- en: 'Now weâ€™ve achieved the desired complexity improvement, but there is still something
    unsatisfactory about the structure of our revised definition of `catalan`: the
    act of memoization is deeply intertwined with the definition of a Catalan number,
    even though these should be intellectually distinct. Letâ€™s do that next.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»å®ç°äº†æœŸæœ›çš„å¤æ‚åº¦æ”¹è¿›ï¼Œä½†æˆ‘ä»¬å¯¹`catalan`ä¿®è®¢å®šä¹‰çš„ç»“æ„ä»æœ‰ä¸€äº›ä¸æ»¡æ„çš„åœ°æ–¹ï¼šè®°å¿†åŒ–çš„è¡Œä¸ºä¸Catalanæ•°çš„å®šä¹‰ç´§å¯†ç›¸è¿ï¼Œå°½ç®¡å®ƒä»¬åœ¨æ™ºåŠ›ä¸Šåº”è¯¥æ˜¯ä¸åŒçš„ã€‚è®©æˆ‘ä»¬æ¥ä¸‹æ¥åšè¿™ä»¶äº‹ã€‚
- en: In effect, we want to separate our program into two parts. One part defines
    a general notion of memoization, while the other defines `catalan` in terms of
    this general notion.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼Œæˆ‘ä»¬æƒ³è¦å°†æˆ‘ä»¬çš„ç¨‹åºåˆ†æˆä¸¤éƒ¨åˆ†ã€‚ä¸€éƒ¨åˆ†å®šä¹‰ä¸€ä¸ªé€šç”¨çš„è®°å¿†åŒ–æ¦‚å¿µï¼Œè€Œå¦ä¸€éƒ¨åˆ†åˆ™ç”¨è¿™ä¸ªé€šç”¨æ¦‚å¿µæ¥å®šä¹‰`catalan`ã€‚
- en: 'What does the former mean? We want to encapsulate the idea of â€œmemoryâ€ (since
    we presumably donâ€™t want this stored in a variable that any old part of the program
    can modify). This should result in a function that takes the input we want to
    check; if it is found in the memory we return that answer, otherwise we compute
    the answer, store it, and return it. To compute the answer, we need a function
    that determines how to do so. Putting together these pieces:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: å‰è€…æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿæˆ‘ä»¬æƒ³è¦å°è£…â€œè®°å¿†â€çš„æ¦‚å¿µï¼ˆå› ä¸ºæˆ‘ä»¬å¯èƒ½ä¸å¸Œæœ›å®ƒå­˜å‚¨åœ¨å¯ä»¥è¢«ç¨‹åºä»»ä½•éƒ¨åˆ†ä¿®æ”¹çš„å˜é‡ä¸­ï¼‰ã€‚è¿™åº”è¯¥å¯¼è‡´ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥å—æˆ‘ä»¬æƒ³è¦æ£€æŸ¥çš„è¾“å…¥ï¼›å¦‚æœå®ƒåœ¨è®°å¿†ä¸­æ‰¾åˆ°ï¼Œæˆ‘ä»¬è¿”å›é‚£ä¸ªç­”æ¡ˆï¼Œå¦åˆ™æˆ‘ä»¬è®¡ç®—ç­”æ¡ˆï¼Œå­˜å‚¨å®ƒï¼Œå¹¶è¿”å›å®ƒã€‚ä¸ºäº†è®¡ç®—ç­”æ¡ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå‡½æ•°æ¥ç¡®å®šå¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹ã€‚å°†è¿™äº›éƒ¨åˆ†ç»„åˆèµ·æ¥ï¼š
- en: '[PRE35]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We use the name `memoize-1` to indicate that this is a memoizer for single-argument
    functions. Observe that the code above is virtually identical to what we had before,
    except where we had the logic of Catalan number computation, we now have the parameter
    `f` determining what to do.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä½¿ç”¨`memoize-1`è¿™ä¸ªåå­—æ¥è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªé’ˆå¯¹å•å‚æ•°å‡½æ•°çš„è®°å¿†åŒ–å™¨ã€‚è§‚å¯Ÿä¸Šé¢çš„ä»£ç ï¼Œå®ƒä¸ä¹‹å‰çš„ä»£ç å‡ ä¹ç›¸åŒï¼Œåªæ˜¯åœ¨ä¹‹å‰æœ‰Catalanæ•°è®¡ç®—çš„é€»è¾‘ï¼Œæˆ‘ä»¬ç°åœ¨æœ‰å‚æ•°`f`æ¥å†³å®šè¦åšä»€ä¹ˆã€‚
- en: 'With this, we can now define `catalan` as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å¦‚ä¸‹å®šä¹‰`catalan`ï¼š
- en: '[PRE36]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note several things about this definition:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„è¿™ä¸ªå®šä¹‰çš„å‡ ä¸ªæ–¹é¢ï¼š
- en: 'We donâ€™t write `fun catalan(...): ...;` because the procedure bound to `catalan`
    is produced by `memoize-1`.'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬ä¸å†™`fun catalan(...): ...;`ï¼Œå› ä¸ºç»‘å®šåˆ°`catalan`çš„è¿‡ç¨‹æ˜¯ç”±`memoize-1`äº§ç”Ÿçš„ã€‚'
- en: Note carefully that the recursive calls to `catalan` have to be to the function
    bound to the result of memoization, thereby behaving like an object. Failing to
    refer to this same shared procedure means the recursive calls will not be memoized,
    thereby losing the benefit of this process.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä»”ç»†æ³¨æ„ï¼Œå¯¹`catalan`çš„é€’å½’è°ƒç”¨å¿…é¡»æ˜¯å¯¹ç»‘å®šåˆ°è®°å¿†åŒ–ç»“æœçš„åŠŸèƒ½çš„è°ƒç”¨ï¼Œä»è€Œè¡¨ç°å¾—åƒä¸€ä¸ªå¯¹è±¡ã€‚æœªèƒ½å¼•ç”¨è¿™ä¸ªç›¸åŒçš„å…±äº«è¿‡ç¨‹æ„å‘³ç€é€’å½’è°ƒç”¨å°†ä¸ä¼šè¢«è®°å¿†åŒ–ï¼Œä»è€Œå¤±å»äº†è¿™ä¸ªè¿‡ç¨‹çš„å¥½å¤„ã€‚
- en: We need to use `rec` for reasons we saw earlier [[Streams From Functions](func-as-data.html#%28part._streams-from-funs%29)].
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦ä½¿ç”¨`rec`çš„åŸå› æ˜¯æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„ [[ä»å‡½æ•°ä¸­è·å–æµ](func-as-data.html#%28part._streams-from-funs%29)]ã€‚
- en: Each invocation of `memoize-1` creates a new table of stored results. Therefore
    the memoization of different functions will each get their own tables rather than
    sharing tables, which is a bad idea!
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ¯æ¬¡è°ƒç”¨`memoize-1`éƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å­˜å‚¨ç»“æœè¡¨ã€‚å› æ­¤ï¼Œä¸åŒå‡½æ•°çš„è®°å¿†åŒ–å°†å„è‡ªå¾—åˆ°å®ƒä»¬è‡ªå·±çš„è¡¨ï¼Œè€Œä¸æ˜¯å…±äº«è¡¨ï¼Œè¿™æ˜¯ä¸€ä¸ªåä¸»æ„ï¼
- en: Exercise
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is sharing memoization tables a bad idea? Be concrete.
  id: totrans-310
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆå…±äº«è®°å¿†åŒ–è¡¨æ˜¯ä¸€ä¸ªåä¸»æ„ï¼Ÿè¯·å…·ä½“è¯´æ˜ã€‚
- en: 22.2Â Edit-Distance for Spelling Correction[ğŸ”—](#(part._levenshtein) "Link to
    here")
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.2Â æ‹¼å†™çº æ­£çš„ç¼–è¾‘è·ç¦»[ğŸ”—](#(part._levenshtein) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Text editors, word processors, mobile phones, and various other devices now
    routinely implement spelling correction or offer suggestions on (mis-)spellings.
    How do they do this? Doing so requires two capabilities: computing the distance
    between words, and finding words that are nearby according to this metric. In
    this section we will study the first of these questions. (For the purposes of
    this discussion, we will not dwell on the exact definition of what a â€œwordâ€ is,
    and just deal with strings instead. A real system would need to focus on this
    definition in considerable detail.)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: æ–‡æœ¬ç¼–è¾‘å™¨ã€æ–‡å­—å¤„ç†å™¨ã€ç§»åŠ¨ç”µè¯å’Œå„ç§å…¶ä»–è®¾å¤‡ç°åœ¨é€šå¸¸å®ç°æ‹¼å†™æ£€æŸ¥æˆ–æä¾›ï¼ˆè¯¯ï¼‰æ‹¼å†™çš„å»ºè®®ã€‚ä»–ä»¬æ˜¯å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹çš„ï¼Ÿè¿™æ ·åšéœ€è¦ä¸¤ç§èƒ½åŠ›ï¼šè®¡ç®—å•è¯ä¹‹é—´çš„è·ç¦»ï¼Œä»¥åŠæ ¹æ®è¿™ä¸ªåº¦é‡æ‰¾åˆ°é™„è¿‘çš„å•è¯ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ç ”ç©¶è¿™äº›é—®é¢˜çš„ç¬¬ä¸€ä¸ªã€‚
    (ä¸ºäº†è®¨è®ºçš„ç›®çš„ï¼Œæˆ‘ä»¬ä¸ä¼šæ·±å…¥æ¢è®¨â€œå•è¯â€çš„ç¡®åˆ‡å®šä¹‰ï¼Œè€Œæ˜¯åªå¤„ç†å­—ç¬¦ä¸²ã€‚ä¸€ä¸ªçœŸæ­£çš„ç³»ç»Ÿéœ€è¦ç›¸å½“è¯¦ç»†åœ°å…³æ³¨è¿™ä¸ªå®šä¹‰ã€‚)
- en: Do Now!
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Think about how you might define the â€œdistance between two wordsâ€. Does it define
    a [metric space](http://en.wikipedia.org/wiki/Metric_space)?
  id: totrans-315
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ€è€ƒä¸€ä¸‹ä½ å¦‚ä½•å®šä¹‰â€œä¸¤ä¸ªå•è¯ä¹‹é—´çš„è·ç¦»â€ã€‚å®ƒå®šä¹‰äº†ä¸€ä¸ª[åº¦é‡ç©ºé—´](http://en.wikipedia.org/wiki/Metric_space)å—ï¼Ÿ
- en: Exercise
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Will the definition we give below define a metric space over the set of words?
  id: totrans-318
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç»™å‡ºçš„å®šä¹‰å°†å®šä¹‰å•è¯é›†ä¸Šçš„åº¦é‡ç©ºé—´å—ï¼Ÿ
- en: 'Though there may be several legitimate ways to define distances between words,
    here we care about the distance in the very specific context of spelling mistakes.
    Given the distance measure, one use might be to compute the distance of a given
    word from all the words in a dictionary, and offer the closest word (i.e., the
    one with the least distance) as a proposed correction.Obviously, we canâ€™t compute
    the distance to every word in a large dictionary on every single entered word.
    Making this process efficient constitutes the other half of this problem. Briefly,
    we need to quickly discard most words as unlikely to be close enough, for which
    a representation such as a [bag-of-words](http://en.wikipedia.org/wiki/Bag-of-words_model)
    (here, a bag of characters) can greatly help. Given such an intended use, we would
    like at least the following to hold:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶å¯èƒ½æœ‰å‡ ç§åˆæ³•çš„æ–¹å¼æ¥å®šä¹‰å•è¯ä¹‹é—´çš„è·ç¦»ï¼Œä½†åœ¨è¿™é‡Œæˆ‘ä»¬å…³æ³¨çš„æ˜¯æ‹¼å†™é”™è¯¯çš„å…·ä½“ä¸Šä¸‹æ–‡ä¸­çš„è·ç¦»ã€‚ç»™å®šè·ç¦»åº¦é‡ï¼Œä¸€ç§ç”¨é€”å¯èƒ½æ˜¯è®¡ç®—ç»™å®šå•è¯ä¸å­—å…¸ä¸­æ‰€æœ‰å•è¯çš„è·ç¦»ï¼Œå¹¶æä¾›æœ€æ¥è¿‘çš„å•è¯ï¼ˆå³è·ç¦»æœ€å°çš„å•è¯ï¼‰ä½œä¸ºå»ºè®®çš„çº æ­£ã€‚æ˜¾ç„¶ï¼Œæˆ‘ä»¬æ— æ³•åœ¨æ¯æ¬¡è¾“å…¥æ—¶è®¡ç®—å¤§å‹å­—å…¸ä¸­æ¯ä¸ªå•è¯çš„è·ç¦»ã€‚ä½¿æ­¤è¿‡ç¨‹é«˜æ•ˆæ„æˆäº†æ­¤é—®é¢˜çš„ä¸€åŠã€‚ç®€è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬éœ€è¦å¿«é€Ÿæ’é™¤å¤§å¤šæ•°ä¸å¤ªå¯èƒ½è¶³å¤Ÿæ¥è¿‘çš„å•è¯ï¼Œä¸ºæ­¤ï¼Œå¦‚[è¯è¢‹æ¨¡å‹](http://en.wikipedia.org/wiki/Bag-of-words_model)ï¼ˆåœ¨è¿™é‡Œæ˜¯ä¸€ä¸ªå­—ç¬¦è¢‹ï¼‰è¿™æ ·çš„è¡¨ç¤ºå¯ä»¥å¤§å¤§å¸®åŠ©ã€‚é‰´äºè¿™ç§é¢„æœŸç”¨é€”ï¼Œæˆ‘ä»¬å¸Œæœ›è‡³å°‘ä»¥ä¸‹æ¡ä»¶æˆç«‹ï¼š
- en: That the distance from a word to itself be zero.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»ä¸€ä¸ªå•è¯åˆ°å®ƒè‡ªèº«çš„è·ç¦»å¿…é¡»æ˜¯é›¶ã€‚
- en: That the distance from a word to any word other than itself be strictly positive.
    (Otherwise, given a word that is already in the dictionary, the â€œcorrectionâ€ might
    be a different dictionary word.)
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»ä¸€ä¸ªå•è¯åˆ°é™¤è‡ªèº«ä»¥å¤–çš„ä»»ä½•å•è¯çš„è·ç¦»å¿…é¡»æ˜¯ä¸¥æ ¼æ­£çš„ã€‚ï¼ˆå¦åˆ™ï¼Œç»™å®šä¸€ä¸ªå·²ç»åœ¨å­—å…¸ä¸­çš„å•è¯ï¼Œ"çº æ­£"å¯èƒ½æ˜¯ä¸€ä¸ªä¸åŒçš„å­—å…¸å•è¯ã€‚ï¼‰
- en: That the distance between two words be symmetric, i.e., it shouldnâ€™t matter
    in which order we pass arguments.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸¤ä¸ªå•è¯ä¹‹é—´çš„è·ç¦»æ˜¯å¯¹ç§°çš„ï¼Œå³ä¼ é€’å‚æ•°çš„é¡ºåºä¸åº”è¯¥å½±å“ç»“æœã€‚
- en: Exercise
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that we have not included the triangle inequality relative to the properties
    of a metric. Why not? If we donâ€™t need the triangle inequality, does this let
    us define more interesting distance functions that are not metrics?
  id: totrans-325
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬æ²¡æœ‰åŒ…æ‹¬ä¸åº¦é‡æ€§è´¨ç›¸å…³çš„ä¸‰è§’ä¸ç­‰å¼ã€‚ä¸ºä»€ä¹ˆï¼Ÿå¦‚æœæˆ‘ä»¬ä¸éœ€è¦ä¸‰è§’ä¸ç­‰å¼ï¼Œè¿™éš¾é“è®©æˆ‘ä»¬èƒ½å¤Ÿå®šä¹‰æ›´å¤šæœ‰è¶£çš„éåº¦é‡è·ç¦»å‡½æ•°å—ï¼Ÿ
- en: 'Given a pair of words, the assumption is that we meant to type one but actually
    typed the other. Here, too, there are several possible definitions, but a popular
    one considers that there are three ways to be fat-fingered:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€å¯¹å•è¯ï¼Œå‡è®¾æˆ‘ä»¬æœ¬æƒ³è¾“å…¥ä¸€ä¸ªå•è¯ï¼Œä½†å®é™…ä¸Šè¾“å…¥äº†å¦ä¸€ä¸ªã€‚åœ¨è¿™é‡Œï¼Œä¹Ÿæœ‰å‡ ç§å¯èƒ½çš„å®šä¹‰ï¼Œä½†æµè¡Œçš„ä¸€ç§è®¤ä¸ºæœ‰ä¸‰ç§æ–¹å¼ä¼šè¢«è¯¯æ‰“ï¼š
- en: we left out a character;
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ¼æ‰äº†ä¸€ä¸ªå­—ç¬¦ï¼›
- en: we typed a character twice; or,
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¾“å…¥äº†ä¸€ä¸ªå­—ç¬¦ä¸¤æ¬¡ï¼›æˆ–è€…ï¼Œ
- en: we typed one character when we meant another.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¾“å…¥äº†ä¸€ä¸ªå­—ç¬¦ï¼Œè€Œæœ¬æ„æ˜¯æƒ³è¾“å…¥å¦ä¸€ä¸ªã€‚
- en: In particular, we are interested in the fewest edits of these forms that need
    to be performed to get from one word to the other. For natural reasons, this notion
    of distance is called the edit distance or, in honor of its creator, the Levenshtein
    distance.See more on [Wikipedia](http://en.wikipedia.org/wiki/Levenshtein_distance).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: å°¤å…¶æ˜¯æˆ‘ä»¬å¯¹å®Œæˆä»ä¸€å•è¯åˆ°å¦ä¸€å•è¯æ‰€éœ€çš„æœ€å°‘ç¼–è¾‘å½¢å¼æ„Ÿå…´è¶£ã€‚ç”±äºè‡ªç„¶åŸå› ï¼Œè¿™ç§è·ç¦»çš„æ¦‚å¿µè¢«ç§°ä¸ºç¼–è¾‘è·ç¦»ï¼Œæˆ–è€…ä¸ºäº†çºªå¿µå…¶åˆ›é€ è€…ï¼Œç§°ä¸ºè±æ–‡æ–¯å¦è·ç¦»ã€‚æ›´å¤šå†…å®¹è¯·å‚é˜…[Wikipedia](http://en.wikipedia.org/wiki/Levenshtein_distance)ã€‚
- en: There are several variations of this definition possible. For now, we will consider
    the simplest one, which assumes that each of these errors has equal cost. For
    certain input devices, we may want to assign different costs to these mistakes;
    we might also assign different costs depending on what wrong character was typed
    (two characters adjacent on a keyboard are much more likely to be a legitimate
    error than two that are far apart). We will return briefly to some of these considerations
    later [[Nature as a Fat-Fingered Typist](#%28part._smith-waterman%29)].
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå®šä¹‰æœ‰å‡ ç§å¯èƒ½çš„å˜ä½“ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å°†è€ƒè™‘æœ€ç®€å•çš„ä¸€ç§ï¼Œå®ƒå‡è®¾è¿™äº›é”™è¯¯ä¸­çš„æ¯ä¸€ä¸ªéƒ½æœ‰ç›¸åŒçš„æˆæœ¬ã€‚å¯¹äºæŸäº›è¾“å…¥è®¾å¤‡ï¼Œæˆ‘ä»¬å¯èƒ½æƒ³è¦ä¸ºè¿™äº›é”™è¯¯åˆ†é…ä¸åŒçš„æˆæœ¬ï¼›æˆ‘ä»¬å¯èƒ½è¿˜ä¼šæ ¹æ®è¾“å…¥äº†å“ªä¸ªé”™è¯¯çš„å­—ç¬¦åˆ†é…ä¸åŒçš„æˆæœ¬ï¼ˆé”®ç›˜ä¸Šç›¸é‚»çš„ä¸¤ä¸ªå­—ç¬¦æ¯”ç›¸è·è¾ƒè¿œçš„ä¸¤ä¸ªå­—ç¬¦æ›´æœ‰å¯èƒ½æ˜¯åˆæ³•çš„é”™è¯¯ï¼‰ã€‚æˆ‘ä»¬å°†åœ¨ç¨åç®€è¦å›åˆ°è¿™äº›è€ƒè™‘[[è‡ªç„¶ä½œä¸ºè¯¯æ‰“æ‰“å­—å‘˜](#%28part._smith-waterman%29)]ã€‚
- en: 'Under this metric, the distance between â€œkittenâ€ and â€œsittingâ€ is 3 because
    we have to replace â€œkâ€ with â€œsâ€, replace â€œeâ€ with â€œiâ€, and insert â€œgâ€ (or symmetrically,
    perform the opposite replacements and delete â€œgâ€). Here are more examples:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªåº¦é‡ä¸‹ï¼Œâ€œkittenâ€å’Œâ€œsittingâ€ä¹‹é—´çš„è·ç¦»æ˜¯3ï¼Œå› ä¸ºæˆ‘ä»¬å¿…é¡»å°†â€œkâ€æ›¿æ¢ä¸ºâ€œsâ€ï¼Œå°†â€œeâ€æ›¿æ¢ä¸ºâ€œiâ€ï¼Œå¹¶æ’å…¥â€œgâ€ï¼ˆæˆ–è€…å¯¹ç§°åœ°ï¼Œæ‰§è¡Œç›¸åçš„æ›¿æ¢å¹¶åˆ é™¤â€œgâ€ï¼‰ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›æ›´å¤šç¤ºä¾‹ï¼š
- en: <levenshtein-tests> ::=
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-tests> ::=
- en: '[PRE37]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The basic algorithm is in fact very simple:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºæœ¬ç®—æ³•å®é™…ä¸Šéå¸¸ç®€å•ï¼š
- en: <levenshtein> ::=
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein> ::=
- en: '[PRE38]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'where, because there are two list inputs, there are four cases, of which two
    are symmetric:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ï¼Œç”±äºæœ‰ä¸¤ä¸ªåˆ—è¡¨è¾“å…¥ï¼Œå› æ­¤æœ‰å››ç§æƒ…å†µï¼Œå…¶ä¸­ä¸¤ç§æ˜¯å¯¹ç§°çš„ï¼š
- en: <levenshtein-body> ::=
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-body> ::=
- en: '[PRE39]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If both inputs are empty, the answer is simple:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä¸¤ä¸ªè¾“å…¥éƒ½ä¸ºç©ºï¼Œç­”æ¡ˆå¾ˆç®€å•ï¼š
- en: <levenshtein-both-empty> ::=
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-both-empty> ::=
- en: '[PRE40]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When one is empty, then the edit distance corresponds to the length of the
    other, which needs to inserted (or deleted) in its entirety (so we charge a cost
    of one per character):'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: å½“å…¶ä¸­ä¸€ä¸ªä¸ºç©ºæ—¶ï¼Œç¼–è¾‘è·ç¦»å¯¹åº”äºå¦ä¸€ä¸ªçš„é•¿åº¦ï¼Œéœ€è¦å®Œæ•´åœ°æ’å…¥ï¼ˆæˆ–åˆ é™¤ï¼‰å®ƒï¼ˆå› æ­¤æˆ‘ä»¬æŒ‰æ¯ä¸ªå­—ç¬¦è®¡è´¹ä¸€ä¸ªæˆæœ¬ï¼‰ï¼š
- en: <levenshtein-one-empty> ::=
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-one-empty> ::=
- en: '[PRE41]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If neither is empty, then each has a first character. If they are the same,
    then there is no edit cost associated with this character (which we reflect by
    recurring on the rest of the words without adding to the edit cost). If they are
    not the same, however, we consider each of the possible edits:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä¸¤è€…éƒ½ä¸ä¸ºç©ºï¼Œé‚£ä¹ˆæ¯ä¸ªéƒ½æœ‰ä¸€ä¸ªç¬¬ä¸€ä¸ªå­—ç¬¦ã€‚å¦‚æœå®ƒä»¬ç›¸åŒï¼Œé‚£ä¹ˆä¸è¿™ä¸ªå­—ç¬¦ç›¸å…³çš„ç¼–è¾‘æˆæœ¬ä¸ºé›¶ï¼ˆæˆ‘ä»¬é€šè¿‡é€’å½’å¤„ç†å‰©ä½™çš„å•è¯è€Œä¸å¢åŠ ç¼–è¾‘æˆæœ¬æ¥åæ˜ è¿™ä¸€ç‚¹ï¼‰ã€‚å¦‚æœå®ƒä»¬ä¸åŒï¼Œé‚£ä¹ˆæˆ‘ä»¬è€ƒè™‘æ¯ç§å¯èƒ½çš„ç¼–è¾‘ï¼š
- en: <levenshtein-neither-empty> ::=
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-neither-empty> ::=
- en: '[PRE42]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the first case, we assume `s` has one too many characters, so we compute
    the cost as if weâ€™re deleting it and finding the lowest cost for the rest of the
    strings (but charging one for this deletion); in the second case, we symmetrically
    assume `t` has one too many; and in the third case, we assume one character got
    replaced by another, so we charge one but consider the rest of both words (e.g.,
    assume â€œsâ€ was typed for â€œkâ€ and continue with â€œittenâ€ and â€œittingâ€). This uses
    the following helper function:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç¬¬ä¸€ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å‡è®¾`s`æœ‰å¤šä¸€ä¸ªå­—ç¬¦ï¼Œæ‰€ä»¥æˆ‘ä»¬è®¡ç®—æˆæœ¬ï¼Œå°±åƒæˆ‘ä»¬åœ¨åˆ é™¤å®ƒå¹¶æ‰¾åˆ°å‰©ä½™å­—ç¬¦ä¸²çš„æœ€ä½æˆæœ¬ä¸€æ ·ï¼ˆä½†ä¸ºæ­¤åˆ é™¤è®¡è´¹ä¸€ä¸ªæˆæœ¬ï¼‰ï¼›åœ¨ç¬¬äºŒç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯¹ç§°åœ°å‡è®¾`t`æœ‰å¤šä¸€ä¸ªå­—ç¬¦ï¼›åœ¨ç¬¬ä¸‰ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å‡è®¾ä¸€ä¸ªå­—ç¬¦è¢«å¦ä¸€ä¸ªå­—ç¬¦æ›¿æ¢ï¼Œæ‰€ä»¥æˆ‘ä»¬è®¡è´¹ä¸€ä¸ªæˆæœ¬ï¼Œä½†è€ƒè™‘ä¸¤ä¸ªå•è¯çš„å…¶ä½™éƒ¨åˆ†ï¼ˆä¾‹å¦‚ï¼Œå‡è®¾â€œsâ€è¢«è¯¯è¾“å…¥ä¸ºâ€œkâ€ï¼Œç„¶åç»§ç»­ä½¿ç”¨â€œittenâ€å’Œâ€œittingâ€ï¼‰ã€‚è¿™ä½¿ç”¨äº†ä»¥ä¸‹è¾…åŠ©å‡½æ•°ï¼š
- en: '[PRE43]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This algorithm will indeed pass all the tests we have written above, but with
    a problem: the running time grows exponentially. That is because, each time we
    find a mismatch, we recur on three subproblems. In principle, therefore, the algorithm
    takes time proportional to three to the power of the length of the shorter word.
    In practice, any prefix that matches causes no branching, so it is mismatches
    that incur branching (thus, confirming that the distance of a word with itself
    is zero only takes time linear in the size of the word).'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç®—æ³•ç¡®å®ä¼šé€šè¿‡æˆ‘ä»¬ä¸Šé¢ç¼–å†™çš„æ‰€æœ‰æµ‹è¯•ï¼Œä½†æœ‰ä¸€ä¸ªé—®é¢˜ï¼šè¿è¡Œæ—¶é—´å‘ˆæŒ‡æ•°å¢é•¿ã€‚è¿™æ˜¯å› ä¸ºï¼Œæ¯æ¬¡æˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ªä¸åŒ¹é…ï¼Œæˆ‘ä»¬éƒ½ä¼šåœ¨ä¸‰ä¸ªå­é—®é¢˜ä¸Šé€’å½’ã€‚å› æ­¤ï¼Œä»åŸåˆ™ä¸Šè®²ï¼Œç®—æ³•çš„æ—¶é—´ä¸è¾ƒçŸ­å•è¯é•¿åº¦çš„ä¸‰æ¬¡æ–¹æˆæ­£æ¯”ã€‚åœ¨å®è·µä¸­ï¼Œä»»ä½•åŒ¹é…çš„è¯å‰ç¼€éƒ½ä¸ä¼šå¯¼è‡´åˆ†æ”¯ï¼Œå› æ­¤æ˜¯åŒ¹é…å¯¼è‡´åˆ†æ”¯ï¼ˆå› æ­¤ï¼Œç¡®è®¤ä¸€ä¸ªå•è¯ä¸è‡ªèº«çš„è·ç¦»ä¸ºé›¶åªéœ€ä¸å•è¯å¤§å°æˆçº¿æ€§æ—¶é—´ï¼‰ã€‚
- en: Observe, however, that many of these subproblems are the same. For instance,
    given â€œkittenâ€ and â€œsittingâ€, the mismatch on the initial character will cause
    the algorithm to compute the distance of â€œittenâ€ from â€œittingâ€ but also â€œittenâ€
    from â€œsittingâ€ and â€œkittenâ€ from â€œittingâ€. Those latter two distance computations
    will also involve matching â€œittenâ€ against â€œittingâ€. Thus, again, we want the
    computation tree to turn into a DAG of expressions that are actually evaluated.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè§‚å¯Ÿè¿™äº›å­é—®é¢˜ä¸­çš„è®¸å¤šæ˜¯ç›¸åŒçš„ã€‚ä¾‹å¦‚ï¼Œç»™å®šâ€œkittenâ€å’Œâ€œsittingâ€ï¼Œåˆå§‹å­—ç¬¦çš„ä¸åŒ¹é…å°†å¯¼è‡´ç®—æ³•è®¡ç®—â€œittenâ€ä¸â€œittingâ€çš„è·ç¦»ï¼Œä½†ä¹Ÿä¼šè®¡ç®—â€œittenâ€ä¸â€œsittingâ€å’Œâ€œkittenâ€ä¸â€œittingâ€çš„è·ç¦»ã€‚åä¸¤ä¸ªè·ç¦»è®¡ç®—ä¹Ÿå°†æ¶‰åŠå°†â€œittenâ€ä¸â€œittingâ€åŒ¹é…ã€‚å› æ­¤ï¼Œå†æ¬¡ï¼Œæˆ‘ä»¬å¸Œæœ›è®¡ç®—æ ‘å˜æˆä¸€ä¸ªå®é™…è¯„ä¼°çš„è¡¨è¾¾å¼çš„DAGï¼ˆæœ‰å‘æ— ç¯å›¾ï¼‰ã€‚
- en: 'The solution, therefore, is naturally to memoize. First, we need a memoizer
    that works over two arguments rather than one:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œè§£å†³æ–¹æ¡ˆè‡ªç„¶æ˜¯è®°å¿†åŒ–ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥å¤„ç†ä¸¤ä¸ªå‚æ•°è€Œä¸æ˜¯ä¸€ä¸ªå‚æ•°çš„è®°å¿†åŒ–å™¨ï¼š
- en: '[PRE44]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Most of the code is unchanged, except that we store two arguments rather than
    one, and correspondingly look up both.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ä»£ç çš„å¤§éƒ¨åˆ†å†…å®¹æ²¡æœ‰å˜åŒ–ï¼Œé™¤äº†æˆ‘ä»¬ç°åœ¨å­˜å‚¨ä¸¤ä¸ªå‚æ•°è€Œä¸æ˜¯ä¸€ä¸ªï¼Œå¹¶ä¸”ç›¸åº”åœ°æŸ¥æ‰¾ä¸¤ä¸ªå‚æ•°ã€‚
- en: 'With this, we can redefine `levenshtein` to use memoization:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥é‡æ–°å®šä¹‰`levenshtein`ä»¥ä½¿ç”¨è®°å¿†åŒ–ï¼š
- en: <levenshtein-memo> ::=
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-memo> ::=
- en: '[PRE45]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: where the argument to `memoize-2` is precisely what we saw earlier as [<levenshtein-body>](#%28elem._levenshtein-body%29)
    (and now you know why we defined `levenshtein` slightly oddly, not using `fun`).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­`memoize-2`çš„å‚æ•°æ­£æ˜¯æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„[<levenshtein-body>](#%28elem._levenshtein-body%29)ï¼ˆç°åœ¨ä½ çŸ¥é“ä¸ºä»€ä¹ˆæˆ‘ä»¬å®šä¹‰`levenshtein`æœ‰äº›å¥‡æ€ªï¼Œæ²¡æœ‰ä½¿ç”¨`fun`ï¼‰ã€‚
- en: 'The complexity of this algorithm is still non-trivial. First, letâ€™s introduce
    the term suffix: the suffix of a string is the rest of the string starting from
    any point in the string. (Thus â€œkittenâ€, â€œittenâ€, â€œtenâ€, â€œnâ€, and â€œâ€ are all suffixes
    of â€œkittenâ€.) Now, observe that in the worst case, starting with every suffix
    in the first word, we may need to perform a comparison against every suffix in
    the second word. Fortunately, for each of these suffixes we perform a constant
    computation relative to the recursion. Therefore, the overall time complexity
    of computing the distance between strings of length \(m\) and \(n\) is \(O([m,
    n \rightarrow m \cdot n])\). (We will return to space consumption later [[Contrasting
    Memoization and Dynamic Programming](#%28part._memo-vs-dp%29)].)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: è¯¥ç®—æ³•çš„å¤æ‚åº¦ä»ç„¶æ˜¯éå¹³å‡¡çš„ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬å¼•å…¥æœ¯è¯­åç¼€ï¼šä¸€ä¸ªå­—ç¬¦ä¸²çš„åç¼€æ˜¯ä»å­—ç¬¦ä¸²ä¸­çš„ä»»ä½•ä¸€ç‚¹å¼€å§‹åˆ°å­—ç¬¦ä¸²æœ«å°¾çš„éƒ¨åˆ†ã€‚ï¼ˆå› æ­¤ï¼Œâ€œkittenâ€ï¼Œâ€œittenâ€ï¼Œâ€œtenâ€ï¼Œâ€œnâ€å’Œâ€œâ€éƒ½æ˜¯â€œkittenâ€çš„åç¼€ã€‚ï¼‰ç°åœ¨ï¼Œè§‚å¯Ÿåœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œä»ç¬¬ä¸€ä¸ªå•è¯çš„æ¯ä¸ªåç¼€å¼€å§‹ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦ä¸ç¬¬äºŒä¸ªå•è¯çš„æ¯ä¸ªåç¼€è¿›è¡Œæ¯”è¾ƒã€‚å¹¸è¿çš„æ˜¯ï¼Œå¯¹äºè¿™äº›åç¼€ä¸­çš„æ¯ä¸€ä¸ªï¼Œæˆ‘ä»¬æ‰§è¡Œçš„è®¡ç®—ç›¸å¯¹äºé€’å½’æ˜¯å¸¸æ•°çº§çš„ã€‚å› æ­¤ï¼Œè®¡ç®—é•¿åº¦ä¸º
    \(m\) å’Œ \(n\) çš„å­—ç¬¦ä¸²ä¹‹é—´è·ç¦»çš„æ•´ä½“æ—¶é—´å¤æ‚åº¦æ˜¯ \(O([m, n \rightarrow m \cdot n])\)ã€‚ï¼ˆæˆ‘ä»¬ç¨åä¼šå›åˆ°ç©ºé—´æ¶ˆè€—é—®é¢˜
    [[å¯¹æ¯”è®°å¿†åŒ–å’ŒåŠ¨æ€è§„åˆ’](#(part._memo-vs-dp%29)]).ï¼‰
- en: Exercise
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify the above algorithm to produce an actual (optimal) sequence of edit operations.
    This is sometimes known as the traceback.
  id: totrans-364
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¿®æ”¹ä¸Šè¿°ç®—æ³•ä»¥ç”Ÿæˆå®é™…çš„ï¼ˆæœ€ä¼˜ï¼‰ç¼–è¾‘æ“ä½œåºåˆ—ã€‚è¿™æœ‰æ—¶è¢«ç§°ä¸ºå›æº¯ã€‚
- en: 22.3Â Nature as a Fat-Fingered Typist[ğŸ”—](#(part._smith-waterman) "Link to here")
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.3 è‡ªç„¶ç•Œçš„â€œå¤§æ‹‡æŒ‡æ‰“å­—å‘˜â€[ğŸ”—](#(part._smith-waterman) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'We have talked about how to address mistakes made by humans. However, humans
    are not the only bad typists: nature is one, too!'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»è®¨è®ºäº†å¦‚ä½•è§£å†³äººç±»çŠ¯çš„é”™è¯¯ã€‚ç„¶è€Œï¼Œäººç±»å¹¶ä¸æ˜¯å”¯ä¸€æ‰“å­—é”™è¯¯çš„ï¼šè‡ªç„¶ç•Œä¹Ÿæ˜¯ï¼
- en: 'When studying living matter we obtain sequences of amino acids and other such
    chemicals that comprise molecules, such as DNA, that hold important and potentially
    determinative information about the organism. These sequences consist of similar
    fragments that we wish to identify because they represent relationships in the
    organismâ€™s behavior or evolution.This section may need to be skipped in [some
    states and countries](http://en.wikipedia.org/wiki/Creation_and_evolution_in_public_education).
    Unfortunately, these sequences are never identical: like all low-level programmers,
    nature slips up and sometimes makes mistakes in copying (calledâ€”<wbr>wait for
    itâ€”<wbr>mutations). Therefore, looking for strict equality would rule out too
    many sequences that are almost certainly equivalent. Instead, we must perform
    an alignment step to find these equivalent sequences. As you might have guessed,
    this process is very much a process of computing an edit distance, and using some
    threshold to determine whether the edit is small enough.To be precise, we are
    performing local [sequence alignment](http://en.wikipedia.org/wiki/Sequence_alignment).
    This algorithm is named, after its creators, Smith-Waterman, and because it is
    essentially identical, has the same complexity as the Levenshtein algorithm.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç ”ç©¶ç”Ÿç‰©ç‰©è´¨æ—¶ï¼Œæˆ‘ä»¬è·å¾—ç”±æ°¨åŸºé…¸å’Œå…¶ä»–ç±»ä¼¼åŒ–å­¦ç‰©è´¨ç»„æˆçš„åºåˆ—ï¼Œè¿™äº›åŒ–å­¦ç‰©è´¨æ„æˆäº†åˆ†å­ï¼Œå¦‚DNAï¼Œå®ƒä»¬åŒ…å«æœ‰å…³ç”Ÿç‰©ä½“çš„é‡è¦å’Œå¯èƒ½å†³å®šæ€§çš„ä¿¡æ¯ã€‚è¿™äº›åºåˆ—ç”±æˆ‘ä»¬å¸Œæœ›è¯†åˆ«çš„ç›¸ä¼¼ç‰‡æ®µç»„æˆï¼Œå› ä¸ºå®ƒä»¬ä»£è¡¨äº†ç”Ÿç‰©ä½“è¡Œä¸ºæˆ–è¿›åŒ–çš„å…³ç³»ã€‚æœ¬èŠ‚åœ¨æŸäº›å·å’Œå›½å®¶å¯èƒ½éœ€è¦è·³è¿‡
    [[å…¬å…±æ•™è‚²ä¸­çš„åˆ›é€ ä¸è¿›åŒ–](http://en.wikipedia.org/wiki/Creation_and_evolution_in_public_education)].
    ä¸å¹¸çš„æ˜¯ï¼Œè¿™äº›åºåˆ—æ°¸è¿œä¸ä¼šå®Œå…¨ç›¸åŒï¼šå°±åƒæ‰€æœ‰ä½çº§ç¨‹åºå‘˜ä¸€æ ·ï¼Œè‡ªç„¶ç•Œä¹Ÿä¼šå‡ºé”™ï¼Œæœ‰æ—¶åœ¨å¤åˆ¶æ—¶ï¼ˆç§°ä¸ºâ€”â€”<wbr>ç­‰ä¸€ä¸‹â€”â€”<wbr>çªå˜ï¼‰çŠ¯é”™è¯¯ã€‚å› æ­¤ï¼Œå¯»æ‰¾ä¸¥æ ¼çš„ç›¸ç­‰æ€§ä¼šæ’é™¤å¤ªå¤šå‡ ä¹è‚¯å®šç­‰æ•ˆçš„åºåˆ—ã€‚ç›¸åï¼Œæˆ‘ä»¬å¿…é¡»æ‰§è¡Œä¸€ä¸ªå¯¹é½æ­¥éª¤æ¥æ‰¾åˆ°è¿™äº›ç­‰æ•ˆåºåˆ—ã€‚æ­£å¦‚ä½ å¯èƒ½å·²ç»çŒœåˆ°çš„ï¼Œè¿™ä¸ªè¿‡ç¨‹éå¸¸ç±»ä¼¼äºè®¡ç®—ç¼–è¾‘è·ç¦»ï¼Œå¹¶ä½¿ç”¨æŸä¸ªé˜ˆå€¼æ¥ç¡®å®šç¼–è¾‘æ˜¯å¦è¶³å¤Ÿå°ã€‚ä¸ºäº†ç²¾ç¡®èµ·è§ï¼Œæˆ‘ä»¬æ­£åœ¨æ‰§è¡Œå±€éƒ¨
    [åºåˆ—å¯¹é½](http://en.wikipedia.org/wiki/Sequence_alignment)ã€‚è¿™ä¸ªç®—æ³•ä»¥å…¶åˆ›é€ è€…çš„åå­—å‘½åä¸ºSmith-Watermanï¼Œå› ä¸ºå®ƒæœ¬è´¨ä¸Šç›¸åŒï¼Œå…·æœ‰ä¸Levenshteinç®—æ³•ç›¸åŒçš„å¤æ‚åº¦ã€‚
- en: 'The only difference between traditional presentations of Levenshtein and Smith-Waterman
    is something we alluded to earlier: why is every edit given a distance of one?
    Instead, in the Smith-Waterman presentation, we assume that we have a function
    that gives us the gap score, i.e., the value to assign every characterâ€™s alignment,
    i.e., scores for both matches and edits, with scores driven by biological considerations.
    Of course, as we have already noted, this need is not peculiar to biology; we
    could just as well use a â€œgap scoreâ€ to reflect the likelihood of a substitution
    based on keyboard characteristics.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Levenshteinå’ŒSmith-Watermançš„ä¼ ç»Ÿè¡¨è¿°ä¹‹é—´çš„å”¯ä¸€åŒºåˆ«æ˜¯æˆ‘ä»¬ä¹‹å‰æåˆ°çš„ï¼šä¸ºä»€ä¹ˆæ¯ä¸ªç¼–è¾‘éƒ½èµ‹äºˆä¸€ä¸ªè·ç¦»ä¸º1ï¼Ÿç›¸åï¼Œåœ¨Smith-Watermançš„è¡¨è¿°ä¸­ï¼Œæˆ‘ä»¬å‡è®¾æœ‰ä¸€ä¸ªå‡½æ•°å¯ä»¥ç»™æˆ‘ä»¬æä¾›é—´éš™åˆ†æ•°ï¼Œå³åˆ†é…ç»™æ¯ä¸ªå­—ç¬¦å¯¹é½çš„å€¼ï¼Œå³åŒ¹é…å’Œç¼–è¾‘çš„åˆ†æ•°ï¼Œåˆ†æ•°ç”±ç”Ÿç‰©å­¦è€ƒè™‘é©±åŠ¨ã€‚å½“ç„¶ï¼Œæ­£å¦‚æˆ‘ä»¬ä¹‹å‰å·²ç»æŒ‡å‡ºçš„ï¼Œè¿™ç§éœ€æ±‚å¹¶ä¸ç‰¹æŒ‡ç”Ÿç‰©å­¦ï¼›æˆ‘ä»¬åŒæ ·å¯ä»¥ä½¿ç”¨â€œé—´éš™åˆ†æ•°â€æ¥åæ˜ åŸºäºé”®ç›˜ç‰¹æ€§çš„æ›¿æ¢å¯èƒ½æ€§ã€‚
- en: 22.4Â Dynamic Programming[ğŸ”—](#(part._.Dynamic_.Programming) "Link to here")
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.4 åŠ¨æ€è§„åˆ’[ğŸ”—](#(part._.Dynamic_.Programming) "é“¾æ¥è‡³æ­¤")
- en: We have used memoization as our canonical means of saving the values of past
    computations to reuse later. There is another popular technique for doing this
    called dynamic programming. This technique is closely related to memoization;
    indeed, it can be viewed as the dual method for achieving the same end. First
    we will see dynamic programming at work, then discuss how it differs from memoization.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»ä½¿ç”¨è®°å¿†åŒ–ä½œä¸ºä¿å­˜è¿‡å»è®¡ç®—å€¼çš„è§„èŒƒæ‰‹æ®µï¼Œä»¥ä¾¿ç¨åé‡ç”¨ã€‚è¿˜æœ‰ä¸€ç§ç§°ä¸ºåŠ¨æ€è§„åˆ’çš„æµè¡ŒæŠ€æœ¯æ¥åšè¿™ä»¶äº‹ã€‚è¿™ç§æŠ€æœ¯ä¸è®°å¿†åŒ–å¯†åˆ‡ç›¸å…³ï¼›å®é™…ä¸Šï¼Œå®ƒå¯ä»¥è¢«è§†ä¸ºè¾¾åˆ°ç›¸åŒç›®çš„çš„äº’è¡¥æ–¹æ³•ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å°†çœ‹åˆ°åŠ¨æ€ç¼–ç¨‹æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œç„¶åè®¨è®ºå®ƒä¸è®°å¿†åŒ–çš„åŒºåˆ«ã€‚
- en: Dynamic programming also proceeds by building up a memory of answers, and looking
    them up instead of recomputing them. As such, it too is a process for turning
    a computationâ€™s shape from a tree to a DAG of actual calls. The key difference
    is that instead of starting with the largest computation and recurring to smaller
    ones, it starts with the smallest computations and builds outward to larger ones.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: åŠ¨æ€ç¼–ç¨‹ä¹Ÿæ˜¯é€šè¿‡æ„å»ºç­”æ¡ˆçš„è®°å¿†æ¥è¿›è¡Œçš„ï¼Œå¹¶æŸ¥æ‰¾å®ƒä»¬è€Œä¸æ˜¯é‡æ–°è®¡ç®—ã€‚å› æ­¤ï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ªå°†è®¡ç®—å½¢çŠ¶ä»æ ‘è½¬æ¢ä¸ºå®é™…è°ƒç”¨æœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰çš„è¿‡ç¨‹ã€‚å…³é”®åŒºåˆ«åœ¨äºï¼Œå®ƒä¸æ˜¯ä»æœ€å¤§çš„è®¡ç®—å¼€å§‹ï¼Œç„¶åé€’å½’åˆ°è¾ƒå°çš„è®¡ç®—ï¼Œè€Œæ˜¯ä»æœ€å°çš„è®¡ç®—å¼€å§‹ï¼Œå‘å¤–æ‰©å±•åˆ°è¾ƒå¤§çš„è®¡ç®—ã€‚
- en: We will revisit our previous examples in light of this approach.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†æ ¹æ®è¿™ç§æ–¹æ³•é‡æ–°å®¡è§†æˆ‘ä»¬ä¹‹å‰çš„ä¾‹å­ã€‚
- en: 22.4.1Â Catalan Numbers with Dynamic Programming[ğŸ”—](#(part._.Catalan_.Numbers_with_.Dynamic_.Programming)
    "Link to here")
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.4.1 ä½¿ç”¨åŠ¨æ€è§„åˆ’è®¡ç®—å¡å¡”å…°æ•°[ğŸ”—](#(part._.Catalan_.Numbers_with_.Dynamic_.Programming)
    "é“¾æ¥è‡³æ­¤")
- en: To begin with, we need to define a data structure to hold answers. Following
    convention, we will use an array.What happens when we run out of space? We can
    use the doubling technique we studied for [Halloween Analysis](amortized-analysis.html).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€ä¸ªæ•°æ®ç»“æ„æ¥å­˜å‚¨ç­”æ¡ˆã€‚æŒ‰ç…§æƒ¯ä¾‹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨æ•°ç»„ã€‚å½“ç©ºé—´ç”¨å°½æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æˆ‘ä»¬ä¸º[ä¸‡åœ£èŠ‚åˆ†æ](amortized-analysis.html)å­¦ä¹ è¿‡çš„åŠ å€æŠ€æœ¯ã€‚
- en: '[PRE46]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, the `catalan` function simply looks up the answer in this array:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œ`catalan`å‡½æ•°åªéœ€åœ¨è¿™ä¸ªæ•°ç»„ä¸­æŸ¥æ‰¾ç­”æ¡ˆï¼š
- en: '[PRE47]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'But how do we fill the array? We initialize the one known value, and use the
    formula to compute the rest in incremental order. Because we have multiple things
    to do in the body, we use `block`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æˆ‘ä»¬å¦‚ä½•å¡«å……è¿™ä¸ªæ•°ç»„å‘¢ï¼Ÿæˆ‘ä»¬åˆå§‹åŒ–ä¸€ä¸ªå·²çŸ¥å€¼ï¼Œå¹¶ä½¿ç”¨å…¬å¼æŒ‰å¢é‡é¡ºåºè®¡ç®—å…¶ä½™éƒ¨åˆ†ã€‚å› ä¸ºæˆ‘ä»¬åœ¨ä¸»ä½“ä¸­è¦åšå¤šä»¶äº‹ï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨`block`ï¼š
- en: '[PRE48]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The resulting program obeys the tests in [<catalan-tests>](#%28elem._catalan-tests%29).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ç”Ÿæˆçš„ç¨‹åºéµå¾ª[<catalan-tests>](#%28elem._catalan-tests%29)ä¸­çš„æµ‹è¯•ã€‚
- en: Notice that we have had to undo the natural recursive definitionâ€”<wbr>which
    proceeds from bigger values to smaller onesâ€”<wbr>to instead use a loop that goes
    from smaller values to larger ones. In principle, the program has the danger that
    when we apply `catalan` to some value, that index of `answers` will have not yet
    been initialized, resultingin an error. In fact, however, we know that because
    we fill all smaller indices in `answers` before computing the next larger one,
    we will never actually encounter this error. Note that this requires careful reasoning
    about our program, which we did not need to perform when using memoization because
    there we made precisely the recursive call we needed, which either looked up the
    value or computed it afresh.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬ä¸å¾—ä¸æ’¤é”€è‡ªç„¶çš„é€’å½’å®šä¹‰â€”â€”<wbr>å®ƒä»è¾ƒå¤§çš„å€¼å¼€å§‹é€’å½’åˆ°è¾ƒå°çš„å€¼â€”â€”<wbr>è€Œæ˜¯ä½¿ç”¨ä¸€ä¸ªä»è¾ƒå°çš„å€¼é€’å½’åˆ°è¾ƒå¤§çš„å€¼çš„å¾ªç¯ã€‚åŸåˆ™ä¸Šï¼Œç¨‹åºæœ‰å±é™©ï¼Œå½“æˆ‘ä»¬åº”ç”¨`catalan`åˆ°æŸä¸ªå€¼æ—¶ï¼Œ`answers`ä¸­é‚£ä¸ªç´¢å¼•å¯èƒ½è¿˜æ²¡æœ‰è¢«åˆå§‹åŒ–ï¼Œä»è€Œå¯¼è‡´é”™è¯¯ã€‚ç„¶è€Œï¼Œå®é™…ä¸Šï¼Œæˆ‘ä»¬çŸ¥é“å› ä¸ºæˆ‘ä»¬å…ˆå¡«å……`answers`ä¸­æ‰€æœ‰è¾ƒå°çš„ç´¢å¼•ï¼Œç„¶åå†è®¡ç®—ä¸‹ä¸€ä¸ªè¾ƒå¤§çš„ç´¢å¼•ï¼Œæ‰€ä»¥æˆ‘ä»¬å®é™…ä¸Šæ°¸è¿œä¸ä¼šé‡åˆ°è¿™ä¸ªé”™è¯¯ã€‚æ³¨æ„ï¼Œè¿™éœ€è¦æˆ‘ä»¬ä»”ç»†æ¨ç†æˆ‘ä»¬çš„ç¨‹åºï¼Œå½“æˆ‘ä»¬ä½¿ç”¨è®°å¿†åŒ–æ—¶ï¼Œæˆ‘ä»¬ä¸éœ€è¦è¿™æ ·åšï¼Œå› ä¸ºåœ¨é‚£é‡Œæˆ‘ä»¬åšäº†ç²¾ç¡®çš„é€’å½’è°ƒç”¨ï¼Œè¦ä¹ˆæŸ¥æ‰¾å€¼ï¼Œè¦ä¹ˆé‡æ–°è®¡ç®—ã€‚
- en: 22.4.2Â Levenshtein Distance and Dynamic Programming[ğŸ”—](#(part._.Levenshtein_.Distance_and_.Dynamic_.Programming)
    "Link to here")
  id: totrans-382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.4.2Â Levenshteinè·ç¦»ä¸åŠ¨æ€è§„åˆ’[ğŸ”—](#(part._.Levenshtein_.Distance_and_.Dynamic_.Programming)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Now letâ€™s take on rewriting the Levenshtein distance computation:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬ç€æ‰‹é‡å†™Levenshteinè·ç¦»çš„è®¡ç®—ï¼š
- en: <levenshtein-dp> ::=
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp> ::=
- en: '[PRE49]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We will use a table representing the edit distance for each prefix of each word.
    That is, we will have a two-dimensional table with as many rows as the length
    of `s1` and as many columns as the length of `s2`. At each position, we will record
    the edit distance for the prefixes of `s1` and `s2` up to the indices represented
    by that position in the table.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªè¡¨æ¥è¡¨ç¤ºæ¯ä¸ªå•è¯æ¯ä¸ªå‰ç¼€çš„ç¼–è¾‘è·ç¦»ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å°†æœ‰ä¸€ä¸ªäºŒç»´è¡¨ï¼Œè¡Œæ•°ä¸`s1`çš„é•¿åº¦ç›¸åŒï¼Œåˆ—æ•°ä¸`s2`çš„é•¿åº¦ç›¸åŒã€‚åœ¨æ¯ä¸€ä¸ªä½ç½®ï¼Œæˆ‘ä»¬å°†è®°å½•`s1`å’Œ`s2`çš„å‰ç¼€çš„ç¼–è¾‘è·ç¦»ï¼Œè¿™äº›è·ç¦»ç”±è¡¨ä¸­è¯¥ä½ç½®æ‰€è¡¨ç¤ºçš„ç´¢å¼•ã€‚
- en: 'Note that index arithmetic will be a constant burden: if a word is of length
    \(n\), we have to record the edit distance to its \(n + 1\) positions, the extra
    one corresponding to the empty word. This will hold for both words:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œç´¢å¼•è¿ç®—å°†æ˜¯ä¸€ä¸ªæ’å®šçš„è´Ÿæ‹…ï¼šå¦‚æœä¸€ä¸ªå•è¯çš„é•¿åº¦ä¸º\(n\)ï¼Œæˆ‘ä»¬å¿…é¡»è®°å½•å…¶åˆ°\(n + 1\)ä¸ªä½ç½®çš„ç¼–è¾‘è·ç¦»ï¼Œé¢å¤–çš„é‚£ä¸ªå¯¹åº”äºç©ºå•è¯ã€‚è¿™å¯¹ä¸¤ä¸ªå•è¯éƒ½é€‚ç”¨ï¼š
- en: <levenshtein-dp/1> ::=
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/1> ::=
- en: '[PRE50]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Observe that by creating `answers` inside `levenshtein`, we can determine the
    exact size it needs to be based on the inputs, rather than having to over-allocate
    or dynamically grow the array.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿåˆ°é€šè¿‡åœ¨`levenshtein`å†…éƒ¨åˆ›å»º`answers`ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®è¾“å…¥ç¡®å®šå®ƒç¡®åˆ‡éœ€è¦çš„å¤§å°ï¼Œè€Œä¸æ˜¯å¿…é¡»è¿‡åº¦åˆ†é…æˆ–åŠ¨æ€å¢é•¿æ•°ç»„ã€‚
- en: Exercise
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define the functions
  id: totrans-393
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®šä¹‰å‡½æ•°
- en: ''
  id: totrans-394
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-395
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We have initialized the table with `none`, so we will get an error if we accidentally
    try to use an uninitialized entry.Which proved to be necessary when writing and
    debugging this code! It will therefore be convenient to create helper functions
    that let us pretend the table contains only numbers:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»ç”¨`none`åˆå§‹åŒ–äº†è¡¨ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬ä¸å°å¿ƒå°è¯•ä½¿ç”¨æœªåˆå§‹åŒ–çš„æ¡ç›®ï¼Œå°†ä¼šå¾—åˆ°ä¸€ä¸ªé”™è¯¯ã€‚è¿™åœ¨ç¼–å†™å’Œè°ƒè¯•æ­¤ä»£ç æ—¶è¢«è¯æ˜æ˜¯å¿…è¦çš„ï¼å› æ­¤ï¼Œåˆ›å»ºè¾…åŠ©å‡½æ•°æ¥è®©æˆ‘ä»¬å‡è£…è¡¨åªåŒ…å«æ•°å­—å°†ä¼šå¾ˆæ–¹ä¾¿ï¼š
- en: <levenshtein-dp/2> ::=
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/2> ::=
- en: '[PRE52]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now we have to populate the array. First, we initialize the row representing
    the edit distances when `s2` is empty, and the column where `s1` is empty. At
    \((0, 0)\), the edit distance is zero; at every position thereafter, it is the
    distance of that position from zero, because that many characters must be added
    to one or deleted from the other word for the two to coincide:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¿…é¡»å¡«å……æ•°ç»„ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬åˆå§‹åŒ–è¡¨ç¤ºå½“`s2`ä¸ºç©ºæ—¶çš„ç¼–è¾‘è·ç¦»çš„è¡Œï¼Œä»¥åŠ`s1`ä¸ºç©ºæ—¶çš„åˆ—ã€‚åœ¨\((0, 0)\)ï¼Œç¼–è¾‘è·ç¦»ä¸ºé›¶ï¼›åœ¨æ­¤ä¹‹åæ¯ä¸ªä½ç½®ï¼Œå®ƒéƒ½æ˜¯è¯¥ä½ç½®ä¸é›¶çš„è·ç¦»ï¼Œå› ä¸ºå¿…é¡»å‘å…¶ä¸­ä¸€ä¸ªå•è¯æ·»åŠ é‚£ä¹ˆå¤šå­—ç¬¦æˆ–ä»å¦ä¸€ä¸ªå•è¯ä¸­åˆ é™¤é‚£ä¹ˆå¤šå­—ç¬¦ï¼Œä»¥ä¾¿ä¸¤ä¸ªå•è¯ç›¸åŒ¹é…ï¼š
- en: <levenshtein-dp/3> ::=
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/3> ::=
- en: '[PRE53]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now we finally get to the heart of the computation. We need to iterate over
    every character in each word. these characters are at indices `0` to `s1-len -
    1` and `s2-len - 1`, which are precisely the ranges of values produced by `range(0,
    s1-len)` and `range(0, s2-len)`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬ç»ˆäºåˆ°è¾¾äº†è®¡ç®—çš„ç²¾é«“ã€‚æˆ‘ä»¬éœ€è¦éå†æ¯ä¸ªå•è¯ä¸­çš„æ¯ä¸ªå­—ç¬¦ã€‚è¿™äº›å­—ç¬¦ä½äºç´¢å¼•`0`åˆ°`s1-len - 1`å’Œ`s2-len - 1`ä¹‹é—´ï¼Œè¿™æ­£æ˜¯`range(0,
    s1-len)`å’Œ`range(0, s2-len)`äº§ç”Ÿçš„å€¼çš„èŒƒå›´ã€‚
- en: <levenshtein-dp/4> ::=
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/4> ::=
- en: '[PRE54]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that weâ€™re building our way â€œoutâ€ from small cases to large ones, rather
    than starting with the large input and working our way â€œdownâ€, recursively, to
    small ones.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬æ­£åœ¨ä»å°æ¡ˆä¾‹â€œå‘å¤–â€æ„å»ºåˆ°å¤§å‹æ¡ˆä¾‹ï¼Œè€Œä¸æ˜¯ä»å¤§å‹è¾“å…¥å¼€å§‹ï¼Œç„¶åé€’å½’åœ°â€œå‘ä¸‹â€å·¥ä½œåˆ°å°æ¡ˆä¾‹ã€‚
- en: Do Now!
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is this strictly true?
  id: totrans-408
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å¦ä¸¥æ ¼æ­£ç¡®ï¼Ÿ
- en: No, it isnâ€™t. We did first fill in values for the â€œbordersâ€ of the table. This
    is because doing so in the midst of [<levenshtein-dp/compute-dist>](#%28elem._levenshtein-dp%2Fcompute-dist%29)
    would be much more annoying. By initializing all the known values, we keep the
    core computation cleaner. But it does mean the order in which we fill in the table
    is fairly complex.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ï¼Œè¿™ä¸æ˜¯ã€‚æˆ‘ä»¬é¦–å…ˆå¡«å†™äº†è¡¨æ ¼çš„â€œè¾¹ç•Œâ€å€¼ã€‚è¿™æ˜¯å› ä¸ºåœ¨ä¸­é€”è¿›è¡Œ [<levenshtein-dp/compute-dist>](#(elem._levenshtein-dp%2Fcompute-dist))
    ä¼šéå¸¸éº»çƒ¦ã€‚é€šè¿‡åˆå§‹åŒ–æ‰€æœ‰å·²çŸ¥å€¼ï¼Œæˆ‘ä»¬ä¿æŒäº†æ ¸å¿ƒè®¡ç®—çš„ç®€æ´æ€§ã€‚ä½†è¿™ç¡®å®æ„å‘³ç€æˆ‘ä»¬å¡«å†™è¡¨æ ¼çš„é¡ºåºç›¸å½“å¤æ‚ã€‚
- en: 'Now, letâ€™s return to computing the distance. For each pair of positions, we
    want the edit distance between the pair of words up to and including those positions.
    This distance is given by checking whether the characters at the pair of positions
    are identical. If they are, then the distance is the same as it was for the previous
    pair of prefixes; otherwise we have to try the three different kinds of edits:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬å›åˆ°è®¡ç®—è·ç¦»çš„é—®é¢˜ã€‚å¯¹äºæ¯ä¸€å¯¹ä½ç½®ï¼Œæˆ‘ä»¬æƒ³è¦è®¡ç®—è¿™ä¸¤ä¸ªä½ç½®ä¹‹é—´çš„å•è¯å¯¹çš„ç¼–è¾‘è·ç¦»ï¼ŒåŒ…æ‹¬è¿™äº›ä½ç½®ã€‚è¿™ä¸ªè·ç¦»æ˜¯é€šè¿‡æ£€æŸ¥è¿™å¯¹ä½ç½®ä¸Šçš„å­—ç¬¦æ˜¯å¦ç›¸åŒæ¥ç»™å‡ºçš„ã€‚å¦‚æœå®ƒä»¬ç›¸åŒï¼Œé‚£ä¹ˆè·ç¦»ä¸ä¹‹å‰çš„å‰ç¼€å¯¹ç›¸åŒï¼›å¦åˆ™ï¼Œæˆ‘ä»¬å¿…é¡»å°è¯•ä¸‰ç§ä¸åŒçš„ç¼–è¾‘æ–¹å¼ï¼š
- en: <levenshtein-dp/compute-dist> ::=
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/compute-dist> ::=
- en: '[PRE55]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As an aside, this sort of â€œoff-by-oneâ€ coordinate arithmetic is traditional
    when using tabular representations, because we write code in terms of elements
    that are not inherently present, and therefore have to create a padded table to
    hold values for the boundary conditions. The alternative would be to allow the
    table to begin its addressing from `-1` so that the main computation looks traditional.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæ—æ³¨ï¼Œè¿™ç§â€œåç§»ä¸€ä½â€çš„åæ ‡ç®—æœ¯åœ¨è¡¨æ ¼è¡¨ç¤ºæ³•ä¸­æ˜¯ä¼ ç»Ÿçš„ï¼Œå› ä¸ºæˆ‘ä»¬ç”¨ä¸å›ºæœ‰çš„å…ƒç´ æ¥ç¼–å†™ä»£ç ï¼Œå› æ­¤å¿…é¡»åˆ›å»ºä¸€ä¸ªå¡«å……çš„è¡¨æ ¼æ¥ä¿å­˜è¾¹ç•Œæ¡ä»¶çš„å€¼ã€‚å¦ä¸€ç§é€‰æ‹©æ˜¯å…è®¸è¡¨æ ¼ä»
    `-1` å¼€å§‹å¯»å€ï¼Œè¿™æ ·ä¸»è¦è®¡ç®—çœ‹èµ·æ¥æ›´ä¼ ç»Ÿã€‚
- en: 'At any rate, when this computation is done, the entire table has been filled
    with values. We still have to read out the answer, with lies at the end of the
    table:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: æ— è®ºå¦‚ä½•ï¼Œå½“è¿™ä¸ªè®¡ç®—å®Œæˆæ—¶ï¼Œæ•´ä¸ªè¡¨æ ¼å·²ç»å¡«æ»¡äº†å€¼ã€‚æˆ‘ä»¬ä»ç„¶éœ€è¦è¯»å–è¡¨æ ¼æœ«å°¾çš„ç­”æ¡ˆï¼š
- en: <levenshtein-dp/get-result> ::=
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/get-result> ::=
- en: '[PRE56]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Even putting aside the helper functions we wrote to satiate our paranoia about
    using undefined values, we end up with:As of this writing, the [current version](http://en.wikipedia.org/w/index.php?title=Levenshtein_distance&oldid=581406185#Iterative_with_full_matrix)
    of the [Wikipedia page](http://en.wikipedia.org/wiki/Levenshtein_distance) on
    the Levenshtein distance features a dynamic programming version that is very similar
    to the code above. By writing in pseudocode, it avoids address arithmetic issues
    (observe how the words are indexed starting from 1 instead of 0, which enables
    the body of the code to look more â€œnormalâ€), and by initializing all elements
    to zero it permits subtle bugs because an uninitialized table element is indistinguishable
    from a legitimate entry with edit distance of zero. The page also shows the [recursive](http://en.wikipedia.org/w/index.php?title=Levenshtein_distance&oldid=581406185#Recursive)
    solution and alludes to memoization, but does not show it in code.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: å³ä½¿ä¸è€ƒè™‘æˆ‘ä»¬ç¼–å†™çš„è¾…åŠ©å‡½æ•°æ¥æ»¡è¶³æˆ‘ä»¬å¯¹ä½¿ç”¨æœªå®šä¹‰å€¼çš„æ‹…å¿§ï¼Œæˆ‘ä»¬æœ€ç»ˆå¾—åˆ°ï¼šæˆªè‡³æœ¬æ–‡å†™ä½œæ—¶ï¼Œ[Wikipedia é¡µé¢](http://en.wikipedia.org/w/index.php?title=Levenshtein_distance&oldid=581406185#Iterative_with_full_matrix)ä¸Šçš„
    Levenshtein è·ç¦»çš„å½“å‰ç‰ˆæœ¬ä¸ä¸Šé¢çš„ä»£ç éå¸¸ç›¸ä¼¼ã€‚é€šè¿‡ç¼–å†™ä¼ªä»£ç ï¼Œå®ƒé¿å…äº†åœ°å€ç®—æœ¯é—®é¢˜ï¼ˆè§‚å¯Ÿå•è¯æ˜¯å¦‚ä½•ä» 1 è€Œä¸æ˜¯ 0 å¼€å§‹ç´¢å¼•çš„ï¼Œè¿™ä½¿å¾—ä»£ç çš„ä¸»ä½“çœ‹èµ·æ¥æ›´â€œæ­£å¸¸â€ï¼‰ï¼Œå¹¶ä¸”é€šè¿‡å°†æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºé›¶ï¼Œå®ƒå…è®¸å‡ºç°å¾®å¦™çš„é”™è¯¯ï¼Œå› ä¸ºæœªåˆå§‹åŒ–çš„è¡¨æ ¼å…ƒç´ ä¸ç¼–è¾‘è·ç¦»ä¸ºé›¶çš„æœ‰æ•ˆæ¡ç›®æ— æ³•åŒºåˆ†ã€‚è¯¥é¡µé¢è¿˜å±•ç¤ºäº†[é€’å½’](http://en.wikipedia.org/w/index.php?title=Levenshtein_distance&oldid=581406185#Recursive)è§£å†³æ–¹æ¡ˆå¹¶æåˆ°äº†è®°å¿†åŒ–ï¼Œä½†å¹¶æœªåœ¨ä»£ç ä¸­å±•ç¤ºã€‚
- en: '[PRE57]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: which is worth contrasting with the memoized version ([<levenshtein-memo>](#%28elem._levenshtein-memo%29)).For
    more examples of canonical dynamic programming problems, see [this page](http://people.csail.mit.edu/bdean/6.046/dp/)
    and think about how each can be expressed as a direct recursion.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸è®°å¿†åŒ–çš„ç‰ˆæœ¬([<levenshtein-memo>](#(elem._levenshtein-memo)))å½¢æˆé²œæ˜å¯¹æ¯”ã€‚æ›´å¤šå…³äºç»å…¸åŠ¨æ€è§„åˆ’é—®é¢˜çš„ä¾‹å­ï¼Œè¯·å‚é˜…[è¿™ä¸ªé¡µé¢](http://people.csail.mit.edu/bdean/6.046/dp/)ï¼Œå¹¶æ€è€ƒæ¯ä¸ªé—®é¢˜å¦‚ä½•ç›´æ¥é€’å½’åœ°è¡¨è¾¾ã€‚
- en: 22.4.1Â Catalan Numbers with Dynamic Programming[ğŸ”—](#(part._.Catalan_.Numbers_with_.Dynamic_.Programming)
    "Link to here")
  id: totrans-420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.4.1 ä½¿ç”¨åŠ¨æ€è§„åˆ’è®¡ç®— Catalan æ•°[ğŸ”—](#(part._.Catalan_.Numbers_with_.Dynamic_.Programming)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: To begin with, we need to define a data structure to hold answers. Following
    convention, we will use an array.What happens when we run out of space? We can
    use the doubling technique we studied for [Halloween Analysis](amortized-analysis.html).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€ä¸ªæ•°æ®ç»“æ„æ¥å­˜å‚¨ç­”æ¡ˆã€‚æŒ‰ç…§æƒ¯ä¾‹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨æ•°ç»„ã€‚å½“æˆ‘ä»¬ç”¨å®Œç©ºé—´æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æˆ‘ä»¬ä¸º [ä¸‡åœ£èŠ‚åˆ†æ](amortized-analysis.html)
    ç ”ç©¶çš„åŠ å€æŠ€æœ¯ã€‚
- en: '[PRE58]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, the `catalan` function simply looks up the answer in this array:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œ`catalan` å‡½æ•°åªéœ€åœ¨æ•°ç»„ä¸­æŸ¥æ‰¾ç­”æ¡ˆï¼š
- en: '[PRE59]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'But how do we fill the array? We initialize the one known value, and use the
    formula to compute the rest in incremental order. Because we have multiple things
    to do in the body, we use `block`:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æˆ‘ä»¬å¦‚ä½•å¡«å……è¿™ä¸ªæ•°ç»„ï¼Ÿæˆ‘ä»¬åˆå§‹åŒ–ä¸€ä¸ªå·²çŸ¥å€¼ï¼Œå¹¶ä½¿ç”¨å…¬å¼æŒ‰å¢é‡é¡ºåºè®¡ç®—å…¶ä½™å€¼ã€‚å› ä¸ºæˆ‘ä»¬åœ¨ä¸»ä½“ä¸­è¦åšå¾ˆå¤šäº‹æƒ…ï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨ `block`ï¼š
- en: '[PRE60]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The resulting program obeys the tests in [<catalan-tests>](#%28elem._catalan-tests%29).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: ç”Ÿæˆçš„ç¨‹åºéµå¾ª [<catalan-tests>](#%28elem._catalan-tests%29) ä¸­çš„æµ‹è¯•ã€‚
- en: Notice that we have had to undo the natural recursive definitionâ€”<wbr>which
    proceeds from bigger values to smaller onesâ€”<wbr>to instead use a loop that goes
    from smaller values to larger ones. In principle, the program has the danger that
    when we apply `catalan` to some value, that index of `answers` will have not yet
    been initialized, resultingin an error. In fact, however, we know that because
    we fill all smaller indices in `answers` before computing the next larger one,
    we will never actually encounter this error. Note that this requires careful reasoning
    about our program, which we did not need to perform when using memoization because
    there we made precisely the recursive call we needed, which either looked up the
    value or computed it afresh.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬ä¸å¾—ä¸æ’¤é”€è‡ªç„¶çš„é€’å½’å®šä¹‰â€”â€”<wbr>å®ƒä»è¾ƒå¤§çš„å€¼å¼€å§‹åˆ°è¾ƒå°çš„å€¼â€”â€”<wbr>è€Œæ˜¯ä½¿ç”¨ä¸€ä¸ªä»è¾ƒå°çš„å€¼åˆ°è¾ƒå¤§çš„å€¼çš„å¾ªç¯ã€‚åŸåˆ™ä¸Šï¼Œç¨‹åºæœ‰å±é™©ï¼Œå½“æˆ‘ä»¬å¯¹æŸä¸ªå€¼åº”ç”¨
    `catalan` æ—¶ï¼Œ`answers` ä¸­çš„é‚£ä¸ªç´¢å¼•å¯èƒ½å°šæœªåˆå§‹åŒ–ï¼Œä»è€Œå¯¼è‡´é”™è¯¯ã€‚ç„¶è€Œï¼Œå®é™…ä¸Šï¼Œæˆ‘ä»¬çŸ¥é“å› ä¸ºæˆ‘ä»¬å¡«å……äº† `answers` ä¸­æ‰€æœ‰è¾ƒå°çš„ç´¢å¼•ï¼Œåœ¨è®¡ç®—ä¸‹ä¸€ä¸ªè¾ƒå¤§çš„ä¸€ä¸ªä¹‹å‰ï¼Œæˆ‘ä»¬å®é™…ä¸Šæ°¸è¿œä¸ä¼šé‡åˆ°è¿™ä¸ªé”™è¯¯ã€‚æ³¨æ„ï¼Œè¿™éœ€è¦å¯¹æˆ‘ä»¬ç¨‹åºè¿›è¡Œä»”ç»†çš„æ¨ç†ï¼Œå½“æˆ‘ä»¬ä½¿ç”¨è®°å¿†åŒ–æ—¶ï¼Œæˆ‘ä»¬ä¸éœ€è¦æ‰§è¡Œè¿™ç§æ¨ç†ï¼Œå› ä¸ºåœ¨é‚£é‡Œæˆ‘ä»¬åšäº†ç²¾ç¡®çš„é€’å½’è°ƒç”¨ï¼Œè¦ä¹ˆæŸ¥æ‰¾å€¼ï¼Œè¦ä¹ˆé‡æ–°è®¡ç®—ã€‚
- en: 22.4.2Â Levenshtein Distance and Dynamic Programming[ğŸ”—](#(part._.Levenshtein_.Distance_and_.Dynamic_.Programming)
    "Link to here")
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 22.4.2Â Levenshtein è·ç¦»ä¸åŠ¨æ€è§„åˆ’[ğŸ”—](#(part._.Levenshtein_.Distance_and_.Dynamic_.Programming)
    "é“¾æ¥è‡³æ­¤")
- en: 'Now letâ€™s take on rewriting the Levenshtein distance computation:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬ç€æ‰‹é‡å†™ Levenshtein è·ç¦»è®¡ç®—ï¼š
- en: <levenshtein-dp> ::=
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp> ::=
- en: '[PRE61]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We will use a table representing the edit distance for each prefix of each word.
    That is, we will have a two-dimensional table with as many rows as the length
    of `s1` and as many columns as the length of `s2`. At each position, we will record
    the edit distance for the prefixes of `s1` and `s2` up to the indices represented
    by that position in the table.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªè¡¨ç¤ºæ¯ä¸ªå•è¯æ¯ä¸ªå‰ç¼€çš„ç¼–è¾‘è·ç¦»çš„è¡¨æ ¼ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å°†æœ‰ä¸€ä¸ªäºŒç»´è¡¨æ ¼ï¼Œè¡Œæ•°ä¸ `s1` çš„é•¿åº¦ç›¸åŒï¼Œåˆ—æ•°ä¸ `s2` çš„é•¿åº¦ç›¸åŒã€‚åœ¨æ¯ä¸€ä¸ªä½ç½®ï¼Œæˆ‘ä»¬å°†è®°å½•
    `s1` å’Œ `s2` çš„å‰ç¼€ç›´åˆ°ç”±è¡¨æ ¼ä¸­è¯¥ä½ç½®è¡¨ç¤ºçš„ç´¢å¼•çš„ç¼–è¾‘è·ç¦»ã€‚
- en: 'Note that index arithmetic will be a constant burden: if a word is of length
    \(n\), we have to record the edit distance to its \(n + 1\) positions, the extra
    one corresponding to the empty word. This will hold for both words:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œç´¢å¼•ç®—æœ¯å°†æ˜¯ä¸€ä¸ªæŒç»­çš„è´Ÿæ‹…ï¼šå¦‚æœä¸€ä¸ªå•è¯çš„é•¿åº¦ä¸º \(n\)ï¼Œæˆ‘ä»¬å¿…é¡»è®°å½•å®ƒä¸ \(n + 1\) ä¸ªä½ç½®çš„ç¼–è¾‘è·ç¦»ï¼Œå…¶ä¸­é¢å¤–çš„ä¸€ä¸ªå¯¹åº”äºç©ºå•è¯ã€‚è¿™é€‚ç”¨äºä¸¤ä¸ªå•è¯ï¼š
- en: <levenshtein-dp/1> ::=
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/1> ::=
- en: '[PRE62]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Observe that by creating `answers` inside `levenshtein`, we can determine the
    exact size it needs to be based on the inputs, rather than having to over-allocate
    or dynamically grow the array.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œé€šè¿‡åœ¨ `levenshtein` ä¸­åˆ›å»º `answers`ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®è¾“å…¥ç¡®å®šå…¶ç¡®åˆ‡å¤§å°ï¼Œè€Œæ— éœ€è¿‡åº¦åˆ†é…æˆ–åŠ¨æ€å¢é•¿æ•°ç»„ã€‚
- en: Exercise
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define the functions
  id: totrans-440
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®šä¹‰å‡½æ•°
- en: ''
  id: totrans-441
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-442
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We have initialized the table with `none`, so we will get an error if we accidentally
    try to use an uninitialized entry.Which proved to be necessary when writing and
    debugging this code! It will therefore be convenient to create helper functions
    that let us pretend the table contains only numbers:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»ç”¨ `none` åˆå§‹åŒ–äº†è¡¨æ ¼ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬ä¸å°å¿ƒå°è¯•ä½¿ç”¨æœªåˆå§‹åŒ–çš„æ¡ç›®ï¼Œå°†ä¼šå¾—åˆ°é”™è¯¯ã€‚è¿™åœ¨ç¼–å†™å’Œè°ƒè¯•æ­¤ä»£ç æ—¶è¢«è¯æ˜æ˜¯å¿…è¦çš„ï¼å› æ­¤ï¼Œåˆ›å»ºè¾…åŠ©å‡½æ•°æ¥è®©æˆ‘ä»¬å‡è£…è¡¨æ ¼åªåŒ…å«æ•°å­—å°†ä¼šå¾ˆæ–¹ä¾¿ï¼š
- en: <levenshtein-dp/2> ::=
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/2> ::=
- en: '[PRE64]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now we have to populate the array. First, we initialize the row representing
    the edit distances when `s2` is empty, and the column where `s1` is empty. At
    \((0, 0)\), the edit distance is zero; at every position thereafter, it is the
    distance of that position from zero, because that many characters must be added
    to one or deleted from the other word for the two to coincide:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¿…é¡»å¡«å……æ•°ç»„ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬åˆå§‹åŒ–è¡¨ç¤ºå½“ `s2` ä¸ºç©ºæ—¶çš„ç¼–è¾‘è·ç¦»çš„è¡Œï¼Œä»¥åŠ `s1` ä¸ºç©ºæ—¶çš„åˆ—ã€‚åœ¨ \((0, 0)\)ï¼Œç¼–è¾‘è·ç¦»æ˜¯é›¶ï¼›åœ¨æ­¤ä¹‹åæ¯ä¸ªä½ç½®ï¼Œå®ƒå°±æ˜¯è¯¥ä½ç½®ä¸é›¶çš„è·ç¦»ï¼Œå› ä¸ºå¿…é¡»å‘ä¸€ä¸ªå•è¯æ·»åŠ è¿™ä¹ˆå¤šå­—ç¬¦æˆ–ä»å¦ä¸€ä¸ªå•è¯ä¸­åˆ é™¤è¿™ä¹ˆå¤šå­—ç¬¦ï¼Œä»¥ä¾¿ä¸¤ä¸ªå•è¯èƒ½å¤ŸåŒ¹é…ï¼š
- en: <levenshtein-dp/3> ::=
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/3> ::=
- en: '[PRE65]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now we finally get to the heart of the computation. We need to iterate over
    every character in each word. these characters are at indices `0` to `s1-len -
    1` and `s2-len - 1`, which are precisely the ranges of values produced by `range(0,
    s1-len)` and `range(0, s2-len)`.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬ç»ˆäºåˆ°è¾¾äº†è®¡ç®—çš„ç²¾é«“ã€‚æˆ‘ä»¬éœ€è¦éå†æ¯ä¸ªå•è¯ä¸­çš„æ¯ä¸ªå­—ç¬¦ã€‚è¿™äº›å­—ç¬¦çš„ç´¢å¼•æ˜¯ `0` åˆ° `s1-len - 1` å’Œ `s2-len - 1`ï¼Œè¿™æ­£æ˜¯ç”±
    `range(0, s1-len)` å’Œ `range(0, s2-len)` ç”Ÿæˆçš„å€¼çš„èŒƒå›´ã€‚
- en: <levenshtein-dp/4> ::=
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/4> ::=
- en: '[PRE66]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note that weâ€™re building our way â€œoutâ€ from small cases to large ones, rather
    than starting with the large input and working our way â€œdownâ€, recursively, to
    small ones.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬æ˜¯ä»å°æ¡ˆä¾‹â€œå‘å¤–â€æ„å»ºåˆ°å¤§å‹æ¡ˆä¾‹ï¼Œè€Œä¸æ˜¯ä»å¤§è¾“å…¥å¼€å§‹ï¼Œé€’å½’åœ°â€œå‘ä¸‹â€å·¥ä½œåˆ°å°æ¡ˆä¾‹ã€‚
- en: Do Now!
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is this strictly true?
  id: totrans-455
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸¥æ ¼æ­£ç¡®å—ï¼Ÿ
- en: No, it isnâ€™t. We did first fill in values for the â€œbordersâ€ of the table. This
    is because doing so in the midst of [<levenshtein-dp/compute-dist>](#%28elem._levenshtein-dp%2Fcompute-dist%29)
    would be much more annoying. By initializing all the known values, we keep the
    core computation cleaner. But it does mean the order in which we fill in the table
    is fairly complex.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ï¼Œå¹¶ä¸æ­£ç¡®ã€‚æˆ‘ä»¬é¦–å…ˆå¡«å……äº†è¡¨æ ¼çš„â€œè¾¹ç•Œâ€å€¼ã€‚è¿™æ˜¯å› ä¸ºå¦‚æœåœ¨ `[levenshtein-dp/compute-dist](#%28elem._levenshtein-dp%2Fcompute-dist%29)`
    ä¸­è¿™æ ·åšä¼šéå¸¸éº»çƒ¦ã€‚é€šè¿‡åˆå§‹åŒ–æ‰€æœ‰å·²çŸ¥å€¼ï¼Œæˆ‘ä»¬ä½¿æ ¸å¿ƒè®¡ç®—æ›´åŠ æ¸…æ™°ã€‚ä½†è¿™ç¡®å®æ„å‘³ç€æˆ‘ä»¬å¡«å……è¡¨æ ¼çš„é¡ºåºç›¸å½“å¤æ‚ã€‚
- en: 'Now, letâ€™s return to computing the distance. For each pair of positions, we
    want the edit distance between the pair of words up to and including those positions.
    This distance is given by checking whether the characters at the pair of positions
    are identical. If they are, then the distance is the same as it was for the previous
    pair of prefixes; otherwise we have to try the three different kinds of edits:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬å›åˆ°è®¡ç®—è·ç¦»ã€‚å¯¹äºæ¯ä¸€å¯¹ä½ç½®ï¼Œæˆ‘ä»¬æƒ³è¦è®¡ç®—è¿™ä¸¤ä¸ªå•è¯åœ¨åŒ…æ‹¬è¿™äº›ä½ç½®åœ¨å†…çš„ç¼–è¾‘è·ç¦»ã€‚è¿™ä¸ªè·ç¦»æ˜¯é€šè¿‡æ£€æŸ¥è¿™å¯¹ä½ç½®ä¸Šçš„å­—ç¬¦æ˜¯å¦ç›¸åŒæ¥ç»™å‡ºçš„ã€‚å¦‚æœå®ƒä»¬ç›¸åŒï¼Œé‚£ä¹ˆè·ç¦»ä¸ä¹‹å‰é‚£å¯¹å‰ç¼€çš„è·ç¦»ç›¸åŒï¼›å¦åˆ™ï¼Œæˆ‘ä»¬å¿…é¡»å°è¯•ä¸‰ç§ä¸åŒçš„ç¼–è¾‘æ–¹å¼ï¼š
- en: <levenshtein-dp/compute-dist> ::=
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/compute-dist> ::=
- en: '[PRE67]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As an aside, this sort of â€œoff-by-oneâ€ coordinate arithmetic is traditional
    when using tabular representations, because we write code in terms of elements
    that are not inherently present, and therefore have to create a padded table to
    hold values for the boundary conditions. The alternative would be to allow the
    table to begin its addressing from `-1` so that the main computation looks traditional.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæ—æ³¨ï¼Œè¿™ç§â€œåç§»ä¸€ä¸ªâ€çš„åæ ‡ç®—æœ¯åœ¨è¡¨æ ¼è¡¨ç¤ºæ³•ä¸­æ˜¯ä¼ ç»Ÿçš„ï¼Œå› ä¸ºæˆ‘ä»¬ç”¨ä¸å›ºæœ‰çš„å…ƒç´ æ¥ç¼–å†™ä»£ç ï¼Œå› æ­¤å¿…é¡»åˆ›å»ºä¸€ä¸ªå¡«å……çš„è¡¨æ ¼æ¥ä¿å­˜è¾¹ç•Œæ¡ä»¶çš„å€¼ã€‚å¦ä¸€ç§é€‰æ‹©æ˜¯å…è®¸è¡¨æ ¼ä»
    `-1` å¼€å§‹å¯»å€ï¼Œè¿™æ ·ä¸»è¦çš„è®¡ç®—çœ‹èµ·æ¥å°±æ›´åŠ ä¼ ç»Ÿã€‚
- en: 'At any rate, when this computation is done, the entire table has been filled
    with values. We still have to read out the answer, with lies at the end of the
    table:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: æ— è®ºå¦‚ä½•ï¼Œå½“è¿™ä¸ªè®¡ç®—å®Œæˆæ—¶ï¼Œæ•´ä¸ªè¡¨æ ¼å·²ç»è¢«å¡«å……äº†å€¼ã€‚æˆ‘ä»¬ä»ç„¶éœ€è¦è¯»å–ç­”æ¡ˆï¼Œå®ƒåœ¨è¡¨æ ¼çš„æœ«å°¾ï¼š
- en: <levenshtein-dp/get-result> ::=
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: <levenshtein-dp/get-result> ::=
- en: '[PRE68]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Even putting aside the helper functions we wrote to satiate our paranoia about
    using undefined values, we end up with:As of this writing, the [current version](http://en.wikipedia.org/w/index.php?title=Levenshtein_distance&oldid=581406185#Iterative_with_full_matrix)
    of the [Wikipedia page](http://en.wikipedia.org/wiki/Levenshtein_distance) on
    the Levenshtein distance features a dynamic programming version that is very similar
    to the code above. By writing in pseudocode, it avoids address arithmetic issues
    (observe how the words are indexed starting from 1 instead of 0, which enables
    the body of the code to look more â€œnormalâ€), and by initializing all elements
    to zero it permits subtle bugs because an uninitialized table element is indistinguishable
    from a legitimate entry with edit distance of zero. The page also shows the [recursive](http://en.wikipedia.org/w/index.php?title=Levenshtein_distance&oldid=581406185#Recursive)
    solution and alludes to memoization, but does not show it in code.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: å³ä½¿ä¸è€ƒè™‘æˆ‘ä»¬ç¼–å†™çš„è¾…åŠ©å‡½æ•°æ¥æ»¡è¶³æˆ‘ä»¬å¯¹ä½¿ç”¨æœªå®šä¹‰å€¼çš„æ‹…å¿§ï¼Œæˆ‘ä»¬æœ€ç»ˆå¾—åˆ°ï¼šæˆªè‡³æœ¬æ–‡å†™ä½œæ—¶ï¼Œ[ç»´åŸºç™¾ç§‘é¡µé¢](http://en.wikipedia.org/w/index.php?title=Levenshtein_distance&oldid=581406185#Iterative_with_full_matrix)ä¸Šçš„Levenshteinè·ç¦»çš„å½“å‰ç‰ˆæœ¬åŒ…å«ä¸€ä¸ªä¸ä¸Šè¿°ä»£ç éå¸¸ç›¸ä¼¼çš„åŠ¨æ€è§„åˆ’ç‰ˆæœ¬ã€‚é€šè¿‡ç¼–å†™ä¼ªä»£ç ï¼Œå®ƒé¿å…äº†åœ°å€ç®—æœ¯é—®é¢˜ï¼ˆè§‚å¯Ÿå•è¯æ˜¯å¦‚ä½•ä»1å¼€å§‹ç´¢å¼•è€Œä¸æ˜¯0ï¼Œè¿™ä½¿å¾—ä»£ç çš„ä¸»ä½“çœ‹èµ·æ¥æ›´â€œæ­£å¸¸â€ï¼‰ï¼Œå¹¶ä¸”é€šè¿‡å°†æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºé›¶ï¼Œå®ƒå…è®¸å¾®å¦™çš„é”™è¯¯ï¼Œå› ä¸ºæœªåˆå§‹åŒ–çš„è¡¨å…ƒç´ ä¸ç¼–è¾‘è·ç¦»ä¸ºé›¶çš„æœ‰æ•ˆæ¡ç›®æ— æ³•åŒºåˆ†ã€‚è¯¥é¡µé¢è¿˜æ˜¾ç¤ºäº†[é€’å½’](http://en.wikipedia.org/w/index.php?title=Levenshtein_distance&oldid=581406185#Recursive)è§£å†³æ–¹æ¡ˆå¹¶æåˆ°äº†è®°å¿†åŒ–ï¼Œä½†æ²¡æœ‰åœ¨ä»£ç ä¸­å±•ç¤ºã€‚
- en: '[PRE69]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: which is worth contrasting with the memoized version ([<levenshtein-memo>](#%28elem._levenshtein-memo%29)).For
    more examples of canonical dynamic programming problems, see [this page](http://people.csail.mit.edu/bdean/6.046/dp/)
    and think about how each can be expressed as a direct recursion.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸è®°å¿†åŒ–ç‰ˆæœ¬([<levenshtein-memo>](#%28elem._levenshtein-memo%29))å€¼å¾—å¯¹æ¯”ã€‚æ›´å¤šå…³äºå…¸å‹åŠ¨æ€è§„åˆ’é—®é¢˜çš„ä¾‹å­ï¼Œè¯·å‚é˜…[è¿™ä¸ªé¡µé¢](http://people.csail.mit.edu/bdean/6.046/dp/)ï¼Œå¹¶æ€è€ƒæ¯ä¸ªå¦‚ä½•ç›´æ¥é€’å½’è¡¨ç¤ºã€‚
- en: 22.5Â Contrasting Memoization and Dynamic Programming[ğŸ”—](#(part._memo-vs-dp)
    "Link to here")
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.5Â å¯¹æ¯”è®°å¿†åŒ–å’ŒåŠ¨æ€è§„åˆ’[ğŸ”—](#(part._memo-vs-dp) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Now that weâ€™ve seen two very different techniques for avoiding recomputation,
    itâ€™s worth contrasting them. The important thing to note is that memoization is
    a much simpler technique: write the natural recursive definition; determine its
    time complexity; decide whether this is problematic enough to warrant a space-time
    trade-off; and if it is, apply memoization. The code remains clean, and subsequent
    readers and maintainers will be grateful for that. In contrast, dynamic programming
    requires a reorganization of the algorithm to work bottom-up, which can often
    make the code harder to follow and full of subtle invariants about boundary conditions
    and computation order.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†ä¸¤ç§é¿å…é‡å¤è®¡ç®—çš„ä¸åŒæŠ€æœ¯ï¼Œå€¼å¾—å¯¹æ¯”å®ƒä»¬ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè®°å¿†åŒ–æ˜¯ä¸€ä¸ªæ›´ç®€å•çš„æŠ€æœ¯ï¼šå†™å‡ºè‡ªç„¶çš„é€’å½’å®šä¹‰ï¼›ç¡®å®šå…¶æ—¶é—´å¤æ‚åº¦ï¼›åˆ¤æ–­è¿™æ˜¯å¦è¶³å¤Ÿæˆé—®é¢˜ï¼Œä»¥è‡³äºéœ€è¦æƒè¡¡æ—¶é—´å’Œç©ºé—´ï¼›å¦‚æœæ˜¯çš„è¯ï¼Œåº”ç”¨è®°å¿†åŒ–ã€‚ä»£ç ä¿æŒç®€æ´ï¼Œåç»­çš„é˜…è¯»è€…å’Œç»´æŠ¤è€…ä¼šä¸ºæ­¤æ„Ÿåˆ°æ„Ÿæ¿€ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼ŒåŠ¨æ€è§„åˆ’éœ€è¦é‡æ–°ç»„ç»‡ç®—æ³•ä»¥è‡ªåº•å‘ä¸Šå·¥ä½œï¼Œè¿™é€šå¸¸ä¼šä½¿ä»£ç æ›´éš¾ä»¥ç†è§£ï¼Œå¹¶å……æ»¡å…³äºè¾¹ç•Œæ¡ä»¶å’Œè®¡ç®—é¡ºåºçš„å¾®å¦™ä¸å˜é‡ã€‚
- en: That said, the dynamic programming solution can sometimes be more computationally
    efficient. For instance, in the Levenshtein case, observe that at each table element,
    we (at most) only ever use the ones that are from the previous row and column.
    That means we never need to store the entire table; we can retain just the fringe
    of the table, which reduces space to being proportional to the sum, rather than
    product, of the length of the words. In a computational biology setting (when
    using Smith-Waterman), for instance, this saving can be substantial. This optimization
    is essentially impossible for memoization.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: è¯è™½å¦‚æ­¤ï¼ŒåŠ¨æ€è§„åˆ’è§£å†³æ–¹æ¡ˆæœ‰æ—¶å¯èƒ½æ›´æœ‰æ•ˆã€‚ä¾‹å¦‚ï¼Œåœ¨Levenshteinçš„æƒ…å†µä¸‹ï¼Œè§‚å¯Ÿæ¯ä¸ªè¡¨å…ƒç´ ï¼Œæˆ‘ä»¬ï¼ˆæœ€å¤šï¼‰åªä½¿ç”¨æ¥è‡ªä¸Šä¸€è¡Œå’Œå‰ä¸€åˆ—çš„å…ƒç´ ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬æ°¸è¿œä¸éœ€è¦å­˜å‚¨æ•´ä¸ªè¡¨ï¼›æˆ‘ä»¬åªéœ€ä¿ç•™è¡¨çš„è¾¹ç¼˜ï¼Œè¿™æ ·ç©ºé—´å°±ä¸å•è¯é•¿åº¦çš„å’Œæˆæ¯”ä¾‹ï¼Œè€Œä¸æ˜¯ä¹˜ç§¯ã€‚ä¾‹å¦‚ï¼Œåœ¨è®¡ç®—ç”Ÿç‰©å­¦ç¯å¢ƒä¸­ï¼ˆä½¿ç”¨Smith-Watermanï¼‰ï¼Œè¿™ç§èŠ‚çœå¯èƒ½æ˜¯å·¨å¤§çš„ã€‚è¿™ç§ä¼˜åŒ–å¯¹äºè®°å¿†åŒ–æ¥è¯´æ˜¯åŸºæœ¬ä¸Šä¸å¯èƒ½çš„ã€‚
- en: 'In more detail, hereâ€™s the contrast:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´è¯¦ç»†åœ°è¯´ï¼Œä»¥ä¸‹æ˜¯å¯¹æ¯”ï¼š
- en: '| Memoization |  | Dynamic Programming |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| è®°å¿†åŒ– |  | åŠ¨æ€è§„åˆ’ |'
- en: '| Top-down |  | Bottom-up |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| è‡ªé¡¶å‘ä¸‹ |  | è‡ªåº•å‘ä¸Š |'
- en: '| Depth-first |  | Breadth-first |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| æ·±åº¦ä¼˜å…ˆ |  | å¹¿åº¦ä¼˜å…ˆ |'
- en: '| Black-box |  | Requires code reorganization |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| é»‘ç›’ |  | éœ€è¦ä»£ç é‡æ„ |'
- en: '| All stored calls are necessary |  | May do unnecessary computation |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| æ‰€æœ‰å­˜å‚¨çš„è°ƒç”¨éƒ½æ˜¯å¿…è¦çš„ |  | å¯èƒ½è¿›è¡Œä¸å¿…è¦çš„è®¡ç®— |'
- en: '| Cannot easily get rid of unnecessary data |  | Can more easily get rid of
    unnecessary data |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| æ— æ³•è½»æ˜“å»é™¤ä¸å¿…è¦çš„æ•°æ® |  | å¯ä»¥æ›´è½»æ˜“åœ°å»é™¤ä¸å¿…è¦çš„æ•°æ® |'
- en: '| Can never accidentally use an uninitialized answer |  | Can accidentally
    use an uninitialized answer |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| æ°¸è¿œä¸ä¼šæ„å¤–ä½¿ç”¨æœªåˆå§‹åŒ–çš„ç­”æ¡ˆ |  | å¯èƒ½æ„å¤–ä½¿ç”¨æœªåˆå§‹åŒ–çš„ç­”æ¡ˆ |'
- en: '| Needs to check for the presence of an answer |  | Can be designed to not
    need to check for the presence of an answer |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| éœ€è¦æ£€æŸ¥ç­”æ¡ˆçš„å­˜åœ¨ |  | å¯ä»¥è®¾è®¡ä¸ºä¸éœ€è¦æ£€æŸ¥ç­”æ¡ˆçš„å­˜åœ¨ |'
- en: As this table should make clear, these are essentialy dual approaches. What
    is perhaps left unstated in most dynamic programming descriptions is that it,
    too, is predicated on the computation always producing the same answer for a given
    inputâ€”<wbr>i.e., being a pure function.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æ­¤è¡¨æ ¼æ‰€ç¤ºï¼Œè¿™äº›åŸºæœ¬ä¸Šæ˜¯ä¸¤ç§å¯¹å¶æ–¹æ³•ã€‚åœ¨å¤§å¤šæ•°åŠ¨æ€è§„åˆ’æè¿°ä¸­å¯èƒ½æ²¡æœ‰æ˜ç¡®æŒ‡å‡ºçš„æ˜¯ï¼Œå®ƒä¹ŸåŸºäºå¯¹äºç»™å®šè¾“å…¥æ€»æ˜¯äº§ç”Ÿç›¸åŒç­”æ¡ˆçš„è®¡ç®—â€”â€”<wbr>å³ï¼Œå®ƒæ˜¯ä¸€ä¸ªçº¯å‡½æ•°ã€‚
- en: From a software design perspective, there are two more considerations.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è½¯ä»¶è®¾è®¡çš„è§’åº¦æ¥çœ‹ï¼Œè¿˜æœ‰ä¸¤ä¸ªé¢å¤–çš„è€ƒè™‘å› ç´ ã€‚
- en: 'First, the performance of a memoized solution can trail that of dynamic programming
    when the memoized solution uses a generic data structure to store the memo table,
    whereas a dynamic programming solution will invariably use a custom data structure
    (since the code needs to be rewritten against it anyway). Therefore, before switching
    to dynamic programming for performance reasons, it makes sense to try to create
    a custom memoizer for the problem: the same knowledge embodied in the dynamic
    programming version can often be encoded in this custom memoizer (e.g., using
    an array instead of list to improve access times). This way, the program can enjoy
    speed comparable to that of dynamic programming while retaining readability and
    maintainability.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œå½“è®°å¿†åŒ–è§£å†³æ–¹æ¡ˆä½¿ç”¨é€šç”¨æ•°æ®ç»“æ„æ¥å­˜å‚¨è®°å¿†è¡¨æ—¶ï¼Œå…¶æ€§èƒ½å¯èƒ½ä¼šè½åäºåŠ¨æ€è§„åˆ’ï¼Œè€ŒåŠ¨æ€è§„åˆ’è§£å†³æ–¹æ¡ˆå°†ä¸å¯é¿å…åœ°ä½¿ç”¨è‡ªå®šä¹‰æ•°æ®ç»“æ„ï¼ˆå› ä¸ºä»£ç éœ€è¦é’ˆå¯¹å®ƒé‡å†™ï¼‰ã€‚å› æ­¤ï¼Œåœ¨å‡ºäºæ€§èƒ½åŸå› åˆ‡æ¢åˆ°åŠ¨æ€è§„åˆ’ä¹‹å‰ï¼Œå°è¯•ä¸ºé—®é¢˜åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰çš„è®°å¿†åŒ–å™¨æ˜¯æœ‰æ„ä¹‰çš„ï¼šåŠ¨æ€è§„åˆ’ç‰ˆæœ¬ä¸­ä½“ç°çš„çŸ¥è¯†é€šå¸¸å¯ä»¥ç¼–ç åœ¨è¿™ä¸ªè‡ªå®šä¹‰çš„è®°å¿†åŒ–å™¨ä¸­ï¼ˆä¾‹å¦‚ï¼Œä½¿ç”¨æ•°ç»„è€Œä¸æ˜¯åˆ—è¡¨æ¥æé«˜è®¿é—®æ—¶é—´ï¼‰ã€‚è¿™æ ·ï¼Œç¨‹åºå¯ä»¥äº«å—åˆ°ä¸åŠ¨æ€è§„åˆ’ç›¸å½“çš„é€Ÿåº¦ï¼ŒåŒæ—¶ä¿æŒå¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚
- en: Second, suppose space is an important consideration and the dynamic programming
    version can make use of significantly less space. Then it does make sense to employ
    dynamic programming instead. Does this mean the memoized version is useless?
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶æ¬¡ï¼Œå‡è®¾ç©ºé—´æ˜¯ä¸€ä¸ªé‡è¦çš„è€ƒè™‘å› ç´ ï¼Œå¹¶ä¸”åŠ¨æ€è§„åˆ’ç‰ˆæœ¬å¯ä»¥åˆ©ç”¨æ˜¾è‘—æ›´å°‘çš„ç©ºé—´ã€‚é‚£ä¹ˆï¼Œä½¿ç”¨åŠ¨æ€è§„åˆ’æ˜¯æœ‰æ„ä¹‰çš„ã€‚è¿™æ„å‘³ç€è®°å¿†åŒ–çš„ç‰ˆæœ¬å°±æ— ç”¨äº†å—ï¼Ÿ
- en: Do Now!
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think? Do we still have use for the memoized version?
  id: totrans-485
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ æ€ä¹ˆçœ‹ï¼Ÿæˆ‘ä»¬æ˜¯å¦ä»ç„¶éœ€è¦è®°å¿†åŒ–çš„ç‰ˆæœ¬ï¼Ÿ
- en: Yes, of course we do! It can serve as an oracle [[Oracles for Testing](testing.html#%28part._test-oracle%29)]
    for the dynamic programming version, since the two are supposed to produce identical
    answers anywayâ€”<wbr>and the memoized version would be a much more efficient oracle
    than the purely recursive implemenation, and can therefore be used to test the
    dynamic programming version on much larger inputs.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œæˆ‘ä»¬ç¡®å®å¯ä»¥ï¼å®ƒå¯ä»¥ä½œä¸ºä¸€ä¸ªåŠ¨æ€è§„åˆ’ç‰ˆæœ¬çš„å…ˆçŸ¥ [[æµ‹è¯•çš„å…ˆçŸ¥](testing.html#%28part._test-oracle%29)]ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªç‰ˆæœ¬æœ¬åº”äº§ç”Ÿç›¸åŒçš„ç­”æ¡ˆâ€”â€”<wbr>è€Œä¸”è®°å¿†åŒ–çš„ç‰ˆæœ¬å°†æ˜¯ä¸€ä¸ªæ¯”çº¯é€’å½’å®ç°æ›´é«˜æ•ˆçš„å…ˆçŸ¥ï¼Œå› æ­¤å¯ä»¥ç”¨æ¥æµ‹è¯•åŠ¨æ€è§„åˆ’ç‰ˆæœ¬åœ¨æ›´å¤§çš„è¾“å…¥ä¸Šã€‚
- en: In short, always first produce the memoized version. If you need more performance,
    consider customizing the memoizerâ€™s data structure. If you need to also save space,
    and can arrive at a more space-efficient dynamic programming solution, then keep
    both versions around, using the former to test the latter (the person who inherits
    your code and needs to alter it will thank you!).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€è€Œè¨€ä¹‹ï¼Œé¦–å…ˆäº§ç”Ÿè®°å¿†åŒ–çš„ç‰ˆæœ¬ã€‚å¦‚æœä½ éœ€è¦æ›´å¤šçš„æ€§èƒ½ï¼Œè€ƒè™‘å®šåˆ¶è®°å¿†åŒ–å™¨çš„æ•°æ®ç»“æ„ã€‚å¦‚æœä½ éœ€è¦èŠ‚çœç©ºé—´ï¼Œå¹¶ä¸”å¯ä»¥æ‰¾åˆ°ä¸€ä¸ªæ›´èŠ‚çœç©ºé—´çš„åŠ¨æ€è§„åˆ’è§£å†³æ–¹æ¡ˆï¼Œé‚£ä¹ˆä¿ç•™ä¸¤ä¸ªç‰ˆæœ¬ï¼Œä½¿ç”¨å‰è€…æ¥æµ‹è¯•åè€…ï¼ˆç»§æ‰¿ä½ çš„ä»£ç å¹¶éœ€è¦ä¿®æ”¹å®ƒçš„äººä¼šæ„Ÿè°¢ä½ ï¼ï¼‰ã€‚
- en: Exercise
  id: totrans-488
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We have characterized the fundamental difference between memoization and dynamic
    programming as that between top-down, depth-first and bottom-up, breadth-first
    computation. This should naturally raise the question, what about:'
  id: totrans-490
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†è®°å¿†åŒ–å’ŒåŠ¨æ€ç¼–ç¨‹ä¹‹é—´çš„åŸºæœ¬åŒºåˆ«æè¿°ä¸ºè‡ªé¡¶å‘ä¸‹ã€æ·±åº¦ä¼˜å…ˆå’Œè‡ªåº•å‘ä¸Šã€å¹¿åº¦ä¼˜å…ˆè®¡ç®—çš„å·®å¼‚ã€‚è¿™è‡ªç„¶ä¼šå¼•å‘ä¸€ä¸ªé—®é¢˜ï¼Œå…³äºï¼š
- en: ''
  id: totrans-491
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: top-down, breadth-first
  id: totrans-492
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: è‡ªé¡¶å‘ä¸‹ï¼Œå¹¿åº¦ä¼˜å…ˆ
- en: ''
  id: totrans-493
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-494
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: bottom-up, depth-first
  id: totrans-495
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: è‡ªåº•å‘ä¸Šï¼Œæ·±åº¦ä¼˜å…ˆ
- en: ''
  id: totrans-496
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-497
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-498
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: orders of computation. Do they also have special names that we just happen to
    not know? Are they uninteresting? Or do they not get discussed for a reason?
  id: totrans-499
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è®¡ç®—çš„é¡ºåºã€‚å®ƒä»¬ä¹Ÿæœ‰ç‰¹æ®Šçš„åç§°ï¼Œæˆ‘ä»¬åªæ˜¯ä¸çŸ¥é“å—ï¼Ÿå®ƒä»¬æ˜¯å¦ä¸æœ‰è¶£ï¼Ÿæˆ–è€…æ˜¯å› ä¸ºæŸç§åŸå› æ²¡æœ‰è®¨è®ºï¼Ÿ
