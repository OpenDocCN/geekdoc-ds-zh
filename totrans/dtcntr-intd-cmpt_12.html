<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>5.1Â From Tables to ListsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>5.1Â From Tables to ListsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/tables-to-lists.html">https://dcic-world.org/2025-08-27/tables-to-lists.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._table-stat-qs%29" class="toclink" data-pltdoc="x">5.1.1Â Basic Statistical Questions</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Extracting_a_.Column_from_a_.Table%29" class="toclink" data-pltdoc="x">5.1.2Â Extracting a Column from a Table</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Understanding_.Lists%29" class="toclink" data-pltdoc="x">5.1.3Â Understanding Lists</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._lists-generic-data%29" class="toclink" data-pltdoc="x">5.1.3.1Â Lists as Anonymous Data</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Creating_.Literal_.Lists%29" class="toclink" data-pltdoc="x">5.1.3.2Â Creating Literal Lists</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Operating_on_.Lists%29" class="toclink" data-pltdoc="x">5.1.4Â Operating on Lists</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Built-.In_.Operations_on_.Lists_of_.Numbers%29" class="toclink" data-pltdoc="x">5.1.4.1Â Built-In Operations on Lists of Numbers</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Built-.In_.Operations_on_.Lists_in_.General%29" class="toclink" data-pltdoc="x">5.1.4.2Â Built-In Operations on Lists in General</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.An_.Aside_on_.Naming_.Conventions%29" class="toclink" data-pltdoc="x">5.1.4.3Â An Aside on Naming Conventions</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Getting_.Elements_.By_.Position%29" class="toclink" data-pltdoc="x">5.1.4.4Â Getting Elements By Position</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Transforming_.Lists%29" class="toclink" data-pltdoc="x">5.1.4.5Â Transforming Lists</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._lists-recap%29" class="toclink" data-pltdoc="x">5.1.4.6Â Recap: Summary of List Operations</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Lambda__.Anonymous_.Functions%29" class="toclink" data-pltdoc="x">5.1.5Â Lambda: Anonymous Functions</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Combining_.Lists_and_.Tables%29" class="toclink" data-pltdoc="x">5.1.6Â Combining Lists and Tables</a></p></td></tr></table><p>Previously [<a href="intro-tabular-data.html" data-pltdoc="x">Introduction to Tabular Data</a>] we began to process
collective data in the form of tables. Though we saw
several powerful operations that let us quickly and easily ask
sophisticated questions about our data, they all had two things in
common. First, all were operations by rows. None of the operations
asked questions about an entire column at a time. Second, all the
operations not only consumed but also produced tables. However, we
already know [<a href="getting-started.html" data-pltdoc="x">Getting Started</a>] there are many other kinds
of data, and sometimes we will want to compute one of them. We will
now see how to achieve both of these things, introducing an important
new type of data in the process.</p><section class="SsectionLevel4" id="section 5.1.1"><h4 class="heading">5.1.1Â <a name="(part._table-stat-qs)"/>Basic Statistical Questions<a href="#(part._table-stat-qs)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>There are many more questions we might want to ask of our events data. For
instance:
</p><ul><li><p>The most-frequently used discount code.</p></li><li><p>The average number of tickets per order.</p></li><li><p>The largest ticket order.</p></li><li><p>The most common number of tickets in an order.</p></li><li><p>The collection of unique discount codes that were used (many
might have been available).</p></li><li><p>The collection of distinct email addresses associated with
orders, so we can contact customers (some customers may have placed
multiple orders).</p></li><li><p>Which school lead to the largest number of orders with a
<code data-lang="pyret" class="sourceCode">"STUDENT"</code> discount.</p></li></ul><p>Notice the kinds of operations that we are talking about: computing
the maximum, minimum, average, median, and other basic
statistics.Pyret has several built-in
statistics functions in the
<a href="http://www.pyret.org/docs/latest/math.html">math</a>
and
<a href="http://www.pyret.org/docs/latest/statistics.html">statistics</a>
packages.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Think about whether and how you would express these questions with the
operations you have already seen.</p></blockquote></blockquote><p>In each of these cases, we need to perform a computation on a single
column of data (even in the last question about the <code data-lang="pyret" class="sourceCode">"STUDENT"</code>
discount, as we would filter the table to those rows, then do a
computation over the <code data-lang="pyret" class="sourceCode">email</code> column). In order to capture these
in code, we need to extract a column from the table.</p><p>For the rest of this chapter, we will work with a cleaned copy of the
<code data-lang="pyret" class="sourceCode">event-data</code> from the previous chapter. The cleaned data, which
applies the transformations at the end of the previous chapter, is in
a different tab of the same Google Sheet as the other versions of the
event data.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">include gdrive-sheets
include data-source

ssid = "1Ks4ll5_8wyYK1zyXMm_21KORhagSMZ59dcr7i3qY6T4"
cleaned-data =
  load-table: name, email, tickcount, discount, delivery, zip
    source: load-spreadsheet(ssid).sheet-by-name("Cleaned", true)
    sanitize name using string-sanitizer
    sanitize email using string-sanitizer
    sanitize tickcount using num-sanitizer
    sanitize discount using string-sanitizer
    sanitize delivery using string-sanitizer
    sanitize zip using string-sanitizer
  end</code></pre></section><section class="SsectionLevel4" id="section 5.1.2"><h4 class="heading">5.1.2Â <a name="(part._.Extracting_a_.Column_from_a_.Table)"/>Extracting a Column from a Table<a href="#(part._.Extracting_a_.Column_from_a_.Table)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Our collection of table functions includes one that we havenâ€™t yet
used, called <code data-lang="pyret" class="sourceCode">select-columns</code>. As the name suggests, this
function produces a new table containing only certain columns from an
existing table. Letâ€™s extract the <code data-lang="pyret" class="sourceCode">tickcount</code> column so we can
compute some statistics over it. We use the following expression:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">select-columns(cleaned-data, [list: "tickcount"])</code></pre><p><img src="../Images/218dbd3d076ef24041ce988f1e4f6c1d.png" alt="" width="94" height="295" data-original-src="https://dcic-world.org/2025-08-27/tickcount-column.png"/></p><p>This focuses our attention on the numeric ticket sales, but weâ€™re still stuck
with a column in a table, and none of the other tables
functions let us do the kinds of computations we might want over these
numbers. Ideally, we want the collection of numbers on their own, without being
wrapped up in the extra layer of table cells.</p><p>In principle, we could have a collection of operations on a single
column. In some languages that focus solely on tables, such as
<a href="https://en.wikipedia.org/wiki/SQL">SQL</a>,
this is what youâ€™ll find. However, in Pyret we have many more
kinds of data than just columns (as weâ€™ll soon see [<a href="intro-struct-data.html" data-pltdoc="x">Introduction to Structured Data</a>], we can even
create our own!), so it makes sense to leave the gentle cocoon of
tables sooner or later. An extracted column is a more basic kind of
datum called a list, which can be used to represent a sequence
of data outside of a table.</p><p>Just as we have used the notation <code data-lang="pyret" class="sourceCode">.row-n</code> to pull a single row
from a table, we use a similar dot-based notion to pull out a single
column. Hereâ€™s how we extract the <code data-lang="pyret" class="sourceCode">tickcount</code> column:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cleaned-data.get-column("tickcount")</code></pre><p>In response, Pyret produces the following value:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 2, 1, 5, 0, 3, 10, 3]</code></pre><p>Now, we seem to have only the values that were in the cells in the
column, without the enclosing table. Yet the numbers are still bundled
up, this time in the <code data-lang="pyret" class="sourceCode">[list: ...]</code> notation. What is that?</p></section><section class="SsectionLevel4" id="section 5.1.3"><h4 class="heading">5.1.3Â <a name="(part._.Understanding_.Lists)"/>Understanding Lists<a href="#(part._.Understanding_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>A list has much in common with a single-column table:
</p><ul><li><p>The elements have an order, so it makes sense to talk about the
â€œfirstâ€, â€œsecondâ€, â€œlastâ€â€”<wbr/>and so onâ€”<wbr/>element of a list.</p></li><li><p>All elements of a list are expected to have the same type.</p></li></ul><p>The crucial difference is that a list does not have a â€œcolumn nameâ€;
it is anonymous. That is, by itself a list does not describe
what it represents; this interpretation is done by our program.</p><section class="SsectionLevel5" id="section 5.1.3.1"><h5 class="heading">5.1.3.1Â <a name="(part._lists-generic-data)"/>Lists as Anonymous Data<a href="#(part._lists-generic-data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>This might sound rather abstractâ€”<wbr/>and it isâ€”<wbr/>but this isnâ€™t actually
a new idea in our programming experience. Consider a value like
<code data-lang="pyret" class="sourceCode">3</code> or <code data-lang="pyret" class="sourceCode">-1</code>: what is it? Itâ€™s the same sort of thing: an
anonymous value that does not describe what it represents; the
interpretation is done by our program. In one setting <code data-lang="pyret" class="sourceCode">3</code> may
represent an age, in another a play count; in one setting <code data-lang="pyret" class="sourceCode">-1</code>
may be a temperature, in another the average of several
temperatures. Similarly with a string: Is <code data-lang="pyret" class="sourceCode">"project"</code> a noun (an
activity that one or more people perform) or a verb (as when we
display something on a screen)? Likewise with images and so on. In
fact, tables have been the exception so far in having description
built into the data rather than being provided by a program!</p><p>This genericity is both a virtue and a problem. Because, like
other anonymous data, a list does not provide any interpretation of
its use, if we are not careful we can accidentally mis-interpret the
values. On the other hand, it means we can use the same datum in
several different contexts, and one operation can be used in many
settings.</p><p>Indeed, if we look at the list of questions we asked earlier, we see
that there are several common operationsâ€”<wbr/>maximum, minimum, average,
and so onâ€”<wbr/>that can be asked of a list of values without regard for
what the list represents (heights, ages, playcounts). In fact, some
are specific to numbers (like average) while some (like maximum) can
be asked of any type on which we can perform a comparison (like
strings).</p></section><section class="SsectionLevel5" id="section 5.1.3.2"><h5 class="heading">5.1.3.2Â <a name="(part._.Creating_.Literal_.Lists)"/>Creating Literal Lists<a href="#(part._.Creating_.Literal_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>We have already seen how we can create lists from a table, using
<code data-lang="pyret" class="sourceCode">get-column</code>. As you might expect, however, we can also create lists
directly:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]
[list: -1, 5, 2.3, 10]
[list: "a", "b", "c"]
[list: "This", "is", "a", "list", "of", "words"]</code></pre><p>Of course, lists are values so we can name them using variablesâ€”<wbr/>
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shopping-list = [list: "muesli", "fiddleheads"]</code></pre><p>â€”<wbr/>pass them to functions (as we will soon see), and so on.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Based on these examples, can you figure out how to create an empty
list?</p></blockquote></blockquote><p>As you might have guessed, itâ€™s <code data-lang="pyret" class="sourceCode">[list: ]</code> (the space isnâ€™t
necessary, but itâ€™s a useful visual reminder of the void).</p></section></section><section class="SsectionLevel4" id="section 5.1.4"><h4 class="heading">5.1.4Â <a name="(part._.Operating_on_.Lists)"/>Operating on Lists<a href="#(part._.Operating_on_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><section class="SsectionLevel5" id="section 5.1.4.1"><h5 class="heading">5.1.4.1Â <a name="(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)"/>Built-In Operations on Lists of Numbers<a href="#(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Pyret handily provides a useful set of operations we can already
perform on lists. The
<a href="https://www.pyret.org/docs/latest/lists.html">lists
documentation</a> describes these operations. As you might have
guessed, we can already compute most of the answers weâ€™ve asked for
at the start of the chapter. First we need to include some libraries that contain useful
functions:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import math as M
import statistics as S</code></pre><p>We can then access several useful functions:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tickcounts = cleaned-data.get-column("tickcount")

M.max(tickcounts)     # largest number in a list
M.sum(tickcounts)     # sum of numbers in a list
S.mean(tickcounts)    # mean (average) of numbers in a list
S.median(tickcounts)  # median of numbers in a list</code></pre><p>The <code data-lang="pyret" class="sourceCode">M.</code> notation means "the function inside the library
<code data-lang="pyret" class="sourceCode">M</code>. The <code data-lang="pyret" class="sourceCode">import</code> statement in the above code gave the name
<code data-lang="pyret" class="sourceCode">M</code> to the <code data-lang="pyret" class="sourceCode">math</code> library.</p></section><section class="SsectionLevel5" id="section 5.1.4.2"><h5 class="heading">5.1.4.2Â <a name="(part._.Built-.In_.Operations_on_.Lists_in_.General)"/>Built-In Operations on Lists in General<a href="#(part._.Built-.In_.Operations_on_.Lists_in_.General)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Some of the useful computations in our list at the start of the
chapter involved the <code data-lang="pyret" class="sourceCode">discount</code> column, which contains strings
rather than numbers. Specifically, letâ€™s consider the following
question:</p><ul><li><p>Compute the collection of unique discount codes that were used (many
might have been available).</p></li></ul><p>None of the table functions handle a question like this. However, this
is a common kind of question to ask about a collection of values (How
many unique artists are in your playlist? How many unique faculty are
teaching courses?). As such, Pyret (as most languages) provides a way
to identify the unique elements of a list. Hereâ€™s how we get the list
of all discount codes that were used in our table:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import lists as L
codes = cleaned-data.get-column("discount")
L.distinct(codes)</code></pre><p>The <code data-lang="pyret" class="sourceCode">distinct</code> function produces a list of the unique values from
the input list: every value in the input list appears exactly once in
the output list. For the above code, Pyret produces:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "BIRTHDAY", "STUDENT", "none"]</code></pre><p>What if we wanted to exclude <code data-lang="pyret" class="sourceCode">"none"</code> from that list? After all,
<code data-lang="pyret" class="sourceCode">"none"</code> isnâ€™t an actual discount code, but rather one that we
introduced while cleaning up the table. Is there a way to easily
remove <code data-lang="pyret" class="sourceCode">"none"</code> from the list?</p><p>There are two ways we could do it. In the Pyret lists documentation,
we find a function called <code data-lang="pyret" class="sourceCode">remove</code>, which removes a specific
element from a list:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.remove(L.distinct(codes), "none")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "BIRTHDAY", "STUDENT"]</code></pre></td></tr></table><p>But this operation should also sound familiar: with tables, we
used <code data-lang="pyret" class="sourceCode">filter-with</code> to keep only those elements that meet a
specific criterion. The filtering idea is so common that Pyret (and
most other languages) provide a similar operation on lists. In the
case of the discount codes, we could also have written:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun real-code(c :: String) -&gt; Boolean:
  not(c == "none")
end
L.filter(real-code, L.distinct(codes))</code></pre><p>The difference between these two approaches is that <code data-lang="pyret" class="sourceCode">filter</code> is
more flexible: we can check any characteristic of a list element using
<code data-lang="pyret" class="sourceCode">filter</code>, but <code data-lang="pyret" class="sourceCode">remove</code> only checks whether the entire
element is equal to the value that we provide. If instead of removing
the specific string <code data-lang="pyret" class="sourceCode">"none"</code>, we had wanted to remove all strings
that were in all-lowercase, we would have needed to use <code data-lang="pyret" class="sourceCode">filter</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function that takes a list of words and removes those words in
which all letters are in lowercase. (Hint: combine
<code data-lang="pyret" class="sourceCode">string-to-lower</code> and <code data-lang="pyret" class="sourceCode">==</code>).</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.1.4.3"><h5 class="heading">5.1.4.3Â <a name="(part._.An_.Aside_on_.Naming_.Conventions)"/>An Aside on Naming Conventions<a href="#(part._.An_.Aside_on_.Naming_.Conventions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Our use of the plural <code data-lang="pyret" class="sourceCode">codes</code> for the list of values in the
column named <code data-lang="pyret" class="sourceCode">discount</code> (singular) is deliberate. A list contains
multiple values, so a plural is appropriate. In a table, in contrast,
we think of a column header as naming a single value that appears in
a specific row. Often, we speak of looking up a value in a specific
row and column: the singular name for the column supports thinking
about lookup in an individual row.</p></section><section class="SsectionLevel5" id="section 5.1.4.4"><h5 class="heading">5.1.4.4Â <a name="(part._.Getting_.Elements_.By_.Position)"/>Getting Elements By Position<a href="#(part._.Getting_.Elements_.By_.Position)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s look at a new analysis question: the events company recently ran
an advertising campaign on <code data-lang="pyret" class="sourceCode">web.com</code>, and they are curious
whether it paid off. To do this, they need to determine how many sales
were made to people with <code data-lang="pyret" class="sourceCode">web.com</code> email addresses.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Propose a task plan (<a href="processing-tables.html#%28part._task-plans%29" data-pltdoc="x">Task Plans</a>) for this computation.</p></blockquote></blockquote><p>Hereâ€™s a proposed plan, annotated with how we might implement each part:</p><ol><li><p>Get the list of email addresses (use <code data-lang="pyret" class="sourceCode">get-column</code>)</p></li><li><p>Extract those that came from <code data-lang="pyret" class="sourceCode">web.com</code> (use <code data-lang="pyret" class="sourceCode">L.filter</code>)</p></li><li><p>Count how many email addresses remain (using <code data-lang="pyret" class="sourceCode">L.length</code>,
which we hadnâ€™t discussed yet, but it is in the documentation)</p></li></ol><p>(As a reminder, unless you immediately see how to solve a problem,
write out a task plan and annotate the parts you know how to do. It
helps break down a programming problem into more manageable parts.)</p><p>Letâ€™s discuss the second task: identifying messages from
<code data-lang="pyret" class="sourceCode">web.com</code>. We know that email addresses are strings, so if we
could determine whether an email string ends in <code data-lang="pyret" class="sourceCode">@web.com</code>,
weâ€™d be set. You could consider doing this by looking at the last 7
characters of the email string. Another option is to use a string
operation that we havenâ€™t yet seen called <code data-lang="pyret" class="sourceCode">string-split-all</code>, which
splits a string into a list of substrings around a given
character. For example:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split-all("this-has-hyphens", "-")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "this", "has", "hyphens"]</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split("bonnie@pyret.org", "@")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "bonnie", "pyret.org"]</code></pre></td></tr></table><p>This seems pretty useful. If we split each email string around the
<code data-lang="pyret" class="sourceCode">@</code> sign, then we can check whether the second string in the
list is <code data-lang="pyret" class="sourceCode">web.com</code> (since email addresses should have only one
<code data-lang="pyret" class="sourceCode">@</code> sign). But how would we get the second element out of
the list produced by <code data-lang="pyret" class="sourceCode">string-split-all</code>? Here we dig into the
list, as we did to extract rows from tables, this time using the
<code data-lang="pyret" class="sourceCode">get</code> operation.</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split("bonnie@pyret.org", "@").get(1)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"pyret.org"</code></pre></td></tr></table><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Why do we use <code data-lang="pyret" class="sourceCode">1</code> as the input to <code data-lang="pyret" class="sourceCode">get</code> if we want the
second item in the list?</p></blockquote></blockquote><p>Hereâ€™s the complete program for doing this check:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun web-com-address(email :: String) -&gt; Boolean:
  doc: "determine whether email is from web.com"
  string-split(email, "@").get(1) == "web.com"
where:
  web-com-address("bonnie@pyret.org") is false
  web-com-address("parrot@web.com") is true
end

emails = cleaned-data.get-column("email")
L.length(L.filter(web-com-address, emails))</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>What happens if there is a malformed email address string that doesnâ€™t
contain the <code data-lang="pyret" class="sourceCode">@</code> string? What would happen? What could you do
about that?</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.1.4.5"><h5 class="heading">5.1.4.5Â <a name="(part._.Transforming_.Lists)"/>Transforming Lists<a href="#(part._.Transforming_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Imagine now that we had a list of email addresses, but instead just
wanted a list of usernames. This doesnâ€™t make sense for our event
data, but it does make sense in other contexts (such as connecting
messages to folders organized by studentsâ€™ usernames).</p><p>Specifcally, we want to start with a list of addresses such as:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "parrot@web.com", "bonnie@pyret.org"]</code></pre><p>and convert it to</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "parrot", "bonnie"]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Consider the list functions we have seen so far (<code data-lang="pyret" class="sourceCode">distinct</code>,
<code data-lang="pyret" class="sourceCode">filter</code>, <code data-lang="pyret" class="sourceCode">length</code>) â€“ are any of them useful for this task?
Can you articulate why?</p></blockquote></blockquote><p>One way to articulate a precise answer to this is think in terms of
the inputs and outputs of the existing functions. Both <code data-lang="pyret" class="sourceCode">filter</code>
and <code data-lang="pyret" class="sourceCode">distinct</code> return a list of elements from the input list, not
transformed elements. <code data-lang="pyret" class="sourceCode">length</code> returns a number, not a list. So
none of these are appropriate.</p><p>This idea of transforming elements is similar to the
<code data-lang="pyret" class="sourceCode">transform-column</code> operation that we previously saw on
tables. The corresponding operation on lists is called
<code data-lang="pyret" class="sourceCode">map</code>. Hereâ€™s an example:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun extract-username(email :: String) -&gt; String:
  doc: "extract the portion of an email address before the @ sign"
  string-split(email, "@").get(0)
where:
  extract-username("bonnie@pyret.org") is "bonnie"
  extract-username("parrot@web.com") is "parrot"
end

L.map(extract-username,
  [list: "parrot@web.com", "bonnie@pyret.org"])</code></pre></section><section class="SsectionLevel5" id="section 5.1.4.6"><h5 class="heading">5.1.4.6Â <a name="(part._lists-recap)"/>Recap: Summary of List Operations<a href="#(part._lists-recap)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>At this point, we have seen several useful built-in functions for
working with lists:</p><ul><li><p><code data-lang="pyret" class="sourceCode">filter :: (A -&gt; Boolean), List&lt;A&gt; -&gt; List&lt;A&gt;</code>, which
produces a list of elements from the input list on which the given
function returns <code data-lang="pyret" class="sourceCode">true</code>.</p></li><li><p><code data-lang="pyret" class="sourceCode">map :: (A -&gt; B), List&lt;A&gt; -&gt; List&lt;B&gt;</code>, which
produces a list of the results of calling the given function on each
element of the input list.</p></li><li><p><code data-lang="pyret" class="sourceCode">distinct :: List&lt;A&gt; -&gt; List&lt;A&gt;</code>, which
produces a list of the unique elements that appear in the input list.</p></li><li><p><code data-lang="pyret" class="sourceCode">length :: List&lt;A&gt; -&gt; Number</code>, which
produces the number of elements in the input list.</p></li></ul><p>Here, a type such as <code data-lang="pyret" class="sourceCode">List&lt;A&gt;</code> says that we have a list whose
elements are of some (unspecified) type which weâ€™ll call
<code data-lang="pyret" class="sourceCode">A</code>. A type variable such as this is useful when we want to
show relationships between two types in a function
contract. Here, the type variable <code data-lang="pyret" class="sourceCode">A</code> captures that the type of
elements is the same in the input and output to <code data-lang="pyret" class="sourceCode">filter</code>. In
<code data-lang="pyret" class="sourceCode">map</code>, however, the type of element in the output list could
differ from that in the input list.</p><p>One additional built-in function that is quite useful in practice is:</p><ul><li><p><code data-lang="pyret" class="sourceCode">member :: List&lt;A&gt;, Any -&gt; Boolean</code>, which
determines whether the given element is in the list. We use the type
<code data-lang="pyret" class="sourceCode">Any</code> when there are no constraints on the type of value provided
to a function.</p></li></ul><p>Many useful computations can be performed by combining these
operations.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Assume you used a list of strings to represent the ingredients in a
recipe. Here are three examples:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">stir-fry =
  [list: "peppers", "pork", "onions", "rice"]
dosa = [list: "rice", "lentils", "potato"]
misir-wot =
  [list: "lentils", "berbere", "tomato"]</code></pre><p>Write the following functions on ingredient lists:</p><ul><li><p><code data-lang="pyret" class="sourceCode">recipes-uses</code>, which takes an ingredient list and an
ingredient and determines whether the recipe uses the ingredient.</p></li><li><p><code data-lang="pyret" class="sourceCode">make-vegetarian</code>, which takes an ingredient list and replaces
all meat ingredients with <code data-lang="pyret" class="sourceCode">"tofu"</code>. Meat ingredients are
<code data-lang="pyret" class="sourceCode">"pork"</code>, <code data-lang="pyret" class="sourceCode">"chicken"</code>, and <code data-lang="pyret" class="sourceCode">"beef"</code>.</p></li><li><p><code data-lang="pyret" class="sourceCode">protein-veg-count</code>, which takes an ingredient list and
determines how many ingredients are in the list that arenâ€™t
<code data-lang="pyret" class="sourceCode">"rice"</code> or <code data-lang="pyret" class="sourceCode">"noodles"</code>.</p></li></ul></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>More challenging: Write a function that takes an
ingredient and a list of ingredient lists and produces a list of all
the lists that contain the given ingredient.</p><p>Hint: write examples first to make sense of the problem as needed.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Even more challenging: Try to write a function that takes two
ingredient lists and
returns all of the ingredients that are common to both lists. What
issue(s) or limitations do you run into?</p><p>Come back to this problem after you finish the next section.</p></blockquote></blockquote></section></section><section class="SsectionLevel4" id="section 5.1.5"><h4 class="heading">5.1.5Â <a name="(part._.Lambda__.Anonymous_.Functions)"/>Lambda: Anonymous Functions<a href="#(part._.Lambda__.Anonymous_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>NOTE: if you already saw <code data-lang="pyret" class="sourceCode">lam</code> in <a href="intro-tabular-data.html#%28part._sec~3alambda-tables%29" data-pltdoc="x">Lambda: Anonymous Functions</a>, feel
free to skip this section, or just do the exercises at the end. Here we present
<code data-lang="pyret" class="sourceCode">lam</code> using lists and <code data-lang="pyret" class="sourceCode">filter</code>, rather than tables and
<code data-lang="pyret" class="sourceCode">filter-with</code>.</p><p>Letâ€™s revisit the program we wrote earlier in this chapter for
finding all of the discount codes that were used in the events table:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun real-code(c :: String) -&gt; Boolean:
  not(c == "none")
end
L.filter(real-code, codes)</code></pre><p>This program might feel a bit verbose: do we really need to write a
helper function just to perform something as simple as a
<code data-lang="pyret" class="sourceCode">filter</code>? Wouldnâ€™t it be easier to just write something like:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.filter(not(c == "none"), codes)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What will Pyret produce if you run this expression?</p></blockquote></blockquote><p>Pyret will produce an <code data-lang="pyret" class="sourceCode">unbound identifier</code> error around the use
of <code data-lang="pyret" class="sourceCode">c</code> in this expression. What is <code data-lang="pyret" class="sourceCode">c</code>? We mean for <code data-lang="pyret" class="sourceCode">c</code>
to be the elements from <code data-lang="pyret" class="sourceCode">codes</code> in turn. Conceptually, thatâ€™s
what <code data-lang="pyret" class="sourceCode">filter</code> does, but we donâ€™t have the mechanics right. When
we call a function, we evaluate the arguments before the body
of the function. Hence, the error regarding <code data-lang="pyret" class="sourceCode">c</code> being unbound.
The whole point of the <code data-lang="pyret" class="sourceCode">real-code</code> helper function is to make
<code data-lang="pyret" class="sourceCode">c</code> a parameter to a function whose body is only evaluated once
a value for <code data-lang="pyret" class="sourceCode">c</code> is available.</p><p>To tighten the notation as in the one-line <code data-lang="pyret" class="sourceCode">filter</code> expression,
then, we have to find a way to tell Pyret to make a temporary function
that will get its inputs once <code data-lang="pyret" class="sourceCode">filter</code> is running. The following
notation achieves this:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.filter(lam(c): not(c == "none") end, codes)</code></pre><p>We have added <code data-lang="pyret" class="sourceCode">lam(c)</code> and <code data-lang="pyret" class="sourceCode">end</code> around the expression that
we want to use in the <code data-lang="pyret" class="sourceCode">filter</code>. The <code data-lang="pyret" class="sourceCode">lam(c)</code> says "make a
temporary function that takes <code data-lang="pyret" class="sourceCode">c</code> as an input". The <code data-lang="pyret" class="sourceCode">end</code>
serves to end the function definition, as when we use
<code data-lang="pyret" class="sourceCode">fun</code>. <code data-lang="pyret" class="sourceCode">lam</code> is short for <code data-lang="pyret" class="sourceCode">lambda</code>, a form of function
definition that exists in many, though not all, languages.</p><p>The main difference between our original expression (using the
<code data-lang="pyret" class="sourceCode">real-code</code> helper) and this new one (using <code data-lang="pyret" class="sourceCode">lam</code>) can be
seen through the program directory. To explain this, a little detail
about how <code data-lang="pyret" class="sourceCode">filter</code> is defined under the hood. In part, it looks
like:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun filter(keep :: (A -&gt; Boolean), lst :: List&lt;A&gt;) -&gt; List&lt;A&gt;:
  if keep(&lt;elt-from-list&gt;):
    ...
  else:
    ...
  end
end</code></pre><p>Whether we pass <code data-lang="pyret" class="sourceCode">real-code</code> or the <code data-lang="pyret" class="sourceCode">lam</code> version to
<code data-lang="pyret" class="sourceCode">filter</code>, the <code data-lang="pyret" class="sourceCode">keep</code> parameter ends up referring to a
function with the same parameter and body. Since the function is only
actually called through the <code data-lang="pyret" class="sourceCode">keep</code> name, it doesnâ€™t matter
whether or not a name is associated with it when it is initially
defined.</p><p>In practice, we use <code data-lang="pyret" class="sourceCode">lam</code> when we have to pass simple (single
line) functions to operations like <code data-lang="pyret" class="sourceCode">filter</code> (or <code data-lang="pyret" class="sourceCode">map</code>). We
could have just as easily used them when we were working with tables
(<code data-lang="pyret" class="sourceCode">build-column</code>, <code data-lang="pyret" class="sourceCode">filter-with</code>, etc). Of course, you can
continue to write out names for helper functions as we did with
<code data-lang="pyret" class="sourceCode">real-code</code> if that makes more sense to you.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write the program to extract the list of usernames from a list of
email addresses using <code data-lang="pyret" class="sourceCode">lam</code> rather than a named helper-function.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Try again to tackle the problem from the end of the
previous section: write a function that takes two ingredient lists and
returns all of the ingredients that are common to both lists.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 5.1.6"><h4 class="heading">5.1.6Â <a name="(part._.Combining_.Lists_and_.Tables)"/>Combining Lists and Tables<a href="#(part._.Combining_.Lists_and_.Tables)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>The table functions we studied previously were primarily for
processing rows. The list functions weâ€™ve learned in this chapter have
been primarily for processing columns (but there are many more uses in
the chapters ahead). If an analysis involves working with only some
rows and some columns, weâ€™ll use a combination of both table and list
functions in our program.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Given the events table, produce a list of names of all people who will
pick up their tickets.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Given the events table, produce the average number of tickets that
were ordered by people with email addresses that end in
<code data-lang="pyret" class="sourceCode">".org"</code>.</p></blockquote></blockquote><p>Sometimes, there will be more than one way to perform a computation:</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Consider a question such as "how many people with <code data-lang="pyret" class="sourceCode">".org"</code> email
addresses bought more than 8 tickets". Propose multiple task plans
that would solve this problem, including which table and list
functions would accomplish each task.</p></blockquote></blockquote><p>There are several options here:</p><ol><li><p>Get the <code data-lang="pyret" class="sourceCode">event-data</code> rows with no more than 8
tickets (using <code data-lang="pyret" class="sourceCode">filter-with</code>), get those rows that have
<code data-lang="pyret" class="sourceCode">".org"</code> addresses (another <code data-lang="pyret" class="sourceCode">filter-with</code>), then ask for how
many rows are in the table (using <code data-lang="pyret" class="sourceCode">&lt;table&gt;.length()</code>).</p></li><li><p>Get the <code data-lang="pyret" class="sourceCode">event-data</code> rows with no more than 8
tickets and <code data-lang="pyret" class="sourceCode">".org"</code> address (using <code data-lang="pyret" class="sourceCode">filter-with</code> with a
function that checks both conditions at once), then ask for how
many rows are in the table (using <code data-lang="pyret" class="sourceCode">&lt;table&gt;.length()</code>).</p></li><li><p>Get the <code data-lang="pyret" class="sourceCode">event-data</code> rows with no more than 8
tickets (using <code data-lang="pyret" class="sourceCode">filter-with</code>), extract the email addresses (using
<code data-lang="pyret" class="sourceCode">get-column</code>), limit those to <code data-lang="pyret" class="sourceCode">".org"</code> (using <code data-lang="pyret" class="sourceCode">L.filter</code>),
then get the length of the resulting list (using <code data-lang="pyret" class="sourceCode">L.length</code>).</p></li></ol><p>There are others, but you get the idea.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Which approach do you like best? Why?</p></blockquote></blockquote><p>While there is no single correct answer, there are various
considerations:</p><ul><li><p>Are any of the intermediate results useful for other computations?
While the second option might seem best because it filters the table
once rather than twice, perhaps the events company has many
computations to perform on larger ticket orders. Similarly, the
company may want the list of email addresses on large orders for
other purposes (the third option)</p></li><li><p>Do you want to follow a discipline of doing operations on
individuals within the table, extracting lists only when needed to
perform aggregating computations that arenâ€™t available on tables?</p></li><li><p>Does one approach seem less resource-intensive than the other?
This is actually a subtle point: you might be tempted to think that
filtering over a table uses more resources than filtering over a list
of values from one column, but this actually isnâ€™t the case. Weâ€™ll
return to this discussion later.</p></li></ul><p>A company or project team sometimes sets design standards to help you
make those decisions. In the absence of that, and especially as you
are learning to program, consider multiple approaches when faced with
such problems, then pick one to implement. Maintaining the ability to
think flexibly about approaches is a useful skill in any form of design.</p><p>Until now weâ€™ve only seen how to use built-in functions over
lists. Next [<a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>], we will study how to create
our own functions that process lists. Once we learn that, these list
processing functions will remain powerful but will no longer seem
quite so magical, because weâ€™ll be able to build them for ourselves!</p></section>&#13;
<h4 class="heading">5.1.1Â <a name="(part._table-stat-qs)"/>Basic Statistical Questions<a href="#(part._table-stat-qs)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>There are many more questions we might want to ask of our events data. For
instance:
</p><ul><li><p>The most-frequently used discount code.</p></li><li><p>The average number of tickets per order.</p></li><li><p>The largest ticket order.</p></li><li><p>The most common number of tickets in an order.</p></li><li><p>The collection of unique discount codes that were used (many
might have been available).</p></li><li><p>The collection of distinct email addresses associated with
orders, so we can contact customers (some customers may have placed
multiple orders).</p></li><li><p>Which school lead to the largest number of orders with a
<code data-lang="pyret" class="sourceCode">"STUDENT"</code> discount.</p></li></ul><p>Notice the kinds of operations that we are talking about: computing
the maximum, minimum, average, median, and other basic
statistics.Pyret has several built-in
statistics functions in the
<a href="http://www.pyret.org/docs/latest/math.html">math</a>
and
<a href="http://www.pyret.org/docs/latest/statistics.html">statistics</a>
packages.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Think about whether and how you would express these questions with the
operations you have already seen.</p></blockquote></blockquote><p>In each of these cases, we need to perform a computation on a single
column of data (even in the last question about the <code data-lang="pyret" class="sourceCode">"STUDENT"</code>
discount, as we would filter the table to those rows, then do a
computation over the <code data-lang="pyret" class="sourceCode">email</code> column). In order to capture these
in code, we need to extract a column from the table.</p><p>For the rest of this chapter, we will work with a cleaned copy of the
<code data-lang="pyret" class="sourceCode">event-data</code> from the previous chapter. The cleaned data, which
applies the transformations at the end of the previous chapter, is in
a different tab of the same Google Sheet as the other versions of the
event data.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">include gdrive-sheets
include data-source

ssid = "1Ks4ll5_8wyYK1zyXMm_21KORhagSMZ59dcr7i3qY6T4"
cleaned-data =
  load-table: name, email, tickcount, discount, delivery, zip
    source: load-spreadsheet(ssid).sheet-by-name("Cleaned", true)
    sanitize name using string-sanitizer
    sanitize email using string-sanitizer
    sanitize tickcount using num-sanitizer
    sanitize discount using string-sanitizer
    sanitize delivery using string-sanitizer
    sanitize zip using string-sanitizer
  end</code></pre>&#13;
<h4 class="heading">5.1.2Â <a name="(part._.Extracting_a_.Column_from_a_.Table)"/>Extracting a Column from a Table<a href="#(part._.Extracting_a_.Column_from_a_.Table)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Our collection of table functions includes one that we havenâ€™t yet
used, called <code data-lang="pyret" class="sourceCode">select-columns</code>. As the name suggests, this
function produces a new table containing only certain columns from an
existing table. Letâ€™s extract the <code data-lang="pyret" class="sourceCode">tickcount</code> column so we can
compute some statistics over it. We use the following expression:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">select-columns(cleaned-data, [list: "tickcount"])</code></pre><p><img src="../Images/218dbd3d076ef24041ce988f1e4f6c1d.png" alt="" width="94" height="295" data-original-src="https://dcic-world.org/2025-08-27/tickcount-column.png"/></p><p>This focuses our attention on the numeric ticket sales, but weâ€™re still stuck
with a column in a table, and none of the other tables
functions let us do the kinds of computations we might want over these
numbers. Ideally, we want the collection of numbers on their own, without being
wrapped up in the extra layer of table cells.</p><p>In principle, we could have a collection of operations on a single
column. In some languages that focus solely on tables, such as
<a href="https://en.wikipedia.org/wiki/SQL">SQL</a>,
this is what youâ€™ll find. However, in Pyret we have many more
kinds of data than just columns (as weâ€™ll soon see [<a href="intro-struct-data.html" data-pltdoc="x">Introduction to Structured Data</a>], we can even
create our own!), so it makes sense to leave the gentle cocoon of
tables sooner or later. An extracted column is a more basic kind of
datum called a list, which can be used to represent a sequence
of data outside of a table.</p><p>Just as we have used the notation <code data-lang="pyret" class="sourceCode">.row-n</code> to pull a single row
from a table, we use a similar dot-based notion to pull out a single
column. Hereâ€™s how we extract the <code data-lang="pyret" class="sourceCode">tickcount</code> column:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cleaned-data.get-column("tickcount")</code></pre><p>In response, Pyret produces the following value:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 2, 1, 5, 0, 3, 10, 3]</code></pre><p>Now, we seem to have only the values that were in the cells in the
column, without the enclosing table. Yet the numbers are still bundled
up, this time in the <code data-lang="pyret" class="sourceCode">[list: ...]</code> notation. What is that?</p>&#13;
<h4 class="heading">5.1.3Â <a name="(part._.Understanding_.Lists)"/>Understanding Lists<a href="#(part._.Understanding_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>A list has much in common with a single-column table:
</p><ul><li><p>The elements have an order, so it makes sense to talk about the
â€œfirstâ€, â€œsecondâ€, â€œlastâ€â€”<wbr/>and so onâ€”<wbr/>element of a list.</p></li><li><p>All elements of a list are expected to have the same type.</p></li></ul><p>The crucial difference is that a list does not have a â€œcolumn nameâ€;
it is anonymous. That is, by itself a list does not describe
what it represents; this interpretation is done by our program.</p><section class="SsectionLevel5" id="section 5.1.3.1"><h5 class="heading">5.1.3.1Â <a name="(part._lists-generic-data)"/>Lists as Anonymous Data<a href="#(part._lists-generic-data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>This might sound rather abstractâ€”<wbr/>and it isâ€”<wbr/>but this isnâ€™t actually
a new idea in our programming experience. Consider a value like
<code data-lang="pyret" class="sourceCode">3</code> or <code data-lang="pyret" class="sourceCode">-1</code>: what is it? Itâ€™s the same sort of thing: an
anonymous value that does not describe what it represents; the
interpretation is done by our program. In one setting <code data-lang="pyret" class="sourceCode">3</code> may
represent an age, in another a play count; in one setting <code data-lang="pyret" class="sourceCode">-1</code>
may be a temperature, in another the average of several
temperatures. Similarly with a string: Is <code data-lang="pyret" class="sourceCode">"project"</code> a noun (an
activity that one or more people perform) or a verb (as when we
display something on a screen)? Likewise with images and so on. In
fact, tables have been the exception so far in having description
built into the data rather than being provided by a program!</p><p>This genericity is both a virtue and a problem. Because, like
other anonymous data, a list does not provide any interpretation of
its use, if we are not careful we can accidentally mis-interpret the
values. On the other hand, it means we can use the same datum in
several different contexts, and one operation can be used in many
settings.</p><p>Indeed, if we look at the list of questions we asked earlier, we see
that there are several common operationsâ€”<wbr/>maximum, minimum, average,
and so onâ€”<wbr/>that can be asked of a list of values without regard for
what the list represents (heights, ages, playcounts). In fact, some
are specific to numbers (like average) while some (like maximum) can
be asked of any type on which we can perform a comparison (like
strings).</p></section><section class="SsectionLevel5" id="section 5.1.3.2"><h5 class="heading">5.1.3.2Â <a name="(part._.Creating_.Literal_.Lists)"/>Creating Literal Lists<a href="#(part._.Creating_.Literal_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>We have already seen how we can create lists from a table, using
<code data-lang="pyret" class="sourceCode">get-column</code>. As you might expect, however, we can also create lists
directly:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]
[list: -1, 5, 2.3, 10]
[list: "a", "b", "c"]
[list: "This", "is", "a", "list", "of", "words"]</code></pre><p>Of course, lists are values so we can name them using variablesâ€”<wbr/>
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shopping-list = [list: "muesli", "fiddleheads"]</code></pre><p>â€”<wbr/>pass them to functions (as we will soon see), and so on.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Based on these examples, can you figure out how to create an empty
list?</p></blockquote></blockquote><p>As you might have guessed, itâ€™s <code data-lang="pyret" class="sourceCode">[list: ]</code> (the space isnâ€™t
necessary, but itâ€™s a useful visual reminder of the void).</p></section>&#13;
<h5 class="heading">5.1.3.1Â <a name="(part._lists-generic-data)"/>Lists as Anonymous Data<a href="#(part._lists-generic-data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>This might sound rather abstractâ€”<wbr/>and it isâ€”<wbr/>but this isnâ€™t actually
a new idea in our programming experience. Consider a value like
<code data-lang="pyret" class="sourceCode">3</code> or <code data-lang="pyret" class="sourceCode">-1</code>: what is it? Itâ€™s the same sort of thing: an
anonymous value that does not describe what it represents; the
interpretation is done by our program. In one setting <code data-lang="pyret" class="sourceCode">3</code> may
represent an age, in another a play count; in one setting <code data-lang="pyret" class="sourceCode">-1</code>
may be a temperature, in another the average of several
temperatures. Similarly with a string: Is <code data-lang="pyret" class="sourceCode">"project"</code> a noun (an
activity that one or more people perform) or a verb (as when we
display something on a screen)? Likewise with images and so on. In
fact, tables have been the exception so far in having description
built into the data rather than being provided by a program!</p><p>This genericity is both a virtue and a problem. Because, like
other anonymous data, a list does not provide any interpretation of
its use, if we are not careful we can accidentally mis-interpret the
values. On the other hand, it means we can use the same datum in
several different contexts, and one operation can be used in many
settings.</p><p>Indeed, if we look at the list of questions we asked earlier, we see
that there are several common operationsâ€”<wbr/>maximum, minimum, average,
and so onâ€”<wbr/>that can be asked of a list of values without regard for
what the list represents (heights, ages, playcounts). In fact, some
are specific to numbers (like average) while some (like maximum) can
be asked of any type on which we can perform a comparison (like
strings).</p>&#13;
<h5 class="heading">5.1.3.2Â <a name="(part._.Creating_.Literal_.Lists)"/>Creating Literal Lists<a href="#(part._.Creating_.Literal_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>We have already seen how we can create lists from a table, using
<code data-lang="pyret" class="sourceCode">get-column</code>. As you might expect, however, we can also create lists
directly:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]
[list: -1, 5, 2.3, 10]
[list: "a", "b", "c"]
[list: "This", "is", "a", "list", "of", "words"]</code></pre><p>Of course, lists are values so we can name them using variablesâ€”<wbr/>
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shopping-list = [list: "muesli", "fiddleheads"]</code></pre><p>â€”<wbr/>pass them to functions (as we will soon see), and so on.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Based on these examples, can you figure out how to create an empty
list?</p></blockquote></blockquote><p>As you might have guessed, itâ€™s <code data-lang="pyret" class="sourceCode">[list: ]</code> (the space isnâ€™t
necessary, but itâ€™s a useful visual reminder of the void).</p>&#13;
<h4 class="heading">5.1.4Â <a name="(part._.Operating_on_.Lists)"/>Operating on Lists<a href="#(part._.Operating_on_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><section class="SsectionLevel5" id="section 5.1.4.1"><h5 class="heading">5.1.4.1Â <a name="(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)"/>Built-In Operations on Lists of Numbers<a href="#(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Pyret handily provides a useful set of operations we can already
perform on lists. The
<a href="https://www.pyret.org/docs/latest/lists.html">lists
documentation</a> describes these operations. As you might have
guessed, we can already compute most of the answers weâ€™ve asked for
at the start of the chapter. First we need to include some libraries that contain useful
functions:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import math as M
import statistics as S</code></pre><p>We can then access several useful functions:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tickcounts = cleaned-data.get-column("tickcount")

M.max(tickcounts)     # largest number in a list
M.sum(tickcounts)     # sum of numbers in a list
S.mean(tickcounts)    # mean (average) of numbers in a list
S.median(tickcounts)  # median of numbers in a list</code></pre><p>The <code data-lang="pyret" class="sourceCode">M.</code> notation means "the function inside the library
<code data-lang="pyret" class="sourceCode">M</code>. The <code data-lang="pyret" class="sourceCode">import</code> statement in the above code gave the name
<code data-lang="pyret" class="sourceCode">M</code> to the <code data-lang="pyret" class="sourceCode">math</code> library.</p></section><section class="SsectionLevel5" id="section 5.1.4.2"><h5 class="heading">5.1.4.2Â <a name="(part._.Built-.In_.Operations_on_.Lists_in_.General)"/>Built-In Operations on Lists in General<a href="#(part._.Built-.In_.Operations_on_.Lists_in_.General)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Some of the useful computations in our list at the start of the
chapter involved the <code data-lang="pyret" class="sourceCode">discount</code> column, which contains strings
rather than numbers. Specifically, letâ€™s consider the following
question:</p><ul><li><p>Compute the collection of unique discount codes that were used (many
might have been available).</p></li></ul><p>None of the table functions handle a question like this. However, this
is a common kind of question to ask about a collection of values (How
many unique artists are in your playlist? How many unique faculty are
teaching courses?). As such, Pyret (as most languages) provides a way
to identify the unique elements of a list. Hereâ€™s how we get the list
of all discount codes that were used in our table:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import lists as L
codes = cleaned-data.get-column("discount")
L.distinct(codes)</code></pre><p>The <code data-lang="pyret" class="sourceCode">distinct</code> function produces a list of the unique values from
the input list: every value in the input list appears exactly once in
the output list. For the above code, Pyret produces:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "BIRTHDAY", "STUDENT", "none"]</code></pre><p>What if we wanted to exclude <code data-lang="pyret" class="sourceCode">"none"</code> from that list? After all,
<code data-lang="pyret" class="sourceCode">"none"</code> isnâ€™t an actual discount code, but rather one that we
introduced while cleaning up the table. Is there a way to easily
remove <code data-lang="pyret" class="sourceCode">"none"</code> from the list?</p><p>There are two ways we could do it. In the Pyret lists documentation,
we find a function called <code data-lang="pyret" class="sourceCode">remove</code>, which removes a specific
element from a list:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.remove(L.distinct(codes), "none")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "BIRTHDAY", "STUDENT"]</code></pre></td></tr></table><p>But this operation should also sound familiar: with tables, we
used <code data-lang="pyret" class="sourceCode">filter-with</code> to keep only those elements that meet a
specific criterion. The filtering idea is so common that Pyret (and
most other languages) provide a similar operation on lists. In the
case of the discount codes, we could also have written:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun real-code(c :: String) -&gt; Boolean:
  not(c == "none")
end
L.filter(real-code, L.distinct(codes))</code></pre><p>The difference between these two approaches is that <code data-lang="pyret" class="sourceCode">filter</code> is
more flexible: we can check any characteristic of a list element using
<code data-lang="pyret" class="sourceCode">filter</code>, but <code data-lang="pyret" class="sourceCode">remove</code> only checks whether the entire
element is equal to the value that we provide. If instead of removing
the specific string <code data-lang="pyret" class="sourceCode">"none"</code>, we had wanted to remove all strings
that were in all-lowercase, we would have needed to use <code data-lang="pyret" class="sourceCode">filter</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function that takes a list of words and removes those words in
which all letters are in lowercase. (Hint: combine
<code data-lang="pyret" class="sourceCode">string-to-lower</code> and <code data-lang="pyret" class="sourceCode">==</code>).</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.1.4.3"><h5 class="heading">5.1.4.3Â <a name="(part._.An_.Aside_on_.Naming_.Conventions)"/>An Aside on Naming Conventions<a href="#(part._.An_.Aside_on_.Naming_.Conventions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Our use of the plural <code data-lang="pyret" class="sourceCode">codes</code> for the list of values in the
column named <code data-lang="pyret" class="sourceCode">discount</code> (singular) is deliberate. A list contains
multiple values, so a plural is appropriate. In a table, in contrast,
we think of a column header as naming a single value that appears in
a specific row. Often, we speak of looking up a value in a specific
row and column: the singular name for the column supports thinking
about lookup in an individual row.</p></section><section class="SsectionLevel5" id="section 5.1.4.4"><h5 class="heading">5.1.4.4Â <a name="(part._.Getting_.Elements_.By_.Position)"/>Getting Elements By Position<a href="#(part._.Getting_.Elements_.By_.Position)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s look at a new analysis question: the events company recently ran
an advertising campaign on <code data-lang="pyret" class="sourceCode">web.com</code>, and they are curious
whether it paid off. To do this, they need to determine how many sales
were made to people with <code data-lang="pyret" class="sourceCode">web.com</code> email addresses.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Propose a task plan (<a href="processing-tables.html#%28part._task-plans%29" data-pltdoc="x">Task Plans</a>) for this computation.</p></blockquote></blockquote><p>Hereâ€™s a proposed plan, annotated with how we might implement each part:</p><ol><li><p>Get the list of email addresses (use <code data-lang="pyret" class="sourceCode">get-column</code>)</p></li><li><p>Extract those that came from <code data-lang="pyret" class="sourceCode">web.com</code> (use <code data-lang="pyret" class="sourceCode">L.filter</code>)</p></li><li><p>Count how many email addresses remain (using <code data-lang="pyret" class="sourceCode">L.length</code>,
which we hadnâ€™t discussed yet, but it is in the documentation)</p></li></ol><p>(As a reminder, unless you immediately see how to solve a problem,
write out a task plan and annotate the parts you know how to do. It
helps break down a programming problem into more manageable parts.)</p><p>Letâ€™s discuss the second task: identifying messages from
<code data-lang="pyret" class="sourceCode">web.com</code>. We know that email addresses are strings, so if we
could determine whether an email string ends in <code data-lang="pyret" class="sourceCode">@web.com</code>,
weâ€™d be set. You could consider doing this by looking at the last 7
characters of the email string. Another option is to use a string
operation that we havenâ€™t yet seen called <code data-lang="pyret" class="sourceCode">string-split-all</code>, which
splits a string into a list of substrings around a given
character. For example:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split-all("this-has-hyphens", "-")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "this", "has", "hyphens"]</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split("bonnie@pyret.org", "@")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "bonnie", "pyret.org"]</code></pre></td></tr></table><p>This seems pretty useful. If we split each email string around the
<code data-lang="pyret" class="sourceCode">@</code> sign, then we can check whether the second string in the
list is <code data-lang="pyret" class="sourceCode">web.com</code> (since email addresses should have only one
<code data-lang="pyret" class="sourceCode">@</code> sign). But how would we get the second element out of
the list produced by <code data-lang="pyret" class="sourceCode">string-split-all</code>? Here we dig into the
list, as we did to extract rows from tables, this time using the
<code data-lang="pyret" class="sourceCode">get</code> operation.</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split("bonnie@pyret.org", "@").get(1)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"pyret.org"</code></pre></td></tr></table><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Why do we use <code data-lang="pyret" class="sourceCode">1</code> as the input to <code data-lang="pyret" class="sourceCode">get</code> if we want the
second item in the list?</p></blockquote></blockquote><p>Hereâ€™s the complete program for doing this check:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun web-com-address(email :: String) -&gt; Boolean:
  doc: "determine whether email is from web.com"
  string-split(email, "@").get(1) == "web.com"
where:
  web-com-address("bonnie@pyret.org") is false
  web-com-address("parrot@web.com") is true
end

emails = cleaned-data.get-column("email")
L.length(L.filter(web-com-address, emails))</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>What happens if there is a malformed email address string that doesnâ€™t
contain the <code data-lang="pyret" class="sourceCode">@</code> string? What would happen? What could you do
about that?</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.1.4.5"><h5 class="heading">5.1.4.5Â <a name="(part._.Transforming_.Lists)"/>Transforming Lists<a href="#(part._.Transforming_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Imagine now that we had a list of email addresses, but instead just
wanted a list of usernames. This doesnâ€™t make sense for our event
data, but it does make sense in other contexts (such as connecting
messages to folders organized by studentsâ€™ usernames).</p><p>Specifcally, we want to start with a list of addresses such as:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "parrot@web.com", "bonnie@pyret.org"]</code></pre><p>and convert it to</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "parrot", "bonnie"]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Consider the list functions we have seen so far (<code data-lang="pyret" class="sourceCode">distinct</code>,
<code data-lang="pyret" class="sourceCode">filter</code>, <code data-lang="pyret" class="sourceCode">length</code>) â€“ are any of them useful for this task?
Can you articulate why?</p></blockquote></blockquote><p>One way to articulate a precise answer to this is think in terms of
the inputs and outputs of the existing functions. Both <code data-lang="pyret" class="sourceCode">filter</code>
and <code data-lang="pyret" class="sourceCode">distinct</code> return a list of elements from the input list, not
transformed elements. <code data-lang="pyret" class="sourceCode">length</code> returns a number, not a list. So
none of these are appropriate.</p><p>This idea of transforming elements is similar to the
<code data-lang="pyret" class="sourceCode">transform-column</code> operation that we previously saw on
tables. The corresponding operation on lists is called
<code data-lang="pyret" class="sourceCode">map</code>. Hereâ€™s an example:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun extract-username(email :: String) -&gt; String:
  doc: "extract the portion of an email address before the @ sign"
  string-split(email, "@").get(0)
where:
  extract-username("bonnie@pyret.org") is "bonnie"
  extract-username("parrot@web.com") is "parrot"
end

L.map(extract-username,
  [list: "parrot@web.com", "bonnie@pyret.org"])</code></pre></section><section class="SsectionLevel5" id="section 5.1.4.6"><h5 class="heading">5.1.4.6Â <a name="(part._lists-recap)"/>Recap: Summary of List Operations<a href="#(part._lists-recap)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>At this point, we have seen several useful built-in functions for
working with lists:</p><ul><li><p><code data-lang="pyret" class="sourceCode">filter :: (A -&gt; Boolean), List&lt;A&gt; -&gt; List&lt;A&gt;</code>, which
produces a list of elements from the input list on which the given
function returns <code data-lang="pyret" class="sourceCode">true</code>.</p></li><li><p><code data-lang="pyret" class="sourceCode">map :: (A -&gt; B), List&lt;A&gt; -&gt; List&lt;B&gt;</code>, which
produces a list of the results of calling the given function on each
element of the input list.</p></li><li><p><code data-lang="pyret" class="sourceCode">distinct :: List&lt;A&gt; -&gt; List&lt;A&gt;</code>, which
produces a list of the unique elements that appear in the input list.</p></li><li><p><code data-lang="pyret" class="sourceCode">length :: List&lt;A&gt; -&gt; Number</code>, which
produces the number of elements in the input list.</p></li></ul><p>Here, a type such as <code data-lang="pyret" class="sourceCode">List&lt;A&gt;</code> says that we have a list whose
elements are of some (unspecified) type which weâ€™ll call
<code data-lang="pyret" class="sourceCode">A</code>. A type variable such as this is useful when we want to
show relationships between two types in a function
contract. Here, the type variable <code data-lang="pyret" class="sourceCode">A</code> captures that the type of
elements is the same in the input and output to <code data-lang="pyret" class="sourceCode">filter</code>. In
<code data-lang="pyret" class="sourceCode">map</code>, however, the type of element in the output list could
differ from that in the input list.</p><p>One additional built-in function that is quite useful in practice is:</p><ul><li><p><code data-lang="pyret" class="sourceCode">member :: List&lt;A&gt;, Any -&gt; Boolean</code>, which
determines whether the given element is in the list. We use the type
<code data-lang="pyret" class="sourceCode">Any</code> when there are no constraints on the type of value provided
to a function.</p></li></ul><p>Many useful computations can be performed by combining these
operations.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Assume you used a list of strings to represent the ingredients in a
recipe. Here are three examples:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">stir-fry =
  [list: "peppers", "pork", "onions", "rice"]
dosa = [list: "rice", "lentils", "potato"]
misir-wot =
  [list: "lentils", "berbere", "tomato"]</code></pre><p>Write the following functions on ingredient lists:</p><ul><li><p><code data-lang="pyret" class="sourceCode">recipes-uses</code>, which takes an ingredient list and an
ingredient and determines whether the recipe uses the ingredient.</p></li><li><p><code data-lang="pyret" class="sourceCode">make-vegetarian</code>, which takes an ingredient list and replaces
all meat ingredients with <code data-lang="pyret" class="sourceCode">"tofu"</code>. Meat ingredients are
<code data-lang="pyret" class="sourceCode">"pork"</code>, <code data-lang="pyret" class="sourceCode">"chicken"</code>, and <code data-lang="pyret" class="sourceCode">"beef"</code>.</p></li><li><p><code data-lang="pyret" class="sourceCode">protein-veg-count</code>, which takes an ingredient list and
determines how many ingredients are in the list that arenâ€™t
<code data-lang="pyret" class="sourceCode">"rice"</code> or <code data-lang="pyret" class="sourceCode">"noodles"</code>.</p></li></ul></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>More challenging: Write a function that takes an
ingredient and a list of ingredient lists and produces a list of all
the lists that contain the given ingredient.</p><p>Hint: write examples first to make sense of the problem as needed.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Even more challenging: Try to write a function that takes two
ingredient lists and
returns all of the ingredients that are common to both lists. What
issue(s) or limitations do you run into?</p><p>Come back to this problem after you finish the next section.</p></blockquote></blockquote></section>&#13;
<h5 class="heading">5.1.4.1Â <a name="(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)"/>Built-In Operations on Lists of Numbers<a href="#(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Pyret handily provides a useful set of operations we can already
perform on lists. The
<a href="https://www.pyret.org/docs/latest/lists.html">lists
documentation</a> describes these operations. As you might have
guessed, we can already compute most of the answers weâ€™ve asked for
at the start of the chapter. First we need to include some libraries that contain useful
functions:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import math as M
import statistics as S</code></pre><p>We can then access several useful functions:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tickcounts = cleaned-data.get-column("tickcount")

M.max(tickcounts)     # largest number in a list
M.sum(tickcounts)     # sum of numbers in a list
S.mean(tickcounts)    # mean (average) of numbers in a list
S.median(tickcounts)  # median of numbers in a list</code></pre><p>The <code data-lang="pyret" class="sourceCode">M.</code> notation means "the function inside the library
<code data-lang="pyret" class="sourceCode">M</code>. The <code data-lang="pyret" class="sourceCode">import</code> statement in the above code gave the name
<code data-lang="pyret" class="sourceCode">M</code> to the <code data-lang="pyret" class="sourceCode">math</code> library.</p>&#13;
<h5 class="heading">5.1.4.2Â <a name="(part._.Built-.In_.Operations_on_.Lists_in_.General)"/>Built-In Operations on Lists in General<a href="#(part._.Built-.In_.Operations_on_.Lists_in_.General)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Some of the useful computations in our list at the start of the
chapter involved the <code data-lang="pyret" class="sourceCode">discount</code> column, which contains strings
rather than numbers. Specifically, letâ€™s consider the following
question:</p><ul><li><p>Compute the collection of unique discount codes that were used (many
might have been available).</p></li></ul><p>None of the table functions handle a question like this. However, this
is a common kind of question to ask about a collection of values (How
many unique artists are in your playlist? How many unique faculty are
teaching courses?). As such, Pyret (as most languages) provides a way
to identify the unique elements of a list. Hereâ€™s how we get the list
of all discount codes that were used in our table:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import lists as L
codes = cleaned-data.get-column("discount")
L.distinct(codes)</code></pre><p>The <code data-lang="pyret" class="sourceCode">distinct</code> function produces a list of the unique values from
the input list: every value in the input list appears exactly once in
the output list. For the above code, Pyret produces:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "BIRTHDAY", "STUDENT", "none"]</code></pre><p>What if we wanted to exclude <code data-lang="pyret" class="sourceCode">"none"</code> from that list? After all,
<code data-lang="pyret" class="sourceCode">"none"</code> isnâ€™t an actual discount code, but rather one that we
introduced while cleaning up the table. Is there a way to easily
remove <code data-lang="pyret" class="sourceCode">"none"</code> from the list?</p><p>There are two ways we could do it. In the Pyret lists documentation,
we find a function called <code data-lang="pyret" class="sourceCode">remove</code>, which removes a specific
element from a list:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.remove(L.distinct(codes), "none")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "BIRTHDAY", "STUDENT"]</code></pre></td></tr></table><p>But this operation should also sound familiar: with tables, we
used <code data-lang="pyret" class="sourceCode">filter-with</code> to keep only those elements that meet a
specific criterion. The filtering idea is so common that Pyret (and
most other languages) provide a similar operation on lists. In the
case of the discount codes, we could also have written:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun real-code(c :: String) -&gt; Boolean:
  not(c == "none")
end
L.filter(real-code, L.distinct(codes))</code></pre><p>The difference between these two approaches is that <code data-lang="pyret" class="sourceCode">filter</code> is
more flexible: we can check any characteristic of a list element using
<code data-lang="pyret" class="sourceCode">filter</code>, but <code data-lang="pyret" class="sourceCode">remove</code> only checks whether the entire
element is equal to the value that we provide. If instead of removing
the specific string <code data-lang="pyret" class="sourceCode">"none"</code>, we had wanted to remove all strings
that were in all-lowercase, we would have needed to use <code data-lang="pyret" class="sourceCode">filter</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function that takes a list of words and removes those words in
which all letters are in lowercase. (Hint: combine
<code data-lang="pyret" class="sourceCode">string-to-lower</code> and <code data-lang="pyret" class="sourceCode">==</code>).</p></blockquote></blockquote>&#13;
<h5 class="heading">5.1.4.3Â <a name="(part._.An_.Aside_on_.Naming_.Conventions)"/>An Aside on Naming Conventions<a href="#(part._.An_.Aside_on_.Naming_.Conventions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Our use of the plural <code data-lang="pyret" class="sourceCode">codes</code> for the list of values in the
column named <code data-lang="pyret" class="sourceCode">discount</code> (singular) is deliberate. A list contains
multiple values, so a plural is appropriate. In a table, in contrast,
we think of a column header as naming a single value that appears in
a specific row. Often, we speak of looking up a value in a specific
row and column: the singular name for the column supports thinking
about lookup in an individual row.</p>&#13;
<h5 class="heading">5.1.4.4Â <a name="(part._.Getting_.Elements_.By_.Position)"/>Getting Elements By Position<a href="#(part._.Getting_.Elements_.By_.Position)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s look at a new analysis question: the events company recently ran
an advertising campaign on <code data-lang="pyret" class="sourceCode">web.com</code>, and they are curious
whether it paid off. To do this, they need to determine how many sales
were made to people with <code data-lang="pyret" class="sourceCode">web.com</code> email addresses.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Propose a task plan (<a href="processing-tables.html#%28part._task-plans%29" data-pltdoc="x">Task Plans</a>) for this computation.</p></blockquote></blockquote><p>Hereâ€™s a proposed plan, annotated with how we might implement each part:</p><ol><li><p>Get the list of email addresses (use <code data-lang="pyret" class="sourceCode">get-column</code>)</p></li><li><p>Extract those that came from <code data-lang="pyret" class="sourceCode">web.com</code> (use <code data-lang="pyret" class="sourceCode">L.filter</code>)</p></li><li><p>Count how many email addresses remain (using <code data-lang="pyret" class="sourceCode">L.length</code>,
which we hadnâ€™t discussed yet, but it is in the documentation)</p></li></ol><p>(As a reminder, unless you immediately see how to solve a problem,
write out a task plan and annotate the parts you know how to do. It
helps break down a programming problem into more manageable parts.)</p><p>Letâ€™s discuss the second task: identifying messages from
<code data-lang="pyret" class="sourceCode">web.com</code>. We know that email addresses are strings, so if we
could determine whether an email string ends in <code data-lang="pyret" class="sourceCode">@web.com</code>,
weâ€™d be set. You could consider doing this by looking at the last 7
characters of the email string. Another option is to use a string
operation that we havenâ€™t yet seen called <code data-lang="pyret" class="sourceCode">string-split-all</code>, which
splits a string into a list of substrings around a given
character. For example:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split-all("this-has-hyphens", "-")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "this", "has", "hyphens"]</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split("bonnie@pyret.org", "@")</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "bonnie", "pyret.org"]</code></pre></td></tr></table><p>This seems pretty useful. If we split each email string around the
<code data-lang="pyret" class="sourceCode">@</code> sign, then we can check whether the second string in the
list is <code data-lang="pyret" class="sourceCode">web.com</code> (since email addresses should have only one
<code data-lang="pyret" class="sourceCode">@</code> sign). But how would we get the second element out of
the list produced by <code data-lang="pyret" class="sourceCode">string-split-all</code>? Here we dig into the
list, as we did to extract rows from tables, this time using the
<code data-lang="pyret" class="sourceCode">get</code> operation.</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split("bonnie@pyret.org", "@").get(1)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"pyret.org"</code></pre></td></tr></table><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Why do we use <code data-lang="pyret" class="sourceCode">1</code> as the input to <code data-lang="pyret" class="sourceCode">get</code> if we want the
second item in the list?</p></blockquote></blockquote><p>Hereâ€™s the complete program for doing this check:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun web-com-address(email :: String) -&gt; Boolean:
  doc: "determine whether email is from web.com"
  string-split(email, "@").get(1) == "web.com"
where:
  web-com-address("bonnie@pyret.org") is false
  web-com-address("parrot@web.com") is true
end

emails = cleaned-data.get-column("email")
L.length(L.filter(web-com-address, emails))</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>What happens if there is a malformed email address string that doesnâ€™t
contain the <code data-lang="pyret" class="sourceCode">@</code> string? What would happen? What could you do
about that?</p></blockquote></blockquote>&#13;
<h5 class="heading">5.1.4.5Â <a name="(part._.Transforming_.Lists)"/>Transforming Lists<a href="#(part._.Transforming_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Imagine now that we had a list of email addresses, but instead just
wanted a list of usernames. This doesnâ€™t make sense for our event
data, but it does make sense in other contexts (such as connecting
messages to folders organized by studentsâ€™ usernames).</p><p>Specifcally, we want to start with a list of addresses such as:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "parrot@web.com", "bonnie@pyret.org"]</code></pre><p>and convert it to</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "parrot", "bonnie"]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Consider the list functions we have seen so far (<code data-lang="pyret" class="sourceCode">distinct</code>,
<code data-lang="pyret" class="sourceCode">filter</code>, <code data-lang="pyret" class="sourceCode">length</code>) â€“ are any of them useful for this task?
Can you articulate why?</p></blockquote></blockquote><p>One way to articulate a precise answer to this is think in terms of
the inputs and outputs of the existing functions. Both <code data-lang="pyret" class="sourceCode">filter</code>
and <code data-lang="pyret" class="sourceCode">distinct</code> return a list of elements from the input list, not
transformed elements. <code data-lang="pyret" class="sourceCode">length</code> returns a number, not a list. So
none of these are appropriate.</p><p>This idea of transforming elements is similar to the
<code data-lang="pyret" class="sourceCode">transform-column</code> operation that we previously saw on
tables. The corresponding operation on lists is called
<code data-lang="pyret" class="sourceCode">map</code>. Hereâ€™s an example:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun extract-username(email :: String) -&gt; String:
  doc: "extract the portion of an email address before the @ sign"
  string-split(email, "@").get(0)
where:
  extract-username("bonnie@pyret.org") is "bonnie"
  extract-username("parrot@web.com") is "parrot"
end

L.map(extract-username,
  [list: "parrot@web.com", "bonnie@pyret.org"])</code></pre>&#13;
<h5 class="heading">5.1.4.6Â <a name="(part._lists-recap)"/>Recap: Summary of List Operations<a href="#(part._lists-recap)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>At this point, we have seen several useful built-in functions for
working with lists:</p><ul><li><p><code data-lang="pyret" class="sourceCode">filter :: (A -&gt; Boolean), List&lt;A&gt; -&gt; List&lt;A&gt;</code>, which
produces a list of elements from the input list on which the given
function returns <code data-lang="pyret" class="sourceCode">true</code>.</p></li><li><p><code data-lang="pyret" class="sourceCode">map :: (A -&gt; B), List&lt;A&gt; -&gt; List&lt;B&gt;</code>, which
produces a list of the results of calling the given function on each
element of the input list.</p></li><li><p><code data-lang="pyret" class="sourceCode">distinct :: List&lt;A&gt; -&gt; List&lt;A&gt;</code>, which
produces a list of the unique elements that appear in the input list.</p></li><li><p><code data-lang="pyret" class="sourceCode">length :: List&lt;A&gt; -&gt; Number</code>, which
produces the number of elements in the input list.</p></li></ul><p>Here, a type such as <code data-lang="pyret" class="sourceCode">List&lt;A&gt;</code> says that we have a list whose
elements are of some (unspecified) type which weâ€™ll call
<code data-lang="pyret" class="sourceCode">A</code>. A type variable such as this is useful when we want to
show relationships between two types in a function
contract. Here, the type variable <code data-lang="pyret" class="sourceCode">A</code> captures that the type of
elements is the same in the input and output to <code data-lang="pyret" class="sourceCode">filter</code>. In
<code data-lang="pyret" class="sourceCode">map</code>, however, the type of element in the output list could
differ from that in the input list.</p><p>One additional built-in function that is quite useful in practice is:</p><ul><li><p><code data-lang="pyret" class="sourceCode">member :: List&lt;A&gt;, Any -&gt; Boolean</code>, which
determines whether the given element is in the list. We use the type
<code data-lang="pyret" class="sourceCode">Any</code> when there are no constraints on the type of value provided
to a function.</p></li></ul><p>Many useful computations can be performed by combining these
operations.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Assume you used a list of strings to represent the ingredients in a
recipe. Here are three examples:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">stir-fry =
  [list: "peppers", "pork", "onions", "rice"]
dosa = [list: "rice", "lentils", "potato"]
misir-wot =
  [list: "lentils", "berbere", "tomato"]</code></pre><p>Write the following functions on ingredient lists:</p><ul><li><p><code data-lang="pyret" class="sourceCode">recipes-uses</code>, which takes an ingredient list and an
ingredient and determines whether the recipe uses the ingredient.</p></li><li><p><code data-lang="pyret" class="sourceCode">make-vegetarian</code>, which takes an ingredient list and replaces
all meat ingredients with <code data-lang="pyret" class="sourceCode">"tofu"</code>. Meat ingredients are
<code data-lang="pyret" class="sourceCode">"pork"</code>, <code data-lang="pyret" class="sourceCode">"chicken"</code>, and <code data-lang="pyret" class="sourceCode">"beef"</code>.</p></li><li><p><code data-lang="pyret" class="sourceCode">protein-veg-count</code>, which takes an ingredient list and
determines how many ingredients are in the list that arenâ€™t
<code data-lang="pyret" class="sourceCode">"rice"</code> or <code data-lang="pyret" class="sourceCode">"noodles"</code>.</p></li></ul></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>More challenging: Write a function that takes an
ingredient and a list of ingredient lists and produces a list of all
the lists that contain the given ingredient.</p><p>Hint: write examples first to make sense of the problem as needed.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Even more challenging: Try to write a function that takes two
ingredient lists and
returns all of the ingredients that are common to both lists. What
issue(s) or limitations do you run into?</p><p>Come back to this problem after you finish the next section.</p></blockquote></blockquote>&#13;
<h4 class="heading">5.1.5Â <a name="(part._.Lambda__.Anonymous_.Functions)"/>Lambda: Anonymous Functions<a href="#(part._.Lambda__.Anonymous_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>NOTE: if you already saw <code data-lang="pyret" class="sourceCode">lam</code> in <a href="intro-tabular-data.html#%28part._sec~3alambda-tables%29" data-pltdoc="x">Lambda: Anonymous Functions</a>, feel
free to skip this section, or just do the exercises at the end. Here we present
<code data-lang="pyret" class="sourceCode">lam</code> using lists and <code data-lang="pyret" class="sourceCode">filter</code>, rather than tables and
<code data-lang="pyret" class="sourceCode">filter-with</code>.</p><p>Letâ€™s revisit the program we wrote earlier in this chapter for
finding all of the discount codes that were used in the events table:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun real-code(c :: String) -&gt; Boolean:
  not(c == "none")
end
L.filter(real-code, codes)</code></pre><p>This program might feel a bit verbose: do we really need to write a
helper function just to perform something as simple as a
<code data-lang="pyret" class="sourceCode">filter</code>? Wouldnâ€™t it be easier to just write something like:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.filter(not(c == "none"), codes)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What will Pyret produce if you run this expression?</p></blockquote></blockquote><p>Pyret will produce an <code data-lang="pyret" class="sourceCode">unbound identifier</code> error around the use
of <code data-lang="pyret" class="sourceCode">c</code> in this expression. What is <code data-lang="pyret" class="sourceCode">c</code>? We mean for <code data-lang="pyret" class="sourceCode">c</code>
to be the elements from <code data-lang="pyret" class="sourceCode">codes</code> in turn. Conceptually, thatâ€™s
what <code data-lang="pyret" class="sourceCode">filter</code> does, but we donâ€™t have the mechanics right. When
we call a function, we evaluate the arguments before the body
of the function. Hence, the error regarding <code data-lang="pyret" class="sourceCode">c</code> being unbound.
The whole point of the <code data-lang="pyret" class="sourceCode">real-code</code> helper function is to make
<code data-lang="pyret" class="sourceCode">c</code> a parameter to a function whose body is only evaluated once
a value for <code data-lang="pyret" class="sourceCode">c</code> is available.</p><p>To tighten the notation as in the one-line <code data-lang="pyret" class="sourceCode">filter</code> expression,
then, we have to find a way to tell Pyret to make a temporary function
that will get its inputs once <code data-lang="pyret" class="sourceCode">filter</code> is running. The following
notation achieves this:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.filter(lam(c): not(c == "none") end, codes)</code></pre><p>We have added <code data-lang="pyret" class="sourceCode">lam(c)</code> and <code data-lang="pyret" class="sourceCode">end</code> around the expression that
we want to use in the <code data-lang="pyret" class="sourceCode">filter</code>. The <code data-lang="pyret" class="sourceCode">lam(c)</code> says "make a
temporary function that takes <code data-lang="pyret" class="sourceCode">c</code> as an input". The <code data-lang="pyret" class="sourceCode">end</code>
serves to end the function definition, as when we use
<code data-lang="pyret" class="sourceCode">fun</code>. <code data-lang="pyret" class="sourceCode">lam</code> is short for <code data-lang="pyret" class="sourceCode">lambda</code>, a form of function
definition that exists in many, though not all, languages.</p><p>The main difference between our original expression (using the
<code data-lang="pyret" class="sourceCode">real-code</code> helper) and this new one (using <code data-lang="pyret" class="sourceCode">lam</code>) can be
seen through the program directory. To explain this, a little detail
about how <code data-lang="pyret" class="sourceCode">filter</code> is defined under the hood. In part, it looks
like:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun filter(keep :: (A -&gt; Boolean), lst :: List&lt;A&gt;) -&gt; List&lt;A&gt;:
  if keep(&lt;elt-from-list&gt;):
    ...
  else:
    ...
  end
end</code></pre><p>Whether we pass <code data-lang="pyret" class="sourceCode">real-code</code> or the <code data-lang="pyret" class="sourceCode">lam</code> version to
<code data-lang="pyret" class="sourceCode">filter</code>, the <code data-lang="pyret" class="sourceCode">keep</code> parameter ends up referring to a
function with the same parameter and body. Since the function is only
actually called through the <code data-lang="pyret" class="sourceCode">keep</code> name, it doesnâ€™t matter
whether or not a name is associated with it when it is initially
defined.</p><p>In practice, we use <code data-lang="pyret" class="sourceCode">lam</code> when we have to pass simple (single
line) functions to operations like <code data-lang="pyret" class="sourceCode">filter</code> (or <code data-lang="pyret" class="sourceCode">map</code>). We
could have just as easily used them when we were working with tables
(<code data-lang="pyret" class="sourceCode">build-column</code>, <code data-lang="pyret" class="sourceCode">filter-with</code>, etc). Of course, you can
continue to write out names for helper functions as we did with
<code data-lang="pyret" class="sourceCode">real-code</code> if that makes more sense to you.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write the program to extract the list of usernames from a list of
email addresses using <code data-lang="pyret" class="sourceCode">lam</code> rather than a named helper-function.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Try again to tackle the problem from the end of the
previous section: write a function that takes two ingredient lists and
returns all of the ingredients that are common to both lists.</p></blockquote></blockquote>&#13;
<h4 class="heading">5.1.6Â <a name="(part._.Combining_.Lists_and_.Tables)"/>Combining Lists and Tables<a href="#(part._.Combining_.Lists_and_.Tables)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>The table functions we studied previously were primarily for
processing rows. The list functions weâ€™ve learned in this chapter have
been primarily for processing columns (but there are many more uses in
the chapters ahead). If an analysis involves working with only some
rows and some columns, weâ€™ll use a combination of both table and list
functions in our program.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Given the events table, produce a list of names of all people who will
pick up their tickets.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Given the events table, produce the average number of tickets that
were ordered by people with email addresses that end in
<code data-lang="pyret" class="sourceCode">".org"</code>.</p></blockquote></blockquote><p>Sometimes, there will be more than one way to perform a computation:</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Consider a question such as "how many people with <code data-lang="pyret" class="sourceCode">".org"</code> email
addresses bought more than 8 tickets". Propose multiple task plans
that would solve this problem, including which table and list
functions would accomplish each task.</p></blockquote></blockquote><p>There are several options here:</p><ol><li><p>Get the <code data-lang="pyret" class="sourceCode">event-data</code> rows with no more than 8
tickets (using <code data-lang="pyret" class="sourceCode">filter-with</code>), get those rows that have
<code data-lang="pyret" class="sourceCode">".org"</code> addresses (another <code data-lang="pyret" class="sourceCode">filter-with</code>), then ask for how
many rows are in the table (using <code data-lang="pyret" class="sourceCode">&lt;table&gt;.length()</code>).</p></li><li><p>Get the <code data-lang="pyret" class="sourceCode">event-data</code> rows with no more than 8
tickets and <code data-lang="pyret" class="sourceCode">".org"</code> address (using <code data-lang="pyret" class="sourceCode">filter-with</code> with a
function that checks both conditions at once), then ask for how
many rows are in the table (using <code data-lang="pyret" class="sourceCode">&lt;table&gt;.length()</code>).</p></li><li><p>Get the <code data-lang="pyret" class="sourceCode">event-data</code> rows with no more than 8
tickets (using <code data-lang="pyret" class="sourceCode">filter-with</code>), extract the email addresses (using
<code data-lang="pyret" class="sourceCode">get-column</code>), limit those to <code data-lang="pyret" class="sourceCode">".org"</code> (using <code data-lang="pyret" class="sourceCode">L.filter</code>),
then get the length of the resulting list (using <code data-lang="pyret" class="sourceCode">L.length</code>).</p></li></ol><p>There are others, but you get the idea.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Which approach do you like best? Why?</p></blockquote></blockquote><p>While there is no single correct answer, there are various
considerations:</p><ul><li><p>Are any of the intermediate results useful for other computations?
While the second option might seem best because it filters the table
once rather than twice, perhaps the events company has many
computations to perform on larger ticket orders. Similarly, the
company may want the list of email addresses on large orders for
other purposes (the third option)</p></li><li><p>Do you want to follow a discipline of doing operations on
individuals within the table, extracting lists only when needed to
perform aggregating computations that arenâ€™t available on tables?</p></li><li><p>Does one approach seem less resource-intensive than the other?
This is actually a subtle point: you might be tempted to think that
filtering over a table uses more resources than filtering over a list
of values from one column, but this actually isnâ€™t the case. Weâ€™ll
return to this discussion later.</p></li></ul><p>A company or project team sometimes sets design standards to help you
make those decisions. In the absence of that, and especially as you
are learning to program, consider multiple approaches when faced with
such problems, then pick one to implement. Maintaining the ability to
think flexibly about approaches is a useful skill in any form of design.</p><p>Until now weâ€™ve only seen how to use built-in functions over
lists. Next [<a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>], we will study how to create
our own functions that process lists. Once we learn that, these list
processing functions will remain powerful but will no longer seem
quite so magical, because weâ€™ll be able to build them for ourselves!</p>    
</body>
</html>