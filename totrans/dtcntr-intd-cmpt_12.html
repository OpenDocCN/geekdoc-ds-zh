<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>5.1Â From Tables to ListsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>5.1Â From Tables to ListsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/tables-to-lists.html">https://dcic-world.org/2025-08-27/tables-to-lists.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._table-stat-qs%29" class="toclink" data-pltdoc="x">5.1.1<span class="hspace">Â </span>Basic Statistical Questions</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Extracting_a_.Column_from_a_.Table%29" class="toclink" data-pltdoc="x">5.1.2<span class="hspace">Â </span>Extracting a Column from a Table</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Understanding_.Lists%29" class="toclink" data-pltdoc="x">5.1.3<span class="hspace">Â </span>Understanding Lists</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._lists-generic-data%29" class="toclink" data-pltdoc="x">5.1.3.1<span class="hspace">Â </span>Lists as Anonymous Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Creating_.Literal_.Lists%29" class="toclink" data-pltdoc="x">5.1.3.2<span class="hspace">Â </span>Creating Literal Lists</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Operating_on_.Lists%29" class="toclink" data-pltdoc="x">5.1.4<span class="hspace">Â </span>Operating on Lists</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Built-.In_.Operations_on_.Lists_of_.Numbers%29" class="toclink" data-pltdoc="x">5.1.4.1<span class="hspace">Â </span>Built-In Operations on Lists of Numbers</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Built-.In_.Operations_on_.Lists_in_.General%29" class="toclink" data-pltdoc="x">5.1.4.2<span class="hspace">Â </span>Built-In Operations on Lists in General</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.An_.Aside_on_.Naming_.Conventions%29" class="toclink" data-pltdoc="x">5.1.4.3<span class="hspace">Â </span>An Aside on Naming Conventions</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Getting_.Elements_.By_.Position%29" class="toclink" data-pltdoc="x">5.1.4.4<span class="hspace">Â </span>Getting Elements By Position</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Transforming_.Lists%29" class="toclink" data-pltdoc="x">5.1.4.5<span class="hspace">Â </span>Transforming Lists</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._lists-recap%29" class="toclink" data-pltdoc="x">5.1.4.6<span class="hspace">Â </span>Recap: Summary of List Operations</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Lambda__.Anonymous_.Functions%29" class="toclink" data-pltdoc="x">5.1.5<span class="hspace">Â </span>Lambda: Anonymous Functions</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Combining_.Lists_and_.Tables%29" class="toclink" data-pltdoc="x">5.1.6<span class="hspace">Â </span>Combining Lists and Tables</a></p></td></tr></table><p>Previously [<a href="intro-tabular-data.html" data-pltdoc="x">Introduction to Tabular Data</a>] we began to process
collective data in the form of tables. Though we saw
several powerful operations that let us quickly and easily ask
sophisticated questions about our data, they all had two things in
common. First, all were operations <span class="emph">by rows</span>. None of the operations
asked questions about an entire column at a time. Second, all the
operations not only consumed but also produced tables. However, we
already know [<a href="getting-started.html" data-pltdoc="x">Getting Started</a>] there are many other kinds
of data, and sometimes we will want to compute one of them. We will
now see how to achieve both of these things, introducing an important
new type of data in the process.</p><section class="SsectionLevel4" id="section 5.1.1"><h4 class="heading">5.1.1<span class="stt">Â </span><a name="(part._table-stat-qs)"/>Basic Statistical Questions<span class="button-group"><a href="#(part._table-stat-qs)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">There are many more questions we might want to ask of our events data. For
instance:
</div><div class="SIntrapara"><ul><li><p>The most-frequently used discount code.</p></li><li><p>The average number of tickets per order.</p></li><li><p>The largest ticket order.</p></li><li><p>The most common number of tickets in an order.</p></li><li><p>The collection of unique discount codes that were used (many
might have been available).</p></li><li><p>The collection of distinct email addresses associated with
orders, so we can contact customers (some customers may have placed
multiple orders).</p></li><li><p>Which school lead to the largest number of orders with a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"STUDENT"</code></span> discount.</p></li></ul></div><div class="SIntrapara">Notice the kinds of operations that we are talking about: computing
the maximum, minimum, average, median, and other basic
statistics.<span class="refelem"><span class="refcolumn"><span class="refcontent">Pyret has several built-in
statistics functions in the
<a href="http://www.pyret.org/docs/latest/math.html">math</a>
and
<a href="http://www.pyret.org/docs/latest/statistics.html">statistics</a>
packages.</span></span></span></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Think about whether and how you would express these questions with the
operations you have already seen.</p></blockquote></blockquote><p>In each of these cases, we need to perform a <span class="emph">computation on a single
column of data</span> (even in the last question about the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"STUDENT"</code></span>
discount, as we would filter the table to those rows, then do a
computation over the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">email</code></span> column). In order to capture these
in code, we need to extract a column from the table.</p><p>For the rest of this chapter, we will work with a cleaned copy of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">event-data</code></span> from the previous chapter. The cleaned data, which
applies the transformations at the end of the previous chapter, is in
a different tab of the same Google Sheet as the other versions of the
event data.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">include gdrive-sheets
include data-source

ssid = "1Ks4ll5_8wyYK1zyXMm_21KORhagSMZ59dcr7i3qY6T4"
cleaned-data =
  load-table: name, email, tickcount, discount, delivery, zip
    source: load-spreadsheet(ssid).sheet-by-name("Cleaned", true)
    sanitize name using string-sanitizer
    sanitize email using string-sanitizer
    sanitize tickcount using num-sanitizer
    sanitize discount using string-sanitizer
    sanitize delivery using string-sanitizer
    sanitize zip using string-sanitizer
  end</code></pre></div></div></section><section class="SsectionLevel4" id="section 5.1.2"><h4 class="heading">5.1.2<span class="stt">Â </span><a name="(part._.Extracting_a_.Column_from_a_.Table)"/>Extracting a Column from a Table<span class="button-group"><a href="#(part._.Extracting_a_.Column_from_a_.Table)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Our collection of table functions includes one that we havenâ€™t yet
used, called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">select-columns</code></span>. As the name suggests, this
function produces a new table containing only certain columns from an
existing table. Letâ€™s extract the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tickcount</code></span> column so we can
compute some statistics over it. We use the following expression:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">select-columns(cleaned-data, [list: "tickcount"])</code></pre></div></div><p><img src="../Images/218dbd3d076ef24041ce988f1e4f6c1d.png" alt="" width="94" height="295" data-original-src="https://dcic-world.org/2025-08-27/tickcount-column.png"/></p><p>This focuses our attention on the numeric ticket sales, but weâ€™re still stuck
with a column <span class="emph">in a table</span>, and none of the other tables
functions let us do the kinds of computations we might want over these
numbers. Ideally, we want the collection of numbers on their own, without being
wrapped up in the extra layer of table cells.</p><p>In principle, we could have a collection of operations on a single
column. In some languages that focus solely on tables, such as
<a href="https://en.wikipedia.org/wiki/SQL">SQL</a>,
this is what youâ€™ll find. However, in Pyret we have many more
kinds of data than just columns (as weâ€™ll soon see [<a href="intro-struct-data.html" data-pltdoc="x">Introduction to Structured Data</a>], we can even
create our own!), so it makes sense to leave the gentle cocoon of
tables sooner or later. An extracted column is a more basic kind of
datum called a <span style="font-style: italic">list</span>, which can be used to represent a sequence
of data outside of a table.</p><p>Just as we have used the notation <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.row-n</code></span> to pull a single row
from a table, we use a similar dot-based notion to pull out a single
column. Hereâ€™s how we extract the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tickcount</code></span> column:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cleaned-data.get-column("tickcount")</code></pre></div></div><p>In response, Pyret produces the following value:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 2, 1, 5, 0, 3, 10, 3]</code></pre></div></div><p>Now, we seem to have only the values that were in the cells in the
column, without the enclosing table. Yet the numbers are still bundled
up, this time in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ...]</code></span> notation. What is that?</p></section><section class="SsectionLevel4" id="section 5.1.3"><h4 class="heading">5.1.3<span class="stt">Â </span><a name="(part._.Understanding_.Lists)"/>Understanding Lists<span class="button-group"><a href="#(part._.Understanding_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">A list has much in common with a single-column table:
</div><div class="SIntrapara"><ul><li><p>The elements have an order, so it makes sense to talk about the
â€œfirstâ€, â€œsecondâ€, â€œlastâ€â€”<wbr/>and so onâ€”<wbr/>element of a list.</p></li><li><p>All elements of a list are expected to have the same type.</p></li></ul></div><div class="SIntrapara">The crucial difference is that a list does not have a â€œcolumn nameâ€;
it is <span style="font-style: italic">anonymous</span>. That is, by itself a list does not describe
what it represents; this interpretation is done by our program.</div><section class="SsectionLevel5" id="section 5.1.3.1"><h5 class="heading">5.1.3.1<span class="stt">Â </span><a name="(part._lists-generic-data)"/>Lists as Anonymous Data<span class="button-group"><a href="#(part._lists-generic-data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>This might sound rather abstractâ€”<wbr/>and it isâ€”<wbr/>but this isnâ€™t actually
a new idea in our programming experience. Consider a value like
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-1</code></span>: what is it? Itâ€™s the same sort of thing: an
anonymous value that does not describe what it represents; the
interpretation is done by our program. In one setting <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> may
represent an age, in another a play count; in one setting <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-1</code></span>
may be a temperature, in another the average of several
temperatures. Similarly with a string: Is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"project"</code></span> a noun (an
activity that one or more people perform) or a verb (as when we
display something on a screen)? Likewise with images and so on. In
fact, tables have been the exception so far in having description
built into the data rather than being provided by a program!</p><p>This <span style="font-style: italic">genericity</span> is both a virtue and a problem. Because, like
other anonymous data, a list does not provide any interpretation of
its use, if we are not careful we can accidentally mis-interpret the
values. On the other hand, it means we can use the same datum in
several different contexts, and one operation can be used in many
settings.</p><p>Indeed, if we look at the list of questions we asked earlier, we see
that there are several common operationsâ€”<wbr/>maximum, minimum, average,
and so onâ€”<wbr/>that can be asked of a list of values without regard for
what the list represents (heights, ages, playcounts). In fact, some
are specific to numbers (like average) while some (like maximum) can
be asked of any type on which we can perform a comparison (like
strings).</p></section><section class="SsectionLevel5" id="section 5.1.3.2"><h5 class="heading">5.1.3.2<span class="stt">Â </span><a name="(part._.Creating_.Literal_.Lists)"/>Creating Literal Lists<span class="button-group"><a href="#(part._.Creating_.Literal_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">We have already seen how we can create lists from a table, using
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">get-column</code></span>. As you might expect, however, we can also create lists
directly:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]
[list: -1, 5, 2.3, 10]
[list: "a", "b", "c"]
[list: "This", "is", "a", "list", "of", "words"]</code></pre></div></div></div><div class="SIntrapara">Of course, lists are values so we can name them using variablesâ€”<wbr/>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shopping-list = [list: "muesli", "fiddleheads"]</code></pre></div></div></div><div class="SIntrapara">â€”<wbr/>pass them to functions (as we will soon see), and so on.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Based on these examples, can you figure out how to create an empty
list?</p></blockquote></blockquote><p>As you might have guessed, itâ€™s <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ]</code></span> (the space isnâ€™t
necessary, but itâ€™s a useful visual reminder of the void).</p></section></section><section class="SsectionLevel4" id="section 5.1.4"><h4 class="heading">5.1.4<span class="stt">Â </span><a name="(part._.Operating_on_.Lists)"/>Operating on Lists<span class="button-group"><a href="#(part._.Operating_on_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><section class="SsectionLevel5" id="section 5.1.4.1"><h5 class="heading">5.1.4.1<span class="stt">Â </span><a name="(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)"/>Built-In Operations on Lists of Numbers<span class="button-group"><a href="#(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Pyret handily provides a useful set of operations we can already
perform on lists. <span class="refelem"><span class="refcolumn"><span class="refcontent">The
<a href="https://www.pyret.org/docs/latest/lists.html">lists
documentation</a> describes these operations.</span></span></span> As you might have
guessed, we can already compute most of the answers weâ€™ve asked for
at the start of the chapter. First we need to include some libraries that contain useful
functions:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import math as M
import statistics as S</code></pre></div></div></div><div class="SIntrapara">We can then access several useful functions:</div><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tickcounts = cleaned-data.get-column("tickcount")

M.max(tickcounts)     # largest number in a list
M.sum(tickcounts)     # sum of numbers in a list
S.mean(tickcounts)    # mean (average) of numbers in a list
S.median(tickcounts)  # median of numbers in a list</code></pre></div></div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">M.</code></span> notation means "the function inside the library
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">M</code></span>. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import</code></span> statement in the above code gave the name
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">M</code></span> to the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">math</code></span> library.</p></section><section class="SsectionLevel5" id="section 5.1.4.2"><h5 class="heading">5.1.4.2<span class="stt">Â </span><a name="(part._.Built-.In_.Operations_on_.Lists_in_.General)"/>Built-In Operations on Lists in General<span class="button-group"><a href="#(part._.Built-.In_.Operations_on_.Lists_in_.General)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Some of the useful computations in our list at the start of the
chapter involved the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">discount</code></span> column, which contains strings
rather than numbers. Specifically, letâ€™s consider the following
question:</p><ul><li><p>Compute the collection of unique discount codes that were used (many
might have been available).</p></li></ul><p>None of the table functions handle a question like this. However, this
is a common kind of question to ask about a collection of values (How
many unique artists are in your playlist? How many unique faculty are
teaching courses?). As such, Pyret (as most languages) provides a way
to identify the unique elements of a list. Hereâ€™s how we get the list
of all discount codes that were used in our table:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import lists as L
codes = cleaned-data.get-column("discount")
L.distinct(codes)</code></pre></div></div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distinct</code></span> function produces a list of the unique values from
the input list: every value in the input list appears exactly once in
the output list. For the above code, Pyret produces:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "BIRTHDAY", "STUDENT", "none"]</code></pre></div></div><p>What if we wanted to exclude <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"none"</code></span> from that list? After all,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"none"</code></span> isnâ€™t an actual discount code, but rather one that we
introduced while cleaning up the table. Is there a way to easily
remove <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"none"</code></span> from the list?</p><p>There are two ways we could do it. In the Pyret lists documentation,
we find a function called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">remove</code></span>, which removes a specific
element from a list:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.remove(L.distinct(codes), "none")</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "BIRTHDAY", "STUDENT"]</code></pre></div></div></td></tr></table><p>But this operation should also sound familiar: with tables, we
used <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> to keep only those elements that meet a
specific criterion. The filtering idea is so common that Pyret (and
most other languages) provide a similar operation on lists. In the
case of the discount codes, we could also have written:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun real-code(c :: String) -&gt; Boolean:
  not(c == "none")
end
L.filter(real-code, L.distinct(codes))</code></pre></div></div><p>The difference between these two approaches is that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span> is
more flexible: we can check any characteristic of a list element using
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>, but <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">remove</code></span> only checks whether the entire
element is equal to the value that we provide. If instead of removing
the specific string <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"none"</code></span>, we had wanted to remove all strings
that were in all-lowercase, we would have needed to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function that takes a list of words and removes those words in
which all letters are in lowercase. (Hint: combine
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-to-lower</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span>).</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.1.4.3"><h5 class="heading">5.1.4.3<span class="stt">Â </span><a name="(part._.An_.Aside_on_.Naming_.Conventions)"/>An Aside on Naming Conventions<span class="button-group"><a href="#(part._.An_.Aside_on_.Naming_.Conventions)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Our use of the plural <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">codes</code></span> for the list of values in the
column named <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">discount</code></span> (singular) is deliberate. A list contains
multiple values, so a plural is appropriate. In a table, in contrast,
we think of a column header as naming a single value that appears in
a specific row. Often, we speak of looking up a value in a specific
row and column: the singular name for the column supports thinking
about lookup in an individual row.</p></section><section class="SsectionLevel5" id="section 5.1.4.4"><h5 class="heading">5.1.4.4<span class="stt">Â </span><a name="(part._.Getting_.Elements_.By_.Position)"/>Getting Elements By Position<span class="button-group"><a href="#(part._.Getting_.Elements_.By_.Position)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Letâ€™s look at a new analysis question: the events company recently ran
an advertising campaign on <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web.com</code></span>, and they are curious
whether it paid off. To do this, they need to determine how many sales
were made to people with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web.com</code></span> email addresses.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Propose a task plan (<a href="processing-tables.html#%28part._task-plans%29" data-pltdoc="x">Task Plans</a>) for this computation.</p></blockquote></blockquote><p>Hereâ€™s a proposed plan, annotated with how we might implement each part:</p><ol><li><p>Get the list of email addresses (use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">get-column</code></span>)</p></li><li><p>Extract those that came from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web.com</code></span> (use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.filter</code></span>)</p></li><li><p>Count how many email addresses remain (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.length</code></span>,
which we hadnâ€™t discussed yet, but it is in the documentation)</p></li></ol><p>(As a reminder, unless you immediately see how to solve a problem,
write out a task plan and annotate the parts you know how to do. It
helps break down a programming problem into more manageable parts.)</p><p>Letâ€™s discuss the second task: identifying messages from
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web.com</code></span>. We know that email addresses are strings, so if we
could determine whether an email string ends in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">@web.com</code></span>,
weâ€™d be set. You could consider doing this by looking at the last 7
characters of the email string. Another option is to use a string
operation that we havenâ€™t yet seen called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split-all</code></span>, which
splits a string into a list of substrings around a given
character. For example:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split-all("this-has-hyphens", "-")</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "this", "has", "hyphens"]</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split("bonnie@pyret.org", "@")</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "bonnie", "pyret.org"]</code></pre></div></div></td></tr></table></div><p>This seems pretty useful. If we split each email string around the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">@</code></span> sign, then we can check whether the second string in the
list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web.com</code></span> (since email addresses should have only one
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">@</code></span> sign). But how would we get the second element out of
the list produced by <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split-all</code></span>? Here we dig into the
list, as we did to extract rows from tables, this time using the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">get</code></span> operation.</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split("bonnie@pyret.org", "@").get(1)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"pyret.org"</code></pre></div></div></td></tr></table><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Why do we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> as the input to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">get</code></span> if we want the
second item in the list?</p></blockquote></blockquote><p>Hereâ€™s the complete program for doing this check:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun web-com-address(email :: String) -&gt; Boolean:
  doc: "determine whether email is from web.com"
  string-split(email, "@").get(1) == "web.com"
where:
  web-com-address("bonnie@pyret.org") is false
  web-com-address("parrot@web.com") is true
end

emails = cleaned-data.get-column("email")
L.length(L.filter(web-com-address, emails))</code></pre></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>What happens if there is a malformed email address string that doesnâ€™t
contain the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">@</code></span> string? What would happen? What could you do
about that?</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.1.4.5"><h5 class="heading">5.1.4.5<span class="stt">Â </span><a name="(part._.Transforming_.Lists)"/>Transforming Lists<span class="button-group"><a href="#(part._.Transforming_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Imagine now that we had a list of email addresses, but instead just
wanted a list of usernames. This doesnâ€™t make sense for our event
data, but it does make sense in other contexts (such as connecting
messages to folders organized by studentsâ€™ usernames).</p><p>Specifcally, we want to start with a list of addresses such as:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "parrot@web.com", "bonnie@pyret.org"]</code></pre></div></div><p>and convert it to</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "parrot", "bonnie"]</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Consider the list functions we have seen so far (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distinct</code></span>,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length</code></span>) â€“ are any of them useful for this task?
Can you articulate why?</p></blockquote></blockquote><p>One way to articulate a precise answer to this is think in terms of
the inputs and outputs of the existing functions. Both <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distinct</code></span> return a list of elements from the input list, not
transformed elements. <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length</code></span> returns a number, not a list. So
none of these are appropriate.</p><p>This idea of transforming elements is similar to the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">transform-column</code></span> operation that we previously saw on
tables. The corresponding operation on lists is called
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>. Hereâ€™s an example:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun extract-username(email :: String) -&gt; String:
  doc: "extract the portion of an email address before the @ sign"
  string-split(email, "@").get(0)
where:
  extract-username("bonnie@pyret.org") is "bonnie"
  extract-username("parrot@web.com") is "parrot"
end

L.map(extract-username,
  [list: "parrot@web.com", "bonnie@pyret.org"])</code></pre></div></div></section><section class="SsectionLevel5" id="section 5.1.4.6"><h5 class="heading">5.1.4.6<span class="stt">Â </span><a name="(part._lists-recap)"/>Recap: Summary of List Operations<span class="button-group"><a href="#(part._lists-recap)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>At this point, we have seen several useful built-in functions for
working with lists:</p><ul><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter :: (A -&gt; Boolean), List&lt;A&gt; -&gt; List&lt;A&gt;</code></span>, which
produces a list of elements from the input list on which the given
function returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map :: (A -&gt; B), List&lt;A&gt; -&gt; List&lt;B&gt;</code></span>, which
produces a list of the results of calling the given function on each
element of the input list.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distinct :: List&lt;A&gt; -&gt; List&lt;A&gt;</code></span>, which
produces a list of the unique elements that appear in the input list.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length :: List&lt;A&gt; -&gt; Number</code></span>, which
produces the number of elements in the input list.</p></li></ul><p>Here, a type such as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">List&lt;A&gt;</code></span> says that we have a list whose
elements are of some (unspecified) type which weâ€™ll call
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">A</code></span>. A <span style="font-style: italic">type variable</span> such as this is useful when we want to
show <span class="emph">relationships</span> between two types in a function
contract. Here, the type variable <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">A</code></span> captures that the type of
elements is the same in the input and output to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>. In
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>, however, the type of element in the output list could
differ from that in the input list.</p><p>One additional built-in function that is quite useful in practice is:</p><ul><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member :: List&lt;A&gt;, Any -&gt; Boolean</code></span>, which
determines whether the given element is in the list. We use the type
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Any</code></span> when there are no constraints on the type of value provided
to a function.</p></li></ul><p>Many useful computations can be performed by combining these
operations.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Assume you used a list of strings to represent the ingredients in a
recipe. Here are three examples:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">stir-fry =
  [list: "peppers", "pork", "onions", "rice"]
dosa = [list: "rice", "lentils", "potato"]
misir-wot =
  [list: "lentils", "berbere", "tomato"]</code></pre></div></div><p>Write the following functions on ingredient lists:</p><ul><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">recipes-uses</code></span>, which takes an ingredient list and an
ingredient and determines whether the recipe uses the ingredient.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">make-vegetarian</code></span>, which takes an ingredient list and replaces
all meat ingredients with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"tofu"</code></span>. Meat ingredients are
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"pork"</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"chicken"</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"beef"</code></span>.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">protein-veg-count</code></span>, which takes an ingredient list and
determines how many ingredients are in the list that arenâ€™t
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"rice"</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"noodles"</code></span>.</p></li></ul></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>More challenging: Write a function that takes an
ingredient and a list of ingredient lists and produces a list of all
the lists that contain the given ingredient.</p><p><span class="emph">Hint: write examples first to make sense of the problem as needed.</span></p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Even more challenging: Try to write a function that takes two
ingredient lists and
returns all of the ingredients that are common to both lists. What
issue(s) or limitations do you run into?</p><p>Come back to this problem after you finish the next section.</p></blockquote></blockquote></section></section><section class="SsectionLevel4" id="section 5.1.5"><h4 class="heading">5.1.5<span class="stt">Â </span><a name="(part._.Lambda__.Anonymous_.Functions)"/>Lambda: Anonymous Functions<span class="button-group"><a href="#(part._.Lambda__.Anonymous_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><span class="emph">NOTE: if you already saw <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> in <a href="intro-tabular-data.html#%28part._sec~3alambda-tables%29" data-pltdoc="x">Lambda: Anonymous Functions</a>, feel
free to skip this section, or just do the exercises at the end. Here we present
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> using lists and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>, rather than tables and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>.</span></p><p>Letâ€™s revisit the program we wrote earlier in this chapter for
finding all of the discount codes that were used in the events table:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun real-code(c :: String) -&gt; Boolean:
  not(c == "none")
end
L.filter(real-code, codes)</code></pre></div></div><p>This program might feel a bit verbose: do we really need to write a
helper function just to perform something as simple as a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>? Wouldnâ€™t it be easier to just write something like:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.filter(not(c == "none"), codes)</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What will Pyret produce if you run this expression?</p></blockquote></blockquote><p>Pyret will produce an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">unbound identifier</code></span> error around the use
of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c</code></span> in this expression. What is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c</code></span>? We mean for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c</code></span>
to be the elements from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">codes</code></span> in turn. Conceptually, thatâ€™s
what <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span> does, but we donâ€™t have the mechanics right. When
we call a function, we evaluate the arguments <span class="emph">before</span> the body
of the function. Hence, the error regarding <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c</code></span> being unbound.
The whole point of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">real-code</code></span> helper function is to make
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c</code></span> a parameter to a function whose body is only evaluated once
a value for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c</code></span> is available.</p><p>To tighten the notation as in the one-line <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span> expression,
then, we have to find a way to tell Pyret to make a temporary function
that will get its inputs once <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span> is running. The following
notation achieves this:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.filter(lam(c): not(c == "none") end, codes)</code></pre></div></div><p>We have added <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam(c)</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span> around the expression that
we want to use in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam(c)</code></span> says "make a
temporary function that takes <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c</code></span> as an input". The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span>
serves to end the function definition, as when we use
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun</code></span>. <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> is short for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lambda</code></span>, a form of function
definition that exists in many, though not all, languages.</p><p>The main difference between our original expression (using the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">real-code</code></span> helper) and this new one (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span>) can be
seen through the program directory. To explain this, a little detail
about how <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span> is defined under the hood. In part, it looks
like:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun filter(keep :: (A -&gt; Boolean), lst :: List&lt;A&gt;) -&gt; List&lt;A&gt;:
  if keep(&lt;elt-from-list&gt;):
    ...
  else:
    ...
  end
end</code></pre></div></div><p>Whether we pass <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">real-code</code></span> or the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> version to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>, the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">keep</code></span> parameter ends up referring to a
function with the same parameter and body. Since the function is only
actually called through the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">keep</code></span> name, it doesnâ€™t matter
whether or not a name is associated with it when it is initially
defined.</p><p>In practice, we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> when we have to pass simple (single
line) functions to operations like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span> (or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>). We
could have just as easily used them when we were working with tables
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">build-column</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>, etc). Of course, you can
continue to write out names for helper functions as we did with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">real-code</code></span> if that makes more sense to you.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write the program to extract the list of usernames from a list of
email addresses using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> rather than a named helper-function.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Try again to tackle the problem from the end of the
previous section: write a function that takes two ingredient lists and
returns all of the ingredients that are common to both lists.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 5.1.6"><h4 class="heading">5.1.6<span class="stt">Â </span><a name="(part._.Combining_.Lists_and_.Tables)"/>Combining Lists and Tables<span class="button-group"><a href="#(part._.Combining_.Lists_and_.Tables)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The table functions we studied previously were primarily for
processing rows. The list functions weâ€™ve learned in this chapter have
been primarily for processing columns (but there are many more uses in
the chapters ahead). If an analysis involves working with only some
rows and some columns, weâ€™ll use a combination of both table and list
functions in our program.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Given the events table, produce a list of names of all people who will
pick up their tickets.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Given the events table, produce the average number of tickets that
were ordered by people with email addresses that end in
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">".org"</code></span>.</p></blockquote></blockquote><p>Sometimes, there will be more than one way to perform a computation:</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Consider a question such as "how many people with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">".org"</code></span> email
addresses bought more than 8 tickets". Propose multiple task plans
that would solve this problem, including which table and list
functions would accomplish each task.</p></blockquote></blockquote><p>There are several options here:</p><ol><li><p>Get the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">event-data</code></span> rows with no more than 8
tickets (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>), get those rows that have
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">".org"</code></span> addresses (another <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>), then ask for how
many rows are in the table (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;table&gt;.length()</code></span>).</p></li><li><p>Get the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">event-data</code></span> rows with no more than 8
tickets and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">".org"</code></span> address (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> with a
function that checks both conditions at once), then ask for how
many rows are in the table (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;table&gt;.length()</code></span>).</p></li><li><p>Get the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">event-data</code></span> rows with no more than 8
tickets (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>), extract the email addresses (using
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">get-column</code></span>), limit those to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">".org"</code></span> (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.filter</code></span>),
then get the length of the resulting list (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.length</code></span>).</p></li></ol><p>There are others, but you get the idea.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Which approach do you like best? Why?</p></blockquote></blockquote><p>While there is no single correct answer, there are various
considerations:</p><ul><li><p>Are any of the intermediate results useful for other computations?
While the second option might seem best because it filters the table
once rather than twice, perhaps the events company has many
computations to perform on larger ticket orders. Similarly, the
company may want the list of email addresses on large orders for
other purposes (the third option)</p></li><li><p>Do you want to follow a discipline of doing operations on
individuals within the table, extracting lists only when needed to
perform aggregating computations that arenâ€™t available on tables?</p></li><li><p>Does one approach seem less resource-intensive than the other?
This is actually a subtle point: you might be tempted to think that
filtering over a table uses more resources than filtering over a list
of values from one column, but this actually isnâ€™t the case. Weâ€™ll
return to this discussion later.</p></li></ul><p>A company or project team sometimes sets design standards to help you
make those decisions. In the absence of that, and especially as you
are learning to program, consider multiple approaches when faced with
such problems, then pick one to implement. Maintaining the ability to
think flexibly about approaches is a useful skill in any form of design.</p><p>Until now weâ€™ve only seen how to use built-in functions over
lists. Next [<a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>], we will study how to create
our own functions that process lists. Once we learn that, these list
processing functions will remain powerful but will no longer seem
quite so magical, because weâ€™ll be able to build them for ourselves!</p></section>&#13;
<h4 class="heading">5.1.1<span class="stt">Â </span><a name="(part._table-stat-qs)"/>Basic Statistical Questions<span class="button-group"><a href="#(part._table-stat-qs)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">There are many more questions we might want to ask of our events data. For
instance:
</div><div class="SIntrapara"><ul><li><p>The most-frequently used discount code.</p></li><li><p>The average number of tickets per order.</p></li><li><p>The largest ticket order.</p></li><li><p>The most common number of tickets in an order.</p></li><li><p>The collection of unique discount codes that were used (many
might have been available).</p></li><li><p>The collection of distinct email addresses associated with
orders, so we can contact customers (some customers may have placed
multiple orders).</p></li><li><p>Which school lead to the largest number of orders with a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"STUDENT"</code></span> discount.</p></li></ul></div><div class="SIntrapara">Notice the kinds of operations that we are talking about: computing
the maximum, minimum, average, median, and other basic
statistics.<span class="refelem"><span class="refcolumn"><span class="refcontent">Pyret has several built-in
statistics functions in the
<a href="http://www.pyret.org/docs/latest/math.html">math</a>
and
<a href="http://www.pyret.org/docs/latest/statistics.html">statistics</a>
packages.</span></span></span></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Think about whether and how you would express these questions with the
operations you have already seen.</p></blockquote></blockquote><p>In each of these cases, we need to perform a <span class="emph">computation on a single
column of data</span> (even in the last question about the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"STUDENT"</code></span>
discount, as we would filter the table to those rows, then do a
computation over the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">email</code></span> column). In order to capture these
in code, we need to extract a column from the table.</p><p>For the rest of this chapter, we will work with a cleaned copy of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">event-data</code></span> from the previous chapter. The cleaned data, which
applies the transformations at the end of the previous chapter, is in
a different tab of the same Google Sheet as the other versions of the
event data.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">include gdrive-sheets
include data-source

ssid = "1Ks4ll5_8wyYK1zyXMm_21KORhagSMZ59dcr7i3qY6T4"
cleaned-data =
  load-table: name, email, tickcount, discount, delivery, zip
    source: load-spreadsheet(ssid).sheet-by-name("Cleaned", true)
    sanitize name using string-sanitizer
    sanitize email using string-sanitizer
    sanitize tickcount using num-sanitizer
    sanitize discount using string-sanitizer
    sanitize delivery using string-sanitizer
    sanitize zip using string-sanitizer
  end</code></pre></div></div>&#13;
<h4 class="heading">5.1.2<span class="stt">Â </span><a name="(part._.Extracting_a_.Column_from_a_.Table)"/>Extracting a Column from a Table<span class="button-group"><a href="#(part._.Extracting_a_.Column_from_a_.Table)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Our collection of table functions includes one that we havenâ€™t yet
used, called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">select-columns</code></span>. As the name suggests, this
function produces a new table containing only certain columns from an
existing table. Letâ€™s extract the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tickcount</code></span> column so we can
compute some statistics over it. We use the following expression:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">select-columns(cleaned-data, [list: "tickcount"])</code></pre></div></div><p><img src="../Images/218dbd3d076ef24041ce988f1e4f6c1d.png" alt="" width="94" height="295" data-original-src="https://dcic-world.org/2025-08-27/tickcount-column.png"/></p><p>This focuses our attention on the numeric ticket sales, but weâ€™re still stuck
with a column <span class="emph">in a table</span>, and none of the other tables
functions let us do the kinds of computations we might want over these
numbers. Ideally, we want the collection of numbers on their own, without being
wrapped up in the extra layer of table cells.</p><p>In principle, we could have a collection of operations on a single
column. In some languages that focus solely on tables, such as
<a href="https://en.wikipedia.org/wiki/SQL">SQL</a>,
this is what youâ€™ll find. However, in Pyret we have many more
kinds of data than just columns (as weâ€™ll soon see [<a href="intro-struct-data.html" data-pltdoc="x">Introduction to Structured Data</a>], we can even
create our own!), so it makes sense to leave the gentle cocoon of
tables sooner or later. An extracted column is a more basic kind of
datum called a <span style="font-style: italic">list</span>, which can be used to represent a sequence
of data outside of a table.</p><p>Just as we have used the notation <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.row-n</code></span> to pull a single row
from a table, we use a similar dot-based notion to pull out a single
column. Hereâ€™s how we extract the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tickcount</code></span> column:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cleaned-data.get-column("tickcount")</code></pre></div></div><p>In response, Pyret produces the following value:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 2, 1, 5, 0, 3, 10, 3]</code></pre></div></div><p>Now, we seem to have only the values that were in the cells in the
column, without the enclosing table. Yet the numbers are still bundled
up, this time in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ...]</code></span> notation. What is that?</p>&#13;
<h4 class="heading">5.1.3<span class="stt">Â </span><a name="(part._.Understanding_.Lists)"/>Understanding Lists<span class="button-group"><a href="#(part._.Understanding_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">A list has much in common with a single-column table:
</div><div class="SIntrapara"><ul><li><p>The elements have an order, so it makes sense to talk about the
â€œfirstâ€, â€œsecondâ€, â€œlastâ€â€”<wbr/>and so onâ€”<wbr/>element of a list.</p></li><li><p>All elements of a list are expected to have the same type.</p></li></ul></div><div class="SIntrapara">The crucial difference is that a list does not have a â€œcolumn nameâ€;
it is <span style="font-style: italic">anonymous</span>. That is, by itself a list does not describe
what it represents; this interpretation is done by our program.</div><section class="SsectionLevel5" id="section 5.1.3.1"><h5 class="heading">5.1.3.1<span class="stt">Â </span><a name="(part._lists-generic-data)"/>Lists as Anonymous Data<span class="button-group"><a href="#(part._lists-generic-data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>This might sound rather abstractâ€”<wbr/>and it isâ€”<wbr/>but this isnâ€™t actually
a new idea in our programming experience. Consider a value like
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-1</code></span>: what is it? Itâ€™s the same sort of thing: an
anonymous value that does not describe what it represents; the
interpretation is done by our program. In one setting <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> may
represent an age, in another a play count; in one setting <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-1</code></span>
may be a temperature, in another the average of several
temperatures. Similarly with a string: Is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"project"</code></span> a noun (an
activity that one or more people perform) or a verb (as when we
display something on a screen)? Likewise with images and so on. In
fact, tables have been the exception so far in having description
built into the data rather than being provided by a program!</p><p>This <span style="font-style: italic">genericity</span> is both a virtue and a problem. Because, like
other anonymous data, a list does not provide any interpretation of
its use, if we are not careful we can accidentally mis-interpret the
values. On the other hand, it means we can use the same datum in
several different contexts, and one operation can be used in many
settings.</p><p>Indeed, if we look at the list of questions we asked earlier, we see
that there are several common operationsâ€”<wbr/>maximum, minimum, average,
and so onâ€”<wbr/>that can be asked of a list of values without regard for
what the list represents (heights, ages, playcounts). In fact, some
are specific to numbers (like average) while some (like maximum) can
be asked of any type on which we can perform a comparison (like
strings).</p></section><section class="SsectionLevel5" id="section 5.1.3.2"><h5 class="heading">5.1.3.2<span class="stt">Â </span><a name="(part._.Creating_.Literal_.Lists)"/>Creating Literal Lists<span class="button-group"><a href="#(part._.Creating_.Literal_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">We have already seen how we can create lists from a table, using
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">get-column</code></span>. As you might expect, however, we can also create lists
directly:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]
[list: -1, 5, 2.3, 10]
[list: "a", "b", "c"]
[list: "This", "is", "a", "list", "of", "words"]</code></pre></div></div></div><div class="SIntrapara">Of course, lists are values so we can name them using variablesâ€”<wbr/>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shopping-list = [list: "muesli", "fiddleheads"]</code></pre></div></div></div><div class="SIntrapara">â€”<wbr/>pass them to functions (as we will soon see), and so on.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Based on these examples, can you figure out how to create an empty
list?</p></blockquote></blockquote><p>As you might have guessed, itâ€™s <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ]</code></span> (the space isnâ€™t
necessary, but itâ€™s a useful visual reminder of the void).</p></section>&#13;
<h5 class="heading">5.1.3.1<span class="stt">Â </span><a name="(part._lists-generic-data)"/>Lists as Anonymous Data<span class="button-group"><a href="#(part._lists-generic-data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>This might sound rather abstractâ€”<wbr/>and it isâ€”<wbr/>but this isnâ€™t actually
a new idea in our programming experience. Consider a value like
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-1</code></span>: what is it? Itâ€™s the same sort of thing: an
anonymous value that does not describe what it represents; the
interpretation is done by our program. In one setting <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> may
represent an age, in another a play count; in one setting <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-1</code></span>
may be a temperature, in another the average of several
temperatures. Similarly with a string: Is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"project"</code></span> a noun (an
activity that one or more people perform) or a verb (as when we
display something on a screen)? Likewise with images and so on. In
fact, tables have been the exception so far in having description
built into the data rather than being provided by a program!</p><p>This <span style="font-style: italic">genericity</span> is both a virtue and a problem. Because, like
other anonymous data, a list does not provide any interpretation of
its use, if we are not careful we can accidentally mis-interpret the
values. On the other hand, it means we can use the same datum in
several different contexts, and one operation can be used in many
settings.</p><p>Indeed, if we look at the list of questions we asked earlier, we see
that there are several common operationsâ€”<wbr/>maximum, minimum, average,
and so onâ€”<wbr/>that can be asked of a list of values without regard for
what the list represents (heights, ages, playcounts). In fact, some
are specific to numbers (like average) while some (like maximum) can
be asked of any type on which we can perform a comparison (like
strings).</p>&#13;
<h5 class="heading">5.1.3.2<span class="stt">Â </span><a name="(part._.Creating_.Literal_.Lists)"/>Creating Literal Lists<span class="button-group"><a href="#(part._.Creating_.Literal_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">We have already seen how we can create lists from a table, using
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">get-column</code></span>. As you might expect, however, we can also create lists
directly:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]
[list: -1, 5, 2.3, 10]
[list: "a", "b", "c"]
[list: "This", "is", "a", "list", "of", "words"]</code></pre></div></div></div><div class="SIntrapara">Of course, lists are values so we can name them using variablesâ€”<wbr/>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">shopping-list = [list: "muesli", "fiddleheads"]</code></pre></div></div></div><div class="SIntrapara">â€”<wbr/>pass them to functions (as we will soon see), and so on.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Based on these examples, can you figure out how to create an empty
list?</p></blockquote></blockquote><p>As you might have guessed, itâ€™s <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ]</code></span> (the space isnâ€™t
necessary, but itâ€™s a useful visual reminder of the void).</p>&#13;
<h4 class="heading">5.1.4<span class="stt">Â </span><a name="(part._.Operating_on_.Lists)"/>Operating on Lists<span class="button-group"><a href="#(part._.Operating_on_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><section class="SsectionLevel5" id="section 5.1.4.1"><h5 class="heading">5.1.4.1<span class="stt">Â </span><a name="(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)"/>Built-In Operations on Lists of Numbers<span class="button-group"><a href="#(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Pyret handily provides a useful set of operations we can already
perform on lists. <span class="refelem"><span class="refcolumn"><span class="refcontent">The
<a href="https://www.pyret.org/docs/latest/lists.html">lists
documentation</a> describes these operations.</span></span></span> As you might have
guessed, we can already compute most of the answers weâ€™ve asked for
at the start of the chapter. First we need to include some libraries that contain useful
functions:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import math as M
import statistics as S</code></pre></div></div></div><div class="SIntrapara">We can then access several useful functions:</div><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tickcounts = cleaned-data.get-column("tickcount")

M.max(tickcounts)     # largest number in a list
M.sum(tickcounts)     # sum of numbers in a list
S.mean(tickcounts)    # mean (average) of numbers in a list
S.median(tickcounts)  # median of numbers in a list</code></pre></div></div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">M.</code></span> notation means "the function inside the library
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">M</code></span>. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import</code></span> statement in the above code gave the name
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">M</code></span> to the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">math</code></span> library.</p></section><section class="SsectionLevel5" id="section 5.1.4.2"><h5 class="heading">5.1.4.2<span class="stt">Â </span><a name="(part._.Built-.In_.Operations_on_.Lists_in_.General)"/>Built-In Operations on Lists in General<span class="button-group"><a href="#(part._.Built-.In_.Operations_on_.Lists_in_.General)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Some of the useful computations in our list at the start of the
chapter involved the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">discount</code></span> column, which contains strings
rather than numbers. Specifically, letâ€™s consider the following
question:</p><ul><li><p>Compute the collection of unique discount codes that were used (many
might have been available).</p></li></ul><p>None of the table functions handle a question like this. However, this
is a common kind of question to ask about a collection of values (How
many unique artists are in your playlist? How many unique faculty are
teaching courses?). As such, Pyret (as most languages) provides a way
to identify the unique elements of a list. Hereâ€™s how we get the list
of all discount codes that were used in our table:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import lists as L
codes = cleaned-data.get-column("discount")
L.distinct(codes)</code></pre></div></div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distinct</code></span> function produces a list of the unique values from
the input list: every value in the input list appears exactly once in
the output list. For the above code, Pyret produces:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "BIRTHDAY", "STUDENT", "none"]</code></pre></div></div><p>What if we wanted to exclude <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"none"</code></span> from that list? After all,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"none"</code></span> isnâ€™t an actual discount code, but rather one that we
introduced while cleaning up the table. Is there a way to easily
remove <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"none"</code></span> from the list?</p><p>There are two ways we could do it. In the Pyret lists documentation,
we find a function called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">remove</code></span>, which removes a specific
element from a list:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.remove(L.distinct(codes), "none")</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "BIRTHDAY", "STUDENT"]</code></pre></div></div></td></tr></table><p>But this operation should also sound familiar: with tables, we
used <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> to keep only those elements that meet a
specific criterion. The filtering idea is so common that Pyret (and
most other languages) provide a similar operation on lists. In the
case of the discount codes, we could also have written:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun real-code(c :: String) -&gt; Boolean:
  not(c == "none")
end
L.filter(real-code, L.distinct(codes))</code></pre></div></div><p>The difference between these two approaches is that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span> is
more flexible: we can check any characteristic of a list element using
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>, but <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">remove</code></span> only checks whether the entire
element is equal to the value that we provide. If instead of removing
the specific string <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"none"</code></span>, we had wanted to remove all strings
that were in all-lowercase, we would have needed to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function that takes a list of words and removes those words in
which all letters are in lowercase. (Hint: combine
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-to-lower</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span>).</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.1.4.3"><h5 class="heading">5.1.4.3<span class="stt">Â </span><a name="(part._.An_.Aside_on_.Naming_.Conventions)"/>An Aside on Naming Conventions<span class="button-group"><a href="#(part._.An_.Aside_on_.Naming_.Conventions)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Our use of the plural <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">codes</code></span> for the list of values in the
column named <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">discount</code></span> (singular) is deliberate. A list contains
multiple values, so a plural is appropriate. In a table, in contrast,
we think of a column header as naming a single value that appears in
a specific row. Often, we speak of looking up a value in a specific
row and column: the singular name for the column supports thinking
about lookup in an individual row.</p></section><section class="SsectionLevel5" id="section 5.1.4.4"><h5 class="heading">5.1.4.4<span class="stt">Â </span><a name="(part._.Getting_.Elements_.By_.Position)"/>Getting Elements By Position<span class="button-group"><a href="#(part._.Getting_.Elements_.By_.Position)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Letâ€™s look at a new analysis question: the events company recently ran
an advertising campaign on <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web.com</code></span>, and they are curious
whether it paid off. To do this, they need to determine how many sales
were made to people with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web.com</code></span> email addresses.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Propose a task plan (<a href="processing-tables.html#%28part._task-plans%29" data-pltdoc="x">Task Plans</a>) for this computation.</p></blockquote></blockquote><p>Hereâ€™s a proposed plan, annotated with how we might implement each part:</p><ol><li><p>Get the list of email addresses (use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">get-column</code></span>)</p></li><li><p>Extract those that came from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web.com</code></span> (use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.filter</code></span>)</p></li><li><p>Count how many email addresses remain (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.length</code></span>,
which we hadnâ€™t discussed yet, but it is in the documentation)</p></li></ol><p>(As a reminder, unless you immediately see how to solve a problem,
write out a task plan and annotate the parts you know how to do. It
helps break down a programming problem into more manageable parts.)</p><p>Letâ€™s discuss the second task: identifying messages from
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web.com</code></span>. We know that email addresses are strings, so if we
could determine whether an email string ends in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">@web.com</code></span>,
weâ€™d be set. You could consider doing this by looking at the last 7
characters of the email string. Another option is to use a string
operation that we havenâ€™t yet seen called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split-all</code></span>, which
splits a string into a list of substrings around a given
character. For example:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split-all("this-has-hyphens", "-")</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "this", "has", "hyphens"]</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split("bonnie@pyret.org", "@")</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "bonnie", "pyret.org"]</code></pre></div></div></td></tr></table></div><p>This seems pretty useful. If we split each email string around the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">@</code></span> sign, then we can check whether the second string in the
list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web.com</code></span> (since email addresses should have only one
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">@</code></span> sign). But how would we get the second element out of
the list produced by <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split-all</code></span>? Here we dig into the
list, as we did to extract rows from tables, this time using the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">get</code></span> operation.</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split("bonnie@pyret.org", "@").get(1)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"pyret.org"</code></pre></div></div></td></tr></table><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Why do we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> as the input to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">get</code></span> if we want the
second item in the list?</p></blockquote></blockquote><p>Hereâ€™s the complete program for doing this check:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun web-com-address(email :: String) -&gt; Boolean:
  doc: "determine whether email is from web.com"
  string-split(email, "@").get(1) == "web.com"
where:
  web-com-address("bonnie@pyret.org") is false
  web-com-address("parrot@web.com") is true
end

emails = cleaned-data.get-column("email")
L.length(L.filter(web-com-address, emails))</code></pre></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>What happens if there is a malformed email address string that doesnâ€™t
contain the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">@</code></span> string? What would happen? What could you do
about that?</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.1.4.5"><h5 class="heading">5.1.4.5<span class="stt">Â </span><a name="(part._.Transforming_.Lists)"/>Transforming Lists<span class="button-group"><a href="#(part._.Transforming_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Imagine now that we had a list of email addresses, but instead just
wanted a list of usernames. This doesnâ€™t make sense for our event
data, but it does make sense in other contexts (such as connecting
messages to folders organized by studentsâ€™ usernames).</p><p>Specifcally, we want to start with a list of addresses such as:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "parrot@web.com", "bonnie@pyret.org"]</code></pre></div></div><p>and convert it to</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "parrot", "bonnie"]</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Consider the list functions we have seen so far (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distinct</code></span>,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length</code></span>) â€“ are any of them useful for this task?
Can you articulate why?</p></blockquote></blockquote><p>One way to articulate a precise answer to this is think in terms of
the inputs and outputs of the existing functions. Both <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distinct</code></span> return a list of elements from the input list, not
transformed elements. <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length</code></span> returns a number, not a list. So
none of these are appropriate.</p><p>This idea of transforming elements is similar to the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">transform-column</code></span> operation that we previously saw on
tables. The corresponding operation on lists is called
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>. Hereâ€™s an example:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun extract-username(email :: String) -&gt; String:
  doc: "extract the portion of an email address before the @ sign"
  string-split(email, "@").get(0)
where:
  extract-username("bonnie@pyret.org") is "bonnie"
  extract-username("parrot@web.com") is "parrot"
end

L.map(extract-username,
  [list: "parrot@web.com", "bonnie@pyret.org"])</code></pre></div></div></section><section class="SsectionLevel5" id="section 5.1.4.6"><h5 class="heading">5.1.4.6<span class="stt">Â </span><a name="(part._lists-recap)"/>Recap: Summary of List Operations<span class="button-group"><a href="#(part._lists-recap)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>At this point, we have seen several useful built-in functions for
working with lists:</p><ul><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter :: (A -&gt; Boolean), List&lt;A&gt; -&gt; List&lt;A&gt;</code></span>, which
produces a list of elements from the input list on which the given
function returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map :: (A -&gt; B), List&lt;A&gt; -&gt; List&lt;B&gt;</code></span>, which
produces a list of the results of calling the given function on each
element of the input list.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distinct :: List&lt;A&gt; -&gt; List&lt;A&gt;</code></span>, which
produces a list of the unique elements that appear in the input list.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length :: List&lt;A&gt; -&gt; Number</code></span>, which
produces the number of elements in the input list.</p></li></ul><p>Here, a type such as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">List&lt;A&gt;</code></span> says that we have a list whose
elements are of some (unspecified) type which weâ€™ll call
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">A</code></span>. A <span style="font-style: italic">type variable</span> such as this is useful when we want to
show <span class="emph">relationships</span> between two types in a function
contract. Here, the type variable <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">A</code></span> captures that the type of
elements is the same in the input and output to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>. In
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>, however, the type of element in the output list could
differ from that in the input list.</p><p>One additional built-in function that is quite useful in practice is:</p><ul><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member :: List&lt;A&gt;, Any -&gt; Boolean</code></span>, which
determines whether the given element is in the list. We use the type
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Any</code></span> when there are no constraints on the type of value provided
to a function.</p></li></ul><p>Many useful computations can be performed by combining these
operations.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Assume you used a list of strings to represent the ingredients in a
recipe. Here are three examples:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">stir-fry =
  [list: "peppers", "pork", "onions", "rice"]
dosa = [list: "rice", "lentils", "potato"]
misir-wot =
  [list: "lentils", "berbere", "tomato"]</code></pre></div></div><p>Write the following functions on ingredient lists:</p><ul><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">recipes-uses</code></span>, which takes an ingredient list and an
ingredient and determines whether the recipe uses the ingredient.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">make-vegetarian</code></span>, which takes an ingredient list and replaces
all meat ingredients with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"tofu"</code></span>. Meat ingredients are
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"pork"</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"chicken"</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"beef"</code></span>.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">protein-veg-count</code></span>, which takes an ingredient list and
determines how many ingredients are in the list that arenâ€™t
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"rice"</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"noodles"</code></span>.</p></li></ul></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>More challenging: Write a function that takes an
ingredient and a list of ingredient lists and produces a list of all
the lists that contain the given ingredient.</p><p><span class="emph">Hint: write examples first to make sense of the problem as needed.</span></p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Even more challenging: Try to write a function that takes two
ingredient lists and
returns all of the ingredients that are common to both lists. What
issue(s) or limitations do you run into?</p><p>Come back to this problem after you finish the next section.</p></blockquote></blockquote></section>&#13;
<h5 class="heading">5.1.4.1<span class="stt">Â </span><a name="(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)"/>Built-In Operations on Lists of Numbers<span class="button-group"><a href="#(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Pyret handily provides a useful set of operations we can already
perform on lists. <span class="refelem"><span class="refcolumn"><span class="refcontent">The
<a href="https://www.pyret.org/docs/latest/lists.html">lists
documentation</a> describes these operations.</span></span></span> As you might have
guessed, we can already compute most of the answers weâ€™ve asked for
at the start of the chapter. First we need to include some libraries that contain useful
functions:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import math as M
import statistics as S</code></pre></div></div></div><div class="SIntrapara">We can then access several useful functions:</div><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tickcounts = cleaned-data.get-column("tickcount")

M.max(tickcounts)     # largest number in a list
M.sum(tickcounts)     # sum of numbers in a list
S.mean(tickcounts)    # mean (average) of numbers in a list
S.median(tickcounts)  # median of numbers in a list</code></pre></div></div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">M.</code></span> notation means "the function inside the library
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">M</code></span>. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import</code></span> statement in the above code gave the name
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">M</code></span> to the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">math</code></span> library.</p>&#13;
<h5 class="heading">5.1.4.2<span class="stt">Â </span><a name="(part._.Built-.In_.Operations_on_.Lists_in_.General)"/>Built-In Operations on Lists in General<span class="button-group"><a href="#(part._.Built-.In_.Operations_on_.Lists_in_.General)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Some of the useful computations in our list at the start of the
chapter involved the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">discount</code></span> column, which contains strings
rather than numbers. Specifically, letâ€™s consider the following
question:</p><ul><li><p>Compute the collection of unique discount codes that were used (many
might have been available).</p></li></ul><p>None of the table functions handle a question like this. However, this
is a common kind of question to ask about a collection of values (How
many unique artists are in your playlist? How many unique faculty are
teaching courses?). As such, Pyret (as most languages) provides a way
to identify the unique elements of a list. Hereâ€™s how we get the list
of all discount codes that were used in our table:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import lists as L
codes = cleaned-data.get-column("discount")
L.distinct(codes)</code></pre></div></div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distinct</code></span> function produces a list of the unique values from
the input list: every value in the input list appears exactly once in
the output list. For the above code, Pyret produces:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "BIRTHDAY", "STUDENT", "none"]</code></pre></div></div><p>What if we wanted to exclude <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"none"</code></span> from that list? After all,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"none"</code></span> isnâ€™t an actual discount code, but rather one that we
introduced while cleaning up the table. Is there a way to easily
remove <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"none"</code></span> from the list?</p><p>There are two ways we could do it. In the Pyret lists documentation,
we find a function called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">remove</code></span>, which removes a specific
element from a list:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.remove(L.distinct(codes), "none")</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "BIRTHDAY", "STUDENT"]</code></pre></div></div></td></tr></table><p>But this operation should also sound familiar: with tables, we
used <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> to keep only those elements that meet a
specific criterion. The filtering idea is so common that Pyret (and
most other languages) provide a similar operation on lists. In the
case of the discount codes, we could also have written:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun real-code(c :: String) -&gt; Boolean:
  not(c == "none")
end
L.filter(real-code, L.distinct(codes))</code></pre></div></div><p>The difference between these two approaches is that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span> is
more flexible: we can check any characteristic of a list element using
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>, but <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">remove</code></span> only checks whether the entire
element is equal to the value that we provide. If instead of removing
the specific string <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"none"</code></span>, we had wanted to remove all strings
that were in all-lowercase, we would have needed to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a function that takes a list of words and removes those words in
which all letters are in lowercase. (Hint: combine
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-to-lower</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span>).</p></blockquote></blockquote>&#13;
<h5 class="heading">5.1.4.3<span class="stt">Â </span><a name="(part._.An_.Aside_on_.Naming_.Conventions)"/>An Aside on Naming Conventions<span class="button-group"><a href="#(part._.An_.Aside_on_.Naming_.Conventions)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Our use of the plural <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">codes</code></span> for the list of values in the
column named <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">discount</code></span> (singular) is deliberate. A list contains
multiple values, so a plural is appropriate. In a table, in contrast,
we think of a column header as naming a single value that appears in
a specific row. Often, we speak of looking up a value in a specific
row and column: the singular name for the column supports thinking
about lookup in an individual row.</p>&#13;
<h5 class="heading">5.1.4.4<span class="stt">Â </span><a name="(part._.Getting_.Elements_.By_.Position)"/>Getting Elements By Position<span class="button-group"><a href="#(part._.Getting_.Elements_.By_.Position)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Letâ€™s look at a new analysis question: the events company recently ran
an advertising campaign on <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web.com</code></span>, and they are curious
whether it paid off. To do this, they need to determine how many sales
were made to people with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web.com</code></span> email addresses.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Propose a task plan (<a href="processing-tables.html#%28part._task-plans%29" data-pltdoc="x">Task Plans</a>) for this computation.</p></blockquote></blockquote><p>Hereâ€™s a proposed plan, annotated with how we might implement each part:</p><ol><li><p>Get the list of email addresses (use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">get-column</code></span>)</p></li><li><p>Extract those that came from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web.com</code></span> (use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.filter</code></span>)</p></li><li><p>Count how many email addresses remain (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.length</code></span>,
which we hadnâ€™t discussed yet, but it is in the documentation)</p></li></ol><p>(As a reminder, unless you immediately see how to solve a problem,
write out a task plan and annotate the parts you know how to do. It
helps break down a programming problem into more manageable parts.)</p><p>Letâ€™s discuss the second task: identifying messages from
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web.com</code></span>. We know that email addresses are strings, so if we
could determine whether an email string ends in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">@web.com</code></span>,
weâ€™d be set. You could consider doing this by looking at the last 7
characters of the email string. Another option is to use a string
operation that we havenâ€™t yet seen called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split-all</code></span>, which
splits a string into a list of substrings around a given
character. For example:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split-all("this-has-hyphens", "-")</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "this", "has", "hyphens"]</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split("bonnie@pyret.org", "@")</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "bonnie", "pyret.org"]</code></pre></div></div></td></tr></table></div><p>This seems pretty useful. If we split each email string around the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">@</code></span> sign, then we can check whether the second string in the
list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web.com</code></span> (since email addresses should have only one
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">@</code></span> sign). But how would we get the second element out of
the list produced by <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split-all</code></span>? Here we dig into the
list, as we did to extract rows from tables, this time using the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">get</code></span> operation.</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-split("bonnie@pyret.org", "@").get(1)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"pyret.org"</code></pre></div></div></td></tr></table><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Why do we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> as the input to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">get</code></span> if we want the
second item in the list?</p></blockquote></blockquote><p>Hereâ€™s the complete program for doing this check:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun web-com-address(email :: String) -&gt; Boolean:
  doc: "determine whether email is from web.com"
  string-split(email, "@").get(1) == "web.com"
where:
  web-com-address("bonnie@pyret.org") is false
  web-com-address("parrot@web.com") is true
end

emails = cleaned-data.get-column("email")
L.length(L.filter(web-com-address, emails))</code></pre></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>What happens if there is a malformed email address string that doesnâ€™t
contain the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">@</code></span> string? What would happen? What could you do
about that?</p></blockquote></blockquote>&#13;
<h5 class="heading">5.1.4.5<span class="stt">Â </span><a name="(part._.Transforming_.Lists)"/>Transforming Lists<span class="button-group"><a href="#(part._.Transforming_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Imagine now that we had a list of email addresses, but instead just
wanted a list of usernames. This doesnâ€™t make sense for our event
data, but it does make sense in other contexts (such as connecting
messages to folders organized by studentsâ€™ usernames).</p><p>Specifcally, we want to start with a list of addresses such as:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "parrot@web.com", "bonnie@pyret.org"]</code></pre></div></div><p>and convert it to</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: "parrot", "bonnie"]</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Consider the list functions we have seen so far (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distinct</code></span>,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length</code></span>) â€“ are any of them useful for this task?
Can you articulate why?</p></blockquote></blockquote><p>One way to articulate a precise answer to this is think in terms of
the inputs and outputs of the existing functions. Both <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distinct</code></span> return a list of elements from the input list, not
transformed elements. <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length</code></span> returns a number, not a list. So
none of these are appropriate.</p><p>This idea of transforming elements is similar to the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">transform-column</code></span> operation that we previously saw on
tables. The corresponding operation on lists is called
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>. Hereâ€™s an example:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun extract-username(email :: String) -&gt; String:
  doc: "extract the portion of an email address before the @ sign"
  string-split(email, "@").get(0)
where:
  extract-username("bonnie@pyret.org") is "bonnie"
  extract-username("parrot@web.com") is "parrot"
end

L.map(extract-username,
  [list: "parrot@web.com", "bonnie@pyret.org"])</code></pre></div></div>&#13;
<h5 class="heading">5.1.4.6<span class="stt">Â </span><a name="(part._lists-recap)"/>Recap: Summary of List Operations<span class="button-group"><a href="#(part._lists-recap)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>At this point, we have seen several useful built-in functions for
working with lists:</p><ul><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter :: (A -&gt; Boolean), List&lt;A&gt; -&gt; List&lt;A&gt;</code></span>, which
produces a list of elements from the input list on which the given
function returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map :: (A -&gt; B), List&lt;A&gt; -&gt; List&lt;B&gt;</code></span>, which
produces a list of the results of calling the given function on each
element of the input list.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distinct :: List&lt;A&gt; -&gt; List&lt;A&gt;</code></span>, which
produces a list of the unique elements that appear in the input list.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length :: List&lt;A&gt; -&gt; Number</code></span>, which
produces the number of elements in the input list.</p></li></ul><p>Here, a type such as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">List&lt;A&gt;</code></span> says that we have a list whose
elements are of some (unspecified) type which weâ€™ll call
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">A</code></span>. A <span style="font-style: italic">type variable</span> such as this is useful when we want to
show <span class="emph">relationships</span> between two types in a function
contract. Here, the type variable <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">A</code></span> captures that the type of
elements is the same in the input and output to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>. In
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>, however, the type of element in the output list could
differ from that in the input list.</p><p>One additional built-in function that is quite useful in practice is:</p><ul><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member :: List&lt;A&gt;, Any -&gt; Boolean</code></span>, which
determines whether the given element is in the list. We use the type
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Any</code></span> when there are no constraints on the type of value provided
to a function.</p></li></ul><p>Many useful computations can be performed by combining these
operations.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Assume you used a list of strings to represent the ingredients in a
recipe. Here are three examples:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">stir-fry =
  [list: "peppers", "pork", "onions", "rice"]
dosa = [list: "rice", "lentils", "potato"]
misir-wot =
  [list: "lentils", "berbere", "tomato"]</code></pre></div></div><p>Write the following functions on ingredient lists:</p><ul><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">recipes-uses</code></span>, which takes an ingredient list and an
ingredient and determines whether the recipe uses the ingredient.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">make-vegetarian</code></span>, which takes an ingredient list and replaces
all meat ingredients with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"tofu"</code></span>. Meat ingredients are
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"pork"</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"chicken"</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"beef"</code></span>.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">protein-veg-count</code></span>, which takes an ingredient list and
determines how many ingredients are in the list that arenâ€™t
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"rice"</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"noodles"</code></span>.</p></li></ul></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>More challenging: Write a function that takes an
ingredient and a list of ingredient lists and produces a list of all
the lists that contain the given ingredient.</p><p><span class="emph">Hint: write examples first to make sense of the problem as needed.</span></p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Even more challenging: Try to write a function that takes two
ingredient lists and
returns all of the ingredients that are common to both lists. What
issue(s) or limitations do you run into?</p><p>Come back to this problem after you finish the next section.</p></blockquote></blockquote>&#13;
<h4 class="heading">5.1.5<span class="stt">Â </span><a name="(part._.Lambda__.Anonymous_.Functions)"/>Lambda: Anonymous Functions<span class="button-group"><a href="#(part._.Lambda__.Anonymous_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><span class="emph">NOTE: if you already saw <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> in <a href="intro-tabular-data.html#%28part._sec~3alambda-tables%29" data-pltdoc="x">Lambda: Anonymous Functions</a>, feel
free to skip this section, or just do the exercises at the end. Here we present
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> using lists and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>, rather than tables and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>.</span></p><p>Letâ€™s revisit the program we wrote earlier in this chapter for
finding all of the discount codes that were used in the events table:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun real-code(c :: String) -&gt; Boolean:
  not(c == "none")
end
L.filter(real-code, codes)</code></pre></div></div><p>This program might feel a bit verbose: do we really need to write a
helper function just to perform something as simple as a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>? Wouldnâ€™t it be easier to just write something like:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.filter(not(c == "none"), codes)</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What will Pyret produce if you run this expression?</p></blockquote></blockquote><p>Pyret will produce an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">unbound identifier</code></span> error around the use
of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c</code></span> in this expression. What is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c</code></span>? We mean for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c</code></span>
to be the elements from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">codes</code></span> in turn. Conceptually, thatâ€™s
what <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span> does, but we donâ€™t have the mechanics right. When
we call a function, we evaluate the arguments <span class="emph">before</span> the body
of the function. Hence, the error regarding <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c</code></span> being unbound.
The whole point of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">real-code</code></span> helper function is to make
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c</code></span> a parameter to a function whose body is only evaluated once
a value for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c</code></span> is available.</p><p>To tighten the notation as in the one-line <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span> expression,
then, we have to find a way to tell Pyret to make a temporary function
that will get its inputs once <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span> is running. The following
notation achieves this:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.filter(lam(c): not(c == "none") end, codes)</code></pre></div></div><p>We have added <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam(c)</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span> around the expression that
we want to use in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam(c)</code></span> says "make a
temporary function that takes <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c</code></span> as an input". The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span>
serves to end the function definition, as when we use
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun</code></span>. <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> is short for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lambda</code></span>, a form of function
definition that exists in many, though not all, languages.</p><p>The main difference between our original expression (using the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">real-code</code></span> helper) and this new one (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span>) can be
seen through the program directory. To explain this, a little detail
about how <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span> is defined under the hood. In part, it looks
like:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun filter(keep :: (A -&gt; Boolean), lst :: List&lt;A&gt;) -&gt; List&lt;A&gt;:
  if keep(&lt;elt-from-list&gt;):
    ...
  else:
    ...
  end
end</code></pre></div></div><p>Whether we pass <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">real-code</code></span> or the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> version to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>, the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">keep</code></span> parameter ends up referring to a
function with the same parameter and body. Since the function is only
actually called through the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">keep</code></span> name, it doesnâ€™t matter
whether or not a name is associated with it when it is initially
defined.</p><p>In practice, we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> when we have to pass simple (single
line) functions to operations like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span> (or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>). We
could have just as easily used them when we were working with tables
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">build-column</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>, etc). Of course, you can
continue to write out names for helper functions as we did with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">real-code</code></span> if that makes more sense to you.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write the program to extract the list of usernames from a list of
email addresses using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lam</code></span> rather than a named helper-function.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Try again to tackle the problem from the end of the
previous section: write a function that takes two ingredient lists and
returns all of the ingredients that are common to both lists.</p></blockquote></blockquote>&#13;
<h4 class="heading">5.1.6<span class="stt">Â </span><a name="(part._.Combining_.Lists_and_.Tables)"/>Combining Lists and Tables<span class="button-group"><a href="#(part._.Combining_.Lists_and_.Tables)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The table functions we studied previously were primarily for
processing rows. The list functions weâ€™ve learned in this chapter have
been primarily for processing columns (but there are many more uses in
the chapters ahead). If an analysis involves working with only some
rows and some columns, weâ€™ll use a combination of both table and list
functions in our program.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Given the events table, produce a list of names of all people who will
pick up their tickets.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Given the events table, produce the average number of tickets that
were ordered by people with email addresses that end in
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">".org"</code></span>.</p></blockquote></blockquote><p>Sometimes, there will be more than one way to perform a computation:</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Consider a question such as "how many people with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">".org"</code></span> email
addresses bought more than 8 tickets". Propose multiple task plans
that would solve this problem, including which table and list
functions would accomplish each task.</p></blockquote></blockquote><p>There are several options here:</p><ol><li><p>Get the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">event-data</code></span> rows with no more than 8
tickets (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>), get those rows that have
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">".org"</code></span> addresses (another <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>), then ask for how
many rows are in the table (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;table&gt;.length()</code></span>).</p></li><li><p>Get the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">event-data</code></span> rows with no more than 8
tickets and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">".org"</code></span> address (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span> with a
function that checks both conditions at once), then ask for how
many rows are in the table (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;table&gt;.length()</code></span>).</p></li><li><p>Get the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">event-data</code></span> rows with no more than 8
tickets (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter-with</code></span>), extract the email addresses (using
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">get-column</code></span>), limit those to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">".org"</code></span> (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.filter</code></span>),
then get the length of the resulting list (using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L.length</code></span>).</p></li></ol><p>There are others, but you get the idea.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Which approach do you like best? Why?</p></blockquote></blockquote><p>While there is no single correct answer, there are various
considerations:</p><ul><li><p>Are any of the intermediate results useful for other computations?
While the second option might seem best because it filters the table
once rather than twice, perhaps the events company has many
computations to perform on larger ticket orders. Similarly, the
company may want the list of email addresses on large orders for
other purposes (the third option)</p></li><li><p>Do you want to follow a discipline of doing operations on
individuals within the table, extracting lists only when needed to
perform aggregating computations that arenâ€™t available on tables?</p></li><li><p>Does one approach seem less resource-intensive than the other?
This is actually a subtle point: you might be tempted to think that
filtering over a table uses more resources than filtering over a list
of values from one column, but this actually isnâ€™t the case. Weâ€™ll
return to this discussion later.</p></li></ul><p>A company or project team sometimes sets design standards to help you
make those decisions. In the absence of that, and especially as you
are learning to program, consider multiple approaches when faced with
such problems, then pick one to implement. Maintaining the ability to
think flexibly about approaches is a useful skill in any form of design.</p><p>Until now weâ€™ve only seen how to use built-in functions over
lists. Next [<a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>], we will study how to create
our own functions that process lists. Once we learn that, these list
processing functions will remain powerful but will no longer seem
quite so magical, because weâ€™ll be able to build them for ourselves!</p>    
</body>
</html>