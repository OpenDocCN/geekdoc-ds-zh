- en: 8.3¬†Examples, Testing, and Program Checkingüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/testing.html](https://dcic-world.org/2025-08-27/testing.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[8.3.1¬†From Examples to Tests](#%28part._from-examples-to-tests%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[8.3.2¬†More Refined Comparisons](#%28part._s~3arefined%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[8.3.3¬†When Tests Fail](#%28part._.When_.Tests_.Fail%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[8.3.4¬†Oracles for Testing](#%28part._test-oracle%29) |'
  prefs: []
  type: TYPE_TB
- en: 'Back in [Documenting Functions with Examples](From_Repeated_Expressions_to_Functions.html#%28part._writing-examples%29),
    we began to develop your habit of writing concrete examples of functions. In [Task
    Plans](processing-tables.html#%28part._task-plans%29), we showed you how to develop
    examples of intermediate values to help you plan the code for you to write. As
    these examples show, there are many ways to write down examples. We could write
    them on a board, on paper, or even as comments in a computer document. These are
    all reasonable and indeed, often, the best way to begin working on a problem.
    However, if we can write our examples in a precise form that a computer can understand,
    we achieve two things:'
  prefs: []
  type: TYPE_NORMAL
- en: When we‚Äôre done writing our purported solution, we can have the computer check
    whether we got it right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the process of writing down our expectation, we often find it hard to express
    with the precision that a computer expects. Sometimes this is because we‚Äôre still
    formulating the details and haven‚Äôt yet pinned them down, but at other times it‚Äôs
    because we don‚Äôt yet understand the problem. In such situations, the force of
    precision actually does us good, because it helps us understand the weakness of
    our understanding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.3.1¬†From Examples to Tests[üîó](#(part._from-examples-to-tests) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Until now, we have written examples in `where:` blocks for two purposes: to
    help us figure out what a function needs to do, and to provide guidance to someone
    reading our code as to what behavior they can expect when using our function.
    For the smaller programs that we have written until now, `where`-based examples
    have been sufficient. As our programs get more complicated, however, a small set
    of related illustrative examples won‚Äôt suffice. We need to think about being much
    more thorough in the sets of inputs that we consider.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider for example a function `count-uses` that counts how many times a specific
    string appears in a list (this could be used to tally votes, to compute the frequency
    of using a discount code, and so on). What input scenarios might we need to check
    before using our function to run an actual election or a business?
  prefs: []
  type: TYPE_NORMAL
- en: The result for a string that is in the list once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result for a string that is in the list multiple times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result for a string that is at the end of a longer list (to make sure we
    are checking all of the elements)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result for a string that isn‚Äôt in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result for a string that is in the list but with different capitalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result for a string that is a typo-away from a word in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that here we are considering many more situations, including fairly nuanced
    ones that affect how robust our code would be under realistic situations. Once
    we start considering situations like these, we are shifting from examples to illustrate
    our code to tests to thoroughly test our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Pyret, we use `where` blocks inside function definitions for examples. We
    use a `check` block outside the function definition for tests. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As a guiding rule, we put illustrative cases that would help someone else reading
    our code into the `where` block, while we put the nitty-gritty checks that our
    code handles the wider range of usage scenarios (including error cases) into the
    `check`. Sometimes, the line between these two isn‚Äôt clear: for example, one could
    easily argue that the second test (the function handles different capitalization)
    belongs in `where` instead. The third test about using a really long list would
    remain in `check`, however, as longer inputs are generally not instructive to
    a reader of your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting tests in a block that lives outside the function has another advantage
    at the level of professional programming: it allows your tests to live in a separate
    file from your code. This has two key benefits. First, it makes it easier for
    someone to read the essential parts of your code (if they are building on your
    work). Second, it makes it easier to control when tests are run. When your `check`
    blocks are in the same file as your code, all the tests will be checked when you
    run your code. When they are in a different file, an organization can choose when
    to run the tests. During development, tests are run frequently to make sure no
    errors have been introduced. Once code is tested and ready to be deployed or used,
    tests are not run along with the program (unless there has been a modification
    or someone has discovered an error with the code). This is standard practice in
    software projects.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth noting that the collection of tests grows throughout the development
    process, moreso than do the collection of examples. As you are developing code,
    every time you find a bug in your code, add a test for it in your `check` block
    so you don‚Äôt accidentally introduce that same error again later. Whereas we develop
    examples up front as we figure out what we want our program to do, we augment
    our tests as we discover what our program actually does (and perhaps should not
    do). In practice, developers write an initial set of checks on the scenarios they
    thought of before and while writing the code, then expand those tests as they
    try out more scenarios and gain users who report scenarios where the code does
    not work.
  prefs: []
  type: TYPE_NORMAL
- en: Nearly all programming languages come with some constructs or packages in which
    you can write tests in separate files. Pyret is unique in supporting the distinction
    between examples and tests (both for learning and for readability of code by others).
    Many programming tools that support professionals expect you to put all tests
    in separate folders and files (offering no support for examples). In this book,
    we emphasize the difference between these two uses of input-output pairs in programming
    because we find them extremely useful both professionally and pedagogically.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.2¬†More Refined Comparisons[üîó](#(part._s~3arefined) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, a direct comparison via `is` isn‚Äôt enough for testing. We have already
    seen this in the case of `raises` tests ([Computing Genetic Parents from an Ancestry
    Table](trees.html#%28part._compute-parents-table%29)). As another example, when
    doing some computations, especially involving math with approximations, the exact
    match of `is` isn‚Äôt feasible. For example, consider these tests for `distance-to-origin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What can we check here? Typing this into the REPL, we can find that the answer
    prints as `1.4142135623730951`. That‚Äôs an approximation of the real answer, which
    Pyret cannot represent exactly. But it‚Äôs hard to know that this precise answer,
    to this decimal place, and no more, is the one we should expect up front, and
    thinking through the answers is supposed to be the first thing we do!
  prefs: []
  type: TYPE_NORMAL
- en: Since we know we‚Äôre getting an approximation, we can really only check that
    the answer is roughly correct, not exactly correct. If we can check that the answer
    to `distance-to-origin(point(1, 1))` is around, say, `1.41`, and can do the same
    for some similar cases, that‚Äôs probably good enough for many applications, and
    for our purposes here. If we were calculating orbital dynamics, we might demand
    higher precision, but note that we‚Äôd still need to pick a cutoff! Testing for
    inexact results is a necessary task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs first define what we mean by ‚Äúaround‚Äù with one of the most precise ways
    we can, a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `is` form now helps us out. There is special syntax for supplying a user-defined
    function to use to compare the two values, instead of just checking if they are
    equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Adding `%(something)` after `is` changes the behavior of `is`. Normally, it
    would compare the left and right values for equality. If something is provided
    with `%`, however, it instead passes the left and right values to the provided
    function (in this example `around`). If the provided function produces `true`,
    the test passes, if it produces `false`, the test fails. This gives us the control
    we need to test functions with predictable approximate results.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend the definition of `distance-to-origin` to include `polar` points.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This might save you a Google search: [polar conversions](http://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates).
    Use the design recipe to write `x-component` and `y-component`, which return the
    `x` and `y` Cartesian parts of the point (which you would need, for example, if
    you were plotting them on a graph). Read about `num-sin` and other functions you‚Äôll
    need at [the Pyret number documentation](http://www.pyret.org/docs/latest/numbers.html).'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write a data definition called `Pay` for pay types that includes both hourly
    employees, whose pay type includes an hourly rate, and salaried employees, whose
    pay type includes a total salary for the year. Use the design recipe to write
    a function called `expected-weekly-wages` that takes a `Pay`, and returns the
    expected weekly salary: the expected weekly salary for an hourly employee assumes
    they work 40 hours, and the expected weekly salary for a salaried employee is
    1/52 of their salary.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 8.3.3¬†When Tests Fail[üîó](#(part._.When_.Tests_.Fail) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose we‚Äôve written the function `sqrt`, which computes the square root of
    a given number. We‚Äôve written some tests for this function. We run the program,
    and find that a test fails. There are two obvious reasons why this can happen.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the two obvious reasons?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The two reasons are, of course, the two ‚Äúsides‚Äù of the test: the problem could
    be with the values we‚Äôve written or with the function we‚Äôve written. For instance,
    if we‚Äôve written'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: then the fault clearly lies with the values (because \(1.75^2\) is clearly not
    \(4\)). On the other hand, if it fails the test
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: then the odds are that we‚Äôve made an error in the definition of `sqrt` instead,
    and that‚Äôs what we need to fix.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is no way for the computer to tell what went wrong. When it
    reports a test failure, all it‚Äôs saying is that there is an inconsistency between
    the program and the tests. The computer is not passing judgment on which one is
    ‚Äúcorrect‚Äù, because it can‚Äôt do that. That is a matter for human judgment.For this
    reason, we‚Äôve been doing research on [peer review of tests](http://cs.brown.edu/~sk/Publications/Papers/Published/pkf-ifpr-tests-tf-prog/),
    so students can help one another review their tests before they begin writing
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually...not so fast. There‚Äôs one more possibility we didn‚Äôt consider: the
    third, not-so-obvious reason why a test might fail. Return to this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Clearly the inputs and outputs are correct, but it could be that the definition
    of `sqrt` is also correct, and yet the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Depending on how we‚Äôve programmed `sqrt`, it might return the root `-2` instead
    of `2`. Now `-2` is a perfectly good answer, too. That is, neither the function
    nor the particular set of test values we specified is inherently wrong; it‚Äôs just
    that the function happens to be a relation, i.e., it maps one input to multiple
    outputs (that is, \(\sqrt{4} = \pm 2\)). The question now is how to write the
    test properly.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.4¬†Oracles for Testing[üîó](#(part._test-oracle) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In other words, sometimes what we want to express is not a concrete input-output
    pair, but rather check that the output has the right relationship to the input.
    Concretely, what might this be in the case of `sqrt`? We hinted at this earlier
    when we said that `1.75` clearly can‚Äôt be right, because squaring it does not
    yield `4`. That gives us the general insight: that a number is a valid root (note
    the use of ‚Äúa‚Äù instead of ‚Äúthe‚Äù) if squaring it yields the original number. That
    is, we might write a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: and then our test looks like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this has an awkward failure case. If `sqrt` does not produce
    a number that is in fact a root, we aren‚Äôt told what the actual value is; instead,
    `is-sqrt` returns false, and the test failure just says that `false` (what `is-sqrt`
    returns) is not `true` (what the test expects)‚Äî<wbr>which is both absolutely true
    and utterly useless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Pyret has a better way of expressing the same check. Instead of
    `is`, we can write `satisfies`, and then the value on the left must satisfy the
    predicate on the right. Concretely, this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'which lets us write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, if there‚Äôs a failure, we learn of the actual value produced by `sqrt(4)`
    that failed to satisfy the predicate.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.1¬†From Examples to Tests[üîó](#(part._from-examples-to-tests) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Until now, we have written examples in `where:` blocks for two purposes: to
    help us figure out what a function needs to do, and to provide guidance to someone
    reading our code as to what behavior they can expect when using our function.
    For the smaller programs that we have written until now, `where`-based examples
    have been sufficient. As our programs get more complicated, however, a small set
    of related illustrative examples won‚Äôt suffice. We need to think about being much
    more thorough in the sets of inputs that we consider.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider for example a function `count-uses` that counts how many times a specific
    string appears in a list (this could be used to tally votes, to compute the frequency
    of using a discount code, and so on). What input scenarios might we need to check
    before using our function to run an actual election or a business?
  prefs: []
  type: TYPE_NORMAL
- en: The result for a string that is in the list once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result for a string that is in the list multiple times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result for a string that is at the end of a longer list (to make sure we
    are checking all of the elements)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result for a string that isn‚Äôt in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result for a string that is in the list but with different capitalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result for a string that is a typo-away from a word in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that here we are considering many more situations, including fairly nuanced
    ones that affect how robust our code would be under realistic situations. Once
    we start considering situations like these, we are shifting from examples to illustrate
    our code to tests to thoroughly test our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Pyret, we use `where` blocks inside function definitions for examples. We
    use a `check` block outside the function definition for tests. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As a guiding rule, we put illustrative cases that would help someone else reading
    our code into the `where` block, while we put the nitty-gritty checks that our
    code handles the wider range of usage scenarios (including error cases) into the
    `check`. Sometimes, the line between these two isn‚Äôt clear: for example, one could
    easily argue that the second test (the function handles different capitalization)
    belongs in `where` instead. The third test about using a really long list would
    remain in `check`, however, as longer inputs are generally not instructive to
    a reader of your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting tests in a block that lives outside the function has another advantage
    at the level of professional programming: it allows your tests to live in a separate
    file from your code. This has two key benefits. First, it makes it easier for
    someone to read the essential parts of your code (if they are building on your
    work). Second, it makes it easier to control when tests are run. When your `check`
    blocks are in the same file as your code, all the tests will be checked when you
    run your code. When they are in a different file, an organization can choose when
    to run the tests. During development, tests are run frequently to make sure no
    errors have been introduced. Once code is tested and ready to be deployed or used,
    tests are not run along with the program (unless there has been a modification
    or someone has discovered an error with the code). This is standard practice in
    software projects.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth noting that the collection of tests grows throughout the development
    process, moreso than do the collection of examples. As you are developing code,
    every time you find a bug in your code, add a test for it in your `check` block
    so you don‚Äôt accidentally introduce that same error again later. Whereas we develop
    examples up front as we figure out what we want our program to do, we augment
    our tests as we discover what our program actually does (and perhaps should not
    do). In practice, developers write an initial set of checks on the scenarios they
    thought of before and while writing the code, then expand those tests as they
    try out more scenarios and gain users who report scenarios where the code does
    not work.
  prefs: []
  type: TYPE_NORMAL
- en: Nearly all programming languages come with some constructs or packages in which
    you can write tests in separate files. Pyret is unique in supporting the distinction
    between examples and tests (both for learning and for readability of code by others).
    Many programming tools that support professionals expect you to put all tests
    in separate folders and files (offering no support for examples). In this book,
    we emphasize the difference between these two uses of input-output pairs in programming
    because we find them extremely useful both professionally and pedagogically.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.2¬†More Refined Comparisons[üîó](#(part._s~3arefined) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, a direct comparison via `is` isn‚Äôt enough for testing. We have already
    seen this in the case of `raises` tests ([Computing Genetic Parents from an Ancestry
    Table](trees.html#%28part._compute-parents-table%29)). As another example, when
    doing some computations, especially involving math with approximations, the exact
    match of `is` isn‚Äôt feasible. For example, consider these tests for `distance-to-origin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What can we check here? Typing this into the REPL, we can find that the answer
    prints as `1.4142135623730951`. That‚Äôs an approximation of the real answer, which
    Pyret cannot represent exactly. But it‚Äôs hard to know that this precise answer,
    to this decimal place, and no more, is the one we should expect up front, and
    thinking through the answers is supposed to be the first thing we do!
  prefs: []
  type: TYPE_NORMAL
- en: Since we know we‚Äôre getting an approximation, we can really only check that
    the answer is roughly correct, not exactly correct. If we can check that the answer
    to `distance-to-origin(point(1, 1))` is around, say, `1.41`, and can do the same
    for some similar cases, that‚Äôs probably good enough for many applications, and
    for our purposes here. If we were calculating orbital dynamics, we might demand
    higher precision, but note that we‚Äôd still need to pick a cutoff! Testing for
    inexact results is a necessary task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs first define what we mean by ‚Äúaround‚Äù with one of the most precise ways
    we can, a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `is` form now helps us out. There is special syntax for supplying a user-defined
    function to use to compare the two values, instead of just checking if they are
    equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Adding `%(something)` after `is` changes the behavior of `is`. Normally, it
    would compare the left and right values for equality. If something is provided
    with `%`, however, it instead passes the left and right values to the provided
    function (in this example `around`). If the provided function produces `true`,
    the test passes, if it produces `false`, the test fails. This gives us the control
    we need to test functions with predictable approximate results.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend the definition of `distance-to-origin` to include `polar` points.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This might save you a Google search: [polar conversions](http://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates).
    Use the design recipe to write `x-component` and `y-component`, which return the
    `x` and `y` Cartesian parts of the point (which you would need, for example, if
    you were plotting them on a graph). Read about `num-sin` and other functions you‚Äôll
    need at [the Pyret number documentation](http://www.pyret.org/docs/latest/numbers.html).'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write a data definition called `Pay` for pay types that includes both hourly
    employees, whose pay type includes an hourly rate, and salaried employees, whose
    pay type includes a total salary for the year. Use the design recipe to write
    a function called `expected-weekly-wages` that takes a `Pay`, and returns the
    expected weekly salary: the expected weekly salary for an hourly employee assumes
    they work 40 hours, and the expected weekly salary for a salaried employee is
    1/52 of their salary.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 8.3.3¬†When Tests Fail[üîó](#(part._.When_.Tests_.Fail) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose we‚Äôve written the function `sqrt`, which computes the square root of
    a given number. We‚Äôve written some tests for this function. We run the program,
    and find that a test fails. There are two obvious reasons why this can happen.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the two obvious reasons?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The two reasons are, of course, the two ‚Äúsides‚Äù of the test: the problem could
    be with the values we‚Äôve written or with the function we‚Äôve written. For instance,
    if we‚Äôve written'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: then the fault clearly lies with the values (because \(1.75^2\) is clearly not
    \(4\)). On the other hand, if it fails the test
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: then the odds are that we‚Äôve made an error in the definition of `sqrt` instead,
    and that‚Äôs what we need to fix.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is no way for the computer to tell what went wrong. When it
    reports a test failure, all it‚Äôs saying is that there is an inconsistency between
    the program and the tests. The computer is not passing judgment on which one is
    ‚Äúcorrect‚Äù, because it can‚Äôt do that. That is a matter for human judgment.For this
    reason, we‚Äôve been doing research on [peer review of tests](http://cs.brown.edu/~sk/Publications/Papers/Published/pkf-ifpr-tests-tf-prog/),
    so students can help one another review their tests before they begin writing
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually...not so fast. There‚Äôs one more possibility we didn‚Äôt consider: the
    third, not-so-obvious reason why a test might fail. Return to this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Clearly the inputs and outputs are correct, but it could be that the definition
    of `sqrt` is also correct, and yet the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Depending on how we‚Äôve programmed `sqrt`, it might return the root `-2` instead
    of `2`. Now `-2` is a perfectly good answer, too. That is, neither the function
    nor the particular set of test values we specified is inherently wrong; it‚Äôs just
    that the function happens to be a relation, i.e., it maps one input to multiple
    outputs (that is, \(\sqrt{4} = \pm 2\)). The question now is how to write the
    test properly.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.4¬†Oracles for Testing[üîó](#(part._test-oracle) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In other words, sometimes what we want to express is not a concrete input-output
    pair, but rather check that the output has the right relationship to the input.
    Concretely, what might this be in the case of `sqrt`? We hinted at this earlier
    when we said that `1.75` clearly can‚Äôt be right, because squaring it does not
    yield `4`. That gives us the general insight: that a number is a valid root (note
    the use of ‚Äúa‚Äù instead of ‚Äúthe‚Äù) if squaring it yields the original number. That
    is, we might write a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: and then our test looks like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this has an awkward failure case. If `sqrt` does not produce
    a number that is in fact a root, we aren‚Äôt told what the actual value is; instead,
    `is-sqrt` returns false, and the test failure just says that `false` (what `is-sqrt`
    returns) is not `true` (what the test expects)‚Äî<wbr>which is both absolutely true
    and utterly useless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Pyret has a better way of expressing the same check. Instead of
    `is`, we can write `satisfies`, and then the value on the left must satisfy the
    predicate on the right. Concretely, this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'which lets us write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, if there‚Äôs a failure, we learn of the actual value produced by `sqrt(4)`
    that failed to satisfy the predicate.
  prefs: []
  type: TYPE_NORMAL
