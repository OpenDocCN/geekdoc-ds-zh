- en: 8.3Â Examples, Testing, and Program CheckingğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.3 ç¤ºä¾‹ã€æµ‹è¯•å’Œç¨‹åºæ£€æŸ¥ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/testing.html](https://dcic-world.org/2025-08-27/testing.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/testing.html](https://dcic-world.org/2025-08-27/testing.html)
- en: '| Â Â Â Â [8.3.1Â From Examples to Tests](#%28part._from-examples-to-tests%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [8.3.1 ä»ç¤ºä¾‹åˆ°æµ‹è¯•](#%28part._from-examples-to-tests%29) |'
- en: '| Â Â Â Â [8.3.2Â More Refined Comparisons](#%28part._s~3arefined%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [8.3.2 æ›´ç²¾ç»†çš„æ¯”è¾ƒ](#%28part._s~3arefined%29) |'
- en: '| Â Â Â Â [8.3.3Â When Tests Fail](#%28part._.When_.Tests_.Fail%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [8.3.3 æµ‹è¯•å¤±è´¥æ—¶](#%28part._.When_.Tests_.Fail%29) |'
- en: '| Â Â Â Â [8.3.4Â Oracles for Testing](#%28part._test-oracle%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [8.3.4 æµ‹è¯•çš„é¢„è¨€è€…](#%28part._test-oracle%29) |'
- en: 'Back in [Documenting Functions with Examples](From_Repeated_Expressions_to_Functions.html#%28part._writing-examples%29),
    we began to develop your habit of writing concrete examples of functions. In [Task
    Plans](processing-tables.html#%28part._task-plans%29), we showed you how to develop
    examples of intermediate values to help you plan the code for you to write. As
    these examples show, there are many ways to write down examples. We could write
    them on a board, on paper, or even as comments in a computer document. These are
    all reasonable and indeed, often, the best way to begin working on a problem.
    However, if we can write our examples in a precise form that a computer can understand,
    we achieve two things:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[ä½¿ç”¨ç¤ºä¾‹æ–‡æ¡£åŒ–å‡½æ•°](From_Repeated_Expressions_to_Functions.html#%28part._writing-examples%29)ä¸­ï¼Œæˆ‘ä»¬å¼€å§‹åŸ¹å…»ä½ ç¼–å†™å‡½æ•°å…·ä½“ç¤ºä¾‹çš„ä¹ æƒ¯ã€‚åœ¨[ä»»åŠ¡è®¡åˆ’](processing-tables.html#%28part._task-plans%29)ä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºäº†å¦‚ä½•å¼€å‘ä¸­é—´å€¼çš„ç¤ºä¾‹ï¼Œä»¥å¸®åŠ©ä½ è§„åˆ’è¦ç¼–å†™çš„ä»£ç ã€‚æ­£å¦‚è¿™äº›ç¤ºä¾‹æ‰€ç¤ºï¼Œè®°å½•ç¤ºä¾‹æœ‰è®¸å¤šæ–¹æ³•ã€‚æˆ‘ä»¬å¯ä»¥åœ¨é»‘æ¿ä¸Šã€çº¸ä¸Šï¼Œç”šè‡³ä½œä¸ºè®¡ç®—æœºæ–‡æ¡£ä¸­çš„æ³¨é‡Šæ¥ç¼–å†™å®ƒä»¬ã€‚è¿™äº›éƒ½æ˜¯åˆç†çš„æ–¹æ³•ï¼Œå®é™…ä¸Šï¼Œå¾€å¾€æ˜¯å¼€å§‹è§£å†³é—®é¢˜çš„æœ€ä½³æ–¹å¼ã€‚ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬èƒ½ä»¥è®¡ç®—æœºèƒ½ç†è§£çš„ç¡®åˆ‡å½¢å¼ç¼–å†™ç¤ºä¾‹ï¼Œæˆ‘ä»¬å°±èƒ½å®ç°ä¸¤ä¸ªç›®æ ‡ï¼š
- en: When weâ€™re done writing our purported solution, we can have the computer check
    whether we got it right.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬å®Œæˆæ‰€è°“çš„è§£å†³æ–¹æ¡ˆçš„ç¼–å†™åï¼Œæˆ‘ä»¬å¯ä»¥è®©è®¡ç®—æœºæ£€æŸ¥æˆ‘ä»¬æ˜¯å¦æ­£ç¡®ã€‚
- en: In the process of writing down our expectation, we often find it hard to express
    with the precision that a computer expects. Sometimes this is because weâ€™re still
    formulating the details and havenâ€™t yet pinned them down, but at other times itâ€™s
    because we donâ€™t yet understand the problem. In such situations, the force of
    precision actually does us good, because it helps us understand the weakness of
    our understanding.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨å†™ä¸‹æˆ‘ä»¬çš„æœŸæœ›çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¸¸å¸¸å‘ç°å¾ˆéš¾ç”¨è®¡ç®—æœºæœŸæœ›çš„ç²¾ç¡®åº¦æ¥è¡¨è¾¾ã€‚æœ‰æ—¶è¿™æ˜¯å› ä¸ºæˆ‘ä»¬ä»åœ¨åˆ¶å®šç»†èŠ‚ï¼Œè¿˜æ²¡æœ‰ç¡®å®šä¸‹æ¥ï¼Œä½†æœ‰æ—¶æ˜¯å› ä¸ºæˆ‘ä»¬è¿˜ä¸ç†è§£é—®é¢˜ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç²¾ç¡®çš„åŠ›é‡å®é™…ä¸Šå¯¹æˆ‘ä»¬æœ‰ç›Šï¼Œå› ä¸ºå®ƒå¸®åŠ©æˆ‘ä»¬ç†è§£æˆ‘ä»¬ç†è§£çš„å¼±ç‚¹ã€‚
- en: 8.3.1Â From Examples to Tests[ğŸ”—](#(part._from-examples-to-tests) "Link to here")
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1 ä»ç¤ºä¾‹åˆ°æµ‹è¯•[ğŸ”—](#(part._from-examples-to-tests) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Until now, we have written examples in `where:` blocks for two purposes: to
    help us figure out what a function needs to do, and to provide guidance to someone
    reading our code as to what behavior they can expect when using our function.
    For the smaller programs that we have written until now, `where`-based examples
    have been sufficient. As our programs get more complicated, however, a small set
    of related illustrative examples wonâ€™t suffice. We need to think about being much
    more thorough in the sets of inputs that we consider.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¸ºäº†ä¸¤ä¸ªç›®çš„åœ¨`where:`å—ä¸­ç¼–å†™ç¤ºä¾‹ï¼šå¸®åŠ©æˆ‘ä»¬å¼„æ¸…æ¥šå‡½æ•°éœ€è¦åšä»€ä¹ˆï¼Œå¹¶ä¸ºé˜…è¯»æˆ‘ä»¬ä»£ç çš„äººæä¾›æŒ‡å¯¼ï¼Œå‘Šè¯‰ä»–ä»¬ä½¿ç”¨æˆ‘ä»¬çš„å‡½æ•°æ—¶å¯ä»¥æœŸå¾…çš„è¡Œä¸ºã€‚å¯¹äºæˆ‘ä»¬ç°åœ¨ç¼–å†™çš„è¾ƒå°ç¨‹åºï¼ŒåŸºäº`where`çš„ç¤ºä¾‹å·²ç»è¶³å¤Ÿäº†ã€‚ç„¶è€Œï¼Œéšç€æˆ‘ä»¬çš„ç¨‹åºå˜å¾—æ›´åŠ å¤æ‚ï¼Œä¸€ç»„ç›¸å…³çš„è¯´æ˜æ€§ç¤ºä¾‹å°±ä¸å¤Ÿäº†ã€‚æˆ‘ä»¬éœ€è¦è€ƒè™‘åœ¨è€ƒè™‘çš„è¾“å…¥é›†åˆä¸Šæ›´åŠ å½»åº•ã€‚
- en: Consider for example a function `count-uses` that counts how many times a specific
    string appears in a list (this could be used to tally votes, to compute the frequency
    of using a discount code, and so on). What input scenarios might we need to check
    before using our function to run an actual election or a business?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œè€ƒè™‘ä¸€ä¸ª`count-uses`å‡½æ•°ï¼Œå®ƒè®¡ç®—ç‰¹å®šå­—ç¬¦ä¸²åœ¨åˆ—è¡¨ä¸­å‡ºç°çš„æ¬¡æ•°ï¼ˆè¿™å¯ä»¥ç”¨æ¥ç»Ÿè®¡é€‰ç¥¨ã€è®¡ç®—ä½¿ç”¨æŠ˜æ‰£ä»£ç çš„é¢‘ç‡ç­‰ï¼‰ã€‚åœ¨ä½¿ç”¨æˆ‘ä»¬çš„å‡½æ•°è¿›è¡Œå®é™…é€‰ä¸¾æˆ–å•†ä¸šæ´»åŠ¨ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥å“ªäº›è¾“å…¥åœºæ™¯ï¼Ÿ
- en: The result for a string that is in the list once
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºåˆ—è¡¨ä¸­ä»…å‡ºç°ä¸€æ¬¡çš„å­—ç¬¦ä¸²çš„ç»“æœ
- en: The result for a string that is in the list multiple times
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºåˆ—è¡¨ä¸­å¤šæ¬¡å‡ºç°çš„å­—ç¬¦ä¸²çš„ç»“æœ
- en: The result for a string that is at the end of a longer list (to make sure we
    are checking all of the elements)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºåˆ—è¡¨æœ«å°¾çš„è¾ƒé•¿çš„å­—ç¬¦ä¸²çš„ç»“æœï¼ˆä»¥ç¡®ä¿æˆ‘ä»¬æ£€æŸ¥äº†æ‰€æœ‰å…ƒç´ ï¼‰
- en: The result for a string that isnâ€™t in the list
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºä¸åœ¨åˆ—è¡¨ä¸­çš„å­—ç¬¦ä¸²çš„ç»“æœ
- en: The result for a string that is in the list but with different capitalization
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºåˆ—è¡¨ä¸­ä½†å¤§å°å†™ä¸åŒçš„å­—ç¬¦ä¸²çš„ç»“æœ
- en: The result for a string that is a typo-away from a word in the list
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºåˆ—è¡¨ä¸­ä¸å•è¯æ‹¼å†™æœ‰è¯¯çš„å­—ç¬¦ä¸²çš„ç»“æœ
- en: Notice that here we are considering many more situations, including fairly nuanced
    ones that affect how robust our code would be under realistic situations. Once
    we start considering situations like these, we are shifting from examples to illustrate
    our code to tests to thoroughly test our code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬æ­£åœ¨è€ƒè™‘è®¸å¤šæ›´å¤šçš„æƒ…å†µï¼ŒåŒ…æ‹¬ç›¸å½“å¾®å¦™çš„é‚£äº›ï¼Œè¿™äº›æƒ…å†µä¼šå½±å“æˆ‘ä»¬çš„ä»£ç åœ¨ç°å®æƒ…å†µä¸‹çš„é²æ£’æ€§ã€‚ä¸€æ—¦æˆ‘ä»¬å¼€å§‹è€ƒè™‘è¿™äº›æƒ…å†µï¼Œæˆ‘ä»¬å°±ä»ç”¨ç¤ºä¾‹æ¥è¯´æ˜æˆ‘ä»¬çš„ä»£ç è½¬å‘å½»åº•æµ‹è¯•æˆ‘ä»¬çš„ä»£ç ã€‚
- en: 'In Pyret, we use `where` blocks inside function definitions for examples. We
    use a `check` block outside the function definition for tests. For example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pyretä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨å‡½æ•°å®šä¹‰å†…çš„`where`å—ä½œä¸ºç¤ºä¾‹ã€‚æˆ‘ä»¬ä½¿ç”¨å‡½æ•°å®šä¹‰å¤–çš„`check`å—è¿›è¡Œæµ‹è¯•ã€‚ä¾‹å¦‚ï¼š
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As a guiding rule, we put illustrative cases that would help someone else reading
    our code into the `where` block, while we put the nitty-gritty checks that our
    code handles the wider range of usage scenarios (including error cases) into the
    `check`. Sometimes, the line between these two isnâ€™t clear: for example, one could
    easily argue that the second test (the function handles different capitalization)
    belongs in `where` instead. The third test about using a really long list would
    remain in `check`, however, as longer inputs are generally not instructive to
    a reader of your code.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºä¸€æ¡æŒ‡å¯¼åŸåˆ™ï¼Œæˆ‘ä»¬å°†æœ‰åŠ©äºä»–äººé˜…è¯»æˆ‘ä»¬ä»£ç çš„ç¤ºä¾‹æ¡ˆä¾‹æ”¾å…¥`where`å—ä¸­ï¼Œè€Œå°†æˆ‘ä»¬ä»£ç å¤„ç†çš„æ›´å¹¿æ³›çš„ä½¿ç”¨åœºæ™¯ï¼ˆåŒ…æ‹¬é”™è¯¯æƒ…å†µï¼‰çš„ç¹çæ£€æŸ¥æ”¾å…¥`check`å—ä¸­ã€‚æœ‰æ—¶ï¼Œè¿™ä¸¤è€…ä¹‹é—´çš„ç•Œé™å¹¶ä¸æ¸…æ™°ï¼šä¾‹å¦‚ï¼Œæœ‰äººå¯èƒ½ä¼šå¾ˆå®¹æ˜“åœ°äº‰è®ºç¬¬äºŒä¸ªæµ‹è¯•ï¼ˆå‡½æ•°å¤„ç†ä¸åŒçš„é¦–å­—æ¯å¤§å°å†™ï¼‰åº”è¯¥æ”¾åœ¨`where`å—ä¸­ã€‚ç„¶è€Œï¼Œå…³äºä½¿ç”¨éå¸¸é•¿çš„åˆ—è¡¨çš„ç¬¬ä¸‰ä¸ªæµ‹è¯•ä»ç„¶ä¼šä¿ç•™åœ¨`check`å—ä¸­ï¼Œå› ä¸ºè¾ƒé•¿çš„è¾“å…¥é€šå¸¸å¯¹é˜…è¯»ä½ ä»£ç çš„è¯»è€…æ¥è¯´ä¸å…·æœ‰æŒ‡å¯¼æ„ä¹‰ã€‚
- en: 'Putting tests in a block that lives outside the function has another advantage
    at the level of professional programming: it allows your tests to live in a separate
    file from your code. This has two key benefits. First, it makes it easier for
    someone to read the essential parts of your code (if they are building on your
    work). Second, it makes it easier to control when tests are run. When your `check`
    blocks are in the same file as your code, all the tests will be checked when you
    run your code. When they are in a different file, an organization can choose when
    to run the tests. During development, tests are run frequently to make sure no
    errors have been introduced. Once code is tested and ready to be deployed or used,
    tests are not run along with the program (unless there has been a modification
    or someone has discovered an error with the code). This is standard practice in
    software projects.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: å°†æµ‹è¯•æ”¾åœ¨å‡½æ•°å¤–éƒ¨ç‹¬ç«‹å­˜åœ¨çš„å—ä¸­ï¼Œåœ¨ä¸“ä¸šç¼–ç¨‹å±‚é¢è¿˜æœ‰ä¸€ä¸ªä¼˜åŠ¿ï¼šå®ƒå…è®¸ä½ çš„æµ‹è¯•ä¸ä»£ç å­˜å‚¨åœ¨ä¸åŒçš„æ–‡ä»¶ä¸­ã€‚è¿™æœ‰ä¸¤ä¸ªå…³é”®çš„å¥½å¤„ã€‚é¦–å…ˆï¼Œå®ƒä½¿å¾—å…¶ä»–äººé˜…è¯»ä½ ä»£ç çš„æ ¸å¿ƒéƒ¨åˆ†å˜å¾—æ›´åŠ å®¹æ˜“ï¼ˆå¦‚æœä»–ä»¬æ˜¯åœ¨åŸºäºä½ çš„å·¥ä½œæ„å»ºï¼‰ã€‚å…¶æ¬¡ï¼Œå®ƒä½¿å¾—æ§åˆ¶ä½•æ—¶è¿è¡Œæµ‹è¯•å˜å¾—æ›´åŠ å®¹æ˜“ã€‚å½“ä½ çš„`check`å—ä¸ä»£ç ä½äºåŒä¸€æ–‡ä»¶ä¸­æ—¶ï¼Œå½“ä½ è¿è¡Œä»£ç æ—¶ï¼Œæ‰€æœ‰æµ‹è¯•éƒ½ä¼šè¢«æ‰§è¡Œã€‚å½“å®ƒä»¬ä½äºä¸åŒçš„æ–‡ä»¶ä¸­æ—¶ï¼Œç»„ç»‡å¯ä»¥è‡ªè¡Œé€‰æ‹©ä½•æ—¶è¿è¡Œæµ‹è¯•ã€‚åœ¨å¼€å‘è¿‡ç¨‹ä¸­ï¼Œä¸ºäº†ç¡®ä¿æ²¡æœ‰å¼•å…¥é”™è¯¯ï¼Œæµ‹è¯•ä¼šé¢‘ç¹è¿è¡Œã€‚ä¸€æ—¦ä»£ç ç»è¿‡æµ‹è¯•å¹¶å‡†å¤‡å¥½éƒ¨ç½²æˆ–ä½¿ç”¨ï¼Œæµ‹è¯•å°±ä¸ä¼šä¸ç¨‹åºä¸€èµ·è¿è¡Œï¼ˆé™¤éæœ‰ä¿®æ”¹æˆ–æœ‰äººå‘ç°äº†ä»£ç ä¸­çš„é”™è¯¯ï¼‰ã€‚è¿™æ˜¯è½¯ä»¶é¡¹ç›®ä¸­çš„æ ‡å‡†åšæ³•ã€‚
- en: It is also worth noting that the collection of tests grows throughout the development
    process, moreso than do the collection of examples. As you are developing code,
    every time you find a bug in your code, add a test for it in your `check` block
    so you donâ€™t accidentally introduce that same error again later. Whereas we develop
    examples up front as we figure out what we want our program to do, we augment
    our tests as we discover what our program actually does (and perhaps should not
    do). In practice, developers write an initial set of checks on the scenarios they
    thought of before and while writing the code, then expand those tests as they
    try out more scenarios and gain users who report scenarios where the code does
    not work.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œåœ¨æ•´ä¸ªå¼€å‘è¿‡ç¨‹ä¸­ï¼Œæµ‹è¯•é›†åˆçš„å¢é•¿é€Ÿåº¦è¶…è¿‡äº†ç¤ºä¾‹é›†åˆã€‚åœ¨ä½ å¼€å‘ä»£ç çš„è¿‡ç¨‹ä¸­ï¼Œæ¯æ¬¡ä½ å‘ç°ä»£ç ä¸­çš„é”™è¯¯ï¼Œå°±åœ¨ä½ çš„`check`å—ä¸­ä¸ºå®ƒæ·»åŠ ä¸€ä¸ªæµ‹è¯•ï¼Œè¿™æ ·ä½ å°±ä¸å¤ªå¯èƒ½åæ¥å†æ¬¡å¼•å…¥ç›¸åŒçš„é”™è¯¯ã€‚è€Œæˆ‘ä»¬åœ¨ç¡®å®šç¨‹åºè¦åšä»€ä¹ˆæ—¶ï¼Œä¼šæå‰å¼€å‘ç¤ºä¾‹ï¼Œè€Œæˆ‘ä»¬çš„æµ‹è¯•åˆ™æ˜¯éšç€æˆ‘ä»¬äº†è§£ç¨‹åºå®é™…åšä»€ä¹ˆï¼ˆä»¥åŠå¯èƒ½ä¸åº”è¯¥åšä»€ä¹ˆï¼‰è€Œå¢å¼ºã€‚åœ¨å®è·µä¸­ï¼Œå¼€å‘è€…ä¼šåœ¨ç¼–å†™ä»£ç ä¹‹å‰å’Œç¼–å†™ä»£ç çš„è¿‡ç¨‹ä¸­ï¼Œé’ˆå¯¹ä»–ä»¬æƒ³åˆ°çš„åœºæ™¯ç¼–å†™ä¸€ç»„åˆå§‹çš„æ£€æŸ¥ï¼Œç„¶åéšç€ä»–ä»¬å°è¯•æ›´å¤šåœºæ™¯å¹¶è·å¾—æŠ¥å‘Šä»£ç ä¸å·¥ä½œçš„ç”¨æˆ·ï¼Œæ‰©å±•è¿™äº›æµ‹è¯•ã€‚
- en: Nearly all programming languages come with some constructs or packages in which
    you can write tests in separate files. Pyret is unique in supporting the distinction
    between examples and tests (both for learning and for readability of code by others).
    Many programming tools that support professionals expect you to put all tests
    in separate folders and files (offering no support for examples). In this book,
    we emphasize the difference between these two uses of input-output pairs in programming
    because we find them extremely useful both professionally and pedagogically.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: å‡ ä¹æ‰€æœ‰ç¼–ç¨‹è¯­è¨€éƒ½æä¾›äº†ä¸€äº›ç»“æ„æˆ–åŒ…ï¼Œå¯ä»¥åœ¨å•ç‹¬çš„æ–‡ä»¶ä¸­ç¼–å†™æµ‹è¯•ã€‚Pyretçš„ç‹¬ç‰¹ä¹‹å¤„åœ¨äºæ”¯æŒç¤ºä¾‹å’Œæµ‹è¯•ä¹‹é—´çš„åŒºåˆ«ï¼ˆæ—¢é€‚ç”¨äºå­¦ä¹ ï¼Œä¹Ÿé€‚ç”¨äºä»–äººé˜…è¯»ä»£ç çš„å¯è¯»æ€§ï¼‰ã€‚è®¸å¤šæ”¯æŒä¸“ä¸šäººå£«çš„ç¼–ç¨‹å·¥å…·éƒ½æœŸæœ›ä½ å°†æ‰€æœ‰æµ‹è¯•æ”¾åœ¨å•ç‹¬çš„æ–‡ä»¶å¤¹å’Œæ–‡ä»¶ä¸­ï¼ˆä¸æä¾›å¯¹ç¤ºä¾‹çš„æ”¯æŒï¼‰ã€‚åœ¨è¿™æœ¬ä¹¦ä¸­ï¼Œæˆ‘ä»¬å¼ºè°ƒç¼–ç¨‹ä¸­è¾“å…¥è¾“å‡ºå¯¹è¿™ä¸¤ç§ç”¨é€”ä¹‹é—´çš„åŒºåˆ«ï¼Œå› ä¸ºæˆ‘ä»¬å‘ç°å®ƒä»¬åœ¨ä¸“ä¸šå’Œæ•™å­¦æ–¹é¢éƒ½éå¸¸æœ‰ç”¨ã€‚
- en: 8.3.2Â More Refined Comparisons[ğŸ”—](#(part._s~3arefined) "Link to here")
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2 æ›´ç²¾ç»†çš„æ¯”è¾ƒ[ğŸ”—](#(part._s~3arefined) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Sometimes, a direct comparison via `is` isnâ€™t enough for testing. We have already
    seen this in the case of `raises` tests ([Computing Genetic Parents from an Ancestry
    Table](trees.html#%28part._compute-parents-table%29)). As another example, when
    doing some computations, especially involving math with approximations, the exact
    match of `is` isnâ€™t feasible. For example, consider these tests for `distance-to-origin`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶å€™ï¼Œé€šè¿‡`is`è¿›è¡Œçš„ç›´æ¥æ¯”è¾ƒä¸è¶³ä»¥è¿›è¡Œæµ‹è¯•ã€‚æˆ‘ä»¬å·²ç»åœ¨`raises`æµ‹è¯•çš„ä¾‹å­ä¸­çœ‹åˆ°äº†è¿™ä¸€ç‚¹ï¼ˆ[ä»å®¶è°±è¡¨ä¸­è®¡ç®—é—ä¼ çˆ¶æ¯](trees.html#%28part._compute-parents-table%29)ï¼‰ã€‚ä½œä¸ºå¦ä¸€ä¸ªä¾‹å­ï¼Œåœ¨è¿›è¡Œä¸€äº›è®¡ç®—ï¼Œå°¤å…¶æ˜¯æ¶‰åŠè¿‘ä¼¼æ•°å­¦çš„è®¡ç®—æ—¶ï¼Œ`is`çš„ç²¾ç¡®åŒ¹é…æ˜¯ä¸åˆ‡å®é™…çš„ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ä»¥ä¸‹å¯¹`distance-to-origin`çš„æµ‹è¯•ï¼š
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What can we check here? Typing this into the REPL, we can find that the answer
    prints as `1.4142135623730951`. Thatâ€™s an approximation of the real answer, which
    Pyret cannot represent exactly. But itâ€™s hard to know that this precise answer,
    to this decimal place, and no more, is the one we should expect up front, and
    thinking through the answers is supposed to be the first thing we do!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨è¿™é‡Œå¯ä»¥æ£€æŸ¥ä»€ä¹ˆï¼Ÿå°†æ­¤è¾“å…¥åˆ°REPLä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ç­”æ¡ˆæ‰“å°ä¸º`1.4142135623730951`ã€‚è¿™æ˜¯çœŸå®ç­”æ¡ˆçš„è¿‘ä¼¼å€¼ï¼ŒPyretæ— æ³•ç²¾ç¡®è¡¨ç¤ºã€‚ä½†å¾ˆéš¾çŸ¥é“è¿™ä¸ªç²¾ç¡®ç­”æ¡ˆï¼Œåˆ°å°æ•°ç‚¹åè¿™ä¹ˆå¤šä½ï¼Œæ˜¯æˆ‘ä»¬ä¸€å¼€å§‹å°±åº”è¯¥é¢„æœŸçš„ï¼Œè€Œä¸”é€šè¿‡æ€è€ƒç­”æ¡ˆåº”è¯¥æ˜¯æˆ‘ä»¬é¦–å…ˆåšçš„äº‹æƒ…ï¼
- en: Since we know weâ€™re getting an approximation, we can really only check that
    the answer is roughly correct, not exactly correct. If we can check that the answer
    to `distance-to-origin(point(1, 1))` is around, say, `1.41`, and can do the same
    for some similar cases, thatâ€™s probably good enough for many applications, and
    for our purposes here. If we were calculating orbital dynamics, we might demand
    higher precision, but note that weâ€™d still need to pick a cutoff! Testing for
    inexact results is a necessary task.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæˆ‘ä»¬çŸ¥é“æˆ‘ä»¬å¾—åˆ°çš„æ˜¯ä¸€ä¸ªè¿‘ä¼¼å€¼ï¼Œæˆ‘ä»¬å®é™…ä¸Šåªèƒ½æ£€æŸ¥ç­”æ¡ˆæ˜¯å¦å¤§è‡´æ­£ç¡®ï¼Œè€Œä¸æ˜¯å®Œå…¨æ­£ç¡®ã€‚å¦‚æœæˆ‘ä»¬èƒ½æ£€æŸ¥`distance-to-origin(point(1,
    1))`çš„ç­”æ¡ˆå¤§çº¦æ˜¯ï¼Œæ¯”å¦‚è¯´ï¼Œ`1.41`ï¼Œå¹¶ä¸”å¯ä»¥å¯¹ä¸€äº›ç±»ä¼¼çš„æƒ…å†µåšåŒæ ·çš„æ£€æŸ¥ï¼Œé‚£ä¹ˆè¿™å¾ˆå¯èƒ½å¯¹è®¸å¤šåº”ç”¨ä»¥åŠæˆ‘ä»¬çš„ç›®çš„æ¥è¯´å·²ç»è¶³å¤Ÿå¥½äº†ã€‚å¦‚æœæˆ‘ä»¬æ­£åœ¨è®¡ç®—è½¨é“åŠ¨åŠ›å­¦ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šè¦æ±‚æ›´é«˜çš„ç²¾åº¦ï¼Œä½†è¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä»ç„¶éœ€è¦é€‰æ‹©ä¸€ä¸ªæˆªæ­¢å€¼ï¼æµ‹è¯•ä¸ç²¾ç¡®çš„ç»“æœæ˜¯ä¸€ä¸ªå¿…è¦çš„ä»»åŠ¡ã€‚
- en: 'Letâ€™s first define what we mean by â€œaroundâ€ with one of the most precise ways
    we can, a function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é¦–å…ˆç”¨æˆ‘ä»¬èƒ½å¤Ÿçš„æœ€ç²¾ç¡®çš„æ–¹å¼å®šä¹‰â€œå¤§çº¦â€çš„å«ä¹‰ï¼Œå³é€šè¿‡ä¸€ä¸ªå‡½æ•°ï¼š
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `is` form now helps us out. There is special syntax for supplying a user-defined
    function to use to compare the two values, instead of just checking if they are
    equal:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨çš„`is`å½¢å¼å¯¹æˆ‘ä»¬æœ‰æ‰€å¸®åŠ©ã€‚æœ‰ä¸€ç§ç‰¹æ®Šçš„è¯­æ³•å¯ä»¥ç”¨æ¥æä¾›ä¸€ä¸ªç”¨æˆ·å®šä¹‰çš„å‡½æ•°æ¥æ¯”è¾ƒä¸¤ä¸ªå€¼ï¼Œè€Œä¸æ˜¯ä»…ä»…æ£€æŸ¥å®ƒä»¬æ˜¯å¦ç›¸ç­‰ï¼š
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Adding `%(something)` after `is` changes the behavior of `is`. Normally, it
    would compare the left and right values for equality. If something is provided
    with `%`, however, it instead passes the left and right values to the provided
    function (in this example `around`). If the provided function produces `true`,
    the test passes, if it produces `false`, the test fails. This gives us the control
    we need to test functions with predictable approximate results.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨`is`ä¹‹åæ·»åŠ `%(something)`ä¼šæ”¹å˜`is`çš„è¡Œä¸ºã€‚é€šå¸¸ï¼Œå®ƒä¼šæ¯”è¾ƒå·¦å³ä¸¤è¾¹çš„å€¼æ˜¯å¦ç›¸ç­‰ã€‚ç„¶è€Œï¼Œå¦‚æœæä¾›äº†`%`ï¼Œå®ƒå°±ä¼šå°†å·¦å³ä¸¤è¾¹çš„å€¼ä¼ é€’ç»™æä¾›çš„å‡½æ•°ï¼ˆåœ¨è¿™ä¸ªä¾‹å­ä¸­æ˜¯`around`ï¼‰ã€‚å¦‚æœæä¾›çš„å‡½æ•°äº§ç”Ÿ`true`ï¼Œåˆ™æµ‹è¯•é€šè¿‡ï¼Œå¦‚æœäº§ç”Ÿ`false`ï¼Œåˆ™æµ‹è¯•å¤±è´¥ã€‚è¿™ç»™äº†æˆ‘ä»¬æµ‹è¯•å…·æœ‰å¯é¢„æµ‹è¿‘ä¼¼ç»“æœçš„å‡½æ•°æ‰€éœ€çš„æ§åˆ¶ã€‚
- en: Exercise
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend the definition of `distance-to-origin` to include `polar` points.
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ‰©å±•`distance-to-origin`çš„å®šä¹‰ï¼ŒåŒ…æ‹¬æåæ ‡ç‚¹ã€‚
- en: Exercise
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This might save you a Google search: [polar conversions](http://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates).
    Use the design recipe to write `x-component` and `y-component`, which return the
    `x` and `y` Cartesian parts of the point (which you would need, for example, if
    you were plotting them on a graph). Read about `num-sin` and other functions youâ€™ll
    need at [the Pyret number documentation](http://www.pyret.org/docs/latest/numbers.html).'
  id: totrans-40
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™å¯èƒ½å¯ä»¥èŠ‚çœä½ ä¸€æ¬¡è°·æ­Œæœç´¢ï¼š[æåæ ‡è½¬æ¢](http://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates)ã€‚ä½¿ç”¨è®¾è®¡é£Ÿè°±ç¼–å†™
    `x-component` å’Œ `y-component` å‡½æ•°ï¼Œå®ƒä»¬è¿”å›ç‚¹çš„ `x` å’Œ `y` åæ ‡éƒ¨åˆ†ï¼ˆä¾‹å¦‚ï¼Œå¦‚æœä½ è¦åœ¨å›¾ä¸Šç»˜åˆ¶å®ƒä»¬çš„è¯ï¼‰ã€‚åœ¨[Pyretæ•°å­—æ–‡æ¡£](http://www.pyret.org/docs/latest/numbers.html)ä¸­äº†è§£
    `num-sin` å’Œå…¶ä»–ä½ éœ€è¦ä½¿ç”¨çš„å‡½æ•°ã€‚
- en: Exercise
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write a data definition called `Pay` for pay types that includes both hourly
    employees, whose pay type includes an hourly rate, and salaried employees, whose
    pay type includes a total salary for the year. Use the design recipe to write
    a function called `expected-weekly-wages` that takes a `Pay`, and returns the
    expected weekly salary: the expected weekly salary for an hourly employee assumes
    they work 40 hours, and the expected weekly salary for a salaried employee is
    1/52 of their salary.'
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªåä¸º `Pay` çš„æ•°æ®å®šä¹‰ï¼Œç”¨äºæ”¯ä»˜ç±»å‹ï¼ŒåŒ…æ‹¬æŒ‰å°æ—¶æ”¯ä»˜çš„å‘˜å·¥ï¼Œå…¶æ”¯ä»˜ç±»å‹åŒ…æ‹¬å°æ—¶å·¥èµ„ï¼Œä»¥åŠå¹´è–ªå‘˜å·¥ï¼Œå…¶æ”¯ä»˜ç±»å‹åŒ…æ‹¬ä¸€å¹´çš„æ€»å·¥èµ„ã€‚ä½¿ç”¨è®¾è®¡é£Ÿè°±ç¼–å†™ä¸€ä¸ªåä¸º
    `expected-weekly-wages` çš„å‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ª `Pay` å‚æ•°ï¼Œå¹¶è¿”å›é¢„æœŸçš„æ¯å‘¨å·¥èµ„ï¼šæŒ‰å°æ—¶æ”¯ä»˜çš„å‘˜å·¥çš„é¢„æœŸæ¯å‘¨å·¥èµ„å‡è®¾ä»–ä»¬å·¥ä½œ40å°æ—¶ï¼Œè€Œå¹´è–ªå‘˜å·¥çš„é¢„æœŸæ¯å‘¨å·¥èµ„æ˜¯ä»–ä»¬å¹´è–ªçš„1/52ã€‚
- en: 8.3.3Â When Tests Fail[ğŸ”—](#(part._.When_.Tests_.Fail) "Link to here")
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3 å½“æµ‹è¯•å¤±è´¥[ğŸ”—](#(part._.When_.Tests_.Fail) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Suppose weâ€™ve written the function `sqrt`, which computes the square root of
    a given number. Weâ€™ve written some tests for this function. We run the program,
    and find that a test fails. There are two obvious reasons why this can happen.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬ç¼–å†™äº†ä¸€ä¸ªåä¸º `sqrt` çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°è®¡ç®—ç»™å®šæ•°å­—çš„å¹³æ–¹æ ¹ã€‚æˆ‘ä»¬ä¸ºè¿™ä¸ªå‡½æ•°ç¼–å†™äº†ä¸€äº›æµ‹è¯•ã€‚æˆ‘ä»¬è¿è¡Œç¨‹åºï¼Œå‘ç°ä¸€ä¸ªæµ‹è¯•å¤±è´¥äº†ã€‚æœ‰ä¸¤ä¸ªæ˜æ˜¾çš„ç†ç”±å¯èƒ½å¯¼è‡´è¿™ç§æƒ…å†µå‘ç”Ÿã€‚
- en: Do Now!
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the two obvious reasons?
  id: totrans-48
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æœ‰ä¸¤ä¸ªæ˜æ˜¾çš„ç†ç”±å—ï¼Ÿ
- en: 'The two reasons are, of course, the two â€œsidesâ€ of the test: the problem could
    be with the values weâ€™ve written or with the function weâ€™ve written. For instance,
    if weâ€™ve written'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œä¸¤ä¸ªåŸå› æ˜¯æµ‹è¯•çš„ä¸¤ä¸ªâ€œæ–¹é¢â€ï¼šé—®é¢˜å¯èƒ½å‡ºåœ¨æˆ‘ä»¬å†™çš„å€¼ä¸Šï¼Œä¹Ÿå¯èƒ½å‡ºåœ¨æˆ‘ä»¬å†™çš„å‡½æ•°ä¸Šã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬å†™äº†
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: then the fault clearly lies with the values (because \(1.75^2\) is clearly not
    \(4\)). On the other hand, if it fails the test
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œå¾ˆæ˜æ˜¾é”™è¯¯å‡ºåœ¨æˆ‘ä»¬å†™çš„å€¼ä¸Šï¼ˆå› ä¸º \(1.75^2\) æ˜æ˜¾ä¸æ˜¯ \(4\)ï¼‰ã€‚å¦ä¸€æ–¹é¢ï¼Œå¦‚æœå®ƒæœªèƒ½é€šè¿‡æµ‹è¯•
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: then the odds are that weâ€™ve made an error in the definition of `sqrt` instead,
    and thatâ€™s what we need to fix.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œå¾ˆå¯èƒ½æ˜¯æˆ‘ä»¬åœ¨ `sqrt` çš„å®šä¹‰ä¸­çŠ¯äº†é”™è¯¯ï¼Œè¿™æ˜¯æˆ‘ä»¬éœ€è¦ä¿®å¤çš„ã€‚
- en: Note that there is no way for the computer to tell what went wrong. When it
    reports a test failure, all itâ€™s saying is that there is an inconsistency between
    the program and the tests. The computer is not passing judgment on which one is
    â€œcorrectâ€, because it canâ€™t do that. That is a matter for human judgment.For this
    reason, weâ€™ve been doing research on [peer review of tests](http://cs.brown.edu/~sk/Publications/Papers/Published/pkf-ifpr-tests-tf-prog/),
    so students can help one another review their tests before they begin writing
    programs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè®¡ç®—æœºæ— æ³•çŸ¥é“å‡ºäº†ä»€ä¹ˆé—®é¢˜ã€‚å½“å®ƒæŠ¥å‘Šæµ‹è¯•å¤±è´¥æ—¶ï¼Œå®ƒåªæ˜¯åœ¨è¯´ç¨‹åºå’Œæµ‹è¯•ä¹‹é—´å­˜åœ¨ä¸ä¸€è‡´ã€‚è®¡ç®—æœºä¸ä¼šå¯¹å“ªä¸ªæ˜¯â€œæ­£ç¡®çš„â€åšå‡ºåˆ¤æ–­ï¼Œå› ä¸ºå®ƒåšä¸åˆ°ã€‚è¿™æ˜¯ä¸€ä¸ªéœ€è¦äººç±»åˆ¤æ–­çš„é—®é¢˜ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¸€ç›´åœ¨ç ”ç©¶[æµ‹è¯•åŒè¡Œè¯„å®¡](http://cs.brown.edu/~sk/Publications/Papers/Published/pkf-ifpr-tests-tf-prog/)ï¼Œä»¥ä¾¿å­¦ç”Ÿåœ¨å¼€å§‹ç¼–å†™ç¨‹åºä¹‹å‰äº’ç›¸å¸®åŠ©å®¡æŸ¥ä»–ä»¬çš„æµ‹è¯•ã€‚
- en: 'Actually...not so fast. Thereâ€™s one more possibility we didnâ€™t consider: the
    third, not-so-obvious reason why a test might fail. Return to this test:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Š...å¹¶ä¸é‚£ä¹ˆå¿«ã€‚è¿˜æœ‰ä¸€ä¸ªæˆ‘ä»¬æ²¡æœ‰è€ƒè™‘çš„å¯èƒ½æ€§ï¼šç¬¬ä¸‰ä¸ªä¸é‚£ä¹ˆæ˜æ˜¾çš„ç†ç”±ï¼Œé‚£å°±æ˜¯æµ‹è¯•å¯èƒ½å¤±è´¥çš„åŸå› ã€‚å›åˆ°è¿™ä¸ªæµ‹è¯•ï¼š
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Clearly the inputs and outputs are correct, but it could be that the definition
    of `sqrt` is also correct, and yet the test fails.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¾ç„¶è¾“å…¥å’Œè¾“å‡ºéƒ½æ˜¯æ­£ç¡®çš„ï¼Œä½†å¯èƒ½æ˜¯ `sqrt` çš„å®šä¹‰ä¹Ÿæ˜¯æ­£ç¡®çš„ï¼Œä½†æµ‹è¯•å´å¤±è´¥äº†ã€‚
- en: Do Now!
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see why?
  id: totrans-60
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ çœ‹æ‡‚äº†å—ï¼Ÿ
- en: Depending on how weâ€™ve programmed `sqrt`, it might return the root `-2` instead
    of `2`. Now `-2` is a perfectly good answer, too. That is, neither the function
    nor the particular set of test values we specified is inherently wrong; itâ€™s just
    that the function happens to be a relation, i.e., it maps one input to multiple
    outputs (that is, \(\sqrt{4} = \pm 2\)). The question now is how to write the
    test properly.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¹æ®æˆ‘ä»¬å¦‚ä½•ç¼–ç¨‹`sqrt`ï¼Œå®ƒå¯èƒ½è¿”å›`-2`è€Œä¸æ˜¯`2`ã€‚ç°åœ¨`-2`ä¹Ÿæ˜¯ä¸€ä¸ªå®Œç¾çš„ç­”æ¡ˆã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå‡½æ•°ä»¥åŠæˆ‘ä»¬æŒ‡å®šçš„ç‰¹å®šæµ‹è¯•å€¼é›†æœ¬èº«å¹¶æ²¡æœ‰é”™è¯¯ï¼›åªæ˜¯å‡½æ•°ç¢°å·§æ˜¯ä¸€ä¸ªå…³ç³»ï¼Œå³å®ƒå°†ä¸€ä¸ªè¾“å…¥æ˜ å°„åˆ°å¤šä¸ªè¾“å‡ºï¼ˆå³\(\sqrt{4}
    = \pm 2\))ã€‚ç°åœ¨çš„é—®é¢˜æ˜¯ï¼Œå¦‚ä½•æ­£ç¡®ç¼–å†™æµ‹è¯•ã€‚
- en: 8.3.4Â Oracles for Testing[ğŸ”—](#(part._test-oracle) "Link to here")
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.4 æµ‹è¯•çš„é¢„è¨€è€…[ğŸ”—](#(part._test-oracle) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'In other words, sometimes what we want to express is not a concrete input-output
    pair, but rather check that the output has the right relationship to the input.
    Concretely, what might this be in the case of `sqrt`? We hinted at this earlier
    when we said that `1.75` clearly canâ€™t be right, because squaring it does not
    yield `4`. That gives us the general insight: that a number is a valid root (note
    the use of â€œaâ€ instead of â€œtheâ€) if squaring it yields the original number. That
    is, we might write a function like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: æ¢å¥è¯è¯´ï¼Œæœ‰æ—¶æˆ‘ä»¬æƒ³è¦è¡¨è¾¾çš„ä¸æ˜¯å…·ä½“çš„è¾“å…¥è¾“å‡ºå¯¹ï¼Œè€Œæ˜¯æ£€æŸ¥è¾“å‡ºä¸è¾“å…¥ä¹‹é—´æ˜¯å¦æœ‰æ­£ç¡®çš„å…³ç³»ã€‚å…·ä½“æ¥è¯´ï¼Œåœ¨`sqrt`çš„æƒ…å†µä¸‹ï¼Œè¿™å¯èƒ½æ˜¯æ€æ ·çš„ï¼Ÿæˆ‘ä»¬ä¹‹å‰åœ¨è¯´`1.75`æ˜¾ç„¶ä¸å¯èƒ½æ˜¯æ­£ç¡®çš„ï¼Œå› ä¸ºå¹³æ–¹å®ƒä¸ä¼šå¾—åˆ°`4`æ—¶ï¼Œå·²ç»æš—ç¤ºäº†è¿™ä¸€ç‚¹ã€‚è¿™ç»™äº†æˆ‘ä»¬ä¸€èˆ¬çš„æ´å¯Ÿï¼šä¸€ä¸ªæ•°æ˜¯æœ‰æ•ˆçš„æ ¹ï¼ˆæ³¨æ„ä½¿ç”¨â€œaâ€è€Œä¸æ˜¯â€œtheâ€ï¼‰ï¼Œå¦‚æœå¹³æ–¹å®ƒå¾—åˆ°åŸå§‹æ•°å­—ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯èƒ½ç¼–å†™ä¸€ä¸ªåƒè¿™æ ·çš„å‡½æ•°ï¼š
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: and then our test looks like
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬çš„æµ‹è¯•çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Unfortunately, this has an awkward failure case. If `sqrt` does not produce
    a number that is in fact a root, we arenâ€™t told what the actual value is; instead,
    `is-sqrt` returns false, and the test failure just says that `false` (what `is-sqrt`
    returns) is not `true` (what the test expects)â€”<wbr>which is both absolutely true
    and utterly useless.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œè¿™æœ‰ä¸€ä¸ªå°´å°¬çš„å¤±è´¥æ¡ˆä¾‹ã€‚å¦‚æœ`sqrt`æ²¡æœ‰äº§ç”Ÿå®é™…ä¸Šæ˜¯ä¸€ä¸ªæ ¹çš„æ•°å­—ï¼Œæˆ‘ä»¬ä¸ä¼šè¢«å‘ŠçŸ¥å®é™…å€¼æ˜¯ä»€ä¹ˆï¼›ç›¸åï¼Œ`is-sqrt`è¿”å›falseï¼Œæµ‹è¯•å¤±è´¥åªæ˜¯è¯´`false`ï¼ˆ`is-sqrt`è¿”å›çš„ï¼‰ä¸æ˜¯`true`ï¼ˆæµ‹è¯•æœŸæœ›çš„ï¼‰â€”â€”<wbr>è¿™æ—¢æ˜¯ç»å¯¹æ­£ç¡®çš„ï¼Œä¹Ÿæ˜¯æ¯«æ— ç”¨å¤„çš„ã€‚
- en: 'Fortunately, Pyret has a better way of expressing the same check. Instead of
    `is`, we can write `satisfies`, and then the value on the left must satisfy the
    predicate on the right. Concretely, this looks like:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¸è¿çš„æ˜¯ï¼ŒPyretæœ‰æ›´å¥½çš„æ–¹å¼æ¥è¡¨è¾¾ç›¸åŒçš„æ£€æŸ¥ã€‚æˆ‘ä»¬ä¸éœ€è¦ä½¿ç”¨`is`ï¼Œè€Œæ˜¯å¯ä»¥å†™`satisfies`ï¼Œç„¶åå·¦è¾¹çš„å€¼å¿…é¡»æ»¡è¶³å³è¾¹çš„è°“è¯ã€‚å…·ä½“æ¥è¯´ï¼Œè¿™çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'which lets us write:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è®©æˆ‘ä»¬å¯ä»¥å†™å‡ºï¼š
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, if thereâ€™s a failure, we learn of the actual value produced by `sqrt(4)`
    that failed to satisfy the predicate.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œå¦‚æœå‡ºç°å¤±è´¥ï¼Œæˆ‘ä»¬ä¼šäº†è§£åˆ°`sqrt(4)`æœªèƒ½æ»¡è¶³è°“è¯çš„å®é™…å€¼ã€‚
- en: 8.3.1Â From Examples to Tests[ğŸ”—](#(part._from-examples-to-tests) "Link to here")
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1 ä»ç¤ºä¾‹åˆ°æµ‹è¯•[ğŸ”—](#(part._from-examples-to-tests) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Until now, we have written examples in `where:` blocks for two purposes: to
    help us figure out what a function needs to do, and to provide guidance to someone
    reading our code as to what behavior they can expect when using our function.
    For the smaller programs that we have written until now, `where`-based examples
    have been sufficient. As our programs get more complicated, however, a small set
    of related illustrative examples wonâ€™t suffice. We need to think about being much
    more thorough in the sets of inputs that we consider.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»åœ¨`where:`å—ä¸­ç¼–å†™äº†ç¤ºä¾‹ï¼Œç”¨äºä¸¤ä¸ªç›®çš„ï¼šå¸®åŠ©æˆ‘ä»¬å¼„æ¸…æ¥šå‡½æ•°éœ€è¦åšä»€ä¹ˆï¼Œå¹¶ä¸ºé˜…è¯»æˆ‘ä»¬ä»£ç çš„äººæä¾›æŒ‡å¯¼ï¼Œå‘Šè¯‰ä»–ä»¬åœ¨ä½¿ç”¨æˆ‘ä»¬çš„å‡½æ•°æ—¶å¯ä»¥æœŸå¾…ä»€ä¹ˆè¡Œä¸ºã€‚å¯¹äºåˆ°ç›®å‰ä¸ºæ­¢æˆ‘ä»¬ç¼–å†™çš„è¾ƒå°ç¨‹åºï¼ŒåŸºäº`where`çš„ç¤ºä¾‹å·²ç»è¶³å¤Ÿäº†ã€‚ç„¶è€Œï¼Œéšç€æˆ‘ä»¬çš„ç¨‹åºå˜å¾—æ›´åŠ å¤æ‚ï¼Œä¸€ç»„ç›¸å…³è¯´æ˜æ€§ç¤ºä¾‹å°±ä¸å¤Ÿäº†ã€‚æˆ‘ä»¬éœ€è¦è€ƒè™‘åœ¨è€ƒè™‘è¾“å…¥é›†æ—¶æ›´åŠ å½»åº•ã€‚
- en: Consider for example a function `count-uses` that counts how many times a specific
    string appears in a list (this could be used to tally votes, to compute the frequency
    of using a discount code, and so on). What input scenarios might we need to check
    before using our function to run an actual election or a business?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œè€ƒè™‘ä¸€ä¸ª`count-uses`å‡½æ•°ï¼Œå®ƒè®¡ç®—ä¸€ä¸ªç‰¹å®šå­—ç¬¦ä¸²åœ¨åˆ—è¡¨ä¸­å‡ºç°çš„æ¬¡æ•°ï¼ˆè¿™å¯ä»¥ç”¨æ¥ç»Ÿè®¡é€‰ç¥¨ï¼Œè®¡ç®—ä½¿ç”¨æŠ˜æ‰£ä»£ç çš„é¢‘ç‡ç­‰ç­‰ï¼‰ã€‚åœ¨ä½¿ç”¨æˆ‘ä»¬çš„å‡½æ•°è¿›è¡Œå®é™…é€‰ä¸¾æˆ–å•†ä¸šæ´»åŠ¨ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥å“ªäº›è¾“å…¥åœºæ™¯ï¼Ÿ
- en: The result for a string that is in the list once
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ä¸­åªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦ä¸²çš„ç»“æœ
- en: The result for a string that is in the list multiple times
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ä¸­å¤šæ¬¡å‡ºç°çš„å­—ç¬¦ä¸²çš„ç»“æœ
- en: The result for a string that is at the end of a longer list (to make sure we
    are checking all of the elements)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºä½äºè¾ƒé•¿åˆ—è¡¨æœ«å°¾çš„å­—ç¬¦ä¸²çš„ç»“æœï¼ˆä»¥ç¡®ä¿æˆ‘ä»¬æ£€æŸ¥äº†æ‰€æœ‰å…ƒç´ ï¼‰
- en: The result for a string that isnâ€™t in the list
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸åœ¨åˆ—è¡¨ä¸­çš„å­—ç¬¦ä¸²çš„ç»“æœ
- en: The result for a string that is in the list but with different capitalization
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“å­—ç¬¦ä¸²åœ¨åˆ—è¡¨ä¸­ä½†å¤§å°å†™ä¸åŒæ—¶çš„ç»“æœ
- en: The result for a string that is a typo-away from a word in the list
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“å­—ç¬¦ä¸²ä¸åˆ—è¡¨ä¸­çš„å•è¯åªæœ‰ä¸€ä¸ªæ‹¼å†™é”™è¯¯æ—¶çš„ç»“æœ
- en: Notice that here we are considering many more situations, including fairly nuanced
    ones that affect how robust our code would be under realistic situations. Once
    we start considering situations like these, we are shifting from examples to illustrate
    our code to tests to thoroughly test our code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™é‡Œæˆ‘ä»¬è€ƒè™‘äº†è®¸å¤šæ›´å¤šçš„æƒ…å†µï¼ŒåŒ…æ‹¬ç›¸å½“å¾®å¦™çš„é‚£äº›ï¼Œè¿™äº›æƒ…å†µä¼šå½±å“æˆ‘ä»¬çš„ä»£ç åœ¨ç°å®æƒ…å†µä¸‹çš„é²æ£’æ€§ã€‚ä¸€æ—¦æˆ‘ä»¬å¼€å§‹è€ƒè™‘è¿™äº›æƒ…å†µï¼Œæˆ‘ä»¬å°±ä»ç”¨ç¤ºä¾‹æ¥è¯´æ˜æˆ‘ä»¬çš„ä»£ç è½¬å‘å½»åº•æµ‹è¯•æˆ‘ä»¬çš„ä»£ç ã€‚
- en: 'In Pyret, we use `where` blocks inside function definitions for examples. We
    use a `check` block outside the function definition for tests. For example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨å‡½æ•°å®šä¹‰å†…çš„ `where` å—ä½œä¸ºç¤ºä¾‹ã€‚æˆ‘ä»¬ä½¿ç”¨å‡½æ•°å®šä¹‰å¤–çš„ `check` å—è¿›è¡Œæµ‹è¯•ã€‚ä¾‹å¦‚ï¼š
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As a guiding rule, we put illustrative cases that would help someone else reading
    our code into the `where` block, while we put the nitty-gritty checks that our
    code handles the wider range of usage scenarios (including error cases) into the
    `check`. Sometimes, the line between these two isnâ€™t clear: for example, one could
    easily argue that the second test (the function handles different capitalization)
    belongs in `where` instead. The third test about using a really long list would
    remain in `check`, however, as longer inputs are generally not instructive to
    a reader of your code.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæŒ‡å¯¼åŸåˆ™ï¼Œæˆ‘ä»¬å°†æœ‰åŠ©äºå…¶ä»–äººé˜…è¯»æˆ‘ä»¬ä»£ç çš„ç¤ºä¾‹æ¡ˆä¾‹æ”¾å…¥ `where` å—ï¼Œè€Œå°†æˆ‘ä»¬ä»£ç å¤„ç†çš„æ›´å¹¿æ³›çš„ç”¨æ³•åœºæ™¯ï¼ˆåŒ…æ‹¬é”™è¯¯æƒ…å†µï¼‰çš„ç¹çæ£€æŸ¥æ”¾å…¥ `check`ã€‚æœ‰æ—¶ï¼Œè¿™ä¸¤è€…ä¹‹é—´çš„ç•Œé™å¹¶ä¸æ¸…æ™°ï¼šä¾‹å¦‚ï¼Œæœ‰äººå¯èƒ½ä¼šå¾ˆå®¹æ˜“åœ°äº‰è®ºç¬¬äºŒä¸ªæµ‹è¯•ï¼ˆå‡½æ•°å¤„ç†ä¸åŒçš„å¤§å°å†™ï¼‰åº”è¯¥æ”¾åœ¨
    `where` ä¸­ã€‚ç„¶è€Œï¼Œå…³äºä½¿ç”¨éå¸¸é•¿çš„åˆ—è¡¨çš„ç¬¬ä¸‰ä¸ªæµ‹è¯•å°†ä¿ç•™åœ¨ `check` ä¸­ï¼Œå› ä¸ºè¾ƒé•¿çš„è¾“å…¥é€šå¸¸å¯¹é˜…è¯»ä½ ä»£ç çš„äººä¸å…·æœ‰æŒ‡å¯¼æ„ä¹‰ã€‚
- en: 'Putting tests in a block that lives outside the function has another advantage
    at the level of professional programming: it allows your tests to live in a separate
    file from your code. This has two key benefits. First, it makes it easier for
    someone to read the essential parts of your code (if they are building on your
    work). Second, it makes it easier to control when tests are run. When your `check`
    blocks are in the same file as your code, all the tests will be checked when you
    run your code. When they are in a different file, an organization can choose when
    to run the tests. During development, tests are run frequently to make sure no
    errors have been introduced. Once code is tested and ready to be deployed or used,
    tests are not run along with the program (unless there has been a modification
    or someone has discovered an error with the code). This is standard practice in
    software projects.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: å°†æµ‹è¯•æ”¾åœ¨å‡½æ•°å¤–éƒ¨çš„å—ä¸­ï¼Œåœ¨ä¸“ä¸šç¼–ç¨‹å±‚é¢ä¸Šè¿˜æœ‰ä¸€ä¸ªä¼˜ç‚¹ï¼šå®ƒå…è®¸ä½ çš„æµ‹è¯•ä¸ä»£ç å­˜å‚¨åœ¨ä¸åŒçš„æ–‡ä»¶ä¸­ã€‚è¿™æœ‰ä¸¤ä¸ªå…³é”®çš„å¥½å¤„ã€‚é¦–å…ˆï¼Œå®ƒä½¿å¾—å…¶ä»–äººæ›´å®¹æ˜“é˜…è¯»ä½ ä»£ç çš„å…³é”®éƒ¨åˆ†ï¼ˆå¦‚æœä»–ä»¬æ­£åœ¨åŸºäºä½ çš„å·¥ä½œæ„å»ºï¼‰ã€‚å…¶æ¬¡ï¼Œå®ƒä½¿å¾—æ§åˆ¶æµ‹è¯•è¿è¡Œçš„æ—¶é—´æ›´å®¹æ˜“ã€‚å½“ä½ çš„
    `check` å—ä¸ä»£ç åœ¨åŒä¸€æ–‡ä»¶ä¸­æ—¶ï¼Œå½“ä½ è¿è¡Œä»£ç æ—¶ï¼Œæ‰€æœ‰æµ‹è¯•éƒ½ä¼šè¢«æ£€æŸ¥ã€‚å½“å®ƒä»¬åœ¨ä¸åŒçš„æ–‡ä»¶ä¸­æ—¶ï¼Œç»„ç»‡å¯ä»¥å†³å®šä½•æ—¶è¿è¡Œæµ‹è¯•ã€‚åœ¨å¼€å‘è¿‡ç¨‹ä¸­ï¼Œé¢‘ç¹è¿è¡Œæµ‹è¯•ä»¥ç¡®ä¿æ²¡æœ‰å¼•å…¥é”™è¯¯ã€‚ä¸€æ—¦ä»£ç ç»è¿‡æµ‹è¯•å¹¶å‡†å¤‡å¥½éƒ¨ç½²æˆ–ä½¿ç”¨ï¼Œå°±ä¸ä¼šä¸ç¨‹åºä¸€èµ·è¿è¡Œæµ‹è¯•ï¼ˆé™¤éæœ‰ä¿®æ”¹æˆ–æœ‰äººå‘ç°ä»£ç ä¸­çš„é”™è¯¯ï¼‰ã€‚è¿™æ˜¯è½¯ä»¶é¡¹ç›®ä¸­çš„æ ‡å‡†åšæ³•ã€‚
- en: It is also worth noting that the collection of tests grows throughout the development
    process, moreso than do the collection of examples. As you are developing code,
    every time you find a bug in your code, add a test for it in your `check` block
    so you donâ€™t accidentally introduce that same error again later. Whereas we develop
    examples up front as we figure out what we want our program to do, we augment
    our tests as we discover what our program actually does (and perhaps should not
    do). In practice, developers write an initial set of checks on the scenarios they
    thought of before and while writing the code, then expand those tests as they
    try out more scenarios and gain users who report scenarios where the code does
    not work.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œåœ¨æ•´ä¸ªå¼€å‘è¿‡ç¨‹ä¸­ï¼Œæµ‹è¯•é›†åˆçš„å¢é•¿é€Ÿåº¦è¶…è¿‡äº†ç¤ºä¾‹é›†åˆã€‚å½“ä½ å¼€å‘ä»£ç æ—¶ï¼Œæ¯æ¬¡ä½ åœ¨ä»£ç ä¸­å‘ç°é”™è¯¯ï¼Œå°±åœ¨ä½ çš„ `check` å—ä¸­ä¸ºå®ƒæ·»åŠ ä¸€ä¸ªæµ‹è¯•ï¼Œè¿™æ ·ä½ å°±ä¸å¤ªå¯èƒ½å†æ¬¡æ„å¤–åœ°å¼•å…¥ç›¸åŒçš„é”™è¯¯ã€‚è€Œæˆ‘ä»¬åœ¨ç¡®å®šç¨‹åºè¦åšä»€ä¹ˆæ—¶ï¼Œä¼šæå‰å¼€å‘ç¤ºä¾‹ï¼Œä½†éšç€æˆ‘ä»¬äº†è§£ç¨‹åºå®é™…åšä»€ä¹ˆï¼ˆä»¥åŠå¯èƒ½ä¸åº”è¯¥åšä»€ä¹ˆï¼‰ï¼Œæˆ‘ä»¬ä¼šå¢å¼ºæˆ‘ä»¬çš„æµ‹è¯•ã€‚åœ¨å®è·µä¸­ï¼Œå¼€å‘è€…ä¼šåœ¨ç¼–å†™ä»£ç ä¹‹å‰å’Œç¼–å†™ä»£ç çš„è¿‡ç¨‹ä¸­ï¼Œå¯¹æƒ³åˆ°çš„åœºæ™¯ç¼–å†™åˆå§‹çš„æ£€æŸ¥ï¼Œç„¶ååœ¨å°è¯•æ›´å¤šåœºæ™¯å¹¶è·å¾—æŠ¥å‘Šä»£ç ä¸å·¥ä½œçš„ç”¨æˆ·æ—¶ï¼Œæ‰©å±•è¿™äº›æµ‹è¯•ã€‚
- en: Nearly all programming languages come with some constructs or packages in which
    you can write tests in separate files. Pyret is unique in supporting the distinction
    between examples and tests (both for learning and for readability of code by others).
    Many programming tools that support professionals expect you to put all tests
    in separate folders and files (offering no support for examples). In this book,
    we emphasize the difference between these two uses of input-output pairs in programming
    because we find them extremely useful both professionally and pedagogically.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: å‡ ä¹æ‰€æœ‰ç¼–ç¨‹è¯­è¨€éƒ½æä¾›äº†ä¸€äº›ç»“æ„æˆ–åŒ…ï¼Œå…è®¸ä½ åœ¨å•ç‹¬çš„æ–‡ä»¶ä¸­ç¼–å†™æµ‹è¯•ã€‚Pyret åœ¨æ”¯æŒåŒºåˆ†ç¤ºä¾‹å’Œæµ‹è¯•ï¼ˆæ—¢é€‚ç”¨äºå­¦ä¹ ï¼Œä¹Ÿé€‚ç”¨äºä»–äººé˜…è¯»ä»£ç çš„å¯è¯»æ€§ï¼‰æ–¹é¢æ˜¯ç‹¬ä¸€æ— äºŒçš„ã€‚è®¸å¤šæ”¯æŒä¸“ä¸šäººå£«çš„ç¼–ç¨‹å·¥å…·éƒ½æœŸæœ›ä½ å°†æ‰€æœ‰æµ‹è¯•æ”¾åœ¨å•ç‹¬çš„æ–‡ä»¶å¤¹å’Œæ–‡ä»¶ä¸­ï¼ˆä¸æä¾›å¯¹ç¤ºä¾‹çš„æ”¯æŒï¼‰ã€‚åœ¨è¿™æœ¬ä¹¦ä¸­ï¼Œæˆ‘ä»¬å¼ºè°ƒç¼–ç¨‹ä¸­è¾“å…¥è¾“å‡ºå¯¹è¿™ä¸¤ç§ç”¨é€”ä¹‹é—´çš„åŒºåˆ«ï¼Œå› ä¸ºæˆ‘ä»¬å‘ç°å®ƒä»¬åœ¨ä¸“ä¸šå’Œæ•™å­¦æ–¹é¢éƒ½éå¸¸æœ‰ç”¨ã€‚
- en: 8.3.2Â More Refined Comparisons[ğŸ”—](#(part._s~3arefined) "Link to here")
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2 æ›´ç²¾ç»†çš„æ¯”è¾ƒ[ğŸ”—](#(part._s~3arefined) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Sometimes, a direct comparison via `is` isnâ€™t enough for testing. We have already
    seen this in the case of `raises` tests ([Computing Genetic Parents from an Ancestry
    Table](trees.html#%28part._compute-parents-table%29)). As another example, when
    doing some computations, especially involving math with approximations, the exact
    match of `is` isnâ€™t feasible. For example, consider these tests for `distance-to-origin`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶å€™ï¼Œé€šè¿‡ `is` è¿›è¡Œç›´æ¥æ¯”è¾ƒå¹¶ä¸è¶³ä»¥è¿›è¡Œæµ‹è¯•ã€‚æˆ‘ä»¬å·²ç»åœ¨ `raises` æµ‹è¯•çš„ä¾‹å­ä¸­çœ‹åˆ°äº†è¿™ä¸€ç‚¹ï¼ˆ[ä»å®¶è°±è¡¨ä¸­è®¡ç®—é—ä¼ çˆ¶æ¯](trees.html#%28part._compute-parents-table%29)ï¼‰ã€‚ä½œä¸ºå¦ä¸€ä¸ªä¾‹å­ï¼Œåœ¨è¿›è¡Œä¸€äº›è®¡ç®—ï¼Œå°¤å…¶æ˜¯æ¶‰åŠè¿‘ä¼¼æ•°å­¦çš„è®¡ç®—æ—¶ï¼Œ`is`
    çš„ç²¾ç¡®åŒ¹é…æ˜¯ä¸åˆ‡å®é™…çš„ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ä»¥ä¸‹ `distance-to-origin` çš„æµ‹è¯•ï¼š
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What can we check here? Typing this into the REPL, we can find that the answer
    prints as `1.4142135623730951`. Thatâ€™s an approximation of the real answer, which
    Pyret cannot represent exactly. But itâ€™s hard to know that this precise answer,
    to this decimal place, and no more, is the one we should expect up front, and
    thinking through the answers is supposed to be the first thing we do!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œæ£€æŸ¥ä»€ä¹ˆï¼Ÿåœ¨ REPL ä¸­è¾“å…¥è¿™ä¸ªå‘½ä»¤ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ç­”æ¡ˆæ‰“å°ä¸º `1.4142135623730951`ã€‚è¿™æ˜¯çœŸå®ç­”æ¡ˆçš„ä¸€ä¸ªè¿‘ä¼¼å€¼ï¼ŒPyret
    æ— æ³•ç²¾ç¡®è¡¨ç¤ºã€‚ä½†å¾ˆéš¾çŸ¥é“è¿™ä¸ªç²¾ç¡®ç­”æ¡ˆï¼Œåˆ°å°æ•°ç‚¹åè¿™ä¹ˆå¤šä½ï¼Œæ˜¯æˆ‘ä»¬ä¸€å¼€å§‹å°±åº”è¯¥é¢„æœŸçš„ï¼Œè€Œä¸”é€šè¿‡æ€è€ƒç­”æ¡ˆåº”è¯¥æ˜¯æˆ‘ä»¬é¦–å…ˆåšçš„äº‹æƒ…ï¼
- en: Since we know weâ€™re getting an approximation, we can really only check that
    the answer is roughly correct, not exactly correct. If we can check that the answer
    to `distance-to-origin(point(1, 1))` is around, say, `1.41`, and can do the same
    for some similar cases, thatâ€™s probably good enough for many applications, and
    for our purposes here. If we were calculating orbital dynamics, we might demand
    higher precision, but note that weâ€™d still need to pick a cutoff! Testing for
    inexact results is a necessary task.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæˆ‘ä»¬çŸ¥é“æˆ‘ä»¬å¾—åˆ°çš„æ˜¯ä¸€ä¸ªè¿‘ä¼¼å€¼ï¼Œæˆ‘ä»¬åªèƒ½æ£€æŸ¥ç­”æ¡ˆæ˜¯å¦å¤§è‡´æ­£ç¡®ï¼Œè€Œä¸æ˜¯å®Œå…¨æ­£ç¡®ã€‚å¦‚æœæˆ‘ä»¬èƒ½æ£€æŸ¥ `distance-to-origin(point(1,
    1))` çš„ç­”æ¡ˆå¤§çº¦æ˜¯ `1.41`ï¼Œå¹¶ä¸”å¯ä»¥å¯¹ä¸€äº›ç±»ä¼¼çš„æƒ…å†µåšåŒæ ·çš„æ£€æŸ¥ï¼Œé‚£ä¹ˆè¿™å¯èƒ½æ˜¯è®¸å¤šåº”ç”¨ä»¥åŠæˆ‘ä»¬è¿™é‡Œçš„ç”¨é€”æ‰€è¶³å¤Ÿå¥½çš„ã€‚å¦‚æœæˆ‘ä»¬æ­£åœ¨è®¡ç®—è½¨é“åŠ¨åŠ›å­¦ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦æ›´é«˜çš„ç²¾åº¦ï¼Œä½†è¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä»ç„¶éœ€è¦é€‰æ‹©ä¸€ä¸ªæˆªæ­¢ç‚¹ï¼æµ‹è¯•ä¸ç²¾ç¡®çš„ç»“æœæ˜¯ä¸€é¡¹å¿…è¦çš„ä»»åŠ¡ã€‚
- en: 'Letâ€™s first define what we mean by â€œaroundâ€ with one of the most precise ways
    we can, a function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é¦–å…ˆç”¨æˆ‘ä»¬èƒ½å¤Ÿåšåˆ°çš„æœ€ç²¾ç¡®çš„æ–¹å¼å®šä¹‰â€œå¤§çº¦â€çš„å«ä¹‰ï¼Œå³ä¸€ä¸ªå‡½æ•°ï¼š
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `is` form now helps us out. There is special syntax for supplying a user-defined
    function to use to compare the two values, instead of just checking if they are
    equal:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨çš„ `is` å½¢å¼å¸®åŠ©æˆ‘ä»¬è§£å†³äº†é—®é¢˜ã€‚æœ‰ä¸€ç§ç‰¹æ®Šçš„è¯­æ³•å¯ä»¥ç”¨æ¥æä¾›ä¸€ä¸ªç”¨æˆ·å®šä¹‰çš„å‡½æ•°æ¥æ¯”è¾ƒä¸¤ä¸ªå€¼ï¼Œè€Œä¸æ˜¯ä»…ä»…æ£€æŸ¥å®ƒä»¬æ˜¯å¦ç›¸ç­‰ï¼š
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Adding `%(something)` after `is` changes the behavior of `is`. Normally, it
    would compare the left and right values for equality. If something is provided
    with `%`, however, it instead passes the left and right values to the provided
    function (in this example `around`). If the provided function produces `true`,
    the test passes, if it produces `false`, the test fails. This gives us the control
    we need to test functions with predictable approximate results.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ `is` åé¢æ·»åŠ  `%(something)` ä¼šæ”¹å˜ `is` çš„è¡Œä¸ºã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œå®ƒä¼šæ¯”è¾ƒå·¦å³ä¸¤è¾¹çš„å€¼æ˜¯å¦ç›¸ç­‰ã€‚ç„¶è€Œï¼Œå¦‚æœæä¾›äº† `%`ï¼Œå®ƒå°±ä¼šå°†å·¦å³ä¸¤è¾¹çš„å€¼ä¼ é€’ç»™æä¾›çš„å‡½æ•°ï¼ˆåœ¨è¿™ä¸ªä¾‹å­ä¸­æ˜¯
    `around`ï¼‰ã€‚å¦‚æœæä¾›çš„å‡½æ•°äº§ç”Ÿ `true`ï¼Œåˆ™æµ‹è¯•é€šè¿‡ï¼›å¦‚æœäº§ç”Ÿ `false`ï¼Œåˆ™æµ‹è¯•å¤±è´¥ã€‚è¿™ä¸ºæˆ‘ä»¬æä¾›äº†æµ‹è¯•å…·æœ‰å¯é¢„æµ‹è¿‘ä¼¼ç»“æœçš„å‡½æ•°æ‰€éœ€çš„æ§åˆ¶ã€‚
- en: Exercise
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend the definition of `distance-to-origin` to include `polar` points.
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°† `distance-to-origin` çš„å®šä¹‰æ‰©å±•åˆ°åŒ…æ‹¬æåæ ‡ç‚¹ã€‚
- en: Exercise
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This might save you a Google search: [polar conversions](http://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates).
    Use the design recipe to write `x-component` and `y-component`, which return the
    `x` and `y` Cartesian parts of the point (which you would need, for example, if
    you were plotting them on a graph). Read about `num-sin` and other functions youâ€™ll
    need at [the Pyret number documentation](http://www.pyret.org/docs/latest/numbers.html).'
  id: totrans-104
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™å¯èƒ½å¯ä»¥èŠ‚çœä½ çš„è°·æ­Œæœç´¢ï¼š[æåæ ‡è½¬æ¢](http://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates)ã€‚ä½¿ç”¨è®¾è®¡é£Ÿè°±ç¼–å†™
    `x-component` å’Œ `y-component` å‡½æ•°ï¼Œå®ƒä»¬è¿”å›ç‚¹çš„ `x` å’Œ `y` åæ ‡éƒ¨åˆ†ï¼ˆä¾‹å¦‚ï¼Œå¦‚æœä½ åœ¨å›¾è¡¨ä¸Šç»˜åˆ¶å®ƒä»¬æ—¶éœ€è¦è¿™äº›ï¼‰ã€‚åœ¨
    [Pyret æ•°å­—æ–‡æ¡£](http://www.pyret.org/docs/latest/numbers.html) ä¸­äº†è§£ `num-sin` å’Œå…¶ä»–ä½ éœ€è¦ä½¿ç”¨çš„å‡½æ•°ã€‚
- en: Exercise
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write a data definition called `Pay` for pay types that includes both hourly
    employees, whose pay type includes an hourly rate, and salaried employees, whose
    pay type includes a total salary for the year. Use the design recipe to write
    a function called `expected-weekly-wages` that takes a `Pay`, and returns the
    expected weekly salary: the expected weekly salary for an hourly employee assumes
    they work 40 hours, and the expected weekly salary for a salaried employee is
    1/52 of their salary.'
  id: totrans-107
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªåä¸º `Pay` çš„æ•°æ®å®šä¹‰ï¼Œç”¨äºæ”¯ä»˜ç±»å‹ï¼ŒåŒ…æ‹¬æŒ‰å°æ—¶æ”¯ä»˜çš„å‘˜å·¥ï¼Œå…¶æ”¯ä»˜ç±»å‹åŒ…æ‹¬å°æ—¶å·¥èµ„ï¼Œä»¥åŠå¹´è–ªå‘˜å·¥ï¼Œå…¶æ”¯ä»˜ç±»å‹åŒ…æ‹¬ä¸€å¹´çš„æ€»å·¥èµ„ã€‚ä½¿ç”¨è®¾è®¡é£Ÿè°±ç¼–å†™ä¸€ä¸ªåä¸º
    `expected-weekly-wages` çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ª `Pay` å‚æ•°ï¼Œå¹¶è¿”å›é¢„æœŸçš„æ¯å‘¨å·¥èµ„ï¼šæŒ‰å°æ—¶æ”¯ä»˜çš„å‘˜å·¥çš„é¢„æœŸæ¯å‘¨å·¥èµ„å‡è®¾ä»–ä»¬å·¥ä½œ40å°æ—¶ï¼Œè€Œå¹´è–ªå‘˜å·¥çš„é¢„æœŸæ¯å‘¨å·¥èµ„æ˜¯ä»–ä»¬å¹´è–ªçš„1/52ã€‚
- en: 8.3.3Â When Tests Fail[ğŸ”—](#(part._.When_.Tests_.Fail) "Link to here")
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3 å½“æµ‹è¯•å¤±è´¥[ğŸ”—](#(part._.When_.Tests_.Fail) "é“¾æ¥è‡³æ­¤")
- en: Suppose weâ€™ve written the function `sqrt`, which computes the square root of
    a given number. Weâ€™ve written some tests for this function. We run the program,
    and find that a test fails. There are two obvious reasons why this can happen.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬ç¼–å†™äº†ä¸€ä¸ªåä¸º `sqrt` çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°è®¡ç®—ç»™å®šæ•°å­—çš„å¹³æ–¹æ ¹ã€‚æˆ‘ä»¬ä¸ºè¿™ä¸ªå‡½æ•°ç¼–å†™äº†ä¸€äº›æµ‹è¯•ã€‚æˆ‘ä»¬è¿è¡Œç¨‹åºï¼Œå‘ç°ä¸€ä¸ªæµ‹è¯•å¤±è´¥äº†ã€‚è¿™ç§æƒ…å†µå¯èƒ½æœ‰ä¸¤ä¸ªæ˜æ˜¾çš„åŸå› ã€‚
- en: Do Now!
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the two obvious reasons?
  id: totrans-112
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æœ‰ä¸¤ä¸ªæ˜æ˜¾çš„åŸå› æ˜¯ä»€ä¹ˆï¼Ÿ
- en: 'The two reasons are, of course, the two â€œsidesâ€ of the test: the problem could
    be with the values weâ€™ve written or with the function weâ€™ve written. For instance,
    if weâ€™ve written'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªåŸå› å½“ç„¶æ˜¯æµ‹è¯•çš„â€œä¸¤é¢â€ï¼šé—®é¢˜å¯èƒ½æ˜¯æˆ‘ä»¬ç¼–å†™çš„æ•°å€¼æˆ–æˆ‘ä»¬ç¼–å†™çš„å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬ç¼–å†™äº†
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: then the fault clearly lies with the values (because \(1.75^2\) is clearly not
    \(4\)). On the other hand, if it fails the test
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœé”™è¯¯æ˜æ˜¾æ˜¯ç”±äºæ•°å€¼ï¼ˆå› ä¸º \(1.75^2\) æ˜¾ç„¶ä¸ç­‰äº \(4\)ï¼‰ï¼Œé‚£ä¹ˆé—®é¢˜æ˜¾ç„¶å‡ºåœ¨è¿™äº›æ•°å€¼ä¸Šã€‚å¦ä¸€æ–¹é¢ï¼Œå¦‚æœå®ƒæœªèƒ½é€šè¿‡æµ‹è¯•
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: then the odds are that weâ€™ve made an error in the definition of `sqrt` instead,
    and thatâ€™s what we need to fix.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆå¾ˆå¯èƒ½æ˜¯æˆ‘ä»¬åœ¨ `sqrt` çš„å®šä¹‰ä¸­çŠ¯äº†é”™è¯¯ï¼Œè¿™æ­£æ˜¯æˆ‘ä»¬éœ€è¦ä¿®å¤çš„ã€‚
- en: Note that there is no way for the computer to tell what went wrong. When it
    reports a test failure, all itâ€™s saying is that there is an inconsistency between
    the program and the tests. The computer is not passing judgment on which one is
    â€œcorrectâ€, because it canâ€™t do that. That is a matter for human judgment.For this
    reason, weâ€™ve been doing research on [peer review of tests](http://cs.brown.edu/~sk/Publications/Papers/Published/pkf-ifpr-tests-tf-prog/),
    so students can help one another review their tests before they begin writing
    programs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè®¡ç®—æœºæ— æ³•çŸ¥é“å‡ºäº†ä»€ä¹ˆé—®é¢˜ã€‚å½“å®ƒæŠ¥å‘Šæµ‹è¯•å¤±è´¥æ—¶ï¼Œå®ƒåªæ˜¯åœ¨è¯´ç¨‹åºå’Œæµ‹è¯•ä¹‹é—´å­˜åœ¨ä¸ä¸€è‡´ã€‚è®¡ç®—æœºä¸ä¼šå¯¹å“ªä¸€ä¸ªæ˜¯â€œæ­£ç¡®çš„â€åšå‡ºåˆ¤æ–­ï¼Œå› ä¸ºå®ƒæ— æ³•åšåˆ°è¿™ä¸€ç‚¹ã€‚è¿™æ˜¯ä¸€ä¸ªéœ€è¦äººç±»åˆ¤æ–­çš„é—®é¢˜ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¸€ç›´åœ¨ç ”ç©¶
    [æµ‹è¯•åŒè¡Œè¯„å®¡](http://cs.brown.edu/~sk/Publications/Papers/Published/pkf-ifpr-tests-tf-prog/)ï¼Œä»¥ä¾¿å­¦ç”Ÿåœ¨å¼€å§‹ç¼–å†™ç¨‹åºä¹‹å‰äº’ç›¸è¯„å®¡ä»–ä»¬çš„æµ‹è¯•ã€‚
- en: 'Actually...not so fast. Thereâ€™s one more possibility we didnâ€™t consider: the
    third, not-so-obvious reason why a test might fail. Return to this test:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Š...å¹¶ä¸é‚£ä¹ˆå¿«ã€‚è¿˜æœ‰ä¸€ç§æˆ‘ä»¬æ²¡æœ‰è€ƒè™‘çš„å¯èƒ½æ€§ï¼šç¬¬ä¸‰ä¸ªä¸é‚£ä¹ˆæ˜æ˜¾çš„æµ‹è¯•å¤±è´¥åŸå› ã€‚å›åˆ°è¿™ä¸ªæµ‹è¯•ï¼š
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Clearly the inputs and outputs are correct, but it could be that the definition
    of `sqrt` is also correct, and yet the test fails.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¾ç„¶è¾“å…¥å’Œè¾“å‡ºéƒ½æ˜¯æ­£ç¡®çš„ï¼Œä½†å¯èƒ½æ˜¯ `sqrt` çš„å®šä¹‰ä¹Ÿæ˜¯æ­£ç¡®çš„ï¼Œä½†æµ‹è¯•ä»ç„¶å¤±è´¥äº†ã€‚
- en: Do Now!
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see why?
  id: totrans-124
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ çœ‹æ‡‚äº†å—ï¼Ÿ
- en: Depending on how weâ€™ve programmed `sqrt`, it might return the root `-2` instead
    of `2`. Now `-2` is a perfectly good answer, too. That is, neither the function
    nor the particular set of test values we specified is inherently wrong; itâ€™s just
    that the function happens to be a relation, i.e., it maps one input to multiple
    outputs (that is, \(\sqrt{4} = \pm 2\)). The question now is how to write the
    test properly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¹æ®æˆ‘ä»¬å¦‚ä½•ç¼–ç¨‹ `sqrt`ï¼Œå®ƒå¯èƒ½è¿”å› `-2` è€Œä¸æ˜¯ `2`ã€‚ç°åœ¨ `-2` ä¹Ÿæ˜¯ä¸€ä¸ªå®Œå…¨åˆç†çš„ç­”æ¡ˆã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå‡½æ•°ä»¥åŠæˆ‘ä»¬æŒ‡å®šçš„ç‰¹å®šæµ‹è¯•å€¼é›†æœ¬èº«å¹¶æ²¡æœ‰é”™è¯¯ï¼›åªæ˜¯è¿™ä¸ªå‡½æ•°ç¢°å·§æ˜¯ä¸€ä¸ªå…³ç³»ï¼Œå³å®ƒå°†ä¸€ä¸ªè¾“å…¥æ˜ å°„åˆ°å¤šä¸ªè¾“å‡ºï¼ˆä¹Ÿå°±æ˜¯è¯´ï¼Œ\(\sqrt{4}
    = \pm 2\)ï¼‰ã€‚ç°åœ¨çš„é—®é¢˜æ˜¯ï¼Œå¦‚ä½•æ­£ç¡®åœ°ç¼–å†™æµ‹è¯•ã€‚
- en: 8.3.4Â Oracles for Testing[ğŸ”—](#(part._test-oracle) "Link to here")
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.4 æµ‹è¯•çš„é¢„è¨€è€…[ğŸ”—](#(part._test-oracle) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'In other words, sometimes what we want to express is not a concrete input-output
    pair, but rather check that the output has the right relationship to the input.
    Concretely, what might this be in the case of `sqrt`? We hinted at this earlier
    when we said that `1.75` clearly canâ€™t be right, because squaring it does not
    yield `4`. That gives us the general insight: that a number is a valid root (note
    the use of â€œaâ€ instead of â€œtheâ€) if squaring it yields the original number. That
    is, we might write a function like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: æ¢å¥è¯è¯´ï¼Œæœ‰æ—¶æˆ‘ä»¬æƒ³è¦è¡¨è¾¾çš„ä¸æ˜¯å…·ä½“çš„è¾“å…¥è¾“å‡ºå¯¹ï¼Œè€Œæ˜¯æ£€æŸ¥è¾“å‡ºä¸è¾“å…¥ä¹‹é—´æ˜¯å¦å…·æœ‰æ­£ç¡®çš„å…³ç³»ã€‚å…·ä½“æ¥è¯´ï¼Œåœ¨ `sqrt` çš„æƒ…å†µä¸‹ï¼Œè¿™å¯èƒ½ä¼šæ˜¯ä»€ä¹ˆï¼Ÿæˆ‘ä»¬ä¹‹å‰åœ¨è¯´
    `1.75` æ˜æ˜¾ä¸æ­£ç¡®æ—¶å·²ç»æš—ç¤ºäº†è¿™ä¸€ç‚¹ï¼Œå› ä¸ºå¹³æ–¹å®ƒä¸ä¼šå¾—åˆ° `4`ã€‚è¿™ç»™äº†æˆ‘ä»¬ä¸€ä¸ªä¸€èˆ¬çš„æ´å¯Ÿï¼šä¸€ä¸ªæ•°æ˜¯æœ‰æ•ˆçš„æ ¹ï¼ˆæ³¨æ„ä½¿ç”¨â€œaâ€è€Œä¸æ˜¯â€œtheâ€ï¼‰ï¼Œå¦‚æœå¹³æ–¹å®ƒå¾—åˆ°åŸå§‹æ•°å­—ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯èƒ½ç¼–å†™ä¸€ä¸ªåƒè¿™æ ·çš„å‡½æ•°ï¼š
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: and then our test looks like
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬çš„æµ‹è¯•çœ‹èµ·æ¥åƒ
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Unfortunately, this has an awkward failure case. If `sqrt` does not produce
    a number that is in fact a root, we arenâ€™t told what the actual value is; instead,
    `is-sqrt` returns false, and the test failure just says that `false` (what `is-sqrt`
    returns) is not `true` (what the test expects)â€”<wbr>which is both absolutely true
    and utterly useless.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œè¿™æœ‰ä¸€ä¸ªå°´å°¬çš„å¤±è´¥æƒ…å†µã€‚å¦‚æœ `sqrt` ä¸äº§ç”Ÿå®é™…ä¸Šæ˜¯ä¸€ä¸ªæ ¹çš„æ•°å­—ï¼Œæˆ‘ä»¬ä¸ä¼šè¢«å‘ŠçŸ¥å®é™…å€¼æ˜¯ä»€ä¹ˆï¼›ç›¸åï¼Œ`is-sqrt` è¿”å› falseï¼Œæµ‹è¯•å¤±è´¥åªæ˜¯è¯´
    `false`ï¼ˆ`is-sqrt` è¿”å›çš„ï¼‰ä¸æ˜¯ `true`ï¼ˆæµ‹è¯•æœŸæœ›çš„ï¼‰â€”â€”<wbr>è¿™æ—¢æ˜¯ç»å¯¹æ­£ç¡®çš„ï¼Œä¹Ÿæ˜¯å®Œå…¨æ— ç”¨çš„ã€‚
- en: 'Fortunately, Pyret has a better way of expressing the same check. Instead of
    `is`, we can write `satisfies`, and then the value on the left must satisfy the
    predicate on the right. Concretely, this looks like:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¸è¿çš„æ˜¯ï¼ŒPyret æœ‰ä¸€ç§æ›´å¥½çš„æ–¹å¼æ¥è¡¨è¾¾ç›¸åŒçš„æ£€æŸ¥ã€‚æˆ‘ä»¬ä¸æ˜¯ç”¨ `is`ï¼Œè€Œæ˜¯å¯ä»¥å†™ `satisfies`ï¼Œç„¶åå·¦è¾¹çš„å€¼å¿…é¡»æ»¡è¶³å³è¾¹çš„è°“è¯ã€‚å…·ä½“æ¥è¯´ï¼Œè¿™çœ‹èµ·æ¥åƒï¼š
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'which lets us write:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è®©æˆ‘ä»¬å¯ä»¥å†™å‡ºï¼š
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, if thereâ€™s a failure, we learn of the actual value produced by `sqrt(4)`
    that failed to satisfy the predicate.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œå¦‚æœå‡ºç°å¤±è´¥ï¼Œæˆ‘ä»¬ä¼šäº†è§£åˆ° `sqrt(4)` äº§ç”Ÿçš„å®é™…å€¼æœªèƒ½æ»¡è¶³è°“è¯ã€‚
