- en: 8.2¬†Queues from Listsüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/queues-from-lists.html](https://dcic-world.org/2025-08-27/queues-from-lists.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[8.2.1¬†Using a Wrapper Datatype](#%28part._.Using_a_.Wrapper_.Datatype%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[8.2.2¬†Combining Answers](#%28part._qfl-comb-ans%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[8.2.3¬†Using a Picker](#%28part._.Using_a_.Picker%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[8.2.4¬†Using Tuples](#%28part._qfl-tuples%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[8.2.5¬†A Picker Method](#%28part._.A_.Picker_.Method%29) |'
  prefs: []
  type: TYPE_TB
- en: Suppose you have a list. When you take its first element, you get the element
    that was most recently `link`ed to create it. The next element is the second most
    recent one that was `link`ed, and so on. That is, the last one in is the first
    one out. This is called a LIFO, short for ‚Äúlast-in-first-out‚Äù, data structure.
    A list is LIFO; we sometimes also refer to this as a stack.
  prefs: []
  type: TYPE_NORMAL
- en: But there are many settings where you want the first-in to be the first-out.
    When you stand at a supermarket line, try to purchase concert tickets, submit
    a job request, or any number of other tasks, you want to be rewarded, not punished,
    for being there first. That is, you want a FIFO instead. This is called a queue.
  prefs: []
  type: TYPE_NORMAL
- en: The game we‚Äôre playing here is that we want one datatype but our language has
    given us another (in this case, lists), and we have to figure out how to encode
    one in the other. We‚Äôll see elsewhere how to encode sets with lists [[Representing
    Sets as Lists](sets-from-lists.html)]. Here let‚Äôs see how we can encode queues
    with lists.
  prefs: []
  type: TYPE_NORMAL
- en: With sets, we allowed the set type to be an alias for lists; that is, the two
    were the same. Another option we have when encoding is to create a completely
    new type that does nothing more than wrap a value of the encoding type. We‚Äôll
    use that principle here to illustrate how that might work.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1¬†Using a Wrapper Datatype[üîó](#(part._.Using_a_.Wrapper_.Datatype) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Concretely, here‚Äôs how we‚Äôll represent queues. For all the code that follows,
    it‚Äôs helpful to use the Pyret type-checker to make sure we‚Äôre composing code correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With this encoding, we can start define a few helper functions: e.g., a way
    to construct an empty queue and to check for emptiness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding an element to a queue is usually called ‚Äúenqueueing‚Äù. It has this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here‚Äôs the corresponding implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did we have a choice?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Yes, we did! We could have made the new element the first element or the last
    element.Be careful here: we mean the first or last element of the list that represents
    the queue, not of the queue itself. There, FIFO gives us no choice. We just happened
    to choose one representation. The other would be equally valid; we would just
    need to implement all the other operations consistently. Let‚Äôs stick to this one
    for now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we come to a problem. What does it mean to ‚Äúdequeue‚Äù? We need to get back
    the one element, but we also need to get back the rest. Let‚Äôs first write this
    as two functions, very analogous to first and rest on lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs write out a few examples to make sure we know how these should work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let‚Äôs implement these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 8.2.2¬†Combining Answers[üîó](#(part._qfl-comb-ans) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: However, it would be nice if we could obtain both the oldest element and the
    rest of the queue at once, if we want them both. That means the single function
    would need to return two values; since a function can return only one value at
    a time, it would need to use a data structure to hold both of them. Furthermore,
    note that both `qpeek` and `qrest` above have the possibility of not having any
    more elements! We might as well reflect that too in the type. Thus we end up with
    a type that looks like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write out the function to use this return type.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Observe that this also follows our principle of making exceptional behavior
    manifest in the return type: [The Option Type](partial-domains.html#%28part._pd-option%29),
    and especially in [Summary](partial-domains.html#%28part._pd-summary%29).'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write out the function using this return type.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 8.2.3¬†Using a Picker[üîó](#(part._.Using_a_.Picker) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Does `Dequeued` look familiar? Of course it should! It‚Äôs basically the same
    as the pickers used for sets in Pyret: [Picking Elements from Sets](Collections_of_Structured_Data.html#%28part._coll-sd-pick%29).
    If we make queues provide the same operations, we can reuse the `Pick` library
    already built into the language, and reuse any code that is written expecting
    the picker interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, first we need to import the picker library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples showing how it would work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And here‚Äôs the corresponding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of big-O complexity, this is a dreadfully inefficient implementation,
    causing two reversals on every `qrest` or `dequeue`. To see how to do better,
    and to conduct a more sophisticated analysis, see [An Example: Queues from Lists](amortized-analysis.html#%28part._queue-data-structure%29).'
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that by providing only a picker interface, we‚Äôre slightly
    changing the meaning of queues. The picker interface in Pyret is designed for
    sets, which don‚Äôt have a notion of order. But queues are, of course, very much
    an ordered datatype; order is why they exist. So by providing only a picker interface,
    we don‚Äôt offer the very guarantee that queues are designed for. Therefore, we
    should provide a picker in addition to an ordered interface, rather than in place
    of one.
  prefs: []
  type: TYPE_NORMAL
- en: At this point we‚Äôre done with the essential content, but here are two more parts
    that you may find interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.4¬†Using Tuples[üîó](#(part._qfl-tuples) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Earlier, we created the `Dequeued` datatype to represent the return value from
    the dequeue. Indeed, it is often useful to create datatypes of this sort to document
    functions and make sure the types can be meaningfully interpreted even when their
    values flow around the code some distance from where they were created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, however, we want to create a compound datum in a special circumstance:
    it represents the return value of a function, and that return value will not live
    for very long, i.e., it will be taken apart as soon as it has returned and only
    the constituent parts will be used thereafter. In such situations, it can feel
    like a burden to create a new datatype for such a fleeting purpose. For such cases,
    Pyret has a built-in generic datatype called the tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of tuples, which illustrate their syntax; note that
    each position (separated by `;`) takes an expression, not only a constant value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pull values out of tuples as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Evaluate `a` and `b` and see what they are bound to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, see what `c`, `d`, and `e` are bound to.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What happens if we use too few or too many variables? Try out the following
    in Pyret and see what happens:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if instead we write this?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: This binds `p` to the entire tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How might we pull apart the constituents of `p`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now that we have tuples, we can write dequeue as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And here‚Äôs how we can use it more generally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You should feel free to use tuples in your programs provided you follow the
    rules above for when tuples are applicable. In general, tuples can cause a reduction
    in readability, and increase the likelihood of errors (because tuples from one
    source aren‚Äôt distinguishable from those from another source). Use them with caution!
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.5¬†A Picker Method[üîó](#(part._.A_.Picker_.Method) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Second, and this is truly optional: you may have noticed earlier that `Set`s
    had a built-in `pick` method. We have a function, but not method, that picks.
    Now we‚Äôll see how we can write this as a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a drop-in replacement for our previous definition of `Queue`, because
    we‚Äôve added a method but left the general datatype structure intact, so all our
    existing code will still work. In addition, we can rewrite `q2l` in terms of the
    picker interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also write generic programs over data that support the Pick interface.
    For instance, here‚Äôs a function that will convert anything satisfying that interface
    into a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, it works on both sets and our new `Queue`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see why we invoked `sort` in the test above?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The only weakness here is that for this last part (making the function generic),
    we have to transition out of the type-checker, because `pick2l` cannot be typed
    by the current Pyret type checker. It requires a feature that the type checker
    does not (yet) have.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1¬†Using a Wrapper Datatype[üîó](#(part._.Using_a_.Wrapper_.Datatype) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Concretely, here‚Äôs how we‚Äôll represent queues. For all the code that follows,
    it‚Äôs helpful to use the Pyret type-checker to make sure we‚Äôre composing code correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With this encoding, we can start define a few helper functions: e.g., a way
    to construct an empty queue and to check for emptiness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding an element to a queue is usually called ‚Äúenqueueing‚Äù. It has this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here‚Äôs the corresponding implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did we have a choice?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Yes, we did! We could have made the new element the first element or the last
    element.Be careful here: we mean the first or last element of the list that represents
    the queue, not of the queue itself. There, FIFO gives us no choice. We just happened
    to choose one representation. The other would be equally valid; we would just
    need to implement all the other operations consistently. Let‚Äôs stick to this one
    for now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we come to a problem. What does it mean to ‚Äúdequeue‚Äù? We need to get back
    the one element, but we also need to get back the rest. Let‚Äôs first write this
    as two functions, very analogous to first and rest on lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs write out a few examples to make sure we know how these should work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let‚Äôs implement these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 8.2.2¬†Combining Answers[üîó](#(part._qfl-comb-ans) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: However, it would be nice if we could obtain both the oldest element and the
    rest of the queue at once, if we want them both. That means the single function
    would need to return two values; since a function can return only one value at
    a time, it would need to use a data structure to hold both of them. Furthermore,
    note that both `qpeek` and `qrest` above have the possibility of not having any
    more elements! We might as well reflect that too in the type. Thus we end up with
    a type that looks like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write out the function to use this return type.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Observe that this also follows our principle of making exceptional behavior
    manifest in the return type: [The Option Type](partial-domains.html#%28part._pd-option%29),
    and especially in [Summary](partial-domains.html#%28part._pd-summary%29).'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write out the function using this return type.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 8.2.3¬†Using a Picker[üîó](#(part._.Using_a_.Picker) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Does `Dequeued` look familiar? Of course it should! It‚Äôs basically the same
    as the pickers used for sets in Pyret: [Picking Elements from Sets](Collections_of_Structured_Data.html#%28part._coll-sd-pick%29).
    If we make queues provide the same operations, we can reuse the `Pick` library
    already built into the language, and reuse any code that is written expecting
    the picker interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, first we need to import the picker library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples showing how it would work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And here‚Äôs the corresponding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of big-O complexity, this is a dreadfully inefficient implementation,
    causing two reversals on every `qrest` or `dequeue`. To see how to do better,
    and to conduct a more sophisticated analysis, see [An Example: Queues from Lists](amortized-analysis.html#%28part._queue-data-structure%29).'
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that by providing only a picker interface, we‚Äôre slightly
    changing the meaning of queues. The picker interface in Pyret is designed for
    sets, which don‚Äôt have a notion of order. But queues are, of course, very much
    an ordered datatype; order is why they exist. So by providing only a picker interface,
    we don‚Äôt offer the very guarantee that queues are designed for. Therefore, we
    should provide a picker in addition to an ordered interface, rather than in place
    of one.
  prefs: []
  type: TYPE_NORMAL
- en: At this point we‚Äôre done with the essential content, but here are two more parts
    that you may find interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.4¬†Using Tuples[üîó](#(part._qfl-tuples) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Earlier, we created the `Dequeued` datatype to represent the return value from
    the dequeue. Indeed, it is often useful to create datatypes of this sort to document
    functions and make sure the types can be meaningfully interpreted even when their
    values flow around the code some distance from where they were created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, however, we want to create a compound datum in a special circumstance:
    it represents the return value of a function, and that return value will not live
    for very long, i.e., it will be taken apart as soon as it has returned and only
    the constituent parts will be used thereafter. In such situations, it can feel
    like a burden to create a new datatype for such a fleeting purpose. For such cases,
    Pyret has a built-in generic datatype called the tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of tuples, which illustrate their syntax; note that
    each position (separated by `;`) takes an expression, not only a constant value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pull values out of tuples as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Evaluate `a` and `b` and see what they are bound to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, see what `c`, `d`, and `e` are bound to.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What happens if we use too few or too many variables? Try out the following
    in Pyret and see what happens:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if instead we write this?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: This binds `p` to the entire tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How might we pull apart the constituents of `p`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now that we have tuples, we can write dequeue as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And here‚Äôs how we can use it more generally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You should feel free to use tuples in your programs provided you follow the
    rules above for when tuples are applicable. In general, tuples can cause a reduction
    in readability, and increase the likelihood of errors (because tuples from one
    source aren‚Äôt distinguishable from those from another source). Use them with caution!
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.5¬†A Picker Method[üîó](#(part._.A_.Picker_.Method) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Second, and this is truly optional: you may have noticed earlier that `Set`s
    had a built-in `pick` method. We have a function, but not method, that picks.
    Now we‚Äôll see how we can write this as a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a drop-in replacement for our previous definition of `Queue`, because
    we‚Äôve added a method but left the general datatype structure intact, so all our
    existing code will still work. In addition, we can rewrite `q2l` in terms of the
    picker interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also write generic programs over data that support the Pick interface.
    For instance, here‚Äôs a function that will convert anything satisfying that interface
    into a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, it works on both sets and our new `Queue`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see why we invoked `sort` in the test above?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The only weakness here is that for this last part (making the function generic),
    we have to transition out of the type-checker, because `pick2l` cannot be typed
    by the current Pyret type checker. It requires a feature that the type checker
    does not (yet) have.
  prefs: []
  type: TYPE_NORMAL
