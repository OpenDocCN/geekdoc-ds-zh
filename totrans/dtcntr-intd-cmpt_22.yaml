- en: 8.2Â Queues from ListsğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.2 ä»åˆ—è¡¨åˆ›å»ºé˜Ÿåˆ—ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/queues-from-lists.html](https://dcic-world.org/2025-08-27/queues-from-lists.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/queues-from-lists.html](https://dcic-world.org/2025-08-27/queues-from-lists.html)
- en: '| Â Â Â Â [8.2.1Â Using a Wrapper Datatype](#%28part._.Using_a_.Wrapper_.Datatype%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| [8.2.1 ä½¿ç”¨åŒ…è£…æ•°æ®ç±»å‹](#%28part._.Using_a_.Wrapper_.Datatype%29) |'
- en: '| Â Â Â Â [8.2.2Â Combining Answers](#%28part._qfl-comb-ans%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| [8.2.2 ç»“åˆç­”æ¡ˆ](#%28part._qfl-comb-ans%29) |'
- en: '| Â Â Â Â [8.2.3Â Using a Picker](#%28part._.Using_a_.Picker%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| [8.2.3 ä½¿ç”¨é€‰æ‹©å™¨](#%28part._.Using_a_.Picker%29) |'
- en: '| Â Â Â Â [8.2.4Â Using Tuples](#%28part._qfl-tuples%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| [8.2.4 ä½¿ç”¨å…ƒç»„](#%28part._qfl-tuples%29) |'
- en: '| Â Â Â Â [8.2.5Â A Picker Method](#%28part._.A_.Picker_.Method%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| [8.2.5 é€‰æ‹©å™¨æ–¹æ³•](#%28part._.A_.Picker_.Method%29) |'
- en: Suppose you have a list. When you take its first element, you get the element
    that was most recently `link`ed to create it. The next element is the second most
    recent one that was `link`ed, and so on. That is, the last one in is the first
    one out. This is called a LIFO, short for â€œlast-in-first-outâ€, data structure.
    A list is LIFO; we sometimes also refer to this as a stack.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾ä½ æœ‰ä¸€ä¸ªåˆ—è¡¨ã€‚å½“ä½ å–å®ƒçš„ç¬¬ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œä½ å¾—åˆ°çš„æ˜¯æœ€è¿‘è¢«`link`åˆ›å»ºçš„å…ƒç´ ã€‚ä¸‹ä¸€ä¸ªå…ƒç´ æ˜¯ç¬¬äºŒä¸ªæœ€è¿‘è¢«`link`çš„å…ƒç´ ï¼Œä»¥æ­¤ç±»æ¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæœ€åè¿›å…¥çš„æ˜¯ç¬¬ä¸€ä¸ªå‡ºæ¥çš„ã€‚è¿™è¢«ç§°ä¸ºLIFOï¼Œå³â€œåè¿›å…ˆå‡ºâ€çš„æ•°æ®ç»“æ„ã€‚åˆ—è¡¨æ˜¯LIFOï¼›æˆ‘ä»¬æœ‰æ—¶ä¹Ÿå°†å…¶ç§°ä¸ºæ ˆã€‚
- en: But there are many settings where you want the first-in to be the first-out.
    When you stand at a supermarket line, try to purchase concert tickets, submit
    a job request, or any number of other tasks, you want to be rewarded, not punished,
    for being there first. That is, you want a FIFO instead. This is called a queue.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œä½ å¸Œæœ›ç¬¬ä¸€ä¸ªè¿›å…¥çš„æ˜¯ç¬¬ä¸€ä¸ªå‡ºæ¥ã€‚å½“ä½ ç«™åœ¨è¶…å¸‚çš„é˜Ÿä¼ä¸­ï¼Œè¯•å›¾è´­ä¹°éŸ³ä¹ä¼šé—¨ç¥¨ï¼Œæäº¤å·¥ä½œè¯·æ±‚ï¼Œæˆ–æ‰§è¡Œä»»ä½•å…¶ä»–ä»»åŠ¡æ—¶ï¼Œä½ å¸Œæœ›å› ä¸ºä½ æ˜¯ç¬¬ä¸€ä¸ªè€Œå¾—åˆ°å¥–åŠ±ï¼Œè€Œä¸æ˜¯æƒ©ç½šã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä½ å¸Œæœ›æœ‰ä¸€ä¸ªFIFOã€‚è¿™è¢«ç§°ä¸ºé˜Ÿåˆ—ã€‚
- en: The game weâ€™re playing here is that we want one datatype but our language has
    given us another (in this case, lists), and we have to figure out how to encode
    one in the other. Weâ€™ll see elsewhere how to encode sets with lists [[Representing
    Sets as Lists](sets-from-lists.html)]. Here letâ€™s see how we can encode queues
    with lists.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨è¿™é‡Œç©çš„æ¸¸æˆæ˜¯ï¼Œæˆ‘ä»¬æƒ³è¦ä¸€ä¸ªæ•°æ®ç±»å‹ï¼Œä½†æˆ‘ä»¬çš„è¯­è¨€ç»™äº†æˆ‘ä»¬å¦ä¸€ä¸ªï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ˜¯åˆ—è¡¨ï¼‰ï¼Œæˆ‘ä»¬å¿…é¡»æ‰¾å‡ºå¦‚ä½•åœ¨å¦ä¸€ä¸ªä¸­ç¼–ç å®ƒã€‚æˆ‘ä»¬å°†åœ¨å…¶ä»–åœ°æ–¹çœ‹åˆ°å¦‚ä½•ä½¿ç”¨åˆ—è¡¨æ¥ç¼–ç é›†åˆ
    [[å°†é›†åˆè¡¨ç¤ºä¸ºåˆ—è¡¨](sets-from-lists.html)]ã€‚åœ¨è¿™é‡Œï¼Œè®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬å¦‚ä½•å¯ä»¥ä½¿ç”¨åˆ—è¡¨æ¥ç¼–ç é˜Ÿåˆ—ã€‚
- en: With sets, we allowed the set type to be an alias for lists; that is, the two
    were the same. Another option we have when encoding is to create a completely
    new type that does nothing more than wrap a value of the encoding type. Weâ€™ll
    use that principle here to illustrate how that might work.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºé›†åˆï¼Œæˆ‘ä»¬å…è®¸é›†åˆç±»å‹æ˜¯åˆ—è¡¨çš„åˆ«åï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸¤è€…æ˜¯ç›¸åŒçš„ã€‚åœ¨ç¼–ç æ—¶ï¼Œæˆ‘ä»¬è¿˜æœ‰ä¸€ä¸ªé€‰æ‹©ï¼Œå³åˆ›å»ºä¸€ä¸ªå®Œå…¨æ–°çš„ç±»å‹ï¼Œå®ƒé™¤äº†åŒ…è£…ç¼–ç ç±»å‹çš„å€¼ä¹‹å¤–ä¸åšä»»ä½•äº‹æƒ…ã€‚æˆ‘ä»¬å°†ä½¿ç”¨è¿™ä¸ªåŸåˆ™æ¥å±•ç¤ºè¿™å¯èƒ½å¦‚ä½•å·¥ä½œã€‚
- en: 8.2.1Â Using a Wrapper Datatype[ğŸ”—](#(part._.Using_a_.Wrapper_.Datatype) "Link
    to here")
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1 ä½¿ç”¨åŒ…è£…æ•°æ®ç±»å‹[ğŸ”—](#(part._.Using_a_.Wrapper_.Datatype) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Concretely, hereâ€™s how weâ€™ll represent queues. For all the code that follows,
    itâ€™s helpful to use the Pyret type-checker to make sure weâ€™re composing code correctly:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬å°†è¿™æ ·è¡¨ç¤ºé˜Ÿåˆ—ã€‚å¯¹äºä¸‹é¢çš„æ‰€æœ‰ä»£ç ï¼Œä½¿ç”¨Pyretç±»å‹æ£€æŸ¥å™¨æ¥ç¡®ä¿æˆ‘ä»¬æ­£ç¡®åœ°ç»„åˆä»£ç æ˜¯æœ‰å¸®åŠ©çš„ï¼š
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With this encoding, we can start define a few helper functions: e.g., a way
    to construct an empty queue and to check for emptiness:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ç§ç¼–ç ï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹å®šä¹‰ä¸€äº›è¾…åŠ©å‡½æ•°ï¼šä¾‹å¦‚ï¼Œæ„å»ºä¸€ä¸ªç©ºé˜Ÿåˆ—å’Œæ£€æŸ¥ç©ºæ€§çš„æ–¹æ³•ï¼š
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Adding an element to a queue is usually called â€œenqueueingâ€. It has this type:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: å‘é˜Ÿåˆ—ä¸­æ·»åŠ å…ƒç´ é€šå¸¸ç§°ä¸ºâ€œå…¥é˜Ÿâ€ã€‚å®ƒå…·æœ‰ä»¥ä¸‹ç±»å‹ï¼š
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Hereâ€™s the corresponding implementation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯å¯¹åº”çš„å®ç°ï¼š
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Do Now!
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did we have a choice?
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ‰é€‰æ‹©å—ï¼Ÿ
- en: 'Yes, we did! We could have made the new element the first element or the last
    element.Be careful here: we mean the first or last element of the list that represents
    the queue, not of the queue itself. There, FIFO gives us no choice. We just happened
    to choose one representation. The other would be equally valid; we would just
    need to implement all the other operations consistently. Letâ€™s stick to this one
    for now.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¯çš„ï¼Œæˆ‘ä»¬ç¡®å®åšåˆ°äº†ï¼æˆ‘ä»¬æœ¬å¯ä»¥å°†æ–°å…ƒç´ ä½œä¸ºç¬¬ä¸€ä¸ªå…ƒç´ æˆ–æœ€åä¸€ä¸ªå…ƒç´ ã€‚åœ¨è¿™é‡Œè¦å°å¿ƒï¼šæˆ‘ä»¬æŒ‡çš„æ˜¯è¡¨ç¤ºé˜Ÿåˆ—çš„åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªæˆ–æœ€åä¸€ä¸ªå…ƒç´ ï¼Œè€Œä¸æ˜¯é˜Ÿåˆ—æœ¬èº«ã€‚åœ¨é‚£é‡Œï¼ŒFIFOï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰ç»™äº†æˆ‘ä»¬æ²¡æœ‰é€‰æ‹©ã€‚æˆ‘ä»¬åªæ˜¯ç¢°å·§é€‰æ‹©äº†è¿™ç§è¡¨ç¤ºæ–¹å¼ã€‚å¦ä¸€ç§è¡¨ç¤ºæ–¹å¼åŒæ ·æœ‰æ•ˆï¼›æˆ‘ä»¬åªéœ€è¦ä¸€è‡´åœ°å®ç°æ‰€æœ‰å…¶ä»–æ“ä½œã€‚ç°åœ¨æˆ‘ä»¬å…ˆåšæŒä½¿ç”¨è¿™ç§è¡¨ç¤ºæ–¹å¼ã€‚
- en: 'Now we come to a problem. What does it mean to â€œdequeueâ€? We need to get back
    the one element, but we also need to get back the rest. Letâ€™s first write this
    as two functions, very analogous to first and rest on lists:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬é‡åˆ°äº†ä¸€ä¸ªé—®é¢˜ã€‚ä»€ä¹ˆæ˜¯â€œå‡ºé˜Ÿâ€çš„å«ä¹‰ï¼Ÿæˆ‘ä»¬éœ€è¦è·å–ä¸€ä¸ªå…ƒç´ ï¼Œä½†åŒæ—¶ä¹Ÿéœ€è¦è·å–å…¶ä½™çš„å…ƒç´ ã€‚è®©æˆ‘ä»¬é¦–å…ˆå°†å…¶å†™æˆä¸¤ä¸ªå‡½æ•°ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°ä¸åˆ—è¡¨ä¸­çš„firstå’Œrestéå¸¸ç›¸ä¼¼ï¼š
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Letâ€™s write out a few examples to make sure we know how these should work:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å†™å‡ºå‡ ä¸ªä¾‹å­æ¥ç¡®ä¿æˆ‘ä»¬çŸ¥é“è¿™äº›åº”è¯¥å¦‚ä½•å·¥ä½œï¼š
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now letâ€™s implement these:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥å®ç°è¿™äº›ï¼š
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 8.2.2Â Combining Answers[ğŸ”—](#(part._qfl-comb-ans) "Link to here")
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2 ç»“åˆç­”æ¡ˆ[ğŸ”—](#(part._qfl-comb-ans) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: However, it would be nice if we could obtain both the oldest element and the
    rest of the queue at once, if we want them both. That means the single function
    would need to return two values; since a function can return only one value at
    a time, it would need to use a data structure to hold both of them. Furthermore,
    note that both `qpeek` and `qrest` above have the possibility of not having any
    more elements! We might as well reflect that too in the type. Thus we end up with
    a type that looks like
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬æƒ³åŒæ—¶è·å¾—æœ€è€çš„å…ƒç´ å’Œé˜Ÿåˆ—çš„å…¶ä½™éƒ¨åˆ†ï¼Œé‚£ä¼šå¾ˆå¥½ã€‚è¿™æ„å‘³ç€å•ä¸ªå‡½æ•°éœ€è¦è¿”å›ä¸¤ä¸ªå€¼ï¼›ç”±äºå‡½æ•°ä¸€æ¬¡åªèƒ½è¿”å›ä¸€ä¸ªå€¼ï¼Œå®ƒéœ€è¦ä½¿ç”¨æ•°æ®ç»“æ„æ¥ä¿å­˜è¿™ä¸¤ä¸ªå€¼ã€‚æ­¤å¤–ï¼Œæ³¨æ„ä¸Šé¢æåˆ°çš„`qpeek`å’Œ`qrest`éƒ½æœ‰å¯èƒ½æ²¡æœ‰æ›´å¤šçš„å…ƒç´ ï¼æˆ‘ä»¬ä¸å¦¨åœ¨ç±»å‹ä¸­ä¹Ÿåæ˜ è¿™ä¸€ç‚¹ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æœ€ç»ˆå¾—åˆ°ä¸€ä¸ªçœ‹èµ·æ¥åƒè¿™æ ·çš„ç±»å‹
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Exercise
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write out the function to use this return type.
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä½¿ç”¨æ­¤è¿”å›ç±»å‹çš„å‡½æ•°ã€‚
- en: 'Observe that this also follows our principle of making exceptional behavior
    manifest in the return type: [The Option Type](partial-domains.html#%28part._pd-option%29),
    and especially in [Summary](partial-domains.html#%28part._pd-summary%29).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™ä¹Ÿéµå¾ªäº†æˆ‘ä»¬çš„åŸåˆ™ï¼Œå³åœ¨è¿”å›ç±»å‹ä¸­ä½“ç°å¼‚å¸¸è¡Œä¸ºï¼š[é€‰é¡¹ç±»å‹](partial-domains.html#%28part._pd-option%29)ï¼Œç‰¹åˆ«æ˜¯åœ¨[æ‘˜è¦](partial-domains.html#%28part._pd-summary%29)ä¸­ã€‚
- en: Exercise
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write out the function using this return type.
  id: totrans-39
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ç§è¿”å›ç±»å‹ç¼–å†™å‡½æ•°ã€‚
- en: 8.2.3Â Using a Picker[ğŸ”—](#(part._.Using_a_.Picker) "Link to here")
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.3 ä½¿ç”¨é€‰æ‹©å™¨[ğŸ”—](#(part._.Using_a_.Picker) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Does `Dequeued` look familiar? Of course it should! Itâ€™s basically the same
    as the pickers used for sets in Pyret: [Picking Elements from Sets](Collections_of_Structured_Data.html#%28part._coll-sd-pick%29).
    If we make queues provide the same operations, we can reuse the `Pick` library
    already built into the language, and reuse any code that is written expecting
    the picker interface.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: â€œDequeuedâ€çœ‹èµ·æ¥ç†Ÿæ‚‰å—ï¼Ÿå½“ç„¶åº”è¯¥ç†Ÿæ‚‰ï¼å®ƒåŸºæœ¬ä¸Šä¸Pyretä¸­ç”¨äºé›†åˆçš„é€‰æ‹©å™¨ç›¸åŒï¼š[ä»é›†åˆä¸­é€‰æ‹©å…ƒç´ ](Collections_of_Structured_Data.html#%28part._coll-sd-pick%29)ã€‚å¦‚æœæˆ‘ä»¬è®©é˜Ÿåˆ—æä¾›ç›¸åŒçš„æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥é‡ç”¨è¯­è¨€ä¸­å·²ç»æ„å»ºçš„â€œPickâ€åº“ï¼Œå¹¶é‡ç”¨ä»»ä½•æœŸæœ›é€‰æ‹©å™¨æ¥å£ç¼–å†™çš„ä»£ç ã€‚
- en: 'To do so, first we need to import the picker library:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: è¦è¿™æ ·åšï¼Œé¦–å…ˆæˆ‘ä»¬éœ€è¦å¯¼å…¥é€‰æ‹©å™¨åº“ï¼š
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then we can write:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™ï¼š
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here are some examples showing how it would work:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€äº›ç¤ºä¾‹ï¼Œè¯´æ˜å®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼š
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And hereâ€™s the corresponding code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯å¯¹åº”çš„ä»£ç ï¼š
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In terms of big-O complexity, this is a dreadfully inefficient implementation,
    causing two reversals on every `qrest` or `dequeue`. To see how to do better,
    and to conduct a more sophisticated analysis, see [An Example: Queues from Lists](amortized-analysis.html#%28part._queue-data-structure%29).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¤§Oå¤æ‚åº¦æ–¹é¢ï¼Œè¿™æ˜¯ä¸€ä¸ªæ•ˆç‡æä½å®ç°ï¼Œæ¯æ¬¡åœ¨`qrest`æˆ–`dequeue`æ—¶éƒ½ä¼šå¯¼è‡´ä¸¤æ¬¡åè½¬ã€‚è¦äº†è§£å¦‚ä½•åšå¾—æ›´å¥½ï¼Œä»¥åŠè¿›è¡Œæ›´æ·±å…¥çš„åˆ†æï¼Œè¯·å‚é˜…[ç¤ºä¾‹ï¼šä»åˆ—è¡¨ä¸­åˆ›å»ºé˜Ÿåˆ—](amortized-analysis.html#%28part._queue-data-structure%29)ã€‚
- en: One thing to note is that by providing only a picker interface, weâ€™re slightly
    changing the meaning of queues. The picker interface in Pyret is designed for
    sets, which donâ€™t have a notion of order. But queues are, of course, very much
    an ordered datatype; order is why they exist. So by providing only a picker interface,
    we donâ€™t offer the very guarantee that queues are designed for. Therefore, we
    should provide a picker in addition to an ordered interface, rather than in place
    of one.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸€ä¸ªéœ€è¦æ³¨æ„çš„äº‹æƒ…æ˜¯ï¼Œé€šè¿‡ä»…æä¾›é€‰æ‹©å™¨æ¥å£ï¼Œæˆ‘ä»¬ç•¥å¾®æ”¹å˜äº†é˜Ÿåˆ—çš„å«ä¹‰ã€‚Pyretä¸­çš„é€‰æ‹©å™¨æ¥å£æ˜¯ä¸ºé›†åˆè®¾è®¡çš„ï¼Œé›†åˆæ²¡æœ‰é¡ºåºçš„æ¦‚å¿µã€‚ä½†é˜Ÿåˆ—å½“ç„¶æ˜¯ä¸€ä¸ªéå¸¸æœ‰åºçš„æ•°æ®ç±»å‹ï¼›é¡ºåºæ˜¯å®ƒä»¬å­˜åœ¨çš„åŸå› ã€‚å› æ­¤ï¼Œé€šè¿‡ä»…æä¾›é€‰æ‹©å™¨æ¥å£ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰æä¾›é˜Ÿåˆ—è®¾è®¡æ‰€ä¿è¯çš„ä¿è¯ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”åœ¨æœ‰åºæ¥å£ä¹‹å¤–æä¾›é€‰æ‹©å™¨ï¼Œè€Œä¸æ˜¯ä»£æ›¿å®ƒã€‚
- en: At this point weâ€™re done with the essential content, but here are two more parts
    that you may find interesting.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»å®Œæˆäº†åŸºæœ¬å†…å®¹ï¼Œä½†è¿™é‡Œè¿˜æœ‰ä¸¤ä¸ªä½ å¯èƒ½æ„Ÿå…´è¶£çš„éƒ¨åˆ†ã€‚
- en: 8.2.4Â Using Tuples[ğŸ”—](#(part._qfl-tuples) "Link to here")
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.4 ä½¿ç”¨å…ƒç»„[ğŸ”—](#(part._qfl-tuples) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Earlier, we created the `Dequeued` datatype to represent the return value from
    the dequeue. Indeed, it is often useful to create datatypes of this sort to document
    functions and make sure the types can be meaningfully interpreted even when their
    values flow around the code some distance from where they were created.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹å‰ï¼Œæˆ‘ä»¬åˆ›å»ºäº†`Dequeued`æ•°æ®ç±»å‹æ¥è¡¨ç¤ºä»`dequeue`è¿”å›çš„å€¼ã€‚å®é™…ä¸Šï¼Œåˆ›å»ºè¿™ç§ç±»å‹çš„æ•°æ®ç±»å‹é€šå¸¸å¾ˆæœ‰ç”¨ï¼Œå¯ä»¥è®°å½•å‡½æ•°å¹¶ç¡®ä¿å³ä½¿å®ƒä»¬çš„å€¼åœ¨ä»£ç ä¸­è¿œç¦»åˆ›å»ºä½ç½®ä¹Ÿèƒ½æœ‰æ„ä¹‰åœ°è§£é‡Šç±»å‹ã€‚
- en: 'Sometimes, however, we want to create a compound datum in a special circumstance:
    it represents the return value of a function, and that return value will not live
    for very long, i.e., it will be taken apart as soon as it has returned and only
    the constituent parts will be used thereafter. In such situations, it can feel
    like a burden to create a new datatype for such a fleeting purpose. For such cases,
    Pyret has a built-in generic datatype called the tuple.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œæœ‰æ—¶æˆ‘ä»¬æƒ³åœ¨ç‰¹æ®Šæƒ…å†µä¸‹åˆ›å»ºä¸€ä¸ªå¤åˆæ•°æ®ï¼šå®ƒä»£è¡¨å‡½æ•°çš„è¿”å›å€¼ï¼Œè€Œè¿™ä¸ªè¿”å›å€¼ä¸ä¼šå­˜æ´»å¾ˆé•¿æ—¶é—´ï¼Œå³ï¼Œå®ƒä¼šåœ¨è¿”å›åç«‹å³è¢«æ‹†åˆ†ï¼Œä¹‹ååªä½¿ç”¨ç»„æˆéƒ¨åˆ†ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸ºè¿™æ ·ä¸€ä¸ªçŸ­æš‚çš„ç›®çš„åˆ›å»ºä¸€ä¸ªæ–°çš„æ•°æ®ç±»å‹å¯èƒ½ä¼šæ„Ÿè§‰åƒæ˜¯ä¸€ç§è´Ÿæ‹…ã€‚å¯¹äºè¿™ç§æƒ…å†µï¼ŒPyretæœ‰ä¸€ä¸ªå†…ç½®çš„é€šç”¨æ•°æ®ç±»å‹ï¼Œç§°ä¸ºå…ƒç»„ã€‚
- en: 'Here are some examples of tuples, which illustrate their syntax; note that
    each position (separated by `;`) takes an expression, not only a constant value:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€äº›å…ƒç»„çš„ç¤ºä¾‹ï¼Œå®ƒä»¬è¯´æ˜äº†å®ƒä»¬çš„è¯­æ³•ï¼›è¯·æ³¨æ„ï¼Œæ¯ä¸ªä½ç½®ï¼ˆç”±`;`åˆ†éš”ï¼‰éƒ½æ¥å—ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œè€Œä¸ä»…ä»…æ˜¯å¸¸é‡å€¼ï¼š
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also pull values out of tuples as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥æŒ‰ç…§ä»¥ä¸‹æ–¹å¼ä»å…ƒç»„ä¸­æå–å€¼ï¼š
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Evaluate `a` and `b` and see what they are bound to.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: è¯„ä¼°`a`å’Œ`b`å¹¶æŸ¥çœ‹å®ƒä»¬ç»‘å®šçš„æ˜¯ä»€ä¹ˆã€‚
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Similarly, see what `c`, `d`, and `e` are bound to.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»ä¼¼åœ°ï¼ŒæŸ¥çœ‹`c`ã€`d`å’Œ`e`ç»‘å®šçš„æ˜¯ä»€ä¹ˆã€‚
- en: Exercise
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What happens if we use too few or too many variables? Try out the following
    in Pyret and see what happens:'
  id: totrans-65
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ä½¿ç”¨å¤ªå°‘æˆ–å¤ªå¤šçš„å˜é‡ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿåœ¨Pyretä¸­å°è¯•ä»¥ä¸‹æ“ä½œå¹¶æŸ¥çœ‹ç»“æœï¼š
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Do Now!
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹å³è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if instead we write this?
  id: totrans-70
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬å†™æˆè¿™æ ·ä¼šæ€æ ·ï¼Ÿ
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-72
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This binds `p` to the entire tuple.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†`p`ç»‘å®šåˆ°æ•´ä¸ªå…ƒç»„ä¸Šã€‚
- en: Exercise
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How might we pull apart the constituents of `p`?
  id: totrans-76
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•æ‹†åˆ†`p`çš„ç»„æˆéƒ¨åˆ†ï¼Ÿ
- en: 'Now that we have tuples, we can write dequeue as:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†å…ƒç»„ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·ç¼–å†™dequeueï¼š
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And hereâ€™s how we can use it more generally:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥è¿™æ ·æ›´æ™®éåœ°ä½¿ç”¨å®ƒï¼š
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You should feel free to use tuples in your programs provided you follow the
    rules above for when tuples are applicable. In general, tuples can cause a reduction
    in readability, and increase the likelihood of errors (because tuples from one
    source arenâ€™t distinguishable from those from another source). Use them with caution!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥åœ¨ç¨‹åºä¸­ä½¿ç”¨å…ƒç»„ï¼Œåªè¦ä½ éµå¾ªä¸Šè¿°è§„åˆ™ï¼Œç¡®ä¿å…ƒç»„é€‚ç”¨ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå…ƒç»„å¯èƒ½ä¼šå¯¼è‡´å¯è¯»æ€§é™ä½ï¼Œå¹¶å¢åŠ å‡ºé”™çš„å¯èƒ½æ€§ï¼ˆå› ä¸ºæ¥è‡ªä¸€ä¸ªæ¥æºçš„å…ƒç»„ä¸æ¥è‡ªå¦ä¸€ä¸ªæ¥æºçš„å…ƒç»„æ— æ³•åŒºåˆ†ï¼‰ã€‚è¯·è°¨æ…ä½¿ç”¨ï¼
- en: 8.2.5Â A Picker Method[ğŸ”—](#(part._.A_.Picker_.Method) "Link to here")
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.5 é€‰æ‹©å™¨æ–¹æ³•[ğŸ”—](#(part._.A_.Picker_.Method) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Second, and this is truly optional: you may have noticed earlier that `Set`s
    had a built-in `pick` method. We have a function, but not method, that picks.
    Now weâ€™ll see how we can write this as a method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒç‚¹ï¼Œè¿™å®é™…ä¸Šæ˜¯å¯é€‰çš„ï¼šä½ å¯èƒ½å·²ç»æ³¨æ„åˆ°ï¼Œ`Set`æœ‰ä¸€ä¸ªå†…ç½®çš„`pick`æ–¹æ³•ã€‚æˆ‘ä»¬æœ‰ä¸€ä¸ªé€‰æ‹©å‡½æ•°ï¼Œä½†æ²¡æœ‰é€‰æ‹©æ–¹æ³•ã€‚ç°åœ¨æˆ‘ä»¬å°†çœ‹åˆ°æˆ‘ä»¬å¦‚ä½•å°†å…¶ç¼–å†™ä¸ºæ–¹æ³•ï¼š
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is a drop-in replacement for our previous definition of `Queue`, because
    weâ€™ve added a method but left the general datatype structure intact, so all our
    existing code will still work. In addition, we can rewrite `q2l` in terms of the
    picker interface:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æˆ‘ä»¬ä¹‹å‰å¯¹`Queue`å®šä¹‰çš„æ›¿ä»£å“ï¼Œå› ä¸ºæˆ‘ä»¬å¢åŠ äº†ä¸€ä¸ªæ–¹æ³•ï¼Œä½†ä¿ç•™äº†é€šç”¨çš„æ•°æ®ç±»å‹ç»“æ„ï¼Œæ‰€ä»¥æ‰€æœ‰ç°æœ‰çš„ä»£ç ä»ç„¶æœ‰æ•ˆã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨pickeræ¥å£æ¥é‡å†™`q2l`ï¼š
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can also write generic programs over data that support the Pick interface.
    For instance, hereâ€™s a function that will convert anything satisfying that interface
    into a list:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥åœ¨æ”¯æŒPickæ¥å£çš„æ•°æ®ä¸Šç¼–å†™é€šç”¨ç¨‹åºã€‚ä¾‹å¦‚ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒå¯ä»¥å°†æ»¡è¶³è¯¥æ¥å£çš„ä»»ä½•å†…å®¹è½¬æ¢ä¸ºåˆ—è¡¨ï¼š
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For instance, it works on both sets and our new `Queue`s:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œå®ƒé€‚ç”¨äºé›†åˆå’Œæˆ‘ä»¬çš„æ–°`Queue`ï¼š
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Exercise
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see why we invoked `sort` in the test above?
  id: totrans-93
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ çœ‹æ‡‚ä¸ºä»€ä¹ˆåœ¨ä¸Šè¿°æµ‹è¯•ä¸­æˆ‘ä»¬è°ƒç”¨äº†`sort`äº†å—ï¼Ÿ
- en: The only weakness here is that for this last part (making the function generic),
    we have to transition out of the type-checker, because `pick2l` cannot be typed
    by the current Pyret type checker. It requires a feature that the type checker
    does not (yet) have.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œå”¯ä¸€çš„å¼±ç‚¹æ˜¯ï¼Œå¯¹äºæœ€åä¸€éƒ¨åˆ†ï¼ˆä½¿å‡½æ•°é€šç”¨ï¼‰ï¼Œæˆ‘ä»¬å¿…é¡»é€€å‡ºç±»å‹æ£€æŸ¥å™¨ï¼Œå› ä¸º`pick2l`ä¸èƒ½ç”±å½“å‰çš„Pyretç±»å‹æ£€æŸ¥å™¨è¿›è¡Œç±»å‹æ£€æŸ¥ã€‚å®ƒéœ€è¦ä¸€ä¸ªç±»å‹æ£€æŸ¥å™¨ç›®å‰è¿˜æ²¡æœ‰çš„åŠŸèƒ½ã€‚
- en: 8.2.1Â Using a Wrapper Datatype[ğŸ”—](#(part._.Using_a_.Wrapper_.Datatype) "Link
    to here")
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1 ä½¿ç”¨åŒ…è£…æ•°æ®ç±»å‹[ğŸ”—](#(part._.Using_a_.Wrapper_.Datatype) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Concretely, hereâ€™s how weâ€™ll represent queues. For all the code that follows,
    itâ€™s helpful to use the Pyret type-checker to make sure weâ€™re composing code correctly:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬å°†è¿™æ ·è¡¨ç¤ºé˜Ÿåˆ—ã€‚å¯¹äºä»¥ä¸‹æ‰€æœ‰ä»£ç ï¼Œä½¿ç”¨Pyretç±»å‹æ£€æŸ¥å™¨æ¥ç¡®ä¿æˆ‘ä»¬æ­£ç¡®åœ°ç¼–å†™ä»£ç æ˜¯æœ‰å¸®åŠ©çš„ï¼š
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With this encoding, we can start define a few helper functions: e.g., a way
    to construct an empty queue and to check for emptiness:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ç§ç¼–ç ï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹å®šä¹‰ä¸€äº›è¾…åŠ©å‡½æ•°ï¼šä¾‹å¦‚ï¼Œæ„å»ºä¸€ä¸ªç©ºé˜Ÿåˆ—å’Œæ£€æŸ¥ç©ºæ€§çš„æ–¹æ³•ï¼š
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Adding an element to a queue is usually called â€œenqueueingâ€. It has this type:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: å‘é˜Ÿåˆ—ä¸­æ·»åŠ å…ƒç´ é€šå¸¸ç§°ä¸ºâ€œå…¥é˜Ÿâ€ã€‚å®ƒå…·æœ‰ä»¥ä¸‹ç±»å‹ï¼š
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Hereâ€™s the corresponding implementation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯å¯¹åº”çš„å®ç°ï¼š
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Do Now!
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did we have a choice?
  id: totrans-106
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ‰é€‰æ‹©å—ï¼Ÿ
- en: 'Yes, we did! We could have made the new element the first element or the last
    element.Be careful here: we mean the first or last element of the list that represents
    the queue, not of the queue itself. There, FIFO gives us no choice. We just happened
    to choose one representation. The other would be equally valid; we would just
    need to implement all the other operations consistently. Letâ€™s stick to this one
    for now.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¯çš„ï¼Œæˆ‘ä»¬åšåˆ°äº†ï¼æˆ‘ä»¬å¯ä»¥å°†æ–°å…ƒç´ ä½œä¸ºç¬¬ä¸€ä¸ªå…ƒç´ æˆ–æœ€åä¸€ä¸ªå…ƒç´ ã€‚åœ¨è¿™é‡Œè¦å°å¿ƒï¼šæˆ‘ä»¬æŒ‡çš„æ˜¯è¡¨ç¤ºé˜Ÿåˆ—çš„åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªæˆ–æœ€åä¸€ä¸ªå…ƒç´ ï¼Œè€Œä¸æ˜¯é˜Ÿåˆ—æœ¬èº«ã€‚åœ¨é‚£é‡Œï¼ŒFIFOæ²¡æœ‰ç»™æˆ‘ä»¬é€‰æ‹©ã€‚æˆ‘ä»¬åªæ˜¯ç¢°å·§é€‰æ‹©äº†è¿™ç§è¡¨ç¤ºã€‚å¦ä¸€ç§è¡¨ç¤ºåŒæ ·æœ‰æ•ˆï¼›æˆ‘ä»¬åªéœ€è¦ä¸€è‡´åœ°å®ç°æ‰€æœ‰å…¶ä»–æ“ä½œã€‚ç°åœ¨è®©æˆ‘ä»¬åšæŒä½¿ç”¨è¿™ç§è¡¨ç¤ºã€‚
- en: 'Now we come to a problem. What does it mean to â€œdequeueâ€? We need to get back
    the one element, but we also need to get back the rest. Letâ€™s first write this
    as two functions, very analogous to first and rest on lists:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬é‡åˆ°äº†ä¸€ä¸ªé—®é¢˜ã€‚ä»€ä¹ˆæ˜¯â€œå‡ºé˜Ÿâ€çš„å«ä¹‰ï¼Ÿæˆ‘ä»¬éœ€è¦è·å–ä¸€ä¸ªå…ƒç´ ï¼Œä½†è¿˜éœ€è¦è·å–å…¶ä½™éƒ¨åˆ†ã€‚è®©æˆ‘ä»¬é¦–å…ˆå°†å…¶ç¼–å†™ä¸ºä¸¤ä¸ªå‡½æ•°ï¼Œéå¸¸ç±»ä¼¼äºåˆ—è¡¨ä¸Šçš„firstå’Œrestï¼š
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Letâ€™s write out a few examples to make sure we know how these should work:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç¼–å†™ä¸€äº›ç¤ºä¾‹ï¼Œä»¥ç¡®ä¿æˆ‘ä»¬çŸ¥é“è¿™äº›åº”è¯¥å¦‚ä½•å·¥ä½œï¼š
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now letâ€™s implement these:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬å®ç°è¿™äº›ï¼š
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 8.2.2Â Combining Answers[ğŸ”—](#(part._qfl-comb-ans) "Link to here")
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2 ç»“åˆç­”æ¡ˆ[ğŸ”—](#(part._qfl-comb-ans) "é“¾æ¥è‡³æ­¤")
- en: However, it would be nice if we could obtain both the oldest element and the
    rest of the queue at once, if we want them both. That means the single function
    would need to return two values; since a function can return only one value at
    a time, it would need to use a data structure to hold both of them. Furthermore,
    note that both `qpeek` and `qrest` above have the possibility of not having any
    more elements! We might as well reflect that too in the type. Thus we end up with
    a type that looks like
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬æƒ³åŒæ—¶è·å¾—æœ€è€çš„å…ƒç´ å’Œé˜Ÿåˆ—çš„å…¶ä½™éƒ¨åˆ†ï¼Œé‚£ä¼šæ›´å¥½ã€‚è¿™æ„å‘³ç€å•ä¸ªå‡½æ•°éœ€è¦è¿”å›ä¸¤ä¸ªå€¼ï¼›ç”±äºå‡½æ•°ä¸€æ¬¡åªèƒ½è¿”å›ä¸€ä¸ªå€¼ï¼Œå®ƒéœ€è¦ä½¿ç”¨ä¸€ä¸ªæ•°æ®ç»“æ„æ¥ä¿å­˜è¿™ä¸¤ä¸ªå€¼ã€‚æ­¤å¤–ï¼Œè¯·æ³¨æ„ï¼Œä¸Šé¢çš„`qpeek`å’Œ`qrest`éƒ½æœ‰å¯èƒ½æ²¡æœ‰æ›´å¤šçš„å…ƒç´ ï¼æˆ‘ä»¬æœ€å¥½ä¹Ÿåœ¨ç±»å‹ä¸­åæ˜ è¿™ä¸€ç‚¹ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æœ€ç»ˆå¾—åˆ°ä¸€ä¸ªçœ‹èµ·æ¥åƒè¿™æ ·çš„ç±»å‹
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Exercise
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write out the function to use this return type.
  id: totrans-119
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™ä½¿ç”¨è¿™ç§è¿”å›ç±»å‹çš„å‡½æ•°ã€‚
- en: 'Observe that this also follows our principle of making exceptional behavior
    manifest in the return type: [The Option Type](partial-domains.html#%28part._pd-option%29),
    and especially in [Summary](partial-domains.html#%28part._pd-summary%29).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™ä¹Ÿéµå¾ªäº†æˆ‘ä»¬çš„åŸåˆ™ï¼Œå³åœ¨è¿”å›ç±»å‹ä¸­ä½“ç°å¼‚å¸¸è¡Œä¸ºï¼š[é€‰é¡¹ç±»å‹](partial-domains.html#%28part._pd-option%29)ï¼Œå°¤å…¶æ˜¯åœ¨[æ€»ç»“](partial-domains.html#%28part._pd-summary%29)ä¸­ã€‚
- en: Exercise
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write out the function using this return type.
  id: totrans-123
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ç§è¿”å›ç±»å‹ç¼–å†™å‡½æ•°ã€‚
- en: 8.2.3Â Using a Picker[ğŸ”—](#(part._.Using_a_.Picker) "Link to here")
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.3 ä½¿ç”¨é€‰æ‹©å™¨[ğŸ”—](#(part._.Using_a_.Picker) "é“¾æ¥è‡³æ­¤")
- en: 'Does `Dequeued` look familiar? Of course it should! Itâ€™s basically the same
    as the pickers used for sets in Pyret: [Picking Elements from Sets](Collections_of_Structured_Data.html#%28part._coll-sd-pick%29).
    If we make queues provide the same operations, we can reuse the `Pick` library
    already built into the language, and reuse any code that is written expecting
    the picker interface.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dequeued`çœ‹èµ·æ¥ç†Ÿæ‚‰å—ï¼Ÿå½“ç„¶åº”è¯¥ç†Ÿæ‚‰ï¼å®ƒåŸºæœ¬ä¸Šä¸Pyretä¸­ç”¨äºé›†åˆçš„é€‰æ‹©å™¨ç›¸åŒï¼š[ä»é›†åˆä¸­é€‰å–å…ƒç´ ](Collections_of_Structured_Data.html#%28part._coll-sd-pick%29)ã€‚å¦‚æœæˆ‘ä»¬è®©é˜Ÿåˆ—æä¾›ç›¸åŒçš„æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥é‡ç”¨è¯­è¨€ä¸­å·²ç»æ„å»ºçš„`Pick`åº“ï¼Œå¹¶é‡ç”¨ä»»ä½•æœŸæœ›é€‰æ‹©å™¨æ¥å£ç¼–å†™çš„ä»£ç ã€‚'
- en: 'To do so, first we need to import the picker library:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: è¦åšåˆ°è¿™ä¸€ç‚¹ï¼Œé¦–å…ˆæˆ‘ä»¬éœ€è¦å¯¼å…¥é€‰æ‹©å™¨åº“ï¼š
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then we can write:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™ï¼š
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here are some examples showing how it would work:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€äº›ç¤ºä¾‹ï¼Œå±•ç¤ºäº†å®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼š
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And hereâ€™s the corresponding code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯å¯¹åº”çš„ä»£ç ï¼š
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In terms of big-O complexity, this is a dreadfully inefficient implementation,
    causing two reversals on every `qrest` or `dequeue`. To see how to do better,
    and to conduct a more sophisticated analysis, see [An Example: Queues from Lists](amortized-analysis.html#%28part._queue-data-structure%29).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¤§Oå¤æ‚åº¦æ–¹é¢ï¼Œè¿™æ˜¯ä¸€ä¸ªæ•ˆç‡æä½å®ç°ï¼Œæ¯æ¬¡`qrest`æˆ–`dequeue`éƒ½ä¼šå¯¼è‡´ä¸¤æ¬¡åè½¬ã€‚è¦äº†è§£å¦‚ä½•åšå¾—æ›´å¥½ï¼Œä»¥åŠè¿›è¡Œæ›´å¤æ‚åˆ†æï¼Œè¯·å‚é˜…[ç¤ºä¾‹ï¼šä»åˆ—è¡¨ä¸­æ„å»ºé˜Ÿåˆ—](amortized-analysis.html#%28part._queue-data-structure%29)ã€‚
- en: One thing to note is that by providing only a picker interface, weâ€™re slightly
    changing the meaning of queues. The picker interface in Pyret is designed for
    sets, which donâ€™t have a notion of order. But queues are, of course, very much
    an ordered datatype; order is why they exist. So by providing only a picker interface,
    we donâ€™t offer the very guarantee that queues are designed for. Therefore, we
    should provide a picker in addition to an ordered interface, rather than in place
    of one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸€ä¸ªéœ€è¦æ³¨æ„çš„äº‹æƒ…æ˜¯ï¼Œé€šè¿‡åªæä¾›é€‰æ‹©å™¨ç•Œé¢ï¼Œæˆ‘ä»¬ç•¥å¾®æ”¹å˜äº†é˜Ÿåˆ—çš„å«ä¹‰ã€‚Pyretä¸­çš„é€‰æ‹©å™¨ç•Œé¢æ˜¯ä¸ºé›†åˆè®¾è®¡çš„ï¼Œé›†åˆæ²¡æœ‰é¡ºåºçš„æ¦‚å¿µã€‚ä½†é˜Ÿåˆ—å½“ç„¶æ˜¯ä¸€ä¸ªéå¸¸æœ‰åºçš„æ•°æ®ç±»å‹ï¼›é¡ºåºæ˜¯å®ƒä»¬å­˜åœ¨çš„åŸå› ã€‚æ‰€ä»¥ï¼Œé€šè¿‡åªæä¾›é€‰æ‹©å™¨ç•Œé¢ï¼Œæˆ‘ä»¬æ²¡æœ‰æä¾›é˜Ÿåˆ—è®¾è®¡æ—¶æ‰€ä¿è¯çš„ä¿è¯ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”åœ¨æœ‰åºç•Œé¢ä¹‹å¤–æä¾›é€‰æ‹©å™¨ï¼Œè€Œä¸æ˜¯å–ä»£å®ƒã€‚
- en: At this point weâ€™re done with the essential content, but here are two more parts
    that you may find interesting.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å·²ç»å®Œæˆäº†åŸºæœ¬å†…å®¹ï¼Œä½†è¿™é‡Œè¿˜æœ‰ä¸¤ä¸ªä½ å¯èƒ½æ„Ÿå…´è¶£çš„éƒ¨åˆ†ã€‚
- en: 8.2.4Â Using Tuples[ğŸ”—](#(part._qfl-tuples) "Link to here")
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.4Â ä½¿ç”¨å…ƒç»„[ğŸ”—](#(part._qfl-tuples) "é“¾æ¥è‡³æ­¤")
- en: Earlier, we created the `Dequeued` datatype to represent the return value from
    the dequeue. Indeed, it is often useful to create datatypes of this sort to document
    functions and make sure the types can be meaningfully interpreted even when their
    values flow around the code some distance from where they were created.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹å‰ï¼Œæˆ‘ä»¬åˆ›å»ºäº†`Dequeued`æ•°æ®ç±»å‹æ¥è¡¨ç¤ºå‡ºé˜Ÿæ“ä½œçš„è¿”å›å€¼ã€‚ç¡®å®ï¼Œåˆ›å»ºè¿™ç§ç±»å‹çš„æ•°æ®ç±»å‹é€šå¸¸å¾ˆæœ‰ç”¨ï¼Œå¯ä»¥è®°å½•å‡½æ•°å¹¶ç¡®ä¿å³ä½¿å®ƒä»¬çš„å€¼åœ¨ä»£ç ä¸­è¿œç¦»åˆ›å»ºä½ç½®ä¹Ÿèƒ½æœ‰æ„ä¹‰åœ°è§£é‡Šç±»å‹ã€‚
- en: 'Sometimes, however, we want to create a compound datum in a special circumstance:
    it represents the return value of a function, and that return value will not live
    for very long, i.e., it will be taken apart as soon as it has returned and only
    the constituent parts will be used thereafter. In such situations, it can feel
    like a burden to create a new datatype for such a fleeting purpose. For such cases,
    Pyret has a built-in generic datatype called the tuple.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œæœ‰æ—¶åœ¨ç‰¹æ®Šæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æƒ³è¦åˆ›å»ºä¸€ä¸ªå¤åˆæ•°æ®ï¼šå®ƒä»£è¡¨å‡½æ•°çš„è¿”å›å€¼ï¼Œè€Œè¿™ä¸ªè¿”å›å€¼ä¸ä¼šå­˜æ´»å¾ˆé•¿æ—¶é—´ï¼Œå³ï¼Œå®ƒä¼šåœ¨è¿”å›åç«‹å³è¢«æ‹†åˆ†ï¼Œä¹‹ååªä½¿ç”¨å…¶ç»„æˆéƒ¨åˆ†ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸ºè¿™æ ·ä¸€ä¸ªçŸ­æš‚çš„ç›®çš„åˆ›å»ºä¸€ä¸ªæ–°çš„æ•°æ®ç±»å‹å¯èƒ½ä¼šæ„Ÿè§‰åƒæ˜¯ä¸€ç§è´Ÿæ‹…ã€‚å¯¹äºè¿™ç§æƒ…å†µï¼ŒPyretæœ‰ä¸€ä¸ªå†…ç½®çš„é€šç”¨æ•°æ®ç±»å‹ï¼Œç§°ä¸ºå…ƒç»„ã€‚
- en: 'Here are some examples of tuples, which illustrate their syntax; note that
    each position (separated by `;`) takes an expression, not only a constant value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€äº›å…ƒç»„çš„ä¾‹å­ï¼Œå®ƒä»¬è¯´æ˜äº†å®ƒä»¬çš„è¯­æ³•ï¼›è¯·æ³¨æ„ï¼Œæ¯ä¸ªä½ç½®ï¼ˆç”±`;`åˆ†éš”ï¼‰éƒ½åŒ…å«ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œè€Œä¸ä»…ä»…æ˜¯å¸¸é‡å€¼ï¼š
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can also pull values out of tuples as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥è¿™æ ·ä»å…ƒç»„ä¸­æå–å€¼ï¼š
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Evaluate `a` and `b` and see what they are bound to.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: è¯„ä¼° `a` å’Œ `b` å¹¶çœ‹çœ‹å®ƒä»¬è¢«ç»‘å®šåˆ°äº†ä»€ä¹ˆã€‚
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Similarly, see what `c`, `d`, and `e` are bound to.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»ä¼¼åœ°ï¼Œçœ‹çœ‹`c`ã€`d`å’Œ`e`è¢«ç»‘å®šåˆ°äº†ä»€ä¹ˆã€‚
- en: Exercise
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What happens if we use too few or too many variables? Try out the following
    in Pyret and see what happens:'
  id: totrans-149
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ä½¿ç”¨å¤ªå°‘æˆ–å¤ªå¤šçš„å˜é‡ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿåœ¨Pyretä¸­å°è¯•ä»¥ä¸‹æ“ä½œå¹¶çœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆï¼š
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-151
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Do Now!
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if instead we write this?
  id: totrans-154
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æ¢æˆå†™è¿™ä¸ªä¼šæ€æ ·å‘¢ï¼Ÿ
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-156
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This binds `p` to the entire tuple.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†`p`ç»‘å®šåˆ°äº†æ•´ä¸ªå…ƒç»„ã€‚
- en: Exercise
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How might we pull apart the constituents of `p`?
  id: totrans-160
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•æ‹†åˆ†`p`çš„ç»„æˆéƒ¨åˆ†ï¼Ÿ
- en: 'Now that we have tuples, we can write dequeue as:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†å…ƒç»„ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å†™å‡ºé˜Ÿæ“ä½œï¼š
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And hereâ€™s how we can use it more generally:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯æˆ‘ä»¬å¯ä»¥æ›´æ™®éåœ°ä½¿ç”¨å®ƒçš„æ–¹æ³•ï¼š
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You should feel free to use tuples in your programs provided you follow the
    rules above for when tuples are applicable. In general, tuples can cause a reduction
    in readability, and increase the likelihood of errors (because tuples from one
    source arenâ€™t distinguishable from those from another source). Use them with caution!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: åªè¦éµå¾ªä¸Šè¿°é€‚ç”¨äºå…ƒç»„çš„æƒ…å†µçš„è§„åˆ™ï¼Œä½ å°±å¯ä»¥åœ¨ç¨‹åºä¸­ä½¿ç”¨å…ƒç»„ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå…ƒç»„å¯èƒ½ä¼šé™ä½å¯è¯»æ€§ï¼Œå¹¶å¢åŠ å‡ºé”™çš„å¯èƒ½æ€§ï¼ˆå› ä¸ºæ¥è‡ªä¸€ä¸ªæºå¤´çš„å…ƒç»„ä¸æ¥è‡ªå¦ä¸€ä¸ªæºå¤´çš„å…ƒç»„æ˜¯æ— æ³•åŒºåˆ†çš„ï¼‰ã€‚ä½¿ç”¨æ—¶è¦è°¨æ…ï¼
- en: 8.2.5Â A Picker Method[ğŸ”—](#(part._.A_.Picker_.Method) "Link to here")
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.5Â é€‰æ‹©å™¨æ–¹æ³•[ğŸ”—](#(part._.A_.Picker_.Method) "é“¾æ¥è‡³æ­¤")
- en: 'Second, and this is truly optional: you may have noticed earlier that `Set`s
    had a built-in `pick` method. We have a function, but not method, that picks.
    Now weâ€™ll see how we can write this as a method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒç‚¹ï¼Œè¿™å®é™…ä¸Šæ˜¯å¯é€‰çš„ï¼šä½ å¯èƒ½å·²ç»æ³¨æ„åˆ°äº†ï¼Œ`Set`æœ‰ä¸€ä¸ªå†…ç½®çš„`pick`æ–¹æ³•ã€‚æˆ‘ä»¬æœ‰ä¸€ä¸ªé€‰æ‹©å‡½æ•°ï¼Œä½†æ²¡æœ‰é€‰æ‹©æ–¹æ³•ã€‚ç°åœ¨æˆ‘ä»¬å°†çœ‹åˆ°å¦‚ä½•å°†å…¶ç¼–å†™ä¸ºæ–¹æ³•ï¼š
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is a drop-in replacement for our previous definition of `Queue`, because
    weâ€™ve added a method but left the general datatype structure intact, so all our
    existing code will still work. In addition, we can rewrite `q2l` in terms of the
    picker interface:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æˆ‘ä»¬ä¹‹å‰å®šä¹‰çš„`Queue`çš„æ›¿ä»£å“ï¼Œå› ä¸ºæˆ‘ä»¬å¢åŠ äº†ä¸€ä¸ªæ–¹æ³•ï¼Œä½†ä¿ç•™äº†é€šç”¨æ•°æ®ç±»å‹ç»“æ„ï¼Œæ‰€ä»¥æ‰€æœ‰ç°æœ‰çš„ä»£ç ä»ç„¶å¯ä»¥å·¥ä½œã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨é€‰æ‹©å™¨ç•Œé¢é‡å†™`q2l`ï¼š
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can also write generic programs over data that support the Pick interface.
    For instance, hereâ€™s a function that will convert anything satisfying that interface
    into a list:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥ç¼–å†™æ”¯æŒPickæ¥å£çš„æ•°æ®çš„æ³›å‹ç¨‹åºã€‚ä¾‹å¦‚ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªå‡½æ•°å¯ä»¥å°†æ»¡è¶³è¯¥æ¥å£çš„ä»»ä½•å†…å®¹è½¬æ¢ä¸ºåˆ—è¡¨ï¼š
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For instance, it works on both sets and our new `Queue`s:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œå®ƒé€‚ç”¨äºé›†åˆå’Œæˆ‘ä»¬çš„æ–°`Queue`ï¼š
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Exercise
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see why we invoked `sort` in the test above?
  id: totrans-177
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ çœ‹åˆ°ä¸ºä»€ä¹ˆæˆ‘ä»¬åœ¨ä¸Šé¢çš„æµ‹è¯•ä¸­è°ƒç”¨äº†`sort`äº†å—ï¼Ÿ
- en: The only weakness here is that for this last part (making the function generic),
    we have to transition out of the type-checker, because `pick2l` cannot be typed
    by the current Pyret type checker. It requires a feature that the type checker
    does not (yet) have.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„å”¯ä¸€å¼±ç‚¹æ˜¯ï¼Œå¯¹äºæœ€åä¸€éƒ¨åˆ†ï¼ˆä½¿å‡½æ•°é€šç”¨ï¼‰ï¼Œæˆ‘ä»¬å¿…é¡»è„±ç¦»ç±»å‹æ£€æŸ¥å™¨ï¼Œå› ä¸º`pick2l`æ— æ³•é€šè¿‡å½“å‰çš„Pyretç±»å‹æ£€æŸ¥å™¨è¿›è¡Œç±»å‹åŒ–ã€‚å®ƒéœ€è¦ä¸€ä¸ªç±»å‹æ£€æŸ¥å™¨ç›®å‰è¿˜æ²¡æœ‰çš„åŠŸèƒ½ã€‚
