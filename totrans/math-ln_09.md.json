["```py\nexample  {M  :  Type*}  [Monoid  M]  (x  :  M)  :  x  *  1  =  x  :=  mul_one  x\n\nexample  {M  :  Type*}  [AddCommMonoid  M]  (x  y  :  M)  :  x  +  y  =  y  +  x  :=  add_comm  x  y \n```", "```py\nexample  {M  N  :  Type*}  [Monoid  M]  [Monoid  N]  (x  y  :  M)  (f  :  M  →*  N)  :  f  (x  *  y)  =  f  x  *  f  y  :=\n  f.map_mul  x  y\n\nexample  {M  N  :  Type*}  [AddMonoid  M]  [AddMonoid  N]  (f  :  M  →+  N)  :  f  0  =  0  :=\n  f.map_zero \n```", "```py\nexample  {M  N  P  :  Type*}  [AddMonoid  M]  [AddMonoid  N]  [AddMonoid  P]\n  (f  :  M  →+  N)  (g  :  N  →+  P)  :  M  →+  P  :=  g.comp  f \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (x  :  G)  :  x  *  x⁻¹  =  1  :=  mul_inv_cancel  x \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (x  y  z  :  G)  :  x  *  (y  *  z)  *  (x  *  z)⁻¹  *  (x  *  y  *  x⁻¹)⁻¹  =  1  :=  by\n  group \n```", "```py\nexample  {G  :  Type*}  [AddCommGroup  G]  (x  y  z  :  G)  :  z  +  x  +  (y  -  z  -  x)  =  y  :=  by\n  abel \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (x  y  :  G)  (f  :  G  →*  H)  :  f  (x  *  y)  =  f  x  *  f  y  :=\n  f.map_mul  x  y \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (x  :  G)  (f  :  G  →*  H)  :  f  (x⁻¹)  =  (f  x)⁻¹  :=\n  f.map_inv  x \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (f  :  G  →  H)  (h  :  ∀  x  y,  f  (x  *  y)  =  f  x  *  f  y)  :\n  G  →*  H  :=\n  MonoidHom.mk'  f  h \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (f  :  G  ≃*  H)  :\n  f.trans  f.symm  =  MulEquiv.refl  G  :=\n  f.self_trans_symm \n```", "```py\nnoncomputable  example  {G  H  :  Type*}  [Group  G]  [Group  H]\n  (f  :  G  →*  H)  (h  :  Function.Bijective  f)  :\n  G  ≃*  H  :=\n  MulEquiv.ofBijective  f  h \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  {x  y  :  G}  (hx  :  x  ∈  H)  (hy  :  y  ∈  H)  :\n  x  *  y  ∈  H  :=\n  H.mul_mem  hx  hy\n\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  {x  :  G}  (hx  :  x  ∈  H)  :\n  x⁻¹  ∈  H  :=\n  H.inv_mem  hx \n```", "```py\nexample  :  AddSubgroup  ℚ  where\n  carrier  :=  Set.range  ((↑)  :  ℤ  →  ℚ)\n  add_mem'  :=  by\n  rintro  _  _  ⟨n,  rfl⟩  ⟨m,  rfl⟩\n  use  n  +  m\n  simp\n  zero_mem'  :=  by\n  use  0\n  simp\n  neg_mem'  :=  by\n  rintro  _  ⟨n,  rfl⟩\n  use  -n\n  simp \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  :  Group  H  :=  inferInstance \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  :  Group  {x  :  G  //  x  ∈  H}  :=  inferInstance \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  H'  :  Subgroup  G)  :\n  ((H  ⊓  H'  :  Subgroup  G)  :  Set  G)  =  (H  :  Set  G)  ∩  (H'  :  Set  G)  :=  rfl \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  H'  :  Subgroup  G)  :\n  ((H  ⊔  H'  :  Subgroup  G)  :  Set  G)  =  Subgroup.closure  ((H  :  Set  G)  ∪  (H'  :  Set  G))  :=  by\n  rw  [Subgroup.sup_eq_closure] \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (x  :  G)  :  x  ∈  (⊤  :  Subgroup  G)  :=  trivial \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (x  :  G)  :  x  ∈  (⊥  :  Subgroup  G)  ↔  x  =  1  :=  Subgroup.mem_bot \n```", "```py\ndef  conjugate  {G  :  Type*}  [Group  G]  (x  :  G)  (H  :  Subgroup  G)  :  Subgroup  G  where\n  carrier  :=  {a  :  G  |  ∃  h,  h  ∈  H  ∧  a  =  x  *  h  *  x⁻¹}\n  one_mem'  :=  by\n  dsimp\n  sorry\n  inv_mem'  :=  by\n  dsimp\n  sorry\n  mul_mem'  :=  by\n  dsimp\n  sorry \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (G'  :  Subgroup  G)  (f  :  G  →*  H)  :  Subgroup  H  :=\n  Subgroup.map  f  G'\n\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (H'  :  Subgroup  H)  (f  :  G  →*  H)  :  Subgroup  G  :=\n  Subgroup.comap  f  H'\n\n#check  Subgroup.mem_map\n#check  Subgroup.mem_comap \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (f  :  G  →*  H)  (g  :  G)  :\n  g  ∈  MonoidHom.ker  f  ↔  f  g  =  1  :=\n  f.mem_ker\n\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (f  :  G  →*  H)  (h  :  H)  :\n  h  ∈  MonoidHom.range  f  ↔  ∃  g  :  G,  f  g  =  h  :=\n  f.mem_range \n```", "```py\nsection  exercises\nvariable  {G  H  :  Type*}  [Group  G]  [Group  H]\n\nopen  Subgroup\n\nexample  (φ  :  G  →*  H)  (S  T  :  Subgroup  H)  (hST  :  S  ≤  T)  :  comap  φ  S  ≤  comap  φ  T  :=  by\n  sorry\n\nexample  (φ  :  G  →*  H)  (S  T  :  Subgroup  G)  (hST  :  S  ≤  T)  :  map  φ  S  ≤  map  φ  T  :=  by\n  sorry\n\nvariable  {K  :  Type*}  [Group  K]\n\n-- Remember you can use the `ext` tactic to prove an equality of subgroups.\nexample  (φ  :  G  →*  H)  (ψ  :  H  →*  K)  (U  :  Subgroup  K)  :\n  comap  (ψ.comp  φ)  U  =  comap  φ  (comap  ψ  U)  :=  by\n  sorry\n\n-- Pushing a subgroup along one homomorphism and then another is equal to\n-- pushing it forward along the composite of the homomorphisms.\nexample  (φ  :  G  →*  H)  (ψ  :  H  →*  K)  (S  :  Subgroup  G)  :\n  map  (ψ.comp  φ)  S  =  map  ψ  (S.map  φ)  :=  by\n  sorry\n\nend  exercises \n```", "```py\nopen  scoped  Classical\n\nexample  {G  :  Type*}  [Group  G]  (G'  :  Subgroup  G)  :  Nat.card  G'  ∣  Nat.card  G  :=\n  ⟨G'.index,  mul_comm  G'.index  _  ▸  G'.index_mul_card.symm⟩\n\nopen  Subgroup\n\nexample  {G  :  Type*}  [Group  G]  [Finite  G]  (p  :  ℕ)  {n  :  ℕ}  [Fact  p.Prime]\n  (hdvd  :  p  ^  n  ∣  Nat.card  G)  :  ∃  K  :  Subgroup  G,  Nat.card  K  =  p  ^  n  :=\n  Sylow.exists_subgroup_card_pow_prime  p  hdvd \n```", "```py\nlemma  eq_bot_iff_card  {G  :  Type*}  [Group  G]  {H  :  Subgroup  G}  :\n  H  =  ⊥  ↔  Nat.card  H  =  1  :=  by\n  suffices  (∀  x  ∈  H,  x  =  1)  ↔  ∃  x  ∈  H,  ∀  a  ∈  H,  a  =  x  by\n  simpa  [eq_bot_iff_forall,  Nat.card_eq_one_iff_exists]\n  sorry\n\n#check  card_dvd_of_le\n\nlemma  inf_bot_of_coprime  {G  :  Type*}  [Group  G]  (H  K  :  Subgroup  G)\n  (h  :  (Nat.card  H).Coprime  (Nat.card  K))  :  H  ⊓  K  =  ⊥  :=  by\n  sorry \n```", "```py\nopen  Equiv\n\nexample  {X  :  Type*}  [Finite  X]  :  Subgroup.closure  {σ  :  Perm  X  |  Perm.IsCycle  σ}  =  ⊤  :=\n  Perm.closure_isCycle \n```", "```py\n#simp  [mul_assoc]  c[1,  2,  3]  *  c[2,  3,  4] \n```", "```py\nsection  FreeGroup\n\ninductive  S  |  a  |  b  |  c\n\nopen  S\n\ndef  myElement  :  FreeGroup  S  :=  (.of  a)  *  (.of  b)⁻¹ \n```", "```py\ndef  myMorphism  :  FreeGroup  S  →*  Perm  (Fin  5)  :=\n  FreeGroup.lift  fun  |  .a  =>  c[1,  2,  3]\n  |  .b  =>  c[2,  3,  1]\n  |  .c  =>  c[2,  3] \n```", "```py\ndef  myGroup  :=  PresentedGroup  {.of  ()  ^  3}  deriving  Group \n```", "```py\ndef  myMap  :  Unit  →  Perm  (Fin  5)\n|  ()  =>  c[1,  2,  3]\n\nlemma  compat_myMap  :\n  ∀  r  ∈  ({.of  ()  ^  3}  :  Set  (FreeGroup  Unit)),  FreeGroup.lift  myMap  r  =  1  :=  by\n  rintro  _  rfl\n  simp\n  decide\n\ndef  myNewMorphism  :  myGroup  →*  Perm  (Fin  5)  :=  PresentedGroup.toGroup  compat_myMap\n\nend  FreeGroup \n```", "```py\nnoncomputable  section  GroupActions\n\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  (g  g':  G)  (x  :  X)  :\n  g  •  (g'  •  x)  =  (g  *  g')  •  x  :=\n  (mul_smul  g  g'  x).symm \n```", "```py\nexample  {G  X  :  Type*}  [AddGroup  G]  [AddAction  G  X]  (g  g'  :  G)  (x  :  X)  :\n  g  +ᵥ  (g'  +ᵥ  x)  =  (g  +  g')  +ᵥ  x  :=\n  (add_vadd  g  g'  x).symm \n```", "```py\nopen  MulAction\n\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  :  G  →*  Equiv.Perm  X  :=\n  toPermHom  G  X \n```", "```py\ndef  CayleyIsoMorphism  (G  :  Type*)  [Group  G]  :  G  ≃*  (toPermHom  G  G).range  :=\n  Equiv.Perm.subgroupOfMulAction  G  G \n```", "```py\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  :  Setoid  X  :=  orbitRel  G  X \n```", "```py\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  :\n  X  ≃  (ω  :  orbitRel.Quotient  G  X)  ×  (orbit  G  (Quotient.out  ω))  :=\n  MulAction.selfEquivSigmaOrbits  G  X \n```", "```py\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  (x  :  X)  :\n  orbit  G  x  ≃  G  ⧸  stabilizer  G  x  :=\n  MulAction.orbitEquivQuotientStabilizer  G  x \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  :  G  ≃  (G  ⧸  H)  ×  H  :=\n  groupEquivQuotientProdSubgroup \n```", "```py\nvariable  {G  :  Type*}  [Group  G]\n\nlemma  conjugate_one  (H  :  Subgroup  G)  :  conjugate  1  H  =  H  :=  by\n  sorry\n\ninstance  :  MulAction  G  (Subgroup  G)  where\n  smul  :=  conjugate\n  one_smul  :=  by\n  sorry\n  mul_smul  :=  by\n  sorry\n\nend  GroupActions \n```", "```py\nnoncomputable  section  QuotientGroup\n\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  [H.Normal]  :  Group  (G  ⧸  H)  :=  inferInstance\n\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  [H.Normal]  :  G  →*  G  ⧸  H  :=\n  QuotientGroup.mk'  H \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (N  :  Subgroup  G)  [N.Normal]  {M  :  Type*}\n  [Group  M]  (φ  :  G  →*  M)  (h  :  N  ≤  MonoidHom.ker  φ)  :  G  ⧸  N  →*  M  :=\n  QuotientGroup.lift  N  φ  h \n```", "```py\nexample  {G  :  Type*}  [Group  G]  {M  :  Type*}  [Group  M]  (φ  :  G  →*  M)  :\n  G  ⧸  MonoidHom.ker  φ  →*  MonoidHom.range  φ  :=\n  QuotientGroup.quotientKerEquivRange  φ \n```", "```py\nexample  {G  G':  Type*}  [Group  G]  [Group  G']\n  {N  :  Subgroup  G}  [N.Normal]  {N'  :  Subgroup  G'}  [N'.Normal]\n  {φ  :  G  →*  G'}  (h  :  N  ≤  Subgroup.comap  φ  N')  :  G  ⧸  N  →*  G'  ⧸  N':=\n  QuotientGroup.map  N  N'  φ  h \n```", "```py\nexample  {G  :  Type*}  [Group  G]  {M  N  :  Subgroup  G}  [M.Normal]\n  [N.Normal]  (h  :  M  =  N)  :  G  ⧸  M  ≃*  G  ⧸  N  :=  QuotientGroup.quotientMulEquivOfEq  h \n```", "```py\nsection\nvariable  {G  :  Type*}  [Group  G]  {H  K  :  Subgroup  G}\n\nopen  MonoidHom\n\n#check  Nat.card_pos  -- The nonempty argument will be automatically inferred for subgroups\n#check  Subgroup.index_eq_card\n#check  Subgroup.index_mul_card\n#check  Nat.eq_of_mul_eq_mul_right\n\nlemma  aux_card_eq  [Finite  G]  (h'  :  Nat.card  G  =  Nat.card  H  *  Nat.card  K)  :\n  Nat.card  (G  ⧸  H)  =  Nat.card  K  :=  by\n  sorry \n```", "```py\nvariable  [H.Normal]  [K.Normal]  [Fintype  G]  (h  :  Disjoint  H  K)\n  (h'  :  Nat.card  G  =  Nat.card  H  *  Nat.card  K)\n\n#check  Nat.bijective_iff_injective_and_card\n#check  ker_eq_bot_iff\n#check  restrict\n#check  ker_restrict\n\ndef  iso₁  :  K  ≃*  G  ⧸  H  :=  by\n  sorry \n```", "```py\ndef  iso₂  :  G  ≃*  (G  ⧸  K)  ×  (G  ⧸  H)  :=  by\n  sorry \n```", "```py\n#check  MulEquiv.prodCongr\n\ndef  finalIso  :  G  ≃*  H  ×  K  :=\n  sorry \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (x  y  :  R)  :  (x  +  y)  ^  2  =  x  ^  2  +  y  ^  2  +  2  *  x  *  y  :=  by  ring \n```", "```py\nexample  (x  y  :  ℕ)  :  (x  +  y)  ^  2  =  x  ^  2  +  y  ^  2  +  2  *  x  *  y  :=  by  ring \n```", "```py\nexample  (x  :  ℤˣ)  :  x  =  1  ∨  x  =  -1  :=  Int.units_eq_one_or  x\n\nexample  {M  :  Type*}  [Monoid  M]  (x  :  Mˣ)  :  (x  :  M)  *  x⁻¹  =  1  :=  Units.mul_inv  x\n\nexample  {M  :  Type*}  [Monoid  M]  :  Group  Mˣ  :=  inferInstance \n```", "```py\nexample  {R  S  :  Type*}  [Ring  R]  [Ring  S]  (f  :  R  →+*  S)  (x  y  :  R)  :\n  f  (x  +  y)  =  f  x  +  f  y  :=  f.map_add  x  y\n\nexample  {R  S  :  Type*}  [Ring  R]  [Ring  S]  (f  :  R  →+*  S)  :  Rˣ  →*  Sˣ  :=\n  Units.map  f \n```", "```py\nexample  {R  :  Type*}  [Ring  R]  (S  :  Subring  R)  :  Ring  S  :=  inferInstance \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (I  :  Ideal  R)  :  R  →+*  R  ⧸  I  :=\n  Ideal.Quotient.mk  I\n\nexample  {R  :  Type*}  [CommRing  R]  {a  :  R}  {I  :  Ideal  R}  :\n  Ideal.Quotient.mk  I  a  =  0  ↔  a  ∈  I  :=\n  Ideal.Quotient.eq_zero_iff_mem \n```", "```py\nexample  {R  S  :  Type*}  [CommRing  R]  [CommRing  S]  (I  :  Ideal  R)  (f  :  R  →+*  S)\n  (H  :  I  ≤  RingHom.ker  f)  :  R  ⧸  I  →+*  S  :=\n  Ideal.Quotient.lift  I  f  H \n```", "```py\nexample  {R  S  :  Type*}  [CommRing  R]  [CommRing  S](f  :  R  →+*  S)  :\n  R  ⧸  RingHom.ker  f  ≃+*  f.range  :=\n  RingHom.quotientKerEquivRange  f \n```", "```py\nvariable  {R  :  Type*}  [CommRing  R]  {I  J  :  Ideal  R}\n\nexample  :  I  +  J  =  I  ⊔  J  :=  rfl\n\nexample  {x  :  R}  :  x  ∈  I  +  J  ↔  ∃  a  ∈  I,  ∃  b  ∈  J,  a  +  b  =  x  :=  by\n  simp  [Submodule.mem_sup]\n\nexample  :  I  *  J  ≤  J  :=  Ideal.mul_le_left\n\nexample  :  I  *  J  ≤  I  :=  Ideal.mul_le_right\n\nexample  :  I  *  J  ≤  I  ⊓  J  :=  Ideal.mul_le_inf \n```", "```py\nexample  {R  S  :  Type*}  [CommRing  R]  [CommRing  S]  (I  :  Ideal  R)  (J  :  Ideal  S)  (f  :  R  →+*  S)\n  (H  :  I  ≤  Ideal.comap  f  J)  :  R  ⧸  I  →+*  S  ⧸  J  :=\n  Ideal.quotientMap  J  f  H \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  {I  J  :  Ideal  R}  (h  :  I  =  J)  :  R  ⧸  I  ≃+*  R  ⧸  J  :=\n  Ideal.quotEquivOfEq  h \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  {ι  :  Type*}  [Fintype  ι]  (f  :  ι  →  Ideal  R)\n  (hf  :  ∀  i  j,  i  ≠  j  →  IsCoprime  (f  i)  (f  j))  :  (R  ⧸  ⨅  i,  f  i)  ≃+*  Π  i,  R  ⧸  f  i  :=\n  Ideal.quotientInfRingEquivPiQuotient  f  hf \n```", "```py\nopen  BigOperators  PiNotation\n\nexample  {ι  :  Type*}  [Fintype  ι]  (a  :  ι  →  ℕ)  (coprime  :  ∀  i  j,  i  ≠  j  →  (a  i).Coprime  (a  j))  :\n  ZMod  (∏  i,  a  i)  ≃+*  Π  i,  ZMod  (a  i)  :=\n  ZMod.prodEquivPi  a  coprime \n```", "```py\nvariable  {ι  R  :  Type*}  [CommRing  R]\nopen  Ideal  Quotient  Function\n\n#check  Pi.ringHom\n#check  ker_Pi_Quotient_mk\n\n/-- The homomorphism from ``R ⧸ ⨅ i, I i`` to ``Π i, R ⧸ I i`` featured in the Chinese\n Remainder Theorem. -/\ndef  chineseMap  (I  :  ι  →  Ideal  R)  :  (R  ⧸  ⨅  i,  I  i)  →+*  Π  i,  R  ⧸  I  i  :=\n  sorry \n```", "```py\nlemma  chineseMap_mk  (I  :  ι  →  Ideal  R)  (x  :  R)  :\n  chineseMap  I  (Quotient.mk  _  x)  =  fun  i  :  ι  ↦  Ideal.Quotient.mk  (I  i)  x  :=\n  sorry\n\nlemma  chineseMap_mk'  (I  :  ι  →  Ideal  R)  (x  :  R)  (i  :  ι)  :\n  chineseMap  I  (mk  _  x)  i  =  mk  (I  i)  x  :=\n  sorry \n```", "```py\n#check  injective_lift_iff\n\nlemma  chineseMap_inj  (I  :  ι  →  Ideal  R)  :  Injective  (chineseMap  I)  :=  by\n  sorry \n```", "```py\n#check  IsCoprime\n#check  isCoprime_iff_add\n#check  isCoprime_iff_exists\n#check  isCoprime_iff_sup_eq\n#check  isCoprime_iff_codisjoint \n```", "```py\n#check  Finset.mem_insert_of_mem\n#check  Finset.mem_insert_self\n\ntheorem  isCoprime_Inf  {I  :  Ideal  R}  {J  :  ι  →  Ideal  R}  {s  :  Finset  ι}\n  (hf  :  ∀  j  ∈  s,  IsCoprime  I  (J  j))  :  IsCoprime  I  (⨅  j  ∈  s,  J  j)  :=  by\n  classical\n  simp_rw  [isCoprime_iff_add]  at  *\n  induction  s  using  Finset.induction  with\n  |  empty  =>\n  simp\n  |  @insert  i  s  _  hs  =>\n  rw  [Finset.iInf_insert,  inf_comm,  one_eq_top,  eq_top_iff,  ←  one_eq_top]\n  set  K  :=  ⨅  j  ∈  s,  J  j\n  calc\n  1  =  I  +  K  :=  sorry\n  _  =  I  +  K  *  (I  +  J  i)  :=  sorry\n  _  =  (1  +  K)  *  I  +  K  *  J  i  :=  sorry\n  _  ≤  I  +  K  ⊓  J  i  :=  sorry \n```", "```py\nlemma  chineseMap_surj  [Fintype  ι]  {I  :  ι  →  Ideal  R}\n  (hI  :  ∀  i  j,  i  ≠  j  →  IsCoprime  (I  i)  (I  j))  :  Surjective  (chineseMap  I)  :=  by\n  classical\n  intro  g\n  choose  f  hf  using  fun  i  ↦  Ideal.Quotient.mk_surjective  (g  i)\n  have  key  :  ∀  i,  ∃  e  :  R,  mk  (I  i)  e  =  1  ∧  ∀  j,  j  ≠  i  →  mk  (I  j)  e  =  0  :=  by\n  intro  i\n  have  hI'  :  ∀  j  ∈  ({i}  :  Finset  ι)ᶜ,  IsCoprime  (I  i)  (I  j)  :=  by\n  sorry\n  sorry\n  choose  e  he  using  key\n  use  mk  _  (∑  i,  f  i  *  e  i)\n  sorry \n```", "```py\nnoncomputable  def  chineseIso  [Fintype  ι]  (f  :  ι  →  Ideal  R)\n  (hf  :  ∀  i  j,  i  ≠  j  →  IsCoprime  (f  i)  (f  j))  :  (R  ⧸  ⨅  i,  f  i)  ≃+*  Π  i,  R  ⧸  f  i  :=\n  {  Equiv.ofBijective  _  ⟨chineseMap_inj  f,  chineseMap_surj  hf⟩,\n  chineseMap  f  with  } \n```", "```py\nexample  {R  A  :  Type*}  [CommRing  R]  [Ring  A]  [Algebra  R  A]  (r  r'  :  R)  (a  :  A)  :\n  (r  +  r')  •  a  =  r  •  a  +  r'  •  a  :=\n  add_smul  r  r'  a\n\nexample  {R  A  :  Type*}  [CommRing  R]  [Ring  A]  [Algebra  R  A]  (r  r'  :  R)  (a  :  A)  :\n  (r  *  r')  •  a  =  r  •  r'  •  a  :=\n  mul_smul  r  r'  a \n```", "```py\nopen  Polynomial\n\nexample  {R  :  Type*}  [CommRing  R]  :  R[X]  :=  X\n\nexample  {R  :  Type*}  [CommRing  R]  (r  :  R)  :=  X  -  C  r \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (r  :  R)  :  (X  +  C  r)  *  (X  -  C  r)  =  X  ^  2  -  C  (r  ^  2)  :=  by\n  rw  [C.map_pow]\n  ring \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (r:R)  :  (C  r).coeff  0  =  r  :=  by  simp\n\nexample  {R  :  Type*}  [CommRing  R]  :  (X  ^  2  +  2  *  X  +  C  3  :  R[X]).coeff  1  =  2  :=  by  simp \n```", "```py\nexample  {R  :  Type*}  [Semiring  R]  [NoZeroDivisors  R]  {p  q  :  R[X]}  :\n  degree  (p  *  q)  =  degree  p  +  degree  q  :=\n  Polynomial.degree_mul \n```", "```py\nexample  {R  :  Type*}  [Semiring  R]  [NoZeroDivisors  R]  {p  q  :  R[X]}  (hp  :  p  ≠  0)  (hq  :  q  ≠  0)  :\n  natDegree  (p  *  q)  =  natDegree  p  +  natDegree  q  :=\n  Polynomial.natDegree_mul  hp  hq \n```", "```py\nexample  {R  :  Type*}  [Semiring  R]  [NoZeroDivisors  R]  {p  q  :  R[X]}  :\n  natDegree  (comp  p  q)  =  natDegree  p  *  natDegree  q  :=\n  Polynomial.natDegree_comp \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (P:  R[X])  (x  :  R)  :=  P.eval  x\n\nexample  {R  :  Type*}  [CommRing  R]  (r  :  R)  :  (X  -  C  r).eval  r  =  0  :=  by  simp \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (P  :  R[X])  (r  :  R)  :  IsRoot  P  r  ↔  P.eval  r  =  0  :=  Iff.rfl \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  [IsDomain  R]  (r  :  R)  :  (X  -  C  r).roots  =  {r}  :=\n  roots_X_sub_C  r\n\nexample  {R  :  Type*}  [CommRing  R]  [IsDomain  R]  (r  :  R)  (n  :  ℕ):\n  ((X  -  C  r)  ^  n).roots  =  n  •  {r}  :=\n  by  simp \n```", "```py\nexample  :  aeval  Complex.I  (X  ^  2  +  1  :  ℝ[X])  =  0  :=  by  simp \n```", "```py\nopen  Complex  Polynomial\n\nexample  :  aroots  (X  ^  2  +  1  :  ℝ[X])  ℂ  =  {Complex.I,  -I}  :=  by\n  suffices  roots  (X  ^  2  +  1  :  ℂ[X])  =  {I,  -I}  by  simpa  [aroots_def]\n  have  factored  :  (X  ^  2  +  1  :  ℂ[X])  =  (X  -  C  I)  *  (X  -  C  (-I))  :=  by\n  have  key  :  (C  I  *  C  I  :  ℂ[X])  =  -1  :=  by  simp  [←  C_mul]\n  rw  [C_neg]\n  linear_combination  key\n  have  p_ne_zero  :  (X  -  C  I)  *  (X  -  C  (-I))  ≠  0  :=  by\n  intro  H\n  apply_fun  eval  0  at  H\n  simp  [eval]  at  H\n  simp  only  [factored,  roots_mul  p_ne_zero,  roots_X_sub_C]\n  rfl\n\n-- Mathlib knows about D'Alembert-Gauss theorem: ``ℂ`` is algebraically closed.\nexample  :  IsAlgClosed  ℂ  :=  inferInstance \n```", "```py\n#check  (Complex.ofRealHom  :  ℝ  →+*  ℂ)\n\nexample  :  (X  ^  2  +  1  :  ℝ[X]).eval₂  Complex.ofRealHom  Complex.I  =  0  :=  by  simp \n```", "```py\nopen  MvPolynomial\n\ndef  circleEquation  :  MvPolynomial  (Fin  2)  ℝ  :=  X  0  ^  2  +  X  1  ^  2  -  1 \n```", "```py\nexample  :  MvPolynomial.eval  ![1,  0]  circleEquation  =  0  :=  by  simp  [circleEquation] \n```", "```py\nexample  {M  :  Type*}  [Monoid  M]  (x  :  M)  :  x  *  1  =  x  :=  mul_one  x\n\nexample  {M  :  Type*}  [AddCommMonoid  M]  (x  y  :  M)  :  x  +  y  =  y  +  x  :=  add_comm  x  y \n```", "```py\nexample  {M  N  :  Type*}  [Monoid  M]  [Monoid  N]  (x  y  :  M)  (f  :  M  →*  N)  :  f  (x  *  y)  =  f  x  *  f  y  :=\n  f.map_mul  x  y\n\nexample  {M  N  :  Type*}  [AddMonoid  M]  [AddMonoid  N]  (f  :  M  →+  N)  :  f  0  =  0  :=\n  f.map_zero \n```", "```py\nexample  {M  N  P  :  Type*}  [AddMonoid  M]  [AddMonoid  N]  [AddMonoid  P]\n  (f  :  M  →+  N)  (g  :  N  →+  P)  :  M  →+  P  :=  g.comp  f \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (x  :  G)  :  x  *  x⁻¹  =  1  :=  mul_inv_cancel  x \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (x  y  z  :  G)  :  x  *  (y  *  z)  *  (x  *  z)⁻¹  *  (x  *  y  *  x⁻¹)⁻¹  =  1  :=  by\n  group \n```", "```py\nexample  {G  :  Type*}  [AddCommGroup  G]  (x  y  z  :  G)  :  z  +  x  +  (y  -  z  -  x)  =  y  :=  by\n  abel \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (x  y  :  G)  (f  :  G  →*  H)  :  f  (x  *  y)  =  f  x  *  f  y  :=\n  f.map_mul  x  y \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (x  :  G)  (f  :  G  →*  H)  :  f  (x⁻¹)  =  (f  x)⁻¹  :=\n  f.map_inv  x \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (f  :  G  →  H)  (h  :  ∀  x  y,  f  (x  *  y)  =  f  x  *  f  y)  :\n  G  →*  H  :=\n  MonoidHom.mk'  f  h \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (f  :  G  ≃*  H)  :\n  f.trans  f.symm  =  MulEquiv.refl  G  :=\n  f.self_trans_symm \n```", "```py\nnoncomputable  example  {G  H  :  Type*}  [Group  G]  [Group  H]\n  (f  :  G  →*  H)  (h  :  Function.Bijective  f)  :\n  G  ≃*  H  :=\n  MulEquiv.ofBijective  f  h \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  {x  y  :  G}  (hx  :  x  ∈  H)  (hy  :  y  ∈  H)  :\n  x  *  y  ∈  H  :=\n  H.mul_mem  hx  hy\n\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  {x  :  G}  (hx  :  x  ∈  H)  :\n  x⁻¹  ∈  H  :=\n  H.inv_mem  hx \n```", "```py\nexample  :  AddSubgroup  ℚ  where\n  carrier  :=  Set.range  ((↑)  :  ℤ  →  ℚ)\n  add_mem'  :=  by\n  rintro  _  _  ⟨n,  rfl⟩  ⟨m,  rfl⟩\n  use  n  +  m\n  simp\n  zero_mem'  :=  by\n  use  0\n  simp\n  neg_mem'  :=  by\n  rintro  _  ⟨n,  rfl⟩\n  use  -n\n  simp \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  :  Group  H  :=  inferInstance \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  :  Group  {x  :  G  //  x  ∈  H}  :=  inferInstance \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  H'  :  Subgroup  G)  :\n  ((H  ⊓  H'  :  Subgroup  G)  :  Set  G)  =  (H  :  Set  G)  ∩  (H'  :  Set  G)  :=  rfl \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  H'  :  Subgroup  G)  :\n  ((H  ⊔  H'  :  Subgroup  G)  :  Set  G)  =  Subgroup.closure  ((H  :  Set  G)  ∪  (H'  :  Set  G))  :=  by\n  rw  [Subgroup.sup_eq_closure] \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (x  :  G)  :  x  ∈  (⊤  :  Subgroup  G)  :=  trivial \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (x  :  G)  :  x  ∈  (⊥  :  Subgroup  G)  ↔  x  =  1  :=  Subgroup.mem_bot \n```", "```py\ndef  conjugate  {G  :  Type*}  [Group  G]  (x  :  G)  (H  :  Subgroup  G)  :  Subgroup  G  where\n  carrier  :=  {a  :  G  |  ∃  h,  h  ∈  H  ∧  a  =  x  *  h  *  x⁻¹}\n  one_mem'  :=  by\n  dsimp\n  sorry\n  inv_mem'  :=  by\n  dsimp\n  sorry\n  mul_mem'  :=  by\n  dsimp\n  sorry \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (G'  :  Subgroup  G)  (f  :  G  →*  H)  :  Subgroup  H  :=\n  Subgroup.map  f  G'\n\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (H'  :  Subgroup  H)  (f  :  G  →*  H)  :  Subgroup  G  :=\n  Subgroup.comap  f  H'\n\n#check  Subgroup.mem_map\n#check  Subgroup.mem_comap \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (f  :  G  →*  H)  (g  :  G)  :\n  g  ∈  MonoidHom.ker  f  ↔  f  g  =  1  :=\n  f.mem_ker\n\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (f  :  G  →*  H)  (h  :  H)  :\n  h  ∈  MonoidHom.range  f  ↔  ∃  g  :  G,  f  g  =  h  :=\n  f.mem_range \n```", "```py\nsection  exercises\nvariable  {G  H  :  Type*}  [Group  G]  [Group  H]\n\nopen  Subgroup\n\nexample  (φ  :  G  →*  H)  (S  T  :  Subgroup  H)  (hST  :  S  ≤  T)  :  comap  φ  S  ≤  comap  φ  T  :=  by\n  sorry\n\nexample  (φ  :  G  →*  H)  (S  T  :  Subgroup  G)  (hST  :  S  ≤  T)  :  map  φ  S  ≤  map  φ  T  :=  by\n  sorry\n\nvariable  {K  :  Type*}  [Group  K]\n\n-- Remember you can use the `ext` tactic to prove an equality of subgroups.\nexample  (φ  :  G  →*  H)  (ψ  :  H  →*  K)  (U  :  Subgroup  K)  :\n  comap  (ψ.comp  φ)  U  =  comap  φ  (comap  ψ  U)  :=  by\n  sorry\n\n-- Pushing a subgroup along one homomorphism and then another is equal to\n-- pushing it forward along the composite of the homomorphisms.\nexample  (φ  :  G  →*  H)  (ψ  :  H  →*  K)  (S  :  Subgroup  G)  :\n  map  (ψ.comp  φ)  S  =  map  ψ  (S.map  φ)  :=  by\n  sorry\n\nend  exercises \n```", "```py\nopen  scoped  Classical\n\nexample  {G  :  Type*}  [Group  G]  (G'  :  Subgroup  G)  :  Nat.card  G'  ∣  Nat.card  G  :=\n  ⟨G'.index,  mul_comm  G'.index  _  ▸  G'.index_mul_card.symm⟩\n\nopen  Subgroup\n\nexample  {G  :  Type*}  [Group  G]  [Finite  G]  (p  :  ℕ)  {n  :  ℕ}  [Fact  p.Prime]\n  (hdvd  :  p  ^  n  ∣  Nat.card  G)  :  ∃  K  :  Subgroup  G,  Nat.card  K  =  p  ^  n  :=\n  Sylow.exists_subgroup_card_pow_prime  p  hdvd \n```", "```py\nlemma  eq_bot_iff_card  {G  :  Type*}  [Group  G]  {H  :  Subgroup  G}  :\n  H  =  ⊥  ↔  Nat.card  H  =  1  :=  by\n  suffices  (∀  x  ∈  H,  x  =  1)  ↔  ∃  x  ∈  H,  ∀  a  ∈  H,  a  =  x  by\n  simpa  [eq_bot_iff_forall,  Nat.card_eq_one_iff_exists]\n  sorry\n\n#check  card_dvd_of_le\n\nlemma  inf_bot_of_coprime  {G  :  Type*}  [Group  G]  (H  K  :  Subgroup  G)\n  (h  :  (Nat.card  H).Coprime  (Nat.card  K))  :  H  ⊓  K  =  ⊥  :=  by\n  sorry \n```", "```py\nopen  Equiv\n\nexample  {X  :  Type*}  [Finite  X]  :  Subgroup.closure  {σ  :  Perm  X  |  Perm.IsCycle  σ}  =  ⊤  :=\n  Perm.closure_isCycle \n```", "```py\n#simp  [mul_assoc]  c[1,  2,  3]  *  c[2,  3,  4] \n```", "```py\nsection  FreeGroup\n\ninductive  S  |  a  |  b  |  c\n\nopen  S\n\ndef  myElement  :  FreeGroup  S  :=  (.of  a)  *  (.of  b)⁻¹ \n```", "```py\ndef  myMorphism  :  FreeGroup  S  →*  Perm  (Fin  5)  :=\n  FreeGroup.lift  fun  |  .a  =>  c[1,  2,  3]\n  |  .b  =>  c[2,  3,  1]\n  |  .c  =>  c[2,  3] \n```", "```py\ndef  myGroup  :=  PresentedGroup  {.of  ()  ^  3}  deriving  Group \n```", "```py\ndef  myMap  :  Unit  →  Perm  (Fin  5)\n|  ()  =>  c[1,  2,  3]\n\nlemma  compat_myMap  :\n  ∀  r  ∈  ({.of  ()  ^  3}  :  Set  (FreeGroup  Unit)),  FreeGroup.lift  myMap  r  =  1  :=  by\n  rintro  _  rfl\n  simp\n  decide\n\ndef  myNewMorphism  :  myGroup  →*  Perm  (Fin  5)  :=  PresentedGroup.toGroup  compat_myMap\n\nend  FreeGroup \n```", "```py\nnoncomputable  section  GroupActions\n\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  (g  g':  G)  (x  :  X)  :\n  g  •  (g'  •  x)  =  (g  *  g')  •  x  :=\n  (mul_smul  g  g'  x).symm \n```", "```py\nexample  {G  X  :  Type*}  [AddGroup  G]  [AddAction  G  X]  (g  g'  :  G)  (x  :  X)  :\n  g  +ᵥ  (g'  +ᵥ  x)  =  (g  +  g')  +ᵥ  x  :=\n  (add_vadd  g  g'  x).symm \n```", "```py\nopen  MulAction\n\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  :  G  →*  Equiv.Perm  X  :=\n  toPermHom  G  X \n```", "```py\ndef  CayleyIsoMorphism  (G  :  Type*)  [Group  G]  :  G  ≃*  (toPermHom  G  G).range  :=\n  Equiv.Perm.subgroupOfMulAction  G  G \n```", "```py\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  :  Setoid  X  :=  orbitRel  G  X \n```", "```py\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  :\n  X  ≃  (ω  :  orbitRel.Quotient  G  X)  ×  (orbit  G  (Quotient.out  ω))  :=\n  MulAction.selfEquivSigmaOrbits  G  X \n```", "```py\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  (x  :  X)  :\n  orbit  G  x  ≃  G  ⧸  stabilizer  G  x  :=\n  MulAction.orbitEquivQuotientStabilizer  G  x \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  :  G  ≃  (G  ⧸  H)  ×  H  :=\n  groupEquivQuotientProdSubgroup \n```", "```py\nvariable  {G  :  Type*}  [Group  G]\n\nlemma  conjugate_one  (H  :  Subgroup  G)  :  conjugate  1  H  =  H  :=  by\n  sorry\n\ninstance  :  MulAction  G  (Subgroup  G)  where\n  smul  :=  conjugate\n  one_smul  :=  by\n  sorry\n  mul_smul  :=  by\n  sorry\n\nend  GroupActions \n```", "```py\nnoncomputable  section  QuotientGroup\n\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  [H.Normal]  :  Group  (G  ⧸  H)  :=  inferInstance\n\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  [H.Normal]  :  G  →*  G  ⧸  H  :=\n  QuotientGroup.mk'  H \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (N  :  Subgroup  G)  [N.Normal]  {M  :  Type*}\n  [Group  M]  (φ  :  G  →*  M)  (h  :  N  ≤  MonoidHom.ker  φ)  :  G  ⧸  N  →*  M  :=\n  QuotientGroup.lift  N  φ  h \n```", "```py\nexample  {G  :  Type*}  [Group  G]  {M  :  Type*}  [Group  M]  (φ  :  G  →*  M)  :\n  G  ⧸  MonoidHom.ker  φ  →*  MonoidHom.range  φ  :=\n  QuotientGroup.quotientKerEquivRange  φ \n```", "```py\nexample  {G  G':  Type*}  [Group  G]  [Group  G']\n  {N  :  Subgroup  G}  [N.Normal]  {N'  :  Subgroup  G'}  [N'.Normal]\n  {φ  :  G  →*  G'}  (h  :  N  ≤  Subgroup.comap  φ  N')  :  G  ⧸  N  →*  G'  ⧸  N':=\n  QuotientGroup.map  N  N'  φ  h \n```", "```py\nexample  {G  :  Type*}  [Group  G]  {M  N  :  Subgroup  G}  [M.Normal]\n  [N.Normal]  (h  :  M  =  N)  :  G  ⧸  M  ≃*  G  ⧸  N  :=  QuotientGroup.quotientMulEquivOfEq  h \n```", "```py\nsection\nvariable  {G  :  Type*}  [Group  G]  {H  K  :  Subgroup  G}\n\nopen  MonoidHom\n\n#check  Nat.card_pos  -- The nonempty argument will be automatically inferred for subgroups\n#check  Subgroup.index_eq_card\n#check  Subgroup.index_mul_card\n#check  Nat.eq_of_mul_eq_mul_right\n\nlemma  aux_card_eq  [Finite  G]  (h'  :  Nat.card  G  =  Nat.card  H  *  Nat.card  K)  :\n  Nat.card  (G  ⧸  H)  =  Nat.card  K  :=  by\n  sorry \n```", "```py\nvariable  [H.Normal]  [K.Normal]  [Fintype  G]  (h  :  Disjoint  H  K)\n  (h'  :  Nat.card  G  =  Nat.card  H  *  Nat.card  K)\n\n#check  Nat.bijective_iff_injective_and_card\n#check  ker_eq_bot_iff\n#check  restrict\n#check  ker_restrict\n\ndef  iso₁  :  K  ≃*  G  ⧸  H  :=  by\n  sorry \n```", "```py\ndef  iso₂  :  G  ≃*  (G  ⧸  K)  ×  (G  ⧸  H)  :=  by\n  sorry \n```", "```py\n#check  MulEquiv.prodCongr\n\ndef  finalIso  :  G  ≃*  H  ×  K  :=\n  sorry \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (x  y  :  R)  :  (x  +  y)  ^  2  =  x  ^  2  +  y  ^  2  +  2  *  x  *  y  :=  by  ring \n```", "```py\nexample  (x  y  :  ℕ)  :  (x  +  y)  ^  2  =  x  ^  2  +  y  ^  2  +  2  *  x  *  y  :=  by  ring \n```", "```py\nexample  (x  :  ℤˣ)  :  x  =  1  ∨  x  =  -1  :=  Int.units_eq_one_or  x\n\nexample  {M  :  Type*}  [Monoid  M]  (x  :  Mˣ)  :  (x  :  M)  *  x⁻¹  =  1  :=  Units.mul_inv  x\n\nexample  {M  :  Type*}  [Monoid  M]  :  Group  Mˣ  :=  inferInstance \n```", "```py\nexample  {R  S  :  Type*}  [Ring  R]  [Ring  S]  (f  :  R  →+*  S)  (x  y  :  R)  :\n  f  (x  +  y)  =  f  x  +  f  y  :=  f.map_add  x  y\n\nexample  {R  S  :  Type*}  [Ring  R]  [Ring  S]  (f  :  R  →+*  S)  :  Rˣ  →*  Sˣ  :=\n  Units.map  f \n```", "```py\nexample  {R  :  Type*}  [Ring  R]  (S  :  Subring  R)  :  Ring  S  :=  inferInstance \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (I  :  Ideal  R)  :  R  →+*  R  ⧸  I  :=\n  Ideal.Quotient.mk  I\n\nexample  {R  :  Type*}  [CommRing  R]  {a  :  R}  {I  :  Ideal  R}  :\n  Ideal.Quotient.mk  I  a  =  0  ↔  a  ∈  I  :=\n  Ideal.Quotient.eq_zero_iff_mem \n```", "```py\nexample  {R  S  :  Type*}  [CommRing  R]  [CommRing  S]  (I  :  Ideal  R)  (f  :  R  →+*  S)\n  (H  :  I  ≤  RingHom.ker  f)  :  R  ⧸  I  →+*  S  :=\n  Ideal.Quotient.lift  I  f  H \n```", "```py\nexample  {R  S  :  Type*}  [CommRing  R]  [CommRing  S](f  :  R  →+*  S)  :\n  R  ⧸  RingHom.ker  f  ≃+*  f.range  :=\n  RingHom.quotientKerEquivRange  f \n```", "```py\nvariable  {R  :  Type*}  [CommRing  R]  {I  J  :  Ideal  R}\n\nexample  :  I  +  J  =  I  ⊔  J  :=  rfl\n\nexample  {x  :  R}  :  x  ∈  I  +  J  ↔  ∃  a  ∈  I,  ∃  b  ∈  J,  a  +  b  =  x  :=  by\n  simp  [Submodule.mem_sup]\n\nexample  :  I  *  J  ≤  J  :=  Ideal.mul_le_left\n\nexample  :  I  *  J  ≤  I  :=  Ideal.mul_le_right\n\nexample  :  I  *  J  ≤  I  ⊓  J  :=  Ideal.mul_le_inf \n```", "```py\nexample  {R  S  :  Type*}  [CommRing  R]  [CommRing  S]  (I  :  Ideal  R)  (J  :  Ideal  S)  (f  :  R  →+*  S)\n  (H  :  I  ≤  Ideal.comap  f  J)  :  R  ⧸  I  →+*  S  ⧸  J  :=\n  Ideal.quotientMap  J  f  H \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  {I  J  :  Ideal  R}  (h  :  I  =  J)  :  R  ⧸  I  ≃+*  R  ⧸  J  :=\n  Ideal.quotEquivOfEq  h \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  {ι  :  Type*}  [Fintype  ι]  (f  :  ι  →  Ideal  R)\n  (hf  :  ∀  i  j,  i  ≠  j  →  IsCoprime  (f  i)  (f  j))  :  (R  ⧸  ⨅  i,  f  i)  ≃+*  Π  i,  R  ⧸  f  i  :=\n  Ideal.quotientInfRingEquivPiQuotient  f  hf \n```", "```py\nopen  BigOperators  PiNotation\n\nexample  {ι  :  Type*}  [Fintype  ι]  (a  :  ι  →  ℕ)  (coprime  :  ∀  i  j,  i  ≠  j  →  (a  i).Coprime  (a  j))  :\n  ZMod  (∏  i,  a  i)  ≃+*  Π  i,  ZMod  (a  i)  :=\n  ZMod.prodEquivPi  a  coprime \n```", "```py\nvariable  {ι  R  :  Type*}  [CommRing  R]\nopen  Ideal  Quotient  Function\n\n#check  Pi.ringHom\n#check  ker_Pi_Quotient_mk\n\n/-- The homomorphism from ``R ⧸ ⨅ i, I i`` to ``Π i, R ⧸ I i`` featured in the Chinese\n Remainder Theorem. -/\ndef  chineseMap  (I  :  ι  →  Ideal  R)  :  (R  ⧸  ⨅  i,  I  i)  →+*  Π  i,  R  ⧸  I  i  :=\n  sorry \n```", "```py\nlemma  chineseMap_mk  (I  :  ι  →  Ideal  R)  (x  :  R)  :\n  chineseMap  I  (Quotient.mk  _  x)  =  fun  i  :  ι  ↦  Ideal.Quotient.mk  (I  i)  x  :=\n  sorry\n\nlemma  chineseMap_mk'  (I  :  ι  →  Ideal  R)  (x  :  R)  (i  :  ι)  :\n  chineseMap  I  (mk  _  x)  i  =  mk  (I  i)  x  :=\n  sorry \n```", "```py\n#check  injective_lift_iff\n\nlemma  chineseMap_inj  (I  :  ι  →  Ideal  R)  :  Injective  (chineseMap  I)  :=  by\n  sorry \n```", "```py\n#check  IsCoprime\n#check  isCoprime_iff_add\n#check  isCoprime_iff_exists\n#check  isCoprime_iff_sup_eq\n#check  isCoprime_iff_codisjoint \n```", "```py\n#check  Finset.mem_insert_of_mem\n#check  Finset.mem_insert_self\n\ntheorem  isCoprime_Inf  {I  :  Ideal  R}  {J  :  ι  →  Ideal  R}  {s  :  Finset  ι}\n  (hf  :  ∀  j  ∈  s,  IsCoprime  I  (J  j))  :  IsCoprime  I  (⨅  j  ∈  s,  J  j)  :=  by\n  classical\n  simp_rw  [isCoprime_iff_add]  at  *\n  induction  s  using  Finset.induction  with\n  |  empty  =>\n  simp\n  |  @insert  i  s  _  hs  =>\n  rw  [Finset.iInf_insert,  inf_comm,  one_eq_top,  eq_top_iff,  ←  one_eq_top]\n  set  K  :=  ⨅  j  ∈  s,  J  j\n  calc\n  1  =  I  +  K  :=  sorry\n  _  =  I  +  K  *  (I  +  J  i)  :=  sorry\n  _  =  (1  +  K)  *  I  +  K  *  J  i  :=  sorry\n  _  ≤  I  +  K  ⊓  J  i  :=  sorry \n```", "```py\nlemma  chineseMap_surj  [Fintype  ι]  {I  :  ι  →  Ideal  R}\n  (hI  :  ∀  i  j,  i  ≠  j  →  IsCoprime  (I  i)  (I  j))  :  Surjective  (chineseMap  I)  :=  by\n  classical\n  intro  g\n  choose  f  hf  using  fun  i  ↦  Ideal.Quotient.mk_surjective  (g  i)\n  have  key  :  ∀  i,  ∃  e  :  R,  mk  (I  i)  e  =  1  ∧  ∀  j,  j  ≠  i  →  mk  (I  j)  e  =  0  :=  by\n  intro  i\n  have  hI'  :  ∀  j  ∈  ({i}  :  Finset  ι)ᶜ,  IsCoprime  (I  i)  (I  j)  :=  by\n  sorry\n  sorry\n  choose  e  he  using  key\n  use  mk  _  (∑  i,  f  i  *  e  i)\n  sorry \n```", "```py\nnoncomputable  def  chineseIso  [Fintype  ι]  (f  :  ι  →  Ideal  R)\n  (hf  :  ∀  i  j,  i  ≠  j  →  IsCoprime  (f  i)  (f  j))  :  (R  ⧸  ⨅  i,  f  i)  ≃+*  Π  i,  R  ⧸  f  i  :=\n  {  Equiv.ofBijective  _  ⟨chineseMap_inj  f,  chineseMap_surj  hf⟩,\n  chineseMap  f  with  } \n```", "```py\nexample  {R  A  :  Type*}  [CommRing  R]  [Ring  A]  [Algebra  R  A]  (r  r'  :  R)  (a  :  A)  :\n  (r  +  r')  •  a  =  r  •  a  +  r'  •  a  :=\n  add_smul  r  r'  a\n\nexample  {R  A  :  Type*}  [CommRing  R]  [Ring  A]  [Algebra  R  A]  (r  r'  :  R)  (a  :  A)  :\n  (r  *  r')  •  a  =  r  •  r'  •  a  :=\n  mul_smul  r  r'  a \n```", "```py\nopen  Polynomial\n\nexample  {R  :  Type*}  [CommRing  R]  :  R[X]  :=  X\n\nexample  {R  :  Type*}  [CommRing  R]  (r  :  R)  :=  X  -  C  r \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (r  :  R)  :  (X  +  C  r)  *  (X  -  C  r)  =  X  ^  2  -  C  (r  ^  2)  :=  by\n  rw  [C.map_pow]\n  ring \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (r:R)  :  (C  r).coeff  0  =  r  :=  by  simp\n\nexample  {R  :  Type*}  [CommRing  R]  :  (X  ^  2  +  2  *  X  +  C  3  :  R[X]).coeff  1  =  2  :=  by  simp \n```", "```py\nexample  {R  :  Type*}  [Semiring  R]  [NoZeroDivisors  R]  {p  q  :  R[X]}  :\n  degree  (p  *  q)  =  degree  p  +  degree  q  :=\n  Polynomial.degree_mul \n```", "```py\nexample  {R  :  Type*}  [Semiring  R]  [NoZeroDivisors  R]  {p  q  :  R[X]}  (hp  :  p  ≠  0)  (hq  :  q  ≠  0)  :\n  natDegree  (p  *  q)  =  natDegree  p  +  natDegree  q  :=\n  Polynomial.natDegree_mul  hp  hq \n```", "```py\nexample  {R  :  Type*}  [Semiring  R]  [NoZeroDivisors  R]  {p  q  :  R[X]}  :\n  natDegree  (comp  p  q)  =  natDegree  p  *  natDegree  q  :=\n  Polynomial.natDegree_comp \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (P:  R[X])  (x  :  R)  :=  P.eval  x\n\nexample  {R  :  Type*}  [CommRing  R]  (r  :  R)  :  (X  -  C  r).eval  r  =  0  :=  by  simp \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (P  :  R[X])  (r  :  R)  :  IsRoot  P  r  ↔  P.eval  r  =  0  :=  Iff.rfl \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  [IsDomain  R]  (r  :  R)  :  (X  -  C  r).roots  =  {r}  :=\n  roots_X_sub_C  r\n\nexample  {R  :  Type*}  [CommRing  R]  [IsDomain  R]  (r  :  R)  (n  :  ℕ):\n  ((X  -  C  r)  ^  n).roots  =  n  •  {r}  :=\n  by  simp \n```", "```py\nexample  :  aeval  Complex.I  (X  ^  2  +  1  :  ℝ[X])  =  0  :=  by  simp \n```", "```py\nopen  Complex  Polynomial\n\nexample  :  aroots  (X  ^  2  +  1  :  ℝ[X])  ℂ  =  {Complex.I,  -I}  :=  by\n  suffices  roots  (X  ^  2  +  1  :  ℂ[X])  =  {I,  -I}  by  simpa  [aroots_def]\n  have  factored  :  (X  ^  2  +  1  :  ℂ[X])  =  (X  -  C  I)  *  (X  -  C  (-I))  :=  by\n  have  key  :  (C  I  *  C  I  :  ℂ[X])  =  -1  :=  by  simp  [←  C_mul]\n  rw  [C_neg]\n  linear_combination  key\n  have  p_ne_zero  :  (X  -  C  I)  *  (X  -  C  (-I))  ≠  0  :=  by\n  intro  H\n  apply_fun  eval  0  at  H\n  simp  [eval]  at  H\n  simp  only  [factored,  roots_mul  p_ne_zero,  roots_X_sub_C]\n  rfl\n\n-- Mathlib knows about D'Alembert-Gauss theorem: ``ℂ`` is algebraically closed.\nexample  :  IsAlgClosed  ℂ  :=  inferInstance \n```", "```py\n#check  (Complex.ofRealHom  :  ℝ  →+*  ℂ)\n\nexample  :  (X  ^  2  +  1  :  ℝ[X]).eval₂  Complex.ofRealHom  Complex.I  =  0  :=  by  simp \n```", "```py\nopen  MvPolynomial\n\ndef  circleEquation  :  MvPolynomial  (Fin  2)  ℝ  :=  X  0  ^  2  +  X  1  ^  2  -  1 \n```", "```py\nexample  :  MvPolynomial.eval  ![1,  0]  circleEquation  =  0  :=  by  simp  [circleEquation] \n```", "```py\nexample  {M  :  Type*}  [Monoid  M]  (x  :  M)  :  x  *  1  =  x  :=  mul_one  x\n\nexample  {M  :  Type*}  [AddCommMonoid  M]  (x  y  :  M)  :  x  +  y  =  y  +  x  :=  add_comm  x  y \n```", "```py\nexample  {M  N  :  Type*}  [Monoid  M]  [Monoid  N]  (x  y  :  M)  (f  :  M  →*  N)  :  f  (x  *  y)  =  f  x  *  f  y  :=\n  f.map_mul  x  y\n\nexample  {M  N  :  Type*}  [AddMonoid  M]  [AddMonoid  N]  (f  :  M  →+  N)  :  f  0  =  0  :=\n  f.map_zero \n```", "```py\nexample  {M  N  P  :  Type*}  [AddMonoid  M]  [AddMonoid  N]  [AddMonoid  P]\n  (f  :  M  →+  N)  (g  :  N  →+  P)  :  M  →+  P  :=  g.comp  f \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (x  :  G)  :  x  *  x⁻¹  =  1  :=  mul_inv_cancel  x \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (x  y  z  :  G)  :  x  *  (y  *  z)  *  (x  *  z)⁻¹  *  (x  *  y  *  x⁻¹)⁻¹  =  1  :=  by\n  group \n```", "```py\nexample  {G  :  Type*}  [AddCommGroup  G]  (x  y  z  :  G)  :  z  +  x  +  (y  -  z  -  x)  =  y  :=  by\n  abel \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (x  y  :  G)  (f  :  G  →*  H)  :  f  (x  *  y)  =  f  x  *  f  y  :=\n  f.map_mul  x  y \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (x  :  G)  (f  :  G  →*  H)  :  f  (x⁻¹)  =  (f  x)⁻¹  :=\n  f.map_inv  x \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (f  :  G  →  H)  (h  :  ∀  x  y,  f  (x  *  y)  =  f  x  *  f  y)  :\n  G  →*  H  :=\n  MonoidHom.mk'  f  h \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (f  :  G  ≃*  H)  :\n  f.trans  f.symm  =  MulEquiv.refl  G  :=\n  f.self_trans_symm \n```", "```py\nnoncomputable  example  {G  H  :  Type*}  [Group  G]  [Group  H]\n  (f  :  G  →*  H)  (h  :  Function.Bijective  f)  :\n  G  ≃*  H  :=\n  MulEquiv.ofBijective  f  h \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  {x  y  :  G}  (hx  :  x  ∈  H)  (hy  :  y  ∈  H)  :\n  x  *  y  ∈  H  :=\n  H.mul_mem  hx  hy\n\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  {x  :  G}  (hx  :  x  ∈  H)  :\n  x⁻¹  ∈  H  :=\n  H.inv_mem  hx \n```", "```py\nexample  :  AddSubgroup  ℚ  where\n  carrier  :=  Set.range  ((↑)  :  ℤ  →  ℚ)\n  add_mem'  :=  by\n  rintro  _  _  ⟨n,  rfl⟩  ⟨m,  rfl⟩\n  use  n  +  m\n  simp\n  zero_mem'  :=  by\n  use  0\n  simp\n  neg_mem'  :=  by\n  rintro  _  ⟨n,  rfl⟩\n  use  -n\n  simp \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  :  Group  H  :=  inferInstance \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  :  Group  {x  :  G  //  x  ∈  H}  :=  inferInstance \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  H'  :  Subgroup  G)  :\n  ((H  ⊓  H'  :  Subgroup  G)  :  Set  G)  =  (H  :  Set  G)  ∩  (H'  :  Set  G)  :=  rfl \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  H'  :  Subgroup  G)  :\n  ((H  ⊔  H'  :  Subgroup  G)  :  Set  G)  =  Subgroup.closure  ((H  :  Set  G)  ∪  (H'  :  Set  G))  :=  by\n  rw  [Subgroup.sup_eq_closure] \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (x  :  G)  :  x  ∈  (⊤  :  Subgroup  G)  :=  trivial \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (x  :  G)  :  x  ∈  (⊥  :  Subgroup  G)  ↔  x  =  1  :=  Subgroup.mem_bot \n```", "```py\ndef  conjugate  {G  :  Type*}  [Group  G]  (x  :  G)  (H  :  Subgroup  G)  :  Subgroup  G  where\n  carrier  :=  {a  :  G  |  ∃  h,  h  ∈  H  ∧  a  =  x  *  h  *  x⁻¹}\n  one_mem'  :=  by\n  dsimp\n  sorry\n  inv_mem'  :=  by\n  dsimp\n  sorry\n  mul_mem'  :=  by\n  dsimp\n  sorry \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (G'  :  Subgroup  G)  (f  :  G  →*  H)  :  Subgroup  H  :=\n  Subgroup.map  f  G'\n\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (H'  :  Subgroup  H)  (f  :  G  →*  H)  :  Subgroup  G  :=\n  Subgroup.comap  f  H'\n\n#check  Subgroup.mem_map\n#check  Subgroup.mem_comap \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (f  :  G  →*  H)  (g  :  G)  :\n  g  ∈  MonoidHom.ker  f  ↔  f  g  =  1  :=\n  f.mem_ker\n\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (f  :  G  →*  H)  (h  :  H)  :\n  h  ∈  MonoidHom.range  f  ↔  ∃  g  :  G,  f  g  =  h  :=\n  f.mem_range \n```", "```py\nsection  exercises\nvariable  {G  H  :  Type*}  [Group  G]  [Group  H]\n\nopen  Subgroup\n\nexample  (φ  :  G  →*  H)  (S  T  :  Subgroup  H)  (hST  :  S  ≤  T)  :  comap  φ  S  ≤  comap  φ  T  :=  by\n  sorry\n\nexample  (φ  :  G  →*  H)  (S  T  :  Subgroup  G)  (hST  :  S  ≤  T)  :  map  φ  S  ≤  map  φ  T  :=  by\n  sorry\n\nvariable  {K  :  Type*}  [Group  K]\n\n-- Remember you can use the `ext` tactic to prove an equality of subgroups.\nexample  (φ  :  G  →*  H)  (ψ  :  H  →*  K)  (U  :  Subgroup  K)  :\n  comap  (ψ.comp  φ)  U  =  comap  φ  (comap  ψ  U)  :=  by\n  sorry\n\n-- Pushing a subgroup along one homomorphism and then another is equal to\n-- pushing it forward along the composite of the homomorphisms.\nexample  (φ  :  G  →*  H)  (ψ  :  H  →*  K)  (S  :  Subgroup  G)  :\n  map  (ψ.comp  φ)  S  =  map  ψ  (S.map  φ)  :=  by\n  sorry\n\nend  exercises \n```", "```py\nopen  scoped  Classical\n\nexample  {G  :  Type*}  [Group  G]  (G'  :  Subgroup  G)  :  Nat.card  G'  ∣  Nat.card  G  :=\n  ⟨G'.index,  mul_comm  G'.index  _  ▸  G'.index_mul_card.symm⟩\n\nopen  Subgroup\n\nexample  {G  :  Type*}  [Group  G]  [Finite  G]  (p  :  ℕ)  {n  :  ℕ}  [Fact  p.Prime]\n  (hdvd  :  p  ^  n  ∣  Nat.card  G)  :  ∃  K  :  Subgroup  G,  Nat.card  K  =  p  ^  n  :=\n  Sylow.exists_subgroup_card_pow_prime  p  hdvd \n```", "```py\nlemma  eq_bot_iff_card  {G  :  Type*}  [Group  G]  {H  :  Subgroup  G}  :\n  H  =  ⊥  ↔  Nat.card  H  =  1  :=  by\n  suffices  (∀  x  ∈  H,  x  =  1)  ↔  ∃  x  ∈  H,  ∀  a  ∈  H,  a  =  x  by\n  simpa  [eq_bot_iff_forall,  Nat.card_eq_one_iff_exists]\n  sorry\n\n#check  card_dvd_of_le\n\nlemma  inf_bot_of_coprime  {G  :  Type*}  [Group  G]  (H  K  :  Subgroup  G)\n  (h  :  (Nat.card  H).Coprime  (Nat.card  K))  :  H  ⊓  K  =  ⊥  :=  by\n  sorry \n```", "```py\nopen  Equiv\n\nexample  {X  :  Type*}  [Finite  X]  :  Subgroup.closure  {σ  :  Perm  X  |  Perm.IsCycle  σ}  =  ⊤  :=\n  Perm.closure_isCycle \n```", "```py\n#simp  [mul_assoc]  c[1,  2,  3]  *  c[2,  3,  4] \n```", "```py\nsection  FreeGroup\n\ninductive  S  |  a  |  b  |  c\n\nopen  S\n\ndef  myElement  :  FreeGroup  S  :=  (.of  a)  *  (.of  b)⁻¹ \n```", "```py\ndef  myMorphism  :  FreeGroup  S  →*  Perm  (Fin  5)  :=\n  FreeGroup.lift  fun  |  .a  =>  c[1,  2,  3]\n  |  .b  =>  c[2,  3,  1]\n  |  .c  =>  c[2,  3] \n```", "```py\ndef  myGroup  :=  PresentedGroup  {.of  ()  ^  3}  deriving  Group \n```", "```py\ndef  myMap  :  Unit  →  Perm  (Fin  5)\n|  ()  =>  c[1,  2,  3]\n\nlemma  compat_myMap  :\n  ∀  r  ∈  ({.of  ()  ^  3}  :  Set  (FreeGroup  Unit)),  FreeGroup.lift  myMap  r  =  1  :=  by\n  rintro  _  rfl\n  simp\n  decide\n\ndef  myNewMorphism  :  myGroup  →*  Perm  (Fin  5)  :=  PresentedGroup.toGroup  compat_myMap\n\nend  FreeGroup \n```", "```py\nnoncomputable  section  GroupActions\n\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  (g  g':  G)  (x  :  X)  :\n  g  •  (g'  •  x)  =  (g  *  g')  •  x  :=\n  (mul_smul  g  g'  x).symm \n```", "```py\nexample  {G  X  :  Type*}  [AddGroup  G]  [AddAction  G  X]  (g  g'  :  G)  (x  :  X)  :\n  g  +ᵥ  (g'  +ᵥ  x)  =  (g  +  g')  +ᵥ  x  :=\n  (add_vadd  g  g'  x).symm \n```", "```py\nopen  MulAction\n\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  :  G  →*  Equiv.Perm  X  :=\n  toPermHom  G  X \n```", "```py\ndef  CayleyIsoMorphism  (G  :  Type*)  [Group  G]  :  G  ≃*  (toPermHom  G  G).range  :=\n  Equiv.Perm.subgroupOfMulAction  G  G \n```", "```py\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  :  Setoid  X  :=  orbitRel  G  X \n```", "```py\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  :\n  X  ≃  (ω  :  orbitRel.Quotient  G  X)  ×  (orbit  G  (Quotient.out  ω))  :=\n  MulAction.selfEquivSigmaOrbits  G  X \n```", "```py\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  (x  :  X)  :\n  orbit  G  x  ≃  G  ⧸  stabilizer  G  x  :=\n  MulAction.orbitEquivQuotientStabilizer  G  x \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  :  G  ≃  (G  ⧸  H)  ×  H  :=\n  groupEquivQuotientProdSubgroup \n```", "```py\nvariable  {G  :  Type*}  [Group  G]\n\nlemma  conjugate_one  (H  :  Subgroup  G)  :  conjugate  1  H  =  H  :=  by\n  sorry\n\ninstance  :  MulAction  G  (Subgroup  G)  where\n  smul  :=  conjugate\n  one_smul  :=  by\n  sorry\n  mul_smul  :=  by\n  sorry\n\nend  GroupActions \n```", "```py\nnoncomputable  section  QuotientGroup\n\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  [H.Normal]  :  Group  (G  ⧸  H)  :=  inferInstance\n\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  [H.Normal]  :  G  →*  G  ⧸  H  :=\n  QuotientGroup.mk'  H \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (N  :  Subgroup  G)  [N.Normal]  {M  :  Type*}\n  [Group  M]  (φ  :  G  →*  M)  (h  :  N  ≤  MonoidHom.ker  φ)  :  G  ⧸  N  →*  M  :=\n  QuotientGroup.lift  N  φ  h \n```", "```py\nexample  {G  :  Type*}  [Group  G]  {M  :  Type*}  [Group  M]  (φ  :  G  →*  M)  :\n  G  ⧸  MonoidHom.ker  φ  →*  MonoidHom.range  φ  :=\n  QuotientGroup.quotientKerEquivRange  φ \n```", "```py\nexample  {G  G':  Type*}  [Group  G]  [Group  G']\n  {N  :  Subgroup  G}  [N.Normal]  {N'  :  Subgroup  G'}  [N'.Normal]\n  {φ  :  G  →*  G'}  (h  :  N  ≤  Subgroup.comap  φ  N')  :  G  ⧸  N  →*  G'  ⧸  N':=\n  QuotientGroup.map  N  N'  φ  h \n```", "```py\nexample  {G  :  Type*}  [Group  G]  {M  N  :  Subgroup  G}  [M.Normal]\n  [N.Normal]  (h  :  M  =  N)  :  G  ⧸  M  ≃*  G  ⧸  N  :=  QuotientGroup.quotientMulEquivOfEq  h \n```", "```py\nsection\nvariable  {G  :  Type*}  [Group  G]  {H  K  :  Subgroup  G}\n\nopen  MonoidHom\n\n#check  Nat.card_pos  -- The nonempty argument will be automatically inferred for subgroups\n#check  Subgroup.index_eq_card\n#check  Subgroup.index_mul_card\n#check  Nat.eq_of_mul_eq_mul_right\n\nlemma  aux_card_eq  [Finite  G]  (h'  :  Nat.card  G  =  Nat.card  H  *  Nat.card  K)  :\n  Nat.card  (G  ⧸  H)  =  Nat.card  K  :=  by\n  sorry \n```", "```py\nvariable  [H.Normal]  [K.Normal]  [Fintype  G]  (h  :  Disjoint  H  K)\n  (h'  :  Nat.card  G  =  Nat.card  H  *  Nat.card  K)\n\n#check  Nat.bijective_iff_injective_and_card\n#check  ker_eq_bot_iff\n#check  restrict\n#check  ker_restrict\n\ndef  iso₁  :  K  ≃*  G  ⧸  H  :=  by\n  sorry \n```", "```py\ndef  iso₂  :  G  ≃*  (G  ⧸  K)  ×  (G  ⧸  H)  :=  by\n  sorry \n```", "```py\n#check  MulEquiv.prodCongr\n\ndef  finalIso  :  G  ≃*  H  ×  K  :=\n  sorry \n```", "```py\nexample  {M  :  Type*}  [Monoid  M]  (x  :  M)  :  x  *  1  =  x  :=  mul_one  x\n\nexample  {M  :  Type*}  [AddCommMonoid  M]  (x  y  :  M)  :  x  +  y  =  y  +  x  :=  add_comm  x  y \n```", "```py\nexample  {M  N  :  Type*}  [Monoid  M]  [Monoid  N]  (x  y  :  M)  (f  :  M  →*  N)  :  f  (x  *  y)  =  f  x  *  f  y  :=\n  f.map_mul  x  y\n\nexample  {M  N  :  Type*}  [AddMonoid  M]  [AddMonoid  N]  (f  :  M  →+  N)  :  f  0  =  0  :=\n  f.map_zero \n```", "```py\nexample  {M  N  P  :  Type*}  [AddMonoid  M]  [AddMonoid  N]  [AddMonoid  P]\n  (f  :  M  →+  N)  (g  :  N  →+  P)  :  M  →+  P  :=  g.comp  f \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (x  :  G)  :  x  *  x⁻¹  =  1  :=  mul_inv_cancel  x \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (x  y  z  :  G)  :  x  *  (y  *  z)  *  (x  *  z)⁻¹  *  (x  *  y  *  x⁻¹)⁻¹  =  1  :=  by\n  group \n```", "```py\nexample  {G  :  Type*}  [AddCommGroup  G]  (x  y  z  :  G)  :  z  +  x  +  (y  -  z  -  x)  =  y  :=  by\n  abel \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (x  y  :  G)  (f  :  G  →*  H)  :  f  (x  *  y)  =  f  x  *  f  y  :=\n  f.map_mul  x  y \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (x  :  G)  (f  :  G  →*  H)  :  f  (x⁻¹)  =  (f  x)⁻¹  :=\n  f.map_inv  x \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (f  :  G  →  H)  (h  :  ∀  x  y,  f  (x  *  y)  =  f  x  *  f  y)  :\n  G  →*  H  :=\n  MonoidHom.mk'  f  h \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (f  :  G  ≃*  H)  :\n  f.trans  f.symm  =  MulEquiv.refl  G  :=\n  f.self_trans_symm \n```", "```py\nnoncomputable  example  {G  H  :  Type*}  [Group  G]  [Group  H]\n  (f  :  G  →*  H)  (h  :  Function.Bijective  f)  :\n  G  ≃*  H  :=\n  MulEquiv.ofBijective  f  h \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  {x  y  :  G}  (hx  :  x  ∈  H)  (hy  :  y  ∈  H)  :\n  x  *  y  ∈  H  :=\n  H.mul_mem  hx  hy\n\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  {x  :  G}  (hx  :  x  ∈  H)  :\n  x⁻¹  ∈  H  :=\n  H.inv_mem  hx \n```", "```py\nexample  :  AddSubgroup  ℚ  where\n  carrier  :=  Set.range  ((↑)  :  ℤ  →  ℚ)\n  add_mem'  :=  by\n  rintro  _  _  ⟨n,  rfl⟩  ⟨m,  rfl⟩\n  use  n  +  m\n  simp\n  zero_mem'  :=  by\n  use  0\n  simp\n  neg_mem'  :=  by\n  rintro  _  ⟨n,  rfl⟩\n  use  -n\n  simp \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  :  Group  H  :=  inferInstance \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  :  Group  {x  :  G  //  x  ∈  H}  :=  inferInstance \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  H'  :  Subgroup  G)  :\n  ((H  ⊓  H'  :  Subgroup  G)  :  Set  G)  =  (H  :  Set  G)  ∩  (H'  :  Set  G)  :=  rfl \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  H'  :  Subgroup  G)  :\n  ((H  ⊔  H'  :  Subgroup  G)  :  Set  G)  =  Subgroup.closure  ((H  :  Set  G)  ∪  (H'  :  Set  G))  :=  by\n  rw  [Subgroup.sup_eq_closure] \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (x  :  G)  :  x  ∈  (⊤  :  Subgroup  G)  :=  trivial \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (x  :  G)  :  x  ∈  (⊥  :  Subgroup  G)  ↔  x  =  1  :=  Subgroup.mem_bot \n```", "```py\ndef  conjugate  {G  :  Type*}  [Group  G]  (x  :  G)  (H  :  Subgroup  G)  :  Subgroup  G  where\n  carrier  :=  {a  :  G  |  ∃  h,  h  ∈  H  ∧  a  =  x  *  h  *  x⁻¹}\n  one_mem'  :=  by\n  dsimp\n  sorry\n  inv_mem'  :=  by\n  dsimp\n  sorry\n  mul_mem'  :=  by\n  dsimp\n  sorry \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (G'  :  Subgroup  G)  (f  :  G  →*  H)  :  Subgroup  H  :=\n  Subgroup.map  f  G'\n\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (H'  :  Subgroup  H)  (f  :  G  →*  H)  :  Subgroup  G  :=\n  Subgroup.comap  f  H'\n\n#check  Subgroup.mem_map\n#check  Subgroup.mem_comap \n```", "```py\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (f  :  G  →*  H)  (g  :  G)  :\n  g  ∈  MonoidHom.ker  f  ↔  f  g  =  1  :=\n  f.mem_ker\n\nexample  {G  H  :  Type*}  [Group  G]  [Group  H]  (f  :  G  →*  H)  (h  :  H)  :\n  h  ∈  MonoidHom.range  f  ↔  ∃  g  :  G,  f  g  =  h  :=\n  f.mem_range \n```", "```py\nsection  exercises\nvariable  {G  H  :  Type*}  [Group  G]  [Group  H]\n\nopen  Subgroup\n\nexample  (φ  :  G  →*  H)  (S  T  :  Subgroup  H)  (hST  :  S  ≤  T)  :  comap  φ  S  ≤  comap  φ  T  :=  by\n  sorry\n\nexample  (φ  :  G  →*  H)  (S  T  :  Subgroup  G)  (hST  :  S  ≤  T)  :  map  φ  S  ≤  map  φ  T  :=  by\n  sorry\n\nvariable  {K  :  Type*}  [Group  K]\n\n-- Remember you can use the `ext` tactic to prove an equality of subgroups.\nexample  (φ  :  G  →*  H)  (ψ  :  H  →*  K)  (U  :  Subgroup  K)  :\n  comap  (ψ.comp  φ)  U  =  comap  φ  (comap  ψ  U)  :=  by\n  sorry\n\n-- Pushing a subgroup along one homomorphism and then another is equal to\n-- pushing it forward along the composite of the homomorphisms.\nexample  (φ  :  G  →*  H)  (ψ  :  H  →*  K)  (S  :  Subgroup  G)  :\n  map  (ψ.comp  φ)  S  =  map  ψ  (S.map  φ)  :=  by\n  sorry\n\nend  exercises \n```", "```py\nopen  scoped  Classical\n\nexample  {G  :  Type*}  [Group  G]  (G'  :  Subgroup  G)  :  Nat.card  G'  ∣  Nat.card  G  :=\n  ⟨G'.index,  mul_comm  G'.index  _  ▸  G'.index_mul_card.symm⟩\n\nopen  Subgroup\n\nexample  {G  :  Type*}  [Group  G]  [Finite  G]  (p  :  ℕ)  {n  :  ℕ}  [Fact  p.Prime]\n  (hdvd  :  p  ^  n  ∣  Nat.card  G)  :  ∃  K  :  Subgroup  G,  Nat.card  K  =  p  ^  n  :=\n  Sylow.exists_subgroup_card_pow_prime  p  hdvd \n```", "```py\nlemma  eq_bot_iff_card  {G  :  Type*}  [Group  G]  {H  :  Subgroup  G}  :\n  H  =  ⊥  ↔  Nat.card  H  =  1  :=  by\n  suffices  (∀  x  ∈  H,  x  =  1)  ↔  ∃  x  ∈  H,  ∀  a  ∈  H,  a  =  x  by\n  simpa  [eq_bot_iff_forall,  Nat.card_eq_one_iff_exists]\n  sorry\n\n#check  card_dvd_of_le\n\nlemma  inf_bot_of_coprime  {G  :  Type*}  [Group  G]  (H  K  :  Subgroup  G)\n  (h  :  (Nat.card  H).Coprime  (Nat.card  K))  :  H  ⊓  K  =  ⊥  :=  by\n  sorry \n```", "```py\nopen  Equiv\n\nexample  {X  :  Type*}  [Finite  X]  :  Subgroup.closure  {σ  :  Perm  X  |  Perm.IsCycle  σ}  =  ⊤  :=\n  Perm.closure_isCycle \n```", "```py\n#simp  [mul_assoc]  c[1,  2,  3]  *  c[2,  3,  4] \n```", "```py\nsection  FreeGroup\n\ninductive  S  |  a  |  b  |  c\n\nopen  S\n\ndef  myElement  :  FreeGroup  S  :=  (.of  a)  *  (.of  b)⁻¹ \n```", "```py\ndef  myMorphism  :  FreeGroup  S  →*  Perm  (Fin  5)  :=\n  FreeGroup.lift  fun  |  .a  =>  c[1,  2,  3]\n  |  .b  =>  c[2,  3,  1]\n  |  .c  =>  c[2,  3] \n```", "```py\ndef  myGroup  :=  PresentedGroup  {.of  ()  ^  3}  deriving  Group \n```", "```py\ndef  myMap  :  Unit  →  Perm  (Fin  5)\n|  ()  =>  c[1,  2,  3]\n\nlemma  compat_myMap  :\n  ∀  r  ∈  ({.of  ()  ^  3}  :  Set  (FreeGroup  Unit)),  FreeGroup.lift  myMap  r  =  1  :=  by\n  rintro  _  rfl\n  simp\n  decide\n\ndef  myNewMorphism  :  myGroup  →*  Perm  (Fin  5)  :=  PresentedGroup.toGroup  compat_myMap\n\nend  FreeGroup \n```", "```py\nnoncomputable  section  GroupActions\n\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  (g  g':  G)  (x  :  X)  :\n  g  •  (g'  •  x)  =  (g  *  g')  •  x  :=\n  (mul_smul  g  g'  x).symm \n```", "```py\nexample  {G  X  :  Type*}  [AddGroup  G]  [AddAction  G  X]  (g  g'  :  G)  (x  :  X)  :\n  g  +ᵥ  (g'  +ᵥ  x)  =  (g  +  g')  +ᵥ  x  :=\n  (add_vadd  g  g'  x).symm \n```", "```py\nopen  MulAction\n\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  :  G  →*  Equiv.Perm  X  :=\n  toPermHom  G  X \n```", "```py\ndef  CayleyIsoMorphism  (G  :  Type*)  [Group  G]  :  G  ≃*  (toPermHom  G  G).range  :=\n  Equiv.Perm.subgroupOfMulAction  G  G \n```", "```py\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  :  Setoid  X  :=  orbitRel  G  X \n```", "```py\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  :\n  X  ≃  (ω  :  orbitRel.Quotient  G  X)  ×  (orbit  G  (Quotient.out  ω))  :=\n  MulAction.selfEquivSigmaOrbits  G  X \n```", "```py\nexample  {G  X  :  Type*}  [Group  G]  [MulAction  G  X]  (x  :  X)  :\n  orbit  G  x  ≃  G  ⧸  stabilizer  G  x  :=\n  MulAction.orbitEquivQuotientStabilizer  G  x \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  :  G  ≃  (G  ⧸  H)  ×  H  :=\n  groupEquivQuotientProdSubgroup \n```", "```py\nvariable  {G  :  Type*}  [Group  G]\n\nlemma  conjugate_one  (H  :  Subgroup  G)  :  conjugate  1  H  =  H  :=  by\n  sorry\n\ninstance  :  MulAction  G  (Subgroup  G)  where\n  smul  :=  conjugate\n  one_smul  :=  by\n  sorry\n  mul_smul  :=  by\n  sorry\n\nend  GroupActions \n```", "```py\nnoncomputable  section  QuotientGroup\n\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  [H.Normal]  :  Group  (G  ⧸  H)  :=  inferInstance\n\nexample  {G  :  Type*}  [Group  G]  (H  :  Subgroup  G)  [H.Normal]  :  G  →*  G  ⧸  H  :=\n  QuotientGroup.mk'  H \n```", "```py\nexample  {G  :  Type*}  [Group  G]  (N  :  Subgroup  G)  [N.Normal]  {M  :  Type*}\n  [Group  M]  (φ  :  G  →*  M)  (h  :  N  ≤  MonoidHom.ker  φ)  :  G  ⧸  N  →*  M  :=\n  QuotientGroup.lift  N  φ  h \n```", "```py\nexample  {G  :  Type*}  [Group  G]  {M  :  Type*}  [Group  M]  (φ  :  G  →*  M)  :\n  G  ⧸  MonoidHom.ker  φ  →*  MonoidHom.range  φ  :=\n  QuotientGroup.quotientKerEquivRange  φ \n```", "```py\nexample  {G  G':  Type*}  [Group  G]  [Group  G']\n  {N  :  Subgroup  G}  [N.Normal]  {N'  :  Subgroup  G'}  [N'.Normal]\n  {φ  :  G  →*  G'}  (h  :  N  ≤  Subgroup.comap  φ  N')  :  G  ⧸  N  →*  G'  ⧸  N':=\n  QuotientGroup.map  N  N'  φ  h \n```", "```py\nexample  {G  :  Type*}  [Group  G]  {M  N  :  Subgroup  G}  [M.Normal]\n  [N.Normal]  (h  :  M  =  N)  :  G  ⧸  M  ≃*  G  ⧸  N  :=  QuotientGroup.quotientMulEquivOfEq  h \n```", "```py\nsection\nvariable  {G  :  Type*}  [Group  G]  {H  K  :  Subgroup  G}\n\nopen  MonoidHom\n\n#check  Nat.card_pos  -- The nonempty argument will be automatically inferred for subgroups\n#check  Subgroup.index_eq_card\n#check  Subgroup.index_mul_card\n#check  Nat.eq_of_mul_eq_mul_right\n\nlemma  aux_card_eq  [Finite  G]  (h'  :  Nat.card  G  =  Nat.card  H  *  Nat.card  K)  :\n  Nat.card  (G  ⧸  H)  =  Nat.card  K  :=  by\n  sorry \n```", "```py\nvariable  [H.Normal]  [K.Normal]  [Fintype  G]  (h  :  Disjoint  H  K)\n  (h'  :  Nat.card  G  =  Nat.card  H  *  Nat.card  K)\n\n#check  Nat.bijective_iff_injective_and_card\n#check  ker_eq_bot_iff\n#check  restrict\n#check  ker_restrict\n\ndef  iso₁  :  K  ≃*  G  ⧸  H  :=  by\n  sorry \n```", "```py\ndef  iso₂  :  G  ≃*  (G  ⧸  K)  ×  (G  ⧸  H)  :=  by\n  sorry \n```", "```py\n#check  MulEquiv.prodCongr\n\ndef  finalIso  :  G  ≃*  H  ×  K  :=\n  sorry \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (x  y  :  R)  :  (x  +  y)  ^  2  =  x  ^  2  +  y  ^  2  +  2  *  x  *  y  :=  by  ring \n```", "```py\nexample  (x  y  :  ℕ)  :  (x  +  y)  ^  2  =  x  ^  2  +  y  ^  2  +  2  *  x  *  y  :=  by  ring \n```", "```py\nexample  (x  :  ℤˣ)  :  x  =  1  ∨  x  =  -1  :=  Int.units_eq_one_or  x\n\nexample  {M  :  Type*}  [Monoid  M]  (x  :  Mˣ)  :  (x  :  M)  *  x⁻¹  =  1  :=  Units.mul_inv  x\n\nexample  {M  :  Type*}  [Monoid  M]  :  Group  Mˣ  :=  inferInstance \n```", "```py\nexample  {R  S  :  Type*}  [Ring  R]  [Ring  S]  (f  :  R  →+*  S)  (x  y  :  R)  :\n  f  (x  +  y)  =  f  x  +  f  y  :=  f.map_add  x  y\n\nexample  {R  S  :  Type*}  [Ring  R]  [Ring  S]  (f  :  R  →+*  S)  :  Rˣ  →*  Sˣ  :=\n  Units.map  f \n```", "```py\nexample  {R  :  Type*}  [Ring  R]  (S  :  Subring  R)  :  Ring  S  :=  inferInstance \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (I  :  Ideal  R)  :  R  →+*  R  ⧸  I  :=\n  Ideal.Quotient.mk  I\n\nexample  {R  :  Type*}  [CommRing  R]  {a  :  R}  {I  :  Ideal  R}  :\n  Ideal.Quotient.mk  I  a  =  0  ↔  a  ∈  I  :=\n  Ideal.Quotient.eq_zero_iff_mem \n```", "```py\nexample  {R  S  :  Type*}  [CommRing  R]  [CommRing  S]  (I  :  Ideal  R)  (f  :  R  →+*  S)\n  (H  :  I  ≤  RingHom.ker  f)  :  R  ⧸  I  →+*  S  :=\n  Ideal.Quotient.lift  I  f  H \n```", "```py\nexample  {R  S  :  Type*}  [CommRing  R]  [CommRing  S](f  :  R  →+*  S)  :\n  R  ⧸  RingHom.ker  f  ≃+*  f.range  :=\n  RingHom.quotientKerEquivRange  f \n```", "```py\nvariable  {R  :  Type*}  [CommRing  R]  {I  J  :  Ideal  R}\n\nexample  :  I  +  J  =  I  ⊔  J  :=  rfl\n\nexample  {x  :  R}  :  x  ∈  I  +  J  ↔  ∃  a  ∈  I,  ∃  b  ∈  J,  a  +  b  =  x  :=  by\n  simp  [Submodule.mem_sup]\n\nexample  :  I  *  J  ≤  J  :=  Ideal.mul_le_left\n\nexample  :  I  *  J  ≤  I  :=  Ideal.mul_le_right\n\nexample  :  I  *  J  ≤  I  ⊓  J  :=  Ideal.mul_le_inf \n```", "```py\nexample  {R  S  :  Type*}  [CommRing  R]  [CommRing  S]  (I  :  Ideal  R)  (J  :  Ideal  S)  (f  :  R  →+*  S)\n  (H  :  I  ≤  Ideal.comap  f  J)  :  R  ⧸  I  →+*  S  ⧸  J  :=\n  Ideal.quotientMap  J  f  H \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  {I  J  :  Ideal  R}  (h  :  I  =  J)  :  R  ⧸  I  ≃+*  R  ⧸  J  :=\n  Ideal.quotEquivOfEq  h \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  {ι  :  Type*}  [Fintype  ι]  (f  :  ι  →  Ideal  R)\n  (hf  :  ∀  i  j,  i  ≠  j  →  IsCoprime  (f  i)  (f  j))  :  (R  ⧸  ⨅  i,  f  i)  ≃+*  Π  i,  R  ⧸  f  i  :=\n  Ideal.quotientInfRingEquivPiQuotient  f  hf \n```", "```py\nopen  BigOperators  PiNotation\n\nexample  {ι  :  Type*}  [Fintype  ι]  (a  :  ι  →  ℕ)  (coprime  :  ∀  i  j,  i  ≠  j  →  (a  i).Coprime  (a  j))  :\n  ZMod  (∏  i,  a  i)  ≃+*  Π  i,  ZMod  (a  i)  :=\n  ZMod.prodEquivPi  a  coprime \n```", "```py\nvariable  {ι  R  :  Type*}  [CommRing  R]\nopen  Ideal  Quotient  Function\n\n#check  Pi.ringHom\n#check  ker_Pi_Quotient_mk\n\n/-- The homomorphism from ``R ⧸ ⨅ i, I i`` to ``Π i, R ⧸ I i`` featured in the Chinese\n Remainder Theorem. -/\ndef  chineseMap  (I  :  ι  →  Ideal  R)  :  (R  ⧸  ⨅  i,  I  i)  →+*  Π  i,  R  ⧸  I  i  :=\n  sorry \n```", "```py\nlemma  chineseMap_mk  (I  :  ι  →  Ideal  R)  (x  :  R)  :\n  chineseMap  I  (Quotient.mk  _  x)  =  fun  i  :  ι  ↦  Ideal.Quotient.mk  (I  i)  x  :=\n  sorry\n\nlemma  chineseMap_mk'  (I  :  ι  →  Ideal  R)  (x  :  R)  (i  :  ι)  :\n  chineseMap  I  (mk  _  x)  i  =  mk  (I  i)  x  :=\n  sorry \n```", "```py\n#check  injective_lift_iff\n\nlemma  chineseMap_inj  (I  :  ι  →  Ideal  R)  :  Injective  (chineseMap  I)  :=  by\n  sorry \n```", "```py\n#check  IsCoprime\n#check  isCoprime_iff_add\n#check  isCoprime_iff_exists\n#check  isCoprime_iff_sup_eq\n#check  isCoprime_iff_codisjoint \n```", "```py\n#check  Finset.mem_insert_of_mem\n#check  Finset.mem_insert_self\n\ntheorem  isCoprime_Inf  {I  :  Ideal  R}  {J  :  ι  →  Ideal  R}  {s  :  Finset  ι}\n  (hf  :  ∀  j  ∈  s,  IsCoprime  I  (J  j))  :  IsCoprime  I  (⨅  j  ∈  s,  J  j)  :=  by\n  classical\n  simp_rw  [isCoprime_iff_add]  at  *\n  induction  s  using  Finset.induction  with\n  |  empty  =>\n  simp\n  |  @insert  i  s  _  hs  =>\n  rw  [Finset.iInf_insert,  inf_comm,  one_eq_top,  eq_top_iff,  ←  one_eq_top]\n  set  K  :=  ⨅  j  ∈  s,  J  j\n  calc\n  1  =  I  +  K  :=  sorry\n  _  =  I  +  K  *  (I  +  J  i)  :=  sorry\n  _  =  (1  +  K)  *  I  +  K  *  J  i  :=  sorry\n  _  ≤  I  +  K  ⊓  J  i  :=  sorry \n```", "```py\nlemma  chineseMap_surj  [Fintype  ι]  {I  :  ι  →  Ideal  R}\n  (hI  :  ∀  i  j,  i  ≠  j  →  IsCoprime  (I  i)  (I  j))  :  Surjective  (chineseMap  I)  :=  by\n  classical\n  intro  g\n  choose  f  hf  using  fun  i  ↦  Ideal.Quotient.mk_surjective  (g  i)\n  have  key  :  ∀  i,  ∃  e  :  R,  mk  (I  i)  e  =  1  ∧  ∀  j,  j  ≠  i  →  mk  (I  j)  e  =  0  :=  by\n  intro  i\n  have  hI'  :  ∀  j  ∈  ({i}  :  Finset  ι)ᶜ,  IsCoprime  (I  i)  (I  j)  :=  by\n  sorry\n  sorry\n  choose  e  he  using  key\n  use  mk  _  (∑  i,  f  i  *  e  i)\n  sorry \n```", "```py\nnoncomputable  def  chineseIso  [Fintype  ι]  (f  :  ι  →  Ideal  R)\n  (hf  :  ∀  i  j,  i  ≠  j  →  IsCoprime  (f  i)  (f  j))  :  (R  ⧸  ⨅  i,  f  i)  ≃+*  Π  i,  R  ⧸  f  i  :=\n  {  Equiv.ofBijective  _  ⟨chineseMap_inj  f,  chineseMap_surj  hf⟩,\n  chineseMap  f  with  } \n```", "```py\nexample  {R  A  :  Type*}  [CommRing  R]  [Ring  A]  [Algebra  R  A]  (r  r'  :  R)  (a  :  A)  :\n  (r  +  r')  •  a  =  r  •  a  +  r'  •  a  :=\n  add_smul  r  r'  a\n\nexample  {R  A  :  Type*}  [CommRing  R]  [Ring  A]  [Algebra  R  A]  (r  r'  :  R)  (a  :  A)  :\n  (r  *  r')  •  a  =  r  •  r'  •  a  :=\n  mul_smul  r  r'  a \n```", "```py\nopen  Polynomial\n\nexample  {R  :  Type*}  [CommRing  R]  :  R[X]  :=  X\n\nexample  {R  :  Type*}  [CommRing  R]  (r  :  R)  :=  X  -  C  r \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (r  :  R)  :  (X  +  C  r)  *  (X  -  C  r)  =  X  ^  2  -  C  (r  ^  2)  :=  by\n  rw  [C.map_pow]\n  ring \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (r:R)  :  (C  r).coeff  0  =  r  :=  by  simp\n\nexample  {R  :  Type*}  [CommRing  R]  :  (X  ^  2  +  2  *  X  +  C  3  :  R[X]).coeff  1  =  2  :=  by  simp \n```", "```py\nexample  {R  :  Type*}  [Semiring  R]  [NoZeroDivisors  R]  {p  q  :  R[X]}  :\n  degree  (p  *  q)  =  degree  p  +  degree  q  :=\n  Polynomial.degree_mul \n```", "```py\nexample  {R  :  Type*}  [Semiring  R]  [NoZeroDivisors  R]  {p  q  :  R[X]}  (hp  :  p  ≠  0)  (hq  :  q  ≠  0)  :\n  natDegree  (p  *  q)  =  natDegree  p  +  natDegree  q  :=\n  Polynomial.natDegree_mul  hp  hq \n```", "```py\nexample  {R  :  Type*}  [Semiring  R]  [NoZeroDivisors  R]  {p  q  :  R[X]}  :\n  natDegree  (comp  p  q)  =  natDegree  p  *  natDegree  q  :=\n  Polynomial.natDegree_comp \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (P:  R[X])  (x  :  R)  :=  P.eval  x\n\nexample  {R  :  Type*}  [CommRing  R]  (r  :  R)  :  (X  -  C  r).eval  r  =  0  :=  by  simp \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (P  :  R[X])  (r  :  R)  :  IsRoot  P  r  ↔  P.eval  r  =  0  :=  Iff.rfl \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  [IsDomain  R]  (r  :  R)  :  (X  -  C  r).roots  =  {r}  :=\n  roots_X_sub_C  r\n\nexample  {R  :  Type*}  [CommRing  R]  [IsDomain  R]  (r  :  R)  (n  :  ℕ):\n  ((X  -  C  r)  ^  n).roots  =  n  •  {r}  :=\n  by  simp \n```", "```py\nexample  :  aeval  Complex.I  (X  ^  2  +  1  :  ℝ[X])  =  0  :=  by  simp \n```", "```py\nopen  Complex  Polynomial\n\nexample  :  aroots  (X  ^  2  +  1  :  ℝ[X])  ℂ  =  {Complex.I,  -I}  :=  by\n  suffices  roots  (X  ^  2  +  1  :  ℂ[X])  =  {I,  -I}  by  simpa  [aroots_def]\n  have  factored  :  (X  ^  2  +  1  :  ℂ[X])  =  (X  -  C  I)  *  (X  -  C  (-I))  :=  by\n  have  key  :  (C  I  *  C  I  :  ℂ[X])  =  -1  :=  by  simp  [←  C_mul]\n  rw  [C_neg]\n  linear_combination  key\n  have  p_ne_zero  :  (X  -  C  I)  *  (X  -  C  (-I))  ≠  0  :=  by\n  intro  H\n  apply_fun  eval  0  at  H\n  simp  [eval]  at  H\n  simp  only  [factored,  roots_mul  p_ne_zero,  roots_X_sub_C]\n  rfl\n\n-- Mathlib knows about D'Alembert-Gauss theorem: ``ℂ`` is algebraically closed.\nexample  :  IsAlgClosed  ℂ  :=  inferInstance \n```", "```py\n#check  (Complex.ofRealHom  :  ℝ  →+*  ℂ)\n\nexample  :  (X  ^  2  +  1  :  ℝ[X]).eval₂  Complex.ofRealHom  Complex.I  =  0  :=  by  simp \n```", "```py\nopen  MvPolynomial\n\ndef  circleEquation  :  MvPolynomial  (Fin  2)  ℝ  :=  X  0  ^  2  +  X  1  ^  2  -  1 \n```", "```py\nexample  :  MvPolynomial.eval  ![1,  0]  circleEquation  =  0  :=  by  simp  [circleEquation] \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (x  y  :  R)  :  (x  +  y)  ^  2  =  x  ^  2  +  y  ^  2  +  2  *  x  *  y  :=  by  ring \n```", "```py\nexample  (x  y  :  ℕ)  :  (x  +  y)  ^  2  =  x  ^  2  +  y  ^  2  +  2  *  x  *  y  :=  by  ring \n```", "```py\nexample  (x  :  ℤˣ)  :  x  =  1  ∨  x  =  -1  :=  Int.units_eq_one_or  x\n\nexample  {M  :  Type*}  [Monoid  M]  (x  :  Mˣ)  :  (x  :  M)  *  x⁻¹  =  1  :=  Units.mul_inv  x\n\nexample  {M  :  Type*}  [Monoid  M]  :  Group  Mˣ  :=  inferInstance \n```", "```py\nexample  {R  S  :  Type*}  [Ring  R]  [Ring  S]  (f  :  R  →+*  S)  (x  y  :  R)  :\n  f  (x  +  y)  =  f  x  +  f  y  :=  f.map_add  x  y\n\nexample  {R  S  :  Type*}  [Ring  R]  [Ring  S]  (f  :  R  →+*  S)  :  Rˣ  →*  Sˣ  :=\n  Units.map  f \n```", "```py\nexample  {R  :  Type*}  [Ring  R]  (S  :  Subring  R)  :  Ring  S  :=  inferInstance \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (I  :  Ideal  R)  :  R  →+*  R  ⧸  I  :=\n  Ideal.Quotient.mk  I\n\nexample  {R  :  Type*}  [CommRing  R]  {a  :  R}  {I  :  Ideal  R}  :\n  Ideal.Quotient.mk  I  a  =  0  ↔  a  ∈  I  :=\n  Ideal.Quotient.eq_zero_iff_mem \n```", "```py\nexample  {R  S  :  Type*}  [CommRing  R]  [CommRing  S]  (I  :  Ideal  R)  (f  :  R  →+*  S)\n  (H  :  I  ≤  RingHom.ker  f)  :  R  ⧸  I  →+*  S  :=\n  Ideal.Quotient.lift  I  f  H \n```", "```py\nexample  {R  S  :  Type*}  [CommRing  R]  [CommRing  S](f  :  R  →+*  S)  :\n  R  ⧸  RingHom.ker  f  ≃+*  f.range  :=\n  RingHom.quotientKerEquivRange  f \n```", "```py\nvariable  {R  :  Type*}  [CommRing  R]  {I  J  :  Ideal  R}\n\nexample  :  I  +  J  =  I  ⊔  J  :=  rfl\n\nexample  {x  :  R}  :  x  ∈  I  +  J  ↔  ∃  a  ∈  I,  ∃  b  ∈  J,  a  +  b  =  x  :=  by\n  simp  [Submodule.mem_sup]\n\nexample  :  I  *  J  ≤  J  :=  Ideal.mul_le_left\n\nexample  :  I  *  J  ≤  I  :=  Ideal.mul_le_right\n\nexample  :  I  *  J  ≤  I  ⊓  J  :=  Ideal.mul_le_inf \n```", "```py\nexample  {R  S  :  Type*}  [CommRing  R]  [CommRing  S]  (I  :  Ideal  R)  (J  :  Ideal  S)  (f  :  R  →+*  S)\n  (H  :  I  ≤  Ideal.comap  f  J)  :  R  ⧸  I  →+*  S  ⧸  J  :=\n  Ideal.quotientMap  J  f  H \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  {I  J  :  Ideal  R}  (h  :  I  =  J)  :  R  ⧸  I  ≃+*  R  ⧸  J  :=\n  Ideal.quotEquivOfEq  h \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  {ι  :  Type*}  [Fintype  ι]  (f  :  ι  →  Ideal  R)\n  (hf  :  ∀  i  j,  i  ≠  j  →  IsCoprime  (f  i)  (f  j))  :  (R  ⧸  ⨅  i,  f  i)  ≃+*  Π  i,  R  ⧸  f  i  :=\n  Ideal.quotientInfRingEquivPiQuotient  f  hf \n```", "```py\nopen  BigOperators  PiNotation\n\nexample  {ι  :  Type*}  [Fintype  ι]  (a  :  ι  →  ℕ)  (coprime  :  ∀  i  j,  i  ≠  j  →  (a  i).Coprime  (a  j))  :\n  ZMod  (∏  i,  a  i)  ≃+*  Π  i,  ZMod  (a  i)  :=\n  ZMod.prodEquivPi  a  coprime \n```", "```py\nvariable  {ι  R  :  Type*}  [CommRing  R]\nopen  Ideal  Quotient  Function\n\n#check  Pi.ringHom\n#check  ker_Pi_Quotient_mk\n\n/-- The homomorphism from ``R ⧸ ⨅ i, I i`` to ``Π i, R ⧸ I i`` featured in the Chinese\n Remainder Theorem. -/\ndef  chineseMap  (I  :  ι  →  Ideal  R)  :  (R  ⧸  ⨅  i,  I  i)  →+*  Π  i,  R  ⧸  I  i  :=\n  sorry \n```", "```py\nlemma  chineseMap_mk  (I  :  ι  →  Ideal  R)  (x  :  R)  :\n  chineseMap  I  (Quotient.mk  _  x)  =  fun  i  :  ι  ↦  Ideal.Quotient.mk  (I  i)  x  :=\n  sorry\n\nlemma  chineseMap_mk'  (I  :  ι  →  Ideal  R)  (x  :  R)  (i  :  ι)  :\n  chineseMap  I  (mk  _  x)  i  =  mk  (I  i)  x  :=\n  sorry \n```", "```py\n#check  injective_lift_iff\n\nlemma  chineseMap_inj  (I  :  ι  →  Ideal  R)  :  Injective  (chineseMap  I)  :=  by\n  sorry \n```", "```py\n#check  IsCoprime\n#check  isCoprime_iff_add\n#check  isCoprime_iff_exists\n#check  isCoprime_iff_sup_eq\n#check  isCoprime_iff_codisjoint \n```", "```py\n#check  Finset.mem_insert_of_mem\n#check  Finset.mem_insert_self\n\ntheorem  isCoprime_Inf  {I  :  Ideal  R}  {J  :  ι  →  Ideal  R}  {s  :  Finset  ι}\n  (hf  :  ∀  j  ∈  s,  IsCoprime  I  (J  j))  :  IsCoprime  I  (⨅  j  ∈  s,  J  j)  :=  by\n  classical\n  simp_rw  [isCoprime_iff_add]  at  *\n  induction  s  using  Finset.induction  with\n  |  empty  =>\n  simp\n  |  @insert  i  s  _  hs  =>\n  rw  [Finset.iInf_insert,  inf_comm,  one_eq_top,  eq_top_iff,  ←  one_eq_top]\n  set  K  :=  ⨅  j  ∈  s,  J  j\n  calc\n  1  =  I  +  K  :=  sorry\n  _  =  I  +  K  *  (I  +  J  i)  :=  sorry\n  _  =  (1  +  K)  *  I  +  K  *  J  i  :=  sorry\n  _  ≤  I  +  K  ⊓  J  i  :=  sorry \n```", "```py\nlemma  chineseMap_surj  [Fintype  ι]  {I  :  ι  →  Ideal  R}\n  (hI  :  ∀  i  j,  i  ≠  j  →  IsCoprime  (I  i)  (I  j))  :  Surjective  (chineseMap  I)  :=  by\n  classical\n  intro  g\n  choose  f  hf  using  fun  i  ↦  Ideal.Quotient.mk_surjective  (g  i)\n  have  key  :  ∀  i,  ∃  e  :  R,  mk  (I  i)  e  =  1  ∧  ∀  j,  j  ≠  i  →  mk  (I  j)  e  =  0  :=  by\n  intro  i\n  have  hI'  :  ∀  j  ∈  ({i}  :  Finset  ι)ᶜ,  IsCoprime  (I  i)  (I  j)  :=  by\n  sorry\n  sorry\n  choose  e  he  using  key\n  use  mk  _  (∑  i,  f  i  *  e  i)\n  sorry \n```", "```py\nnoncomputable  def  chineseIso  [Fintype  ι]  (f  :  ι  →  Ideal  R)\n  (hf  :  ∀  i  j,  i  ≠  j  →  IsCoprime  (f  i)  (f  j))  :  (R  ⧸  ⨅  i,  f  i)  ≃+*  Π  i,  R  ⧸  f  i  :=\n  {  Equiv.ofBijective  _  ⟨chineseMap_inj  f,  chineseMap_surj  hf⟩,\n  chineseMap  f  with  } \n```", "```py\nexample  {R  A  :  Type*}  [CommRing  R]  [Ring  A]  [Algebra  R  A]  (r  r'  :  R)  (a  :  A)  :\n  (r  +  r')  •  a  =  r  •  a  +  r'  •  a  :=\n  add_smul  r  r'  a\n\nexample  {R  A  :  Type*}  [CommRing  R]  [Ring  A]  [Algebra  R  A]  (r  r'  :  R)  (a  :  A)  :\n  (r  *  r')  •  a  =  r  •  r'  •  a  :=\n  mul_smul  r  r'  a \n```", "```py\nopen  Polynomial\n\nexample  {R  :  Type*}  [CommRing  R]  :  R[X]  :=  X\n\nexample  {R  :  Type*}  [CommRing  R]  (r  :  R)  :=  X  -  C  r \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (r  :  R)  :  (X  +  C  r)  *  (X  -  C  r)  =  X  ^  2  -  C  (r  ^  2)  :=  by\n  rw  [C.map_pow]\n  ring \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (r:R)  :  (C  r).coeff  0  =  r  :=  by  simp\n\nexample  {R  :  Type*}  [CommRing  R]  :  (X  ^  2  +  2  *  X  +  C  3  :  R[X]).coeff  1  =  2  :=  by  simp \n```", "```py\nexample  {R  :  Type*}  [Semiring  R]  [NoZeroDivisors  R]  {p  q  :  R[X]}  :\n  degree  (p  *  q)  =  degree  p  +  degree  q  :=\n  Polynomial.degree_mul \n```", "```py\nexample  {R  :  Type*}  [Semiring  R]  [NoZeroDivisors  R]  {p  q  :  R[X]}  (hp  :  p  ≠  0)  (hq  :  q  ≠  0)  :\n  natDegree  (p  *  q)  =  natDegree  p  +  natDegree  q  :=\n  Polynomial.natDegree_mul  hp  hq \n```", "```py\nexample  {R  :  Type*}  [Semiring  R]  [NoZeroDivisors  R]  {p  q  :  R[X]}  :\n  natDegree  (comp  p  q)  =  natDegree  p  *  natDegree  q  :=\n  Polynomial.natDegree_comp \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (P:  R[X])  (x  :  R)  :=  P.eval  x\n\nexample  {R  :  Type*}  [CommRing  R]  (r  :  R)  :  (X  -  C  r).eval  r  =  0  :=  by  simp \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  (P  :  R[X])  (r  :  R)  :  IsRoot  P  r  ↔  P.eval  r  =  0  :=  Iff.rfl \n```", "```py\nexample  {R  :  Type*}  [CommRing  R]  [IsDomain  R]  (r  :  R)  :  (X  -  C  r).roots  =  {r}  :=\n  roots_X_sub_C  r\n\nexample  {R  :  Type*}  [CommRing  R]  [IsDomain  R]  (r  :  R)  (n  :  ℕ):\n  ((X  -  C  r)  ^  n).roots  =  n  •  {r}  :=\n  by  simp \n```", "```py\nexample  :  aeval  Complex.I  (X  ^  2  +  1  :  ℝ[X])  =  0  :=  by  simp \n```", "```py\nopen  Complex  Polynomial\n\nexample  :  aroots  (X  ^  2  +  1  :  ℝ[X])  ℂ  =  {Complex.I,  -I}  :=  by\n  suffices  roots  (X  ^  2  +  1  :  ℂ[X])  =  {I,  -I}  by  simpa  [aroots_def]\n  have  factored  :  (X  ^  2  +  1  :  ℂ[X])  =  (X  -  C  I)  *  (X  -  C  (-I))  :=  by\n  have  key  :  (C  I  *  C  I  :  ℂ[X])  =  -1  :=  by  simp  [←  C_mul]\n  rw  [C_neg]\n  linear_combination  key\n  have  p_ne_zero  :  (X  -  C  I)  *  (X  -  C  (-I))  ≠  0  :=  by\n  intro  H\n  apply_fun  eval  0  at  H\n  simp  [eval]  at  H\n  simp  only  [factored,  roots_mul  p_ne_zero,  roots_X_sub_C]\n  rfl\n\n-- Mathlib knows about D'Alembert-Gauss theorem: ``ℂ`` is algebraically closed.\nexample  :  IsAlgClosed  ℂ  :=  inferInstance \n```", "```py\n#check  (Complex.ofRealHom  :  ℝ  →+*  ℂ)\n\nexample  :  (X  ^  2  +  1  :  ℝ[X]).eval₂  Complex.ofRealHom  Complex.I  =  0  :=  by  simp \n```", "```py\nopen  MvPolynomial\n\ndef  circleEquation  :  MvPolynomial  (Fin  2)  ℝ  :=  X  0  ^  2  +  X  1  ^  2  -  1 \n```", "```py\nexample  :  MvPolynomial.eval  ![1,  0]  circleEquation  =  0  :=  by  simp  [circleEquation] \n```"]