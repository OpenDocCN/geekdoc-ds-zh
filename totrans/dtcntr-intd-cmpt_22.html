<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>8.2Â Queues from ListsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>8.2Â Queues from ListsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/queues-from-lists.html">https://dcic-world.org/2025-08-27/queues-from-lists.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Using_a_.Wrapper_.Datatype%29" class="toclink" data-pltdoc="x">8.2.1<span class="hspace">Â </span>Using a Wrapper Datatype</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._qfl-comb-ans%29" class="toclink" data-pltdoc="x">8.2.2<span class="hspace">Â </span>Combining Answers</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Using_a_.Picker%29" class="toclink" data-pltdoc="x">8.2.3<span class="hspace">Â </span>Using a Picker</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._qfl-tuples%29" class="toclink" data-pltdoc="x">8.2.4<span class="hspace">Â </span>Using Tuples</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.A_.Picker_.Method%29" class="toclink" data-pltdoc="x">8.2.5<span class="hspace">Â </span>A Picker Method</a></p></td></tr></table><p>Suppose you have a list. When you take its first element, you get the
element that was most recently <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>ed to create it. The next element is the
second most recent one that was <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>ed, and so on. That is, the last one in is
the first one out. This is called a <span class="Smaller">LIFO</span>, short for â€œlast-in-first-outâ€, data
structure. A list is <span class="Smaller">LIFO</span>; we sometimes also refer to this as a <span style="font-style: italic">stack</span>.</p><p>But there are many settings where you want the first-in to be the
first-out. When you stand at a supermarket line, try to purchase concert
tickets, submit a job request, or any number of other tasks, you want to be
rewarded, not punished, for being there first. That is, you want a <span class="Smaller">FIFO</span> instead. This
is called a <span style="font-style: italic">queue</span>.</p><p>The game weâ€™re playing here is that we want one datatype but our language has
given us another (in this case, lists), and we have to figure out how to encode
one in the other. Weâ€™ll see elsewhere how to encode sets with lists
[<a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>]. Here letâ€™s see how we can encode queues with lists.</p><p>With sets, we allowed the set type to be an alias for lists; that is, the two
were the same. Another option we have when encoding is to create a completely
new type that does nothing more than wrap a value of the encoding type. Weâ€™ll
use that principle here to illustrate how that might work.</p><section class="SsectionLevel4" id="section 8.2.1"><h4 class="heading">8.2.1<span class="stt">Â </span><a name="(part._.Using_a_.Wrapper_.Datatype)"/>Using a Wrapper Datatype<span class="button-group"><a href="#(part._.Using_a_.Wrapper_.Datatype)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Concretely, hereâ€™s how weâ€™ll represent queues. For all the code that follows,
itâ€™s helpful to use the Pyret type-checker to make sure weâ€™re composing code
correctly:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Queue&lt;T&gt;:
  | queue(l :: List&lt;T&gt;)
end</code></pre></div></div></div><div class="SIntrapara">With this encoding, we can start define a few helper functions: e.g., a way to
construct an empty queue and to check for emptiness:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun mk-mtq&lt;T&gt;() -&gt; Queue&lt;T&gt;:
  queue(empty)
end

fun is-mtq&lt;T&gt;(q :: Queue&lt;T&gt;) -&gt; Boolean:
  is-empty(q.l)
end</code></pre></div></div></div><div class="SIntrapara">Adding an element to a queue is usually called â€œenqueueingâ€. It has this type:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">enqueue :: &lt;T&gt; Queue&lt;T&gt;, T -&gt; Queue&lt;T&gt;</code></pre></div></div></div><div class="SIntrapara">Hereâ€™s the corresponding implementation:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun enqueue(q, e):
  queue(link(e, q.l))
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Did we have a choice?</p></blockquote></blockquote><p>Yes, we did! We could have made the new element the <span class="emph">first</span> element or the
<span class="emph">last</span> element.<span class="refelem"><span class="refcolumn"><span class="refcontent">Be careful here: we mean the first or last
element of <span class="emph">the list that represents the queue</span>, not of the queue
itself. There, <span class="Smaller">FIFO</span> gives us no choice.</span></span></span> We just happened to choose one
representation. The other would be equally valid; we would just need to
implement all the other operations consistently. Letâ€™s stick to this one for
now.</p><p/><div class="SIntrapara">Now we come to a problem. What does it mean to â€œdequeueâ€? We need to get back
the one element, but we also need to get back the rest. Letâ€™s first write this
as two functions, very analogous to first and rest on lists:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">qpeek :: &lt;T&gt; Queue&lt;T&gt; -&gt; T
qrest :: &lt;T&gt; Queue&lt;T&gt; -&gt; Queue&lt;T&gt;</code></pre></div></div></div><div class="SIntrapara">Letâ€™s write out a few examples to make sure we know how these should work:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">q_ = mk-mtq()
q3 = enqueue(q_, 3)
m43 = enqueue(q3, 4)
m543 = enqueue(m43, 5)

check:
  qpeek(q3) is 3
  qpeek(m43) is 3
  qpeek(m543) is 3
end

check:
  qrest(q3) is mk-mtq()
  qrest(m43) is enqueue(mk-mtq(), 4)
  qrest(m543) is enqueue(enqueue(mk-mtq(), 4), 5)
end</code></pre></div></div></div><div class="SIntrapara">Now letâ€™s implement these:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun qpeek(q):
  if is-mtq(q):
    raise("can't peek an empty queue")
  else:
    q.l.get(q.l.length() - 1)
  end
end

fun qrest(q):
  fun safe-rest(l :: List&lt;T&gt;) -&gt; List&lt;T&gt;:
    cases (List) l:
      | empty =&gt; raise("can't dequeue an empty queue")
      | link(f, r) =&gt; r
    end
  end
  queue(safe-rest(q.l.reverse()).reverse())
end</code></pre></div></div></div></section><section class="SsectionLevel4" id="section 8.2.2"><h4 class="heading">8.2.2<span class="stt">Â </span><a name="(part._qfl-comb-ans)"/>Combining Answers<span class="button-group"><a href="#(part._qfl-comb-ans)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">However, it would be nice if we could obtain both the oldest element and the
rest of the queue at once, if we want them both. That means the single function
would need to return two values; since a function can return only one value at
a time, it would need to use a data structure to hold both of
them. Furthermore, note that both <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">qpeek</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">qrest</code></span> above have the
possibility of not having any more elements! We might as well reflect that too
in the type. Thus we end up with a type that looks like
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Dequeued&lt;T&gt;:
  | none-left
  | elt-and-q(e :: T, q :: Queue&lt;T&gt;)
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write out the function to use this return type.</p></blockquote></blockquote><p>Observe that this also follows our principle of making exceptional behavior
manifest in the return type: <a href="partial-domains.html#%28part._pd-option%29" data-pltdoc="x">The Option Type</a>, and especially in
<a href="partial-domains.html#%28part._pd-summary%29" data-pltdoc="x">Summary</a>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write out the function using this return type.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 8.2.3"><h4 class="heading">8.2.3<span class="stt">Â </span><a name="(part._.Using_a_.Picker)"/>Using a Picker<span class="button-group"><a href="#(part._.Using_a_.Picker)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Does <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Dequeued</code></span> look familiar? Of course it should! Itâ€™s basically the
same as the pickers used for sets in Pyret: <a href="Collections_of_Structured_Data.html#%28part._coll-sd-pick%29" data-pltdoc="x">Picking Elements from Sets</a>. If we make
queues provide the same operations, we can reuse the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Pick</code></span> library
already built into the language, and reuse any code that is written expecting
the picker interface.</p><p/><div class="SIntrapara">To do so, first we need to import the picker library:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">include pick</code></pre></div></div></div><div class="SIntrapara">Then we can write:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">dequeue :: &lt;T&gt; Queue&lt;T&gt; -&gt; Pick&lt;T, Queue&lt;T&gt;&gt;</code></pre></div></div></div><div class="SIntrapara">Here are some examples showing how it would work:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  dequeue(q_) is pick-none
  dequeue(q3) is pick-some(3, mk-mtq())
  dequeue(m43) is pick-some(3, enqueue(mk-mtq(), 4))
  dequeue(m543) is pick-some(3, enqueue(enqueue(mk-mtq(), 4), 5))
end</code></pre></div></div></div><div class="SIntrapara">And hereâ€™s the corresponding code:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun dequeue&lt;T&gt;(q):
  rev = q.l.reverse()
  cases (List) rev:
    | empty =&gt; pick-none
    | link(f, r) =&gt;
      pick-some(f, queue(r.reverse()))
  end
end</code></pre></div></div></div><div class="SIntrapara">In terms of big-O complexity, this is a dreadfully inefficient implementation,
causing two reversals on every <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">qrest</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">dequeue</code></span>. To see how to do
better, and to conduct a more sophisticated analysis, see
<a href="amortized-analysis.html#%28part._queue-data-structure%29" data-pltdoc="x">An Example: Queues from Lists</a>.</div><p>One thing to note is that by providing only a picker interface, weâ€™re slightly
changing the meaning of queues. The picker interface in Pyret is designed for
sets, which donâ€™t have a notion of order. But queues are, of course, very much
an ordered datatype; order is why they exist. So by providing <span class="emph">only</span> a
picker interface, we donâ€™t offer the very guarantee that queues are designed
for. Therefore, we should provide a picker <span class="emph">in addition to</span> an ordered
interface, rather than <span class="emph">in place of</span> one.</p><p>At this point weâ€™re done with the essential content, but here are two more
parts that you may find interesting.</p></section><section class="SsectionLevel4" id="section 8.2.4"><h4 class="heading">8.2.4<span class="stt">Â </span><a name="(part._qfl-tuples)"/>Using Tuples<span class="button-group"><a href="#(part._qfl-tuples)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Earlier, we created the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Dequeued</code></span> datatype to represent the return value
from the dequeue. Indeed, it is often useful to create datatypes of this sort
to document functions and make sure the types can be meaningfully interpreted
even when their values flow around the code some distance from where they were
created.</p><p>Sometimes, however, we want to create a compound datum in a special
circumstance: it represents the return value of a function, and that return
value will not live for very long, i.e., it will be taken apart as soon as it
has returned and only the constituent parts will be used thereafter. In such
situations, it can feel like a burden to create a new datatype for such a
fleeting purpose. For such cases, Pyret has a built-in generic datatype called
the <span style="font-style: italic">tuple</span>.</p><p/><div class="SIntrapara">Here are some examples of tuples, which illustrate their syntax; note that each
position (separated by <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">;</code></span>) takes an <span class="emph">expression</span>, not only a
constant value:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{1; 2}
{3; 4; 5}
{1 + 2; 3}
{6}
{}</code></pre></div></div></div><div class="SIntrapara">We can also pull values out of tuples as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{a; b} = {1; 2}</code></pre></div></div></div><div class="SIntrapara">Evaluate <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b</code></span> and see what they are bound to.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{c; d; e} = {1 + 2; 6 - 2; 5}</code></pre></div></div></div><div class="SIntrapara">Similarly, see what <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e</code></span> are bound to.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p/><div class="SIntrapara">What happens if we use too few or too many variables? Try out the following in
Pyret and see what happens:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{p; q} = {1}
{p} = {1; 2}
{p} = 1</code></pre></div></div></div></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">What happens if instead we write this?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p = {1; 2}</code></pre></div></div></div></blockquote></blockquote><p>This binds <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p</code></span> to the entire tuple.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>How might we pull apart the constituents of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p</code></span>?</p></blockquote></blockquote><p/><div class="SIntrapara">Now that we have tuples, we can write dequeue as:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun dequeue-tuple&lt;T&gt;(q :: Queue&lt;T&gt;) -&gt; {T; Queue&lt;T&gt;}:
  rev = q.l.reverse()
  cases (List) rev:
    | empty =&gt; raise("can't dequeue an empty queue")
    | link(f, r) =&gt;
      {f; queue(r.reverse())}
  end
end

check:
  dequeue-tuple(q3) is {3; mk-mtq()}
  dequeue-tuple(m43) is {3; enqueue(mk-mtq(), 4)}
  dequeue-tuple(m543) is {3; enqueue(enqueue(mk-mtq(), 4), 5)}
end</code></pre></div></div></div><div class="SIntrapara">And hereâ€™s how we can use it more generally:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun q2l&lt;T&gt;(q :: Queue&lt;T&gt;) -&gt; List&lt;T&gt;:
  if is-mtq(q):
    empty
  else:
    {e; rq} = dequeue-tuple(q)
    link(e, q2l(rq))
  end
end

check:
  q2l(mk-mtq()) is empty
  q2l(q3) is [list: 3]
  q2l(m43) is [list: 3, 4]
  q2l(m543) is [list: 3, 4, 5]
end</code></pre></div></div></div><div class="SIntrapara">You should feel free to use tuples in your programs provided you follow the
rules above for when tuples are applicable. In general, tuples can cause a
reduction in readability, and increase the likelihood of errors (because tuples
from one source arenâ€™t distinguishable from those from another source). Use
them with caution!</div></section><section class="SsectionLevel4" id="section 8.2.5"><h4 class="heading">8.2.5<span class="stt">Â </span><a name="(part._.A_.Picker_.Method)"/>A Picker Method<span class="button-group"><a href="#(part._.A_.Picker_.Method)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Second, and this is truly optional: you may have noticed earlier that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Set</code></span>s had a
built-in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick</code></span> method. We have a <span class="emph">function</span>, but not <span class="emph">method</span>,
that picks. Now weâ€™ll see how we can write this as a method:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Queue&lt;T&gt;:
  | queue(l :: List&lt;T&gt;) with:
    method pick(self):
      rev = self.l.reverse()
      cases (List) rev:
        | empty =&gt; pick-none
        | link(f, r) =&gt;
          pick-some(f, queue(r.reverse()))
      end
    end
end</code></pre></div></div></div><div class="SIntrapara">This is a drop-in replacement for our previous definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Queue</code></span>,
because weâ€™ve added a method but left the general datatype structure intact, so
all our existing code will still work. In addition, we can rewrite <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">q2l</code></span> in terms
of the picker interface:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun q2lm&lt;T&gt;(c :: Queue&lt;T&gt;) -&gt; List&lt;T&gt;:
  cases (Pick) c.pick():
    | pick-none =&gt; empty
    | pick-some(e, r) =&gt; link(e, q2lm(r))
  end
end

check:
  q2lm(m543)
end</code></pre></div></div></div><div class="SIntrapara">We can also write generic programs over data that support the Pick interface. For instance, hereâ€™s a function that will convert anything satisfying that interface into a list:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pick2l&lt;T&gt;(c) -&gt; List&lt;T&gt;:
  cases (Pick) c.pick():
    | pick-none =&gt; empty
    | pick-some(e, r) =&gt; link(e, pick2l(r))
  end
end</code></pre></div></div></div><div class="SIntrapara">For instance, it works on both sets and our new <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Queue</code></span>s:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import sets as S    # put this at the top of the file

check:
  pick2l([S.set: 3, 4, 5]).sort() is [list: 3, 4, 5]
  pick2l(m543) is [list: 3, 4, 5]
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Do you see why we invoked <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sort</code></span> in the test above?</p></blockquote></blockquote><p>The only weakness here is that for this last part (making the function
generic), we have to transition out of the type-checker, because <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick2l</code></span>
cannot be typed by the current Pyret type checker. It requires a feature that
the type checker does not (yet) have.</p></section>&#13;
<h4 class="heading">8.2.1<span class="stt">Â </span><a name="(part._.Using_a_.Wrapper_.Datatype)"/>Using a Wrapper Datatype<span class="button-group"><a href="#(part._.Using_a_.Wrapper_.Datatype)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Concretely, hereâ€™s how weâ€™ll represent queues. For all the code that follows,
itâ€™s helpful to use the Pyret type-checker to make sure weâ€™re composing code
correctly:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Queue&lt;T&gt;:
  | queue(l :: List&lt;T&gt;)
end</code></pre></div></div></div><div class="SIntrapara">With this encoding, we can start define a few helper functions: e.g., a way to
construct an empty queue and to check for emptiness:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun mk-mtq&lt;T&gt;() -&gt; Queue&lt;T&gt;:
  queue(empty)
end

fun is-mtq&lt;T&gt;(q :: Queue&lt;T&gt;) -&gt; Boolean:
  is-empty(q.l)
end</code></pre></div></div></div><div class="SIntrapara">Adding an element to a queue is usually called â€œenqueueingâ€. It has this type:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">enqueue :: &lt;T&gt; Queue&lt;T&gt;, T -&gt; Queue&lt;T&gt;</code></pre></div></div></div><div class="SIntrapara">Hereâ€™s the corresponding implementation:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun enqueue(q, e):
  queue(link(e, q.l))
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Did we have a choice?</p></blockquote></blockquote><p>Yes, we did! We could have made the new element the <span class="emph">first</span> element or the
<span class="emph">last</span> element.<span class="refelem"><span class="refcolumn"><span class="refcontent">Be careful here: we mean the first or last
element of <span class="emph">the list that represents the queue</span>, not of the queue
itself. There, <span class="Smaller">FIFO</span> gives us no choice.</span></span></span> We just happened to choose one
representation. The other would be equally valid; we would just need to
implement all the other operations consistently. Letâ€™s stick to this one for
now.</p><p/><div class="SIntrapara">Now we come to a problem. What does it mean to â€œdequeueâ€? We need to get back
the one element, but we also need to get back the rest. Letâ€™s first write this
as two functions, very analogous to first and rest on lists:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">qpeek :: &lt;T&gt; Queue&lt;T&gt; -&gt; T
qrest :: &lt;T&gt; Queue&lt;T&gt; -&gt; Queue&lt;T&gt;</code></pre></div></div></div><div class="SIntrapara">Letâ€™s write out a few examples to make sure we know how these should work:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">q_ = mk-mtq()
q3 = enqueue(q_, 3)
m43 = enqueue(q3, 4)
m543 = enqueue(m43, 5)

check:
  qpeek(q3) is 3
  qpeek(m43) is 3
  qpeek(m543) is 3
end

check:
  qrest(q3) is mk-mtq()
  qrest(m43) is enqueue(mk-mtq(), 4)
  qrest(m543) is enqueue(enqueue(mk-mtq(), 4), 5)
end</code></pre></div></div></div><div class="SIntrapara">Now letâ€™s implement these:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun qpeek(q):
  if is-mtq(q):
    raise("can't peek an empty queue")
  else:
    q.l.get(q.l.length() - 1)
  end
end

fun qrest(q):
  fun safe-rest(l :: List&lt;T&gt;) -&gt; List&lt;T&gt;:
    cases (List) l:
      | empty =&gt; raise("can't dequeue an empty queue")
      | link(f, r) =&gt; r
    end
  end
  queue(safe-rest(q.l.reverse()).reverse())
end</code></pre></div></div></div>&#13;
<h4 class="heading">8.2.2<span class="stt">Â </span><a name="(part._qfl-comb-ans)"/>Combining Answers<span class="button-group"><a href="#(part._qfl-comb-ans)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">However, it would be nice if we could obtain both the oldest element and the
rest of the queue at once, if we want them both. That means the single function
would need to return two values; since a function can return only one value at
a time, it would need to use a data structure to hold both of
them. Furthermore, note that both <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">qpeek</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">qrest</code></span> above have the
possibility of not having any more elements! We might as well reflect that too
in the type. Thus we end up with a type that looks like
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Dequeued&lt;T&gt;:
  | none-left
  | elt-and-q(e :: T, q :: Queue&lt;T&gt;)
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write out the function to use this return type.</p></blockquote></blockquote><p>Observe that this also follows our principle of making exceptional behavior
manifest in the return type: <a href="partial-domains.html#%28part._pd-option%29" data-pltdoc="x">The Option Type</a>, and especially in
<a href="partial-domains.html#%28part._pd-summary%29" data-pltdoc="x">Summary</a>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write out the function using this return type.</p></blockquote></blockquote>&#13;
<h4 class="heading">8.2.3<span class="stt">Â </span><a name="(part._.Using_a_.Picker)"/>Using a Picker<span class="button-group"><a href="#(part._.Using_a_.Picker)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Does <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Dequeued</code></span> look familiar? Of course it should! Itâ€™s basically the
same as the pickers used for sets in Pyret: <a href="Collections_of_Structured_Data.html#%28part._coll-sd-pick%29" data-pltdoc="x">Picking Elements from Sets</a>. If we make
queues provide the same operations, we can reuse the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Pick</code></span> library
already built into the language, and reuse any code that is written expecting
the picker interface.</p><p/><div class="SIntrapara">To do so, first we need to import the picker library:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">include pick</code></pre></div></div></div><div class="SIntrapara">Then we can write:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">dequeue :: &lt;T&gt; Queue&lt;T&gt; -&gt; Pick&lt;T, Queue&lt;T&gt;&gt;</code></pre></div></div></div><div class="SIntrapara">Here are some examples showing how it would work:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  dequeue(q_) is pick-none
  dequeue(q3) is pick-some(3, mk-mtq())
  dequeue(m43) is pick-some(3, enqueue(mk-mtq(), 4))
  dequeue(m543) is pick-some(3, enqueue(enqueue(mk-mtq(), 4), 5))
end</code></pre></div></div></div><div class="SIntrapara">And hereâ€™s the corresponding code:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun dequeue&lt;T&gt;(q):
  rev = q.l.reverse()
  cases (List) rev:
    | empty =&gt; pick-none
    | link(f, r) =&gt;
      pick-some(f, queue(r.reverse()))
  end
end</code></pre></div></div></div><div class="SIntrapara">In terms of big-O complexity, this is a dreadfully inefficient implementation,
causing two reversals on every <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">qrest</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">dequeue</code></span>. To see how to do
better, and to conduct a more sophisticated analysis, see
<a href="amortized-analysis.html#%28part._queue-data-structure%29" data-pltdoc="x">An Example: Queues from Lists</a>.</div><p>One thing to note is that by providing only a picker interface, weâ€™re slightly
changing the meaning of queues. The picker interface in Pyret is designed for
sets, which donâ€™t have a notion of order. But queues are, of course, very much
an ordered datatype; order is why they exist. So by providing <span class="emph">only</span> a
picker interface, we donâ€™t offer the very guarantee that queues are designed
for. Therefore, we should provide a picker <span class="emph">in addition to</span> an ordered
interface, rather than <span class="emph">in place of</span> one.</p><p>At this point weâ€™re done with the essential content, but here are two more
parts that you may find interesting.</p>&#13;
<h4 class="heading">8.2.4<span class="stt">Â </span><a name="(part._qfl-tuples)"/>Using Tuples<span class="button-group"><a href="#(part._qfl-tuples)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Earlier, we created the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Dequeued</code></span> datatype to represent the return value
from the dequeue. Indeed, it is often useful to create datatypes of this sort
to document functions and make sure the types can be meaningfully interpreted
even when their values flow around the code some distance from where they were
created.</p><p>Sometimes, however, we want to create a compound datum in a special
circumstance: it represents the return value of a function, and that return
value will not live for very long, i.e., it will be taken apart as soon as it
has returned and only the constituent parts will be used thereafter. In such
situations, it can feel like a burden to create a new datatype for such a
fleeting purpose. For such cases, Pyret has a built-in generic datatype called
the <span style="font-style: italic">tuple</span>.</p><p/><div class="SIntrapara">Here are some examples of tuples, which illustrate their syntax; note that each
position (separated by <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">;</code></span>) takes an <span class="emph">expression</span>, not only a
constant value:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{1; 2}
{3; 4; 5}
{1 + 2; 3}
{6}
{}</code></pre></div></div></div><div class="SIntrapara">We can also pull values out of tuples as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{a; b} = {1; 2}</code></pre></div></div></div><div class="SIntrapara">Evaluate <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b</code></span> and see what they are bound to.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{c; d; e} = {1 + 2; 6 - 2; 5}</code></pre></div></div></div><div class="SIntrapara">Similarly, see what <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">d</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e</code></span> are bound to.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p/><div class="SIntrapara">What happens if we use too few or too many variables? Try out the following in
Pyret and see what happens:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{p; q} = {1}
{p} = {1; 2}
{p} = 1</code></pre></div></div></div></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">What happens if instead we write this?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p = {1; 2}</code></pre></div></div></div></blockquote></blockquote><p>This binds <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p</code></span> to the entire tuple.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>How might we pull apart the constituents of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p</code></span>?</p></blockquote></blockquote><p/><div class="SIntrapara">Now that we have tuples, we can write dequeue as:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun dequeue-tuple&lt;T&gt;(q :: Queue&lt;T&gt;) -&gt; {T; Queue&lt;T&gt;}:
  rev = q.l.reverse()
  cases (List) rev:
    | empty =&gt; raise("can't dequeue an empty queue")
    | link(f, r) =&gt;
      {f; queue(r.reverse())}
  end
end

check:
  dequeue-tuple(q3) is {3; mk-mtq()}
  dequeue-tuple(m43) is {3; enqueue(mk-mtq(), 4)}
  dequeue-tuple(m543) is {3; enqueue(enqueue(mk-mtq(), 4), 5)}
end</code></pre></div></div></div><div class="SIntrapara">And hereâ€™s how we can use it more generally:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun q2l&lt;T&gt;(q :: Queue&lt;T&gt;) -&gt; List&lt;T&gt;:
  if is-mtq(q):
    empty
  else:
    {e; rq} = dequeue-tuple(q)
    link(e, q2l(rq))
  end
end

check:
  q2l(mk-mtq()) is empty
  q2l(q3) is [list: 3]
  q2l(m43) is [list: 3, 4]
  q2l(m543) is [list: 3, 4, 5]
end</code></pre></div></div></div><div class="SIntrapara">You should feel free to use tuples in your programs provided you follow the
rules above for when tuples are applicable. In general, tuples can cause a
reduction in readability, and increase the likelihood of errors (because tuples
from one source arenâ€™t distinguishable from those from another source). Use
them with caution!</div>&#13;
<h4 class="heading">8.2.5<span class="stt">Â </span><a name="(part._.A_.Picker_.Method)"/>A Picker Method<span class="button-group"><a href="#(part._.A_.Picker_.Method)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Second, and this is truly optional: you may have noticed earlier that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Set</code></span>s had a
built-in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick</code></span> method. We have a <span class="emph">function</span>, but not <span class="emph">method</span>,
that picks. Now weâ€™ll see how we can write this as a method:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Queue&lt;T&gt;:
  | queue(l :: List&lt;T&gt;) with:
    method pick(self):
      rev = self.l.reverse()
      cases (List) rev:
        | empty =&gt; pick-none
        | link(f, r) =&gt;
          pick-some(f, queue(r.reverse()))
      end
    end
end</code></pre></div></div></div><div class="SIntrapara">This is a drop-in replacement for our previous definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Queue</code></span>,
because weâ€™ve added a method but left the general datatype structure intact, so
all our existing code will still work. In addition, we can rewrite <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">q2l</code></span> in terms
of the picker interface:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun q2lm&lt;T&gt;(c :: Queue&lt;T&gt;) -&gt; List&lt;T&gt;:
  cases (Pick) c.pick():
    | pick-none =&gt; empty
    | pick-some(e, r) =&gt; link(e, q2lm(r))
  end
end

check:
  q2lm(m543)
end</code></pre></div></div></div><div class="SIntrapara">We can also write generic programs over data that support the Pick interface. For instance, hereâ€™s a function that will convert anything satisfying that interface into a list:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pick2l&lt;T&gt;(c) -&gt; List&lt;T&gt;:
  cases (Pick) c.pick():
    | pick-none =&gt; empty
    | pick-some(e, r) =&gt; link(e, pick2l(r))
  end
end</code></pre></div></div></div><div class="SIntrapara">For instance, it works on both sets and our new <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Queue</code></span>s:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import sets as S    # put this at the top of the file

check:
  pick2l([S.set: 3, 4, 5]).sort() is [list: 3, 4, 5]
  pick2l(m543) is [list: 3, 4, 5]
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Do you see why we invoked <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sort</code></span> in the test above?</p></blockquote></blockquote><p>The only weakness here is that for this last part (making the function
generic), we have to transition out of the type-checker, because <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick2l</code></span>
cannot be typed by the current Pyret type checker. It requires a feature that
the type checker does not (yet) have.</p>    
</body>
</html>