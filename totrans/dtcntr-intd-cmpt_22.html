<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>8.2Â Queues from ListsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>8.2Â Queues from ListsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/queues-from-lists.html">https://dcic-world.org/2025-08-27/queues-from-lists.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._.Using_a_.Wrapper_.Datatype%29" class="toclink" data-pltdoc="x">8.2.1Â Using a Wrapper Datatype</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._qfl-comb-ans%29" class="toclink" data-pltdoc="x">8.2.2Â Combining Answers</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Using_a_.Picker%29" class="toclink" data-pltdoc="x">8.2.3Â Using a Picker</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._qfl-tuples%29" class="toclink" data-pltdoc="x">8.2.4Â Using Tuples</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.A_.Picker_.Method%29" class="toclink" data-pltdoc="x">8.2.5Â A Picker Method</a></p></td></tr></table><p>Suppose you have a list. When you take its first element, you get the
element that was most recently <code data-lang="pyret" class="sourceCode">link</code>ed to create it. The next element is the
second most recent one that was <code data-lang="pyret" class="sourceCode">link</code>ed, and so on. That is, the last one in is
the first one out. This is called a LIFO, short for â€œlast-in-first-outâ€, data
structure. A list is LIFO; we sometimes also refer to this as a stack.</p><p>But there are many settings where you want the first-in to be the
first-out. When you stand at a supermarket line, try to purchase concert
tickets, submit a job request, or any number of other tasks, you want to be
rewarded, not punished, for being there first. That is, you want a FIFO instead. This
is called a queue.</p><p>The game weâ€™re playing here is that we want one datatype but our language has
given us another (in this case, lists), and we have to figure out how to encode
one in the other. Weâ€™ll see elsewhere how to encode sets with lists
[<a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>]. Here letâ€™s see how we can encode queues with lists.</p><p>With sets, we allowed the set type to be an alias for lists; that is, the two
were the same. Another option we have when encoding is to create a completely
new type that does nothing more than wrap a value of the encoding type. Weâ€™ll
use that principle here to illustrate how that might work.</p><section class="SsectionLevel4" id="section 8.2.1"><h4 class="heading">8.2.1Â <a name="(part._.Using_a_.Wrapper_.Datatype)"/>Using a Wrapper Datatype<a href="#(part._.Using_a_.Wrapper_.Datatype)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Concretely, hereâ€™s how weâ€™ll represent queues. For all the code that follows,
itâ€™s helpful to use the Pyret type-checker to make sure weâ€™re composing code
correctly:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Queue&lt;T&gt;:
  | queue(l :: List&lt;T&gt;)
end</code></pre><p>With this encoding, we can start define a few helper functions: e.g., a way to
construct an empty queue and to check for emptiness:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun mk-mtq&lt;T&gt;() -&gt; Queue&lt;T&gt;:
  queue(empty)
end

fun is-mtq&lt;T&gt;(q :: Queue&lt;T&gt;) -&gt; Boolean:
  is-empty(q.l)
end</code></pre><p>Adding an element to a queue is usually called â€œenqueueingâ€. It has this type:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">enqueue :: &lt;T&gt; Queue&lt;T&gt;, T -&gt; Queue&lt;T&gt;</code></pre><p>Hereâ€™s the corresponding implementation:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun enqueue(q, e):
  queue(link(e, q.l))
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Did we have a choice?</p></blockquote></blockquote><p>Yes, we did! We could have made the new element the first element or the
last element.Be careful here: we mean the first or last
element of the list that represents the queue, not of the queue
itself. There, FIFO gives us no choice. We just happened to choose one
representation. The other would be equally valid; we would just need to
implement all the other operations consistently. Letâ€™s stick to this one for
now.</p><p>Now we come to a problem. What does it mean to â€œdequeueâ€? We need to get back
the one element, but we also need to get back the rest. Letâ€™s first write this
as two functions, very analogous to first and rest on lists:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">qpeek :: &lt;T&gt; Queue&lt;T&gt; -&gt; T
qrest :: &lt;T&gt; Queue&lt;T&gt; -&gt; Queue&lt;T&gt;</code></pre><p>Letâ€™s write out a few examples to make sure we know how these should work:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">q_ = mk-mtq()
q3 = enqueue(q_, 3)
m43 = enqueue(q3, 4)
m543 = enqueue(m43, 5)

check:
  qpeek(q3) is 3
  qpeek(m43) is 3
  qpeek(m543) is 3
end

check:
  qrest(q3) is mk-mtq()
  qrest(m43) is enqueue(mk-mtq(), 4)
  qrest(m543) is enqueue(enqueue(mk-mtq(), 4), 5)
end</code></pre><p>Now letâ€™s implement these:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun qpeek(q):
  if is-mtq(q):
    raise("can't peek an empty queue")
  else:
    q.l.get(q.l.length() - 1)
  end
end

fun qrest(q):
  fun safe-rest(l :: List&lt;T&gt;) -&gt; List&lt;T&gt;:
    cases (List) l:
      | empty =&gt; raise("can't dequeue an empty queue")
      | link(f, r) =&gt; r
    end
  end
  queue(safe-rest(q.l.reverse()).reverse())
end</code></pre></section><section class="SsectionLevel4" id="section 8.2.2"><h4 class="heading">8.2.2Â <a name="(part._qfl-comb-ans)"/>Combining Answers<a href="#(part._qfl-comb-ans)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>However, it would be nice if we could obtain both the oldest element and the
rest of the queue at once, if we want them both. That means the single function
would need to return two values; since a function can return only one value at
a time, it would need to use a data structure to hold both of
them. Furthermore, note that both <code data-lang="pyret" class="sourceCode">qpeek</code> and <code data-lang="pyret" class="sourceCode">qrest</code> above have the
possibility of not having any more elements! We might as well reflect that too
in the type. Thus we end up with a type that looks like
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Dequeued&lt;T&gt;:
  | none-left
  | elt-and-q(e :: T, q :: Queue&lt;T&gt;)
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write out the function to use this return type.</p></blockquote></blockquote><p>Observe that this also follows our principle of making exceptional behavior
manifest in the return type: <a href="partial-domains.html#%28part._pd-option%29" data-pltdoc="x">The Option Type</a>, and especially in
<a href="partial-domains.html#%28part._pd-summary%29" data-pltdoc="x">Summary</a>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write out the function using this return type.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 8.2.3"><h4 class="heading">8.2.3Â <a name="(part._.Using_a_.Picker)"/>Using a Picker<a href="#(part._.Using_a_.Picker)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Does <code data-lang="pyret" class="sourceCode">Dequeued</code> look familiar? Of course it should! Itâ€™s basically the
same as the pickers used for sets in Pyret: <a href="Collections_of_Structured_Data.html#%28part._coll-sd-pick%29" data-pltdoc="x">Picking Elements from Sets</a>. If we make
queues provide the same operations, we can reuse the <code data-lang="pyret" class="sourceCode">Pick</code> library
already built into the language, and reuse any code that is written expecting
the picker interface.</p><p>To do so, first we need to import the picker library:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">include pick</code></pre><p>Then we can write:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">dequeue :: &lt;T&gt; Queue&lt;T&gt; -&gt; Pick&lt;T, Queue&lt;T&gt;&gt;</code></pre><p>Here are some examples showing how it would work:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  dequeue(q_) is pick-none
  dequeue(q3) is pick-some(3, mk-mtq())
  dequeue(m43) is pick-some(3, enqueue(mk-mtq(), 4))
  dequeue(m543) is pick-some(3, enqueue(enqueue(mk-mtq(), 4), 5))
end</code></pre><p>And hereâ€™s the corresponding code:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun dequeue&lt;T&gt;(q):
  rev = q.l.reverse()
  cases (List) rev:
    | empty =&gt; pick-none
    | link(f, r) =&gt;
      pick-some(f, queue(r.reverse()))
  end
end</code></pre><p>In terms of big-O complexity, this is a dreadfully inefficient implementation,
causing two reversals on every <code data-lang="pyret" class="sourceCode">qrest</code> or <code data-lang="pyret" class="sourceCode">dequeue</code>. To see how to do
better, and to conduct a more sophisticated analysis, see
<a href="amortized-analysis.html#%28part._queue-data-structure%29" data-pltdoc="x">An Example: Queues from Lists</a>.</p><p>One thing to note is that by providing only a picker interface, weâ€™re slightly
changing the meaning of queues. The picker interface in Pyret is designed for
sets, which donâ€™t have a notion of order. But queues are, of course, very much
an ordered datatype; order is why they exist. So by providing only a
picker interface, we donâ€™t offer the very guarantee that queues are designed
for. Therefore, we should provide a picker in addition to an ordered
interface, rather than in place of one.</p><p>At this point weâ€™re done with the essential content, but here are two more
parts that you may find interesting.</p></section><section class="SsectionLevel4" id="section 8.2.4"><h4 class="heading">8.2.4Â <a name="(part._qfl-tuples)"/>Using Tuples<a href="#(part._qfl-tuples)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Earlier, we created the <code data-lang="pyret" class="sourceCode">Dequeued</code> datatype to represent the return value
from the dequeue. Indeed, it is often useful to create datatypes of this sort
to document functions and make sure the types can be meaningfully interpreted
even when their values flow around the code some distance from where they were
created.</p><p>Sometimes, however, we want to create a compound datum in a special
circumstance: it represents the return value of a function, and that return
value will not live for very long, i.e., it will be taken apart as soon as it
has returned and only the constituent parts will be used thereafter. In such
situations, it can feel like a burden to create a new datatype for such a
fleeting purpose. For such cases, Pyret has a built-in generic datatype called
the tuple.</p><p>Here are some examples of tuples, which illustrate their syntax; note that each
position (separated by <code data-lang="pyret" class="sourceCode">;</code>) takes an expression, not only a
constant value:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{1; 2}
{3; 4; 5}
{1 + 2; 3}
{6}
{}</code></pre><p>We can also pull values out of tuples as follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{a; b} = {1; 2}</code></pre><p>Evaluate <code data-lang="pyret" class="sourceCode">a</code> and <code data-lang="pyret" class="sourceCode">b</code> and see what they are bound to.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{c; d; e} = {1 + 2; 6 - 2; 5}</code></pre><p>Similarly, see what <code data-lang="pyret" class="sourceCode">c</code>, <code data-lang="pyret" class="sourceCode">d</code>, and <code data-lang="pyret" class="sourceCode">e</code> are bound to.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>What happens if we use too few or too many variables? Try out the following in
Pyret and see what happens:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{p; q} = {1}
{p} = {1; 2}
{p} = 1</code></pre></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What happens if instead we write this?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p = {1; 2}</code></pre></blockquote></blockquote><p>This binds <code data-lang="pyret" class="sourceCode">p</code> to the entire tuple.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>How might we pull apart the constituents of <code data-lang="pyret" class="sourceCode">p</code>?</p></blockquote></blockquote><p>Now that we have tuples, we can write dequeue as:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun dequeue-tuple&lt;T&gt;(q :: Queue&lt;T&gt;) -&gt; {T; Queue&lt;T&gt;}:
  rev = q.l.reverse()
  cases (List) rev:
    | empty =&gt; raise("can't dequeue an empty queue")
    | link(f, r) =&gt;
      {f; queue(r.reverse())}
  end
end

check:
  dequeue-tuple(q3) is {3; mk-mtq()}
  dequeue-tuple(m43) is {3; enqueue(mk-mtq(), 4)}
  dequeue-tuple(m543) is {3; enqueue(enqueue(mk-mtq(), 4), 5)}
end</code></pre><p>And hereâ€™s how we can use it more generally:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun q2l&lt;T&gt;(q :: Queue&lt;T&gt;) -&gt; List&lt;T&gt;:
  if is-mtq(q):
    empty
  else:
    {e; rq} = dequeue-tuple(q)
    link(e, q2l(rq))
  end
end

check:
  q2l(mk-mtq()) is empty
  q2l(q3) is [list: 3]
  q2l(m43) is [list: 3, 4]
  q2l(m543) is [list: 3, 4, 5]
end</code></pre><p>You should feel free to use tuples in your programs provided you follow the
rules above for when tuples are applicable. In general, tuples can cause a
reduction in readability, and increase the likelihood of errors (because tuples
from one source arenâ€™t distinguishable from those from another source). Use
them with caution!</p></section><section class="SsectionLevel4" id="section 8.2.5"><h4 class="heading">8.2.5Â <a name="(part._.A_.Picker_.Method)"/>A Picker Method<a href="#(part._.A_.Picker_.Method)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Second, and this is truly optional: you may have noticed earlier that <code data-lang="pyret" class="sourceCode">Set</code>s had a
built-in <code data-lang="pyret" class="sourceCode">pick</code> method. We have a function, but not method,
that picks. Now weâ€™ll see how we can write this as a method:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Queue&lt;T&gt;:
  | queue(l :: List&lt;T&gt;) with:
    method pick(self):
      rev = self.l.reverse()
      cases (List) rev:
        | empty =&gt; pick-none
        | link(f, r) =&gt;
          pick-some(f, queue(r.reverse()))
      end
    end
end</code></pre><p>This is a drop-in replacement for our previous definition of <code data-lang="pyret" class="sourceCode">Queue</code>,
because weâ€™ve added a method but left the general datatype structure intact, so
all our existing code will still work. In addition, we can rewrite <code data-lang="pyret" class="sourceCode">q2l</code> in terms
of the picker interface:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun q2lm&lt;T&gt;(c :: Queue&lt;T&gt;) -&gt; List&lt;T&gt;:
  cases (Pick) c.pick():
    | pick-none =&gt; empty
    | pick-some(e, r) =&gt; link(e, q2lm(r))
  end
end

check:
  q2lm(m543)
end</code></pre><p>We can also write generic programs over data that support the Pick interface. For instance, hereâ€™s a function that will convert anything satisfying that interface into a list:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pick2l&lt;T&gt;(c) -&gt; List&lt;T&gt;:
  cases (Pick) c.pick():
    | pick-none =&gt; empty
    | pick-some(e, r) =&gt; link(e, pick2l(r))
  end
end</code></pre><p>For instance, it works on both sets and our new <code data-lang="pyret" class="sourceCode">Queue</code>s:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import sets as S    # put this at the top of the file

check:
  pick2l([S.set: 3, 4, 5]).sort() is [list: 3, 4, 5]
  pick2l(m543) is [list: 3, 4, 5]
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Do you see why we invoked <code data-lang="pyret" class="sourceCode">sort</code> in the test above?</p></blockquote></blockquote><p>The only weakness here is that for this last part (making the function
generic), we have to transition out of the type-checker, because <code data-lang="pyret" class="sourceCode">pick2l</code>
cannot be typed by the current Pyret type checker. It requires a feature that
the type checker does not (yet) have.</p></section>&#13;
<h4 class="heading">8.2.1Â <a name="(part._.Using_a_.Wrapper_.Datatype)"/>Using a Wrapper Datatype<a href="#(part._.Using_a_.Wrapper_.Datatype)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Concretely, hereâ€™s how weâ€™ll represent queues. For all the code that follows,
itâ€™s helpful to use the Pyret type-checker to make sure weâ€™re composing code
correctly:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Queue&lt;T&gt;:
  | queue(l :: List&lt;T&gt;)
end</code></pre><p>With this encoding, we can start define a few helper functions: e.g., a way to
construct an empty queue and to check for emptiness:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun mk-mtq&lt;T&gt;() -&gt; Queue&lt;T&gt;:
  queue(empty)
end

fun is-mtq&lt;T&gt;(q :: Queue&lt;T&gt;) -&gt; Boolean:
  is-empty(q.l)
end</code></pre><p>Adding an element to a queue is usually called â€œenqueueingâ€. It has this type:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">enqueue :: &lt;T&gt; Queue&lt;T&gt;, T -&gt; Queue&lt;T&gt;</code></pre><p>Hereâ€™s the corresponding implementation:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun enqueue(q, e):
  queue(link(e, q.l))
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Did we have a choice?</p></blockquote></blockquote><p>Yes, we did! We could have made the new element the first element or the
last element.Be careful here: we mean the first or last
element of the list that represents the queue, not of the queue
itself. There, FIFO gives us no choice. We just happened to choose one
representation. The other would be equally valid; we would just need to
implement all the other operations consistently. Letâ€™s stick to this one for
now.</p><p>Now we come to a problem. What does it mean to â€œdequeueâ€? We need to get back
the one element, but we also need to get back the rest. Letâ€™s first write this
as two functions, very analogous to first and rest on lists:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">qpeek :: &lt;T&gt; Queue&lt;T&gt; -&gt; T
qrest :: &lt;T&gt; Queue&lt;T&gt; -&gt; Queue&lt;T&gt;</code></pre><p>Letâ€™s write out a few examples to make sure we know how these should work:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">q_ = mk-mtq()
q3 = enqueue(q_, 3)
m43 = enqueue(q3, 4)
m543 = enqueue(m43, 5)

check:
  qpeek(q3) is 3
  qpeek(m43) is 3
  qpeek(m543) is 3
end

check:
  qrest(q3) is mk-mtq()
  qrest(m43) is enqueue(mk-mtq(), 4)
  qrest(m543) is enqueue(enqueue(mk-mtq(), 4), 5)
end</code></pre><p>Now letâ€™s implement these:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun qpeek(q):
  if is-mtq(q):
    raise("can't peek an empty queue")
  else:
    q.l.get(q.l.length() - 1)
  end
end

fun qrest(q):
  fun safe-rest(l :: List&lt;T&gt;) -&gt; List&lt;T&gt;:
    cases (List) l:
      | empty =&gt; raise("can't dequeue an empty queue")
      | link(f, r) =&gt; r
    end
  end
  queue(safe-rest(q.l.reverse()).reverse())
end</code></pre>&#13;
<h4 class="heading">8.2.2Â <a name="(part._qfl-comb-ans)"/>Combining Answers<a href="#(part._qfl-comb-ans)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>However, it would be nice if we could obtain both the oldest element and the
rest of the queue at once, if we want them both. That means the single function
would need to return two values; since a function can return only one value at
a time, it would need to use a data structure to hold both of
them. Furthermore, note that both <code data-lang="pyret" class="sourceCode">qpeek</code> and <code data-lang="pyret" class="sourceCode">qrest</code> above have the
possibility of not having any more elements! We might as well reflect that too
in the type. Thus we end up with a type that looks like
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Dequeued&lt;T&gt;:
  | none-left
  | elt-and-q(e :: T, q :: Queue&lt;T&gt;)
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write out the function to use this return type.</p></blockquote></blockquote><p>Observe that this also follows our principle of making exceptional behavior
manifest in the return type: <a href="partial-domains.html#%28part._pd-option%29" data-pltdoc="x">The Option Type</a>, and especially in
<a href="partial-domains.html#%28part._pd-summary%29" data-pltdoc="x">Summary</a>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write out the function using this return type.</p></blockquote></blockquote>&#13;
<h4 class="heading">8.2.3Â <a name="(part._.Using_a_.Picker)"/>Using a Picker<a href="#(part._.Using_a_.Picker)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Does <code data-lang="pyret" class="sourceCode">Dequeued</code> look familiar? Of course it should! Itâ€™s basically the
same as the pickers used for sets in Pyret: <a href="Collections_of_Structured_Data.html#%28part._coll-sd-pick%29" data-pltdoc="x">Picking Elements from Sets</a>. If we make
queues provide the same operations, we can reuse the <code data-lang="pyret" class="sourceCode">Pick</code> library
already built into the language, and reuse any code that is written expecting
the picker interface.</p><p>To do so, first we need to import the picker library:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">include pick</code></pre><p>Then we can write:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">dequeue :: &lt;T&gt; Queue&lt;T&gt; -&gt; Pick&lt;T, Queue&lt;T&gt;&gt;</code></pre><p>Here are some examples showing how it would work:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  dequeue(q_) is pick-none
  dequeue(q3) is pick-some(3, mk-mtq())
  dequeue(m43) is pick-some(3, enqueue(mk-mtq(), 4))
  dequeue(m543) is pick-some(3, enqueue(enqueue(mk-mtq(), 4), 5))
end</code></pre><p>And hereâ€™s the corresponding code:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun dequeue&lt;T&gt;(q):
  rev = q.l.reverse()
  cases (List) rev:
    | empty =&gt; pick-none
    | link(f, r) =&gt;
      pick-some(f, queue(r.reverse()))
  end
end</code></pre><p>In terms of big-O complexity, this is a dreadfully inefficient implementation,
causing two reversals on every <code data-lang="pyret" class="sourceCode">qrest</code> or <code data-lang="pyret" class="sourceCode">dequeue</code>. To see how to do
better, and to conduct a more sophisticated analysis, see
<a href="amortized-analysis.html#%28part._queue-data-structure%29" data-pltdoc="x">An Example: Queues from Lists</a>.</p><p>One thing to note is that by providing only a picker interface, weâ€™re slightly
changing the meaning of queues. The picker interface in Pyret is designed for
sets, which donâ€™t have a notion of order. But queues are, of course, very much
an ordered datatype; order is why they exist. So by providing only a
picker interface, we donâ€™t offer the very guarantee that queues are designed
for. Therefore, we should provide a picker in addition to an ordered
interface, rather than in place of one.</p><p>At this point weâ€™re done with the essential content, but here are two more
parts that you may find interesting.</p>&#13;
<h4 class="heading">8.2.4Â <a name="(part._qfl-tuples)"/>Using Tuples<a href="#(part._qfl-tuples)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Earlier, we created the <code data-lang="pyret" class="sourceCode">Dequeued</code> datatype to represent the return value
from the dequeue. Indeed, it is often useful to create datatypes of this sort
to document functions and make sure the types can be meaningfully interpreted
even when their values flow around the code some distance from where they were
created.</p><p>Sometimes, however, we want to create a compound datum in a special
circumstance: it represents the return value of a function, and that return
value will not live for very long, i.e., it will be taken apart as soon as it
has returned and only the constituent parts will be used thereafter. In such
situations, it can feel like a burden to create a new datatype for such a
fleeting purpose. For such cases, Pyret has a built-in generic datatype called
the tuple.</p><p>Here are some examples of tuples, which illustrate their syntax; note that each
position (separated by <code data-lang="pyret" class="sourceCode">;</code>) takes an expression, not only a
constant value:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{1; 2}
{3; 4; 5}
{1 + 2; 3}
{6}
{}</code></pre><p>We can also pull values out of tuples as follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{a; b} = {1; 2}</code></pre><p>Evaluate <code data-lang="pyret" class="sourceCode">a</code> and <code data-lang="pyret" class="sourceCode">b</code> and see what they are bound to.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{c; d; e} = {1 + 2; 6 - 2; 5}</code></pre><p>Similarly, see what <code data-lang="pyret" class="sourceCode">c</code>, <code data-lang="pyret" class="sourceCode">d</code>, and <code data-lang="pyret" class="sourceCode">e</code> are bound to.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>What happens if we use too few or too many variables? Try out the following in
Pyret and see what happens:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">{p; q} = {1}
{p} = {1; 2}
{p} = 1</code></pre></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What happens if instead we write this?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p = {1; 2}</code></pre></blockquote></blockquote><p>This binds <code data-lang="pyret" class="sourceCode">p</code> to the entire tuple.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>How might we pull apart the constituents of <code data-lang="pyret" class="sourceCode">p</code>?</p></blockquote></blockquote><p>Now that we have tuples, we can write dequeue as:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun dequeue-tuple&lt;T&gt;(q :: Queue&lt;T&gt;) -&gt; {T; Queue&lt;T&gt;}:
  rev = q.l.reverse()
  cases (List) rev:
    | empty =&gt; raise("can't dequeue an empty queue")
    | link(f, r) =&gt;
      {f; queue(r.reverse())}
  end
end

check:
  dequeue-tuple(q3) is {3; mk-mtq()}
  dequeue-tuple(m43) is {3; enqueue(mk-mtq(), 4)}
  dequeue-tuple(m543) is {3; enqueue(enqueue(mk-mtq(), 4), 5)}
end</code></pre><p>And hereâ€™s how we can use it more generally:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun q2l&lt;T&gt;(q :: Queue&lt;T&gt;) -&gt; List&lt;T&gt;:
  if is-mtq(q):
    empty
  else:
    {e; rq} = dequeue-tuple(q)
    link(e, q2l(rq))
  end
end

check:
  q2l(mk-mtq()) is empty
  q2l(q3) is [list: 3]
  q2l(m43) is [list: 3, 4]
  q2l(m543) is [list: 3, 4, 5]
end</code></pre><p>You should feel free to use tuples in your programs provided you follow the
rules above for when tuples are applicable. In general, tuples can cause a
reduction in readability, and increase the likelihood of errors (because tuples
from one source arenâ€™t distinguishable from those from another source). Use
them with caution!</p>&#13;
<h4 class="heading">8.2.5Â <a name="(part._.A_.Picker_.Method)"/>A Picker Method<a href="#(part._.A_.Picker_.Method)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Second, and this is truly optional: you may have noticed earlier that <code data-lang="pyret" class="sourceCode">Set</code>s had a
built-in <code data-lang="pyret" class="sourceCode">pick</code> method. We have a function, but not method,
that picks. Now weâ€™ll see how we can write this as a method:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Queue&lt;T&gt;:
  | queue(l :: List&lt;T&gt;) with:
    method pick(self):
      rev = self.l.reverse()
      cases (List) rev:
        | empty =&gt; pick-none
        | link(f, r) =&gt;
          pick-some(f, queue(r.reverse()))
      end
    end
end</code></pre><p>This is a drop-in replacement for our previous definition of <code data-lang="pyret" class="sourceCode">Queue</code>,
because weâ€™ve added a method but left the general datatype structure intact, so
all our existing code will still work. In addition, we can rewrite <code data-lang="pyret" class="sourceCode">q2l</code> in terms
of the picker interface:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun q2lm&lt;T&gt;(c :: Queue&lt;T&gt;) -&gt; List&lt;T&gt;:
  cases (Pick) c.pick():
    | pick-none =&gt; empty
    | pick-some(e, r) =&gt; link(e, q2lm(r))
  end
end

check:
  q2lm(m543)
end</code></pre><p>We can also write generic programs over data that support the Pick interface. For instance, hereâ€™s a function that will convert anything satisfying that interface into a list:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pick2l&lt;T&gt;(c) -&gt; List&lt;T&gt;:
  cases (Pick) c.pick():
    | pick-none =&gt; empty
    | pick-some(e, r) =&gt; link(e, pick2l(r))
  end
end</code></pre><p>For instance, it works on both sets and our new <code data-lang="pyret" class="sourceCode">Queue</code>s:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import sets as S    # put this at the top of the file

check:
  pick2l([S.set: 3, 4, 5]).sort() is [list: 3, 4, 5]
  pick2l(m543) is [list: 3, 4, 5]
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Do you see why we invoked <code data-lang="pyret" class="sourceCode">sort</code> in the test above?</p></blockquote></blockquote><p>The only weakness here is that for this last part (making the function
generic), we have to transition out of the type-checker, because <code data-lang="pyret" class="sourceCode">pick2l</code>
cannot be typed by the current Pyret type checker. It requires a feature that
the type checker does not (yet) have.</p>    
</body>
</html>