<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>5.2Â Processing ListsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>5.2Â Processing ListsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/processing-lists.html">https://dcic-world.org/2025-08-27/processing-lists.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._.Making_.Lists_and_.Taking_.Them_.Apart%29" class="toclink" data-pltdoc="x">5.2.1Â Making Lists and Taking Them Apart</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._my-len%29" class="toclink" data-pltdoc="x">5.2.2Â Some Example Exercises</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Structural_.Problems_with_.Scalar_.Answers%29" class="toclink" data-pltdoc="x">5.2.3Â Structural Problems with Scalar Answers</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._len-eg%29" class="toclink" data-pltdoc="x">5.2.3.1Â <code data-lang="pyret" class="sourceCode">my-len</code>: Examples</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._sum-eg%29" class="toclink" data-pltdoc="x">5.2.3.2Â <code data-lang="pyret" class="sourceCode">my-sum</code>: Examples</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.From_.Examples_to_.Code%29" class="toclink" data-pltdoc="x">5.2.3.3Â From Examples to Code</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Structural_.Problems_that_.Transform_.Lists%29" class="toclink" data-pltdoc="x">5.2.4Â Structural Problems that Transform Lists</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._doubles-eg-code%29" class="toclink" data-pltdoc="x">5.2.4.1Â <code data-lang="pyret" class="sourceCode">my-doubles</code>: Examples and Code</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._str-len-eg-code%29" class="toclink" data-pltdoc="x">5.2.4.2Â <code data-lang="pyret" class="sourceCode">my-str-len</code>: Examples and Code</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Structural_.Problems_that_.Select_from_.Lists%29" class="toclink" data-pltdoc="x">5.2.5Â Structural Problems that Select from Lists</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._pos-nums-eg-code%29" class="toclink" data-pltdoc="x">5.2.5.1Â <code data-lang="pyret" class="sourceCode">my-pos-nums</code>: Examples and Code</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._alternating-eg-code%29" class="toclink" data-pltdoc="x">5.2.5.2Â <code data-lang="pyret" class="sourceCode">my-alternating</code>:
Examples and Code</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._struct-prob-sub-dom%29" class="toclink" data-pltdoc="x">5.2.6Â Structural Problems Over Relaxed Domains</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._my-max%29" class="toclink" data-pltdoc="x">5.2.6.1Â <code data-lang="pyret" class="sourceCode">my-max</code>: Examples</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code%29" class="toclink" data-pltdoc="x">5.2.6.2Â <code data-lang="pyret" class="sourceCode">my-max</code>: From Examples to Code</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.More_.Structural_.Problems_with_.Scalar_.Answers%29" class="toclink" data-pltdoc="x">5.2.7Â More Structural Problems with Scalar Answers</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._avg-eg%29" class="toclink" data-pltdoc="x">5.2.7.1Â <code data-lang="pyret" class="sourceCode">my-avg</code>: Examples</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._accumulators%29" class="toclink" data-pltdoc="x">5.2.8Â Structural Problems with Accumulators</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._running-sum-1st-attempt%29" class="toclink" data-pltdoc="x">5.2.8.1Â <code data-lang="pyret" class="sourceCode">my-running-sum</code>: First Attempt</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._running-sum-eg-code%29" class="toclink" data-pltdoc="x">5.2.8.2Â <code data-lang="pyret" class="sourceCode">my-running-sum</code>: Examples and Code</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._alternating-accumulator%29" class="toclink" data-pltdoc="x">5.2.8.3Â <code data-lang="pyret" class="sourceCode">my-alternating</code>: Examples and Code</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Dealing_with_.Multiple_.Answers%29" class="toclink" data-pltdoc="x">5.2.9Â Dealing with Multiple Answers</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._uniq%29" class="toclink" data-pltdoc="x">5.2.9.1Â <code data-lang="pyret" class="sourceCode">uniq</code>: Problem Setup</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._uniq-eg%29" class="toclink" data-pltdoc="x">5.2.9.2Â <code data-lang="pyret" class="sourceCode">uniq</code>: Examples</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code%29" class="toclink" data-pltdoc="x">5.2.9.3Â <code data-lang="pyret" class="sourceCode">uniq</code>: Code</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation%29" class="toclink" data-pltdoc="x">5.2.9.4Â <code data-lang="pyret" class="sourceCode">uniq</code>: Reducing Computation</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations%29" class="toclink" data-pltdoc="x">5.2.9.5Â <code data-lang="pyret" class="sourceCode">uniq</code>: Example and Code Variations</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_%29" class="toclink" data-pltdoc="x">5.2.9.6Â <code data-lang="pyret" class="sourceCode">uniq</code>: Why Produce a List?</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._polymorphic-data%29" class="toclink" data-pltdoc="x">5.2.10Â Monomorphic Lists and Polymorphic Types</a></p></td></tr></table><p>We have already seen [<a href="tables-to-lists.html" data-pltdoc="x">From Tables to Lists</a>] several examples of
list-processing functions. They have been especially useful for
advanced processing of tables. However, lists arise frequently in
programs, and they do so naturally because so many things in our
livesâ€”<wbr/>from shopping lists to to-do lists to checklistsâ€”<wbr/>are
naturally lists. Thinking about the functions that we might want
when processing lists, we can observe that there are some interesting
categories regarding the types of the data in the list:</p><ul><li><p>some list functions are generic and operate on any kind
of list: e.g., the length of a list is the same irrespective of what
kind of values it contains;</p></li><li><p>some are specific at least to the type of data: e.g., the sum
assumes that all the values are numbers (though they may be ages or
prices or other information represented by numbers); and</p></li><li><p>some are somewhere in-between: e.g., a maximum function applies
to any list of comparable values, such as numbers or strings.</p></li></ul><p>This seems like a great variety, and we might worry about how we can
handle this many different kinds of functions. Fortunately, and
perhaps surprisingly, there is one standard way in which we can think
about writing all these functions! Understanding
and internalizing this process is the goal of this chapter.</p><section class="SsectionLevel4" id="section 5.2.1"><h4 class="heading">5.2.1Â <a name="(part._.Making_.Lists_and_.Taking_.Them_.Apart)"/>Making Lists and Taking Them Apart<a href="#(part._.Making_.Lists_and_.Taking_.Them_.Apart)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>So far weâ€™ve seen one way to make a list: by writing
<code data-lang="pyret" class="sourceCode">[list: â€¦]</code>. While useful, writing lists this way actually
hides their true nature. Every list actually has two parts: a
first element and the rest of the list. The rest of the
list is itself a list, so it too has two partsâ€¦and so on.</p><p>Consider the list <code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code>. Its first element is <code data-lang="pyret" class="sourceCode">1</code>, and
the rest of it is <code data-lang="pyret" class="sourceCode">[list: 2, 3]</code>. For this second list, the first element
is <code data-lang="pyret" class="sourceCode">2</code> and the rest is <code data-lang="pyret" class="sourceCode">[list: 3]</code>.
</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Take apart this third list.</p></blockquote></blockquote><p>For the third list, the first element is <code data-lang="pyret" class="sourceCode">3</code> and the rest is
<code data-lang="pyret" class="sourceCode">[list: ]</code>, i.e., the empty list. In Pyret, we have another way
of writing the empty list: <code data-lang="pyret" class="sourceCode">empty</code>.</p><p>Lists are an instance of structured data: data with component
parts and a well-defined format for the shape of the parts. Lists are
formatted by the first element and the rest of the elements. Tables
are somewhat structured: they are formatted by rows and columns, but
the column names arenâ€™t consistent across all tables.  Structured data
is valuable in programming because a predictable format (the
structure) lets us write programs based on that structure. What do we
mean by that?</p><p>Programming languages can (and do!) provide built-in operators for
taking apart structured data. These operators are called
accessors. Accessors are defined on the structure of the
datatype alone, independent of the contents of the data. In the case
of lists, there are two accessors: <code data-lang="pyret" class="sourceCode">first</code> and
<code data-lang="pyret" class="sourceCode">rest</code>. We use an accessor by writing an expression, followed by
a dot (<code data-lang="pyret" class="sourceCode">.</code>), followed by the accessorâ€™s name. As we saw with
tables, the dot means "dig into". Thus:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l1 = [list: 1, 2, 3]
e1 = l1.first
l2 = l1.rest
e2 = l2.first
l3 = l2.rest
e3 = l3.first
l4 = l3.rest

check:
  e1 is 1
  e2 is 2
  e3 is 3
  l2 is [list: 2, 3]
  l3 is [list: 3]
  l4 is empty
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What are the accessors for tables?</p></blockquote></blockquote><p>Accessors give a way to take data apart based on their structure
(there is another way that we will see shortly). Is there a way to
also build data based on its structure? So far, we have been
building lists using the <code data-lang="pyret" class="sourceCode">[list: ...]</code> form, but that doesnâ€™t
emphasize the structural constraint that the <code data-lang="pyret" class="sourceCode">rest</code> is itself a
list. A structured operator for building lists would clearly show both
a <code data-lang="pyret" class="sourceCode">first</code> element and a <code data-lang="pyret" class="sourceCode">rest</code> that is itself a
list. Operators for building structured data are called
constructors.</p><p>The constructor for lists is called <code data-lang="pyret" class="sourceCode">link</code>. It takes two
arguments: a <code data-lang="pyret" class="sourceCode">first</code> element, and the list to build on (the
<code data-lang="pyret" class="sourceCode">rest</code> part). Hereâ€™s an example of using <code data-lang="pyret" class="sourceCode">link</code> to create a
three-element list.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link(1, link(2, link(3, empty)))</code></pre><p>The <code data-lang="pyret" class="sourceCode">link</code> form creates the same underlying list datum as our
previous <code data-lang="pyret" class="sourceCode">[list: ...]</code> operation, as confirmed by the following
check:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  [list: 1, 2, 3] is link(1, link(2, link(3, empty)))
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Look at these two forms of writing lists: what differences do you notice?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use the <code data-lang="pyret" class="sourceCode">link</code> form to write a four-element list of fruits containing
<code data-lang="pyret" class="sourceCode">"lychee"</code>, <code data-lang="pyret" class="sourceCode">"dates"</code>, <code data-lang="pyret" class="sourceCode">"mango"</code>, and <code data-lang="pyret" class="sourceCode">"durian"</code>.</p></blockquote></blockquote><p>After doing this exercise, you might wonder why anyone would use the
<code data-lang="pyret" class="sourceCode">link</code> form: itâ€™s more verbose, and makes the individual elements
harder to discern. This form is not very convenient to
humans. But it will prove very valuable to programs!</p><p>In particular, the <code data-lang="pyret" class="sourceCode">link</code> form highlights that we really have
two different structures of lists.
Some lists are empty. All other lists are non-empty
lists, meaning they have at least one <code data-lang="pyret" class="sourceCode">link</code>. There may be
more interesting structure to some lists (as we will see later), but all lists have this much
in common. Specifically, a list is either
</p><ul><li><p>empty (written <code data-lang="pyret" class="sourceCode">empty</code> or <code data-lang="pyret" class="sourceCode">[list: ]</code>), or</p></li><li><p>non-empty (written <code data-lang="pyret" class="sourceCode">link(â€¦, â€¦)</code> or <code data-lang="pyret" class="sourceCode">[list: ]</code> with
at least one value inside the brackets), where the rest is also
a list (and hence may in turn be empty or non-empty, â€¦).</p></li></ul><p>This means we actually have two structural features of lists, both of
which are important when writing programs over lists:
</p><ol><li><p>Lists can be empty or non-empty</p></li><li><p>Non-empty lists have a first element and a rest of the list</p></li></ol><p>Letâ€™s leverage these two structural features to write some programs to
process lists!</p></section><section class="SsectionLevel4" id="section 5.2.2"><h4 class="heading">5.2.2Â <a name="(part._my-len)"/>Some Example Exercises<a href="#(part._my-len)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>To illustrate our thinking, letâ€™s work through a few concrete examples
of list-processing functions. All of these will consume lists; some
will even produce them. Some will transform their inputs (like
<code data-lang="pyret" class="sourceCode">map</code>), some will select from their inputs (like <code data-lang="pyret" class="sourceCode">filter</code>),
and some will aggregate their inputs. Since some of these functions already exist in
Pyret, weâ€™ll name them with the prefix <code data-lang="pyret" class="sourceCode">my-</code> to avoid
errors.Be sure to use the <code data-lang="pyret" class="sourceCode">my-</code> name consistently,
including inside the body of the function. As we will see, there is a
standard strategy that we can use to approach writing all of these
functions: having you learn this strategy is the goal of this chapter.</p></section><section class="SsectionLevel4" id="section 5.2.3"><h4 class="heading">5.2.3Â <a name="(part._.Structural_.Problems_with_.Scalar_.Answers)"/>Structural Problems with Scalar Answers<a href="#(part._.Structural_.Problems_with_.Scalar_.Answers)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Letâ€™s write out examples for a few of the functions described
above. Weâ€™ll approach writing examples in a very specific, stylized
way. First of all, we should always construct at least two examples:
one with <code data-lang="pyret" class="sourceCode">empty</code> and the other with at least one <code data-lang="pyret" class="sourceCode">link</code>, so
that weâ€™ve covered the two very broad kinds of lists. Then, we should
have more examples specific to the kind of list stated in the
problem. Finally, we should have even more examples to illustrate how
we think about solving the problem.</p><section class="SsectionLevel5" id="section 5.2.3.1"><h5 class="heading">5.2.3.1Â <a name="(part._len-eg)"/><code data-lang="pyret" class="sourceCode">my-len</code>: Examples<a href="#(part._len-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>We haveâ€™t precisely defined what it means to be â€œthe lengthâ€ of a
list. We confront this right away when trying to write an
example. What is the length of the list <code data-lang="pyret" class="sourceCode">empty</code>?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you think?</p></blockquote></blockquote><p>Two common examples are <code data-lang="pyret" class="sourceCode">0</code> and <code data-lang="pyret" class="sourceCode">1</code>. The latter, <code data-lang="pyret" class="sourceCode">1</code>,
certainly looks reasonable. However, if you write the list as
<code data-lang="pyret" class="sourceCode">[list: ]</code>, now it doesnâ€™t look so right: this is clearly (as the
name <code data-lang="pyret" class="sourceCode">empty</code> also suggests) an empty list, and an empty
list has zero elements in it. Therefore, itâ€™s conventional to
declare that
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len(empty) is 0</code></pre><p>How about a list like <code data-lang="pyret" class="sourceCode">[list: 7]</code>? Well, itâ€™s clearly got one
element (<code data-lang="pyret" class="sourceCode">7</code>) in it, so
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7]) is 1</code></pre><p>Similarly, for a list like <code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code>, we would say
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3</code></pre><p>Now letâ€™s look at that last example in a different light. Consider
the argument <code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code>. Its first element is <code data-lang="pyret" class="sourceCode">7</code> and
the rest of it is <code data-lang="pyret" class="sourceCode">[list: 8, 9]</code>. Well, <code data-lang="pyret" class="sourceCode">7</code> is a number, not
a list; but <code data-lang="pyret" class="sourceCode">[list: 8, 9]</code> certainly is a list, so we can ask for
its length. What is <code data-lang="pyret" class="sourceCode">my-len([list: 8, 9])</code>? It has two
elements, so
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 8, 9]) is 2</code></pre><p>The first element of that list is <code data-lang="pyret" class="sourceCode">8</code> while its rest is
<code data-lang="pyret" class="sourceCode">[list: 9]</code>. What is its length?
Note that we asked a very similar question before, for the length of
the list <code data-lang="pyret" class="sourceCode">[list: 7]</code>. But <code data-lang="pyret" class="sourceCode">[list: 7]</code> is not a
sub-list of <code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code>, which we started with,
whereas <code data-lang="pyret" class="sourceCode">[list: 9]</code> is. And using the same reasoning as before,
we can say
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 9]) is 1</code></pre><p>The rest of this last list is, of course, the empty list, whose length
we have already decided is <code data-lang="pyret" class="sourceCode">0</code>.</p><p>Putting together these examples, and writing out <code data-lang="pyret" class="sourceCode">empty</code> in its
other form, hereâ€™s what we get:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3
my-len([list:    8, 9]) is 2
my-len([list:       9]) is 1
my-len([list:        ]) is 0</code></pre><p>Another way we can write this (paying attention to the right side) is
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + 2
my-len([list:    8, 9]) is 1 + 1
my-len([list:       9]) is 1 + 0
my-len([list:        ]) is     0</code></pre><p>Where did the <code data-lang="pyret" class="sourceCode">2</code>, <code data-lang="pyret" class="sourceCode">1</code>, and <code data-lang="pyret" class="sourceCode">0</code> on the right sides of
each <code data-lang="pyret" class="sourceCode">+</code> operation come from? Those are the lengths of the
<code data-lang="pyret" class="sourceCode">rest</code> component of the input list. In the previous example
block, we wrote those lengths as explicit examples. Letâ€™s substitute
the numbers <code data-lang="pyret" class="sourceCode">2</code>, <code data-lang="pyret" class="sourceCode">1</code>, and <code data-lang="pyret" class="sourceCode">0</code> with the <code data-lang="pyret" class="sourceCode">my-len</code>
expressions that produce them:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list:    8, 9]) is 1 + my-len([list:    9])
my-len([list:       9]) is 1 + my-len([list:     ])
my-len([list:        ]) is 0</code></pre><p>From this, maybe you can start to see a pattern. For an empty list,
the length is <code data-lang="pyret" class="sourceCode">0</code>. For a non-empty list, itâ€™s the sum of <code data-lang="pyret" class="sourceCode">1</code>
(the first elementâ€™s â€œcontributionâ€ to the listâ€™s length) to the
length of the rest of the list. In other words, we can use the result
of computing <code data-lang="pyret" class="sourceCode">my-len</code> on the rest of the list to compute the
answer for the entire list.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Each of our examples in this section has written a different check on
the expression <code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9])</code>. Here are those examples
presented together, along with one last one that explicitly uses the
<code data-lang="pyret" class="sourceCode">rest</code> operation:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3
my-len([list: 7, 8, 9]) is 1 + 2
my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)</code></pre><p>Check that you agree with each of these assertions. Also check whether
you understand how the right-hand side of each <code data-lang="pyret" class="sourceCode">is</code> expression
derives from the right-hand-side just above it. The goal of this
exercise is to make sure that you believe that the last check (which
we will turn into code) is equivalent to the first (which we wrote
down when understanding the problem).</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.2.3.2"><h5 class="heading">5.2.3.2Â <a name="(part._sum-eg)"/><code data-lang="pyret" class="sourceCode">my-sum</code>: Examples<a href="#(part._sum-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s repeat this process of developing examples on a second function,
this time one that computes the sum of the elements in a list of numbers.
What is the
sum of the list <code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code>? Just adding up the numbers by hand,
the result should be <code data-lang="pyret" class="sourceCode">24</code>. Letâ€™s see how that works out through
the examples.</p><p>Setting aside the empty list for a moment, here are examples that show
the sum computations:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum([list: 7, 8, 9]) is 7 + 8 + 9
my-sum([list:    8, 9]) is     8 + 9
my-sum([list:       9]) is         9</code></pre><p>which (by substitution) is the same as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum([list: 7, 8, 9]) is 7 + my-sum([list: 8, 9])
my-sum([list:    8, 9]) is 8 + my-sum([list:    9])
my-sum([list:       9]) is 9 + my-sum([list:     ])</code></pre><p>From this, we can see that the sum of the empty list must be
<code data-lang="pyret" class="sourceCode">0</code>:Zero is called the additive identity: a
fancy way of saying, adding zero to any number N gives you
N. Therefore, it makes sense that it would be the length of the
empty list, because the empty list has no items to contribute to a
sum. Can you figure out what the multiplicative identity is?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum(empty) is 0</code></pre><p>Observe, again, how we can use the result of computing <code data-lang="pyret" class="sourceCode">my-sum</code>
of the rest of the list to compute its result for the whole list.</p></section><section class="SsectionLevel5" id="section 5.2.3.3"><h5 class="heading">5.2.3.3Â <a name="(part._.From_.Examples_to_.Code)"/>From Examples to Code<a href="#(part._.From_.Examples_to_.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Having developed these examples, we now want to use them to develop a
program that can compute the length or the sum of any list, not
just the specific ones we used in these examples. As we have done up
in earlier chapters, we will leverage patterns in the examples to
figure out how to define the general-purpose function.</p><p>Here is one last version of the examples for <code data-lang="pyret" class="sourceCode">my-len</code>, this time
making the <code data-lang="pyret" class="sourceCode">rest</code> explicit on the right-hand sides of <code data-lang="pyret" class="sourceCode">is</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)
my-len([list:        ]) is 0</code></pre><p>As we did when developing functions over images, letâ€™s try to identify
the common parts of these examples. We start by noticing that most of
the examples have a lot in common, except for the <code data-lang="pyret" class="sourceCode">[list: ]</code>
(<code data-lang="pyret" class="sourceCode">empty</code>) case. So letâ€™s separate this into two sets of examples:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)


my-len([list:        ]) is 0</code></pre><p>With this separation (which follows one of the structural features of
lists that we mentioned earlier), a clearer pattern emerges: for a
non-empty list (called <code data-lang="pyret" class="sourceCode">someList</code>), we compute its length via the
expression:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 + my-len(someList.rest)</code></pre><p>In general, then, our <code data-lang="pyret" class="sourceCode">my-len</code> program needs to determine whether
its input list is empty or non-empty, using this expression with
<code data-lang="pyret" class="sourceCode">.rest</code> in the non-empty case. How do we indicate different code
based on the structure of the list?</p><p>Pyret has a construct called <code data-lang="pyret" class="sourceCode">cases</code> which is used to distinguish
different forms within a structured datatype. When working with lists,
the general shape of a <code data-lang="pyret" class="sourceCode">cases</code> expression is:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (List) e:
  | empty      =&gt; â€¦
  | link(f, r) =&gt; â€¦ f â€¦ r â€¦
end</code></pre><p>where most parts are fixed, but a few youâ€™re free to change:
</p><ul><li><p><code data-lang="pyret" class="sourceCode">e</code> is an expression whose value needs to be a list; it
could be a variable bound to a list, or some complex expression that
evaluates to a list.</p></li><li><p><code data-lang="pyret" class="sourceCode">f</code> and <code data-lang="pyret" class="sourceCode">r</code> are names given to the first and rest of
the list. You can choose any names you like, though in Pyret, itâ€™s
conventional to use <code data-lang="pyret" class="sourceCode">f</code> and <code data-lang="pyret" class="sourceCode">r</code>.Occasionally
using different names can help students recall that they can choose
how to label the <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> components. This can be
particularly useful for <code data-lang="pyret" class="sourceCode">first</code>, which has a problem-specific
meaning (such as <code data-lang="pyret" class="sourceCode">price</code> in a list of prices, and so on).</p></li></ul><p>The right-hand side of every <code data-lang="pyret" class="sourceCode">=&gt;</code> is an expression.</p><p>Hereâ€™s how <code data-lang="pyret" class="sourceCode">cases</code> works in this instance. Pyret first evaluates
<code data-lang="pyret" class="sourceCode">e</code>. It then checks that the resulting value truly is a list;
otherwise it halts with an error. If it is a list, Pyret examines what
kind of list it is. If itâ€™s an empty list, it runs the
expression after the <code data-lang="pyret" class="sourceCode">=&gt;</code> in the <code data-lang="pyret" class="sourceCode">empty</code> clause. Otherwise,
the list is not empty, which means it has a first and rest; Pyret
binds <code data-lang="pyret" class="sourceCode">f</code> and <code data-lang="pyret" class="sourceCode">r</code> to the two parts, respectively, and then
evaluates the expression after the <code data-lang="pyret" class="sourceCode">=&gt;</code> in the <code data-lang="pyret" class="sourceCode">link</code> clause.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Try using a non-listâ€”<wbr/>e.g., a numberâ€”<wbr/>in the <code data-lang="pyret" class="sourceCode">e</code> position and
see what happens!</p></blockquote></blockquote><p>Now letâ€™s use <code data-lang="pyret" class="sourceCode">cases</code> to define <code data-lang="pyret" class="sourceCode">my-len</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-len(l):
  cases (List) l:
    | empty      =&gt; 0
    | link(f, r) =&gt; 1 + my-len(r)
  end
end</code></pre><p>This follows from our examples: when the list is empty <code data-lang="pyret" class="sourceCode">my-len</code>
produces <code data-lang="pyret" class="sourceCode">0</code>; when it is not empty, we add one to the length of
the rest of the list (here, <code data-lang="pyret" class="sourceCode">r</code>).</p><p>Note that while our most recent collection of <code data-lang="pyret" class="sourceCode">my-len</code> examples
explicitly said <code data-lang="pyret" class="sourceCode">.rest</code>, when using <code data-lang="pyret" class="sourceCode">cases</code> we instead use
just the name <code data-lang="pyret" class="sourceCode">r</code>, which Pyret has already defined (under the
hood) to be <code data-lang="pyret" class="sourceCode">l.rest</code>.</p><p>Similarly, letâ€™s define <code data-lang="pyret" class="sourceCode">my-sum</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-sum(l):
  cases (List) l:
    | empty      =&gt; 0
    | link(f, r) =&gt; f + my-sum(r)
  end
end</code></pre><p>Notice how similar they are in code, and how readily the structure of
the data suggest a structure for the program. This is a pattern you
will get very used to soon!</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Developing Functions Over Lists</p><blockquote class="StrategyBody"><p>Leverage the structure of lists and the power of concrete examples to
develop list-processing functions.
</p><ul><li><p>Pick a concrete list with (at least) three elements. Write a
sequence of examples for each of the entire list and each suffix of
the list (including the empty list).</p></li><li><p>Rewrite each example to express its expected
answer in terms of the <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> data of its input
list. You donâ€™t have to use the <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> operators
in the new answers, but you should see the <code data-lang="pyret" class="sourceCode">first</code> and
<code data-lang="pyret" class="sourceCode">rest</code> values represented explicitly in the answer.</p></li><li><p>Look for a pattern across the answers in the examples. Use these
to develop the code: write a <code data-lang="pyret" class="sourceCode">cases</code> expression, filling in the
right side of each <code data-lang="pyret" class="sourceCode">=&gt;</code> based on your examples.</p></li></ul><p>This strategy applies to structured data in general, leveraging
components of each datum rather than specifically <code data-lang="pyret" class="sourceCode">first</code> and
<code data-lang="pyret" class="sourceCode">rest</code> as presented so far.</p></blockquote></blockquote></section></section><section class="SsectionLevel4" id="section 5.2.4"><h4 class="heading">5.2.4Â <a name="(part._.Structural_.Problems_that_.Transform_.Lists)"/>Structural Problems that Transform Lists<a href="#(part._.Structural_.Problems_that_.Transform_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Now that we have a systematic way to develop functions that take lists
as input, letâ€™s apply that same strategy to functions that
produce a list as the answer.</p><section class="SsectionLevel5" id="section 5.2.4.1"><h5 class="heading">5.2.4.1Â <a name="(part._doubles-eg-code)"/><code data-lang="pyret" class="sourceCode">my-doubles</code>: Examples and Code<a href="#(part._doubles-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>As always, weâ€™ll begin with some examples. Given a list of numbers, we
want a list that doubles each number (in the order of the
original list). Hereâ€™s a reasonable example with three numbers:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is [list: 6, 10, 4]</code></pre><p>As before, letâ€™s write out the answers for each suffix of our example
list as well, including for the <code data-lang="pyret" class="sourceCode">empty</code> list:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list:    5, 2]) is [list:    10, 4]
my-doubles([list:       2]) is [list:        4]
my-doubles([list:        ]) is [list:         ]</code></pre><p>Now, we rewrite the answer expressions to include the concrete
<code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> data for each example. Letâ€™s start with
just the <code data-lang="pyret" class="sourceCode">first</code> data, and just on the first example:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is [list: 3 * 2, 10, 4]
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre><p>Next, letâ€™s include the <code data-lang="pyret" class="sourceCode">rest</code> data (<code data-lang="pyret" class="sourceCode">[list: 5, 2]</code>) in the
first example. The current answer in the first example is</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, 10, 4]</code></pre><p>and that <code data-lang="pyret" class="sourceCode">[list: 10, 4]</code> is the result of using the function on
<code data-lang="pyret" class="sourceCode">[list: 5, 2]</code>. We might therefore be tempted to replace the
right side of the first example with:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, my-doubles([list: 5, 2])]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What value would this expression produce? You might want to try this
example that doesnâ€™t use <code data-lang="pyret" class="sourceCode">my-doubles</code> directly:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, [list: 10, 4]]</code></pre></blockquote></blockquote><p>Oops! We want a single (flat) list, not a list-within-a-list. This
feels like it is on the right track in terms of reworking the answer
to use the <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> values, but weâ€™re clearly not
quite there yet.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What value does the following expression produce?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link(3 * 2, [list: 10, 4])</code></pre></blockquote></blockquote><p>Notice the difference between the two expressions in these last two
exercises: the latter used <code data-lang="pyret" class="sourceCode">link</code> to put the value involving
<code data-lang="pyret" class="sourceCode">first</code> into the conversion of the <code data-lang="pyret" class="sourceCode">rest</code>, while the former
tried to do this with <code data-lang="pyret" class="sourceCode">list:</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How many elements are in the lists that result from each of the
following expressions?</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 25, 16, 32]
[list: 25, [list: 16, 32]]
link(25, [list: 16, 32])</code></pre></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Summarize the difference between how <code data-lang="pyret" class="sourceCode">link</code> and <code data-lang="pyret" class="sourceCode">list:</code>
combine an element and a list. Try additional examples at the
interactions prompt if needed to explore these ideas.</p></blockquote></blockquote><p>The takeaway here is that we use <code data-lang="pyret" class="sourceCode">link</code> to insert an
element into an existing list, whereas we use <code data-lang="pyret" class="sourceCode">list:</code> to make a
new list that contains the old list as an element. Going back
to our examples, then, we include <code data-lang="pyret" class="sourceCode">rest</code> in the first example by
writing it as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, [list: 10, 4])
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre><p>which we then convert to</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre><p>Applying this idea across the examples, we get:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is link(5 * 2, my-doubles([list: 2]))
my-doubles([list:       2]) is link(2 * 2, my-doubles([list: ]))
my-doubles([list:        ]) is [list:             ]</code></pre><p>Now that we have examples that explicitly use the <code data-lang="pyret" class="sourceCode">first</code> and
<code data-lang="pyret" class="sourceCode">rest</code> elements, we can produce to write the <code data-lang="pyret" class="sourceCode">my-doubles</code>
function:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-doubles(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      link(f * 2, my-doubles(r))
  end
end</code></pre></section><section class="SsectionLevel5" id="section 5.2.4.2"><h5 class="heading">5.2.4.2Â <a name="(part._str-len-eg-code)"/><code data-lang="pyret" class="sourceCode">my-str-len</code>: Examples and Code<a href="#(part._str-len-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>In <code data-lang="pyret" class="sourceCode">my-doubles</code>, the input and output lists have the same type of
element. Functions can also produce lists whose contents have a
different type from the input list. Letâ€™s work through an example.
Given a list of strings, we
want the lengths of each string (in the same order as in the input list). Thus, hereâ€™s a
reasonable example:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is [list: 2, 5, 6]</code></pre><p>As we have before, we should consider the answers for each
sub-problem of the above example:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list:       "there", "mateys"]) is [list:    5, 6]
my-str-len([list:                "mateys"]) is [list:       6]</code></pre><p>Or, in other words:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(2, [list: 5, 6])
my-str-len([list:       "there", "mateys"]) is link(5, [list:    6])
my-str-len([list:                "mateys"]) is link(6, [list:     ])</code></pre><p>which tells us that the response for the empty list should be
<code data-lang="pyret" class="sourceCode">empty</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len(empty) is empty</code></pre><p>The next step is to rework the answers in the examples to make the
<code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> parts explicit. Hopefully by now you are
starting to detect a pattern: The result on the rest of the list
appears explicitly as another example. Therefore, weâ€™ll start by
getting the <code data-lang="pyret" class="sourceCode">rest</code> value of each example input into the answer:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(2, my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(5, my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(6, my-str-len([list:                  ]))
my-str-len([list:                        ]) is [list: ]</code></pre><p>All that remains now is to figure out how to work the <code data-lang="pyret" class="sourceCode">first</code>
values into the outputs. In the context of this problem, this means we
need to convert <code data-lang="pyret" class="sourceCode">"hi"</code> into <code data-lang="pyret" class="sourceCode">2</code>, <code data-lang="pyret" class="sourceCode">"there"</code> into
<code data-lang="pyret" class="sourceCode">5</code>, and so on. From the problem statement, we know that <code data-lang="pyret" class="sourceCode">2</code>
and <code data-lang="pyret" class="sourceCode">5</code> are meant to be the lengths (character counts) of the
corresponding strings. The operation that determines the length of a
string is called <code data-lang="pyret" class="sourceCode">string-length</code>. Thus, our examples appear as:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(string-length("hi"), my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(string-length("there"), my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(string-length("mateys"), my-str-len([list: ]))
my-str-len([list:                        ]) is [list: ]</code></pre><p>From here, we write a function that captures the pattern developed
across our examples:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-str-len(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      link(string-length(f), my-str-len(r))
  end
end</code></pre></section></section><section class="SsectionLevel4" id="section 5.2.5"><h4 class="heading">5.2.5Â <a name="(part._.Structural_.Problems_that_.Select_from_.Lists)"/>Structural Problems that Select from Lists<a href="#(part._.Structural_.Problems_that_.Select_from_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In the previous section, we saw functions that transform list
elements (by doubling numbers or counting characters). The type of the
output list may or may not be the same as the type of the input
list. Other functions that produce lists instead select
elements: every element in the output list was in the input list, but
some input-list elements might not appear in the output list. This
section adapts our method of deriving functions from examples to
accommodate selection of elements.</p><section class="SsectionLevel5" id="section 5.2.5.1"><h5 class="heading">5.2.5.1Â <a name="(part._pos-nums-eg-code)"/><code data-lang="pyret" class="sourceCode">my-pos-nums</code>: Examples and Code<a href="#(part._pos-nums-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>As our first example, we will select the positive numbers from a list
that contains both positive and non-positive numbers.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Construct the sequence of examples that we obtain from the input
<code data-lang="pyret" class="sourceCode">[list: 1, -2, 3, -4]</code>.</p></blockquote></blockquote><p>Here we go:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is [list: 1, 3]
my-pos-nums([list:    -2, 3, -4]) is [list:    3]
my-pos-nums([list:        3, -4]) is [list:    3]
my-pos-nums([list:           -4]) is [list:     ]
my-pos-nums([list:             ]) is [list:     ]</code></pre><p>We can write this in the following form:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, [list: 3])
my-pos-nums([list:    -2, 3, -4]) is         [list: 3]
my-pos-nums([list:        3, -4]) is link(3, [list: ])
my-pos-nums([list:           -4]) is         [list: ]
my-pos-nums([list:             ]) is         [list: ]</code></pre><p>or, even more explicitly,
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])
my-pos-nums([list:             ]) is         [list: ]</code></pre><p>Unlike in the example sequences for functions that transform lists,
here we see that the answers have different shapes: some involve a
<code data-lang="pyret" class="sourceCode">link</code>, while others simply process the <code data-lang="pyret" class="sourceCode">rest</code> of the
list. Whenever we need different shapes of outputs across a set of
examples, we will need an <code data-lang="pyret" class="sourceCode">if</code> expression in our code to
distinguish the conditions that yield each shape.</p><p>What determines which shape of output we get? Letâ€™s rearrange the
examples (other than the empty-list input) by output shape:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))

my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])</code></pre><p>Re-organized, we can see that the examples that use <code data-lang="pyret" class="sourceCode">link</code> have a
positive number in the <code data-lang="pyret" class="sourceCode">first</code> position, while the ones that
donâ€™t simply process the <code data-lang="pyret" class="sourceCode">rest</code> of the list. That indicates that
our <code data-lang="pyret" class="sourceCode">if</code> expression needs to ask whether the <code data-lang="pyret" class="sourceCode">first</code> element
in the list is positive. This yields the following program:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-pos-nums(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if f &gt; 0:
        link(f, my-pos-nums(r))
      else:
        my-pos-nums(r)
      end
  end
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Is our set of examples comprehensive?</p></blockquote></blockquote><p>Not really. There are many examples we havenâ€™t considered, such
as lists that end with positive numbers and lists with <code data-lang="pyret" class="sourceCode">0</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Work through these examples and see how they affect the program!</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.2.5.2"><h5 class="heading">5.2.5.2Â <a name="(part._alternating-eg-code)"/><code data-lang="pyret" class="sourceCode">my-alternating</code>:
Examples and Code<a href="#(part._alternating-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Now letâ€™s consider a problem that selects elements not by value, but
by position. We want to write a function that selects
alternating elements from a list. Once again, weâ€™re going to work from examples.
</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Work out the results for <code data-lang="pyret" class="sourceCode">my-alternating</code> starting from the list
<code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4, 5, 6]</code>.</p></blockquote></blockquote><p>Hereâ€™s how they work out:
</p><a name="(elem._alternating-egs-1)"/>&lt;alternating-egs-1&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
  my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
  my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
  my-alternating([list:          4, 5, 6]) is [list:    4, 6]
end</code></pre><p>Wait, whatâ€™s that? The two answers above are each correct, but
the second answer does not help us in any way construct the
first answer. That means the way weâ€™ve solved these problems until
now is not enough for this new kind of problem. Itâ€™s still useful,
though: notice that thereâ€™s a connection between the first example and
the third, as well as between the second example and the fourth. This
observation is consistent with our goal of selecting alternating elements.</p><p>What would something like this look like in code? Before we try to
write the function, letâ€™s rewrite the first example in terms of the
third:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]

my-alternating([list: 1, 2, 3, 4, 5, 6]) is link(1, my-alternating([list: 3, 4, 5, 6]))</code></pre><p>Note that in the rewritten version, we are dropping two
elements from the list before using <code data-lang="pyret" class="sourceCode">my-alternating</code> again, not
just one. We will have to figure out how to handle that in our code.</p><p>Letâ€™s start with our usual function pattern with a <code data-lang="pyret" class="sourceCode">cases</code>
expression:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; [list:]
    | link(f, r) =&gt; link(f, â€¦ r â€¦)
  end
end</code></pre><p>Note that we cannot simply call <code data-lang="pyret" class="sourceCode">my-alternating</code> on <code data-lang="pyret" class="sourceCode">r</code>,
because <code data-lang="pyret" class="sourceCode">r</code> excludes only one item from the list, not two as this
problem requires. We have to break down <code data-lang="pyret" class="sourceCode">r</code> as well, in order to
get to the <code data-lang="pyret" class="sourceCode">rest</code> of the <code data-lang="pyret" class="sourceCode">rest</code> of the original list. To do
this, we use another <code data-lang="pyret" class="sourceCode">cases</code> expression, nested within the first
<code data-lang="pyret" class="sourceCode">cases</code> expression:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; [list:]
    | link(f, r) =&gt;
      cases (List) r:  # note: deconstructing r, not l
        | empty =&gt; ??? # note the ???
        | link(fr, rr) =&gt;
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end</code></pre><p>This code is consistent with the example that we just worked out. But
note that we still have a bit of unfinished work to do: we need to
decide what to do in the <code data-lang="pyret" class="sourceCode">empty</code> case of the inner <code data-lang="pyret" class="sourceCode">cases</code>
expression (marked by <code data-lang="pyret" class="sourceCode">???</code> in the code).</p><p>A common temptation at this point is to replace the <code data-lang="pyret" class="sourceCode">???</code> with
<code data-lang="pyret" class="sourceCode">[list:]</code>. After all, havenâ€™t we always returned <code data-lang="pyret" class="sourceCode">[list:]</code> in
the <code data-lang="pyret" class="sourceCode">empty</code> cases?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Replace <code data-lang="pyret" class="sourceCode">???</code> with <code data-lang="pyret" class="sourceCode">[list:]</code> and test the program on our
original examples:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
my-alternating([list:          4, 5, 6]) is [list:    4, 6]</code></pre><p>What do you observe?</p></blockquote></blockquote><p>Oops! Weâ€™ve written a program that appears to work on lists with an
even number of elements, but not on lists with an odd number of
elements. How did that happen? The only part of this code that we
guessed at was how to fill in the <code data-lang="pyret" class="sourceCode">empty</code> case of the inner
<code data-lang="pyret" class="sourceCode">cases</code>, so the issue must be there. Rather than focus on the
code, however, focus on the examples. We need a simple example
that would land on that part of the code. We get to that spot when the
list <code data-lang="pyret" class="sourceCode">l</code> is not empty, but <code data-lang="pyret" class="sourceCode">r</code> (the rest of <code data-lang="pyret" class="sourceCode">l</code>) is
empty. In other words, we need an example with only one element.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Finish the following example:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 5]) is ???</code></pre></blockquote></blockquote><p>Given a list with one element, that element should be included in a
list of alternating elements. Thus, we should finish this example as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 5]) is [list: 5]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use this example to update the result of <code data-lang="pyret" class="sourceCode">my-alternating</code> when
<code data-lang="pyret" class="sourceCode">r</code> is <code data-lang="pyret" class="sourceCode">empty</code> in our code.</p></blockquote></blockquote><p>Leveraging this new example, the final version of
<code data-lang="pyret" class="sourceCode">my-alternating</code> is as follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      cases (List) r: # note: deconstructing r, not l
        | empty =&gt;    # the list has an odd number of elements
          [list: f]
        | link(fr, rr) =&gt;
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end</code></pre><p>Whatâ€™s the takeaway from this problem? There are two:
</p><ul><li><p>Donâ€™t skip the small examples: the result of a list-processing
function on the <code data-lang="pyret" class="sourceCode">empty</code> case wonâ€™t always be <code data-lang="pyret" class="sourceCode">empty</code>.</p></li><li><p>If a problem asks you to work with multiple elements from the
front of a list, you can nest <code data-lang="pyret" class="sourceCode">cases</code> expressions to access later
elements.</p></li></ul><p>These takeaways will matter again in future examples: keep an eye out
for them!</p></section></section><section class="SsectionLevel4" id="section 5.2.6"><h4 class="heading">5.2.6Â <a name="(part._struct-prob-sub-dom)"/>Structural Problems Over Relaxed Domains<a href="#(part._struct-prob-sub-dom)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><section class="SsectionLevel5" id="section 5.2.6.1"><h5 class="heading">5.2.6.1Â <a name="(part._my-max)"/><code data-lang="pyret" class="sourceCode">my-max</code>: Examples<a href="#(part._my-max)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Now letâ€™s find the maximum value of a list. Letâ€™s assume for
simplicity that weâ€™re dealing with just lists of numbers. What kinds
of lists should we construct? Clearly, we should have empty and
non-empty listsâ€¦but what else? Is a list like <code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code> a
good example? Well, thereâ€™s nothing wrong with it, but we should also
consider lists where the maximum is at the beginning rather than at the
end; the maximum might be in the middle; the maximum might be
repeated; the maximum might be negative; and so on. While not
comprehensive, here is a small but interesting set of examples:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 1, 2, 3]) is 3
my-max([list: 3, 2, 1]) is 3
my-max([list: 2, 3, 1]) is 3
my-max([list: 2, 3, 1, 3, 2]) is 3
my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list: -2, -1, -3]) is -1</code></pre><p>What about <code data-lang="pyret" class="sourceCode">my-max(empty)</code>?
</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Could we define <code data-lang="pyret" class="sourceCode">my-max(empty)</code> to be <code data-lang="pyret" class="sourceCode">0</code>? Returning
<code data-lang="pyret" class="sourceCode">0</code> for the empty list has worked well twice already!</p></blockquote></blockquote><p>Weâ€™ll return to this in a while.</p><p>Before we proceed, itâ€™s useful to know that thereâ€™s a function called
<code data-lang="pyret" class="sourceCode">num-max</code> already defined in Pyret, that compares two numbers:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max(1, 2) is 2
num-max(-1, -2) is -1</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Suppose <code data-lang="pyret" class="sourceCode">num-max</code> were not already built in. Can you define it?
You will find what you learned about <a href="Conditionals_and_Booleans.html#%28part._booleans%29" data-pltdoc="x">Booleans</a>
handy. Remember to write some tests!</p></blockquote></blockquote><p>Now we can look at <code data-lang="pyret" class="sourceCode">my-max</code> at work:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 1, 2, 3]) is 3
my-max([list:    2, 3]) is 3
my-max([list:       3]) is 3</code></pre><p>Hmm. That didnâ€™t really teach us anything, did it? Maybe, we canâ€™t be
sure. And we still donâ€™t know what to do with <code data-lang="pyret" class="sourceCode">empty</code>.</p><p>Letâ€™s try the second example input:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 3, 2, 1]) is 3
my-max([list:    2, 1]) is 2
my-max([list:       1]) is 1</code></pre><p>This is actually telling us something useful as well, but maybe we
canâ€™t see it yet. Letâ€™s take on something more ambitious:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list:    1, 4, 3, 2]) is 4
my-max([list:       4, 3, 2]) is 4
my-max([list:          3, 2]) is 3
my-max([list:             2]) is 2</code></pre><p>Observe how the maximum of the rest of the list gives us a candidate
answer, but comparing it to the first element gives us a definitive
one:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is num-max(2, 4)
my-max([list:    1, 4, 3, 2]) is num-max(1, 4)
my-max([list:       4, 3, 2]) is num-max(4, 3)
my-max([list:          3, 2]) is num-max(3, 2)
my-max([list:             2]) is â€¦</code></pre><p>The last one is a little awkward: weâ€™d like to write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list:             2]) is num-max(2, â€¦)</code></pre><p>but we donâ€™t really know what the maximum (or minimum, or any other
element) of the empty list is, but we can only provide numbers
to <code data-lang="pyret" class="sourceCode">num-max</code>. Therefore, leaving out that dodgy case, weâ€™re left
with
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is num-max(2, my-max([list: 1, 4, 3, 2]))
my-max([list:    1, 4, 3, 2]) is num-max(1, my-max([list:    4, 3, 2]))
my-max([list:       4, 3, 2]) is num-max(4, my-max([list:       3, 2]))
my-max([list:          3, 2]) is num-max(3, my-max([list:          2]))</code></pre><p>Our examples have again helped: theyâ€™ve revealed how we can use the
answer for each rest of the list to compute the answer for the whole
list, which in turn is the rest of some other list, and so on. If you
go back and look at the other example lists we wrote above, youâ€™ll see
the pattern holds there too.</p><p>However, itâ€™s time we now confront the <code data-lang="pyret" class="sourceCode">empty</code> case. The real
problem is that we donâ€™t have a maximum for the empty list: for any
number we might provide, there is always a number bigger than it
(assuming our computer is large enough) that could have been the
answer instead. In short, itâ€™s nonsensical to ask for the maximum (or
minimum) of the empty list: the concept of â€œmaximumâ€ is only defined
on non-empty lists! That is, when asked for the maximum of an empty
list, we should signal an error:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max(empty) raises ""</code></pre><p>(which is how, in Pyret, we say that it will generate an error; we
donâ€™t care about the details of the error, hence the empty string).</p></section><section class="SsectionLevel5" id="section 5.2.6.2"><h5 class="heading">5.2.6.2Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)"/><code data-lang="pyret" class="sourceCode">my-max</code>: From Examples to Code<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Once again, we can codify the examples above, i.e., turn them into a
uniform program that works for all instances. However, we now have a
twist. If we blindly followed the pattern weâ€™ve used earlier, we would
end up with:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt; num-max(f, my-max(r))
  end
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Whatâ€™s wrong with this?</p></blockquote></blockquote><p>Consider the list <code data-lang="pyret" class="sourceCode">[list: 2]</code>. This turns into
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max(2, my-max([list: ]))</code></pre><p>which of course raises an error. Therefore, this function never works
for any list that has one or more elements!</p><p>Thatâ€™s because we need to make sure we arenâ€™t trying to compute the
maximum of the empty list.
Going back to our examples, we see that what we need to do, before
calling <code data-lang="pyret" class="sourceCode">my-max</code>, is check whether the rest of the list is
empty. If it is, we do not want to call <code data-lang="pyret" class="sourceCode">my-max</code> at all. That is:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; â€¦
        | â€¦
      end
  end
end</code></pre><p>Weâ€™ll return to what to do when the rest is not empty in a moment.</p><p>If the rest of the list <code data-lang="pyret" class="sourceCode">l</code> is empty, our examples above tell us
that the maximum is the first element in the list. Therefore, we can
fill this in:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; f
        | â€¦
      end
  end
end</code></pre><p>Note in particular the absence of a call to <code data-lang="pyret" class="sourceCode">my-max</code>. If the list
is not empty, however, our examples above tell us that <code data-lang="pyret" class="sourceCode">my-max</code>
will give us the maximum of the rest of the list, and we just need to
compare this answer with the first element (<code data-lang="pyret" class="sourceCode">f</code>):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; f
        | else  =&gt; num-max(f, my-max(r))
      end
  end
end</code></pre><p>And sure enough, this definition does the job!</p></section></section><section class="SsectionLevel4" id="section 5.2.7"><h4 class="heading">5.2.7Â <a name="(part._.More_.Structural_.Problems_with_.Scalar_.Answers)"/>More Structural Problems with Scalar Answers<a href="#(part._.More_.Structural_.Problems_with_.Scalar_.Answers)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><section class="SsectionLevel5" id="section 5.2.7.1"><h5 class="heading">5.2.7.1Â <a name="(part._avg-eg)"/><code data-lang="pyret" class="sourceCode">my-avg</code>: Examples<a href="#(part._avg-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s now try to compute the average of a list of numbers. Letâ€™s start
with the example list <code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4]</code> and work out more
examples from it. The average of numbers in this list is clearly
<code data-lang="pyret" class="sourceCode">(1 + 2 + 3 + 4)/4</code>, or <code data-lang="pyret" class="sourceCode">10/4</code>.</p><p>Based on the listâ€™s structure, we see that the rest of the list is
<code data-lang="pyret" class="sourceCode">[list: 2, 3, 4]</code>, and the rest of that is <code data-lang="pyret" class="sourceCode">[list: 3, 4]</code>,
and so on. The resulting averages are:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-avg([list: 1, 2, 3, 4]) is 10/4
my-avg([list:    2, 3, 4]) is 9/3
my-avg([list:       3, 4]) is 7/2
my-avg([list:          4]) is 4/1</code></pre><p>The problem is, itâ€™s simply not clear how we get from the answer for
the sub-list to the answer for the whole list. That is, given the
following two bits of information:
</p><ul><li><p>The average of the remainder of the list is <code data-lang="pyret" class="sourceCode">9/3</code>, i.e.,
<code data-lang="pyret" class="sourceCode">3</code>.</p></li><li><p>The first number in the list is <code data-lang="pyret" class="sourceCode">1</code>.</p></li></ul><p>How do we determine that the average of the whole list must be
<code data-lang="pyret" class="sourceCode">10/4</code>? If itâ€™s not clear to you, donâ€™t worry: with just those
two pieces of information, itâ€™s impossible!</p><p>Hereâ€™s a simpler example that explains why. Letâ€™s suppose the first
value in a list is <code data-lang="pyret" class="sourceCode">1</code>, and the average of the rest of the list
is <code data-lang="pyret" class="sourceCode">2</code>. Here are two very different lists that fit this
description:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2]    # the rest has one element with sum 2
[list: 1, 4, 0] # the rest has two elements with sum 4</code></pre><p>The average of the entire first list is <code data-lang="pyret" class="sourceCode">3/2</code>, while the average
of the entire second list is <code data-lang="pyret" class="sourceCode">5/3</code>, and the two are not the same.</p><p>That is, to compute the average of a whole list, itâ€™s not even useful to
know the average of the rest of the list. Rather, we need to
know the sum and the length of the rest of the
list. With these two, we can add the first to the sum, and <code data-lang="pyret" class="sourceCode">1</code> to
the length, and compute the new average.</p><p>In principle, we could try to make a <code data-lang="pyret" class="sourceCode">average</code> function that
returns all this information. Instead, it will be a lot simpler to
simply decompose the task into two smaller tasks. After all, we
have already seen how to compute the length and how to compute the
sum. The average, therefore, can just use these existing functions:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-avg(l):
  my-sum(l) / my-len(l)
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What should be the average of the empty list? Does the above code
produce what you would expect?</p></blockquote></blockquote><p>Just as we argued earlier about the maximum
[<a href="#%28part._struct-prob-sub-dom%29" data-pltdoc="x">Structural Problems Over Relaxed Domains</a>], the average of the empty list isnâ€™t
a well-defined concept. Therefore, it would be appropriate to signal
an error. The implementation above does this, but poorly: it reports
an error on division. A better programming practice would be to
catch this situation and report the error right away, rather than
hoping some other function will report the error.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Alter <code data-lang="pyret" class="sourceCode">my-avg</code> above to signal an error when given the empty
list.</p></blockquote></blockquote><p>Therefore, we see that the process weâ€™ve usedâ€”<wbr/>of inferring code from
examplesâ€”<wbr/>wonâ€™t always suffice, and weâ€™ll need more
sophisticated techniques to solve some problems. However, notice that
working from examples helps us quickly identify situations
where this approach does and doesnâ€™t work. Furthermore, if you look
more closely youâ€™ll notice that the examples above do hint at
how to solve the problem: in our very first examples, we wrote answers
like <code data-lang="pyret" class="sourceCode">10/4</code>, <code data-lang="pyret" class="sourceCode">9/3</code>, and <code data-lang="pyret" class="sourceCode">7/2</code>, which correspond to the
sum of the numbers divided by the length. Thus, writing the answers in
this form (as opposed, for instance, to writing the second of those as
<code data-lang="pyret" class="sourceCode">3</code>) already reveals a structure for a solution.</p></section></section><section class="SsectionLevel4" id="section 5.2.8"><h4 class="heading">5.2.8Â <a name="(part._accumulators)"/>Structural Problems with Accumulators<a href="#(part._accumulators)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><section class="SsectionLevel5" id="section 5.2.8.1"><h5 class="heading">5.2.8.1Â <a name="(part._running-sum-1st-attempt)"/><code data-lang="pyret" class="sourceCode">my-running-sum</code>: First Attempt<a href="#(part._running-sum-1st-attempt)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>One more time, weâ€™ll begin with an example.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Work out the results for <code data-lang="pyret" class="sourceCode">my-running-sum</code> starting from the list
<code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4, 5]</code>.</p></blockquote></blockquote><p>Hereâ€™s what our first few examples look like:
</p><a name="(elem._running-sum-egs-1)"/>&lt;running-sum-egs-1&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
  my-running-sum([list:    2, 3, 4, 5]) is [list: 2, 5, 9, 14]
  my-running-sum([list:       3, 4, 5]) is [list: 3, 7, 12]
end</code></pre><p>Again, there doesnâ€™t appear to be any clear connection between the
result on the rest of the list and the result on the entire list.</p><p>(That isnâ€™t strictly true: we can still line up the answers as
follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
my-running-sum([list:    2, 3, 4, 5]) is [list:    2, 5,  9, 14]
my-running-sum([list:       3, 4, 5]) is [list:       3,  7, 12]</code></pre><p>and observe that weâ€™re computing the answer for the rest of the list,
then adding the first element to each element in the answer, and
<code data-lang="pyret" class="sourceCode">link</code>ing the first element to the front. In principle, we can
compute this solution directly, but for
now that may be more work than finding a simpler way to answer it.)</p></section><section class="SsectionLevel5" id="section 5.2.8.2"><h5 class="heading">5.2.8.2Â <a name="(part._running-sum-eg-code)"/><code data-lang="pyret" class="sourceCode">my-running-sum</code>: Examples and Code<a href="#(part._running-sum-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Recall how we began in <a href="#%28part._running-sum-1st-attempt%29" data-pltdoc="x"><code data-lang="pyret" class="sourceCode">my-running-sum</code>: First Attempt</a>. Our
examples [<a href="#%28elem._running-sum-egs-1%29" data-pltdoc="x">&lt;running-sum-egs-1&gt;</a>] showed the following
problem. When we process the rest of the list, we have forgotten
everything about what preceded it. That is, when processing the list
starting at <code data-lang="pyret" class="sourceCode">2</code> we forget that weâ€™ve seen a <code data-lang="pyret" class="sourceCode">1</code> earlier;
when starting from <code data-lang="pyret" class="sourceCode">3</code>, we forget that weâ€™ve seen both <code data-lang="pyret" class="sourceCode">1</code>
and <code data-lang="pyret" class="sourceCode">2</code> earlier; and so on. In other words, we keep
forgetting the past. We need some way of avoiding that.</p><p>The easiest thing we can do is simply change our function to carry
along this â€œmemoryâ€, or what weâ€™ll call an accumulator. That
is, imagine we were defining a new function, called <code data-lang="pyret" class="sourceCode">my-rs</code>. It
will consume a list of numbers and produce a list of numbers, but in
addition it will also take the sum of numbers preceding the
current list.
</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What should the initial sum be?</p></blockquote></blockquote><p>Initially there is no â€œpreceding listâ€, so we will use the additive
identity: <code data-lang="pyret" class="sourceCode">0</code>. The type of <code data-lang="pyret" class="sourceCode">my-rs</code> is
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs :: Number, List&lt;Number&gt; -&gt; List&lt;Number&gt;</code></pre><p>Letâ€™s now re-work our examples from <a href="#%28elem._running-sum-egs-1%29" data-pltdoc="x">&lt;running-sum-egs-1&gt;</a> as
examples of <code data-lang="pyret" class="sourceCode">my-rs</code> instead. The examples use the <code data-lang="pyret" class="sourceCode">+</code>
operator to append two lists into one (the elements of the first list
followed by the elements of the second):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs( 0, [list: 1, 2, 3, 4, 5]) is [list:  0 + 1] + my-rs( 0 + 1, [list: 2, 3, 4, 5])
my-rs( 1, [list:    2, 3, 4, 5]) is [list:  1 + 2] + my-rs( 1 + 2, [list:    3, 4, 5])
my-rs( 3, [list:       3, 4, 5]) is [list:  3 + 3] + my-rs( 3 + 3, [list:       4, 5])
my-rs( 6, [list:          4, 5]) is [list:  6 + 4] + my-rs( 6 + 4, [list:          5])
my-rs(10, [list:             5]) is [list: 10 + 5] + my-rs(10 + 5, [list:           ])
my-rs(15, [list:              ]) is empty</code></pre><p>That is, <code data-lang="pyret" class="sourceCode">my-rs</code> translates into the following code:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-rs(acc, l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      new-sum = acc + f
      link(new-sum, my-rs(new-sum, r))
  end
end</code></pre><p>All thatâ€™s then left is to call it from <code data-lang="pyret" class="sourceCode">my-running-sum</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-running-sum(l):
  my-rs(0, l)
end</code></pre><p>Observe that we do not change <code data-lang="pyret" class="sourceCode">my-running-sum</code> itself to take
extra arguments. The correctness of our code depends on the initial
value of <code data-lang="pyret" class="sourceCode">acc</code> being 0. If we added a parameter for <code data-lang="pyret" class="sourceCode">acc</code>,
any code that calls <code data-lang="pyret" class="sourceCode">my-running-sum</code> could supply an unexpected
value, which would distort the result. In addition, since the value is
fixed, adding the parameter would amount to shifting additional (and
needless) work onto others who use our code.</p></section><section class="SsectionLevel5" id="section 5.2.8.3"><h5 class="heading">5.2.8.3Â <a name="(part._alternating-accumulator)"/><code data-lang="pyret" class="sourceCode">my-alternating</code>: Examples and Code<a href="#(part._alternating-accumulator)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Recall our examples in <a href="#%28part._alternating-eg-code%29" data-pltdoc="x"><code data-lang="pyret" class="sourceCode">my-alternating</code>:
Examples and Code</a>. There, we
noticed that the code built on every-other example. We might have
chosen our examples differently, so that from one example to the next
we skipped two elements rather than one.
Here we will see another way to think about the same problem.</p><p>Return to the examples weâ€™ve already seen
[<a href="#%28elem._alternating-egs-1%29" data-pltdoc="x">&lt;alternating-egs-1&gt;</a>]. We wrote <code data-lang="pyret" class="sourceCode">my-alternating</code>
to traverse the list essentially two elements at a time. Another option is to traverse it just one
element at a time, but keeping track of whether weâ€™re at an odd
or even elementâ€”<wbr/>i.e., add â€œmemoryâ€ to our program. Since we just
need to track that one piece of information, we can use a
<code data-lang="pyret" class="sourceCode">Boolean</code> to do it. Letâ€™s define a new function for this purpose:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alt :: List&lt;Any&gt;, Boolean -&gt; List&lt;Any&gt;</code></pre><p>The extra argument accumulates whether weâ€™re at an element to keep or
one to discard.</p><p>We can reuse the existing template for list functions. When we have an
element, we have to consult the accumulator whether to keep it or
not. If its value is <code data-lang="pyret" class="sourceCode">true</code> we <code data-lang="pyret" class="sourceCode">link</code> it to the answer;
otherwise we ignore it. As we process the rest of the list, however,
we have to remember to update the accumulator: if we kept an element
we donâ€™t wish to keep the next one, and vice versa.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alt(l, keep):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if keep:
        link(f, my-alt(r, false))
      else:
        my-alt(r, true)
      end
  end
end</code></pre><p>Finally, we have to determine the initial value of the accumulator. In
this case, since we want to keep alternating elements starting
with the first one, its initial value should be <code data-lang="pyret" class="sourceCode">true</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  my-alt(l, true)
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Define <code data-lang="pyret" class="sourceCode">my-max</code> using an accumulator. What does the accumulator
represent? Do you encounter any difficulty?</p></blockquote></blockquote></section></section><section class="SsectionLevel4" id="section 5.2.9"><h4 class="heading">5.2.9Â <a name="(part._.Dealing_with_.Multiple_.Answers)"/>Dealing with Multiple Answers<a href="#(part._.Dealing_with_.Multiple_.Answers)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Our discussion above has assumed there is only one answer for a given
input. This is often true, but it also depends on how the problem is
worded and how we choose to generate examples. We will study this in
some detail now.</p><section class="SsectionLevel5" id="section 5.2.9.1"><h5 class="heading">5.2.9.1Â <a name="(part._uniq)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Problem Setup<a href="#(part._uniq)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Consider the task of writing <code data-lang="pyret" class="sourceCode">uniq</code>:uniq is the
name of a Unix utility with similar behavior; hence the spelling of
the name. given a list of values, it produces a collection of the
same elements while avoiding any duplicates (hence <code data-lang="pyret" class="sourceCode">uniq</code>, short
for â€œuniqueâ€).</p><p>Consider the following input: <code data-lang="pyret" class="sourceCode">[list: 1, 2, 1, 3, 1, 2, 4, 1]</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What is the sequence of examples this input generates?  Itâ€™s
really important you stop and try to do this by hand. As we
will see there are multiple solutions, and itâ€™s useful for you to
consider what you generate. Even if you canâ€™t generate a sequence,
trying to do so will better prepare you for what you read next.</p></blockquote></blockquote><p>How did you obtain your example? If you just â€œthought about it for a
moment and wrote something downâ€, you may or may not have gotten
something you can turn into a program. Programs can only proceed
systematically; they canâ€™t â€œthinkâ€. So, hopefully you took a
well-defined path to computing the answer.</p></section><section class="SsectionLevel5" id="section 5.2.9.2"><h5 class="heading">5.2.9.2Â <a name="(part._uniq-eg)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Examples<a href="#(part._uniq-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>It turns out there are several possible answers, because we
have (intentionally) left the problem unspecified. Suppose there are
two instances of a value in the list; which one do we keep, the first
or the second? On the one hand, since the two instances must be
equivalent it doesnâ€™t matter, but it does for writing concrete
examples and deriving a solution.</p><p>For instance, you might have generated this sequence:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">examples:
  uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:    2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:       1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:          3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:             1, 2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                   4, 1]) is [list:       4, 1]
  uniq([list:                      1]) is [list:          1]
  uniq([list:                       ]) is [list:           ]
end</code></pre><p>However, you might have also generated sequences that began with
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 1, 2, 3, 4]</code></pre><p>or
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 4, 3, 2, 1]</code></pre><p>and so on. Letâ€™s work with the examples weâ€™ve worked out above.</p></section><section class="SsectionLevel5" id="section 5.2.9.3"><h5 class="heading">5.2.9.3Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Code<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>What is the systematic approach that gets us to this answer?
When given a non-empty list, we split it into its first element and
the rest of the list. Suppose we have the answer to <code data-lang="pyret" class="sourceCode">uniq</code>
applied to the rest of the list. Now we can ask: is the first element
in the rest of the list? If it is, then we can ignore it, since it is
certain to be in the <code data-lang="pyret" class="sourceCode">uniq</code> of the rest of the list. If, however,
it is not in the rest of the list, itâ€™s critical that we <code data-lang="pyret" class="sourceCode">link</code>
it to the answer.</p><p>This translates into the following program. For the empty list, we
return the empty list. If the list is non-empty, we check whether the
first is in the rest of the list. If it is not, we include it;
otherwise we can ignore it for now.</p><p>This results in the following program:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if r.member(f):
        uniq-rec(r)
      else:
        link(f, uniq-rec(r))
      end
  end
end</code></pre><p>which weâ€™ve called <code data-lang="pyret" class="sourceCode">uniq-rec</code> instead of <code data-lang="pyret" class="sourceCode">uniq</code> to
differentiate it from other versions of <code data-lang="pyret" class="sourceCode">uniq</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Note that weâ€™re using <code data-lang="pyret" class="sourceCode">.member</code> to check whether an element is a
member of the list. Write a function <code data-lang="pyret" class="sourceCode">member</code> that consumes an
element and a list, and tells us whether the element is a member of
the list.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Uniqueness checking has many practical applications. For example, one
might have a list of names of people who have registered to vote in an
election. To keep the voting fair, with only one vote allowed per
person, we should remove duplicate names from the list.</p><ol><li><p>Propose a set of examples for a function <code data-lang="pyret" class="sourceCode">rem-duplicate-voters</code>
that takes a list of voter names and returns a list in which duplicate
registrations have been removed. In developing your examples, consider
real-world scenarios that you can imagine arising when identifying
duplicate names. Can you identify cases in which two names
might appear to be the same person, but not be? Cases in which two
names might appear different but be referring to the same person?</p></li><li><p>What might you need to change about our current <code data-lang="pyret" class="sourceCode">uniq-rec</code>
function to handle a situation like removing duplicate voters?</p></li></ol></blockquote></blockquote><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Context Matters When Comparing Values</p><blockquote class="RespCSBody"><p>The data de-duplication context in the above exercise reminds us that
different contexts may call for different notions of when two data values
are the same. Sometimes, we want exact matching to determine that two
strings are equal. Sometimes, we need methods that normalize data,
either in simple ways like capitalization or subtler ways based on
middle initials. Sometimes, we need more information (like street
addresses in addition to names) in order to determine whether two
items in a list should be considered â€œthe sameâ€.</p><p>It is easy to write programs that encode assumptions about our data
that might not apply in practice.  This is again a situation that can
be helped by thinking about the concrete examples on which your code
needs to work in context.  </p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.2.9.4"><h5 class="heading">5.2.9.4Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Reducing Computation<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Notice that this function has a repeated expression. Instead of
writing it twice, we could call it just once and use the result in
both places:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec2(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      ur = uniq-rec2(r)
      if r.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end</code></pre><p>You might think, because we replaced two function calls with one, that
weâ€™ve reduced the amount of computation the program does. It does not!
The two function calls are both in the two branches of the same
conditional; therefore, for any given list element, only one or the
other call to <code data-lang="pyret" class="sourceCode">uniq</code> happens. In fact, in both cases, there was
one call to <code data-lang="pyret" class="sourceCode">uniq</code> before, and there is one now. So we have
reduced the number of calls in the source program, but not the number
that take place when the program runs. In that sense, the name of this
section was intentionally misleading!</p><p>However, there is one useful reduction we can perform, which is
enabled by the structure of <code data-lang="pyret" class="sourceCode">uniq-rec2</code>. We currently check
whether <code data-lang="pyret" class="sourceCode">f</code> is a member of <code data-lang="pyret" class="sourceCode">r</code>, which is the list of
all the remaining elements. In our example, this means that in
the very second turn, we check whether <code data-lang="pyret" class="sourceCode">2</code> is a member of the list
<code data-lang="pyret" class="sourceCode">[list: 1, 3, 1, 2, 4, 1]</code>. This is a list of six elements,
including three copies of <code data-lang="pyret" class="sourceCode">1</code>. We compare <code data-lang="pyret" class="sourceCode">2</code> against
two copies of <code data-lang="pyret" class="sourceCode">1</code>. However, we gain nothing from the
second comparison. Put differently, we can think of <code data-lang="pyret" class="sourceCode">uniq(r)</code> as
a â€œsummaryâ€ of the rest of the list that is exactly as good as
<code data-lang="pyret" class="sourceCode">r</code> itself for checking membership, with the advantage that it
might be significantly shorter. This, of course, is exactly what
<code data-lang="pyret" class="sourceCode">ur</code> represents. Therefore, we can encode this intuition as
follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec3(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      ur = uniq-rec3(r)
      if ur.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end</code></pre><p>Note that all that changed is that we check for membership in
<code data-lang="pyret" class="sourceCode">ur</code> rather than in <code data-lang="pyret" class="sourceCode">r</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Later [<a href="predicting-growth.html" data-pltdoc="x">Predicting Growth</a>] we will study how to formally
study how long a program takes to run. By the measure introduced in
that section, does the change we just made make any difference? Be
careful with your answer: it depends on how we count â€œthe lengthâ€ of
the list.</p></blockquote></blockquote><p>Observe that if the list never contained duplicates in the first
place, then it wouldnâ€™t matter which list we check membership inâ€”<wbr/>but
if we knew the list didnâ€™t contain duplicates, we wouldnâ€™t be
using <code data-lang="pyret" class="sourceCode">uniq</code> in the first place! We will return to the issue of
lists and duplicate elements in <a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>.</p></section><section class="SsectionLevel5" id="section 5.2.9.5"><h5 class="heading">5.2.9.5Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Example and Code Variations<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>As we mentioned earlier, there are other example sequences you might
have written down. Hereâ€™s a very different process:
</p><ul><li><p>Start with the entire given list and with the empty answer (so
far).</p></li><li><p>For each list element, check whether itâ€™s already in the answer
so far. If it is, ignore it, otherwise extend the answer with it.</p></li><li><p>When there are no more elements in the list, the answer so far
is the answer for the whole list.</p></li></ul><p>Notice that this solution assumes that we will be accumulating the
answer as we traverse the list. Therefore, we canâ€™t even write the
example with one parameter as we did before. We would argue that a
natural solution asks whether we can solve the problem just
from the structure of the data using the computation we are already
defining, as we did above. If we cannot, then we have to resort to an
accumulator. But because we can, the accumulator is unnecessary here
and greatly complicates even writing down examples (give it a try!).</p></section><section class="SsectionLevel5" id="section 5.2.9.6"><h5 class="heading">5.2.9.6Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Why Produce a List?<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>If you go back to the original statement of the <code data-lang="pyret" class="sourceCode">uniq</code> problem
[<a href="#%28part._uniq%29" data-pltdoc="x"><code data-lang="pyret" class="sourceCode">uniq</code>: Problem Setup</a>], youâ€™ll notice it said nothing about what order the
output should have; in fact, it didnâ€™t even say the output needs to be
a list (and hence have an order). In that case, we should think about
whether a list even makes sense for this problem. In fact, if we donâ€™t
care about order and donâ€™t want duplicates (by definition of
<code data-lang="pyret" class="sourceCode">uniq</code>), then there is a much simpler solution, which is to
produce a set. Pyret already has sets built in, and converting
the list to a set automatically takes care of duplicates. This is of
course cheating from the perspective of learning how to write
<code data-lang="pyret" class="sourceCode">uniq</code>, but it is worth remembering that sometimes the right data
structure to produce isnâ€™t necessarily the same as the one we were
given. Also, later [<a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>], we will see how to build sets
for ourselves (at which point, <code data-lang="pyret" class="sourceCode">uniq</code> will look familiar, since
it is at the heart of set-ness).</p></section></section><section class="SsectionLevel4" id="section 5.2.10"><h4 class="heading">5.2.10Â <a name="(part._polymorphic-data)"/>Monomorphic Lists and Polymorphic Types<a href="#(part._polymorphic-data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Earlier we wrote contracts like:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len :: List&lt;Any&gt; -&gt; Number
my-max :: List&lt;Any&gt; -&gt; Any</code></pre><p>These are unsatisfying for several reasons. Consider
<code data-lang="pyret" class="sourceCode">my-max</code>. The contract suggests that any kind of element can be
in the input list, but in fact that isnâ€™t true: the input
<code data-lang="pyret" class="sourceCode">[list: 1, "two", 3]</code> is not valid, because we canâ€™t compare
<code data-lang="pyret" class="sourceCode">1</code> with <code data-lang="pyret" class="sourceCode">"two"</code> or <code data-lang="pyret" class="sourceCode">"two"</code> with <code data-lang="pyret" class="sourceCode">3</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>What happens if we run <code data-lang="pyret" class="sourceCode">1 &gt; "two"</code> or <code data-lang="pyret" class="sourceCode">"two" &gt; 3</code>?</p></blockquote></blockquote><p>Rather, what we mean is a list where all the elements are of the
same kind,Technically, elements that are also comparable.
and the contract has not captured that. Furthermore, we donâ€™t mean
that <code data-lang="pyret" class="sourceCode">my-max</code> might return any old type: if we supply it with a
list of numbers, we will not get a string as the maximum element!
Rather, it will only return the kind of element that is in the
provided list.</p><p>In short, we mean that all elements of the list are of the same type,
but they can be of any type. We call the former monomorphic:
â€œmonoâ€ meaning one, and â€œmorphicâ€ meaning shape, i.e., all values
have one type. But the function <code data-lang="pyret" class="sourceCode">my-max</code> itself can operate over
many of these kinds of lists, so we call it polymorphic
(â€œpolyâ€ meaning many).</p><p>Therefore, we need a better way of writing these
contracts. Essentially, we want to say that there is a
type variable (as opposed to regular program variable) that represents the
type of element in the list. Given that type, <code data-lang="pyret" class="sourceCode">my-max</code> will
return an element of that type. We write this syntactically as
follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max&lt;T&gt;(l :: List&lt;T&gt;) -&gt; T: â€¦ end</code></pre><p>The notation <code data-lang="pyret" class="sourceCode">&lt;T&gt;</code> says that <code data-lang="pyret" class="sourceCode">T</code> is a type variable
parameter that will be used in the rest of the function (both the
header and the body).</p><p>Using this notation, we can also revisit <code data-lang="pyret" class="sourceCode">my-len</code>. Its header now
becomes:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-len&lt;T&gt;(l :: List&lt;T&gt;) -&gt; Number: â€¦ end</code></pre><p>Note that <code data-lang="pyret" class="sourceCode">my-len</code> did not actually â€œcareâ€ that whether all the
values were of the same type or not: it never looks at the individual
elements, much less at pairs of them. However, as a convention
we demand that lists always be monomorphic. This is important because
it enables us to process the elements of the list uniformly: if we
know how to process elements of type <code data-lang="pyret" class="sourceCode">T</code>, then we will know how
to process a <code data-lang="pyret" class="sourceCode">List&lt;T&gt;</code>. If the list elements can be of truly any
old type, we canâ€™t know how to process its elements.</p></section>&#13;
<h4 class="heading">5.2.1Â <a name="(part._.Making_.Lists_and_.Taking_.Them_.Apart)"/>Making Lists and Taking Them Apart<a href="#(part._.Making_.Lists_and_.Taking_.Them_.Apart)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>So far weâ€™ve seen one way to make a list: by writing
<code data-lang="pyret" class="sourceCode">[list: â€¦]</code>. While useful, writing lists this way actually
hides their true nature. Every list actually has two parts: a
first element and the rest of the list. The rest of the
list is itself a list, so it too has two partsâ€¦and so on.</p><p>Consider the list <code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code>. Its first element is <code data-lang="pyret" class="sourceCode">1</code>, and
the rest of it is <code data-lang="pyret" class="sourceCode">[list: 2, 3]</code>. For this second list, the first element
is <code data-lang="pyret" class="sourceCode">2</code> and the rest is <code data-lang="pyret" class="sourceCode">[list: 3]</code>.
</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Take apart this third list.</p></blockquote></blockquote><p>For the third list, the first element is <code data-lang="pyret" class="sourceCode">3</code> and the rest is
<code data-lang="pyret" class="sourceCode">[list: ]</code>, i.e., the empty list. In Pyret, we have another way
of writing the empty list: <code data-lang="pyret" class="sourceCode">empty</code>.</p><p>Lists are an instance of structured data: data with component
parts and a well-defined format for the shape of the parts. Lists are
formatted by the first element and the rest of the elements. Tables
are somewhat structured: they are formatted by rows and columns, but
the column names arenâ€™t consistent across all tables.  Structured data
is valuable in programming because a predictable format (the
structure) lets us write programs based on that structure. What do we
mean by that?</p><p>Programming languages can (and do!) provide built-in operators for
taking apart structured data. These operators are called
accessors. Accessors are defined on the structure of the
datatype alone, independent of the contents of the data. In the case
of lists, there are two accessors: <code data-lang="pyret" class="sourceCode">first</code> and
<code data-lang="pyret" class="sourceCode">rest</code>. We use an accessor by writing an expression, followed by
a dot (<code data-lang="pyret" class="sourceCode">.</code>), followed by the accessorâ€™s name. As we saw with
tables, the dot means "dig into". Thus:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l1 = [list: 1, 2, 3]
e1 = l1.first
l2 = l1.rest
e2 = l2.first
l3 = l2.rest
e3 = l3.first
l4 = l3.rest

check:
  e1 is 1
  e2 is 2
  e3 is 3
  l2 is [list: 2, 3]
  l3 is [list: 3]
  l4 is empty
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What are the accessors for tables?</p></blockquote></blockquote><p>Accessors give a way to take data apart based on their structure
(there is another way that we will see shortly). Is there a way to
also build data based on its structure? So far, we have been
building lists using the <code data-lang="pyret" class="sourceCode">[list: ...]</code> form, but that doesnâ€™t
emphasize the structural constraint that the <code data-lang="pyret" class="sourceCode">rest</code> is itself a
list. A structured operator for building lists would clearly show both
a <code data-lang="pyret" class="sourceCode">first</code> element and a <code data-lang="pyret" class="sourceCode">rest</code> that is itself a
list. Operators for building structured data are called
constructors.</p><p>The constructor for lists is called <code data-lang="pyret" class="sourceCode">link</code>. It takes two
arguments: a <code data-lang="pyret" class="sourceCode">first</code> element, and the list to build on (the
<code data-lang="pyret" class="sourceCode">rest</code> part). Hereâ€™s an example of using <code data-lang="pyret" class="sourceCode">link</code> to create a
three-element list.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link(1, link(2, link(3, empty)))</code></pre><p>The <code data-lang="pyret" class="sourceCode">link</code> form creates the same underlying list datum as our
previous <code data-lang="pyret" class="sourceCode">[list: ...]</code> operation, as confirmed by the following
check:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  [list: 1, 2, 3] is link(1, link(2, link(3, empty)))
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Look at these two forms of writing lists: what differences do you notice?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use the <code data-lang="pyret" class="sourceCode">link</code> form to write a four-element list of fruits containing
<code data-lang="pyret" class="sourceCode">"lychee"</code>, <code data-lang="pyret" class="sourceCode">"dates"</code>, <code data-lang="pyret" class="sourceCode">"mango"</code>, and <code data-lang="pyret" class="sourceCode">"durian"</code>.</p></blockquote></blockquote><p>After doing this exercise, you might wonder why anyone would use the
<code data-lang="pyret" class="sourceCode">link</code> form: itâ€™s more verbose, and makes the individual elements
harder to discern. This form is not very convenient to
humans. But it will prove very valuable to programs!</p><p>In particular, the <code data-lang="pyret" class="sourceCode">link</code> form highlights that we really have
two different structures of lists.
Some lists are empty. All other lists are non-empty
lists, meaning they have at least one <code data-lang="pyret" class="sourceCode">link</code>. There may be
more interesting structure to some lists (as we will see later), but all lists have this much
in common. Specifically, a list is either
</p><ul><li><p>empty (written <code data-lang="pyret" class="sourceCode">empty</code> or <code data-lang="pyret" class="sourceCode">[list: ]</code>), or</p></li><li><p>non-empty (written <code data-lang="pyret" class="sourceCode">link(â€¦, â€¦)</code> or <code data-lang="pyret" class="sourceCode">[list: ]</code> with
at least one value inside the brackets), where the rest is also
a list (and hence may in turn be empty or non-empty, â€¦).</p></li></ul><p>This means we actually have two structural features of lists, both of
which are important when writing programs over lists:
</p><ol><li><p>Lists can be empty or non-empty</p></li><li><p>Non-empty lists have a first element and a rest of the list</p></li></ol><p>Letâ€™s leverage these two structural features to write some programs to
process lists!</p>&#13;
<h4 class="heading">5.2.2Â <a name="(part._my-len)"/>Some Example Exercises<a href="#(part._my-len)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>To illustrate our thinking, letâ€™s work through a few concrete examples
of list-processing functions. All of these will consume lists; some
will even produce them. Some will transform their inputs (like
<code data-lang="pyret" class="sourceCode">map</code>), some will select from their inputs (like <code data-lang="pyret" class="sourceCode">filter</code>),
and some will aggregate their inputs. Since some of these functions already exist in
Pyret, weâ€™ll name them with the prefix <code data-lang="pyret" class="sourceCode">my-</code> to avoid
errors.Be sure to use the <code data-lang="pyret" class="sourceCode">my-</code> name consistently,
including inside the body of the function. As we will see, there is a
standard strategy that we can use to approach writing all of these
functions: having you learn this strategy is the goal of this chapter.</p>&#13;
<h4 class="heading">5.2.3Â <a name="(part._.Structural_.Problems_with_.Scalar_.Answers)"/>Structural Problems with Scalar Answers<a href="#(part._.Structural_.Problems_with_.Scalar_.Answers)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Letâ€™s write out examples for a few of the functions described
above. Weâ€™ll approach writing examples in a very specific, stylized
way. First of all, we should always construct at least two examples:
one with <code data-lang="pyret" class="sourceCode">empty</code> and the other with at least one <code data-lang="pyret" class="sourceCode">link</code>, so
that weâ€™ve covered the two very broad kinds of lists. Then, we should
have more examples specific to the kind of list stated in the
problem. Finally, we should have even more examples to illustrate how
we think about solving the problem.</p><section class="SsectionLevel5" id="section 5.2.3.1"><h5 class="heading">5.2.3.1Â <a name="(part._len-eg)"/><code data-lang="pyret" class="sourceCode">my-len</code>: Examples<a href="#(part._len-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>We haveâ€™t precisely defined what it means to be â€œthe lengthâ€ of a
list. We confront this right away when trying to write an
example. What is the length of the list <code data-lang="pyret" class="sourceCode">empty</code>?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you think?</p></blockquote></blockquote><p>Two common examples are <code data-lang="pyret" class="sourceCode">0</code> and <code data-lang="pyret" class="sourceCode">1</code>. The latter, <code data-lang="pyret" class="sourceCode">1</code>,
certainly looks reasonable. However, if you write the list as
<code data-lang="pyret" class="sourceCode">[list: ]</code>, now it doesnâ€™t look so right: this is clearly (as the
name <code data-lang="pyret" class="sourceCode">empty</code> also suggests) an empty list, and an empty
list has zero elements in it. Therefore, itâ€™s conventional to
declare that
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len(empty) is 0</code></pre><p>How about a list like <code data-lang="pyret" class="sourceCode">[list: 7]</code>? Well, itâ€™s clearly got one
element (<code data-lang="pyret" class="sourceCode">7</code>) in it, so
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7]) is 1</code></pre><p>Similarly, for a list like <code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code>, we would say
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3</code></pre><p>Now letâ€™s look at that last example in a different light. Consider
the argument <code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code>. Its first element is <code data-lang="pyret" class="sourceCode">7</code> and
the rest of it is <code data-lang="pyret" class="sourceCode">[list: 8, 9]</code>. Well, <code data-lang="pyret" class="sourceCode">7</code> is a number, not
a list; but <code data-lang="pyret" class="sourceCode">[list: 8, 9]</code> certainly is a list, so we can ask for
its length. What is <code data-lang="pyret" class="sourceCode">my-len([list: 8, 9])</code>? It has two
elements, so
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 8, 9]) is 2</code></pre><p>The first element of that list is <code data-lang="pyret" class="sourceCode">8</code> while its rest is
<code data-lang="pyret" class="sourceCode">[list: 9]</code>. What is its length?
Note that we asked a very similar question before, for the length of
the list <code data-lang="pyret" class="sourceCode">[list: 7]</code>. But <code data-lang="pyret" class="sourceCode">[list: 7]</code> is not a
sub-list of <code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code>, which we started with,
whereas <code data-lang="pyret" class="sourceCode">[list: 9]</code> is. And using the same reasoning as before,
we can say
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 9]) is 1</code></pre><p>The rest of this last list is, of course, the empty list, whose length
we have already decided is <code data-lang="pyret" class="sourceCode">0</code>.</p><p>Putting together these examples, and writing out <code data-lang="pyret" class="sourceCode">empty</code> in its
other form, hereâ€™s what we get:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3
my-len([list:    8, 9]) is 2
my-len([list:       9]) is 1
my-len([list:        ]) is 0</code></pre><p>Another way we can write this (paying attention to the right side) is
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + 2
my-len([list:    8, 9]) is 1 + 1
my-len([list:       9]) is 1 + 0
my-len([list:        ]) is     0</code></pre><p>Where did the <code data-lang="pyret" class="sourceCode">2</code>, <code data-lang="pyret" class="sourceCode">1</code>, and <code data-lang="pyret" class="sourceCode">0</code> on the right sides of
each <code data-lang="pyret" class="sourceCode">+</code> operation come from? Those are the lengths of the
<code data-lang="pyret" class="sourceCode">rest</code> component of the input list. In the previous example
block, we wrote those lengths as explicit examples. Letâ€™s substitute
the numbers <code data-lang="pyret" class="sourceCode">2</code>, <code data-lang="pyret" class="sourceCode">1</code>, and <code data-lang="pyret" class="sourceCode">0</code> with the <code data-lang="pyret" class="sourceCode">my-len</code>
expressions that produce them:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list:    8, 9]) is 1 + my-len([list:    9])
my-len([list:       9]) is 1 + my-len([list:     ])
my-len([list:        ]) is 0</code></pre><p>From this, maybe you can start to see a pattern. For an empty list,
the length is <code data-lang="pyret" class="sourceCode">0</code>. For a non-empty list, itâ€™s the sum of <code data-lang="pyret" class="sourceCode">1</code>
(the first elementâ€™s â€œcontributionâ€ to the listâ€™s length) to the
length of the rest of the list. In other words, we can use the result
of computing <code data-lang="pyret" class="sourceCode">my-len</code> on the rest of the list to compute the
answer for the entire list.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Each of our examples in this section has written a different check on
the expression <code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9])</code>. Here are those examples
presented together, along with one last one that explicitly uses the
<code data-lang="pyret" class="sourceCode">rest</code> operation:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3
my-len([list: 7, 8, 9]) is 1 + 2
my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)</code></pre><p>Check that you agree with each of these assertions. Also check whether
you understand how the right-hand side of each <code data-lang="pyret" class="sourceCode">is</code> expression
derives from the right-hand-side just above it. The goal of this
exercise is to make sure that you believe that the last check (which
we will turn into code) is equivalent to the first (which we wrote
down when understanding the problem).</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.2.3.2"><h5 class="heading">5.2.3.2Â <a name="(part._sum-eg)"/><code data-lang="pyret" class="sourceCode">my-sum</code>: Examples<a href="#(part._sum-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s repeat this process of developing examples on a second function,
this time one that computes the sum of the elements in a list of numbers.
What is the
sum of the list <code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code>? Just adding up the numbers by hand,
the result should be <code data-lang="pyret" class="sourceCode">24</code>. Letâ€™s see how that works out through
the examples.</p><p>Setting aside the empty list for a moment, here are examples that show
the sum computations:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum([list: 7, 8, 9]) is 7 + 8 + 9
my-sum([list:    8, 9]) is     8 + 9
my-sum([list:       9]) is         9</code></pre><p>which (by substitution) is the same as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum([list: 7, 8, 9]) is 7 + my-sum([list: 8, 9])
my-sum([list:    8, 9]) is 8 + my-sum([list:    9])
my-sum([list:       9]) is 9 + my-sum([list:     ])</code></pre><p>From this, we can see that the sum of the empty list must be
<code data-lang="pyret" class="sourceCode">0</code>:Zero is called the additive identity: a
fancy way of saying, adding zero to any number N gives you
N. Therefore, it makes sense that it would be the length of the
empty list, because the empty list has no items to contribute to a
sum. Can you figure out what the multiplicative identity is?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum(empty) is 0</code></pre><p>Observe, again, how we can use the result of computing <code data-lang="pyret" class="sourceCode">my-sum</code>
of the rest of the list to compute its result for the whole list.</p></section><section class="SsectionLevel5" id="section 5.2.3.3"><h5 class="heading">5.2.3.3Â <a name="(part._.From_.Examples_to_.Code)"/>From Examples to Code<a href="#(part._.From_.Examples_to_.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Having developed these examples, we now want to use them to develop a
program that can compute the length or the sum of any list, not
just the specific ones we used in these examples. As we have done up
in earlier chapters, we will leverage patterns in the examples to
figure out how to define the general-purpose function.</p><p>Here is one last version of the examples for <code data-lang="pyret" class="sourceCode">my-len</code>, this time
making the <code data-lang="pyret" class="sourceCode">rest</code> explicit on the right-hand sides of <code data-lang="pyret" class="sourceCode">is</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)
my-len([list:        ]) is 0</code></pre><p>As we did when developing functions over images, letâ€™s try to identify
the common parts of these examples. We start by noticing that most of
the examples have a lot in common, except for the <code data-lang="pyret" class="sourceCode">[list: ]</code>
(<code data-lang="pyret" class="sourceCode">empty</code>) case. So letâ€™s separate this into two sets of examples:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)


my-len([list:        ]) is 0</code></pre><p>With this separation (which follows one of the structural features of
lists that we mentioned earlier), a clearer pattern emerges: for a
non-empty list (called <code data-lang="pyret" class="sourceCode">someList</code>), we compute its length via the
expression:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 + my-len(someList.rest)</code></pre><p>In general, then, our <code data-lang="pyret" class="sourceCode">my-len</code> program needs to determine whether
its input list is empty or non-empty, using this expression with
<code data-lang="pyret" class="sourceCode">.rest</code> in the non-empty case. How do we indicate different code
based on the structure of the list?</p><p>Pyret has a construct called <code data-lang="pyret" class="sourceCode">cases</code> which is used to distinguish
different forms within a structured datatype. When working with lists,
the general shape of a <code data-lang="pyret" class="sourceCode">cases</code> expression is:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (List) e:
  | empty      =&gt; â€¦
  | link(f, r) =&gt; â€¦ f â€¦ r â€¦
end</code></pre><p>where most parts are fixed, but a few youâ€™re free to change:
</p><ul><li><p><code data-lang="pyret" class="sourceCode">e</code> is an expression whose value needs to be a list; it
could be a variable bound to a list, or some complex expression that
evaluates to a list.</p></li><li><p><code data-lang="pyret" class="sourceCode">f</code> and <code data-lang="pyret" class="sourceCode">r</code> are names given to the first and rest of
the list. You can choose any names you like, though in Pyret, itâ€™s
conventional to use <code data-lang="pyret" class="sourceCode">f</code> and <code data-lang="pyret" class="sourceCode">r</code>.Occasionally
using different names can help students recall that they can choose
how to label the <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> components. This can be
particularly useful for <code data-lang="pyret" class="sourceCode">first</code>, which has a problem-specific
meaning (such as <code data-lang="pyret" class="sourceCode">price</code> in a list of prices, and so on).</p></li></ul><p>The right-hand side of every <code data-lang="pyret" class="sourceCode">=&gt;</code> is an expression.</p><p>Hereâ€™s how <code data-lang="pyret" class="sourceCode">cases</code> works in this instance. Pyret first evaluates
<code data-lang="pyret" class="sourceCode">e</code>. It then checks that the resulting value truly is a list;
otherwise it halts with an error. If it is a list, Pyret examines what
kind of list it is. If itâ€™s an empty list, it runs the
expression after the <code data-lang="pyret" class="sourceCode">=&gt;</code> in the <code data-lang="pyret" class="sourceCode">empty</code> clause. Otherwise,
the list is not empty, which means it has a first and rest; Pyret
binds <code data-lang="pyret" class="sourceCode">f</code> and <code data-lang="pyret" class="sourceCode">r</code> to the two parts, respectively, and then
evaluates the expression after the <code data-lang="pyret" class="sourceCode">=&gt;</code> in the <code data-lang="pyret" class="sourceCode">link</code> clause.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Try using a non-listâ€”<wbr/>e.g., a numberâ€”<wbr/>in the <code data-lang="pyret" class="sourceCode">e</code> position and
see what happens!</p></blockquote></blockquote><p>Now letâ€™s use <code data-lang="pyret" class="sourceCode">cases</code> to define <code data-lang="pyret" class="sourceCode">my-len</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-len(l):
  cases (List) l:
    | empty      =&gt; 0
    | link(f, r) =&gt; 1 + my-len(r)
  end
end</code></pre><p>This follows from our examples: when the list is empty <code data-lang="pyret" class="sourceCode">my-len</code>
produces <code data-lang="pyret" class="sourceCode">0</code>; when it is not empty, we add one to the length of
the rest of the list (here, <code data-lang="pyret" class="sourceCode">r</code>).</p><p>Note that while our most recent collection of <code data-lang="pyret" class="sourceCode">my-len</code> examples
explicitly said <code data-lang="pyret" class="sourceCode">.rest</code>, when using <code data-lang="pyret" class="sourceCode">cases</code> we instead use
just the name <code data-lang="pyret" class="sourceCode">r</code>, which Pyret has already defined (under the
hood) to be <code data-lang="pyret" class="sourceCode">l.rest</code>.</p><p>Similarly, letâ€™s define <code data-lang="pyret" class="sourceCode">my-sum</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-sum(l):
  cases (List) l:
    | empty      =&gt; 0
    | link(f, r) =&gt; f + my-sum(r)
  end
end</code></pre><p>Notice how similar they are in code, and how readily the structure of
the data suggest a structure for the program. This is a pattern you
will get very used to soon!</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Developing Functions Over Lists</p><blockquote class="StrategyBody"><p>Leverage the structure of lists and the power of concrete examples to
develop list-processing functions.
</p><ul><li><p>Pick a concrete list with (at least) three elements. Write a
sequence of examples for each of the entire list and each suffix of
the list (including the empty list).</p></li><li><p>Rewrite each example to express its expected
answer in terms of the <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> data of its input
list. You donâ€™t have to use the <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> operators
in the new answers, but you should see the <code data-lang="pyret" class="sourceCode">first</code> and
<code data-lang="pyret" class="sourceCode">rest</code> values represented explicitly in the answer.</p></li><li><p>Look for a pattern across the answers in the examples. Use these
to develop the code: write a <code data-lang="pyret" class="sourceCode">cases</code> expression, filling in the
right side of each <code data-lang="pyret" class="sourceCode">=&gt;</code> based on your examples.</p></li></ul><p>This strategy applies to structured data in general, leveraging
components of each datum rather than specifically <code data-lang="pyret" class="sourceCode">first</code> and
<code data-lang="pyret" class="sourceCode">rest</code> as presented so far.</p></blockquote></blockquote></section>&#13;
<h5 class="heading">5.2.3.1Â <a name="(part._len-eg)"/><code data-lang="pyret" class="sourceCode">my-len</code>: Examples<a href="#(part._len-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>We haveâ€™t precisely defined what it means to be â€œthe lengthâ€ of a
list. We confront this right away when trying to write an
example. What is the length of the list <code data-lang="pyret" class="sourceCode">empty</code>?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you think?</p></blockquote></blockquote><p>Two common examples are <code data-lang="pyret" class="sourceCode">0</code> and <code data-lang="pyret" class="sourceCode">1</code>. The latter, <code data-lang="pyret" class="sourceCode">1</code>,
certainly looks reasonable. However, if you write the list as
<code data-lang="pyret" class="sourceCode">[list: ]</code>, now it doesnâ€™t look so right: this is clearly (as the
name <code data-lang="pyret" class="sourceCode">empty</code> also suggests) an empty list, and an empty
list has zero elements in it. Therefore, itâ€™s conventional to
declare that
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len(empty) is 0</code></pre><p>How about a list like <code data-lang="pyret" class="sourceCode">[list: 7]</code>? Well, itâ€™s clearly got one
element (<code data-lang="pyret" class="sourceCode">7</code>) in it, so
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7]) is 1</code></pre><p>Similarly, for a list like <code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code>, we would say
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3</code></pre><p>Now letâ€™s look at that last example in a different light. Consider
the argument <code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code>. Its first element is <code data-lang="pyret" class="sourceCode">7</code> and
the rest of it is <code data-lang="pyret" class="sourceCode">[list: 8, 9]</code>. Well, <code data-lang="pyret" class="sourceCode">7</code> is a number, not
a list; but <code data-lang="pyret" class="sourceCode">[list: 8, 9]</code> certainly is a list, so we can ask for
its length. What is <code data-lang="pyret" class="sourceCode">my-len([list: 8, 9])</code>? It has two
elements, so
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 8, 9]) is 2</code></pre><p>The first element of that list is <code data-lang="pyret" class="sourceCode">8</code> while its rest is
<code data-lang="pyret" class="sourceCode">[list: 9]</code>. What is its length?
Note that we asked a very similar question before, for the length of
the list <code data-lang="pyret" class="sourceCode">[list: 7]</code>. But <code data-lang="pyret" class="sourceCode">[list: 7]</code> is not a
sub-list of <code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code>, which we started with,
whereas <code data-lang="pyret" class="sourceCode">[list: 9]</code> is. And using the same reasoning as before,
we can say
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 9]) is 1</code></pre><p>The rest of this last list is, of course, the empty list, whose length
we have already decided is <code data-lang="pyret" class="sourceCode">0</code>.</p><p>Putting together these examples, and writing out <code data-lang="pyret" class="sourceCode">empty</code> in its
other form, hereâ€™s what we get:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3
my-len([list:    8, 9]) is 2
my-len([list:       9]) is 1
my-len([list:        ]) is 0</code></pre><p>Another way we can write this (paying attention to the right side) is
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + 2
my-len([list:    8, 9]) is 1 + 1
my-len([list:       9]) is 1 + 0
my-len([list:        ]) is     0</code></pre><p>Where did the <code data-lang="pyret" class="sourceCode">2</code>, <code data-lang="pyret" class="sourceCode">1</code>, and <code data-lang="pyret" class="sourceCode">0</code> on the right sides of
each <code data-lang="pyret" class="sourceCode">+</code> operation come from? Those are the lengths of the
<code data-lang="pyret" class="sourceCode">rest</code> component of the input list. In the previous example
block, we wrote those lengths as explicit examples. Letâ€™s substitute
the numbers <code data-lang="pyret" class="sourceCode">2</code>, <code data-lang="pyret" class="sourceCode">1</code>, and <code data-lang="pyret" class="sourceCode">0</code> with the <code data-lang="pyret" class="sourceCode">my-len</code>
expressions that produce them:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list:    8, 9]) is 1 + my-len([list:    9])
my-len([list:       9]) is 1 + my-len([list:     ])
my-len([list:        ]) is 0</code></pre><p>From this, maybe you can start to see a pattern. For an empty list,
the length is <code data-lang="pyret" class="sourceCode">0</code>. For a non-empty list, itâ€™s the sum of <code data-lang="pyret" class="sourceCode">1</code>
(the first elementâ€™s â€œcontributionâ€ to the listâ€™s length) to the
length of the rest of the list. In other words, we can use the result
of computing <code data-lang="pyret" class="sourceCode">my-len</code> on the rest of the list to compute the
answer for the entire list.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Each of our examples in this section has written a different check on
the expression <code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9])</code>. Here are those examples
presented together, along with one last one that explicitly uses the
<code data-lang="pyret" class="sourceCode">rest</code> operation:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3
my-len([list: 7, 8, 9]) is 1 + 2
my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)</code></pre><p>Check that you agree with each of these assertions. Also check whether
you understand how the right-hand side of each <code data-lang="pyret" class="sourceCode">is</code> expression
derives from the right-hand-side just above it. The goal of this
exercise is to make sure that you believe that the last check (which
we will turn into code) is equivalent to the first (which we wrote
down when understanding the problem).</p></blockquote></blockquote>&#13;
<h5 class="heading">5.2.3.2Â <a name="(part._sum-eg)"/><code data-lang="pyret" class="sourceCode">my-sum</code>: Examples<a href="#(part._sum-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s repeat this process of developing examples on a second function,
this time one that computes the sum of the elements in a list of numbers.
What is the
sum of the list <code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code>? Just adding up the numbers by hand,
the result should be <code data-lang="pyret" class="sourceCode">24</code>. Letâ€™s see how that works out through
the examples.</p><p>Setting aside the empty list for a moment, here are examples that show
the sum computations:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum([list: 7, 8, 9]) is 7 + 8 + 9
my-sum([list:    8, 9]) is     8 + 9
my-sum([list:       9]) is         9</code></pre><p>which (by substitution) is the same as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum([list: 7, 8, 9]) is 7 + my-sum([list: 8, 9])
my-sum([list:    8, 9]) is 8 + my-sum([list:    9])
my-sum([list:       9]) is 9 + my-sum([list:     ])</code></pre><p>From this, we can see that the sum of the empty list must be
<code data-lang="pyret" class="sourceCode">0</code>:Zero is called the additive identity: a
fancy way of saying, adding zero to any number N gives you
N. Therefore, it makes sense that it would be the length of the
empty list, because the empty list has no items to contribute to a
sum. Can you figure out what the multiplicative identity is?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum(empty) is 0</code></pre><p>Observe, again, how we can use the result of computing <code data-lang="pyret" class="sourceCode">my-sum</code>
of the rest of the list to compute its result for the whole list.</p>&#13;
<h5 class="heading">5.2.3.3Â <a name="(part._.From_.Examples_to_.Code)"/>From Examples to Code<a href="#(part._.From_.Examples_to_.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Having developed these examples, we now want to use them to develop a
program that can compute the length or the sum of any list, not
just the specific ones we used in these examples. As we have done up
in earlier chapters, we will leverage patterns in the examples to
figure out how to define the general-purpose function.</p><p>Here is one last version of the examples for <code data-lang="pyret" class="sourceCode">my-len</code>, this time
making the <code data-lang="pyret" class="sourceCode">rest</code> explicit on the right-hand sides of <code data-lang="pyret" class="sourceCode">is</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)
my-len([list:        ]) is 0</code></pre><p>As we did when developing functions over images, letâ€™s try to identify
the common parts of these examples. We start by noticing that most of
the examples have a lot in common, except for the <code data-lang="pyret" class="sourceCode">[list: ]</code>
(<code data-lang="pyret" class="sourceCode">empty</code>) case. So letâ€™s separate this into two sets of examples:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)


my-len([list:        ]) is 0</code></pre><p>With this separation (which follows one of the structural features of
lists that we mentioned earlier), a clearer pattern emerges: for a
non-empty list (called <code data-lang="pyret" class="sourceCode">someList</code>), we compute its length via the
expression:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 + my-len(someList.rest)</code></pre><p>In general, then, our <code data-lang="pyret" class="sourceCode">my-len</code> program needs to determine whether
its input list is empty or non-empty, using this expression with
<code data-lang="pyret" class="sourceCode">.rest</code> in the non-empty case. How do we indicate different code
based on the structure of the list?</p><p>Pyret has a construct called <code data-lang="pyret" class="sourceCode">cases</code> which is used to distinguish
different forms within a structured datatype. When working with lists,
the general shape of a <code data-lang="pyret" class="sourceCode">cases</code> expression is:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (List) e:
  | empty      =&gt; â€¦
  | link(f, r) =&gt; â€¦ f â€¦ r â€¦
end</code></pre><p>where most parts are fixed, but a few youâ€™re free to change:
</p><ul><li><p><code data-lang="pyret" class="sourceCode">e</code> is an expression whose value needs to be a list; it
could be a variable bound to a list, or some complex expression that
evaluates to a list.</p></li><li><p><code data-lang="pyret" class="sourceCode">f</code> and <code data-lang="pyret" class="sourceCode">r</code> are names given to the first and rest of
the list. You can choose any names you like, though in Pyret, itâ€™s
conventional to use <code data-lang="pyret" class="sourceCode">f</code> and <code data-lang="pyret" class="sourceCode">r</code>.Occasionally
using different names can help students recall that they can choose
how to label the <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> components. This can be
particularly useful for <code data-lang="pyret" class="sourceCode">first</code>, which has a problem-specific
meaning (such as <code data-lang="pyret" class="sourceCode">price</code> in a list of prices, and so on).</p></li></ul><p>The right-hand side of every <code data-lang="pyret" class="sourceCode">=&gt;</code> is an expression.</p><p>Hereâ€™s how <code data-lang="pyret" class="sourceCode">cases</code> works in this instance. Pyret first evaluates
<code data-lang="pyret" class="sourceCode">e</code>. It then checks that the resulting value truly is a list;
otherwise it halts with an error. If it is a list, Pyret examines what
kind of list it is. If itâ€™s an empty list, it runs the
expression after the <code data-lang="pyret" class="sourceCode">=&gt;</code> in the <code data-lang="pyret" class="sourceCode">empty</code> clause. Otherwise,
the list is not empty, which means it has a first and rest; Pyret
binds <code data-lang="pyret" class="sourceCode">f</code> and <code data-lang="pyret" class="sourceCode">r</code> to the two parts, respectively, and then
evaluates the expression after the <code data-lang="pyret" class="sourceCode">=&gt;</code> in the <code data-lang="pyret" class="sourceCode">link</code> clause.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Try using a non-listâ€”<wbr/>e.g., a numberâ€”<wbr/>in the <code data-lang="pyret" class="sourceCode">e</code> position and
see what happens!</p></blockquote></blockquote><p>Now letâ€™s use <code data-lang="pyret" class="sourceCode">cases</code> to define <code data-lang="pyret" class="sourceCode">my-len</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-len(l):
  cases (List) l:
    | empty      =&gt; 0
    | link(f, r) =&gt; 1 + my-len(r)
  end
end</code></pre><p>This follows from our examples: when the list is empty <code data-lang="pyret" class="sourceCode">my-len</code>
produces <code data-lang="pyret" class="sourceCode">0</code>; when it is not empty, we add one to the length of
the rest of the list (here, <code data-lang="pyret" class="sourceCode">r</code>).</p><p>Note that while our most recent collection of <code data-lang="pyret" class="sourceCode">my-len</code> examples
explicitly said <code data-lang="pyret" class="sourceCode">.rest</code>, when using <code data-lang="pyret" class="sourceCode">cases</code> we instead use
just the name <code data-lang="pyret" class="sourceCode">r</code>, which Pyret has already defined (under the
hood) to be <code data-lang="pyret" class="sourceCode">l.rest</code>.</p><p>Similarly, letâ€™s define <code data-lang="pyret" class="sourceCode">my-sum</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-sum(l):
  cases (List) l:
    | empty      =&gt; 0
    | link(f, r) =&gt; f + my-sum(r)
  end
end</code></pre><p>Notice how similar they are in code, and how readily the structure of
the data suggest a structure for the program. This is a pattern you
will get very used to soon!</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Developing Functions Over Lists</p><blockquote class="StrategyBody"><p>Leverage the structure of lists and the power of concrete examples to
develop list-processing functions.
</p><ul><li><p>Pick a concrete list with (at least) three elements. Write a
sequence of examples for each of the entire list and each suffix of
the list (including the empty list).</p></li><li><p>Rewrite each example to express its expected
answer in terms of the <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> data of its input
list. You donâ€™t have to use the <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> operators
in the new answers, but you should see the <code data-lang="pyret" class="sourceCode">first</code> and
<code data-lang="pyret" class="sourceCode">rest</code> values represented explicitly in the answer.</p></li><li><p>Look for a pattern across the answers in the examples. Use these
to develop the code: write a <code data-lang="pyret" class="sourceCode">cases</code> expression, filling in the
right side of each <code data-lang="pyret" class="sourceCode">=&gt;</code> based on your examples.</p></li></ul><p>This strategy applies to structured data in general, leveraging
components of each datum rather than specifically <code data-lang="pyret" class="sourceCode">first</code> and
<code data-lang="pyret" class="sourceCode">rest</code> as presented so far.</p></blockquote></blockquote>&#13;
<h4 class="heading">5.2.4Â <a name="(part._.Structural_.Problems_that_.Transform_.Lists)"/>Structural Problems that Transform Lists<a href="#(part._.Structural_.Problems_that_.Transform_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Now that we have a systematic way to develop functions that take lists
as input, letâ€™s apply that same strategy to functions that
produce a list as the answer.</p><section class="SsectionLevel5" id="section 5.2.4.1"><h5 class="heading">5.2.4.1Â <a name="(part._doubles-eg-code)"/><code data-lang="pyret" class="sourceCode">my-doubles</code>: Examples and Code<a href="#(part._doubles-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>As always, weâ€™ll begin with some examples. Given a list of numbers, we
want a list that doubles each number (in the order of the
original list). Hereâ€™s a reasonable example with three numbers:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is [list: 6, 10, 4]</code></pre><p>As before, letâ€™s write out the answers for each suffix of our example
list as well, including for the <code data-lang="pyret" class="sourceCode">empty</code> list:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list:    5, 2]) is [list:    10, 4]
my-doubles([list:       2]) is [list:        4]
my-doubles([list:        ]) is [list:         ]</code></pre><p>Now, we rewrite the answer expressions to include the concrete
<code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> data for each example. Letâ€™s start with
just the <code data-lang="pyret" class="sourceCode">first</code> data, and just on the first example:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is [list: 3 * 2, 10, 4]
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre><p>Next, letâ€™s include the <code data-lang="pyret" class="sourceCode">rest</code> data (<code data-lang="pyret" class="sourceCode">[list: 5, 2]</code>) in the
first example. The current answer in the first example is</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, 10, 4]</code></pre><p>and that <code data-lang="pyret" class="sourceCode">[list: 10, 4]</code> is the result of using the function on
<code data-lang="pyret" class="sourceCode">[list: 5, 2]</code>. We might therefore be tempted to replace the
right side of the first example with:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, my-doubles([list: 5, 2])]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What value would this expression produce? You might want to try this
example that doesnâ€™t use <code data-lang="pyret" class="sourceCode">my-doubles</code> directly:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, [list: 10, 4]]</code></pre></blockquote></blockquote><p>Oops! We want a single (flat) list, not a list-within-a-list. This
feels like it is on the right track in terms of reworking the answer
to use the <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> values, but weâ€™re clearly not
quite there yet.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What value does the following expression produce?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link(3 * 2, [list: 10, 4])</code></pre></blockquote></blockquote><p>Notice the difference between the two expressions in these last two
exercises: the latter used <code data-lang="pyret" class="sourceCode">link</code> to put the value involving
<code data-lang="pyret" class="sourceCode">first</code> into the conversion of the <code data-lang="pyret" class="sourceCode">rest</code>, while the former
tried to do this with <code data-lang="pyret" class="sourceCode">list:</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How many elements are in the lists that result from each of the
following expressions?</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 25, 16, 32]
[list: 25, [list: 16, 32]]
link(25, [list: 16, 32])</code></pre></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Summarize the difference between how <code data-lang="pyret" class="sourceCode">link</code> and <code data-lang="pyret" class="sourceCode">list:</code>
combine an element and a list. Try additional examples at the
interactions prompt if needed to explore these ideas.</p></blockquote></blockquote><p>The takeaway here is that we use <code data-lang="pyret" class="sourceCode">link</code> to insert an
element into an existing list, whereas we use <code data-lang="pyret" class="sourceCode">list:</code> to make a
new list that contains the old list as an element. Going back
to our examples, then, we include <code data-lang="pyret" class="sourceCode">rest</code> in the first example by
writing it as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, [list: 10, 4])
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre><p>which we then convert to</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre><p>Applying this idea across the examples, we get:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is link(5 * 2, my-doubles([list: 2]))
my-doubles([list:       2]) is link(2 * 2, my-doubles([list: ]))
my-doubles([list:        ]) is [list:             ]</code></pre><p>Now that we have examples that explicitly use the <code data-lang="pyret" class="sourceCode">first</code> and
<code data-lang="pyret" class="sourceCode">rest</code> elements, we can produce to write the <code data-lang="pyret" class="sourceCode">my-doubles</code>
function:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-doubles(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      link(f * 2, my-doubles(r))
  end
end</code></pre></section><section class="SsectionLevel5" id="section 5.2.4.2"><h5 class="heading">5.2.4.2Â <a name="(part._str-len-eg-code)"/><code data-lang="pyret" class="sourceCode">my-str-len</code>: Examples and Code<a href="#(part._str-len-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>In <code data-lang="pyret" class="sourceCode">my-doubles</code>, the input and output lists have the same type of
element. Functions can also produce lists whose contents have a
different type from the input list. Letâ€™s work through an example.
Given a list of strings, we
want the lengths of each string (in the same order as in the input list). Thus, hereâ€™s a
reasonable example:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is [list: 2, 5, 6]</code></pre><p>As we have before, we should consider the answers for each
sub-problem of the above example:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list:       "there", "mateys"]) is [list:    5, 6]
my-str-len([list:                "mateys"]) is [list:       6]</code></pre><p>Or, in other words:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(2, [list: 5, 6])
my-str-len([list:       "there", "mateys"]) is link(5, [list:    6])
my-str-len([list:                "mateys"]) is link(6, [list:     ])</code></pre><p>which tells us that the response for the empty list should be
<code data-lang="pyret" class="sourceCode">empty</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len(empty) is empty</code></pre><p>The next step is to rework the answers in the examples to make the
<code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> parts explicit. Hopefully by now you are
starting to detect a pattern: The result on the rest of the list
appears explicitly as another example. Therefore, weâ€™ll start by
getting the <code data-lang="pyret" class="sourceCode">rest</code> value of each example input into the answer:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(2, my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(5, my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(6, my-str-len([list:                  ]))
my-str-len([list:                        ]) is [list: ]</code></pre><p>All that remains now is to figure out how to work the <code data-lang="pyret" class="sourceCode">first</code>
values into the outputs. In the context of this problem, this means we
need to convert <code data-lang="pyret" class="sourceCode">"hi"</code> into <code data-lang="pyret" class="sourceCode">2</code>, <code data-lang="pyret" class="sourceCode">"there"</code> into
<code data-lang="pyret" class="sourceCode">5</code>, and so on. From the problem statement, we know that <code data-lang="pyret" class="sourceCode">2</code>
and <code data-lang="pyret" class="sourceCode">5</code> are meant to be the lengths (character counts) of the
corresponding strings. The operation that determines the length of a
string is called <code data-lang="pyret" class="sourceCode">string-length</code>. Thus, our examples appear as:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(string-length("hi"), my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(string-length("there"), my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(string-length("mateys"), my-str-len([list: ]))
my-str-len([list:                        ]) is [list: ]</code></pre><p>From here, we write a function that captures the pattern developed
across our examples:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-str-len(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      link(string-length(f), my-str-len(r))
  end
end</code></pre></section>&#13;
<h5 class="heading">5.2.4.1Â <a name="(part._doubles-eg-code)"/><code data-lang="pyret" class="sourceCode">my-doubles</code>: Examples and Code<a href="#(part._doubles-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>As always, weâ€™ll begin with some examples. Given a list of numbers, we
want a list that doubles each number (in the order of the
original list). Hereâ€™s a reasonable example with three numbers:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is [list: 6, 10, 4]</code></pre><p>As before, letâ€™s write out the answers for each suffix of our example
list as well, including for the <code data-lang="pyret" class="sourceCode">empty</code> list:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list:    5, 2]) is [list:    10, 4]
my-doubles([list:       2]) is [list:        4]
my-doubles([list:        ]) is [list:         ]</code></pre><p>Now, we rewrite the answer expressions to include the concrete
<code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> data for each example. Letâ€™s start with
just the <code data-lang="pyret" class="sourceCode">first</code> data, and just on the first example:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is [list: 3 * 2, 10, 4]
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre><p>Next, letâ€™s include the <code data-lang="pyret" class="sourceCode">rest</code> data (<code data-lang="pyret" class="sourceCode">[list: 5, 2]</code>) in the
first example. The current answer in the first example is</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, 10, 4]</code></pre><p>and that <code data-lang="pyret" class="sourceCode">[list: 10, 4]</code> is the result of using the function on
<code data-lang="pyret" class="sourceCode">[list: 5, 2]</code>. We might therefore be tempted to replace the
right side of the first example with:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, my-doubles([list: 5, 2])]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What value would this expression produce? You might want to try this
example that doesnâ€™t use <code data-lang="pyret" class="sourceCode">my-doubles</code> directly:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, [list: 10, 4]]</code></pre></blockquote></blockquote><p>Oops! We want a single (flat) list, not a list-within-a-list. This
feels like it is on the right track in terms of reworking the answer
to use the <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> values, but weâ€™re clearly not
quite there yet.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What value does the following expression produce?
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link(3 * 2, [list: 10, 4])</code></pre></blockquote></blockquote><p>Notice the difference between the two expressions in these last two
exercises: the latter used <code data-lang="pyret" class="sourceCode">link</code> to put the value involving
<code data-lang="pyret" class="sourceCode">first</code> into the conversion of the <code data-lang="pyret" class="sourceCode">rest</code>, while the former
tried to do this with <code data-lang="pyret" class="sourceCode">list:</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How many elements are in the lists that result from each of the
following expressions?</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 25, 16, 32]
[list: 25, [list: 16, 32]]
link(25, [list: 16, 32])</code></pre></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Summarize the difference between how <code data-lang="pyret" class="sourceCode">link</code> and <code data-lang="pyret" class="sourceCode">list:</code>
combine an element and a list. Try additional examples at the
interactions prompt if needed to explore these ideas.</p></blockquote></blockquote><p>The takeaway here is that we use <code data-lang="pyret" class="sourceCode">link</code> to insert an
element into an existing list, whereas we use <code data-lang="pyret" class="sourceCode">list:</code> to make a
new list that contains the old list as an element. Going back
to our examples, then, we include <code data-lang="pyret" class="sourceCode">rest</code> in the first example by
writing it as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, [list: 10, 4])
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre><p>which we then convert to</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre><p>Applying this idea across the examples, we get:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is link(5 * 2, my-doubles([list: 2]))
my-doubles([list:       2]) is link(2 * 2, my-doubles([list: ]))
my-doubles([list:        ]) is [list:             ]</code></pre><p>Now that we have examples that explicitly use the <code data-lang="pyret" class="sourceCode">first</code> and
<code data-lang="pyret" class="sourceCode">rest</code> elements, we can produce to write the <code data-lang="pyret" class="sourceCode">my-doubles</code>
function:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-doubles(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      link(f * 2, my-doubles(r))
  end
end</code></pre>&#13;
<h5 class="heading">5.2.4.2Â <a name="(part._str-len-eg-code)"/><code data-lang="pyret" class="sourceCode">my-str-len</code>: Examples and Code<a href="#(part._str-len-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>In <code data-lang="pyret" class="sourceCode">my-doubles</code>, the input and output lists have the same type of
element. Functions can also produce lists whose contents have a
different type from the input list. Letâ€™s work through an example.
Given a list of strings, we
want the lengths of each string (in the same order as in the input list). Thus, hereâ€™s a
reasonable example:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is [list: 2, 5, 6]</code></pre><p>As we have before, we should consider the answers for each
sub-problem of the above example:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list:       "there", "mateys"]) is [list:    5, 6]
my-str-len([list:                "mateys"]) is [list:       6]</code></pre><p>Or, in other words:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(2, [list: 5, 6])
my-str-len([list:       "there", "mateys"]) is link(5, [list:    6])
my-str-len([list:                "mateys"]) is link(6, [list:     ])</code></pre><p>which tells us that the response for the empty list should be
<code data-lang="pyret" class="sourceCode">empty</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len(empty) is empty</code></pre><p>The next step is to rework the answers in the examples to make the
<code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code> parts explicit. Hopefully by now you are
starting to detect a pattern: The result on the rest of the list
appears explicitly as another example. Therefore, weâ€™ll start by
getting the <code data-lang="pyret" class="sourceCode">rest</code> value of each example input into the answer:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(2, my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(5, my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(6, my-str-len([list:                  ]))
my-str-len([list:                        ]) is [list: ]</code></pre><p>All that remains now is to figure out how to work the <code data-lang="pyret" class="sourceCode">first</code>
values into the outputs. In the context of this problem, this means we
need to convert <code data-lang="pyret" class="sourceCode">"hi"</code> into <code data-lang="pyret" class="sourceCode">2</code>, <code data-lang="pyret" class="sourceCode">"there"</code> into
<code data-lang="pyret" class="sourceCode">5</code>, and so on. From the problem statement, we know that <code data-lang="pyret" class="sourceCode">2</code>
and <code data-lang="pyret" class="sourceCode">5</code> are meant to be the lengths (character counts) of the
corresponding strings. The operation that determines the length of a
string is called <code data-lang="pyret" class="sourceCode">string-length</code>. Thus, our examples appear as:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(string-length("hi"), my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(string-length("there"), my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(string-length("mateys"), my-str-len([list: ]))
my-str-len([list:                        ]) is [list: ]</code></pre><p>From here, we write a function that captures the pattern developed
across our examples:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-str-len(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      link(string-length(f), my-str-len(r))
  end
end</code></pre>&#13;
<h4 class="heading">5.2.5Â <a name="(part._.Structural_.Problems_that_.Select_from_.Lists)"/>Structural Problems that Select from Lists<a href="#(part._.Structural_.Problems_that_.Select_from_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In the previous section, we saw functions that transform list
elements (by doubling numbers or counting characters). The type of the
output list may or may not be the same as the type of the input
list. Other functions that produce lists instead select
elements: every element in the output list was in the input list, but
some input-list elements might not appear in the output list. This
section adapts our method of deriving functions from examples to
accommodate selection of elements.</p><section class="SsectionLevel5" id="section 5.2.5.1"><h5 class="heading">5.2.5.1Â <a name="(part._pos-nums-eg-code)"/><code data-lang="pyret" class="sourceCode">my-pos-nums</code>: Examples and Code<a href="#(part._pos-nums-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>As our first example, we will select the positive numbers from a list
that contains both positive and non-positive numbers.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Construct the sequence of examples that we obtain from the input
<code data-lang="pyret" class="sourceCode">[list: 1, -2, 3, -4]</code>.</p></blockquote></blockquote><p>Here we go:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is [list: 1, 3]
my-pos-nums([list:    -2, 3, -4]) is [list:    3]
my-pos-nums([list:        3, -4]) is [list:    3]
my-pos-nums([list:           -4]) is [list:     ]
my-pos-nums([list:             ]) is [list:     ]</code></pre><p>We can write this in the following form:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, [list: 3])
my-pos-nums([list:    -2, 3, -4]) is         [list: 3]
my-pos-nums([list:        3, -4]) is link(3, [list: ])
my-pos-nums([list:           -4]) is         [list: ]
my-pos-nums([list:             ]) is         [list: ]</code></pre><p>or, even more explicitly,
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])
my-pos-nums([list:             ]) is         [list: ]</code></pre><p>Unlike in the example sequences for functions that transform lists,
here we see that the answers have different shapes: some involve a
<code data-lang="pyret" class="sourceCode">link</code>, while others simply process the <code data-lang="pyret" class="sourceCode">rest</code> of the
list. Whenever we need different shapes of outputs across a set of
examples, we will need an <code data-lang="pyret" class="sourceCode">if</code> expression in our code to
distinguish the conditions that yield each shape.</p><p>What determines which shape of output we get? Letâ€™s rearrange the
examples (other than the empty-list input) by output shape:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))

my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])</code></pre><p>Re-organized, we can see that the examples that use <code data-lang="pyret" class="sourceCode">link</code> have a
positive number in the <code data-lang="pyret" class="sourceCode">first</code> position, while the ones that
donâ€™t simply process the <code data-lang="pyret" class="sourceCode">rest</code> of the list. That indicates that
our <code data-lang="pyret" class="sourceCode">if</code> expression needs to ask whether the <code data-lang="pyret" class="sourceCode">first</code> element
in the list is positive. This yields the following program:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-pos-nums(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if f &gt; 0:
        link(f, my-pos-nums(r))
      else:
        my-pos-nums(r)
      end
  end
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Is our set of examples comprehensive?</p></blockquote></blockquote><p>Not really. There are many examples we havenâ€™t considered, such
as lists that end with positive numbers and lists with <code data-lang="pyret" class="sourceCode">0</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Work through these examples and see how they affect the program!</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.2.5.2"><h5 class="heading">5.2.5.2Â <a name="(part._alternating-eg-code)"/><code data-lang="pyret" class="sourceCode">my-alternating</code>:
Examples and Code<a href="#(part._alternating-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Now letâ€™s consider a problem that selects elements not by value, but
by position. We want to write a function that selects
alternating elements from a list. Once again, weâ€™re going to work from examples.
</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Work out the results for <code data-lang="pyret" class="sourceCode">my-alternating</code> starting from the list
<code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4, 5, 6]</code>.</p></blockquote></blockquote><p>Hereâ€™s how they work out:
</p><a name="(elem._alternating-egs-1)"/>&lt;alternating-egs-1&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
  my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
  my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
  my-alternating([list:          4, 5, 6]) is [list:    4, 6]
end</code></pre><p>Wait, whatâ€™s that? The two answers above are each correct, but
the second answer does not help us in any way construct the
first answer. That means the way weâ€™ve solved these problems until
now is not enough for this new kind of problem. Itâ€™s still useful,
though: notice that thereâ€™s a connection between the first example and
the third, as well as between the second example and the fourth. This
observation is consistent with our goal of selecting alternating elements.</p><p>What would something like this look like in code? Before we try to
write the function, letâ€™s rewrite the first example in terms of the
third:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]

my-alternating([list: 1, 2, 3, 4, 5, 6]) is link(1, my-alternating([list: 3, 4, 5, 6]))</code></pre><p>Note that in the rewritten version, we are dropping two
elements from the list before using <code data-lang="pyret" class="sourceCode">my-alternating</code> again, not
just one. We will have to figure out how to handle that in our code.</p><p>Letâ€™s start with our usual function pattern with a <code data-lang="pyret" class="sourceCode">cases</code>
expression:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; [list:]
    | link(f, r) =&gt; link(f, â€¦ r â€¦)
  end
end</code></pre><p>Note that we cannot simply call <code data-lang="pyret" class="sourceCode">my-alternating</code> on <code data-lang="pyret" class="sourceCode">r</code>,
because <code data-lang="pyret" class="sourceCode">r</code> excludes only one item from the list, not two as this
problem requires. We have to break down <code data-lang="pyret" class="sourceCode">r</code> as well, in order to
get to the <code data-lang="pyret" class="sourceCode">rest</code> of the <code data-lang="pyret" class="sourceCode">rest</code> of the original list. To do
this, we use another <code data-lang="pyret" class="sourceCode">cases</code> expression, nested within the first
<code data-lang="pyret" class="sourceCode">cases</code> expression:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; [list:]
    | link(f, r) =&gt;
      cases (List) r:  # note: deconstructing r, not l
        | empty =&gt; ??? # note the ???
        | link(fr, rr) =&gt;
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end</code></pre><p>This code is consistent with the example that we just worked out. But
note that we still have a bit of unfinished work to do: we need to
decide what to do in the <code data-lang="pyret" class="sourceCode">empty</code> case of the inner <code data-lang="pyret" class="sourceCode">cases</code>
expression (marked by <code data-lang="pyret" class="sourceCode">???</code> in the code).</p><p>A common temptation at this point is to replace the <code data-lang="pyret" class="sourceCode">???</code> with
<code data-lang="pyret" class="sourceCode">[list:]</code>. After all, havenâ€™t we always returned <code data-lang="pyret" class="sourceCode">[list:]</code> in
the <code data-lang="pyret" class="sourceCode">empty</code> cases?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Replace <code data-lang="pyret" class="sourceCode">???</code> with <code data-lang="pyret" class="sourceCode">[list:]</code> and test the program on our
original examples:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
my-alternating([list:          4, 5, 6]) is [list:    4, 6]</code></pre><p>What do you observe?</p></blockquote></blockquote><p>Oops! Weâ€™ve written a program that appears to work on lists with an
even number of elements, but not on lists with an odd number of
elements. How did that happen? The only part of this code that we
guessed at was how to fill in the <code data-lang="pyret" class="sourceCode">empty</code> case of the inner
<code data-lang="pyret" class="sourceCode">cases</code>, so the issue must be there. Rather than focus on the
code, however, focus on the examples. We need a simple example
that would land on that part of the code. We get to that spot when the
list <code data-lang="pyret" class="sourceCode">l</code> is not empty, but <code data-lang="pyret" class="sourceCode">r</code> (the rest of <code data-lang="pyret" class="sourceCode">l</code>) is
empty. In other words, we need an example with only one element.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Finish the following example:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 5]) is ???</code></pre></blockquote></blockquote><p>Given a list with one element, that element should be included in a
list of alternating elements. Thus, we should finish this example as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 5]) is [list: 5]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use this example to update the result of <code data-lang="pyret" class="sourceCode">my-alternating</code> when
<code data-lang="pyret" class="sourceCode">r</code> is <code data-lang="pyret" class="sourceCode">empty</code> in our code.</p></blockquote></blockquote><p>Leveraging this new example, the final version of
<code data-lang="pyret" class="sourceCode">my-alternating</code> is as follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      cases (List) r: # note: deconstructing r, not l
        | empty =&gt;    # the list has an odd number of elements
          [list: f]
        | link(fr, rr) =&gt;
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end</code></pre><p>Whatâ€™s the takeaway from this problem? There are two:
</p><ul><li><p>Donâ€™t skip the small examples: the result of a list-processing
function on the <code data-lang="pyret" class="sourceCode">empty</code> case wonâ€™t always be <code data-lang="pyret" class="sourceCode">empty</code>.</p></li><li><p>If a problem asks you to work with multiple elements from the
front of a list, you can nest <code data-lang="pyret" class="sourceCode">cases</code> expressions to access later
elements.</p></li></ul><p>These takeaways will matter again in future examples: keep an eye out
for them!</p></section>&#13;
<h5 class="heading">5.2.5.1Â <a name="(part._pos-nums-eg-code)"/><code data-lang="pyret" class="sourceCode">my-pos-nums</code>: Examples and Code<a href="#(part._pos-nums-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>As our first example, we will select the positive numbers from a list
that contains both positive and non-positive numbers.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Construct the sequence of examples that we obtain from the input
<code data-lang="pyret" class="sourceCode">[list: 1, -2, 3, -4]</code>.</p></blockquote></blockquote><p>Here we go:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is [list: 1, 3]
my-pos-nums([list:    -2, 3, -4]) is [list:    3]
my-pos-nums([list:        3, -4]) is [list:    3]
my-pos-nums([list:           -4]) is [list:     ]
my-pos-nums([list:             ]) is [list:     ]</code></pre><p>We can write this in the following form:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, [list: 3])
my-pos-nums([list:    -2, 3, -4]) is         [list: 3]
my-pos-nums([list:        3, -4]) is link(3, [list: ])
my-pos-nums([list:           -4]) is         [list: ]
my-pos-nums([list:             ]) is         [list: ]</code></pre><p>or, even more explicitly,
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])
my-pos-nums([list:             ]) is         [list: ]</code></pre><p>Unlike in the example sequences for functions that transform lists,
here we see that the answers have different shapes: some involve a
<code data-lang="pyret" class="sourceCode">link</code>, while others simply process the <code data-lang="pyret" class="sourceCode">rest</code> of the
list. Whenever we need different shapes of outputs across a set of
examples, we will need an <code data-lang="pyret" class="sourceCode">if</code> expression in our code to
distinguish the conditions that yield each shape.</p><p>What determines which shape of output we get? Letâ€™s rearrange the
examples (other than the empty-list input) by output shape:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))

my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])</code></pre><p>Re-organized, we can see that the examples that use <code data-lang="pyret" class="sourceCode">link</code> have a
positive number in the <code data-lang="pyret" class="sourceCode">first</code> position, while the ones that
donâ€™t simply process the <code data-lang="pyret" class="sourceCode">rest</code> of the list. That indicates that
our <code data-lang="pyret" class="sourceCode">if</code> expression needs to ask whether the <code data-lang="pyret" class="sourceCode">first</code> element
in the list is positive. This yields the following program:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-pos-nums(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if f &gt; 0:
        link(f, my-pos-nums(r))
      else:
        my-pos-nums(r)
      end
  end
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Is our set of examples comprehensive?</p></blockquote></blockquote><p>Not really. There are many examples we havenâ€™t considered, such
as lists that end with positive numbers and lists with <code data-lang="pyret" class="sourceCode">0</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Work through these examples and see how they affect the program!</p></blockquote></blockquote>&#13;
<h5 class="heading">5.2.5.2Â <a name="(part._alternating-eg-code)"/><code data-lang="pyret" class="sourceCode">my-alternating</code>:
Examples and Code<a href="#(part._alternating-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Now letâ€™s consider a problem that selects elements not by value, but
by position. We want to write a function that selects
alternating elements from a list. Once again, weâ€™re going to work from examples.
</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Work out the results for <code data-lang="pyret" class="sourceCode">my-alternating</code> starting from the list
<code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4, 5, 6]</code>.</p></blockquote></blockquote><p>Hereâ€™s how they work out:
</p><a name="(elem._alternating-egs-1)"/>&lt;alternating-egs-1&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
  my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
  my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
  my-alternating([list:          4, 5, 6]) is [list:    4, 6]
end</code></pre><p>Wait, whatâ€™s that? The two answers above are each correct, but
the second answer does not help us in any way construct the
first answer. That means the way weâ€™ve solved these problems until
now is not enough for this new kind of problem. Itâ€™s still useful,
though: notice that thereâ€™s a connection between the first example and
the third, as well as between the second example and the fourth. This
observation is consistent with our goal of selecting alternating elements.</p><p>What would something like this look like in code? Before we try to
write the function, letâ€™s rewrite the first example in terms of the
third:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]

my-alternating([list: 1, 2, 3, 4, 5, 6]) is link(1, my-alternating([list: 3, 4, 5, 6]))</code></pre><p>Note that in the rewritten version, we are dropping two
elements from the list before using <code data-lang="pyret" class="sourceCode">my-alternating</code> again, not
just one. We will have to figure out how to handle that in our code.</p><p>Letâ€™s start with our usual function pattern with a <code data-lang="pyret" class="sourceCode">cases</code>
expression:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; [list:]
    | link(f, r) =&gt; link(f, â€¦ r â€¦)
  end
end</code></pre><p>Note that we cannot simply call <code data-lang="pyret" class="sourceCode">my-alternating</code> on <code data-lang="pyret" class="sourceCode">r</code>,
because <code data-lang="pyret" class="sourceCode">r</code> excludes only one item from the list, not two as this
problem requires. We have to break down <code data-lang="pyret" class="sourceCode">r</code> as well, in order to
get to the <code data-lang="pyret" class="sourceCode">rest</code> of the <code data-lang="pyret" class="sourceCode">rest</code> of the original list. To do
this, we use another <code data-lang="pyret" class="sourceCode">cases</code> expression, nested within the first
<code data-lang="pyret" class="sourceCode">cases</code> expression:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; [list:]
    | link(f, r) =&gt;
      cases (List) r:  # note: deconstructing r, not l
        | empty =&gt; ??? # note the ???
        | link(fr, rr) =&gt;
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end</code></pre><p>This code is consistent with the example that we just worked out. But
note that we still have a bit of unfinished work to do: we need to
decide what to do in the <code data-lang="pyret" class="sourceCode">empty</code> case of the inner <code data-lang="pyret" class="sourceCode">cases</code>
expression (marked by <code data-lang="pyret" class="sourceCode">???</code> in the code).</p><p>A common temptation at this point is to replace the <code data-lang="pyret" class="sourceCode">???</code> with
<code data-lang="pyret" class="sourceCode">[list:]</code>. After all, havenâ€™t we always returned <code data-lang="pyret" class="sourceCode">[list:]</code> in
the <code data-lang="pyret" class="sourceCode">empty</code> cases?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Replace <code data-lang="pyret" class="sourceCode">???</code> with <code data-lang="pyret" class="sourceCode">[list:]</code> and test the program on our
original examples:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
my-alternating([list:          4, 5, 6]) is [list:    4, 6]</code></pre><p>What do you observe?</p></blockquote></blockquote><p>Oops! Weâ€™ve written a program that appears to work on lists with an
even number of elements, but not on lists with an odd number of
elements. How did that happen? The only part of this code that we
guessed at was how to fill in the <code data-lang="pyret" class="sourceCode">empty</code> case of the inner
<code data-lang="pyret" class="sourceCode">cases</code>, so the issue must be there. Rather than focus on the
code, however, focus on the examples. We need a simple example
that would land on that part of the code. We get to that spot when the
list <code data-lang="pyret" class="sourceCode">l</code> is not empty, but <code data-lang="pyret" class="sourceCode">r</code> (the rest of <code data-lang="pyret" class="sourceCode">l</code>) is
empty. In other words, we need an example with only one element.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Finish the following example:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 5]) is ???</code></pre></blockquote></blockquote><p>Given a list with one element, that element should be included in a
list of alternating elements. Thus, we should finish this example as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 5]) is [list: 5]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use this example to update the result of <code data-lang="pyret" class="sourceCode">my-alternating</code> when
<code data-lang="pyret" class="sourceCode">r</code> is <code data-lang="pyret" class="sourceCode">empty</code> in our code.</p></blockquote></blockquote><p>Leveraging this new example, the final version of
<code data-lang="pyret" class="sourceCode">my-alternating</code> is as follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      cases (List) r: # note: deconstructing r, not l
        | empty =&gt;    # the list has an odd number of elements
          [list: f]
        | link(fr, rr) =&gt;
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end</code></pre><p>Whatâ€™s the takeaway from this problem? There are two:
</p><ul><li><p>Donâ€™t skip the small examples: the result of a list-processing
function on the <code data-lang="pyret" class="sourceCode">empty</code> case wonâ€™t always be <code data-lang="pyret" class="sourceCode">empty</code>.</p></li><li><p>If a problem asks you to work with multiple elements from the
front of a list, you can nest <code data-lang="pyret" class="sourceCode">cases</code> expressions to access later
elements.</p></li></ul><p>These takeaways will matter again in future examples: keep an eye out
for them!</p>&#13;
<h4 class="heading">5.2.6Â <a name="(part._struct-prob-sub-dom)"/>Structural Problems Over Relaxed Domains<a href="#(part._struct-prob-sub-dom)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><section class="SsectionLevel5" id="section 5.2.6.1"><h5 class="heading">5.2.6.1Â <a name="(part._my-max)"/><code data-lang="pyret" class="sourceCode">my-max</code>: Examples<a href="#(part._my-max)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Now letâ€™s find the maximum value of a list. Letâ€™s assume for
simplicity that weâ€™re dealing with just lists of numbers. What kinds
of lists should we construct? Clearly, we should have empty and
non-empty listsâ€¦but what else? Is a list like <code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code> a
good example? Well, thereâ€™s nothing wrong with it, but we should also
consider lists where the maximum is at the beginning rather than at the
end; the maximum might be in the middle; the maximum might be
repeated; the maximum might be negative; and so on. While not
comprehensive, here is a small but interesting set of examples:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 1, 2, 3]) is 3
my-max([list: 3, 2, 1]) is 3
my-max([list: 2, 3, 1]) is 3
my-max([list: 2, 3, 1, 3, 2]) is 3
my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list: -2, -1, -3]) is -1</code></pre><p>What about <code data-lang="pyret" class="sourceCode">my-max(empty)</code>?
</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Could we define <code data-lang="pyret" class="sourceCode">my-max(empty)</code> to be <code data-lang="pyret" class="sourceCode">0</code>? Returning
<code data-lang="pyret" class="sourceCode">0</code> for the empty list has worked well twice already!</p></blockquote></blockquote><p>Weâ€™ll return to this in a while.</p><p>Before we proceed, itâ€™s useful to know that thereâ€™s a function called
<code data-lang="pyret" class="sourceCode">num-max</code> already defined in Pyret, that compares two numbers:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max(1, 2) is 2
num-max(-1, -2) is -1</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Suppose <code data-lang="pyret" class="sourceCode">num-max</code> were not already built in. Can you define it?
You will find what you learned about <a href="Conditionals_and_Booleans.html#%28part._booleans%29" data-pltdoc="x">Booleans</a>
handy. Remember to write some tests!</p></blockquote></blockquote><p>Now we can look at <code data-lang="pyret" class="sourceCode">my-max</code> at work:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 1, 2, 3]) is 3
my-max([list:    2, 3]) is 3
my-max([list:       3]) is 3</code></pre><p>Hmm. That didnâ€™t really teach us anything, did it? Maybe, we canâ€™t be
sure. And we still donâ€™t know what to do with <code data-lang="pyret" class="sourceCode">empty</code>.</p><p>Letâ€™s try the second example input:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 3, 2, 1]) is 3
my-max([list:    2, 1]) is 2
my-max([list:       1]) is 1</code></pre><p>This is actually telling us something useful as well, but maybe we
canâ€™t see it yet. Letâ€™s take on something more ambitious:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list:    1, 4, 3, 2]) is 4
my-max([list:       4, 3, 2]) is 4
my-max([list:          3, 2]) is 3
my-max([list:             2]) is 2</code></pre><p>Observe how the maximum of the rest of the list gives us a candidate
answer, but comparing it to the first element gives us a definitive
one:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is num-max(2, 4)
my-max([list:    1, 4, 3, 2]) is num-max(1, 4)
my-max([list:       4, 3, 2]) is num-max(4, 3)
my-max([list:          3, 2]) is num-max(3, 2)
my-max([list:             2]) is â€¦</code></pre><p>The last one is a little awkward: weâ€™d like to write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list:             2]) is num-max(2, â€¦)</code></pre><p>but we donâ€™t really know what the maximum (or minimum, or any other
element) of the empty list is, but we can only provide numbers
to <code data-lang="pyret" class="sourceCode">num-max</code>. Therefore, leaving out that dodgy case, weâ€™re left
with
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is num-max(2, my-max([list: 1, 4, 3, 2]))
my-max([list:    1, 4, 3, 2]) is num-max(1, my-max([list:    4, 3, 2]))
my-max([list:       4, 3, 2]) is num-max(4, my-max([list:       3, 2]))
my-max([list:          3, 2]) is num-max(3, my-max([list:          2]))</code></pre><p>Our examples have again helped: theyâ€™ve revealed how we can use the
answer for each rest of the list to compute the answer for the whole
list, which in turn is the rest of some other list, and so on. If you
go back and look at the other example lists we wrote above, youâ€™ll see
the pattern holds there too.</p><p>However, itâ€™s time we now confront the <code data-lang="pyret" class="sourceCode">empty</code> case. The real
problem is that we donâ€™t have a maximum for the empty list: for any
number we might provide, there is always a number bigger than it
(assuming our computer is large enough) that could have been the
answer instead. In short, itâ€™s nonsensical to ask for the maximum (or
minimum) of the empty list: the concept of â€œmaximumâ€ is only defined
on non-empty lists! That is, when asked for the maximum of an empty
list, we should signal an error:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max(empty) raises ""</code></pre><p>(which is how, in Pyret, we say that it will generate an error; we
donâ€™t care about the details of the error, hence the empty string).</p></section><section class="SsectionLevel5" id="section 5.2.6.2"><h5 class="heading">5.2.6.2Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)"/><code data-lang="pyret" class="sourceCode">my-max</code>: From Examples to Code<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Once again, we can codify the examples above, i.e., turn them into a
uniform program that works for all instances. However, we now have a
twist. If we blindly followed the pattern weâ€™ve used earlier, we would
end up with:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt; num-max(f, my-max(r))
  end
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Whatâ€™s wrong with this?</p></blockquote></blockquote><p>Consider the list <code data-lang="pyret" class="sourceCode">[list: 2]</code>. This turns into
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max(2, my-max([list: ]))</code></pre><p>which of course raises an error. Therefore, this function never works
for any list that has one or more elements!</p><p>Thatâ€™s because we need to make sure we arenâ€™t trying to compute the
maximum of the empty list.
Going back to our examples, we see that what we need to do, before
calling <code data-lang="pyret" class="sourceCode">my-max</code>, is check whether the rest of the list is
empty. If it is, we do not want to call <code data-lang="pyret" class="sourceCode">my-max</code> at all. That is:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; â€¦
        | â€¦
      end
  end
end</code></pre><p>Weâ€™ll return to what to do when the rest is not empty in a moment.</p><p>If the rest of the list <code data-lang="pyret" class="sourceCode">l</code> is empty, our examples above tell us
that the maximum is the first element in the list. Therefore, we can
fill this in:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; f
        | â€¦
      end
  end
end</code></pre><p>Note in particular the absence of a call to <code data-lang="pyret" class="sourceCode">my-max</code>. If the list
is not empty, however, our examples above tell us that <code data-lang="pyret" class="sourceCode">my-max</code>
will give us the maximum of the rest of the list, and we just need to
compare this answer with the first element (<code data-lang="pyret" class="sourceCode">f</code>):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; f
        | else  =&gt; num-max(f, my-max(r))
      end
  end
end</code></pre><p>And sure enough, this definition does the job!</p></section>&#13;
<h5 class="heading">5.2.6.1Â <a name="(part._my-max)"/><code data-lang="pyret" class="sourceCode">my-max</code>: Examples<a href="#(part._my-max)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Now letâ€™s find the maximum value of a list. Letâ€™s assume for
simplicity that weâ€™re dealing with just lists of numbers. What kinds
of lists should we construct? Clearly, we should have empty and
non-empty listsâ€¦but what else? Is a list like <code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code> a
good example? Well, thereâ€™s nothing wrong with it, but we should also
consider lists where the maximum is at the beginning rather than at the
end; the maximum might be in the middle; the maximum might be
repeated; the maximum might be negative; and so on. While not
comprehensive, here is a small but interesting set of examples:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 1, 2, 3]) is 3
my-max([list: 3, 2, 1]) is 3
my-max([list: 2, 3, 1]) is 3
my-max([list: 2, 3, 1, 3, 2]) is 3
my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list: -2, -1, -3]) is -1</code></pre><p>What about <code data-lang="pyret" class="sourceCode">my-max(empty)</code>?
</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Could we define <code data-lang="pyret" class="sourceCode">my-max(empty)</code> to be <code data-lang="pyret" class="sourceCode">0</code>? Returning
<code data-lang="pyret" class="sourceCode">0</code> for the empty list has worked well twice already!</p></blockquote></blockquote><p>Weâ€™ll return to this in a while.</p><p>Before we proceed, itâ€™s useful to know that thereâ€™s a function called
<code data-lang="pyret" class="sourceCode">num-max</code> already defined in Pyret, that compares two numbers:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max(1, 2) is 2
num-max(-1, -2) is -1</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Suppose <code data-lang="pyret" class="sourceCode">num-max</code> were not already built in. Can you define it?
You will find what you learned about <a href="Conditionals_and_Booleans.html#%28part._booleans%29" data-pltdoc="x">Booleans</a>
handy. Remember to write some tests!</p></blockquote></blockquote><p>Now we can look at <code data-lang="pyret" class="sourceCode">my-max</code> at work:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 1, 2, 3]) is 3
my-max([list:    2, 3]) is 3
my-max([list:       3]) is 3</code></pre><p>Hmm. That didnâ€™t really teach us anything, did it? Maybe, we canâ€™t be
sure. And we still donâ€™t know what to do with <code data-lang="pyret" class="sourceCode">empty</code>.</p><p>Letâ€™s try the second example input:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 3, 2, 1]) is 3
my-max([list:    2, 1]) is 2
my-max([list:       1]) is 1</code></pre><p>This is actually telling us something useful as well, but maybe we
canâ€™t see it yet. Letâ€™s take on something more ambitious:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list:    1, 4, 3, 2]) is 4
my-max([list:       4, 3, 2]) is 4
my-max([list:          3, 2]) is 3
my-max([list:             2]) is 2</code></pre><p>Observe how the maximum of the rest of the list gives us a candidate
answer, but comparing it to the first element gives us a definitive
one:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is num-max(2, 4)
my-max([list:    1, 4, 3, 2]) is num-max(1, 4)
my-max([list:       4, 3, 2]) is num-max(4, 3)
my-max([list:          3, 2]) is num-max(3, 2)
my-max([list:             2]) is â€¦</code></pre><p>The last one is a little awkward: weâ€™d like to write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list:             2]) is num-max(2, â€¦)</code></pre><p>but we donâ€™t really know what the maximum (or minimum, or any other
element) of the empty list is, but we can only provide numbers
to <code data-lang="pyret" class="sourceCode">num-max</code>. Therefore, leaving out that dodgy case, weâ€™re left
with
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is num-max(2, my-max([list: 1, 4, 3, 2]))
my-max([list:    1, 4, 3, 2]) is num-max(1, my-max([list:    4, 3, 2]))
my-max([list:       4, 3, 2]) is num-max(4, my-max([list:       3, 2]))
my-max([list:          3, 2]) is num-max(3, my-max([list:          2]))</code></pre><p>Our examples have again helped: theyâ€™ve revealed how we can use the
answer for each rest of the list to compute the answer for the whole
list, which in turn is the rest of some other list, and so on. If you
go back and look at the other example lists we wrote above, youâ€™ll see
the pattern holds there too.</p><p>However, itâ€™s time we now confront the <code data-lang="pyret" class="sourceCode">empty</code> case. The real
problem is that we donâ€™t have a maximum for the empty list: for any
number we might provide, there is always a number bigger than it
(assuming our computer is large enough) that could have been the
answer instead. In short, itâ€™s nonsensical to ask for the maximum (or
minimum) of the empty list: the concept of â€œmaximumâ€ is only defined
on non-empty lists! That is, when asked for the maximum of an empty
list, we should signal an error:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max(empty) raises ""</code></pre><p>(which is how, in Pyret, we say that it will generate an error; we
donâ€™t care about the details of the error, hence the empty string).</p>&#13;
<h5 class="heading">5.2.6.2Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)"/><code data-lang="pyret" class="sourceCode">my-max</code>: From Examples to Code<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Once again, we can codify the examples above, i.e., turn them into a
uniform program that works for all instances. However, we now have a
twist. If we blindly followed the pattern weâ€™ve used earlier, we would
end up with:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt; num-max(f, my-max(r))
  end
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Whatâ€™s wrong with this?</p></blockquote></blockquote><p>Consider the list <code data-lang="pyret" class="sourceCode">[list: 2]</code>. This turns into
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max(2, my-max([list: ]))</code></pre><p>which of course raises an error. Therefore, this function never works
for any list that has one or more elements!</p><p>Thatâ€™s because we need to make sure we arenâ€™t trying to compute the
maximum of the empty list.
Going back to our examples, we see that what we need to do, before
calling <code data-lang="pyret" class="sourceCode">my-max</code>, is check whether the rest of the list is
empty. If it is, we do not want to call <code data-lang="pyret" class="sourceCode">my-max</code> at all. That is:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; â€¦
        | â€¦
      end
  end
end</code></pre><p>Weâ€™ll return to what to do when the rest is not empty in a moment.</p><p>If the rest of the list <code data-lang="pyret" class="sourceCode">l</code> is empty, our examples above tell us
that the maximum is the first element in the list. Therefore, we can
fill this in:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; f
        | â€¦
      end
  end
end</code></pre><p>Note in particular the absence of a call to <code data-lang="pyret" class="sourceCode">my-max</code>. If the list
is not empty, however, our examples above tell us that <code data-lang="pyret" class="sourceCode">my-max</code>
will give us the maximum of the rest of the list, and we just need to
compare this answer with the first element (<code data-lang="pyret" class="sourceCode">f</code>):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; f
        | else  =&gt; num-max(f, my-max(r))
      end
  end
end</code></pre><p>And sure enough, this definition does the job!</p>&#13;
<h4 class="heading">5.2.7Â <a name="(part._.More_.Structural_.Problems_with_.Scalar_.Answers)"/>More Structural Problems with Scalar Answers<a href="#(part._.More_.Structural_.Problems_with_.Scalar_.Answers)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><section class="SsectionLevel5" id="section 5.2.7.1"><h5 class="heading">5.2.7.1Â <a name="(part._avg-eg)"/><code data-lang="pyret" class="sourceCode">my-avg</code>: Examples<a href="#(part._avg-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s now try to compute the average of a list of numbers. Letâ€™s start
with the example list <code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4]</code> and work out more
examples from it. The average of numbers in this list is clearly
<code data-lang="pyret" class="sourceCode">(1 + 2 + 3 + 4)/4</code>, or <code data-lang="pyret" class="sourceCode">10/4</code>.</p><p>Based on the listâ€™s structure, we see that the rest of the list is
<code data-lang="pyret" class="sourceCode">[list: 2, 3, 4]</code>, and the rest of that is <code data-lang="pyret" class="sourceCode">[list: 3, 4]</code>,
and so on. The resulting averages are:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-avg([list: 1, 2, 3, 4]) is 10/4
my-avg([list:    2, 3, 4]) is 9/3
my-avg([list:       3, 4]) is 7/2
my-avg([list:          4]) is 4/1</code></pre><p>The problem is, itâ€™s simply not clear how we get from the answer for
the sub-list to the answer for the whole list. That is, given the
following two bits of information:
</p><ul><li><p>The average of the remainder of the list is <code data-lang="pyret" class="sourceCode">9/3</code>, i.e.,
<code data-lang="pyret" class="sourceCode">3</code>.</p></li><li><p>The first number in the list is <code data-lang="pyret" class="sourceCode">1</code>.</p></li></ul><p>How do we determine that the average of the whole list must be
<code data-lang="pyret" class="sourceCode">10/4</code>? If itâ€™s not clear to you, donâ€™t worry: with just those
two pieces of information, itâ€™s impossible!</p><p>Hereâ€™s a simpler example that explains why. Letâ€™s suppose the first
value in a list is <code data-lang="pyret" class="sourceCode">1</code>, and the average of the rest of the list
is <code data-lang="pyret" class="sourceCode">2</code>. Here are two very different lists that fit this
description:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2]    # the rest has one element with sum 2
[list: 1, 4, 0] # the rest has two elements with sum 4</code></pre><p>The average of the entire first list is <code data-lang="pyret" class="sourceCode">3/2</code>, while the average
of the entire second list is <code data-lang="pyret" class="sourceCode">5/3</code>, and the two are not the same.</p><p>That is, to compute the average of a whole list, itâ€™s not even useful to
know the average of the rest of the list. Rather, we need to
know the sum and the length of the rest of the
list. With these two, we can add the first to the sum, and <code data-lang="pyret" class="sourceCode">1</code> to
the length, and compute the new average.</p><p>In principle, we could try to make a <code data-lang="pyret" class="sourceCode">average</code> function that
returns all this information. Instead, it will be a lot simpler to
simply decompose the task into two smaller tasks. After all, we
have already seen how to compute the length and how to compute the
sum. The average, therefore, can just use these existing functions:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-avg(l):
  my-sum(l) / my-len(l)
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What should be the average of the empty list? Does the above code
produce what you would expect?</p></blockquote></blockquote><p>Just as we argued earlier about the maximum
[<a href="#%28part._struct-prob-sub-dom%29" data-pltdoc="x">Structural Problems Over Relaxed Domains</a>], the average of the empty list isnâ€™t
a well-defined concept. Therefore, it would be appropriate to signal
an error. The implementation above does this, but poorly: it reports
an error on division. A better programming practice would be to
catch this situation and report the error right away, rather than
hoping some other function will report the error.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Alter <code data-lang="pyret" class="sourceCode">my-avg</code> above to signal an error when given the empty
list.</p></blockquote></blockquote><p>Therefore, we see that the process weâ€™ve usedâ€”<wbr/>of inferring code from
examplesâ€”<wbr/>wonâ€™t always suffice, and weâ€™ll need more
sophisticated techniques to solve some problems. However, notice that
working from examples helps us quickly identify situations
where this approach does and doesnâ€™t work. Furthermore, if you look
more closely youâ€™ll notice that the examples above do hint at
how to solve the problem: in our very first examples, we wrote answers
like <code data-lang="pyret" class="sourceCode">10/4</code>, <code data-lang="pyret" class="sourceCode">9/3</code>, and <code data-lang="pyret" class="sourceCode">7/2</code>, which correspond to the
sum of the numbers divided by the length. Thus, writing the answers in
this form (as opposed, for instance, to writing the second of those as
<code data-lang="pyret" class="sourceCode">3</code>) already reveals a structure for a solution.</p></section>&#13;
<h5 class="heading">5.2.7.1Â <a name="(part._avg-eg)"/><code data-lang="pyret" class="sourceCode">my-avg</code>: Examples<a href="#(part._avg-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s now try to compute the average of a list of numbers. Letâ€™s start
with the example list <code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4]</code> and work out more
examples from it. The average of numbers in this list is clearly
<code data-lang="pyret" class="sourceCode">(1 + 2 + 3 + 4)/4</code>, or <code data-lang="pyret" class="sourceCode">10/4</code>.</p><p>Based on the listâ€™s structure, we see that the rest of the list is
<code data-lang="pyret" class="sourceCode">[list: 2, 3, 4]</code>, and the rest of that is <code data-lang="pyret" class="sourceCode">[list: 3, 4]</code>,
and so on. The resulting averages are:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-avg([list: 1, 2, 3, 4]) is 10/4
my-avg([list:    2, 3, 4]) is 9/3
my-avg([list:       3, 4]) is 7/2
my-avg([list:          4]) is 4/1</code></pre><p>The problem is, itâ€™s simply not clear how we get from the answer for
the sub-list to the answer for the whole list. That is, given the
following two bits of information:
</p><ul><li><p>The average of the remainder of the list is <code data-lang="pyret" class="sourceCode">9/3</code>, i.e.,
<code data-lang="pyret" class="sourceCode">3</code>.</p></li><li><p>The first number in the list is <code data-lang="pyret" class="sourceCode">1</code>.</p></li></ul><p>How do we determine that the average of the whole list must be
<code data-lang="pyret" class="sourceCode">10/4</code>? If itâ€™s not clear to you, donâ€™t worry: with just those
two pieces of information, itâ€™s impossible!</p><p>Hereâ€™s a simpler example that explains why. Letâ€™s suppose the first
value in a list is <code data-lang="pyret" class="sourceCode">1</code>, and the average of the rest of the list
is <code data-lang="pyret" class="sourceCode">2</code>. Here are two very different lists that fit this
description:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2]    # the rest has one element with sum 2
[list: 1, 4, 0] # the rest has two elements with sum 4</code></pre><p>The average of the entire first list is <code data-lang="pyret" class="sourceCode">3/2</code>, while the average
of the entire second list is <code data-lang="pyret" class="sourceCode">5/3</code>, and the two are not the same.</p><p>That is, to compute the average of a whole list, itâ€™s not even useful to
know the average of the rest of the list. Rather, we need to
know the sum and the length of the rest of the
list. With these two, we can add the first to the sum, and <code data-lang="pyret" class="sourceCode">1</code> to
the length, and compute the new average.</p><p>In principle, we could try to make a <code data-lang="pyret" class="sourceCode">average</code> function that
returns all this information. Instead, it will be a lot simpler to
simply decompose the task into two smaller tasks. After all, we
have already seen how to compute the length and how to compute the
sum. The average, therefore, can just use these existing functions:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-avg(l):
  my-sum(l) / my-len(l)
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What should be the average of the empty list? Does the above code
produce what you would expect?</p></blockquote></blockquote><p>Just as we argued earlier about the maximum
[<a href="#%28part._struct-prob-sub-dom%29" data-pltdoc="x">Structural Problems Over Relaxed Domains</a>], the average of the empty list isnâ€™t
a well-defined concept. Therefore, it would be appropriate to signal
an error. The implementation above does this, but poorly: it reports
an error on division. A better programming practice would be to
catch this situation and report the error right away, rather than
hoping some other function will report the error.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Alter <code data-lang="pyret" class="sourceCode">my-avg</code> above to signal an error when given the empty
list.</p></blockquote></blockquote><p>Therefore, we see that the process weâ€™ve usedâ€”<wbr/>of inferring code from
examplesâ€”<wbr/>wonâ€™t always suffice, and weâ€™ll need more
sophisticated techniques to solve some problems. However, notice that
working from examples helps us quickly identify situations
where this approach does and doesnâ€™t work. Furthermore, if you look
more closely youâ€™ll notice that the examples above do hint at
how to solve the problem: in our very first examples, we wrote answers
like <code data-lang="pyret" class="sourceCode">10/4</code>, <code data-lang="pyret" class="sourceCode">9/3</code>, and <code data-lang="pyret" class="sourceCode">7/2</code>, which correspond to the
sum of the numbers divided by the length. Thus, writing the answers in
this form (as opposed, for instance, to writing the second of those as
<code data-lang="pyret" class="sourceCode">3</code>) already reveals a structure for a solution.</p>&#13;
<h4 class="heading">5.2.8Â <a name="(part._accumulators)"/>Structural Problems with Accumulators<a href="#(part._accumulators)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><section class="SsectionLevel5" id="section 5.2.8.1"><h5 class="heading">5.2.8.1Â <a name="(part._running-sum-1st-attempt)"/><code data-lang="pyret" class="sourceCode">my-running-sum</code>: First Attempt<a href="#(part._running-sum-1st-attempt)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>One more time, weâ€™ll begin with an example.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Work out the results for <code data-lang="pyret" class="sourceCode">my-running-sum</code> starting from the list
<code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4, 5]</code>.</p></blockquote></blockquote><p>Hereâ€™s what our first few examples look like:
</p><a name="(elem._running-sum-egs-1)"/>&lt;running-sum-egs-1&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
  my-running-sum([list:    2, 3, 4, 5]) is [list: 2, 5, 9, 14]
  my-running-sum([list:       3, 4, 5]) is [list: 3, 7, 12]
end</code></pre><p>Again, there doesnâ€™t appear to be any clear connection between the
result on the rest of the list and the result on the entire list.</p><p>(That isnâ€™t strictly true: we can still line up the answers as
follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
my-running-sum([list:    2, 3, 4, 5]) is [list:    2, 5,  9, 14]
my-running-sum([list:       3, 4, 5]) is [list:       3,  7, 12]</code></pre><p>and observe that weâ€™re computing the answer for the rest of the list,
then adding the first element to each element in the answer, and
<code data-lang="pyret" class="sourceCode">link</code>ing the first element to the front. In principle, we can
compute this solution directly, but for
now that may be more work than finding a simpler way to answer it.)</p></section><section class="SsectionLevel5" id="section 5.2.8.2"><h5 class="heading">5.2.8.2Â <a name="(part._running-sum-eg-code)"/><code data-lang="pyret" class="sourceCode">my-running-sum</code>: Examples and Code<a href="#(part._running-sum-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Recall how we began in <a href="#%28part._running-sum-1st-attempt%29" data-pltdoc="x"><code data-lang="pyret" class="sourceCode">my-running-sum</code>: First Attempt</a>. Our
examples [<a href="#%28elem._running-sum-egs-1%29" data-pltdoc="x">&lt;running-sum-egs-1&gt;</a>] showed the following
problem. When we process the rest of the list, we have forgotten
everything about what preceded it. That is, when processing the list
starting at <code data-lang="pyret" class="sourceCode">2</code> we forget that weâ€™ve seen a <code data-lang="pyret" class="sourceCode">1</code> earlier;
when starting from <code data-lang="pyret" class="sourceCode">3</code>, we forget that weâ€™ve seen both <code data-lang="pyret" class="sourceCode">1</code>
and <code data-lang="pyret" class="sourceCode">2</code> earlier; and so on. In other words, we keep
forgetting the past. We need some way of avoiding that.</p><p>The easiest thing we can do is simply change our function to carry
along this â€œmemoryâ€, or what weâ€™ll call an accumulator. That
is, imagine we were defining a new function, called <code data-lang="pyret" class="sourceCode">my-rs</code>. It
will consume a list of numbers and produce a list of numbers, but in
addition it will also take the sum of numbers preceding the
current list.
</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What should the initial sum be?</p></blockquote></blockquote><p>Initially there is no â€œpreceding listâ€, so we will use the additive
identity: <code data-lang="pyret" class="sourceCode">0</code>. The type of <code data-lang="pyret" class="sourceCode">my-rs</code> is
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs :: Number, List&lt;Number&gt; -&gt; List&lt;Number&gt;</code></pre><p>Letâ€™s now re-work our examples from <a href="#%28elem._running-sum-egs-1%29" data-pltdoc="x">&lt;running-sum-egs-1&gt;</a> as
examples of <code data-lang="pyret" class="sourceCode">my-rs</code> instead. The examples use the <code data-lang="pyret" class="sourceCode">+</code>
operator to append two lists into one (the elements of the first list
followed by the elements of the second):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs( 0, [list: 1, 2, 3, 4, 5]) is [list:  0 + 1] + my-rs( 0 + 1, [list: 2, 3, 4, 5])
my-rs( 1, [list:    2, 3, 4, 5]) is [list:  1 + 2] + my-rs( 1 + 2, [list:    3, 4, 5])
my-rs( 3, [list:       3, 4, 5]) is [list:  3 + 3] + my-rs( 3 + 3, [list:       4, 5])
my-rs( 6, [list:          4, 5]) is [list:  6 + 4] + my-rs( 6 + 4, [list:          5])
my-rs(10, [list:             5]) is [list: 10 + 5] + my-rs(10 + 5, [list:           ])
my-rs(15, [list:              ]) is empty</code></pre><p>That is, <code data-lang="pyret" class="sourceCode">my-rs</code> translates into the following code:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-rs(acc, l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      new-sum = acc + f
      link(new-sum, my-rs(new-sum, r))
  end
end</code></pre><p>All thatâ€™s then left is to call it from <code data-lang="pyret" class="sourceCode">my-running-sum</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-running-sum(l):
  my-rs(0, l)
end</code></pre><p>Observe that we do not change <code data-lang="pyret" class="sourceCode">my-running-sum</code> itself to take
extra arguments. The correctness of our code depends on the initial
value of <code data-lang="pyret" class="sourceCode">acc</code> being 0. If we added a parameter for <code data-lang="pyret" class="sourceCode">acc</code>,
any code that calls <code data-lang="pyret" class="sourceCode">my-running-sum</code> could supply an unexpected
value, which would distort the result. In addition, since the value is
fixed, adding the parameter would amount to shifting additional (and
needless) work onto others who use our code.</p></section><section class="SsectionLevel5" id="section 5.2.8.3"><h5 class="heading">5.2.8.3Â <a name="(part._alternating-accumulator)"/><code data-lang="pyret" class="sourceCode">my-alternating</code>: Examples and Code<a href="#(part._alternating-accumulator)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Recall our examples in <a href="#%28part._alternating-eg-code%29" data-pltdoc="x"><code data-lang="pyret" class="sourceCode">my-alternating</code>:
Examples and Code</a>. There, we
noticed that the code built on every-other example. We might have
chosen our examples differently, so that from one example to the next
we skipped two elements rather than one.
Here we will see another way to think about the same problem.</p><p>Return to the examples weâ€™ve already seen
[<a href="#%28elem._alternating-egs-1%29" data-pltdoc="x">&lt;alternating-egs-1&gt;</a>]. We wrote <code data-lang="pyret" class="sourceCode">my-alternating</code>
to traverse the list essentially two elements at a time. Another option is to traverse it just one
element at a time, but keeping track of whether weâ€™re at an odd
or even elementâ€”<wbr/>i.e., add â€œmemoryâ€ to our program. Since we just
need to track that one piece of information, we can use a
<code data-lang="pyret" class="sourceCode">Boolean</code> to do it. Letâ€™s define a new function for this purpose:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alt :: List&lt;Any&gt;, Boolean -&gt; List&lt;Any&gt;</code></pre><p>The extra argument accumulates whether weâ€™re at an element to keep or
one to discard.</p><p>We can reuse the existing template for list functions. When we have an
element, we have to consult the accumulator whether to keep it or
not. If its value is <code data-lang="pyret" class="sourceCode">true</code> we <code data-lang="pyret" class="sourceCode">link</code> it to the answer;
otherwise we ignore it. As we process the rest of the list, however,
we have to remember to update the accumulator: if we kept an element
we donâ€™t wish to keep the next one, and vice versa.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alt(l, keep):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if keep:
        link(f, my-alt(r, false))
      else:
        my-alt(r, true)
      end
  end
end</code></pre><p>Finally, we have to determine the initial value of the accumulator. In
this case, since we want to keep alternating elements starting
with the first one, its initial value should be <code data-lang="pyret" class="sourceCode">true</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  my-alt(l, true)
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Define <code data-lang="pyret" class="sourceCode">my-max</code> using an accumulator. What does the accumulator
represent? Do you encounter any difficulty?</p></blockquote></blockquote></section>&#13;
<h5 class="heading">5.2.8.1Â <a name="(part._running-sum-1st-attempt)"/><code data-lang="pyret" class="sourceCode">my-running-sum</code>: First Attempt<a href="#(part._running-sum-1st-attempt)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>One more time, weâ€™ll begin with an example.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Work out the results for <code data-lang="pyret" class="sourceCode">my-running-sum</code> starting from the list
<code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4, 5]</code>.</p></blockquote></blockquote><p>Hereâ€™s what our first few examples look like:
</p><a name="(elem._running-sum-egs-1)"/>&lt;running-sum-egs-1&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
  my-running-sum([list:    2, 3, 4, 5]) is [list: 2, 5, 9, 14]
  my-running-sum([list:       3, 4, 5]) is [list: 3, 7, 12]
end</code></pre><p>Again, there doesnâ€™t appear to be any clear connection between the
result on the rest of the list and the result on the entire list.</p><p>(That isnâ€™t strictly true: we can still line up the answers as
follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
my-running-sum([list:    2, 3, 4, 5]) is [list:    2, 5,  9, 14]
my-running-sum([list:       3, 4, 5]) is [list:       3,  7, 12]</code></pre><p>and observe that weâ€™re computing the answer for the rest of the list,
then adding the first element to each element in the answer, and
<code data-lang="pyret" class="sourceCode">link</code>ing the first element to the front. In principle, we can
compute this solution directly, but for
now that may be more work than finding a simpler way to answer it.)</p>&#13;
<h5 class="heading">5.2.8.2Â <a name="(part._running-sum-eg-code)"/><code data-lang="pyret" class="sourceCode">my-running-sum</code>: Examples and Code<a href="#(part._running-sum-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Recall how we began in <a href="#%28part._running-sum-1st-attempt%29" data-pltdoc="x"><code data-lang="pyret" class="sourceCode">my-running-sum</code>: First Attempt</a>. Our
examples [<a href="#%28elem._running-sum-egs-1%29" data-pltdoc="x">&lt;running-sum-egs-1&gt;</a>] showed the following
problem. When we process the rest of the list, we have forgotten
everything about what preceded it. That is, when processing the list
starting at <code data-lang="pyret" class="sourceCode">2</code> we forget that weâ€™ve seen a <code data-lang="pyret" class="sourceCode">1</code> earlier;
when starting from <code data-lang="pyret" class="sourceCode">3</code>, we forget that weâ€™ve seen both <code data-lang="pyret" class="sourceCode">1</code>
and <code data-lang="pyret" class="sourceCode">2</code> earlier; and so on. In other words, we keep
forgetting the past. We need some way of avoiding that.</p><p>The easiest thing we can do is simply change our function to carry
along this â€œmemoryâ€, or what weâ€™ll call an accumulator. That
is, imagine we were defining a new function, called <code data-lang="pyret" class="sourceCode">my-rs</code>. It
will consume a list of numbers and produce a list of numbers, but in
addition it will also take the sum of numbers preceding the
current list.
</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What should the initial sum be?</p></blockquote></blockquote><p>Initially there is no â€œpreceding listâ€, so we will use the additive
identity: <code data-lang="pyret" class="sourceCode">0</code>. The type of <code data-lang="pyret" class="sourceCode">my-rs</code> is
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs :: Number, List&lt;Number&gt; -&gt; List&lt;Number&gt;</code></pre><p>Letâ€™s now re-work our examples from <a href="#%28elem._running-sum-egs-1%29" data-pltdoc="x">&lt;running-sum-egs-1&gt;</a> as
examples of <code data-lang="pyret" class="sourceCode">my-rs</code> instead. The examples use the <code data-lang="pyret" class="sourceCode">+</code>
operator to append two lists into one (the elements of the first list
followed by the elements of the second):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs( 0, [list: 1, 2, 3, 4, 5]) is [list:  0 + 1] + my-rs( 0 + 1, [list: 2, 3, 4, 5])
my-rs( 1, [list:    2, 3, 4, 5]) is [list:  1 + 2] + my-rs( 1 + 2, [list:    3, 4, 5])
my-rs( 3, [list:       3, 4, 5]) is [list:  3 + 3] + my-rs( 3 + 3, [list:       4, 5])
my-rs( 6, [list:          4, 5]) is [list:  6 + 4] + my-rs( 6 + 4, [list:          5])
my-rs(10, [list:             5]) is [list: 10 + 5] + my-rs(10 + 5, [list:           ])
my-rs(15, [list:              ]) is empty</code></pre><p>That is, <code data-lang="pyret" class="sourceCode">my-rs</code> translates into the following code:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-rs(acc, l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      new-sum = acc + f
      link(new-sum, my-rs(new-sum, r))
  end
end</code></pre><p>All thatâ€™s then left is to call it from <code data-lang="pyret" class="sourceCode">my-running-sum</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-running-sum(l):
  my-rs(0, l)
end</code></pre><p>Observe that we do not change <code data-lang="pyret" class="sourceCode">my-running-sum</code> itself to take
extra arguments. The correctness of our code depends on the initial
value of <code data-lang="pyret" class="sourceCode">acc</code> being 0. If we added a parameter for <code data-lang="pyret" class="sourceCode">acc</code>,
any code that calls <code data-lang="pyret" class="sourceCode">my-running-sum</code> could supply an unexpected
value, which would distort the result. In addition, since the value is
fixed, adding the parameter would amount to shifting additional (and
needless) work onto others who use our code.</p>&#13;
<h5 class="heading">5.2.8.3Â <a name="(part._alternating-accumulator)"/><code data-lang="pyret" class="sourceCode">my-alternating</code>: Examples and Code<a href="#(part._alternating-accumulator)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Recall our examples in <a href="#%28part._alternating-eg-code%29" data-pltdoc="x"><code data-lang="pyret" class="sourceCode">my-alternating</code>:
Examples and Code</a>. There, we
noticed that the code built on every-other example. We might have
chosen our examples differently, so that from one example to the next
we skipped two elements rather than one.
Here we will see another way to think about the same problem.</p><p>Return to the examples weâ€™ve already seen
[<a href="#%28elem._alternating-egs-1%29" data-pltdoc="x">&lt;alternating-egs-1&gt;</a>]. We wrote <code data-lang="pyret" class="sourceCode">my-alternating</code>
to traverse the list essentially two elements at a time. Another option is to traverse it just one
element at a time, but keeping track of whether weâ€™re at an odd
or even elementâ€”<wbr/>i.e., add â€œmemoryâ€ to our program. Since we just
need to track that one piece of information, we can use a
<code data-lang="pyret" class="sourceCode">Boolean</code> to do it. Letâ€™s define a new function for this purpose:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alt :: List&lt;Any&gt;, Boolean -&gt; List&lt;Any&gt;</code></pre><p>The extra argument accumulates whether weâ€™re at an element to keep or
one to discard.</p><p>We can reuse the existing template for list functions. When we have an
element, we have to consult the accumulator whether to keep it or
not. If its value is <code data-lang="pyret" class="sourceCode">true</code> we <code data-lang="pyret" class="sourceCode">link</code> it to the answer;
otherwise we ignore it. As we process the rest of the list, however,
we have to remember to update the accumulator: if we kept an element
we donâ€™t wish to keep the next one, and vice versa.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alt(l, keep):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if keep:
        link(f, my-alt(r, false))
      else:
        my-alt(r, true)
      end
  end
end</code></pre><p>Finally, we have to determine the initial value of the accumulator. In
this case, since we want to keep alternating elements starting
with the first one, its initial value should be <code data-lang="pyret" class="sourceCode">true</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  my-alt(l, true)
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Define <code data-lang="pyret" class="sourceCode">my-max</code> using an accumulator. What does the accumulator
represent? Do you encounter any difficulty?</p></blockquote></blockquote>&#13;
<h4 class="heading">5.2.9Â <a name="(part._.Dealing_with_.Multiple_.Answers)"/>Dealing with Multiple Answers<a href="#(part._.Dealing_with_.Multiple_.Answers)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Our discussion above has assumed there is only one answer for a given
input. This is often true, but it also depends on how the problem is
worded and how we choose to generate examples. We will study this in
some detail now.</p><section class="SsectionLevel5" id="section 5.2.9.1"><h5 class="heading">5.2.9.1Â <a name="(part._uniq)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Problem Setup<a href="#(part._uniq)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Consider the task of writing <code data-lang="pyret" class="sourceCode">uniq</code>:uniq is the
name of a Unix utility with similar behavior; hence the spelling of
the name. given a list of values, it produces a collection of the
same elements while avoiding any duplicates (hence <code data-lang="pyret" class="sourceCode">uniq</code>, short
for â€œuniqueâ€).</p><p>Consider the following input: <code data-lang="pyret" class="sourceCode">[list: 1, 2, 1, 3, 1, 2, 4, 1]</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What is the sequence of examples this input generates?  Itâ€™s
really important you stop and try to do this by hand. As we
will see there are multiple solutions, and itâ€™s useful for you to
consider what you generate. Even if you canâ€™t generate a sequence,
trying to do so will better prepare you for what you read next.</p></blockquote></blockquote><p>How did you obtain your example? If you just â€œthought about it for a
moment and wrote something downâ€, you may or may not have gotten
something you can turn into a program. Programs can only proceed
systematically; they canâ€™t â€œthinkâ€. So, hopefully you took a
well-defined path to computing the answer.</p></section><section class="SsectionLevel5" id="section 5.2.9.2"><h5 class="heading">5.2.9.2Â <a name="(part._uniq-eg)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Examples<a href="#(part._uniq-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>It turns out there are several possible answers, because we
have (intentionally) left the problem unspecified. Suppose there are
two instances of a value in the list; which one do we keep, the first
or the second? On the one hand, since the two instances must be
equivalent it doesnâ€™t matter, but it does for writing concrete
examples and deriving a solution.</p><p>For instance, you might have generated this sequence:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">examples:
  uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:    2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:       1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:          3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:             1, 2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                   4, 1]) is [list:       4, 1]
  uniq([list:                      1]) is [list:          1]
  uniq([list:                       ]) is [list:           ]
end</code></pre><p>However, you might have also generated sequences that began with
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 1, 2, 3, 4]</code></pre><p>or
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 4, 3, 2, 1]</code></pre><p>and so on. Letâ€™s work with the examples weâ€™ve worked out above.</p></section><section class="SsectionLevel5" id="section 5.2.9.3"><h5 class="heading">5.2.9.3Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Code<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>What is the systematic approach that gets us to this answer?
When given a non-empty list, we split it into its first element and
the rest of the list. Suppose we have the answer to <code data-lang="pyret" class="sourceCode">uniq</code>
applied to the rest of the list. Now we can ask: is the first element
in the rest of the list? If it is, then we can ignore it, since it is
certain to be in the <code data-lang="pyret" class="sourceCode">uniq</code> of the rest of the list. If, however,
it is not in the rest of the list, itâ€™s critical that we <code data-lang="pyret" class="sourceCode">link</code>
it to the answer.</p><p>This translates into the following program. For the empty list, we
return the empty list. If the list is non-empty, we check whether the
first is in the rest of the list. If it is not, we include it;
otherwise we can ignore it for now.</p><p>This results in the following program:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if r.member(f):
        uniq-rec(r)
      else:
        link(f, uniq-rec(r))
      end
  end
end</code></pre><p>which weâ€™ve called <code data-lang="pyret" class="sourceCode">uniq-rec</code> instead of <code data-lang="pyret" class="sourceCode">uniq</code> to
differentiate it from other versions of <code data-lang="pyret" class="sourceCode">uniq</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Note that weâ€™re using <code data-lang="pyret" class="sourceCode">.member</code> to check whether an element is a
member of the list. Write a function <code data-lang="pyret" class="sourceCode">member</code> that consumes an
element and a list, and tells us whether the element is a member of
the list.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Uniqueness checking has many practical applications. For example, one
might have a list of names of people who have registered to vote in an
election. To keep the voting fair, with only one vote allowed per
person, we should remove duplicate names from the list.</p><ol><li><p>Propose a set of examples for a function <code data-lang="pyret" class="sourceCode">rem-duplicate-voters</code>
that takes a list of voter names and returns a list in which duplicate
registrations have been removed. In developing your examples, consider
real-world scenarios that you can imagine arising when identifying
duplicate names. Can you identify cases in which two names
might appear to be the same person, but not be? Cases in which two
names might appear different but be referring to the same person?</p></li><li><p>What might you need to change about our current <code data-lang="pyret" class="sourceCode">uniq-rec</code>
function to handle a situation like removing duplicate voters?</p></li></ol></blockquote></blockquote><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Context Matters When Comparing Values</p><blockquote class="RespCSBody"><p>The data de-duplication context in the above exercise reminds us that
different contexts may call for different notions of when two data values
are the same. Sometimes, we want exact matching to determine that two
strings are equal. Sometimes, we need methods that normalize data,
either in simple ways like capitalization or subtler ways based on
middle initials. Sometimes, we need more information (like street
addresses in addition to names) in order to determine whether two
items in a list should be considered â€œthe sameâ€.</p><p>It is easy to write programs that encode assumptions about our data
that might not apply in practice.  This is again a situation that can
be helped by thinking about the concrete examples on which your code
needs to work in context.  </p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.2.9.4"><h5 class="heading">5.2.9.4Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Reducing Computation<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Notice that this function has a repeated expression. Instead of
writing it twice, we could call it just once and use the result in
both places:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec2(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      ur = uniq-rec2(r)
      if r.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end</code></pre><p>You might think, because we replaced two function calls with one, that
weâ€™ve reduced the amount of computation the program does. It does not!
The two function calls are both in the two branches of the same
conditional; therefore, for any given list element, only one or the
other call to <code data-lang="pyret" class="sourceCode">uniq</code> happens. In fact, in both cases, there was
one call to <code data-lang="pyret" class="sourceCode">uniq</code> before, and there is one now. So we have
reduced the number of calls in the source program, but not the number
that take place when the program runs. In that sense, the name of this
section was intentionally misleading!</p><p>However, there is one useful reduction we can perform, which is
enabled by the structure of <code data-lang="pyret" class="sourceCode">uniq-rec2</code>. We currently check
whether <code data-lang="pyret" class="sourceCode">f</code> is a member of <code data-lang="pyret" class="sourceCode">r</code>, which is the list of
all the remaining elements. In our example, this means that in
the very second turn, we check whether <code data-lang="pyret" class="sourceCode">2</code> is a member of the list
<code data-lang="pyret" class="sourceCode">[list: 1, 3, 1, 2, 4, 1]</code>. This is a list of six elements,
including three copies of <code data-lang="pyret" class="sourceCode">1</code>. We compare <code data-lang="pyret" class="sourceCode">2</code> against
two copies of <code data-lang="pyret" class="sourceCode">1</code>. However, we gain nothing from the
second comparison. Put differently, we can think of <code data-lang="pyret" class="sourceCode">uniq(r)</code> as
a â€œsummaryâ€ of the rest of the list that is exactly as good as
<code data-lang="pyret" class="sourceCode">r</code> itself for checking membership, with the advantage that it
might be significantly shorter. This, of course, is exactly what
<code data-lang="pyret" class="sourceCode">ur</code> represents. Therefore, we can encode this intuition as
follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec3(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      ur = uniq-rec3(r)
      if ur.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end</code></pre><p>Note that all that changed is that we check for membership in
<code data-lang="pyret" class="sourceCode">ur</code> rather than in <code data-lang="pyret" class="sourceCode">r</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Later [<a href="predicting-growth.html" data-pltdoc="x">Predicting Growth</a>] we will study how to formally
study how long a program takes to run. By the measure introduced in
that section, does the change we just made make any difference? Be
careful with your answer: it depends on how we count â€œthe lengthâ€ of
the list.</p></blockquote></blockquote><p>Observe that if the list never contained duplicates in the first
place, then it wouldnâ€™t matter which list we check membership inâ€”<wbr/>but
if we knew the list didnâ€™t contain duplicates, we wouldnâ€™t be
using <code data-lang="pyret" class="sourceCode">uniq</code> in the first place! We will return to the issue of
lists and duplicate elements in <a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>.</p></section><section class="SsectionLevel5" id="section 5.2.9.5"><h5 class="heading">5.2.9.5Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Example and Code Variations<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>As we mentioned earlier, there are other example sequences you might
have written down. Hereâ€™s a very different process:
</p><ul><li><p>Start with the entire given list and with the empty answer (so
far).</p></li><li><p>For each list element, check whether itâ€™s already in the answer
so far. If it is, ignore it, otherwise extend the answer with it.</p></li><li><p>When there are no more elements in the list, the answer so far
is the answer for the whole list.</p></li></ul><p>Notice that this solution assumes that we will be accumulating the
answer as we traverse the list. Therefore, we canâ€™t even write the
example with one parameter as we did before. We would argue that a
natural solution asks whether we can solve the problem just
from the structure of the data using the computation we are already
defining, as we did above. If we cannot, then we have to resort to an
accumulator. But because we can, the accumulator is unnecessary here
and greatly complicates even writing down examples (give it a try!).</p></section><section class="SsectionLevel5" id="section 5.2.9.6"><h5 class="heading">5.2.9.6Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Why Produce a List?<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>If you go back to the original statement of the <code data-lang="pyret" class="sourceCode">uniq</code> problem
[<a href="#%28part._uniq%29" data-pltdoc="x"><code data-lang="pyret" class="sourceCode">uniq</code>: Problem Setup</a>], youâ€™ll notice it said nothing about what order the
output should have; in fact, it didnâ€™t even say the output needs to be
a list (and hence have an order). In that case, we should think about
whether a list even makes sense for this problem. In fact, if we donâ€™t
care about order and donâ€™t want duplicates (by definition of
<code data-lang="pyret" class="sourceCode">uniq</code>), then there is a much simpler solution, which is to
produce a set. Pyret already has sets built in, and converting
the list to a set automatically takes care of duplicates. This is of
course cheating from the perspective of learning how to write
<code data-lang="pyret" class="sourceCode">uniq</code>, but it is worth remembering that sometimes the right data
structure to produce isnâ€™t necessarily the same as the one we were
given. Also, later [<a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>], we will see how to build sets
for ourselves (at which point, <code data-lang="pyret" class="sourceCode">uniq</code> will look familiar, since
it is at the heart of set-ness).</p></section>&#13;
<h5 class="heading">5.2.9.1Â <a name="(part._uniq)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Problem Setup<a href="#(part._uniq)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Consider the task of writing <code data-lang="pyret" class="sourceCode">uniq</code>:uniq is the
name of a Unix utility with similar behavior; hence the spelling of
the name. given a list of values, it produces a collection of the
same elements while avoiding any duplicates (hence <code data-lang="pyret" class="sourceCode">uniq</code>, short
for â€œuniqueâ€).</p><p>Consider the following input: <code data-lang="pyret" class="sourceCode">[list: 1, 2, 1, 3, 1, 2, 4, 1]</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What is the sequence of examples this input generates?  Itâ€™s
really important you stop and try to do this by hand. As we
will see there are multiple solutions, and itâ€™s useful for you to
consider what you generate. Even if you canâ€™t generate a sequence,
trying to do so will better prepare you for what you read next.</p></blockquote></blockquote><p>How did you obtain your example? If you just â€œthought about it for a
moment and wrote something downâ€, you may or may not have gotten
something you can turn into a program. Programs can only proceed
systematically; they canâ€™t â€œthinkâ€. So, hopefully you took a
well-defined path to computing the answer.</p>&#13;
<h5 class="heading">5.2.9.2Â <a name="(part._uniq-eg)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Examples<a href="#(part._uniq-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>It turns out there are several possible answers, because we
have (intentionally) left the problem unspecified. Suppose there are
two instances of a value in the list; which one do we keep, the first
or the second? On the one hand, since the two instances must be
equivalent it doesnâ€™t matter, but it does for writing concrete
examples and deriving a solution.</p><p>For instance, you might have generated this sequence:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">examples:
  uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:    2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:       1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:          3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:             1, 2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                   4, 1]) is [list:       4, 1]
  uniq([list:                      1]) is [list:          1]
  uniq([list:                       ]) is [list:           ]
end</code></pre><p>However, you might have also generated sequences that began with
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 1, 2, 3, 4]</code></pre><p>or
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 4, 3, 2, 1]</code></pre><p>and so on. Letâ€™s work with the examples weâ€™ve worked out above.</p>&#13;
<h5 class="heading">5.2.9.3Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Code<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>What is the systematic approach that gets us to this answer?
When given a non-empty list, we split it into its first element and
the rest of the list. Suppose we have the answer to <code data-lang="pyret" class="sourceCode">uniq</code>
applied to the rest of the list. Now we can ask: is the first element
in the rest of the list? If it is, then we can ignore it, since it is
certain to be in the <code data-lang="pyret" class="sourceCode">uniq</code> of the rest of the list. If, however,
it is not in the rest of the list, itâ€™s critical that we <code data-lang="pyret" class="sourceCode">link</code>
it to the answer.</p><p>This translates into the following program. For the empty list, we
return the empty list. If the list is non-empty, we check whether the
first is in the rest of the list. If it is not, we include it;
otherwise we can ignore it for now.</p><p>This results in the following program:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if r.member(f):
        uniq-rec(r)
      else:
        link(f, uniq-rec(r))
      end
  end
end</code></pre><p>which weâ€™ve called <code data-lang="pyret" class="sourceCode">uniq-rec</code> instead of <code data-lang="pyret" class="sourceCode">uniq</code> to
differentiate it from other versions of <code data-lang="pyret" class="sourceCode">uniq</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Note that weâ€™re using <code data-lang="pyret" class="sourceCode">.member</code> to check whether an element is a
member of the list. Write a function <code data-lang="pyret" class="sourceCode">member</code> that consumes an
element and a list, and tells us whether the element is a member of
the list.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Uniqueness checking has many practical applications. For example, one
might have a list of names of people who have registered to vote in an
election. To keep the voting fair, with only one vote allowed per
person, we should remove duplicate names from the list.</p><ol><li><p>Propose a set of examples for a function <code data-lang="pyret" class="sourceCode">rem-duplicate-voters</code>
that takes a list of voter names and returns a list in which duplicate
registrations have been removed. In developing your examples, consider
real-world scenarios that you can imagine arising when identifying
duplicate names. Can you identify cases in which two names
might appear to be the same person, but not be? Cases in which two
names might appear different but be referring to the same person?</p></li><li><p>What might you need to change about our current <code data-lang="pyret" class="sourceCode">uniq-rec</code>
function to handle a situation like removing duplicate voters?</p></li></ol></blockquote></blockquote><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Context Matters When Comparing Values</p><blockquote class="RespCSBody"><p>The data de-duplication context in the above exercise reminds us that
different contexts may call for different notions of when two data values
are the same. Sometimes, we want exact matching to determine that two
strings are equal. Sometimes, we need methods that normalize data,
either in simple ways like capitalization or subtler ways based on
middle initials. Sometimes, we need more information (like street
addresses in addition to names) in order to determine whether two
items in a list should be considered â€œthe sameâ€.</p><p>It is easy to write programs that encode assumptions about our data
that might not apply in practice.  This is again a situation that can
be helped by thinking about the concrete examples on which your code
needs to work in context.  </p></blockquote></blockquote>&#13;
<h5 class="heading">5.2.9.4Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Reducing Computation<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Notice that this function has a repeated expression. Instead of
writing it twice, we could call it just once and use the result in
both places:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec2(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      ur = uniq-rec2(r)
      if r.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end</code></pre><p>You might think, because we replaced two function calls with one, that
weâ€™ve reduced the amount of computation the program does. It does not!
The two function calls are both in the two branches of the same
conditional; therefore, for any given list element, only one or the
other call to <code data-lang="pyret" class="sourceCode">uniq</code> happens. In fact, in both cases, there was
one call to <code data-lang="pyret" class="sourceCode">uniq</code> before, and there is one now. So we have
reduced the number of calls in the source program, but not the number
that take place when the program runs. In that sense, the name of this
section was intentionally misleading!</p><p>However, there is one useful reduction we can perform, which is
enabled by the structure of <code data-lang="pyret" class="sourceCode">uniq-rec2</code>. We currently check
whether <code data-lang="pyret" class="sourceCode">f</code> is a member of <code data-lang="pyret" class="sourceCode">r</code>, which is the list of
all the remaining elements. In our example, this means that in
the very second turn, we check whether <code data-lang="pyret" class="sourceCode">2</code> is a member of the list
<code data-lang="pyret" class="sourceCode">[list: 1, 3, 1, 2, 4, 1]</code>. This is a list of six elements,
including three copies of <code data-lang="pyret" class="sourceCode">1</code>. We compare <code data-lang="pyret" class="sourceCode">2</code> against
two copies of <code data-lang="pyret" class="sourceCode">1</code>. However, we gain nothing from the
second comparison. Put differently, we can think of <code data-lang="pyret" class="sourceCode">uniq(r)</code> as
a â€œsummaryâ€ of the rest of the list that is exactly as good as
<code data-lang="pyret" class="sourceCode">r</code> itself for checking membership, with the advantage that it
might be significantly shorter. This, of course, is exactly what
<code data-lang="pyret" class="sourceCode">ur</code> represents. Therefore, we can encode this intuition as
follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec3(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      ur = uniq-rec3(r)
      if ur.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end</code></pre><p>Note that all that changed is that we check for membership in
<code data-lang="pyret" class="sourceCode">ur</code> rather than in <code data-lang="pyret" class="sourceCode">r</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Later [<a href="predicting-growth.html" data-pltdoc="x">Predicting Growth</a>] we will study how to formally
study how long a program takes to run. By the measure introduced in
that section, does the change we just made make any difference? Be
careful with your answer: it depends on how we count â€œthe lengthâ€ of
the list.</p></blockquote></blockquote><p>Observe that if the list never contained duplicates in the first
place, then it wouldnâ€™t matter which list we check membership inâ€”<wbr/>but
if we knew the list didnâ€™t contain duplicates, we wouldnâ€™t be
using <code data-lang="pyret" class="sourceCode">uniq</code> in the first place! We will return to the issue of
lists and duplicate elements in <a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>.</p>&#13;
<h5 class="heading">5.2.9.5Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Example and Code Variations<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>As we mentioned earlier, there are other example sequences you might
have written down. Hereâ€™s a very different process:
</p><ul><li><p>Start with the entire given list and with the empty answer (so
far).</p></li><li><p>For each list element, check whether itâ€™s already in the answer
so far. If it is, ignore it, otherwise extend the answer with it.</p></li><li><p>When there are no more elements in the list, the answer so far
is the answer for the whole list.</p></li></ul><p>Notice that this solution assumes that we will be accumulating the
answer as we traverse the list. Therefore, we canâ€™t even write the
example with one parameter as we did before. We would argue that a
natural solution asks whether we can solve the problem just
from the structure of the data using the computation we are already
defining, as we did above. If we cannot, then we have to resort to an
accumulator. But because we can, the accumulator is unnecessary here
and greatly complicates even writing down examples (give it a try!).</p>&#13;
<h5 class="heading">5.2.9.6Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)"/><code data-lang="pyret" class="sourceCode">uniq</code>: Why Produce a List?<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>If you go back to the original statement of the <code data-lang="pyret" class="sourceCode">uniq</code> problem
[<a href="#%28part._uniq%29" data-pltdoc="x"><code data-lang="pyret" class="sourceCode">uniq</code>: Problem Setup</a>], youâ€™ll notice it said nothing about what order the
output should have; in fact, it didnâ€™t even say the output needs to be
a list (and hence have an order). In that case, we should think about
whether a list even makes sense for this problem. In fact, if we donâ€™t
care about order and donâ€™t want duplicates (by definition of
<code data-lang="pyret" class="sourceCode">uniq</code>), then there is a much simpler solution, which is to
produce a set. Pyret already has sets built in, and converting
the list to a set automatically takes care of duplicates. This is of
course cheating from the perspective of learning how to write
<code data-lang="pyret" class="sourceCode">uniq</code>, but it is worth remembering that sometimes the right data
structure to produce isnâ€™t necessarily the same as the one we were
given. Also, later [<a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>], we will see how to build sets
for ourselves (at which point, <code data-lang="pyret" class="sourceCode">uniq</code> will look familiar, since
it is at the heart of set-ness).</p>&#13;
<h4 class="heading">5.2.10Â <a name="(part._polymorphic-data)"/>Monomorphic Lists and Polymorphic Types<a href="#(part._polymorphic-data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Earlier we wrote contracts like:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len :: List&lt;Any&gt; -&gt; Number
my-max :: List&lt;Any&gt; -&gt; Any</code></pre><p>These are unsatisfying for several reasons. Consider
<code data-lang="pyret" class="sourceCode">my-max</code>. The contract suggests that any kind of element can be
in the input list, but in fact that isnâ€™t true: the input
<code data-lang="pyret" class="sourceCode">[list: 1, "two", 3]</code> is not valid, because we canâ€™t compare
<code data-lang="pyret" class="sourceCode">1</code> with <code data-lang="pyret" class="sourceCode">"two"</code> or <code data-lang="pyret" class="sourceCode">"two"</code> with <code data-lang="pyret" class="sourceCode">3</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>What happens if we run <code data-lang="pyret" class="sourceCode">1 &gt; "two"</code> or <code data-lang="pyret" class="sourceCode">"two" &gt; 3</code>?</p></blockquote></blockquote><p>Rather, what we mean is a list where all the elements are of the
same kind,Technically, elements that are also comparable.
and the contract has not captured that. Furthermore, we donâ€™t mean
that <code data-lang="pyret" class="sourceCode">my-max</code> might return any old type: if we supply it with a
list of numbers, we will not get a string as the maximum element!
Rather, it will only return the kind of element that is in the
provided list.</p><p>In short, we mean that all elements of the list are of the same type,
but they can be of any type. We call the former monomorphic:
â€œmonoâ€ meaning one, and â€œmorphicâ€ meaning shape, i.e., all values
have one type. But the function <code data-lang="pyret" class="sourceCode">my-max</code> itself can operate over
many of these kinds of lists, so we call it polymorphic
(â€œpolyâ€ meaning many).</p><p>Therefore, we need a better way of writing these
contracts. Essentially, we want to say that there is a
type variable (as opposed to regular program variable) that represents the
type of element in the list. Given that type, <code data-lang="pyret" class="sourceCode">my-max</code> will
return an element of that type. We write this syntactically as
follows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max&lt;T&gt;(l :: List&lt;T&gt;) -&gt; T: â€¦ end</code></pre><p>The notation <code data-lang="pyret" class="sourceCode">&lt;T&gt;</code> says that <code data-lang="pyret" class="sourceCode">T</code> is a type variable
parameter that will be used in the rest of the function (both the
header and the body).</p><p>Using this notation, we can also revisit <code data-lang="pyret" class="sourceCode">my-len</code>. Its header now
becomes:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-len&lt;T&gt;(l :: List&lt;T&gt;) -&gt; Number: â€¦ end</code></pre><p>Note that <code data-lang="pyret" class="sourceCode">my-len</code> did not actually â€œcareâ€ that whether all the
values were of the same type or not: it never looks at the individual
elements, much less at pairs of them. However, as a convention
we demand that lists always be monomorphic. This is important because
it enables us to process the elements of the list uniformly: if we
know how to process elements of type <code data-lang="pyret" class="sourceCode">T</code>, then we will know how
to process a <code data-lang="pyret" class="sourceCode">List&lt;T&gt;</code>. If the list elements can be of truly any
old type, we canâ€™t know how to process its elements.</p>    
</body>
</html>