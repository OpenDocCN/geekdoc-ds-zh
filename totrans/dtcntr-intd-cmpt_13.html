<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>5.2Â Processing ListsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>5.2Â Processing ListsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/processing-lists.html">https://dcic-world.org/2025-08-27/processing-lists.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Making_.Lists_and_.Taking_.Them_.Apart%29" class="toclink" data-pltdoc="x">5.2.1<span class="hspace">Â </span>Making Lists and Taking Them Apart</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._my-len%29" class="toclink" data-pltdoc="x">5.2.2<span class="hspace">Â </span>Some Example Exercises</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Structural_.Problems_with_.Scalar_.Answers%29" class="toclink" data-pltdoc="x">5.2.3<span class="hspace">Â </span>Structural Problems with Scalar Answers</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._len-eg%29" class="toclink" data-pltdoc="x">5.2.3.1<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>: Examples</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._sum-eg%29" class="toclink" data-pltdoc="x">5.2.3.2<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum</code></span>: Examples</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.From_.Examples_to_.Code%29" class="toclink" data-pltdoc="x">5.2.3.3<span class="hspace">Â </span>From Examples to Code</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Structural_.Problems_that_.Transform_.Lists%29" class="toclink" data-pltdoc="x">5.2.4<span class="hspace">Â </span>Structural Problems that Transform Lists</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._doubles-eg-code%29" class="toclink" data-pltdoc="x">5.2.4.1<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles</code></span>: Examples and Code</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._str-len-eg-code%29" class="toclink" data-pltdoc="x">5.2.4.2<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len</code></span>: Examples and Code</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Structural_.Problems_that_.Select_from_.Lists%29" class="toclink" data-pltdoc="x">5.2.5<span class="hspace">Â </span>Structural Problems that Select from Lists</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._pos-nums-eg-code%29" class="toclink" data-pltdoc="x">5.2.5.1<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums</code></span>: Examples and Code</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._alternating-eg-code%29" class="toclink" data-pltdoc="x">5.2.5.2<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span>:
Examples and Code</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._struct-prob-sub-dom%29" class="toclink" data-pltdoc="x">5.2.6<span class="hspace">Â </span>Structural Problems Over Relaxed Domains</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._my-max%29" class="toclink" data-pltdoc="x">5.2.6.1<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>: Examples</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code%29" class="toclink" data-pltdoc="x">5.2.6.2<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>: From Examples to Code</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.More_.Structural_.Problems_with_.Scalar_.Answers%29" class="toclink" data-pltdoc="x">5.2.7<span class="hspace">Â </span>More Structural Problems with Scalar Answers</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._avg-eg%29" class="toclink" data-pltdoc="x">5.2.7.1<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-avg</code></span>: Examples</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._accumulators%29" class="toclink" data-pltdoc="x">5.2.8<span class="hspace">Â </span>Structural Problems with Accumulators</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._running-sum-1st-attempt%29" class="toclink" data-pltdoc="x">5.2.8.1<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>: First Attempt</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._running-sum-eg-code%29" class="toclink" data-pltdoc="x">5.2.8.2<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>: Examples and Code</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._alternating-accumulator%29" class="toclink" data-pltdoc="x">5.2.8.3<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span>: Examples and Code</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Dealing_with_.Multiple_.Answers%29" class="toclink" data-pltdoc="x">5.2.9<span class="hspace">Â </span>Dealing with Multiple Answers</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._uniq%29" class="toclink" data-pltdoc="x">5.2.9.1<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Problem Setup</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._uniq-eg%29" class="toclink" data-pltdoc="x">5.2.9.2<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Examples</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code%29" class="toclink" data-pltdoc="x">5.2.9.3<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Code</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation%29" class="toclink" data-pltdoc="x">5.2.9.4<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Reducing Computation</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations%29" class="toclink" data-pltdoc="x">5.2.9.5<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Example and Code Variations</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_%29" class="toclink" data-pltdoc="x">5.2.9.6<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Why Produce a List?</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._polymorphic-data%29" class="toclink" data-pltdoc="x">5.2.10<span class="hspace">Â </span>Monomorphic Lists and Polymorphic Types</a></p></td></tr></table><p>We have already seen [<a href="tables-to-lists.html" data-pltdoc="x">From Tables to Lists</a>] several examples of
list-processing functions. They have been especially useful for
advanced processing of tables. However, lists arise frequently in
programs, and they do so naturally because so many things in our
livesâ€”<wbr/>from shopping lists to to-do lists to checklistsâ€”<wbr/>are
naturally lists. Thinking about the functions that we might want
when processing lists, we can observe that there are some interesting
categories regarding the <span class="emph">types</span> of the data in the list:</p><ul><li><p>some list functions are generic and operate on <span class="emph">any</span> kind
of list: e.g., the length of a list is the same irrespective of what
kind of values it contains;</p></li><li><p>some are specific at least to the type of data: e.g., the sum
assumes that all the values are numbers (though they may be ages or
prices or other information represented by numbers); and</p></li><li><p>some are somewhere in-between: e.g., a maximum function applies
to any list of comparable values, such as numbers or strings.</p></li></ul><p>This seems like a great variety, and we might worry about how we can
handle this many different kinds of functions. Fortunately, and
perhaps surprisingly, there is one standard way in which we can think
about writing <span class="emph">all</span> these functions! Understanding
and internalizing this process is the goal of this chapter.</p><section class="SsectionLevel4" id="section 5.2.1"><h4 class="heading">5.2.1<span class="stt">Â </span><a name="(part._.Making_.Lists_and_.Taking_.Them_.Apart)"/>Making Lists and Taking Them Apart<span class="button-group"><a href="#(part._.Making_.Lists_and_.Taking_.Them_.Apart)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>So far weâ€™ve seen one way to make a list: by writing
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: â€¦]</code></span>. While useful, writing lists this way actually
hides their true nature. Every list actually has two parts: a
<span class="emph">first</span> element and the <span class="emph">rest</span> of the list. The rest of the
list is itself a list, so it too has two partsâ€¦and so on.</p><p/><div class="SIntrapara">Consider the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code></span>. Its first element is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>, and
the rest of it is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 2, 3]</code></span>. For this second list, the first element
is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span> and the rest is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3]</code></span>.
</div><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Take apart this third list.</p></blockquote></blockquote></div><div class="SIntrapara">For the third list, the first element is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> and the rest is
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ]</code></span>, i.e., the empty list. In Pyret, we have another way
of writing the empty list: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>.</div><p>Lists are an instance of <span style="font-style: italic">structured data</span>: data with component
parts and a well-defined format for the shape of the parts. Lists are
formatted by the first element and the rest of the elements. Tables
are somewhat structured: they are formatted by rows and columns, but
the column names arenâ€™t consistent across all tables.  Structured data
is valuable in programming because a predictable format (the
structure) lets us write programs based on that structure. What do we
mean by that?</p><p/><div class="SIntrapara">Programming languages can (and do!) provide built-in operators for
taking apart structured data. These operators are called
<span style="font-style: italic">accessors</span>. Accessors are defined on the structure of the
datatype alone, independent of the contents of the data. In the case
of lists, there are two accessors: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span>. We use an accessor by writing an expression, followed by
a dot (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.</code></span>), followed by the accessorâ€™s name. As we saw with
tables, the dot means "dig into". Thus:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l1 = [list: 1, 2, 3]
e1 = l1.first
l2 = l1.rest
e2 = l2.first
l3 = l2.rest
e3 = l3.first
l4 = l3.rest

check:
  e1 is 1
  e2 is 2
  e3 is 3
  l2 is [list: 2, 3]
  l3 is [list: 3]
  l4 is empty
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What are the accessors for tables?</p></blockquote></blockquote><p>Accessors give a way to take data apart based on their structure
(there is another way that we will see shortly). Is there a way to
also <span class="emph">build</span> data based on its structure? So far, we have been
building lists using the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ...]</code></span> form, but that doesnâ€™t
emphasize the structural constraint that the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> is itself a
list. A structured operator for building lists would clearly show both
a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> element and a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> that is itself a
list. Operators for building structured data are called
<span style="font-style: italic">constructors</span>.</p><p>The constructor for lists is called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>. It takes two
arguments: a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> element, and the list to build on (the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> part). Hereâ€™s an example of using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> to create a
three-element list.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link(1, link(2, link(3, empty)))</code></pre></div></div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> form creates the same underlying list datum as our
previous <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ...]</code></span> operation, as confirmed by the following
check:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  [list: 1, 2, 3] is link(1, link(2, link(3, empty)))
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Look at these two forms of writing lists: what differences do you notice?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> form to write a four-element list of fruits containing
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"lychee"</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"dates"</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"mango"</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"durian"</code></span>.</p></blockquote></blockquote><p>After doing this exercise, you might wonder why anyone would use the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> form: itâ€™s more verbose, and makes the individual elements
harder to discern. This form is not very convenient to
humans. But it will prove very valuable to programs!</p><p/><div class="SIntrapara">In particular, the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> form highlights that we really have
<span class="emph">two different structures of lists</span>.
Some lists are empty. All other lists are <span style="font-style: italic">non-empty</span>
lists, meaning they have <span class="emph">at least one</span> <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>. There may be
more interesting structure to some lists (as we will see later), but all lists have this much
in common. Specifically, a list is either
</div><div class="SIntrapara"><ul><li><p>empty (written <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ]</code></span>), or</p></li><li><p>non-empty (written <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link(â€¦, â€¦)</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ]</code></span> with
at least one value inside the brackets), where <span class="emph">the rest is also
a list</span> (and hence may in turn be empty or non-empty, â€¦).</p></li></ul></div><p/><div class="SIntrapara">This means we actually have two structural features of lists, both of
which are important when writing programs over lists:
</div><div class="SIntrapara"><ol><li><p>Lists can be empty or non-empty</p></li><li><p>Non-empty lists have a first element and a rest of the list</p></li></ol></div><div class="SIntrapara">Letâ€™s leverage these two structural features to write some programs to
process lists!</div></section><section class="SsectionLevel4" id="section 5.2.2"><h4 class="heading">5.2.2<span class="stt">Â </span><a name="(part._my-len)"/>Some Example Exercises<span class="button-group"><a href="#(part._my-len)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>To illustrate our thinking, letâ€™s work through a few concrete examples
of list-processing functions. All of these will consume lists; some
will even produce them. Some will transform their inputs (like
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>), some will select from their inputs (like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>),
and some will aggregate their inputs. Since some of these functions already exist in
Pyret, weâ€™ll name them with the prefix <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-</code></span> to avoid
errors.<span class="refelem"><span class="refcolumn"><span class="refcontent">Be sure to use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-</code></span> name consistently,
including inside the body of the function.</span></span></span> As we will see, there is a
standard strategy that we can use to approach writing all of these
functions: having you learn this strategy is the goal of this chapter.</p></section><section class="SsectionLevel4" id="section 5.2.3"><h4 class="heading">5.2.3<span class="stt">Â </span><a name="(part._.Structural_.Problems_with_.Scalar_.Answers)"/>Structural Problems with Scalar Answers<span class="button-group"><a href="#(part._.Structural_.Problems_with_.Scalar_.Answers)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Letâ€™s write out examples for a few of the functions described
above. Weâ€™ll approach writing examples in a very specific, stylized
way. First of all, we should always construct at least two examples:
one with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> and the other with at least one <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>, so
that weâ€™ve covered the two very broad kinds of lists. Then, we should
have more examples specific to the kind of list stated in the
problem. Finally, we should have even more examples to illustrate how
we think about solving the problem.</p><section class="SsectionLevel5" id="section 5.2.3.1"><h5 class="heading">5.2.3.1<span class="stt">Â </span><a name="(part._len-eg)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>: Examples<span class="button-group"><a href="#(part._len-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>We haveâ€™t precisely defined what it means to be â€œthe lengthâ€ of a
list. We confront this right away when trying to write an
example. What is the length of the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you think?</p></blockquote></blockquote><p/><div class="SIntrapara">Two common examples are <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>. The latter, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>,
certainly looks reasonable. However, if you write the list as
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ]</code></span>, now it doesnâ€™t look so right: this is clearly (as the
name <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> also suggests) an <span class="emph">empty</span> list, and an empty
list has <span class="emph">zero</span> elements in it. Therefore, itâ€™s conventional to
declare that
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len(empty) is 0</code></pre></div></div></div><div class="SIntrapara">How about a list like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7]</code></span>? Well, itâ€™s clearly got one
element (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span>) in it, so
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7]) is 1</code></pre></div></div></div><div class="SIntrapara">Similarly, for a list like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code></span>, we would say
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3</code></pre></div></div></div><p/><div class="SIntrapara">Now letâ€™s look at that last example in a different light. Consider
the argument <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code></span>. Its first element is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span> and
the rest of it is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 8, 9]</code></span>. Well, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span> is a number, not
a list; but <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 8, 9]</code></span> certainly is a list, so we can ask for
<span class="emph">its</span> length. What is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 8, 9])</code></span>? It has two
elements, so
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 8, 9]) is 2</code></pre></div></div></div><div class="SIntrapara">The first element of <span class="emph">that</span> list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">8</code></span> while its rest is
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 9]</code></span>. What is its length?
Note that we asked a very similar question before, for the length of
the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7]</code></span>. But <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7]</code></span> is not a
<span style="font-style: italic">sub-list</span> of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code></span>, which we started with,
whereas <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 9]</code></span> is. And using the same reasoning as before,
we can say
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 9]) is 1</code></pre></div></div></div><div class="SIntrapara">The rest of this last list is, of course, the empty list, whose length
we have already decided is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>.</div><p/><div class="SIntrapara">Putting together these examples, and writing out <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> in its
other form, hereâ€™s what we get:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3
my-len([list:    8, 9]) is 2
my-len([list:       9]) is 1
my-len([list:        ]) is 0</code></pre></div></div></div><div class="SIntrapara">Another way we can write this (paying attention to the right side) is
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + 2
my-len([list:    8, 9]) is 1 + 1
my-len([list:       9]) is 1 + 0
my-len([list:        ]) is     0</code></pre></div></div></div><div class="SIntrapara">Where did the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span> on the right sides of
each <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span> operation come from? Those are the lengths of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> component of the input list. In the previous example
block, we wrote those lengths as explicit examples. Letâ€™s substitute
the numbers <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span> with the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>
expressions that produce them:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list:    8, 9]) is 1 + my-len([list:    9])
my-len([list:       9]) is 1 + my-len([list:     ])
my-len([list:        ]) is 0</code></pre></div></div></div><div class="SIntrapara">From this, maybe you can start to see a pattern. For an empty list,
the length is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>. For a non-empty list, itâ€™s the sum of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>
(the first elementâ€™s â€œcontributionâ€ to the listâ€™s length) to the
length of the rest of the list. In other words, we can use the result
of computing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span> on the rest of the list to compute the
answer for the entire list.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Each of our examples in this section has written a different check on
the expression <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9])</code></span>. Here are those examples
presented together, along with one last one that explicitly uses the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> operation:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3
my-len([list: 7, 8, 9]) is 1 + 2
my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)</code></pre></div></div></div><div class="SIntrapara">Check that you agree with each of these assertions. Also check whether
you understand how the right-hand side of each <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> expression
derives from the right-hand-side just above it. The goal of this
exercise is to make sure that you believe that the last check (which
we will turn into code) is equivalent to the first (which we wrote
down when understanding the problem).</div></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.2.3.2"><h5 class="heading">5.2.3.2<span class="stt">Â </span><a name="(part._sum-eg)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum</code></span>: Examples<span class="button-group"><a href="#(part._sum-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Letâ€™s repeat this process of developing examples on a second function,
this time one that computes the sum of the elements in a list of numbers.
What is the
sum of the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code></span>? Just adding up the numbers by hand,
the result should be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">24</code></span>. Letâ€™s see how that works out through
the examples.</p><p/><div class="SIntrapara">Setting aside the empty list for a moment, here are examples that show
the sum computations:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum([list: 7, 8, 9]) is 7 + 8 + 9
my-sum([list:    8, 9]) is     8 + 9
my-sum([list:       9]) is         9</code></pre></div></div></div><div class="SIntrapara">which (by substitution) is the same as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum([list: 7, 8, 9]) is 7 + my-sum([list: 8, 9])
my-sum([list:    8, 9]) is 8 + my-sum([list:    9])
my-sum([list:       9]) is 9 + my-sum([list:     ])</code></pre></div></div></div><div class="SIntrapara">From this, we can see that the sum of the empty list must be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>:<span class="refelem"><span class="refcolumn"><span class="refcontent">Zero is called the <span style="font-style: italic">additive identity</span>: a
fancy way of saying, adding zero to any number <span style="font-style: italic">N</span> gives you
<span style="font-style: italic">N</span>. Therefore, it makes sense that it would be the length of the
empty list, because the empty list has no items to contribute to a
sum. Can you figure out what the <span style="font-style: italic">multiplicative identity</span> is?</span></span></span>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum(empty) is 0</code></pre></div></div></div><p>Observe, again, how we can use the result of computing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum</code></span>
of the rest of the list to compute its result for the whole list.</p></section><section class="SsectionLevel5" id="section 5.2.3.3"><h5 class="heading">5.2.3.3<span class="stt">Â </span><a name="(part._.From_.Examples_to_.Code)"/>From Examples to Code<span class="button-group"><a href="#(part._.From_.Examples_to_.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Having developed these examples, we now want to use them to develop a
program that can compute the length or the sum of <span class="emph">any</span> list, not
just the specific ones we used in these examples. As we have done up
in earlier chapters, we will leverage patterns in the examples to
figure out how to define the general-purpose function.</p><p/><div class="SIntrapara">Here is one last version of the examples for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>, this time
making the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> explicit on the right-hand sides of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)
my-len([list:        ]) is 0</code></pre></div></div></div><div class="SIntrapara">As we did when developing functions over images, letâ€™s try to identify
the common parts of these examples. We start by noticing that most of
the examples have a lot in common, except for the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ]</code></span>
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>) case. So letâ€™s separate this into two sets of examples:</div><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)


my-len([list:        ]) is 0</code></pre></div></div></div><div class="SIntrapara">With this separation (which follows one of the structural features of
lists that we mentioned earlier), a clearer pattern emerges: for a
non-empty list (called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">someList</code></span>), we compute its length via the
expression:</div><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 + my-len(someList.rest)</code></pre></div></div></div><div class="SIntrapara">In general, then, our <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span> program needs to determine whether
its input list is empty or non-empty, using this expression with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.rest</code></span> in the non-empty case. How do we indicate different code
based on the structure of the list?</div><p/><div class="SIntrapara">Pyret has a construct called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> which is used to distinguish
different forms within a structured datatype. When working with lists,
the general shape of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expression is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (List) e:
  | empty      =&gt; â€¦
  | link(f, r) =&gt; â€¦ f â€¦ r â€¦
end</code></pre></div></div></div><div class="SIntrapara">where most parts are fixed, but a few youâ€™re free to change:
</div><div class="SIntrapara"><ul><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e</code></span> is an expression whose value needs to be a list; it
could be a variable bound to a list, or some complex expression that
evaluates to a list.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> are names given to the first and rest of
the list. You can choose any names you like, though in Pyret, itâ€™s
conventional to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">Occasionally
using different names can help students recall that they can choose
how to label the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> components. This can be
particularly useful for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span>, which has a problem-specific
meaning (such as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">price</code></span> in a list of prices, and so on).</span></span></span></p></li></ul></div><div class="SIntrapara">The right-hand side of every <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;</code></span> is an expression.</div><p>Hereâ€™s how <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> works in this instance. Pyret first evaluates
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e</code></span>. It then checks that the resulting value truly is a list;
otherwise it halts with an error. If it is a list, Pyret examines what
<span class="emph">kind</span> of list it is. If itâ€™s an empty list, it runs the
expression after the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;</code></span> in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> clause. Otherwise,
the list is not empty, which means it has a first and rest; Pyret
binds <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> to the two parts, respectively, and then
evaluates the expression after the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;</code></span> in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> clause.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Try using a non-listâ€”<wbr/>e.g., a numberâ€”<wbr/>in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e</code></span> position and
see what happens!</p></blockquote></blockquote><p/><div class="SIntrapara">Now letâ€™s use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> to define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-len(l):
  cases (List) l:
    | empty      =&gt; 0
    | link(f, r) =&gt; 1 + my-len(r)
  end
end</code></pre></div></div></div><div class="SIntrapara">This follows from our examples: when the list is empty <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>
produces <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>; when it is not empty, we add one to the length of
the rest of the list (here, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>).</div><p>Note that while our most recent collection of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span> examples
explicitly said <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.rest</code></span>, when using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> we instead use
just the name <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>, which Pyret has already defined (under the
hood) to be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l.rest</code></span>.</p><p/><div class="SIntrapara">Similarly, letâ€™s define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-sum(l):
  cases (List) l:
    | empty      =&gt; 0
    | link(f, r) =&gt; f + my-sum(r)
  end
end</code></pre></div></div></div><div class="SIntrapara">Notice how similar they are in code, and how readily the structure of
the data suggest a structure for the program. This is a pattern you
will get very used to soon!</div><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Developing Functions Over Lists</p><blockquote class="StrategyBody"><p/><div class="SIntrapara">Leverage the structure of lists and the power of concrete examples to
develop list-processing functions.
</div><div class="SIntrapara"><ul><li><p>Pick a concrete list with (at least) three elements. Write a
sequence of examples for each of the entire list and each suffix of
the list (including the empty list).</p></li><li><p>Rewrite each example to express its expected
answer in terms of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> data of its input
list. You donâ€™t have to use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> operators
in the new answers, but you should see the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> <span class="emph">values</span> represented explicitly in the answer.</p></li><li><p>Look for a pattern across the answers in the examples. Use these
to develop the code: write a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expression, filling in the
right side of each <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;</code></span> based on your examples.</p></li></ul></div><div class="SIntrapara">This strategy applies to structured data in general, leveraging
components of each datum rather than specifically <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> as presented so far.</div></blockquote></blockquote></section></section><section class="SsectionLevel4" id="section 5.2.4"><h4 class="heading">5.2.4<span class="stt">Â </span><a name="(part._.Structural_.Problems_that_.Transform_.Lists)"/>Structural Problems that Transform Lists<span class="button-group"><a href="#(part._.Structural_.Problems_that_.Transform_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Now that we have a systematic way to develop functions that take lists
as input, letâ€™s apply that same strategy to functions that
<span class="emph">produce</span> a list as the answer.</p><section class="SsectionLevel5" id="section 5.2.4.1"><h5 class="heading">5.2.4.1<span class="stt">Â </span><a name="(part._doubles-eg-code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles</code></span>: Examples and Code<span class="button-group"><a href="#(part._doubles-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>As always, weâ€™ll begin with some examples. Given a list of numbers, we
want a list that doubles each number (in the order of the
original list). Hereâ€™s a reasonable example with three numbers:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is [list: 6, 10, 4]</code></pre></div></div><p>As before, letâ€™s write out the answers for each suffix of our example
list as well, including for the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> list:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list:    5, 2]) is [list:    10, 4]
my-doubles([list:       2]) is [list:        4]
my-doubles([list:        ]) is [list:         ]</code></pre></div></div><p>Now, we rewrite the answer expressions to include the concrete
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> data for each example. Letâ€™s start with
just the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> data, and just on the first example:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is [list: 3 * 2, 10, 4]
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre></div></div><p>Next, letâ€™s include the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> data (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 5, 2]</code></span>) in the
first example. The current answer in the first example is</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, 10, 4]</code></pre></div></div><p>and that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 10, 4]</code></span> is the result of using the function on
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 5, 2]</code></span>. We might therefore be tempted to replace the
right side of the first example with:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, my-doubles([list: 5, 2])]</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">What value would this expression produce? You might want to try this
example that doesnâ€™t use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles</code></span> directly:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, [list: 10, 4]]</code></pre></div></div></div></blockquote></blockquote><p>Oops! We want a single (flat) list, not a list-within-a-list. This
feels like it is on the right track in terms of reworking the answer
to use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> values, but weâ€™re clearly not
quite there yet.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">What value does the following expression produce?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link(3 * 2, [list: 10, 4])</code></pre></div></div></div></blockquote></blockquote><p>Notice the difference between the two expressions in these last two
exercises: the latter used <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> to put the value involving
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> into the conversion of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span>, while the former
tried to do this with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list:</code></span>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How many elements are in the lists that result from each of the
following expressions?</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 25, 16, 32]
[list: 25, [list: 16, 32]]
link(25, [list: 16, 32])</code></pre></div></div></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Summarize the difference between how <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list:</code></span>
combine an element and a list. Try additional examples at the
interactions prompt if needed to explore these ideas.</p></blockquote></blockquote><p>The takeaway here is that we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> to <span class="emph">insert an
element into an existing list</span>, whereas we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list:</code></span> to make a
new list that <span class="emph">contains</span> the old list as an element. Going back
to our examples, then, we include <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> in the first example by
writing it as follows:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, [list: 10, 4])
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre></div></div><p>which we then convert to</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre></div></div><p>Applying this idea across the examples, we get:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is link(5 * 2, my-doubles([list: 2]))
my-doubles([list:       2]) is link(2 * 2, my-doubles([list: ]))
my-doubles([list:        ]) is [list:             ]</code></pre></div></div><p>Now that we have examples that explicitly use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> elements, we can produce to write the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles</code></span>
function:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-doubles(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      link(f * 2, my-doubles(r))
  end
end</code></pre></div></div></section><section class="SsectionLevel5" id="section 5.2.4.2"><h5 class="heading">5.2.4.2<span class="stt">Â </span><a name="(part._str-len-eg-code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len</code></span>: Examples and Code<span class="button-group"><a href="#(part._str-len-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">In <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles</code></span>, the input and output lists have the same type of
element. Functions can also produce lists whose contents have a
different type from the input list. Letâ€™s work through an example.
Given a list of strings, we
want the lengths of each string (in the same order as in the input list). Thus, hereâ€™s a
reasonable example:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is [list: 2, 5, 6]</code></pre></div></div></div><div class="SIntrapara">As we have before, we should consider the answers for each
sub-problem of the above example:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list:       "there", "mateys"]) is [list:    5, 6]
my-str-len([list:                "mateys"]) is [list:       6]</code></pre></div></div></div><p/><div class="SIntrapara">Or, in other words:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(2, [list: 5, 6])
my-str-len([list:       "there", "mateys"]) is link(5, [list:    6])
my-str-len([list:                "mateys"]) is link(6, [list:     ])</code></pre></div></div></div><div class="SIntrapara">which tells us that the response for the empty list should be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len(empty) is empty</code></pre></div></div></div><p>The next step is to rework the answers in the examples to make the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> parts explicit. Hopefully by now you are
starting to detect a pattern: The result on the rest of the list
appears explicitly as another example. Therefore, weâ€™ll start by
getting the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> value of each example input into the answer:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(2, my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(5, my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(6, my-str-len([list:                  ]))
my-str-len([list:                        ]) is [list: ]</code></pre></div></div><p>All that remains now is to figure out how to work the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span>
values into the outputs. In the context of this problem, this means we
need to convert <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"hi"</code></span> into <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"there"</code></span> into
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">5</code></span>, and so on. From the problem statement, we know that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">5</code></span> are meant to be the lengths (character counts) of the
corresponding strings. The operation that determines the length of a
string is called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-length</code></span>. Thus, our examples appear as:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(string-length("hi"), my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(string-length("there"), my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(string-length("mateys"), my-str-len([list: ]))
my-str-len([list:                        ]) is [list: ]</code></pre></div></div><p>From here, we write a function that captures the pattern developed
across our examples:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-str-len(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      link(string-length(f), my-str-len(r))
  end
end</code></pre></div></div></section></section><section class="SsectionLevel4" id="section 5.2.5"><h4 class="heading">5.2.5<span class="stt">Â </span><a name="(part._.Structural_.Problems_that_.Select_from_.Lists)"/>Structural Problems that Select from Lists<span class="button-group"><a href="#(part._.Structural_.Problems_that_.Select_from_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In the previous section, we saw functions that <span class="emph">transform</span> list
elements (by doubling numbers or counting characters). The type of the
output list may or may not be the same as the type of the input
list. Other functions that produce lists instead <span class="emph">select</span>
elements: every element in the output list was in the input list, but
some input-list elements might not appear in the output list. This
section adapts our method of deriving functions from examples to
accommodate selection of elements.</p><section class="SsectionLevel5" id="section 5.2.5.1"><h5 class="heading">5.2.5.1<span class="stt">Â </span><a name="(part._pos-nums-eg-code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums</code></span>: Examples and Code<span class="button-group"><a href="#(part._pos-nums-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>As our first example, we will select the positive numbers from a list
that contains both positive and non-positive numbers.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Construct the sequence of examples that we obtain from the input
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, -2, 3, -4]</code></span>.</p></blockquote></blockquote><p/><div class="SIntrapara">Here we go:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is [list: 1, 3]
my-pos-nums([list:    -2, 3, -4]) is [list:    3]
my-pos-nums([list:        3, -4]) is [list:    3]
my-pos-nums([list:           -4]) is [list:     ]
my-pos-nums([list:             ]) is [list:     ]</code></pre></div></div></div><div class="SIntrapara">We can write this in the following form:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, [list: 3])
my-pos-nums([list:    -2, 3, -4]) is         [list: 3]
my-pos-nums([list:        3, -4]) is link(3, [list: ])
my-pos-nums([list:           -4]) is         [list: ]
my-pos-nums([list:             ]) is         [list: ]</code></pre></div></div></div><div class="SIntrapara">or, even more explicitly,
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])
my-pos-nums([list:             ]) is         [list: ]</code></pre></div></div></div><div class="SIntrapara">Unlike in the example sequences for functions that transform lists,
here we see that the answers have different shapes: some involve a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>, while others simply process the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> of the
list. Whenever we need different shapes of outputs across a set of
examples, we will need an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression in our code to
distinguish the conditions that yield each shape.</div><p/><div class="SIntrapara">What determines which shape of output we get? Letâ€™s rearrange the
examples (other than the empty-list input) by output shape:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))

my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])</code></pre></div></div></div><div class="SIntrapara">Re-organized, we can see that the examples that use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> have a
positive number in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> position, while the ones that
donâ€™t simply process the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> of the list. That indicates that
our <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression needs to ask whether the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> element
in the list is positive. This yields the following program:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-pos-nums(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if f &gt; 0:
        link(f, my-pos-nums(r))
      else:
        my-pos-nums(r)
      end
  end
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Is our set of examples comprehensive?</p></blockquote></blockquote><p>Not really. There are <span class="emph">many</span> examples we havenâ€™t considered, such
as lists that end with positive numbers and lists with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Work through these examples and see how they affect the program!</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.2.5.2"><h5 class="heading">5.2.5.2<span class="stt">Â </span><a name="(part._alternating-eg-code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span>:
Examples and Code<span class="button-group"><a href="#(part._alternating-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Now letâ€™s consider a problem that selects elements not by <span class="emph">value</span>, but
by <span class="emph">position</span>. We want to write a function that selects
alternating elements from a list. Once again, weâ€™re going to work from examples.
</div><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Work out the results for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span> starting from the list
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4, 5, 6]</code></span>.</p></blockquote></blockquote></div><p/><div class="SIntrapara">Hereâ€™s how they work out:
</div><div class="SIntrapara"><a name="(elem._alternating-egs-1)"/>&lt;<span style="font-style: italic">alternating-egs-1</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
  my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
  my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
  my-alternating([list:          4, 5, 6]) is [list:    4, 6]
end</code></pre></div></div></div><div class="SIntrapara">Wait, whatâ€™s that? The two answers above are each correct, but
<span class="emph">the second answer does not help us in any way construct the
first answer</span>. That means the way weâ€™ve solved these problems until
now is not enough for this new kind of problem. Itâ€™s still useful,
though: notice that thereâ€™s a connection between the first example and
the third, as well as between the second example and the fourth. This
observation is consistent with our goal of selecting alternating elements.</div><p>What would something like this look like in code? Before we try to
write the function, letâ€™s rewrite the first example in terms of the
third:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]

my-alternating([list: 1, 2, 3, 4, 5, 6]) is link(1, my-alternating([list: 3, 4, 5, 6]))</code></pre></div></div><p>Note that in the rewritten version, we are dropping <span class="emph">two</span>
elements from the list before using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span> again, not
just one. We will have to figure out how to handle that in our code.</p><p>Letâ€™s start with our usual function pattern with a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>
expression:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; [list:]
    | link(f, r) =&gt; link(f, â€¦ r â€¦)
  end
end</code></pre></div></div><p/><div class="SIntrapara">Note that we cannot simply call <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span> on <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>,
because <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> excludes only one item from the list, not two as this
problem requires. We have to break down <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> as well, in order to
get to the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> of the original list. To do
this, we use another <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expression, nested within the first
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expression:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; [list:]
    | link(f, r) =&gt;
      cases (List) r:  # note: deconstructing r, not l
        | empty =&gt; ??? # note the ???
        | link(fr, rr) =&gt;
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">This code is consistent with the example that we just worked out. But
note that we still have a bit of unfinished work to do: we need to
decide what to do in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> case of the inner <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>
expression (marked by <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">???</code></span> in the code).</div><p>A common temptation at this point is to replace the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">???</code></span> with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list:]</code></span>. After all, havenâ€™t we always returned <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list:]</code></span> in
the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> cases?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Replace <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">???</code></span> with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list:]</code></span> and test the program on our
original examples:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
my-alternating([list:          4, 5, 6]) is [list:    4, 6]</code></pre></div></div></div><div class="SIntrapara">What do you observe?</div></blockquote></blockquote><p>Oops! Weâ€™ve written a program that appears to work on lists with an
even number of elements, but not on lists with an odd number of
elements. How did that happen? The only part of this code that we
guessed at was how to fill in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> case of the inner
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>, so the issue must be there. Rather than focus on the
code, however, <span class="emph">focus on the examples</span>. We need a simple example
that would land on that part of the code. We get to that spot when the
list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l</code></span> is not empty, but <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> (the rest of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l</code></span>) is
empty. In other words, we need an example with only one element.</p><p/><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Finish the following example:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 5]) is ???</code></pre></div></div></div></blockquote></blockquote></div><div class="SIntrapara">Given a list with one element, that element should be included in a
list of alternating elements. Thus, we should finish this example as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 5]) is [list: 5]</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use this example to update the result of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span> when
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> in our code.</p></blockquote></blockquote><p/><div class="SIntrapara">Leveraging this new example, the final version of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span> is as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      cases (List) r: # note: deconstructing r, not l
        | empty =&gt;    # the list has an odd number of elements
          [list: f]
        | link(fr, rr) =&gt;
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end</code></pre></div></div></div><p/><div class="SIntrapara">Whatâ€™s the takeaway from this problem? There are two:
</div><div class="SIntrapara"><ul><li><p>Donâ€™t skip the small examples: the result of a list-processing
function on the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> case wonâ€™t always be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>.</p></li><li><p>If a problem asks you to work with multiple elements from the
front of a list, you can nest <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expressions to access later
elements.</p></li></ul></div><div class="SIntrapara">These takeaways will matter again in future examples: keep an eye out
for them!</div></section></section><section class="SsectionLevel4" id="section 5.2.6"><h4 class="heading">5.2.6<span class="stt">Â </span><a name="(part._struct-prob-sub-dom)"/>Structural Problems Over Relaxed Domains<span class="button-group"><a href="#(part._struct-prob-sub-dom)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><section class="SsectionLevel5" id="section 5.2.6.1"><h5 class="heading">5.2.6.1<span class="stt">Â </span><a name="(part._my-max)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>: Examples<span class="button-group"><a href="#(part._my-max)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Now letâ€™s find the maximum value of a list. Letâ€™s assume for
simplicity that weâ€™re dealing with just lists of numbers. What kinds
of lists should we construct? Clearly, we should have empty and
non-empty listsâ€¦but what else? Is a list like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code></span> a
good example? Well, thereâ€™s nothing wrong with it, but we should also
consider lists where the maximum is at the beginning rather than at the
end; the maximum might be in the middle; the maximum might be
repeated; the maximum might be negative; and so on. While not
comprehensive, here is a small but interesting set of examples:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 1, 2, 3]) is 3
my-max([list: 3, 2, 1]) is 3
my-max([list: 2, 3, 1]) is 3
my-max([list: 2, 3, 1, 3, 2]) is 3
my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list: -2, -1, -3]) is -1</code></pre></div></div></div><div class="SIntrapara">What about <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max(empty)</code></span>?
</div><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Could we define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max(empty)</code></span> to be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>? Returning
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span> for the empty list has worked well twice already!</p></blockquote></blockquote></div><div class="SIntrapara">Weâ€™ll return to this in a while.</div><p/><div class="SIntrapara">Before we proceed, itâ€™s useful to know that thereâ€™s a function called
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max</code></span> already defined in Pyret, that compares two numbers:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max(1, 2) is 2
num-max(-1, -2) is -1</code></pre></div></div></div><div class="SIntrapara"><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Suppose <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max</code></span> were not already built in. Can you define it?
You will find what you learned about <a href="Conditionals_and_Booleans.html#%28part._booleans%29" data-pltdoc="x">Booleans</a>
handy. Remember to write some tests!</p></blockquote></blockquote></div><p/><div class="SIntrapara">Now we can look at <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span> at work:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 1, 2, 3]) is 3
my-max([list:    2, 3]) is 3
my-max([list:       3]) is 3</code></pre></div></div></div><div class="SIntrapara">Hmm. That didnâ€™t really teach us anything, did it? Maybe, we canâ€™t be
sure. And we still donâ€™t know what to do with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>.</div><p/><div class="SIntrapara">Letâ€™s try the second example input:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 3, 2, 1]) is 3
my-max([list:    2, 1]) is 2
my-max([list:       1]) is 1</code></pre></div></div></div><div class="SIntrapara">This is actually telling us something useful as well, but maybe we
canâ€™t see it yet. Letâ€™s take on something more ambitious:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list:    1, 4, 3, 2]) is 4
my-max([list:       4, 3, 2]) is 4
my-max([list:          3, 2]) is 3
my-max([list:             2]) is 2</code></pre></div></div></div><div class="SIntrapara">Observe how the maximum of the rest of the list gives us a candidate
answer, but comparing it to the first element gives us a definitive
one:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is num-max(2, 4)
my-max([list:    1, 4, 3, 2]) is num-max(1, 4)
my-max([list:       4, 3, 2]) is num-max(4, 3)
my-max([list:          3, 2]) is num-max(3, 2)
my-max([list:             2]) is â€¦</code></pre></div></div></div><div class="SIntrapara">The last one is a little awkward: weâ€™d like to write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list:             2]) is num-max(2, â€¦)</code></pre></div></div></div><div class="SIntrapara">but we donâ€™t really know what the maximum (or minimum, or any other
element) of the <span class="emph">empty</span> list is, but we can only provide numbers
to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max</code></span>. Therefore, leaving out that dodgy case, weâ€™re left
with
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is num-max(2, my-max([list: 1, 4, 3, 2]))
my-max([list:    1, 4, 3, 2]) is num-max(1, my-max([list:    4, 3, 2]))
my-max([list:       4, 3, 2]) is num-max(4, my-max([list:       3, 2]))
my-max([list:          3, 2]) is num-max(3, my-max([list:          2]))</code></pre></div></div></div><div class="SIntrapara">Our examples have again helped: theyâ€™ve revealed how we can use the
answer for each rest of the list to compute the answer for the whole
list, which in turn is the rest of some other list, and so on. If you
go back and look at the other example lists we wrote above, youâ€™ll see
the pattern holds there too.</div><p/><div class="SIntrapara">However, itâ€™s time we now confront the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> case. The real
problem is that we donâ€™t have a maximum for the empty list: for any
number we might provide, there is always a number bigger than it
(assuming our computer is large enough) that could have been the
answer instead. In short, itâ€™s nonsensical to ask for the maximum (or
minimum) of the empty list: the concept of â€œmaximumâ€ is only defined
on non-empty lists! That is, when asked for the maximum of an empty
list, we should signal an error:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max(empty) raises ""</code></pre></div></div></div><div class="SIntrapara">(which is how, in Pyret, we say that it will generate an error; we
donâ€™t care about the details of the error, hence the empty string).</div></section><section class="SsectionLevel5" id="section 5.2.6.2"><h5 class="heading">5.2.6.2<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>: From Examples to Code<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Once again, we can codify the examples above, i.e., turn them into a
uniform program that works for all instances. However, we now have a
twist. If we blindly followed the pattern weâ€™ve used earlier, we would
end up with:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt; num-max(f, my-max(r))
  end
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Whatâ€™s wrong with this?</p></blockquote></blockquote><p/><div class="SIntrapara">Consider the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 2]</code></span>. This turns into
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max(2, my-max([list: ]))</code></pre></div></div></div><div class="SIntrapara">which of course raises an error. Therefore, this function never works
for any list that has one or more elements!</div><p/><div class="SIntrapara">Thatâ€™s because we need to make sure we arenâ€™t trying to compute the
maximum of the empty list.
Going back to our examples, we see that what we need to do, before
calling <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>, is check whether the rest of the list is
empty. If it is, we do not want to call <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span> at all. That is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; â€¦
        | â€¦
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">Weâ€™ll return to what to do when the rest is not empty in a moment.</div><p/><div class="SIntrapara">If the rest of the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l</code></span> is empty, our examples above tell us
that the maximum is the first element in the list. Therefore, we can
fill this in:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; f
        | â€¦
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">Note in particular the absence of a call to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>. If the list
is not empty, however, our examples above tell us that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>
will give us the maximum of the rest of the list, and we just need to
compare this answer with the first element (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span>):
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; f
        | else  =&gt; num-max(f, my-max(r))
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">And sure enough, this definition does the job!</div></section></section><section class="SsectionLevel4" id="section 5.2.7"><h4 class="heading">5.2.7<span class="stt">Â </span><a name="(part._.More_.Structural_.Problems_with_.Scalar_.Answers)"/>More Structural Problems with Scalar Answers<span class="button-group"><a href="#(part._.More_.Structural_.Problems_with_.Scalar_.Answers)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><section class="SsectionLevel5" id="section 5.2.7.1"><h5 class="heading">5.2.7.1<span class="stt">Â </span><a name="(part._avg-eg)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-avg</code></span>: Examples<span class="button-group"><a href="#(part._avg-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Letâ€™s now try to compute the average of a list of numbers. Letâ€™s start
with the example list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4]</code></span> and work out more
examples from it. The average of numbers in this list is clearly
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(1 + 2 + 3 + 4)/4</code></span>, or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">10/4</code></span>.</p><p/><div class="SIntrapara">Based on the listâ€™s structure, we see that the rest of the list is
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 2, 3, 4]</code></span>, and the rest of that is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3, 4]</code></span>,
and so on. The resulting averages are:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-avg([list: 1, 2, 3, 4]) is 10/4
my-avg([list:    2, 3, 4]) is 9/3
my-avg([list:       3, 4]) is 7/2
my-avg([list:          4]) is 4/1</code></pre></div></div></div><div class="SIntrapara">The problem is, itâ€™s simply not clear how we get from the answer for
the sub-list to the answer for the whole list. That is, given the
following two bits of information:
</div><div class="SIntrapara"><ul><li><p>The average of the remainder of the list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">9/3</code></span>, i.e.,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>.</p></li><li><p>The first number in the list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>.</p></li></ul></div><div class="SIntrapara">How do we determine that the average of the whole list must be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">10/4</code></span>? If itâ€™s not clear to you, donâ€™t worry: with just those
two pieces of information, itâ€™s <span class="emph">impossible</span>!</div><p/><div class="SIntrapara">Hereâ€™s a simpler example that explains why. Letâ€™s suppose the first
value in a list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>, and the average of the rest of the list
is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>. Here are two very different lists that fit this
description:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2]    # the rest has one element with sum 2
[list: 1, 4, 0] # the rest has two elements with sum 4</code></pre></div></div></div><div class="SIntrapara">The average of the entire first list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3/2</code></span>, while the average
of the entire second list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">5/3</code></span>, and the two are not the same.</div><p>That is, to compute the average of a whole list, itâ€™s not even useful to
know the <span class="emph">average</span> of the rest of the list. Rather, we need to
know the <span class="emph">sum</span> and the <span class="emph">length</span> of the rest of the
list. With these two, we can add the first to the sum, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> to
the length, and compute the new average.</p><p/><div class="SIntrapara">In principle, we could try to make a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">average</code></span> function that
returns all this information. Instead, it will be a lot simpler to
simply <span style="font-style: italic">decompose</span> the task into two smaller tasks. After all, we
have already seen how to compute the length and how to compute the
sum. The average, therefore, can just use these existing functions:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-avg(l):
  my-sum(l) / my-len(l)
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What should be the average of the empty list? Does the above code
produce what you would expect?</p></blockquote></blockquote><p>Just as we argued earlier about the maximum
[<a href="#%28part._struct-prob-sub-dom%29" data-pltdoc="x">Structural Problems Over Relaxed Domains</a>], the average of the empty list isnâ€™t
a well-defined concept. Therefore, it would be appropriate to signal
an error. The implementation above does this, but poorly: it reports
an error on division. A better programming practice would be to
catch this situation and report the error right away, rather than
hoping some other function will report the error.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Alter <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-avg</code></span> above to signal an error when given the empty
list.</p></blockquote></blockquote><p>Therefore, we see that the process weâ€™ve usedâ€”<wbr/>of inferring code from
examplesâ€”<wbr/>wonâ€™t always suffice, and weâ€™ll need more
sophisticated techniques to solve some problems. However, notice that
working from examples helps us quickly <span class="emph">identify</span> situations
where this approach does and doesnâ€™t work. Furthermore, if you look
more closely youâ€™ll notice that the examples above <span class="emph">do</span> hint at
how to solve the problem: in our very first examples, we wrote answers
like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">10/4</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">9/3</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7/2</code></span>, which correspond to the
sum of the numbers divided by the length. Thus, writing the answers in
this form (as opposed, for instance, to writing the second of those as
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>) already reveals a structure for a solution.</p></section></section><section class="SsectionLevel4" id="section 5.2.8"><h4 class="heading">5.2.8<span class="stt">Â </span><a name="(part._accumulators)"/>Structural Problems with Accumulators<span class="button-group"><a href="#(part._accumulators)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><section class="SsectionLevel5" id="section 5.2.8.1"><h5 class="heading">5.2.8.1<span class="stt">Â </span><a name="(part._running-sum-1st-attempt)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>: First Attempt<span class="button-group"><a href="#(part._running-sum-1st-attempt)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>One more time, weâ€™ll begin with an example.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Work out the results for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span> starting from the list
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4, 5]</code></span>.</p></blockquote></blockquote><p/><div class="SIntrapara">Hereâ€™s what our first few examples look like:
</div><div class="SIntrapara"><a name="(elem._running-sum-egs-1)"/>&lt;<span style="font-style: italic">running-sum-egs-1</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
  my-running-sum([list:    2, 3, 4, 5]) is [list: 2, 5, 9, 14]
  my-running-sum([list:       3, 4, 5]) is [list: 3, 7, 12]
end</code></pre></div></div></div><div class="SIntrapara">Again, there doesnâ€™t appear to be any clear connection between the
result on the rest of the list and the result on the entire list.</div><p/><div class="SIntrapara">(That isnâ€™t strictly true: we can still line up the answers as
follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
my-running-sum([list:    2, 3, 4, 5]) is [list:    2, 5,  9, 14]
my-running-sum([list:       3, 4, 5]) is [list:       3,  7, 12]</code></pre></div></div></div><div class="SIntrapara">and observe that weâ€™re computing the answer for the rest of the list,
then adding the first element to each element in the answer, and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>ing the first element to the front. In principle, we can
compute this solution directly, but for
now that may be more work than finding a simpler way to answer it.)</div></section><section class="SsectionLevel5" id="section 5.2.8.2"><h5 class="heading">5.2.8.2<span class="stt">Â </span><a name="(part._running-sum-eg-code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>: Examples and Code<span class="button-group"><a href="#(part._running-sum-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Recall how we began in <a href="#%28part._running-sum-1st-attempt%29" data-pltdoc="x"><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>: First Attempt</a>. Our
examples [<a href="#%28elem._running-sum-egs-1%29" data-pltdoc="x">&lt;<span style="font-style: italic">running-sum-egs-1</span>&gt;</a>] showed the following
problem. When we process the rest of the list, we have forgotten
everything about what preceded it. That is, when processing the list
starting at <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span> we forget that weâ€™ve seen a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> earlier;
when starting from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>, we forget that weâ€™ve seen both <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span> earlier; and so on. In other words, we keep
<span class="emph">forgetting</span> the past. We need some way of avoiding that.</p><p/><div class="SIntrapara">The easiest thing we can do is simply change our function to carry
along this â€œmemoryâ€, or what weâ€™ll call an <span style="font-style: italic">accumulator</span>. That
is, imagine we were defining a new function, called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs</code></span>. It
will consume a list of numbers and produce a list of numbers, but in
addition it will <span class="emph">also take the sum of numbers preceding the
current list</span>.
</div><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What should the initial sum be?</p></blockquote></blockquote></div><div class="SIntrapara">Initially there is no â€œpreceding listâ€, so we will use the additive
identity: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>. The type of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs</code></span> is
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs :: Number, List&lt;Number&gt; -&gt; List&lt;Number&gt;</code></pre></div></div></div><p/><div class="SIntrapara">Letâ€™s now re-work our examples from <a href="#%28elem._running-sum-egs-1%29" data-pltdoc="x">&lt;<span style="font-style: italic">running-sum-egs-1</span>&gt;</a> as
examples of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs</code></span> instead. The examples use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span>
operator to append two lists into one (the elements of the first list
followed by the elements of the second):
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs( 0, [list: 1, 2, 3, 4, 5]) is [list:  0 + 1] + my-rs( 0 + 1, [list: 2, 3, 4, 5])
my-rs( 1, [list:    2, 3, 4, 5]) is [list:  1 + 2] + my-rs( 1 + 2, [list:    3, 4, 5])
my-rs( 3, [list:       3, 4, 5]) is [list:  3 + 3] + my-rs( 3 + 3, [list:       4, 5])
my-rs( 6, [list:          4, 5]) is [list:  6 + 4] + my-rs( 6 + 4, [list:          5])
my-rs(10, [list:             5]) is [list: 10 + 5] + my-rs(10 + 5, [list:           ])
my-rs(15, [list:              ]) is empty</code></pre></div></div></div><div class="SIntrapara">That is, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs</code></span> translates into the following code:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-rs(acc, l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      new-sum = acc + f
      link(new-sum, my-rs(new-sum, r))
  end
end</code></pre></div></div></div><div class="SIntrapara">All thatâ€™s then left is to call it from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-running-sum(l):
  my-rs(0, l)
end</code></pre></div></div></div><p>Observe that we do not change <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span> itself to take
extra arguments. The correctness of our code depends on the initial
value of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acc</code></span> being 0. If we added a parameter for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acc</code></span>,
any code that calls <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span> could supply an unexpected
value, which would distort the result. In addition, since the value is
fixed, adding the parameter would amount to shifting additional (and
needless) work onto others who use our code.</p></section><section class="SsectionLevel5" id="section 5.2.8.3"><h5 class="heading">5.2.8.3<span class="stt">Â </span><a name="(part._alternating-accumulator)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span>: Examples and Code<span class="button-group"><a href="#(part._alternating-accumulator)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Recall our examples in <a href="#%28part._alternating-eg-code%29" data-pltdoc="x"><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span>:
Examples and Code</a>. There, we
noticed that the code built on every-other example. We might have
chosen our examples differently, so that from one example to the next
we skipped two elements rather than one.
Here we will see another way to think about the same problem.</p><p/><div class="SIntrapara">Return to the examples weâ€™ve already seen
[<a href="#%28elem._alternating-egs-1%29" data-pltdoc="x">&lt;<span style="font-style: italic">alternating-egs-1</span>&gt;</a>]. We wrote <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span>
to traverse the list essentially two elements at a time. Another option is to traverse it just one
element at a time, but <span class="emph">keeping track of whether weâ€™re at an odd
or even element</span>â€”<wbr/>i.e., add â€œmemoryâ€ to our program. Since we just
need to track that one piece of information, we can use a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Boolean</code></span> to do it. Letâ€™s define a new function for this purpose:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alt :: List&lt;Any&gt;, Boolean -&gt; List&lt;Any&gt;</code></pre></div></div></div><div class="SIntrapara">The extra argument accumulates whether weâ€™re at an element to keep or
one to discard.</div><p/><div class="SIntrapara">We can reuse the existing template for list functions. When we have an
element, we have to consult the accumulator whether to keep it or
not. If its value is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> we <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> it to the answer;
otherwise we ignore it. As we process the rest of the list, however,
we have to remember to update the accumulator: if we kept an element
we donâ€™t wish to keep the next one, and vice versa.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alt(l, keep):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if keep:
        link(f, my-alt(r, false))
      else:
        my-alt(r, true)
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">Finally, we have to determine the initial value of the accumulator. In
this case, since we want to keep alternating elements <span class="emph">starting
with the first one</span>, its initial value should be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  my-alt(l, true)
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span> using an accumulator. What does the accumulator
represent? Do you encounter any difficulty?</p></blockquote></blockquote></section></section><section class="SsectionLevel4" id="section 5.2.9"><h4 class="heading">5.2.9<span class="stt">Â </span><a name="(part._.Dealing_with_.Multiple_.Answers)"/>Dealing with Multiple Answers<span class="button-group"><a href="#(part._.Dealing_with_.Multiple_.Answers)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Our discussion above has assumed there is only one answer for a given
input. This is often true, but it also depends on how the problem is
worded and how we choose to generate examples. We will study this in
some detail now.</p><section class="SsectionLevel5" id="section 5.2.9.1"><h5 class="heading">5.2.9.1<span class="stt">Â </span><a name="(part._uniq)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Problem Setup<span class="button-group"><a href="#(part._uniq)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Consider the task of writing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>:<span class="refelem"><span class="refcolumn"><span class="refcontent"><span class="stt">uniq</span> is the
name of a Unix utility with similar behavior; hence the spelling of
the name.</span></span></span> given a list of values, it produces a collection of the
same elements while avoiding any duplicates (hence <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>, short
for â€œuniqueâ€).</p><p>Consider the following input: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 1, 3, 1, 2, 4, 1]</code></span>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What is the sequence of examples this input generates?  Itâ€™s
<span class="emph">really important</span> you stop and try to do this by hand. As we
will see there are multiple solutions, and itâ€™s useful for you to
consider what you generate. Even if you canâ€™t generate a sequence,
trying to do so will better prepare you for what you read next.</p></blockquote></blockquote><p>How did you obtain your example? If you just â€œthought about it for a
moment and wrote something downâ€, you may or may not have gotten
something you can turn into a program. Programs can only proceed
systematically; they canâ€™t â€œthinkâ€. So, hopefully you took a
well-defined path to computing the answer.</p></section><section class="SsectionLevel5" id="section 5.2.9.2"><h5 class="heading">5.2.9.2<span class="stt">Â </span><a name="(part._uniq-eg)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Examples<span class="button-group"><a href="#(part._uniq-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>It turns out there are <span class="emph">several</span> possible answers, because we
have (intentionally) left the problem unspecified. Suppose there are
two instances of a value in the list; which one do we keep, the first
or the second? On the one hand, since the two instances must be
equivalent it doesnâ€™t matter, but it does for writing concrete
examples and deriving a solution.</p><p/><div class="SIntrapara">For instance, you might have generated this sequence:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">examples:
  uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:    2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:       1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:          3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:             1, 2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                   4, 1]) is [list:       4, 1]
  uniq([list:                      1]) is [list:          1]
  uniq([list:                       ]) is [list:           ]
end</code></pre></div></div></div><div class="SIntrapara">However, you might have also generated sequences that began with
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 1, 2, 3, 4]</code></pre></div></div></div><div class="SIntrapara">or
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 4, 3, 2, 1]</code></pre></div></div></div><div class="SIntrapara">and so on. Letâ€™s work with the examples weâ€™ve worked out above.</div></section><section class="SsectionLevel5" id="section 5.2.9.3"><h5 class="heading">5.2.9.3<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Code<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>What is the <span class="emph">systematic</span> approach that gets us to this answer?
When given a non-empty list, we split it into its first element and
the rest of the list. Suppose we have the answer to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>
applied to the rest of the list. Now we can ask: is the first element
in the rest of the list? If it is, then we can ignore it, since it is
certain to be in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> of the rest of the list. If, however,
it is not in the rest of the list, itâ€™s critical that we <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>
it to the answer.</p><p>This translates into the following program. For the empty list, we
return the empty list. If the list is non-empty, we check whether the
first is in the rest of the list. If it is <span class="emph">not</span>, we include it;
otherwise we can ignore it for now.</p><p/><div class="SIntrapara">This results in the following program:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if r.member(f):
        uniq-rec(r)
      else:
        link(f, uniq-rec(r))
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">which weâ€™ve called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq-rec</code></span> instead of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> to
differentiate it from other versions of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Note that weâ€™re using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.member</code></span> to check whether an element is a
member of the list. Write a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member</code></span> that consumes an
element and a list, and tells us whether the element is a member of
the list.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Uniqueness checking has many practical applications. For example, one
might have a list of names of people who have registered to vote in an
election. To keep the voting fair, with only one vote allowed per
person, we should remove duplicate names from the list.</p><ol><li><p>Propose a set of examples for a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rem-duplicate-voters</code></span>
that takes a list of voter names and returns a list in which duplicate
registrations have been removed. In developing your examples, consider
real-world scenarios that you can imagine arising when identifying
duplicate names. Can you identify cases in which two names
might appear to be the same person, but not be? Cases in which two
names might appear different but be referring to the same person?</p></li><li><p>What might you need to change about our current <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq-rec</code></span>
function to handle a situation like removing duplicate voters?</p></li></ol></blockquote></blockquote><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Context Matters When Comparing Values</p><blockquote class="RespCSBody"><p>The data de-duplication context in the above exercise reminds us that
different contexts may call for different notions of when two data values
are the same. Sometimes, we want exact matching to determine that two
strings are equal. Sometimes, we need methods that normalize data,
either in simple ways like capitalization or subtler ways based on
middle initials. Sometimes, we need more information (like street
addresses in addition to names) in order to determine whether two
items in a list should be considered â€œthe sameâ€.</p><p>It is easy to write programs that encode assumptions about our data
that might not apply in practice.  This is again a situation that can
be helped by thinking about the concrete examples on which your code
needs to work in context.  </p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.2.9.4"><h5 class="heading">5.2.9.4<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Reducing Computation<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Notice that this function has a repeated expression. Instead of
writing it twice, we could call it just once and use the result in
both places:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec2(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      ur = uniq-rec2(r)
      if r.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">You might think, because we replaced two function calls with one, that
weâ€™ve reduced the amount of computation the program does. It does not!
The two function calls are both in the two branches of the same
conditional; therefore, for any given list element, only one or the
other call to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> happens. In fact, in both cases, there was
one call to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> before, and there is one now. So we have
reduced the number of calls in the source program, but not the number
that take place when the program runs. In that sense, the name of this
section was intentionally misleading!</div><p/><div class="SIntrapara">However, there is one useful reduction we can perform, which is
enabled by the structure of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq-rec2</code></span>. We currently check
whether <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> is a member of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>, which is the list of
<span class="emph">all</span> the remaining elements. In our example, this means that in
the very second turn, we check whether <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span> is a member of the list
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 3, 1, 2, 4, 1]</code></span>. This is a list of six elements,
including three copies of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>. We compare <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span> against
<span class="emph">two</span> copies of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>. However, we gain nothing from the
second comparison. Put differently, we can think of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq(r)</code></span> as
a â€œsummaryâ€ of the rest of the list that is exactly as good as
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> itself for checking membership, with the advantage that it
might be significantly shorter. This, of course, is exactly what
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ur</code></span> represents. Therefore, we can encode this intuition as
follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec3(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      ur = uniq-rec3(r)
      if ur.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">Note that all that changed is that we check for membership in
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ur</code></span> rather than in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Later [<a href="predicting-growth.html" data-pltdoc="x">Predicting Growth</a>] we will study how to formally
study how long a program takes to run. By the measure introduced in
that section, does the change we just made make any difference? Be
careful with your answer: it depends on how we count â€œthe lengthâ€ of
the list.</p></blockquote></blockquote><p>Observe that if the list never contained duplicates in the first
place, then it wouldnâ€™t matter which list we check membership inâ€”<wbr/>but
if we <span class="emph">knew</span> the list didnâ€™t contain duplicates, we wouldnâ€™t be
using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> in the first place! We will return to the issue of
lists and duplicate elements in <a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>.</p></section><section class="SsectionLevel5" id="section 5.2.9.5"><h5 class="heading">5.2.9.5<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Example and Code Variations<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">As we mentioned earlier, there are other example sequences you might
have written down. Hereâ€™s a very different process:
</div><div class="SIntrapara"><ul><li><p>Start with the entire given list and with the empty answer (so
far).</p></li><li><p>For each list element, check whether itâ€™s already in the answer
so far. If it is, ignore it, otherwise extend the answer with it.</p></li><li><p>When there are no more elements in the list, the answer so far
is the answer for the whole list.</p></li></ul></div><div class="SIntrapara">Notice that this solution assumes that we will be accumulating the
answer as we traverse the list. Therefore, we canâ€™t even write the
example with one parameter as we did before. We would argue that a
<span class="emph">natural</span> solution asks whether we can solve the problem just
from the structure of the data using the computation we are already
defining, as we did above. If we cannot, then we have to resort to an
accumulator. But because we can, the accumulator is unnecessary here
and greatly complicates even writing down examples (give it a try!).</div></section><section class="SsectionLevel5" id="section 5.2.9.6"><h5 class="heading">5.2.9.6<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Why Produce a List?<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>If you go back to the original statement of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> problem
[<a href="#%28part._uniq%29" data-pltdoc="x"><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Problem Setup</a>], youâ€™ll notice it said nothing about what order the
output should have; in fact, it didnâ€™t even say the output needs to be
a list (and hence have an order). In that case, we should think about
whether a list even makes sense for this problem. In fact, if we donâ€™t
care about order and donâ€™t want duplicates (by definition of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>), then there is a much simpler solution, which is to
produce a <span style="font-style: italic">set</span>. Pyret already has sets built in, and converting
the list to a set automatically takes care of duplicates. This is of
course cheating from the perspective of learning how to write
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>, but it is worth remembering that sometimes the right data
structure to produce isnâ€™t necessarily the same as the one we were
given. Also, later [<a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>], we will see how to build sets
for ourselves (at which point, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> will look familiar, since
it is at the heart of set-ness).</p></section></section><section class="SsectionLevel4" id="section 5.2.10"><h4 class="heading">5.2.10<span class="stt">Â </span><a name="(part._polymorphic-data)"/>Monomorphic Lists and Polymorphic Types<span class="button-group"><a href="#(part._polymorphic-data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Earlier we wrote contracts like:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len :: List&lt;Any&gt; -&gt; Number
my-max :: List&lt;Any&gt; -&gt; Any</code></pre></div></div></div><div class="SIntrapara">These are unsatisfying for several reasons. Consider
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>. The contract suggests that any kind of element can be
in the input list, but in fact that isnâ€™t true: the input
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, "two", 3]</code></span> is not valid, because we canâ€™t compare
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"two"</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"two"</code></span> with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>What happens if we run <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 &gt; "two"</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"two" &gt; 3</code></span>?</p></blockquote></blockquote><p>Rather, what we mean is a list where all the elements are <span class="emph">of the
same kind</span>,<span class="refelem"><span class="refcolumn"><span class="refcontent">Technically, elements that are also comparable.</span></span></span>
and the contract has not captured that. Furthermore, we donâ€™t mean
that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span> might return any old type: if we supply it with a
list of numbers, we will not get a string as the maximum element!
Rather, it will only return the kind of element that is in the
provided list.</p><p>In short, we mean that all elements of the list are of the same type,
but they can be of any type. We call the former <span style="font-style: italic">monomorphic</span>:
â€œmonoâ€ meaning one, and â€œmorphicâ€ meaning shape, i.e., all values
have one type. But the function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span> itself can operate over
many of these kinds of lists, so we call it <span style="font-style: italic">polymorphic</span>
(â€œpolyâ€ meaning many).</p><p/><div class="SIntrapara">Therefore, we need a better way of writing these
contracts. Essentially, we want to say that there is a
<span style="font-style: italic">type variable</span> (as opposed to regular program variable) that represents the
type of element in the list. Given that type, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span> will
return an element of that type. We write this syntactically as
follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max&lt;T&gt;(l :: List&lt;T&gt;) -&gt; T: â€¦ end</code></pre></div></div></div><div class="SIntrapara">The notation <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;T&gt;</code></span> says that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">T</code></span> is a type variable
parameter that will be used in the rest of the function (both the
header and the body).</div><p/><div class="SIntrapara">Using this notation, we can also revisit <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>. Its header now
becomes:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-len&lt;T&gt;(l :: List&lt;T&gt;) -&gt; Number: â€¦ end</code></pre></div></div></div><div class="SIntrapara">Note that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span> did not actually â€œcareâ€ that whether all the
values were of the same type or not: it never looks at the individual
elements, much less at pairs of them. However, as a <span class="emph">convention</span>
we demand that lists always be monomorphic. This is important because
it enables us to process the elements of the list uniformly: if we
know how to process elements of type <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">T</code></span>, then we will know how
to process a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">List&lt;T&gt;</code></span>. If the list elements can be of truly any
old type, we canâ€™t know how to process its elements.</div></section>&#13;
<h4 class="heading">5.2.1<span class="stt">Â </span><a name="(part._.Making_.Lists_and_.Taking_.Them_.Apart)"/>Making Lists and Taking Them Apart<span class="button-group"><a href="#(part._.Making_.Lists_and_.Taking_.Them_.Apart)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>So far weâ€™ve seen one way to make a list: by writing
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: â€¦]</code></span>. While useful, writing lists this way actually
hides their true nature. Every list actually has two parts: a
<span class="emph">first</span> element and the <span class="emph">rest</span> of the list. The rest of the
list is itself a list, so it too has two partsâ€¦and so on.</p><p/><div class="SIntrapara">Consider the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code></span>. Its first element is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>, and
the rest of it is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 2, 3]</code></span>. For this second list, the first element
is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span> and the rest is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3]</code></span>.
</div><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Take apart this third list.</p></blockquote></blockquote></div><div class="SIntrapara">For the third list, the first element is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span> and the rest is
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ]</code></span>, i.e., the empty list. In Pyret, we have another way
of writing the empty list: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>.</div><p>Lists are an instance of <span style="font-style: italic">structured data</span>: data with component
parts and a well-defined format for the shape of the parts. Lists are
formatted by the first element and the rest of the elements. Tables
are somewhat structured: they are formatted by rows and columns, but
the column names arenâ€™t consistent across all tables.  Structured data
is valuable in programming because a predictable format (the
structure) lets us write programs based on that structure. What do we
mean by that?</p><p/><div class="SIntrapara">Programming languages can (and do!) provide built-in operators for
taking apart structured data. These operators are called
<span style="font-style: italic">accessors</span>. Accessors are defined on the structure of the
datatype alone, independent of the contents of the data. In the case
of lists, there are two accessors: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span>. We use an accessor by writing an expression, followed by
a dot (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.</code></span>), followed by the accessorâ€™s name. As we saw with
tables, the dot means "dig into". Thus:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l1 = [list: 1, 2, 3]
e1 = l1.first
l2 = l1.rest
e2 = l2.first
l3 = l2.rest
e3 = l3.first
l4 = l3.rest

check:
  e1 is 1
  e2 is 2
  e3 is 3
  l2 is [list: 2, 3]
  l3 is [list: 3]
  l4 is empty
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What are the accessors for tables?</p></blockquote></blockquote><p>Accessors give a way to take data apart based on their structure
(there is another way that we will see shortly). Is there a way to
also <span class="emph">build</span> data based on its structure? So far, we have been
building lists using the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ...]</code></span> form, but that doesnâ€™t
emphasize the structural constraint that the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> is itself a
list. A structured operator for building lists would clearly show both
a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> element and a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> that is itself a
list. Operators for building structured data are called
<span style="font-style: italic">constructors</span>.</p><p>The constructor for lists is called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>. It takes two
arguments: a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> element, and the list to build on (the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> part). Hereâ€™s an example of using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> to create a
three-element list.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link(1, link(2, link(3, empty)))</code></pre></div></div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> form creates the same underlying list datum as our
previous <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ...]</code></span> operation, as confirmed by the following
check:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  [list: 1, 2, 3] is link(1, link(2, link(3, empty)))
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Look at these two forms of writing lists: what differences do you notice?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> form to write a four-element list of fruits containing
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"lychee"</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"dates"</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"mango"</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"durian"</code></span>.</p></blockquote></blockquote><p>After doing this exercise, you might wonder why anyone would use the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> form: itâ€™s more verbose, and makes the individual elements
harder to discern. This form is not very convenient to
humans. But it will prove very valuable to programs!</p><p/><div class="SIntrapara">In particular, the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> form highlights that we really have
<span class="emph">two different structures of lists</span>.
Some lists are empty. All other lists are <span style="font-style: italic">non-empty</span>
lists, meaning they have <span class="emph">at least one</span> <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>. There may be
more interesting structure to some lists (as we will see later), but all lists have this much
in common. Specifically, a list is either
</div><div class="SIntrapara"><ul><li><p>empty (written <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ]</code></span>), or</p></li><li><p>non-empty (written <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link(â€¦, â€¦)</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ]</code></span> with
at least one value inside the brackets), where <span class="emph">the rest is also
a list</span> (and hence may in turn be empty or non-empty, â€¦).</p></li></ul></div><p/><div class="SIntrapara">This means we actually have two structural features of lists, both of
which are important when writing programs over lists:
</div><div class="SIntrapara"><ol><li><p>Lists can be empty or non-empty</p></li><li><p>Non-empty lists have a first element and a rest of the list</p></li></ol></div><div class="SIntrapara">Letâ€™s leverage these two structural features to write some programs to
process lists!</div>&#13;
<h4 class="heading">5.2.2<span class="stt">Â </span><a name="(part._my-len)"/>Some Example Exercises<span class="button-group"><a href="#(part._my-len)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>To illustrate our thinking, letâ€™s work through a few concrete examples
of list-processing functions. All of these will consume lists; some
will even produce them. Some will transform their inputs (like
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>), some will select from their inputs (like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>),
and some will aggregate their inputs. Since some of these functions already exist in
Pyret, weâ€™ll name them with the prefix <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-</code></span> to avoid
errors.<span class="refelem"><span class="refcolumn"><span class="refcontent">Be sure to use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-</code></span> name consistently,
including inside the body of the function.</span></span></span> As we will see, there is a
standard strategy that we can use to approach writing all of these
functions: having you learn this strategy is the goal of this chapter.</p>&#13;
<h4 class="heading">5.2.3<span class="stt">Â </span><a name="(part._.Structural_.Problems_with_.Scalar_.Answers)"/>Structural Problems with Scalar Answers<span class="button-group"><a href="#(part._.Structural_.Problems_with_.Scalar_.Answers)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Letâ€™s write out examples for a few of the functions described
above. Weâ€™ll approach writing examples in a very specific, stylized
way. First of all, we should always construct at least two examples:
one with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> and the other with at least one <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>, so
that weâ€™ve covered the two very broad kinds of lists. Then, we should
have more examples specific to the kind of list stated in the
problem. Finally, we should have even more examples to illustrate how
we think about solving the problem.</p><section class="SsectionLevel5" id="section 5.2.3.1"><h5 class="heading">5.2.3.1<span class="stt">Â </span><a name="(part._len-eg)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>: Examples<span class="button-group"><a href="#(part._len-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>We haveâ€™t precisely defined what it means to be â€œthe lengthâ€ of a
list. We confront this right away when trying to write an
example. What is the length of the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you think?</p></blockquote></blockquote><p/><div class="SIntrapara">Two common examples are <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>. The latter, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>,
certainly looks reasonable. However, if you write the list as
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ]</code></span>, now it doesnâ€™t look so right: this is clearly (as the
name <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> also suggests) an <span class="emph">empty</span> list, and an empty
list has <span class="emph">zero</span> elements in it. Therefore, itâ€™s conventional to
declare that
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len(empty) is 0</code></pre></div></div></div><div class="SIntrapara">How about a list like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7]</code></span>? Well, itâ€™s clearly got one
element (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span>) in it, so
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7]) is 1</code></pre></div></div></div><div class="SIntrapara">Similarly, for a list like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code></span>, we would say
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3</code></pre></div></div></div><p/><div class="SIntrapara">Now letâ€™s look at that last example in a different light. Consider
the argument <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code></span>. Its first element is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span> and
the rest of it is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 8, 9]</code></span>. Well, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span> is a number, not
a list; but <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 8, 9]</code></span> certainly is a list, so we can ask for
<span class="emph">its</span> length. What is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 8, 9])</code></span>? It has two
elements, so
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 8, 9]) is 2</code></pre></div></div></div><div class="SIntrapara">The first element of <span class="emph">that</span> list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">8</code></span> while its rest is
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 9]</code></span>. What is its length?
Note that we asked a very similar question before, for the length of
the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7]</code></span>. But <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7]</code></span> is not a
<span style="font-style: italic">sub-list</span> of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code></span>, which we started with,
whereas <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 9]</code></span> is. And using the same reasoning as before,
we can say
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 9]) is 1</code></pre></div></div></div><div class="SIntrapara">The rest of this last list is, of course, the empty list, whose length
we have already decided is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>.</div><p/><div class="SIntrapara">Putting together these examples, and writing out <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> in its
other form, hereâ€™s what we get:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3
my-len([list:    8, 9]) is 2
my-len([list:       9]) is 1
my-len([list:        ]) is 0</code></pre></div></div></div><div class="SIntrapara">Another way we can write this (paying attention to the right side) is
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + 2
my-len([list:    8, 9]) is 1 + 1
my-len([list:       9]) is 1 + 0
my-len([list:        ]) is     0</code></pre></div></div></div><div class="SIntrapara">Where did the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span> on the right sides of
each <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span> operation come from? Those are the lengths of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> component of the input list. In the previous example
block, we wrote those lengths as explicit examples. Letâ€™s substitute
the numbers <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span> with the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>
expressions that produce them:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list:    8, 9]) is 1 + my-len([list:    9])
my-len([list:       9]) is 1 + my-len([list:     ])
my-len([list:        ]) is 0</code></pre></div></div></div><div class="SIntrapara">From this, maybe you can start to see a pattern. For an empty list,
the length is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>. For a non-empty list, itâ€™s the sum of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>
(the first elementâ€™s â€œcontributionâ€ to the listâ€™s length) to the
length of the rest of the list. In other words, we can use the result
of computing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span> on the rest of the list to compute the
answer for the entire list.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Each of our examples in this section has written a different check on
the expression <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9])</code></span>. Here are those examples
presented together, along with one last one that explicitly uses the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> operation:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3
my-len([list: 7, 8, 9]) is 1 + 2
my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)</code></pre></div></div></div><div class="SIntrapara">Check that you agree with each of these assertions. Also check whether
you understand how the right-hand side of each <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> expression
derives from the right-hand-side just above it. The goal of this
exercise is to make sure that you believe that the last check (which
we will turn into code) is equivalent to the first (which we wrote
down when understanding the problem).</div></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.2.3.2"><h5 class="heading">5.2.3.2<span class="stt">Â </span><a name="(part._sum-eg)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum</code></span>: Examples<span class="button-group"><a href="#(part._sum-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Letâ€™s repeat this process of developing examples on a second function,
this time one that computes the sum of the elements in a list of numbers.
What is the
sum of the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code></span>? Just adding up the numbers by hand,
the result should be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">24</code></span>. Letâ€™s see how that works out through
the examples.</p><p/><div class="SIntrapara">Setting aside the empty list for a moment, here are examples that show
the sum computations:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum([list: 7, 8, 9]) is 7 + 8 + 9
my-sum([list:    8, 9]) is     8 + 9
my-sum([list:       9]) is         9</code></pre></div></div></div><div class="SIntrapara">which (by substitution) is the same as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum([list: 7, 8, 9]) is 7 + my-sum([list: 8, 9])
my-sum([list:    8, 9]) is 8 + my-sum([list:    9])
my-sum([list:       9]) is 9 + my-sum([list:     ])</code></pre></div></div></div><div class="SIntrapara">From this, we can see that the sum of the empty list must be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>:<span class="refelem"><span class="refcolumn"><span class="refcontent">Zero is called the <span style="font-style: italic">additive identity</span>: a
fancy way of saying, adding zero to any number <span style="font-style: italic">N</span> gives you
<span style="font-style: italic">N</span>. Therefore, it makes sense that it would be the length of the
empty list, because the empty list has no items to contribute to a
sum. Can you figure out what the <span style="font-style: italic">multiplicative identity</span> is?</span></span></span>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum(empty) is 0</code></pre></div></div></div><p>Observe, again, how we can use the result of computing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum</code></span>
of the rest of the list to compute its result for the whole list.</p></section><section class="SsectionLevel5" id="section 5.2.3.3"><h5 class="heading">5.2.3.3<span class="stt">Â </span><a name="(part._.From_.Examples_to_.Code)"/>From Examples to Code<span class="button-group"><a href="#(part._.From_.Examples_to_.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Having developed these examples, we now want to use them to develop a
program that can compute the length or the sum of <span class="emph">any</span> list, not
just the specific ones we used in these examples. As we have done up
in earlier chapters, we will leverage patterns in the examples to
figure out how to define the general-purpose function.</p><p/><div class="SIntrapara">Here is one last version of the examples for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>, this time
making the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> explicit on the right-hand sides of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)
my-len([list:        ]) is 0</code></pre></div></div></div><div class="SIntrapara">As we did when developing functions over images, letâ€™s try to identify
the common parts of these examples. We start by noticing that most of
the examples have a lot in common, except for the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ]</code></span>
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>) case. So letâ€™s separate this into two sets of examples:</div><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)


my-len([list:        ]) is 0</code></pre></div></div></div><div class="SIntrapara">With this separation (which follows one of the structural features of
lists that we mentioned earlier), a clearer pattern emerges: for a
non-empty list (called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">someList</code></span>), we compute its length via the
expression:</div><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 + my-len(someList.rest)</code></pre></div></div></div><div class="SIntrapara">In general, then, our <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span> program needs to determine whether
its input list is empty or non-empty, using this expression with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.rest</code></span> in the non-empty case. How do we indicate different code
based on the structure of the list?</div><p/><div class="SIntrapara">Pyret has a construct called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> which is used to distinguish
different forms within a structured datatype. When working with lists,
the general shape of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expression is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (List) e:
  | empty      =&gt; â€¦
  | link(f, r) =&gt; â€¦ f â€¦ r â€¦
end</code></pre></div></div></div><div class="SIntrapara">where most parts are fixed, but a few youâ€™re free to change:
</div><div class="SIntrapara"><ul><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e</code></span> is an expression whose value needs to be a list; it
could be a variable bound to a list, or some complex expression that
evaluates to a list.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> are names given to the first and rest of
the list. You can choose any names you like, though in Pyret, itâ€™s
conventional to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">Occasionally
using different names can help students recall that they can choose
how to label the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> components. This can be
particularly useful for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span>, which has a problem-specific
meaning (such as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">price</code></span> in a list of prices, and so on).</span></span></span></p></li></ul></div><div class="SIntrapara">The right-hand side of every <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;</code></span> is an expression.</div><p>Hereâ€™s how <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> works in this instance. Pyret first evaluates
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e</code></span>. It then checks that the resulting value truly is a list;
otherwise it halts with an error. If it is a list, Pyret examines what
<span class="emph">kind</span> of list it is. If itâ€™s an empty list, it runs the
expression after the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;</code></span> in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> clause. Otherwise,
the list is not empty, which means it has a first and rest; Pyret
binds <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> to the two parts, respectively, and then
evaluates the expression after the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;</code></span> in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> clause.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Try using a non-listâ€”<wbr/>e.g., a numberâ€”<wbr/>in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e</code></span> position and
see what happens!</p></blockquote></blockquote><p/><div class="SIntrapara">Now letâ€™s use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> to define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-len(l):
  cases (List) l:
    | empty      =&gt; 0
    | link(f, r) =&gt; 1 + my-len(r)
  end
end</code></pre></div></div></div><div class="SIntrapara">This follows from our examples: when the list is empty <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>
produces <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>; when it is not empty, we add one to the length of
the rest of the list (here, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>).</div><p>Note that while our most recent collection of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span> examples
explicitly said <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.rest</code></span>, when using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> we instead use
just the name <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>, which Pyret has already defined (under the
hood) to be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l.rest</code></span>.</p><p/><div class="SIntrapara">Similarly, letâ€™s define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-sum(l):
  cases (List) l:
    | empty      =&gt; 0
    | link(f, r) =&gt; f + my-sum(r)
  end
end</code></pre></div></div></div><div class="SIntrapara">Notice how similar they are in code, and how readily the structure of
the data suggest a structure for the program. This is a pattern you
will get very used to soon!</div><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Developing Functions Over Lists</p><blockquote class="StrategyBody"><p/><div class="SIntrapara">Leverage the structure of lists and the power of concrete examples to
develop list-processing functions.
</div><div class="SIntrapara"><ul><li><p>Pick a concrete list with (at least) three elements. Write a
sequence of examples for each of the entire list and each suffix of
the list (including the empty list).</p></li><li><p>Rewrite each example to express its expected
answer in terms of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> data of its input
list. You donâ€™t have to use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> operators
in the new answers, but you should see the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> <span class="emph">values</span> represented explicitly in the answer.</p></li><li><p>Look for a pattern across the answers in the examples. Use these
to develop the code: write a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expression, filling in the
right side of each <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;</code></span> based on your examples.</p></li></ul></div><div class="SIntrapara">This strategy applies to structured data in general, leveraging
components of each datum rather than specifically <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> as presented so far.</div></blockquote></blockquote></section>&#13;
<h5 class="heading">5.2.3.1<span class="stt">Â </span><a name="(part._len-eg)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>: Examples<span class="button-group"><a href="#(part._len-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>We haveâ€™t precisely defined what it means to be â€œthe lengthâ€ of a
list. We confront this right away when trying to write an
example. What is the length of the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you think?</p></blockquote></blockquote><p/><div class="SIntrapara">Two common examples are <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>. The latter, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>,
certainly looks reasonable. However, if you write the list as
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ]</code></span>, now it doesnâ€™t look so right: this is clearly (as the
name <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> also suggests) an <span class="emph">empty</span> list, and an empty
list has <span class="emph">zero</span> elements in it. Therefore, itâ€™s conventional to
declare that
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len(empty) is 0</code></pre></div></div></div><div class="SIntrapara">How about a list like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7]</code></span>? Well, itâ€™s clearly got one
element (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span>) in it, so
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7]) is 1</code></pre></div></div></div><div class="SIntrapara">Similarly, for a list like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code></span>, we would say
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3</code></pre></div></div></div><p/><div class="SIntrapara">Now letâ€™s look at that last example in a different light. Consider
the argument <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code></span>. Its first element is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span> and
the rest of it is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 8, 9]</code></span>. Well, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span> is a number, not
a list; but <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 8, 9]</code></span> certainly is a list, so we can ask for
<span class="emph">its</span> length. What is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 8, 9])</code></span>? It has two
elements, so
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 8, 9]) is 2</code></pre></div></div></div><div class="SIntrapara">The first element of <span class="emph">that</span> list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">8</code></span> while its rest is
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 9]</code></span>. What is its length?
Note that we asked a very similar question before, for the length of
the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7]</code></span>. But <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7]</code></span> is not a
<span style="font-style: italic">sub-list</span> of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code></span>, which we started with,
whereas <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 9]</code></span> is. And using the same reasoning as before,
we can say
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 9]) is 1</code></pre></div></div></div><div class="SIntrapara">The rest of this last list is, of course, the empty list, whose length
we have already decided is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>.</div><p/><div class="SIntrapara">Putting together these examples, and writing out <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> in its
other form, hereâ€™s what we get:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3
my-len([list:    8, 9]) is 2
my-len([list:       9]) is 1
my-len([list:        ]) is 0</code></pre></div></div></div><div class="SIntrapara">Another way we can write this (paying attention to the right side) is
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + 2
my-len([list:    8, 9]) is 1 + 1
my-len([list:       9]) is 1 + 0
my-len([list:        ]) is     0</code></pre></div></div></div><div class="SIntrapara">Where did the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span> on the right sides of
each <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span> operation come from? Those are the lengths of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> component of the input list. In the previous example
block, we wrote those lengths as explicit examples. Letâ€™s substitute
the numbers <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span> with the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>
expressions that produce them:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list:    8, 9]) is 1 + my-len([list:    9])
my-len([list:       9]) is 1 + my-len([list:     ])
my-len([list:        ]) is 0</code></pre></div></div></div><div class="SIntrapara">From this, maybe you can start to see a pattern. For an empty list,
the length is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>. For a non-empty list, itâ€™s the sum of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>
(the first elementâ€™s â€œcontributionâ€ to the listâ€™s length) to the
length of the rest of the list. In other words, we can use the result
of computing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span> on the rest of the list to compute the
answer for the entire list.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Each of our examples in this section has written a different check on
the expression <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9])</code></span>. Here are those examples
presented together, along with one last one that explicitly uses the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> operation:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 3
my-len([list: 7, 8, 9]) is 1 + 2
my-len([list: 7, 8, 9]) is 1 + my-len([list: 8, 9])
my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)</code></pre></div></div></div><div class="SIntrapara">Check that you agree with each of these assertions. Also check whether
you understand how the right-hand side of each <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> expression
derives from the right-hand-side just above it. The goal of this
exercise is to make sure that you believe that the last check (which
we will turn into code) is equivalent to the first (which we wrote
down when understanding the problem).</div></blockquote></blockquote>&#13;
<h5 class="heading">5.2.3.2<span class="stt">Â </span><a name="(part._sum-eg)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum</code></span>: Examples<span class="button-group"><a href="#(part._sum-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Letâ€™s repeat this process of developing examples on a second function,
this time one that computes the sum of the elements in a list of numbers.
What is the
sum of the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 7, 8, 9]</code></span>? Just adding up the numbers by hand,
the result should be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">24</code></span>. Letâ€™s see how that works out through
the examples.</p><p/><div class="SIntrapara">Setting aside the empty list for a moment, here are examples that show
the sum computations:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum([list: 7, 8, 9]) is 7 + 8 + 9
my-sum([list:    8, 9]) is     8 + 9
my-sum([list:       9]) is         9</code></pre></div></div></div><div class="SIntrapara">which (by substitution) is the same as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum([list: 7, 8, 9]) is 7 + my-sum([list: 8, 9])
my-sum([list:    8, 9]) is 8 + my-sum([list:    9])
my-sum([list:       9]) is 9 + my-sum([list:     ])</code></pre></div></div></div><div class="SIntrapara">From this, we can see that the sum of the empty list must be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>:<span class="refelem"><span class="refcolumn"><span class="refcontent">Zero is called the <span style="font-style: italic">additive identity</span>: a
fancy way of saying, adding zero to any number <span style="font-style: italic">N</span> gives you
<span style="font-style: italic">N</span>. Therefore, it makes sense that it would be the length of the
empty list, because the empty list has no items to contribute to a
sum. Can you figure out what the <span style="font-style: italic">multiplicative identity</span> is?</span></span></span>
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum(empty) is 0</code></pre></div></div></div><p>Observe, again, how we can use the result of computing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum</code></span>
of the rest of the list to compute its result for the whole list.</p>&#13;
<h5 class="heading">5.2.3.3<span class="stt">Â </span><a name="(part._.From_.Examples_to_.Code)"/>From Examples to Code<span class="button-group"><a href="#(part._.From_.Examples_to_.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Having developed these examples, we now want to use them to develop a
program that can compute the length or the sum of <span class="emph">any</span> list, not
just the specific ones we used in these examples. As we have done up
in earlier chapters, we will leverage patterns in the examples to
figure out how to define the general-purpose function.</p><p/><div class="SIntrapara">Here is one last version of the examples for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>, this time
making the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> explicit on the right-hand sides of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)
my-len([list:        ]) is 0</code></pre></div></div></div><div class="SIntrapara">As we did when developing functions over images, letâ€™s try to identify
the common parts of these examples. We start by noticing that most of
the examples have a lot in common, except for the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: ]</code></span>
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>) case. So letâ€™s separate this into two sets of examples:</div><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len([list: 7, 8, 9]) is 1 + my-len([list: 7, 8, 9].rest)
my-len([list:    8, 9]) is 1 + my-len([list:    8, 9].rest)
my-len([list:       9]) is 1 + my-len([list:       9].rest)


my-len([list:        ]) is 0</code></pre></div></div></div><div class="SIntrapara">With this separation (which follows one of the structural features of
lists that we mentioned earlier), a clearer pattern emerges: for a
non-empty list (called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">someList</code></span>), we compute its length via the
expression:</div><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 + my-len(someList.rest)</code></pre></div></div></div><div class="SIntrapara">In general, then, our <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span> program needs to determine whether
its input list is empty or non-empty, using this expression with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.rest</code></span> in the non-empty case. How do we indicate different code
based on the structure of the list?</div><p/><div class="SIntrapara">Pyret has a construct called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> which is used to distinguish
different forms within a structured datatype. When working with lists,
the general shape of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expression is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (List) e:
  | empty      =&gt; â€¦
  | link(f, r) =&gt; â€¦ f â€¦ r â€¦
end</code></pre></div></div></div><div class="SIntrapara">where most parts are fixed, but a few youâ€™re free to change:
</div><div class="SIntrapara"><ul><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e</code></span> is an expression whose value needs to be a list; it
could be a variable bound to a list, or some complex expression that
evaluates to a list.</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> are names given to the first and rest of
the list. You can choose any names you like, though in Pyret, itâ€™s
conventional to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>.<span class="refelem"><span class="refcolumn"><span class="refcontent">Occasionally
using different names can help students recall that they can choose
how to label the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> components. This can be
particularly useful for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span>, which has a problem-specific
meaning (such as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">price</code></span> in a list of prices, and so on).</span></span></span></p></li></ul></div><div class="SIntrapara">The right-hand side of every <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;</code></span> is an expression.</div><p>Hereâ€™s how <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> works in this instance. Pyret first evaluates
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e</code></span>. It then checks that the resulting value truly is a list;
otherwise it halts with an error. If it is a list, Pyret examines what
<span class="emph">kind</span> of list it is. If itâ€™s an empty list, it runs the
expression after the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;</code></span> in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> clause. Otherwise,
the list is not empty, which means it has a first and rest; Pyret
binds <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> to the two parts, respectively, and then
evaluates the expression after the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;</code></span> in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> clause.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Try using a non-listâ€”<wbr/>e.g., a numberâ€”<wbr/>in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e</code></span> position and
see what happens!</p></blockquote></blockquote><p/><div class="SIntrapara">Now letâ€™s use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> to define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-len(l):
  cases (List) l:
    | empty      =&gt; 0
    | link(f, r) =&gt; 1 + my-len(r)
  end
end</code></pre></div></div></div><div class="SIntrapara">This follows from our examples: when the list is empty <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>
produces <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>; when it is not empty, we add one to the length of
the rest of the list (here, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>).</div><p>Note that while our most recent collection of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span> examples
explicitly said <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.rest</code></span>, when using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> we instead use
just the name <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>, which Pyret has already defined (under the
hood) to be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l.rest</code></span>.</p><p/><div class="SIntrapara">Similarly, letâ€™s define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-sum</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-sum(l):
  cases (List) l:
    | empty      =&gt; 0
    | link(f, r) =&gt; f + my-sum(r)
  end
end</code></pre></div></div></div><div class="SIntrapara">Notice how similar they are in code, and how readily the structure of
the data suggest a structure for the program. This is a pattern you
will get very used to soon!</div><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Developing Functions Over Lists</p><blockquote class="StrategyBody"><p/><div class="SIntrapara">Leverage the structure of lists and the power of concrete examples to
develop list-processing functions.
</div><div class="SIntrapara"><ul><li><p>Pick a concrete list with (at least) three elements. Write a
sequence of examples for each of the entire list and each suffix of
the list (including the empty list).</p></li><li><p>Rewrite each example to express its expected
answer in terms of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> data of its input
list. You donâ€™t have to use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> operators
in the new answers, but you should see the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> <span class="emph">values</span> represented explicitly in the answer.</p></li><li><p>Look for a pattern across the answers in the examples. Use these
to develop the code: write a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expression, filling in the
right side of each <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=&gt;</code></span> based on your examples.</p></li></ul></div><div class="SIntrapara">This strategy applies to structured data in general, leveraging
components of each datum rather than specifically <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> as presented so far.</div></blockquote></blockquote>&#13;
<h4 class="heading">5.2.4<span class="stt">Â </span><a name="(part._.Structural_.Problems_that_.Transform_.Lists)"/>Structural Problems that Transform Lists<span class="button-group"><a href="#(part._.Structural_.Problems_that_.Transform_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Now that we have a systematic way to develop functions that take lists
as input, letâ€™s apply that same strategy to functions that
<span class="emph">produce</span> a list as the answer.</p><section class="SsectionLevel5" id="section 5.2.4.1"><h5 class="heading">5.2.4.1<span class="stt">Â </span><a name="(part._doubles-eg-code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles</code></span>: Examples and Code<span class="button-group"><a href="#(part._doubles-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>As always, weâ€™ll begin with some examples. Given a list of numbers, we
want a list that doubles each number (in the order of the
original list). Hereâ€™s a reasonable example with three numbers:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is [list: 6, 10, 4]</code></pre></div></div><p>As before, letâ€™s write out the answers for each suffix of our example
list as well, including for the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> list:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list:    5, 2]) is [list:    10, 4]
my-doubles([list:       2]) is [list:        4]
my-doubles([list:        ]) is [list:         ]</code></pre></div></div><p>Now, we rewrite the answer expressions to include the concrete
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> data for each example. Letâ€™s start with
just the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> data, and just on the first example:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is [list: 3 * 2, 10, 4]
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre></div></div><p>Next, letâ€™s include the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> data (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 5, 2]</code></span>) in the
first example. The current answer in the first example is</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, 10, 4]</code></pre></div></div><p>and that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 10, 4]</code></span> is the result of using the function on
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 5, 2]</code></span>. We might therefore be tempted to replace the
right side of the first example with:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, my-doubles([list: 5, 2])]</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">What value would this expression produce? You might want to try this
example that doesnâ€™t use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles</code></span> directly:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, [list: 10, 4]]</code></pre></div></div></div></blockquote></blockquote><p>Oops! We want a single (flat) list, not a list-within-a-list. This
feels like it is on the right track in terms of reworking the answer
to use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> values, but weâ€™re clearly not
quite there yet.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">What value does the following expression produce?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link(3 * 2, [list: 10, 4])</code></pre></div></div></div></blockquote></blockquote><p>Notice the difference between the two expressions in these last two
exercises: the latter used <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> to put the value involving
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> into the conversion of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span>, while the former
tried to do this with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list:</code></span>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How many elements are in the lists that result from each of the
following expressions?</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 25, 16, 32]
[list: 25, [list: 16, 32]]
link(25, [list: 16, 32])</code></pre></div></div></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Summarize the difference between how <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list:</code></span>
combine an element and a list. Try additional examples at the
interactions prompt if needed to explore these ideas.</p></blockquote></blockquote><p>The takeaway here is that we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> to <span class="emph">insert an
element into an existing list</span>, whereas we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list:</code></span> to make a
new list that <span class="emph">contains</span> the old list as an element. Going back
to our examples, then, we include <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> in the first example by
writing it as follows:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, [list: 10, 4])
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre></div></div><p>which we then convert to</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre></div></div><p>Applying this idea across the examples, we get:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is link(5 * 2, my-doubles([list: 2]))
my-doubles([list:       2]) is link(2 * 2, my-doubles([list: ]))
my-doubles([list:        ]) is [list:             ]</code></pre></div></div><p>Now that we have examples that explicitly use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> elements, we can produce to write the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles</code></span>
function:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-doubles(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      link(f * 2, my-doubles(r))
  end
end</code></pre></div></div></section><section class="SsectionLevel5" id="section 5.2.4.2"><h5 class="heading">5.2.4.2<span class="stt">Â </span><a name="(part._str-len-eg-code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len</code></span>: Examples and Code<span class="button-group"><a href="#(part._str-len-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">In <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles</code></span>, the input and output lists have the same type of
element. Functions can also produce lists whose contents have a
different type from the input list. Letâ€™s work through an example.
Given a list of strings, we
want the lengths of each string (in the same order as in the input list). Thus, hereâ€™s a
reasonable example:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is [list: 2, 5, 6]</code></pre></div></div></div><div class="SIntrapara">As we have before, we should consider the answers for each
sub-problem of the above example:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list:       "there", "mateys"]) is [list:    5, 6]
my-str-len([list:                "mateys"]) is [list:       6]</code></pre></div></div></div><p/><div class="SIntrapara">Or, in other words:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(2, [list: 5, 6])
my-str-len([list:       "there", "mateys"]) is link(5, [list:    6])
my-str-len([list:                "mateys"]) is link(6, [list:     ])</code></pre></div></div></div><div class="SIntrapara">which tells us that the response for the empty list should be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len(empty) is empty</code></pre></div></div></div><p>The next step is to rework the answers in the examples to make the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> parts explicit. Hopefully by now you are
starting to detect a pattern: The result on the rest of the list
appears explicitly as another example. Therefore, weâ€™ll start by
getting the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> value of each example input into the answer:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(2, my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(5, my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(6, my-str-len([list:                  ]))
my-str-len([list:                        ]) is [list: ]</code></pre></div></div><p>All that remains now is to figure out how to work the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span>
values into the outputs. In the context of this problem, this means we
need to convert <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"hi"</code></span> into <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"there"</code></span> into
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">5</code></span>, and so on. From the problem statement, we know that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">5</code></span> are meant to be the lengths (character counts) of the
corresponding strings. The operation that determines the length of a
string is called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-length</code></span>. Thus, our examples appear as:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(string-length("hi"), my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(string-length("there"), my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(string-length("mateys"), my-str-len([list: ]))
my-str-len([list:                        ]) is [list: ]</code></pre></div></div><p>From here, we write a function that captures the pattern developed
across our examples:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-str-len(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      link(string-length(f), my-str-len(r))
  end
end</code></pre></div></div></section>&#13;
<h5 class="heading">5.2.4.1<span class="stt">Â </span><a name="(part._doubles-eg-code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles</code></span>: Examples and Code<span class="button-group"><a href="#(part._doubles-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>As always, weâ€™ll begin with some examples. Given a list of numbers, we
want a list that doubles each number (in the order of the
original list). Hereâ€™s a reasonable example with three numbers:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is [list: 6, 10, 4]</code></pre></div></div><p>As before, letâ€™s write out the answers for each suffix of our example
list as well, including for the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> list:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list:    5, 2]) is [list:    10, 4]
my-doubles([list:       2]) is [list:        4]
my-doubles([list:        ]) is [list:         ]</code></pre></div></div><p>Now, we rewrite the answer expressions to include the concrete
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> data for each example. Letâ€™s start with
just the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> data, and just on the first example:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is [list: 3 * 2, 10, 4]
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre></div></div><p>Next, letâ€™s include the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> data (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 5, 2]</code></span>) in the
first example. The current answer in the first example is</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, 10, 4]</code></pre></div></div><p>and that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 10, 4]</code></span> is the result of using the function on
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 5, 2]</code></span>. We might therefore be tempted to replace the
right side of the first example with:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, my-doubles([list: 5, 2])]</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">What value would this expression produce? You might want to try this
example that doesnâ€™t use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles</code></span> directly:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3 * 2, [list: 10, 4]]</code></pre></div></div></div></blockquote></blockquote><p>Oops! We want a single (flat) list, not a list-within-a-list. This
feels like it is on the right track in terms of reworking the answer
to use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> values, but weâ€™re clearly not
quite there yet.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">What value does the following expression produce?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link(3 * 2, [list: 10, 4])</code></pre></div></div></div></blockquote></blockquote><p>Notice the difference between the two expressions in these last two
exercises: the latter used <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> to put the value involving
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> into the conversion of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span>, while the former
tried to do this with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list:</code></span>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How many elements are in the lists that result from each of the
following expressions?</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 25, 16, 32]
[list: 25, [list: 16, 32]]
link(25, [list: 16, 32])</code></pre></div></div></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Summarize the difference between how <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list:</code></span>
combine an element and a list. Try additional examples at the
interactions prompt if needed to explore these ideas.</p></blockquote></blockquote><p>The takeaway here is that we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> to <span class="emph">insert an
element into an existing list</span>, whereas we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list:</code></span> to make a
new list that <span class="emph">contains</span> the old list as an element. Going back
to our examples, then, we include <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> in the first example by
writing it as follows:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, [list: 10, 4])
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre></div></div><p>which we then convert to</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is [list:        10, 4]
my-doubles([list:       2]) is [list:            4]
my-doubles([list:        ]) is [list:             ]</code></pre></div></div><p>Applying this idea across the examples, we get:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles([list: 3, 5, 2]) is link(3 * 2, my-doubles([list: 5, 2]))
my-doubles([list:    5, 2]) is link(5 * 2, my-doubles([list: 2]))
my-doubles([list:       2]) is link(2 * 2, my-doubles([list: ]))
my-doubles([list:        ]) is [list:             ]</code></pre></div></div><p>Now that we have examples that explicitly use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> elements, we can produce to write the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles</code></span>
function:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-doubles(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      link(f * 2, my-doubles(r))
  end
end</code></pre></div></div>&#13;
<h5 class="heading">5.2.4.2<span class="stt">Â </span><a name="(part._str-len-eg-code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len</code></span>: Examples and Code<span class="button-group"><a href="#(part._str-len-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">In <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-doubles</code></span>, the input and output lists have the same type of
element. Functions can also produce lists whose contents have a
different type from the input list. Letâ€™s work through an example.
Given a list of strings, we
want the lengths of each string (in the same order as in the input list). Thus, hereâ€™s a
reasonable example:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is [list: 2, 5, 6]</code></pre></div></div></div><div class="SIntrapara">As we have before, we should consider the answers for each
sub-problem of the above example:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list:       "there", "mateys"]) is [list:    5, 6]
my-str-len([list:                "mateys"]) is [list:       6]</code></pre></div></div></div><p/><div class="SIntrapara">Or, in other words:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(2, [list: 5, 6])
my-str-len([list:       "there", "mateys"]) is link(5, [list:    6])
my-str-len([list:                "mateys"]) is link(6, [list:     ])</code></pre></div></div></div><div class="SIntrapara">which tells us that the response for the empty list should be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len(empty) is empty</code></pre></div></div></div><p>The next step is to rework the answers in the examples to make the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> parts explicit. Hopefully by now you are
starting to detect a pattern: The result on the rest of the list
appears explicitly as another example. Therefore, weâ€™ll start by
getting the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> value of each example input into the answer:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(2, my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(5, my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(6, my-str-len([list:                  ]))
my-str-len([list:                        ]) is [list: ]</code></pre></div></div><p>All that remains now is to figure out how to work the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span>
values into the outputs. In the context of this problem, this means we
need to convert <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"hi"</code></span> into <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"there"</code></span> into
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">5</code></span>, and so on. From the problem statement, we know that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">5</code></span> are meant to be the lengths (character counts) of the
corresponding strings. The operation that determines the length of a
string is called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">string-length</code></span>. Thus, our examples appear as:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-str-len([list: "hi", "there", "mateys"]) is link(string-length("hi"), my-str-len([list: "there", "mateys"]))
my-str-len([list:       "there", "mateys"]) is link(string-length("there"), my-str-len([list:          "mateys"]))
my-str-len([list:                "mateys"]) is link(string-length("mateys"), my-str-len([list: ]))
my-str-len([list:                        ]) is [list: ]</code></pre></div></div><p>From here, we write a function that captures the pattern developed
across our examples:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-str-len(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      link(string-length(f), my-str-len(r))
  end
end</code></pre></div></div>&#13;
<h4 class="heading">5.2.5<span class="stt">Â </span><a name="(part._.Structural_.Problems_that_.Select_from_.Lists)"/>Structural Problems that Select from Lists<span class="button-group"><a href="#(part._.Structural_.Problems_that_.Select_from_.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In the previous section, we saw functions that <span class="emph">transform</span> list
elements (by doubling numbers or counting characters). The type of the
output list may or may not be the same as the type of the input
list. Other functions that produce lists instead <span class="emph">select</span>
elements: every element in the output list was in the input list, but
some input-list elements might not appear in the output list. This
section adapts our method of deriving functions from examples to
accommodate selection of elements.</p><section class="SsectionLevel5" id="section 5.2.5.1"><h5 class="heading">5.2.5.1<span class="stt">Â </span><a name="(part._pos-nums-eg-code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums</code></span>: Examples and Code<span class="button-group"><a href="#(part._pos-nums-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>As our first example, we will select the positive numbers from a list
that contains both positive and non-positive numbers.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Construct the sequence of examples that we obtain from the input
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, -2, 3, -4]</code></span>.</p></blockquote></blockquote><p/><div class="SIntrapara">Here we go:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is [list: 1, 3]
my-pos-nums([list:    -2, 3, -4]) is [list:    3]
my-pos-nums([list:        3, -4]) is [list:    3]
my-pos-nums([list:           -4]) is [list:     ]
my-pos-nums([list:             ]) is [list:     ]</code></pre></div></div></div><div class="SIntrapara">We can write this in the following form:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, [list: 3])
my-pos-nums([list:    -2, 3, -4]) is         [list: 3]
my-pos-nums([list:        3, -4]) is link(3, [list: ])
my-pos-nums([list:           -4]) is         [list: ]
my-pos-nums([list:             ]) is         [list: ]</code></pre></div></div></div><div class="SIntrapara">or, even more explicitly,
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])
my-pos-nums([list:             ]) is         [list: ]</code></pre></div></div></div><div class="SIntrapara">Unlike in the example sequences for functions that transform lists,
here we see that the answers have different shapes: some involve a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>, while others simply process the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> of the
list. Whenever we need different shapes of outputs across a set of
examples, we will need an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression in our code to
distinguish the conditions that yield each shape.</div><p/><div class="SIntrapara">What determines which shape of output we get? Letâ€™s rearrange the
examples (other than the empty-list input) by output shape:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))

my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])</code></pre></div></div></div><div class="SIntrapara">Re-organized, we can see that the examples that use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> have a
positive number in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> position, while the ones that
donâ€™t simply process the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> of the list. That indicates that
our <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression needs to ask whether the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> element
in the list is positive. This yields the following program:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-pos-nums(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if f &gt; 0:
        link(f, my-pos-nums(r))
      else:
        my-pos-nums(r)
      end
  end
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Is our set of examples comprehensive?</p></blockquote></blockquote><p>Not really. There are <span class="emph">many</span> examples we havenâ€™t considered, such
as lists that end with positive numbers and lists with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Work through these examples and see how they affect the program!</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.2.5.2"><h5 class="heading">5.2.5.2<span class="stt">Â </span><a name="(part._alternating-eg-code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span>:
Examples and Code<span class="button-group"><a href="#(part._alternating-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Now letâ€™s consider a problem that selects elements not by <span class="emph">value</span>, but
by <span class="emph">position</span>. We want to write a function that selects
alternating elements from a list. Once again, weâ€™re going to work from examples.
</div><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Work out the results for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span> starting from the list
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4, 5, 6]</code></span>.</p></blockquote></blockquote></div><p/><div class="SIntrapara">Hereâ€™s how they work out:
</div><div class="SIntrapara"><a name="(elem._alternating-egs-1)"/>&lt;<span style="font-style: italic">alternating-egs-1</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
  my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
  my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
  my-alternating([list:          4, 5, 6]) is [list:    4, 6]
end</code></pre></div></div></div><div class="SIntrapara">Wait, whatâ€™s that? The two answers above are each correct, but
<span class="emph">the second answer does not help us in any way construct the
first answer</span>. That means the way weâ€™ve solved these problems until
now is not enough for this new kind of problem. Itâ€™s still useful,
though: notice that thereâ€™s a connection between the first example and
the third, as well as between the second example and the fourth. This
observation is consistent with our goal of selecting alternating elements.</div><p>What would something like this look like in code? Before we try to
write the function, letâ€™s rewrite the first example in terms of the
third:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]

my-alternating([list: 1, 2, 3, 4, 5, 6]) is link(1, my-alternating([list: 3, 4, 5, 6]))</code></pre></div></div><p>Note that in the rewritten version, we are dropping <span class="emph">two</span>
elements from the list before using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span> again, not
just one. We will have to figure out how to handle that in our code.</p><p>Letâ€™s start with our usual function pattern with a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>
expression:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; [list:]
    | link(f, r) =&gt; link(f, â€¦ r â€¦)
  end
end</code></pre></div></div><p/><div class="SIntrapara">Note that we cannot simply call <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span> on <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>,
because <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> excludes only one item from the list, not two as this
problem requires. We have to break down <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> as well, in order to
get to the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> of the original list. To do
this, we use another <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expression, nested within the first
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expression:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; [list:]
    | link(f, r) =&gt;
      cases (List) r:  # note: deconstructing r, not l
        | empty =&gt; ??? # note the ???
        | link(fr, rr) =&gt;
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">This code is consistent with the example that we just worked out. But
note that we still have a bit of unfinished work to do: we need to
decide what to do in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> case of the inner <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>
expression (marked by <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">???</code></span> in the code).</div><p>A common temptation at this point is to replace the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">???</code></span> with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list:]</code></span>. After all, havenâ€™t we always returned <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list:]</code></span> in
the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> cases?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Replace <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">???</code></span> with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list:]</code></span> and test the program on our
original examples:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
my-alternating([list:          4, 5, 6]) is [list:    4, 6]</code></pre></div></div></div><div class="SIntrapara">What do you observe?</div></blockquote></blockquote><p>Oops! Weâ€™ve written a program that appears to work on lists with an
even number of elements, but not on lists with an odd number of
elements. How did that happen? The only part of this code that we
guessed at was how to fill in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> case of the inner
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>, so the issue must be there. Rather than focus on the
code, however, <span class="emph">focus on the examples</span>. We need a simple example
that would land on that part of the code. We get to that spot when the
list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l</code></span> is not empty, but <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> (the rest of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l</code></span>) is
empty. In other words, we need an example with only one element.</p><p/><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Finish the following example:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 5]) is ???</code></pre></div></div></div></blockquote></blockquote></div><div class="SIntrapara">Given a list with one element, that element should be included in a
list of alternating elements. Thus, we should finish this example as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 5]) is [list: 5]</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use this example to update the result of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span> when
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> in our code.</p></blockquote></blockquote><p/><div class="SIntrapara">Leveraging this new example, the final version of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span> is as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      cases (List) r: # note: deconstructing r, not l
        | empty =&gt;    # the list has an odd number of elements
          [list: f]
        | link(fr, rr) =&gt;
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end</code></pre></div></div></div><p/><div class="SIntrapara">Whatâ€™s the takeaway from this problem? There are two:
</div><div class="SIntrapara"><ul><li><p>Donâ€™t skip the small examples: the result of a list-processing
function on the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> case wonâ€™t always be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>.</p></li><li><p>If a problem asks you to work with multiple elements from the
front of a list, you can nest <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expressions to access later
elements.</p></li></ul></div><div class="SIntrapara">These takeaways will matter again in future examples: keep an eye out
for them!</div></section>&#13;
<h5 class="heading">5.2.5.1<span class="stt">Â </span><a name="(part._pos-nums-eg-code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums</code></span>: Examples and Code<span class="button-group"><a href="#(part._pos-nums-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>As our first example, we will select the positive numbers from a list
that contains both positive and non-positive numbers.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Construct the sequence of examples that we obtain from the input
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, -2, 3, -4]</code></span>.</p></blockquote></blockquote><p/><div class="SIntrapara">Here we go:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is [list: 1, 3]
my-pos-nums([list:    -2, 3, -4]) is [list:    3]
my-pos-nums([list:        3, -4]) is [list:    3]
my-pos-nums([list:           -4]) is [list:     ]
my-pos-nums([list:             ]) is [list:     ]</code></pre></div></div></div><div class="SIntrapara">We can write this in the following form:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, [list: 3])
my-pos-nums([list:    -2, 3, -4]) is         [list: 3]
my-pos-nums([list:        3, -4]) is link(3, [list: ])
my-pos-nums([list:           -4]) is         [list: ]
my-pos-nums([list:             ]) is         [list: ]</code></pre></div></div></div><div class="SIntrapara">or, even more explicitly,
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])
my-pos-nums([list:             ]) is         [list: ]</code></pre></div></div></div><div class="SIntrapara">Unlike in the example sequences for functions that transform lists,
here we see that the answers have different shapes: some involve a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>, while others simply process the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> of the
list. Whenever we need different shapes of outputs across a set of
examples, we will need an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression in our code to
distinguish the conditions that yield each shape.</div><p/><div class="SIntrapara">What determines which shape of output we get? Letâ€™s rearrange the
examples (other than the empty-list input) by output shape:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-pos-nums([list: 1, -2, 3, -4]) is link(1, my-pos-nums([list: -2, 3, -4]))
my-pos-nums([list:        3, -4]) is link(3, my-pos-nums([list:        -4]))

my-pos-nums([list:    -2, 3, -4]) is         my-pos-nums([list:     3, -4])
my-pos-nums([list:           -4]) is         my-pos-nums([list:          ])</code></pre></div></div></div><div class="SIntrapara">Re-organized, we can see that the examples that use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> have a
positive number in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> position, while the ones that
donâ€™t simply process the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> of the list. That indicates that
our <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression needs to ask whether the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> element
in the list is positive. This yields the following program:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-pos-nums(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if f &gt; 0:
        link(f, my-pos-nums(r))
      else:
        my-pos-nums(r)
      end
  end
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Is our set of examples comprehensive?</p></blockquote></blockquote><p>Not really. There are <span class="emph">many</span> examples we havenâ€™t considered, such
as lists that end with positive numbers and lists with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Work through these examples and see how they affect the program!</p></blockquote></blockquote>&#13;
<h5 class="heading">5.2.5.2<span class="stt">Â </span><a name="(part._alternating-eg-code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span>:
Examples and Code<span class="button-group"><a href="#(part._alternating-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Now letâ€™s consider a problem that selects elements not by <span class="emph">value</span>, but
by <span class="emph">position</span>. We want to write a function that selects
alternating elements from a list. Once again, weâ€™re going to work from examples.
</div><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Work out the results for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span> starting from the list
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4, 5, 6]</code></span>.</p></blockquote></blockquote></div><p/><div class="SIntrapara">Hereâ€™s how they work out:
</div><div class="SIntrapara"><a name="(elem._alternating-egs-1)"/>&lt;<span style="font-style: italic">alternating-egs-1</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
  my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
  my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
  my-alternating([list:          4, 5, 6]) is [list:    4, 6]
end</code></pre></div></div></div><div class="SIntrapara">Wait, whatâ€™s that? The two answers above are each correct, but
<span class="emph">the second answer does not help us in any way construct the
first answer</span>. That means the way weâ€™ve solved these problems until
now is not enough for this new kind of problem. Itâ€™s still useful,
though: notice that thereâ€™s a connection between the first example and
the third, as well as between the second example and the fourth. This
observation is consistent with our goal of selecting alternating elements.</div><p>What would something like this look like in code? Before we try to
write the function, letâ€™s rewrite the first example in terms of the
third:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]

my-alternating([list: 1, 2, 3, 4, 5, 6]) is link(1, my-alternating([list: 3, 4, 5, 6]))</code></pre></div></div><p>Note that in the rewritten version, we are dropping <span class="emph">two</span>
elements from the list before using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span> again, not
just one. We will have to figure out how to handle that in our code.</p><p>Letâ€™s start with our usual function pattern with a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>
expression:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; [list:]
    | link(f, r) =&gt; link(f, â€¦ r â€¦)
  end
end</code></pre></div></div><p/><div class="SIntrapara">Note that we cannot simply call <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span> on <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>,
because <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> excludes only one item from the list, not two as this
problem requires. We have to break down <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> as well, in order to
get to the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span> of the original list. To do
this, we use another <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expression, nested within the first
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expression:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; [list:]
    | link(f, r) =&gt;
      cases (List) r:  # note: deconstructing r, not l
        | empty =&gt; ??? # note the ???
        | link(fr, rr) =&gt;
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">This code is consistent with the example that we just worked out. But
note that we still have a bit of unfinished work to do: we need to
decide what to do in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> case of the inner <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>
expression (marked by <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">???</code></span> in the code).</div><p>A common temptation at this point is to replace the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">???</code></span> with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list:]</code></span>. After all, havenâ€™t we always returned <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list:]</code></span> in
the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> cases?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Replace <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">???</code></span> with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list:]</code></span> and test the program on our
original examples:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 1, 2, 3, 4, 5, 6]) is [list: 1, 3, 5]
my-alternating([list:    2, 3, 4, 5, 6]) is [list: 2, 4, 6]
my-alternating([list:       3, 4, 5, 6]) is [list:    3, 5]
my-alternating([list:          4, 5, 6]) is [list:    4, 6]</code></pre></div></div></div><div class="SIntrapara">What do you observe?</div></blockquote></blockquote><p>Oops! Weâ€™ve written a program that appears to work on lists with an
even number of elements, but not on lists with an odd number of
elements. How did that happen? The only part of this code that we
guessed at was how to fill in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> case of the inner
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span>, so the issue must be there. Rather than focus on the
code, however, <span class="emph">focus on the examples</span>. We need a simple example
that would land on that part of the code. We get to that spot when the
list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l</code></span> is not empty, but <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> (the rest of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l</code></span>) is
empty. In other words, we need an example with only one element.</p><p/><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Finish the following example:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 5]) is ???</code></pre></div></div></div></blockquote></blockquote></div><div class="SIntrapara">Given a list with one element, that element should be included in a
list of alternating elements. Thus, we should finish this example as
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating([list: 5]) is [list: 5]</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use this example to update the result of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span> when
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> in our code.</p></blockquote></blockquote><p/><div class="SIntrapara">Leveraging this new example, the final version of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span> is as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      cases (List) r: # note: deconstructing r, not l
        | empty =&gt;    # the list has an odd number of elements
          [list: f]
        | link(fr, rr) =&gt;
          # fr = first of rest, rr = rest of rest
          link(f, my-alternating(rr))
      end
  end
end</code></pre></div></div></div><p/><div class="SIntrapara">Whatâ€™s the takeaway from this problem? There are two:
</div><div class="SIntrapara"><ul><li><p>Donâ€™t skip the small examples: the result of a list-processing
function on the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> case wonâ€™t always be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>.</p></li><li><p>If a problem asks you to work with multiple elements from the
front of a list, you can nest <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases</code></span> expressions to access later
elements.</p></li></ul></div><div class="SIntrapara">These takeaways will matter again in future examples: keep an eye out
for them!</div>&#13;
<h4 class="heading">5.2.6<span class="stt">Â </span><a name="(part._struct-prob-sub-dom)"/>Structural Problems Over Relaxed Domains<span class="button-group"><a href="#(part._struct-prob-sub-dom)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><section class="SsectionLevel5" id="section 5.2.6.1"><h5 class="heading">5.2.6.1<span class="stt">Â </span><a name="(part._my-max)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>: Examples<span class="button-group"><a href="#(part._my-max)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Now letâ€™s find the maximum value of a list. Letâ€™s assume for
simplicity that weâ€™re dealing with just lists of numbers. What kinds
of lists should we construct? Clearly, we should have empty and
non-empty listsâ€¦but what else? Is a list like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code></span> a
good example? Well, thereâ€™s nothing wrong with it, but we should also
consider lists where the maximum is at the beginning rather than at the
end; the maximum might be in the middle; the maximum might be
repeated; the maximum might be negative; and so on. While not
comprehensive, here is a small but interesting set of examples:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 1, 2, 3]) is 3
my-max([list: 3, 2, 1]) is 3
my-max([list: 2, 3, 1]) is 3
my-max([list: 2, 3, 1, 3, 2]) is 3
my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list: -2, -1, -3]) is -1</code></pre></div></div></div><div class="SIntrapara">What about <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max(empty)</code></span>?
</div><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Could we define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max(empty)</code></span> to be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>? Returning
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span> for the empty list has worked well twice already!</p></blockquote></blockquote></div><div class="SIntrapara">Weâ€™ll return to this in a while.</div><p/><div class="SIntrapara">Before we proceed, itâ€™s useful to know that thereâ€™s a function called
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max</code></span> already defined in Pyret, that compares two numbers:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max(1, 2) is 2
num-max(-1, -2) is -1</code></pre></div></div></div><div class="SIntrapara"><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Suppose <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max</code></span> were not already built in. Can you define it?
You will find what you learned about <a href="Conditionals_and_Booleans.html#%28part._booleans%29" data-pltdoc="x">Booleans</a>
handy. Remember to write some tests!</p></blockquote></blockquote></div><p/><div class="SIntrapara">Now we can look at <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span> at work:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 1, 2, 3]) is 3
my-max([list:    2, 3]) is 3
my-max([list:       3]) is 3</code></pre></div></div></div><div class="SIntrapara">Hmm. That didnâ€™t really teach us anything, did it? Maybe, we canâ€™t be
sure. And we still donâ€™t know what to do with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>.</div><p/><div class="SIntrapara">Letâ€™s try the second example input:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 3, 2, 1]) is 3
my-max([list:    2, 1]) is 2
my-max([list:       1]) is 1</code></pre></div></div></div><div class="SIntrapara">This is actually telling us something useful as well, but maybe we
canâ€™t see it yet. Letâ€™s take on something more ambitious:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list:    1, 4, 3, 2]) is 4
my-max([list:       4, 3, 2]) is 4
my-max([list:          3, 2]) is 3
my-max([list:             2]) is 2</code></pre></div></div></div><div class="SIntrapara">Observe how the maximum of the rest of the list gives us a candidate
answer, but comparing it to the first element gives us a definitive
one:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is num-max(2, 4)
my-max([list:    1, 4, 3, 2]) is num-max(1, 4)
my-max([list:       4, 3, 2]) is num-max(4, 3)
my-max([list:          3, 2]) is num-max(3, 2)
my-max([list:             2]) is â€¦</code></pre></div></div></div><div class="SIntrapara">The last one is a little awkward: weâ€™d like to write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list:             2]) is num-max(2, â€¦)</code></pre></div></div></div><div class="SIntrapara">but we donâ€™t really know what the maximum (or minimum, or any other
element) of the <span class="emph">empty</span> list is, but we can only provide numbers
to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max</code></span>. Therefore, leaving out that dodgy case, weâ€™re left
with
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is num-max(2, my-max([list: 1, 4, 3, 2]))
my-max([list:    1, 4, 3, 2]) is num-max(1, my-max([list:    4, 3, 2]))
my-max([list:       4, 3, 2]) is num-max(4, my-max([list:       3, 2]))
my-max([list:          3, 2]) is num-max(3, my-max([list:          2]))</code></pre></div></div></div><div class="SIntrapara">Our examples have again helped: theyâ€™ve revealed how we can use the
answer for each rest of the list to compute the answer for the whole
list, which in turn is the rest of some other list, and so on. If you
go back and look at the other example lists we wrote above, youâ€™ll see
the pattern holds there too.</div><p/><div class="SIntrapara">However, itâ€™s time we now confront the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> case. The real
problem is that we donâ€™t have a maximum for the empty list: for any
number we might provide, there is always a number bigger than it
(assuming our computer is large enough) that could have been the
answer instead. In short, itâ€™s nonsensical to ask for the maximum (or
minimum) of the empty list: the concept of â€œmaximumâ€ is only defined
on non-empty lists! That is, when asked for the maximum of an empty
list, we should signal an error:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max(empty) raises ""</code></pre></div></div></div><div class="SIntrapara">(which is how, in Pyret, we say that it will generate an error; we
donâ€™t care about the details of the error, hence the empty string).</div></section><section class="SsectionLevel5" id="section 5.2.6.2"><h5 class="heading">5.2.6.2<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>: From Examples to Code<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Once again, we can codify the examples above, i.e., turn them into a
uniform program that works for all instances. However, we now have a
twist. If we blindly followed the pattern weâ€™ve used earlier, we would
end up with:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt; num-max(f, my-max(r))
  end
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Whatâ€™s wrong with this?</p></blockquote></blockquote><p/><div class="SIntrapara">Consider the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 2]</code></span>. This turns into
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max(2, my-max([list: ]))</code></pre></div></div></div><div class="SIntrapara">which of course raises an error. Therefore, this function never works
for any list that has one or more elements!</div><p/><div class="SIntrapara">Thatâ€™s because we need to make sure we arenâ€™t trying to compute the
maximum of the empty list.
Going back to our examples, we see that what we need to do, before
calling <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>, is check whether the rest of the list is
empty. If it is, we do not want to call <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span> at all. That is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; â€¦
        | â€¦
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">Weâ€™ll return to what to do when the rest is not empty in a moment.</div><p/><div class="SIntrapara">If the rest of the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l</code></span> is empty, our examples above tell us
that the maximum is the first element in the list. Therefore, we can
fill this in:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; f
        | â€¦
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">Note in particular the absence of a call to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>. If the list
is not empty, however, our examples above tell us that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>
will give us the maximum of the rest of the list, and we just need to
compare this answer with the first element (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span>):
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; f
        | else  =&gt; num-max(f, my-max(r))
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">And sure enough, this definition does the job!</div></section>&#13;
<h5 class="heading">5.2.6.1<span class="stt">Â </span><a name="(part._my-max)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>: Examples<span class="button-group"><a href="#(part._my-max)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Now letâ€™s find the maximum value of a list. Letâ€™s assume for
simplicity that weâ€™re dealing with just lists of numbers. What kinds
of lists should we construct? Clearly, we should have empty and
non-empty listsâ€¦but what else? Is a list like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code></span> a
good example? Well, thereâ€™s nothing wrong with it, but we should also
consider lists where the maximum is at the beginning rather than at the
end; the maximum might be in the middle; the maximum might be
repeated; the maximum might be negative; and so on. While not
comprehensive, here is a small but interesting set of examples:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 1, 2, 3]) is 3
my-max([list: 3, 2, 1]) is 3
my-max([list: 2, 3, 1]) is 3
my-max([list: 2, 3, 1, 3, 2]) is 3
my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list: -2, -1, -3]) is -1</code></pre></div></div></div><div class="SIntrapara">What about <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max(empty)</code></span>?
</div><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Could we define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max(empty)</code></span> to be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>? Returning
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span> for the empty list has worked well twice already!</p></blockquote></blockquote></div><div class="SIntrapara">Weâ€™ll return to this in a while.</div><p/><div class="SIntrapara">Before we proceed, itâ€™s useful to know that thereâ€™s a function called
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max</code></span> already defined in Pyret, that compares two numbers:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max(1, 2) is 2
num-max(-1, -2) is -1</code></pre></div></div></div><div class="SIntrapara"><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Suppose <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max</code></span> were not already built in. Can you define it?
You will find what you learned about <a href="Conditionals_and_Booleans.html#%28part._booleans%29" data-pltdoc="x">Booleans</a>
handy. Remember to write some tests!</p></blockquote></blockquote></div><p/><div class="SIntrapara">Now we can look at <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span> at work:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 1, 2, 3]) is 3
my-max([list:    2, 3]) is 3
my-max([list:       3]) is 3</code></pre></div></div></div><div class="SIntrapara">Hmm. That didnâ€™t really teach us anything, did it? Maybe, we canâ€™t be
sure. And we still donâ€™t know what to do with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span>.</div><p/><div class="SIntrapara">Letâ€™s try the second example input:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 3, 2, 1]) is 3
my-max([list:    2, 1]) is 2
my-max([list:       1]) is 1</code></pre></div></div></div><div class="SIntrapara">This is actually telling us something useful as well, but maybe we
canâ€™t see it yet. Letâ€™s take on something more ambitious:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is 4
my-max([list:    1, 4, 3, 2]) is 4
my-max([list:       4, 3, 2]) is 4
my-max([list:          3, 2]) is 3
my-max([list:             2]) is 2</code></pre></div></div></div><div class="SIntrapara">Observe how the maximum of the rest of the list gives us a candidate
answer, but comparing it to the first element gives us a definitive
one:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is num-max(2, 4)
my-max([list:    1, 4, 3, 2]) is num-max(1, 4)
my-max([list:       4, 3, 2]) is num-max(4, 3)
my-max([list:          3, 2]) is num-max(3, 2)
my-max([list:             2]) is â€¦</code></pre></div></div></div><div class="SIntrapara">The last one is a little awkward: weâ€™d like to write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list:             2]) is num-max(2, â€¦)</code></pre></div></div></div><div class="SIntrapara">but we donâ€™t really know what the maximum (or minimum, or any other
element) of the <span class="emph">empty</span> list is, but we can only provide numbers
to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max</code></span>. Therefore, leaving out that dodgy case, weâ€™re left
with
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max([list: 2, 1, 4, 3, 2]) is num-max(2, my-max([list: 1, 4, 3, 2]))
my-max([list:    1, 4, 3, 2]) is num-max(1, my-max([list:    4, 3, 2]))
my-max([list:       4, 3, 2]) is num-max(4, my-max([list:       3, 2]))
my-max([list:          3, 2]) is num-max(3, my-max([list:          2]))</code></pre></div></div></div><div class="SIntrapara">Our examples have again helped: theyâ€™ve revealed how we can use the
answer for each rest of the list to compute the answer for the whole
list, which in turn is the rest of some other list, and so on. If you
go back and look at the other example lists we wrote above, youâ€™ll see
the pattern holds there too.</div><p/><div class="SIntrapara">However, itâ€™s time we now confront the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> case. The real
problem is that we donâ€™t have a maximum for the empty list: for any
number we might provide, there is always a number bigger than it
(assuming our computer is large enough) that could have been the
answer instead. In short, itâ€™s nonsensical to ask for the maximum (or
minimum) of the empty list: the concept of â€œmaximumâ€ is only defined
on non-empty lists! That is, when asked for the maximum of an empty
list, we should signal an error:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max(empty) raises ""</code></pre></div></div></div><div class="SIntrapara">(which is how, in Pyret, we say that it will generate an error; we
donâ€™t care about the details of the error, hence the empty string).</div>&#13;
<h5 class="heading">5.2.6.2<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>: From Examples to Code<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Once again, we can codify the examples above, i.e., turn them into a
uniform program that works for all instances. However, we now have a
twist. If we blindly followed the pattern weâ€™ve used earlier, we would
end up with:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt; num-max(f, my-max(r))
  end
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Whatâ€™s wrong with this?</p></blockquote></blockquote><p/><div class="SIntrapara">Consider the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 2]</code></span>. This turns into
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-max(2, my-max([list: ]))</code></pre></div></div></div><div class="SIntrapara">which of course raises an error. Therefore, this function never works
for any list that has one or more elements!</div><p/><div class="SIntrapara">Thatâ€™s because we need to make sure we arenâ€™t trying to compute the
maximum of the empty list.
Going back to our examples, we see that what we need to do, before
calling <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>, is check whether the rest of the list is
empty. If it is, we do not want to call <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span> at all. That is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; â€¦
        | â€¦
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">Weâ€™ll return to what to do when the rest is not empty in a moment.</div><p/><div class="SIntrapara">If the rest of the list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">l</code></span> is empty, our examples above tell us
that the maximum is the first element in the list. Therefore, we can
fill this in:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; f
        | â€¦
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">Note in particular the absence of a call to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>. If the list
is not empty, however, our examples above tell us that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>
will give us the maximum of the rest of the list, and we just need to
compare this answer with the first element (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span>):
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max(l):
  cases (List) l:
    | empty      =&gt; raise("not defined for empty lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; f
        | else  =&gt; num-max(f, my-max(r))
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">And sure enough, this definition does the job!</div>&#13;
<h4 class="heading">5.2.7<span class="stt">Â </span><a name="(part._.More_.Structural_.Problems_with_.Scalar_.Answers)"/>More Structural Problems with Scalar Answers<span class="button-group"><a href="#(part._.More_.Structural_.Problems_with_.Scalar_.Answers)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><section class="SsectionLevel5" id="section 5.2.7.1"><h5 class="heading">5.2.7.1<span class="stt">Â </span><a name="(part._avg-eg)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-avg</code></span>: Examples<span class="button-group"><a href="#(part._avg-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Letâ€™s now try to compute the average of a list of numbers. Letâ€™s start
with the example list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4]</code></span> and work out more
examples from it. The average of numbers in this list is clearly
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(1 + 2 + 3 + 4)/4</code></span>, or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">10/4</code></span>.</p><p/><div class="SIntrapara">Based on the listâ€™s structure, we see that the rest of the list is
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 2, 3, 4]</code></span>, and the rest of that is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3, 4]</code></span>,
and so on. The resulting averages are:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-avg([list: 1, 2, 3, 4]) is 10/4
my-avg([list:    2, 3, 4]) is 9/3
my-avg([list:       3, 4]) is 7/2
my-avg([list:          4]) is 4/1</code></pre></div></div></div><div class="SIntrapara">The problem is, itâ€™s simply not clear how we get from the answer for
the sub-list to the answer for the whole list. That is, given the
following two bits of information:
</div><div class="SIntrapara"><ul><li><p>The average of the remainder of the list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">9/3</code></span>, i.e.,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>.</p></li><li><p>The first number in the list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>.</p></li></ul></div><div class="SIntrapara">How do we determine that the average of the whole list must be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">10/4</code></span>? If itâ€™s not clear to you, donâ€™t worry: with just those
two pieces of information, itâ€™s <span class="emph">impossible</span>!</div><p/><div class="SIntrapara">Hereâ€™s a simpler example that explains why. Letâ€™s suppose the first
value in a list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>, and the average of the rest of the list
is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>. Here are two very different lists that fit this
description:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2]    # the rest has one element with sum 2
[list: 1, 4, 0] # the rest has two elements with sum 4</code></pre></div></div></div><div class="SIntrapara">The average of the entire first list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3/2</code></span>, while the average
of the entire second list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">5/3</code></span>, and the two are not the same.</div><p>That is, to compute the average of a whole list, itâ€™s not even useful to
know the <span class="emph">average</span> of the rest of the list. Rather, we need to
know the <span class="emph">sum</span> and the <span class="emph">length</span> of the rest of the
list. With these two, we can add the first to the sum, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> to
the length, and compute the new average.</p><p/><div class="SIntrapara">In principle, we could try to make a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">average</code></span> function that
returns all this information. Instead, it will be a lot simpler to
simply <span style="font-style: italic">decompose</span> the task into two smaller tasks. After all, we
have already seen how to compute the length and how to compute the
sum. The average, therefore, can just use these existing functions:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-avg(l):
  my-sum(l) / my-len(l)
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What should be the average of the empty list? Does the above code
produce what you would expect?</p></blockquote></blockquote><p>Just as we argued earlier about the maximum
[<a href="#%28part._struct-prob-sub-dom%29" data-pltdoc="x">Structural Problems Over Relaxed Domains</a>], the average of the empty list isnâ€™t
a well-defined concept. Therefore, it would be appropriate to signal
an error. The implementation above does this, but poorly: it reports
an error on division. A better programming practice would be to
catch this situation and report the error right away, rather than
hoping some other function will report the error.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Alter <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-avg</code></span> above to signal an error when given the empty
list.</p></blockquote></blockquote><p>Therefore, we see that the process weâ€™ve usedâ€”<wbr/>of inferring code from
examplesâ€”<wbr/>wonâ€™t always suffice, and weâ€™ll need more
sophisticated techniques to solve some problems. However, notice that
working from examples helps us quickly <span class="emph">identify</span> situations
where this approach does and doesnâ€™t work. Furthermore, if you look
more closely youâ€™ll notice that the examples above <span class="emph">do</span> hint at
how to solve the problem: in our very first examples, we wrote answers
like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">10/4</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">9/3</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7/2</code></span>, which correspond to the
sum of the numbers divided by the length. Thus, writing the answers in
this form (as opposed, for instance, to writing the second of those as
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>) already reveals a structure for a solution.</p></section>&#13;
<h5 class="heading">5.2.7.1<span class="stt">Â </span><a name="(part._avg-eg)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-avg</code></span>: Examples<span class="button-group"><a href="#(part._avg-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Letâ€™s now try to compute the average of a list of numbers. Letâ€™s start
with the example list <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4]</code></span> and work out more
examples from it. The average of numbers in this list is clearly
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">(1 + 2 + 3 + 4)/4</code></span>, or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">10/4</code></span>.</p><p/><div class="SIntrapara">Based on the listâ€™s structure, we see that the rest of the list is
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 2, 3, 4]</code></span>, and the rest of that is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 3, 4]</code></span>,
and so on. The resulting averages are:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-avg([list: 1, 2, 3, 4]) is 10/4
my-avg([list:    2, 3, 4]) is 9/3
my-avg([list:       3, 4]) is 7/2
my-avg([list:          4]) is 4/1</code></pre></div></div></div><div class="SIntrapara">The problem is, itâ€™s simply not clear how we get from the answer for
the sub-list to the answer for the whole list. That is, given the
following two bits of information:
</div><div class="SIntrapara"><ul><li><p>The average of the remainder of the list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">9/3</code></span>, i.e.,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>.</p></li><li><p>The first number in the list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>.</p></li></ul></div><div class="SIntrapara">How do we determine that the average of the whole list must be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">10/4</code></span>? If itâ€™s not clear to you, donâ€™t worry: with just those
two pieces of information, itâ€™s <span class="emph">impossible</span>!</div><p/><div class="SIntrapara">Hereâ€™s a simpler example that explains why. Letâ€™s suppose the first
value in a list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>, and the average of the rest of the list
is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>. Here are two very different lists that fit this
description:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2]    # the rest has one element with sum 2
[list: 1, 4, 0] # the rest has two elements with sum 4</code></pre></div></div></div><div class="SIntrapara">The average of the entire first list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3/2</code></span>, while the average
of the entire second list is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">5/3</code></span>, and the two are not the same.</div><p>That is, to compute the average of a whole list, itâ€™s not even useful to
know the <span class="emph">average</span> of the rest of the list. Rather, we need to
know the <span class="emph">sum</span> and the <span class="emph">length</span> of the rest of the
list. With these two, we can add the first to the sum, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> to
the length, and compute the new average.</p><p/><div class="SIntrapara">In principle, we could try to make a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">average</code></span> function that
returns all this information. Instead, it will be a lot simpler to
simply <span style="font-style: italic">decompose</span> the task into two smaller tasks. After all, we
have already seen how to compute the length and how to compute the
sum. The average, therefore, can just use these existing functions:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-avg(l):
  my-sum(l) / my-len(l)
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What should be the average of the empty list? Does the above code
produce what you would expect?</p></blockquote></blockquote><p>Just as we argued earlier about the maximum
[<a href="#%28part._struct-prob-sub-dom%29" data-pltdoc="x">Structural Problems Over Relaxed Domains</a>], the average of the empty list isnâ€™t
a well-defined concept. Therefore, it would be appropriate to signal
an error. The implementation above does this, but poorly: it reports
an error on division. A better programming practice would be to
catch this situation and report the error right away, rather than
hoping some other function will report the error.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Alter <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-avg</code></span> above to signal an error when given the empty
list.</p></blockquote></blockquote><p>Therefore, we see that the process weâ€™ve usedâ€”<wbr/>of inferring code from
examplesâ€”<wbr/>wonâ€™t always suffice, and weâ€™ll need more
sophisticated techniques to solve some problems. However, notice that
working from examples helps us quickly <span class="emph">identify</span> situations
where this approach does and doesnâ€™t work. Furthermore, if you look
more closely youâ€™ll notice that the examples above <span class="emph">do</span> hint at
how to solve the problem: in our very first examples, we wrote answers
like <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">10/4</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">9/3</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7/2</code></span>, which correspond to the
sum of the numbers divided by the length. Thus, writing the answers in
this form (as opposed, for instance, to writing the second of those as
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>) already reveals a structure for a solution.</p>&#13;
<h4 class="heading">5.2.8<span class="stt">Â </span><a name="(part._accumulators)"/>Structural Problems with Accumulators<span class="button-group"><a href="#(part._accumulators)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><section class="SsectionLevel5" id="section 5.2.8.1"><h5 class="heading">5.2.8.1<span class="stt">Â </span><a name="(part._running-sum-1st-attempt)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>: First Attempt<span class="button-group"><a href="#(part._running-sum-1st-attempt)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>One more time, weâ€™ll begin with an example.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Work out the results for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span> starting from the list
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4, 5]</code></span>.</p></blockquote></blockquote><p/><div class="SIntrapara">Hereâ€™s what our first few examples look like:
</div><div class="SIntrapara"><a name="(elem._running-sum-egs-1)"/>&lt;<span style="font-style: italic">running-sum-egs-1</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
  my-running-sum([list:    2, 3, 4, 5]) is [list: 2, 5, 9, 14]
  my-running-sum([list:       3, 4, 5]) is [list: 3, 7, 12]
end</code></pre></div></div></div><div class="SIntrapara">Again, there doesnâ€™t appear to be any clear connection between the
result on the rest of the list and the result on the entire list.</div><p/><div class="SIntrapara">(That isnâ€™t strictly true: we can still line up the answers as
follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
my-running-sum([list:    2, 3, 4, 5]) is [list:    2, 5,  9, 14]
my-running-sum([list:       3, 4, 5]) is [list:       3,  7, 12]</code></pre></div></div></div><div class="SIntrapara">and observe that weâ€™re computing the answer for the rest of the list,
then adding the first element to each element in the answer, and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>ing the first element to the front. In principle, we can
compute this solution directly, but for
now that may be more work than finding a simpler way to answer it.)</div></section><section class="SsectionLevel5" id="section 5.2.8.2"><h5 class="heading">5.2.8.2<span class="stt">Â </span><a name="(part._running-sum-eg-code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>: Examples and Code<span class="button-group"><a href="#(part._running-sum-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Recall how we began in <a href="#%28part._running-sum-1st-attempt%29" data-pltdoc="x"><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>: First Attempt</a>. Our
examples [<a href="#%28elem._running-sum-egs-1%29" data-pltdoc="x">&lt;<span style="font-style: italic">running-sum-egs-1</span>&gt;</a>] showed the following
problem. When we process the rest of the list, we have forgotten
everything about what preceded it. That is, when processing the list
starting at <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span> we forget that weâ€™ve seen a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> earlier;
when starting from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>, we forget that weâ€™ve seen both <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span> earlier; and so on. In other words, we keep
<span class="emph">forgetting</span> the past. We need some way of avoiding that.</p><p/><div class="SIntrapara">The easiest thing we can do is simply change our function to carry
along this â€œmemoryâ€, or what weâ€™ll call an <span style="font-style: italic">accumulator</span>. That
is, imagine we were defining a new function, called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs</code></span>. It
will consume a list of numbers and produce a list of numbers, but in
addition it will <span class="emph">also take the sum of numbers preceding the
current list</span>.
</div><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What should the initial sum be?</p></blockquote></blockquote></div><div class="SIntrapara">Initially there is no â€œpreceding listâ€, so we will use the additive
identity: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>. The type of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs</code></span> is
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs :: Number, List&lt;Number&gt; -&gt; List&lt;Number&gt;</code></pre></div></div></div><p/><div class="SIntrapara">Letâ€™s now re-work our examples from <a href="#%28elem._running-sum-egs-1%29" data-pltdoc="x">&lt;<span style="font-style: italic">running-sum-egs-1</span>&gt;</a> as
examples of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs</code></span> instead. The examples use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span>
operator to append two lists into one (the elements of the first list
followed by the elements of the second):
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs( 0, [list: 1, 2, 3, 4, 5]) is [list:  0 + 1] + my-rs( 0 + 1, [list: 2, 3, 4, 5])
my-rs( 1, [list:    2, 3, 4, 5]) is [list:  1 + 2] + my-rs( 1 + 2, [list:    3, 4, 5])
my-rs( 3, [list:       3, 4, 5]) is [list:  3 + 3] + my-rs( 3 + 3, [list:       4, 5])
my-rs( 6, [list:          4, 5]) is [list:  6 + 4] + my-rs( 6 + 4, [list:          5])
my-rs(10, [list:             5]) is [list: 10 + 5] + my-rs(10 + 5, [list:           ])
my-rs(15, [list:              ]) is empty</code></pre></div></div></div><div class="SIntrapara">That is, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs</code></span> translates into the following code:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-rs(acc, l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      new-sum = acc + f
      link(new-sum, my-rs(new-sum, r))
  end
end</code></pre></div></div></div><div class="SIntrapara">All thatâ€™s then left is to call it from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-running-sum(l):
  my-rs(0, l)
end</code></pre></div></div></div><p>Observe that we do not change <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span> itself to take
extra arguments. The correctness of our code depends on the initial
value of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acc</code></span> being 0. If we added a parameter for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acc</code></span>,
any code that calls <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span> could supply an unexpected
value, which would distort the result. In addition, since the value is
fixed, adding the parameter would amount to shifting additional (and
needless) work onto others who use our code.</p></section><section class="SsectionLevel5" id="section 5.2.8.3"><h5 class="heading">5.2.8.3<span class="stt">Â </span><a name="(part._alternating-accumulator)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span>: Examples and Code<span class="button-group"><a href="#(part._alternating-accumulator)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Recall our examples in <a href="#%28part._alternating-eg-code%29" data-pltdoc="x"><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span>:
Examples and Code</a>. There, we
noticed that the code built on every-other example. We might have
chosen our examples differently, so that from one example to the next
we skipped two elements rather than one.
Here we will see another way to think about the same problem.</p><p/><div class="SIntrapara">Return to the examples weâ€™ve already seen
[<a href="#%28elem._alternating-egs-1%29" data-pltdoc="x">&lt;<span style="font-style: italic">alternating-egs-1</span>&gt;</a>]. We wrote <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span>
to traverse the list essentially two elements at a time. Another option is to traverse it just one
element at a time, but <span class="emph">keeping track of whether weâ€™re at an odd
or even element</span>â€”<wbr/>i.e., add â€œmemoryâ€ to our program. Since we just
need to track that one piece of information, we can use a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Boolean</code></span> to do it. Letâ€™s define a new function for this purpose:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alt :: List&lt;Any&gt;, Boolean -&gt; List&lt;Any&gt;</code></pre></div></div></div><div class="SIntrapara">The extra argument accumulates whether weâ€™re at an element to keep or
one to discard.</div><p/><div class="SIntrapara">We can reuse the existing template for list functions. When we have an
element, we have to consult the accumulator whether to keep it or
not. If its value is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> we <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> it to the answer;
otherwise we ignore it. As we process the rest of the list, however,
we have to remember to update the accumulator: if we kept an element
we donâ€™t wish to keep the next one, and vice versa.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alt(l, keep):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if keep:
        link(f, my-alt(r, false))
      else:
        my-alt(r, true)
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">Finally, we have to determine the initial value of the accumulator. In
this case, since we want to keep alternating elements <span class="emph">starting
with the first one</span>, its initial value should be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  my-alt(l, true)
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span> using an accumulator. What does the accumulator
represent? Do you encounter any difficulty?</p></blockquote></blockquote></section>&#13;
<h5 class="heading">5.2.8.1<span class="stt">Â </span><a name="(part._running-sum-1st-attempt)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>: First Attempt<span class="button-group"><a href="#(part._running-sum-1st-attempt)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>One more time, weâ€™ll begin with an example.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Work out the results for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span> starting from the list
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3, 4, 5]</code></span>.</p></blockquote></blockquote><p/><div class="SIntrapara">Hereâ€™s what our first few examples look like:
</div><div class="SIntrapara"><a name="(elem._running-sum-egs-1)"/>&lt;<span style="font-style: italic">running-sum-egs-1</span>&gt; ::=</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
  my-running-sum([list:    2, 3, 4, 5]) is [list: 2, 5, 9, 14]
  my-running-sum([list:       3, 4, 5]) is [list: 3, 7, 12]
end</code></pre></div></div></div><div class="SIntrapara">Again, there doesnâ€™t appear to be any clear connection between the
result on the rest of the list and the result on the entire list.</div><p/><div class="SIntrapara">(That isnâ€™t strictly true: we can still line up the answers as
follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum([list: 1, 2, 3, 4, 5]) is [list: 1, 3, 6, 10, 15]
my-running-sum([list:    2, 3, 4, 5]) is [list:    2, 5,  9, 14]
my-running-sum([list:       3, 4, 5]) is [list:       3,  7, 12]</code></pre></div></div></div><div class="SIntrapara">and observe that weâ€™re computing the answer for the rest of the list,
then adding the first element to each element in the answer, and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>ing the first element to the front. In principle, we can
compute this solution directly, but for
now that may be more work than finding a simpler way to answer it.)</div>&#13;
<h5 class="heading">5.2.8.2<span class="stt">Â </span><a name="(part._running-sum-eg-code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>: Examples and Code<span class="button-group"><a href="#(part._running-sum-eg-code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Recall how we began in <a href="#%28part._running-sum-1st-attempt%29" data-pltdoc="x"><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>: First Attempt</a>. Our
examples [<a href="#%28elem._running-sum-egs-1%29" data-pltdoc="x">&lt;<span style="font-style: italic">running-sum-egs-1</span>&gt;</a>] showed the following
problem. When we process the rest of the list, we have forgotten
everything about what preceded it. That is, when processing the list
starting at <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span> we forget that weâ€™ve seen a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> earlier;
when starting from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>, we forget that weâ€™ve seen both <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span> earlier; and so on. In other words, we keep
<span class="emph">forgetting</span> the past. We need some way of avoiding that.</p><p/><div class="SIntrapara">The easiest thing we can do is simply change our function to carry
along this â€œmemoryâ€, or what weâ€™ll call an <span style="font-style: italic">accumulator</span>. That
is, imagine we were defining a new function, called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs</code></span>. It
will consume a list of numbers and produce a list of numbers, but in
addition it will <span class="emph">also take the sum of numbers preceding the
current list</span>.
</div><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What should the initial sum be?</p></blockquote></blockquote></div><div class="SIntrapara">Initially there is no â€œpreceding listâ€, so we will use the additive
identity: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0</code></span>. The type of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs</code></span> is
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs :: Number, List&lt;Number&gt; -&gt; List&lt;Number&gt;</code></pre></div></div></div><p/><div class="SIntrapara">Letâ€™s now re-work our examples from <a href="#%28elem._running-sum-egs-1%29" data-pltdoc="x">&lt;<span style="font-style: italic">running-sum-egs-1</span>&gt;</a> as
examples of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs</code></span> instead. The examples use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span>
operator to append two lists into one (the elements of the first list
followed by the elements of the second):
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs( 0, [list: 1, 2, 3, 4, 5]) is [list:  0 + 1] + my-rs( 0 + 1, [list: 2, 3, 4, 5])
my-rs( 1, [list:    2, 3, 4, 5]) is [list:  1 + 2] + my-rs( 1 + 2, [list:    3, 4, 5])
my-rs( 3, [list:       3, 4, 5]) is [list:  3 + 3] + my-rs( 3 + 3, [list:       4, 5])
my-rs( 6, [list:          4, 5]) is [list:  6 + 4] + my-rs( 6 + 4, [list:          5])
my-rs(10, [list:             5]) is [list: 10 + 5] + my-rs(10 + 5, [list:           ])
my-rs(15, [list:              ]) is empty</code></pre></div></div></div><div class="SIntrapara">That is, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-rs</code></span> translates into the following code:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-rs(acc, l):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      new-sum = acc + f
      link(new-sum, my-rs(new-sum, r))
  end
end</code></pre></div></div></div><div class="SIntrapara">All thatâ€™s then left is to call it from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-running-sum(l):
  my-rs(0, l)
end</code></pre></div></div></div><p>Observe that we do not change <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span> itself to take
extra arguments. The correctness of our code depends on the initial
value of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acc</code></span> being 0. If we added a parameter for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acc</code></span>,
any code that calls <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span> could supply an unexpected
value, which would distort the result. In addition, since the value is
fixed, adding the parameter would amount to shifting additional (and
needless) work onto others who use our code.</p>&#13;
<h5 class="heading">5.2.8.3<span class="stt">Â </span><a name="(part._alternating-accumulator)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span>: Examples and Code<span class="button-group"><a href="#(part._alternating-accumulator)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Recall our examples in <a href="#%28part._alternating-eg-code%29" data-pltdoc="x"><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span>:
Examples and Code</a>. There, we
noticed that the code built on every-other example. We might have
chosen our examples differently, so that from one example to the next
we skipped two elements rather than one.
Here we will see another way to think about the same problem.</p><p/><div class="SIntrapara">Return to the examples weâ€™ve already seen
[<a href="#%28elem._alternating-egs-1%29" data-pltdoc="x">&lt;<span style="font-style: italic">alternating-egs-1</span>&gt;</a>]. We wrote <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alternating</code></span>
to traverse the list essentially two elements at a time. Another option is to traverse it just one
element at a time, but <span class="emph">keeping track of whether weâ€™re at an odd
or even element</span>â€”<wbr/>i.e., add â€œmemoryâ€ to our program. Since we just
need to track that one piece of information, we can use a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Boolean</code></span> to do it. Letâ€™s define a new function for this purpose:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-alt :: List&lt;Any&gt;, Boolean -&gt; List&lt;Any&gt;</code></pre></div></div></div><div class="SIntrapara">The extra argument accumulates whether weâ€™re at an element to keep or
one to discard.</div><p/><div class="SIntrapara">We can reuse the existing template for list functions. When we have an
element, we have to consult the accumulator whether to keep it or
not. If its value is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> we <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> it to the answer;
otherwise we ignore it. As we process the rest of the list, however,
we have to remember to update the accumulator: if we kept an element
we donâ€™t wish to keep the next one, and vice versa.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alt(l, keep):
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if keep:
        link(f, my-alt(r, false))
      else:
        my-alt(r, true)
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">Finally, we have to determine the initial value of the accumulator. In
this case, since we want to keep alternating elements <span class="emph">starting
with the first one</span>, its initial value should be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-alternating(l):
  my-alt(l, true)
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span> using an accumulator. What does the accumulator
represent? Do you encounter any difficulty?</p></blockquote></blockquote>&#13;
<h4 class="heading">5.2.9<span class="stt">Â </span><a name="(part._.Dealing_with_.Multiple_.Answers)"/>Dealing with Multiple Answers<span class="button-group"><a href="#(part._.Dealing_with_.Multiple_.Answers)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Our discussion above has assumed there is only one answer for a given
input. This is often true, but it also depends on how the problem is
worded and how we choose to generate examples. We will study this in
some detail now.</p><section class="SsectionLevel5" id="section 5.2.9.1"><h5 class="heading">5.2.9.1<span class="stt">Â </span><a name="(part._uniq)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Problem Setup<span class="button-group"><a href="#(part._uniq)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Consider the task of writing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>:<span class="refelem"><span class="refcolumn"><span class="refcontent"><span class="stt">uniq</span> is the
name of a Unix utility with similar behavior; hence the spelling of
the name.</span></span></span> given a list of values, it produces a collection of the
same elements while avoiding any duplicates (hence <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>, short
for â€œuniqueâ€).</p><p>Consider the following input: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 1, 3, 1, 2, 4, 1]</code></span>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What is the sequence of examples this input generates?  Itâ€™s
<span class="emph">really important</span> you stop and try to do this by hand. As we
will see there are multiple solutions, and itâ€™s useful for you to
consider what you generate. Even if you canâ€™t generate a sequence,
trying to do so will better prepare you for what you read next.</p></blockquote></blockquote><p>How did you obtain your example? If you just â€œthought about it for a
moment and wrote something downâ€, you may or may not have gotten
something you can turn into a program. Programs can only proceed
systematically; they canâ€™t â€œthinkâ€. So, hopefully you took a
well-defined path to computing the answer.</p></section><section class="SsectionLevel5" id="section 5.2.9.2"><h5 class="heading">5.2.9.2<span class="stt">Â </span><a name="(part._uniq-eg)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Examples<span class="button-group"><a href="#(part._uniq-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>It turns out there are <span class="emph">several</span> possible answers, because we
have (intentionally) left the problem unspecified. Suppose there are
two instances of a value in the list; which one do we keep, the first
or the second? On the one hand, since the two instances must be
equivalent it doesnâ€™t matter, but it does for writing concrete
examples and deriving a solution.</p><p/><div class="SIntrapara">For instance, you might have generated this sequence:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">examples:
  uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:    2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:       1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:          3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:             1, 2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                   4, 1]) is [list:       4, 1]
  uniq([list:                      1]) is [list:          1]
  uniq([list:                       ]) is [list:           ]
end</code></pre></div></div></div><div class="SIntrapara">However, you might have also generated sequences that began with
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 1, 2, 3, 4]</code></pre></div></div></div><div class="SIntrapara">or
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 4, 3, 2, 1]</code></pre></div></div></div><div class="SIntrapara">and so on. Letâ€™s work with the examples weâ€™ve worked out above.</div></section><section class="SsectionLevel5" id="section 5.2.9.3"><h5 class="heading">5.2.9.3<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Code<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>What is the <span class="emph">systematic</span> approach that gets us to this answer?
When given a non-empty list, we split it into its first element and
the rest of the list. Suppose we have the answer to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>
applied to the rest of the list. Now we can ask: is the first element
in the rest of the list? If it is, then we can ignore it, since it is
certain to be in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> of the rest of the list. If, however,
it is not in the rest of the list, itâ€™s critical that we <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>
it to the answer.</p><p>This translates into the following program. For the empty list, we
return the empty list. If the list is non-empty, we check whether the
first is in the rest of the list. If it is <span class="emph">not</span>, we include it;
otherwise we can ignore it for now.</p><p/><div class="SIntrapara">This results in the following program:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if r.member(f):
        uniq-rec(r)
      else:
        link(f, uniq-rec(r))
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">which weâ€™ve called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq-rec</code></span> instead of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> to
differentiate it from other versions of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Note that weâ€™re using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.member</code></span> to check whether an element is a
member of the list. Write a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member</code></span> that consumes an
element and a list, and tells us whether the element is a member of
the list.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Uniqueness checking has many practical applications. For example, one
might have a list of names of people who have registered to vote in an
election. To keep the voting fair, with only one vote allowed per
person, we should remove duplicate names from the list.</p><ol><li><p>Propose a set of examples for a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rem-duplicate-voters</code></span>
that takes a list of voter names and returns a list in which duplicate
registrations have been removed. In developing your examples, consider
real-world scenarios that you can imagine arising when identifying
duplicate names. Can you identify cases in which two names
might appear to be the same person, but not be? Cases in which two
names might appear different but be referring to the same person?</p></li><li><p>What might you need to change about our current <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq-rec</code></span>
function to handle a situation like removing duplicate voters?</p></li></ol></blockquote></blockquote><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Context Matters When Comparing Values</p><blockquote class="RespCSBody"><p>The data de-duplication context in the above exercise reminds us that
different contexts may call for different notions of when two data values
are the same. Sometimes, we want exact matching to determine that two
strings are equal. Sometimes, we need methods that normalize data,
either in simple ways like capitalization or subtler ways based on
middle initials. Sometimes, we need more information (like street
addresses in addition to names) in order to determine whether two
items in a list should be considered â€œthe sameâ€.</p><p>It is easy to write programs that encode assumptions about our data
that might not apply in practice.  This is again a situation that can
be helped by thinking about the concrete examples on which your code
needs to work in context.  </p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 5.2.9.4"><h5 class="heading">5.2.9.4<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Reducing Computation<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Notice that this function has a repeated expression. Instead of
writing it twice, we could call it just once and use the result in
both places:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec2(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      ur = uniq-rec2(r)
      if r.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">You might think, because we replaced two function calls with one, that
weâ€™ve reduced the amount of computation the program does. It does not!
The two function calls are both in the two branches of the same
conditional; therefore, for any given list element, only one or the
other call to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> happens. In fact, in both cases, there was
one call to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> before, and there is one now. So we have
reduced the number of calls in the source program, but not the number
that take place when the program runs. In that sense, the name of this
section was intentionally misleading!</div><p/><div class="SIntrapara">However, there is one useful reduction we can perform, which is
enabled by the structure of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq-rec2</code></span>. We currently check
whether <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> is a member of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>, which is the list of
<span class="emph">all</span> the remaining elements. In our example, this means that in
the very second turn, we check whether <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span> is a member of the list
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 3, 1, 2, 4, 1]</code></span>. This is a list of six elements,
including three copies of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>. We compare <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span> against
<span class="emph">two</span> copies of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>. However, we gain nothing from the
second comparison. Put differently, we can think of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq(r)</code></span> as
a â€œsummaryâ€ of the rest of the list that is exactly as good as
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> itself for checking membership, with the advantage that it
might be significantly shorter. This, of course, is exactly what
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ur</code></span> represents. Therefore, we can encode this intuition as
follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec3(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      ur = uniq-rec3(r)
      if ur.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">Note that all that changed is that we check for membership in
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ur</code></span> rather than in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Later [<a href="predicting-growth.html" data-pltdoc="x">Predicting Growth</a>] we will study how to formally
study how long a program takes to run. By the measure introduced in
that section, does the change we just made make any difference? Be
careful with your answer: it depends on how we count â€œthe lengthâ€ of
the list.</p></blockquote></blockquote><p>Observe that if the list never contained duplicates in the first
place, then it wouldnâ€™t matter which list we check membership inâ€”<wbr/>but
if we <span class="emph">knew</span> the list didnâ€™t contain duplicates, we wouldnâ€™t be
using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> in the first place! We will return to the issue of
lists and duplicate elements in <a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>.</p></section><section class="SsectionLevel5" id="section 5.2.9.5"><h5 class="heading">5.2.9.5<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Example and Code Variations<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">As we mentioned earlier, there are other example sequences you might
have written down. Hereâ€™s a very different process:
</div><div class="SIntrapara"><ul><li><p>Start with the entire given list and with the empty answer (so
far).</p></li><li><p>For each list element, check whether itâ€™s already in the answer
so far. If it is, ignore it, otherwise extend the answer with it.</p></li><li><p>When there are no more elements in the list, the answer so far
is the answer for the whole list.</p></li></ul></div><div class="SIntrapara">Notice that this solution assumes that we will be accumulating the
answer as we traverse the list. Therefore, we canâ€™t even write the
example with one parameter as we did before. We would argue that a
<span class="emph">natural</span> solution asks whether we can solve the problem just
from the structure of the data using the computation we are already
defining, as we did above. If we cannot, then we have to resort to an
accumulator. But because we can, the accumulator is unnecessary here
and greatly complicates even writing down examples (give it a try!).</div></section><section class="SsectionLevel5" id="section 5.2.9.6"><h5 class="heading">5.2.9.6<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Why Produce a List?<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>If you go back to the original statement of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> problem
[<a href="#%28part._uniq%29" data-pltdoc="x"><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Problem Setup</a>], youâ€™ll notice it said nothing about what order the
output should have; in fact, it didnâ€™t even say the output needs to be
a list (and hence have an order). In that case, we should think about
whether a list even makes sense for this problem. In fact, if we donâ€™t
care about order and donâ€™t want duplicates (by definition of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>), then there is a much simpler solution, which is to
produce a <span style="font-style: italic">set</span>. Pyret already has sets built in, and converting
the list to a set automatically takes care of duplicates. This is of
course cheating from the perspective of learning how to write
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>, but it is worth remembering that sometimes the right data
structure to produce isnâ€™t necessarily the same as the one we were
given. Also, later [<a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>], we will see how to build sets
for ourselves (at which point, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> will look familiar, since
it is at the heart of set-ness).</p></section>&#13;
<h5 class="heading">5.2.9.1<span class="stt">Â </span><a name="(part._uniq)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Problem Setup<span class="button-group"><a href="#(part._uniq)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Consider the task of writing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>:<span class="refelem"><span class="refcolumn"><span class="refcontent"><span class="stt">uniq</span> is the
name of a Unix utility with similar behavior; hence the spelling of
the name.</span></span></span> given a list of values, it produces a collection of the
same elements while avoiding any duplicates (hence <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>, short
for â€œuniqueâ€).</p><p>Consider the following input: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 2, 1, 3, 1, 2, 4, 1]</code></span>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What is the sequence of examples this input generates?  Itâ€™s
<span class="emph">really important</span> you stop and try to do this by hand. As we
will see there are multiple solutions, and itâ€™s useful for you to
consider what you generate. Even if you canâ€™t generate a sequence,
trying to do so will better prepare you for what you read next.</p></blockquote></blockquote><p>How did you obtain your example? If you just â€œthought about it for a
moment and wrote something downâ€, you may or may not have gotten
something you can turn into a program. Programs can only proceed
systematically; they canâ€™t â€œthinkâ€. So, hopefully you took a
well-defined path to computing the answer.</p>&#13;
<h5 class="heading">5.2.9.2<span class="stt">Â </span><a name="(part._uniq-eg)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Examples<span class="button-group"><a href="#(part._uniq-eg)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>It turns out there are <span class="emph">several</span> possible answers, because we
have (intentionally) left the problem unspecified. Suppose there are
two instances of a value in the list; which one do we keep, the first
or the second? On the one hand, since the two instances must be
equivalent it doesnâ€™t matter, but it does for writing concrete
examples and deriving a solution.</p><p/><div class="SIntrapara">For instance, you might have generated this sequence:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">examples:
  uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:    2, 1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:       1, 3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:          3, 1, 2, 4, 1]) is [list: 3, 2, 4, 1]
  uniq([list:             1, 2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                2, 4, 1]) is [list:    2, 4, 1]
  uniq([list:                   4, 1]) is [list:       4, 1]
  uniq([list:                      1]) is [list:          1]
  uniq([list:                       ]) is [list:           ]
end</code></pre></div></div></div><div class="SIntrapara">However, you might have also generated sequences that began with
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 1, 2, 3, 4]</code></pre></div></div></div><div class="SIntrapara">or
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq([list: 1, 2, 1, 3, 1, 2, 4, 1]) is [list: 4, 3, 2, 1]</code></pre></div></div></div><div class="SIntrapara">and so on. Letâ€™s work with the examples weâ€™ve worked out above.</div>&#13;
<h5 class="heading">5.2.9.3<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Code<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>What is the <span class="emph">systematic</span> approach that gets us to this answer?
When given a non-empty list, we split it into its first element and
the rest of the list. Suppose we have the answer to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>
applied to the rest of the list. Now we can ask: is the first element
in the rest of the list? If it is, then we can ignore it, since it is
certain to be in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> of the rest of the list. If, however,
it is not in the rest of the list, itâ€™s critical that we <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span>
it to the answer.</p><p>This translates into the following program. For the empty list, we
return the empty list. If the list is non-empty, we check whether the
first is in the rest of the list. If it is <span class="emph">not</span>, we include it;
otherwise we can ignore it for now.</p><p/><div class="SIntrapara">This results in the following program:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      if r.member(f):
        uniq-rec(r)
      else:
        link(f, uniq-rec(r))
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">which weâ€™ve called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq-rec</code></span> instead of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> to
differentiate it from other versions of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Note that weâ€™re using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.member</code></span> to check whether an element is a
member of the list. Write a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member</code></span> that consumes an
element and a list, and tells us whether the element is a member of
the list.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Uniqueness checking has many practical applications. For example, one
might have a list of names of people who have registered to vote in an
election. To keep the voting fair, with only one vote allowed per
person, we should remove duplicate names from the list.</p><ol><li><p>Propose a set of examples for a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rem-duplicate-voters</code></span>
that takes a list of voter names and returns a list in which duplicate
registrations have been removed. In developing your examples, consider
real-world scenarios that you can imagine arising when identifying
duplicate names. Can you identify cases in which two names
might appear to be the same person, but not be? Cases in which two
names might appear different but be referring to the same person?</p></li><li><p>What might you need to change about our current <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq-rec</code></span>
function to handle a situation like removing duplicate voters?</p></li></ol></blockquote></blockquote><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Context Matters When Comparing Values</p><blockquote class="RespCSBody"><p>The data de-duplication context in the above exercise reminds us that
different contexts may call for different notions of when two data values
are the same. Sometimes, we want exact matching to determine that two
strings are equal. Sometimes, we need methods that normalize data,
either in simple ways like capitalization or subtler ways based on
middle initials. Sometimes, we need more information (like street
addresses in addition to names) in order to determine whether two
items in a list should be considered â€œthe sameâ€.</p><p>It is easy to write programs that encode assumptions about our data
that might not apply in practice.  This is again a situation that can
be helped by thinking about the concrete examples on which your code
needs to work in context.  </p></blockquote></blockquote>&#13;
<h5 class="heading">5.2.9.4<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Reducing Computation<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">Notice that this function has a repeated expression. Instead of
writing it twice, we could call it just once and use the result in
both places:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec2(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      ur = uniq-rec2(r)
      if r.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">You might think, because we replaced two function calls with one, that
weâ€™ve reduced the amount of computation the program does. It does not!
The two function calls are both in the two branches of the same
conditional; therefore, for any given list element, only one or the
other call to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> happens. In fact, in both cases, there was
one call to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> before, and there is one now. So we have
reduced the number of calls in the source program, but not the number
that take place when the program runs. In that sense, the name of this
section was intentionally misleading!</div><p/><div class="SIntrapara">However, there is one useful reduction we can perform, which is
enabled by the structure of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq-rec2</code></span>. We currently check
whether <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f</code></span> is a member of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>, which is the list of
<span class="emph">all</span> the remaining elements. In our example, this means that in
the very second turn, we check whether <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span> is a member of the list
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, 3, 1, 2, 4, 1]</code></span>. This is a list of six elements,
including three copies of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>. We compare <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span> against
<span class="emph">two</span> copies of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>. However, we gain nothing from the
second comparison. Put differently, we can think of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq(r)</code></span> as
a â€œsummaryâ€ of the rest of the list that is exactly as good as
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> itself for checking membership, with the advantage that it
might be significantly shorter. This, of course, is exactly what
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ur</code></span> represents. Therefore, we can encode this intuition as
follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun uniq-rec3(l :: List&lt;Any&gt;) -&gt; List&lt;Any&gt;:
  cases (List) l:
    | empty =&gt; empty
    | link(f, r) =&gt;
      ur = uniq-rec3(r)
      if ur.member(f):
        ur
      else:
        link(f, ur)
      end
  end
end</code></pre></div></div></div><div class="SIntrapara">Note that all that changed is that we check for membership in
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ur</code></span> rather than in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span>.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Later [<a href="predicting-growth.html" data-pltdoc="x">Predicting Growth</a>] we will study how to formally
study how long a program takes to run. By the measure introduced in
that section, does the change we just made make any difference? Be
careful with your answer: it depends on how we count â€œthe lengthâ€ of
the list.</p></blockquote></blockquote><p>Observe that if the list never contained duplicates in the first
place, then it wouldnâ€™t matter which list we check membership inâ€”<wbr/>but
if we <span class="emph">knew</span> the list didnâ€™t contain duplicates, we wouldnâ€™t be
using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> in the first place! We will return to the issue of
lists and duplicate elements in <a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>.</p>&#13;
<h5 class="heading">5.2.9.5<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Example and Code Variations<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">As we mentioned earlier, there are other example sequences you might
have written down. Hereâ€™s a very different process:
</div><div class="SIntrapara"><ul><li><p>Start with the entire given list and with the empty answer (so
far).</p></li><li><p>For each list element, check whether itâ€™s already in the answer
so far. If it is, ignore it, otherwise extend the answer with it.</p></li><li><p>When there are no more elements in the list, the answer so far
is the answer for the whole list.</p></li></ul></div><div class="SIntrapara">Notice that this solution assumes that we will be accumulating the
answer as we traverse the list. Therefore, we canâ€™t even write the
example with one parameter as we did before. We would argue that a
<span class="emph">natural</span> solution asks whether we can solve the problem just
from the structure of the data using the computation we are already
defining, as we did above. If we cannot, then we have to resort to an
accumulator. But because we can, the accumulator is unnecessary here
and greatly complicates even writing down examples (give it a try!).</div>&#13;
<h5 class="heading">5.2.9.6<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Why Produce a List?<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>If you go back to the original statement of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> problem
[<a href="#%28part._uniq%29" data-pltdoc="x"><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>: Problem Setup</a>], youâ€™ll notice it said nothing about what order the
output should have; in fact, it didnâ€™t even say the output needs to be
a list (and hence have an order). In that case, we should think about
whether a list even makes sense for this problem. In fact, if we donâ€™t
care about order and donâ€™t want duplicates (by definition of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>), then there is a much simpler solution, which is to
produce a <span style="font-style: italic">set</span>. Pyret already has sets built in, and converting
the list to a set automatically takes care of duplicates. This is of
course cheating from the perspective of learning how to write
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span>, but it is worth remembering that sometimes the right data
structure to produce isnâ€™t necessarily the same as the one we were
given. Also, later [<a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>], we will see how to build sets
for ourselves (at which point, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">uniq</code></span> will look familiar, since
it is at the heart of set-ness).</p>&#13;
<h4 class="heading">5.2.10<span class="stt">Â </span><a name="(part._polymorphic-data)"/>Monomorphic Lists and Polymorphic Types<span class="button-group"><a href="#(part._polymorphic-data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Earlier we wrote contracts like:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len :: List&lt;Any&gt; -&gt; Number
my-max :: List&lt;Any&gt; -&gt; Any</code></pre></div></div></div><div class="SIntrapara">These are unsatisfying for several reasons. Consider
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>. The contract suggests that any kind of element can be
in the input list, but in fact that isnâ€™t true: the input
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 1, "two", 3]</code></span> is not valid, because we canâ€™t compare
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"two"</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"two"</code></span> with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>What happens if we run <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1 &gt; "two"</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"two" &gt; 3</code></span>?</p></blockquote></blockquote><p>Rather, what we mean is a list where all the elements are <span class="emph">of the
same kind</span>,<span class="refelem"><span class="refcolumn"><span class="refcontent">Technically, elements that are also comparable.</span></span></span>
and the contract has not captured that. Furthermore, we donâ€™t mean
that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span> might return any old type: if we supply it with a
list of numbers, we will not get a string as the maximum element!
Rather, it will only return the kind of element that is in the
provided list.</p><p>In short, we mean that all elements of the list are of the same type,
but they can be of any type. We call the former <span style="font-style: italic">monomorphic</span>:
â€œmonoâ€ meaning one, and â€œmorphicâ€ meaning shape, i.e., all values
have one type. But the function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span> itself can operate over
many of these kinds of lists, so we call it <span style="font-style: italic">polymorphic</span>
(â€œpolyâ€ meaning many).</p><p/><div class="SIntrapara">Therefore, we need a better way of writing these
contracts. Essentially, we want to say that there is a
<span style="font-style: italic">type variable</span> (as opposed to regular program variable) that represents the
type of element in the list. Given that type, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span> will
return an element of that type. We write this syntactically as
follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-max&lt;T&gt;(l :: List&lt;T&gt;) -&gt; T: â€¦ end</code></pre></div></div></div><div class="SIntrapara">The notation <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;T&gt;</code></span> says that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">T</code></span> is a type variable
parameter that will be used in the rest of the function (both the
header and the body).</div><p/><div class="SIntrapara">Using this notation, we can also revisit <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>. Its header now
becomes:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-len&lt;T&gt;(l :: List&lt;T&gt;) -&gt; Number: â€¦ end</code></pre></div></div></div><div class="SIntrapara">Note that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span> did not actually â€œcareâ€ that whether all the
values were of the same type or not: it never looks at the individual
elements, much less at pairs of them. However, as a <span class="emph">convention</span>
we demand that lists always be monomorphic. This is important because
it enables us to process the elements of the list uniformly: if we
know how to process elements of type <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">T</code></span>, then we will know how
to process a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">List&lt;T&gt;</code></span>. If the list elements can be of truly any
old type, we canâ€™t know how to process its elements.</div>    
</body>
</html>