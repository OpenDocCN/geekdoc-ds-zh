- en: Instrumentation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于排序算法，我们想知道它进行了多少次比较。
- en: 原文：[https://en.algorithmica.org/hpc/profiling/instrumentation/](https://en.algorithmica.org/hpc/profiling/instrumentation/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 译文：[https://en.algorithmica.org/hpc/profiling/instrumentation/](https://en.algorithmica.org/hpc/profiling/instrumentation/)
- en: '*Instrumentation* is an overcomplicated term that means inserting timers and
    other tracking code into programs. The simplest example is using the `time` utility
    in Unix-like systems to measure the duration of execution for the whole program.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个哈希函数，我们对其输入的平均长度感兴趣；
- en: 'More generally, we want to know *which parts* of the program need optimization.
    There are tools shipped with compilers and IDEs that can time designated functions
    automatically, but it is more robust to do it by hand using any methods of interacting
    with time that the language provides:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到更高的精度，你可以在循环中重复调用函数，只计时一次，然后将总时间除以迭代次数：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: One nuance here is that you can’t measure the execution time of particularly
    quick functions this way because the `clock` function returns the current timestamp
    in microseconds ($10^{-6}$) and also by itself takes up to a few hundred nanoseconds
    to complete. All other time-related utilities similarly have at least microsecond
    granularity, which is an eternity in the world of low-level optimization.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个细微差别，那就是你不能用这种方法来测量特别快的函数的执行时间，因为`clock`函数返回当前时间戳（以微秒为单位，$10^{-6}$），并且它本身完成也需要几百纳秒。所有其他与时间相关的实用工具都具有至少微秒级的粒度，这在底层优化的世界中是永恒的。
- en: 'To achieve higher precision, you can invoke the function repeatedly in a loop,
    time the whole thing once, and then divide the total time by the number of iterations:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/profiling/instrumentation/#event-sampling)事件抽样'
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You also need to ensure that nothing gets cached, optimized away by the compiler,
    or affected by similar side effects. This is a separate and highly complicated
    topic that we will discuss in more detail at [the end of the chapter](../benchmarking).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*仪器*是一个过于复杂的术语，意味着将计时器和其他跟踪代码插入到程序中。最简单的例子是在类Unix系统中使用`time`实用工具来测量整个程序的执行持续时间。'
- en: '### [#](https://en.algorithmica.org/hpc/profiling/instrumentation/#event-sampling)Event
    Sampling'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/profiling/instrumentation/](https://en.algorithmica.org/hpc/profiling/instrumentation/)
- en: 'Instrumentation can also be used to collect other types of information that
    can give useful insights about the performance of a particular algorithm. For
    example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 仪器也可以用来收集其他类型的信息，这些信息可以提供关于特定算法性能的有用见解。例如：
- en: for a hash function, we are interested in the average length of its input;
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一个二叉树，我们关心其大小和高度；
- en: for a binary tree, we care about its size and height;
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更一般地，我们想知道程序中哪些部分需要优化。编译器和IDEs附带了一些工具，可以自动计时指定的函数，但通过手动使用语言提供的任何与时间交互的方法来做会更稳健：
- en: for a sorting algorithm, we we want to know how many comparisons it does.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加计数器有一个缺点，那就是它会引入开销，尽管你可以通过只对一小部分调用进行随机操作来几乎完全缓解这个问题：
- en: In a similar way, we can insert counters in the code that compute these algorithm-specific
    statistics.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果采样率足够小，每次调用剩余的唯一开销将是随机数生成和条件检查。有趣的是，我们可以通过一些统计技巧进一步优化它。
- en: 'Adding counters has the disadvantage of introducing overhead, although you
    can mitigate it almost completely by only doing it randomly for a small fraction
    of invocations:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，我们在这里所做的就是反复从[伯努利分布](https://en.wikipedia.org/wiki/Bernoulli_distribution)（$p$等于采样率）中进行抽样，直到我们得到一个成功。还有一个分布可以告诉我们需要多少次伯努利抽样迭代才能得到第一个正值，称为[几何分布](https://en.wikipedia.org/wiki/Geometric_distribution)。我们可以从它中进行抽样，并使用该值作为递减计数器：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the sample rate is small enough, the only remaining overhead per invocation
    will be random number generation and a condition check. Interestingly, we can
    optimize it a bit more with some stats magic.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要确保没有任何东西被缓存、被编译器优化掉或受到类似副作用的影响。这是一个单独且非常复杂的话题，我们将在[本章末尾](../benchmarking)进行更详细的讨论。
- en: 'Mathematically, what we are doing here is repeatedly sampling from [Bernoulli
    distribution](https://en.wikipedia.org/wiki/Bernoulli_distribution) (with $p$
    equal to sample rate) until we get a success. There is another distribution that
    tells us how many iterations of Bernoulli sampling we need until the first positive,
    called [geometric distribution](https://en.wikipedia.org/wiki/Geometric_distribution).
    What we can do is to sample from it instead and use that value as a decrementing
    counter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以在代码中插入计数器来计算这些特定算法的统计数据。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This way we can remove the need to sample a new random number on each invocation,
    only resetting the counter when we choose to calculate statistics.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以消除每次调用时都需要采样新随机数的需要，只有在选择计算统计数据时才重置计数器。
- en: Techniques like that are frequently used by library algorithm developers inside
    large projects to collect profiling data without affecting the performance of
    the end program too much. [← ../Profiling](https://en.algorithmica.org/hpc/profiling/)[Statistical
    Profiling →](https://en.algorithmica.org/hpc/profiling/events/)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术通常被大型项目中的库算法开发者频繁使用，以收集性能分析数据，同时尽量不影响最终程序的性能。[← ../性能分析](https://en.algorithmica.org/hpc/profiling/)[统计性能分析
    →](https://en.algorithmica.org/hpc/profiling/events/)
