- en: Instrumentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://en.algorithmica.org/hpc/profiling/instrumentation/](https://en.algorithmica.org/hpc/profiling/instrumentation/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Instrumentation* is an overcomplicated term that means inserting timers and
    other tracking code into programs. The simplest example is using the `time` utility
    in Unix-like systems to measure the duration of execution for the whole program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'More generally, we want to know *which parts* of the program need optimization.
    There are tools shipped with compilers and IDEs that can time designated functions
    automatically, but it is more robust to do it by hand using any methods of interacting
    with time that the language provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: One nuance here is that you can’t measure the execution time of particularly
    quick functions this way because the `clock` function returns the current timestamp
    in microseconds ($10^{-6}$) and also by itself takes up to a few hundred nanoseconds
    to complete. All other time-related utilities similarly have at least microsecond
    granularity, which is an eternity in the world of low-level optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve higher precision, you can invoke the function repeatedly in a loop,
    time the whole thing once, and then divide the total time by the number of iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You also need to ensure that nothing gets cached, optimized away by the compiler,
    or affected by similar side effects. This is a separate and highly complicated
    topic that we will discuss in more detail at [the end of the chapter](../benchmarking).
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/profiling/instrumentation/#event-sampling)Event
    Sampling'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instrumentation can also be used to collect other types of information that
    can give useful insights about the performance of a particular algorithm. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: for a hash function, we are interested in the average length of its input;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for a binary tree, we care about its size and height;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for a sorting algorithm, we we want to know how many comparisons it does.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a similar way, we can insert counters in the code that compute these algorithm-specific
    statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding counters has the disadvantage of introducing overhead, although you
    can mitigate it almost completely by only doing it randomly for a small fraction
    of invocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the sample rate is small enough, the only remaining overhead per invocation
    will be random number generation and a condition check. Interestingly, we can
    optimize it a bit more with some stats magic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically, what we are doing here is repeatedly sampling from [Bernoulli
    distribution](https://en.wikipedia.org/wiki/Bernoulli_distribution) (with $p$
    equal to sample rate) until we get a success. There is another distribution that
    tells us how many iterations of Bernoulli sampling we need until the first positive,
    called [geometric distribution](https://en.wikipedia.org/wiki/Geometric_distribution).
    What we can do is to sample from it instead and use that value as a decrementing
    counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This way we can remove the need to sample a new random number on each invocation,
    only resetting the counter when we choose to calculate statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques like that are frequently used by library algorithm developers inside
    large projects to collect profiling data without affecting the performance of
    the end program too much. [← ../Profiling](https://en.algorithmica.org/hpc/profiling/)[Statistical
    Profiling →](https://en.algorithmica.org/hpc/profiling/events/)
  prefs: []
  type: TYPE_NORMAL
