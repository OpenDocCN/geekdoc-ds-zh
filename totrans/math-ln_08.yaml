- en: 8\. Hierarchiesïƒ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. å±‚æ¬¡ç»“æ„ïƒ
- en: åŸæ–‡ï¼š[https://leanprover-community.github.io/mathematics_in_lean/C08_Hierarchies.html](https://leanprover-community.github.io/mathematics_in_lean/C08_Hierarchies.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://leanprover-community.github.io/mathematics_in_lean/C08_Hierarchies.html](https://leanprover-community.github.io/mathematics_in_lean/C08_Hierarchies.html)
- en: '*[Mathematics in Lean](index.html)* **   8\. Hierarchies'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Leanä¸­çš„æ•°å­¦](index.html)* **   8. å±‚æ¬¡ç»“æ„'
- en: '[View page source](_sources/C08_Hierarchies.rst.txt)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[æŸ¥çœ‹é¡µé¢æºä»£ç ](_sources/C08_Hierarchies.rst.txt)'
- en: '* * *'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'We have seen in [Chapter 7](C07_Structures.html#structures) how to define the
    class of groups and build instances of this class, and then how to build an instance
    of the commutative ring class. But of course there is a hierarchy here: a commutative
    ring is in particular an additive group. In this chapter we will study how to
    build such hierarchies. They appear in all branches of mathematics but in this
    chapter the emphasis will be on algebraic examples.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨[ç¬¬7ç« ](C07_Structures.html#structures)ä¸­çœ‹åˆ°äº†å¦‚ä½•å®šä¹‰ç¾¤ç±»å¹¶æ„å»ºè¿™ä¸ªç±»çš„å®ä¾‹ï¼Œç„¶åæ˜¯å¦‚ä½•æ„å»ºäº¤æ¢ç¯ç±»çš„å®ä¾‹ã€‚ä½†å½“ç„¶è¿™é‡Œæœ‰ä¸€ä¸ªå±‚æ¬¡ç»“æ„ï¼šäº¤æ¢ç¯ç‰¹åˆ«æ˜¯ä¸€ä¸ªåŠ æ³•ç¾¤ã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†ç ”ç©¶å¦‚ä½•æ„å»ºè¿™æ ·çš„å±‚æ¬¡ç»“æ„ã€‚å®ƒä»¬å‡ºç°åœ¨æ•°å­¦çš„æ‰€æœ‰åˆ†æ”¯ä¸­ï¼Œä½†æœ¬ç« çš„é‡ç‚¹å°†æ”¾åœ¨ä»£æ•°ç¤ºä¾‹ä¸Šã€‚
- en: It may seem premature to discuss how to build hierarchies before more discussions
    about using existing hierarchies. But some understanding of the technology underlying
    hierarchies is required to use them. So you should probably still read this chapter,
    but without trying too hard to remember everything on your first read, then read
    the following chapters and come back here for a second reading.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ›´å¤šå…³äºä½¿ç”¨ç°æœ‰å±‚æ¬¡ç»“æ„çš„è®¨è®ºä¹‹å‰è®¨è®ºå¦‚ä½•æ„å»ºå±‚æ¬¡ç»“æ„å¯èƒ½æ˜¾å¾—æœ‰äº›è¿‡æ—©ã€‚ä½†æ˜¯ï¼Œä¸ºäº†ä½¿ç”¨è¿™äº›å±‚æ¬¡ç»“æ„ï¼Œéœ€è¦å¯¹æ”¯æ’‘è¿™äº›å±‚æ¬¡ç»“æ„çš„æŠ€æœ¯æœ‰ä¸€å®šçš„äº†è§£ã€‚å› æ­¤ï¼Œä½ å¯èƒ½ä»ç„¶åº”è¯¥é˜…è¯»è¿™ä¸€ç« ï¼Œä½†ä¸è¦åœ¨ç¬¬ä¸€æ¬¡é˜…è¯»æ—¶è¿‡äºåŠªåŠ›åœ°è®°ä½æ‰€æœ‰å†…å®¹ï¼Œç„¶åé˜…è¯»æ¥ä¸‹æ¥çš„ç« èŠ‚ï¼Œå†å›æ¥è¿™é‡Œè¿›è¡Œç¬¬äºŒæ¬¡é˜…è¯»ã€‚
- en: In this chapter, we will redefine (simpler versions of) many things that appear
    in Mathlib so we will used indices to distinguish our version. For instance we
    will have `Ringâ‚` as our version of `Ring`. Since we will gradually explain more
    powerful ways of formalizing structures, those indices will sometimes grow beyond
    one.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†é‡æ–°å®šä¹‰ï¼ˆMathlibä¸­å‡ºç°çš„è®¸å¤šäº‹ç‰©çš„ç®€åŒ–ç‰ˆæœ¬ï¼‰ï¼Œå› æ­¤æˆ‘ä»¬å°†ä½¿ç”¨ç´¢å¼•æ¥åŒºåˆ†æˆ‘ä»¬çš„ç‰ˆæœ¬ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å°†æœ‰ `Ringâ‚` ä½œä¸ºæˆ‘ä»¬çš„ `Ring`
    ç‰ˆæœ¬ã€‚ç”±äºæˆ‘ä»¬å°†é€æ¸è§£é‡Šæ›´å¼ºå¤§çš„å½¢å¼åŒ–ç»“æ„çš„æ–¹æ³•ï¼Œè¿™äº›ç´¢å¼•æœ‰æ—¶ä¼šè¶…è¿‡ä¸€ä¸ªã€‚
- en: '## 8.1\. Basics[ïƒ](#basics "Link to this heading")'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '## 8.1. åŸºç¡€[ïƒ](#basics "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")'
- en: At the very bottom of all hierarchies in Lean, we find data-carrying classes.
    The following class records that the given type `Î±` is endowed with a distinguished
    element called `one`. At this stage, it has no property at all.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ‰€æœ‰å±‚æ¬¡ç»“æ„çš„åº•å±‚ï¼Œæˆ‘ä»¬æ‰¾åˆ°äº†æºå¸¦æ•°æ®çš„ç±»ã€‚ä»¥ä¸‹ç±»è®°å½•äº†ç»™å®šçš„ç±»å‹ `Î±` è¢«èµ‹äºˆäº†ä¸€ä¸ªç§°ä¸º `one` çš„ç‰¹æ®Šå…ƒç´ ã€‚åœ¨è¿™ä¸ªé˜¶æ®µï¼Œå®ƒæ²¡æœ‰ä»»ä½•å±æ€§ã€‚
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since weâ€™ll make a much heavier use of classes in this chapter, we need to
    understand some more details about what the `class` command is doing. First, the
    `class` command above defines a structure `Oneâ‚` with parameter `Î± : Type` and
    a single field `one`. It also mark this structure as a class so that arguments
    of type `Oneâ‚ Î±` for some type `Î±` will be inferrable using the instance resolution
    procedure, as long as they are marked as instance-implicit, i.e. appear between
    square brackets. Those two effects could also have been achieved using the `structure`
    command with `class` attribute, i.e. writing `@[class] structure` instance of
    `class`. But the class command also ensures that `Oneâ‚ Î±` appears as an instance-implicit
    argument in its own fields. Compare:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç”±äºåœ¨æœ¬ç« ä¸­æˆ‘ä»¬å°†æ›´é¢‘ç¹åœ°ä½¿ç”¨ç±»ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£ä¸€äº›å…³äº `class` å‘½ä»¤æ‰€åšäº‹æƒ…çš„æ›´å¤šç»†èŠ‚ã€‚é¦–å…ˆï¼Œä¸Šé¢çš„ `class` å‘½ä»¤å®šä¹‰äº†ä¸€ä¸ªå¸¦æœ‰å‚æ•°
    `Î± : Type` å’Œå•ä¸ªå­—æ®µ `one` çš„ç»“æ„ `Oneâ‚`ã€‚å®ƒè¿˜æ ‡è®°è¿™ä¸ªç»“æ„ä¸ºä¸€ä¸ªç±»ï¼Œä»¥ä¾¿å¯¹äºæŸäº›ç±»å‹ `Î±` çš„ `Oneâ‚ Î±` å‚æ•°ï¼Œåªè¦å®ƒä»¬è¢«æ ‡è®°ä¸ºå®ä¾‹éšå¼ï¼Œå³å‡ºç°åœ¨æ–¹æ‹¬å·ä¹‹é—´ï¼Œå°±å¯ä»¥ä½¿ç”¨å®ä¾‹è§£æè¿‡ç¨‹è¿›è¡Œæ¨æ–­ã€‚è¿™ä¸¤ä¸ªæ•ˆæœä¹Ÿå¯ä»¥é€šè¿‡å¸¦æœ‰
    `class` å±æ€§çš„ `structure` å‘½ä»¤å®ç°ï¼Œå³å†™ä½œ `@[class] structure` å®ä¾‹çš„ `class`ã€‚ä½†æ˜¯ï¼Œç±»å‘½ä»¤è¿˜ç¡®ä¿ `Oneâ‚
    Î±` åœ¨å…¶è‡ªå·±çš„å­—æ®µä¸­ä½œä¸ºå®ä¾‹éšå¼å‚æ•°å‡ºç°ã€‚æ¯”è¾ƒï¼š'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the second check, we can see that `self : Oneâ‚‚ Î±` is an explicit argument.
    Let us make sure the first version is indeed usable without any explicit argument.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 'åœ¨ç¬¬äºŒæ¬¡æ£€æŸ¥ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ° `self : Oneâ‚‚ Î±` æ˜¯ä¸€ä¸ªæ˜¾å¼å‚æ•°ã€‚è®©æˆ‘ä»¬ç¡®ä¿ç¬¬ä¸€ä¸ªç‰ˆæœ¬ç¡®å®å¯ä»¥åœ¨æ²¡æœ‰ä»»ä½•æ˜¾å¼å‚æ•°çš„æƒ…å†µä¸‹ä½¿ç”¨ã€‚'
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Remark: in the above example, the argument `Oneâ‚ Î±` is marked as instance-implicit,
    which is a bit silly since this affects only *uses* of the declaration and declaration
    created by the `example` command cannot be used. However it allows us to avoid
    giving a name to that argument and, more importantly, it starts installing the
    good habit of marking `Oneâ‚ Î±` arguments as instance-implicit.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: å¤‡æ³¨ï¼šåœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œå‚æ•°`Oneâ‚ Î±`è¢«æ ‡è®°ä¸ºå®ä¾‹éšå¼ï¼Œè¿™æœ‰ç‚¹æ„šè ¢ï¼Œå› ä¸ºè¿™åªå½±å“å£°æ˜çš„*ä½¿ç”¨*å’Œç”±`example`å‘½ä»¤åˆ›å»ºçš„å£°æ˜ä¸èƒ½ä½¿ç”¨ã€‚ç„¶è€Œï¼Œå®ƒå…è®¸æˆ‘ä»¬é¿å…ç»™è¿™ä¸ªå‚æ•°å‘½åï¼Œæ›´é‡è¦çš„æ˜¯ï¼Œå®ƒå¼€å§‹å…»æˆæ ‡è®°`Oneâ‚
    Î±`å‚æ•°ä¸ºå®ä¾‹éšå¼çš„è‰¯å¥½ä¹ æƒ¯ã€‚
- en: 'Another remark is that all this will work only when Lean knows what is `Î±`.
    In the above example, leaving out the type ascription `: Î±` would generate an
    error message like: `typeclass instance problem is stuck, it is often due to metavariables
    Oneâ‚ (?m.263 Î±)` where `?m.263 Î±` means â€œsome type depending on `Î±`â€ (and 263
    is simply an auto-generated index that would be useful to distinguish between
    several unknown things). Another way to avoid this issue would be to use a type
    annotation, as in:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¦ä¸€ä¸ªè¦æ³¨æ„çš„æ˜¯ï¼Œæ‰€æœ‰è¿™äº›åªæœ‰åœ¨LeançŸ¥é“`Î±`æ˜¯ä»€ä¹ˆçš„æ—¶å€™æ‰ä¼šèµ·ä½œç”¨ã€‚åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œçœç•¥ç±»å‹æ³¨è§£`: Î±`ä¼šäº§ç”Ÿä¸€ä¸ªé”™è¯¯ä¿¡æ¯ï¼Œä¾‹å¦‚ï¼š`typeclass
    instance problem is stuck, it is often due to metavariables Oneâ‚ (?m.263 Î±)`ï¼Œå…¶ä¸­`?m.263
    Î±`æ„å‘³ç€â€œä¾èµ–äº`Î±`çš„æŸäº›ç±»å‹â€ï¼ˆè€Œ263æ˜¯ä¸€ä¸ªè‡ªåŠ¨ç”Ÿæˆçš„ç´¢å¼•ï¼Œå¯ä»¥ç”¨æ¥åŒºåˆ†å‡ ä¸ªæœªçŸ¥çš„äº‹ç‰©ï¼‰ã€‚é¿å…è¿™ä¸ªé—®é¢˜çš„å¦ä¸€ç§æ–¹æ³•å°±æ˜¯ä½¿ç”¨ç±»å‹æ³¨è§£ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You may have already encountered that issue when playing with limits of sequences
    in [Section 3.6](C03_Logic.html#sequences-and-convergence) if you tried to state
    for instance that `0 < 1` without telling Lean whether you meant this inequality
    to be about natural numbers or real numbers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½åœ¨[ç¬¬3.6èŠ‚](C03_Logic.html#sequences-and-convergence)ä¸­ç©åºåˆ—çš„æé™æ—¶å·²ç»é‡åˆ°è¿‡è¿™ä¸ªé—®é¢˜ï¼Œå¦‚æœä½ è¯•å›¾å£°æ˜ä¾‹å¦‚`0
    < 1`ï¼Œä½†æ²¡æœ‰å‘Šè¯‰Leanä½ æ˜¯æŒ‡è‡ªç„¶æ•°è¿˜æ˜¯å®æ•°çš„è¿™ä¸ªä¸ç­‰å¼ã€‚
- en: Our next task is to assign a notation to `Oneâ‚.one`. Since we donâ€™t want collisions
    with the builtin notation for `1`, we will use `ğŸ™`. This is achieved by the following
    command where the first line tells Lean to use the documentation of `Oneâ‚.one`
    as documentation for the symbol `ğŸ™`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸‹ä¸€ä¸ªä»»åŠ¡æ˜¯ç»™`Oneâ‚.one`åˆ†é…ä¸€ä¸ªç¬¦å·ã€‚ç”±äºæˆ‘ä»¬ä¸å¸Œæœ›ä¸å†…ç½®çš„`1`çš„ç¬¦å·å†²çªï¼Œæˆ‘ä»¬å°†ä½¿ç”¨`ğŸ™`ã€‚è¿™æ˜¯é€šè¿‡ä»¥ä¸‹å‘½ä»¤å®ç°çš„ï¼Œå…¶ä¸­ç¬¬ä¸€è¡Œå‘Šè¯‰Leanä½¿ç”¨`Oneâ‚.one`çš„æ–‡æ¡£ä½œä¸ºç¬¦å·`ğŸ™`çš„æ–‡æ¡£ã€‚
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We now want a data-carrying class recording a binary operation. We donâ€™t want
    to choose between addition and multiplication for now so weâ€™ll use diamond.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨æƒ³è¦ä¸€ä¸ªæºå¸¦æ•°æ®çš„ç±»æ¥è®°å½•äºŒå…ƒæ“ä½œã€‚æˆ‘ä»¬ç›®å‰ä¸æƒ³åœ¨åŠ æ³•å’Œä¹˜æ³•ä¹‹é—´åšå‡ºé€‰æ‹©ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†ä½¿ç”¨è±å½¢ã€‚
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As in the `Oneâ‚` example, the operation has no property at all at this stage.
    Let us now define the class of semigroup structures where the operation is denoted
    by `â‹„`. For now, we define it by hand as a structure with two fields, a `Diaâ‚`
    instance and some `Prop`-valued field `dia_assoc` asserting associativity of `â‹„`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: å°±åƒ`Oneâ‚`çš„ä¾‹å­ä¸€æ ·ï¼Œåœ¨è¿™ä¸ªé˜¶æ®µæ“ä½œæ²¡æœ‰ä»»ä½•å±æ€§ã€‚ç°åœ¨è®©æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªåŠç¾¤ç»“æ„ç±»ï¼Œå…¶ä¸­æ“ä½œç”¨`â‹„`è¡¨ç¤ºã€‚ç°åœ¨æˆ‘ä»¬æ‰‹åŠ¨å®šä¹‰å®ƒä¸ºä¸€ä¸ªæœ‰ä¸¤ä¸ªå­—æ®µçš„ç»“æ„ï¼Œä¸€ä¸ª`Diaâ‚`å®ä¾‹å’Œä¸€äº›`Prop`ç±»å‹çš„å­—æ®µ`dia_assoc`ï¼Œæ–­è¨€`â‹„`çš„ç»“åˆæ€§ã€‚
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that while stating dia_assoc, the previously defined field toDiaâ‚ is in
    the local context hence can be used when Lean searches for an instance of Diaâ‚
    Î± to make sense of a â‹„ b. However this toDiaâ‚ field does not become part of the
    type class instances database. Hence doing `example {Î± : Type} [Semigroupâ‚ Î±]
    (a b : Î±) : Î± := a â‹„ b` would fail with error message `failed to synthesize instance
    Diaâ‚ Î±`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ³¨æ„ï¼Œåœ¨å£°æ˜dia_assocæ—¶ï¼Œä¹‹å‰å®šä¹‰çš„å­—æ®µtoDiaâ‚åœ¨å±€éƒ¨ä¸Šä¸‹æ–‡ä¸­ï¼Œå› æ­¤å¯ä»¥åœ¨Leanæœç´¢Diaâ‚ Î±çš„å®ä¾‹ä»¥ç†è§£â‹„ bæ—¶ä½¿ç”¨ã€‚ç„¶è€Œï¼Œè¿™ä¸ªtoDiaâ‚å­—æ®µä¸ä¼šæˆä¸ºç±»å‹ç±»å®ä¾‹æ•°æ®åº“çš„ä¸€éƒ¨åˆ†ã€‚å› æ­¤ï¼Œæ‰§è¡Œ`example
    {Î± : Type} [Semigroupâ‚ Î±] (a b : Î±) : Î± := a â‹„ b`ä¼šå¤±è´¥ï¼Œé”™è¯¯ä¿¡æ¯ä¸º`failed to synthesize
    instance Diaâ‚ Î±`ã€‚'
- en: We can fix this by adding the `instance` attribute later.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é€šè¿‡ç¨åæ·»åŠ `instance`å±æ€§æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Before building up, we need to use a different syntax to add this toDiaâ‚ field,
    to tell Lean that Diaâ‚ Î± should be treated as if its fields were fields of Semigroupâ‚
    itself. This also conveniently adds the toDiaâ‚ instance automatically. The `class`
    command supports this using the `extends` syntax as in:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ„å»ºä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ä¸åŒçš„è¯­æ³•æ¥æ·»åŠ è¿™ä¸ªtoDiaâ‚å­—æ®µï¼Œå‘Šè¯‰Leanå°†Diaâ‚ Î±è§†ä¸ºå¦‚æœå®ƒçš„å­—æ®µæ˜¯Semigroupâ‚æœ¬èº«çš„å­—æ®µã€‚è¿™ä¹Ÿæ–¹ä¾¿åœ°è‡ªåŠ¨æ·»åŠ äº†toDiaâ‚å®ä¾‹ã€‚`class`å‘½ä»¤é€šè¿‡ä½¿ç”¨`extends`è¯­æ³•æ”¯æŒè¿™ä¸€ç‚¹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note this syntax is also available in the `structure` command, although it that
    case it fixes only the hurdle of writing fields such as toDiaâ‚ since there is
    no instance to define in that case.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™ç§è¯­æ³•åœ¨`structure`å‘½ä»¤ä¸­ä¹Ÿæ˜¯å¯ç”¨çš„ï¼Œå°½ç®¡åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒåªè§£å†³äº†ç¼–å†™åƒtoDiaâ‚è¿™æ ·çš„å­—æ®µçš„é—®é¢˜ï¼Œå› ä¸ºåœ¨è¿™ç§æƒ…å†µä¸‹æ²¡æœ‰å®ä¾‹è¦å®šä¹‰ã€‚
- en: The field name toDiaâ‚ is optional in the extends syntax. By default it takes
    the name of the class being extended and prefixes it with â€œtoâ€.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨`extends`è¯­æ³•ä¸­ï¼Œå­—æ®µå`toDiaâ‚`æ˜¯å¯é€‰çš„ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå®ƒé‡‡ç”¨è¢«æ‰©å±•çš„ç±»çš„åç§°ï¼Œå¹¶åœ¨å…¶å‰é¢åŠ ä¸Šâ€œtoâ€ã€‚
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let us now try to combine a diamond operation and a distinguished one element
    with axioms saying this element is neutral on both sides.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç°åœ¨å°è¯•ç»„åˆä¸€ä¸ªè±å½¢æ“ä½œå’Œä¸€ä¸ªç‰¹æ®Šå…ƒç´ ï¼Œå¹¶ä½¿ç”¨æ–­è¨€è¿™ä¸ªå…ƒç´ åœ¨ä¸¤ä¾§éƒ½æ˜¯ä¸­æ€§çš„å…¬ç†ã€‚
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the next example, we tell Lean that `Î±` has a `DiaOneClassâ‚` structure and
    state a property that uses both a Diaâ‚ instance and a Oneâ‚ instance. In order
    to see how Lean finds those instances we set a tracing option whose result can
    be seen in the Infoview. This result is rather terse by default but it can be
    expanded by clicking on lines ending with black arrows. It includes failed attempts
    where Lean tried to find instances before having enough type information to succeed.
    The successful attempts do involve the instances generated by the `extends` syntax.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹ä¸€ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å‘Šè¯‰Lean `Î±`æœ‰ä¸€ä¸ª`DiaOneClassâ‚`ç»“æ„ï¼Œå¹¶é™ˆè¿°äº†ä¸€ä¸ªä½¿ç”¨Diaâ‚å®ä¾‹å’ŒOneâ‚å®ä¾‹çš„å±æ€§ã€‚ä¸ºäº†çœ‹åˆ°Leanå¦‚ä½•æ‰¾åˆ°è¿™äº›å®ä¾‹ï¼Œæˆ‘ä»¬è®¾ç½®äº†ä¸€ä¸ªè·Ÿè¸ªé€‰é¡¹ï¼Œå…¶ç»“æœå¯ä»¥åœ¨Infoviewä¸­æŸ¥çœ‹ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè¿™ä¸ªç»“æœç›¸å½“ç®€æ´ï¼Œä½†å¯ä»¥é€šè¿‡å•å‡»ä»¥é»‘è‰²ç®­å¤´ç»“å°¾çš„è¡Œæ¥å±•å¼€ã€‚å®ƒåŒ…æ‹¬Leanåœ¨æˆåŠŸä¹‹å‰å°è¯•æ‰¾åˆ°å®ä¾‹çš„å¤±è´¥å°è¯•ã€‚æˆåŠŸçš„å°è¯•ç¡®å®æ¶‰åŠç”±`extends`è¯­æ³•ç”Ÿæˆçš„å®ä¾‹ã€‚
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that we donâ€™t need to include extra fields where combining existing classes.
    Hence we can define monoids as:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬ä¸éœ€è¦åœ¨ç»„åˆç°æœ‰ç±»æ—¶åŒ…å«é¢å¤–çš„å­—æ®µã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰å¹ºåŠç¾¤å¦‚ä¸‹ï¼š
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: While the above definition seems straightforward, it hides an important subtlety.
    Both `Semigroupâ‚ Î±` and `DiaOneClassâ‚ Î±` extend `Diaâ‚ Î±`, so one could fear that
    having a `Monoidâ‚ Î±` instance gives two unrelated diamond operations on `Î±`, one
    coming from a field `Monoidâ‚.toSemigroupâ‚` and one coming from a field `Monoidâ‚.toDiaOneClassâ‚`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶ä¸Šè¿°å®šä¹‰çœ‹èµ·æ¥å¾ˆç›´æ¥ï¼Œä½†å®ƒéšè—äº†ä¸€ä¸ªé‡è¦çš„å¾®å¦™ä¹‹å¤„ã€‚`Semigroupâ‚ Î±`å’Œ`DiaOneClassâ‚ Î±`éƒ½æ‰©å±•äº†`Diaâ‚ Î±`ï¼Œå› æ­¤äººä»¬å¯èƒ½ä¼šæ‹…å¿ƒï¼Œæœ‰ä¸€ä¸ª`Monoidâ‚
    Î±`å®ä¾‹ä¼šåœ¨`Î±`ä¸Šç»™å‡ºä¸¤ä¸ªæ— å…³çš„è±å½¢æ“ä½œï¼Œä¸€ä¸ªæ¥è‡ªå­—æ®µ`Monoidâ‚.toSemigroupâ‚`ï¼Œå¦ä¸€ä¸ªæ¥è‡ªå­—æ®µ`Monoidâ‚.toDiaOneClassâ‚`ã€‚
- en: 'Indeed if we try to build a monoid class by hand using:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œå¦‚æœæˆ‘ä»¬å°è¯•æ‰‹åŠ¨ä½¿ç”¨ä»¥ä¸‹æ–¹å¼æ„å»ºä¸€ä¸ªå¹ºåŠç¾¤ç±»ï¼š
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: then we get two completely unrelated diamond operations `Monoidâ‚‚.toSemigroupâ‚.toDiaâ‚.dia`
    and `Monoidâ‚‚.toDiaOneClassâ‚.toDiaâ‚.dia`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸¤ä¸ªå®Œå…¨æ— å…³çš„è±å½¢æ“ä½œ`Monoidâ‚‚.toSemigroupâ‚.toDiaâ‚.dia`å’Œ`Monoidâ‚‚.toDiaOneClassâ‚.toDiaâ‚.dia`ã€‚
- en: The version generated using the `extends` syntax does not have this defect.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`extends`è¯­æ³•ç”Ÿæˆçš„ç‰ˆæœ¬æ²¡æœ‰è¿™ä¸ªç¼ºé™·ã€‚
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So the `class` command did some magic for us (and the `structure` command would
    have done it too). An easy way to see what are the fields of our classes is to
    check their constructor. Compare:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œ`class`å‘½ä»¤ä¸ºæˆ‘ä»¬åšäº†ä¸€äº›é­”æ³•ï¼ˆ`structure`å‘½ä»¤ä¹Ÿä¼šè¿™æ ·åšï¼‰ã€‚æŸ¥çœ‹æˆ‘ä»¬ç±»å­—æ®µçš„ä¸€ä¸ªç®€å•æ–¹æ³•å°±æ˜¯æ£€æŸ¥å®ƒä»¬çš„æ„é€ å‡½æ•°ã€‚æ¯”è¾ƒï¼š
- en: '[PRE15]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So we see that `Monoidâ‚` takes `Semigroupâ‚ Î±` argument as expected but then
    it wonâ€™t take a would-be overlapping `DiaOneClassâ‚ Î±` argument but instead tears
    it apart and includes only the non-overlapping parts. And it also auto-generated
    an instance `Monoidâ‚.toDiaOneClassâ‚` which is *not* a field but has the expected
    signature which, from the end-user point of view, restores the symmetry between
    the two extended classes `Semigroupâ‚` and `DiaOneClassâ‚`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬çœ‹åˆ°`Monoidâ‚`æœŸæœ›æ¥å—`Semigroupâ‚ Î±`å‚æ•°ï¼Œä½†ç„¶åå®ƒä¸ä¼šæ¥å—ä¸€ä¸ªæ½œåœ¨çš„å†²çª`DiaOneClassâ‚ Î±`å‚æ•°ï¼Œè€Œæ˜¯å°†å…¶æ‹†åˆ†å¹¶ä»…åŒ…å«éé‡å éƒ¨åˆ†ã€‚å®ƒè¿˜è‡ªåŠ¨ç”Ÿæˆäº†ä¸€ä¸ªå®ä¾‹`Monoidâ‚.toDiaOneClassâ‚`ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªå­—æ®µï¼Œä½†å®ƒå…·æœ‰é¢„æœŸçš„ç­¾åï¼Œä»æœ€ç»ˆç”¨æˆ·çš„è§’åº¦æ¥çœ‹ï¼Œå®ƒæ¢å¤äº†ä¸¤ä¸ªæ‰©å±•ç±»`Semigroupâ‚`å’Œ`DiaOneClassâ‚`ä¹‹é—´çš„å¯¹ç§°æ€§ã€‚
- en: '[PRE16]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are now very close to defining groups. We could add to the monoid structure
    a field asserting the existence of an inverse for every element. But then we would
    need to work to access these inverses. In practice it is more convenient to add
    it as data. To optimize reusability, we define a new data-carrying class, and
    then give it some notation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨éå¸¸æ¥è¿‘å®šä¹‰ç¾¤ã€‚æˆ‘ä»¬å¯ä»¥åœ¨å¹ºåŠç¾¤ç»“æ„ä¸­æ·»åŠ ä¸€ä¸ªå­—æ®µï¼Œæ–­è¨€æ¯ä¸ªå…ƒç´ éƒ½å­˜åœ¨é€†å…ƒã€‚ä½†é‚£æ ·çš„è¯ï¼Œæˆ‘ä»¬å°±éœ€è¦åŠªåŠ›è®¿é—®è¿™äº›é€†å…ƒã€‚åœ¨å®è·µä¸­ï¼Œå°†å…¶ä½œä¸ºæ•°æ®æ·»åŠ æ›´ä¸ºæ–¹ä¾¿ã€‚ä¸ºäº†ä¼˜åŒ–å¯é‡ç”¨æ€§ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªæ–°çš„æ•°æ®æ‰¿è½½ç±»ï¼Œç„¶åç»™å®ƒä¸€äº›ç¬¦å·ã€‚
- en: '[PRE17]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The above definition may seem too weak, we only ask that `aâ»Â¹` is a left-inverse
    of `a`. But the other side is automatic. In order to prove that, we need a preliminary
    lemma.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°å®šä¹‰å¯èƒ½çœ‹èµ·æ¥å¤ªå¼±äº†ï¼Œæˆ‘ä»¬åªè¦æ±‚`aâ»Â¹`æ˜¯`a`çš„å·¦é€†ã€‚ä½†å¦ä¸€æ–¹é¢æ˜¯è‡ªåŠ¨çš„ã€‚ä¸ºäº†è¯æ˜è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåˆæ­¥çš„å¼•ç†ã€‚
- en: '[PRE18]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this lemma, it is pretty annoying to give full names, especially since it
    requires knowing which part of the hierarchy provides those facts. One way to
    fix this is to use the `export` command to copy those facts as lemmas in the root
    name space.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªå¼•ç†ä¸­ï¼Œç»™å‡ºå…¨åç›¸å½“ä»¤äººçƒ¦æ¼ï¼Œå°¤å…¶æ˜¯å½“å®ƒéœ€è¦çŸ¥é“å“ªä¸ªå±‚æ¬¡ç»“æ„æä¾›äº†è¿™äº›äº‹å®æ—¶ã€‚è§£å†³è¿™ä¸ªé—®é¢˜çš„ä¸€ç§æ–¹æ³•æ˜¯é€šè¿‡ä½¿ç”¨`export`å‘½ä»¤å°†é‚£äº›äº‹å®ä½œä¸ºæ ¹å‘½åç©ºé—´ä¸­çš„å¼•ç†æ¥å¤åˆ¶ã€‚
- en: '[PRE19]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can then rewrite the above proof as:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸Šé¢çš„è¯æ˜é‡å†™ä¸ºï¼š
- en: '[PRE20]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is now your turn to prove things about our algebraic structures.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è½®åˆ°ä½ æ¥è¯æ˜å…³äºæˆ‘ä»¬çš„ä»£æ•°ç»“æ„çš„äº‹æƒ…äº†ã€‚
- en: '[PRE21]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: At this stage we would like to move on to define rings, but there is a serious
    issue. A ring structure on a type contains both an additive group structure and
    a multiplicative monoid structure, and some properties about their interaction.
    But so far we hard-coded a notation `â‹„` for all our operations. More fundamentally,
    the type class system assumes every type has only one instance of each type class.
    There are various ways to solve this issue. Surprisingly Mathlib uses the naive
    idea to duplicate everything for additive and multiplicative theories with the
    help of some code-generating attribute. Structures and classes are defined in
    both additive and multiplicative notation with an attribute `to_additive` linking
    them. In case of multiple inheritance like for semi-groups, the auto-generated
    â€œsymmetry-restoringâ€ instances need also to be marked. This is a bit technical;
    you donâ€™t need to understand details. The important point is that lemmas are then
    only stated in multiplicative notation and marked with the attribute `to_additive`
    to generate the additive version as `left_inv_eq_right_inv'` with its auto-generated
    additive version `left_neg_eq_right_neg'`. In order to check the name of this
    additive version we used the `whatsnew in` command on top of `left_inv_eq_right_inv'`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªé˜¶æ®µï¼Œæˆ‘ä»¬å¸Œæœ›ç»§ç»­å®šä¹‰ç¯ï¼Œä½†æœ‰ä¸€ä¸ªä¸¥é‡çš„é—®é¢˜ã€‚ä¸€ä¸ªç±»å‹ä¸Šçš„ç¯ç»“æ„åŒ…å«ä¸€ä¸ªåŠ æ³•ç¾¤ç»“æ„å’Œä¹˜æ³•å¹ºåŠç¾¤ç»“æ„ï¼Œä»¥åŠå…³äºå®ƒä»¬ä¹‹é—´ç›¸äº’ä½œç”¨çš„ä¸€äº›æ€§è´¨ã€‚ä½†åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¸ºæ‰€æœ‰æ“ä½œç¡¬ç¼–ç äº†ä¸€ä¸ªç¬¦å·
    `â‹„`ã€‚æ›´åŸºæœ¬çš„æ˜¯ï¼Œç±»å‹ç±»ç³»ç»Ÿå‡è®¾æ¯ä¸ªç±»å‹åªæœ‰ä¸€ä¸ªç±»å‹ç±»çš„å®ä¾‹ã€‚æœ‰å„ç§æ–¹æ³•å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ä»¤äººæƒŠè®¶çš„æ˜¯ï¼ŒMathlib ä½¿ç”¨äº†å¤åˆ¶åŠ æ³•å’Œä¹˜æ³•ç†è®ºçš„åŸå§‹æƒ³æ³•ï¼Œè¿™å¾—ç›Šäºä¸€äº›ä»£ç ç”Ÿæˆå±æ€§ã€‚ç»“æ„å’Œç±»éƒ½åœ¨åŠ æ³•å’Œä¹˜æ³•ç¬¦å·ä¸­å®šä¹‰ï¼Œå¹¶é€šè¿‡
    `to_additive` å±æ€§å°†å®ƒä»¬é“¾æ¥èµ·æ¥ã€‚åœ¨åƒåŠç¾¤è¿™æ ·çš„å¤šé‡ç»§æ‰¿çš„æƒ…å†µä¸‹ï¼Œè‡ªåŠ¨ç”Ÿæˆçš„â€œå¯¹ç§°æ¢å¤â€å®ä¾‹ä¹Ÿéœ€è¦æ ‡è®°ã€‚è¿™æœ‰ç‚¹æŠ€æœ¯æ€§ï¼›ä½ ä¸éœ€è¦ç†è§£ç»†èŠ‚ã€‚é‡è¦çš„æ˜¯ï¼Œå¼•ç†åªä»¥ä¹˜æ³•ç¬¦å·è¡¨ç¤ºï¼Œå¹¶æ ‡è®°ä¸º
    `to_additive` ä»¥ç”ŸæˆåŠ æ³•ç‰ˆæœ¬ `left_inv_eq_right_inv'` åŠå…¶è‡ªåŠ¨ç”Ÿæˆçš„åŠ æ³•ç‰ˆæœ¬ `left_neg_eq_right_neg'`ã€‚ä¸ºäº†æ£€æŸ¥è¿™ä¸ªåŠ æ³•ç‰ˆæœ¬çš„åå­—ï¼Œæˆ‘ä»¬åœ¨
    `left_inv_eq_right_inv'` çš„é¡¶éƒ¨ä½¿ç”¨äº† `whatsnew in` å‘½ä»¤ã€‚
- en: '[PRE22]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Equipped with this technology, we can easily define also commutative semigroups,
    monoids and groups, and then define rings.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: é…å¤‡äº†è¿™é¡¹æŠ€æœ¯ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è½»æ¾åœ°å®šä¹‰äº¤æ¢åŠç¾¤ã€å¹ºåŠç¾¤å’Œç¾¤ï¼Œç„¶åå®šä¹‰ç¯ã€‚
- en: '[PRE23]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We should remember to tag lemmas with `simp` when appropriate.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åº”è¯¥è®°ä½åœ¨é€‚å½“çš„æ—¶å€™ç”¨ `simp` æ ‡è®°å¼•ç†ã€‚
- en: '[PRE24]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then we need to repeat ourselves a bit since we switch to standard notations,
    but at least `to_additive` does the work of translating from the multiplicative
    notation to the additive one.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œç”±äºæˆ‘ä»¬è½¬å‘äº†æ ‡å‡†ç¬¦å·ï¼Œæˆ‘ä»¬éœ€è¦é‡å¤è¯´æ˜ä¸€ç‚¹ï¼Œä½†è‡³å°‘ `to_additive` æ‰§è¡Œäº†å°†ä¹˜æ³•ç¬¦å·è½¬æ¢ä¸ºåŠ æ³•ç¬¦å·çš„è½¬æ¢å·¥ä½œã€‚
- en: '[PRE25]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that `to_additive` can be asked to tag a lemma with `simp` and propagate
    that attribute to the additive version as follows.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ`to_additive` å¯ä»¥è¢«è¦æ±‚ä¸ºå¼•ç†æ ‡è®° `simp` å¹¶å°†æ­¤å±æ€§ä¼ æ’­åˆ°åŠ æ³•ç‰ˆæœ¬ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚
- en: '[PRE26]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We are now ready for rings. For demonstration purposes we wonâ€™t assume that
    addition is commutative, and then immediately provide an instance of `AddCommGroupâ‚ƒ`.
    Mathlib does not play this game, first because in practice this does not make
    any ring instance easier and also because Mathlibâ€™s algebraic hierarchy goes through
    semirings which are like rings but without opposites so that the proof below does
    not work for them. What we gain here, besides a nice exercise if you have never
    seen it, is an example of building an instance using the syntax that allows to
    provide a parent structure as an instance parameter and then supply the extra
    fields. Here the Ringâ‚ƒ R argument supplies anything AddCommGroupâ‚ƒ R wants except
    for add_comm.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»å‡†å¤‡å¥½å®šä¹‰ç¯äº†ã€‚ä¸ºäº†æ¼”ç¤ºç›®çš„ï¼Œæˆ‘ä»¬ä¸ä¼šå‡è®¾åŠ æ³•æ˜¯äº¤æ¢çš„ï¼Œç„¶åç«‹å³æä¾›ä¸€ä¸ª `AddCommGroupâ‚ƒ` çš„å®ä¾‹ã€‚Mathlib ä¸ç©è¿™ç§æ¸¸æˆï¼Œé¦–å…ˆæ˜¯å› ä¸ºåœ¨å®è·µä¸­è¿™å¹¶ä¸ä¼šä½¿ä»»ä½•ç¯å®ä¾‹æ›´å®¹æ˜“ï¼Œè€Œä¸”
    Mathlib çš„ä»£æ•°å±‚æ¬¡ç»“æ„é€šè¿‡åŠç¯ï¼Œè¿™äº›åŠç¯ç±»ä¼¼äºç¯ä½†æ²¡æœ‰ç›¸åå…ƒç´ ï¼Œå› æ­¤ä¸‹é¢çš„è¯æ˜å¯¹å®ƒä»¬ä¸é€‚ç”¨ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œè·å¾—çš„å¥½å¤„ï¼Œé™¤äº†å¦‚æœä½ ä»æœªè§è¿‡å®ƒï¼Œå®ƒæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ç»ƒä¹ ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªä½¿ç”¨å…è®¸å°†çˆ¶ç»“æ„ä½œä¸ºå®ä¾‹å‚æ•°æä¾›çš„è¯­æ³•æ„å»ºå®ä¾‹çš„ä¾‹å­ï¼Œç„¶åæä¾›é¢å¤–çš„å­—æ®µã€‚è¿™é‡Œ
    Ringâ‚ƒ R å‚æ•°ä¸º AddCommGroupâ‚ƒ R æä¾›äº†æ‰€æœ‰éœ€è¦çš„ä¸œè¥¿ï¼Œé™¤äº† add_commã€‚
- en: '[PRE27]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Of course we can also build concrete instances, such as a ring structure on
    integers (of course the instance below uses that all the work is already done
    in Mathlib).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æ„å»ºå…·ä½“çš„å®ä¾‹ï¼Œä¾‹å¦‚æ•´æ•°ä¸Šçš„ç¯ç»“æ„ï¼ˆå½“ç„¶ä¸‹é¢çš„å®ä¾‹ä½¿ç”¨çš„æ˜¯ Mathlib ä¸­å·²ç»å®Œæˆçš„æ‰€æœ‰å·¥ä½œï¼‰ã€‚
- en: '[PRE28]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As an exercise you can now set up a simple hierarchy for order relations, including
    a class for ordered commutative monoids, which have both a partial order and a
    commutative monoid structure such that `âˆ€ a b : Î±, a â‰¤ b â†’ âˆ€ c : Î±, c * a â‰¤ c
    * b`. Of course you need to add fields and maybe `extends` clauses to the following
    classes.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä½œä¸ºç»ƒä¹ ï¼Œä½ ç°åœ¨å¯ä»¥è®¾ç½®ä¸€ä¸ªç®€å•çš„å±‚æ¬¡ç»“æ„ï¼ŒåŒ…æ‹¬ä¸€ä¸ªæœ‰åºäº¤æ¢å¹ºåŠç¾¤ç±»ï¼Œå®ƒå…·æœ‰éƒ¨åˆ†åºå’Œäº¤æ¢å¹ºåŠç¾¤ç»“æ„ï¼Œä½¿å¾—`âˆ€ a b : Î±, a â‰¤ b â†’ âˆ€ c
    : Î±, c * a â‰¤ c * b`ã€‚å½“ç„¶ï¼Œä½ éœ€è¦ä¸ºä»¥ä¸‹ç±»æ·»åŠ å­—æ®µå’Œå¯èƒ½`extends`å­å¥ã€‚'
- en: '[PRE29]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We now want to discuss algebraic structures involving several types. The prime
    example is modules over rings. If you donâ€™t know what is a module, you can pretend
    it means vector space and think that all our rings are fields. Those structures
    are commutative additive groups equipped with a scalar multiplication by elements
    of some ring.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬æƒ³è¦è®¨è®ºæ¶‰åŠå¤šä¸ªç±»å‹çš„ä»£æ•°ç»“æ„ã€‚ä¸€ä¸ªå…¸å‹çš„ä¾‹å­æ˜¯ç¯ä¸Šçš„æ¨¡å—ã€‚å¦‚æœä½ ä¸çŸ¥é“ä»€ä¹ˆæ˜¯æ¨¡å—ï¼Œä½ å¯ä»¥å‡è£…å®ƒæ„å‘³ç€å‘é‡ç©ºé—´ï¼Œå¹¶è®¤ä¸ºæˆ‘ä»¬æ‰€æœ‰çš„ç¯éƒ½æ˜¯åŸŸã€‚è¿™äº›ç»“æ„æ˜¯å¸¦æœ‰æŸäº›ç¯å…ƒç´ çš„æ ‡é‡ä¹˜æ³•çš„äº¤æ¢åŠ æ³•ç¾¤ã€‚
- en: We first define the data-carrying type class of scalar multiplication by some
    type `Î±` on some type `Î²`, and give it a right associative notation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é¦–å…ˆå®šä¹‰ç”±æŸäº›ç±»å‹`Î±`åœ¨æŸä¸ªç±»å‹`Î²`ä¸Šçš„ä¸€äº›ç±»å‹`Î±`å®šä¹‰çš„æ ‡é‡ä¹˜æ³•çš„æºå¸¦æ•°æ®ç±»å‹ç±»ï¼Œå¹¶ç»™å®ƒä¸€ä¸ªå³ç»“åˆçš„ç¬¦å·ã€‚
- en: '[PRE30]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then we can define modules (again think about vector spaces if you donâ€™t know
    what is a module).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰æ¨¡å—ï¼ˆå¦‚æœä½ ä¸çŸ¥é“ä»€ä¹ˆæ˜¯æ¨¡å—ï¼Œå¯ä»¥å†æ¬¡è€ƒè™‘å‘é‡ç©ºé—´ï¼‰ã€‚
- en: '[PRE31]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There is something interesting going on here. While it isnâ€™t too surprising
    that the ring structure on `R` is a parameter in this definition, you probably
    expected `AddCommGroupâ‚ƒ M` to be part of the `extends` clause just as `SMulâ‚ƒ R
    M` is. Trying to do that would lead to a mysterious sounding error message: `cannot
    find synthesization order for instance Moduleâ‚.toAddCommGroupâ‚ƒ with type (R :
    Type) â†’ [inst : Ringâ‚ƒ R] â†’ {M : Type} â†’ [self : Moduleâ‚ R M] â†’ AddCommGroupâ‚ƒ M
    all remaining arguments have metavariables: Ringâ‚ƒ ?R @Moduleâ‚ ?R ?instâœ M`. In
    order to understand this message, you need to remember that such an `extends`
    clause would lead to a field `Moduleâ‚ƒ.toAddCommGroupâ‚ƒ` marked as an instance.
    This instance would have the signature appearing in the error message: `(R : Type)
    â†’ [inst : Ringâ‚ƒ R] â†’ {M : Type} â†’ [self : Moduleâ‚ R M] â†’ AddCommGroupâ‚ƒ M`. With
    such an instance in the type class database, each time Lean would look for a `AddCommGroupâ‚ƒ
    M` instance for some `M`, it would need to go hunting for a completely unspecified
    type `R` and a `Ringâ‚ƒ R` instance before embarking on the main quest of finding
    a `Moduleâ‚ R M` instance. Those two side-quests are represented by the meta-variables
    mentioned in the error message and denoted by `?R` and `?instâœ` there. Such a
    `Moduleâ‚ƒ.toAddCommGroupâ‚ƒ` instance would then be a huge trap for the instance
    resolution procedure and then `class` command refuses to set it up.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™é‡Œæœ‰ä¸€äº›æœ‰è¶£çš„äº‹æƒ…æ­£åœ¨å‘ç”Ÿã€‚è™½ç„¶åœ¨è¿™ä¸ªå®šä¹‰ä¸­ï¼Œ`R`ä¸Šçš„ç¯ç»“æ„æ˜¯ä¸€ä¸ªå‚æ•°å¹¶ä¸å¤ªä»¤äººæƒŠè®¶ï¼Œä½†ä½ å¯èƒ½é¢„è®¡`AddCommGroupâ‚ƒ M`å°†åƒ`SMulâ‚ƒ
    R M`ä¸€æ ·æˆä¸º`extends`å­å¥çš„ä¸€éƒ¨åˆ†ã€‚å°è¯•è¿™æ ·åšä¼šå¯¼è‡´ä¸€ä¸ªå¬èµ·æ¥å¾ˆç¥ç§˜çš„é”™è¯¯ä¿¡æ¯ï¼šâ€œæ— æ³•ä¸ºå®ä¾‹Moduleâ‚.toAddCommGroupâ‚ƒæ‰¾åˆ°åˆæˆé¡ºåºï¼Œç±»å‹ä¸º(R
    : Type) â†’ [inst : Ringâ‚ƒ R] â†’ {M : Type} â†’ [self : Moduleâ‚ R M] â†’ AddCommGroupâ‚ƒ
    Mï¼Œæ‰€æœ‰å‰©ä½™çš„å‚æ•°éƒ½æœ‰å…ƒå˜é‡ï¼šRingâ‚ƒ ?R @Moduleâ‚ ?R ?instâœ Mâ€ã€‚ä¸ºäº†ç†è§£è¿™æ¡ä¿¡æ¯ï¼Œä½ éœ€è¦è®°ä½ï¼Œè¿™æ ·çš„`extends`å­å¥ä¼šå¯¼è‡´ä¸€ä¸ªæ ‡è®°ä¸ºå®ä¾‹çš„å­—æ®µ`Moduleâ‚ƒ.toAddCommGroupâ‚ƒ`ã€‚è¿™ä¸ªå®ä¾‹å°†å…·æœ‰é”™è¯¯ä¿¡æ¯ä¸­å‡ºç°çš„ç­¾åï¼š(R
    : Type) â†’ [inst : Ringâ‚ƒ R] â†’ {M : Type} â†’ [self : Moduleâ‚ R M] â†’ AddCommGroupâ‚ƒ
    Mã€‚åœ¨ç±»å‹ç±»æ•°æ®åº“ä¸­æ‹¥æœ‰è¿™æ ·çš„å®ä¾‹åï¼Œæ¯æ¬¡Leanå¯»æ‰¾æŸä¸ª`M`çš„`AddCommGroupâ‚ƒ M`å®ä¾‹æ—¶ï¼Œå®ƒéƒ½éœ€è¦åœ¨å¼€å§‹å¯»æ‰¾`Moduleâ‚ R M`å®ä¾‹çš„ä¸»è¦ä»»åŠ¡ä¹‹å‰ï¼Œå»å¯»æ‰¾ä¸€ä¸ªå®Œå…¨æœªæŒ‡å®šçš„ç±»å‹`R`å’Œä¸€ä¸ª`Ringâ‚ƒ
    R`å®ä¾‹ã€‚è¿™ä¸¤ä¸ªè¾…åŠ©ä»»åŠ¡æ˜¯é”™è¯¯ä¿¡æ¯ä¸­æåˆ°çš„å…ƒå˜é‡æ‰€ä»£è¡¨çš„ï¼Œåˆ†åˆ«ç”¨`?R`å’Œ`?instâœ`è¡¨ç¤ºã€‚è¿™æ ·çš„`Moduleâ‚ƒ.toAddCommGroupâ‚ƒ`å®ä¾‹å°†æ˜¯å¯¹å®ä¾‹è§£æè¿‡ç¨‹çš„å·¨å¤§é™·é˜±ï¼Œç„¶å`class`å‘½ä»¤æ‹’ç»è®¾ç½®å®ƒã€‚'
- en: 'What about `extends SMulâ‚ƒ R M` then? That one creates a field `Moduleâ‚.toSMulâ‚ƒ
    : {R : Type} â†’Â  [inst : Ringâ‚ƒ R] â†’ {M : Type} â†’ [inst_1 : AddCommGroupâ‚ƒ M] â†’ [self
    : Moduleâ‚ R M] â†’ SMulâ‚ƒ R M` whose end result `SMulâ‚ƒ R M` mentions both `R` and
    `M` so this field can safely be used as an instance. The rule is easy to remember:
    each class appearing in the `extends` clause should mention every type appearing
    in the parameters.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 'é‚£ä¹ˆ`extends SMulâ‚ƒ R M`åˆæ˜¯æ€ä¹ˆå›äº‹å‘¢ï¼Ÿå®ƒåˆ›å»ºäº†ä¸€ä¸ªåŸŸ`Moduleâ‚.toSMulâ‚ƒ : {R : Type} â†’ [inst :
    Ringâ‚ƒ R] â†’ {M : Type} â†’ [inst_1 : AddCommGroupâ‚ƒ M] â†’ [self : Moduleâ‚ R M] â†’ SMulâ‚ƒ
    R M`ï¼Œå…¶æœ€ç»ˆç»“æœ`SMulâ‚ƒ R M`æåˆ°äº†`R`å’Œ`M`ï¼Œå› æ­¤è¿™ä¸ªåŸŸå¯ä»¥å®‰å…¨åœ°ç”¨ä½œå®ä¾‹ã€‚è§„åˆ™å¾ˆå®¹æ˜“è®°ä½ï¼š`extends`å­å¥ä¸­å‡ºç°çš„æ¯ä¸ªç±»éƒ½åº”è¯¥æåˆ°å‚æ•°ä¸­å‡ºç°çš„æ¯ä¸ªç±»å‹ã€‚'
- en: 'Let us create our first module instance: a ring is a module over itself using
    its multiplication as a scalar multiplication.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åˆ›å»ºç¬¬ä¸€ä¸ªæ¨¡å—å®ä¾‹ï¼šä¸€ä¸ªç¯æ˜¯å…¶è‡ªèº«ä¸Šçš„ä¸€ä¸ªæ¨¡å—ï¼Œä½¿ç”¨å…¶ä¹˜æ³•ä½œä¸ºæ ‡é‡ä¹˜æ³•ã€‚
- en: '[PRE32]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As a second example, every abelian group is a module over `â„¤` (this is one
    of the reason to generalize the theory of vector spaces by allowing non-invertible
    scalars). First one can define scalar multiplication by a natural number for any
    type equipped with a zero and an addition: `n â€¢ a` is defined as `a + â‹¯ + a` where
    `a` appears `n` times. Then this is extended to scalar multiplication by an integer
    by ensuring `(-1) â€¢ a = -a`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç¬¬äºŒä¸ªä¾‹å­ï¼Œæ¯ä¸ªé˜¿è´å°”ç¾¤éƒ½æ˜¯ `â„¤` ä¸Šçš„ä¸€ä¸ªæ¨¡å—ï¼ˆè¿™ä¹Ÿæ˜¯é€šè¿‡å…è®¸éå¯é€†æ ‡é‡æ¥æ¨å¹¿å‘é‡ç©ºé—´ç†è®ºçš„åŸå› ä¹‹ä¸€ï¼‰ã€‚é¦–å…ˆï¼Œå¯ä»¥ä¸ºä»»ä½•å¸¦æœ‰é›¶å’ŒåŠ æ³•çš„ç±»å‹å®šä¹‰è‡ªç„¶æ•°çš„æ ‡é‡ä¹˜æ³•ï¼š`n
    â€¢ a` è¢«å®šä¹‰ä¸º `a + â‹¯ + a`ï¼Œå…¶ä¸­ `a` å‡ºç° `n` æ¬¡ã€‚ç„¶åï¼Œé€šè¿‡ç¡®ä¿ `(-1) â€¢ a = -a` æ¥å°†å…¶æ‰©å±•åˆ°æ•´æ•°çš„æ ‡é‡ä¹˜æ³•ã€‚
- en: '[PRE33]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Proving this gives rise to a module structure is a bit tedious and not interesting
    for the current discussion, so we will sorry all axioms. You are *not* asked to
    replace those sorries with proofs. If you insist on doing it then you will probably
    want to state and prove several intermediate lemmas about `nsmulâ‚` and `zsmulâ‚`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: è¯æ˜è¿™ä¸€ç‚¹å¹¶å¾—å‡ºä¸€ä¸ªæ¨¡å—ç»“æ„æœ‰ç‚¹ç¹çï¼Œå¹¶ä¸”å¯¹äºå½“å‰çš„è®¨è®ºæ¥è¯´å¹¶ä¸æœ‰è¶£ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†å¯¹æ‰€æœ‰å…¬ç†è¡¨ç¤ºæ­‰æ„ã€‚ä½ **ä¸éœ€è¦**ç”¨è¯æ˜æ¥æ›¿æ¢è¿™äº›æ­‰æ„ã€‚å¦‚æœä½ åšæŒè¿™æ ·åšï¼Œé‚£ä¹ˆä½ å¯èƒ½éœ€è¦é™ˆè¿°å¹¶è¯æ˜å…³äº
    `nsmulâ‚` å’Œ `zsmulâ‚` çš„å‡ ä¸ªä¸­é—´å¼•ç†ã€‚
- en: '[PRE34]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A much more important issue is that we now have two module structures over
    the ring `â„¤` for `â„¤` itself: `abGrpModule â„¤` since `â„¤` is a abelian group, and
    `selfModule â„¤` since `â„¤` is a ring. Those two module structure correspond to the
    same abelian group structure, but it is not obvious that they have the same scalar
    multiplication. They actually do, but this isnâ€™t true by definition, it requires
    a proof. This is very bad news for the type class instance resolution procedure
    and will lead to very frustrating failures for users of this hierarchy. When directly
    asked to find an instance, Lean will pick one, and we can see which one using:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ›´åŠ é‡è¦çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬ç°åœ¨åœ¨ `â„¤` ç¯ä¸Šå¯¹ `â„¤` æœ¬èº«æœ‰ä¸¤ä¸ªæ¨¡å—ç»“æ„ï¼š`abGrpModule â„¤`ï¼Œå› ä¸º `â„¤` æ˜¯ä¸€ä¸ªé˜¿è´å°”ç¾¤ï¼Œä»¥åŠ `selfModule
    â„¤`ï¼Œå› ä¸º `â„¤` æ˜¯ä¸€ä¸ªç¯ã€‚è¿™ä¸¤ä¸ªæ¨¡å—ç»“æ„å¯¹åº”äºç›¸åŒçš„é˜¿è´å°”ç¾¤ç»“æ„ï¼Œä½†å®ƒä»¬æ˜¯å¦å…·æœ‰ç›¸åŒçš„æ ‡é‡ä¹˜æ³•å¹¶ä¸æ˜æ˜¾ã€‚å®é™…ä¸Šï¼Œå®ƒä»¬ç¡®å®å¦‚æ­¤ï¼Œä½†è¿™å¹¶ä¸æ˜¯å®šä¹‰ä¸Šçš„ï¼Œéœ€è¦è¯æ˜ã€‚è¿™å¯¹ç±»å‹ç±»å®ä¾‹è§£æè¿‡ç¨‹æ¥è¯´æ˜¯ä¸ªåæ¶ˆæ¯ï¼Œå¹¶å°†å¯¼è‡´ç”¨æˆ·åœ¨ä½¿ç”¨è¿™ä¸ªå±‚æ¬¡ç»“æ„æ—¶é‡åˆ°éå¸¸ä»¤äººæ²®ä¸§çš„å¤±è´¥ã€‚å½“ç›´æ¥è¦æ±‚æ‰¾åˆ°ä¸€ä¸ªå®ä¾‹æ—¶ï¼ŒLean
    ä¼šé€‰æ‹©ä¸€ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ–¹å¼æ¥æŸ¥çœ‹å®ƒï¼š
- en: '[PRE35]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: But in a more indirect context it can happen that Lean infers the other one
    and then gets confused. This situation is known as a bad diamond. This has nothing
    to do with the diamond operation we used above, it refers to the way one can draw
    the paths from `â„¤` to its `Moduleâ‚ â„¤` going through either `AddCommGroupâ‚ƒ â„¤` or
    `Ringâ‚ƒ â„¤`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†åœ¨æ›´é—´æ¥çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œå¯èƒ½ä¼šå‘ç”Ÿ Lean æ¨æ–­å‡ºå¦ä¸€ä¸ªï¼Œç„¶åå˜å¾—å›°æƒ‘çš„æƒ…å†µã€‚è¿™ç§æƒ…å†µè¢«ç§°ä¸ºâ€œåé’»çŸ³â€ã€‚è¿™ä¸æˆ‘ä»¬ä¸Šé¢ä½¿ç”¨çš„é’»çŸ³æ“ä½œæ— å…³ï¼Œå®ƒæŒ‡çš„æ˜¯ä» `â„¤`
    åˆ°å…¶ `Moduleâ‚ â„¤` çš„è·¯å¾„ç»˜åˆ¶æ–¹å¼ï¼Œæ— è®ºæ˜¯é€šè¿‡ `AddCommGroupâ‚ƒ â„¤` è¿˜æ˜¯ `Ringâ‚ƒ â„¤`ã€‚
- en: It is important to understand that not all diamonds are bad. In fact there are
    diamonds everywhere in Mathlib, and also in this chapter. Already at the very
    beginning we saw one can go from `Monoidâ‚ Î±` to `Diaâ‚ Î±` through either `Semigroupâ‚
    Î±` or `DiaOneClassâ‚ Î±` and thanks to the work done by the `class` command, the
    resulting two `Diaâ‚ Î±` instances are definitionally equal. In particular a diamond
    having a `Prop`-valued class at the bottom cannot be bad since any two proofs
    of the same statement are definitionally equal.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: é‡è¦çš„æ˜¯è¦ç†è§£å¹¶éæ‰€æœ‰é’»çŸ³éƒ½æ˜¯åçš„ã€‚äº‹å®ä¸Šï¼ŒMathlib ä¸­åˆ°å¤„éƒ½æ˜¯é’»çŸ³ï¼Œæœ¬ç« ä¹Ÿæ˜¯å¦‚æ­¤ã€‚åœ¨éå¸¸å¼€å§‹çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±çœ‹åˆ°äº†å¯ä»¥ä» `Monoidâ‚ Î±`
    é€šè¿‡ `Semigroupâ‚ Î±` æˆ– `DiaOneClassâ‚ Î±` åˆ° `Diaâ‚ Î±` çš„è½¬æ¢ï¼Œå¹¶ä¸”ç”±äº `class` å‘½ä»¤çš„å·¥ä½œï¼Œå¾—åˆ°çš„ä¸¤ä¸ª `Diaâ‚
    Î±` å®ä¾‹åœ¨å®šä¹‰ä¸Šæ˜¯ç›¸ç­‰çš„ã€‚ç‰¹åˆ«æ˜¯ï¼Œåº•éƒ¨æœ‰ `Prop` å€¼ç±»çš„ä¸€ä¸ªé’»çŸ³ä¸èƒ½æ˜¯åçš„ï¼Œå› ä¸ºä»»ä½•ä¸¤ä¸ªç›¸åŒé™ˆè¿°çš„è¯æ˜åœ¨å®šä¹‰ä¸Šæ˜¯ç›¸ç­‰çš„ã€‚
- en: But the diamond we created with modules is definitely bad. The offending piece
    is the `smul` field which is data, not a proof, and we have two constructions
    that are not definitionally equal. The robust way of fixing this issue is to make
    sure that going from a rich structure to a poor structure is always done by forgetting
    data, not by defining data. This well-known pattern has been named â€œforgetful
    inheritanceâ€ and extensively discussed in [https://inria.hal.science/hal-02463336v2](https://inria.hal.science/hal-02463336v2).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æˆ‘ä»¬ç”¨æ¨¡å—åˆ›å»ºçš„é’»çŸ³è‚¯å®šæ˜¯ä¸å¥½çš„ã€‚é—®é¢˜åœ¨äº `smul` å­—æ®µï¼Œå®ƒæ˜¯æ•°æ®ï¼Œè€Œä¸æ˜¯è¯æ˜ï¼Œæˆ‘ä»¬æœ‰ä¸¤ç§ä¸æ˜¯å®šä¹‰ä¸Šç›¸ç­‰çš„æ„é€ ã€‚ä¿®å¤è¿™ä¸ªé—®é¢˜çš„ç¨³å¥æ–¹å¼æ˜¯ç¡®ä¿ä»ä¸°å¯Œç»“æ„åˆ°è´«å¼±ç»“æ„çš„è½¬æ¢æ€»æ˜¯é€šè¿‡å¿˜è®°æ•°æ®æ¥å®Œæˆçš„ï¼Œè€Œä¸æ˜¯é€šè¿‡å®šä¹‰æ•°æ®ã€‚è¿™ä¸ªä¼—æ‰€å‘¨çŸ¥çš„è®¾è®¡æ¨¡å¼è¢«å‘½åä¸ºâ€œé—å¿˜ç»§æ‰¿â€ï¼Œå¹¶åœ¨[https://inria.hal.science/hal-02463336v2](https://inria.hal.science/hal-02463336v2)ä¸­å¹¿æ³›è®¨è®ºã€‚
- en: In our concrete case, we can modify the definition of `AddMonoidâ‚ƒ` to include
    a `nsmul` data field and some `Prop`-valued fields ensuring this operation is
    provably the one we constructed above. Those fields are given default values using
    `:=` after their type in the definition below. Thanks to these default values,
    most instances would be constructed exactly as with our previous definitions.
    But in the special case of `â„¤` we will be able to provide specific values.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬çš„å…·ä½“æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ä¿®æ”¹`AddMonoidâ‚ƒ`çš„å®šä¹‰ï¼ŒåŒ…æ‹¬ä¸€ä¸ª`nsmul`æ•°æ®å­—æ®µå’Œä¸€äº›`Prop`ç±»å‹çš„å­—æ®µï¼Œä»¥ç¡®ä¿è¿™ä¸ªæ“ä½œæ˜¯å¯è¯æ˜çš„ï¼Œæ­£å¦‚æˆ‘ä»¬ä¸Šé¢æ„é€ çš„é‚£æ ·ã€‚è¿™äº›å­—æ®µåœ¨ä¸‹é¢çš„å®šä¹‰ä¸­ä½¿ç”¨`:=`åœ¨å®ƒä»¬çš„ç±»å‹ä¹‹åç»™å‡ºé»˜è®¤å€¼ã€‚å¤šäºäº†è¿™äº›é»˜è®¤å€¼ï¼Œå¤§å¤šæ•°å®ä¾‹å°†ä¸æˆ‘ä»¬ä¹‹å‰çš„å®šä¹‰å®Œå…¨ä¸€æ ·æ„å»ºã€‚ä½†åœ¨`â„¤`çš„ç‰¹æ®Šæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†èƒ½å¤Ÿæä¾›ç‰¹å®šçš„å€¼ã€‚
- en: '[PRE36]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let us check we can still construct a product monoid instance without providing
    the `nsmul` related fields.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦ä»ç„¶å¯ä»¥æ„å»ºä¸€ä¸ªä¸æä¾›`nsmul`ç›¸å…³å­—æ®µçš„ä¹˜ç§¯å•ç¾¤å®ä¾‹ã€‚
- en: '[PRE37]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: And now let us handle the special case of `â„¤` where we want to build `nsmul`
    using the coercion of `â„•` to `â„¤` and the multiplication on `â„¤`. Note in particular
    how the proof fields contain more work than in the default value above.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ¥å¤„ç†`â„¤`çš„ç‰¹æ®Šæƒ…å†µï¼Œæˆ‘ä»¬æƒ³è¦ä½¿ç”¨`â„•`åˆ°`â„¤`çš„å¼ºåˆ¶è½¬æ¢å’Œ`â„¤`ä¸Šçš„ä¹˜æ³•æ¥æ„å»º`nsmul`ã€‚ç‰¹åˆ«æ³¨æ„çš„æ˜¯ï¼Œè¯æ˜å­—æ®µæ¯”ä¸Šé¢çš„é»˜è®¤å€¼åŒ…å«æ›´å¤šçš„å·¥ä½œã€‚
- en: '[PRE38]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let us check we solved our issue. Because Lean already has a definition of scalar
    multiplication of a natural number and an integer, and we want to make sure our
    instance is used, we wonâ€™t use the `â€¢` notation but call `SMul.mul` and explicitly
    provide our instance defined above.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦è§£å†³äº†æˆ‘ä»¬çš„é—®é¢˜ã€‚å› ä¸ºLeanå·²ç»æœ‰ä¸€ä¸ªè‡ªç„¶æ•°å’Œæ•´æ•°æ ‡é‡ä¹˜æ³•çš„å®šä¹‰ï¼Œæˆ‘ä»¬æƒ³è¦ç¡®ä¿æˆ‘ä»¬çš„å®ä¾‹è¢«ä½¿ç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸ä¼šä½¿ç”¨`â€¢`ç¬¦å·ï¼Œè€Œæ˜¯è°ƒç”¨`SMul.mul`å¹¶æ˜ç¡®æä¾›æˆ‘ä»¬ä¸Šé¢å®šä¹‰çš„å®ä¾‹ã€‚
- en: '[PRE39]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This story then continues with incorporating a `zsmul` field into the definition
    of groups and similar tricks. You are now ready to read the definition of monoids,
    groups, rings and modules in Mathlib. There are more complicated than what we
    have seen here, because they are part of a huge hierarchy, but all principles
    have been explained above.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªæ•…äº‹ç»§ç»­è®²è¿°å°†`zsmul`å­—æ®µçº³å…¥ç¾¤çš„å®šä¹‰ä»¥åŠç±»ä¼¼çš„æŠ€å·§ã€‚ä½ ç°åœ¨å¯ä»¥é˜…è¯»Mathlibä¸­å•ç¾¤ã€ç¾¤ã€ç¯å’Œæ¨¡çš„å®šä¹‰äº†ã€‚å®ƒä»¬æ¯”æˆ‘ä»¬åœ¨è¿™é‡Œçœ‹åˆ°çš„è¦å¤æ‚ï¼Œå› ä¸ºå®ƒä»¬æ˜¯å·¨å¤§å±‚æ¬¡ç»“æ„çš„ä¸€éƒ¨åˆ†ï¼Œä½†æ‰€æœ‰åŸåˆ™éƒ½å·²åœ¨ä¸Šé¢è§£é‡Šè¿‡ã€‚
- en: 'As an exercise, you can come back to the order relation hierarchy you built
    above and try to incorporate a type class `LTâ‚` carrying the Less-Than notation
    `<â‚` and make sure that every preorder comes with a `<â‚` which has a default value
    built from `â‰¤â‚` and a `Prop`-valued field asserting the natural relation between
    those two comparison operators.  ## 8.2\. Morphisms[ïƒ](#morphisms "Link to this
    heading")'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç»ƒä¹ ï¼Œä½ å¯ä»¥å›åˆ°ä½ ä¸Šé¢æ„å»ºçš„åºå…³ç³»å±‚æ¬¡ç»“æ„ï¼Œå°è¯•å¼•å…¥ä¸€ä¸ªå¸¦æœ‰`<â‚`å°äºç¬¦å·çš„ç±»å‹ç±»`LTâ‚`ï¼Œå¹¶ç¡®ä¿æ¯ä¸ªååºéƒ½å¸¦æœ‰`<â‚`ï¼Œå®ƒæœ‰ä¸€ä¸ªä»`â‰¤â‚`æ„å»ºçš„é»˜è®¤å€¼ï¼Œä»¥åŠä¸€ä¸ª`Prop`ç±»å‹çš„å­—æ®µï¼Œæ–­è¨€è¿™ä¸¤ä¸ªæ¯”è¾ƒè¿ç®—ç¬¦ä¹‹é—´çš„è‡ªç„¶å…³ç³»ã€‚##
    8.2. æ€å°„[ïƒ](#morphisms "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: So far in this chapter, we discussed how to create a hierarchy of mathematical
    structures. But defining structures is not really completed until we have morphisms.
    There are two main approaches here. The most obvious one is to define a predicate
    on functions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œåœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬è®¨è®ºäº†å¦‚ä½•åˆ›å»ºæ•°å­¦ç»“æ„çš„å±‚æ¬¡ç»“æ„ã€‚ä½†å®šä¹‰ç»“æ„å¹¶ä¸æ˜¯çœŸæ­£å®Œæˆï¼Œç›´åˆ°æˆ‘ä»¬æœ‰æ€å°„ã€‚è¿™é‡Œæœ‰ä¸¤ç§ä¸»è¦çš„æ–¹æ³•ã€‚æœ€æ˜æ˜¾çš„ä¸€ä¸ªæ˜¯å®šä¹‰ä¸€ä¸ªå…³äºå‡½æ•°çš„è°“è¯ã€‚
- en: '[PRE40]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this definition, it is a bit unpleasant to use a conjunction. In particular
    users will need to remember the ordering we chose when they want to access the
    two conditions. So we could use a structure instead.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªå®šä¹‰ä¸­ï¼Œä½¿ç”¨è¿è¯æœ‰ç‚¹ä»¤äººä¸å¿«ã€‚ç‰¹åˆ«æ˜¯å½“ç”¨æˆ·æƒ³è¦è®¿é—®ä¸¤ä¸ªæ¡ä»¶æ—¶ï¼Œä»–ä»¬éœ€è¦è®°ä½æˆ‘ä»¬é€‰æ‹©çš„é¡ºåºã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªç»“æ„æ¥ä»£æ›¿ã€‚
- en: '[PRE41]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Once we are here, it is even tempting to make it a class and use the type class
    instance resolution procedure to automatically infer `isMonoidHomâ‚‚` for complicated
    functions out of instances for simpler functions. For instance a composition of
    monoid morphisms is a monoid morphism and this seems like a useful instance. However
    such an instance would be very tricky for the resolution procedure since it would
    need to hunt down `g âˆ˜ f` everywhere. Seeing it failing in `g (f x)` would be
    very frustrating. More generally one must always keep in mind that recognizing
    which function is applied in a given expression is a very difficult problem, called
    the â€œhigher-order unification problemâ€. So Mathlib does not use this class approach.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬åˆ°äº†è¿™é‡Œï¼Œç”šè‡³æœ‰å°†å…¶åšæˆä¸€ä¸ªç±»å¹¶ä½¿ç”¨ç±»å‹ç±»å®ä¾‹è§£æè¿‡ç¨‹è‡ªåŠ¨æ¨æ–­å‡ºå¤æ‚å‡½æ•°çš„`isMonoidHomâ‚‚`çš„è¯±æƒ‘ã€‚ä¾‹å¦‚ï¼Œå•ç¾¤åŒæ€çš„å¤åˆæ˜¯ä¸€ä¸ªå•ç¾¤åŒæ€ï¼Œè¿™ä¼¼ä¹æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„å®ä¾‹ã€‚ç„¶è€Œï¼Œè¿™æ ·çš„å®ä¾‹å¯¹äºè§£æè¿‡ç¨‹æ¥è¯´ä¼šéå¸¸æ£˜æ‰‹ï¼Œå› ä¸ºå®ƒéœ€è¦åˆ°å¤„å¯»æ‰¾`g
    âˆ˜ f`ã€‚åœ¨`g (f x)`ä¸­çœ‹åˆ°å®ƒå¤±è´¥ä¼šéå¸¸æ²®ä¸§ã€‚æ›´æ™®éåœ°è¯´ï¼Œæˆ‘ä»¬å¿…é¡»å§‹ç»ˆè®°ä½ï¼Œè¯†åˆ«ç»™å®šè¡¨è¾¾å¼ä¸­çš„å“ªä¸ªå‡½æ•°è¢«åº”ç”¨æ˜¯ä¸€ä¸ªéå¸¸å›°éš¾çš„é—®é¢˜ï¼Œè¢«ç§°ä¸ºâ€œé«˜é˜¶ç»Ÿä¸€é—®é¢˜â€ã€‚å› æ­¤ï¼ŒMathlibä¸ä½¿ç”¨è¿™ç§ç±»æ–¹æ³•ã€‚
- en: 'A more fundamental question is whether we use predicates as above (using either
    a `def` or a `structure`) or use structures bundling a function and predicates.
    This is partly a psychological issue. It is extremely rare to consider a function
    between monoids that is not a morphism. It really feels like â€œmonoid morphismâ€
    is not an adjective you can assign to a bare function, it is a noun. On the other
    hand one can argue that a continuous function between topological spaces is really
    a function that happens to be continuous. This is one reason why Mathlib has a
    `Continuous` predicate. For instance you can write:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ›´åŸºæœ¬çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬æ˜¯ä½¿ç”¨ä¸Šè¿°çš„è°“è¯ï¼ˆä½¿ç”¨`def`æˆ–`structure`ï¼‰è¿˜æ˜¯ä½¿ç”¨æ†ç»‘å‡½æ•°å’Œè°“è¯çš„ç»“æ„ã€‚è¿™åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šæ˜¯ä¸€ä¸ªå¿ƒç†é—®é¢˜ã€‚è€ƒè™‘ä¸€ä¸ªä¸æ˜¯åŒæ€çš„ä»å•ç¾¤åˆ°å•ç¾¤ä¹‹é—´çš„å‡½æ•°æ˜¯éå¸¸ç½•è§çš„ã€‚è¿™çœŸçš„æ„Ÿè§‰åƒæ˜¯â€œå•ç¾¤åŒæ€â€ä¸æ˜¯ä¸€ä¸ªä½ å¯ä»¥èµ‹äºˆè£¸å‡½æ•°çš„å½¢å®¹è¯ï¼Œå®ƒæ˜¯ä¸€ä¸ªåè¯ã€‚å¦ä¸€æ–¹é¢ï¼Œæœ‰äººå¯ä»¥äº‰è¾©è¯´ï¼Œåœ¨æ‹“æ‰‘ç©ºé—´ä¹‹é—´çš„è¿ç»­å‡½æ•°å®é™…ä¸Šæ˜¯ä¸€ä¸ªæ°å¥½æ˜¯è¿ç»­çš„å‡½æ•°ã€‚è¿™å°±æ˜¯Mathlibæœ‰`Continuous`è°“è¯çš„ä¸€ä¸ªåŸå› ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥å†™ï¼š
- en: '[PRE42]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We still have bundles of continuous functions, which are convenient for instance
    to put a topology on a space of continuous functions, but they are not the primary
    tool to work with continuity.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä»ç„¶æœ‰è¿ç»­å‡½æ•°çš„æ†ç»‘ï¼Œè¿™åœ¨ä¾‹å¦‚ç»™è¿ç»­å‡½æ•°çš„ç©ºé—´èµ‹äºˆæ‹“æ‰‘æ—¶å¾ˆæ–¹ä¾¿ï¼Œä½†å®ƒä»¬ä¸æ˜¯å¤„ç†è¿ç»­æ€§çš„ä¸»è¦å·¥å…·ã€‚
- en: 'By contrast, morphisms between monoids (or other algebraic structures) are
    bundled as in:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸æ¯”ä¹‹ä¸‹ï¼Œå•ç¾¤ï¼ˆæˆ–å…¶ä»–ä»£æ•°ç»“æ„ï¼‰ä¹‹é—´çš„åŒæ€æ˜¯æ†ç»‘åœ¨ä¸€èµ·çš„ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE43]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Of course we donâ€™t want to type `toFun` everywhere so we register a coercion
    using the `CoeFun` type class. Its first argument is the type we want to coerce
    to a function. The second argument describes the target function type. In our
    case it is always `G â†’ H` for every `f : MonoidHomâ‚ G H`. We also tag `MonoidHomâ‚.toFun`
    with the `coe` attribute to make sure it is displayed almost invisibly in the
    tactic state, simply by a `â†‘` prefix.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'å½“ç„¶ï¼Œæˆ‘ä»¬ä¸æƒ³åœ¨æ‰€æœ‰åœ°æ–¹éƒ½è¾“å…¥`toFun`ï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨`CoeFun`ç±»å‹ç±»æ³¨å†Œäº†ä¸€ä¸ªå¼ºåˆ¶è½¬æ¢ã€‚å®ƒçš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯æˆ‘ä»¬æƒ³è¦å¼ºåˆ¶è½¬æ¢ä¸ºå‡½æ•°çš„ç±»å‹ã€‚ç¬¬äºŒä¸ªå‚æ•°æè¿°äº†ç›®æ ‡å‡½æ•°ç±»å‹ã€‚åœ¨æˆ‘ä»¬çš„æƒ…å†µä¸‹ï¼Œå¯¹äºæ¯ä¸ª`f
    : MonoidHomâ‚ G H`ï¼Œå®ƒæ€»æ˜¯`G â†’ H`ã€‚æˆ‘ä»¬è¿˜ç”¨`coe`å±æ€§æ ‡è®°äº†`MonoidHomâ‚.toFun`ï¼Œä»¥ç¡®ä¿å®ƒåœ¨æˆ˜æœ¯çŠ¶æ€ä¸­å‡ ä¹ä¸å¯è§ï¼Œåªéœ€ä¸€ä¸ª`â†‘`å‰ç¼€å³å¯ã€‚'
- en: '[PRE44]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Let us check we can indeed apply a bundled monoid morphism to an element.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦çœŸçš„å¯ä»¥å°†æ†ç»‘çš„å•ç¾¤åŒæ€åº”ç”¨äºä¸€ä¸ªå…ƒç´ ã€‚
- en: '[PRE45]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We can do the same with other kind of morphisms until we reach ring morphisms.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ç”¨å…¶ä»–ç±»å‹çš„åŒæ€åšåŒæ ·çš„äº‹æƒ…ï¼Œç›´åˆ°æˆ‘ä»¬è¾¾åˆ°ç¯åŒæ€ã€‚
- en: '[PRE46]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There are a couple of issues about this approach. A minor one is we donâ€™t quite
    know where to put the `coe` attribute since the `RingHomâ‚.toFun` does not exist,
    the relevant function is `MonoidHomâ‚.toFun âˆ˜ RingHomâ‚.toMonoidHomâ‚` which is not
    a declaration that can be tagged with an attribute (but we could still define
    a `CoeFunÂ  (RingHomâ‚ R S) (fun _ â†¦ R â†’ S)` instance). A much more important one
    is that lemmas about monoid morphisms wonâ€™t directly apply to ring morphisms.
    This leaves the alternative of either juggling with `RingHomâ‚.toMonoidHomâ‚` each
    time we want to apply a monoid morphism lemma or restate every such lemmas for
    ring morphisms. Neither option is appealing so Mathlib uses a new hierarchy trick
    here. The idea is to define a type class for objects that are at least monoid
    morphisms, instantiate that class with both monoid morphisms and ring morphisms
    and use it to state every lemma. In the definition below, `F` could be `MonoidHomâ‚
    M N`, or `RingHomâ‚ M N` if `M` and `N` have a ring structure.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äºè¿™ç§æ–¹æ³•æœ‰å‡ ä¸ªé—®é¢˜ã€‚ä¸€ä¸ªè¾ƒå°çš„é—®é¢˜æ˜¯ï¼Œç”±äº`RingHomâ‚.toFun`ä¸å­˜åœ¨ï¼Œæˆ‘ä»¬ä¸å¤ªæ¸…æ¥š`coe`å±æ€§åº”è¯¥æ”¾åœ¨å“ªé‡Œï¼Œç›¸å…³çš„å‡½æ•°æ˜¯`MonoidHomâ‚.toFun
    âˆ˜ RingHomâ‚.toMonoidHomâ‚`ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªå¯ä»¥æ ‡è®°å±æ€§çš„å£°æ˜ï¼ˆä½†æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ª`CoeFunÂ  (RingHomâ‚ R S) (fun
    _ â†¦ R â†’ S)`å®ä¾‹ï¼‰ã€‚ä¸€ä¸ªæ›´é‡è¦çš„é—®é¢˜æ˜¯ï¼Œå…³äºå•ç¾¤åŒæ€çš„å¼•ç†ä¸ä¼šç›´æ¥é€‚ç”¨äºç¯åŒæ€ã€‚è¿™ç•™ä¸‹äº†ä¸¤ç§é€‰æ‹©ï¼šè¦ä¹ˆæ¯æ¬¡æƒ³è¦åº”ç”¨å•ç¾¤åŒæ€å¼•ç†æ—¶éƒ½ç©å¼„`RingHomâ‚.toMonoidHomâ‚`ï¼Œè¦ä¹ˆä¸ºç¯åŒæ€é‡æ–°é™ˆè¿°æ¯ä¸€ä¸ªè¿™æ ·çš„å¼•ç†ã€‚è¿™ä¸¤ç§é€‰æ‹©éƒ½ä¸å¸å¼•äººï¼Œå› æ­¤Mathlibåœ¨è¿™é‡Œä½¿ç”¨äº†ä¸€ä¸ªæ–°çš„å±‚æ¬¡æŠ€å·§ã€‚æƒ³æ³•æ˜¯ä¸ºè‡³å°‘æ˜¯å•ç¾¤åŒæ€çš„å¯¹è±¡å®šä¹‰ä¸€ä¸ªç±»å‹ç±»ï¼Œç”¨å•ç¾¤åŒæ€å’Œç¯åŒæ€å®ä¾‹åŒ–è¿™ä¸ªç±»ï¼Œå¹¶ä½¿ç”¨å®ƒæ¥é™ˆè¿°æ¯ä¸€ä¸ªå¼•ç†ã€‚åœ¨ä¸‹é¢çš„å®šä¹‰ä¸­ï¼Œ`F`å¯ä»¥æ˜¯`MonoidHomâ‚
    M N`ï¼Œæˆ–è€…å¦‚æœ`M`å’Œ`N`æœ‰ç¯ç»“æ„ï¼Œå¯ä»¥æ˜¯`RingHomâ‚ M N`ã€‚
- en: '[PRE47]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: However there is a problem with the above implementation. We havenâ€™t registered
    a coercion to function instance yet. Let us try to do it now.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œä¸Šè¿°å®ç°å­˜åœ¨ä¸€ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬è¿˜æ²¡æœ‰æ³¨å†Œä¸€ä¸ªè½¬æ¢åˆ°å‡½æ•°å®ä¾‹çš„å¼ºåˆ¶ã€‚ç°åœ¨è®©æˆ‘ä»¬å°è¯•åšè¿™ä»¶äº‹ã€‚
- en: '[PRE48]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Making this an instance would be bad. When faced with something like `f x`
    where the type of `f` is not a function type, Lean will try to find a `CoeFun`
    instance to coerce `f` into a function. The above function has type: `{M N F :
    Type} â†’ [Monoid M] â†’ [Monoid N] â†’ [MonoidHomClassâ‚ F M N] â†’ CoeFun F (fun x â†¦
    M â†’ N)` so, when it trying to apply it, it wouldnâ€™t be a priori clear to Lean
    in which order the unknown types `M`, `N` and `F` should be inferred. This is
    a kind of bad instance that is slightly different from the one we saw already,
    but it boils down to the same issue: without knowing `M`, Lean would have to search
    for a monoid instance on an unknown type, hence hopelessly try *every* monoid
    instance in the database. If you are curious to see the effect of such an instance
    you can type `set_option synthInstance.checkSynthOrder false in` on top of the
    above declaration, replace `def badInst` with `instance`, and look for random
    failures in this file.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'å°†å…¶ä½œä¸ºä¸€ä¸ªå®ä¾‹æ˜¯é”™è¯¯çš„ã€‚å½“é¢å¯¹ç±»ä¼¼`f x`çš„ä¸œè¥¿ï¼Œå…¶ä¸­`f`çš„ç±»å‹ä¸æ˜¯å‡½æ•°ç±»å‹æ—¶ï¼ŒLeanä¼šå°è¯•æ‰¾åˆ°ä¸€ä¸ª`CoeFun`å®ä¾‹æ¥å°†`f`è½¬æ¢æˆä¸€ä¸ªå‡½æ•°ã€‚ä¸Šè¿°å‡½æ•°çš„ç±»å‹æ˜¯ï¼š`{M
    N F : Type} â†’ [Monoid M] â†’ [Monoid N] â†’ [MonoidHomClassâ‚ F M N] â†’ CoeFun F (fun
    x â†¦ M â†’ N)`ï¼Œå› æ­¤ï¼Œå½“å®ƒå°è¯•åº”ç”¨å®ƒæ—¶ï¼ŒLeanåœ¨å…ˆéªŒä¸Šä¸æ¸…æ¥šæœªçŸ¥ç±»å‹`M`ã€`N`å’Œ`F`åº”è¯¥ä»¥ä»€ä¹ˆé¡ºåºæ¨æ–­ã€‚è¿™æ˜¯ä¸€ç§ä¸æˆ‘ä»¬å·²ç»çœ‹åˆ°çš„ç•¥æœ‰ä¸åŒçš„ä¸è‰¯å®ä¾‹ï¼Œä½†å½’ç»“ä¸ºåŒä¸€ä¸ªé—®é¢˜ï¼šä¸çŸ¥é“`M`ï¼ŒLeanå°†ä¸å¾—ä¸åœ¨ä¸€ä¸ªæœªçŸ¥ç±»å‹ä¸Šæœç´¢å•ç¾¤å®ä¾‹ï¼Œå› æ­¤ç»æœ›åœ°å°è¯•æ•°æ®åº“ä¸­çš„æ¯ä¸€ä¸ªå•ç¾¤å®ä¾‹ã€‚å¦‚æœä½ å¯¹è¿™ç§å®ä¾‹çš„æ•ˆæœæ„Ÿåˆ°å¥½å¥‡ï¼Œä½ å¯ä»¥åœ¨ä¸Šè¿°å£°æ˜é¡¶éƒ¨é”®å…¥`set_option
    synthInstance.checkSynthOrder false in`ï¼Œå°†`def badInst`æ›¿æ¢ä¸º`instance`ï¼Œå¹¶åœ¨è¿™ä¸ªæ–‡ä»¶ä¸­å¯»æ‰¾éšæœºçš„å¤±è´¥ã€‚'
- en: 'Here the solution is easy, we need to tell Lean to first search what is `F`
    and then deduce `M` and `N`. This is done using the `outParam` function. This
    function is defined as the identity function, but is still recognized by the type
    class machinery and triggers the desired behavior. Hence we can retry defining
    our class, paying attention to the `outParam` function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œè§£å†³æ–¹æ¡ˆå¾ˆç®€å•ï¼Œæˆ‘ä»¬éœ€è¦å‘Šè¯‰Leané¦–å…ˆæœç´¢`F`æ˜¯ä»€ä¹ˆï¼Œç„¶åæ¨æ–­å‡º`M`å’Œ`N`ã€‚è¿™æ˜¯é€šè¿‡ä½¿ç”¨`outParam`å‡½æ•°æ¥å®Œæˆçš„ã€‚è¿™ä¸ªå‡½æ•°å®šä¹‰ä¸ºæ’ç­‰å‡½æ•°ï¼Œä½†ä»ç„¶è¢«ç±»å‹ç±»æœºåˆ¶è¯†åˆ«å¹¶è§¦å‘æ‰€éœ€çš„è¡Œä¸ºã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥é‡æ–°å®šä¹‰æˆ‘ä»¬çš„ç±»ï¼Œæ³¨æ„`outParam`å‡½æ•°ï¼š
- en: '[PRE49]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now we can proceed with our plan to instantiate this class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥ç»§ç»­æ‰§è¡Œæˆ‘ä»¬çš„è®¡åˆ’ï¼Œå®ä¾‹åŒ–è¿™ä¸ªç±»ã€‚
- en: '[PRE50]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As promised every lemma we prove about `f : F` assuming an instance of `MonoidHomClassâ‚
    F` will apply both to monoid morphisms and ring morphisms. Let us see an example
    lemma and check it applies to both situations.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¦‚æ‰¿è¯ºçš„é‚£æ ·ï¼Œæˆ‘ä»¬å…³äº`f : F`çš„æ¯ä¸€ä¸ªå¼•ç†ï¼Œå‡è®¾`MonoidHomClassâ‚ F`çš„å®ä¾‹ï¼Œéƒ½å°†é€‚ç”¨äºå•ç¾¤åŒæ€å’Œç¯åŒæ€ã€‚è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªç¤ºä¾‹å¼•ç†å¹¶æ£€æŸ¥å®ƒæ˜¯å¦é€‚ç”¨äºè¿™ä¸¤ç§æƒ…å†µã€‚'
- en: '[PRE51]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: At first sight, it may look like we got back to our old bad idea of making `MonoidHomâ‚`
    a class. But we havenâ€™t. Everything is shifted one level of abstraction up. The
    type class resolution procedure wonâ€™t be looking for functions, it will be looking
    for either `MonoidHomâ‚` or `RingHomâ‚`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: åˆçœ‹èµ·æ¥ï¼Œå¯èƒ½çœ‹èµ·æ¥æˆ‘ä»¬å›åˆ°äº†æˆ‘ä»¬ä»¥å‰çš„è€åä¸»æ„ï¼Œå°† `MonoidHomâ‚` ä½œä¸ºç±»ã€‚ä½†æˆ‘ä»¬å¹¶æ²¡æœ‰ã€‚ä¸€åˆ‡éƒ½è¢«æå‡äº†ä¸€ä¸ªæŠ½è±¡å±‚æ¬¡ã€‚ç±»å‹ç±»è§£æè¿‡ç¨‹ä¸ä¼šå¯»æ‰¾å‡½æ•°ï¼Œå®ƒå°†å¯»æ‰¾
    `MonoidHomâ‚` æˆ– `RingHomâ‚`ã€‚
- en: One remaining issue with our approach is the presence of repetitive code around
    the `toFun` field and the corresponding `CoeFun` instance and `coe` attribute.
    It would also be better to record that this pattern is used only for functions
    with extra properties, meaning that the coercion to functions should be injective.
    So Mathlib adds one more layer of abstraction with the base class `DFunLike` (where
    â€œDFunâ€ stands for dependent function). Let us redefine our `MonoidHomClass` on
    top of this base layer.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„æ–¹æ³•ä¸­å­˜åœ¨çš„ä¸€ä¸ªé—®é¢˜æ˜¯å›´ç»• `toFun` å­—æ®µåŠå…¶å¯¹åº”çš„ `CoeFun` å®ä¾‹å’Œ `coe` å±æ€§çš„é‡å¤ä»£ç ã€‚æœ€å¥½ä¹Ÿè®°å½•ä¸‹è¿™ç§æ¨¡å¼ä»…ç”¨äºå…·æœ‰é¢å¤–å±æ€§çš„åŠŸèƒ½ï¼Œè¿™æ„å‘³ç€å‡½æ•°çš„å¼ºåˆ¶è½¬æ¢åº”è¯¥æ˜¯å•å°„çš„ã€‚å› æ­¤ï¼ŒMathlib
    é€šè¿‡æ·»åŠ ä¸€ä¸ªåŸºäºç±» `DFunLike`ï¼ˆå…¶ä¸­â€œDFunâ€ä»£è¡¨ä¾èµ–å‡½æ•°ï¼‰çš„æŠ½è±¡å±‚ã€‚è®©æˆ‘ä»¬åœ¨åŸºç¡€å±‚ä¹‹ä¸Šé‡æ–°å®šä¹‰æˆ‘ä»¬çš„ `MonoidHomClass`ã€‚
- en: '[PRE52]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Of course the hierarchy of morphisms does not stop here. We could go on and
    define a class `RingHomClassâ‚ƒ` extending `MonoidHomClassâ‚ƒ` and instantiate it
    on `RingHom` and then later on `AlgebraHom` (algebras are rings with some extra
    structure). But weâ€™ve covered the main formalization ideas used in Mathlib for
    morphisms and you should be ready to understand how morphisms are defined in Mathlib.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼ŒåŒæ€çš„å±‚æ¬¡ç»“æ„å¹¶æ²¡æœ‰åœ¨è¿™é‡Œåœæ­¢ã€‚æˆ‘ä»¬å¯ä»¥ç»§ç»­å®šä¹‰ä¸€ä¸ªæ‰©å±• `MonoidHomClassâ‚ƒ` çš„ç±» `RingHomClassâ‚ƒ`ï¼Œå¹¶åœ¨ `RingHom`
    ä¸Šå®ä¾‹åŒ–å®ƒï¼Œç„¶åç¨ååœ¨å…¶ä¸Šå®ä¾‹åŒ– `AlgebraHom`ï¼ˆä»£æ•°æ˜¯å…·æœ‰é¢å¤–ç»“æ„çš„ç¯ï¼‰ã€‚ä½†æˆ‘ä»¬å·²ç»æ¶µç›–äº† Mathlib ä¸­ç”¨äºåŒæ€çš„ä¸»è¦å½¢å¼åŒ–æ€æƒ³ï¼Œä½ åº”è¯¥å‡†å¤‡å¥½ç†è§£
    Mathlib ä¸­åŒæ€æ˜¯å¦‚ä½•å®šä¹‰çš„ã€‚
- en: As an exercise, you should try to define your class of bundled order-preserving
    function between ordered types, and then order preserving monoid morphisms. This
    is for training purposes only. Like continuous functions, order preserving functions
    are primarily unbundled in Mathlib where they are defined by the `Monotone` predicate.
    Of course you need to complete the class definitions below.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç»ƒä¹ ï¼Œä½ åº”è¯¥å°è¯•å®šä¹‰ä½ çš„æœ‰åºç±»å‹ä¹‹é—´æ‰“åŒ…çš„ä¿æŒé¡ºåºçš„å‡½æ•°ç±»ï¼Œç„¶åå®šä¹‰ä¿æŒé¡ºåºçš„å¹ºåŠç¾¤åŒæ€ã€‚è¿™åªæ˜¯ä¸ºäº†è®­ç»ƒç›®çš„ã€‚åƒè¿ç»­å‡½æ•°ä¸€æ ·ï¼Œä¿æŒé¡ºåºçš„å‡½æ•°åœ¨ Mathlib
    ä¸­ä¸»è¦æ˜¯æœªæ‰“åŒ…çš„ï¼Œå®ƒä»¬ç”± `Monotone` è°“è¯å®šä¹‰ã€‚å½“ç„¶ï¼Œä½ éœ€è¦å®Œæˆä¸‹é¢çš„ç±»å®šä¹‰ã€‚
- en: '[PRE53]  ## 8.3\. Sub-objects[ïƒ](#sub-objects "Link to this heading")'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE53]  ## 8.3\. å­å¯¹è±¡[ïƒ](#sub-objects "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")'
- en: After defining some algebraic structure and its morphisms, the next step is
    to consider sets that inherit this algebraic structure, for instance subgroups
    or subrings. This largely overlaps with our previous topic. Indeed a set in `X`
    is implemented as a function from `X` to `Prop` so sub-objects are function satisfying
    a certain predicate. Hence we can reuse of lot of the ideas that led to the `DFunLike`
    class and its descendants. We wonâ€™t reuse `DFunLike` itself because this would
    break the abstraction barrier from `Set X` to `X â†’ Prop`. Instead there is a `SetLike`
    class. Instead of wrapping an injection into a function type, that class wraps
    an injection into a `Set` type and defines the corresponding coercion and `Membership`
    instance.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®šä¹‰äº†ä¸€äº›ä»£æ•°ç»“æ„å’Œå…¶åŒæ€ä¹‹åï¼Œä¸‹ä¸€æ­¥æ˜¯è€ƒè™‘ç»§æ‰¿è¿™ç§ä»£æ•°ç»“æ„çš„é›†åˆï¼Œä¾‹å¦‚å­ç¾¤æˆ–å­ç¯ã€‚è¿™å¾ˆå¤§ç¨‹åº¦ä¸Šä¸æˆ‘ä»¬çš„å‰ä¸€ä¸ªä¸»é¢˜é‡å ã€‚å®é™…ä¸Šï¼Œ`X` ä¸­çš„é›†åˆè¢«å®ç°ä¸ºä¸€ä¸ªä»
    `X` åˆ° `Prop` çš„å‡½æ•°ï¼Œå› æ­¤å­å¯¹è±¡æ˜¯æ»¡è¶³ä¸€å®šè°“è¯çš„å‡½æ•°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥é‡ç”¨å¯¼è‡´ `DFunLike` ç±»åŠå…¶åä»£çš„è®¸å¤šæƒ³æ³•ã€‚æˆ‘ä»¬ä¸ä¼šé‡ç”¨ `DFunLike`
    æœ¬èº«ï¼Œå› ä¸ºè¿™ä¼šæ‰“ç ´ä» `Set X` åˆ° `X â†’ Prop` çš„æŠ½è±¡éšœç¢ã€‚ç›¸åï¼Œæœ‰ä¸€ä¸ª `SetLike` ç±»ã€‚è¯¥ç±»ä¸æ˜¯å°†æ³¨å…¥åŒ…è£…åˆ°å‡½æ•°ç±»å‹ä¸­ï¼Œè€Œæ˜¯å°†æ³¨å…¥åŒ…è£…åˆ°
    `Set` ç±»å‹ä¸­ï¼Œå¹¶å®šä¹‰ç›¸åº”çš„å¼ºåˆ¶è½¬æ¢å’Œ `Membership` å®ä¾‹ã€‚
- en: '[PRE54]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Equipped with the above `SetLike` instance, we can already state naturally that
    a submonoid `N` contains `1` without using `N.carrier`. We can also silently treat
    `N` as a set in `M` as take its direct image under a map.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: é…å¤‡äº†ä¸Šè¿° `SetLike` å®ä¾‹ï¼Œæˆ‘ä»¬å·²ç»åœ¨ä¸ä½¿ç”¨ `N.carrier` çš„æƒ…å†µä¸‹è‡ªç„¶åœ°é™ˆè¿°äº†ä¸€ä¸ªå­å¹ºåŠç¾¤ `N` åŒ…å« `1`ã€‚æˆ‘ä»¬è¿˜å¯ä»¥åœ¨ `M`
    ä¸­é»˜é»˜åœ°å°† `N` ä½œä¸ºé›†åˆå¤„ç†ï¼Œæˆ–è€…åœ¨å…¶æ˜ å°„ä¸‹å–å…¶ç›´æ¥åƒã€‚
- en: '[PRE55]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We also have a coercion to `Type` which uses `Subtype` so, given a submonoid
    `N` we can write a parameter `(x : N)` which can be coerced to an element of `M`
    belonging to `N`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬è¿˜æœ‰ä¸€ä¸ªå¼ºåˆ¶è½¬æ¢åˆ° `Type` çš„æ“ä½œï¼Œå®ƒä½¿ç”¨ `Subtype`ï¼Œå› æ­¤ï¼Œç»™å®šä¸€ä¸ªå­å¹ºåŠç¾¤ `N`ï¼Œæˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªå‚æ•° `(x : N)`ï¼Œå®ƒå¯ä»¥è¢«å¼ºåˆ¶è½¬æ¢åˆ°å±äº
    `M` ä¸”å±äº `N` çš„ä¸€ä¸ªå…ƒç´ ã€‚'
- en: '[PRE56]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Using this coercion to `Type` we can also tackle the task of equipping a submonoid
    with a monoid structure. We will use the coercion from the type associated to
    `N` as above, and the lemma `SetCoe.ext` asserting this coercion is injective.
    Both are provided by the `SetLike` instance.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ç§å¼ºåˆ¶è½¬æ¢ä¸º`Type`ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å¤„ç†ç»™å­å¹ºåŠç¾¤èµ‹äºˆå¹ºåŠç¾¤ç»“æ„çš„é—®é¢˜ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ä¸Šé¢æåˆ°çš„ä¸`N`å…³è”çš„ç±»å‹å¼ºåˆ¶è½¬æ¢ï¼Œä»¥åŠæ–­è¨€è¿™ç§å¼ºåˆ¶è½¬æ¢æ˜¯å•å°„çš„`SetCoe.ext`å¼•ç†ã€‚è¿™ä¸¤ä¸ªéƒ½æ˜¯ç”±`SetLike`å®ä¾‹æä¾›çš„ã€‚
- en: '[PRE57]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that, in the above instance, instead of using the coercion to `M` and calling
    the `property` field, we could have used destructuring binders as follows.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨ä¸Šé¢çš„å®ä¾‹ä¸­ï¼Œæˆ‘ä»¬ä¸æ˜¯ä½¿ç”¨å¯¹`M`çš„å¼ºåˆ¶è½¬æ¢å¹¶è°ƒç”¨`property`å­—æ®µï¼Œè€Œæ˜¯å¯ä»¥ä½¿ç”¨è§£æ„ç»‘å®šç¬¦å¦‚ä¸‹æ‰€ç¤ºã€‚
- en: '[PRE58]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In order to apply lemmas about submonoids to subgroups or subrings, we need
    a class, just like for morphisms. Note this class take a `SetLike` instance as
    a parameter so it does not need a carrier field and can use the membership notation
    in its fields.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å°†å…³äºå­å¹ºåŠç¾¤çš„å®šä¹‰åº”ç”¨äºå­ç¾¤æˆ–å­ç¯ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªç±»ï¼Œå°±åƒå¯¹äºæ€å°„é‚£æ ·ã€‚æ³¨æ„è¿™ä¸ªç±»æ¥å—ä¸€ä¸ª`SetLike`å®ä¾‹ä½œä¸ºå‚æ•°ï¼Œå› æ­¤å®ƒä¸éœ€è¦è½½ä½“åŸŸå¹¶ä¸”å¯ä»¥åœ¨å…¶å­—æ®µä¸­ä½¿ç”¨æˆå‘˜ç¬¦å·ã€‚
- en: '[PRE59]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As an exercise you should define a `Subgroupâ‚` structure, endow it with a `SetLike`
    instance and a `SubmonoidClassâ‚` instance, put a `Group` instance on the subtype
    associated to a `Subgroupâ‚` and define a `SubgroupClassâ‚` class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç»ƒä¹ ï¼Œä½ åº”è¯¥å®šä¹‰ä¸€ä¸ª`Subgroupâ‚`ç»“æ„ï¼Œç»™å®ƒèµ‹äºˆä¸€ä¸ª`SetLike`å®ä¾‹å’Œä¸€ä¸ª`SubmonoidClassâ‚`å®ä¾‹ï¼Œåœ¨`Subgroupâ‚`å…³è”çš„å­ç±»å‹ä¸Šæ”¾ç½®ä¸€ä¸ª`Group`å®ä¾‹ï¼Œå¹¶å®šä¹‰ä¸€ä¸ª`SubgroupClassâ‚`ç±»ã€‚
- en: Another very important thing to know about subobjects of a given algebraic object
    in Mathlib always form a complete lattice, and this structure is used a lot. For
    instance you may look for the lemma saying that an intersection of submonoids
    is a submonoid. But this wonâ€™t be a lemma, this will be an infimum construction.
    Let us do the case of two submonoids.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äºMathlibä¸­ç»™å®šä»£æ•°å¯¹è±¡çš„å­å¯¹è±¡æ€»æ˜¯å½¢æˆä¸€ä¸ªå®Œå¤‡æ ¼ï¼Œè¿™ä¸€ç‚¹éå¸¸é‡è¦ï¼Œå¹¶ä¸”è¿™ç§ç»“æ„è¢«å¤§é‡ä½¿ç”¨ã€‚ä¾‹å¦‚ï¼Œä½ å¯èƒ½æƒ³è¦æŸ¥æ‰¾ä¸€ä¸ªå¼•ç†ï¼Œè¯´æ˜å­å¹ºåŠç¾¤çš„äº¤é›†æ˜¯ä¸€ä¸ªå­å¹ºåŠç¾¤ã€‚ä½†è¿™ä¸ä¼šæ˜¯ä¸€ä¸ªå¼•ç†ï¼Œè€Œæ˜¯ä¸€ä¸ªä¸‹ç¡®ç•Œæ„é€ ã€‚è®©æˆ‘ä»¬æ¥çœ‹ä¸¤ä¸ªå­å¹ºåŠç¾¤çš„æƒ…å†µã€‚
- en: '[PRE60]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This allows to get the intersections of two submonoids as a submonoid.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å…è®¸æˆ‘ä»¬å¾—åˆ°ä¸¤ä¸ªå­å¹ºåŠç¾¤çš„äº¤é›†ä½œä¸ºä¸€ä¸ªå­å¹ºåŠç¾¤ã€‚
- en: '[PRE61]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You may think itâ€™s a shame that we had to use the inf symbol `âŠ“` in the above
    example instead of the intersection symbol `âˆ©`. But think about the supremum.
    The union of two submonoids is not a submonoid. However submonoids still form
    a lattice (even a complete one). Actually `N âŠ” P` is the submonoid generated by
    the union of `N` and `P` and of course it would be very confusing to denote it
    by `N âˆª P`. So you can see the use of `N âŠ“ P` as much more consistent. It is also
    a lot more consistent across various kind of algebraic structures. It may look
    a bit weird at first to see the sum of two vector subspace `E` and `F` denoted
    by `E âŠ” F` instead of `E + F`. But you will get used to it. And soon you will
    consider the `E + F` notation as a distraction emphasizing the anecdotal fact
    that elements of `E âŠ” F` can be written as a sum of an element of `E` and an element
    of `F` instead of emphasizing the fundamental fact that `E âŠ” F` is the smallest
    vector subspace containing both `E` and `F`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½ä¼šè§‰å¾—æˆ‘ä»¬ä¸å¾—ä¸åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ä½¿ç”¨ä¸‹ç¡®ç•Œç¬¦å·`âŠ“`è€Œä¸æ˜¯äº¤é›†ç¬¦å·`âˆ©`æ˜¯ä¸€ç§é—æ†¾ã€‚ä½†æƒ³æƒ³ä¸Šç¡®ç•Œã€‚ä¸¤ä¸ªå­å¹ºåŠç¾¤çš„å¹¶é›†ä¸æ˜¯ä¸€ä¸ªå­å¹ºåŠç¾¤ã€‚ç„¶è€Œï¼Œå­å¹ºåŠç¾¤ä»ç„¶å½¢æˆä¸€ä¸ªæ ¼ï¼ˆç”šè‡³æ˜¯ä¸€ä¸ªå®Œå¤‡æ ¼ï¼‰ã€‚å®é™…ä¸Šï¼Œ`N
    âŠ” P`æ˜¯ç”±`N`å’Œ`P`çš„å¹¶é›†ç”Ÿæˆçš„å­å¹ºåŠç¾¤ï¼Œå½“ç„¶ç”¨`N âˆª P`æ¥è¡¨ç¤ºå®ƒä¼šéå¸¸ä»¤äººå›°æƒ‘ã€‚æ‰€ä»¥ï¼Œä½ å¯ä»¥çœ‹åˆ°ä½¿ç”¨`N âŠ“ P`çš„ç”¨æ³•è¦ä¸€è‡´å¾—å¤šã€‚å®ƒåœ¨å„ç§ç±»å‹çš„ä»£æ•°ç»“æ„ä¸­ä¹Ÿéå¸¸ä¸€è‡´ã€‚ä¸€å¼€å§‹çœ‹åˆ°ä¸¤ä¸ªå‘é‡å­ç©ºé—´`E`å’Œ`F`çš„å’Œç”¨`E
    âŠ” F`è¡¨ç¤ºè€Œä¸æ˜¯`E + F`å¯èƒ½ä¼šè§‰å¾—æœ‰ç‚¹å¥‡æ€ªã€‚ä½†ä½ ä¼šä¹ æƒ¯çš„ã€‚å¾ˆå¿«ï¼Œä½ å°†æŠŠ`E + F`çš„è¡¨ç¤ºçœ‹ä½œæ˜¯ä¸€ç§å¹²æ‰°ï¼Œå¼ºè°ƒ`E âŠ” F`çš„å…ƒç´ å¯ä»¥å†™æˆ`E`çš„ä¸€ä¸ªå…ƒç´ å’Œ`F`çš„ä¸€ä¸ªå…ƒç´ çš„å’Œï¼Œè€Œä¸æ˜¯å¼ºè°ƒ`E
    âŠ” F`æ˜¯åŒ…å«`E`å’Œ`F`çš„æœ€å°å­å‘é‡å­ç©ºé—´è¿™ä¸€åŸºæœ¬äº‹å®ã€‚
- en: Our last topic for this chapter is that of quotients. Again we want to explain
    how convenient notation are built and code duplication is avoided in Mathlib.
    Here the main device is the `HasQuotient` class which allows notations like `M
    â§¸ N`. Beware the quotient symbol `â§¸` is a special unicode character, not a regular
    ASCII division symbol.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ¬ç« çš„æœ€åä¸€ä¸ªä¸»é¢˜æ˜¯å•†ã€‚åŒæ ·ï¼Œæˆ‘ä»¬æƒ³è¦è§£é‡Šåœ¨Mathlibä¸­å¦‚ä½•æ„å»ºæ–¹ä¾¿çš„è¡¨ç¤ºæ³•å¹¶é¿å…ä»£ç é‡å¤ã€‚åœ¨è¿™é‡Œï¼Œä¸»è¦çš„å·¥å…·æ˜¯`HasQuotient`ç±»ï¼Œå®ƒå…è®¸ä½¿ç”¨åƒ`M
    â§¸ N`è¿™æ ·çš„è¡¨ç¤ºæ³•ã€‚æ³¨æ„ï¼Œå•†ç¬¦å·`â§¸`æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„Unicodeå­—ç¬¦ï¼Œä¸æ˜¯ä¸€ä¸ªå¸¸è§„çš„ASCIIé™¤æ³•ç¬¦å·ã€‚
- en: As an example, we will build the quotient of a commutative monoid by a submonoid,
    leave proofs to you. In the last example, you can use `Setoid.refl` but it wonâ€™t
    automatically pick up the relevant `Setoid` structure. You can fix this issue
    by providing all arguments using the `@` syntax, as in `@Setoid.refl M N.Setoid`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºä¾‹å­ï¼Œæˆ‘ä»¬å°†æ„å»ºä¸€ä¸ªäº¤æ¢å¹ºåŠç¾¤é™¤ä»¥å­å¹ºåŠç¾¤çš„å•†ï¼Œè¯æ˜ç•™ç»™ä½ ä»¬ã€‚åœ¨ä¸Šä¸€ä¸ªä¾‹å­ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨`Setoid.refl`ï¼Œä½†å®ƒä¸ä¼šè‡ªåŠ¨è·å–ç›¸å…³çš„`Setoid`ç»“æ„ã€‚ä½ å¯ä»¥é€šè¿‡ä½¿ç”¨`@`è¯­æ³•æä¾›æ‰€æœ‰å‚æ•°æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå°±åƒåœ¨`@Setoid.refl
    M N.Setoid`ä¸­ä¸€æ ·ã€‚
- en: '[PRE62] [Previous](C07_Structures.html "7\. Structures") [Next](C09_Groups_and_Rings.html
    "9\. Groups and Rings")'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE62] [ä¸Šä¸€èŠ‚](C07_Structures.html "7. ç»“æ„") [ä¸‹ä¸€èŠ‚](C09_Groups_and_Rings.html
    "9. ç¾¤å’Œç¯")'
- en: '* * *'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Â© Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Â© ç‰ˆæƒæ‰€æœ‰ 2020-2025ï¼ŒJeremy Avigadï¼ŒPatrick Massotã€‚æ–‡æœ¬è®¸å¯åè®®ä¸ºCC BY 4.0ã€‚
- en: 'Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). We have seen in [Chapter
    7](C07_Structures.html#structures) how to define the class of groups and build
    instances of this class, and then how to build an instance of the commutative
    ring class. But of course there is a hierarchy here: a commutative ring is in
    particular an additive group. In this chapter we will study how to build such
    hierarchies. They appear in all branches of mathematics but in this chapter the
    emphasis will be on algebraic examples.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨[Sphinx](https://www.sphinx-doc.org/)å’Œç”±[Read the Docs](https://readthedocs.org)æä¾›çš„[ä¸»é¢˜](https://github.com/readthedocs/sphinx_rtd_theme)æ„å»ºã€‚æˆ‘ä»¬åœ¨[ç¬¬7ç« ](C07_Structures.html#structures)ä¸­çœ‹åˆ°äº†å¦‚ä½•å®šä¹‰ç¾¤ç±»å¹¶æ„å»ºè¯¥ç±»çš„å®ä¾‹ï¼Œç„¶åæ˜¯å¦‚ä½•æ„å»ºäº¤æ¢ç¯ç±»çš„å®ä¾‹ã€‚ä½†å½“ç„¶è¿™é‡Œä¹Ÿæœ‰ä¸€ä¸ªå±‚æ¬¡ç»“æ„ï¼šäº¤æ¢ç¯ç‰¹åˆ«æ˜¯ä¸€ä¸ªåŠ æ³•ç¾¤ã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†ç ”ç©¶å¦‚ä½•æ„å»ºè¿™æ ·çš„å±‚æ¬¡ç»“æ„ã€‚å®ƒä»¬å‡ºç°åœ¨æ•°å­¦çš„æ‰€æœ‰åˆ†æ”¯ä¸­ï¼Œä½†æœ¬ç« çš„é‡ç‚¹å°†æ”¾åœ¨ä»£æ•°ç¤ºä¾‹ä¸Šã€‚
- en: It may seem premature to discuss how to build hierarchies before more discussions
    about using existing hierarchies. But some understanding of the technology underlying
    hierarchies is required to use them. So you should probably still read this chapter,
    but without trying too hard to remember everything on your first read, then read
    the following chapters and come back here for a second reading.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ›´å¤šå…³äºå¦‚ä½•ä½¿ç”¨ç°æœ‰å±‚æ¬¡ç»“æ„çš„è®¨è®ºä¹‹å‰è®¨è®ºå¦‚ä½•æ„å»ºå±‚æ¬¡ç»“æ„å¯èƒ½æ˜¾å¾—æœ‰äº›è¿‡æ—©ã€‚ä½†ä¸ºäº†ä½¿ç”¨è¿™äº›å±‚æ¬¡ç»“æ„ï¼Œå¯¹æ”¯æ’‘è¿™äº›å±‚æ¬¡ç»“æ„çš„æŠ€æœ¯æœ‰ä¸€äº›äº†è§£æ˜¯å¿…è¦çš„ã€‚å› æ­¤ï¼Œä½ å¯èƒ½ä»ç„¶åº”è¯¥é˜…è¯»è¿™ä¸€ç« ï¼Œä½†ä¸è¦åœ¨ç¬¬ä¸€æ¬¡é˜…è¯»æ—¶è¿‡äºåŠªåŠ›åœ°è®°ä½æ‰€æœ‰å†…å®¹ï¼Œç„¶åé˜…è¯»æ¥ä¸‹æ¥çš„ç« èŠ‚ï¼Œå†å›æ¥è¿™é‡Œè¿›è¡Œç¬¬äºŒæ¬¡é˜…è¯»ã€‚
- en: In this chapter, we will redefine (simpler versions of) many things that appear
    in Mathlib so we will used indices to distinguish our version. For instance we
    will have `Ringâ‚` as our version of `Ring`. Since we will gradually explain more
    powerful ways of formalizing structures, those indices will sometimes grow beyond
    one.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†é‡æ–°å®šä¹‰ï¼ˆMathlibä¸­å‡ºç°çš„è®¸å¤šäº‹ç‰©çš„ç®€åŒ–ç‰ˆæœ¬ï¼‰è®¸å¤šä¸œè¥¿ï¼Œå› æ­¤æˆ‘ä»¬å°†ä½¿ç”¨ç´¢å¼•æ¥åŒºåˆ†æˆ‘ä»¬çš„ç‰ˆæœ¬ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å°†æœ‰`Ringâ‚`ä½œä¸ºæˆ‘ä»¬çš„`Ring`ç‰ˆæœ¬ã€‚ç”±äºæˆ‘ä»¬å°†é€æ­¥è§£é‡Šæ›´å¼ºå¤§çš„å½¢å¼åŒ–ç»“æ„çš„æ–¹æ³•ï¼Œè¿™äº›ç´¢å¼•æœ‰æ—¶ä¼šè¶…è¿‡ä¸€ä¸ªã€‚
- en: '## 8.1\. Basics[ïƒ](#basics "Link to this heading")'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '## 8.1. åŸºç¡€[ïƒ](#basics "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")'
- en: At the very bottom of all hierarchies in Lean, we find data-carrying classes.
    The following class records that the given type `Î±` is endowed with a distinguished
    element called `one`. At this stage, it has no property at all.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Leançš„æ‰€æœ‰å±‚æ¬¡ç»“æ„çš„åº•éƒ¨ï¼Œæˆ‘ä»¬æ‰¾åˆ°äº†æºå¸¦æ•°æ®çš„ç±»ã€‚ä»¥ä¸‹ç±»è®°å½•äº†ç»™å®šçš„ç±»å‹`Î±`è¢«èµ‹äºˆäº†ä¸€ä¸ªç§°ä¸º`one`çš„ç‰¹ç§°å…ƒç´ ã€‚åœ¨è¿™ä¸€é˜¶æ®µï¼Œå®ƒæ²¡æœ‰ä»»ä½•å±æ€§ã€‚
- en: '[PRE63]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Since weâ€™ll make a much heavier use of classes in this chapter, we need to
    understand some more details about what the `class` command is doing. First, the
    `class` command above defines a structure `Oneâ‚` with parameter `Î± : Type` and
    a single field `one`. It also mark this structure as a class so that arguments
    of type `Oneâ‚ Î±` for some type `Î±` will be inferrable using the instance resolution
    procedure, as long as they are marked as instance-implicit, i.e. appear between
    square brackets. Those two effects could also have been achieved using the `structure`
    command with `class` attribute, i.e. writing `@[class] structure` instance of
    `class`. But the class command also ensures that `Oneâ‚ Î±` appears as an instance-implicit
    argument in its own fields. Compare:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç”±äºæˆ‘ä»¬å°†åœ¨æœ¬ç« ä¸­æ›´é¢‘ç¹åœ°ä½¿ç”¨ç±»ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£ä¸€äº›å…³äº`class`å‘½ä»¤åšäº†ä»€ä¹ˆçš„æ›´å¤šç»†èŠ‚ã€‚é¦–å…ˆï¼Œä¸Šé¢çš„`class`å‘½ä»¤å®šä¹‰äº†ä¸€ä¸ªå¸¦æœ‰å‚æ•°`Î± :
    Type`å’Œå•ä¸ªå­—æ®µ`one`çš„ç»“æ„`Oneâ‚`ã€‚å®ƒè¿˜æ ‡è®°è¿™ä¸ªç»“æ„ä¸ºä¸€ä¸ªç±»ï¼Œä»¥ä¾¿æŸäº›ç±»å‹`Î±`çš„`Oneâ‚ Î±`å‚æ•°å¯ä»¥é€šè¿‡å®ä¾‹è§£æè¿‡ç¨‹æ¨æ–­å‡ºæ¥ï¼Œåªè¦å®ƒä»¬è¢«æ ‡è®°ä¸ºå®ä¾‹éšå¼ï¼Œå³å‡ºç°åœ¨æ–¹æ‹¬å·ä¹‹é—´ã€‚è¿™ä¸¤ä¸ªæ•ˆæœä¹Ÿå¯ä»¥é€šè¿‡å¸¦æœ‰`class`å±æ€§çš„`structure`å‘½ä»¤å®ç°ï¼Œå³å†™ä½œ`@[class]
    structure`å®ä¾‹ã€‚ä½†ç±»å‘½ä»¤è¿˜ç¡®ä¿`Oneâ‚ Î±`å‡ºç°åœ¨å…¶è‡ªå·±çš„å­—æ®µä¸­ä½œä¸ºå®ä¾‹éšå¼å‚æ•°ã€‚æ¯”è¾ƒï¼š'
- en: '[PRE64]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the second check, we can see that `self : Oneâ‚‚ Î±` is an explicit argument.
    Let us make sure the first version is indeed usable without any explicit argument.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'åœ¨ç¬¬äºŒä¸ªæ£€æŸ¥ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°`self : Oneâ‚‚ Î±`æ˜¯ä¸€ä¸ªæ˜¾å¼å‚æ•°ã€‚è®©æˆ‘ä»¬ç¡®ä¿ç¬¬ä¸€ä¸ªç‰ˆæœ¬ç¡®å®å¯ä»¥åœ¨æ²¡æœ‰ä»»ä½•æ˜¾å¼å‚æ•°çš„æƒ…å†µä¸‹ä½¿ç”¨ã€‚'
- en: '[PRE65]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Remark: in the above example, the argument `Oneâ‚ Î±` is marked as instance-implicit,
    which is a bit silly since this affects only *uses* of the declaration and declaration
    created by the `example` command cannot be used. However it allows us to avoid
    giving a name to that argument and, more importantly, it starts installing the
    good habit of marking `Oneâ‚ Î±` arguments as instance-implicit.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: å¤‡æ³¨ï¼šåœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œå‚æ•°`Oneâ‚ Î±`è¢«æ ‡è®°ä¸ºå®ä¾‹éšå¼ï¼Œè¿™æœ‰ç‚¹æ„šè ¢ï¼Œå› ä¸ºè¿™åªå½±å“å£°æ˜çš„*ä½¿ç”¨*ä»¥åŠç”±`example`å‘½ä»¤åˆ›å»ºçš„å£°æ˜ä¸èƒ½è¢«ä½¿ç”¨ã€‚ç„¶è€Œï¼Œå®ƒå…è®¸æˆ‘ä»¬é¿å…ç»™è¿™ä¸ªå‚æ•°å‘½åï¼Œæ›´é‡è¦çš„æ˜¯ï¼Œå®ƒå¼€å§‹åŸ¹å…»æ ‡è®°`Oneâ‚
    Î±`å‚æ•°ä¸ºå®ä¾‹éšå¼çš„è‰¯å¥½ä¹ æƒ¯ã€‚
- en: 'Another remark is that all this will work only when Lean knows what is `Î±`.
    In the above example, leaving out the type ascription `: Î±` would generate an
    error message like: `typeclass instance problem is stuck, it is often due to metavariables
    Oneâ‚ (?m.263 Î±)` where `?m.263 Î±` means â€œsome type depending on `Î±`â€ (and 263
    is simply an auto-generated index that would be useful to distinguish between
    several unknown things). Another way to avoid this issue would be to use a type
    annotation, as in:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¦ä¸€ä¸ªå¤‡æ³¨æ˜¯ï¼Œæ‰€æœ‰è¿™äº›åªæœ‰åœ¨LeançŸ¥é“`Î±`æ˜¯ä»€ä¹ˆæ—¶æ‰ä¼šå·¥ä½œã€‚åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œçœç•¥ç±»å‹æ³¨è§£`: Î±`å°†ç”Ÿæˆä¸€ä¸ªé”™è¯¯ä¿¡æ¯ï¼Œä¾‹å¦‚ï¼š`typeclass
    instance problem is stuck, it is often due to metavariables Oneâ‚ (?m.263 Î±)`ï¼Œå…¶ä¸­`?m.263
    Î±`æ„å‘³ç€â€œä¾èµ–äº`Î±`çš„æŸäº›ç±»å‹â€ï¼ˆè€Œ263æ˜¯ä¸€ä¸ªè‡ªåŠ¨ç”Ÿæˆçš„ç´¢å¼•ï¼Œå¯ä»¥ç”¨æ¥åŒºåˆ†å‡ ä¸ªæœªçŸ¥çš„äº‹ç‰©ï¼‰ã€‚é¿å…è¿™ä¸ªé—®é¢˜çš„å¦ä¸€ç§æ–¹æ³•æ˜¯åœ¨ç±»å‹å£°æ˜ä¸­ä½¿ç”¨ç±»å‹æ³¨è§£ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š'
- en: '[PRE66]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You may have already encountered that issue when playing with limits of sequences
    in [Section 3.6](C03_Logic.html#sequences-and-convergence) if you tried to state
    for instance that `0 < 1` without telling Lean whether you meant this inequality
    to be about natural numbers or real numbers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½å·²ç»åœ¨[ç¬¬3.6èŠ‚](C03_Logic.html#sequences-and-convergence)ä¸­ç©åºåˆ—çš„æé™æ—¶é‡åˆ°è¿‡è¿™ä¸ªé—®é¢˜ï¼Œå¦‚æœä½ å°è¯•å£°æ˜ä¾‹å¦‚`0
    < 1`è€Œæ²¡æœ‰å‘Šè¯‰Leanä½ æŒ‡çš„æ˜¯è‡ªç„¶æ•°è¿˜æ˜¯å®æ•°çš„ä¸ç­‰å¼ã€‚
- en: Our next task is to assign a notation to `Oneâ‚.one`. Since we donâ€™t want collisions
    with the builtin notation for `1`, we will use `ğŸ™`. This is achieved by the following
    command where the first line tells Lean to use the documentation of `Oneâ‚.one`
    as documentation for the symbol `ğŸ™`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸‹ä¸€ä¸ªä»»åŠ¡æ˜¯ç»™`Oneâ‚.one`åˆ†é…ä¸€ä¸ªç¬¦å·ã€‚ç”±äºæˆ‘ä»¬ä¸å¸Œæœ›ä¸å†…ç½®çš„`1`çš„ç¬¦å·å†²çªï¼Œæˆ‘ä»¬å°†ä½¿ç”¨`ğŸ™`ã€‚è¿™å¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤å®ç°ï¼Œå…¶ä¸­ç¬¬ä¸€è¡Œå‘Šè¯‰Leanä½¿ç”¨`Oneâ‚.one`çš„æ–‡æ¡£ä½œä¸ºç¬¦å·`ğŸ™`çš„æ–‡æ¡£ã€‚
- en: '[PRE67]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We now want a data-carrying class recording a binary operation. We donâ€™t want
    to choose between addition and multiplication for now so weâ€™ll use diamond.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨æƒ³è¦ä¸€ä¸ªæºå¸¦æ•°æ®çš„ç±»æ¥è®°å½•äºŒå…ƒè¿ç®—ã€‚ç›®å‰æˆ‘ä»¬ä¸æƒ³åœ¨åŠ æ³•å’Œä¹˜æ³•ä¹‹é—´åšå‡ºé€‰æ‹©ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†ä½¿ç”¨è±å½¢ã€‚
- en: '[PRE68]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As in the `Oneâ‚` example, the operation has no property at all at this stage.
    Let us now define the class of semigroup structures where the operation is denoted
    by `â‹„`. For now, we define it by hand as a structure with two fields, a `Diaâ‚`
    instance and some `Prop`-valued field `dia_assoc` asserting associativity of `â‹„`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚åœ¨`Oneâ‚`çš„ä¾‹å­ä¸­ï¼Œè¿™ä¸ªæ“ä½œåœ¨è¿™ä¸ªé˜¶æ®µæ²¡æœ‰ä»»ä½•å±æ€§ã€‚ç°åœ¨è®©æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªåŠç¾¤ç»“æ„ç±»ï¼Œå…¶ä¸­æ“ä½œç”¨`â‹„`è¡¨ç¤ºã€‚ç°åœ¨ï¼Œæˆ‘ä»¬é€šè¿‡æ‰‹åŠ¨å®šä¹‰ä¸€ä¸ªå…·æœ‰ä¸¤ä¸ªå­—æ®µçš„ç»“æ„æ¥å®šä¹‰å®ƒï¼Œä¸€ä¸ª`Diaâ‚`å®ä¾‹å’Œä¸€äº›`Prop`ç±»å‹çš„å­—æ®µ`dia_assoc`ï¼Œè¯¥å­—æ®µæ–­è¨€`â‹„`çš„ç»“åˆæ€§ã€‚
- en: '[PRE69]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Note that while stating dia_assoc, the previously defined field toDiaâ‚ is in
    the local context hence can be used when Lean searches for an instance of Diaâ‚
    Î± to make sense of a â‹„ b. However this toDiaâ‚ field does not become part of the
    type class instances database. Hence doing `example {Î± : Type} [Semigroupâ‚ Î±]
    (a b : Î±) : Î± := a â‹„ b` would fail with error message `failed to synthesize instance
    Diaâ‚ Î±`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ³¨æ„ï¼Œåœ¨å£°æ˜dia_assocæ—¶ï¼Œä¹‹å‰å®šä¹‰çš„å­—æ®µtoDiaâ‚å¤„äºå±€éƒ¨ä¸Šä¸‹æ–‡ä¸­ï¼Œå› æ­¤å½“Leanæœç´¢Diaâ‚ Î±çš„å®ä¾‹ä»¥ç†è§£â‹„ bæ—¶å¯ä»¥ä½¿ç”¨å®ƒã€‚ç„¶è€Œï¼Œè¿™ä¸ªtoDiaâ‚å­—æ®µå¹¶ä¸æˆä¸ºç±»å‹ç±»å®ä¾‹æ•°æ®åº“çš„ä¸€éƒ¨åˆ†ã€‚å› æ­¤ï¼Œæ‰§è¡Œ`example
    {Î± : Type} [Semigroupâ‚ Î±] (a b : Î±) : Î± := a â‹„ b`å°†ä¼šå¤±è´¥ï¼Œå¹¶æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯`failed to synthesize
    instance Diaâ‚ Î±`ã€‚'
- en: We can fix this by adding the `instance` attribute later.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é€šè¿‡ç¨åæ·»åŠ `instance`å±æ€§æ¥ä¿®å¤è¿™ä¸ªé—®é¢˜ã€‚
- en: '[PRE70]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Before building up, we need to use a different syntax to add this toDiaâ‚ field,
    to tell Lean that Diaâ‚ Î± should be treated as if its fields were fields of Semigroupâ‚
    itself. This also conveniently adds the toDiaâ‚ instance automatically. The `class`
    command supports this using the `extends` syntax as in:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ„å»ºä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ä¸åŒçš„è¯­æ³•æ¥æ·»åŠ è¿™ä¸ªtoDiaâ‚å­—æ®µï¼Œå‘Šè¯‰Leanå°†Diaâ‚ Î±è§†ä¸ºå¦‚æœå®ƒçš„å­—æ®µæ˜¯Semigroupâ‚æœ¬èº«çš„å­—æ®µã€‚è¿™ä¹Ÿæ–¹ä¾¿åœ°è‡ªåŠ¨æ·»åŠ äº†toDiaâ‚å®ä¾‹ã€‚`class`å‘½ä»¤ä½¿ç”¨`extends`è¯­æ³•æ”¯æŒè¿™ä¸€ç‚¹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE71]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note this syntax is also available in the `structure` command, although it that
    case it fixes only the hurdle of writing fields such as toDiaâ‚ since there is
    no instance to define in that case.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„è¿™ä¸ªè¯­æ³•åœ¨ `structure` å‘½ä»¤ä¸­ä¹Ÿæ˜¯å¯ç”¨çš„ï¼Œå°½ç®¡åœ¨é‚£ä¸ªæƒ…å†µä¸‹ï¼Œå®ƒåªè§£å†³äº†ç¼–å†™è¯¸å¦‚ toDiaâ‚ è¿™æ ·çš„å­—æ®µçš„é—®é¢˜ï¼Œå› ä¸ºåœ¨è¿™ç§æƒ…å†µä¸‹æ²¡æœ‰å®ä¾‹éœ€è¦å®šä¹‰ã€‚
- en: The field name toDiaâ‚ is optional in the extends syntax. By default it takes
    the name of the class being extended and prefixes it with â€œtoâ€.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ `extends` è¯­æ³•ä¸­ï¼Œå­—æ®µå toDiaâ‚ æ˜¯å¯é€‰çš„ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå®ƒé‡‡ç”¨è¢«æ‰©å±•çš„ç±»çš„åç§°ï¼Œå¹¶åœ¨å…¶å‰é¢åŠ ä¸Šâ€œtoâ€ã€‚
- en: '[PRE72]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Let us now try to combine a diamond operation and a distinguished one element
    with axioms saying this element is neutral on both sides.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å°è¯•å°†ä¸€ä¸ªè±å½¢æ“ä½œå’Œä¸€ä¸ªç‰¹æ®Šå…ƒç´ ç»“åˆï¼Œé€šè¿‡å…¬ç†è¯´æ˜è¿™ä¸ªå…ƒç´ åœ¨ä¸¤è¾¹éƒ½æ˜¯ä¸­æ€§çš„ã€‚
- en: '[PRE73]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the next example, we tell Lean that `Î±` has a `DiaOneClassâ‚` structure and
    state a property that uses both a Diaâ‚ instance and a Oneâ‚ instance. In order
    to see how Lean finds those instances we set a tracing option whose result can
    be seen in the Infoview. This result is rather terse by default but it can be
    expanded by clicking on lines ending with black arrows. It includes failed attempts
    where Lean tried to find instances before having enough type information to succeed.
    The successful attempts do involve the instances generated by the `extends` syntax.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹ä¸€ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å‘Šè¯‰ Lean `Î±` æœ‰ä¸€ä¸ª `DiaOneClassâ‚` ç»“æ„ï¼Œå¹¶é™ˆè¿°ä¸€ä¸ªä½¿ç”¨ Diaâ‚ å®ä¾‹å’Œ Oneâ‚ å®ä¾‹çš„å±æ€§ã€‚ä¸ºäº†çœ‹åˆ°
    Lean å¦‚ä½•æ‰¾åˆ°è¿™äº›å®ä¾‹ï¼Œæˆ‘ä»¬è®¾ç½®äº†ä¸€ä¸ªè·Ÿè¸ªé€‰é¡¹ï¼Œå…¶ç»“æœå¯ä»¥åœ¨ Infoview ä¸­çœ‹åˆ°ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè¿™ä¸ªç»“æœç›¸å½“ç®€çŸ­ï¼Œä½†å¯ä»¥é€šè¿‡å•å‡»ä»¥é»‘è‰²ç®­å¤´ç»“å°¾çš„è¡Œæ¥æ‰©å±•ã€‚å®ƒåŒ…æ‹¬
    Lean åœ¨æˆåŠŸä¹‹å‰å°è¯•æ‰¾åˆ°å®ä¾‹çš„å¤±è´¥å°è¯•ã€‚æˆåŠŸçš„å°è¯•ç¡®å®æ¶‰åŠç”± `extends` è¯­æ³•ç”Ÿæˆçš„å®ä¾‹ã€‚
- en: '[PRE74]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Note that we donâ€™t need to include extra fields where combining existing classes.
    Hence we can define monoids as:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨ç»„åˆç°æœ‰ç±»æ—¶ï¼Œæˆ‘ä»¬ä¸éœ€è¦åŒ…å«é¢å¤–çš„å­—æ®µã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰å¹ºåŠç¾¤å¦‚ä¸‹ï¼š
- en: '[PRE75]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: While the above definition seems straightforward, it hides an important subtlety.
    Both `Semigroupâ‚ Î±` and `DiaOneClassâ‚ Î±` extend `Diaâ‚ Î±`, so one could fear that
    having a `Monoidâ‚ Î±` instance gives two unrelated diamond operations on `Î±`, one
    coming from a field `Monoidâ‚.toSemigroupâ‚` and one coming from a field `Monoidâ‚.toDiaOneClassâ‚`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶ä¸Šé¢çš„å®šä¹‰çœ‹èµ·æ¥å¾ˆç®€å•ï¼Œä½†å®ƒéšè—äº†ä¸€ä¸ªé‡è¦çš„å¾®å¦™ä¹‹å¤„ã€‚`Semigroupâ‚ Î±` å’Œ `DiaOneClassâ‚ Î±` éƒ½æ‰©å±•äº† `Diaâ‚ Î±`ï¼Œå› æ­¤äººä»¬å¯èƒ½ä¼šæ‹…å¿ƒæ‹¥æœ‰ä¸€ä¸ª
    `Monoidâ‚ Î±` å®ä¾‹ä¼šåœ¨ `Î±` ä¸Šäº§ç”Ÿä¸¤ä¸ªæ— å…³çš„è±å½¢æ“ä½œï¼Œä¸€ä¸ªæ¥è‡ªåŸŸ `Monoidâ‚.toSemigroupâ‚`ï¼Œå¦ä¸€ä¸ªæ¥è‡ªåŸŸ `Monoidâ‚.toDiaOneClassâ‚`ã€‚
- en: 'Indeed if we try to build a monoid class by hand using:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œå¦‚æœæˆ‘ä»¬å°è¯•æ‰‹åŠ¨ä½¿ç”¨ä»¥ä¸‹æ–¹å¼æ„å»ºä¸€ä¸ªå¹ºåŠç¾¤ç±»ï¼š
- en: '[PRE76]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: then we get two completely unrelated diamond operations `Monoidâ‚‚.toSemigroupâ‚.toDiaâ‚.dia`
    and `Monoidâ‚‚.toDiaOneClassâ‚.toDiaâ‚.dia`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¾—åˆ°ä¸¤ä¸ªå®Œå…¨æ— å…³çš„è±å½¢æ“ä½œ `Monoidâ‚‚.toSemigroupâ‚.toDiaâ‚.dia` å’Œ `Monoidâ‚‚.toDiaOneClassâ‚.toDiaâ‚.dia`ã€‚
- en: The version generated using the `extends` syntax does not have this defect.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ `extends` è¯­æ³•ç”Ÿæˆçš„ç‰ˆæœ¬æ²¡æœ‰è¿™ä¸ªç¼ºé™·ã€‚
- en: '[PRE77]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'So the `class` command did some magic for us (and the `structure` command would
    have done it too). An easy way to see what are the fields of our classes is to
    check their constructor. Compare:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œ`class` å‘½ä»¤ä¸ºæˆ‘ä»¬åšäº†ä¸€äº›é­”æ³•ï¼ˆ`structure` å‘½ä»¤ä¹Ÿä¼šè¿™æ ·åšï¼‰ã€‚ä¸€ä¸ªç®€å•çš„æ–¹æ³•æ¥æŸ¥çœ‹æˆ‘ä»¬ç±»çš„å­—æ®µæ˜¯æ£€æŸ¥å®ƒä»¬çš„æ„é€ å‡½æ•°ã€‚æ¯”è¾ƒï¼š
- en: '[PRE78]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: So we see that `Monoidâ‚` takes `Semigroupâ‚ Î±` argument as expected but then
    it wonâ€™t take a would-be overlapping `DiaOneClassâ‚ Î±` argument but instead tears
    it apart and includes only the non-overlapping parts. And it also auto-generated
    an instance `Monoidâ‚.toDiaOneClassâ‚` which is *not* a field but has the expected
    signature which, from the end-user point of view, restores the symmetry between
    the two extended classes `Semigroupâ‚` and `DiaOneClassâ‚`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬çœ‹åˆ° `Monoidâ‚` æŒ‰é¢„æœŸæ¥å— `Semigroupâ‚ Î±` å‚æ•°ï¼Œä½†å®ƒä¸ä¼šæ¥å—ä¸€ä¸ªæ½œåœ¨çš„é‡å¤çš„ `DiaOneClassâ‚ Î±` å‚æ•°ï¼Œè€Œæ˜¯å°†å…¶æ‹†åˆ†å¹¶åªåŒ…å«éé‡å çš„éƒ¨åˆ†ã€‚å®ƒè¿˜è‡ªåŠ¨ç”Ÿæˆäº†ä¸€ä¸ªå®ä¾‹
    `Monoidâ‚.toDiaOneClassâ‚`ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªåŸŸï¼Œä½†å®ƒå…·æœ‰é¢„æœŸçš„ç­¾åï¼Œä»æœ€ç»ˆç”¨æˆ·çš„è§’åº¦æ¥çœ‹ï¼Œæ¢å¤äº†ä¸¤ä¸ªæ‰©å±•ç±» `Semigroupâ‚` å’Œ `DiaOneClassâ‚`
    ä¹‹é—´çš„å¯¹ç§°æ€§ã€‚
- en: '[PRE79]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We are now very close to defining groups. We could add to the monoid structure
    a field asserting the existence of an inverse for every element. But then we would
    need to work to access these inverses. In practice it is more convenient to add
    it as data. To optimize reusability, we define a new data-carrying class, and
    then give it some notation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨éå¸¸æ¥è¿‘å®šä¹‰ç¾¤çš„æ¦‚å¿µã€‚æˆ‘ä»¬å¯ä»¥åœ¨å¹ºåŠç¾¤ç»“æ„ä¸­æ·»åŠ ä¸€ä¸ªåŸŸï¼Œæ–­è¨€æ¯ä¸ªå…ƒç´ éƒ½å­˜åœ¨é€†å…ƒã€‚ä½†é‚£æ ·æˆ‘ä»¬å°±éœ€è¦å·¥ä½œæ¥è®¿é—®è¿™äº›é€†å…ƒã€‚åœ¨å®è·µä¸­ï¼Œå°†å…¶ä½œä¸ºæ•°æ®æ·»åŠ æ›´ä¸ºæ–¹ä¾¿ã€‚ä¸ºäº†ä¼˜åŒ–å¯é‡ç”¨æ€§ï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæ–°çš„æ•°æ®æ‰¿è½½ç±»ï¼Œç„¶åç»™å®ƒä¸€äº›ç¬¦å·ã€‚
- en: '[PRE80]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The above definition may seem too weak, we only ask that `aâ»Â¹` is a left-inverse
    of `a`. But the other side is automatic. In order to prove that, we need a preliminary
    lemma.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°å®šä¹‰å¯èƒ½çœ‹èµ·æ¥å¤ªå¼±ï¼Œæˆ‘ä»¬åªè¦æ±‚ `aâ»Â¹` æ˜¯ `a` çš„å·¦é€†ã€‚ä½†å¦ä¸€æ–¹é¢æ˜¯è‡ªåŠ¨çš„ã€‚ä¸ºäº†è¯æ˜è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåˆæ­¥çš„å¼•ç†ã€‚
- en: '[PRE81]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In this lemma, it is pretty annoying to give full names, especially since it
    requires knowing which part of the hierarchy provides those facts. One way to
    fix this is to use the `export` command to copy those facts as lemmas in the root
    name space.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªå¼•ç†ä¸­ï¼Œç»™å‡ºå…¨åç›¸å½“ä»¤äººçƒ¦æ¼ï¼Œå°¤å…¶æ˜¯å› ä¸ºå®ƒéœ€è¦çŸ¥é“å“ªä¸ªå±‚æ¬¡ç»“æ„æä¾›äº†è¿™äº›äº‹å®ã€‚è§£å†³è¿™ä¸ªé—®é¢˜çš„ä¸€ç§æ–¹æ³•æ˜¯é€šè¿‡ä½¿ç”¨`export`å‘½ä»¤å°†é‚£äº›äº‹å®ä½œä¸ºæ ¹å‘½åç©ºé—´ä¸­çš„å¼•ç†æ¥å¤åˆ¶ã€‚
- en: '[PRE82]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can then rewrite the above proof as:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å°†ä¸Šè¿°è¯æ˜é‡å†™ä¸ºï¼š
- en: '[PRE83]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: It is now your turn to prove things about our algebraic structures.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è½®åˆ°ä½ æ¥è¯æ˜å…³äºæˆ‘ä»¬çš„ä»£æ•°ç»“æ„çš„äº‹æƒ…äº†ã€‚
- en: '[PRE84]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: At this stage we would like to move on to define rings, but there is a serious
    issue. A ring structure on a type contains both an additive group structure and
    a multiplicative monoid structure, and some properties about their interaction.
    But so far we hard-coded a notation `â‹„` for all our operations. More fundamentally,
    the type class system assumes every type has only one instance of each type class.
    There are various ways to solve this issue. Surprisingly Mathlib uses the naive
    idea to duplicate everything for additive and multiplicative theories with the
    help of some code-generating attribute. Structures and classes are defined in
    both additive and multiplicative notation with an attribute `to_additive` linking
    them. In case of multiple inheritance like for semi-groups, the auto-generated
    â€œsymmetry-restoringâ€ instances need also to be marked. This is a bit technical;
    you donâ€™t need to understand details. The important point is that lemmas are then
    only stated in multiplicative notation and marked with the attribute `to_additive`
    to generate the additive version as `left_inv_eq_right_inv'` with its auto-generated
    additive version `left_neg_eq_right_neg'`. In order to check the name of this
    additive version we used the `whatsnew in` command on top of `left_inv_eq_right_inv'`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªé˜¶æ®µï¼Œæˆ‘ä»¬å¸Œæœ›ç»§ç»­å®šä¹‰ç¯ï¼Œä½†å­˜åœ¨ä¸€ä¸ªä¸¥é‡çš„é—®é¢˜ã€‚ä¸€ä¸ªç±»å‹ä¸Šçš„ç¯ç»“æ„åŒ…å«ä¸€ä¸ªåŠ æ³•ç¾¤ç»“æ„å’Œä¹˜æ³•å¹ºåŠç¾¤ç»“æ„ï¼Œä»¥åŠå…³äºå®ƒä»¬ä¹‹é—´ç›¸äº’ä½œç”¨çš„æŸäº›æ€§è´¨ã€‚ä½†åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¸ºæ‰€æœ‰æ“ä½œç¡¬ç¼–ç äº†ä¸€ä¸ªç¬¦å·`â‹„`ã€‚æ›´åŸºæœ¬çš„æ˜¯ï¼Œç±»å‹ç±»ç³»ç»Ÿå‡è®¾æ¯ä¸ªç±»å‹åªæœ‰ä¸€ä¸ªç±»å‹ç±»çš„å®ä¾‹ã€‚æœ‰å„ç§æ–¹æ³•å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ä»¤äººæƒŠè®¶çš„æ˜¯ï¼ŒMathlibä½¿ç”¨äº†ä¸€ç§åŸå§‹çš„æƒ³æ³•ï¼Œé€šè¿‡ä¸€äº›ä»£ç ç”Ÿæˆå±æ€§æ¥å¤åˆ¶æ‰€æœ‰åŠ æ³•å’Œä¹˜æ³•ç†è®ºçš„å†…å®¹ã€‚ç»“æ„å’Œç±»éƒ½åœ¨åŠ æ³•å’Œä¹˜æ³•ç¬¦å·ä¸‹å®šä¹‰ï¼Œå¹¶é€šè¿‡å±æ€§`to_additive`å°†å®ƒä»¬é“¾æ¥èµ·æ¥ã€‚åœ¨ç±»ä¼¼åŠç¾¤çš„å¤šé‡ç»§æ‰¿æƒ…å†µä¸‹ï¼Œè‡ªåŠ¨ç”Ÿæˆçš„â€œå¯¹ç§°æ¢å¤â€å®ä¾‹ä¹Ÿéœ€è¦æ ‡è®°ã€‚è¿™æœ‰ç‚¹æŠ€æœ¯æ€§ï¼›ä½ ä¸éœ€è¦ç†è§£ç»†èŠ‚ã€‚é‡è¦çš„æ˜¯ï¼Œå¼•ç†åªä»¥ä¹˜æ³•ç¬¦å·è¡¨ç¤ºï¼Œå¹¶æ ‡è®°ä¸º`to_additive`ä»¥ç”ŸæˆåŠ æ³•ç‰ˆæœ¬`left_inv_eq_right_inv'`åŠå…¶è‡ªåŠ¨ç”Ÿæˆçš„åŠ æ³•ç‰ˆæœ¬`left_neg_eq_right_neg'`ã€‚ä¸ºäº†æ£€æŸ¥è¿™ä¸ªåŠ æ³•ç‰ˆæœ¬çš„åç§°ï¼Œæˆ‘ä»¬åœ¨`left_inv_eq_right_inv'`çš„é¡¶éƒ¨ä½¿ç”¨äº†`whatsnew
    in`å‘½ä»¤ã€‚
- en: '[PRE85]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Equipped with this technology, we can easily define also commutative semigroups,
    monoids and groups, and then define rings.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰äº†è¿™é¡¹æŠ€æœ¯ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è½»æ¾åœ°å®šä¹‰äº¤æ¢åŠç¾¤ã€å¹ºåŠç¾¤å’Œç¾¤ï¼Œç„¶åå®šä¹‰ç¯ã€‚
- en: '[PRE86]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We should remember to tag lemmas with `simp` when appropriate.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åº”è¯¥è®°å¾—åœ¨é€‚å½“çš„æ—¶å€™ç”¨`simp`æ ‡è®°å¼•ç†ã€‚
- en: '[PRE87]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Then we need to repeat ourselves a bit since we switch to standard notations,
    but at least `to_additive` does the work of translating from the multiplicative
    notation to the additive one.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œç”±äºæˆ‘ä»¬è½¬å‘æ ‡å‡†ç¬¦å·ï¼Œæˆ‘ä»¬éœ€è¦é‡å¤ä¸€ä¸‹ï¼Œä½†è‡³å°‘`to_additive`å®Œæˆäº†å°†ä¹˜æ³•ç¬¦å·ç¿»è¯‘ä¸ºåŠ æ³•ç¬¦å·çš„å·¥ä½œã€‚
- en: '[PRE88]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note that `to_additive` can be asked to tag a lemma with `simp` and propagate
    that attribute to the additive version as follows.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ`to_additive`å¯ä»¥è¦æ±‚æ ‡è®°ä¸€ä¸ªå¼•ç†ä¸º`simp`å¹¶å°†è¯¥å±æ€§ä¼ æ’­åˆ°åŠ æ³•ç‰ˆæœ¬ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚
- en: '[PRE89]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We are now ready for rings. For demonstration purposes we wonâ€™t assume that
    addition is commutative, and then immediately provide an instance of `AddCommGroupâ‚ƒ`.
    Mathlib does not play this game, first because in practice this does not make
    any ring instance easier and also because Mathlibâ€™s algebraic hierarchy goes through
    semirings which are like rings but without opposites so that the proof below does
    not work for them. What we gain here, besides a nice exercise if you have never
    seen it, is an example of building an instance using the syntax that allows to
    provide a parent structure as an instance parameter and then supply the extra
    fields. Here the Ringâ‚ƒ R argument supplies anything AddCommGroupâ‚ƒ R wants except
    for add_comm.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å·²å‡†å¤‡å¥½å®šä¹‰ç¯ã€‚ä¸ºäº†æ¼”ç¤ºç›®çš„ï¼Œæˆ‘ä»¬ä¸ä¼šå‡è®¾åŠ æ³•æ˜¯äº¤æ¢çš„ï¼Œç„¶åç«‹å³æä¾›ä¸€ä¸ª`AddCommGroupâ‚ƒ`çš„å®ä¾‹ã€‚Mathlibä¸ç©è¿™ä¸ªæ¸¸æˆï¼Œé¦–å…ˆæ˜¯å› ä¸ºåœ¨å®è·µä¸­è¿™ä¸ä¼šä½¿ä»»ä½•ç¯å®ä¾‹æ›´å®¹æ˜“ï¼Œè€Œä¸”Mathlibçš„ä»£æ•°å±‚æ¬¡ç»“æ„é€šè¿‡åŠç¯ï¼Œå®ƒä»¬åƒç¯ä½†æ²¡æœ‰ç›¸åå…ƒç´ ï¼Œæ‰€ä»¥ä¸‹é¢çš„è¯æ˜å¯¹å®ƒä»¬ä¸é€‚ç”¨ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œè·å¾—çš„å¥½å¤„ï¼Œé™¤äº†å¦‚æœä½ ä»æœªè§è¿‡å®ƒï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ç»ƒä¹ ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªä½¿ç”¨å…è®¸æä¾›çˆ¶ç»“æ„ä½œä¸ºå®ä¾‹å‚æ•°çš„è¯­æ³•æ¥æ„å»ºå®ä¾‹çš„ä¾‹å­ï¼Œç„¶åæä¾›é¢å¤–çš„å­—æ®µã€‚è¿™é‡Œï¼ŒRingâ‚ƒ
    Rå‚æ•°æä¾›äº†AddCommGroupâ‚ƒ Ræƒ³è¦çš„ä»»ä½•ä¸œè¥¿ï¼Œé™¤äº†add_commã€‚
- en: '[PRE90]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Of course we can also build concrete instances, such as a ring structure on
    integers (of course the instance below uses that all the work is already done
    in Mathlib).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æ„å»ºå…·ä½“çš„å®ä¾‹ï¼Œä¾‹å¦‚æ•´æ•°ä¸Šçš„ç¯ç»“æ„ï¼ˆå½“ç„¶ä¸‹é¢çš„å®ä¾‹ä½¿ç”¨Mathlibä¸­å·²ç»å®Œæˆçš„æ‰€æœ‰å·¥ä½œï¼‰ã€‚
- en: '[PRE91]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'As an exercise you can now set up a simple hierarchy for order relations, including
    a class for ordered commutative monoids, which have both a partial order and a
    commutative monoid structure such that `âˆ€ a b : Î±, a â‰¤ b â†’ âˆ€ c : Î±, c * a â‰¤ c
    * b`. Of course you need to add fields and maybe `extends` clauses to the following
    classes.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä½œä¸ºç»ƒä¹ ï¼Œä½ ç°åœ¨å¯ä»¥è®¾ç½®ä¸€ä¸ªç®€å•çš„å±‚æ¬¡ç»“æ„ï¼ŒåŒ…æ‹¬ä¸€ä¸ªæœ‰åºäº¤æ¢å¹ºåŠç¾¤ç±»ï¼Œå®ƒå…·æœ‰éƒ¨åˆ†åºå’Œäº¤æ¢å¹ºåŠç¾¤ç»“æ„ï¼Œä½¿å¾—`âˆ€ a b : Î±, a â‰¤ b â†’ âˆ€ c
    : Î±, c * a â‰¤ c * b`ã€‚å½“ç„¶ï¼Œä½ éœ€è¦å‘ä»¥ä¸‹ç±»ä¸­æ·»åŠ åŸŸå’Œå¯èƒ½`extends`å­å¥ã€‚'
- en: '[PRE92]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We now want to discuss algebraic structures involving several types. The prime
    example is modules over rings. If you donâ€™t know what is a module, you can pretend
    it means vector space and think that all our rings are fields. Those structures
    are commutative additive groups equipped with a scalar multiplication by elements
    of some ring.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨æƒ³è¦è®¨è®ºæ¶‰åŠå¤šç§ç±»å‹çš„ä»£æ•°ç»“æ„ã€‚ä¸€ä¸ªå…¸å‹çš„ä¾‹å­æ˜¯ç¯ä¸Šçš„æ¨¡ã€‚å¦‚æœä½ ä¸çŸ¥é“ä»€ä¹ˆæ˜¯æ¨¡ï¼Œä½ å¯ä»¥å‡è®¾å®ƒæ„å‘³ç€å‘é‡ç©ºé—´ï¼Œå¹¶è®¤ä¸ºæˆ‘ä»¬æ‰€æœ‰çš„ç¯éƒ½æ˜¯åŸŸã€‚è¿™äº›ç»“æ„æ˜¯å¸¦æœ‰ç”±æŸäº›ç¯çš„å…ƒç´ è¿›è¡Œçš„æ ‡é‡ä¹˜æ³•çš„äº¤æ¢åŠ æ³•ç¾¤ã€‚
- en: We first define the data-carrying type class of scalar multiplication by some
    type `Î±` on some type `Î²`, and give it a right associative notation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é¦–å…ˆå®šä¹‰ç”±ç±»å‹`Î±`åœ¨ç±»å‹`Î²`ä¸Šæºå¸¦çš„æ•°æ®ç±»å‹ç±»ï¼Œå¹¶ç»™å®ƒä¸€ä¸ªå³ç»“åˆçš„ç¬¦å·ã€‚
- en: '[PRE93]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Then we can define modules (again think about vector spaces if you donâ€™t know
    what is a module).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰æ¨¡ï¼ˆå¦‚æœä½ ä¸çŸ¥é“ä»€ä¹ˆæ˜¯æ¨¡ï¼Œå¯ä»¥å†æ¬¡è€ƒè™‘å‘é‡ç©ºé—´ï¼‰ã€‚
- en: '[PRE94]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'There is something interesting going on here. While it isnâ€™t too surprising
    that the ring structure on `R` is a parameter in this definition, you probably
    expected `AddCommGroupâ‚ƒ M` to be part of the `extends` clause just as `SMulâ‚ƒ R
    M` is. Trying to do that would lead to a mysterious sounding error message: `cannot
    find synthesization order for instance Moduleâ‚.toAddCommGroupâ‚ƒ with type (R :
    Type) â†’ [inst : Ringâ‚ƒ R] â†’ {M : Type} â†’ [self : Moduleâ‚ R M] â†’ AddCommGroupâ‚ƒ M
    all remaining arguments have metavariables: Ringâ‚ƒ ?R @Moduleâ‚ ?R ?instâœ M`. In
    order to understand this message, you need to remember that such an `extends`
    clause would lead to a field `Moduleâ‚ƒ.toAddCommGroupâ‚ƒ` marked as an instance.
    This instance would have the signature appearing in the error message: `(R : Type)
    â†’ [inst : Ringâ‚ƒ R] â†’ {M : Type} â†’ [self : Moduleâ‚ R M] â†’ AddCommGroupâ‚ƒ M`. With
    such an instance in the type class database, each time Lean would look for a `AddCommGroupâ‚ƒ
    M` instance for some `M`, it would need to go hunting for a completely unspecified
    type `R` and a `Ringâ‚ƒ R` instance before embarking on the main quest of finding
    a `Moduleâ‚ R M` instance. Those two side-quests are represented by the meta-variables
    mentioned in the error message and denoted by `?R` and `?instâœ` there. Such a
    `Moduleâ‚ƒ.toAddCommGroupâ‚ƒ` instance would then be a huge trap for the instance
    resolution procedure and then `class` command refuses to set it up.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™é‡Œæœ‰ä¸€äº›æœ‰è¶£çš„äº‹æƒ…æ­£åœ¨å‘ç”Ÿã€‚è™½ç„¶`R`ä¸Šçš„ç¯ç»“æ„åœ¨è¿™ä¸ªå®šä¹‰ä¸­æ˜¯å‚æ•°å¹¶ä¸å¤ªä»¤äººæƒŠè®¶ï¼Œä½†ä½ å¯èƒ½é¢„è®¡`AddCommGroupâ‚ƒ M`å°†åƒ`SMulâ‚ƒ R
    M`ä¸€æ ·æˆä¸º`extends`å­å¥çš„ä¸€éƒ¨åˆ†ã€‚å°è¯•è¿™æ ·åšä¼šå¯¼è‡´ä¸€ä¸ªå¬èµ·æ¥å¾ˆç¥ç§˜çš„é”™è¯¯ä¿¡æ¯ï¼šâ€œæ— æ³•ä¸ºå®ä¾‹Moduleâ‚.toAddCommGroupâ‚ƒæ‰¾åˆ°åˆæˆé¡ºåºï¼Œç±»å‹ä¸º(R
    : Type) â†’ [inst : Ringâ‚ƒ R] â†’ {M : Type} â†’ [self : Moduleâ‚ R M] â†’ AddCommGroupâ‚ƒ
    Mï¼Œæ‰€æœ‰å‰©ä½™çš„å‚æ•°éƒ½æœ‰å…ƒå˜é‡ï¼šRingâ‚ƒ ?R @Moduleâ‚ ?R ?instâœ Mâ€ã€‚ä¸ºäº†ç†è§£è¿™æ¡ä¿¡æ¯ï¼Œä½ éœ€è¦è®°ä½è¿™æ ·çš„`extends`å­å¥ä¼šå¯¼è‡´ä¸€ä¸ªæ ‡è®°ä¸ºå®ä¾‹çš„`Moduleâ‚ƒ.toAddCommGroupâ‚ƒ`å­—æ®µã€‚è¿™ä¸ªå®ä¾‹å°†å…·æœ‰é”™è¯¯ä¿¡æ¯ä¸­å‡ºç°çš„ç­¾åï¼š`(R
    : Type) â†’ [inst : Ringâ‚ƒ R] â†’ {M : Type} â†’ [self : Moduleâ‚ R M] â†’ AddCommGroupâ‚ƒ
    M`ã€‚åœ¨ç±»å‹ç±»æ•°æ®åº“ä¸­æœ‰äº†è¿™æ ·çš„å®ä¾‹åï¼Œæ¯æ¬¡Leanå¯»æ‰¾æŸä¸ª`M`çš„`AddCommGroupâ‚ƒ M`å®ä¾‹æ—¶ï¼Œå®ƒéƒ½éœ€è¦åœ¨å¼€å§‹å¯»æ‰¾`Moduleâ‚ R M`å®ä¾‹çš„ä¸»è¦ä»»åŠ¡ä¹‹å‰ï¼Œå»å¯»æ‰¾ä¸€ä¸ªå®Œå…¨æœªæŒ‡å®šçš„ç±»å‹`R`å’Œ`Ringâ‚ƒ
    R`å®ä¾‹ã€‚è¿™ä¸¤ä¸ªå‰¯ä»»åŠ¡ç”±é”™è¯¯ä¿¡æ¯ä¸­æåˆ°çš„å…ƒå˜é‡è¡¨ç¤ºï¼Œå¹¶åœ¨è¿™é‡Œç”¨`?R`å’Œ`?instâœ`è¡¨ç¤ºã€‚è¿™æ ·çš„`Moduleâ‚ƒ.toAddCommGroupâ‚ƒ`å®ä¾‹å°†æˆä¸ºå®ä¾‹è§£æè¿‡ç¨‹çš„ä¸€ä¸ªå·¨å¤§é™·é˜±ï¼Œç„¶å`class`å‘½ä»¤æ‹’ç»è®¾ç½®å®ƒã€‚'
- en: 'What about `extends SMulâ‚ƒ R M` then? That one creates a field `Moduleâ‚.toSMulâ‚ƒ
    : {R : Type} â†’Â  [inst : Ringâ‚ƒ R] â†’ {M : Type} â†’ [inst_1 : AddCommGroupâ‚ƒ M] â†’ [self
    : Moduleâ‚ R M] â†’ SMulâ‚ƒ R M` whose end result `SMulâ‚ƒ R M` mentions both `R` and
    `M` so this field can safely be used as an instance. The rule is easy to remember:
    each class appearing in the `extends` clause should mention every type appearing
    in the parameters.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'é‚£ä¹ˆ`extends SMulâ‚ƒ R M`åˆæ˜¯æ€ä¹ˆå›äº‹å‘¢ï¼Ÿå®ƒåˆ›å»ºäº†ä¸€ä¸ªå­—æ®µ`Moduleâ‚.toSMulâ‚ƒ : {R : Type} â†’ [inst
    : Ringâ‚ƒ R] â†’ {M : Type} â†’ [inst_1 : AddCommGroupâ‚ƒ M] â†’ [self : Moduleâ‚ R M] â†’
    SMulâ‚ƒ R M`ï¼Œå…¶æœ€ç»ˆç»“æœ`SMulâ‚ƒ R M`æåˆ°äº†`R`å’Œ`M`ï¼Œå› æ­¤è¿™ä¸ªå­—æ®µå¯ä»¥å®‰å…¨åœ°ç”¨ä½œå®ä¾‹ã€‚è§„åˆ™å¾ˆå®¹æ˜“è®°ä½ï¼š`extends`å­å¥ä¸­å‡ºç°çš„æ¯ä¸ªç±»éƒ½åº”è¯¥æåˆ°å‚æ•°ä¸­å‡ºç°çš„æ¯ä¸ªç±»å‹ã€‚'
- en: 'Let us create our first module instance: a ring is a module over itself using
    its multiplication as a scalar multiplication.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åˆ›å»ºæˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªæ¨¡å—å®ä¾‹ï¼šä¸€ä¸ªç¯æ˜¯å…¶è‡ªèº«çš„æ¨¡å—ï¼Œä½¿ç”¨å…¶ä¹˜æ³•ä½œä¸ºæ ‡é‡ä¹˜æ³•ã€‚
- en: '[PRE95]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'As a second example, every abelian group is a module over `â„¤` (this is one
    of the reason to generalize the theory of vector spaces by allowing non-invertible
    scalars). First one can define scalar multiplication by a natural number for any
    type equipped with a zero and an addition: `n â€¢ a` is defined as `a + â‹¯ + a` where
    `a` appears `n` times. Then this is extended to scalar multiplication by an integer
    by ensuring `(-1) â€¢ a = -a`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç¬¬äºŒä¸ªä¾‹å­ï¼Œæ¯ä¸ªé˜¿è´å°”ç¾¤éƒ½æ˜¯`â„¤`çš„æ¨¡å—ï¼ˆè¿™æ˜¯é€šè¿‡å…è®¸éå¯é€†æ ‡é‡æ¥æ³›åŒ–å‘é‡ç©ºé—´ç†è®ºçš„åŸå› ä¹‹ä¸€ï¼‰ã€‚é¦–å…ˆï¼Œå¯ä»¥ä¸ºä»»ä½•å¸¦æœ‰é›¶å’ŒåŠ æ³•çš„ç±»å‹å®šä¹‰è‡ªç„¶æ•°çš„æ ‡é‡ä¹˜æ³•ï¼š`n
    â€¢ a`å®šä¹‰ä¸º`a + â‹¯ + a`ï¼Œå…¶ä¸­`a`å‡ºç°`n`æ¬¡ã€‚ç„¶åï¼Œé€šè¿‡ç¡®ä¿`(-1) â€¢ a = -a`å°†å…¶æ‰©å±•åˆ°æ•´æ•°çš„æ ‡é‡ä¹˜æ³•ã€‚
- en: '[PRE96]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Proving this gives rise to a module structure is a bit tedious and not interesting
    for the current discussion, so we will sorry all axioms. You are *not* asked to
    replace those sorries with proofs. If you insist on doing it then you will probably
    want to state and prove several intermediate lemmas about `nsmulâ‚` and `zsmulâ‚`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: è¯æ˜è¿™ä¸€ç‚¹ä¼šäº§ç”Ÿä¸€ä¸ªæ¨¡å—ç»“æ„ï¼Œå¯¹äºå½“å‰çš„è®¨è®ºæ¥è¯´æœ‰ç‚¹ç¹çä¸”ä¸æœ‰è¶£ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†å¯¹æ‰€æœ‰å…¬ç†è¡¨ç¤ºæ­‰æ„ã€‚ä½ **ä¸æ˜¯**è¢«è¦æ±‚ç”¨è¯æ˜æ¥æ›¿æ¢è¿™äº›æ­‰æ„ã€‚å¦‚æœä½ åšæŒè¿™æ ·åšï¼Œä½ å¯èƒ½éœ€è¦é™ˆè¿°å¹¶è¯æ˜å…³äº`nsmulâ‚`å’Œ`zsmulâ‚`çš„å‡ ä¸ªä¸­é—´å¼•ç†ã€‚
- en: '[PRE97]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'A much more important issue is that we now have two module structures over
    the ring `â„¤` for `â„¤` itself: `abGrpModule â„¤` since `â„¤` is a abelian group, and
    `selfModule â„¤` since `â„¤` is a ring. Those two module structure correspond to the
    same abelian group structure, but it is not obvious that they have the same scalar
    multiplication. They actually do, but this isnâ€™t true by definition, it requires
    a proof. This is very bad news for the type class instance resolution procedure
    and will lead to very frustrating failures for users of this hierarchy. When directly
    asked to find an instance, Lean will pick one, and we can see which one using:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ›´åŠ é‡è¦çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬ç°åœ¨åœ¨ç¯`â„¤`ä¸Šå¯¹`â„¤`æœ¬èº«æœ‰ä¸¤ä¸ªæ¨¡å—ç»“æ„ï¼š`abGrpModule â„¤`ï¼Œå› ä¸º`â„¤`æ˜¯ä¸€ä¸ªé˜¿è´å°”ç¾¤ï¼Œä»¥åŠ`selfModule
    â„¤`ï¼Œå› ä¸º`â„¤`æ˜¯ä¸€ä¸ªç¯ã€‚è¿™ä¸¤ä¸ªæ¨¡å—ç»“æ„å¯¹åº”äºç›¸åŒçš„é˜¿è´å°”ç¾¤ç»“æ„ï¼Œä½†å®ƒä»¬æ˜¯å¦å…·æœ‰ç›¸åŒçš„æ ‡é‡ä¹˜æ³•å¹¶ä¸æ˜æ˜¾ã€‚å®é™…ä¸Šï¼Œå®ƒä»¬ç¡®å®å¦‚æ­¤ï¼Œä½†è¿™å¹¶ä¸æ˜¯å®šä¹‰ä¸Šçš„ï¼Œå®ƒéœ€è¦ä¸€ä¸ªè¯æ˜ã€‚è¿™å¯¹ç±»å‹ç±»å®ä¾‹è§£æè¿‡ç¨‹æ¥è¯´æ˜¯éå¸¸ç³Ÿç³•çš„æ¶ˆæ¯ï¼Œå¹¶å°†å¯¼è‡´ç”¨æˆ·åœ¨ä½¿ç”¨è¿™ä¸ªå±‚æ¬¡ç»“æ„æ—¶é‡åˆ°éå¸¸ä»¤äººæ²®ä¸§çš„å¤±è´¥ã€‚å½“ç›´æ¥è¦æ±‚æ‰¾åˆ°ä¸€ä¸ªå®ä¾‹æ—¶ï¼ŒLeanä¼šé€‰æ‹©ä¸€ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ–¹å¼æŸ¥çœ‹ï¼š
- en: '[PRE98]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: But in a more indirect context it can happen that Lean infers the other one
    and then gets confused. This situation is known as a bad diamond. This has nothing
    to do with the diamond operation we used above, it refers to the way one can draw
    the paths from `â„¤` to its `Moduleâ‚ â„¤` going through either `AddCommGroupâ‚ƒ â„¤` or
    `Ringâ‚ƒ â„¤`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†åœ¨æ›´é—´æ¥çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œå¯èƒ½ä¼šå‘ç”ŸLeanæ¨æ–­å‡ºå¦ä¸€ä¸ªï¼Œç„¶åå˜å¾—å›°æƒ‘çš„æƒ…å†µã€‚è¿™ç§æƒ…å†µè¢«ç§°ä¸ºåé’»çŸ³ã€‚è¿™ä¸æˆ‘ä»¬ä¸Šé¢ä½¿ç”¨çš„é’»çŸ³æ“ä½œæ— å…³ï¼Œå®ƒæŒ‡çš„æ˜¯ä»`â„¤`åˆ°å…¶`Moduleâ‚
    â„¤`é€šè¿‡`AddCommGroupâ‚ƒ â„¤`æˆ–`Ringâ‚ƒ â„¤`ç»˜åˆ¶è·¯å¾„çš„æ–¹å¼ã€‚
- en: It is important to understand that not all diamonds are bad. In fact there are
    diamonds everywhere in Mathlib, and also in this chapter. Already at the very
    beginning we saw one can go from `Monoidâ‚ Î±` to `Diaâ‚ Î±` through either `Semigroupâ‚
    Î±` or `DiaOneClassâ‚ Î±` and thanks to the work done by the `class` command, the
    resulting two `Diaâ‚ Î±` instances are definitionally equal. In particular a diamond
    having a `Prop`-valued class at the bottom cannot be bad since any two proofs
    of the same statement are definitionally equal.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: é‡è¦çš„æ˜¯è¦ç†è§£å¹¶éæ‰€æœ‰é’»çŸ³éƒ½æ˜¯åçš„ã€‚å®é™…ä¸Šï¼Œåœ¨Mathlibä¸­åˆ°å¤„éƒ½æ˜¯é’»çŸ³ï¼Œä¹ŸåŒ…æ‹¬æœ¬ç« ã€‚åœ¨éå¸¸å¼€å§‹çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±çœ‹åˆ°äº†å¯ä»¥ä»`Monoidâ‚ Î±`é€šè¿‡`Semigroupâ‚
    Î±`æˆ–`DiaOneClassâ‚ Î±`è½¬æ¢åˆ°`Diaâ‚ Î±`ï¼Œå¤šäºäº†`class`å‘½ä»¤çš„å·¥ä½œï¼Œå¾—åˆ°çš„ä¸¤ä¸ª`Diaâ‚ Î±`å®ä¾‹åœ¨å®šä¹‰ä¸Šæ˜¯ç›¸ç­‰çš„ã€‚ç‰¹åˆ«æ˜¯ï¼Œåº•éƒ¨æœ‰`Prop`å€¼ç±»çš„é’»çŸ³ä¸èƒ½æ˜¯åçš„ï¼Œå› ä¸ºä»»ä½•ä¸¤ä¸ªç›¸åŒé™ˆè¿°çš„è¯æ˜åœ¨å®šä¹‰ä¸Šéƒ½æ˜¯ç›¸ç­‰çš„ã€‚
- en: But the diamond we created with modules is definitely bad. The offending piece
    is the `smul` field which is data, not a proof, and we have two constructions
    that are not definitionally equal. The robust way of fixing this issue is to make
    sure that going from a rich structure to a poor structure is always done by forgetting
    data, not by defining data. This well-known pattern has been named â€œforgetful
    inheritanceâ€ and extensively discussed in [https://inria.hal.science/hal-02463336v2](https://inria.hal.science/hal-02463336v2).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æˆ‘ä»¬åˆ›å»ºçš„æ¨¡å—é’»çŸ³è‚¯å®šæ˜¯ä¸å¥½çš„ã€‚é—®é¢˜å‡ºåœ¨`smul`å­—æ®µä¸Šï¼Œå®ƒä¸æ˜¯è¯æ˜ï¼Œè€Œæ˜¯æ•°æ®ï¼Œæˆ‘ä»¬æœ‰ä¸¤ç»„ä¸æ˜¯å®šä¹‰ä¸Šç›¸ç­‰çš„æ„é€ ã€‚ä¿®å¤è¿™ä¸ªé—®é¢˜çš„ç¨³å¥æ–¹å¼æ˜¯ç¡®ä¿ä»ä¸°å¯Œç»“æ„åˆ°è´«å¼±ç»“æ„çš„è½¬æ¢æ€»æ˜¯é€šè¿‡å¿˜è®°æ•°æ®æ¥å®Œæˆçš„ï¼Œè€Œä¸æ˜¯é€šè¿‡å®šä¹‰æ•°æ®ã€‚è¿™ä¸ªä¼—æ‰€å‘¨çŸ¥çš„æ¨¡å¼è¢«å‘½åä¸ºâ€œé—å¿˜ç»§æ‰¿â€ï¼Œå¹¶åœ¨[https://inria.hal.science/hal-02463336v2](https://inria.hal.science/hal-02463336v2)ä¸­å¹¿æ³›è®¨è®ºã€‚
- en: In our concrete case, we can modify the definition of `AddMonoidâ‚ƒ` to include
    a `nsmul` data field and some `Prop`-valued fields ensuring this operation is
    provably the one we constructed above. Those fields are given default values using
    `:=` after their type in the definition below. Thanks to these default values,
    most instances would be constructed exactly as with our previous definitions.
    But in the special case of `â„¤` we will be able to provide specific values.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬çš„å…·ä½“æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ä¿®æ”¹ `AddMonoidâ‚ƒ` çš„å®šä¹‰ï¼ŒåŒ…æ‹¬ä¸€ä¸ª `nsmul` æ•°æ®å­—æ®µå’Œä¸€äº›ç¡®ä¿æ­¤æ“ä½œå¯è¯æ˜æ˜¯æˆ‘ä»¬ä¸Šé¢æ„é€ çš„ `Prop`
    å€¼å­—æ®µã€‚è¿™äº›å­—æ®µåœ¨ä¸‹é¢çš„å®šä¹‰ä¸­ä½¿ç”¨ `:=` åœ¨å®ƒä»¬çš„ç±»å‹ä¹‹åæä¾›é»˜è®¤å€¼ã€‚å¤šäºäº†è¿™äº›é»˜è®¤å€¼ï¼Œå¤§å¤šæ•°å®ä¾‹å°†ä¸æˆ‘ä»¬ä¹‹å‰çš„å®šä¹‰å®Œå…¨ä¸€æ ·æ„å»ºã€‚ä½†åœ¨ `â„¤` çš„ç‰¹æ®Šæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†èƒ½å¤Ÿæä¾›ç‰¹å®šçš„å€¼ã€‚
- en: '[PRE99]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Let us check we can still construct a product monoid instance without providing
    the `nsmul` related fields.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦ä»ç„¶å¯ä»¥æ„å»ºä¸€ä¸ªä¸æä¾› `nsmul` ç›¸å…³å­—æ®µçš„ä¹˜ç§¯å¹ºåŠç¾¤å®ä¾‹ã€‚
- en: '[PRE100]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: And now let us handle the special case of `â„¤` where we want to build `nsmul`
    using the coercion of `â„•` to `â„¤` and the multiplication on `â„¤`. Note in particular
    how the proof fields contain more work than in the default value above.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬å¤„ç† `â„¤` çš„ç‰¹æ®Šæƒ…å†µï¼Œæˆ‘ä»¬æƒ³ä½¿ç”¨ `â„•` åˆ° `â„¤` çš„å¼ºåˆ¶è½¬æ¢å’Œ `â„¤` ä¸Šçš„ä¹˜æ³•æ¥æ„å»º `nsmul`ã€‚ç‰¹åˆ«è¦æ³¨æ„è¯æ˜å­—æ®µæ¯”ä¸Šé¢çš„é»˜è®¤å€¼åŒ…å«æ›´å¤šçš„å·¥ä½œã€‚
- en: '[PRE101]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Let us check we solved our issue. Because Lean already has a definition of scalar
    multiplication of a natural number and an integer, and we want to make sure our
    instance is used, we wonâ€™t use the `â€¢` notation but call `SMul.mul` and explicitly
    provide our instance defined above.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦è§£å†³äº†é—®é¢˜ã€‚å› ä¸º Lean å·²ç»å®šä¹‰äº†è‡ªç„¶æ•°å’Œæ•´æ•°çš„æ ‡é‡ä¹˜æ³•ï¼Œæˆ‘ä»¬æƒ³ç¡®ä¿æˆ‘ä»¬çš„å®ä¾‹è¢«ä½¿ç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸ä¼šä½¿ç”¨ `â€¢` ç¬¦å·ï¼Œè€Œæ˜¯è°ƒç”¨ `SMul.mul`
    å¹¶æ˜¾å¼æä¾›ä¸Šé¢å®šä¹‰çš„å®ä¾‹ã€‚
- en: '[PRE102]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This story then continues with incorporating a `zsmul` field into the definition
    of groups and similar tricks. You are now ready to read the definition of monoids,
    groups, rings and modules in Mathlib. There are more complicated than what we
    have seen here, because they are part of a huge hierarchy, but all principles
    have been explained above.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªæ•…äº‹éšåç»§ç»­ï¼Œå°† `zsmul` å­—æ®µçº³å…¥ç¾¤çš„å®šä¹‰ä»¥åŠç±»ä¼¼çš„æŠ€å·§ã€‚ä½ ç°åœ¨å¯ä»¥é˜…è¯» Mathlib ä¸­å•ç¾¤ã€ç¾¤ã€ç¯å’Œæ¨¡å—çš„å®šä¹‰äº†ã€‚å®ƒä»¬æ¯”æˆ‘ä»¬è¿™é‡Œçœ‹åˆ°çš„æ›´å¤æ‚ï¼Œå› ä¸ºå®ƒä»¬æ˜¯å·¨å¤§å±‚æ¬¡ç»“æ„çš„ä¸€éƒ¨åˆ†ï¼Œä½†æ‰€æœ‰åŸåˆ™éƒ½å·²åœ¨ä¸Šé¢è§£é‡Šã€‚
- en: 'As an exercise, you can come back to the order relation hierarchy you built
    above and try to incorporate a type class `LTâ‚` carrying the Less-Than notation
    `<â‚` and make sure that every preorder comes with a `<â‚` which has a default value
    built from `â‰¤â‚` and a `Prop`-valued field asserting the natural relation between
    those two comparison operators.  ## 8.2\. Morphisms[ïƒ](#morphisms "Link to this
    heading")'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç»ƒä¹ ï¼Œä½ å¯ä»¥å›åˆ°ä½ ä¸Šé¢æ„å»ºçš„åºå…³ç³»å±‚æ¬¡ï¼Œå°è¯•çº³å…¥ä¸€ä¸ªæºå¸¦ `<â‚` å°äºå·æ³¨è®°çš„ `LTâ‚` ç±»å‹ç±»ï¼Œå¹¶ç¡®ä¿æ¯ä¸ªååºéƒ½å¸¦æœ‰ `<â‚`ï¼Œå®ƒæœ‰ä¸€ä¸ªä» `â‰¤â‚`
    æ„å»ºçš„é»˜è®¤å€¼ï¼Œä»¥åŠä¸€ä¸ª `Prop` å€¼å­—æ®µï¼Œæ–­è¨€è¿™ä¸¤ä¸ªæ¯”è¾ƒè¿ç®—ç¬¦ä¹‹é—´çš„è‡ªç„¶å…³ç³»ã€‚## 8.2\. æ€å°„[ïƒ](#morphisms "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")
- en: So far in this chapter, we discussed how to create a hierarchy of mathematical
    structures. But defining structures is not really completed until we have morphisms.
    There are two main approaches here. The most obvious one is to define a predicate
    on functions.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œåœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬è®¨è®ºäº†å¦‚ä½•åˆ›å»ºæ•°å­¦ç»“æ„çš„å±‚æ¬¡ã€‚ä½†ç›´åˆ°æˆ‘ä»¬æœ‰äº†æ€å°„ï¼Œå®šä¹‰ç»“æ„æ‰ç®—çœŸæ­£å®Œæˆã€‚è¿™é‡Œæœ‰ä¸¤ç§ä¸»è¦çš„æ–¹æ³•ã€‚æœ€æ˜æ˜¾çš„ä¸€ç§æ˜¯å®šä¹‰ä¸€ä¸ªå…³äºå‡½æ•°çš„è°“è¯ã€‚
- en: '[PRE103]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: In this definition, it is a bit unpleasant to use a conjunction. In particular
    users will need to remember the ordering we chose when they want to access the
    two conditions. So we could use a structure instead.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªå®šä¹‰ä¸­ï¼Œä½¿ç”¨åˆå–æœ‰ç‚¹ä¸æ„‰å¿«ã€‚ç‰¹åˆ«æ˜¯å½“ç”¨æˆ·æƒ³è¦è®¿é—®ä¸¤ä¸ªæ¡ä»¶æ—¶ï¼Œä»–ä»¬éœ€è¦è®°ä½æˆ‘ä»¬é€‰æ‹©çš„æ’åºã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªç»“æ„ã€‚
- en: '[PRE104]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Once we are here, it is even tempting to make it a class and use the type class
    instance resolution procedure to automatically infer `isMonoidHomâ‚‚` for complicated
    functions out of instances for simpler functions. For instance a composition of
    monoid morphisms is a monoid morphism and this seems like a useful instance. However
    such an instance would be very tricky for the resolution procedure since it would
    need to hunt down `g âˆ˜ f` everywhere. Seeing it failing in `g (f x)` would be
    very frustrating. More generally one must always keep in mind that recognizing
    which function is applied in a given expression is a very difficult problem, called
    the â€œhigher-order unification problemâ€. So Mathlib does not use this class approach.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬åˆ°äº†è¿™é‡Œï¼Œç”šè‡³æœ‰å°†å…¶ä½œä¸ºä¸€ä¸ªç±»å¹¶ä½¿ç”¨ç±»å‹ç±»å®ä¾‹è§£æè¿‡ç¨‹æ¥è‡ªåŠ¨æ¨æ–­å¤æ‚å‡½æ•°çš„`isMonoidHomâ‚‚`çš„è¯±æƒ‘ã€‚ä¾‹å¦‚ï¼Œå•ç¾¤åŒæ€çš„å¤åˆä»ç„¶æ˜¯ä¸€ä¸ªå•ç¾¤åŒæ€ï¼Œè¿™ä¼¼ä¹æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„å®ä¾‹ã€‚ç„¶è€Œï¼Œå¯¹äºè§£æè¿‡ç¨‹æ¥è¯´ï¼Œè¿™æ ·çš„å®ä¾‹ä¼šéå¸¸æ£˜æ‰‹ï¼Œå› ä¸ºå®ƒéœ€è¦åˆ°å¤„å¯»æ‰¾`g
    âˆ˜ f`ã€‚åœ¨`g (f x)`ä¸­çœ‹åˆ°å®ƒå¤±è´¥ä¼šéå¸¸ä»¤äººæ²®ä¸§ã€‚æ›´æ™®éåœ°è¯´ï¼Œæˆ‘ä»¬å¿…é¡»å§‹ç»ˆç‰¢è®°ï¼Œè¯†åˆ«ç»™å®šè¡¨è¾¾å¼ä¸­çš„å“ªä¸ªå‡½æ•°è¢«åº”ç”¨æ˜¯ä¸€ä¸ªéå¸¸å›°éš¾çš„é—®é¢˜ï¼Œè¢«ç§°ä¸ºâ€œé«˜é˜¶ç»Ÿä¸€é—®é¢˜â€ã€‚å› æ­¤ï¼ŒMathlibä¸ä½¿ç”¨è¿™ç§ç±»æ–¹æ³•ã€‚
- en: 'A more fundamental question is whether we use predicates as above (using either
    a `def` or a `structure`) or use structures bundling a function and predicates.
    This is partly a psychological issue. It is extremely rare to consider a function
    between monoids that is not a morphism. It really feels like â€œmonoid morphismâ€
    is not an adjective you can assign to a bare function, it is a noun. On the other
    hand one can argue that a continuous function between topological spaces is really
    a function that happens to be continuous. This is one reason why Mathlib has a
    `Continuous` predicate. For instance you can write:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ›´åŸºæœ¬çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬æ˜¯ä½¿ç”¨ä¸Šè¿°è°“è¯ï¼ˆä½¿ç”¨`def`æˆ–`structure`ï¼‰è¿˜æ˜¯ä½¿ç”¨æ†ç»‘å‡½æ•°å’Œè°“è¯çš„ç»“æ„ã€‚è¿™éƒ¨åˆ†æ˜¯ä¸€ä¸ªå¿ƒç†é—®é¢˜ã€‚è€ƒè™‘ä¸€ä¸ªä¸æ˜¯åŒæ€çš„ç¾¤ä¹‹é—´çš„å‡½æ•°æ˜¯éå¸¸ç½•è§çš„ã€‚è¿™çœŸçš„æ„Ÿè§‰åƒâ€œå•ç¾¤åŒæ€â€ä¸æ˜¯ä¸€ä¸ªä½ å¯ä»¥åˆ†é…ç»™è£¸å‡½æ•°çš„å½¢å®¹è¯ï¼Œå®ƒæ˜¯ä¸€ä¸ªåè¯ã€‚å¦ä¸€æ–¹é¢ï¼Œå¯ä»¥äº‰è¾©è¯´ï¼Œæ‹“æ‰‘ç©ºé—´ä¹‹é—´çš„è¿ç»­å‡½æ•°å®é™…ä¸Šæ˜¯ä¸€ä¸ªæ°å¥½æ˜¯è¿ç»­çš„å‡½æ•°ã€‚è¿™æ˜¯Mathlibæœ‰`Continuous`è°“è¯çš„ä¸€ä¸ªåŸå› ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥å†™ï¼š
- en: '[PRE105]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: We still have bundles of continuous functions, which are convenient for instance
    to put a topology on a space of continuous functions, but they are not the primary
    tool to work with continuity.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä»ç„¶æœ‰ä¸€å¤§å †è¿ç»­å‡½æ•°ï¼Œä¾‹å¦‚ï¼Œå®ƒä»¬æ–¹ä¾¿åœ°å°†æ‹“æ‰‘ç»“æ„ç½®äºè¿ç»­å‡½æ•°çš„ç©ºé—´ä¸­ï¼Œä½†å®ƒä»¬å¹¶ä¸æ˜¯å¤„ç†è¿ç»­æ€§çš„ä¸»è¦å·¥å…·ã€‚
- en: 'By contrast, morphisms between monoids (or other algebraic structures) are
    bundled as in:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸æ¯”ä¹‹ä¸‹ï¼Œç¾¤ï¼ˆæˆ–å…¶ä»–ä»£æ•°ç»“æ„ï¼‰ä¹‹é—´çš„å½¢æ€æ†ç»‘å¦‚ä¸‹ï¼š
- en: '[PRE106]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Of course we donâ€™t want to type `toFun` everywhere so we register a coercion
    using the `CoeFun` type class. Its first argument is the type we want to coerce
    to a function. The second argument describes the target function type. In our
    case it is always `G â†’ H` for every `f : MonoidHomâ‚ G H`. We also tag `MonoidHomâ‚.toFun`
    with the `coe` attribute to make sure it is displayed almost invisibly in the
    tactic state, simply by a `â†‘` prefix.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 'å½“ç„¶ï¼Œæˆ‘ä»¬ä¸æƒ³åœ¨æ‰€æœ‰åœ°æ–¹éƒ½è¾“å…¥`toFun`ï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨`CoeFun`ç±»å‹ç±»æ³¨å†Œäº†ä¸€ä¸ªå¼ºåˆ¶è½¬æ¢ã€‚å®ƒçš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯æˆ‘ä»¬æƒ³è¦å¼ºåˆ¶è½¬æ¢ä¸ºå‡½æ•°çš„ç±»å‹ã€‚ç¬¬äºŒä¸ªå‚æ•°æè¿°äº†ç›®æ ‡å‡½æ•°ç±»å‹ã€‚åœ¨æˆ‘ä»¬çš„æƒ…å†µä¸‹ï¼Œå¯¹äºæ¯ä¸ª`f
    : MonoidHomâ‚ G H`ï¼Œå®ƒæ€»æ˜¯`G â†’ H`ã€‚æˆ‘ä»¬è¿˜ä½¿ç”¨`coe`å±æ€§æ ‡è®°`MonoidHomâ‚.toFun`ï¼Œä»¥ç¡®ä¿å®ƒåœ¨æˆ˜æœ¯çŠ¶æ€ä¸­å‡ ä¹ä¸å¯è§ï¼Œåªéœ€ä¸€ä¸ª`â†‘`å‰ç¼€å³å¯ã€‚'
- en: '[PRE107]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Let us check we can indeed apply a bundled monoid morphism to an element.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦çœŸçš„å¯ä»¥å°†ä¸€ä¸ªæ†ç»‘çš„å•ç¾¤åŒæ€åº”ç”¨äºä¸€ä¸ªå…ƒç´ ã€‚
- en: '[PRE108]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: We can do the same with other kind of morphisms until we reach ring morphisms.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ç”¨å…¶ä»–ç±»å‹çš„å½¢æ€åšåŒæ ·çš„äº‹æƒ…ï¼Œç›´åˆ°æˆ‘ä»¬è¾¾åˆ°ç¯åŒæ€ã€‚
- en: '[PRE109]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: There are a couple of issues about this approach. A minor one is we donâ€™t quite
    know where to put the `coe` attribute since the `RingHomâ‚.toFun` does not exist,
    the relevant function is `MonoidHomâ‚.toFun âˆ˜ RingHomâ‚.toMonoidHomâ‚` which is not
    a declaration that can be tagged with an attribute (but we could still define
    a `CoeFunÂ  (RingHomâ‚ R S) (fun _ â†¦ R â†’ S)` instance). A much more important one
    is that lemmas about monoid morphisms wonâ€™t directly apply to ring morphisms.
    This leaves the alternative of either juggling with `RingHomâ‚.toMonoidHomâ‚` each
    time we want to apply a monoid morphism lemma or restate every such lemmas for
    ring morphisms. Neither option is appealing so Mathlib uses a new hierarchy trick
    here. The idea is to define a type class for objects that are at least monoid
    morphisms, instantiate that class with both monoid morphisms and ring morphisms
    and use it to state every lemma. In the definition below, `F` could be `MonoidHomâ‚
    M N`, or `RingHomâ‚ M N` if `M` and `N` have a ring structure.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§æ–¹æ³•æœ‰å‡ ä¸ªé—®é¢˜ã€‚ä¸€ä¸ªè¾ƒå°çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬ä¸çŸ¥é“å°† `coe` å±æ€§æ”¾åœ¨å“ªé‡Œï¼Œå› ä¸º `RingHomâ‚.toFun` ä¸å­˜åœ¨ï¼Œç›¸å…³çš„å‡½æ•°æ˜¯ `MonoidHomâ‚.toFun
    âˆ˜ RingHomâ‚.toMonoidHomâ‚`ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªå¯ä»¥æ ‡è®°å±æ€§çš„å£°æ˜ï¼ˆä½†æˆ‘ä»¬ä»ç„¶å¯ä»¥å®šä¹‰ä¸€ä¸ª `CoeFunÂ  (RingHomâ‚ R S) (fun
    _ â†¦ R â†’ S)` å®ä¾‹ï¼‰ã€‚ä¸€ä¸ªæ›´é‡è¦çš„é—®é¢˜æ˜¯ï¼Œå…³äºå•ç¾¤åŒæ€çš„å¼•ç†ä¸ä¼šç›´æ¥é€‚ç”¨äºç¯åŒæ€ã€‚è¿™ç•™ä¸‹äº†ä¸¤ç§é€‰æ‹©ï¼šæ¯æ¬¡æƒ³è¦åº”ç”¨å•ç¾¤åŒæ€å¼•ç†æ—¶éƒ½ç©å¼„ `RingHomâ‚.toMonoidHomâ‚`ï¼Œæˆ–è€…ä¸ºç¯åŒæ€é‡æ–°é™ˆè¿°æ¯ä¸ªè¿™æ ·çš„å¼•ç†ã€‚è¿™ä¸¤ç§é€‰æ‹©éƒ½ä¸å¸å¼•äººï¼Œå› æ­¤
    Mathlib åœ¨è¿™é‡Œä½¿ç”¨äº†ä¸€ä¸ªæ–°çš„å±‚æ¬¡æŠ€å·§ã€‚æƒ³æ³•æ˜¯ä¸ºè‡³å°‘æ˜¯å•ç¾¤åŒæ€çš„å¯¹è±¡å®šä¹‰ä¸€ä¸ªç±»å‹ç±»ï¼Œç”¨å•ç¾¤åŒæ€å’Œç¯åŒæ€å®ä¾‹åŒ–è¿™ä¸ªç±»ï¼Œå¹¶ä½¿ç”¨å®ƒæ¥é™ˆè¿°æ¯ä¸ªå¼•ç†ã€‚åœ¨ä¸‹é¢çš„å®šä¹‰ä¸­ï¼Œ`F`
    å¯ä»¥æ˜¯ `MonoidHomâ‚ M N`ï¼Œæˆ–è€…å¦‚æœ `M` å’Œ `N` æœ‰ç¯ç»“æ„ï¼Œåˆ™æ˜¯ `RingHomâ‚ M N`ã€‚
- en: '[PRE110]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: However there is a problem with the above implementation. We havenâ€™t registered
    a coercion to function instance yet. Let us try to do it now.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œä¸Šè¿°å®ç°æœ‰ä¸€ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬è¿˜æ²¡æœ‰æ³¨å†Œä¸€ä¸ªè½¬æ¢åˆ°å‡½æ•°å®ä¾‹çš„è½¬æ¢ã€‚è®©æˆ‘ä»¬ç°åœ¨å°è¯•åšè¿™ä»¶äº‹ã€‚
- en: '[PRE111]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Making this an instance would be bad. When faced with something like `f x`
    where the type of `f` is not a function type, Lean will try to find a `CoeFun`
    instance to coerce `f` into a function. The above function has type: `{M N F :
    Type} â†’ [Monoid M] â†’ [Monoid N] â†’ [MonoidHomClassâ‚ F M N] â†’ CoeFun F (fun x â†¦
    M â†’ N)` so, when it trying to apply it, it wouldnâ€™t be a priori clear to Lean
    in which order the unknown types `M`, `N` and `F` should be inferred. This is
    a kind of bad instance that is slightly different from the one we saw already,
    but it boils down to the same issue: without knowing `M`, Lean would have to search
    for a monoid instance on an unknown type, hence hopelessly try *every* monoid
    instance in the database. If you are curious to see the effect of such an instance
    you can type `set_option synthInstance.checkSynthOrder false in` on top of the
    above declaration, replace `def badInst` with `instance`, and look for random
    failures in this file.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 'å°†å…¶ä½œä¸ºä¸€ä¸ªå®ä¾‹æ˜¯ç³Ÿç³•çš„ã€‚å½“é¢å¯¹åƒ `f x` è¿™æ ·çš„ä¸œè¥¿ï¼Œå…¶ä¸­ `f` çš„ç±»å‹ä¸æ˜¯å‡½æ•°ç±»å‹æ—¶ï¼ŒLean ä¼šå°è¯•æ‰¾åˆ°ä¸€ä¸ª `CoeFun` å®ä¾‹æ¥å°†
    `f` è½¬æ¢ä¸ºå‡½æ•°ã€‚ä¸Šè¿°å‡½æ•°çš„ç±»å‹æ˜¯ï¼š`{M N F : Type} â†’ [Monoid M] â†’ [Monoid N] â†’ [MonoidHomClassâ‚
    F M N] â†’ CoeFun F (fun x â†¦ M â†’ N)`ï¼Œå› æ­¤ï¼Œå½“å®ƒå°è¯•åº”ç”¨å®ƒæ—¶ï¼ŒLean å¹¶ä¸æ¸…æ¥šæœªçŸ¥ç±»å‹ `M`ã€`N` å’Œ `F` åº”è¯¥ä»¥ä»€ä¹ˆé¡ºåºæ¨æ–­ã€‚è¿™æ˜¯ä¸€ç§ä¸æˆ‘ä»¬å·²ç»çœ‹åˆ°çš„ç•¥æœ‰ä¸åŒçš„ä¸è‰¯å®ä¾‹ï¼Œä½†å½’ç»“ä¸ºåŒä¸€ä¸ªé—®é¢˜ï¼šä¸çŸ¥é“
    `M`ï¼ŒLean å°±å¿…é¡»åœ¨ä¸€ä¸ªæœªçŸ¥ç±»å‹ä¸Šæœç´¢å•ç¾¤å®ä¾‹ï¼Œå› æ­¤ç»æœ›åœ°å°è¯•æ•°æ®åº“ä¸­çš„æ¯ä¸ªå•ç¾¤å®ä¾‹ã€‚å¦‚æœä½ å¥½å¥‡æƒ³çœ‹åˆ°è¿™ç§å®ä¾‹çš„æ•ˆæœï¼Œä½ å¯ä»¥åœ¨ä¸Šè¿°å£°æ˜é¡¶éƒ¨é”®å…¥ `set_option
    synthInstance.checkSynthOrder false in`ï¼Œå°† `def badInst` æ›¿æ¢ä¸º `instance`ï¼Œå¹¶åœ¨è¿™ä¸ªæ–‡ä»¶ä¸­å¯»æ‰¾éšæœºçš„å¤±è´¥ã€‚'
- en: 'Here the solution is easy, we need to tell Lean to first search what is `F`
    and then deduce `M` and `N`. This is done using the `outParam` function. This
    function is defined as the identity function, but is still recognized by the type
    class machinery and triggers the desired behavior. Hence we can retry defining
    our class, paying attention to the `outParam` function:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè§£å†³æ–¹æ¡ˆå¾ˆç®€å•ï¼Œæˆ‘ä»¬éœ€è¦å‘Šè¯‰ Lean é¦–å…ˆæœç´¢ `F` æ˜¯ä»€ä¹ˆï¼Œç„¶åæ¨æ–­ `M` å’Œ `N`ã€‚è¿™æ˜¯é€šè¿‡ä½¿ç”¨ `outParam` å‡½æ•°æ¥å®Œæˆçš„ã€‚è¿™ä¸ªå‡½æ•°å®šä¹‰ä¸ºæ’ç­‰å‡½æ•°ï¼Œä½†ä»ç„¶è¢«ç±»å‹ç±»æœºåˆ¶è¯†åˆ«å¹¶è§¦å‘æ‰€éœ€çš„è¡Œä¸ºã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥é‡æ–°å®šä¹‰æˆ‘ä»¬çš„ç±»ï¼Œæ³¨æ„
    `outParam` å‡½æ•°ï¼š
- en: '[PRE112]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Now we can proceed with our plan to instantiate this class.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥ç»§ç»­æˆ‘ä»¬çš„è®¡åˆ’æ¥å®ä¾‹åŒ–è¿™ä¸ªç±»ã€‚
- en: '[PRE113]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'As promised every lemma we prove about `f : F` assuming an instance of `MonoidHomClassâ‚
    F` will apply both to monoid morphisms and ring morphisms. Let us see an example
    lemma and check it applies to both situations.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¦‚åŒæ‰¿è¯ºï¼Œæˆ‘ä»¬å…³äº `f : F` çš„æ¯ä¸ªè¯æ˜ï¼Œå‡è®¾ `MonoidHomClassâ‚ F` çš„ä¸€ä¸ªå®ä¾‹ï¼Œéƒ½å°†é€‚ç”¨äºå•ç¾¤åŒæ€å’Œç¯åŒæ€ã€‚è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªç¤ºä¾‹å¼•ç†å¹¶æ£€æŸ¥å®ƒæ˜¯å¦é€‚ç”¨äºè¿™ä¸¤ç§æƒ…å†µã€‚'
- en: '[PRE114]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: At first sight, it may look like we got back to our old bad idea of making `MonoidHomâ‚`
    a class. But we havenâ€™t. Everything is shifted one level of abstraction up. The
    type class resolution procedure wonâ€™t be looking for functions, it will be looking
    for either `MonoidHomâ‚` or `RingHomâ‚`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: åˆçœ‹èµ·æ¥ï¼Œæˆ‘ä»¬å¯èƒ½è§‰å¾—æˆ‘ä»¬åˆå›åˆ°äº†å°† `MonoidHomâ‚` ä½œä¸ºç±»çš„è€æƒ³æ³•ã€‚ä½†æˆ‘ä»¬å¹¶æ²¡æœ‰ã€‚ä¸€åˆ‡éƒ½è¢«æå‡äº†ä¸€ä¸ªæŠ½è±¡å±‚æ¬¡ã€‚ç±»å‹ç±»è§£æè¿‡ç¨‹ä¸ä¼šå¯»æ‰¾å‡½æ•°ï¼Œå®ƒå°†å¯»æ‰¾
    `MonoidHomâ‚` æˆ– `RingHomâ‚`ã€‚
- en: One remaining issue with our approach is the presence of repetitive code around
    the `toFun` field and the corresponding `CoeFun` instance and `coe` attribute.
    It would also be better to record that this pattern is used only for functions
    with extra properties, meaning that the coercion to functions should be injective.
    So Mathlib adds one more layer of abstraction with the base class `DFunLike` (where
    â€œDFunâ€ stands for dependent function). Let us redefine our `MonoidHomClass` on
    top of this base layer.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„æ–¹æ³•ä¸­è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯ `toFun` å­—æ®µå‘¨å›´çš„é‡å¤ä»£ç ä»¥åŠç›¸åº”çš„ `CoeFun` å®ä¾‹å’Œ `coe` å±æ€§ã€‚æœ€å¥½ä¹Ÿè®°å½•è¿™ç§æ¨¡å¼ä»…ç”¨äºå…·æœ‰é¢å¤–å±æ€§çš„åŠŸèƒ½ï¼Œè¿™æ„å‘³ç€å‡½æ•°çš„å¼ºåˆ¶è½¬æ¢åº”è¯¥æ˜¯å•å°„çš„ã€‚å› æ­¤ï¼ŒMathlib
    é€šè¿‡åŸºç±» `DFunLike`ï¼ˆå…¶ä¸­â€œDFunâ€ä»£è¡¨ä¾èµ–å‡½æ•°ï¼‰æ·»åŠ äº†ä¸€ä¸ªæŠ½è±¡å±‚ã€‚è®©æˆ‘ä»¬åœ¨åŸºå±‚ä¹‹ä¸Šé‡æ–°å®šä¹‰æˆ‘ä»¬çš„ `MonoidHomClass`ã€‚
- en: '[PRE115]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Of course the hierarchy of morphisms does not stop here. We could go on and
    define a class `RingHomClassâ‚ƒ` extending `MonoidHomClassâ‚ƒ` and instantiate it
    on `RingHom` and then later on `AlgebraHom` (algebras are rings with some extra
    structure). But weâ€™ve covered the main formalization ideas used in Mathlib for
    morphisms and you should be ready to understand how morphisms are defined in Mathlib.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œå½¢æ€çš„å±‚æ¬¡ç»“æ„å¹¶æ²¡æœ‰åœ¨è¿™é‡Œåœæ­¢ã€‚æˆ‘ä»¬å¯ä»¥ç»§ç»­å®šä¹‰ä¸€ä¸ªæ‰©å±• `MonoidHomClassâ‚ƒ` çš„ç±» `RingHomClassâ‚ƒ`ï¼Œå¹¶åœ¨ `RingHom`
    ä¸Šå®ä¾‹åŒ–å®ƒï¼Œç„¶åç¨ååœ¨å…¶ä¸Šå®ä¾‹åŒ– `AlgebraHom`ï¼ˆä»£æ•°æ˜¯å…·æœ‰é¢å¤–ç»“æ„çš„ç¯ï¼‰ã€‚ä½†æˆ‘ä»¬å·²ç»æ¶µç›–äº† Mathlib ä¸­ç”¨äºå½¢æ€çš„ä¸»è¦å½¢å¼åŒ–æ€æƒ³ï¼Œä½ åº”è¯¥å‡†å¤‡å¥½ç†è§£
    Mathlib ä¸­å½¢æ€æ˜¯å¦‚ä½•å®šä¹‰çš„ã€‚
- en: As an exercise, you should try to define your class of bundled order-preserving
    function between ordered types, and then order preserving monoid morphisms. This
    is for training purposes only. Like continuous functions, order preserving functions
    are primarily unbundled in Mathlib where they are defined by the `Monotone` predicate.
    Of course you need to complete the class definitions below.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç»ƒä¹ ï¼Œä½ åº”è¯¥å°è¯•å®šä¹‰ä½ çš„æœ‰åºç±»å‹ä¹‹é—´æ‰“åŒ…çš„ä¿æŒé¡ºåºçš„å‡½æ•°ç±»ï¼Œç„¶åå®šä¹‰ä¿æŒé¡ºåºçš„å¹ºåŠç¾¤åŒæ€ã€‚è¿™ä»…ç”¨äºè®­ç»ƒç›®çš„ã€‚åƒè¿ç»­å‡½æ•°ä¸€æ ·ï¼Œä¿æŒé¡ºåºçš„å‡½æ•°åœ¨ Mathlib
    ä¸­ä¸»è¦æ˜¯æœªæ‰“åŒ…çš„ï¼Œå®ƒä»¬ç”± `Monotone` è°“è¯å®šä¹‰ã€‚å½“ç„¶ï¼Œä½ éœ€è¦å®Œæˆä¸‹é¢çš„ç±»å®šä¹‰ã€‚
- en: '[PRE116]  ## 8.3\. Sub-objects[ïƒ](#sub-objects "Link to this heading")'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE116]  ## 8.3\. å­å¯¹è±¡[ïƒ](#sub-objects "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")'
- en: After defining some algebraic structure and its morphisms, the next step is
    to consider sets that inherit this algebraic structure, for instance subgroups
    or subrings. This largely overlaps with our previous topic. Indeed a set in `X`
    is implemented as a function from `X` to `Prop` so sub-objects are function satisfying
    a certain predicate. Hence we can reuse of lot of the ideas that led to the `DFunLike`
    class and its descendants. We wonâ€™t reuse `DFunLike` itself because this would
    break the abstraction barrier from `Set X` to `X â†’ Prop`. Instead there is a `SetLike`
    class. Instead of wrapping an injection into a function type, that class wraps
    an injection into a `Set` type and defines the corresponding coercion and `Membership`
    instance.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®šä¹‰äº†ä¸€äº›ä»£æ•°ç»“æ„å’Œå…¶å½¢æ€ä¹‹åï¼Œä¸‹ä¸€æ­¥æ˜¯è€ƒè™‘ç»§æ‰¿è¿™ç§ä»£æ•°ç»“æ„çš„é›†åˆï¼Œä¾‹å¦‚å­ç¾¤æˆ–å­ç¯ã€‚è¿™å¾ˆå¤§ç¨‹åº¦ä¸Šä¸æˆ‘ä»¬çš„å‰ä¸€ä¸ªä¸»é¢˜é‡å ã€‚å®é™…ä¸Šï¼Œ`X` ä¸­çš„é›†åˆè¢«å®ç°ä¸ºä¸€ä¸ªä»
    `X` åˆ° `Prop` çš„å‡½æ•°ï¼Œå› æ­¤å­å¯¹è±¡æ˜¯æ»¡è¶³ä¸€å®šè°“è¯çš„å‡½æ•°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥é‡ç”¨å¯¼è‡´ `DFunLike` ç±»åŠå…¶åä»£çš„è®¸å¤šæƒ³æ³•ã€‚æˆ‘ä»¬ä¸ä¼šé‡ç”¨ `DFunLike`
    æœ¬èº«ï¼Œå› ä¸ºè¿™ä¼šæ‰“ç ´ä» `Set X` åˆ° `X â†’ Prop` çš„æŠ½è±¡éšœç¢ã€‚å–è€Œä»£ä¹‹çš„æ˜¯ï¼Œæœ‰ä¸€ä¸ª `SetLike` ç±»ã€‚è¯¥ç±»ä¸æ˜¯å°†æ³¨å…¥åŒ…è£…åˆ°å‡½æ•°ç±»å‹ä¸­ï¼Œè€Œæ˜¯å°†æ³¨å…¥åŒ…è£…åˆ°
    `Set` ç±»å‹ä¸­ï¼Œå¹¶å®šä¹‰ç›¸åº”çš„å¼ºåˆ¶è½¬æ¢å’Œ `Membership` å®ä¾‹ã€‚
- en: '[PRE117]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Equipped with the above `SetLike` instance, we can already state naturally that
    a submonoid `N` contains `1` without using `N.carrier`. We can also silently treat
    `N` as a set in `M` as take its direct image under a map.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: é…å¤‡äº†ä¸Šè¿° `SetLike` å®ä¾‹ï¼Œæˆ‘ä»¬æ— éœ€ä½¿ç”¨ `N.carrier` å°±å¯ä»¥è‡ªç„¶åœ°å£°æ˜å­å¹ºåŠç¾¤ `N` åŒ…å« `1`ã€‚æˆ‘ä»¬è¿˜å¯ä»¥åœ¨ `M` ä¸­é»˜é»˜åœ°å°†
    `N` è§†ä¸ºä¸€ä¸ªé›†åˆï¼Œå¹¶å–å…¶åœ¨æ˜ å°„ä¸‹çš„ç›´æ¥åƒã€‚
- en: '[PRE118]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'We also have a coercion to `Type` which uses `Subtype` so, given a submonoid
    `N` we can write a parameter `(x : N)` which can be coerced to an element of `M`
    belonging to `N`.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬è¿˜æœ‰ä¸€ä¸ªä½¿ç”¨ `Subtype` çš„ `Type` å¼ºåˆ¶è½¬æ¢ï¼Œå› æ­¤ï¼Œç»™å®šä¸€ä¸ªå­å¹ºåŠç¾¤ `N`ï¼Œæˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªå‚æ•° `(x : N)`ï¼Œå®ƒå¯ä»¥è¢«å¼ºåˆ¶è½¬æ¢ä¸ºå±äº
    `M` ä¸”å±äº `N` çš„ä¸€ä¸ªå…ƒç´ ã€‚'
- en: '[PRE119]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Using this coercion to `Type` we can also tackle the task of equipping a submonoid
    with a monoid structure. We will use the coercion from the type associated to
    `N` as above, and the lemma `SetCoe.ext` asserting this coercion is injective.
    Both are provided by the `SetLike` instance.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ç§åˆ° `Type` çš„å¼ºåˆ¶è½¬æ¢ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥å¤„ç†ç»™å­ç¾¤é…å¤‡å¹ºåŠç¾¤ç»“æ„çš„é—®é¢˜ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ä¸ä¸Šé¢ `N` å…³è”çš„ç±»å‹ç›¸å…³çš„å¼ºåˆ¶è½¬æ¢ï¼Œä»¥åŠæ–­è¨€è¿™ç§å¼ºåˆ¶è½¬æ¢æ˜¯å•å°„çš„å¼•ç†
    `SetCoe.ext`ã€‚è¿™ä¸¤ä¸ªéƒ½ç”± `SetLike` å®ä¾‹æä¾›ã€‚
- en: '[PRE120]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Note that, in the above instance, instead of using the coercion to `M` and calling
    the `property` field, we could have used destructuring binders as follows.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨ä¸Šé¢çš„å®ä¾‹ä¸­ï¼Œæˆ‘ä»¬ä¸æ˜¯ä½¿ç”¨åˆ° `M` çš„å¼ºåˆ¶è½¬æ¢å¹¶è°ƒç”¨ `property` å­—æ®µï¼Œè€Œæ˜¯å¯ä»¥ä½¿ç”¨å¦‚ä¸‹ç»“æ„åŒ–ç»‘å®šã€‚
- en: '[PRE121]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: In order to apply lemmas about submonoids to subgroups or subrings, we need
    a class, just like for morphisms. Note this class take a `SetLike` instance as
    a parameter so it does not need a carrier field and can use the membership notation
    in its fields.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å°†å…³äºå­ç¾¤æˆ–å­ç¯çš„å¼•ç†åº”ç”¨äºå­ç¾¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªç±»ï¼Œå°±åƒå¯¹äºæ€å°„ä¸€æ ·ã€‚æ³¨æ„è¿™ä¸ªç±»æ¥å—ä¸€ä¸ª `SetLike` å®ä¾‹ä½œä¸ºå‚æ•°ï¼Œå› æ­¤å®ƒä¸éœ€è¦è½½ä½“åŸŸå¹¶ä¸”å¯ä»¥åœ¨å…¶å­—æ®µä¸­ä½¿ç”¨æˆå‘˜ç¬¦å·ã€‚
- en: '[PRE122]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: As an exercise you should define a `Subgroupâ‚` structure, endow it with a `SetLike`
    instance and a `SubmonoidClassâ‚` instance, put a `Group` instance on the subtype
    associated to a `Subgroupâ‚` and define a `SubgroupClassâ‚` class.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç»ƒä¹ ï¼Œä½ åº”è¯¥å®šä¹‰ä¸€ä¸ª `Subgroupâ‚` ç»“æ„ï¼Œç»™å®ƒé…å¤‡ä¸€ä¸ª `SetLike` å®ä¾‹å’Œä¸€ä¸ª `SubmonoidClassâ‚` å®ä¾‹ï¼Œåœ¨ `Subgroupâ‚`
    å…³è”çš„å­ç±»å‹ä¸Šæ”¾ç½®ä¸€ä¸ª `Group` å®ä¾‹ï¼Œå¹¶å®šä¹‰ä¸€ä¸ª `SubgroupClassâ‚` ç±»ã€‚
- en: Another very important thing to know about subobjects of a given algebraic object
    in Mathlib always form a complete lattice, and this structure is used a lot. For
    instance you may look for the lemma saying that an intersection of submonoids
    is a submonoid. But this wonâ€™t be a lemma, this will be an infimum construction.
    Let us do the case of two submonoids.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Mathlib ä¸­ï¼Œå…³äºç»™å®šä»£æ•°å¯¹è±¡çš„å­å¯¹è±¡æ€»æ˜¯å½¢æˆä¸€ä¸ªå®Œå¤‡æ ¼ï¼Œå¹¶ä¸”è¿™ä¸ªç»“æ„è¢«å¤§é‡ä½¿ç”¨ã€‚ä¾‹å¦‚ï¼Œä½ å¯èƒ½æƒ³è¦å¯»æ‰¾ä¸€ä¸ªè¯´å­ç¾¤çš„äº¤é›†æ˜¯ä¸€ä¸ªå­ç¾¤çš„å¼•ç†ã€‚ä½†è¿™ä¸ä¼šæ˜¯ä¸€ä¸ªå¼•ç†ï¼Œè€Œæ˜¯ä¸€ä¸ªä¸‹ç¡®ç•Œæ„é€ ã€‚è®©æˆ‘ä»¬æ¥çœ‹ä¸¤ä¸ªå­ç¾¤çš„æƒ…å†µã€‚
- en: '[PRE123]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: This allows to get the intersections of two submonoids as a submonoid.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å…è®¸æˆ‘ä»¬å¾—åˆ°ä¸¤ä¸ªå­ç¾¤çš„äº¤é›†ä½œä¸ºä¸€ä¸ªå­ç¾¤ã€‚
- en: '[PRE124]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: You may think itâ€™s a shame that we had to use the inf symbol `âŠ“` in the above
    example instead of the intersection symbol `âˆ©`. But think about the supremum.
    The union of two submonoids is not a submonoid. However submonoids still form
    a lattice (even a complete one). Actually `N âŠ” P` is the submonoid generated by
    the union of `N` and `P` and of course it would be very confusing to denote it
    by `N âˆª P`. So you can see the use of `N âŠ“ P` as much more consistent. It is also
    a lot more consistent across various kind of algebraic structures. It may look
    a bit weird at first to see the sum of two vector subspace `E` and `F` denoted
    by `E âŠ” F` instead of `E + F`. But you will get used to it. And soon you will
    consider the `E + F` notation as a distraction emphasizing the anecdotal fact
    that elements of `E âŠ” F` can be written as a sum of an element of `E` and an element
    of `F` instead of emphasizing the fundamental fact that `E âŠ” F` is the smallest
    vector subspace containing both `E` and `F`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½ä¼šè®¤ä¸ºæˆ‘ä»¬ä¸å¾—ä¸åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ä½¿ç”¨ä¸‹ç¡®ç•Œç¬¦å· `âŠ“` è€Œä¸æ˜¯äº¤é›†ç¬¦å· `âˆ©` æ˜¯ä¸€ç§é—æ†¾ã€‚ä½†æƒ³æƒ³ä¸Šç¡®ç•Œã€‚ä¸¤ä¸ªå­ç¾¤çš„å¹¶é›†ä¸æ˜¯ä¸€ä¸ªå­ç¾¤ã€‚ç„¶è€Œï¼Œå­ç¾¤ä»ç„¶å½¢æˆä¸€ä¸ªæ ¼ï¼ˆç”šè‡³æ˜¯ä¸€ä¸ªå®Œå¤‡æ ¼ï¼‰ã€‚å®é™…ä¸Šï¼Œ`N
    âŠ” P` æ˜¯ç”± `N` å’Œ `P` çš„å¹¶é›†ç”Ÿæˆçš„å­ç¾¤ï¼Œå½“ç„¶ç”¨ `N âˆª P` æ¥è¡¨ç¤ºå®ƒä¼šéå¸¸ä»¤äººå›°æƒ‘ã€‚æ‰€ä»¥ï¼Œä½ å¯ä»¥çœ‹åˆ°ä½¿ç”¨ `N âŠ“ P` çš„åšæ³•æ›´åŠ ä¸€è‡´ã€‚å®ƒåœ¨å„ç§ç±»å‹çš„ä»£æ•°ç»“æ„ä¸­ä¹Ÿéå¸¸ä¸€è‡´ã€‚ä¸€å¼€å§‹çœ‹åˆ°ä¸¤ä¸ªå‘é‡å­ç©ºé—´
    `E` å’Œ `F` çš„å’Œç”¨ `E âŠ” F` è€Œä¸æ˜¯ `E + F` è¡¨ç¤ºå¯èƒ½ä¼šè§‰å¾—æœ‰ç‚¹å¥‡æ€ªã€‚ä½†ä½ ä¼šä¹ æƒ¯çš„ã€‚å¾ˆå¿«ï¼Œä½ å°†æŠŠ `E + F` ç¬¦å·çœ‹ä½œæ˜¯ä¸€ä¸ªå¹²æ‰°ï¼Œå¼ºè°ƒ
    `E âŠ” F` çš„å…ƒç´ å¯ä»¥å†™æˆ `E` çš„ä¸€ä¸ªå…ƒç´ å’Œ `F` çš„ä¸€ä¸ªå…ƒç´ çš„å’Œä¸­ï¼Œè€Œä¸æ˜¯å¼ºè°ƒ `E âŠ” F` æ˜¯åŒ…å« `E` å’Œ `F` çš„æœ€å°å‘é‡å­ç©ºé—´è¿™ä¸€åŸºæœ¬äº‹å®ã€‚
- en: Our last topic for this chapter is that of quotients. Again we want to explain
    how convenient notation are built and code duplication is avoided in Mathlib.
    Here the main device is the `HasQuotient` class which allows notations like `M
    â§¸ N`. Beware the quotient symbol `â§¸` is a special unicode character, not a regular
    ASCII division symbol.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« çš„æœ€åä¸€ä¸ªä¸»é¢˜æ˜¯å•†çš„æ¦‚å¿µã€‚æˆ‘ä»¬å†æ¬¡æƒ³è¦è§£é‡Šåœ¨ Mathlib ä¸­å¦‚ä½•æ„å»ºæ–¹ä¾¿çš„ç¬¦å·å¹¶é¿å…ä»£ç é‡å¤ã€‚åœ¨è¿™é‡Œï¼Œä¸»è¦çš„å·¥å…·æ˜¯ `HasQuotient`
    ç±»ï¼Œå®ƒå…è®¸ä½¿ç”¨åƒ `M â§¸ N` è¿™æ ·çš„ç¬¦å·ã€‚è¯·æ³¨æ„ï¼Œå•†ç¬¦å· `â§¸` æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ Unicode å­—ç¬¦ï¼Œè€Œä¸æ˜¯å¸¸è§„çš„ ASCII é™¤æ³•ç¬¦å·ã€‚
- en: As an example, we will build the quotient of a commutative monoid by a submonoid,
    leave proofs to you. In the last example, you can use `Setoid.refl` but it wonâ€™t
    automatically pick up the relevant `Setoid` structure. You can fix this issue
    by providing all arguments using the `@` syntax, as in `@Setoid.refl M N.Setoid`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºä¾‹å­ï¼Œæˆ‘ä»¬å°†é€šè¿‡å­å¹ºåŠç¾¤æ„å»ºä¸€ä¸ªäº¤æ¢å¹ºåŠç¾¤çš„å•†ï¼Œè¯æ˜ç•™ç»™ä½ ä»¬ã€‚åœ¨ä¸Šä¸€ä¸ªä¾‹å­ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨`Setoid.refl`ï¼Œä½†å®ƒä¸ä¼šè‡ªåŠ¨é€‰æ‹©ç›¸å…³çš„`Setoid`ç»“æ„ã€‚ä½ å¯ä»¥é€šè¿‡ä½¿ç”¨`@`è¯­æ³•æä¾›æ‰€æœ‰å‚æ•°æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä¾‹å¦‚`@Setoid.refl
    M N.Setoid`ã€‚
- en: '[PRE125]  ## 8.1\. Basics[ïƒ](#basics "Link to this heading")'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE125]  ## 8.1\. åŸºç¡€[ïƒ](#basics "é“¾æ¥åˆ°è¿™ä¸ªæ ‡é¢˜")'
- en: At the very bottom of all hierarchies in Lean, we find data-carrying classes.
    The following class records that the given type `Î±` is endowed with a distinguished
    element called `one`. At this stage, it has no property at all.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Leançš„æ‰€æœ‰å±‚æ¬¡ç»“æ„çš„åº•éƒ¨ï¼Œæˆ‘ä»¬æ‰¾åˆ°äº†æºå¸¦æ•°æ®çš„ç±»ã€‚ä»¥ä¸‹ç±»è®°å½•äº†ç»™å®šçš„ç±»å‹`Î±`è¢«èµ‹äºˆäº†ä¸€ä¸ªç§°ä¸º`one`çš„ç‰¹ç§°å…ƒç´ ã€‚åœ¨è¿™ä¸ªé˜¶æ®µï¼Œå®ƒæ²¡æœ‰ä»»ä½•å±æ€§ã€‚
- en: '[PRE126]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Since weâ€™ll make a much heavier use of classes in this chapter, we need to
    understand some more details about what the `class` command is doing. First, the
    `class` command above defines a structure `Oneâ‚` with parameter `Î± : Type` and
    a single field `one`. It also mark this structure as a class so that arguments
    of type `Oneâ‚ Î±` for some type `Î±` will be inferrable using the instance resolution
    procedure, as long as they are marked as instance-implicit, i.e. appear between
    square brackets. Those two effects could also have been achieved using the `structure`
    command with `class` attribute, i.e. writing `@[class] structure` instance of
    `class`. But the class command also ensures that `Oneâ‚ Î±` appears as an instance-implicit
    argument in its own fields. Compare:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç”±äºæˆ‘ä»¬å°†åœ¨æœ¬ç« ä¸­å¤§é‡ä½¿ç”¨ç±»ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£ä¸€äº›å…³äº`class`å‘½ä»¤åšäº†ä»€ä¹ˆçš„æ›´å¤šç»†èŠ‚ã€‚é¦–å…ˆï¼Œä¸Šé¢çš„`class`å‘½ä»¤å®šä¹‰äº†ä¸€ä¸ªå¸¦æœ‰å‚æ•°`Î± : Type`å’Œå•ä¸ªå­—æ®µ`one`çš„ç»“æ„`Oneâ‚`ã€‚å®ƒè¿˜æ ‡è®°è¿™ä¸ªç»“æ„ä¸ºç±»ï¼Œä»¥ä¾¿æŸäº›ç±»å‹`Î±`çš„`Oneâ‚
    Î±`çš„å‚æ•°å¯ä»¥é€šè¿‡å®ä¾‹è§£æè¿‡ç¨‹æ¨æ–­å‡ºæ¥ï¼Œåªè¦å®ƒä»¬è¢«æ ‡è®°ä¸ºå®ä¾‹éšå¼ï¼Œå³å‡ºç°åœ¨æ–¹æ‹¬å·ä¹‹é—´ã€‚è¿™ä¸¤ä¸ªæ•ˆæœä¹Ÿå¯ä»¥é€šè¿‡å¸¦æœ‰`class`å±æ€§çš„`structure`å‘½ä»¤æ¥å®ç°ï¼Œå³å†™ä½œ`@[class]
    structure`å®ä¾‹`class`ã€‚ä½†æ˜¯ï¼Œç±»å‘½ä»¤è¿˜ç¡®ä¿`Oneâ‚ Î±`åœ¨å…¶è‡ªå·±çš„å­—æ®µä¸­ä½œä¸ºå®ä¾‹éšå¼å‚æ•°å‡ºç°ã€‚æ¯”è¾ƒï¼š'
- en: '[PRE127]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'In the second check, we can see that `self : Oneâ‚‚ Î±` is an explicit argument.
    Let us make sure the first version is indeed usable without any explicit argument.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 'åœ¨ç¬¬äºŒä¸ªæ£€æŸ¥ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°`self : Oneâ‚‚ Î±`æ˜¯ä¸€ä¸ªæ˜¾å¼å‚æ•°ã€‚è®©æˆ‘ä»¬ç¡®ä¿ç¬¬ä¸€ä¸ªç‰ˆæœ¬ç¡®å®å¯ä»¥åœ¨æ²¡æœ‰ä»»ä½•æ˜¾å¼å‚æ•°çš„æƒ…å†µä¸‹ä½¿ç”¨ã€‚'
- en: '[PRE128]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Remark: in the above example, the argument `Oneâ‚ Î±` is marked as instance-implicit,
    which is a bit silly since this affects only *uses* of the declaration and declaration
    created by the `example` command cannot be used. However it allows us to avoid
    giving a name to that argument and, more importantly, it starts installing the
    good habit of marking `Oneâ‚ Î±` arguments as instance-implicit.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: å¤‡æ³¨ï¼šåœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œå‚æ•°`Oneâ‚ Î±`è¢«æ ‡è®°ä¸ºå®ä¾‹éšå¼ï¼Œè¿™æœ‰ç‚¹æ„šè ¢ï¼Œå› ä¸ºè¿™åªå½±å“å£°æ˜çš„*ä½¿ç”¨*ä»¥åŠç”±`example`å‘½ä»¤åˆ›å»ºçš„å£°æ˜ä¸èƒ½è¢«ä½¿ç”¨ã€‚ç„¶è€Œï¼Œå®ƒå…è®¸æˆ‘ä»¬é¿å…ç»™è¿™ä¸ªå‚æ•°å‘½åï¼Œæ›´é‡è¦çš„æ˜¯ï¼Œå®ƒå¼€å§‹å…»æˆå°†`Oneâ‚
    Î±`å‚æ•°æ ‡è®°ä¸ºå®ä¾‹éšå¼çš„è‰¯å¥½ä¹ æƒ¯ã€‚
- en: 'Another remark is that all this will work only when Lean knows what is `Î±`.
    In the above example, leaving out the type ascription `: Î±` would generate an
    error message like: `typeclass instance problem is stuck, it is often due to metavariables
    Oneâ‚ (?m.263 Î±)` where `?m.263 Î±` means â€œsome type depending on `Î±`â€ (and 263
    is simply an auto-generated index that would be useful to distinguish between
    several unknown things). Another way to avoid this issue would be to use a type
    annotation, as in:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¦ä¸€ä¸ªéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ‰€æœ‰è¿™äº›åªæœ‰åœ¨LeançŸ¥é“`Î±`æ˜¯ä»€ä¹ˆçš„æƒ…å†µä¸‹æ‰ä¼šå·¥ä½œã€‚åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œçœç•¥ç±»å‹æ³¨è§£`: Î±`å°†ç”Ÿæˆä¸€ä¸ªé”™è¯¯ä¿¡æ¯ï¼Œä¾‹å¦‚ï¼š`typeclass
    instance problem is stuck, it is often due to metavariables Oneâ‚ (?m.263 Î±)`ï¼Œå…¶ä¸­`?m.263
    Î±`è¡¨ç¤ºâ€œä¾èµ–äº`Î±`çš„æŸäº›ç±»å‹â€ï¼ˆè€Œ263åªæ˜¯ä¸€ä¸ªè‡ªåŠ¨ç”Ÿæˆçš„ç´¢å¼•ï¼Œå¯ä»¥ç”¨æ¥åŒºåˆ†å‡ ä¸ªæœªçŸ¥çš„äº‹ç‰©ï¼‰ã€‚é¿å…è¿™ä¸ªé—®é¢˜çš„å¦ä¸€ç§æ–¹æ³•æ˜¯åœ¨ä½¿ç”¨ç±»å‹æ³¨è§£ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š'
- en: '[PRE129]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: You may have already encountered that issue when playing with limits of sequences
    in [Section 3.6](C03_Logic.html#sequences-and-convergence) if you tried to state
    for instance that `0 < 1` without telling Lean whether you meant this inequality
    to be about natural numbers or real numbers.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½åœ¨[ç¬¬3.6èŠ‚](C03_Logic.html#sequences-and-convergence)ä¸­ç©åºåˆ—çš„æé™æ—¶å·²ç»é‡åˆ°è¿‡è¿™ä¸ªé—®é¢˜ï¼Œå¦‚æœä½ è¯•å›¾å£°æ˜ä¾‹å¦‚`0
    < 1`ï¼Œä½†æ²¡æœ‰å‘Šè¯‰Leanä½ æ˜¯æŒ‡è‡ªç„¶æ•°è¿˜æ˜¯å®æ•°çš„è¿™ä¸ªä¸ç­‰å¼ã€‚
- en: Our next task is to assign a notation to `Oneâ‚.one`. Since we donâ€™t want collisions
    with the builtin notation for `1`, we will use `ğŸ™`. This is achieved by the following
    command where the first line tells Lean to use the documentation of `Oneâ‚.one`
    as documentation for the symbol `ğŸ™`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ¥ä¸‹æ¥çš„ä»»åŠ¡æ˜¯ç»™ `Oneâ‚.one` åˆ†é…ä¸€ä¸ªç¬¦å·ã€‚ç”±äºæˆ‘ä»¬ä¸å¸Œæœ›ä¸å†…ç½®çš„ `1` çš„ç¬¦å·å‘ç”Ÿå†²çªï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ `ğŸ™`ã€‚è¿™æ˜¯é€šè¿‡ä»¥ä¸‹å‘½ä»¤å®ç°çš„ï¼Œå…¶ä¸­ç¬¬ä¸€è¡Œå‘Šè¯‰
    Lean ä½¿ç”¨ `Oneâ‚.one` çš„æ–‡æ¡£ä½œä¸ºç¬¦å· `ğŸ™` çš„æ–‡æ¡£ã€‚
- en: '[PRE130]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: We now want a data-carrying class recording a binary operation. We donâ€™t want
    to choose between addition and multiplication for now so weâ€™ll use diamond.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨æƒ³è¦ä¸€ä¸ªæºå¸¦æ•°æ®çš„ç±»æ¥è®°å½•äºŒå…ƒæ“ä½œã€‚ç›®å‰æˆ‘ä»¬ä¸æƒ³åœ¨åŠ æ³•å’Œä¹˜æ³•ä¹‹é—´åšå‡ºé€‰æ‹©ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†ä½¿ç”¨è±å½¢ã€‚
- en: '[PRE131]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: As in the `Oneâ‚` example, the operation has no property at all at this stage.
    Let us now define the class of semigroup structures where the operation is denoted
    by `â‹„`. For now, we define it by hand as a structure with two fields, a `Diaâ‚`
    instance and some `Prop`-valued field `dia_assoc` asserting associativity of `â‹„`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ `Oneâ‚` ä¾‹å­ä¸€æ ·ï¼Œè¿™ä¸ªæ“ä½œåœ¨è¿™ä¸ªé˜¶æ®µæ²¡æœ‰ä»»ä½•å±æ€§ã€‚ç°åœ¨è®©æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªåŠç¾¤ç»“æ„çš„ç±»ï¼Œå…¶ä¸­æ“ä½œç”¨ `â‹„` è¡¨ç¤ºã€‚ç›®å‰ï¼Œæˆ‘ä»¬é€šè¿‡æ‰‹åŠ¨å®šä¹‰ä¸€ä¸ªå…·æœ‰ä¸¤ä¸ªå­—æ®µçš„ç»“æ„æ¥å®šä¹‰å®ƒï¼Œä¸€ä¸ª
    `Diaâ‚` å®ä¾‹å’Œä¸€äº› `Prop` ç±»å‹çš„å­—æ®µ `dia_assoc`ï¼Œæ–­è¨€ `â‹„` çš„ç»“åˆæ€§ã€‚
- en: '[PRE132]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Note that while stating dia_assoc, the previously defined field toDiaâ‚ is in
    the local context hence can be used when Lean searches for an instance of Diaâ‚
    Î± to make sense of a â‹„ b. However this toDiaâ‚ field does not become part of the
    type class instances database. Hence doing `example {Î± : Type} [Semigroupâ‚ Î±]
    (a b : Î±) : Î± := a â‹„ b` would fail with error message `failed to synthesize instance
    Diaâ‚ Î±`.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ³¨æ„ï¼Œåœ¨é™ˆè¿° dia_assoc æ—¶ï¼Œä¹‹å‰å®šä¹‰çš„å­—æ®µ toDiaâ‚ ä½äºå±€éƒ¨ä¸Šä¸‹æ–‡ä¸­ï¼Œå› æ­¤å½“ Lean æœç´¢ Diaâ‚ Î± çš„å®ä¾‹ä»¥ç†è§£ â‹„ b æ—¶å¯ä»¥ä½¿ç”¨ã€‚ç„¶è€Œï¼Œè¿™ä¸ª
    toDiaâ‚ å­—æ®µä¸ä¼šæˆä¸ºç±»å‹ç±»å®ä¾‹æ•°æ®åº“çš„ä¸€éƒ¨åˆ†ã€‚å› æ­¤ï¼Œæ‰§è¡Œ `example {Î± : Type} [Semigroupâ‚ Î±] (a b : Î±) :
    Î± := a â‹„ b` ä¼šå¤±è´¥ï¼Œé”™è¯¯ä¿¡æ¯ä¸º `failed to synthesize instance Diaâ‚ Î±`ã€‚'
- en: We can fix this by adding the `instance` attribute later.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é€šè¿‡ç¨åæ·»åŠ  `instance` å±æ€§æ¥ä¿®å¤è¿™ä¸ªé—®é¢˜ã€‚
- en: '[PRE133]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Before building up, we need to use a different syntax to add this toDiaâ‚ field,
    to tell Lean that Diaâ‚ Î± should be treated as if its fields were fields of Semigroupâ‚
    itself. This also conveniently adds the toDiaâ‚ instance automatically. The `class`
    command supports this using the `extends` syntax as in:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ„å»ºä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ä¸åŒçš„è¯­æ³•æ¥æ·»åŠ è¿™ä¸ª toDiaâ‚ å­—æ®µï¼Œå‘Šè¯‰ Lean Diaâ‚ Î± åº”è¯¥è¢«è§†ä¸ºå…¶å­—æ®µæ˜¯ Semigroupâ‚ è‡ªèº«çš„å­—æ®µã€‚è¿™ä¹Ÿæ–¹ä¾¿åœ°è‡ªåŠ¨æ·»åŠ äº†
    toDiaâ‚ å®ä¾‹ã€‚`class` å‘½ä»¤ä½¿ç”¨ `extends` è¯­æ³•æ”¯æŒè¿™ä¸€ç‚¹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE134]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Note this syntax is also available in the `structure` command, although it that
    case it fixes only the hurdle of writing fields such as toDiaâ‚ since there is
    no instance to define in that case.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæ­¤è¯­æ³•ä¹Ÿé€‚ç”¨äº `structure` å‘½ä»¤ï¼Œå°½ç®¡åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒä»…è§£å†³äº†ç¼–å†™ toDiaâ‚ ç­‰å­—æ®µçš„é—®é¢˜ï¼Œå› ä¸ºåœ¨é‚£ç§æƒ…å†µä¸‹æ²¡æœ‰å®ä¾‹è¦å®šä¹‰ã€‚
- en: The field name toDiaâ‚ is optional in the extends syntax. By default it takes
    the name of the class being extended and prefixes it with â€œtoâ€.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ `extends` è¯­æ³•ä¸­ï¼Œå­—æ®µå toDiaâ‚ æ˜¯å¯é€‰çš„ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå®ƒé‡‡ç”¨è¢«æ‰©å±•çš„ç±»çš„åç§°ï¼Œå¹¶åœ¨å…¶å‰é¢åŠ ä¸Šâ€œtoâ€ã€‚
- en: '[PRE135]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Let us now try to combine a diamond operation and a distinguished one element
    with axioms saying this element is neutral on both sides.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å°è¯•å°†ä¸€ä¸ªè±å½¢æ“ä½œå’Œä¸€ä¸ªç‰¹æ®Šå…ƒç´ ç»“åˆèµ·æ¥ï¼Œé€šè¿‡å…¬ç†è¯´æ˜è¿™ä¸ªå…ƒç´ åœ¨ä¸¤è¾¹éƒ½æ˜¯ä¸­æ€§çš„ã€‚
- en: '[PRE136]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: In the next example, we tell Lean that `Î±` has a `DiaOneClassâ‚` structure and
    state a property that uses both a Diaâ‚ instance and a Oneâ‚ instance. In order
    to see how Lean finds those instances we set a tracing option whose result can
    be seen in the Infoview. This result is rather terse by default but it can be
    expanded by clicking on lines ending with black arrows. It includes failed attempts
    where Lean tried to find instances before having enough type information to succeed.
    The successful attempts do involve the instances generated by the `extends` syntax.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹ä¸€ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å‘Šè¯‰ Lean `Î±` å…·æœ‰ç»“æ„ `DiaOneClassâ‚`ï¼Œå¹¶é™ˆè¿°äº†ä¸€ä¸ªä½¿ç”¨ Diaâ‚ å®ä¾‹å’Œ Oneâ‚ å®ä¾‹çš„å±æ€§ã€‚ä¸ºäº†äº†è§£
    Lean å¦‚ä½•æ‰¾åˆ°è¿™äº›å®ä¾‹ï¼Œæˆ‘ä»¬è®¾ç½®äº†ä¸€ä¸ªè·Ÿè¸ªé€‰é¡¹ï¼Œå…¶ç»“æœå¯ä»¥åœ¨ Infoview ä¸­æŸ¥çœ‹ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè¿™ä¸ªç»“æœç›¸å½“ç®€çŸ­ï¼Œä½†å¯ä»¥é€šè¿‡ç‚¹å‡»ä»¥é»‘è‰²ç®­å¤´ç»“æŸçš„è¡Œæ¥å±•å¼€ã€‚å®ƒåŒ…æ‹¬
    Lean åœ¨æˆåŠŸä¹‹å‰å°è¯•æ‰¾åˆ°å®ä¾‹çš„å¤±è´¥å°è¯•ã€‚æˆåŠŸçš„å°è¯•ç¡®å®æ¶‰åŠç”± `extends` è¯­æ³•ç”Ÿæˆçš„å®ä¾‹ã€‚
- en: '[PRE137]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Note that we donâ€™t need to include extra fields where combining existing classes.
    Hence we can define monoids as:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨ç»„åˆç°æœ‰ç±»æ—¶ï¼Œæˆ‘ä»¬ä¸éœ€è¦åŒ…å«é¢å¤–çš„å­—æ®µã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰å¹ºåŠç¾¤å¦‚ä¸‹ï¼š
- en: '[PRE138]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: While the above definition seems straightforward, it hides an important subtlety.
    Both `Semigroupâ‚ Î±` and `DiaOneClassâ‚ Î±` extend `Diaâ‚ Î±`, so one could fear that
    having a `Monoidâ‚ Î±` instance gives two unrelated diamond operations on `Î±`, one
    coming from a field `Monoidâ‚.toSemigroupâ‚` and one coming from a field `Monoidâ‚.toDiaOneClassâ‚`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶ä¸Šè¿°å®šä¹‰çœ‹èµ·æ¥å¾ˆç®€å•ï¼Œä½†å®ƒéšè—äº†ä¸€ä¸ªé‡è¦çš„å¾®å¦™ä¹‹å¤„ã€‚`Semigroupâ‚ Î±` å’Œ `DiaOneClassâ‚ Î±` éƒ½æ‰©å±•äº† `Diaâ‚ Î±`ï¼Œå› æ­¤äººä»¬å¯èƒ½ä¼šæ‹…å¿ƒæ‹¥æœ‰ä¸€ä¸ª
    `Monoidâ‚ Î±` å®ä¾‹ä¼šç»™å‡ºä¸¤ä¸ªä¸ `Î±` æ— å…³çš„è±å½¢æ“ä½œï¼Œä¸€ä¸ªæ¥è‡ªå­—æ®µ `Monoidâ‚.toSemigroupâ‚`ï¼Œå¦ä¸€ä¸ªæ¥è‡ªå­—æ®µ `Monoidâ‚.toDiaOneClassâ‚`ã€‚
- en: 'Indeed if we try to build a monoid class by hand using:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œå¦‚æœæˆ‘ä»¬å°è¯•æ‰‹åŠ¨æ„å»ºä¸€ä¸ªå¹ºåŠç¾¤ç±»ï¼Œä½¿ç”¨ï¼š
- en: '[PRE139]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: then we get two completely unrelated diamond operations `Monoidâ‚‚.toSemigroupâ‚.toDiaâ‚.dia`
    and `Monoidâ‚‚.toDiaOneClassâ‚.toDiaâ‚.dia`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œæˆ‘ä»¬å¾—åˆ°ä¸¤ä¸ªå®Œå…¨æ— å…³çš„è±å½¢æ“ä½œ `Monoidâ‚‚.toSemigroupâ‚.toDiaâ‚.dia` å’Œ `Monoidâ‚‚.toDiaOneClassâ‚.toDiaâ‚.dia`ã€‚
- en: The version generated using the `extends` syntax does not have this defect.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ `extends` è¯­æ³•ç”Ÿæˆçš„ç‰ˆæœ¬æ²¡æœ‰è¿™ä¸ªç¼ºé™·ã€‚
- en: '[PRE140]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'So the `class` command did some magic for us (and the `structure` command would
    have done it too). An easy way to see what are the fields of our classes is to
    check their constructor. Compare:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œ`class` å‘½ä»¤ä¸ºæˆ‘ä»¬åšäº†ä¸€äº›é­”æ³•ï¼ˆ`structure` å‘½ä»¤ä¹Ÿä¼šè¿™æ ·åšï¼‰ã€‚æŸ¥çœ‹æˆ‘ä»¬ç±»çš„å­—æ®µçš„ä¸€ä¸ªç®€å•æ–¹æ³•æ˜¯æ¯”è¾ƒå®ƒä»¬çš„æ„é€ å‡½æ•°ã€‚æ¯”è¾ƒï¼š
- en: '[PRE141]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: So we see that `Monoidâ‚` takes `Semigroupâ‚ Î±` argument as expected but then
    it wonâ€™t take a would-be overlapping `DiaOneClassâ‚ Î±` argument but instead tears
    it apart and includes only the non-overlapping parts. And it also auto-generated
    an instance `Monoidâ‚.toDiaOneClassâ‚` which is *not* a field but has the expected
    signature which, from the end-user point of view, restores the symmetry between
    the two extended classes `Semigroupâ‚` and `DiaOneClassâ‚`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤æˆ‘ä»¬çœ‹åˆ° `Monoidâ‚` æŒ‰é¢„æœŸæ¥å— `Semigroupâ‚ Î±` å‚æ•°ï¼Œä½†å®ƒä¸ä¼šæ¥å—ä¸€ä¸ªæ½œåœ¨çš„é‡å¤çš„ `DiaOneClassâ‚ Î±` å‚æ•°ï¼Œè€Œæ˜¯å°†å…¶æ‹†åˆ†å¹¶åªåŒ…å«éé‡å çš„éƒ¨åˆ†ã€‚å®ƒè¿˜è‡ªåŠ¨ç”Ÿæˆäº†ä¸€ä¸ªå®ä¾‹
    `Monoidâ‚.toDiaOneClassâ‚`ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªå­—æ®µï¼Œä½†å®ƒå…·æœ‰é¢„æœŸçš„ç­¾åï¼Œä»æœ€ç»ˆç”¨æˆ·çš„è§’åº¦æ¥çœ‹ï¼Œå®ƒæ¢å¤äº†ä¸¤ä¸ªæ‰©å±•ç±» `Semigroupâ‚` å’Œ
    `DiaOneClassâ‚` ä¹‹é—´çš„å¯¹ç§°æ€§ã€‚
- en: '[PRE142]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: We are now very close to defining groups. We could add to the monoid structure
    a field asserting the existence of an inverse for every element. But then we would
    need to work to access these inverses. In practice it is more convenient to add
    it as data. To optimize reusability, we define a new data-carrying class, and
    then give it some notation.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨éå¸¸æ¥è¿‘å®šä¹‰ç¾¤äº†ã€‚æˆ‘ä»¬å¯ä»¥åœ¨å¹ºåŠç¾¤ç»“æ„ä¸­æ·»åŠ ä¸€ä¸ªå­—æ®µï¼Œæ–­è¨€æ¯ä¸ªå…ƒç´ çš„å­˜åœ¨æ€§ã€‚ä½†é‚£æ—¶æˆ‘ä»¬éœ€è¦åŠªåŠ›æ¥è®¿é—®è¿™äº›é€†å…ƒã€‚åœ¨å®è·µä¸­ï¼Œå°†å…¶ä½œä¸ºæ•°æ®æ·»åŠ æ›´æ–¹ä¾¿ã€‚ä¸ºäº†ä¼˜åŒ–å¯é‡ç”¨æ€§ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªæ–°çš„æ•°æ®æ‰¿è½½ç±»ï¼Œç„¶åç»™å®ƒä¸€äº›ç¬¦å·ã€‚
- en: '[PRE143]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: The above definition may seem too weak, we only ask that `aâ»Â¹` is a left-inverse
    of `a`. But the other side is automatic. In order to prove that, we need a preliminary
    lemma.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°å®šä¹‰å¯èƒ½çœ‹èµ·æ¥å¤ªå¼±äº†ï¼Œæˆ‘ä»¬åªè¦æ±‚ `aâ»Â¹` æ˜¯ `a` çš„å·¦é€†ã€‚ä½†å¦ä¸€æ–¹é¢æ˜¯è‡ªåŠ¨çš„ã€‚ä¸ºäº†è¯æ˜è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåˆæ­¥çš„å¼•ç†ã€‚
- en: '[PRE144]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: In this lemma, it is pretty annoying to give full names, especially since it
    requires knowing which part of the hierarchy provides those facts. One way to
    fix this is to use the `export` command to copy those facts as lemmas in the root
    name space.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªå¼•ç†ä¸­ï¼Œç»™å‡ºå…¨åç›¸å½“ä»¤äººçƒ¦æ¼ï¼Œå°¤å…¶æ˜¯å› ä¸ºå®ƒéœ€è¦çŸ¥é“å“ªä¸ªéƒ¨åˆ†æä¾›äº†è¿™äº›äº‹å®ã€‚ä¸€ç§ä¿®å¤æ–¹æ³•æ˜¯ä½¿ç”¨ `export` å‘½ä»¤å°†è¿™äº›äº‹å®ä½œä¸ºæ ¹åç§°ç©ºé—´ä¸­çš„å¼•ç†å¤åˆ¶ã€‚
- en: '[PRE145]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'We can then rewrite the above proof as:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸Šè¿°è¯æ˜é‡å†™ä¸ºï¼š
- en: '[PRE146]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: It is now your turn to prove things about our algebraic structures.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è½®åˆ°ä½ æ¥è¯æ˜å…³äºæˆ‘ä»¬çš„ä»£æ•°ç»“æ„çš„äº‹å®äº†ã€‚
- en: '[PRE147]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: At this stage we would like to move on to define rings, but there is a serious
    issue. A ring structure on a type contains both an additive group structure and
    a multiplicative monoid structure, and some properties about their interaction.
    But so far we hard-coded a notation `â‹„` for all our operations. More fundamentally,
    the type class system assumes every type has only one instance of each type class.
    There are various ways to solve this issue. Surprisingly Mathlib uses the naive
    idea to duplicate everything for additive and multiplicative theories with the
    help of some code-generating attribute. Structures and classes are defined in
    both additive and multiplicative notation with an attribute `to_additive` linking
    them. In case of multiple inheritance like for semi-groups, the auto-generated
    â€œsymmetry-restoringâ€ instances need also to be marked. This is a bit technical;
    you donâ€™t need to understand details. The important point is that lemmas are then
    only stated in multiplicative notation and marked with the attribute `to_additive`
    to generate the additive version as `left_inv_eq_right_inv'` with its auto-generated
    additive version `left_neg_eq_right_neg'`. In order to check the name of this
    additive version we used the `whatsnew in` command on top of `left_inv_eq_right_inv'`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªé˜¶æ®µï¼Œæˆ‘ä»¬å¸Œæœ›ç»§ç»­å®šä¹‰ç¯ï¼Œä½†æœ‰ä¸€ä¸ªä¸¥é‡çš„é—®é¢˜ã€‚ä¸€ä¸ªç±»å‹ä¸Šçš„ç¯ç»“æ„åŒ…å«ä¸€ä¸ªåŠ æ³•ç¾¤ç»“æ„å’Œä¹˜æ³•å¹ºåŠç¾¤ç»“æ„ï¼Œä»¥åŠå…³äºå®ƒä»¬ä¹‹é—´ç›¸äº’ä½œç”¨çš„æŸäº›æ€§è´¨ã€‚ä½†åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¸ºæ‰€æœ‰æ“ä½œç¡¬ç¼–ç äº†ä¸€ä¸ªç¬¦å·`â‹„`ã€‚æ›´åŸºæœ¬çš„æ˜¯ï¼Œç±»å‹ç±»ç³»ç»Ÿå‡è®¾æ¯ä¸ªç±»å‹åªæœ‰ä¸€ä¸ªç±»å‹ç±»çš„å®ä¾‹ã€‚æœ‰å„ç§æ–¹æ³•å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ä»¤äººæƒŠè®¶çš„æ˜¯ï¼ŒMathlibä½¿ç”¨ä¸€ç§åŸå§‹çš„æƒ³æ³•ï¼Œé€šè¿‡ä¸€äº›ä»£ç ç”Ÿæˆå±æ€§æ¥ä¸ºåŠ æ³•å’Œä¹˜æ³•ç†è®ºå¤åˆ¶ä¸€åˆ‡ã€‚ç»“æ„å’Œç±»éƒ½åœ¨åŠ æ³•å’Œä¹˜æ³•ç¬¦å·ä¸‹å®šä¹‰ï¼Œå¹¶é€šè¿‡å±æ€§`to_additive`å°†å®ƒä»¬é“¾æ¥èµ·æ¥ã€‚åœ¨åƒåŠç¾¤è¿™æ ·çš„å¤šé‡ç»§æ‰¿çš„æƒ…å†µä¸‹ï¼Œè‡ªåŠ¨ç”Ÿæˆçš„â€œå¯¹ç§°æ¢å¤â€å®ä¾‹ä¹Ÿéœ€è¦æ ‡è®°ã€‚è¿™æœ‰ç‚¹æŠ€æœ¯æ€§ï¼›ä½ ä¸éœ€è¦ç†è§£ç»†èŠ‚ã€‚é‡è¦çš„æ˜¯ï¼Œå¼•ç†åªä»¥ä¹˜æ³•ç¬¦å·çš„å½¢å¼é™ˆè¿°ï¼Œå¹¶æ ‡è®°äº†`to_additive`å±æ€§ä»¥ç”ŸæˆåŠ æ³•ç‰ˆæœ¬`left_inv_eq_right_inv'`åŠå…¶è‡ªåŠ¨ç”Ÿæˆçš„åŠ æ³•ç‰ˆæœ¬`left_neg_eq_right_neg'`ã€‚ä¸ºäº†æ£€æŸ¥è¿™ä¸ªåŠ æ³•ç‰ˆæœ¬çš„åå­—ï¼Œæˆ‘ä»¬åœ¨`left_inv_eq_right_inv'`çš„é¡¶éƒ¨ä½¿ç”¨äº†`whatsnew
    in`å‘½ä»¤ã€‚
- en: '[PRE148]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Equipped with this technology, we can easily define also commutative semigroups,
    monoids and groups, and then define rings.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰äº†è¿™é¡¹æŠ€æœ¯ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è½»æ¾åœ°å®šä¹‰äº¤æ¢åŠç¾¤ã€å¹ºåŠç¾¤å’Œç¾¤ï¼Œç„¶åå®šä¹‰ç¯ã€‚
- en: '[PRE149]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: We should remember to tag lemmas with `simp` when appropriate.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åº”è¯¥è®°å¾—åœ¨é€‚å½“çš„æ—¶å€™ç»™å¼•ç†æ ‡è®°`simp`ã€‚
- en: '[PRE150]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Then we need to repeat ourselves a bit since we switch to standard notations,
    but at least `to_additive` does the work of translating from the multiplicative
    notation to the additive one.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬éœ€è¦é‡å¤ä¸€ä¸‹ï¼Œå› ä¸ºæˆ‘ä»¬åˆ‡æ¢åˆ°æ ‡å‡†ç¬¦å·ï¼Œä½†è‡³å°‘`to_additive`å®Œæˆäº†ä»ä¹˜æ³•ç¬¦å·åˆ°åŠ æ³•ç¬¦å·çš„ç¿»è¯‘å·¥ä½œã€‚
- en: '[PRE151]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Note that `to_additive` can be asked to tag a lemma with `simp` and propagate
    that attribute to the additive version as follows.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ`to_additive`å¯ä»¥è¦æ±‚ç»™ä¸€ä¸ªå¼•ç†æ ‡è®°`simp`å¹¶å°†è¯¥å±æ€§ä¼ æ’­åˆ°åŠ æ³•ç‰ˆæœ¬ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚
- en: '[PRE152]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: We are now ready for rings. For demonstration purposes we wonâ€™t assume that
    addition is commutative, and then immediately provide an instance of `AddCommGroupâ‚ƒ`.
    Mathlib does not play this game, first because in practice this does not make
    any ring instance easier and also because Mathlibâ€™s algebraic hierarchy goes through
    semirings which are like rings but without opposites so that the proof below does
    not work for them. What we gain here, besides a nice exercise if you have never
    seen it, is an example of building an instance using the syntax that allows to
    provide a parent structure as an instance parameter and then supply the extra
    fields. Here the Ringâ‚ƒ R argument supplies anything AddCommGroupâ‚ƒ R wants except
    for add_comm.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨å‡†å¤‡å¥½å¤„ç†ç¯äº†ã€‚ä¸ºäº†æ¼”ç¤ºç›®çš„ï¼Œæˆ‘ä»¬ä¸ä¼šå‡è®¾åŠ æ³•æ˜¯äº¤æ¢çš„ï¼Œç„¶åç«‹å³æä¾›ä¸€ä¸ª`AddCommGroupâ‚ƒ`çš„å®ä¾‹ã€‚Mathlibä¸ç©è¿™ç§æ¸¸æˆï¼Œé¦–å…ˆæ˜¯å› ä¸ºåœ¨å®é™…ä¸Šè¿™å¹¶ä¸ä¼šè®©ä»»ä½•ç¯å®ä¾‹æ›´å®¹æ˜“ï¼Œè€Œä¸”Mathlibçš„ä»£æ•°å±‚æ¬¡ç»“æ„é€šè¿‡åŠç¯ï¼Œè¿™äº›åŠç¯åƒç¯ä¸€æ ·ä½†æ²¡æœ‰ç›¸åæ•°ï¼Œæ‰€ä»¥ä¸‹é¢çš„è¯æ˜å¯¹å®ƒä»¬ä¸é€‚ç”¨ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œè·å¾—çš„å¥½å¤„ï¼Œé™¤äº†å¦‚æœä½ ä»æœªè§è¿‡å®ƒï¼Œæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ç»ƒä¹ ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªä½¿ç”¨å…è®¸æä¾›çˆ¶ç»“æ„ä½œä¸ºå®ä¾‹å‚æ•°ç„¶åæä¾›é¢å¤–å­—æ®µçš„è¯­æ³•çš„æ„å»ºå®ä¾‹çš„ä¾‹å­ã€‚è¿™é‡ŒRingâ‚ƒ
    Rå‚æ•°æä¾›äº†AddCommGroupâ‚ƒ Ræƒ³è¦çš„ä»»ä½•ä¸œè¥¿ï¼Œé™¤äº†add_commã€‚
- en: '[PRE153]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Of course we can also build concrete instances, such as a ring structure on
    integers (of course the instance below uses that all the work is already done
    in Mathlib).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æ„å»ºå…·ä½“çš„å®ä¾‹ï¼Œä¾‹å¦‚æ•´æ•°ä¸Šçš„ç¯ç»“æ„ï¼ˆå½“ç„¶ä¸‹é¢çš„å®ä¾‹ä½¿ç”¨çš„æ˜¯Mathlibä¸­æ‰€æœ‰çš„å·¥ä½œéƒ½å·²ç»å®Œæˆï¼‰ã€‚
- en: '[PRE154]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'As an exercise you can now set up a simple hierarchy for order relations, including
    a class for ordered commutative monoids, which have both a partial order and a
    commutative monoid structure such that `âˆ€ a b : Î±, a â‰¤ b â†’ âˆ€ c : Î±, c * a â‰¤ c
    * b`. Of course you need to add fields and maybe `extends` clauses to the following
    classes.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä½œä¸ºç»ƒä¹ ï¼Œä½ ç°åœ¨å¯ä»¥è®¾ç½®ä¸€ä¸ªç®€å•çš„å±‚æ¬¡ç»“æ„æ¥è¡¨ç¤ºé¡ºåºå…³ç³»ï¼ŒåŒ…æ‹¬ä¸€ä¸ªç”¨äºæœ‰åºäº¤æ¢å¹ºåŠç¾¤çš„ç±»ï¼Œå®ƒæ—¢æœ‰ååºç»“æ„ï¼Œä¹Ÿæœ‰äº¤æ¢å¹ºåŠç¾¤ç»“æ„ï¼Œä½¿å¾—`âˆ€ a b : Î±,
    a â‰¤ b â†’ âˆ€ c : Î±, c * a â‰¤ c * b`ã€‚å½“ç„¶ï¼Œä½ éœ€è¦ä¸ºä»¥ä¸‹ç±»æ·»åŠ å­—æ®µå’Œå¯èƒ½æ€§çš„`extends`å­å¥ã€‚'
- en: '[PRE155]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: We now want to discuss algebraic structures involving several types. The prime
    example is modules over rings. If you donâ€™t know what is a module, you can pretend
    it means vector space and think that all our rings are fields. Those structures
    are commutative additive groups equipped with a scalar multiplication by elements
    of some ring.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨æƒ³è®¨è®ºæ¶‰åŠå¤šä¸ªç±»å‹çš„ä»£æ•°ç»“æ„ã€‚ä¸€ä¸ªå…¸å‹çš„ä¾‹å­æ˜¯ç¯ä¸Šçš„æ¨¡å—ã€‚å¦‚æœä½ ä¸çŸ¥é“ä»€ä¹ˆæ˜¯æ¨¡å—ï¼Œä½ å¯ä»¥å‡è£…å®ƒæ„å‘³ç€å‘é‡ç©ºé—´ï¼Œå¹¶è®¤ä¸ºæˆ‘ä»¬æ‰€æœ‰çš„ç¯éƒ½æ˜¯åŸŸã€‚è¿™äº›ç»“æ„æ˜¯å¸¦æœ‰æŸäº›ç¯å…ƒç´ çš„æ ‡é‡ä¹˜æ³•çš„äº¤æ¢åŠ æ³•ç¾¤ã€‚
- en: We first define the data-carrying type class of scalar multiplication by some
    type `Î±` on some type `Î²`, and give it a right associative notation.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é¦–å…ˆå®šä¹‰ç”±ç±»å‹`Î±`åœ¨ç±»å‹`Î²`ä¸Šé€šè¿‡æŸç§ç±»å‹`Î±`è¿›è¡Œæ ‡é‡ä¹˜æ³•çš„æºå¸¦æ•°æ®çš„ç±»å‹ç±»ï¼Œå¹¶ç»™å®ƒä¸€ä¸ªå³ç»“åˆçš„ç¬¦å·ã€‚
- en: '[PRE156]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Then we can define modules (again think about vector spaces if you donâ€™t know
    what is a module).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰æ¨¡å—ï¼ˆå¦‚æœä½ ä¸çŸ¥é“ä»€ä¹ˆæ˜¯æ¨¡å—ï¼Œå†æƒ³æƒ³å‘é‡ç©ºé—´ï¼‰ã€‚
- en: '[PRE157]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'There is something interesting going on here. While it isnâ€™t too surprising
    that the ring structure on `R` is a parameter in this definition, you probably
    expected `AddCommGroupâ‚ƒ M` to be part of the `extends` clause just as `SMulâ‚ƒ R
    M` is. Trying to do that would lead to a mysterious sounding error message: `cannot
    find synthesization order for instance Moduleâ‚.toAddCommGroupâ‚ƒ with type (R :
    Type) â†’ [inst : Ringâ‚ƒ R] â†’ {M : Type} â†’ [self : Moduleâ‚ R M] â†’ AddCommGroupâ‚ƒ M
    all remaining arguments have metavariables: Ringâ‚ƒ ?R @Moduleâ‚ ?R ?instâœ M`. In
    order to understand this message, you need to remember that such an `extends`
    clause would lead to a field `Moduleâ‚ƒ.toAddCommGroupâ‚ƒ` marked as an instance.
    This instance would have the signature appearing in the error message: `(R : Type)
    â†’ [inst : Ringâ‚ƒ R] â†’ {M : Type} â†’ [self : Moduleâ‚ R M] â†’ AddCommGroupâ‚ƒ M`. With
    such an instance in the type class database, each time Lean would look for a `AddCommGroupâ‚ƒ
    M` instance for some `M`, it would need to go hunting for a completely unspecified
    type `R` and a `Ringâ‚ƒ R` instance before embarking on the main quest of finding
    a `Moduleâ‚ R M` instance. Those two side-quests are represented by the meta-variables
    mentioned in the error message and denoted by `?R` and `?instâœ` there. Such a
    `Moduleâ‚ƒ.toAddCommGroupâ‚ƒ` instance would then be a huge trap for the instance
    resolution procedure and then `class` command refuses to set it up.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™é‡Œæœ‰ä¸€äº›æœ‰è¶£çš„äº‹æƒ…æ­£åœ¨å‘ç”Ÿã€‚è™½ç„¶`R`ä¸Šçš„ç¯ç»“æ„åœ¨è¿™ä¸ªå®šä¹‰ä¸­ä½œä¸ºå‚æ•°å¹¶ä¸å¤ªä»¤äººæƒŠè®¶ï¼Œä½†ä½ å¯èƒ½é¢„è®¡`AddCommGroupâ‚ƒ M`å°†åƒ`SMulâ‚ƒ
    R M`ä¸€æ ·æˆä¸º`extends`å­å¥çš„ä¸€éƒ¨åˆ†ã€‚å°è¯•è¿™æ ·åšä¼šå¯¼è‡´ä¸€ä¸ªå¬èµ·æ¥å¾ˆç¥ç§˜çš„é”™è¯¯ä¿¡æ¯ï¼šâ€œæ— æ³•ä¸ºå®ä¾‹Moduleâ‚.toAddCommGroupâ‚ƒæ‰¾åˆ°åˆæˆé¡ºåºï¼Œç±»å‹ä¸º(R
    : Type) â†’ [inst : Ringâ‚ƒ R] â†’ {M : Type} â†’ [self : Moduleâ‚ R M] â†’ AddCommGroupâ‚ƒ
    Mï¼Œæ‰€æœ‰å‰©ä½™çš„å‚æ•°éƒ½æœ‰å…ƒå˜é‡ï¼šRingâ‚ƒ ?R @Moduleâ‚ ?R ?instâœ Mâ€ã€‚ä¸ºäº†ç†è§£è¿™æ¡ä¿¡æ¯ï¼Œä½ éœ€è¦è®°ä½ï¼Œè¿™æ ·çš„`extends`å­å¥ä¼šå¯¼è‡´ä¸€ä¸ªæ ‡è®°ä¸ºå®ä¾‹çš„å­—æ®µ`Moduleâ‚ƒ.toAddCommGroupâ‚ƒ`ã€‚è¿™ä¸ªå®ä¾‹å°†å…·æœ‰é”™è¯¯ä¿¡æ¯ä¸­å‡ºç°çš„ç­¾åï¼š`(R
    : Type) â†’ [inst : Ringâ‚ƒ R] â†’ {M : Type} â†’ [self : Moduleâ‚ R M] â†’ AddCommGroupâ‚ƒ
    M`ã€‚åœ¨ç±»å‹ç±»æ•°æ®åº“ä¸­ï¼Œæ¯æ¬¡Leanå¯»æ‰¾æŸä¸ª`M`çš„`AddCommGroupâ‚ƒ M`å®ä¾‹æ—¶ï¼Œå®ƒéƒ½éœ€è¦åœ¨å¼€å§‹å¯»æ‰¾`Moduleâ‚ R M`å®ä¾‹çš„ä¸»è¦ä»»åŠ¡ä¹‹å‰ï¼Œå»å¯»æ‰¾ä¸€ä¸ªå®Œå…¨æœªæŒ‡å®šçš„ç±»å‹`R`å’Œä¸€ä¸ª`Ringâ‚ƒ
    R`å®ä¾‹ã€‚è¿™ä¸¤ä¸ªè¾…åŠ©ä»»åŠ¡æ˜¯é”™è¯¯ä¿¡æ¯ä¸­æåˆ°çš„å…ƒå˜é‡æ‰€ä»£è¡¨çš„ï¼Œåˆ†åˆ«ç”¨`?R`å’Œ`?instâœ`è¡¨ç¤ºã€‚è¿™æ ·çš„`Moduleâ‚ƒ.toAddCommGroupâ‚ƒ`å®ä¾‹å°†æˆä¸ºå®ä¾‹è§£æè¿‡ç¨‹çš„ä¸€ä¸ªå·¨å¤§é™·é˜±ï¼Œç„¶å`class`å‘½ä»¤æ‹’ç»è®¾ç½®å®ƒã€‚'
- en: 'What about `extends SMulâ‚ƒ R M` then? That one creates a field `Moduleâ‚.toSMulâ‚ƒ
    : {R : Type} â†’Â  [inst : Ringâ‚ƒ R] â†’ {M : Type} â†’ [inst_1 : AddCommGroupâ‚ƒ M] â†’ [self
    : Moduleâ‚ R M] â†’ SMulâ‚ƒ R M` whose end result `SMulâ‚ƒ R M` mentions both `R` and
    `M` so this field can safely be used as an instance. The rule is easy to remember:
    each class appearing in the `extends` clause should mention every type appearing
    in the parameters.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 'é‚£ä¹ˆ`extends SMulâ‚ƒ R M`åˆæ˜¯æ€ä¹ˆå›äº‹å‘¢ï¼Ÿå®ƒåˆ›å»ºäº†ä¸€ä¸ªå­—æ®µ`Moduleâ‚.toSMulâ‚ƒ : {R : Type} â†’ [inst
    : Ringâ‚ƒ R] â†’ {M : Type} â†’ [inst_1 : AddCommGroupâ‚ƒ M] â†’ [self : Moduleâ‚ R M] â†’
    SMulâ‚ƒ R M`ï¼Œå…¶æœ€ç»ˆç»“æœ`SMulâ‚ƒ R M`æåˆ°äº†`R`å’Œ`M`ï¼Œå› æ­¤è¿™ä¸ªå­—æ®µå¯ä»¥å®‰å…¨åœ°ç”¨ä½œå®ä¾‹ã€‚è§„åˆ™å¾ˆå®¹æ˜“è®°ä½ï¼š`extends`å­å¥ä¸­å‡ºç°çš„æ¯ä¸ªç±»éƒ½åº”è¯¥æåˆ°å‚æ•°ä¸­å‡ºç°çš„æ¯ä¸ªç±»å‹ã€‚'
- en: 'Let us create our first module instance: a ring is a module over itself using
    its multiplication as a scalar multiplication.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åˆ›å»ºæˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªæ¨¡å—å®ä¾‹ï¼šä¸€ä¸ªç¯æ˜¯å…¶è‡ªèº«çš„æ¨¡å—ï¼Œä½¿ç”¨å…¶ä¹˜æ³•ä½œä¸ºæ ‡é‡ä¹˜æ³•ã€‚
- en: '[PRE158]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'As a second example, every abelian group is a module over `â„¤` (this is one
    of the reason to generalize the theory of vector spaces by allowing non-invertible
    scalars). First one can define scalar multiplication by a natural number for any
    type equipped with a zero and an addition: `n â€¢ a` is defined as `a + â‹¯ + a` where
    `a` appears `n` times. Then this is extended to scalar multiplication by an integer
    by ensuring `(-1) â€¢ a = -a`.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç¬¬äºŒä¸ªä¾‹å­ï¼Œæ¯ä¸ªé˜¿è´å°”ç¾¤éƒ½æ˜¯ `â„¤` ä¸Šçš„æ¨¡å—ï¼ˆè¿™æ˜¯é€šè¿‡å…è®¸éå¯é€†æ ‡é‡æ¥æ¨å¹¿å‘é‡ç©ºé—´ç†è®ºçš„åŸå› ä¹‹ä¸€ï¼‰ã€‚é¦–å…ˆï¼Œå¯ä»¥ä¸ºä»»ä½•å¸¦æœ‰é›¶å’ŒåŠ æ³•çš„ç±»å‹å®šä¹‰è‡ªç„¶æ•°çš„æ ‡é‡ä¹˜æ³•ï¼š`n
    â€¢ a` è¢«å®šä¹‰ä¸º `a + â‹¯ + a`ï¼Œå…¶ä¸­ `a` å‡ºç° `n` æ¬¡ã€‚ç„¶åï¼Œé€šè¿‡ç¡®ä¿ `(-1) â€¢ a = -a` æ¥å°†æ ‡é‡ä¹˜æ³•æ‰©å±•åˆ°æ•´æ•°ã€‚
- en: '[PRE159]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Proving this gives rise to a module structure is a bit tedious and not interesting
    for the current discussion, so we will sorry all axioms. You are *not* asked to
    replace those sorries with proofs. If you insist on doing it then you will probably
    want to state and prove several intermediate lemmas about `nsmulâ‚` and `zsmulâ‚`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: è¯æ˜è¿™ä¸€ç‚¹ä»¥äº§ç”Ÿä¸€ä¸ªæ¨¡å—ç»“æ„æœ‰ç‚¹ç¹çï¼Œå¹¶ä¸”å¯¹äºå½“å‰çš„è®¨è®ºæ¥è¯´å¹¶ä¸æœ‰è¶£ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†å¯¹æ‰€æœ‰å…¬ç†è¡¨ç¤ºæ­‰æ„ã€‚ä½ **ä¸**éœ€è¦ç”¨è¯æ˜æ¥æ›¿æ¢è¿™äº›æ­‰æ„ã€‚å¦‚æœä½ åšæŒè¿™æ ·åšï¼Œä½ å¯èƒ½éœ€è¦é™ˆè¿°å¹¶è¯æ˜å…³äº
    `nsmulâ‚` å’Œ `zsmulâ‚` çš„å‡ ä¸ªä¸­é—´å¼•ç†ã€‚
- en: '[PRE160]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'A much more important issue is that we now have two module structures over
    the ring `â„¤` for `â„¤` itself: `abGrpModule â„¤` since `â„¤` is a abelian group, and
    `selfModule â„¤` since `â„¤` is a ring. Those two module structure correspond to the
    same abelian group structure, but it is not obvious that they have the same scalar
    multiplication. They actually do, but this isnâ€™t true by definition, it requires
    a proof. This is very bad news for the type class instance resolution procedure
    and will lead to very frustrating failures for users of this hierarchy. When directly
    asked to find an instance, Lean will pick one, and we can see which one using:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ›´åŠ é‡è¦çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬ç°åœ¨åœ¨ç¯ `â„¤` ä¸Šå¯¹ `â„¤` æœ¬èº«æœ‰ä¸¤ä¸ªæ¨¡å—ç»“æ„ï¼š`abGrpModule â„¤`ï¼Œå› ä¸º `â„¤` æ˜¯ä¸€ä¸ªé˜¿è´å°”ç¾¤ï¼Œä»¥åŠ `selfModule
    â„¤`ï¼Œå› ä¸º `â„¤` æ˜¯ä¸€ä¸ªç¯ã€‚è¿™ä¸¤ä¸ªæ¨¡å—ç»“æ„å¯¹åº”äºç›¸åŒçš„é˜¿è´å°”ç¾¤ç»“æ„ï¼Œä½†å®ƒä»¬æ˜¯å¦å…·æœ‰ç›¸åŒçš„æ ‡é‡ä¹˜æ³•å¹¶ä¸æ˜æ˜¾ã€‚å®é™…ä¸Šï¼Œå®ƒä»¬ç¡®å®å¦‚æ­¤ï¼Œä½†è¿™å¹¶ä¸æ˜¯å®šä¹‰ä¸Šçš„ï¼Œéœ€è¦è¯æ˜ã€‚è¿™å¯¹ç±»å‹ç±»å®ä¾‹è§£æè¿‡ç¨‹æ¥è¯´æ˜¯ä¸ªåæ¶ˆæ¯ï¼Œå¹¶å°†å¯¼è‡´ç”¨æˆ·åœ¨ä½¿ç”¨è¿™ä¸ªå±‚æ¬¡ç»“æ„æ—¶é‡åˆ°éå¸¸ä»¤äººæ²®ä¸§çš„å¤±è´¥ã€‚å½“ç›´æ¥è¦æ±‚æ‰¾åˆ°ä¸€ä¸ªå®ä¾‹æ—¶ï¼ŒLean
    ä¼šé€‰æ‹©ä¸€ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼çœ‹åˆ°å®ƒï¼š
- en: '[PRE161]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: But in a more indirect context it can happen that Lean infers the other one
    and then gets confused. This situation is known as a bad diamond. This has nothing
    to do with the diamond operation we used above, it refers to the way one can draw
    the paths from `â„¤` to its `Moduleâ‚ â„¤` going through either `AddCommGroupâ‚ƒ â„¤` or
    `Ringâ‚ƒ â„¤`.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†åœ¨æ›´é—´æ¥çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œå¯èƒ½ä¼šå‘ç”Ÿ Lean æ¨æ–­å‡ºå¦ä¸€ä¸ªï¼Œç„¶åå˜å¾—å›°æƒ‘çš„æƒ…å†µã€‚è¿™ç§æƒ…å†µè¢«ç§°ä¸ºâ€œåé’»çŸ³â€ã€‚è¿™ä¸æˆ‘ä»¬ä¸Šé¢ä½¿ç”¨çš„é’»çŸ³æ“ä½œæ— å…³ï¼Œå®ƒæŒ‡çš„æ˜¯ä» `â„¤`
    åˆ°å…¶ `Moduleâ‚ â„¤` çš„è·¯å¾„ï¼Œå¯ä»¥é€šè¿‡ `AddCommGroupâ‚ƒ â„¤` æˆ– `Ringâ‚ƒ â„¤` æ¥ç»˜åˆ¶ã€‚
- en: It is important to understand that not all diamonds are bad. In fact there are
    diamonds everywhere in Mathlib, and also in this chapter. Already at the very
    beginning we saw one can go from `Monoidâ‚ Î±` to `Diaâ‚ Î±` through either `Semigroupâ‚
    Î±` or `DiaOneClassâ‚ Î±` and thanks to the work done by the `class` command, the
    resulting two `Diaâ‚ Î±` instances are definitionally equal. In particular a diamond
    having a `Prop`-valued class at the bottom cannot be bad since any two proofs
    of the same statement are definitionally equal.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: é‡è¦çš„æ˜¯è¦ç†è§£å¹¶éæ‰€æœ‰é’»çŸ³éƒ½æ˜¯åçš„ã€‚äº‹å®ä¸Šï¼Œåœ¨ Mathlib ä¸­åˆ°å¤„éƒ½æœ‰é’»çŸ³ï¼Œåœ¨æœ¬ç« ä¸­ä¹Ÿæ˜¯å¦‚æ­¤ã€‚åœ¨éå¸¸å¼€å§‹çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±çœ‹åˆ°äº†å¯ä»¥ä» `Monoidâ‚
    Î±` é€šè¿‡ `Semigroupâ‚ Î±` æˆ– `DiaOneClassâ‚ Î±` åˆ° `Diaâ‚ Î±` çš„è½¬æ¢ï¼Œå¹¶ä¸”ç”±äº `class` å‘½ä»¤çš„å·¥ä½œï¼Œå¾—åˆ°çš„ä¸¤ä¸ª
    `Diaâ‚ Î±` å®ä¾‹åœ¨å®šä¹‰ä¸Šæ˜¯ç›¸ç­‰çš„ã€‚ç‰¹åˆ«æ˜¯ï¼Œåº•éƒ¨æœ‰ `Prop` å€¼ç±»çš„é’»çŸ³ä¸èƒ½æ˜¯åçš„ï¼Œå› ä¸ºä»»ä½•ä¸¤ä¸ªç›¸åŒé™ˆè¿°çš„è¯æ˜åœ¨å®šä¹‰ä¸Šæ˜¯ç›¸ç­‰çš„ã€‚
- en: But the diamond we created with modules is definitely bad. The offending piece
    is the `smul` field which is data, not a proof, and we have two constructions
    that are not definitionally equal. The robust way of fixing this issue is to make
    sure that going from a rich structure to a poor structure is always done by forgetting
    data, not by defining data. This well-known pattern has been named â€œforgetful
    inheritanceâ€ and extensively discussed in [https://inria.hal.science/hal-02463336v2](https://inria.hal.science/hal-02463336v2).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æˆ‘ä»¬ç”¨æ¨¡å—åˆ›å»ºçš„é’»çŸ³è‚¯å®šæ˜¯ä¸å¥½çš„ã€‚é—®é¢˜åœ¨äº `smul` å­—æ®µï¼Œå®ƒæ˜¯æ•°æ®ï¼Œè€Œä¸æ˜¯è¯æ˜ï¼Œå¹¶ä¸”æˆ‘ä»¬æœ‰ä¸¤ç§ä¸æ˜¯å®šä¹‰ä¸Šç›¸ç­‰çš„æ„é€ ã€‚ä¿®å¤è¿™ä¸ªé—®é¢˜çš„ç¨³å¥æ–¹æ³•æ˜¯ç¡®ä¿ä»ä¸°å¯Œç»“æ„åˆ°è´«å¼±ç»“æ„çš„è½¬æ¢æ€»æ˜¯é€šè¿‡å¿˜è®°æ•°æ®æ¥å®Œæˆï¼Œè€Œä¸æ˜¯é€šè¿‡å®šä¹‰æ•°æ®ã€‚è¿™ä¸ªä¼—æ‰€å‘¨çŸ¥çš„æ¨¡å¼è¢«å‘½åä¸ºâ€œé—å¿˜ç»§æ‰¿â€ï¼Œå¹¶åœ¨
    [https://inria.hal.science/hal-02463336v2](https://inria.hal.science/hal-02463336v2)
    ä¸­å¹¿æ³›è®¨è®ºã€‚
- en: In our concrete case, we can modify the definition of `AddMonoidâ‚ƒ` to include
    a `nsmul` data field and some `Prop`-valued fields ensuring this operation is
    provably the one we constructed above. Those fields are given default values using
    `:=` after their type in the definition below. Thanks to these default values,
    most instances would be constructed exactly as with our previous definitions.
    But in the special case of `â„¤` we will be able to provide specific values.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬çš„å…·ä½“æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ä¿®æ”¹`AddMonoidâ‚ƒ`çš„å®šä¹‰ï¼ŒåŒ…æ‹¬ä¸€ä¸ª`nsmul`æ•°æ®å­—æ®µå’Œä¸€äº›`Prop`ç±»å‹çš„å­—æ®µï¼Œä»¥ç¡®ä¿è¿™ä¸ªæ“ä½œæ˜¯å¯è¯æ˜çš„ï¼Œä¸æˆ‘ä»¬ä¸Šé¢æ„é€ çš„æ˜¯åŒä¸€ä¸ªã€‚è¿™äº›å­—æ®µåœ¨ä¸‹é¢çš„å®šä¹‰ä¸­ä½¿ç”¨`:=`åœ¨å®ƒä»¬çš„ç±»å‹åé¢èµ‹äºˆé»˜è®¤å€¼ã€‚å¤šäºäº†è¿™äº›é»˜è®¤å€¼ï¼Œå¤§å¤šæ•°å®ä¾‹å°†ä¸æˆ‘ä»¬ä¹‹å‰çš„å®šä¹‰å®Œå…¨ä¸€æ ·æ„å»ºã€‚ä½†åœ¨`â„¤`çš„ç‰¹æ®Šæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†èƒ½å¤Ÿæä¾›ç‰¹å®šçš„å€¼ã€‚
- en: '[PRE162]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Let us check we can still construct a product monoid instance without providing
    the `nsmul` related fields.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦ä»ç„¶å¯ä»¥æ„å»ºä¸€ä¸ªä¹˜ç§¯å¹ºåŠç¾¤å®ä¾‹ï¼Œè€Œä¸æä¾›`nsmul`ç›¸å…³å­—æ®µã€‚
- en: '[PRE163]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: And now let us handle the special case of `â„¤` where we want to build `nsmul`
    using the coercion of `â„•` to `â„¤` and the multiplication on `â„¤`. Note in particular
    how the proof fields contain more work than in the default value above.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬å¤„ç†`â„¤`çš„ç‰¹æ®Šæƒ…å†µï¼Œæˆ‘ä»¬æƒ³è¦ä½¿ç”¨`â„•`åˆ°`â„¤`çš„å¼ºåˆ¶è½¬æ¢å’Œ`â„¤`ä¸Šçš„ä¹˜æ³•æ¥æ„å»º`nsmul`ã€‚ç‰¹åˆ«æ³¨æ„çš„æ˜¯ï¼Œè¯æ˜å­—æ®µæ¯”ä¸Šé¢çš„é»˜è®¤å€¼åŒ…å«æ›´å¤šçš„å·¥ä½œã€‚
- en: '[PRE164]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Let us check we solved our issue. Because Lean already has a definition of scalar
    multiplication of a natural number and an integer, and we want to make sure our
    instance is used, we wonâ€™t use the `â€¢` notation but call `SMul.mul` and explicitly
    provide our instance defined above.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦è§£å†³äº†æˆ‘ä»¬çš„é—®é¢˜ã€‚å› ä¸ºLeanå·²ç»æœ‰ä¸€ä¸ªè‡ªç„¶æ•°å’Œæ•´æ•°æ ‡é‡ä¹˜æ³•çš„å®šä¹‰ï¼Œæˆ‘ä»¬æƒ³è¦ç¡®ä¿æˆ‘ä»¬çš„å®ä¾‹è¢«ä½¿ç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸ä¼šä½¿ç”¨`â€¢`ç¬¦å·ï¼Œè€Œæ˜¯è°ƒç”¨`SMul.mul`å¹¶æ˜ç¡®æä¾›æˆ‘ä»¬ä¸Šé¢å®šä¹‰çš„å®ä¾‹ã€‚
- en: '[PRE165]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: This story then continues with incorporating a `zsmul` field into the definition
    of groups and similar tricks. You are now ready to read the definition of monoids,
    groups, rings and modules in Mathlib. There are more complicated than what we
    have seen here, because they are part of a huge hierarchy, but all principles
    have been explained above.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªæ•…äº‹ç»§ç»­é€šè¿‡å°†`zsmul`å­—æ®µçº³å…¥ç¾¤çš„å®šä¹‰ä¸­ï¼Œå¹¶ä½¿ç”¨ç±»ä¼¼çš„æŠ€å·§ã€‚ä½ ç°åœ¨å¯ä»¥é˜…è¯»Mathlibä¸­å•ç¾¤ã€ç¾¤ã€ç¯å’Œæ¨¡å—çš„å®šä¹‰äº†ã€‚å®ƒä»¬æ¯”æˆ‘ä»¬è¿™é‡Œçœ‹åˆ°çš„æ›´å¤æ‚ï¼Œå› ä¸ºå®ƒä»¬æ˜¯å·¨å¤§å±‚æ¬¡ç»“æ„çš„ä¸€éƒ¨åˆ†ï¼Œä½†æ‰€æœ‰åŸåˆ™éƒ½å·²ç»åœ¨ä¸Šé¢è§£é‡Šè¿‡äº†ã€‚
- en: As an exercise, you can come back to the order relation hierarchy you built
    above and try to incorporate a type class `LTâ‚` carrying the Less-Than notation
    `<â‚` and make sure that every preorder comes with a `<â‚` which has a default value
    built from `â‰¤â‚` and a `Prop`-valued field asserting the natural relation between
    those two comparison operators.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç»ƒä¹ ï¼Œä½ å¯ä»¥å›åˆ°ä½ ä¸Šé¢æ„å»ºçš„é¡ºåºå…³ç³»å±‚æ¬¡ï¼Œå°è¯•ç»“åˆä¸€ä¸ªæºå¸¦å°äºç¬¦å·`<â‚`çš„ç±»å‹ç±»`LTâ‚`ï¼Œå¹¶ç¡®ä¿æ¯ä¸ªååºéƒ½å¸¦æœ‰`<â‚`ï¼Œå®ƒæœ‰ä¸€ä¸ªä»`â‰¤â‚`æ„å»ºçš„é»˜è®¤å€¼ï¼Œä»¥åŠä¸€ä¸ª`Prop`ç±»å‹çš„å­—æ®µï¼Œæ–­è¨€è¿™ä¸¤ä¸ªæ¯”è¾ƒè¿ç®—ç¬¦ä¹‹é—´çš„è‡ªç„¶å…³ç³»ã€‚
- en: '## 8.2\. Morphisms[ïƒ](#morphisms "Link to this heading")'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '## 8.2. æ‘©å°”å‹[ïƒ](#morphisms "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")'
- en: So far in this chapter, we discussed how to create a hierarchy of mathematical
    structures. But defining structures is not really completed until we have morphisms.
    There are two main approaches here. The most obvious one is to define a predicate
    on functions.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œåœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬è®¨è®ºäº†å¦‚ä½•åˆ›å»ºæ•°å­¦ç»“æ„çš„å±‚æ¬¡ã€‚ä½†å®šä¹‰ç»“æ„å¹¶ä¸æ˜¯çœŸæ­£å®Œæˆï¼Œç›´åˆ°æˆ‘ä»¬æœ‰æ‘©å°”å‹ã€‚è¿™é‡Œæœ‰ä¸¤ç§ä¸»è¦çš„æ–¹æ³•ã€‚æœ€æ˜æ˜¾çš„ä¸€ä¸ªæ˜¯å®šä¹‰ä¸€ä¸ªå…³äºå‡½æ•°çš„è°“è¯ã€‚
- en: '[PRE166]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: In this definition, it is a bit unpleasant to use a conjunction. In particular
    users will need to remember the ordering we chose when they want to access the
    two conditions. So we could use a structure instead.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªå®šä¹‰ä¸­ï¼Œä½¿ç”¨åˆå–æœ‰ç‚¹ä¸æ„‰å¿«ã€‚ç‰¹åˆ«æ˜¯å½“ç”¨æˆ·æƒ³è¦è®¿é—®ä¸¤ä¸ªæ¡ä»¶æ—¶ï¼Œä»–ä»¬éœ€è¦è®°ä½æˆ‘ä»¬é€‰æ‹©çš„æ’åºã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªç»“æ„ã€‚
- en: '[PRE167]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Once we are here, it is even tempting to make it a class and use the type class
    instance resolution procedure to automatically infer `isMonoidHomâ‚‚` for complicated
    functions out of instances for simpler functions. For instance a composition of
    monoid morphisms is a monoid morphism and this seems like a useful instance. However
    such an instance would be very tricky for the resolution procedure since it would
    need to hunt down `g âˆ˜ f` everywhere. Seeing it failing in `g (f x)` would be
    very frustrating. More generally one must always keep in mind that recognizing
    which function is applied in a given expression is a very difficult problem, called
    the â€œhigher-order unification problemâ€. So Mathlib does not use this class approach.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬åˆ°äº†è¿™é‡Œï¼Œç”šè‡³æœ‰å°†å…¶åšæˆä¸€ä¸ªç±»å¹¶ä½¿ç”¨ç±»å‹ç±»å®ä¾‹è§£æè¿‡ç¨‹è‡ªåŠ¨æ¨æ–­å‡ºå¤æ‚å‡½æ•°çš„`isMonoidHomâ‚‚`çš„è¯±æƒ‘ã€‚ä¾‹å¦‚ï¼Œå¹ºåŠç¾¤åŒæ€çš„å¤åˆæ˜¯ä¸€ä¸ªå¹ºåŠç¾¤åŒæ€ï¼Œè¿™ä¼¼ä¹æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„å®ä¾‹ã€‚ç„¶è€Œï¼Œè¿™æ ·çš„å®ä¾‹å¯¹äºè§£æè¿‡ç¨‹æ¥è¯´ä¼šéå¸¸æ£˜æ‰‹ï¼Œå› ä¸ºå®ƒéœ€è¦åˆ°å¤„å¯»æ‰¾`g
    âˆ˜ f`ã€‚åœ¨`g (f x)`ä¸­çœ‹åˆ°å®ƒå¤±è´¥ä¼šéå¸¸æ²®ä¸§ã€‚æ›´æ™®éåœ°è¯´ï¼Œæˆ‘ä»¬å¿…é¡»å§‹ç»ˆè®°ä½ï¼Œè¯†åˆ«ç»™å®šè¡¨è¾¾å¼ä¸­åº”ç”¨äº†å“ªä¸ªå‡½æ•°æ˜¯ä¸€ä¸ªéå¸¸å›°éš¾çš„é—®é¢˜ï¼Œç§°ä¸ºâ€œé«˜é˜¶ç»Ÿä¸€é—®é¢˜â€ã€‚å› æ­¤ï¼ŒMathlibä¸ä½¿ç”¨è¿™ç§ç±»æ–¹æ³•ã€‚
- en: 'A more fundamental question is whether we use predicates as above (using either
    a `def` or a `structure`) or use structures bundling a function and predicates.
    This is partly a psychological issue. It is extremely rare to consider a function
    between monoids that is not a morphism. It really feels like â€œmonoid morphismâ€
    is not an adjective you can assign to a bare function, it is a noun. On the other
    hand one can argue that a continuous function between topological spaces is really
    a function that happens to be continuous. This is one reason why Mathlib has a
    `Continuous` predicate. For instance you can write:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ›´åŸºæœ¬çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬æ˜¯å¦ä½¿ç”¨ä¸Šè¿°è°“è¯ï¼ˆä½¿ç”¨`def`æˆ–`structure`ï¼‰æˆ–è€…ä½¿ç”¨æ†ç»‘å‡½æ•°å’Œè°“è¯çš„ç»“æ„ã€‚è¿™éƒ¨åˆ†æ˜¯ä¸€ä¸ªå¿ƒç†é—®é¢˜ã€‚è€ƒè™‘ä¸€ä¸ªä¸æ˜¯åŒæ€çš„å¹ºåŠç¾¤ä¹‹é—´çš„å‡½æ•°æ˜¯éå¸¸ç½•è§çš„ã€‚è¿™çœŸçš„æ„Ÿè§‰åƒâ€œå¹ºåŠç¾¤åŒæ€â€ä¸æ˜¯ä¸€ä¸ªä½ å¯ä»¥èµ‹äºˆä¸€ä¸ªè£¸å‡½æ•°çš„å½¢å®¹è¯ï¼Œå®ƒæ˜¯ä¸€ä¸ªåè¯ã€‚å¦ä¸€æ–¹é¢ï¼Œæœ‰äººå¯ä»¥äº‰è¾©è¯´ï¼Œæ‹“æ‰‘ç©ºé—´ä¹‹é—´çš„è¿ç»­å‡½æ•°å®é™…ä¸Šæ˜¯ä¸€ä¸ªæ°å¥½æ˜¯è¿ç»­çš„å‡½æ•°ã€‚è¿™æ˜¯Mathlibæœ‰`Continuous`è°“è¯çš„ä¸€ä¸ªåŸå› ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥å†™ï¼š
- en: '[PRE168]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: We still have bundles of continuous functions, which are convenient for instance
    to put a topology on a space of continuous functions, but they are not the primary
    tool to work with continuity.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä»ç„¶æœ‰è¿ç»­å‡½æ•°çš„æ†ç»‘ï¼Œè¿™åœ¨ä¾‹å¦‚ç»™è¿ç»­å‡½æ•°çš„ç©ºé—´èµ‹äºˆæ‹“æ‰‘æ—¶å¾ˆæ–¹ä¾¿ï¼Œä½†å®ƒä»¬ä¸æ˜¯å¤„ç†è¿ç»­æ€§çš„ä¸»è¦å·¥å…·ã€‚
- en: 'By contrast, morphisms between monoids (or other algebraic structures) are
    bundled as in:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸æ¯”ä¹‹ä¸‹ï¼Œå¹ºåŠç¾¤ï¼ˆæˆ–å…¶ä»–ä»£æ•°ç»“æ„ï¼‰ä¹‹é—´çš„åŒæ€æ†ç»‘å¦‚ä¸‹ï¼š
- en: '[PRE169]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Of course we donâ€™t want to type `toFun` everywhere so we register a coercion
    using the `CoeFun` type class. Its first argument is the type we want to coerce
    to a function. The second argument describes the target function type. In our
    case it is always `G â†’ H` for every `f : MonoidHomâ‚ G H`. We also tag `MonoidHomâ‚.toFun`
    with the `coe` attribute to make sure it is displayed almost invisibly in the
    tactic state, simply by a `â†‘` prefix.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 'å½“ç„¶ï¼Œæˆ‘ä»¬ä¸æƒ³åœ¨æ‰€æœ‰åœ°æ–¹éƒ½è¾“å…¥`toFun`ï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨`CoeFun`ç±»å‹ç±»æ³¨å†Œäº†ä¸€ä¸ªå¼ºåˆ¶è½¬æ¢ã€‚å®ƒçš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯æˆ‘ä»¬æƒ³è¦å¼ºåˆ¶è½¬æ¢ä¸ºå‡½æ•°çš„ç±»å‹ã€‚ç¬¬äºŒä¸ªå‚æ•°æè¿°äº†ç›®æ ‡å‡½æ•°ç±»å‹ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œå¯¹äºæ¯ä¸ª`f
    : MonoidHomâ‚ G H`ï¼Œå®ƒæ€»æ˜¯`G â†’ H`ã€‚æˆ‘ä»¬è¿˜ä½¿ç”¨`coe`å±æ€§æ ‡è®°`MonoidHomâ‚.toFun`ï¼Œä»¥ç¡®ä¿å®ƒåœ¨æˆ˜æœ¯çŠ¶æ€ä¸­å‡ ä¹ä¸å¯è§ï¼Œåªéœ€ä¸€ä¸ª`â†‘`å‰ç¼€å³å¯ã€‚'
- en: '[PRE170]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Let us check we can indeed apply a bundled monoid morphism to an element.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦çœŸçš„å¯ä»¥å°†ä¸€ä¸ªæ†ç»‘çš„å¹ºåŠç¾¤åŒæ€åº”ç”¨äºä¸€ä¸ªå…ƒç´ ã€‚
- en: '[PRE171]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: We can do the same with other kind of morphisms until we reach ring morphisms.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ç”¨åŒæ ·çš„æ–¹æ³•å¤„ç†å…¶ä»–ç±»å‹çš„åŒæ€ï¼Œç›´åˆ°æˆ‘ä»¬è¾¾åˆ°ç¯åŒæ€ã€‚
- en: '[PRE172]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: There are a couple of issues about this approach. A minor one is we donâ€™t quite
    know where to put the `coe` attribute since the `RingHomâ‚.toFun` does not exist,
    the relevant function is `MonoidHomâ‚.toFun âˆ˜ RingHomâ‚.toMonoidHomâ‚` which is not
    a declaration that can be tagged with an attribute (but we could still define
    a `CoeFunÂ  (RingHomâ‚ R S) (fun _ â†¦ R â†’ S)` instance). A much more important one
    is that lemmas about monoid morphisms wonâ€™t directly apply to ring morphisms.
    This leaves the alternative of either juggling with `RingHomâ‚.toMonoidHomâ‚` each
    time we want to apply a monoid morphism lemma or restate every such lemmas for
    ring morphisms. Neither option is appealing so Mathlib uses a new hierarchy trick
    here. The idea is to define a type class for objects that are at least monoid
    morphisms, instantiate that class with both monoid morphisms and ring morphisms
    and use it to state every lemma. In the definition below, `F` could be `MonoidHomâ‚
    M N`, or `RingHomâ‚ M N` if `M` and `N` have a ring structure.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§æ–¹æ³•æœ‰å‡ ä¸ªé—®é¢˜ã€‚ä¸€ä¸ªè¾ƒå°çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬ä¸çŸ¥é“åœ¨å“ªé‡Œæ”¾ç½® `coe` å±æ€§ï¼Œå› ä¸º `RingHomâ‚.toFun` ä¸å­˜åœ¨ï¼Œç›¸å…³çš„å‡½æ•°æ˜¯ `MonoidHomâ‚.toFun
    âˆ˜ RingHomâ‚.toMonoidHomâ‚`ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªå¯ä»¥æ ‡è®°å±æ€§çš„å£°æ˜ï¼ˆä½†æˆ‘ä»¬ä»ç„¶å¯ä»¥å®šä¹‰ä¸€ä¸ª `CoeFun (RingHomâ‚ R S) (fun
    _ â†¦ R â†’ S)` å®ä¾‹ï¼‰ã€‚ä¸€ä¸ªæ›´é‡è¦çš„ä¸€ä¸ªæ˜¯ï¼Œå…³äºä»£æ•°åŒæ€çš„å¼•ç†ä¸ä¼šç›´æ¥é€‚ç”¨äºç¯åŒæ€ã€‚è¿™ç•™ä¸‹äº†ä¸¤ç§é€‰æ‹©ï¼šæ¯æ¬¡æƒ³è¦åº”ç”¨ä»£æ•°åŒæ€å¼•ç†æ—¶éƒ½ç©å¼„ `RingHomâ‚.toMonoidHomâ‚`ï¼Œæˆ–è€…ä¸ºç¯åŒæ€é‡æ–°é™ˆè¿°æ¯ä¸ªè¿™æ ·çš„å¼•ç†ã€‚è¿™ä¸¤ç§é€‰æ‹©éƒ½ä¸å¸å¼•äººï¼Œå› æ­¤
    Mathlib åœ¨è¿™é‡Œä½¿ç”¨äº†ä¸€ä¸ªæ–°çš„å±‚æ¬¡ç»“æ„æŠ€å·§ã€‚æƒ³æ³•æ˜¯ä¸ºè‡³å°‘æ˜¯ä»£æ•°åŒæ€çš„å¯¹è±¡å®šä¹‰ä¸€ä¸ªç±»å‹ç±»ï¼Œç”¨ä»£æ•°åŒæ€å’Œç¯åŒæ€å®ä¾‹åŒ–è¿™ä¸ªç±»ï¼Œå¹¶ä½¿ç”¨å®ƒæ¥é™ˆè¿°æ¯ä¸ªå¼•ç†ã€‚åœ¨ä¸‹é¢çš„å®šä¹‰ä¸­ï¼Œ`F`
    å¯ä»¥æ˜¯ `MonoidHomâ‚ M N`ï¼Œæˆ–è€…å¦‚æœ `M` å’Œ `N` æœ‰ç¯ç»“æ„ï¼Œåˆ™æ˜¯ `RingHomâ‚ M N`ã€‚
- en: '[PRE173]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: However there is a problem with the above implementation. We havenâ€™t registered
    a coercion to function instance yet. Let us try to do it now.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œä¸Šè¿°å®ç°å­˜åœ¨ä¸€ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬è¿˜æ²¡æœ‰æ³¨å†Œä¸€ä¸ªå¼ºåˆ¶è½¬æ¢ä¸ºå‡½æ•°å®ä¾‹ã€‚ç°åœ¨è®©æˆ‘ä»¬å°è¯•ä¸€ä¸‹ã€‚
- en: '[PRE174]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Making this an instance would be bad. When faced with something like `f x`
    where the type of `f` is not a function type, Lean will try to find a `CoeFun`
    instance to coerce `f` into a function. The above function has type: `{M N F :
    Type} â†’ [Monoid M] â†’ [Monoid N] â†’ [MonoidHomClassâ‚ F M N] â†’ CoeFun F (fun x â†¦
    M â†’ N)` so, when it trying to apply it, it wouldnâ€™t be a priori clear to Lean
    in which order the unknown types `M`, `N` and `F` should be inferred. This is
    a kind of bad instance that is slightly different from the one we saw already,
    but it boils down to the same issue: without knowing `M`, Lean would have to search
    for a monoid instance on an unknown type, hence hopelessly try *every* monoid
    instance in the database. If you are curious to see the effect of such an instance
    you can type `set_option synthInstance.checkSynthOrder false in` on top of the
    above declaration, replace `def badInst` with `instance`, and look for random
    failures in this file.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 'å°†å…¶ä½œä¸ºä¸€ä¸ªå®ä¾‹ä¼šä¸å¥½ã€‚å½“é¢å¯¹ç±»ä¼¼ `f x` è¿™æ ·çš„æƒ…å†µï¼Œå…¶ä¸­ `f` çš„ç±»å‹ä¸æ˜¯å‡½æ•°ç±»å‹æ—¶ï¼ŒLean å°†å°è¯•æ‰¾åˆ°ä¸€ä¸ª `CoeFun` å®ä¾‹æ¥å°†
    `f` è½¬æ¢ä¸ºå‡½æ•°ã€‚ä¸Šè¿°å‡½æ•°çš„ç±»å‹æ˜¯ï¼š`{M N F : Type} â†’ [Monoid M] â†’ [Monoid N] â†’ [MonoidHomClassâ‚
    F M N] â†’ CoeFun F (fun x â†¦ M â†’ N)`ï¼Œå› æ­¤ï¼Œå½“å®ƒå°è¯•åº”ç”¨å®ƒæ—¶ï¼ŒLean å¹¶ä¸æ¸…æ¥šæœªçŸ¥ç±»å‹ `M`ã€`N` å’Œ `F` åº”è¯¥ä»¥ä½•ç§é¡ºåºè¿›è¡Œæ¨æ–­ã€‚è¿™æ˜¯ä¸€ç§ä¸ä¹‹å‰æ‰€è§ç•¥æœ‰ä¸åŒä½†æœ¬è´¨ä¸Šç›¸åŒçš„é—®é¢˜ï¼šä¸çŸ¥é“
    `M` æ—¶ï¼ŒLean å°†ä¸å¾—ä¸åœ¨æœªçŸ¥ç±»å‹ä¸Šæœç´¢ä¸€ä¸ªä»£æ•°å®ä¾‹ï¼Œå› æ­¤ä¼šæ— æœ›åœ°å°è¯•æ•°æ®åº“ä¸­çš„ *æ¯ä¸€ä¸ª* ä»£æ•°å®ä¾‹ã€‚å¦‚æœä½ å¯¹è¿™ç§å®ä¾‹çš„æ•ˆæœæ„Ÿåˆ°å¥½å¥‡ï¼Œå¯ä»¥åœ¨ä¸Šè¿°å£°æ˜ä¸Šæ–¹è¾“å…¥
    `set_option synthInstance.checkSynthOrder false in`ï¼Œå°† `def badInst` æ›¿æ¢ä¸º `instance`ï¼Œå¹¶åœ¨æ­¤æ–‡ä»¶ä¸­æŸ¥æ‰¾éšæœºå¤±è´¥ã€‚'
- en: 'Here the solution is easy, we need to tell Lean to first search what is `F`
    and then deduce `M` and `N`. This is done using the `outParam` function. This
    function is defined as the identity function, but is still recognized by the type
    class machinery and triggers the desired behavior. Hence we can retry defining
    our class, paying attention to the `outParam` function:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œè§£å†³æ–¹æ¡ˆå¾ˆç®€å•ï¼Œæˆ‘ä»¬éœ€è¦å‘Šè¯‰ Lean é¦–å…ˆæœç´¢ `F` æ˜¯ä»€ä¹ˆï¼Œç„¶åæ¨æ–­ `M` å’Œ `N`ã€‚è¿™æ˜¯é€šè¿‡ä½¿ç”¨ `outParam` å‡½æ•°å®ç°çš„ã€‚è¿™ä¸ªå‡½æ•°å®šä¹‰ä¸ºæ’ç­‰å‡½æ•°ï¼Œä½†ä»ç„¶è¢«ç±»å‹ç±»æœºåˆ¶è¯†åˆ«å¹¶è§¦å‘æ‰€éœ€çš„è¡Œä¸ºã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥é‡æ–°å®šä¹‰æˆ‘ä»¬çš„ç±»ï¼Œæ³¨æ„ä½¿ç”¨
    `outParam` å‡½æ•°ï¼š
- en: '[PRE175]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Now we can proceed with our plan to instantiate this class.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ç»§ç»­æˆ‘ä»¬çš„è®¡åˆ’æ¥å®ä¾‹åŒ–è¿™ä¸ªç±»ã€‚
- en: '[PRE176]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'As promised every lemma we prove about `f : F` assuming an instance of `MonoidHomClassâ‚
    F` will apply both to monoid morphisms and ring morphisms. Let us see an example
    lemma and check it applies to both situations.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¦‚æ‰¿è¯ºçš„é‚£æ ·ï¼Œæˆ‘ä»¬å…³äº `f : F` çš„æ¯ä¸ªå¼•ç†ï¼Œå‡è®¾ `MonoidHomClassâ‚ F` çš„ä¸€ä¸ªå®ä¾‹ï¼Œéƒ½å°†é€‚ç”¨äºä»£æ•°åŒæ€å’Œç¯åŒæ€ã€‚è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªç¤ºä¾‹å¼•ç†å¹¶æ£€æŸ¥å®ƒæ˜¯å¦é€‚ç”¨äºè¿™ä¸¤ç§æƒ…å†µã€‚'
- en: '[PRE177]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: At first sight, it may look like we got back to our old bad idea of making `MonoidHomâ‚`
    a class. But we havenâ€™t. Everything is shifted one level of abstraction up. The
    type class resolution procedure wonâ€™t be looking for functions, it will be looking
    for either `MonoidHomâ‚` or `RingHomâ‚`.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: åˆçœ‹èµ·æ¥ï¼Œå¯èƒ½çœ‹èµ·æ¥æˆ‘ä»¬å›åˆ°äº†æˆ‘ä»¬ä»¥å‰çš„è€åä¸»æ„ï¼Œå°†`MonoidHomâ‚`åšæˆä¸€ä¸ªç±»ã€‚ä½†æˆ‘ä»¬å¹¶æ²¡æœ‰ã€‚ä¸€åˆ‡éƒ½è¢«æå‡äº†ä¸€ä¸ªæŠ½è±¡å±‚æ¬¡ã€‚ç±»å‹ç±»è§£æè¿‡ç¨‹ä¸ä¼šå¯»æ‰¾å‡½æ•°ï¼Œå®ƒå°†å¯»æ‰¾`MonoidHomâ‚`æˆ–`RingHomâ‚`ã€‚
- en: One remaining issue with our approach is the presence of repetitive code around
    the `toFun` field and the corresponding `CoeFun` instance and `coe` attribute.
    It would also be better to record that this pattern is used only for functions
    with extra properties, meaning that the coercion to functions should be injective.
    So Mathlib adds one more layer of abstraction with the base class `DFunLike` (where
    â€œDFunâ€ stands for dependent function). Let us redefine our `MonoidHomClass` on
    top of this base layer.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„æ–¹æ³•ä¸­å­˜åœ¨çš„ä¸€ä¸ªé—®é¢˜æ˜¯å›´ç»•`toFun`å­—æ®µåŠå…¶å¯¹åº”çš„`CoeFun`å®ä¾‹å’Œ`coe`å±æ€§å‘¨å›´çš„é‡å¤ä»£ç ã€‚æœ€å¥½ä¹Ÿè®°å½•ä¸‹è¿™ç§æ¨¡å¼ä»…ç”¨äºå…·æœ‰é¢å¤–å±æ€§çš„åŠŸèƒ½ï¼Œè¿™æ„å‘³ç€å‡½æ•°åˆ°å‡½æ•°çš„å¼ºåˆ¶è½¬æ¢åº”è¯¥æ˜¯å•å°„çš„ã€‚å› æ­¤ï¼ŒMathlibé€šè¿‡æ·»åŠ ä¸€ä¸ªåŸºäºç±»`DFunLike`ï¼ˆå…¶ä¸­â€œDFunâ€ä»£è¡¨ä¾èµ–å‡½æ•°ï¼‰çš„é¢å¤–æŠ½è±¡å±‚ã€‚è®©æˆ‘ä»¬åœ¨åŸºç¡€å±‚ä¹‹ä¸Šé‡æ–°å®šä¹‰æˆ‘ä»¬çš„`MonoidHomClass`ã€‚
- en: '[PRE178]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Of course the hierarchy of morphisms does not stop here. We could go on and
    define a class `RingHomClassâ‚ƒ` extending `MonoidHomClassâ‚ƒ` and instantiate it
    on `RingHom` and then later on `AlgebraHom` (algebras are rings with some extra
    structure). But weâ€™ve covered the main formalization ideas used in Mathlib for
    morphisms and you should be ready to understand how morphisms are defined in Mathlib.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œå½¢æ€çš„å±‚æ¬¡ç»“æ„å¹¶æ²¡æœ‰åœ¨è¿™é‡Œåœæ­¢ã€‚æˆ‘ä»¬å¯ä»¥ç»§ç»­å®šä¹‰ä¸€ä¸ªæ‰©å±•`MonoidHomClassâ‚ƒ`çš„ç±»`RingHomClassâ‚ƒ`ï¼Œå¹¶åœ¨`RingHom`ä¸Šå®ä¾‹åŒ–å®ƒï¼Œç„¶åç¨ååœ¨å…¶ä¸Šå®ä¾‹åŒ–`AlgebraHom`ï¼ˆä»£æ•°æ˜¯å…·æœ‰ä¸€äº›é¢å¤–ç»“æ„çš„ç¯ï¼‰ã€‚ä½†æˆ‘ä»¬å·²ç»æ¶µç›–äº†Mathlibä¸­ç”¨äºå½¢æ€çš„ä¸»è¦å½¢å¼åŒ–æ€æƒ³ï¼Œä½ åº”è¯¥å‡†å¤‡å¥½ç†è§£åœ¨Mathlibä¸­å¦‚ä½•å®šä¹‰å½¢æ€ã€‚
- en: As an exercise, you should try to define your class of bundled order-preserving
    function between ordered types, and then order preserving monoid morphisms. This
    is for training purposes only. Like continuous functions, order preserving functions
    are primarily unbundled in Mathlib where they are defined by the `Monotone` predicate.
    Of course you need to complete the class definitions below.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç»ƒä¹ ï¼Œä½ åº”è¯¥å°è¯•å®šä¹‰ä½ çš„æœ‰åºç±»å‹ä¹‹é—´æ‰“åŒ…çš„ä¿æŒé¡ºåºçš„å‡½æ•°çš„ç±»ï¼Œç„¶åå®šä¹‰ä¿æŒé¡ºåºçš„å¹ºåŠç¾¤å½¢æ€ã€‚è¿™ä»…ç”¨äºè®­ç»ƒç›®çš„ã€‚åƒè¿ç»­å‡½æ•°ä¸€æ ·ï¼Œä¿æŒé¡ºåºçš„å‡½æ•°åœ¨Mathlibä¸­ä¸»è¦æ˜¯æœªæ‰“åŒ…çš„ï¼Œå®ƒä»¬ç”±`Monotone`è°“è¯å®šä¹‰ã€‚å½“ç„¶ï¼Œä½ éœ€è¦å®Œæˆä¸‹é¢çš„ç±»å®šä¹‰ã€‚
- en: '[PRE179]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '## 8.3\. Sub-objects[ïƒ](#sub-objects "Link to this heading")'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '## 8.3. å­å¯¹è±¡[ïƒ](#sub-objects "é“¾æ¥åˆ°æœ¬æ ‡é¢˜")'
- en: After defining some algebraic structure and its morphisms, the next step is
    to consider sets that inherit this algebraic structure, for instance subgroups
    or subrings. This largely overlaps with our previous topic. Indeed a set in `X`
    is implemented as a function from `X` to `Prop` so sub-objects are function satisfying
    a certain predicate. Hence we can reuse of lot of the ideas that led to the `DFunLike`
    class and its descendants. We wonâ€™t reuse `DFunLike` itself because this would
    break the abstraction barrier from `Set X` to `X â†’ Prop`. Instead there is a `SetLike`
    class. Instead of wrapping an injection into a function type, that class wraps
    an injection into a `Set` type and defines the corresponding coercion and `Membership`
    instance.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®šä¹‰äº†ä¸€äº›ä»£æ•°ç»“æ„å’Œå…¶å½¢æ€ä¹‹åï¼Œä¸‹ä¸€æ­¥æ˜¯è€ƒè™‘ç»§æ‰¿è¿™ç§ä»£æ•°ç»“æ„çš„é›†åˆï¼Œä¾‹å¦‚å­ç¾¤æˆ–å­ç¯ã€‚è¿™å¾ˆå¤§ç¨‹åº¦ä¸Šä¸æˆ‘ä»¬çš„å‰ä¸€ä¸ªä¸»é¢˜é‡å ã€‚å®é™…ä¸Šï¼Œ`X`ä¸­çš„é›†åˆè¢«å®ç°ä¸ºä¸€ä¸ªä»`X`åˆ°`Prop`çš„å‡½æ•°ï¼Œå› æ­¤å­å¯¹è±¡æ˜¯æ»¡è¶³ä¸€å®šè°“è¯çš„å‡½æ•°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥é‡ç”¨å¯¼è‡´`DFunLike`ç±»åŠå…¶åä»£çš„è®¸å¤šæƒ³æ³•ã€‚æˆ‘ä»¬ä¸ä¼šé‡ç”¨`DFunLike`æœ¬èº«ï¼Œå› ä¸ºè¿™ä¼šæ‰“ç ´ä»`Set
    X`åˆ°`X â†’ Prop`çš„æŠ½è±¡éšœç¢ã€‚ç›¸åï¼Œæœ‰ä¸€ä¸ª`SetLike`ç±»ã€‚è¯¥ç±»ä¸æ˜¯å°†æ³¨å…¥åŒ…è£…åˆ°å‡½æ•°ç±»å‹ä¸­ï¼Œè€Œæ˜¯å°†æ³¨å…¥åŒ…è£…åˆ°`Set`ç±»å‹ä¸­ï¼Œå¹¶å®šä¹‰ç›¸åº”çš„å¼ºåˆ¶è½¬æ¢å’Œ`Membership`å®ä¾‹ã€‚
- en: '[PRE180]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Equipped with the above `SetLike` instance, we can already state naturally that
    a submonoid `N` contains `1` without using `N.carrier`. We can also silently treat
    `N` as a set in `M` as take its direct image under a map.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: é…å¤‡äº†ä¸Šè¿°`SetLike`å®ä¾‹ï¼Œæˆ‘ä»¬ç›®å‰å·²ç»å¯ä»¥è‡ªç„¶åœ°é™ˆè¿°ä¸€ä¸ªå­å¹ºåŠç¾¤`N`åŒ…å«`1`ï¼Œè€Œæ— éœ€ä½¿ç”¨`N.carrier`ã€‚æˆ‘ä»¬è¿˜å¯ä»¥åœ¨`M`ä¸­å°†`N`è§†ä¸ºä¸€ä¸ªé›†åˆï¼Œå¹¶å¯¹å…¶ç›´æ¥åƒè¿›è¡Œæ˜ å°„ã€‚
- en: '[PRE181]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'We also have a coercion to `Type` which uses `Subtype` so, given a submonoid
    `N` we can write a parameter `(x : N)` which can be coerced to an element of `M`
    belonging to `N`.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬è¿˜æœ‰ä¸€ä¸ªåˆ°`Type`çš„å¼ºåˆ¶è½¬æ¢ï¼Œå®ƒä½¿ç”¨`Subtype`ï¼Œå› æ­¤ï¼Œç»™å®šä¸€ä¸ªå­å¹ºåŠç¾¤`N`ï¼Œæˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªå‚æ•°`(x : N)`ï¼Œå®ƒå¯ä»¥è¢«å¼ºåˆ¶è½¬æ¢ä¸ºå±äº`M`ä¸”å±äº`N`çš„å…ƒç´ ã€‚'
- en: '[PRE182]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Using this coercion to `Type` we can also tackle the task of equipping a submonoid
    with a monoid structure. We will use the coercion from the type associated to
    `N` as above, and the lemma `SetCoe.ext` asserting this coercion is injective.
    Both are provided by the `SetLike` instance.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ç§åˆ° `Type` çš„å¼ºåˆ¶è½¬æ¢ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å¤„ç†ç»™å­ç¾¤æ—èµ‹äºˆå¹ºåŠç¾¤ç»“æ„çš„é—®é¢˜ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ä¸Šé¢æåˆ°çš„ä¸ `N` å…³è”çš„ç±»å‹å¼ºåˆ¶è½¬æ¢ï¼Œä»¥åŠæ–­è¨€è¿™ç§å¼ºåˆ¶è½¬æ¢æ˜¯å•å°„çš„
    `SetCoe.ext` å¼•ç†ã€‚è¿™ä¸¤ä¸ªéƒ½æ˜¯ç”± `SetLike` å®ä¾‹æä¾›çš„ã€‚
- en: '[PRE183]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Note that, in the above instance, instead of using the coercion to `M` and calling
    the `property` field, we could have used destructuring binders as follows.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨ä¸Šé¢çš„å®ä¾‹ä¸­ï¼Œæˆ‘ä»¬é™¤äº†ä½¿ç”¨åˆ° `M` çš„å¼ºåˆ¶è½¬æ¢å¹¶è°ƒç”¨ `property` å­—æ®µå¤–ï¼Œè¿˜å¯ä»¥ä½¿ç”¨è§£æ„ç»‘å®šç¬¦ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚
- en: '[PRE184]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: In order to apply lemmas about submonoids to subgroups or subrings, we need
    a class, just like for morphisms. Note this class take a `SetLike` instance as
    a parameter so it does not need a carrier field and can use the membership notation
    in its fields.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å°†å…³äºå­ç¾¤æ—çš„å¼•ç†åº”ç”¨äºå­ç¾¤æˆ–å­ç¯ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªç±»ï¼Œå°±åƒå¯¹äºæ€å°„ä¸€æ ·ã€‚æ³¨æ„è¿™ä¸ªç±»æ¥å—ä¸€ä¸ª `SetLike` å®ä¾‹ä½œä¸ºå‚æ•°ï¼Œå› æ­¤å®ƒä¸éœ€è¦è½½ä½“åŸŸï¼Œå¯ä»¥åœ¨å…¶å­—æ®µä¸­ä½¿ç”¨æˆå‘˜ç¬¦å·ã€‚
- en: '[PRE185]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: As an exercise you should define a `Subgroupâ‚` structure, endow it with a `SetLike`
    instance and a `SubmonoidClassâ‚` instance, put a `Group` instance on the subtype
    associated to a `Subgroupâ‚` and define a `SubgroupClassâ‚` class.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºç»ƒä¹ ï¼Œä½ åº”è¯¥å®šä¹‰ä¸€ä¸ª `Subgroupâ‚` ç»“æ„ï¼Œç»™å®ƒèµ‹äºˆä¸€ä¸ª `SetLike` å®ä¾‹å’Œä¸€ä¸ª `SubmonoidClassâ‚` å®ä¾‹ï¼Œåœ¨å…³è”äº
    `Subgroupâ‚` çš„å­ç±»å‹ä¸Šæ”¾ç½®ä¸€ä¸ª `Group` å®ä¾‹ï¼Œå¹¶å®šä¹‰ä¸€ä¸ª `SubgroupClassâ‚` ç±»ã€‚
- en: Another very important thing to know about subobjects of a given algebraic object
    in Mathlib always form a complete lattice, and this structure is used a lot. For
    instance you may look for the lemma saying that an intersection of submonoids
    is a submonoid. But this wonâ€™t be a lemma, this will be an infimum construction.
    Let us do the case of two submonoids.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äº Mathlib ä¸­ç»™å®šä»£æ•°å¯¹è±¡çš„å­å¯¹è±¡ï¼Œæ€»æ˜¯å½¢æˆä¸€ä¸ªå®Œå¤‡æ ¼ï¼Œå¹¶ä¸”è¿™ä¸ªç»“æ„è¢«å¤§é‡ä½¿ç”¨ã€‚ä¾‹å¦‚ï¼Œä½ å¯èƒ½æƒ³è¦æŸ¥æ‰¾ä¸€ä¸ªè¯´å­ç¾¤æ—çš„äº¤é›†æ˜¯ä¸€ä¸ªå­ç¾¤æ—çš„å¼•ç†ã€‚ä½†è¿™ä¸ä¼šæ˜¯ä¸€ä¸ªå¼•ç†ï¼Œè¿™å°†æ˜¯ä¸€ä¸ªä¸‹ç¡®ç•Œæ„é€ ã€‚è®©æˆ‘ä»¬çœ‹çœ‹ä¸¤ä¸ªå­ç¾¤æ—çš„ä¾‹å­ã€‚
- en: '[PRE186]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: This allows to get the intersections of two submonoids as a submonoid.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å…è®¸æˆ‘ä»¬å¾—åˆ°ä¸¤ä¸ªå­ç¾¤æ—çš„äº¤é›†ä½œä¸ºä¸€ä¸ªå­ç¾¤æ—ã€‚
- en: '[PRE187]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: You may think itâ€™s a shame that we had to use the inf symbol `âŠ“` in the above
    example instead of the intersection symbol `âˆ©`. But think about the supremum.
    The union of two submonoids is not a submonoid. However submonoids still form
    a lattice (even a complete one). Actually `N âŠ” P` is the submonoid generated by
    the union of `N` and `P` and of course it would be very confusing to denote it
    by `N âˆª P`. So you can see the use of `N âŠ“ P` as much more consistent. It is also
    a lot more consistent across various kind of algebraic structures. It may look
    a bit weird at first to see the sum of two vector subspace `E` and `F` denoted
    by `E âŠ” F` instead of `E + F`. But you will get used to it. And soon you will
    consider the `E + F` notation as a distraction emphasizing the anecdotal fact
    that elements of `E âŠ” F` can be written as a sum of an element of `E` and an element
    of `F` instead of emphasizing the fundamental fact that `E âŠ” F` is the smallest
    vector subspace containing both `E` and `F`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½è§‰å¾—æˆ‘ä»¬ä¸å¾—ä¸åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ä½¿ç”¨ç¬¦å· `âŠ“` è€Œä¸æ˜¯äº¤é›†ç¬¦å· `âˆ©` æ˜¯ä¸€ç§é—æ†¾ã€‚ä½†æƒ³æƒ³ä¸Šç¡®ç•Œã€‚ä¸¤ä¸ªå­ç¾¤æ—çš„å¹¶é›†ä¸æ˜¯ä¸€ä¸ªå­ç¾¤æ—ã€‚ç„¶è€Œï¼Œå­ç¾¤æ—ä»ç„¶å½¢æˆä¸€ä¸ªæ ¼ï¼ˆç”šè‡³æ˜¯ä¸€ä¸ªå®Œå¤‡æ ¼ï¼‰ã€‚å®é™…ä¸Šï¼Œ`N
    âŠ” P` æ˜¯ç”± `N` å’Œ `P` çš„å¹¶é›†ç”Ÿæˆçš„å­ç¾¤æ—ï¼Œå½“ç„¶ç”¨ `N âˆª P` æ¥è¡¨ç¤ºå®ƒä¼šéå¸¸ä»¤äººå›°æƒ‘ã€‚æ‰€ä»¥ï¼Œä½ å¯ä»¥çœ‹åˆ°ä½¿ç”¨ `N âŠ“ P` çš„æ–¹å¼è¦ä¸€è‡´å¾—å¤šã€‚å®ƒåœ¨å„ç§ä»£æ•°ç»“æ„ä¸­çš„ä¸€è‡´æ€§ä¹Ÿæ›´å¼ºã€‚ä¸€å¼€å§‹çœ‹åˆ°ä¸¤ä¸ªå‘é‡å­ç©ºé—´
    `E` å’Œ `F` çš„å’Œç”¨ `E âŠ” F` è¡¨ç¤ºè€Œä¸æ˜¯ `E + F` å¯èƒ½ä¼šæ˜¾å¾—æœ‰äº›å¥‡æ€ªã€‚ä½†ä½ ä¼šä¹ æƒ¯çš„ã€‚å¾ˆå¿«ï¼Œä½ å°±ä¼šè®¤ä¸º `E + F` çš„è¡¨ç¤ºæ˜¯ä¸€ä¸ªå¹²æ‰°ï¼Œå¼ºè°ƒ
    `E âŠ” F` çš„å…ƒç´ å¯ä»¥å†™æˆ `E` çš„ä¸€ä¸ªå…ƒç´ å’Œ `F` çš„ä¸€ä¸ªå…ƒç´ çš„å’Œï¼Œè€Œä¸æ˜¯å¼ºè°ƒ `E âŠ” F` æ˜¯åŒ…å« `E` å’Œ `F` çš„æœ€å°å‘é‡å­ç©ºé—´è¿™ä¸€åŸºæœ¬äº‹å®ã€‚
- en: Our last topic for this chapter is that of quotients. Again we want to explain
    how convenient notation are built and code duplication is avoided in Mathlib.
    Here the main device is the `HasQuotient` class which allows notations like `M
    â§¸ N`. Beware the quotient symbol `â§¸` is a special unicode character, not a regular
    ASCII division symbol.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« çš„æœ€åä¸€ä¸ªä¸»é¢˜æ˜¯å•†ã€‚åŒæ ·ï¼Œæˆ‘ä»¬æƒ³è¦è§£é‡Šåœ¨ Mathlib ä¸­å¦‚ä½•æ„å»ºæ–¹ä¾¿çš„è®°å·å¹¶é¿å…ä»£ç é‡å¤ã€‚è¿™é‡Œçš„ä¸»è¦å·¥å…·æ˜¯ `HasQuotient` ç±»ï¼Œå®ƒå…è®¸ä½¿ç”¨åƒ
    `M â§¸ N` è¿™æ ·çš„è®°å·ã€‚æ³¨æ„ï¼Œå•†ç¬¦å· `â§¸` æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ Unicode å­—ç¬¦ï¼Œä¸æ˜¯ä¸€ä¸ªå¸¸è§„çš„ ASCII é™¤æ³•ç¬¦å·ã€‚
- en: As an example, we will build the quotient of a commutative monoid by a submonoid,
    leave proofs to you. In the last example, you can use `Setoid.refl` but it wonâ€™t
    automatically pick up the relevant `Setoid` structure. You can fix this issue
    by providing all arguments using the `@` syntax, as in `@Setoid.refl M N.Setoid`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œæˆ‘ä»¬å°†é€šè¿‡å­å¹ºåŠç¾¤æ„å»ºä¸€ä¸ªäº¤æ¢å¹ºåŠç¾¤çš„å•†ï¼Œè¯æ˜ç•™ç»™ä½ ä»¬ã€‚åœ¨ä¸Šä¸€ä¸ªä¾‹å­ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨ `Setoid.refl`ï¼Œä½†å®ƒä¸ä¼šè‡ªåŠ¨è·å–ç›¸å…³çš„ `Setoid`
    ç»“æ„ã€‚ä½ å¯ä»¥é€šè¿‡ä½¿ç”¨ `@` è¯­æ³•æä¾›æ‰€æœ‰å‚æ•°æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå°±åƒåœ¨ `@Setoid.refl M N.Setoid` ä¸­ä¸€æ ·ã€‚
- en: '[PRE188]*'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE188]*'
