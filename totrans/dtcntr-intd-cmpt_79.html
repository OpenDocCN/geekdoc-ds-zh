<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>32Â GlossaryğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>32Â GlossaryğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/glossary.html">https://dcic-world.org/2025-08-27/glossary.html</a></blockquote><p/><div class="SIntrapara"><a name="(elem._glossary-bandwidth)"/>â˜ <span style="font-style: italic">bandwidth</span></div><div class="SIntrapara"><blockquote><p>The bandwidth between two network nodes is
the quantity of data that can be transferred in a unit of time between
the nodes.</p></blockquote></div><p/><div class="SIntrapara"><a name="(elem._glossary-cache)"/>â˜ <span style="font-style: italic">cache</span></div><div class="SIntrapara"><blockquote><p>A cache is an instance of a
<a href="#%28elem._glossary-space-time._tradeoff%29" data-pltdoc="x">â˜› <span style="font-style: italic">space-time tradeoff</span></a>: it trades space for time by
using the space to avoid recomputing an answer. The act of using a
cache is called <span style="font-style: italic">caching</span>.  The word â€œcacheâ€ is often used
loosely; we use it only for information that can be perfectly
reconstructed even if it were lost: this enables a program that needs
to reverse the tradeâ€”<wbr/>i.e., use less space in return for more
timeâ€”<wbr/>to do so safely, knowing it will lose no information and thus
not sacrifice correctness.</p></blockquote></div><p/><div class="SIntrapara"><a name="(elem._glossary-coinduction)"/>â˜ <span style="font-style: italic">coinduction</span></div><div class="SIntrapara"><blockquote><p>Coinduction is a proof principle for
mathematical structures that are equipped with methods of observation
rather than of construction. Conversely, functions over inductive data
take them apart; functions over coinductive data construct them. The
<a href="http://www.cs.ru.nl/~bart/PAPERS/JR.pdf">classic tutorial</a>
on the topic will be useful to mathematically sophisticated readers.</p></blockquote></div><p/><div class="SIntrapara"><a name="(elem._glossary-idempotence)"/>â˜ <span style="font-style: italic">idempotence</span></div><div class="SIntrapara"><blockquote><p>An idempotent operator is one whose repeated
application to any value in its domain yields the same result as a
single application (note that this implies the range is a subset of
the domain). Thus, a function \(f\) is idempotent if, for all \(x\) in
its domain, \(f(f(x)) = f(x)\) (and by induction this holds for
additional applications of \(f\)).</p></blockquote></div><p/><div class="SIntrapara"><a name="(elem._glossary-invariants)"/>â˜ <span style="font-style: italic">invariants</span></div><div class="SIntrapara"><blockquote><p>Invariants are assertions about programs
that are intended to always be true (â€œin-vary-antâ€â€”<wbr/><span class="emph">never
varying</span>). For instance, a sorting routine may have as an invariant
that the list it returns is sorted.</p></blockquote></div><p/><div class="SIntrapara"><a name="(elem._glossary-latency)"/>â˜ <span style="font-style: italic">latency</span></div><div class="SIntrapara"><blockquote><p>The latency between two network nodes is the
time it takes for packets to go between the nodes.</p></blockquote></div><p/><div class="SIntrapara"><a name="(elem._glossary-metasyntactic._variable)"/>â˜ <span style="font-style: italic">metasyntactic variable</span></div><div class="SIntrapara"><blockquote><p>A metasyntactic variable is
one that lives outside the language, and ranges over a fragment of
syntax. For instance, if we write â€œfor expressions <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e1</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e2</code></span>, the sum <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e1 + e2</code></span>â€, we do not mean the programmer
literally wrote â€œ<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e1</code></span>â€ in the program; rather we are using
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e1</code></span> to refer to whatever the programmer might write on the left
of the addition sign. Therefore, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e1</code></span> is <span class="emph">metasyntax</span>.</p></blockquote></div><p/><div class="SIntrapara"><a name="(elem._glossary-packed._representation)"/>â˜ <span style="font-style: italic">packed representation</span></div><div class="SIntrapara"><blockquote><p>At the machine level, a packed
representation is one that ignores traditional alignment boundaries
(in older or smaller machines, bytes; on most contemporary machines,
words) to let multiple values fit inside or even spill over the
boundary.</p><p>For instance, say we wish to store a vector of four values, each of
which represents one of four options. A traditional representation
would store one value per alignment boundary, thereby consuming four
units of memory. A packed representation would recognize that each
value requires two bits, and four of them can fit into eight bits, so
a single byte can hold all four values. Suppose instead we wished to
store four values representing five options each, therefore requiring
three bits for each value.  A byte- or word-aligned representation
would not fundamentally change, but the packed representation would
use two bytes to store the twelve bits, even permitting the third
valueâ€™s three bits to be split across a byte boundary.</p><p>Of course, packed representations have a cost. Extracting the values
requires more careful and complex operations. Thus, they represent a
classic <a href="#%28elem._glossary-space-time._tradeoff%29" data-pltdoc="x">â˜› <span style="font-style: italic">space-time tradeoff</span></a>: using more time to
shrink space consumption. More subtly, packed representations can
confound certain run-time systems that may have expected data to be
aligned.</p></blockquote></div><p/><div class="SIntrapara"><a name="(elem._glossary-parsing)"/>â˜ <span style="font-style: italic">parsing</span></div><div class="SIntrapara"><blockquote><p>Parsing is, very broadly speaking, the act of
converting content in one kind of structured input into content in
another. The structures could be very similar, but usually they are
quite different. Often, the input format is simple while the output
format is expected to capture rich information about the
<span class="emph">content</span> of the input. For instance, the input might be a linear
sequence of characters on an input stream, and the output might be
expected to be rich and tree-structured according to some datatype:
most program and natural-language parsers are faced with this task.</p></blockquote></div><p/><div class="SIntrapara"><a name="(elem._glossary-reduction)"/>â˜ <span style="font-style: italic">reduction</span></div><div class="SIntrapara"><blockquote><p>Reduction is a relationship between a pair
of situationsâ€”<wbr/>problems, functions, data structures, etc.â€”<wbr/>where one
is defined in terms of the other. A reduction <span style="font-style: italic">R</span> is a
function from situations of the form <span style="font-style: italic">P</span> to ones of the form
<span style="font-style: italic">Q</span> if, for every instance of <span style="font-style: italic">P</span>, <span style="font-style: italic">R</span>
can construct an instance of <span style="font-style: italic">Q</span> such that it preserves
the meaning of <span style="font-style: italic">P</span>. Note that the converse strictly does not
need to hold.</p></blockquote></div><p/><div class="SIntrapara"><a name="(elem._glossary-space-time._tradeoff)"/>â˜ <span style="font-style: italic">space-time tradeoff</span></div><div class="SIntrapara"><blockquote><p>Suppose you have an expensive
computation that always produces the same answer for a given set of
inputs. Once you have computed the answer once, you now have a choice:
store the answer so that you can simply look it up when you need it
again, or throw it away and re-compute it the next time. The former
uses more space, but saves time; the latter uses less space, but
consumes more time. This, at its heart, is the space-time
tradeoff. Memoization [<a href="avoid-recomp.html" data-pltdoc="x">Avoiding Recomputation by Remembering Answers</a>] and using a <a href="#%28elem._glossary-cache%29" data-pltdoc="x">â˜› <span style="font-style: italic">cache</span></a>
are both instances of it.</p></blockquote></div><p/><div class="SIntrapara"><a name="(elem._glossary-type._variable)"/>â˜ <span style="font-style: italic">type variable</span></div><div class="SIntrapara"><blockquote><p>Type variables are identifiers in the
type language that (usually) range over actual types.</p></blockquote></div><p/><div class="SIntrapara"><a name="(elem._glossary-wire._format)"/>â˜ <span style="font-style: italic">wire format</span></div><div class="SIntrapara"><blockquote><p>A notation used to transmit data across,
as opposed to within, a closed platform (such as a virtual
machine). These are usually expected to be relatively simple because
they must be implemented in many languages and on weak processes. They
are also expected to be <span class="emph">unambiguous</span> to aid simple, fast, and
correct parsing.  Popular examples include XML, JSON, and
s-expressions.</p></blockquote></div>    
</body>
</html>