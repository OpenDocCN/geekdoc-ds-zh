- en: Binary GCD
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制 GCD
- en: 原文：[https://en.algorithmica.org/hpc/algorithms/gcd/](https://en.algorithmica.org/hpc/algorithms/gcd/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/algorithms/gcd/](https://en.algorithmica.org/hpc/algorithms/gcd/)
- en: In this section, we will derive a variant of `gcd` that is ~2x faster than the
    one in the C++ standard library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将推导出一个比 C++ 标准库中的 `gcd` 快约 2 倍的 `gcd` 变体。
- en: '## [#](https://en.algorithmica.org/hpc/algorithms/gcd/#euclids-algorithm)Euclid’s
    Algorithm'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '## [#](https://en.algorithmica.org/hpc/algorithms/gcd/#euclids-algorithm)欧几里得算法'
- en: 'Euclid’s algorithm solves the problem of finding the *greatest common divisor*
    (GCD) of two integer numbers $a$ and $b$, which is defined as the largest such
    number $g$ that divides both $a$ and $b$:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得算法解决了寻找两个整数 $a$ 和 $b$ 的最大公约数（GCD）的问题，定义为能够同时整除 $a$ 和 $b$ 的最大数 $g$：
- en: '$$ \gcd(a, b) = \max_{g: \; g|a \, \land \, g | b} g $$ You probably already
    know this algorithm from a CS textbook, but I will summarize it here. It is based
    on the following formula, assuming that $a > b$: $$ \gcd(a, b) = \begin{cases}
    a, & b = 0 \\ \gcd(b, a \bmod b), & b > 0 \end{cases} $$'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '$$ \gcd(a, b) = \max_{g: \; g|a \, \land \, g | b} g $$ 你可能已经从计算机科学教科书中了解到这个算法，但我会在这里总结。它基于以下公式，假设
    $a > b$：$$ \gcd(a, b) = \begin{cases} a, & b = 0 \\ \gcd(b, a \bmod b), & b >
    0 \end{cases} $$'
- en: 'This is true, because if $g = \gcd(a, b)$ divides both $a$ and $b$, it should
    also divide $(a \bmod b = a - k \cdot b)$, but any larger divisor $d$ of $b$ will
    not: $d > g$ implies that $d$ couldn’t divide $a$ and thus won’t divide $(a -
    k \cdot b)$.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是真的，因为如果 $g = \gcd(a, b)$ 能够整除 $a$ 和 $b$，它也应该能够整除 $(a \bmod b = a - k \cdot
    b)$，但任何更大的除数 $d$ 都不能：$d > g$ 意味着 $d$ 不能整除 $a$，因此也不会整除 $(a - k \cdot b)$。
- en: 'The formula above is essentially the algorithm itself: you can simply apply
    it recursively, and since each time one of the arguments strictly decreases, it
    will eventually converge to the $b = 0$ case.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的公式本质上就是算法本身：你可以简单地递归地应用它，由于每次其中一个参数严格递减，它最终会收敛到 $b = 0$ 的情况。
- en: The textbook also probably mentioned that the worst possible input to Euclid’s
    algorithm — the one that maximizes the total number of steps — are consecutive
    Fibonacci numbers, and since they grow exponentially, the running time of the
    algorithm is logarithmic in the worst case. This is also true for its *average*
    running time if we define it as the expected number of steps for pairs of uniformly
    distributed integers. [The Wikipedia article](https://en.wikipedia.org/wiki/Euclidean_algorithm)
    also has a cryptic derivation of a more precise $0.84 \cdot \ln n$ asymptotic
    estimate.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 教科书可能还提到了欧几里得算法最坏可能的输入——最大化步骤总数的连续斐波那契数，由于它们呈指数增长，算法的最坏情况运行时间是对数级的。如果我们将其定义为均匀分布整数对的期望步数，其平均运行时间也是如此。[维基百科文章](https://en.wikipedia.org/wiki/Euclidean_algorithm)
    也提供了一个更精确的 $0.84 \cdot \ln n$ 的渐近估计。
- en: '![](../Images/43200f1ef22ee0e23387fdd9a29ee5c1.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/43200f1ef22ee0e23387fdd9a29ee5c1.png)'
- en: You can see bright blue lines at the proportions of the golden ratio
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到明亮的蓝色线条，它们的比例是黄金比例
- en: 'There are many ways you can implement Euclid’s algorithm. The simplest would
    be just to convert the definition into code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以多种方式实现欧几里得算法。最简单的方法就是将定义转换为代码：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can rewrite it more compactly like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更紧凑地重写它如下：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can rewrite it as a loop, which will be closer to how it is actually executed
    by the hardware. It won’t be faster though, because compilers can easily optimize
    tail recursion.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其重写为一个循环，这将更接近硬件实际执行的顺序。但这不会更快，因为编译器可以轻松优化尾递归。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can even write the body of the loop as this confusing one-liner — and it
    will even compile without causing undefined behavior warnings since C++17:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将循环体写成这个令人困惑的一行——并且它甚至会在 C++17 之后编译而不会产生未定义行为警告：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All of these, as well as `std::gcd` which was introduced in C++17, are almost
    equivalent and get [compiled](https://godbolt.org/z/r8z5KcGqK) into functionally
    the following assembly loop:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些，以及 C++17 中引入的 `std::gcd`，几乎等价，并且被编译成功能上相当于以下汇编循环：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you run [perf](/hpc/profiling/events) on it, you will see that it spends
    ~90% of the time on the `idiv` line. This isn’t surprising: general [integer division](/hpc/arithmetic/division)
    works notoriously slow on all computers, including x86.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 [perf](/hpc/profiling/events)，你会看到它大约花费了 90% 的时间在 `idiv` 行上。这并不奇怪：在所有计算机上，包括
    x86，通用整数除法都出奇地慢。
- en: 'But there is one kind of division that works well in hardware: division by
    a power of 2.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一种除法在硬件中工作得很好：除以 2 的幂。
- en: '## [#](https://en.algorithmica.org/hpc/algorithms/gcd/#binary-gcd)Binary GCD'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '## [#](https://en.algorithmica.org/hpc/algorithms/gcd/#binary-gcd)二进制最大公约数'
- en: The *binary GCD algorithm* was discovered around the same time as Euclid’s,
    but on the other end of the civilized world, in ancient China. In 1967, it was
    rediscovered by Josef Stein for use in computers that either don’t have division
    instruction or have a very slow one — it wasn’t uncommon for CPUs of that era
    to use hundreds or thousands of cycles for rare or complex operations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*二进制最大公约数算法*与欧几里得算法几乎同时被发现，但它在文明世界的另一端，即古代中国。1967年，约瑟夫·斯坦因重新发现了它，用于那些没有除法指令或除法指令非常慢的计算机——在那个时代的CPU中，使用数百或数千个周期进行罕见或复杂操作并不罕见。'
- en: 'Analogous to the Euclidean algorithm, it is based on a few similar observations:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于欧几里得算法，它基于几个类似的观察：
- en: $\gcd(0, b) = b$ and symmetrically $\gcd(a, 0) = a$;
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: $\gcd(0, b) = b$和对称地$\gcd(a, 0) = a$；
- en: $\gcd(2a, 2b) = 2 \cdot \gcd(a, b)$;
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: $\gcd(2a, 2b) = 2 \cdot \gcd(a, b)$；
- en: $\gcd(2a, b) = \gcd(a, b)$ if $b$ is odd and symmetrically $\gcd(a, b) = \gcd(a,
    2b)$ if $a$ is odd;
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果$b$是奇数，则$\gcd(2a, b) = \gcd(a, b)$；如果$a$是奇数，则对称地$\gcd(a, b) = \gcd(a, 2b)$；
- en: $\gcd(a, b) = \gcd(|a − b|, \min(a, b))$, if $a$ and $b$ are both odd.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果$a$和$b$都是奇数，则$\gcd(a, b) = \gcd(|a − b|, \min(a, b))$；
- en: Likewise, the algorithm itself is just a repeated application of these identities.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，算法本身只是这些恒等式的重复应用。
- en: Its running time is still logarithmic, which is even easier to show because
    in each of these identities one of the arguments is divided by 2 — except for
    the last case, in which the new first argument, the absolute difference of two
    odd numbers, is guaranteed to be even and thus will be divided by 2 on the next
    iteration.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它的运行时间仍然是对数级的，这甚至更容易证明，因为在这些恒等式中的每一个，都有一个参数被除以2——除了最后一个情况，其中新的第一个参数，两个奇数的绝对差，保证是偶数，因此在下一次迭代中将被除以2。
- en: What makes this algorithm especially interesting to us is that the only arithmetic
    operations it uses are binary shifts, comparisons, and subtractions, all of which
    typically take just one cycle.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个算法对我们特别有趣的是，它使用的唯一算术运算只是二进制位移、比较和减法，所有这些通常只需要一个周期。
- en: '### [#](https://en.algorithmica.org/hpc/algorithms/gcd/#implementation)Implementation'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/algorithms/gcd/#implementation)实现'
- en: 'The reason this algorithm is not in the textbooks is because it can’t be implemented
    as a simple one-liner anymore:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法没有出现在教科书中，是因为它不能再简单地实现为一个单行代码：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let’s run it, and… it sucks. The difference in speed compared to `std::gcd`
    is indeed 2x, but on the other side of the equation. This is mainly because of
    all the branching needed to differentiate between the cases. Let’s start optimizing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它，然后……它很糟糕。与`std::gcd`相比，速度差异确实达到了2倍，但这是在方程的另一侧。这主要是因为区分不同情况所需的分支太多。让我们开始优化。
- en: First, let’s replace all divisions by 2 with divisions by whichever highest
    power of 2 we can. We can do it efficiently with `__builtin_ctz`, the “count trailing
    zeros” instruction available on modern CPUs. Whenever we are supposed to divide
    by 2 in the original algorithm, we will call this function instead, which will
    give us the exact number of bits to right-shift the number by. Assuming that the
    we are dealing with large random numbers, this is expected to decrease the number
    of iterations by almost a factor 2, because $1 + \frac{1}{2} + \frac{1}{4} + \frac{1}{8}
    + \ldots \to 2$.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将所有除以2的操作替换为除以我们可以使用的任意最高次幂的2。我们可以通过现代CPU上可用的`__builtin_ctz`（“计算尾部零数”指令）来有效地做到这一点。每当我们在原始算法中应该除以2时，我们将调用这个函数，它将给出将数字右移的确切位数。假设我们处理的是大随机数，这预计将减少迭代次数近一个因子，因为$1
    + \frac{1}{2} + \frac{1}{4} + \frac{1}{8} + \ldots \to 2$。
- en: Second, we can notice that condition 2 can now only be true once — in the very
    beginning — because every other identity leaves at least one of the numbers odd.
    Therefore we can handle this case just once in the beginning and not consider
    it in the main loop.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们可以注意到，条件2现在只能为真一次——在开始时——因为其他每个恒等式都会至少留下一个数字是奇数。因此，我们可以在开始时只处理这种情况一次，并在主循环中不考虑它。
- en: Third, we can notice that after we’ve entered condition 4 and applied its identity,
    $a$ will always be even and $b$ will always be odd, so we already know that on
    the next iteration we are going to be in condition 3\. This means that we can
    actually “de-evenize” $a$ right away, and if we do so we will again hit condition
    4 on the next iteration. This means that we can only ever be either in condition
    4 or terminating by condition 1, which removes the need to branch.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们可以注意到，在我们进入条件4并应用其恒等式之后，$a$ 总是偶数，而 $b$ 总是奇数，因此我们已知在下一迭代中我们将处于条件3。这意味着我们实际上可以立即“去偶”$a$，如果我们这样做，我们将在下一迭代再次遇到条件4。这意味着我们只能处于条件4或通过条件1终止，这样就消除了分支的需要。
- en: 'Combining these ideas, we get the following implementation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这些想法，我们得到以下实现：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It runs in 116ns, while `std::gcd` takes 198ns. Almost twice as fast — maybe
    we can even optimize it below 100ns?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它运行在116纳秒，而`std::gcd`需要198纳秒。几乎快了两倍——也许我们甚至可以将其优化到100纳秒以下？
- en: 'For that we need to stare at [its assembly](https://godbolt.org/z/nKKMe48cW)
    again, in particular at this block:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要再次仔细查看[其汇编](https://godbolt.org/z/nKKMe48cW)，特别是这个块：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s draw the dependency graph of this loop:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制这个循环的依赖图：
- en: '![](../Images/a95d9803e5b4e2b557b4ef6e9764f222.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a95d9803e5b4e2b557b4ef6e9764f222.png)'
- en: Modern processors can execute many instructions in parallel, essentially meaning
    that the true “cost” of this computation is roughly the sum of latencies on its
    critical path. In this case, it is the total latency of `diff`, `abs`, `ctz`,
    and `shift`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现代处理器可以并行执行许多指令，这本质上意味着这个计算的“真正成本”大约是其关键路径上延迟的总和。在这种情况下，它是`diff`、`abs`、`ctz`和`shift`的总延迟。
- en: 'We can decrease this latency using the fact that we can actually calculate
    `ctz` using just `diff = a - b`, because a [negative number](../hpc/arithmetic/integer/#signed-integers)
    divisible by $2^k$ still has $k$ zeros at the end of its binary representation.
    This lets us not wait for `max(diff, -diff)` to be computed first, resulting in
    a shorter graph like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用以下事实来减少这个延迟：我们实际上可以使用`diff = a - b`来计算`ctz`，因为一个[负数](../hpc/arithmetic/integer/#signed-integers)如果可以被$2^k$整除，那么它的二进制表示的末尾仍然有$k$个零。这使得我们不必等待`max(diff,
    -diff)`首先被计算，从而得到一个更短的图，如下所示：
- en: '![](../Images/4da8b376d272876c85fa3c25b56d1616.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4da8b376d272876c85fa3c25b56d1616.png)'
- en: 'Hopefully you will be less confused when you think about how the final code
    will be executed:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你在思考最终代码将如何执行时，会感到不那么困惑：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It runs in 91ns, which is good enough to leave it there.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它运行在91纳秒，这已经足够好，可以保持不变。
- en: If somebody wants to try to shave off a few more nanoseconds by rewriting the
    assembly by hand or trying a lookup table to save a few last iterations, please
    [let me know](http://sereja.me/).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人想尝试通过手动重写汇编或尝试查找表来节省最后几次迭代以减少几纳秒，请[告诉我](http://sereja.me/)。
- en: '### [#](https://en.algorithmica.org/hpc/algorithms/gcd/#acknowledgements)Acknowledgements'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/algorithms/gcd/#acknowledgements)致谢'
- en: The main optimization ideas belong to Daniel Lemire and Ralph Corderoy, who
    [had nothing better to do](https://lemire.me/blog/2013/12/26/fastest-way-to-compute-the-greatest-common-divisor/)
    on the Christmas holidays of 2013. [← ../Algorithms Case Studies](https://en.algorithmica.org/hpc/algorithms/)[Integer
    Factorization →](https://en.algorithmica.org/hpc/algorithms/factorization/)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的优化想法属于Daniel Lemire和Ralph Corderoy，他们在2013年圣诞节假期没有更好的事情可做。[← 算法案例研究](https://en.algorithmica.org/hpc/algorithms/)[整数分解
    →](https://en.algorithmica.org/hpc/algorithms/factorization/)
