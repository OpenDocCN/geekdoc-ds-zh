- en: From Python to Numpy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Python 到 Numpy
- en: Copyright (c) 2017 - Nicolas P. Rougier <[Nicolas.Rougier@inria.fr](mailto:Nicolas.Rougier%40inria.fr)>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版权所有 (c) 2017 - 尼古拉斯·P·鲁吉耶 <[Nicolas.Rougier@inria.fr](mailto:Nicolas.Rougier%40inria.fr)>
- en: '![img/37ef03690ff06d35c7a6a4721a5bfdf6.png](img/37ef03690ff06d35c7a6a4721a5bfdf6.png)
    ![img/b9aad74680f5251444b0d4b4ffa1af9a.png](img/b9aad74680f5251444b0d4b4ffa1af9a.png)
    ![img/02dcd8f1f04a6181a76ede131dfccf71.png](img/02dcd8f1f04a6181a76ede131dfccf71.png)
    ![img/2cdafe9a0083e1ba44f35436fa336345.png](img/2cdafe9a0083e1ba44f35436fa336345.png)Latest
    version - May 2017DOI: [10.5281/zenodo.225783](http://doi.org/10.5281/zenodo.225783)![img/247a52e4201671bc71b669dffc84bc84.png](img/247a52e4201671bc71b669dffc84bc84.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![img/37ef03690ff06d35c7a6a4721a5bfdf6.png](img/37ef03690ff06d35c7a6a4721a5bfdf6.png)
    ![img/b9aad74680f5251444b0d4b4ffa1af9a.png](img/b9aad74680f5251444b0d4b4ffa1af9a.png)
    ![img/02dcd8f1f04a6181a76ede131dfccf71.png](img/02dcd8f1f04a6181a76ede131dfccf71.png)
    ![img/2cdafe9a0083e1ba44f35436fa336345.png](img/2cdafe9a0083e1ba44f35436fa336345.png)最新版本
    - 2017 年 5 月DOI: [10.5281/zenodo.225783](http://doi.org/10.5281/zenodo.225783)![img/247a52e4201671bc71b669dffc84bc84.png](img/247a52e4201671bc71b669dffc84bc84.png)'
- en: There are already a fair number of books about Numpy (see [Bibliography](#bibliography))
    and a legitimate question is to wonder if another book is really necessary. As
    you may have guessed by reading these lines, my personal answer is yes, mostly
    because I think there is room for a different approach concentrating on the migration
    from Python to Numpy through vectorization. There are a lot of techniques that
    you don't find in books and such techniques are mostly learned through experience.
    The goal of this book is to explain some of these techniques and to provide an
    opportunity for making this experience in the process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有很多关于 Numpy 的书籍（参见[参考文献](#bibliography)），一个合理的问题可能是质疑是否真的需要另一本书。正如你可能通过阅读这些行所猜测的，我个人的答案是肯定的，主要是因为我认为在从
    Python 到 Numpy 的向量化迁移方面，还有不同的方法空间。有很多你在书中找不到的技术，而这些技术大多是通过经验学到的。本书的目标是解释这些技术中的一些，并在这个过程中提供一个体验的机会。
- en: '**Website:** [http://www.labri.fr/perso/nrougier/from-python-to-numpy](http://www.labri.fr/perso/nrougier/from-python-to-numpy)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站:** [http://www.labri.fr/perso/nrougier/from-python-to-numpy](http://www.labri.fr/perso/nrougier/from-python-to-numpy)'
- en: '**Table of Contents**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录**'
- en: '[Preface](#preface)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[前言](#preface)'
- en: '[About the author](#about-the-author)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于作者](#about-the-author)'
- en: '[About this book](#about-this-book)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于本书](#about-this-book)'
- en: '[License](#license)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[许可证](#license)'
- en: '[Introduction](#introduction)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简介](#introduction)'
- en: '[Simple example](#simple-example)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简单示例](#simple-example)'
- en: '[Readability vs speed](#readability-vs-speed)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可读性与速度](#readability-vs-speed)'
- en: '[Anatomy of an array](#anatomy-of-an-array)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数组的解剖结构](#anatomy-of-an-array)'
- en: '[Introduction](#id3)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简介](#id3)'
- en: '[Memory layout](#memory-layout)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[内存布局](#memory-layout)'
- en: '[Views and copies](#views-and-copies)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[视图和副本](#views-and-copies)'
- en: '[Conclusion](#conclusion)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结论](#conclusion)'
- en: '[Code vectorization](#code-vectorization)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[代码向量化](#code-vectorization)'
- en: '[Introduction](#id5)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简介](#id5)'
- en: '[Uniform vectorization](#uniform-vectorization)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[统一向量化](#uniform-vectorization)'
- en: '[Temporal vectorization](#temporal-vectorization)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[时间向量化](#temporal-vectorization)'
- en: '[Spatial vectorization](#spatial-vectorization)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[空间向量化](#spatial-vectorization)'
- en: '[Conclusion](#id17)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结论](#id17)'
- en: '[Problem vectorization](#problem-vectorization)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题向量化](#problem-vectorization)'
- en: '[Introduction](#id19)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简介](#id19)'
- en: '[Path finding](#path-finding)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[路径查找](#path-finding)'
- en: '[Fluid Dynamics](#fluid-dynamics)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[流体动力学](#fluid-dynamics)'
- en: '[Blue noise sampling](#blue-noise-sampling)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[蓝色噪声采样](#blue-noise-sampling)'
- en: '[Conclusion](#id27)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结论](#id27)'
- en: '[Custom vectorization](#custom-vectorization)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[自定义向量化](#custom-vectorization)'
- en: '[Introduction](#id29)'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简介](#id29)'
- en: '[Typed list](#typed-list)'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类型化列表](#typed-list)'
- en: '[Memory aware array](#memory-aware-array)'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[内存感知数组](#memory-aware-array)'
- en: '[Conclusion](#id36)'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结论](#id36)'
- en: '[Beyond Numpy](#beyond-numpy)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[超越 Numpy](#beyond-numpy)'
- en: '[Back to Python](#back-to-python)'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[返回 Python](#back-to-python)'
- en: '[Numpy & co](#numpy-co)'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Numpy 及其相关](#numpy-co)'
- en: '[Scipy & co](#scipy-co)'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Scipy 及其相关](#scipy-co)'
- en: '[Conclusion](#id52)'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结论](#id52)'
- en: '[Conclusion](#id53)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结论](#id53)'
- en: '[Quick References](#quick-references)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[快速参考](#quick-references)'
- en: '[Data type](#id56)'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据类型](#id56)'
- en: '[Creation](#id57)'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建](#id57)'
- en: '[Indexing](#id58)'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[索引](#id58)'
- en: '[Reshaping](#reshaping)'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[重塑](#reshaping)'
- en: '[Broadcasting](#broadcasting)'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[广播](#broadcasting)'
- en: '[Bibliography](#bibliography)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[参考文献](#bibliography)'
- en: '[Tutorials](#tutorials)'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[教程](#tutorials)'
- en: '[Articles](#articles)'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[文章](#articles)'
- en: '[Books](#books)'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[书籍](#books)'
- en: '**Disclaimer:** All external pictures should have associated credits. If there
    are missing credits, please tell me, I will correct it. Similarly, all excerpts
    should be sourced (wikipedia mostly). If not, this is an error and I will correct
    it as soon as you tell me.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**免责声明：**所有外部图片都应附有相关信用。如果缺少信用，请告诉我，我会进行更正。同样，所有摘录都应注明来源（主要是维基百科）。如果没有注明来源，则视为错误，我会尽快更正。'
- en: '[Preface](#table-of-contents)'
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[前言](#table-of-contents)'
- en: '**Contents**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录**'
- en: '[About the author](#about-the-author)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于作者](#about-the-author)'
- en: '[About this book](#about-this-book)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于本书](#about-this-book)'
- en: '[Prerequisites](#prerequisites)'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[先决条件](#prerequisites)'
- en: '[Conventions](#conventions)'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[约定](#conventions)'
- en: '[How to contribute](#how-to-contribute)'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何贡献](#how-to-contribute)'
- en: '[Publishing](#publishing)'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[出版](#publishing)'
- en: '[License](#license)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[许可证](#license)'
- en: '[About the author](#contents)'
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[关于作者](#contents)'
- en: '[Nicolas P. Rougier](http://www.labri.fr/perso/nrougier/) is a full-time research
    scientist at [Inria](http://www.inria.fr/en) which is the French national institute
    for research in computer science and control. This is a public scientific and
    technological establishment (EPST) under the double supervision of the Research
    & Education Ministry, and the Ministry of Economy Finance and Industry. Nicolas
    P. Rougier is working within the [Mnemosyne](http://www.inria.fr/en/teams/mnemosyne)
    project which lies at the frontier between integrative and computational neuroscience
    in association with the [Institute of Neurodegenerative Diseases](http://www.imn-bordeaux.org/en/),
    the Bordeaux laboratory for research in computer science ([LaBRI](https://www.labri.fr/)),
    the [University of Bordeaux](http://www.u-bordeaux.com/) and the national center
    for scientific research ([CNRS](http://www.cnrs.fr/index.php)).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[Nicolas P. Rougier](http://www.labri.fr/perso/nrougier/)是法国国家计算机科学和控制研究机构Inria的全职研究科学家。这是一个公共科学和技术机构（EPST），在研究与教育部的双重监督下。Nicolas
    P. Rougier在[Mnemosyne](http://www.inria.fr/en/teams/mnemosyne)项目中工作，该项目位于整合神经科学和计算神经科学的交汇处，与[神经退行性疾病研究所](http://www.imn-bordeaux.org/en/)、波尔多计算机科学研究实验室([LaBRI](https://www.labri.fr/))、[波尔多大学](http://www.u-bordeaux.com/)和国家级科学研究中心([CNRS](http://www.cnrs.fr/index.php))合作。'
- en: He has been using Python for more than 15 years and numpy for more than 10 years
    for modeling in neuroscience, machine learning and for advanced visualization
    (OpenGL). Nicolas P. Rougier is the author of several online resources and tutorials
    (Matplotlib, numpy, OpenGL) and he's teaching Python, numpy and scientific visualization
    at the University of Bordeaux and in various conferences and schools worldwide
    (SciPy, EuroScipy, etc). He's also the author of the popular article [Ten Simple
    Rules for Better Figures](http://dx.doi.org/10.1371/journal.pcbi.1003833) and
    a popular [matplotlib tutorial](http://www.labri.fr/perso/nrougier/teaching/matplotlib/matplotlib.html).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 他已经使用Python超过15年，使用numpy超过10年进行神经科学、机器学习和高级可视化（OpenGL）建模。Nicolas P. Rougier是多个在线资源和教程（Matplotlib、numpy、OpenGL）的作者，并在波尔多大学以及世界各地的各种会议和学校（SciPy、EuroScipy等）教授Python、numpy和科学可视化。他还是广受欢迎的文章《制作更好图形的十简单规则》（http://dx.doi.org/10.1371/journal.pcbi.1003833）和流行的[matplotlib教程](http://www.labri.fr/perso/nrougier/teaching/matplotlib/matplotlib.html)的作者。
- en: '[About this book](#contents)'
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[关于本书](#contents)'
- en: This book has been written in [restructured text](http://docutils.sourceforge.net/rst.html)
    format and generated using the `rst2html.py` command line available from the [docutils](http://docutils.sourceforge.net/)
    python package.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是用[restructured text](http://docutils.sourceforge.net/rst.html)格式编写的，并使用来自[docutils](http://docutils.sourceforge.net/)
    Python包的`rst2html.py`命令行生成。
- en: 'If you want to rebuild the html output, from the top directory, type:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想重新构建html输出，从顶级目录开始，输入：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The sources are available from [https://github.com/rougier/from-python-to-numpy](https://github.com/rougier/from-python-to-numpy).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以从[https://github.com/rougier/from-python-to-numpy](https://github.com/rougier/from-python-to-numpy)获取。
- en: '[Prerequisites](#contents)'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[先决条件](#contents)'
- en: This is not a Python beginner guide and you should have an intermediate level
    in Python and ideally a beginner level in numpy. If this is not the case, have
    a look at the [bibliography](#bibliography) for a curated list of resources.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本Python入门指南，你应该具备Python的中级水平，理想情况下numpy的入门水平。如果不是这样，请查看[bibliography](#bibliography)部分，以获取精选资源列表。
- en: '[Conventions](#contents)'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[约定](#contents)'
- en: 'We will use usual naming conventions. If not stated explicitly, each script
    should import numpy, scipy and matplotlib as:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用常规的命名约定。除非明确说明，每个脚本都应该导入numpy、scipy和matplotlib，如下所示：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We''ll use up-to-date versions (at the date of writing, i.e. January, 2017)
    of the different packages:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用不同软件包的最新版本（截至写作日期，即2017年1月）：
- en: '| Packages | Version |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 软件包 | 版本 |'
- en: '| --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Python | 3.6.0 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| Python | 3.6.0 |'
- en: '| Numpy | 1.12.0 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| Numpy | 1.12.0 |'
- en: '| Scipy | 0.18.1 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| Scipy | 0.18.1 |'
- en: '| Matplotlib | 2.0.0 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| Matplotlib | 2.0.0 |'
- en: '[How to contribute](#contents)'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[如何贡献](#contents)'
- en: 'If you want to contribute to this book, you can:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为这本书做出贡献，你可以：
- en: Review chapters (please contact me)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审阅章节（请与我联系）
- en: Report issues ([https://github.com/rougier/from-python-to-numpy/issues](https://github.com/rougier/from-python-to-numpy/issues))
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告问题（[https://github.com/rougier/from-python-to-numpy/issues](https://github.com/rougier/from-python-to-numpy/issues)）
- en: Suggest improvements ([https://github.com/rougier/from-python-to-numpy/pulls](https://github.com/rougier/from-python-to-numpy/pulls))
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议改进（[https://github.com/rougier/from-python-to-numpy/pulls](https://github.com/rougier/from-python-to-numpy/pulls)）
- en: Correct English ([https://github.com/rougier/from-python-to-numpy/issues](https://github.com/rougier/from-python-to-numpy/issues))
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的英文（[https://github.com/rougier/from-python-to-numpy/issues](https://github.com/rougier/from-python-to-numpy/issues)）
- en: Design a better and more responsive html template for the book.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为书籍设计一个更好、更响应式的html模板。
- en: Star the project ([https://github.com/rougier/from-python-to-numpy](https://github.com/rougier/from-python-to-numpy))
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注项目（[https://github.com/rougier/from-python-to-numpy](https://github.com/rougier/from-python-to-numpy)）
- en: '[Publishing](#contents)'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[发布](#contents)'
- en: 'If you''re an editor interested in publishing this book, you can [contact me](mailto:Nicolas.Rougier%40inria.fr)
    if you agree to have this version and all subsequent versions open access (i.e.
    online at [this address](http://www.labri.fr/perso/nrougier/from-python-to-numpy)),
    you know how to deal with [restructured text](http://docutils.sourceforge.net/rst.html)
    (Word is not an option), you provide a real added-value as well as supporting
    services, and more importantly, you have a truly amazing latex book template (and
    be warned that I''m a bit picky about typography & design: [Edward Tufte](https://www.edwardtufte.com/tufte/)
    is my hero). Still here?'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一位对出版这本书感兴趣的编辑，如果你同意将这个版本和所有后续版本开放获取（即在此地址[http://www.labri.fr/perso/nrougier/from-python-to-numpy](http://www.labri.fr/perso/nrougier/from-python-to-numpy)上在线），你知道如何处理[restructured
    text](http://docutils.sourceforge.net/rst.html)（Word不是选择），你提供真正的增值服务以及支持服务，更重要的是，你有一个真正惊人的latex书籍模板（并且警告：我对字体排印和设计有点挑剔：[Edward
    Tufte](https://www.edwardtufte.com/tufte/)是我的英雄）。还在这里吗？
- en: '[License](#contents)'
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[许可](#contents)'
- en: '**Book**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**书籍**'
- en: 'This work is licensed under a [Creative Commons Attribution-Non Commercial-Share
    Alike 4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    You are free to:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本作品根据[Creative Commons Attribution-Non Commercial-Share Alike 4.0 International
    License](https://creativecommons.org/licenses/by-nc-sa/4.0/)授权。你可以：
- en: '**Share** — copy and redistribute the material in any medium or format'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分享** — 以任何媒体或格式复制和重新分发材料'
- en: '**Adapt** — remix, transform, and build upon the material'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改编** — 混合、转换和在此基础上构建材料'
- en: The licensor cannot revoke these freedoms as long as you follow the license
    terms.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 只要您遵守许可条款，许可方不能撤销这些自由。
- en: '**Code**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: The code is licensed under the [OSI-approved BSD 2-Clause License](LICENSE-code.txt).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代码根据[OSI批准的BSD 2-Clause许可](LICENSE-code.txt)授权。
- en: '[Introduction](#table-of-contents)'
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[简介](#table-of-contents)'
- en: '**Contents**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录**'
- en: '[Simple example](#simple-example)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简单示例](#simple-example)'
- en: '[Readability vs speed](#readability-vs-speed)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可读性 vs 速度](#readability-vs-speed)'
- en: '[Simple example](#id1)'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[简单示例](#id1)'
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can execute any code below from the [code](code) folder using the regular
    python shell or from inside an IPython session or Jupyter notebook. In such a
    case, you might want to use the magic command `%timeit` instead of the [custom
    one](code/tools.py) I wrote.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用常规的python shell或从IPython会话或Jupyter笔记本中执行下面的任何代码。在这种情况下，你可能想使用魔法命令`%timeit`而不是我写的[自定义命令](code/tools.py)。
- en: Numpy is all about vectorization. If you are familiar with Python, this is the
    main difficulty you'll face because you'll need to change your way of thinking
    and your new friends (among others) are named "vectors", "arrays", "views" or
    "ufuncs".
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Numpy主要关于向量化。如果你熟悉Python，这将是你面临的主要困难，因为你需要改变你的思维方式，你的新朋友（包括其他）被称为“向量”、“数组”、“视图”或“ufuncs”。
- en: 'Let''s take a very simple example, random walk. One possible object oriented
    approach would be to define a `RandomWalker` class and write a walk method that
    would return the current position after each (random) step. It''s nice, it''s
    readable, but it is slow:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个非常简单的例子来举例，随机游走。一种可能的对象式方法是定义一个`RandomWalker`类，并编写一个walk方法，该方法会在每次（随机）步骤后返回当前位置。这很好，可读性不错，但速度较慢：
- en: '**Object oriented approach**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象的方法**'
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Benchmarking gives us:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试给我们：
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Procedural approach**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程式方法**'
- en: For such a simple problem, we can probably save the class definition and concentrate
    only on the walk method that computes successive positions after each random step.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个简单的问题，我们可能可以省略类定义，只关注walk方法，该方法计算每次随机步骤后的连续位置。
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This new method saves some CPU cycles but not that much because this function
    is pretty much the same as in the object-oriented approach and the few cycles
    we saved probably come from the inner Python object-oriented machinery.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新方法节省了一些CPU周期，但并不多，因为这个函数基本上与面向对象的方法相同，我们节省的几个周期可能来自Python内部的面向对象机制。
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Vectorized approach**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**向量化方法**'
- en: 'But we can do better using the [itertools](https://docs.python.org/3.6/library/itertools.html)
    Python module that offers *a set of functions creating iterators for efficient
    looping*. If we observe that a random walk is an accumulation of steps, we can
    rewrite the function by first generating all the steps and accumulate them without
    any loop:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以使用提供创建迭代器以实现高效循环的[itertools](https://docs.python.org/3.6/library/itertools.html)
    Python模块做得更好。如果我们观察到随机游走是步骤的累积，我们可以通过首先生成所有步骤并累积它们而不使用任何循环来重写函数：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In fact, we''ve just *vectorized* our function. Instead of looping for picking
    sequential steps and add them to the current position, we first generated all
    the steps at once and used the [accumulate](https://docs.python.org/3.6/library/itertools.html#itertools.accumulate)
    function to compute all the positions. We got rid of the loop and this makes things
    faster:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们只是将函数向量化了。我们不再通过循环来选择连续步骤并将它们添加到当前位置，而是首先一次性生成所有步骤，并使用[accumulate](https://docs.python.org/3.6/library/itertools.html#itertools.accumulate)函数来计算所有位置。我们消除了循环，这使得事情变得更快：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We gained 85% of computation-time compared to the previous version, not so bad.
    But the advantage of this new version is that it makes numpy vectorization super
    simple. We just have to translate itertools call into numpy ones.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个版本相比，我们获得了85%的计算时间，这并不坏。但这个新版本的优势在于它使numpy向量化变得超级简单。我们只需将itertools调用转换为numpy调用即可。
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Not too difficult, but we gained a factor 500x using numpy:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不太难，但我们使用numpy获得了500倍的提升：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This book is about vectorization, be it at the code or problem level. We'll
    see this difference is important before looking at custom vectorization.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是关于向量化，无论是代码层面还是问题层面。在查看自定义向量化之前，我们会看到这种差异很重要。
- en: '[Readability vs speed](#id1)'
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[可读性 vs 速度](#id1)'
- en: Before heading to the next chapter, I would like to warn you about a potential
    problem you may encounter once you'll have become familiar with numpy. It is a
    very powerful library and you can make wonders with it but, most of the time,
    this comes at the price of readability. If you don't comment your code at the
    time of writing, you won't be able to tell what a function is doing after a few
    weeks (or possibly days). For example, can you tell what the two functions below
    are doing? Probably you can tell for the first one, but unlikely for the second
    (or your name is [Jaime Fernández del Río](http://stackoverflow.com/questions/7100242/python-numpy-first-occurrence-of-subarray)
    and you don't need to read this book).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一章之前，我想提醒你，一旦你熟悉了numpy，你可能会遇到一个潜在的问题。这是一个非常强大的库，你可以用它做出奇迹，但大多数情况下，这要以可读性为代价。如果你在编写代码时没有注释，几周（或可能是几天）后你将无法知道一个函数在做什么。例如，你能说出下面两个函数在做什么吗？你可能可以猜出第一个，但第二个可能不太可能（或者你的名字是[Jaime
    Fernández del Río](http://stackoverflow.com/questions/7100242/python-numpy-first-occurrence-of-subarray)并且你不需要读这本书）。
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you may have guessed, the second function is the vectorized-optimized-faster-numpy
    version of the first function. It is 10 times faster than the pure Python version,
    but it is hardly readable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，第二个函数是第一个函数的向量化-优化-更快-numpy版本。它比纯Python版本快10倍，但几乎不可读。
- en: '[Anatomy of an array](#table-of-contents)'
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[数组解剖](#table-of-contents)'
- en: '**Contents**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容**'
- en: '[Introduction](#id3)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍](#id3)'
- en: '[Memory layout](#memory-layout)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[内存布局](#memory-layout)'
- en: '[Views and copies](#views-and-copies)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[视图和副本](#views-and-copies)'
- en: '[Direct and indirect access](#direct-and-indirect-access)'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[直接和间接访问](#direct-and-indirect-access)'
- en: '[Temporary copy](#temporary-copy)'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[临时副本](#temporary-copy)'
- en: '[Conclusion](#conclusion)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结论](#conclusion)'
- en: '[Introduction](#id2)'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[介绍](#id2)'
- en: As explained in the [Preface](#preface), you should have a basic experience
    with numpy to read this book. If this is not the case, you'd better start with
    a beginner tutorial before coming back here. Consequently I'll only give here
    a quick reminder on the basic anatomy of numpy arrays, especially regarding the
    memory layout, view, copy and the data type. They are critical notions to understand
    if you want your computation to benefit from numpy philosophy.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [前言](#preface) 中所述，你应该对 numpy 有基本的了解才能阅读这本书。如果不是这样，你最好先从入门教程开始，然后再回来。因此，我这里只简要回顾一下
    numpy 数组的基本结构，特别是关于内存布局、视图、副本和数据类型。如果你想让你的计算从 numpy 哲学中受益，这些是关键的概念。
- en: Let's consider a simple example where we want to clear all the values from an
    array which has the dtype `np.float32`. How does one write it to maximize speed?
    The below syntax is rather obvious (at least for those familiar with numpy) but
    the above question asks to find the fastest operation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的例子，我们想要清除具有 `np.float32` 数据类型的数组中的所有值。如何编写它以最大化速度？下面的语法相当明显（至少对于熟悉
    numpy 的人来说是这样），但上述问题要求找到最快的操作。
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you look more closely at both the dtype and the size of the array, you can
    observe that this array can be casted (i.e. viewed) into many other "compatible"
    data types. By compatible, I mean that `Z.size * Z.itemsize` can be divided by
    the new dtype itemsize.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更仔细地观察数组的 dtype 和大小，你可以观察到这个数组可以被转换为（即视为）许多其他“兼容”的数据类型。这里的兼容是指 `Z.size *
    Z.itemsize` 可以被新的 dtype 元素大小整除。
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Interestingly enough, the obvious way of clearing all the values is not the
    fastest. By casting the array into a larger data type such as `np.float64`, we
    gained a 25% speed factor. But, by viewing the array as a byte array (`np.int8`),
    we gained a 50% factor. The reason for such speedup are to be found in the internal
    numpy machinery and the compiler optimization. This simple example illustrates
    the philosophy of numpy as we'll see in the next section below.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，清除所有值的明显方法并不是最快的。通过将数组转换为更大的数据类型，例如 `np.float64`，我们获得了 25% 的速度提升。但是，通过将数组视为字节数组（`np.int8`），我们获得了
    50% 的速度提升。这种加速的原因可以在 numpy 的内部机制和编译器优化中找到。这个简单的例子说明了 numpy 的哲学，我们将在下一节中看到。
- en: '[Memory layout](#id2)'
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[内存布局](#id2)'
- en: 'The [numpy documentation](https://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html)
    defines the ndarray class very clearly:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[numpy 文档](https://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html)
    对 `ndarray` 类定义得非常清楚：'
- en: '*An instance of class ndarray consists of a contiguous one-dimensional segment
    of computer memory (owned by the array, or by some other object), combined with
    an indexing scheme that maps N integers into the location of an item in the block.*'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*`ndarray` 类的实例由一个连续的一维内存段（由数组或某些其他对象拥有）组成，并结合一个索引方案，该方案将 N 个整数映射到块中项的位置。*'
- en: 'Said differently, an array is mostly a contiguous block of memory whose parts
    can be accessed using an indexing scheme. Such indexing scheme is in turn defined
    by a [shape](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.shape.html#numpy.ndarray.shape)
    and a [data type](https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html)
    and this is precisely what is needed when you define a new array:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，数组主要是一个连续的内存块，其部分可以通过索引方案访问。这种索引方案反过来由一个 [形状](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.shape.html#numpy.ndarray.shape)
    和一个 [数据类型](https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html) 定义，这正是当你定义一个新数组时所需要的：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we know that Z itemsize is 2 bytes (`int16`), the shape is (3,3) and the
    number of dimensions is 2 (`len(Z.shape)`).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们知道 Z 的元素大小是 2 字节（`int16`），形状是 (3,3)，维度数是 2（`len(Z.shape)`）。
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Furthermore and because Z is not a view, we can deduce the [strides](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.strides.html#numpy.ndarray.strides)
    of the array that define the number of bytes to step in each dimension when traversing
    the array.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于 Z 不是一个视图，我们可以推断出数组的步长（[strides](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.strides.html#numpy.ndarray.strides)），这些步长定义了在遍历数组时每个维度需要步进的字节数。
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With all these information, we know how to access a specific item (designed
    by an index tuple) and more precisely, how to compute the start and end offsets:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些信息的基础上，我们知道如何访问一个特定的项（由索引元组设计），以及更精确地，如何计算起始和结束偏移量：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s see if this is correct using the [tobytes](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.tobytes.html)
    conversion method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用[tobytes](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.tobytes.html)转换方法来验证这是否正确：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This array can be actually considered from different perspectives (i.e. layouts):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组可以从不同的角度（即布局）来考虑：
- en: '**Item layout**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目布局**'
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Flattened item layout**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**扁平化项目布局**'
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Memory layout (C order, big endian)**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存布局（C顺序，大端序）**'
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we now take a slice of `Z`, the result is a view of the base array `Z`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在对`Z`进行切片，结果是基础数组`Z`的视图：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Such view is specified using a shape, a dtype **and** strides because strides
    cannot be deduced anymore from the dtype and shape only:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种视图是通过形状、dtype **和** 步长来指定的，因为步长不能再从dtype和形状中推导出来：
- en: '**Item layout**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目布局**'
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Flattened item layout**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**扁平化项目布局**'
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Memory layout (C order, big endian)**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存布局（C顺序，大端序）**'
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Views and copies](#id2)'
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[视图和副本](#id2)'
- en: Views and copies are important concepts for the optimization of your numerical
    computations. Even if we've already manipulated them in the previous section,
    the whole story is a bit more complex.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 视图和副本是优化您数值计算的重要概念。即使我们在前面的部分已经操作过它们，整个故事还是要复杂一些。
- en: '[Direct and indirect access](#id2)'
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[直接和间接访问](#id2)'
- en: 'First, we have to distinguish between [indexing](https://docs.scipy.org/doc/numpy/user/basics.indexing.html#)
    and [fancy indexing](https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing).
    The first will always return a view while the second will return a copy. This
    difference is important because in the first case, modifying the view modifies
    the base array while this is not true in the second case:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须区分[索引](https://docs.scipy.org/doc/numpy/user/basics.indexing.html#)和[复杂索引](https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing)。第一个总是返回一个视图，而第二个将返回一个副本。这种差异很重要，因为在第一种情况下，修改视图会修改基础数组，而在第二种情况下则不是这样：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Thus, if you need fancy indexing, it''s better to keep a copy of your fancy
    index (especially if it was complex to compute it) and to work with it:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您需要复杂的索引，最好保留您复杂索引的副本（尤其是如果计算它很复杂的话），并且使用它：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you are unsure if the result of your indexing is a view or a copy, you can
    check what is the `base` of your result. If it is `None`, then you result is a
    copy:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定索引的结果是视图还是副本，您可以检查结果的`base`是什么。如果是`None`，则结果是一个副本：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that some numpy functions return a view when possible (e.g. [ravel](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html))
    while some others always return a copy (e.g. [flatten](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flatten.html#numpy.ndarray.flatten)):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些numpy函数在可能的情况下会返回一个视图（例如[ravel](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html)），而另一些则总是返回一个副本（例如[flatten](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flatten.html#numpy.ndarray.flatten)）：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Temporary copy](#id2)'
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[临时副本](#id2)'
- en: 'Copies can be made explicitly like in the previous section, but the most general
    case is the implicit creation of intermediate copies. This is the case when you
    are doing some arithmetic with arrays:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像上一节那样显式地创建副本，但最通用的情况是中间副本的隐式创建。这是您在数组上进行某些算术运算时的情况：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the example above, three intermediate arrays have been created. One for
    holding the result of `2*X`, one for holding the result of `2*Y` and the last
    one for holding the result of `2*X+2*Y`. In this specific case, the arrays are
    small enough and this does not really make a difference. However, if your arrays
    are big, then you have to be careful with such expressions and wonder if you can
    do it differently. For example, if only the final result matters and you don''t
    need `X` nor `Y` afterwards, an alternate solution would be:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，创建了三个中间数组。一个用于存储`2*X`的结果，一个用于存储`2*Y`的结果，最后一个用于存储`2*X+2*Y`的结果。在这种情况下，数组足够小，这并不会真正造成差异。然而，如果您的数组很大，那么您必须小心处理这样的表达式，并考虑是否可以以不同的方式完成。例如，如果只有最终结果重要，您之后不需要`X`或`Y`，那么另一种解决方案将是：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Using this alternate solution, no temporary array has been created. Problem
    is that there are many other cases where such copies needs to be created and this
    impact the performance like demonstrated on the example below:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种替代方案，没有创建临时数组。问题是还有许多其他情况需要创建这样的副本，这会影响性能，如下面的例子所示：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[Conclusion](#id2)'
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[结论](#id2)'
- en: As a conclusion, we'll make an exercise. Given two vectors `Z1` and `Z2`. We
    would like to know if `Z2` is a view of `Z1` and if yes, what is this view ?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结论，我们将进行一个练习。给定两个向量`Z1`和`Z2`。我们想知道`Z2`是否是`Z1`的视图，如果是，这个视图是什么？
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, we need to check if `Z1` is the base of `Z2`
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检查`Z1`是否是`Z2`的基
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'At this point, we know `Z2` is a view of `Z1`, meaning `Z2` can be expressed
    as `Z1[start:stop:step]`. The difficulty is to find `start`, `stop` and `step`.
    For the `step`, we can use the `strides` property of any array that gives the
    number of bytes to go from one element to the other in each dimension. In our
    case, and because both arrays are one-dimensional, we can directly compare the
    first stride only:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们知道`Z2`是`Z1`的视图，这意味着`Z2`可以表示为`Z1[start:stop:step]`。困难之处在于找到`start`、`stop`和`step`。对于`step`，我们可以使用任何数组的`strides`属性，该属性给出每个维度中从一个元素到另一个元素的字节数。在我们的情况下，由于两个数组都是一维的，我们可以直接比较第一个步长：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Next difficulty is to find the `start` and the `stop` indices. To do this, we
    can take advantage of the `byte_bounds` method that returns a pointer to the end-points
    of an array.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个难度是找到`start`和`stop`索引。为此，我们可以利用`byte_bounds`方法，该方法返回数组的端点指针。
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Converting these offsets into indices is straightforward using the `itemsize`
    and taking into account that the `offset_stop` is negative (end-bound of `Z2`
    is logically smaller than end-bound of `Z1` array). We thus need to add the items
    size of Z1 to get the right end index.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`itemsize`将这些偏移量转换为索引是直接的，同时考虑到`offset_stop`是负数（`Z2`的逻辑结束边界小于`Z1`数组的结束边界）。因此，我们需要将Z1的元素大小加到正确的结束索引上。
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Last we test our results:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我们测试我们的结果：
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As an exercise, you can improve this first and very simple implementation by
    taking into account:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以通过考虑以下内容来改进这个最初且非常简单的实现：
- en: Negative steps
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负步长
- en: Multi-dimensional arrays
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多维数组
- en: '[Solution](code/find_index.py) to the exercise.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[练习的解决方案](code/find_index.py)。'
- en: '[Code vectorization](#table-of-contents)'
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[代码向量化](#table-of-contents)'
- en: '**Contents**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录**'
- en: '[Introduction](#id5)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍](#id5)'
- en: '[Uniform vectorization](#uniform-vectorization)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[统一向量化](#uniform-vectorization)'
- en: '[The Game of Life](#the-game-of-life)'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[生命游戏](#the-game-of-life)'
- en: '[Python implementation](#python-implementation)'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python实现](#python-implementation)'
- en: '[Numpy implementation](#numpy-implementation)'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NumPy实现](#numpy-implementation)'
- en: '[Exercise](#exercise)'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercise)'
- en: '[Sources](#sources)'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[来源](#sources)'
- en: '[References](#references)'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[参考文献](#references)'
- en: '[Temporal vectorization](#temporal-vectorization)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[时间向量化](#temporal-vectorization)'
- en: '[Python implementation](#id6)'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python实现](#id6)'
- en: '[Numpy implementation](#id7)'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NumPy实现](#id7)'
- en: '[Faster numpy implementation](#faster-numpy-implementation)'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[更快的NumPy实现](#faster-numpy-implementation)'
- en: '[Visualization](#visualization)'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可视化](#visualization)'
- en: '[Exercise](#id8)'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#id8)'
- en: '[Sources](#id9)'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[来源](#id9)'
- en: '[References](#id10)'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[参考文献](#id10)'
- en: '[Spatial vectorization](#spatial-vectorization)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[空间向量化](#spatial-vectorization)'
- en: '[Boids](#boids)'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[鸟群](#boids)'
- en: '[Python implementation](#id12)'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python实现](#id12)'
- en: '[Numpy implementation](#id13)'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NumPy实现](#id13)'
- en: '[Exercise](#id14)'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#id14)'
- en: '[Sources](#id15)'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[来源](#id15)'
- en: '[References](#id16)'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[参考文献](#id16)'
- en: '[Conclusion](#id17)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结论](#id17)'
- en: '[Introduction](#id4)'
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[介绍](#id4)'
- en: 'Code vectorization means that the problem you''re trying to solve is inherently
    vectorizable and only requires a few numpy tricks to make it faster. Of course
    it does not mean it is easy or straightforward, but at least it does not necessitate
    totally rethinking your problem (as it will be the case in the [Problem vectorization](#problem-vectorization)
    chapter). Still, it may require some experience to see where code can be vectorized.
    Let''s illustrate this through a simple example where we want to sum up two lists
    of integers. One simple way using pure Python is:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 代码向量化意味着你试图解决的问题本质上是可向量的，并且只需要几个NumPy技巧来使其更快。当然，这并不意味着它容易或直接，但至少它不需要完全重新思考你的问题（正如它将在[问题向量化](#problem-vectorization)章节中那样）。然而，这可能需要一些经验来看到代码可以向量化的地方。让我们通过一个简单的例子来说明这一点，我们想要对两个整数列表求和。一种简单的方法是使用纯Python：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This first naive solution can be vectorized very easily using numpy:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最初的天真解决方案可以非常容易地使用NumPy向量化：
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Without any surprise, benchmarking the two approaches shows the second method
    is the fastest with one order of magnitude.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不意外，对两种方法进行基准测试表明第二种方法快了一个数量级。
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Not only is the second approach faster, but it also naturally adapts to the
    shape of `Z1` and `Z2`. This is the reason why we did not write `Z1 + Z2` because
    it would not work if `Z1` and `Z2` were both lists. In the first Python method,
    the inner `+` is interpreted differently depending on the nature of the two objects
    such that if we consider two nested lists, we get the following outputs:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅第二种方法更快，而且它还自然地适应了 `Z1` 和 `Z2` 的形状。这就是我们没有写 `Z1 + Z2` 的原因，因为如果 `Z1` 和 `Z2`
    都是列表，那么它将不起作用。在第一个 Python 方法中，内层的 `+` 根据两个对象的性质被解释为不同，因此如果我们考虑两个嵌套列表，我们会得到以下输出：
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first method concatenates the two lists together, the second method concatenates
    the internal lists together and the last one computes what is (numerically) expected.
    As an exercise, you can rewrite the Python version such that it accepts nested
    lists of any depth.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是将两个列表连接在一起，第二种方法是将内部列表连接在一起，最后一种方法计算的是（数值上）预期的结果。作为一个练习，你可以重写 Python 版本，使其能够接受任何深度的嵌套列表。
- en: '[Uniform vectorization](#id4)'
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[均匀向量化](#id4)'
- en: Uniform vectorization is the simplest form of vectorization where all the elements
    share the same computation at every time step with no specific processing for
    any element. One stereotypical case is the Game of Life that has been invented
    by John Conway (see below) and is one of the earliest examples of cellular automata.
    Those cellular automata can be conveniently regarded as an array of cells that
    are connected together with the notion of neighbours and their vectorization is
    straightforward. Let me first define the game and we'll see how to vectorize it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 均匀向量化是向量化最简单的形式，其中所有元素在每个时间步骤中执行相同的计算，没有针对任何特定元素的处理。一个典型的例子是由约翰·康威（见下文）发明的生命游戏，它是细胞自动机最早的例子之一。那些细胞自动机可以方便地被视为由细胞组成的数组，这些细胞通过邻居的概念连接在一起，它们的向量化是直接的。让我首先定义这个游戏，然后我们将看到如何向量化它。
- en: '**Figure 4.1**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.1**'
- en: Conus textile snail exhibits a cellular automaton pattern on its shell. Image
    by [Richard Ling](https://commons.wikimedia.org/wiki/File:Textile_cone.JPG), 2005.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 织锦螺在其壳上表现出细胞自动机模式。图片由 [Richard Ling](https://commons.wikimedia.org/wiki/File:Textile_cone.JPG)，2005
    年拍摄。
- en: '![img/c091c3d73318960a6f67f0411911ec50.png](img/c091c3d73318960a6f67f0411911ec50.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![img/c091c3d73318960a6f67f0411911ec50.png](img/c091c3d73318960a6f67f0411911ec50.png)'
- en: '[The Game of Life](#id4)'
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[生命游戏](#id4)'
- en: Note
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: Excerpt from the Wikipedia entry on the [Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 来自维基百科关于 [生命游戏](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life) 条目的摘录
- en: The Game of Life is a cellular automaton devised by the British mathematician
    John Horton Conway in 1970\. It is the best-known example of a cellular automaton.
    The "game" is actually a zero-player game, meaning that its evolution is determined
    by its initial state, needing no input from human players. One interacts with
    the Game of Life by creating an initial configuration and observing how it evolves.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 生命游戏是由英国数学家约翰·霍顿·康威在 1970 年设计的细胞自动机。它是细胞自动机最著名的例子。这个“游戏”实际上是一个零玩家游戏，意味着其演变由其初始状态决定，不需要来自人类玩家的输入。玩家通过与创建初始配置并观察其演变来与生命游戏互动。
- en: 'The universe of the Game of Life is an infinite two-dimensional orthogonal
    grid of square cells, each of which is in one of two possible states, live or
    dead. Every cell interacts with its eight neighbours, which are the cells that
    are directly horizontally, vertically, or diagonally adjacent. At each step in
    time, the following transitions occur:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 生命游戏的宇宙是一个无限的两维正交网格，由正方形细胞组成，每个细胞处于两种可能的状态之一，即活着或死亡。每个细胞与其八个邻居相互作用，这些邻居是直接水平、垂直或对角相邻的细胞。在每一个时间步骤中，以下转换发生：
- en: Any live cell with fewer than two live neighbours dies, as if by needs caused
    by underpopulation.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何拥有少于两个活邻居的活细胞都会死亡，就像由于人口不足而导致的需要一样。
- en: Any live cell with more than three live neighbours dies, as if by overcrowding.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何拥有超过三个活邻居的活细胞都会死亡，就像由于过度拥挤一样。
- en: Any live cell with two or three live neighbours lives, unchanged, to the next
    generation.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何拥有两个或三个活邻居的活细胞在下一代中保持不变。
- en: Any dead cell with exactly three live neighbours becomes a live cell.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何拥有恰好三个活邻居的死亡细胞变成活细胞。
- en: The initial pattern constitutes the 'seed' of the system. The first generation
    is created by applying the above rules simultaneously to every cell in the seed
    – births and deaths happen simultaneously, and the discrete moment at which this
    happens is sometimes called a tick. (In other words, each generation is a pure
    function of the one before.) The rules continue to be applied repeatedly to create
    further generations.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 初始模式构成了系统的“种子”。第一代是通过将上述规则同时应用于种子中的每个细胞来创建的——出生和死亡是同时发生的，这个离散的时刻有时被称为“滴答”。（换句话说，每一代都是前一代的纯函数。）规则会反复应用以创建更多代。
- en: '[Python implementation](#id4)'
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Python实现](#id4)'
- en: Note
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We could have used the more efficient python [array interface](http://docs.python.org/3/library/array.html)
    but it is more convenient to use the familiar list object.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用更高效的python [数组接口](http://docs.python.org/3/library/array.html)，但使用熟悉的列表对象更方便。
- en: In pure Python, we can code the Game of Life using a list of lists representing
    the board where cells are supposed to evolve. Such a board will be equipped with
    border of 0 that allows to accelerate things a bit by avoiding having specific
    tests for borders when counting the number of neighbours.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯Python中，我们可以使用表示棋盘的列表的列表来编码生命游戏，其中细胞将进化。这样的棋盘将配备一个0的边界，这可以通过避免在计算邻居数量时对边界进行特定测试来加速事情。
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Taking the border into account, counting neighbours then is straightforward:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到边界，然后计算邻居就很简单了：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To iterate one step in time, we then simply count the number of neighbours
    for each internal cell and we update the whole board according to the four aforementioned
    rules:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要迭代一步时间，我们只需计算每个内部细胞的邻居数量，然后根据上述四个规则更新整个棋盘：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The figure below shows four iterations on a 4x4 area where the initial state
    is a [glider](https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)), a structure
    discovered by Richard K. Guy in 1970.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了在4x4区域内对初始状态为[滑翔机](https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life))的四个迭代过程，该结构由理查德·K·盖于1970年发现。
- en: '**Figure 4.2**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.2**'
- en: The glider pattern is known to replicate itself one step diagonally in 4 iterations.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 已知滑翔机模式在4次迭代中会沿对角线复制自己一步。
- en: '![img/d3d45b9f3ee5417c34c6fd84b90f9af4.png](img/d3d45b9f3ee5417c34c6fd84b90f9af4.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![img/d3d45b9f3ee5417c34c6fd84b90f9af4.png](img/d3d45b9f3ee5417c34c6fd84b90f9af4.png)'
- en: '[Numpy implementation](#id4)'
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Numpy实现](#id4)'
- en: 'Starting from the Python version, the vectorization of the Game of Life requires
    two parts, one responsible for counting the neighbours and one responsible for
    enforcing the rules. Neighbour-counting is relatively easy if we remember we took
    care of adding a null border around the arena. By considering partial views of
    the arena we can actually access neighbours quite intuitively as illustrated below
    for the one-dimensional case:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python版本开始，生命游戏的向量化需要两部分，一部分负责计算邻居，另一部分负责执行规则。如果记住我们已经在竞技场周围添加了一个空边界，邻居计数相对简单。通过考虑竞技场的部分视图，我们实际上可以直观地访问邻居，如下面的一维情况所示：
- en: '[PRE47]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Going to the two dimensional case requires just a bit of arithmetic to make
    sure to consider all the eight neighbours.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 转到二维情况只需要一点算术，以确保考虑所有八个邻居。
- en: '[PRE48]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For the rule enforcement, we can write a first version using numpy's [argwhere](http://docs.scipy.org/doc/numpy/reference/generated/numpy.argwhere.html)
    method that will give us the indices where a given condition is True.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于规则执行，我们可以编写一个使用numpy的[argwhere](http://docs.scipy.org/doc/numpy/reference/generated/numpy.argwhere.html)方法的第一个版本，这将给我们给定条件为真的索引。
- en: '[PRE49]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Even if this first version does not use nested loops, it is far from optimal
    because of the use of the four `argwhere` calls that may be quite slow. We can
    instead factorize the rules into cells that will survive (stay at 1) and cells
    that will give birth. For doing this, we can take advantage of Numpy boolean capability
    and write quite naturally:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个第一个版本没有使用嵌套循环，但由于使用了四个`argwhere`调用，它远非最优，因为这些调用可能相当慢。我们可以将规则分解为将存活的（保持为1）和将出生的细胞，为此，我们可以利用Numpy的布尔能力，并自然地编写：
- en: Note
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We did no write `Z = 0` as this would simply assign the value 0 to `Z` that
    would then become a simple scalar.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有写`Z = 0`，因为这会将值0赋给`Z`，然后它将变成一个简单的标量。
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If you look at the `birth` and `survive` lines, you'll see that these two variables
    are arrays that can be used to set `Z` values to 1 after having cleared it.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`出生`和`存活`行，你会看到这两个变量是数组，可以在清除后将其`Z`值设置为1。
- en: '**Figure 4.3**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.3**'
- en: The Game of Life. Gray levels indicate how much a cell has been active in the
    past.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 生命游戏。灰度表示细胞过去活跃的程度。
- en: <https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/game-of-life.mp4>
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[从Python到NumPy的数据：生命游戏](https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/game-of-life.mp4)'
- en: Your browser does not support the video tag.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您的浏览器不支持视频标签。
- en: '[Exercise](#id4)'
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[练习](#id4)'
- en: 'Reaction and diffusion of chemical species can produce a variety of patterns,
    reminiscent of those often seen in nature. The Gray-Scott equations model such
    a reaction. For more information on this chemical system see the article *Complex
    Patterns in a Simple System* (John E. Pearson, Science, Volume 261, 1993). Let''s
    consider two chemical species *U* and *V* with respective concentrations *u* and
    *v* and diffusion rates *Du* and *Dv*. *V* is converted into *P* with a rate of
    conversion *k*. *f* represents the rate of the process that feeds *U* and drains
    *U*, *V* and *P*. This can be written as:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 化学物种的反应和扩散可以产生各种图案，这些图案常在自然界中看到。灰色-斯科特方程式模拟了这样的反应。有关这个化学系统的更多信息，请参阅文章《简单系统中的复杂模式》（约翰·E·皮尔森，科学，第261卷，1993年）。让我们考虑两种化学物种
    *U* 和 *V*，它们分别具有浓度 *u* 和 *v* 以及扩散率 *Du* 和 *Dv*。*V* 以转换率 *k* 转换为 *P*。*f* 代表喂养 *U*
    并从 *U*、*V* 和 *P* 中排出的过程的速率。这可以写成：
- en: '| Chemical reaction | Equations |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 化学反应 | 方程式 |'
- en: '| --- | --- |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *U* + 2*V* → 3*V* | *u̇* = *Du*∇²*u* − *uv*² + *f*(1 − *u*) |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| *U*＋2*V*→3*V* | *u̇*＝*Du*∇²*u*－*uv*²＋*f*(1－*u*) |'
- en: '| *V* → *P* | *v̇* = *Dv*∇²*v* + *uv*² − (*f* + *k*)*v* |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| *V*→*P* | *v̇*＝*Dv*∇²*v*＋*uv*²－(*f*＋*k*)*v* |'
- en: 'Based on the Game of Life example, try to implement such reaction-diffusion
    system. Here is a set of interesting parameters to test:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 基于生命游戏的示例，尝试实现这样的反应-扩散系统。以下是一组有趣的参数以供测试：
- en: '| Name | Du | Dv | f | k |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 杜 | 杜v | f | k |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Bacteria 1 | 0.16 | 0.08 | 0.035 | 0.065 |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 细菌 1 | 0.16 | 0.08 | 0.035 | 0.065 |'
- en: '| Bacteria 2 | 0.14 | 0.06 | 0.035 | 0.065 |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 细菌 2 | 0.14 | 0.06 | 0.035 | 0.065 |'
- en: '| Coral | 0.16 | 0.08 | 0.060 | 0.062 |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 珊瑚 | 0.16 | 0.08 | 0.060 | 0.062 |'
- en: '| Fingerprint | 0.19 | 0.05 | 0.060 | 0.062 |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 指纹 | 0.19 | 0.05 | 0.060 | 0.062 |'
- en: '| Spirals | 0.10 | 0.10 | 0.018 | 0.050 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 螺旋 | 0.10 | 0.10 | 0.018 | 0.050 |'
- en: '| Spirals Dense | 0.12 | 0.08 | 0.020 | 0.050 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 密集螺旋 | 0.12 | 0.08 | 0.020 | 0.050 |'
- en: '| Spirals Fast | 0.10 | 0.16 | 0.020 | 0.050 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 螺旋快速 | 0.10 | 0.16 | 0.020 | 0.050 |'
- en: '| Unstable | 0.16 | 0.08 | 0.020 | 0.055 |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 不稳定 | 0.16 | 0.08 | 0.020 | 0.055 |'
- en: '| Worms 1 | 0.16 | 0.08 | 0.050 | 0.065 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 蠕虫 1 | 0.16 | 0.08 | 0.050 | 0.065 |'
- en: '| Worms 2 | 0.16 | 0.08 | 0.054 | 0.063 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 蠕虫 2 | 0.16 | 0.08 | 0.054 | 0.063 |'
- en: '| Zebrafish | 0.16 | 0.08 | 0.035 | 0.060 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 斑马鱼 | 0.16 | 0.08 | 0.035 | 0.060 |'
- en: The figure below shows some animations of the model for a specific set of parameters.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了该模型在特定参数集下的动画。
- en: '**Figure 4.4**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.4**'
- en: Reaction-diffusion Gray-Scott model. From left to right, *Bacteria 1*, *Coral*
    and *Spiral Dense*.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 反应-扩散灰色-斯科特模型。从左到右，*细菌 1*、*珊瑚*和*密集螺旋*。
- en: <https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/gray-scott-1.mp4>
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[从Python到NumPy的数据：灰色-斯科特模型 1](https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/gray-scott-1.mp4)'
- en: Your browser does not support the video tag.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您的浏览器不支持视频标签。
- en: <https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/gray-scott-2.mp4>
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[从Python到NumPy的数据：灰色-斯科特模型](https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/gray-scott-2.mp4)'
- en: Your browser does not support the video tag.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您的浏览器不支持视频标签。
- en: <https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/gray-scott-3.mp4>
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[从Python到NumPy的数据：灰色-斯科特模型 3](https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/gray-scott-3.mp4)'
- en: Your browser does not support the video tag.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您的浏览器不支持视频标签。
- en: '[Sources](#id4)'
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[来源](#id4)'
- en: '[game_of_life_python.py](code/game_of_life_python.py)'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[game_of_life_python.py](code/game_of_life_python.py)'
- en: '[game_of_life_numpy.py](code/game_of_life_numpy.py)'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[game_of_life_numpy.py](code/game_of_life_numpy.py)'
- en: '[gray_scott.py](code/gray_scott.py) (solution to the exercise)'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[gray_scott.py](code/gray_scott.py)（练习的解决方案）'
- en: '[References](#id4)'
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[参考文献](#id4)'
- en: '[John Conway new solitaire game "life"](https://web.archive.org/web/20090603015231/http://ddi.cs.uni-potsdam.de/HyFISCH/Produzieren/lis_projekt/proj_gamelife/ConwayScientificAmerican.htm),
    Martin Gardner, Scientific American 223, 1970.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[约翰·康威的新单人纸牌游戏 "生命"](https://web.archive.org/web/20090603015231/http://ddi.cs.uni-potsdam.de/HyFISCH/Produzieren/lis_projekt/proj_gamelife/ConwayScientificAmerican.htm),
    马丁·加德纳, 科学美国人 223, 1970.'
- en: '[Gray Scott Model of Reaction Diffusion](http://groups.csail.mit.edu/mac/projects/amorphous/GrayScott/),
    Abelson, Adams, Coore, Hanson, Nagpal, Sussman, 1997.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[反应-扩散的灰色-斯科特模型](http://groups.csail.mit.edu/mac/projects/amorphous/GrayScott/),
    阿贝尔森，亚当斯，库尔，汉森，纳加帕尔，苏斯曼，1997.'
- en: '[Reaction-Diffusion by the Gray-Scott Model](http://mrob.com/pub/comp/xmorphia/),
    Robert P. Munafo, 1996.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通过灰色-斯科特模型进行反应-扩散](http://mrob.com/pub/comp/xmorphia/), 罗伯特·P·穆纳福，1996.'
- en: '[Temporal vectorization](#id4)'
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[时间向量化](#id4)'
- en: The Mandelbrot set is the set of complex numbers *c* for which the function
    *f*[*c*](*z*) = *z*² + *c* does not diverge when iterated from *z* = 0, i.e.,
    for which the sequence *f*[*c*](0), *f*[*c*](*f*[*c*](0)), etc., remains bounded
    in absolute value. It is very easy to compute, but it can take a very long time
    because you need to ensure a given number does not diverge. This is generally
    done by iterating the computation up to a maximum number of iterations, after
    which, if the number is still within some bounds, it is considered non-divergent.
    Of course, the more iterations you do, the more precision you get.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 曼德布罗特集是复数 *c* 的集合，对于这些复数，函数 *f*[*c*](*z*) = *z*² + *c* 在从 *z* = 0 迭代时不会发散，即对于序列
    *f*[*c*](0)，*f*[*c*](*f*[*c*](0))，等等，其绝对值保持有界。它非常容易计算，但可能需要非常长的时间，因为需要确保给定的数字不会发散。这通常是通过迭代计算直到最大迭代次数来完成的，之后，如果数字仍然在某个范围内，则认为它不是发散的。当然，你进行的迭代越多，你得到的精度就越高。
- en: '**Figure 4.5**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.5**'
- en: Romanesco broccoli, showing self-similar form approximating a natural fractal.
    Image by [Jon Sullivan](https://commons.wikimedia.org/wiki/File:Fractal_Broccoli.jpg),
    2004.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 罗马esco西兰花，显示出近似自然分形的自相似形态。图片由 [Jon Sullivan](https://commons.wikimedia.org/wiki/File:Fractal_Broccoli.jpg)，2004
    年拍摄。
- en: '![img/c00398a6e63dcdcf8495aa58e80c0f72.png](img/c00398a6e63dcdcf8495aa58e80c0f72.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![img/c00398a6e63dcdcf8495aa58e80c0f72.png](img/c00398a6e63dcdcf8495aa58e80c0f72.png)'
- en: '[Python implementation](#id4)'
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Python 实现](#id4)'
- en: 'A pure python implementation is written as:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 纯 Python 实现如下编写：
- en: '[PRE51]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The interesting (and slow) part of this code is the `mandelbrot` function that
    actually computes the sequence *f*[*c*](*f*[*c*](*f*[*c*]...))). The vectorization
    of such code is not totally straightforward because the internal `return` implies
    a differential processing of the element. Once it has diverged, we don't need
    to iterate any more and we can safely return the iteration count at divergence.
    The problem is to then do the same in numpy. But how?
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有趣（且缓慢）的部分是 `mandelbrot` 函数，它实际上计算序列 *f*[*c*](*f*[*c*](*f*[*c*]...)))。此类代码的向量化并不完全直接，因为内部的
    `return` 表明对元素进行了微分处理。一旦它发散，我们就不需要再迭代了，并且可以安全地返回发散时的迭代次数。问题是然后在 numpy 中做同样的事情。但如何做呢？
- en: '[Numpy implementation](#id4)'
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Numpy 实现](#id4)'
- en: The trick is to search at each iteration values that have not yet diverged and
    update relevant information for these values and only these values. Because we
    start from *Z* = 0, we know that each value will be updated at least once (when
    they're equal to 0, they have not yet diverged) and will stop being updated as
    soon as they've diverged. To do that, we'll use numpy fancy indexing with the
    `less(x1,x2)` function that return the truth value of `(x1 < x2)` element-wise.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 技巧在于在每次迭代中搜索尚未发散的值，并只更新这些值的相关信息。因为我们从 *Z* = 0 开始，我们知道每个值至少会被更新一次（当它们等于 0 时，它们尚未发散），并且一旦它们发散，就会停止更新。为此，我们将使用
    numpy 的花式索引和 `less(x1,x2)` 函数，该函数返回 `(x1 < x2)` 的逐元素真值。
- en: '[PRE52]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here is the benchmark:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是基准测试：
- en: '[PRE53]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[Faster numpy implementation](#id4)'
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[更快的 Numpy 实现](#id4)'
- en: The gain is roughly a 5x factor, not as much as we could have expected. Part
    of the problem is that the `np.less` function implies *xn* × *yn* tests at every
    iteration while we know that some values have already diverged. Even if these
    tests are performed at the C level (through numpy), the cost is nonetheless significant.
    Another approach proposed by [Dan Goodman](https://thesamovar.wordpress.com/)
    is to work on a dynamic array at each iteration that stores only the points which
    have not yet diverged. It requires more lines but the result is faster and leads
    to a 10x factor speed improvement compared to the Python version.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 收益大约是 5 倍，没有我们预期的那么多。部分问题是 `np.less` 函数在每次迭代中都意味着 *xn* × *yn* 测试，而我们知道某些值已经发散了。即使这些测试在
    C 级别（通过 numpy）执行，成本仍然相当显著。Dan Goodman [https://thesamovar.wordpress.com/](https://thesamovar.wordpress.com/)
    提出的一种另一种方法是，在每次迭代中处理一个动态数组，该数组只存储尚未发散的点。这需要更多的行，但结果更快，与 Python 版本相比，速度提高了 10 倍。
- en: '[PRE54]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The benchmark gives us:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试给我们：
- en: '[PRE55]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[Visualization](#id4)'
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[可视化](#id4)'
- en: In order to visualize our results, we could directly display the `N` array using
    the matplotlib `imshow` command, but this would result in a "banded" image that
    is a known consequence of the escape count algorithm that we've been using. Such
    banding can be eliminated by using a fractional escape count. This can be done
    by measuring how far the iterated point landed outside of the escape cutoff. See
    the reference below about the renormalization of the escape count. Here is a picture
    of the result where we use recount normalization, and added a power normalized
    color map (gamma=0.3) as well as light shading.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化我们的结果，我们可以直接使用matplotlib的`imshow`命令显示`N`数组，但这会导致“带状”图像，这是我们所使用的逃逸计数算法的已知后果。这种带状可以通过使用分数逃逸计数来消除。这可以通过测量迭代点落在逃逸截止点之外有多远来实现。请参阅下文关于逃逸计数的重新归一化的参考。以下是使用重新计数归一化，并添加了功率归一化颜色图（伽马=0.3）以及浅阴影的结果图片。
- en: '**Figure 4.6**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.6**'
- en: The Mandelbrot as rendered by matplotlib using recount normalization, power
    normalized color map (gamma=0.3) and light shading.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用重新计数归一化、功率归一化颜色图（伽马=0.3）和浅阴影渲染的曼德尔布罗特集。
- en: '![img/9ea19f540f154a1bc6fcf2fa7a4ba552.png](img/9ea19f540f154a1bc6fcf2fa7a4ba552.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![img/9ea19f540f154a1bc6fcf2fa7a4ba552.png](img/9ea19f540f154a1bc6fcf2fa7a4ba552.png)'
- en: '[Exercise](#id4)'
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[练习](#id4)'
- en: Note
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You should look at the [ufunc.reduceat](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.reduceat.html)
    method that performs a (local) reduce with specified slices over a single axis.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该查看[ufunc.reduceat](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.reduceat.html)方法，该方法在单个轴上执行具有指定切片的（局部）归约。
- en: We now want to measure the fractal dimension of the Mandelbrot set using the
    [Minkowski–Bouligand dimension](https://en.wikipedia.org/wiki/Minkowski–Bouligand_dimension).
    To do that, we need to do box-counting with a decreasing box size (see figure
    below). As you can imagine, we cannot use pure Python because it would be way
    too slow. The goal of the exercise is to write a function using numpy that takes
    a two-dimensional float array and returns the dimension. We'll consider values
    in the array to be normalized (i.e. all values are between 0 and 1).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想使用[闵可夫斯基-博利冈德维度](https://en.wikipedia.org/wiki/Minkowski–Bouligand_dimension)来测量曼德尔布罗特集的分数维数。为此，我们需要使用递减的盒子大小进行盒子计数（见下文图示）。正如你可以想象的那样，我们不能使用纯Python，因为它会非常慢。这个练习的目的是编写一个使用numpy的函数，该函数接受一个二维浮点数组并返回维度。我们将考虑数组中的值是归一化的（即所有值都在0和1之间）。
- en: '**Figure 4.7**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.7**'
- en: The Minkowski–Bouligand dimension of the Great Britain coastlines is approximately
    1.24.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 大不列颠海岸线的闵可夫斯基-博利冈德维度大约为1.24。
- en: '![img/3790c715b411fa4b5650d93efabbaf3d.png](img/3790c715b411fa4b5650d93efabbaf3d.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![img/3790c715b411fa4b5650d93efabbaf3d.png](img/3790c715b411fa4b5650d93efabbaf3d.png)'
- en: '[Sources](#id4)'
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[来源](#id4)'
- en: '[mandelbrot.py](code/mandelbrot.py)'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[mandelbrot.py](code/mandelbrot.py)'
- en: '[mandelbrot_python.py](code/mandelbrot_python.py)'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[mandelbrot_python.py](code/mandelbrot_python.py)'
- en: '[mandelbrot_numpy_1.py](code/mandelbrot_numpy_1.py)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[mandelbrot_numpy_1.py](code/mandelbrot_numpy_1.py)'
- en: '[mandelbrot_numpy_2.py](code/mandelbrot_numpy_2.py)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[mandelbrot_numpy_2.py](code/mandelbrot_numpy_2.py)'
- en: '[fractal_dimension.py](code/fractal_dimension.py) (solution to the exercise)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[fractal_dimension.py](code/fractal_dimension.py)（练习的解决方案）'
- en: '[References](#id4)'
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[参考文献](#id4)'
- en: '[How To Quickly Compute the Mandelbrot Set in Python](https://www.ibm.com/developerworks/community/blogs/jfp/entry/How_To_Compute_Mandelbrodt_Set_Quickly?lang=en),
    Jean Francois Puget, 2015.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何在Python中快速计算曼德尔布罗特集](https://www.ibm.com/developerworks/community/blogs/jfp/entry/How_To_Compute_Mandelbrodt_Set_Quickly?lang=en)，Jean
    Francois Puget，2015。'
- en: '[My Christmas Gift: Mandelbrot Set Computation In Python](https://www.ibm.com/developerworks/community/blogs/jfp/entry/My_Christmas_Gift?lang=en),
    Jean Francois Puget, 2015.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我的圣诞礼物：Python中的曼德尔布罗特集计算](https://www.ibm.com/developerworks/community/blogs/jfp/entry/My_Christmas_Gift?lang=en)，Jean
    Francois Puget，2015。'
- en: '[Fast fractals with Python and Numpy](https://thesamovar.wordpress.com/2009/03/22/fast-fractals-with-python-and-numpy/),
    Dan Goodman, 2009.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用Python和Numpy快速处理分形](https://thesamovar.wordpress.com/2009/03/22/fast-fractals-with-python-and-numpy/)，Dan
    Goodman，2009。'
- en: '[Renormalizing the Mandelbrot Escape](http://linas.org/art-gallery/escape/escape.html),
    Linas Vepstas, 1997.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[重新归一化曼德尔布罗特逃逸](http://linas.org/art-gallery/escape/escape.html)，Linas Vepstas，1997。'
- en: '[Spatial vectorization](#id4)'
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[空间向量化](#id4)'
- en: Spatial vectorization refers to a situation where elements share the same computation
    but are in interaction with only a subgroup of other elements. This was already
    the case for the game of life example, but in some situations there is an added
    difficulty because the subgroup is dynamic and needs to be updated at each iteration.
    This the case, for example, in particle systems where particles interact mostly
    with local neighbours. This is also the case for "boids" that simulate flocking
    behaviors.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 空间向量化指的是元素共享相同的计算，但只与其他元素的一个子集交互。在“生命游戏”示例中已经是这种情况，但在某些情况下，由于子集是动态的并且需要在每次迭代中更新，因此会带来额外的困难。例如，在粒子系统中，粒子主要与本地邻居交互。对于模拟集群行为的“boids”也是如此。
- en: '**Figure 4.8**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.8**'
- en: Flocking birds are an example of self-organization in biology. Image by [Christoffer
    A Rasmussen](https://commons.wikimedia.org/wiki/File:Fugle,_ørnsø_073.jpg), 2012.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 集群鸟类是生物学中自组织的例子。图片由[Christoffer A Rasmussen](https://commons.wikimedia.org/wiki/File:Fugle,_ørnsø_073.jpg)，2012年拍摄。
- en: '![img/7b37fde927b910d7cbe8fb3dcbf545d4.png](img/7b37fde927b910d7cbe8fb3dcbf545d4.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![img/7b37fde927b910d7cbe8fb3dcbf545d4.png](img/7b37fde927b910d7cbe8fb3dcbf545d4.png)'
- en: '[Boids](#id4)'
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Boids](#id4)'
- en: Note
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Excerpt from the Wikipedia entry [Boids](https://en.wikipedia.org/wiki/Boids)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 来自维基百科条目[Boids](https://en.wikipedia.org/wiki/Boids)的摘录
- en: Boids is an artificial life program, developed by Craig Reynolds in 1986, which
    simulates the flocking behaviour of birds. The name "boid" corresponds to a shortened
    version of "bird-oid object", which refers to a bird-like object.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Boids是一个由克雷格·雷诺兹在1986年开发的人工生命程序，它模拟了鸟类的集群行为。名称“boid”是“bird-oid object”（鸟形对象）的缩写，指的是类似鸟的对象。
- en: 'As with most artificial life simulations, Boids is an example of emergent behavior;
    that is, the complexity of Boids arises from the interaction of individual agents
    (the boids, in this case) adhering to a set of simple rules. The rules applied
    in the simplest Boids world are as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数人工生命模拟一样，Boids是一个涌现行为的例子；也就是说，Boids的复杂性源于遵循一组简单规则的个人代理（在这种情况下是boids）的交互。在最简单的Boids世界中应用的规则如下：
- en: '**separation**: steer to avoid crowding local flock-mates'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离**：避免拥挤本地鸟群成员'
- en: '**alignment**: steer towards the average heading of local flock-mates'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐**：朝向本地鸟群成员的平均航向'
- en: '**cohesion**: steer to move toward the average position (center of mass) of
    local flock-mates'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凝聚**：朝向本地鸟群成员的平均位置（质心）移动'
- en: '**Figure 4.9**'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.9**'
- en: Boids are governed by a set of three local rules (separation, cohesion and alignment)
    that serve as computing velocity and acceleration.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Boids受三个局部规则（分离、凝聚和对齐）的支配，这些规则作为计算速度和加速度。
- en: '![img/c8b3883aeb2fb8322a4b531ca31ccaed.png](img/c8b3883aeb2fb8322a4b531ca31ccaed.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![img/c8b3883aeb2fb8322a4b531ca31ccaed.png](img/c8b3883aeb2fb8322a4b531ca31ccaed.png)'
- en: '[Python implementation](#id4)'
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Python实现](#id4)'
- en: 'Since each boid is an autonomous entity with several properties such as position
    and velocity, it seems natural to start by writing a Boid class:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个Boid都是一个具有位置和速度等几个属性的自主实体，因此从编写Boid类开始似乎是自然的：
- en: '[PRE56]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `vec2` object is a very simple class that handles all common vector operations
    with 2 components. It will save us some writing in the main `Boid` class. Note
    that there are some vector packages in the Python Package Index, but that would
    be overkill for such a simple example.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`vec2`对象是一个处理所有常见2分量向量操作的非常简单的类。它将在主`Boid`类中为我们节省一些编写工作。请注意，Python包索引中有些向量包，但对于这样一个简单的例子来说，这将是过度设计。'
- en: 'Boid is a difficult case for regular Python because a boid has interaction
    with local neighbours. However, and because boids are moving, to find such local
    neighbours requires computing at each time step the distance to each and every
    other boid in order to sort those which are in a given interaction radius. The
    prototypical way of writing the three rules is thus something like:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规Python来说，Boid是一个难题，因为Boid与本地邻居有交互。然而，由于Boids是移动的，要找到这样的本地邻居，需要在每个时间步计算每个Boid与其他每个Boid的距离，以便对那些在给定交互半径内的Boid进行排序。因此，编写三个规则的原型方式如下：
- en: '[PRE57]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Full sources are given in the references section below, it would be too long
    to describe it here and there is no real difficulty.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码在下面的参考文献部分给出，在这里描述它将太长，而且没有真正的困难。
- en: 'To complete the picture, we can also create a `Flock` object:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整地描述，我们还可以创建一个`Flock`对象：
- en: '[PRE58]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Using this approach, we can have up to 50 boids until the computation time becomes
    too slow for a smooth animation. As you may have guessed, we can do much better
    using numpy, but let me first point out the main problem with this Python implementation.
    If you look at the code, you will certainly notice there is a lot of redundancy.
    More precisely, we do not exploit the fact that the Euclidean distance is reflexive,
    that is, |*x* − *y*| = |*y* − *x*|. In this naive Python implementation, each
    rule (function) computes *n*² distances while (*n*²)/(2) would be sufficient if
    properly cached. Furthermore, each rule re-computes every distance without caching
    the result for the other functions. In the end, we are computing 3*n*² distances
    instead of (*n*²)/(2).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以有高达50个boids，直到计算时间变得太慢，无法进行平滑动画。正如你可能猜到的，我们可以使用numpy做得更好，但让我首先指出这个Python实现的主要问题。如果你查看代码，你肯定会注意到有很多冗余。更确切地说，我们没有利用欧几里得距离是自反的这一事实，即
    |*x* − *y*| = |*y* − *x*|。在这个原始的Python实现中，每个规则（函数）计算 *n*² 个距离，而如果适当缓存，(*n*²)/(2)
    就足够了。此外，每个规则都会重新计算每个距离，而不缓存其他函数的结果。最终，我们计算了 3*n*² 个距离，而不是 (*n*²)/(2)。
- en: '[Numpy implementation](#id4)'
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Numpy实现](#id4)'
- en: 'As you might expect, the numpy implementation takes a different approach and
    we''ll gather all our boids into a `position` array and a `velocity` array:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，numpy实现采取了不同的方法，我们将把所有的boids收集到一个`position`数组和`velocity`数组中：
- en: '[PRE59]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The first step is to compute the local neighborhood for all boids, and for
    this we need to compute all paired distances:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是计算所有boids的局部邻域，为此我们需要计算所有配对距离：
- en: '[PRE60]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We could have used the scipy [cdist](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html)
    but we'll need the `dx` and `dy` arrays later. Once those have been computed,
    it is faster to use the [hypot](https://docs.scipy.org/doc/numpy/reference/generated/numpy.hypot.html)
    method. Note that distance shape is `(n, n)` and each line relates to one boid,
    i.e. each line gives the distance to all other boids (including self).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用scipy的[cdist](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html)，但我们需要稍后使用`dx`和`dy`数组。一旦这些数组被计算出来，使用[hypot](https://docs.scipy.org/doc/numpy/reference/generated/numpy.hypot.html)方法会更快。请注意，距离形状是`(n,
    n)`，每一行都对应一个boid，即每一行给出了到所有其他boids（包括自身）的距离。
- en: From theses distances, we can now compute the local neighborhood for each of
    the three rules, taking advantage of the fact that we can mix them together. We
    can actually compute a mask for distances that are strictly positive (i.e. have
    no self-interaction) and multiply it with other distance masks.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些距离中，我们现在可以计算每个三个规则的局部邻域，利用我们可以混合它们的事实。实际上，我们可以计算一个严格正（即没有自我交互）的距离掩码，并将其与其他距离掩码相乘。
- en: Note
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If we suppose that boids cannot occupy the same position, how can you compute
    `mask_0` more efficiently?
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设boids不能占据相同的位置，你如何更有效地计算`mask_0`？
- en: '[PRE61]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Then, we compute the number of neighbours within the given radius and we ensure
    it is at least 1 to avoid division by zero.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们计算给定半径内的邻居数量，并确保它至少为1，以避免除以零。
- en: '[PRE62]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We''re ready to write our three rules:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好编写我们的三个规则：
- en: '**Alignment**'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '**对齐**'
- en: '[PRE63]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**Cohesion**'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**凝聚力**'
- en: '[PRE64]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**Separation**'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '**分离**'
- en: '[PRE65]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'All three resulting steerings (separation, alignment & cohesion) need to be
    limited in magnitude. We leave this as an exercise for the reader. Combination
    of these rules is straightforward as well as the resulting update of velocity
    and position:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的三个结果导向（分离、对齐和凝聚力）都需要限制其幅度。我们将此作为读者的练习。这些规则的组合以及速度和位置的更新都是简单直接的：
- en: '[PRE66]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We finally visualize the result using a custom oriented scatter plot.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终使用自定义定向散点图来可视化结果。
- en: '**Figure 4.10**'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.10**'
- en: Boids is an artificial life program, developed by Craig Reynolds in 1986, which
    simulates the flocking behaviour of birds.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Boids 是一个由克雷格·雷诺兹在1986年开发的人工生命程序，它模拟了鸟类的集群行为。
- en: <https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/boids.mp4>
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: <https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/boids.mp4>
- en: Your browser does not support the video tag.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 您的浏览器不支持视频标签。
- en: '[Exercise](#id4)'
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[练习](#id4)'
- en: 'We are now ready to visualize our boids. The easiest way is to use the matplotlib
    animation function and a scatter plot. Unfortunately, scatters cannot be individually
    oriented and we need to make our own objects using a matplotlib `PathCollection`.
    A simple triangle path can be defined as:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以可视化我们的鸟群了。最简单的方法是使用 matplotlib 动画函数和散点图。不幸的是，散点图不能单独定向，我们需要使用 matplotlib
    的 `PathCollection` 创建自己的对象。一个简单的三角形路径可以定义为：
- en: '[PRE67]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This path can be repeated several times inside an array and each triangle can
    be made independent.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路径可以在数组内部重复多次，并且每个三角形都可以独立。
- en: '[PRE68]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We now have a `(n,4,2)` array for vertices and a `(n,4)` array for codes representing
    `n` boids. We are interested in manipulating the vertices array to reflect the
    translation, scaling and rotation of each of the `n` boids.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个 `(n,4,2)` 的顶点数组和一个 `(n,4)` 的数组来表示 `n` 个鸟群，我们感兴趣的是操作顶点数组以反映每个 `n` 个鸟群的平移、缩放和旋转。
- en: Note
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Rotate is really tricky.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转确实很棘手。
- en: How would you write the `translate`, `scale` and `rotate` functions ?
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何编写 `translate`、`scale` 和 `rotate` 函数？
- en: '[Sources](#id4)'
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[来源](#id4)'
- en: '[boid_python.py](code/boid_python.py)'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[boid_python.py](code/boid_python.py)'
- en: '[boid_numpy.py](code/boid_numpy.py) (solution to the exercise)'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[boid_numpy.py](code/boid_numpy.py)（练习的解决方案）'
- en: '[References](#id4)'
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[参考文献](#id4)'
- en: '[Flocking](https://processing.org/examples/flocking.html), Daniel Shiffman,
    2010.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[鸟群](https://processing.org/examples/flocking.html)，Daniel Shiffman，2010。'
- en: '[Flocks, herds and schools: A distributed behavioral model](http://www.red3d.com/cwr/boids/),
    Craig Reynolds, SIGGRAPH, 1987'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[鸟群、牧群和学校：一种分布式行为模型](http://www.red3d.com/cwr/boids/)，Craig Reynolds，SIGGRAPH，1987'
- en: '[Conclusion](#id4)'
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[结论](#id4)'
- en: 'We''ve seen through these examples three forms of code vectorization:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些示例，我们已经看到了三种代码向量化形式：
- en: Uniform vectorization where elements share the same computation unconditionally
    and for the same duration.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均匀向量化，其中元素无条件且在相同时间内共享相同的计算。
- en: Temporal vectorization where elements share the same computation but necessitate
    a different number of iterations.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间向量化，其中元素共享相同的计算，但需要不同数量的迭代。
- en: Spatial vectorization where elements share the same computation but on dynamic
    spatial arguments.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间向量化，其中元素共享相同的计算，但基于动态空间参数。
- en: And there are probably many more forms of such direct code vectorization. As
    explained before, this kind of vectorization is one of the most simple even though
    we've seen it can be really tricky to implement and requires some experience,
    some help or both. For example, the solution to the boids exercise was provided
    by [Divakar](http://stackoverflow.com/users/3293881/divakar) on [stack overflow](http://stackoverflow.com/questions/40822983/multiple-individual-2d-rotation-at-once)
    after having explained my problem.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有更多这样的直接代码向量化形式。正如之前解释的，这种向量化是最简单的一种，尽管我们看到了它实施起来可能非常棘手，需要一些经验，一些帮助，或者两者都需要。例如，鸟群练习的解决方案是由
    [Divakar](http://stackoverflow.com/users/3293881/divakar) 在 [Stack Overflow](http://stackoverflow.com/questions/40822983/multiple-individual-2d-rotation-at-once)
    上提供的，在解释了我的问题之后。
- en: '[Problem vectorization](#table-of-contents)'
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[问题向量化](#table-of-contents)'
- en: '**Contents**'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录**'
- en: '[Introduction](#id19)'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[引言](#id19)'
- en: '[Path finding](#path-finding)'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[路径查找](#path-finding)'
- en: '[Building a maze](#building-a-maze)'
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[构建迷宫](#building-a-maze)'
- en: '[Breadth-first](#breadth-first)'
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[广度优先搜索](#breadth-first)'
- en: '[Bellman-Ford method](#bellman-ford-method)'
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Bellman-Ford 方法](#bellman-ford-method)'
- en: '[Sources](#id20)'
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[来源](#id20)'
- en: '[References](#id21)'
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[参考文献](#id21)'
- en: '[Fluid Dynamics](#fluid-dynamics)'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[流体动力学](#fluid-dynamics)'
- en: '[Lagrangian vs Eulerian method](#lagrangian-vs-eulerian-method)'
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[拉格朗日方法与欧拉方法](#lagrangian-vs-eulerian-method)'
- en: '[Numpy implementation](#id22)'
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Numpy 实现](#id22)'
- en: '[Sources](#id23)'
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[来源](#id23)'
- en: '[References](#id24)'
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[参考文献](#id24)'
- en: '[Blue noise sampling](#blue-noise-sampling)'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[蓝色噪声采样](#blue-noise-sampling)'
- en: '[DART method](#dart-method)'
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[DART 方法](#dart-method)'
- en: '[Bridson method](#bridson-method)'
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Bridson 方法](#bridson-method)'
- en: '[Sources](#id25)'
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[来源](#id25)'
- en: '[References](#id26)'
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[参考文献](#id26)'
- en: '[Conclusion](#id27)'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结论](#id27)'
- en: '[Introduction](#id18)'
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[引言](#id18)'
- en: Problem vectorization is much harder than code vectorization because it means
    that you fundamentally have to rethink your problem in order to make it vectorizable.
    Most of the time this means you have to use a different algorithm to solve your
    problem or even worse... to invent a new one. The difficulty is thus to think
    out-of-the-box.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 问题向量化比代码向量化要难得多，因为它意味着你从根本上必须重新思考你的问题，以便使其可向量化。大多数情况下，这意味着你必须使用不同的算法来解决你的问题，或者更糟糕的是……发明一个新的算法。因此，困难在于跳出思维定势。
- en: 'To illustrate this, let''s consider a simple problem where given two vectors
    `X` and `Y`, we want to compute the sum of `X[i]*Y[j]` for all pairs of indices
    `i`, `j`. One simple and obvious solution is to write:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们考虑一个简单的问题，给定两个向量 `X` 和 `Y`，我们想要计算所有索引对 `i`，`j` 的 `X[i]*Y[j]` 的和。一个简单且明显的方法是写出：
- en: '[PRE69]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'However, this first and naïve implementation requires two loops and we already
    know it will be slow:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个最初且简单的方法需要两个循环，而我们已知它将会很慢：
- en: '[PRE70]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'How to vectorize the problem then? If you remember your linear algebra course,
    you may have identified the expression `X[i] * Y[j]` to be very similar to a matrix
    product expression. So maybe we could benefit from some numpy speedup. One wrong
    solution would be to write:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何向量化这个问题呢？如果你记得你的线性代数课程，你可能已经识别出表达式 `X[i] * Y[j]` 与矩阵乘法表达式非常相似。所以也许我们可以从一些
    numpy 速度提升中受益。一个错误的方法是写出：
- en: '[PRE71]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This is wrong because the `X*Y` expression will actually compute a new vector
    `Z` such that `Z[i] = X[i] * Y[i]` and this is not what we want. Instead, we can
    exploit numpy broadcasting by first reshaping the two vectors and then multiply
    them:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这是错误的，因为 `X*Y` 表达式实际上会计算一个新的向量 `Z`，使得 `Z[i] = X[i] * Y[i]`，而这不是我们想要的。相反，我们可以利用
    numpy 的广播功能，首先重塑两个向量，然后相乘：
- en: '[PRE72]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here we have `Z[i,j] == X[i,0]*Y[0,j]` and if we take the sum over each elements
    of `Z`, we get the expected result. Let''s see how much speedup we gain in the
    process:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有 `Z[i,j] == X[i,0]*Y[0,j]`，如果我们对 `Z` 的每个元素求和，我们就能得到预期的结果。让我们看看在这个过程中我们获得了多少速度提升：
- en: '[PRE73]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This is better, we gained a factor of ~150\. But we can do much better.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这更好，我们得到了一个因子 ~150。但我们还能做得更好。
- en: 'If you look again and more closely at the pure Python version, you can see
    that the inner loop is using `X[i]` that does not depend on the `j` index, meaning
    it can be removed from the inner loop. Code can be rewritten as:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次仔细地看纯 Python 版本，你会发现内循环使用了 `X[i]`，它不依赖于 `j` 索引，这意味着它可以从内循环中移除。代码可以重写为：
- en: '[PRE74]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'But since the inner loop does not depend on the `i` index, we might as well
    compute it only once:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于内循环不依赖于 `i` 索引，我们不妨只计算一次：
- en: '[PRE75]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Not so bad, we have removed the inner loop, meaning with transform a *O*(*n*²)
    complexity into *O*(*n*) complexity. Using the same approach, we can now write:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错，我们移除了内循环，这意味着将 *O*(*n*²) 复杂度转换为 *O*(*n*) 复杂度。使用相同的方法，我们现在可以写出：
- en: '[PRE76]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, having realized we only need the product of the sum over `X` and `Y`
    respectively, we can benefit from the `np.sum` function and write:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，意识到我们只需要 `X` 和 `Y` 的和的乘积，我们可以利用 `np.sum` 函数并写出：
- en: '[PRE77]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'It is shorter, clearer and much, much faster:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 它更短，更清晰，并且快得多：
- en: '[PRE78]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We have indeed reformulated our problem, taking advantage of the fact that
    ∑[*ij*]*X*[*i*]*Y*[*j*] = ∑[*i*]*X*[*i*]∑[*j*]*Y*[*j*] and we''ve learned in the
    meantime that there are two kinds of vectorization: code vectorization and problem
    vectorization. The latter is the most difficult but the most important because
    this is where you can expect huge gains in speed. In this simple example, we gain
    a factor of 150 with code vectorization but we gained a factor of 70,000 with
    problem vectorization, just by writing our problem differently (even though you
    cannot expect such a huge speedup in all situations). However, code vectorization
    remains an important factor, and if we rewrite the last solution the Python way,
    the improvement is good but not as much as in the numpy version:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实重新表述了我们的问题，利用了 ∑[*ij*]*X*[*i*]*Y*[*j*] = ∑[*i*]*X*[*i*]∑[*j*]*Y*[*j*] 的事实，并且在同时我们了解到有两种向量化：代码向量和问题向量化。后者是最难的，但也是最重要的，因为这是你可以期望在速度上获得巨大提升的地方。在这个简单的例子中，我们通过代码向量化获得了
    150 倍的因子，但通过问题向量化我们获得了 70,000 倍的因子，仅仅是通过以不同的方式编写我们的问题（尽管你不能期望在所有情况下都能获得如此巨大的速度提升）。然而，代码向量化仍然是一个重要的因素，如果我们用
    Python 的方式重写最后一个解决方案，改进是好的，但不如 numpy 版本那么好：
- en: '[PRE79]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This new Python version is much faster than the previous Python version, but
    still, it is 50 times slower than the numpy version:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的 Python 版本比之前的 Python 版本快得多，但仍然，它比 numpy 版本慢 50 倍：
- en: '[PRE80]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[Path finding](#id18)'
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[寻路](#id18)'
- en: 'Path finding is all about finding the shortest path in a graph. This can be
    split in two distinct problems: to find a path between two nodes in a graph and
    to find the shortest path. We''ll illustrate this through path finding in a maze.
    The first task is thus to build a maze.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 寻路问题就是在一个图中找到最短路径。这可以分为两个独立的问题：在一个图中找到两个节点之间的路径，以及找到最短路径。我们将通过迷宫中的寻路来展示这一点。因此，第一个任务是构建一个迷宫。
- en: '**Figure 5.1**'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.1**'
- en: A hedge maze at Longleat stately home in England. Image by [Prince Rurik](https://commons.wikimedia.org/wiki/File:Longleat_maze.jpg),
    2005.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 位于英国Longleat庄园的树篱迷宫。图片由[Prince Rurik](https://commons.wikimedia.org/wiki/File:Longleat_maze.jpg)，2005年拍摄。
- en: '![img/760876f935b5a4bdc2877549c1cabec9.png](img/760876f935b5a4bdc2877549c1cabec9.png)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![img/760876f935b5a4bdc2877549c1cabec9.png](img/760876f935b5a4bdc2877549c1cabec9.png)'
- en: '[Building a maze](#id18)'
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[构建迷宫](#id18)'
- en: There exist [many maze generation algorithms](https://en.wikipedia.org/wiki/Maze_generation_algorithm)
    but I tend to prefer the one I've been using for several years but whose origin
    is unknown to me. I've added the code in the cited wikipedia entry. Feel free
    to complete it if you know the original author. This algorithm works by creating
    `n` (density) islands of length `p` (complexity). An island is created by choosing
    a random starting point with odd coordinates, then a random direction is chosen.
    If the cell two steps in a given direction is free, then a wall is added at both
    one step and two steps in this direction. The process is iterated for `n` steps
    for this island. `p` islands are created. `n` and `p` are expressed as `float`
    to adapt them to the size of the maze. With a low complexity, islands are very
    small and the maze is easy to solve. With low density, the maze has more "big
    empty rooms".
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着[许多迷宫生成算法](https://en.wikipedia.org/wiki/Maze_generation_algorithm)，但我倾向于使用我已经使用了几年的算法，但其起源对我来说是未知的。我已经在引用的维基百科条目中添加了代码。如果你知道原始作者，请随时完善它。该算法通过创建长度为
    `p`（复杂度）的 `n`（密度）岛屿来工作。岛屿是通过选择具有奇数坐标的随机起始点来创建的，然后选择一个随机方向。如果在给定方向上两步的单元格是空的，那么在这个方向上一步和两步都添加墙壁。这个过程为这个岛屿迭代
    `n` 步。创建 `p` 个岛屿。`n` 和 `p` 被表示为 `float` 以适应迷宫的大小。低复杂度时，岛屿非常小，迷宫容易解决。低密度时，迷宫有更多的“大空房间”。
- en: '[PRE81]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here is an animation showing the generation process.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个动画展示了生成过程。
- en: '**Figure 5.2**'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.2**'
- en: Progressive maze building with complexity and density control.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 带有复杂度和密度控制的渐进式迷宫构建。
- en: <https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/maze-build.mp4>
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: <https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/maze-build.mp4>
- en: Your browser does not support the video tag.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 您的浏览器不支持视频标签。
- en: '[Breadth-first](#id18)'
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[广度优先](#id18)'
- en: The breadth-first (as well as depth-first) search algorithm addresses the problem
    of finding a path between two nodes by examining all possibilities starting from
    the root node and stopping as soon as a solution has been found (destination node
    has been reached). This algorithm runs in linear time with complexity in *O*(|*V*| + |*E*|)
    (where *V* is the number of vertices, and *E* is the number of edges). Writing
    such an algorithm is not especially difficult, provided you have the right data
    structure. In our case, the array representation of the maze is not the most well-suited
    and we need to transform it into an actual graph as proposed by [Valentin Bryukhanov](http://bryukh.com).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先（以及深度优先）搜索算法通过从根节点开始检查所有可能性，并在找到解决方案（目标节点）时停止，来解决在两个节点之间找到路径的问题。此算法以线性时间运行，其复杂度为
    *O*(|*V*| + |*E*|)（其中 *V* 是顶点数，*E* 是边数）。只要你有合适的数据结构，编写这样的算法并不特别困难。在我们的情况下，迷宫的数组表示并不是最合适的，我们需要将其转换为[Valentin
    Bryukhanov](http://bryukh.com)提出的实际图。
- en: '[PRE82]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Note
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If we had used the depth-first algorithm, there is no guarantee to find the
    shortest path, only to find a path (if it exists).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用了深度优先算法，我们无法保证找到最短路径，只能找到一条路径（如果存在的话）。
- en: 'Once this is done, writing the breadth-first algorithm is straightforward.
    We start from the starting node and we visit nodes at the current depth only (breadth-first,
    remember?) and we iterate the process until reaching the final node, if possible.
    The question is then: do we get the shortest path exploring the graph this way?
    In this specific case, "yes", because we don''t have an edge-weighted graph, i.e.
    all the edges have the same weight (or cost).'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这个步骤，编写广度优先算法就很简单了。我们从起始节点开始，只访问当前深度的节点（记住，是广度优先）并迭代这个过程，直到达到最终节点（如果可能的话）。问题是：通过这种方式探索图，我们能得到最短路径吗？在这个特定情况下，“是的”，因为我们没有带权重的图，即所有边都有相同的权重（或成本）。
- en: '[PRE83]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[Bellman-Ford method](#id18)'
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Bellman-Ford方法](#id18)'
- en: The Bellman–Ford algorithm is an algorithm that is able to find the optimal
    path in a graph using a diffusion process. The optimal path is found by ascending
    the resulting gradient. This algorithm runs in quadratic time *O*(|*V*||*E*|)
    (where *V* is the number of vertices, and *E* is the number of edges). However,
    in our simple case, we won't hit the worst case scenario. The algorithm is illustrated
    below (reading from left to right, top to bottom). Once this is done, we can ascend
    the gradient from the starting node. You can check on the figure that this leads
    to the shortest path.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: Bellman-Ford算法是一种能够通过扩散过程在图中找到最优路径的算法。最优路径是通过沿着产生的梯度上升找到的。这个算法的时间复杂度是二次的 *O*(|*V*||*E*|)（其中
    *V* 是顶点的数量，*E* 是边的数量）。然而，在我们的简单情况下，我们不会遇到最坏的情况。算法如图所示（从左到右，从上到下阅读）。一旦完成，我们就可以从起始节点开始沿着梯度上升。您可以在图中看到这会导致最短路径。
- en: '**Figure 5.3**'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.3**'
- en: Value iteration algorithm on a simple maze. Once entrance has been reached,
    it is easy to find the shortest path by ascending the value gradient.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单迷宫上的值迭代算法。一旦到达入口，通过向上爬升值梯度很容易找到最短路径。
- en: '![img/23273028ed7c308c5053f969e41f7471.png](img/23273028ed7c308c5053f969e41f7471.png)
    ![img/0bd752138eda95a4a062032e9ef4100e.png](img/0bd752138eda95a4a062032e9ef4100e.png)
    ![img/e33abc8e918425a64e9453cf0a651e41.png](img/e33abc8e918425a64e9453cf0a651e41.png)
    ![img/89b5382abc5d8c757df5ae510473f636.png](img/89b5382abc5d8c757df5ae510473f636.png)
    ![img/28a4fc5dbe7ab7c7cd41be569274fec7.png](img/28a4fc5dbe7ab7c7cd41be569274fec7.png)
    ![img/c980df26414ea32c86e51335a027d6b9.png](img/c980df26414ea32c86e51335a027d6b9.png)
    ![img/37b7fa5200493002586ba83473dfa57f.png](img/37b7fa5200493002586ba83473dfa57f.png)
    ![img/2cd153d230f00b7cdb9e8c87ee555fad.png](img/2cd153d230f00b7cdb9e8c87ee555fad.png)
    ![img/0970a7d64f8fce9622ca4d1bf1fb440d.png](img/0970a7d64f8fce9622ca4d1bf1fb440d.png)
    ![img/a731b6cc95670022e66d5585c8d7e130.png](img/a731b6cc95670022e66d5585c8d7e130.png)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![img/23273028ed7c308c5053f969e41f7471.png](img/23273028ed7c308c5053f969e41f7471.png)
    ![img/0bd752138eda95a4a062032e9ef4100e.png](img/0bd752138eda95a4a062032e9ef4100e.png)
    ![img/e33abc8e918425a64e9453cf0a651e41.png](img/e33abc8e918425a64e9453cf0a651e41.png)
    ![img/89b5382abc5d8c757df5ae510473f636.png](img/89b5382abc5d8c757df5ae510473f636.png)
    ![img/28a4fc5dbe7ab7c7cd41be569274fec7.png](img/28a4fc5dbe7ab7c7cd41be569274fec7.png)
    ![img/c980df26414ea32c86e51335a027d6b9.png](img/c980df26414ea32c86e51335a027d6b9.png)
    ![img/37b7fa5200493002586ba83473dfa57f.png](img/37b7fa5200493002586ba83473dfa57f.png)
    ![img/2cd153d230f00b7cdb9e8c87ee555fad.png](img/2cd153d230f00b7cdb9e8c87ee555fad.png)
    ![img/0970a7d64f8fce9622ca4d1bf1fb440d.png](img/0970a7d64f8fce9622ca4d1bf1fb440d.png)
    ![img/a731b6cc95670022e66d5585c8d7e130.png](img/a731b6cc95670022e66d5585c8d7e130.png)'
- en: We start by setting the exit node to the value 1, while every other node is
    set to 0, except the walls. Then we iterate a process such that each cell's new
    value is computed as the maximum value between the current cell value and the
    discounted (`gamma=0.9` in the case below) 4 neighbour values. The process starts
    as soon as the starting node value becomes strictly positive.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将出口节点设置为值1，而其他所有节点都设置为0，除了墙壁。然后我们迭代一个过程，使得每个单元格的新值是当前单元格值和折扣（以下情况中`gamma=0.9`）的4个邻居值之间的最大值。一旦起始节点值变为严格正值，这个过程就开始。
- en: 'The numpy implementation is straightforward if we take advantage of the `generic_filter`
    (from `scipy.ndimage`) for the diffusion process:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们利用`generic_filter`（来自`scipy.ndimage`）进行扩散过程，NumPy的实现就很简单：
- en: '[PRE84]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'But in this specific case, it is rather slow. We''d better cook-up our own
    solution, reusing part of the game of life code:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这个特定情况下，它相当慢。我们最好自己想出一个解决方案，重用生命游戏代码的一部分：
- en: '[PRE85]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Once this is done, we can ascend the gradient to find the shortest path as
    illustrated on the figure below:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们就可以沿着梯度上升找到如图所示的最近路径：
- en: '**Figure 5.4**'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.4**'
- en: Path finding using the Bellman-Ford algorithm. Gradient colors indicate propagated
    values from the end-point of the maze (bottom-right). Path is found by ascending
    gradient from the goal.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Bellman-Ford算法进行路径查找。渐变颜色表示从迷宫的终点（右下角）传播的值。路径是通过从目标向上爬升梯度找到的。
- en: '![img/d808f0dc7c41b6768554a47834b568e9.png](img/d808f0dc7c41b6768554a47834b568e9.png)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![img/d808f0dc7c41b6768554a47834b568e9.png](img/d808f0dc7c41b6768554a47834b568e9.png)'
- en: '[Sources](#id18)'
  id: totrans-525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[来源](#id18)'
- en: '[maze_build.py](code/maze_build.py)'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[maze_build.py](code/maze_build.py)'
- en: '[maze_numpy.py](code/maze_numpy.py)'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[maze_numpy.py](code/maze_numpy.py)'
- en: '[References](#id18)'
  id: totrans-528
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[参考文献](#id18)'
- en: '[Labyrinth Algorithms](http://bryukh.com/labyrinth-algorithms/), Valentin Bryukhanov,
    2014.'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[迷宫算法](http://bryukh.com/labyrinth-algorithms/), 瓦伦丁·布里亚库诺夫，2014.'
- en: '[Fluid Dynamics](#id18)'
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[流体动力学](#id18)'
- en: '**Figure 5.5**'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.5**'
- en: Hydrodynamic flow at two different zoom levels, Neckar river, Heidelberg, Germany.
    Image by [Steven Mathey](https://commons.wikimedia.org/wiki/File:Self_Similar_Turbulence.png),
    2012.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 德国海德堡内卡河在不同放大级别下的流体动力学流动。图片由[Steven Mathey](https://commons.wikimedia.org/wiki/File:Self_Similar_Turbulence.png)，2012年拍摄。
- en: '![img/89e537df1608439e1d4339ff3bad9a78.png](img/89e537df1608439e1d4339ff3bad9a78.png)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![img/89e537df1608439e1d4339ff3bad9a78.png](img/89e537df1608439e1d4339ff3bad9a78.png)'
- en: '[Lagrangian vs Eulerian method](#id18)'
  id: totrans-534
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[拉格朗日与欧拉方法](#id18)'
- en: Note
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Excerpt from the Wikipedia entry on the [Lagrangian and Eulerian specification](https://en.wikipedia.org/wiki/Lagrangian_and_Eulerian_specification_of_the_flow_field)
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 来自维基百科关于[拉格朗日和欧拉流场指定](https://en.wikipedia.org/wiki/Lagrangian_and_Eulerian_specification_of_the_flow_field)条目的摘录
- en: In classical field theory, the Lagrangian specification of the field is a way
    of looking at fluid motion where the observer follows an individual fluid parcel
    as it moves through space and time. Plotting the position of an individual parcel
    through time gives the pathline of the parcel. This can be visualized as sitting
    in a boat and drifting down a river.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典场论中，场的拉格朗日指定是一种观察流体运动的方法，观察者跟随单个流体包随其在空间和时间中的移动。通过时间绘制单个包的位置给出包的路径线。这可以想象为坐在船上，随河流漂流。
- en: The Eulerian specification of the flow field is a way of looking at fluid motion
    that focuses on specific locations in the space through which the fluid flows
    as time passes. This can be visualized by sitting on the bank of a river and watching
    the water pass the fixed location.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉流场指定是一种观察流体运动的方法，它关注随着时间流逝，流体流经空间中的特定位置。这可以通过坐在河岸上，观察水流过固定位置来可视化。
- en: In other words, in the Eulerian case, you divide a portion of space into cells
    and each cell contains a velocity vector and other information, such as density
    and temperature. In the Lagrangian case, we need particle-based physics with dynamic
    interactions and generally we need a high number of particles. Both methods have
    advantages and disadvantages and the choice between the two methods depends on
    the nature of your problem. Of course, you can also mix the two methods into a
    hybrid method.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在欧拉方法中，你将空间的一部分划分为单元格，每个单元格包含一个速度向量和其他信息，例如密度和温度。在拉格朗日方法中，我们需要基于粒子的物理，具有动态交互，通常需要大量的粒子。这两种方法都有优缺点，选择哪种方法取决于你问题的本质。当然，你也可以将这两种方法混合成一种混合方法。
- en: However, the biggest problem for particle-based simulation is that particle
    interaction requires finding neighbouring particles and this has a cost as we've
    seen in the boids case. If we target Python and numpy only, it is probably better
    to choose the Eulerian method since vectorization will be almost trivial compared
    to the Lagrangian method.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，基于粒子的模拟最大的问题是粒子交互需要找到邻近的粒子，正如我们在boids案例中看到的那样，这会产生成本。如果我们只针对Python和numpy，那么选择欧拉方法可能更好，因为与拉格朗日方法相比，向量化几乎将是微不足道的。
- en: '[Numpy implementation](#id18)'
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Numpy实现](#id18)'
- en: I won't explain all the theory behind computational fluid dynamics because first,
    I cannot (I'm not an expert at all in this domain) and there are many resources
    online that explain this nicely (have a look at references below, especially tutorial
    by L. Barba). Why choose a computational fluid as an example then? Because results
    are (almost) always beautiful and fascinating. I couldn't resist (look at the
    movie below).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会解释计算流体动力学背后的所有理论，因为首先，我做不到（我对这个领域根本不是专家）而且网上有许多资源很好地解释了这一点（查看下面的参考文献，特别是L.
    Barba的教程）。那么为什么选择计算流体动力学作为例子呢？因为结果（几乎）总是美丽而迷人的。我无法抗拒（看看下面的电影）。
- en: We'll further simplify the problem by implementing a method from computer graphics
    where the goal is not correctness but convincing behavior. Jos Stam wrote a very
    nice article for SIGGRAPH 1999 describing a technique to have stable fluids over
    time (i.e. whose solution in the long term does not diverge). [Alberto Santini](https://github.com/albertosantini/python-fluid)
    wrote a Python replication a long time ago (using numarray!) such that I only
    had to adapt it to modern numpy and accelerate it a bit using modern numpy tricks.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过实施计算机图形学中的一个方法来进一步简化问题，该方法的目标不是正确性，而是令人信服的行为。Jos Stam为1999年的SIGGRAPH撰写了一篇非常好的文章，描述了一种在长时间内保持流体稳定的技术（即其长期解不会发散）。[Alberto
    Santini](https://github.com/albertosantini/python-fluid)很久以前（使用numarray！）编写了一个Python复制版本，这样我就只需要将其适配到现代numpy，并使用现代numpy技巧进行一点加速。
- en: I won't comment the code since it would be too long, but you can read the original
    paper as well as the explanation by [Philip Rideout](http://prideout.net/blog/?p=58)
    on his blog. Below are some movies I've made using this technique.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会对代码进行注释，因为它太长了，但您也可以阅读原始论文以及 [Philip Rideout](http://prideout.net/blog/?p=58)
    在他的博客上的解释。以下是我使用这种技术制作的几个电影。
- en: '**Figure 5.6**'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.6**'
- en: Smoke simulation using the stable fluids algorithm by Jos Stam. Right most video
    comes from the [glumpy](http://glumpy.github.io) package and is using the GPU
    (framebuffer operations, i.e. no OpenCL nor CUDA) for faster computations.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Jos Stam 的稳定流体算法进行的烟雾模拟。最右侧的视频来自 [glumpy](http://glumpy.github.io) 包，并使用
    GPU（帧缓冲区操作，即不使用 OpenCL 也不使用 CUDA）进行更快的计算。
- en: <https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/smoke-1.mp4>
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: <https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/smoke-1.mp4>
- en: Your browser does not support the video tag.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 您的浏览器不支持视频标签。
- en: <https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/smoke-2.mp4>
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: <https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/smoke-2.mp4>
- en: Your browser does not support the video tag.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 您的浏览器不支持视频标签。
- en: <https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/smoke-gpu.mp4>
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: <https://www.labri.fr/perso/nrougier/from-python-to-numpy/data/smoke-gpu.mp4>
- en: Your browser does not support the video tag.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 您的浏览器不支持视频标签。
- en: '[Sources](#id18)'
  id: totrans-553
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[源代码](#id18)'
- en: '[smoke_1.py](code/smoke_1.py)'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[smoke_1.py](code/smoke_1.py)'
- en: '[smoke_2.py](code/smoke_2.py)'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[smoke_2.py](code/smoke_2.py)'
- en: '[smoke_solver.py](code/smoke_solver.py)'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[smoke_solver.py](code/smoke_solver.py)'
- en: '[smoke_interactive.py](code/smoke_interactive.py)'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[smoke_interactive.py](code/smoke_interactive.py)'
- en: '[References](#id18)'
  id: totrans-558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[参考文献](#id18)'
- en: '[12 Steps to Navier-Stokes](https://github.com/barbagroup/CFDPython), Lorena
    Barba, 2013.'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12 步到纳维-斯托克斯方程](https://github.com/barbagroup/CFDPython), Lorena Barba, 2013.'
- en: '[Stable Fluids](http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/ns.pdf),
    Jos Stam, 1999.'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[稳定流体](http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/ns.pdf),
    Jos Stam, 1999.'
- en: '[Simple Fluid Simulation](http://prideout.net/blog/?p=58), Philip Rideout,
    2010'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简单流体模拟](http://prideout.net/blog/?p=58), Philip Rideout, 2010'
- en: '[Fast Fluid Dynamics Simulation on the GPU](http://http.developer.nvidia.com/GPUGems/gpugems_ch38.html),
    Mark Harris, 2004.'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在 GPU 上进行快速流体动力学模拟](http://http.developer.nvidia.com/GPUGems/gpugems_ch38.html),
    Mark Harris, 2004.'
- en: '[Animating Sand as a Fluid](https://www.cs.ubc.ca/%7Erbridson/docs/zhu-siggraph05-sandfluid.pdf),
    Yongning Zhu & Robert Bridson, 2005.'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将沙子作为流体进行动画](https://www.cs.ubc.ca/%7Erbridson/docs/zhu-siggraph05-sandfluid.pdf),
    Yongning Zhu & Robert Bridson, 2005.'
- en: '[Blue noise sampling](#id18)'
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[蓝色噪声采样](#id18)'
- en: Blue noise refers to sample sets that have random and yet uniform distributions
    with absence of any spectral bias. Such noise is very useful in a variety of graphics
    applications like rendering, dithering, stippling, etc. Many different methods
    have been proposed to achieve such noise, but the most simple is certainly the
    DART method.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色噪声指的是具有随机且均匀分布且没有任何频谱偏差的样本集。这种噪声在渲染、抖动、点彩等多种图形应用中非常有用。已经提出了许多不同的方法来实现这种噪声，但最简单的方法无疑是
    DART 方法。
- en: '**Figure 5.7**'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.7**'
- en: Detail of "The Starry Night", Vincent van Gogh, 1889\. The detail has been resampled
    using voronoi cells whose centers are a blue noise sample.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 文森特·梵高 1889 年的《星夜》的细节。细节已经使用 voronoi 单元中心为蓝色噪声样本进行重采样。
- en: '![img/b5243aadd074137f551ae1b47c8d5cc0.png](img/b5243aadd074137f551ae1b47c8d5cc0.png)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![img/b5243aadd074137f551ae1b47c8d5cc0.png](img/b5243aadd074137f551ae1b47c8d5cc0.png)'
- en: '[DART method](#id18)'
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[DART 方法](#id18)'
- en: The DART method is one of the earliest and simplest methods. It works by sequentially
    drawing uniform random points and only accepting those that lie at a minimum distance
    from every previous accepted sample. This sequential method is therefore extremely
    slow because each new candidate needs to be tested against previous accepted candidates.
    The more points you accept, the slower the method is. Let's consider the unit
    surface and a minimum radius `r` to be enforced between each point.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: DART 方法是最早且最简单的方法之一。它通过顺序地绘制均匀随机点，并且只接受那些与每个先前接受的样本保持最小距离的点。因此，这种顺序方法非常慢，因为每个新的候选点都需要与先前接受的候选点进行测试。你接受的点越多，该方法就越慢。让我们考虑单位表面和每个点之间要强制执行的半径
    `r`。
- en: Knowing that the densest packing of circles in the plane is the hexagonal lattice
    of the bee's honeycomb, we know this density is *d* = (1)/(6)*π*√(3) (in fact
    [I learned it](https://en.wikipedia.org/wiki/Circle_packing) while writing this
    book). Considering circles with radius *r*, we can pack at most (*d*)/(*π**r*²) = (√(3))/(6*r*²) = (1)/(2*r*²√(3)).
    We know the theoretical upper limit for the number of discs we can pack onto the
    surface, but we'll likely not reach this upper limit because of random placements.
    Furthermore, because a lot of points will be rejected after a few have been accepted,
    we need to set a limit on the number of successive failed trials before we stop
    the whole process.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 知道在平面上圆的密集排列是蜜蜂蜂巢的六边形晶格，我们知道这种密度是 *d* = (1)/(6)*π*√(3)（实际上 [我在写这本书时学到了这一点](https://en.wikipedia.org/wiki/Circle_packing)）。考虑半径为
    *r* 的圆，我们最多可以排列 (*d*)/(*π**r*²) = (√(3))/(6*r*²) = (1)/(2*r*²√(3)) 的圆。我们知道可以排列在表面上的圆片数量的理论上限，但我们可能不会达到这个上限，因为随机放置。此外，由于在几个点被接受之后，许多点将被拒绝，我们需要在停止整个过程之前设定连续失败尝试的数量上限。
- en: '[PRE86]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: I left as an exercise the vectorization of the DART method. The idea is to pre-compute
    enough uniform random samples as well as paired distances and to test for their
    sequential inclusion.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 我将 DART 方法的向量化留作练习。想法是预先计算足够的均匀随机样本以及成对距离，并测试它们的顺序包含。
- en: '[Bridson method](#id18)'
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Bridson 方法](#id18)'
- en: 'If the vectorization of the previous method poses no real difficulty, the speed
    improvement is not so good and the quality remains low and dependent on the `k`
    parameter. The higher, the better since it basically governs how hard to try to
    insert a new sample. But, when there is already a large number of accepted samples,
    only chance allows us to find a position to insert a new sample. We could increase
    the `k` value but this would make the method even slower without any guarantee
    in quality. It''s time to think out-of-the-box and luckily enough, Robert Bridson
    did that for us and proposed a simple yet efficient method:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前一种方法的向量化没有真正的困难，速度提升并不那么好，质量仍然很低，并且依赖于 `k` 参数。数值越高越好，因为它基本上控制了尝试插入新样本的难度。但是，当已经有大量样本被接受时，只有机会才能找到插入新样本的位置。我们可以增加
    `k` 值，但这会使方法变得更慢，而且没有任何质量保证。是时候跳出思维定式了，幸运的是，Robert Bridson 已经为我们做到了这一点，并提出了一个简单而有效的方法：
- en: '**Step 0**. Initialize an n-dimensional background grid for storing samples
    and accelerating spatial searches. We pick the cell size to be bounded by (*r*)/(√(*n*)),
    so that each grid cell will contain at most one sample, and thus the grid can
    be implemented as a simple n-dimensional array of integers: the default −1 indicates
    no sample, a non-negative integer gives the index of the sample located in a cell.'
  id: totrans-576
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**步骤 0**. 初始化一个用于存储样本和加速空间搜索的 n 维背景网格。我们选择单元格大小为 (*r*)/(√(*n*))，这样每个网格单元格最多包含一个样本，因此网格可以作为一个简单的
    n 维整数数组实现：默认值 -1 表示没有样本，一个非负整数表示位于单元格中的样本索引。'
- en: ''
  id: totrans-577
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Step 1**. Select the initial sample, *x*[0], randomly chosen uniformly from
    the domain. Insert it into the background grid, and initialize the “active list”
    (an array of sample indices) with this index (zero).'
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**步骤 1**. 随机地从域中均匀选择初始样本 *x*[0]。将其插入到背景网格中，并用此索引（零）初始化“活动列表”（样本索引数组）。'
- en: ''
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Step 2**. While the active list is not empty, choose a random index from
    it (say *i*). Generate up to *k* points chosen uniformly from the spherical annulus
    between radius *r* and 2*r* around *x*[*i*]. For each point in turn, check if
    it is within distance *r* of existing samples (using the background grid to only
    test nearby samples). If a point is adequately far from existing samples, emit
    it as the next sample and add it to the active list. If after *k* attempts no
    such point is found, instead remove *i* from the active list.'
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**步骤 2**. 当活动列表不为空时，从其中随机选择一个索引（比如说 *i*）。生成最多 *k* 个点，这些点均匀地选择在半径 *r* 和 2*r*
    之间的球形环带中，围绕 *x*[*i*]。依次检查每个点，看它是否在现有样本距离 *r* 以内（使用背景网格仅测试附近的样本）。如果一个点足够远离现有样本，则将其作为下一个样本发射，并将其添加到活动列表中。如果在
    *k* 次尝试后没有找到这样的点，则从活动列表中删除 *i*。'
- en: Implementation poses no real problem and is left as an exercise for the reader.
    Note that not only is this method fast, but it also offers a better quality (more
    samples) than the DART method even with a high *k* parameter.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 实现没有真正的问题，留作读者的练习。请注意，这种方法不仅速度快，而且即使在高 *k* 参数下，也比 DART 方法提供更好的质量（更多样本）。
- en: '**Figure 5.8**'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.8**'
- en: Comparison of uniform, grid-jittered and Bridson sampling.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 均匀、网格抖动和Bridson采样的比较。
- en: '![img/3f0249fec14faeea13174847e8028b41.png](img/3f0249fec14faeea13174847e8028b41.png)'
  id: totrans-584
  prefs: []
  type: TYPE_IMG
  zh: '![img/3f0249fec14faeea13174847e8028b41.png](img/3f0249fec14faeea13174847e8028b41.png)'
- en: '[Sources](#id18)'
  id: totrans-585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[来源](#id18)'
- en: '[DART_sampling_python.py](code/DART_sampling_python.py)'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[DART_sampling_python.py](code/DART_sampling_python.py)'
- en: '[DART_sampling_numpy.py](code/DART_sampling_numpy.py) (solution to the exercise)'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[DART_sampling_numpy.py](code/DART_sampling_numpy.py)（练习的解决方案）'
- en: '[Bridson_sampling.py](code/Bridson_sampling.py) (solution to the exercise)'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Bridson_sampling.py](code/Bridson_sampling.py)（练习的解决方案）'
- en: '[sampling.py](code/sampling.py)'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sampling.py](code/sampling.py)'
- en: '[mosaic.py](code/mosaic.py)'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[mosaic.py](code/mosaic.py)'
- en: '[voronoi.py](code/voronoi.py)'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[voronoi.py](code/voronoi.py)'
- en: '[References](#id18)'
  id: totrans-592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[参考文献](#id18)'
- en: '[Visualizing Algorithms](https://bost.ocks.org/mike/algorithms/) Mike Bostock,
    2014.'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可视化算法](https://bost.ocks.org/mike/algorithms/) Mike Bostock, 2014.'
- en: '[Stippling and Blue Noise](http://www.joesfer.com/?p=108) Jose Esteve, 2012.'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ stippling 和蓝噪声](http://www.joesfer.com/?p=108) Jose Esteve, 2012.'
- en: '[Poisson Disk Sampling](http://devmag.org.za/2009/05/03/poisson-disk-sampling/)
    Herman Tulleken, 2009.'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[泊松盘采样](http://devmag.org.za/2009/05/03/poisson-disk-sampling/) Herman Tulleken,
    2009.'
- en: '[Fast Poisson Disk Sampling in Arbitrary Dimensions](http://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf),
    Robert Bridson, SIGGRAPH, 2007.'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[任意维度的快速泊松盘采样](http://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf),
    Robert Bridson, SIGGRAPH, 2007.'
- en: '[Conclusion](#id18)'
  id: totrans-597
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[结论](#id18)'
- en: The last example we've been studying is indeed a nice example where it is more
    important to vectorize the problem rather than to vectorize the code (and too
    early). In this specific case we were lucky enough to have the work done for us
    but it won't be always the case and in such a case, the temptation might be high
    to vectorize the first solution we've found. I hope you're now convinced it might
    be a good idea in general to look for alternative solutions once you've found
    one. You'll (almost) always improve speed by vectorizing your code, but in the
    process, you may miss huge improvements.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后研究的一个例子确实是一个很好的例子，在这个例子中，将问题向量化比将代码向量化（而且过早地）更重要。在这个特定的情况下，我们很幸运地有人为我们完成了这项工作，但这种情况并不总是如此，在这种情况下，向量化我们找到的第一个解决方案的诱惑可能会很大。我希望你现在已经相信，一旦你找到了一个解决方案，通常寻找替代方案是一个好主意。你（几乎）总是可以通过向量化你的代码来提高速度，但在过程中，你可能会错过巨大的改进。
- en: '[Custom vectorization](#table-of-contents)'
  id: totrans-599
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[自定义向量化](#table-of-contents)'
- en: '**Contents**'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容**'
- en: '[Introduction](#id29)'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍](#id29)'
- en: '[Typed list](#typed-list)'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类型化列表](#typed-list)'
- en: '[Creation](#creation)'
  id: totrans-603
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建](#creation)'
- en: '[Access](#access)'
  id: totrans-604
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[访问](#access)'
- en: '[Exercise](#id31)'
  id: totrans-605
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#id31)'
- en: '[Sources](#id32)'
  id: totrans-606
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[来源](#id32)'
- en: '[Memory aware array](#memory-aware-array)'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[内存感知数组](#memory-aware-array)'
- en: '[Glumpy](#id33)'
  id: totrans-608
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Glumpy](#id33)'
- en: '[Array subclass](#array-subclass)'
  id: totrans-609
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数组子类](#array-subclass)'
- en: '[Computing extents](#computing-extents)'
  id: totrans-610
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[计算范围](#computing-extents)'
- en: '[Keeping track of pending data](#keeping-track-of-pending-data)'
  id: totrans-611
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[跟踪待处理数据](#keeping-track-of-pending-data)'
- en: '[Sources](#id35)'
  id: totrans-612
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[来源](#id35)'
- en: '[Conclusion](#id36)'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结论](#id36)'
- en: '[Introduction](#id28)'
  id: totrans-614
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[介绍](#id28)'
- en: One of the strengths of numpy is that it can be used to build new objects or
    to [subclass the ndarray](https://docs.scipy.org/doc/numpy/user/basics.subclassing.html)
    object. This later process is a bit tedious but it is worth the effort because
    it allows you to improve the `ndarray` object to suit your problem. We'll examine
    in the following section two real-world cases (typed list and memory-aware array)
    that are extensively used in the [glumpy](http://glumpy.github.io) project (that
    I maintain) while the last one (double precision array) is a more academic case.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的一个优点是它可以用来构建新对象或[子类 ndarray 对象](https://docs.scipy.org/doc/numpy/user/basics.subclassing.html)。这个过程可能有点繁琐，但这是值得的，因为它允许你改进
    `ndarray` 对象以适应你的问题。在下一节中，我们将研究两个实际案例（类型化列表和内存感知数组），这些案例在[glumpy](http://glumpy.github.io)项目（我维护的项目）中得到了广泛的应用，而最后一个（双精度数组）是一个更学术的案例。
- en: '[Typed list](#id28)'
  id: totrans-616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[类型化列表](#id28)'
- en: Typed list (also known as ragged array) is a list of items that all have the
    same data type (in the sense of numpy). They offer both the list and the ndarray
    API (with some restriction of course) but because their respective APIs may not
    be compatible in some cases, we have to make choices. For example, concerning
    the `+` operator, we'll choose to use the numpy API where the value is added to
    each individual item instead of expanding the list by appending a new item (`1`).
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 打印列表（也称为参差不齐数组）是一个所有项都具有相同数据类型（在numpy的意义上）的项列表。它们提供了列表和ndarray API（当然有一些限制），但由于它们的API在某些情况下可能不兼容，我们必须做出选择。例如，关于`+`运算符，我们将选择使用numpy
    API，其中值被添加到每个单独的项上，而不是通过追加新项（`1`）来扩展列表。
- en: '[PRE87]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: From the list API, we want our new object to offer the possibility of inserting,
    appending and removing items seamlessly.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表API中，我们希望我们的新对象能够提供无缝插入、追加和删除项的可能性。
- en: '[Creation](#id28)'
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[创建](#id28)'
- en: Since the object is dynamic by definition, it is important to offer a general-purpose
    creation method powerful enough to avoid having to do later manipulations. Such
    manipulations, for example insertion/deletion, cost a lot of operations and we
    want to avoid them. Here is a proposal (among others) for the creation of a `TypedList`
    object.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对象按定义是动态的，因此提供一种通用且功能强大的创建方法以避免以后需要进行操作是很重要的。例如，插入/删除这样的操作成本很高，我们希望避免它们。以下是一个创建`TypedList`对象的建议（以及其他建议）。
- en: '[PRE88]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This API allows creating an empty list or creating a list from some external
    data. Note that in the latter case, we need to specify how to partition the data
    into several items or they will split into 1-size items. It can be a regular partition
    (i.e. each item is 2 data long) or a custom one (i.e. data must be split in items
    of size 1, 2, 3 and 4 items).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 此API允许创建一个空列表或从某些外部数据创建一个列表。请注意，在后一种情况下，我们需要指定如何将数据分割成几个项，否则它们将分割成1-size项。它可以是一个常规分区（即每个项是2个数据长）或一个自定义分区（即数据必须分割成1、2、3和4个项的大小）。
- en: '[PRE89]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: At this point, the question is whether to subclass the `ndarray` class or to
    use an internal `ndarray` to store our data. In our specific case, it does not
    really make sense to subclass `ndarray` because we don't really want to offer
    the `ndarray` interface. Instead, we'll use an `ndarray` for storing the list
    data and this design choice will offer us more flexibility.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，问题是是否要子类化`ndarray`类或使用内部`ndarray`来存储我们的数据。在我们的特定情况下，子类化`ndarray`实际上没有意义，因为我们并不真正想要提供`ndarray`接口。相反，我们将使用`ndarray`来存储列表数据，这种设计选择将为我们提供更多的灵活性。
- en: '[PRE90]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'To store the limit of each item, we''ll use an `items` array that will take
    care of storing the position (start and end) for each item. For the creation of
    a list, there are two distinct cases: no data is given or some data is given.
    The first case is easy and requires only the creation of the `_data` and `_items`
    arrays. Note that their size is not `null` since it would be too costly to resize
    the array each time we insert a new item. Instead, it''s better to reserve some
    space.'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储每个项的极限，我们将使用一个`items`数组，它将负责存储每个项的位置（起始和结束）。对于列表的创建，有两种不同的情况：没有提供数据或提供了数据。第一种情况很简单，只需要创建`_data`和`_items`数组。请注意，它们的大小不是`null`，因为每次我们插入新项时调整数组大小会非常昂贵。相反，最好预留一些空间。
- en: '**First case.** No data has been given, only dtype.'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一种情况。**没有提供数据，只有dtype。'
- en: '[PRE91]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '**Second case.** Some data has been given as well as a list of item sizes (for
    other cases, see full code below)'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二种情况。**已经提供了数据以及一个项大小列表（对于其他情况，请参阅下面的完整代码）'
- en: '[PRE92]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[Access](#id28)'
  id: totrans-632
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[访问](#id28)'
- en: 'Once this is done, every list method requires only a bit of computation and
    playing with the different key when getting, inserting or setting an item. Here
    is the code for the `__getitem__` method. No real difficulty but the possible
    negative step:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，每个列表方法只需要进行一点计算和操作不同的键来获取、插入或设置项。以下是`__getitem__`方法的代码。没有真正的困难，但可能的负步骤：
- en: '[PRE93]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[Exercise](#id28)'
  id: totrans-635
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[练习](#id28)'
- en: Modification of the list is a bit more complicated, because it requires managing
    memory properly. Since it poses no real difficulty, we left this as an exercise
    for the reader. For the lazy, you can have a look at the code below. Be careful
    with negative steps, key range and array expansion. When the underlying array
    needs to be expanded, it's better to expand it more than necessary in order to
    avoid future expansion.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的修改稍微复杂一些，因为它需要正确管理内存。由于这并不构成真正的困难，所以我们将其留作读者的练习。对于懒惰的人，可以看看下面的代码。注意负步长、关键范围和数组扩展。当底层数组需要扩展时，最好扩展得比实际需要的多，以避免未来的扩展。
- en: '**setitem**'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置项**'
- en: '[PRE94]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '**delitem**'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除项**'
- en: '[PRE96]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '**insert**'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入**'
- en: '[PRE98]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[Sources](#id28)'
  id: totrans-646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[源代码](#id28)'
- en: '[array_list.py](code/array_list.py) (solution to the exercise)'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[array_list.py](code/array_list.py)（练习的解决方案）'
- en: '[Memory aware array](#id28)'
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[内存感知数组](#id28)'
- en: '[Glumpy](#id28)'
  id: totrans-649
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Glumpy](#id28)'
- en: '[Glumpy](http://glumpy.github.io) is an OpenGL-based interactive visualization
    library in Python whose goal is to make it easy to create fast, scalable, beautiful,
    interactive and dynamic visualizations.'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '[Glumpy](http://glumpy.github.io) 是一个基于 OpenGL 的 Python 交互式可视化库，其目标是使创建快速、可扩展、美观、交互式和动态的可视化变得容易。'
- en: '**Figure 6.1**'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.1**'
- en: Simulation of a spiral galaxy using the density wave theory.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 使用密度波理论模拟螺旋星系。
- en: '![img/4a1bec6566a39698532f9fb071ef6ffc.png](img/4a1bec6566a39698532f9fb071ef6ffc.png)'
  id: totrans-653
  prefs: []
  type: TYPE_IMG
  zh: '![img/4a1bec6566a39698532f9fb071ef6ffc.png](img/4a1bec6566a39698532f9fb071ef6ffc.png)'
- en: '**Figure 6.2**'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.2**'
- en: Tiger display using collections and 2 GL calls
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合和 2 个 GL 调用实现的虎形显示
- en: '![img/97405080ef01bac0bf56599757b7489f.png](img/97405080ef01bac0bf56599757b7489f.png)'
  id: totrans-656
  prefs: []
  type: TYPE_IMG
  zh: '![img/97405080ef01bac0bf56599757b7489f.png](img/97405080ef01bac0bf56599757b7489f.png)'
- en: 'Glumpy is based on a tight and seamless integration with numpy arrays. This
    means you can manipulate GPU data as you would with regular numpy arrays and glumpy
    will take care of the rest. But an example is worth a thousand words:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: Glumpy 是基于与 numpy 数组的紧密和无缝集成。这意味着你可以像操作常规 numpy 数组一样操作 GPU 数据，而 glumpy 会处理其余部分。但一个例子胜过千言万语：
- en: '[PRE100]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '`V` is a `VertexBuffer` which is both a `GPUData` and a numpy array. When `V`
    is modified, glumpy takes care of computing the smallest contiguous block of dirty
    memory since it was last uploaded to GPU memory. When this buffer is to be used
    on the GPU, glumpy takes care of uploading the "dirty" area at the very last moment.
    This means that if you never use `V`, nothing will be ever uploaded to the GPU!
    In the case above, the last computed "dirty" area is made of 88 bytes starting
    at offset 0 as illustrated below:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '`V` 是一个 `VertexBuffer`，它既是 `GPUData` 也是 numpy 数组。当 `V` 被修改时，glumpy 会负责计算自上次上传到
    GPU 内存以来最小的连续脏内存块。当这个缓冲区要在 GPU 上使用时，glumpy 会负责在最后时刻上传“脏”区域。这意味着如果你从未使用 `V`，则永远不会上传任何内容到
    GPU！在上面的例子中，最后计算的“脏”区域由从偏移量 0 开始的 88 字节组成，如下所示：'
- en: '![img/51d636eb5c4a87df76ffe74319ca2360.png](img/51d636eb5c4a87df76ffe74319ca2360.png)'
  id: totrans-660
  prefs: []
  type: TYPE_IMG
  zh: '![img/51d636eb5c4a87df76ffe74319ca2360.png](img/51d636eb5c4a87df76ffe74319ca2360.png)'
- en: Note
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When a buffer is created, it is marked as totally dirty, but for the sake of
    illustration, just pretend this is not the case here.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建缓冲区时，它被标记为完全脏，但为了说明，这里就假装不是这种情况。
- en: Glumpy will thus end up uploading 88 bytes while only 16 bytes have been actually
    modified. You might wonder if this optimal. Actually, most of the time it is,
    because uploading some data to a buffer requires a lot of operations on the GL
    side and each call has a fixed cost.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，glumpy 最终将上传 88 字节，而实际上只修改了 16 字节。你可能想知道这是否是最优的。实际上，大多数情况下是这样的，因为将一些数据上传到缓冲区需要在
    GL 端进行大量操作，并且每次调用都有固定的成本。
- en: '[Array subclass](#id28)'
  id: totrans-664
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[数组子类](#id28)'
- en: 'As explained in the [Subclassing ndarray](https://docs.scipy.org/doc/numpy/user/basics.subclassing.html)
    documentation, subclassing `ndarray` is complicated by the fact that new instances
    of `ndarray` classes can come about in three different ways:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [ndarray 子类化](https://docs.scipy.org/doc/numpy/user/basics.subclassing.html)
    文档中所述，`ndarray` 的子类化由于 `ndarray` 类的新实例可以通过三种不同的方式产生而变得复杂：
- en: Explicit constructor call
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式构造函数调用
- en: View casting
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图转换
- en: New from template
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模板新建
- en: 'However our case is simpler because we''re only interested in the view casting.
    We thus only need to define the `__new__` method that will be called at each instance
    creation. As such, the `GPUData` class will be equipped with two properties:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的情况更简单，因为我们只对视图转换感兴趣。因此，我们只需要定义在每次实例创建时都会被调用的 `__new__` 方法。这样，`GPUData`
    类将配备两个属性：
- en: '`extents`: This represents the full extent of the view relatively to the base
    array. It is stored as a byte offset and a byte size.'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extents`：这表示相对于基本数组的视图的完整范围。它存储为字节偏移量和字节大小。'
- en: '`pending_data`: This represents the contiguous *dirty* area as (byte offset,
    byte size) relatively to the `extents` property.'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pending_data`：这表示相对于 `extents` 属性的连续 *脏* 区域，以（字节偏移量，字节大小）的形式。'
- en: '[PRE101]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[Computing extents](#id28)'
  id: totrans-673
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[计算范围](#id28)'
- en: Each time a partial view of the array is requested, we need to compute the extents
    of this partial view while we have access to the base array.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 每次请求数组的部分视图时，我们需要在可以访问基本数组的同时计算这个部分视图的范围。
- en: '[PRE102]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[Keeping track of pending data](#id28)'
  id: totrans-676
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[跟踪待处理数据](#id28)'
- en: 'One extra difficulty is that we don''t want all the views to keep track of
    the dirty area but only the base array. This is the reason why we don''t instantiate
    the `self._pending_data` in the second case of the `__array_finalize__` method.
    This will be handled when we need to update some data as during a `__setitem__`
    call for example:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个额外的困难是我们不希望所有视图都跟踪脏区域，而只跟踪基本数组。这就是为什么在 `__array_finalize__` 方法的第二种情况下我们不实例化
    `self._pending_data` 的原因。这将在我们需要更新某些数据时处理，例如在 `__setitem__` 调用期间：
- en: '[PRE103]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[Sources](#id28)'
  id: totrans-679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[来源](#id28)'
- en: '[gpudata.py](code/gpudata.py)'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[gpudata.py](code/gpudata.py)'
- en: '[Conclusion](#id28)'
  id: totrans-681
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[结论](#id28)'
- en: As explained on the numpy website, numpy is the fundamental package for scientific
    computing with Python. However, as illustrated in this chapter, the usage of numpy
    strengths goes far beyond a mere *multi-dimensional container of generic data*.
    Using `ndarray` as a private property in one case (`TypedList`) or directly subclassing
    the `ndarray` class (`GPUData`) to keep track of memory in another case, we've
    seen how it is possible to extend numpy's capabilities to suit very specific needs.
    The limit is only your imagination and your experience.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 numpy 网站上所述，numpy 是 Python 科学计算的基础包。然而，正如本章所示，numpy 强度的使用远远超出了仅仅是一个 *通用数据的多维容器*。在一种情况下（`TypedList`）将
    `ndarray` 作为私有属性，或在另一种情况下（`GPUData`）直接子类化 `ndarray` 类以跟踪内存，我们已经看到如何扩展 numpy 的功能以适应非常特定的需求。限制只在于你的想象力和经验。
- en: '[Beyond Numpy](#table-of-contents)'
  id: totrans-683
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[超越 Numpy](#table-of-contents)'
- en: '**Contents**'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容**'
- en: '[Back to Python](#back-to-python)'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[回到 Python](#back-to-python)'
- en: '[Numpy & co](#numpy-co)'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Numpy 及其相关](#numpy-co)'
- en: '[NumExpr](#numexpr)'
  id: totrans-687
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NumExpr](#numexpr)'
- en: '[Cython](#cython)'
  id: totrans-688
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Cython](#cython)'
- en: '[Numba](#numba)'
  id: totrans-689
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Numba](#numba)'
- en: '[Theano](#theano)'
  id: totrans-690
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Theano](#theano)'
- en: '[PyCUDA](#pycuda)'
  id: totrans-691
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PyCUDA](#pycuda)'
- en: '[PyOpenCL](#pyopencl)'
  id: totrans-692
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PyOpenCL](#pyopencl)'
- en: '[Scipy & co](#scipy-co)'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Scipy 及其相关](#scipy-co)'
- en: '[scikit-learn](#scikit-learn)'
  id: totrans-694
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[scikit-learn](#scikit-learn)'
- en: '[scikit-image](#scikit-image)'
  id: totrans-695
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[scikit-image](#scikit-image)'
- en: '[SymPy](#sympy)'
  id: totrans-696
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SymPy](#sympy)'
- en: '[Astropy](#astropy)'
  id: totrans-697
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Astropy](#astropy)'
- en: '[Cartopy](#cartopy)'
  id: totrans-698
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Cartopy](#cartopy)'
- en: '[Brian](#brian)'
  id: totrans-699
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Brian](#brian)'
- en: '[Glumpy](#id50)'
  id: totrans-700
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Glumpy](#id50)'
- en: '[Conclusion](#id52)'
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结论](#id52)'
- en: '[Back to Python](#id37)'
  id: totrans-702
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[回到 Python](#id37)'
- en: 'You''ve almost reached the end of the book and, hopefully, you''ve learned
    that numpy is a very versatile and powerful library. However in the meantime,
    remember that Python is also quite a powerful language. In fact, in some specific
    cases, it might be more powerful than numpy. Let''s consider, for example, an
    interesting exercise that has been proposed by Tucker Balch in his [Coursera''s
    Computational Investing](https://www.coursera.org/learn/computational-investing)
    course. The exercise is written as:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎读完了这本书，希望你已经了解到 numpy 是一个非常灵活且强大的库。然而在此期间，记住 Python 也是一种相当强大的语言。实际上，在某些特定情况下，它可能比
    numpy 更强大。让我们考虑一个有趣的练习，这是由 Tucker Balch 在他的 [Coursera 的计算投资课程](https://www.coursera.org/learn/computational-investing)中提出的。练习的编写如下：
- en: '*Write the most succinct code possible to compute all "legal" allocations to
    4 stocks such that the allocations are in 1.0 chunks, and the allocations sum
    to 10.0.*'
  id: totrans-704
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*编写尽可能简洁的代码来计算所有“合法”的 4 只股票的分配，使得分配在 1.0 块中，并且分配总和为 10.0。*'
- en: '[Yaser Martinez](http://yasermartinez.com/blog/index.html) collected the different
    answers from the community and the proposed solutions yield surprising results.
    But let''s start with the most obvious Python solution:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '[Yaser Martinez](http://yasermartinez.com/blog/index.html) 收集了社区的不同答案和提出的解决方案，产生了令人惊讶的结果。但让我们从最明显的
    Python 解决方案开始：'
- en: '[PRE104]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This solution is the slowest solution because it requires 4 loops, and more
    importantly, it tests all the different combinations (11641) of 4 integers between
    0 and 10 to retain only combinations whose sum is 10\. We can of course get rid
    of the 4 loops using itertools, but the code remains slow:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案是最慢的解决方案，因为它需要 4 个循环，更重要的是，它测试了 0 到 10 之间 4 个整数的所有不同组合（11641），以保留和为 10
    的组合。我们当然可以使用 itertools 来消除 4 个循环，但代码仍然很慢：
- en: '[PRE105]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'One of the best solution that has been proposed by Nick Popplas takes advantage
    of the fact we can have intelligent imbricated loops that will allow us to directly
    build each tuple without any test as shown below:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: Nick Popplas 提出的最佳解决方案之一利用了我们可以拥有智能嵌套循环的事实，这将允许我们直接构建每个元组，而无需任何测试，如下所示：
- en: '[PRE106]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The best numpy solution by Yaser Martinez uses a different strategy with a
    restricted set of tests:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: Yaser Martinez 提供的最佳 numpy 解决方案采用了一种不同的策略，使用一组有限的测试：
- en: '[PRE107]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'If we benchmark these methods, we get:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对这些方法进行基准测试，我们得到：
- en: '[PRE108]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The numpy solution is the fastest but the pure Python solution is comparable.
    But let me introduce a small modification to the Python solution:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: numpy 解决方案是最快的，但纯 Python 解决方案也是可以比较的。但让我介绍一下 Python 解决方案的一个小修改：
- en: '[PRE109]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'If we benchmark it, we get:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对其进行基准测试，我们得到：
- en: '[PRE110]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'You read that right, we have gained a factor of 100 just by replacing square
    brackets with parenthesis. How is that possible? The explanation can be found
    by looking at the type of the returned object:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 你没看错，我们仅仅通过将方括号替换为圆括号就提高了 100 倍。这是怎么做到的？解释可以通过查看返回对象的类型来找到：
- en: '[PRE111]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `solution_3_bis()` returns a generator that can be used to generate the
    full list or to iterate over all the different elements. In any case, the huge
    speedup comes from the non-instantiation of the full list and it is thus important
    to wonder if you need an actual instance of your result or if a simple generator
    might do the job.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '`solution_3_bis()` 返回一个生成器，可以用来生成完整的列表或遍历所有不同的元素。在任何情况下，巨大的速度提升都来自于不实例化完整的列表，因此重要的是要考虑你是否需要一个实际的结果实例，或者一个简单的生成器可能就足够了。'
- en: '[Numpy & co](#id37)'
  id: totrans-722
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[Numpy & co](#id37)'
- en: 'Beyond numpy, there are several other Python packages that are worth a look
    because they address similar yet different class of problems using different technology
    (compilation, virtual machine, just in time compilation, GPU, compression, etc.).
    Depending on your specific problem and your hardware, one package may be better
    than the other. Let''s illustrate their usage using a very simple example where
    we want to compute an expression based on two float vectors:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 numpy 之外，还有几个其他 Python 包值得一看，因为它们使用不同的技术（编译、虚拟机、即时编译、GPU、压缩等）解决了类似但不同类别的问题。根据您具体的问题和硬件，一个包可能比另一个包更好。让我们用一个非常简单的例子来说明它们的用法，其中我们想要根据两个浮点向量计算一个表达式：
- en: '[PRE112]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[NumExpr](#id37)'
  id: totrans-725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[NumExpr](#id37)'
- en: The [numexpr](https://github.com/pyhttps://www.labri.fr/perso/nrougier/from-python-to-numpy/data/numexpr/wiki/Numexpr-Users-Guide)
    package supplies routines for the fast evaluation of array expressions element-wise
    by using a vector-based virtual machine. It's comparable to SciPy's weave package,
    but doesn't require a separate compile step of C or C++ code.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '[numexpr](https://github.com/pyhttps://www.labri.fr/perso/nrougier/from-python-to-numpy/data/numexpr/wiki/Numexpr-Users-Guide)
    包提供了一组通过使用基于向量的虚拟机逐元素快速评估数组表达式的例程。它与 SciPy 的 weave 包类似，但不需要单独编译 C 或 C++ 代码的步骤。'
- en: '[PRE113]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[Cython](#id37)'
  id: totrans-728
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Cython](#id37)'
- en: '[Cython](http://cython.org) is an optimising static compiler for both the Python
    programming language and the extended Cython programming language (based on Pyrex).
    It makes writing C extensions for Python as easy as Python itself.'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '[Cython](http://cython.org) 是一个针对 Python 编程语言及其扩展 Cython 编程语言（基于 Pyrex）的优化静态编译器。它使得编写
    Python 的 C 扩展变得和 Python 本身一样简单。'
- en: '[PRE114]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[Numba](#id37)'
  id: totrans-731
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Numba](#id37)'
- en: '[Numba](http://numba.pydata.org) gives you the power to speed up your applications
    with high performance functions written directly in Python. With a few annotations,
    array-oriented and math-heavy Python code can be just-in-time compiled to native
    machine instructions, similar in performance to C, C++ and Fortran, without having
    to switch languages or Python interpreters.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '[Numba](http://numba.pydata.org) 为您提供了使用直接在 Python 中编写的性能函数来加速应用程序的能力。通过一些注解，面向数组的和数学密集型的
    Python 代码可以被即时编译成原生机器指令，其性能与 C、C++ 和 Fortran 相似，而无需切换语言或 Python 解释器。'
- en: '[PRE115]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[Theano](#id37)'
  id: totrans-734
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Theano](#id37)'
- en: '[Theano](http://www.deeplearning.net/software/theano/) is a Python library
    that allows you to define, optimize, and evaluate mathematical expressions involving
    multi-dimensional arrays efficiently. Theano features tight integration with numpy,
    transparent use of a GPU, efficient symbolic differentiation, speed and stability
    optimizations, dynamic C code generation and extensive unit-testing and self-verification.'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '[Theano](http://www.deeplearning.net/software/theano/) 是一个 Python 库，允许您高效地定义、优化和评估涉及多维数组的数学表达式。Theano
    具有与 numpy 的紧密集成、透明地使用 GPU、高效的符号微分、速度和稳定性优化、动态 C 代码生成以及广泛的单元测试和自我验证功能。'
- en: '[PRE116]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PyCUDA](#id37)'
  id: totrans-737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[PyCUDA](#id37)'
- en: '[PyCUDA](http://mathema.tician.de/software/pycuda) lets you access Nvidia''s
    CUDA parallel computation API from Python.'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '[PyCUDA](http://mathema.tician.de/software/pycuda) 允许您从 Python 访问 Nvidia 的
    CUDA 并行计算 API。'
- en: '[PRE117]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PyOpenCL](#id37)'
  id: totrans-740
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[PyOpenCL](#id37)'
- en: '[PyOpenCL](http://mathema.tician.de/software/pyopencl) lets you access GPUs
    and other massively parallel compute devices from Python.'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '[PyOpenCL](http://mathema.tician.de/software/pyopencl) 允许您从 Python 访问 GPU 和其他大规模并行计算设备。'
- en: '[PRE118]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[Scipy & co](#id37)'
  id: totrans-743
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[Scipy & co](#id37)'
- en: If there are several additional packages for numpy, there are a trillion additional
    packages for scipy. In fact, every domain of science probably has its own package
    and most of the examples we've been studying until now could have been solved
    in two or three calls to a method in the relevant package. But of course, that
    was not the goal and programming things yourself is generally a good exercise
    if you have some spare time. The biggest difficulty at this point is to find these
    relevant packages. Here is a very short list of packages that are well-maintained,
    well-tested and may simplify your scientific life (depending on your domain).
    There are of course many more and depending on your specific needs, chances are
    you do not have to program everything by yourself. For an extensive list, have
    a look at the [Awesome python list](https://awesome-python.com).
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个针对 numpy 的附加包，那么就有成千上万的 scipy 附加包。实际上，科学领域的每个领域可能都有自己的包，而且我们迄今为止所研究的多数例子都可以通过调用相关包中的方法来解决。但当然，这并不是目标，如果你有一些空闲时间，自己编程通常是一个很好的练习。目前最大的困难是找到这些相关包。以下是一个非常简短的、维护良好、经过良好测试的包列表，这些包可能会简化你的科学生活（取决于你的领域）。当然，还有很多其他的包，根据你的具体需求，你可能不需要自己编写所有代码。要查看一个详尽的列表，请查看
    [Awesome python 列表](https://awesome-python.com)。
- en: '[scikit-learn](#id37)'
  id: totrans-745
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[scikit-learn](#id37)'
- en: '[scikit-learn](http://scikit-learn.org/stable/) is a free software machine
    learning library for the Python programming language. It features various classification,
    regression and clustering algorithms including support vector machines, random
    forests, gradient boosting, k-means and DBSCAN, and is designed to inter-operate
    with the Python numerical and scientific libraries numpy and SciPy.'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '[scikit-learn](http://scikit-learn.org/stable/) 是一个用于 Python 编程语言的免费软件机器学习库。它包含各种分类、回归和聚类算法，包括支持向量机、随机森林、梯度提升、k-means
    和 DBSCAN，并且设计为与 Python 的数值和科学库 numpy 和 SciPy 互操作。'
- en: '[scikit-image](#id37)'
  id: totrans-747
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[scikit-image](#id37)'
- en: '[scikit-image](http://scikit-image.org) is a Python package dedicated to image
    processing, and using natively numpy arrays as image objects. This chapter describes
    how to use scikit-image on various image processing tasks, and insists on the
    link with other scientific Python modules such as numpy and SciPy.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '[scikit-image](http://scikit-image.org) 是一个专注于图像处理的 Python 包，它使用原生的 numpy 数组作为图像对象。本章描述了如何在各种图像处理任务中使用
    scikit-image，并强调了与其他科学 Python 模块（如 numpy 和 SciPy）之间的联系。'
- en: '[SymPy](#id37)'
  id: totrans-749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[SymPy](#id37)'
- en: '[SymPy](http://www.sympy.org/en/index.html) is a Python library for symbolic
    mathematics. It aims to become a full-featured computer algebra system (CAS) while
    keeping the code as simple as possible in order to be comprehensible and easily
    extensible. SymPy is written entirely in Python.'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '[SymPy](http://www.sympy.org/en/index.html) 是一个用于符号数学的 Python 库。它的目标是成为一个功能齐全的计算机代数系统（CAS），同时保持代码尽可能简单，以便于理解并易于扩展。SymPy
    完全用 Python 编写。'
- en: '[Astropy](#id37)'
  id: totrans-751
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Astropy](#id37)'
- en: The [Astropy](http://www.astropy.org) project is a community effort to develop
    a single core package for astronomy in Python and foster interoperability between
    Python astronomy packages.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '[Astropy](http://www.astropy.org) 项目是一个社区努力，旨在为 Python 开发一个单一的核心天文包，并促进 Python
    天文包之间的互操作性。'
- en: '[Cartopy](#id37)'
  id: totrans-753
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Cartopy](#id37)'
- en: '[Cartopy](http://scitools.org.uk/cartopy/) is a Python package designed to
    make drawing maps for data analysis and visualization as easy as possible. Cartopy
    makes use of the powerful PROJ.4, numpy and shapely libraries and has a simple
    and intuitive drawing interface to matplotlib for creating publication quality
    maps.'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '[Cartopy](http://scitools.org.uk/cartopy/)是一个Python包，旨在使绘制用于数据分析可视化的地图尽可能容易。Cartopy利用了强大的PROJ.4、numpy和shapely库，并为matplotlib提供了一个简单直观的绘图界面，用于创建高质量的地图。'
- en: '[Brian](#id37)'
  id: totrans-755
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Brian](#id37)'
- en: '[Brian](http://www.briansimulator.org) is a free, open source simulator for
    spiking neural networks. It is written in the Python programming language and
    is available on almost all platforms. We believe that a simulator should not only
    save the time of processors, but also the time of scientists. Brian is therefore
    designed to be easy to learn and use, highly flexible and easily extensible.'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '[Brian](http://www.briansimulator.org)是一个免费的开源模拟器，用于模拟突触神经网络。它用Python编程语言编写，几乎在所有平台上都可用。我们相信，模拟器不仅应该节省处理器的处理时间，还应该节省科学家的研究时间。因此，Brian被设计成易于学习和使用，高度灵活且易于扩展。'
- en: '[Glumpy](#id37)'
  id: totrans-757
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Glumpy](#id37)'
- en: '[Glumpy](http://glumpy.github.io) is an OpenGL-based interactive visualization
    library in Python. Its goal is to make it easy to create fast, scalable, beautiful,
    interactive and dynamic visualizations. The main documentation for the site is
    organized into a couple of sections:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '[Glumpy](http://glumpy.github.io)是一个基于OpenGL的Python交互式可视化库。它的目标是使创建快速、可扩展、美观、交互式和动态的可视化变得容易。该网站的主要文档组织为几个部分：'
- en: '[Conclusion](#id37)'
  id: totrans-759
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[结论](#id37)'
- en: Numpy is a very versatile library but still, it does not mean you have to use
    it in every situation. In this chapter, we've seen some alternatives (including
    Python itself) that are worth a look. As always, the choice belongs to you. You
    have to consider what is the best solution for you in term of development time,
    computation time and effort in maintenance. On the one hand, if you design your
    own solution, you'll have to test it and to maintain it, but in exchange, you'll
    be free to design it the way you want. On the other hand, if you decide to rely
    on a third-party package, you'll save time in development and benefit from community-support
    even though you might have to adapt the package to your specific needs. The choice
    is up to you.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: Numpy是一个非常通用的库，但并不意味着你必须在每种情况下都使用它。在本章中，我们看到了一些值得一看的替代方案（包括Python本身）。一如既往，选择权在你。你必须考虑对你来说，在开发时间、计算时间和维护努力方面，哪种解决方案是最好的。一方面，如果你设计自己的解决方案，你将不得不对其进行测试和维护，但作为交换，你将能够自由地按照自己的意愿来设计它。另一方面，如果你决定依赖第三方包，你将在开发上节省时间，并从社区支持中受益，尽管你可能需要根据你的特定需求调整包。选择权在你。
- en: '[Conclusion](#table-of-contents)'
  id: totrans-761
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[结论](#table-of-contents)'
- en: You've reached the end of this book. I hope you've learned something while reading
    it, I sure learned a lot writing it. Trying to explain something is a generally
    a good exercise to test for your knowledge of this thing. Of course, we only scratched
    the surface of numpy and there are many things left to discover. Have a look at
    the bibliography for books written by true experts, at the documentation written
    by people making numpy and don't hesitate to ask your questions on the mailing
    lists because the numpy community is very friendly.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经到达了这本书的结尾。我希望你在阅读过程中学到了一些东西，我写作时确实学到了很多。试图解释某件事通常是一个很好的练习，可以检验你对这个知识的掌握。当然，我们只是触及了numpy的表面，还有很多东西等待去发现。请查看由真正的专家撰写的书籍目录，查看由制作numpy的人撰写的文档，并且不要犹豫在邮件列表上提出你的问题，因为numpy社区非常友好。
- en: 'If there''s a single message to retain from this book it is "premature optimization
    is the root of all evil". We''ve seen that code vectorization can drastically
    improve your computation, with several orders of magnitude in some cases. Still,
    problem vectorization is generally much more powerful. If you write code vectorization
    too early in your design process, you won''t be able to think out-of-the-box and
    you''ll certainly miss some really powerful alternatives because you won''t be
    able to identify your problem properly as we''ve seen in the problem vectorization
    chapter. This requires some experience and you have to be patient: experience
    is not an overnight process.'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这本书中有一个信息需要保留，那就是“过早优化是万恶之源”。我们已经看到，代码向量化可以极大地提高你的计算效率，在某些情况下甚至可以提升几个数量级。然而，问题向量化通常更加强大。如果你在设计过程中过早地使用代码向量化，你就无法跳出思维定式，你肯定会错过一些真正强大的替代方案，因为你无法像我们在问题向量化章节中看到的那样正确地识别你的问题。这需要一些经验，你必须有耐心：经验不是一蹴而就的过程。
- en: Finally, custom vectorization is an option worth considering once you've looked
    at the alternatives to numpy. When nothing works for you, numpy still offers you
    a clever framework to forge your own tools. And who knows, this can be the start
    of an exciting adventure for you and the community as it happened to me with the
    [glumpy](http://glumpy.github.io) and the [vispy](http://vispy.org) packages.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦你考虑了 NumPy 的替代方案，自定义向量化是一个值得考虑的选项。当你发现没有任何方法可行时，NumPy 仍然提供了一个巧妙的框架来锻造你自己的工具。而且谁知道呢，这可能是你和你所在社区的一次激动人心的冒险的开始，就像它发生在我与
    [glumpy](http://glumpy.github.io) 和 [vispy](http://vispy.org) 软件包一样。
- en: '[Quick References](#table-of-contents)'
  id: totrans-765
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[快速参考](#table-of-contents)'
- en: '**Contents**'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容**'
- en: '[Data type](#id56)'
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据类型](#id56)'
- en: '[Creation](#id57)'
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建](#id57)'
- en: '[Indexing](#id58)'
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[索引](#id58)'
- en: '[Reshaping](#reshaping)'
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[重塑](#reshaping)'
- en: '[Broadcasting](#broadcasting)'
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[广播](#broadcasting)'
- en: '[Data type](#id55)'
  id: totrans-772
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[数据类型](#id55)'
- en: '| Type | Name | Bytes | Description |'
  id: totrans-773
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 名称 | 字节数 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-774
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `bool` | `b` | 1 | Boolean (True or False) stored as a byte |'
  id: totrans-775
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `b` | 1 | 布尔值（真或假），存储为一个字节 |'
- en: '| `int` | `l` | 4-8 | Platform (long) integer (normally either int32 or int64)
    |'
  id: totrans-776
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `l` | 4-8 | 平台（长）整数（通常是 int32 或 int64）|'
- en: '| `intp` | `p` | 4-8 | Integer used for indexing (normally either int32 or
    int64) |'
  id: totrans-777
  prefs: []
  type: TYPE_TB
  zh: '| `intp` | `p` | 4-8 | 用于索引的整数（通常是 int32 或 int64）|'
- en: '| `int8` | `i1` | 1 | Byte (-128 to 127) |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '| `int8` | `i1` | 1 | 字节（-128 到 127）|'
- en: '| `int16` | `i2` | 2 | Integer (-32768 to 32767) |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
  zh: '| `int16` | `i2` | 2 | 整数（-32768 到 32767）|'
- en: '| `int32` | `i4` | 4 | Integer (-2147483648 to 2147483647) |'
  id: totrans-780
  prefs: []
  type: TYPE_TB
  zh: '| `int32` | `i4` | 4 | 整数（-2147483648 到 2147483647）|'
- en: '| `int64` | `i8` | 8 | Integer (-9223372036854775808 to 9223372036854775807)
    |'
  id: totrans-781
  prefs: []
  type: TYPE_TB
  zh: '| `int64` | `i8` | 8 | 整数（-9223372036854775808 到 9223372036854775807）|'
- en: '| `uint8` | `u1` | 1 | Unsigned integer (0 to 255) |'
  id: totrans-782
  prefs: []
  type: TYPE_TB
  zh: '| `uint8` | `u1` | 1 | 无符号整数（0 到 255）|'
- en: '| `uint16` | `u2` | 2 | Unsigned integer (0 to 65535) |'
  id: totrans-783
  prefs: []
  type: TYPE_TB
  zh: '| `uint16` | `u2` | 2 | 无符号整数（0 到 65535）|'
- en: '| `uint32` | `u4` | 4 | Unsigned integer (0 to 4294967295) |'
  id: totrans-784
  prefs: []
  type: TYPE_TB
  zh: '| `uint32` | `u4` | 4 | 无符号整数（0 到 4294967295）|'
- en: '| `uint64` | `u8` | 8 | Unsigned integer (0 to 18446744073709551615) |'
  id: totrans-785
  prefs: []
  type: TYPE_TB
  zh: '| `uint64` | `u8` | 8 | 无符号整数（0 到 18446744073709551615）|'
- en: '| `float` | `f8` | 8 | Shorthand for float64 |'
  id: totrans-786
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `f8` | 8 | 简写为 float64 |'
- en: '| `float16` | `f2` | 2 | Half precision float: sign bit, 5 bits exponent, 10
    bits mantissa |'
  id: totrans-787
  prefs: []
  type: TYPE_TB
  zh: '| `float16` | `f2` | 2 | 半精度浮点数：符号位，5 位指数，10 位尾数 |'
- en: '| `float32` | `f` | 4 | Single precision float: sign bit, 8 bits exponent,
    23 bits mantissa |'
  id: totrans-788
  prefs: []
  type: TYPE_TB
  zh: '| `float32` | `f` | 4 | 单精度浮点数：符号位，8 位指数，23 位尾数 |'
- en: '| `float64` | `d` | 8 | Double precision float: sign bit, 11 bits exponent,
    52 bits mantissa |'
  id: totrans-789
  prefs: []
  type: TYPE_TB
  zh: '| `float64` | `d` | 8 | 双精度浮点数：符号位，11 位指数，52 位尾数 |'
- en: '| `complex` | `c16` | 16 | Shorthand for complex128. |'
  id: totrans-790
  prefs: []
  type: TYPE_TB
  zh: '| `complex` | `c16` | 16 | 简写为 complex128。|'
- en: '| `complex64` | `c8` | 8 | Complex number, represented by two 32-bit floats
    |'
  id: totrans-791
  prefs: []
  type: TYPE_TB
  zh: '| `complex64` | `c8` | 8 | 复数，由两个 32 位浮点数表示 |'
- en: '| `complex128` | `c16` | 16 | Complex number, represented by two 64-bit floats
    |'
  id: totrans-792
  prefs: []
  type: TYPE_TB
  zh: '| `complex128` | `c16` | 16 | 复数，由两个 64 位浮点数表示 |'
- en: '`bool`, `int`, `float`, and `complex` are understood, but named `np.bool_`
    with an additional underscore in NumPy. Additionally the names such as `intc`,
    `long`, or `double` used in the C programming language are defined.'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool`、`int`、`float` 和 `complex` 在 NumPy 中被理解，但名称为 `np.bool_`，额外有一个下划线。此外，在
    C 编程语言中使用的名称，如 `intc`、`long` 或 `double`，也被定义。'
- en: '[Creation](#id55)'
  id: totrans-794
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[创建](#id55)'
- en: '[PRE119]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[Indexing](#id55)'
  id: totrans-815
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[索引](#id55)'
- en: '[PRE139]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[Reshaping](#id55)'
  id: totrans-830
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[重塑](#id55)'
- en: '[PRE153]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[Broadcasting](#id55)'
  id: totrans-843
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[广播](#id55)'
- en: '[PRE165]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[Bibliography](#table-of-contents)'
  id: totrans-852
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[参考文献](#table-of-contents)'
- en: This is a curated list of some numpy related resources (articles, books & tutorials)
    addressing different aspects of numpy. Some are very specific to numpy/Scipy while
    some others offer a broader view on numerical computing.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个精选的numpy相关资源列表（文章、书籍和教程），涵盖了numpy的不同方面。其中一些非常特定于numpy/Scipy，而另一些则提供了对数值计算的更广泛视角。
- en: '**Contents**'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容**'
- en: '[Tutorials](#tutorials)'
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[教程](#tutorials)'
- en: '[Articles](#articles)'
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[文章](#articles)'
- en: '[Books](#books)'
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[书籍](#books)'
- en: '[Tutorials](#id59)'
  id: totrans-858
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[教程](#id59)'
- en: '[100 Numpy exercises](http://www.labri.fr/perso/nrougier/teaching/numpy.100/index.html),
    Nicolas P. Rougier, 2016.'
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[100 Numpy练习](http://www.labri.fr/perso/nrougier/teaching/numpy.100/index.html),
    Nicolas P. Rougier, 2016.'
- en: '[Numpy tutorial](http://www.labri.fr/perso/nrougier/teaching/numpy/numpy.html),
    Nicolas P. Rougier, 2015.'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NumPy教程](http://www.labri.fr/perso/nrougier/teaching/numpy/numpy.html), Nicolas
    P. Rougier, 2015。'
- en: '[Python course](http://www.python-course.eu/numpy.php), Bernd Klein, 2015.'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python课程](http://www.python-course.eu/numpy.php), Bernd Klein, 2015.'
- en: '[An introduction to Numpy and Scipy](https://engineering.ucsb.edu/~shell/che210d/numpy.pdf),
    M. Scott Shell, 2014.'
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NumPy和Scipy简介](https://engineering.ucsb.edu/~shell/che210d/numpy.pdf), M.
    Scott Shell, 2014。'
- en: '[Python Numpy tutorial](http://cs231n.github.io/python-numpy-tutorial/), Justin
    Johnson, 2014.'
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python Numpy教程](http://cs231n.github.io/python-numpy-tutorial/), Justin Johnson,
    2014.'
- en: '[Quickstart tutorial](https://docs.scipy.org/doc/numpy-dev/user/quickstart.html),
    Numpy developers, 2009.'
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[快速入门教程](https://docs.scipy.org/doc/numpy-dev/user/quickstart.html), Numpy开发者,
    2009.'
- en: '[Numpy medkits](http://mentat.za.net/numpy/numpy_advanced_slides/), Stéfan
    van der Walt, 2008.'
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NumPy工具包](http://mentat.za.net/numpy/numpy_advanced_slides/), Stéfan van der
    Walt, 2008。'
- en: '[Articles](#id59)'
  id: totrans-866
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[文章](#id59)'
- en: '[The NumPy array: a structure for efficient numerical computation](https://hal.inria.fr/inria-00564007/document)Stéfan
    van der Walt, Chris Colbert & Gael Varoquaux, Computing in Science and Engineering,
    13(2), 2011.'
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NumPy数组：高效数值计算的结构](https://hal.inria.fr/inria-00564007/document)Stéfan van
    der Walt, Chris Colbert & Gael Varoquaux, 计算科学工程，13(2)，2011。'
- en: 'In the Python world, NumPy arrays are the standard representation for numerical
    data and enable efficient implementation of numerical computations in a high-level
    language. As this effort shows, NumPy performance can be improved through three
    techniques: vectorizing calculations, avoiding copying data in memory, and minimizing
    operation counts.'
  id: totrans-868
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Python世界中，NumPy数组是数值数据的标准表示形式，并允许在高级语言中高效实现数值计算。正如这个努力所显示的，可以通过三种技术来提高NumPy的性能：向量化计算、避免在内存中复制数据以及最小化操作次数。
- en: '[Vectorised algorithms for spiking neural network simulation](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.397.6097)Romain
    Brette & Dan F. M. Goodman, Neural Computation, 23(6), 2010.'
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用于突触神经网络模拟的矢量化算法](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.397.6097)Romain
    Brette & Dan F. M. Goodman, Neural Computation, 23(6), 2010.'
- en: High-level languages (Matlab, Python) are popular in neuroscience because they
    are flexible and accelerate development. However, for simulating spiking neural
    networks, the cost of interpretation is a bottleneck. We describe a set of algorithms
    to simulate large spiking neural networks efficiently with high-level languages
    using vector-based operations. These algorithms constitute the core of Brian,
    a spiking neural network simulator written in the Python language. Vectorized
    simulation makes it possible to combine the flexibility of high-level languages
    with the computational efficiency usually associated with compiled languages.
  id: totrans-870
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 高级语言（Matlab、Python）在神经科学中很受欢迎，因为它们灵活且能加速开发。然而，对于模拟突触神经网络，解释的开销是一个瓶颈。我们描述了一组算法，使用基于向量的操作，以高效的方式使用高级语言模拟大型突触神经网络。这些算法构成了用Python语言编写的突触神经网络模拟器Brian的核心。向量化模拟使得将高级语言的灵活性与通常与编译语言相关的计算效率结合起来成为可能。
- en: '[Python for Scientific Computing](http://dl.acm.org/citation.cfm?id=1251830)Travis
    E. Oliphant, Computing in Science & Engineering, 9(3), 2007.'
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[科学计算中的Python](http://dl.acm.org/citation.cfm?id=1251830)Travis E. Oliphant,
    计算科学工程，9(3)，2007。'
- en: By itself, Python is an excellent "steering" language for scientific codes written
    in other languages. However, with additional basic tools, Python transforms into
    a high-level language suited for scientific and engineering code that's often
    fast enough to be immediately useful but also flexible enough to be sped up with
    additional extensions.
  id: totrans-872
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅就Python本身而言，它是一种优秀的“引导”语言，适用于用其他语言编写的科学代码。然而，通过添加一些基本工具，Python可以转变为适合科学和工程代码的高级语言，这种语言通常足够快，可以立即使用，同时足够灵活，可以通过额外的扩展来加速。
- en: '[Books](#id59)'
  id: totrans-873
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[书籍](#id59)'
- en: '[SciPy Lecture Notes](http://www.scipy-lectures.org),Gaël Varoquaux, Emmanuelle
    Gouillart, Olav Vahtras et al., 2016.'
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SciPy讲义](http://www.scipy-lectures.org)，Gaël Varoquaux，Emmanuelle Gouillart，Olav
    Vahtras等人，2016。'
- en: 'One document to learn numerics, science, and data with Python. Tutorials on
    the scientific Python ecosystem: a quick introduction to central tools and techniques.
    The different chapters each correspond to a 1 to 2 hours course with increasing
    level of expertise, from beginner to expert.'
  id: totrans-875
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一份学习使用Python进行数值计算、科学和数据的文档。关于科学Python生态系统的教程：对核心工具和技术进行快速介绍。不同的章节各自对应1到2小时的课程，从入门到专家级别。
- en: '[Python Data Science Handbook](http://shop.oreilly.com/product/0636920034919.do)Jake
    van der Plas, O''Reilly, 2016.'
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python数据科学手册](http://shop.oreilly.com/product/0636920034919.do)Jake van der
    Plas, O''Reilly, 2016.'
- en: 'The Python Data Science Handbook provides a reference to the breadth of computational
    and statistical methods that are central to data—intensive science, research,
    and discovery. People with a programming background who want to use Python effectively
    for data science tasks will learn how to face a variety of problems: for example,
    how can you read this data format into your script? How can you manipulate, transform,
    and clean this data? How can you use this data to gain insight, answer questions,
    or to build statistical or machine learning models?'
  id: totrans-877
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 《Python数据科学手册》提供了对数据密集型科学、研究和发现中核心的计算和统计方法的参考。具有编程背景并希望有效地使用Python进行数据科学任务的人将学习如何面对各种问题：例如，你如何将这种数据格式读入你的脚本？你如何操作、转换和清理这些数据？你如何使用这些数据来获得洞察力、回答问题或构建统计或机器学习模型？
- en: '[Elegant SciPy: The Art of Scientific Python](http://shop.oreilly.com/product/0636920038481.do)Juan
    Nunez-Iglesias, Stéfan van der Walt, Harriet Dashnow, O''Reilly, 2016.'
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[优雅的SciPy：科学Python的艺术](http://shop.oreilly.com/product/0636920038481.do)Juan
    Nunez-Iglesias，Stéfan van der Walt，Harriet Dashnow，O''Reilly，2016。'
- en: Welcome to Scientific Python and its community! With this practical book, you'll
    learn the fundamental parts of SciPy and related libraries, and get a taste of
    beautiful, easy-to-read code that you can use in practice. More and more scientists
    are programming, and the SciPy library is here to help. Finding useful functions
    and using them correctly, efficiently, and in easily readable code are two very
    different things. You'll learn by example with some of the best code available,
    selected to cover a wide range of SciPy and related libraries—including scikit-learn,
    scikit-image, toolz, and pandas.
  id: totrans-879
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 欢迎来到科学Python及其社区！通过这本实用的书，你将学习SciPy及其相关库的基本部分，并品尝到易于阅读的漂亮代码，你可以在实践中使用。越来越多的科学家在编程，SciPy库就在这里帮助你。找到有用的函数并正确、高效、易于阅读地使用它们是两件非常不同的事情。你将通过一些最好的代码示例进行学习，这些代码被选中以涵盖SciPy和相关库的广泛范围——包括scikit-learn、scikit-image、toolz和pandas。
- en: '[Learning IPython for Interactive Computing and Data Visualization](https://www.packtpub.com/big-data-and-business-intelligence/learning-ipython-interactive-computing-and-data-visualization-sec)Cyrille
    Rossant, Packt Publishing, 2015.'
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[学习IPython进行交互式计算和数据可视化](https://www.packtpub.com/big-data-and-business-intelligence/learning-ipython-interactive-computing-and-data-visualization-sec)Cyrille
    Rossant，Packt Publishing，2015。'
- en: This book is a beginner-friendly guide to the Python data analysis platform.
    After an introduction to the Python language, IPython, and the Jupyter Notebook,
    you will learn how to analyze and visualize data on real-world examples, how to
    create graphical user interfaces for image processing in the Notebook, and how
    to perform fast numerical computations for scientific simulations with NumPy,
    Numba, Cython, and ipyparallel. By the end of this book, you will be able to perform
    in-depth analyses of all sorts of data.
  id: totrans-881
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这本书是Python数据分析平台的入门友好指南。在介绍Python语言、IPython和Jupyter Notebook之后，你将学习如何在现实世界的例子中分析和可视化数据，如何在Notebook中为图像处理创建图形用户界面，以及如何使用NumPy、Numba、Cython和ipyparallel进行快速数值计算以进行科学模拟。到本书结束时，你将能够对各种数据进行深入分析。
- en: '[SciPy and NumPy](https://www.safaribooksonline.com/library/view/scipy-and-numpy/9781449361600/)Eli
    Bressert, O''Reilly Media, Inc., 2012'
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SciPy和NumPy](https://www.safaribooksonline.com/library/view/scipy-and-numpy/9781449361600/)Eli
    Bressert，O''Reilly Media, Inc.，2012'
- en: Are you new to SciPy and NumPy? Do you want to learn it quickly and easily through
    examples and concise introduction? Then this is the book for you. You’ll cut through
    the complexity of online documentation and discover how easily you can get up
    to speed with these Python libraries.
  id: totrans-883
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你是SciPy和NumPy的新手吗？你想通过示例和简洁的介绍快速轻松地学习它们吗？那么这本书就是为你准备的。你将能够穿透在线文档的复杂性，发现如何轻松地掌握这些Python库。
- en: '[Python for Data Analysis](http://shop.oreilly.com/product/0636920023784.do)Wes
    McKinney, O''Reilly Media, Inc., 2012.'
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据分析中的Python](http://shop.oreilly.com/product/0636920023784.do) Wes McKinney,
    O''Reilly Media, Inc., 2012.'
- en: Looking for complete instructions on manipulating, processing, cleaning, and
    crunching structured data in Python? This hands-on book is packed with practical
    cases studies that show you how to effectively solve a broad set of data analysis
    problems, using several Python libraries.*
  id: totrans-885
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在寻找关于如何在Python中操作、处理、清洗和计算结构化数据的完整指南吗？这本实践性强的书籍包含了大量的实际案例研究，展示了如何有效地解决一系列数据分析问题，使用多个Python库。
- en: '[Guide to NumPy](http://csc.ucdavis.edu/~chaos/courses/nlp/Software/NumPyBook.pdf)Travis
    Oliphant, 2006'
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NumPy指南](http://csc.ucdavis.edu/~chaos/courses/nlp/Software/NumPyBook.pdf)
    Travis Oliphant, 2006'
- en: This book only briefly outlines some of the infrastructure that surrounds the
    basic objects in NumPy to provide the additional functionality contained in the
    older Numeric package (i.e. LinearAlgebra, RandomArray, FFT). This infrastructure
    in NumPy includes basic linear algebra routines, Fourier transform capabilities,
    and random number generators. In addition, the f2py module is described in its
    own documentation, and so is only briefly mentioned in the second part of the
    book.
  id: totrans-887
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书仅简要概述了NumPy中基本对象周围的一些基础设施，以提供包含在较旧的Numeric包中的附加功能（例如，线性代数、随机数组、FFT）。NumPy中的这个基础设施包括基本的线性代数例程、傅里叶变换能力和随机数生成器。此外，f2py模块在其自己的文档中有描述，因此在书的第二部分中仅简要提及。
