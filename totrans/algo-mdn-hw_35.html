<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Fast Inverse Square Root</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Fast Inverse Square Root</h1>
<blockquote>原文：<a href="https://en.algorithmica.org/hpc/arithmetic/rsqrt/">https://en.algorithmica.org/hpc/arithmetic/rsqrt/</a></blockquote><div id="search"><input id="search-bar" type="search" placeholder="Search this book…" oninput="search()"/><div id="search-count"/><div id="search-results"/></div><header><div class="info"/></header><article>The inverse square root of a floating-point number $\frac{1}{\sqrt x}$ is used in calculating normalized vectors, which are in turn extensively used in various simulation scenarios such as computer graphics (e.g., to determine angles of incidence and reflection to simulate lighting).
$$
\hat{v} = \frac{\vec v}{\sqrt {v_x^2 + v_y^2 + v_z^2}}
$$<p>Calculating an inverse square root directly — by first calculating a square root and then dividing $1$ by it — is extremely slow because both of these operations are slow even though they are implemented in hardware.</p><p>But there is a surprisingly good approximation algorithm that takes advantage of the way floating-point numbers are stored in memory. In fact, it is so good that it has been <a href="https://www.felixcloutier.com/x86/rsqrtps">implemented in hardware</a>, so the algorithm is no longer relevant by itself for software engineers, but we are nonetheless going to walk through it for its intrinsic beauty and great educational value.</p><p>Apart from the method itself, quite interesting is the history of its creation. It is attributed to a game studio <em>id Software</em> that used it in their iconic 1999 game <em>Quake III Arena</em>, although apparently, it got there by a chain of “I learned it from a guy who learned it from a guy” that seems to end on William Kahan (the same one that is responsible for IEEE 754 and Kahan summation algorithm).</p><p>It became popular in game developing community around 2005 when they released the source code of the game. Here is <a href="https://github.com/id-Software/Quake-III-Arena/blob/master/code/game/q_math.c#L552">the relevant excerpt from it</a>, including the comments:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">float</span> <span class="nf">Q_rsqrt</span><span class="p">(</span><span class="kt">float</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="n">threehalfs</span> <span class="o">=</span> <span class="mf">1.5F</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">x2</span> <span class="o">=</span> <span class="n">number</span> <span class="o">*</span> <span class="mf">0.5F</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span>  <span class="o">=</span> <span class="n">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span>  <span class="o">=</span> <span class="o">*</span> <span class="p">(</span> <span class="kt">long</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span>                       <span class="c1">// evil floating point bit level hacking
</span></span></span><span class="line"><span class="cl"><span class="c1"/>    <span class="n">i</span>  <span class="o">=</span> <span class="mh">0x5f3759df</span> <span class="o">-</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="p">);</span>               <span class="c1">// what the fuck? 
</span></span></span><span class="line"><span class="cl"><span class="c1"/>    <span class="n">y</span>  <span class="o">=</span> <span class="o">*</span> <span class="p">(</span> <span class="kt">float</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span>  <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span> <span class="n">threehalfs</span> <span class="o">-</span> <span class="p">(</span> <span class="n">x2</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span> <span class="p">)</span> <span class="p">);</span>   <span class="c1">// 1st iteration
</span></span></span><span class="line"><span class="cl"><span class="c1">//  y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
</span></span></span><span class="line"><span class="cl"><span class="c1"/>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>We will go through what it does step by step, but first, we need to take a small detour.</p><span class="anchor" id="approximate-logarithm"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/arithmetic/rsqrt/#approximate-logarithm">#</a>Approximate Logarithm</h3><p>Before computers (or at least affordable calculators) became an everyday thing, people computed multiplication and related operations using logarithm tables — by looking up the logarithms of $a$ and $b$, adding them, and then finding the inverse logarithm of the result.</p>$$
a \times b = 10^{\log a + \log b} = \log^{-1}(\log a + \log b)
$$
You can do the same trick when computing $\frac{1}{\sqrt x}$ using the identity:
$$
\log \frac{1}{\sqrt x} = - \frac{1}{2} \log x
$$<p>The fast inverse square root is based on this identity, and so it needs to calculate the logarithm of $x$ very quickly. Turns out, it can be approximated by just reinterpreting a 32-bit <code>float</code> as an integer.</p><p><a href="../float">Recall</a> that floating-point numbers sequentially store the sign bit (equal to zero for positive values, which is our case), exponent $e_x$ and mantissa $m_x$, which corresponds to</p>$$
x = 2^{e_x} \cdot (1 + m_x)
$$
Its logarithm is therefore
$$
\log_2 x = e_x + \log_2 (1 + m_x)
$$
Since $m_x \in [0, 1)$, the logarithm on the right-hand side can be approximated by
$$
\log_2 (1 + m_x) \approx m_x
$$
The approximation is exact at both ends of the intervals, but to account for the average case we need to shift it by a small constant $\sigma$, therefore
$$
\log_2 x = e_x + \log_2 (1 + m_x) \approx e_x + m_x + \sigma
$$
Now, having this approximation in mind and defining $L=2^{23}$ (the number of mantissa bits in a <code>float</code>) and $B=127$ (the exponent bias), when we reinterpret the bit-pattern of $x$ as an integer $I_x$, we essentially get
$$
\begin{aligned}
I_x &amp;= L \cdot (e_x + B + m_x)
\\  &amp;= L \cdot (e_x + m_x + \sigma +B-\sigma )
\\ &amp;\approx L \cdot \log_2 (x) + L \cdot (B-\sigma )
\end{aligned}
$$<p>(Multiplying an integer by $L=2^{23}$ is equivalent to left-shifting it by 23.)</p><p>When you tune $\sigma$ to minimize the mean square error, this results in a surprisingly accurate approximation.</p><p><figure><img src="../Images/88bc73d39f8ad83d3a6a5db10bcda863.png" data-original-src="https://en.algorithmica.org/hpc/arithmetic/img/approx.svg"/><figcaption>Reinterpreting a floating-point number $x$ as an integer (blue) compared to its scaled and shifted logarithm (gray)</figcaption></figure></p><p>Now, expressing the logarithm from the approximation, we get</p>$$
\log_2 x \approx \frac{I_x}{L} - (B - \sigma)
$$<p>Cool. Now, where were we? Oh, yes, we wanted to calculate the inverse square root.</p><span class="anchor" id="approximating-the-result"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/arithmetic/rsqrt/#approximating-the-result">#</a>Approximating the Result</h3><p>To calculate $y = \frac{1}{\sqrt x}$ using the identity $\log_2 y = - \frac{1}{2} \log_2 x$, we can plug it into our approximation formula and get</p>$$
\frac{I_y}{L} - (B - \sigma)
\approx
- \frac{1}{2} ( \frac{I_x}{L} - (B - \sigma) )
$$
Solving for $I_y$:
$$
I_y \approx \frac{3}{2} L (B - \sigma) - \frac{1}{2} I_x
$$<p>It turns out, we don’t even need to calculate the logarithm in the first place: the formula above is just a constant minus half the integer reinterpretation of $x$. It is written in the code as:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">i</span> <span class="o">=</span> <span class="o">*</span> <span class="p">(</span> <span class="kt">long</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">i</span> <span class="o">=</span> <span class="mh">0x5f3759df</span> <span class="o">-</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="p">);</span>
</span></span></code></pre></div><p>We reinterpret <code>y</code> as an integer in the first line, and then it plug into the formula on the second, the first term of which is the magic number $\frac{3}{2} L (B - \sigma) = \mathtt{0x5F3759DF}$, while the second is calculated with a binary shift instead of division.</p><span class="anchor" id="iterating-with-newtons-method"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/arithmetic/rsqrt/#iterating-with-newtons-method">#</a>Iterating with Newton’s Method</h3><p>What we have next is a couple hand-coded iterations of Newton’s method with $f(y) = \frac{1}{y^2} - x$ and a very good initial value. Its update rule is</p>$$
f'(y) = - \frac{2}{y^3} \implies y_{i+1} = y_{i} (\frac{3}{2} - \frac{x}{2} y_i^2) = \frac{y_i (3 - x y_i^2)}{2}
$$<p>which is written in the code as</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">x2</span> <span class="o">=</span> <span class="n">number</span> <span class="o">*</span> <span class="mf">0.5F</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span>  <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span> <span class="n">threehalfs</span> <span class="o">-</span> <span class="p">(</span> <span class="n">x2</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span> <span class="p">)</span> <span class="p">);</span>
</span></span></code></pre></div><p>The initial approximation is so good that just one iteration was enough for game development purposes. It falls within 99.8% of the correct answer after just the first iteration and can be reiterated further to improve accuracy — which is what is done in the hardware: <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#ig_expand=3037,3009,5135,4870,4870,4872,4875,833,879,874,849,848,6715,4845,6046,3853,288,6570,6527,6527,90,7307,6385,5993&amp;text=rsqrt&amp;techs=AVX,AVX2">the x86 instruction</a> does a few of them and guarantees a relative error of no more than $1.5 \times 2^{-12}$.</p><span class="anchor" id="further-reading"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/arithmetic/rsqrt/#further-reading">#</a>Further Reading</h3><p><a href="https://en.wikipedia.org/wiki/Fast_inverse_square_root#Floating-point_representation">Wikipedia article on fast inverse square root</a>.</p></article><div class="nextprev"><div class="left"><a href="https://en.algorithmica.org/hpc/arithmetic/newton/" id="prev-article">← Newton's Method</a></div><div class="right"><a href="https://en.algorithmica.org/hpc/arithmetic/integer/" id="next-article">Integer Numbers →</a></div></div>    
</body>
</html>