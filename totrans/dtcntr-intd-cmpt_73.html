<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>27Â Interactive Games as Reactive SystemsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>27Â Interactive Games as Reactive SystemsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/games-reactive.html">https://dcic-world.org/2025-08-27/games-reactive.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.About_.Reactive_.Animations%29" class="toclink" data-pltdoc="x">27.1<span class="hspace">Â </span>About Reactive Animations</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Preliminaries%29" class="toclink" data-pltdoc="x">27.2<span class="hspace">Â </span>Preliminaries</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Version__.Airplane_.Moving_.Across_the_.Screen%29" class="toclink" data-pltdoc="x">27.3<span class="hspace">Â </span>Version: Airplane Moving Across the Screen</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Updating_the_.World_.State%29" class="toclink" data-pltdoc="x">27.3.1<span class="hspace">Â </span>Updating the World State</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Displaying_the_.World_.State%29" class="toclink" data-pltdoc="x">27.3.2<span class="hspace">Â </span>Displaying the World State</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Observing_.Time__and_.Combining_the_.Pieces_%29" class="toclink" data-pltdoc="x">27.3.3<span class="hspace">Â </span>Observing Time (and Combining the Pieces)</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Version__.Wrapping_.Around%29" class="toclink" data-pltdoc="x">27.4<span class="hspace">Â </span>Version: Wrapping Around</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Version__.Descending%29" class="toclink" data-pltdoc="x">27.5<span class="hspace">Â </span>Version: Descending</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Moving_the_.Airplane%29" class="toclink" data-pltdoc="x">27.5.1<span class="hspace">Â </span>Moving the Airplane</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Drawing_the_.Scene%29" class="toclink" data-pltdoc="x">27.5.2<span class="hspace">Â </span>Drawing the Scene</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Finishing_.Touches%29" class="toclink" data-pltdoc="x">27.5.3<span class="hspace">Â </span>Finishing Touches</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Version__.Responding_to_.Keystrokes%29" class="toclink" data-pltdoc="x">27.6<span class="hspace">Â </span>Version: Responding to Keystrokes</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Version__.Landing%29" class="toclink" data-pltdoc="x">27.7<span class="hspace">Â </span>Version: Landing</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Version__.A_.Fixed_.Balloon%29" class="toclink" data-pltdoc="x">27.8<span class="hspace">Â </span>Version: A Fixed Balloon</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Version__.Keep_.Your_.Eye_on_the_.Tank%29" class="toclink" data-pltdoc="x">27.9<span class="hspace">Â </span>Version: Keep Your Eye on the Tank</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Version__.The_.Balloon_.Moves__.Too%29" class="toclink" data-pltdoc="x">27.10<span class="hspace">Â </span>Version: The Balloon Moves, Too</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Version__.One__.Two_______.Ninety-.Nine_.Luftballons_%29" class="toclink" data-pltdoc="x">27.11<span class="hspace">Â </span>Version: One, Two, ..., Ninety-Nine Luftballons!</a></p></td></tr></table><p>In this tutorial weâ€™re going to write a little interactive game. The
game wonâ€™t be sophisticated, but itâ€™ll have all the elements you need
to build much richer games of your own.</p><blockquote class="SCentered"><p><img src="../Images/998e83245f5c413f941ee7fad3ab6d30.png" alt="" width="151" height="201" data-original-src="https://dcic-world.org/2025-08-27/balloon-fiesta.png"/>
<br/>
<span class="emph">Albuquerque Balloon Fiesta</span></p></blockquote><p>Imagine we have an airplane coming in to land. Itâ€™s unfortunately
trying to do so amidst a hot-air balloon festival, so it naturally
wants to avoid colliding with any (moving) balloons. In addition,
there is both land and water, and the airplane needs to alight on
land. We might also equip it with limited amounts of fuel to complete
its task. Here are some animations of the game:</p><ul><li><p><a href="https://drive.google.com/file/d/1RyDtWXnodN1rzUwwe79InaVUTfIW5GC8/view?usp=share_link">The airplane comes in to land succcessfully.</a></p></li><li><p><a href="https://drive.google.com/file/d/1N8H8T4ssaIlzGfL8XD99QruxLlrIAnAu/view?usp=sharing">Uh ohâ€”<wbr/>the airplane collides with a balloon!</a></p></li><li><p><a href="https://drive.google.com/file/d/1zdlxGY8InPkyYRWi3ROWDHLZPtuj2KZu/view?usp=share_link">Uh ohâ€”<wbr/>the airplane lands in the water!</a></p></li></ul><p/><div class="SIntrapara">By the end, you will have written all the relevant portions of this
program. Your program will:
</div><div class="SIntrapara"><ul><li><p>animate the airplane to move autonomously;</p></li><li><p>detect keystrokes and adjust the airplane accordingly;</p></li><li><p>have multiple moving balloons;</p></li><li><p>detect collisions between the airplane and balloons;</p></li><li><p>check for landing on water and land; and</p></li><li><p>account for the use of fuel.</p></li></ul></div><div class="SIntrapara">Phew: thatâ€™s a lot going on! Therefore, we wonâ€™t write it all at
once; instead, weâ€™ll build it up bit-by-bit. But weâ€™ll get there by
the end.</div><section class="SsectionLevel3" id="section 27.1"><h3 class="heading">27.1<span class="stt">Â </span><a name="(part._.About_.Reactive_.Animations)"/>About Reactive Animations<span class="button-group"><a href="#(part._.About_.Reactive_.Animations)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>We are writing a program with two important interactive elements: it
is an <span style="font-style: italic">animation</span>, meaning it gives the impression of motion, and
it is <span style="font-style: italic">reactive</span>, meaning it responds to user input. Both of these
can be challenging to program, but Pyret provides a simple mechanism
that accommodates both and integrates well with other programming
principles such as testing. We will learn about this as we go along.</p><p/><div class="SIntrapara">The key to creating an animation is the <span style="font-style: italic">Movie Principle</span>. Even in
the most sophisticated movie you can watch, there is no <span class="emph">motion</span>
(indeed, the very term â€œmovieâ€â€”<wbr/>short for â€œmoving pictureâ€â€”<wbr/>is a
clever bit of false advertising). Rather, there is just a sequence of
still images shown in rapid succession, relying on the human brain to
create the <span class="emph">impression</span> of motion:
</div><div class="SIntrapara"><blockquote class="SCentered"><p><img src="../Images/5c8adbce3d9a918184e456af57b76f30.png" alt="" data-original-src="https://dcic-world.org/2025-08-27/filmstrip.jpg"/></p></blockquote></div><div class="SIntrapara">We are going to exploit the same idea: our animations will consist of
a sequence of individual images, and we will ask Pyret to show these
in rapid succession. We will then see how reactivity folds into the
same process.</div></section><section class="SsectionLevel3" id="section 27.2"><h3 class="heading">27.2<span class="stt">Â </span><a name="(part._.Preliminaries)"/>Preliminaries<span class="button-group"><a href="#(part._.Preliminaries)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">To begin with, we should inform Pyret that we plan to make use of both
images and animations. We load the libraries as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import image as I
import reactors as R</code></pre></div></div></div><div class="SIntrapara">This tells Pyret to load these two libraries and bind the results
to the corresponding names, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">I</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">R</code></span>. Thus, all image
operations are obtained from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">I</code></span> and animation operations from
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">R</code></span>.</div></section><section class="SsectionLevel3" id="section 27.3"><h3 class="heading">27.3<span class="stt">Â </span><a name="(part._.Version__.Airplane_.Moving_.Across_the_.Screen)"/>Version: Airplane Moving Across the Screen<span class="button-group"><a href="#(part._.Version__.Airplane_.Moving_.Across_the_.Screen)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>We will start with the simplest version: one in which the airplane
moves horizontally across the screen. Watch
<a href="https://drive.google.com/file/d/1rbDJJJEQV2z-FZT3R1c15xelLsCwhaLI/view?usp=share_link">this video</a>.</p><p>First, hereâ€™s an image of an airplane:<span class="refelem"><span class="refcolumn"><span class="refcontent">Have fun finding
your preferred airplane image! But donâ€™t spend too long on it,
because weâ€™ve still got a lot of work to do.</span></span></span></p><p><a href="http://world.cs.brown.edu/1/clipart/airplane-small.png">http://world.cs.brown.edu/1/clipart/airplane-small.png</a></p><p/><div class="SIntrapara">We can tell Pyret to load this image and give it a name as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AIRPLANE-URL =
  "http://world.cs.brown.edu/1/clipart/airplane-small.png"
AIRPLANE = I.image-url(AIRPLANE-URL)</code></pre></div></div></div><div class="SIntrapara">Henceforth, when we refer to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AIRPLANE</code></span>, it will always refer to
this image. (Try it out in the interactions area!)</div><p>Now look at the video again. Watch what happens at different points in
time. What stays the same, and what changes? Whatâ€™s common is the
water and land, which stay the same. What changes is the (horizontal)
position of the airplane.</p><p/><div class="SIntrapara"><span style="font-weight: bold">Note</span></div><div class="SIntrapara"><blockquote class="Note"><p>The <span style="font-style: italic">World State</span> consists of everything that changes. Things
that stay the same do not need to get recorded in the World
State.</p></blockquote></div><p>We can now define our first World State:</p><p/><div class="SIntrapara"><span style="font-weight: bold">World Definition</span></div><div class="SIntrapara"><blockquote class="WorldDef"><p>The World State is a number, representing the <span style="font-style: italic">x</span>-position
of the airplane.</p></blockquote></div><p>Observe something important above:</p><p/><div class="SIntrapara"><span style="font-weight: bold">Note</span></div><div class="SIntrapara"><blockquote class="Note"><p>When we record a World State, we donâ€™t capture only the type of the
values, but also their intended meaning.</p></blockquote></div><p/><div class="SIntrapara">Now we have a representation of the core data, but to generate the
above animation, we still have to do several things:
</div><div class="SIntrapara"><ol><li><p>Ask to be notified of the passage of time.</p></li><li><p>As time passes, correspondingly update the World State.</p></li><li><p>Given an updated World State, produce the corresponding visual
display.</p></li></ol></div><div class="SIntrapara">This sounds like a lot! Fortunately, Pyret makes this much easier than
it sounds. Weâ€™ll do these in a slightly different order than listed
above.</div><section class="SsectionLevel4" id="section 27.3.1"><h4 class="heading">27.3.1<span class="stt">Â </span><a name="(part._.Updating_the_.World_.State)"/>Updating the World State<span class="button-group"><a href="#(part._.Updating_the_.World_.State)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>As weâ€™ve noted, the airplane doesnâ€™t actually â€œmoveâ€. Rather, we can
ask Pyret to notify us every time a clock ticks. If on each
tick we place the airplane in an appropriately different position, and
the ticks happen often enough, we will get the impression of motion.</p><p/><div class="SIntrapara">Because the World State consists of just the airplaneâ€™s
<span style="font-style: italic">x</span>-position, to move it to the right, we simply increment
its value. Letâ€™s first give this constant distance a name:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AIRPLANE-X-MOVE = 10</code></pre></div></div></div><div class="SIntrapara">We will need to write a function that reflects this movement. Letâ€™s
first write some test cases:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  move-airplane-x-on-tick(50) is 50 + AIRPLANE-X-MOVE
  move-airplane-x-on-tick(0) is 0 + AIRPLANE-X-MOVE
  move-airplane-x-on-tick(100) is 100 + AIRPLANE-X-MOVE
end</code></pre></div></div></div><div class="SIntrapara">The functionâ€™s definition is now clear:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun move-airplane-x-on-tick(w):
  w + AIRPLANE-X-MOVE
end</code></pre></div></div></div><div class="SIntrapara">And sure enough, Pyret will confirm that this function passes all of
its tests.</div><p/><div class="SIntrapara"><span style="font-weight: bold">Note</span></div><div class="SIntrapara"><blockquote class="Note"><p>If you have prior experience programming animations and reactive
programs, you will immediately notice an important difference: itâ€™s
easy to test parts of your program in Pyret!</p></blockquote></div></section><section class="SsectionLevel4" id="section 27.3.2"><h4 class="heading">27.3.2<span class="stt">Â </span><a name="(part._.Displaying_the_.World_.State)"/>Displaying the World State<span class="button-group"><a href="#(part._.Displaying_the_.World_.State)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Now weâ€™re ready to draw the gameâ€™s visual output. We produce an image
that consists of all the necessary components. It first helps to
define some constants representing the visual output:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">WIDTH = 800
HEIGHT = 500

BASE-HEIGHT = 50
WATER-WIDTH = 500</code></pre></div></div></div><div class="SIntrapara">Using these, we can create a blank canvas, and overlay rectangles
representing water and land:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BLANK-SCENE = I.empty-scene(WIDTH, HEIGHT)

WATER = I.rectangle(WATER-WIDTH, BASE-HEIGHT, "solid", "blue")
LAND = I.rectangle(WIDTH - WATER-WIDTH, BASE-HEIGHT, "solid", "brown")

BASE = I.beside(WATER, LAND)

BACKGROUND =
  I.place-image(BASE,
    WIDTH / 2, HEIGHT - (BASE-HEIGHT / 2),
    BLANK-SCENE)</code></pre></div></div></div><div class="SIntrapara">Examine the value of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BACKGROUND</code></span> in the interactions area
to confirm that it looks right.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>The reason we divide by two when placing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BASE</code></span> is because
Pyret puts the <span class="emph">middle</span> of the image at the given
location. Remove the division and see what happens to the resulting
image.</p></blockquote></blockquote><p/><div class="SIntrapara">Now that we know how to get our background, weâ€™re ready to place the
airplane on it. The expression to do so looks roughly like this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">I.place-image(AIRPLANE,
  # some x position,
  50,
  BACKGROUND)</code></pre></div></div></div><div class="SIntrapara">but what <span style="font-style: italic">x</span> position do we use? Actually, thatâ€™s just what
the World State represents! So we create a function out of this
expression:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun place-airplane-x(w):
  I.place-image(AIRPLANE,
    w,
    50,
    BACKGROUND)
end</code></pre></div></div></div></section><section class="SsectionLevel4" id="section 27.3.3"><h4 class="heading">27.3.3<span class="stt">Â </span><a name="(part._.Observing_.Time__and_.Combining_the_.Pieces_)"/>Observing Time (and Combining the Pieces)<span class="button-group"><a href="#(part._.Observing_.Time__and_.Combining_the_.Pieces_)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Finally, weâ€™re ready to put these pieces together.</p><p>We create a special kind of Pyret value called a <span class="emph">reactor</span>, which
creates animations. Weâ€™ll start by creating a fairly simple kind of
reactor, then grow it as the program gets more sophisticated.</p><p/><div class="SIntrapara">The following code creates a reactor named <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anim</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anim = reactor:
  init: 0,
  on-tick: move-airplane-x-on-tick,
  to-draw: place-airplane-x
end</code></pre></div></div></div><div class="SIntrapara">A reactor needs to be given an initial World State
as well as <span style="font-style: italic">handlers</span> that tell it how to react. Specifying
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">on-tick</code></span> tells Pyret to run a clock and, every time the clock
ticks (roughly thirty times a second), invoke the associated
handler. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">to-draw</code></span> handler is used by Pyret to refresh the
visual display.</div><p/><div class="SIntrapara">Having defined this reactor, we can run it in several ways that are
useful for finding errors, running scientific experiments, and so
on. Our needs here are simple; we ask Pyret to just run the program
on the screen interactively:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">R.interact(anim)</code></pre></div></div></div><div class="SIntrapara">This creates a running program where the airplane flies across the background!</div><p>Thatâ€™s it! Weâ€™ve created our first animation. Now that weâ€™ve gotten
all the preliminaries out of the way, we can go about enhancing it.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>If you want the airplane to appear to move faster, what can you change?</p></blockquote></blockquote></section></section><section class="SsectionLevel3" id="section 27.4"><h3 class="heading">27.4<span class="stt">Â </span><a name="(part._.Version__.Wrapping_.Around)"/>Version: Wrapping Around<span class="button-group"><a href="#(part._.Version__.Wrapping_.Around)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>When you run the preceding program, youâ€™ll notice that after a while,
the airplane just disappears. This is because it has gone past the right
edge of the screen; it is still being â€œdrawnâ€, but in a location
that you cannot see. Thatâ€™s not very useful!<span class="refelem"><span class="refcolumn"><span class="refcontent">Also, after
a long while you might get an error because the computer is being
asked to draw the airplane at a location beyond what the graphics
system can manage.</span></span></span> Instead, when the airplane is about to go past the
right edge of the screen, weâ€™d like it to reappear on the left by a
corresponding amount: â€œwrapping aroundâ€, as it were.</p><p><a href="https://drive.google.com/file/d/1zL4PY1vOWgFMBuPmMvr8wixh5VE9Pg_r/view?usp=share_link">Hereâ€™s the video for this version.</a></p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What needs to change?</p></blockquote></blockquote><p>Clearly, we need to modify
the function that updates the airplaneâ€™s location, since this must now
reflect our decision to wrap around. But the task of <span class="emph">how</span> to draw
the airplane doesnâ€™t need to change at all! Similarly, the definition of
the World State does not need to change, either.</p><p/><div class="SIntrapara">Therefore, we only need to modify <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">move-airplane-x-on-tick</code></span>. The
function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-modulo</code></span> does exactly what we need. That is, we want
the <span style="font-style: italic">x</span>-location to always be modulo the width of the scene:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun move-airplane-wrapping-x-on-tick(x):
  num-modulo(x + AIRPLANE-X-MOVE, WIDTH)
end</code></pre></div></div></div><div class="SIntrapara">Notice that, instead of copying the content of the previous definition
we can simply reuse it:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun move-airplane-wrapping-x-on-tick(x):
  num-modulo(move-airplane-x-on-tick(x), WIDTH)
end</code></pre></div></div></div><div class="SIntrapara">which makes our intent clearer: compute whatever position we would
have had before, but adapt the coordinate to remain within the sceneâ€™s
width.</div><p>Well, thatâ€™s a <span class="emph">proposed</span> re-definition. Be sure to test this
function thoroughly: itâ€™s tricker than you might think! Have you
thought about all the cases? For instance, what happens if the airplane
is half-way off the right edge of the screen?</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Define quality tests for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">move-airplane-wrapping-x-on-tick</code></span>.</p></blockquote></blockquote><p/><div class="SIntrapara"><span style="font-weight: bold">Note</span></div><div class="SIntrapara"><blockquote class="Note"><p>It <span class="emph">is</span> possible to leave <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">move-airplane-x-on-tick</code></span> unchanged
and perform the modular arithmetic in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">place-airplane-x</code></span>
instead. We choose not to do that for the following reason. In this
version, we really do think of the airplane as circling around and
starting again from the left edge (imagine the world is a
cylinder...). Thus, the airplaneâ€™s <span style="font-style: italic">x</span>-position really does
keep going back down. If instead we allowed the World State to
increase monotonically, then it would really be representing the total
distance traveled, contradicting our definition of the World State.</p></blockquote></div><p/><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>After adding this function, run your program again. Did you see any
change in behavior?</p></blockquote></blockquote></div><div class="SIntrapara">If you didnâ€™tâ€¦did you remember to update your reactor to use the new
airplane-moving function?</div></section><section class="SsectionLevel3" id="section 27.5"><h3 class="heading">27.5<span class="stt">Â </span><a name="(part._.Version__.Descending)"/>Version: Descending<span class="button-group"><a href="#(part._.Version__.Descending)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Of course, we need our airplane to move in more than just one dimension:
to get to the final game, it must both ascend and descend as well. For
now, weâ€™ll focus on the simplest version of this, which is an airplane
that continuously descends.
<a href="https://drive.google.com/file/d/1fJ7eJ7Uv-YCXm87OKH5obAYFXp1pAnZo/view?usp=share_link">Hereâ€™s a video.</a></p><p>Letâ€™s again consider individual frames of this video. Whatâ€™s staying
the same? Once again, the water and the land. Whatâ€™s changing? The
position of the airplane. But, whereas before the airplane moved only
in the <span style="font-style: italic">x</span>-dimension, now it moves in both <span style="font-style: italic">x</span> and
<span style="font-style: italic">y</span>. That immediately tells us that our definition of the
World State is inadequate, and must be modified.</p><p/><div class="SIntrapara">We therefore define a new structure to hold this pair of data:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Posn:
  | posn(x, y)
end</code></pre></div></div></div><div class="SIntrapara">Given this, we can revise our definition:</div><p/><div class="SIntrapara"><span style="font-weight: bold">World Definition</span></div><div class="SIntrapara"><blockquote class="WorldDef"><p>The World State is a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">posn</code></span>, representing the
<span style="font-style: italic">x</span>-position and <span style="font-style: italic">y</span>-position of the airplane on
the screen.</p></blockquote></div><section class="SsectionLevel4" id="section 27.5.1"><h4 class="heading">27.5.1<span class="stt">Â </span><a name="(part._.Moving_the_.Airplane)"/>Moving the Airplane<span class="button-group"><a href="#(part._.Moving_the_.Airplane)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">First, letâ€™s consider
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">move-airplane-wrapping-x-on-tick</code></span>. Previously our airplane moved
only in the <span style="font-style: italic">x</span>-direction; now we want it to descend as
well, which means we must add something to the current <span style="font-style: italic">y</span>
value:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AIRPLANE-Y-MOVE = 3</code></pre></div></div></div><div class="SIntrapara">Letâ€™s write some test cases for the new function. Hereâ€™s one:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  move-airplane-xy-on-tick(posn(10, 10)) is posn(20, 13)
end</code></pre></div></div></div><div class="SIntrapara">Another way to write the test would be:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  p = posn(10, 10)
  move-airplane-xy-on-tick(p) is
    posn(move-airplane-wrapping-x-on-tick(p.x),
      move-airplane-y-on-tick(p.y))
end</code></pre></div></div></div><p/><div class="SIntrapara"><span style="font-weight: bold">Note</span></div><div class="SIntrapara"><blockquote class="Note"><p/><div class="SIntrapara">Which method of writing tests is better? <span class="emph">Both!</span> They each offer
different advantages:
</div><div class="SIntrapara"><ul><li><p>The former method has the benefit of being very concrete:
thereâ€™s no question what you expect, and it demonstrates that you
really can compute the desired answer from first principles.</p></li><li><p>The latter method has the advantage that, if you change the
constants in your program (such as the rate of descent), seemingly
correct tests do not suddenly fail. That is, this form of testing is
more about the <span class="emph">relationships</span> between things rather than their
precise <span class="emph">values</span>.</p></li></ul></div><div class="SIntrapara">There is one more choice available, which often combines the best of
both worlds: write the answer as concretely as possible (the former
style), but using constants to compute the answer (the advantage
of the latter style). For instance:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  p = posn(10, 10)
  move-airplane-xy-on-tick(p) is
   posn(num-modulo(p.x + AIRPLANE-X-MOVE, WIDTH),
    p.y + AIRPLANE-Y-MOVE)
end</code></pre></div></div></div></blockquote></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Before you proceed, have you written enough test cases? Are you sure?
Have you, for instance, tested what should happen when the airplane is
near the edge of the screen in either or both dimensions? We thought
notâ€”<wbr/>go back and write more tests before you proceed!</p></blockquote></blockquote><p/><div class="SIntrapara">Using the design recipe, now define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">move-airplane-xy-on-tick</code></span>. You
should end up with something like this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun move-airplane-xy-on-tick(w):
  posn(move-airplane-wrapping-x-on-tick(w.x),
    move-airplane-y-on-tick(w.y))
end</code></pre></div></div></div><div class="SIntrapara">Note that we have reused the existing function for the
<span style="font-style: italic">x</span>-dimension and, correspondingly, created a helper for the
<span style="font-style: italic">y</span> dimension:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun move-airplane-y-on-tick(y):
  y + AIRPLANE-Y-MOVE
end</code></pre></div></div></div><div class="SIntrapara">This may be slight overkill for now, but it does lead to a cleaner
<span style="font-style: italic">separation of concerns</span>, and makes it possible for the complexity
of movement in each dimension to evolve independently while keeping
the code relatively readable.</div></section><section class="SsectionLevel4" id="section 27.5.2"><h4 class="heading">27.5.2<span class="stt">Â </span><a name="(part._.Drawing_the_.Scene)"/>Drawing the Scene<span class="button-group"><a href="#(part._.Drawing_the_.Scene)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">We have to also examine and update <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">place-airplane-x</code></span>. Our
earlier definition placed the airplane at an arbitrary
<span style="font-style: italic">y</span>-coordinate; now we have to take the
<span style="font-style: italic">y</span>-coordinate from the World State:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun place-airplane-xy(w):
  I.place-image(AIRPLANE,
    w.x,
    w.y,
    BACKGROUND)
end</code></pre></div></div></div><div class="SIntrapara">Notice that we canâ€™t really reuse the previous definition because it hard-coded
the <span style="font-style: italic">y</span>-position, which we must now make a parameter.</div></section><section class="SsectionLevel4" id="section 27.5.3"><h4 class="heading">27.5.3<span class="stt">Â </span><a name="(part._.Finishing_.Touches)"/>Finishing Touches<span class="button-group"><a href="#(part._.Finishing_.Touches)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Are we done? It would seem so: weâ€™ve examined all the procedures that
consume and produce World State and updated them
appropriately. Actually, weâ€™re forgetting one small thing: the initial
World State given to the reactor! If weâ€™ve changed the definition
of World State, then we need to update this too. (We
also need to use the new functions rather than the old ones.)
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">INIT-POS = posn(0, 0)

anim = reactor:
  init: INIT-POS,
  on-tick: move-airplane-xy-on-tick,
  to-draw: place-airplane-xy
end

R.interact(anim)</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Itâ€™s a little unsatisfactory to have the airplane truncated by the
screen. You can use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">I.image-width</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">I.image-height</code></span> to
obtain the dimensions of an image, such as the airplane. Use these to
ensure the airplane fits entirely within the screen for the initial scene,
and similarly in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">move-airplane-xy-on-tick</code></span>.</p></blockquote></blockquote></section></section><section class="SsectionLevel3" id="section 27.6"><h3 class="heading">27.6<span class="stt">Â </span><a name="(part._.Version__.Responding_to_.Keystrokes)"/>Version: Responding to Keystrokes<span class="button-group"><a href="#(part._.Version__.Responding_to_.Keystrokes)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Now that we have the airplane descending, thereâ€™s no reason it canâ€™t
ascend as well.
<a href="https://drive.google.com/file/d/1IZw4NrmXsJ-KRaE1GNRhL2Cl3kU27whu/view?usp=share_link">Hereâ€™s a video.</a></p><p>Weâ€™ll use the keyboard to control its motion: specifically, the up-key
will make it move up, while the down-key will make it descend even
faster. This is easy to support using what we already know: we just
need to provide one more handler using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">on-key</code></span>. This handler
takes <span class="emph">two</span> arguments: the first is the current value of the
world, while the second is a representation of which key was
pressed. For the purposes of this program, the only key values we care
about are <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"up"</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"down"</code></span>.</p><p/><div class="SIntrapara">This gives us a fairly comprehensive view of the core capabilities of
reactors:
</div><div class="SIntrapara"><blockquote class="SCentered"><p><img src="../Images/4925a999ce7daf16dda269c55117e5c5.png" alt="" data-original-src="https://dcic-world.org/2025-08-27/world-automaton.jpg"/></p></blockquote></div><div class="SIntrapara">We just define a group of functions to perform all our desired
actions, and the reactor strings them together. Some functions update
world values (sometimes taking additional information about a
stimulus, such as the key pressed), while others transform them into
output (such as what we see on the screen).</div><p/><div class="SIntrapara">Returning to our program, letâ€™s define a constant representing how
much distance a key represents:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">KEY-DISTANCE = 10</code></pre></div></div></div><div class="SIntrapara">Now we can define a function that alterâ€™s the airplaneâ€™s position by that
distance depending on which key is pressed:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun alter-airplane-y-on-key(w, key):
  ask:
    | key == "up"   then: posn(w.x, w.y - KEY-DISTANCE)
    | key == "down" then: posn(w.x, w.y + KEY-DISTANCE)
    | otherwise: w
  end
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Why does this function definition contain
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">| otherwise: w</code></pre></div></div></div><div class="SIntrapara">as its last condition?</div></blockquote></blockquote><p>Notice that if we receive any key other than the two we expect, we
leave the World State as it was; from the userâ€™s perspective, this has
the effect of just ignoring the keystroke. Remove this last clause,
press some other key, and watch what happens!</p><p>No matter what you choose, be sure to test this! Can the airplane drift
off the top of the screen? How about off the screen at the bottom? Can
it overlap with the land or water?</p><p/><div class="SIntrapara">Once weâ€™ve written and thoroughly tested this function, we simply need
to ask Pyret to use it to handle keystrokes:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anim = reactor:
  init: INIT-POS,
  on-tick: move-airplane-xy-on-tick,
  on-key: alter-airplane-y-on-key,
  to-draw: place-airplane-xy
end</code></pre></div></div></div><div class="SIntrapara">Now your airplane moves not only with the passage of time but also in
response to your keystrokes. You can keep it up in the air forever!</div></section><section class="SsectionLevel3" id="section 27.7"><h3 class="heading">27.7<span class="stt">Â </span><a name="(part._.Version__.Landing)"/>Version: Landing<span class="button-group"><a href="#(part._.Version__.Landing)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Remember that the objective of our game is to land the airplane, not to
keep it airborne indefinitely. That means we need to detect when the
airplane reaches the land or water level and, when it does,
<a href="https://drive.google.com/file/d/1XbO-FHQIveD0f3KCvVlUZPjVLNpHW9NT/view?usp=share_link">terminate the
animation</a>.</p><p/><div class="SIntrapara">First, letâ€™s try to characterize when the animation should halt. This
means writing a function that consumes the current World State and
produces a boolean value: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> if the animation should halt,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span> otherwise. This requires a little arithmetic based on the
airplaneâ€™s size:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun is-on-land-or-water(w):
  w.y &gt;= (HEIGHT - BASE-HEIGHT)
end</code></pre></div></div></div><div class="SIntrapara">We just need to inform Pyret to use this predicate to automatically halt
the reactor:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anim = reactor:
  init: INIT-POS,
  on-tick: move-airplane-xy-on-tick,
  on-key: alter-airplane-y-on-key,
  to-draw: place-airplane-xy,
  stop-when: is-on-land-or-water
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>When you test this, youâ€™ll see it isnâ€™t quite right because it doesnâ€™t
take account of the size of the airplaneâ€™s image. As a result, the
airplane only halts when itâ€™s half-way into the land or water, not when
it first touches down. Adjust the formula so that it halts upon first
contact.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Extend this so that the airplane rolls for a while upon touching land,
decelerating according to the laws of physics.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Suppose the airplane is actually landing at a secret subterranean
airbase. The actual landing strip is actually below ground level, and
opens up only when the airplane comes in to land. That means, after
landing, only the parts of the airplane that stick above ground level
would be visible. Implement this. As a hint, consider modifying
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">place-airplane-xy</code></span>.</p></blockquote></blockquote></section><section class="SsectionLevel3" id="section 27.8"><h3 class="heading">27.8<span class="stt">Â </span><a name="(part._.Version__.A_.Fixed_.Balloon)"/>Version: A Fixed Balloon<span class="button-group"><a href="#(part._.Version__.A_.Fixed_.Balloon)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Now letâ€™s add a balloon to the scene.
<a href="https://drive.google.com/file/d/1QLt9tdt2sSPWR90-mmMLCDW4ZklgR_lN/view?usp=share_link">Hereâ€™s a video of the action.</a></p><p>Notice that while the airplane moves, everything elseâ€”<wbr/>including the
balloonâ€”<wbr/>stays immobile. Therefore, we do not need to alter the World
State to record the balloonâ€™s position. All we need to do is alter the
conditions under which the program halts: effectively, there is one
more situation under which it terminates, and that is a collision with
the balloon.</p><p>When does the game halt? There are now two circumstances: one is
contact with land or water, and the other is contact with the
balloon. The former remains unchanged from what it was before, so we can
focus on the latter.</p><p/><div class="SIntrapara">Where is the balloon, and how do we represent where it is? The latter
is easy to answer: thatâ€™s what <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">posn</code></span>s are good for. As for the
former, we can decide where it is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BALLOON-LOC = posn(600, 300)</code></pre></div></div></div><div class="SIntrapara">or we can let Pyret pick a random position:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BALLOON-LOC = posn(random(WIDTH), random(HEIGHT))</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Improve the random placement of the balloon so that it is in credible
spaces (e.g., not submerged).</p></blockquote></blockquote><p/><div class="SIntrapara">Given a position for the balloon, we just need to detect
collision. One simple way is as follows: determine whether the
distance between the airplane and the balloon is within some threshold:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun are-overlapping(airplane-posn, balloon-posn):
  distance(airplane-posn, balloon-posn)
    &lt; COLLISION-THRESHOLD
end</code></pre></div></div></div><div class="SIntrapara">where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">COLLISION-THRESHOLD</code></span> is some suitable constant computed
based on the sizes of the airplane and balloon images. (For these
particular images, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">75</code></span> works pretty well.)</div><p/><div class="SIntrapara">What is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distance</code></span>? It consumes two <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">posn</code></span>s and determines
the Euclidean distance between them:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun distance(p1, p2):
  fun square(n): n * n end
  num-sqrt(square(p1.x - p2.x) + square(p1.y - p2.y))
end</code></pre></div></div></div><p/><div class="SIntrapara">Finally, we have to weave together the two termination conditions:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun game-ends(w):
  ask:
    | is-on-land-or-water(w)          then: true
    | are-overlapping(w, BALLOON-LOC) then: true
    | otherwise: false
  end
end</code></pre></div></div></div><div class="SIntrapara">and use it instead:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anim = reactor:
  init: INIT-POS,
  on-tick: move-airplane-xy-on-tick,
  on-key: alter-airplane-y-on-key,
  to-draw: place-airplane-xy,
  stop-when: game-ends
end</code></pre></div></div></div><p/><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Were you surprised by anything? Did the game look as you expected?</p></blockquote></blockquote></div><div class="SIntrapara">Odds are you didnâ€™t see a balloon on the screen! Thatâ€™s because we
didnâ€™t update our display.</div><p/><div class="SIntrapara">You will need to define the balloonâ€™s image:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BALLOON-URL =
  "http://world.cs.brown.edu/1/clipart/balloon-small.png"
BALLOON = I.image-url(BALLOON-URL)</code></pre></div></div></div><div class="SIntrapara">and also update the drawing function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BACKGROUND =
  I.place-image(BASE,
    WIDTH / 2, HEIGHT - (BASE-HEIGHT / 2),
    I.place-image(BALLOON,
      BALLOON-LOC.x, BALLOON-LOC.y,
      BLANK-SCENE))</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Do you see how to write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">game-ends</code></span> more concisely?</p></blockquote></blockquote><p/><div class="SIntrapara">Hereâ€™s another version:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun game-ends(w):
  is-on-land-or-water(w) or are-overlapping(w, BALLOON-LOC)
end</code></pre></div></div></div></section><section class="SsectionLevel3" id="section 27.9"><h3 class="heading">27.9<span class="stt">Â </span><a name="(part._.Version__.Keep_.Your_.Eye_on_the_.Tank)"/>Version: Keep Your Eye on the Tank<span class="button-group"><a href="#(part._.Version__.Keep_.Your_.Eye_on_the_.Tank)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Now weâ€™ll introduce the idea of fuel. In our simplified world, fuel
isnâ€™t necessary to descendâ€”<wbr/>gravity does that automaticallyâ€”<wbr/>but it
is needed to climb. Weâ€™ll assume that fuel is counted in whole number
units, and every ascension consumes one unit of fuel. When you run out
of fuel, the program no longer responds to the up-arrow, so you can no
longer avoid either the balloon or water.</p><p>In the past, weâ€™ve looked at still images of the game video to
determine what is changing and what isnâ€™t.  For this version, we could
easily place a little gauge on the screen to show the quantity of fuel
left. However, we donâ€™t on purpose, to illustrate a principle.</p><p/><div class="SIntrapara"><span style="font-weight: bold">Note</span></div><div class="SIntrapara"><blockquote class="Note"><p>You canâ€™t always determine what is fixed and what is changing just by
looking at the image.  You have to also read the problem statement
carefully, and think about it in depth.</p></blockquote></div><p>Itâ€™s clear from our description that there are two things changing:
the position of the airplane and the quantity of fuel left. Therefore,
the World State must capture the current values of both of these. The
fuel is best represented as a single number. However, we do need to
create a new structure to represent the combination of these two.</p><p/><div class="SIntrapara"><span style="font-weight: bold">World Definition</span></div><div class="SIntrapara"><blockquote class="WorldDef"><p>The World State is a structure representing the airplaneâ€™s current
position and the quantity of fuel left.</p></blockquote></div><p/><div class="SIntrapara">Concretely, we will use this structure:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data World:
  | world(p, f)
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>We could have also defined the World to be a structure consisting of
three components: the airplaneâ€™s <span style="font-style: italic">x</span>-position, the
airplaneâ€™s <span style="font-style: italic">y</span>-position, and the quantity of fuel. Why do we
choose to use the representation above?</p></blockquote></blockquote><p>We can again look at each of the parts of the program to determine
what can stay the same and what changes. Concretely, we must focus on
the functions that consume and produce <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">World</code></span>s.</p><p/><div class="SIntrapara">On each tick, we consume a world and compute one. The passage of time
does not consume any fuel, so this code can remain unchanged, other
than having to create a structure containing the current amount of
fuel. Concretely:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun move-airplane-xy-on-tick(w :: World):
  world(
    posn(
      move-airplane-wrapping-x-on-tick(w.p.x),
      move-airplane-y-on-tick(w.p.y)),
    w.f)
end</code></pre></div></div></div><div class="SIntrapara">Similarly, the function that responds to keystrokes clearly needs to
take into account how much fuel is left:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun alter-airplane-y-on-key(w, key):
  ask:
    | key == "up"   then:
      if w.f &gt; 0:
        world(posn(w.p.x, w.p.y - KEY-DISTANCE), w.f - 1)
      else:
        w # there's no fuel, so ignore the keystroke
      end
    | key == "down" then:
      world(posn(w.p.x, w.p.y + KEY-DISTANCE), w.f)
    | otherwise: w
  end
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Updating the function that renders a scene. Recall that the world has
two fields; one of them corresponds to what we used to draw before, and
the other isnâ€™t being drawn in the output.</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What else do you need to change to get a working program?</p></blockquote></blockquote><p>You should have noticed that your initial world value is also
incorrect because it doesnâ€™t account for fuel. What are interesting
fuel values to try?</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Extend your program to draw a fuel gauge.</p></blockquote></blockquote></section><section class="SsectionLevel3" id="section 27.10"><h3 class="heading">27.10<span class="stt">Â </span><a name="(part._.Version__.The_.Balloon_.Moves__.Too)"/>Version: The Balloon Moves, Too<span class="button-group"><a href="#(part._.Version__.The_.Balloon_.Moves__.Too)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Until now weâ€™ve left our balloon immobile. Letâ€™s now make the game
more interesting by letting the balloon move, as
<a href="https://drive.google.com/file/d/19kxqArza5y72V9xIezUtPi8PNV33KsG3/view?usp=share_link">this video shows.</a></p><p>Obviously, the balloonâ€™s location needs to also become part of the
World State.</p><p/><div class="SIntrapara"><span style="font-weight: bold">World Definition</span></div><div class="SIntrapara"><blockquote class="WorldDef"><p>The World State is a structure representing the planeâ€™s current
position, the balloonâ€™s current position, and the quantity of fuel
left.</p></blockquote></div><p/><div class="SIntrapara">Here is a representation of the world state. As these states become
more complex, itâ€™s important to add annotations so we can keep track
of whatâ€™s what.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data World:
  | world(p :: Posn, b :: Posn, f :: Number)
end</code></pre></div></div></div><div class="SIntrapara">With this definition, we obviously need to re-write all our previous
definitions. Most of this is quite routine relative to what weâ€™ve seen
before. The only detail we havenâ€™t really specified is how the balloon
is supposed to move: in what direction, at what speed, and what to do
at the edges. Weâ€™ll let you use your imagination for this one!
(Remember that the closer the balloon is to land, the harder it is to
safely land the plane.)</div><p/><div class="SIntrapara">We thus have to modify:
</div><div class="SIntrapara"><ul><li><p>The background image (to remove the static balloon).</p></li><li><p>The drawing handler (to draw the balloon at its position).</p></li><li><p>The timer handler (to move the balloon as well as the
airplane).</p></li><li><p>The key handler (to construct world data that leaves the balloon
unchanged).</p></li><li><p>The termination condition (to account for the balloonâ€™s dynamic
location).</p></li></ul></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Modify each of the above functions, along with their test cases.</p></blockquote></blockquote></section><section class="SsectionLevel3" id="section 27.11"><h3 class="heading">27.11<span class="stt">Â </span><a name="(part._.Version__.One__.Two_______.Ninety-.Nine_.Luftballons_)"/>Version: One, Two, ..., Ninety-Nine Luftballons!<span class="button-group"><a href="#(part._.Version__.One__.Two_______.Ninety-.Nine_.Luftballons_)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Finally, thereâ€™s no need to limit ourselves to only one balloon. How
many is right? Two? Three? Ten? ... Why fix any one number? It could be
a balloon festival!</p><p>Similarly, many games have levels that become progressively harder; we
could do the same, letting the number of balloons be part of what
changes across levels. However, there is conceptually no big
difference between having two balloons and five; the code to control
each balloon is essentially the same.</p><p>We need to represent a collection of balloons. We can use a list to
represent them. Thus:</p><p/><div class="SIntrapara"><span style="font-weight: bold">World Definition</span></div><div class="SIntrapara"><blockquote class="WorldDef"><p>The World State is a structure representing the planeâ€™s current
position, a list of balloon positions, and the quantity of fuel
left.</p></blockquote></div><p/><div class="SIntrapara">You should now use the design recipe for lists of structures to
rewrite the functions. Notice that youâ€™ve already written the function
to move one balloon. Whatâ€™s left?
</div><div class="SIntrapara"><ol><li><p>Apply the same function to each balloon in the list.</p></li><li><p>Determine what to do if two balloons collide.</p></li></ol></div><div class="SIntrapara">For now, you can avoid the latter problem by placing each balloon
sufficiently spread apart along the <span style="font-style: italic">x</span>-dimension and
letting them move only up and down.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Introduce a concept of <span class="emph">wind</span>, which affects balloons but not the
airplane. After random periods of time, the wind blows with random
speed and direction, causing the ballooons to move laterally.</p></blockquote></blockquote></section>&#13;
<h3 class="heading">27.1<span class="stt">Â </span><a name="(part._.About_.Reactive_.Animations)"/>About Reactive Animations<span class="button-group"><a href="#(part._.About_.Reactive_.Animations)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>We are writing a program with two important interactive elements: it
is an <span style="font-style: italic">animation</span>, meaning it gives the impression of motion, and
it is <span style="font-style: italic">reactive</span>, meaning it responds to user input. Both of these
can be challenging to program, but Pyret provides a simple mechanism
that accommodates both and integrates well with other programming
principles such as testing. We will learn about this as we go along.</p><p/><div class="SIntrapara">The key to creating an animation is the <span style="font-style: italic">Movie Principle</span>. Even in
the most sophisticated movie you can watch, there is no <span class="emph">motion</span>
(indeed, the very term â€œmovieâ€â€”<wbr/>short for â€œmoving pictureâ€â€”<wbr/>is a
clever bit of false advertising). Rather, there is just a sequence of
still images shown in rapid succession, relying on the human brain to
create the <span class="emph">impression</span> of motion:
</div><div class="SIntrapara"><blockquote class="SCentered"><p><img src="../Images/5c8adbce3d9a918184e456af57b76f30.png" alt="" data-original-src="https://dcic-world.org/2025-08-27/filmstrip.jpg"/></p></blockquote></div><div class="SIntrapara">We are going to exploit the same idea: our animations will consist of
a sequence of individual images, and we will ask Pyret to show these
in rapid succession. We will then see how reactivity folds into the
same process.</div>&#13;
<h3 class="heading">27.2<span class="stt">Â </span><a name="(part._.Preliminaries)"/>Preliminaries<span class="button-group"><a href="#(part._.Preliminaries)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">To begin with, we should inform Pyret that we plan to make use of both
images and animations. We load the libraries as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import image as I
import reactors as R</code></pre></div></div></div><div class="SIntrapara">This tells Pyret to load these two libraries and bind the results
to the corresponding names, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">I</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">R</code></span>. Thus, all image
operations are obtained from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">I</code></span> and animation operations from
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">R</code></span>.</div>&#13;
<h3 class="heading">27.3<span class="stt">Â </span><a name="(part._.Version__.Airplane_.Moving_.Across_the_.Screen)"/>Version: Airplane Moving Across the Screen<span class="button-group"><a href="#(part._.Version__.Airplane_.Moving_.Across_the_.Screen)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>We will start with the simplest version: one in which the airplane
moves horizontally across the screen. Watch
<a href="https://drive.google.com/file/d/1rbDJJJEQV2z-FZT3R1c15xelLsCwhaLI/view?usp=share_link">this video</a>.</p><p>First, hereâ€™s an image of an airplane:<span class="refelem"><span class="refcolumn"><span class="refcontent">Have fun finding
your preferred airplane image! But donâ€™t spend too long on it,
because weâ€™ve still got a lot of work to do.</span></span></span></p><p><a href="http://world.cs.brown.edu/1/clipart/airplane-small.png">http://world.cs.brown.edu/1/clipart/airplane-small.png</a></p><p/><div class="SIntrapara">We can tell Pyret to load this image and give it a name as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AIRPLANE-URL =
  "http://world.cs.brown.edu/1/clipart/airplane-small.png"
AIRPLANE = I.image-url(AIRPLANE-URL)</code></pre></div></div></div><div class="SIntrapara">Henceforth, when we refer to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AIRPLANE</code></span>, it will always refer to
this image. (Try it out in the interactions area!)</div><p>Now look at the video again. Watch what happens at different points in
time. What stays the same, and what changes? Whatâ€™s common is the
water and land, which stay the same. What changes is the (horizontal)
position of the airplane.</p><p/><div class="SIntrapara"><span style="font-weight: bold">Note</span></div><div class="SIntrapara"><blockquote class="Note"><p>The <span style="font-style: italic">World State</span> consists of everything that changes. Things
that stay the same do not need to get recorded in the World
State.</p></blockquote></div><p>We can now define our first World State:</p><p/><div class="SIntrapara"><span style="font-weight: bold">World Definition</span></div><div class="SIntrapara"><blockquote class="WorldDef"><p>The World State is a number, representing the <span style="font-style: italic">x</span>-position
of the airplane.</p></blockquote></div><p>Observe something important above:</p><p/><div class="SIntrapara"><span style="font-weight: bold">Note</span></div><div class="SIntrapara"><blockquote class="Note"><p>When we record a World State, we donâ€™t capture only the type of the
values, but also their intended meaning.</p></blockquote></div><p/><div class="SIntrapara">Now we have a representation of the core data, but to generate the
above animation, we still have to do several things:
</div><div class="SIntrapara"><ol><li><p>Ask to be notified of the passage of time.</p></li><li><p>As time passes, correspondingly update the World State.</p></li><li><p>Given an updated World State, produce the corresponding visual
display.</p></li></ol></div><div class="SIntrapara">This sounds like a lot! Fortunately, Pyret makes this much easier than
it sounds. Weâ€™ll do these in a slightly different order than listed
above.</div><section class="SsectionLevel4" id="section 27.3.1"><h4 class="heading">27.3.1<span class="stt">Â </span><a name="(part._.Updating_the_.World_.State)"/>Updating the World State<span class="button-group"><a href="#(part._.Updating_the_.World_.State)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>As weâ€™ve noted, the airplane doesnâ€™t actually â€œmoveâ€. Rather, we can
ask Pyret to notify us every time a clock ticks. If on each
tick we place the airplane in an appropriately different position, and
the ticks happen often enough, we will get the impression of motion.</p><p/><div class="SIntrapara">Because the World State consists of just the airplaneâ€™s
<span style="font-style: italic">x</span>-position, to move it to the right, we simply increment
its value. Letâ€™s first give this constant distance a name:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AIRPLANE-X-MOVE = 10</code></pre></div></div></div><div class="SIntrapara">We will need to write a function that reflects this movement. Letâ€™s
first write some test cases:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  move-airplane-x-on-tick(50) is 50 + AIRPLANE-X-MOVE
  move-airplane-x-on-tick(0) is 0 + AIRPLANE-X-MOVE
  move-airplane-x-on-tick(100) is 100 + AIRPLANE-X-MOVE
end</code></pre></div></div></div><div class="SIntrapara">The functionâ€™s definition is now clear:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun move-airplane-x-on-tick(w):
  w + AIRPLANE-X-MOVE
end</code></pre></div></div></div><div class="SIntrapara">And sure enough, Pyret will confirm that this function passes all of
its tests.</div><p/><div class="SIntrapara"><span style="font-weight: bold">Note</span></div><div class="SIntrapara"><blockquote class="Note"><p>If you have prior experience programming animations and reactive
programs, you will immediately notice an important difference: itâ€™s
easy to test parts of your program in Pyret!</p></blockquote></div></section><section class="SsectionLevel4" id="section 27.3.2"><h4 class="heading">27.3.2<span class="stt">Â </span><a name="(part._.Displaying_the_.World_.State)"/>Displaying the World State<span class="button-group"><a href="#(part._.Displaying_the_.World_.State)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Now weâ€™re ready to draw the gameâ€™s visual output. We produce an image
that consists of all the necessary components. It first helps to
define some constants representing the visual output:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">WIDTH = 800
HEIGHT = 500

BASE-HEIGHT = 50
WATER-WIDTH = 500</code></pre></div></div></div><div class="SIntrapara">Using these, we can create a blank canvas, and overlay rectangles
representing water and land:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BLANK-SCENE = I.empty-scene(WIDTH, HEIGHT)

WATER = I.rectangle(WATER-WIDTH, BASE-HEIGHT, "solid", "blue")
LAND = I.rectangle(WIDTH - WATER-WIDTH, BASE-HEIGHT, "solid", "brown")

BASE = I.beside(WATER, LAND)

BACKGROUND =
  I.place-image(BASE,
    WIDTH / 2, HEIGHT - (BASE-HEIGHT / 2),
    BLANK-SCENE)</code></pre></div></div></div><div class="SIntrapara">Examine the value of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BACKGROUND</code></span> in the interactions area
to confirm that it looks right.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>The reason we divide by two when placing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BASE</code></span> is because
Pyret puts the <span class="emph">middle</span> of the image at the given
location. Remove the division and see what happens to the resulting
image.</p></blockquote></blockquote><p/><div class="SIntrapara">Now that we know how to get our background, weâ€™re ready to place the
airplane on it. The expression to do so looks roughly like this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">I.place-image(AIRPLANE,
  # some x position,
  50,
  BACKGROUND)</code></pre></div></div></div><div class="SIntrapara">but what <span style="font-style: italic">x</span> position do we use? Actually, thatâ€™s just what
the World State represents! So we create a function out of this
expression:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun place-airplane-x(w):
  I.place-image(AIRPLANE,
    w,
    50,
    BACKGROUND)
end</code></pre></div></div></div></section><section class="SsectionLevel4" id="section 27.3.3"><h4 class="heading">27.3.3<span class="stt">Â </span><a name="(part._.Observing_.Time__and_.Combining_the_.Pieces_)"/>Observing Time (and Combining the Pieces)<span class="button-group"><a href="#(part._.Observing_.Time__and_.Combining_the_.Pieces_)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Finally, weâ€™re ready to put these pieces together.</p><p>We create a special kind of Pyret value called a <span class="emph">reactor</span>, which
creates animations. Weâ€™ll start by creating a fairly simple kind of
reactor, then grow it as the program gets more sophisticated.</p><p/><div class="SIntrapara">The following code creates a reactor named <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anim</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anim = reactor:
  init: 0,
  on-tick: move-airplane-x-on-tick,
  to-draw: place-airplane-x
end</code></pre></div></div></div><div class="SIntrapara">A reactor needs to be given an initial World State
as well as <span style="font-style: italic">handlers</span> that tell it how to react. Specifying
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">on-tick</code></span> tells Pyret to run a clock and, every time the clock
ticks (roughly thirty times a second), invoke the associated
handler. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">to-draw</code></span> handler is used by Pyret to refresh the
visual display.</div><p/><div class="SIntrapara">Having defined this reactor, we can run it in several ways that are
useful for finding errors, running scientific experiments, and so
on. Our needs here are simple; we ask Pyret to just run the program
on the screen interactively:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">R.interact(anim)</code></pre></div></div></div><div class="SIntrapara">This creates a running program where the airplane flies across the background!</div><p>Thatâ€™s it! Weâ€™ve created our first animation. Now that weâ€™ve gotten
all the preliminaries out of the way, we can go about enhancing it.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>If you want the airplane to appear to move faster, what can you change?</p></blockquote></blockquote></section>&#13;
<h4 class="heading">27.3.1<span class="stt">Â </span><a name="(part._.Updating_the_.World_.State)"/>Updating the World State<span class="button-group"><a href="#(part._.Updating_the_.World_.State)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>As weâ€™ve noted, the airplane doesnâ€™t actually â€œmoveâ€. Rather, we can
ask Pyret to notify us every time a clock ticks. If on each
tick we place the airplane in an appropriately different position, and
the ticks happen often enough, we will get the impression of motion.</p><p/><div class="SIntrapara">Because the World State consists of just the airplaneâ€™s
<span style="font-style: italic">x</span>-position, to move it to the right, we simply increment
its value. Letâ€™s first give this constant distance a name:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AIRPLANE-X-MOVE = 10</code></pre></div></div></div><div class="SIntrapara">We will need to write a function that reflects this movement. Letâ€™s
first write some test cases:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  move-airplane-x-on-tick(50) is 50 + AIRPLANE-X-MOVE
  move-airplane-x-on-tick(0) is 0 + AIRPLANE-X-MOVE
  move-airplane-x-on-tick(100) is 100 + AIRPLANE-X-MOVE
end</code></pre></div></div></div><div class="SIntrapara">The functionâ€™s definition is now clear:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun move-airplane-x-on-tick(w):
  w + AIRPLANE-X-MOVE
end</code></pre></div></div></div><div class="SIntrapara">And sure enough, Pyret will confirm that this function passes all of
its tests.</div><p/><div class="SIntrapara"><span style="font-weight: bold">Note</span></div><div class="SIntrapara"><blockquote class="Note"><p>If you have prior experience programming animations and reactive
programs, you will immediately notice an important difference: itâ€™s
easy to test parts of your program in Pyret!</p></blockquote></div>&#13;
<h4 class="heading">27.3.2<span class="stt">Â </span><a name="(part._.Displaying_the_.World_.State)"/>Displaying the World State<span class="button-group"><a href="#(part._.Displaying_the_.World_.State)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Now weâ€™re ready to draw the gameâ€™s visual output. We produce an image
that consists of all the necessary components. It first helps to
define some constants representing the visual output:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">WIDTH = 800
HEIGHT = 500

BASE-HEIGHT = 50
WATER-WIDTH = 500</code></pre></div></div></div><div class="SIntrapara">Using these, we can create a blank canvas, and overlay rectangles
representing water and land:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BLANK-SCENE = I.empty-scene(WIDTH, HEIGHT)

WATER = I.rectangle(WATER-WIDTH, BASE-HEIGHT, "solid", "blue")
LAND = I.rectangle(WIDTH - WATER-WIDTH, BASE-HEIGHT, "solid", "brown")

BASE = I.beside(WATER, LAND)

BACKGROUND =
  I.place-image(BASE,
    WIDTH / 2, HEIGHT - (BASE-HEIGHT / 2),
    BLANK-SCENE)</code></pre></div></div></div><div class="SIntrapara">Examine the value of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BACKGROUND</code></span> in the interactions area
to confirm that it looks right.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>The reason we divide by two when placing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BASE</code></span> is because
Pyret puts the <span class="emph">middle</span> of the image at the given
location. Remove the division and see what happens to the resulting
image.</p></blockquote></blockquote><p/><div class="SIntrapara">Now that we know how to get our background, weâ€™re ready to place the
airplane on it. The expression to do so looks roughly like this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">I.place-image(AIRPLANE,
  # some x position,
  50,
  BACKGROUND)</code></pre></div></div></div><div class="SIntrapara">but what <span style="font-style: italic">x</span> position do we use? Actually, thatâ€™s just what
the World State represents! So we create a function out of this
expression:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun place-airplane-x(w):
  I.place-image(AIRPLANE,
    w,
    50,
    BACKGROUND)
end</code></pre></div></div></div>&#13;
<h4 class="heading">27.3.3<span class="stt">Â </span><a name="(part._.Observing_.Time__and_.Combining_the_.Pieces_)"/>Observing Time (and Combining the Pieces)<span class="button-group"><a href="#(part._.Observing_.Time__and_.Combining_the_.Pieces_)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Finally, weâ€™re ready to put these pieces together.</p><p>We create a special kind of Pyret value called a <span class="emph">reactor</span>, which
creates animations. Weâ€™ll start by creating a fairly simple kind of
reactor, then grow it as the program gets more sophisticated.</p><p/><div class="SIntrapara">The following code creates a reactor named <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anim</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anim = reactor:
  init: 0,
  on-tick: move-airplane-x-on-tick,
  to-draw: place-airplane-x
end</code></pre></div></div></div><div class="SIntrapara">A reactor needs to be given an initial World State
as well as <span style="font-style: italic">handlers</span> that tell it how to react. Specifying
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">on-tick</code></span> tells Pyret to run a clock and, every time the clock
ticks (roughly thirty times a second), invoke the associated
handler. The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">to-draw</code></span> handler is used by Pyret to refresh the
visual display.</div><p/><div class="SIntrapara">Having defined this reactor, we can run it in several ways that are
useful for finding errors, running scientific experiments, and so
on. Our needs here are simple; we ask Pyret to just run the program
on the screen interactively:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">R.interact(anim)</code></pre></div></div></div><div class="SIntrapara">This creates a running program where the airplane flies across the background!</div><p>Thatâ€™s it! Weâ€™ve created our first animation. Now that weâ€™ve gotten
all the preliminaries out of the way, we can go about enhancing it.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>If you want the airplane to appear to move faster, what can you change?</p></blockquote></blockquote>&#13;
<h3 class="heading">27.4<span class="stt">Â </span><a name="(part._.Version__.Wrapping_.Around)"/>Version: Wrapping Around<span class="button-group"><a href="#(part._.Version__.Wrapping_.Around)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>When you run the preceding program, youâ€™ll notice that after a while,
the airplane just disappears. This is because it has gone past the right
edge of the screen; it is still being â€œdrawnâ€, but in a location
that you cannot see. Thatâ€™s not very useful!<span class="refelem"><span class="refcolumn"><span class="refcontent">Also, after
a long while you might get an error because the computer is being
asked to draw the airplane at a location beyond what the graphics
system can manage.</span></span></span> Instead, when the airplane is about to go past the
right edge of the screen, weâ€™d like it to reappear on the left by a
corresponding amount: â€œwrapping aroundâ€, as it were.</p><p><a href="https://drive.google.com/file/d/1zL4PY1vOWgFMBuPmMvr8wixh5VE9Pg_r/view?usp=share_link">Hereâ€™s the video for this version.</a></p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What needs to change?</p></blockquote></blockquote><p>Clearly, we need to modify
the function that updates the airplaneâ€™s location, since this must now
reflect our decision to wrap around. But the task of <span class="emph">how</span> to draw
the airplane doesnâ€™t need to change at all! Similarly, the definition of
the World State does not need to change, either.</p><p/><div class="SIntrapara">Therefore, we only need to modify <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">move-airplane-x-on-tick</code></span>. The
function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-modulo</code></span> does exactly what we need. That is, we want
the <span style="font-style: italic">x</span>-location to always be modulo the width of the scene:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun move-airplane-wrapping-x-on-tick(x):
  num-modulo(x + AIRPLANE-X-MOVE, WIDTH)
end</code></pre></div></div></div><div class="SIntrapara">Notice that, instead of copying the content of the previous definition
we can simply reuse it:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun move-airplane-wrapping-x-on-tick(x):
  num-modulo(move-airplane-x-on-tick(x), WIDTH)
end</code></pre></div></div></div><div class="SIntrapara">which makes our intent clearer: compute whatever position we would
have had before, but adapt the coordinate to remain within the sceneâ€™s
width.</div><p>Well, thatâ€™s a <span class="emph">proposed</span> re-definition. Be sure to test this
function thoroughly: itâ€™s tricker than you might think! Have you
thought about all the cases? For instance, what happens if the airplane
is half-way off the right edge of the screen?</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Define quality tests for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">move-airplane-wrapping-x-on-tick</code></span>.</p></blockquote></blockquote><p/><div class="SIntrapara"><span style="font-weight: bold">Note</span></div><div class="SIntrapara"><blockquote class="Note"><p>It <span class="emph">is</span> possible to leave <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">move-airplane-x-on-tick</code></span> unchanged
and perform the modular arithmetic in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">place-airplane-x</code></span>
instead. We choose not to do that for the following reason. In this
version, we really do think of the airplane as circling around and
starting again from the left edge (imagine the world is a
cylinder...). Thus, the airplaneâ€™s <span style="font-style: italic">x</span>-position really does
keep going back down. If instead we allowed the World State to
increase monotonically, then it would really be representing the total
distance traveled, contradicting our definition of the World State.</p></blockquote></div><p/><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>After adding this function, run your program again. Did you see any
change in behavior?</p></blockquote></blockquote></div><div class="SIntrapara">If you didnâ€™tâ€¦did you remember to update your reactor to use the new
airplane-moving function?</div>&#13;
<h3 class="heading">27.5<span class="stt">Â </span><a name="(part._.Version__.Descending)"/>Version: Descending<span class="button-group"><a href="#(part._.Version__.Descending)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Of course, we need our airplane to move in more than just one dimension:
to get to the final game, it must both ascend and descend as well. For
now, weâ€™ll focus on the simplest version of this, which is an airplane
that continuously descends.
<a href="https://drive.google.com/file/d/1fJ7eJ7Uv-YCXm87OKH5obAYFXp1pAnZo/view?usp=share_link">Hereâ€™s a video.</a></p><p>Letâ€™s again consider individual frames of this video. Whatâ€™s staying
the same? Once again, the water and the land. Whatâ€™s changing? The
position of the airplane. But, whereas before the airplane moved only
in the <span style="font-style: italic">x</span>-dimension, now it moves in both <span style="font-style: italic">x</span> and
<span style="font-style: italic">y</span>. That immediately tells us that our definition of the
World State is inadequate, and must be modified.</p><p/><div class="SIntrapara">We therefore define a new structure to hold this pair of data:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Posn:
  | posn(x, y)
end</code></pre></div></div></div><div class="SIntrapara">Given this, we can revise our definition:</div><p/><div class="SIntrapara"><span style="font-weight: bold">World Definition</span></div><div class="SIntrapara"><blockquote class="WorldDef"><p>The World State is a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">posn</code></span>, representing the
<span style="font-style: italic">x</span>-position and <span style="font-style: italic">y</span>-position of the airplane on
the screen.</p></blockquote></div><section class="SsectionLevel4" id="section 27.5.1"><h4 class="heading">27.5.1<span class="stt">Â </span><a name="(part._.Moving_the_.Airplane)"/>Moving the Airplane<span class="button-group"><a href="#(part._.Moving_the_.Airplane)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">First, letâ€™s consider
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">move-airplane-wrapping-x-on-tick</code></span>. Previously our airplane moved
only in the <span style="font-style: italic">x</span>-direction; now we want it to descend as
well, which means we must add something to the current <span style="font-style: italic">y</span>
value:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AIRPLANE-Y-MOVE = 3</code></pre></div></div></div><div class="SIntrapara">Letâ€™s write some test cases for the new function. Hereâ€™s one:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  move-airplane-xy-on-tick(posn(10, 10)) is posn(20, 13)
end</code></pre></div></div></div><div class="SIntrapara">Another way to write the test would be:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  p = posn(10, 10)
  move-airplane-xy-on-tick(p) is
    posn(move-airplane-wrapping-x-on-tick(p.x),
      move-airplane-y-on-tick(p.y))
end</code></pre></div></div></div><p/><div class="SIntrapara"><span style="font-weight: bold">Note</span></div><div class="SIntrapara"><blockquote class="Note"><p/><div class="SIntrapara">Which method of writing tests is better? <span class="emph">Both!</span> They each offer
different advantages:
</div><div class="SIntrapara"><ul><li><p>The former method has the benefit of being very concrete:
thereâ€™s no question what you expect, and it demonstrates that you
really can compute the desired answer from first principles.</p></li><li><p>The latter method has the advantage that, if you change the
constants in your program (such as the rate of descent), seemingly
correct tests do not suddenly fail. That is, this form of testing is
more about the <span class="emph">relationships</span> between things rather than their
precise <span class="emph">values</span>.</p></li></ul></div><div class="SIntrapara">There is one more choice available, which often combines the best of
both worlds: write the answer as concretely as possible (the former
style), but using constants to compute the answer (the advantage
of the latter style). For instance:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  p = posn(10, 10)
  move-airplane-xy-on-tick(p) is
   posn(num-modulo(p.x + AIRPLANE-X-MOVE, WIDTH),
    p.y + AIRPLANE-Y-MOVE)
end</code></pre></div></div></div></blockquote></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Before you proceed, have you written enough test cases? Are you sure?
Have you, for instance, tested what should happen when the airplane is
near the edge of the screen in either or both dimensions? We thought
notâ€”<wbr/>go back and write more tests before you proceed!</p></blockquote></blockquote><p/><div class="SIntrapara">Using the design recipe, now define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">move-airplane-xy-on-tick</code></span>. You
should end up with something like this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun move-airplane-xy-on-tick(w):
  posn(move-airplane-wrapping-x-on-tick(w.x),
    move-airplane-y-on-tick(w.y))
end</code></pre></div></div></div><div class="SIntrapara">Note that we have reused the existing function for the
<span style="font-style: italic">x</span>-dimension and, correspondingly, created a helper for the
<span style="font-style: italic">y</span> dimension:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun move-airplane-y-on-tick(y):
  y + AIRPLANE-Y-MOVE
end</code></pre></div></div></div><div class="SIntrapara">This may be slight overkill for now, but it does lead to a cleaner
<span style="font-style: italic">separation of concerns</span>, and makes it possible for the complexity
of movement in each dimension to evolve independently while keeping
the code relatively readable.</div></section><section class="SsectionLevel4" id="section 27.5.2"><h4 class="heading">27.5.2<span class="stt">Â </span><a name="(part._.Drawing_the_.Scene)"/>Drawing the Scene<span class="button-group"><a href="#(part._.Drawing_the_.Scene)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">We have to also examine and update <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">place-airplane-x</code></span>. Our
earlier definition placed the airplane at an arbitrary
<span style="font-style: italic">y</span>-coordinate; now we have to take the
<span style="font-style: italic">y</span>-coordinate from the World State:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun place-airplane-xy(w):
  I.place-image(AIRPLANE,
    w.x,
    w.y,
    BACKGROUND)
end</code></pre></div></div></div><div class="SIntrapara">Notice that we canâ€™t really reuse the previous definition because it hard-coded
the <span style="font-style: italic">y</span>-position, which we must now make a parameter.</div></section><section class="SsectionLevel4" id="section 27.5.3"><h4 class="heading">27.5.3<span class="stt">Â </span><a name="(part._.Finishing_.Touches)"/>Finishing Touches<span class="button-group"><a href="#(part._.Finishing_.Touches)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Are we done? It would seem so: weâ€™ve examined all the procedures that
consume and produce World State and updated them
appropriately. Actually, weâ€™re forgetting one small thing: the initial
World State given to the reactor! If weâ€™ve changed the definition
of World State, then we need to update this too. (We
also need to use the new functions rather than the old ones.)
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">INIT-POS = posn(0, 0)

anim = reactor:
  init: INIT-POS,
  on-tick: move-airplane-xy-on-tick,
  to-draw: place-airplane-xy
end

R.interact(anim)</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Itâ€™s a little unsatisfactory to have the airplane truncated by the
screen. You can use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">I.image-width</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">I.image-height</code></span> to
obtain the dimensions of an image, such as the airplane. Use these to
ensure the airplane fits entirely within the screen for the initial scene,
and similarly in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">move-airplane-xy-on-tick</code></span>.</p></blockquote></blockquote></section>&#13;
<h4 class="heading">27.5.1<span class="stt">Â </span><a name="(part._.Moving_the_.Airplane)"/>Moving the Airplane<span class="button-group"><a href="#(part._.Moving_the_.Airplane)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">First, letâ€™s consider
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">move-airplane-wrapping-x-on-tick</code></span>. Previously our airplane moved
only in the <span style="font-style: italic">x</span>-direction; now we want it to descend as
well, which means we must add something to the current <span style="font-style: italic">y</span>
value:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AIRPLANE-Y-MOVE = 3</code></pre></div></div></div><div class="SIntrapara">Letâ€™s write some test cases for the new function. Hereâ€™s one:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  move-airplane-xy-on-tick(posn(10, 10)) is posn(20, 13)
end</code></pre></div></div></div><div class="SIntrapara">Another way to write the test would be:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  p = posn(10, 10)
  move-airplane-xy-on-tick(p) is
    posn(move-airplane-wrapping-x-on-tick(p.x),
      move-airplane-y-on-tick(p.y))
end</code></pre></div></div></div><p/><div class="SIntrapara"><span style="font-weight: bold">Note</span></div><div class="SIntrapara"><blockquote class="Note"><p/><div class="SIntrapara">Which method of writing tests is better? <span class="emph">Both!</span> They each offer
different advantages:
</div><div class="SIntrapara"><ul><li><p>The former method has the benefit of being very concrete:
thereâ€™s no question what you expect, and it demonstrates that you
really can compute the desired answer from first principles.</p></li><li><p>The latter method has the advantage that, if you change the
constants in your program (such as the rate of descent), seemingly
correct tests do not suddenly fail. That is, this form of testing is
more about the <span class="emph">relationships</span> between things rather than their
precise <span class="emph">values</span>.</p></li></ul></div><div class="SIntrapara">There is one more choice available, which often combines the best of
both worlds: write the answer as concretely as possible (the former
style), but using constants to compute the answer (the advantage
of the latter style). For instance:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  p = posn(10, 10)
  move-airplane-xy-on-tick(p) is
   posn(num-modulo(p.x + AIRPLANE-X-MOVE, WIDTH),
    p.y + AIRPLANE-Y-MOVE)
end</code></pre></div></div></div></blockquote></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Before you proceed, have you written enough test cases? Are you sure?
Have you, for instance, tested what should happen when the airplane is
near the edge of the screen in either or both dimensions? We thought
notâ€”<wbr/>go back and write more tests before you proceed!</p></blockquote></blockquote><p/><div class="SIntrapara">Using the design recipe, now define <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">move-airplane-xy-on-tick</code></span>. You
should end up with something like this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun move-airplane-xy-on-tick(w):
  posn(move-airplane-wrapping-x-on-tick(w.x),
    move-airplane-y-on-tick(w.y))
end</code></pre></div></div></div><div class="SIntrapara">Note that we have reused the existing function for the
<span style="font-style: italic">x</span>-dimension and, correspondingly, created a helper for the
<span style="font-style: italic">y</span> dimension:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun move-airplane-y-on-tick(y):
  y + AIRPLANE-Y-MOVE
end</code></pre></div></div></div><div class="SIntrapara">This may be slight overkill for now, but it does lead to a cleaner
<span style="font-style: italic">separation of concerns</span>, and makes it possible for the complexity
of movement in each dimension to evolve independently while keeping
the code relatively readable.</div>&#13;
<h4 class="heading">27.5.2<span class="stt">Â </span><a name="(part._.Drawing_the_.Scene)"/>Drawing the Scene<span class="button-group"><a href="#(part._.Drawing_the_.Scene)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">We have to also examine and update <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">place-airplane-x</code></span>. Our
earlier definition placed the airplane at an arbitrary
<span style="font-style: italic">y</span>-coordinate; now we have to take the
<span style="font-style: italic">y</span>-coordinate from the World State:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun place-airplane-xy(w):
  I.place-image(AIRPLANE,
    w.x,
    w.y,
    BACKGROUND)
end</code></pre></div></div></div><div class="SIntrapara">Notice that we canâ€™t really reuse the previous definition because it hard-coded
the <span style="font-style: italic">y</span>-position, which we must now make a parameter.</div>&#13;
<h4 class="heading">27.5.3<span class="stt">Â </span><a name="(part._.Finishing_.Touches)"/>Finishing Touches<span class="button-group"><a href="#(part._.Finishing_.Touches)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">Are we done? It would seem so: weâ€™ve examined all the procedures that
consume and produce World State and updated them
appropriately. Actually, weâ€™re forgetting one small thing: the initial
World State given to the reactor! If weâ€™ve changed the definition
of World State, then we need to update this too. (We
also need to use the new functions rather than the old ones.)
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">INIT-POS = posn(0, 0)

anim = reactor:
  init: INIT-POS,
  on-tick: move-airplane-xy-on-tick,
  to-draw: place-airplane-xy
end

R.interact(anim)</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Itâ€™s a little unsatisfactory to have the airplane truncated by the
screen. You can use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">I.image-width</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">I.image-height</code></span> to
obtain the dimensions of an image, such as the airplane. Use these to
ensure the airplane fits entirely within the screen for the initial scene,
and similarly in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">move-airplane-xy-on-tick</code></span>.</p></blockquote></blockquote>&#13;
<h3 class="heading">27.6<span class="stt">Â </span><a name="(part._.Version__.Responding_to_.Keystrokes)"/>Version: Responding to Keystrokes<span class="button-group"><a href="#(part._.Version__.Responding_to_.Keystrokes)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Now that we have the airplane descending, thereâ€™s no reason it canâ€™t
ascend as well.
<a href="https://drive.google.com/file/d/1IZw4NrmXsJ-KRaE1GNRhL2Cl3kU27whu/view?usp=share_link">Hereâ€™s a video.</a></p><p>Weâ€™ll use the keyboard to control its motion: specifically, the up-key
will make it move up, while the down-key will make it descend even
faster. This is easy to support using what we already know: we just
need to provide one more handler using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">on-key</code></span>. This handler
takes <span class="emph">two</span> arguments: the first is the current value of the
world, while the second is a representation of which key was
pressed. For the purposes of this program, the only key values we care
about are <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"up"</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"down"</code></span>.</p><p/><div class="SIntrapara">This gives us a fairly comprehensive view of the core capabilities of
reactors:
</div><div class="SIntrapara"><blockquote class="SCentered"><p><img src="../Images/4925a999ce7daf16dda269c55117e5c5.png" alt="" data-original-src="https://dcic-world.org/2025-08-27/world-automaton.jpg"/></p></blockquote></div><div class="SIntrapara">We just define a group of functions to perform all our desired
actions, and the reactor strings them together. Some functions update
world values (sometimes taking additional information about a
stimulus, such as the key pressed), while others transform them into
output (such as what we see on the screen).</div><p/><div class="SIntrapara">Returning to our program, letâ€™s define a constant representing how
much distance a key represents:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">KEY-DISTANCE = 10</code></pre></div></div></div><div class="SIntrapara">Now we can define a function that alterâ€™s the airplaneâ€™s position by that
distance depending on which key is pressed:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun alter-airplane-y-on-key(w, key):
  ask:
    | key == "up"   then: posn(w.x, w.y - KEY-DISTANCE)
    | key == "down" then: posn(w.x, w.y + KEY-DISTANCE)
    | otherwise: w
  end
end</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Why does this function definition contain
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">| otherwise: w</code></pre></div></div></div><div class="SIntrapara">as its last condition?</div></blockquote></blockquote><p>Notice that if we receive any key other than the two we expect, we
leave the World State as it was; from the userâ€™s perspective, this has
the effect of just ignoring the keystroke. Remove this last clause,
press some other key, and watch what happens!</p><p>No matter what you choose, be sure to test this! Can the airplane drift
off the top of the screen? How about off the screen at the bottom? Can
it overlap with the land or water?</p><p/><div class="SIntrapara">Once weâ€™ve written and thoroughly tested this function, we simply need
to ask Pyret to use it to handle keystrokes:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anim = reactor:
  init: INIT-POS,
  on-tick: move-airplane-xy-on-tick,
  on-key: alter-airplane-y-on-key,
  to-draw: place-airplane-xy
end</code></pre></div></div></div><div class="SIntrapara">Now your airplane moves not only with the passage of time but also in
response to your keystrokes. You can keep it up in the air forever!</div>&#13;
<h3 class="heading">27.7<span class="stt">Â </span><a name="(part._.Version__.Landing)"/>Version: Landing<span class="button-group"><a href="#(part._.Version__.Landing)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Remember that the objective of our game is to land the airplane, not to
keep it airborne indefinitely. That means we need to detect when the
airplane reaches the land or water level and, when it does,
<a href="https://drive.google.com/file/d/1XbO-FHQIveD0f3KCvVlUZPjVLNpHW9NT/view?usp=share_link">terminate the
animation</a>.</p><p/><div class="SIntrapara">First, letâ€™s try to characterize when the animation should halt. This
means writing a function that consumes the current World State and
produces a boolean value: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> if the animation should halt,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span> otherwise. This requires a little arithmetic based on the
airplaneâ€™s size:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun is-on-land-or-water(w):
  w.y &gt;= (HEIGHT - BASE-HEIGHT)
end</code></pre></div></div></div><div class="SIntrapara">We just need to inform Pyret to use this predicate to automatically halt
the reactor:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anim = reactor:
  init: INIT-POS,
  on-tick: move-airplane-xy-on-tick,
  on-key: alter-airplane-y-on-key,
  to-draw: place-airplane-xy,
  stop-when: is-on-land-or-water
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>When you test this, youâ€™ll see it isnâ€™t quite right because it doesnâ€™t
take account of the size of the airplaneâ€™s image. As a result, the
airplane only halts when itâ€™s half-way into the land or water, not when
it first touches down. Adjust the formula so that it halts upon first
contact.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Extend this so that the airplane rolls for a while upon touching land,
decelerating according to the laws of physics.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Suppose the airplane is actually landing at a secret subterranean
airbase. The actual landing strip is actually below ground level, and
opens up only when the airplane comes in to land. That means, after
landing, only the parts of the airplane that stick above ground level
would be visible. Implement this. As a hint, consider modifying
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">place-airplane-xy</code></span>.</p></blockquote></blockquote>&#13;
<h3 class="heading">27.8<span class="stt">Â </span><a name="(part._.Version__.A_.Fixed_.Balloon)"/>Version: A Fixed Balloon<span class="button-group"><a href="#(part._.Version__.A_.Fixed_.Balloon)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Now letâ€™s add a balloon to the scene.
<a href="https://drive.google.com/file/d/1QLt9tdt2sSPWR90-mmMLCDW4ZklgR_lN/view?usp=share_link">Hereâ€™s a video of the action.</a></p><p>Notice that while the airplane moves, everything elseâ€”<wbr/>including the
balloonâ€”<wbr/>stays immobile. Therefore, we do not need to alter the World
State to record the balloonâ€™s position. All we need to do is alter the
conditions under which the program halts: effectively, there is one
more situation under which it terminates, and that is a collision with
the balloon.</p><p>When does the game halt? There are now two circumstances: one is
contact with land or water, and the other is contact with the
balloon. The former remains unchanged from what it was before, so we can
focus on the latter.</p><p/><div class="SIntrapara">Where is the balloon, and how do we represent where it is? The latter
is easy to answer: thatâ€™s what <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">posn</code></span>s are good for. As for the
former, we can decide where it is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BALLOON-LOC = posn(600, 300)</code></pre></div></div></div><div class="SIntrapara">or we can let Pyret pick a random position:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BALLOON-LOC = posn(random(WIDTH), random(HEIGHT))</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Improve the random placement of the balloon so that it is in credible
spaces (e.g., not submerged).</p></blockquote></blockquote><p/><div class="SIntrapara">Given a position for the balloon, we just need to detect
collision. One simple way is as follows: determine whether the
distance between the airplane and the balloon is within some threshold:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun are-overlapping(airplane-posn, balloon-posn):
  distance(airplane-posn, balloon-posn)
    &lt; COLLISION-THRESHOLD
end</code></pre></div></div></div><div class="SIntrapara">where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">COLLISION-THRESHOLD</code></span> is some suitable constant computed
based on the sizes of the airplane and balloon images. (For these
particular images, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">75</code></span> works pretty well.)</div><p/><div class="SIntrapara">What is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distance</code></span>? It consumes two <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">posn</code></span>s and determines
the Euclidean distance between them:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun distance(p1, p2):
  fun square(n): n * n end
  num-sqrt(square(p1.x - p2.x) + square(p1.y - p2.y))
end</code></pre></div></div></div><p/><div class="SIntrapara">Finally, we have to weave together the two termination conditions:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun game-ends(w):
  ask:
    | is-on-land-or-water(w)          then: true
    | are-overlapping(w, BALLOON-LOC) then: true
    | otherwise: false
  end
end</code></pre></div></div></div><div class="SIntrapara">and use it instead:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anim = reactor:
  init: INIT-POS,
  on-tick: move-airplane-xy-on-tick,
  on-key: alter-airplane-y-on-key,
  to-draw: place-airplane-xy,
  stop-when: game-ends
end</code></pre></div></div></div><p/><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Were you surprised by anything? Did the game look as you expected?</p></blockquote></blockquote></div><div class="SIntrapara">Odds are you didnâ€™t see a balloon on the screen! Thatâ€™s because we
didnâ€™t update our display.</div><p/><div class="SIntrapara">You will need to define the balloonâ€™s image:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BALLOON-URL =
  "http://world.cs.brown.edu/1/clipart/balloon-small.png"
BALLOON = I.image-url(BALLOON-URL)</code></pre></div></div></div><div class="SIntrapara">and also update the drawing function:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">BACKGROUND =
  I.place-image(BASE,
    WIDTH / 2, HEIGHT - (BASE-HEIGHT / 2),
    I.place-image(BALLOON,
      BALLOON-LOC.x, BALLOON-LOC.y,
      BLANK-SCENE))</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Do you see how to write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">game-ends</code></span> more concisely?</p></blockquote></blockquote><p/><div class="SIntrapara">Hereâ€™s another version:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun game-ends(w):
  is-on-land-or-water(w) or are-overlapping(w, BALLOON-LOC)
end</code></pre></div></div></div>&#13;
<h3 class="heading">27.9<span class="stt">Â </span><a name="(part._.Version__.Keep_.Your_.Eye_on_the_.Tank)"/>Version: Keep Your Eye on the Tank<span class="button-group"><a href="#(part._.Version__.Keep_.Your_.Eye_on_the_.Tank)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Now weâ€™ll introduce the idea of fuel. In our simplified world, fuel
isnâ€™t necessary to descendâ€”<wbr/>gravity does that automaticallyâ€”<wbr/>but it
is needed to climb. Weâ€™ll assume that fuel is counted in whole number
units, and every ascension consumes one unit of fuel. When you run out
of fuel, the program no longer responds to the up-arrow, so you can no
longer avoid either the balloon or water.</p><p>In the past, weâ€™ve looked at still images of the game video to
determine what is changing and what isnâ€™t.  For this version, we could
easily place a little gauge on the screen to show the quantity of fuel
left. However, we donâ€™t on purpose, to illustrate a principle.</p><p/><div class="SIntrapara"><span style="font-weight: bold">Note</span></div><div class="SIntrapara"><blockquote class="Note"><p>You canâ€™t always determine what is fixed and what is changing just by
looking at the image.  You have to also read the problem statement
carefully, and think about it in depth.</p></blockquote></div><p>Itâ€™s clear from our description that there are two things changing:
the position of the airplane and the quantity of fuel left. Therefore,
the World State must capture the current values of both of these. The
fuel is best represented as a single number. However, we do need to
create a new structure to represent the combination of these two.</p><p/><div class="SIntrapara"><span style="font-weight: bold">World Definition</span></div><div class="SIntrapara"><blockquote class="WorldDef"><p>The World State is a structure representing the airplaneâ€™s current
position and the quantity of fuel left.</p></blockquote></div><p/><div class="SIntrapara">Concretely, we will use this structure:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data World:
  | world(p, f)
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>We could have also defined the World to be a structure consisting of
three components: the airplaneâ€™s <span style="font-style: italic">x</span>-position, the
airplaneâ€™s <span style="font-style: italic">y</span>-position, and the quantity of fuel. Why do we
choose to use the representation above?</p></blockquote></blockquote><p>We can again look at each of the parts of the program to determine
what can stay the same and what changes. Concretely, we must focus on
the functions that consume and produce <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">World</code></span>s.</p><p/><div class="SIntrapara">On each tick, we consume a world and compute one. The passage of time
does not consume any fuel, so this code can remain unchanged, other
than having to create a structure containing the current amount of
fuel. Concretely:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun move-airplane-xy-on-tick(w :: World):
  world(
    posn(
      move-airplane-wrapping-x-on-tick(w.p.x),
      move-airplane-y-on-tick(w.p.y)),
    w.f)
end</code></pre></div></div></div><div class="SIntrapara">Similarly, the function that responds to keystrokes clearly needs to
take into account how much fuel is left:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun alter-airplane-y-on-key(w, key):
  ask:
    | key == "up"   then:
      if w.f &gt; 0:
        world(posn(w.p.x, w.p.y - KEY-DISTANCE), w.f - 1)
      else:
        w # there's no fuel, so ignore the keystroke
      end
    | key == "down" then:
      world(posn(w.p.x, w.p.y + KEY-DISTANCE), w.f)
    | otherwise: w
  end
end</code></pre></div></div></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Updating the function that renders a scene. Recall that the world has
two fields; one of them corresponds to what we used to draw before, and
the other isnâ€™t being drawn in the output.</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What else do you need to change to get a working program?</p></blockquote></blockquote><p>You should have noticed that your initial world value is also
incorrect because it doesnâ€™t account for fuel. What are interesting
fuel values to try?</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Extend your program to draw a fuel gauge.</p></blockquote></blockquote>&#13;
<h3 class="heading">27.10<span class="stt">Â </span><a name="(part._.Version__.The_.Balloon_.Moves__.Too)"/>Version: The Balloon Moves, Too<span class="button-group"><a href="#(part._.Version__.The_.Balloon_.Moves__.Too)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Until now weâ€™ve left our balloon immobile. Letâ€™s now make the game
more interesting by letting the balloon move, as
<a href="https://drive.google.com/file/d/19kxqArza5y72V9xIezUtPi8PNV33KsG3/view?usp=share_link">this video shows.</a></p><p>Obviously, the balloonâ€™s location needs to also become part of the
World State.</p><p/><div class="SIntrapara"><span style="font-weight: bold">World Definition</span></div><div class="SIntrapara"><blockquote class="WorldDef"><p>The World State is a structure representing the planeâ€™s current
position, the balloonâ€™s current position, and the quantity of fuel
left.</p></blockquote></div><p/><div class="SIntrapara">Here is a representation of the world state. As these states become
more complex, itâ€™s important to add annotations so we can keep track
of whatâ€™s what.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data World:
  | world(p :: Posn, b :: Posn, f :: Number)
end</code></pre></div></div></div><div class="SIntrapara">With this definition, we obviously need to re-write all our previous
definitions. Most of this is quite routine relative to what weâ€™ve seen
before. The only detail we havenâ€™t really specified is how the balloon
is supposed to move: in what direction, at what speed, and what to do
at the edges. Weâ€™ll let you use your imagination for this one!
(Remember that the closer the balloon is to land, the harder it is to
safely land the plane.)</div><p/><div class="SIntrapara">We thus have to modify:
</div><div class="SIntrapara"><ul><li><p>The background image (to remove the static balloon).</p></li><li><p>The drawing handler (to draw the balloon at its position).</p></li><li><p>The timer handler (to move the balloon as well as the
airplane).</p></li><li><p>The key handler (to construct world data that leaves the balloon
unchanged).</p></li><li><p>The termination condition (to account for the balloonâ€™s dynamic
location).</p></li></ul></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Modify each of the above functions, along with their test cases.</p></blockquote></blockquote>&#13;
<h3 class="heading">27.11<span class="stt">Â </span><a name="(part._.Version__.One__.Two_______.Ninety-.Nine_.Luftballons_)"/>Version: One, Two, ..., Ninety-Nine Luftballons!<span class="button-group"><a href="#(part._.Version__.One__.Two_______.Ninety-.Nine_.Luftballons_)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Finally, thereâ€™s no need to limit ourselves to only one balloon. How
many is right? Two? Three? Ten? ... Why fix any one number? It could be
a balloon festival!</p><p>Similarly, many games have levels that become progressively harder; we
could do the same, letting the number of balloons be part of what
changes across levels. However, there is conceptually no big
difference between having two balloons and five; the code to control
each balloon is essentially the same.</p><p>We need to represent a collection of balloons. We can use a list to
represent them. Thus:</p><p/><div class="SIntrapara"><span style="font-weight: bold">World Definition</span></div><div class="SIntrapara"><blockquote class="WorldDef"><p>The World State is a structure representing the planeâ€™s current
position, a list of balloon positions, and the quantity of fuel
left.</p></blockquote></div><p/><div class="SIntrapara">You should now use the design recipe for lists of structures to
rewrite the functions. Notice that youâ€™ve already written the function
to move one balloon. Whatâ€™s left?
</div><div class="SIntrapara"><ol><li><p>Apply the same function to each balloon in the list.</p></li><li><p>Determine what to do if two balloons collide.</p></li></ol></div><div class="SIntrapara">For now, you can avoid the latter problem by placing each balloon
sufficiently spread apart along the <span style="font-style: italic">x</span>-dimension and
letting them move only up and down.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Introduce a concept of <span class="emph">wind</span>, which affects balloons but not the
airplane. After random periods of time, the wind blows with random
speed and direction, causing the ballooons to move laterally.</p></blockquote></blockquote>    
</body>
</html>