["```cpp\n#include <iostream> using namespace std;   int main() {  cout << __builtin_cpu_supports(\"sse\") << endl; cout << __builtin_cpu_supports(\"sse2\") << endl; cout << __builtin_cpu_supports(\"avx\") << endl; cout << __builtin_cpu_supports(\"avx2\") << endl; cout << __builtin_cpu_supports(\"avx512f\") << endl;   return 0; } \n```", "```cpp\n#pragma GCC target(\"avx2\") #pragma GCC optimize(\"O3\")  #include <x86intrin.h> #include <bits/stdc++.h>  using namespace std; \n```", "```cpp\ndouble a[100], b[100], c[100];   // iterate in blocks of 4, // because that's how many doubles can fit into a 256-bit register for (int i = 0; i < 100; i += 4) {  // load two 256-bit segments into registers __m256d x = _mm256_loadu_pd(&a[i]); __m256d y = _mm256_loadu_pd(&b[i]);   // add 4+4 64-bit numbers together __m256d z = _mm256_add_pd(x, y);   // write the 256-bit result into memory, starting with c[i] _mm256_storeu_pd(&c[i], z); } \n```", "```cpp\nvmovapd ymm1, YMMWORD PTR a[rax] vaddpd  ymm0, ymm1, YMMWORD PTR b[rax] vmovapd YMMWORD PTR c[rax], ymm0 \n```", "```cpp\ntypedef int v8si __attribute__ (( vector_size(32) )); // type ^   ^ typename          size in bytes ^ \n```", "```cpp\nv4si a = {1, 2, 3, 5}; v4si b = {8, 13, 21, 34};   v4si c = a + b;   for (int i = 0; i < 4; i++)  printf(\"%d\\n\", c[i]);   c *= 2; // multiply by scalar  for (int i = 0; i < 4; i++)  printf(\"%d\\n\", c[i]); \n```", "```cpp\ntypedef double v4d __attribute__ (( vector_size(32) )); v4d a[100/4], b[100/4], c[100/4];   for (int i = 0; i < 100/4; i++)  c[i] = a[i] + b[i]; \n```", "```cpp\nv8f x; int mask = _mm256_movemask_ps((__m256) x) \n```"]