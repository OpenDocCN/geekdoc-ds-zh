["```py\nmy_running_ave = 1.0\nmy_running_ave\n## 1.0\nmy_running_ave = ((2-1)*my_running_ave + 3.0)/2\nmy_running_ave\n## 2.0\nmy_running_ave = ((3-1)*my_running_ave + 2.0)/3\nmy_running_ave\n## 2.0\n```", "```py\nmy_ave = RunningMean() # create running average object\nmy_ave.get_current_xbar() # no data yet!\nmy_ave.update(1.) # first data point\nmy_ave.get_current_xbar() # xbar_1\n## 1.0\nmy_ave.update(3.)  # second data point\nmy_ave.get_current_xbar()  #xbar_2\n## 2.0\nmy_ave.n   # my_ave.n instead of self.n\n## 2\n```", "```py\nclass RunningMean:\n \"\"\"Updates a running average\"\"\"\n def __init__(self):\n self.current_xbar = 0.0\n self.n = 0\n def update(self, new_x):\n self.n += 1\n self.current_xbar *= (self.n-1)\n self.current_xbar += new_x\n self.current_xbar /= self.n\n def get_current_xbar(self):\n if self.n == 0:\n return None\n else:\n return self.current_xbar\n```", "```py\nimport numpy as np\n\nclass RunningCI(RunningMean):# <-notice what's inside the parentheses\n \"\"\"Updates a running average and \n gives you a known-variance confidence interval\"\"\"\n\n def __init__(self, known_var):\n super().__init__()\n self.known_var = known_var\n\n def get_current_interval(self):\n if self.n == 0:\n return None\n else:\n half_width = 1.96 * np.sqrt(self.known_var / self.n) \n left_num = self.current_xbar - half_width\n right_num = self.current_xbar + half_width\n return np.array([left_num, right_num])\n```", "```py\nmy_ci = RunningCI(1) # create running average object\nmy_ci.get_current_xbar() # no data yet!\nmy_ci.update(1.) \nmy_ci.get_current_interval() \n## array([-0.96,  2.96])\nmy_ci.update(3.) \nmy_ci.get_current_interval() \n## array([0.61407071, 3.38592929])\n```", "```py\nfor datum in time_series:\n for thing in obj_list:\n thing.update(xt)\n```", "```py\nfor datum in time_series:\n for thing in obj_list:\n if isinstance(thing, class1):\n thing.updatec1(xt)\n if isinstance(thing, class2):\n thing.updatec2(xt)\n if isinstance(thing, class3):\n thing.updatec3(xt)\n if isinstance(thing, class4):\n thing.updatec4(xt)\n if isinstance(thing, class5):\n thing.updatec5(xt)\n if isinstance(thing, class6):\n thing.updatec6(xt)\n```", "```py\nclass RunningCI2:\n \"\"\"Updates a running average and \n gives you a known-variance confidence interval\"\"\"\n\n def __init__(self, known_var):\n self.mean = RunningMean()\n self.known_var = known_var\n\n def update(self, new_x): \n self.mean.update(new_x)\n\n def get_current_interval(self):\n if self.n == 0:\n return None\n else:\n half_width = 1.96 * np.sqrt(self.known_var / self.n) \n left = self.mean.get_current_xbar() - half_width\n right = self.mean.get_current_xbar() + half_width\n return np.array([left, right])\n```", "```py\nmy_obj.print()\n```", "```py\nprint(my_obj)\n```", "```py\n# print works on pretty much everything\nprint(myObj)\nprint(myObjOfADifferentClass)\nprint(aThirdClassObject)\n```", "```py\nplot\n```", "```py\n## function (x, y, ...) \n## UseMethod(\"plot\")\n## <bytecode: 0x5654afa2fd00>\n## <environment: namespace:base>\n```", "```py\nlength(methods(plot))\n```", "```py\n## [1] 39\n```", "```py\naDF <-  data.frame(matrix(rnorm(100), nrow = 10))\nis.object(aDF) # is this s3?\n## [1] TRUE\nclass(aDF)\n## [1] \"data.frame\"\nplot(aDF)\n```", "```py\nmyECDF <-  ecdf(rnorm(100))\nis.object(myECDF)\n## [1] TRUE\nclass(myECDF)\n## [1] \"ecdf\"     \"stepfun\"  \"function\"\nplot(myECDF)\n```", "```py\nmyThing <-  1:3\nattributes(myThing)\n## NULL\nclass(myThing) <- \"CoolClass\"\nattributes(myThing) # also try class(myThing)\n## $class\n## [1] \"CoolClass\"\n```", "```py\nsummary(myThing)\n## [1] \"No summary available!\"\n## [1] \"Cool Classes are too cool for summaries!\"\n## [1] \":)\"\n```", "```py\nsummary.CoolClass <-  function(object,...){\n print(\"No summary available!\")\n print(\"Cool Classes are too cool for summaries!\")\n print(\":)\")\n}\n```", "```py\nlibrary(Matrix)\nM <-  Matrix(10 +  1:28, 4, 7)\nisS4(M)\n## [1] TRUE\nM\n## 4 x 7 Matrix of class \"dgeMatrix\"\n##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]\n## [1,]   11   15   19   23   27   31   35\n## [2,]   12   16   20   24   28   32   36\n## [3,]   13   17   21   25   29   33   37\n## [4,]   14   18   22   26   30   34   38\nM@Dim\n## [1] 4 7\n```", "```py\nsetClass(\"RunningMean\",\n slots = list(n = \"integer\", \n currentXbar = \"numeric\"))\nsetClass(\"RunningCI\",\n slots = list(knownVar = \"numeric\"),\n contains = \"RunningMean\")\n```", "```py\nnew(\"RunningMean\", n = 0L, currentXbar = 0)\nnew(\"RunningCI\", n = 0L, currentXbar = 0, knownVar = 1.0)\n```", "```py\n## Creating a new generic function for 'update' in the global environment\n## [1] \"update\"\n```", "```py\nsetGeneric(\"update\", function(oldMean, newNum) {\n standardGeneric(\"update\")\n})\nsetMethod(\"update\",\n c(oldMean = \"RunningMean\", newNum = \"numeric\"),\n function(oldMean, newNum) {\n oldN <-  oldMean@n\n oldAve <-  oldMean@currentXbar\n newAve <-  (oldAve*oldN +  newNum)/(oldN +  1)\n newN <-  oldN +  1L\n return(new(\"RunningMean\", n = newN, currentXbar = newAve))\n }\n)\nsetMethod(\"update\",\n c(oldMean = \"RunningCI\", newNum = \"numeric\"),\n function(oldMean, newNum) {\n oldN <-  oldMean@n\n oldAve <-  oldMean@currentXbar\n newAve <-  (oldAve*oldN +  newNum)/(oldN +  1)\n newN <-  oldN +  1L\n return(new(\"RunningCI\", n = newN, currentXbar = newAve, \n knownVar = oldMean@knownVar))\n }\n)\n```", "```py\nmyAve <-  new(\"RunningMean\", n = 0L, currentXbar = 0)\nmyAve <-  update(myAve, 3)\nmyAve\n## An object of class \"RunningMean\"\n## Slot \"n\":\n## [1] 1\n## \n## Slot \"currentXbar\":\n## [1] 3\nmyAve <-  update(myAve, 1)\nmyAve\n## An object of class \"RunningMean\"\n## Slot \"n\":\n## [1] 2\n## \n## Slot \"currentXbar\":\n## [1] 2\n\nmyCI <-  new(\"RunningCI\", n = 0L, currentXbar = 0, knownVar = 1.0)\nmyCI <-  update(myCI, 3)\nmyCI\n## An object of class \"RunningCI\"\n## Slot \"knownVar\":\n## [1] 1\n## \n## Slot \"n\":\n## [1] 1\n## \n## Slot \"currentXbar\":\n## [1] 3\nmyCI <-  update(myCI, 1)\nmyCI\n## An object of class \"RunningCI\"\n## Slot \"knownVar\":\n## [1] 1\n## \n## Slot \"n\":\n## [1] 2\n## \n## Slot \"currentXbar\":\n## [1] 2\n```", "```py\nRunningMeanRC <-  setRefClass(\"RunningMeanRC\", \n fields = list(current_xbar = \"numeric\",\n n = \"integer\"),\n methods = list(\n update = function(new_x){\n n <<-  n +  1L\n new_sum <-  current_xbar*(n-1) +  new_x\n current_xbar <<-  new_sum/n\n }))\n```", "```py\nmy_ave <-  RunningMeanRC$new(current_xbar=0, n=0L)\nmy_ave\n## Reference class object of class \"RunningMeanRC\"\n## Field \"current_xbar\":\n## [1] 0\n## Field \"n\":\n## [1] 0\nmy_ave$update(1.) \nmy_ave$current_xbar\n## [1] 1\nmy_ave$n \n## [1] 1\nmy_ave$update(3.) \nmy_ave$current_xbar\n## [1] 2\nmy_ave$n \n## [1] 2\n```", "```py\nlibrary(R6)\n\nRunningMeanR6 <-  R6Class(\"RunningMeanR6\",\n public = list(\n current_xbar = NULL,\n n = NULL,\n initialize = function(current_xbar = NA, n = NA) {\n self$current_xbar <-  current_xbar\n self$n <-  n\n },\n update = function(new_x) {\n newSum <-  self$current_xbar*self$n +  new_x\n self$n <-  self$n +  1L\n self$current_xbar <-  newSum /  self$n\n }\n )\n)\nmy_r6_ave <-  RunningMeanR6$new(current_xbar=0, n=0L)\nmy_r6_ave\n## <RunningMeanR6>\n##   Public:\n##     clone: function (deep = FALSE) \n##     current_xbar: 0\n##     initialize: function (current_xbar = NA, n = NA) \n##     n: 0\n##     update: function (new_x)\nmy_r6_ave$update(1.) \nmy_r6_ave$current_xbar\n## [1] 1\nmy_r6_ave$n \n## [1] 1\nmy_r6_ave$update(3.) \nmy_r6_ave$current_xbar\n## [1] 2\nmy_r6_ave$n \n## [1] 2\n```", "```py\nmod = SimpleLinReg()\nmod.get_coeffs()\nx = np.arange(10)\ny = 1 + .2 * x + np.random.normal(size=10)\nmod.fit(x,y)\nmod.get_coeffs()\n```"]