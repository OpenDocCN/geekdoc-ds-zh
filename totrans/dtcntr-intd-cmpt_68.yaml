- en: 23Â Partial DomainsğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 23Â éƒ¨åˆ†åŸŸğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/partial-domains.html](https://dcic-world.org/2025-08-27/partial-domains.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/partial-domains.html](https://dcic-world.org/2025-08-27/partial-domains.html)
- en: '| Â Â Â Â [23.1Â A Non-Solution](#%28part._pd-sentinel%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [23.1Â ä¸€ä¸ªéè§£å†³æ–¹æ¡ˆ](#%28part._pd-sentinel%29) |'
- en: '| Â Â Â Â [23.2Â Exceptions](#%28part._pd-exceptions%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [23.2Â å¼‚å¸¸](#%28part._pd-exceptions%29) |'
- en: '| Â Â Â Â [23.3Â The Option Type](#%28part._pd-option%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [23.3Â é€‰é¡¹ç±»å‹](#%28part._pd-option%29) |'
- en: '| Â Â Â Â [23.4Â Total Domains, Dynamically](#%28part._pd-total-dyn%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [23.4Â åŠ¨æ€æ€»åŸŸ](#%28part._pd-total-dyn%29) |'
- en: '| Â Â Â Â [23.5Â Total Domains, Statically](#%28part._pd-total-static%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [23.5Â é™æ€æ€»åŸŸ](#%28part._pd-total-static%29) |'
- en: '| Â Â Â Â [23.6Â Summary](#%28part._pd-summary%29) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [23.6Â æ€»ç»“](#%28part._pd-summary%29) |'
- en: '| Â Â Â Â [23.7Â A Note on Notation](#%28part._pd-pyret-list-constr%29) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [23.7Â å…³äºç¬¦å·çš„è¯´æ˜](#%28part._pd-pyret-list-constr%29) |'
- en: Sometimes, we cannot precisely capture the domain of a function with the precision
    we would like. In mathematics, if a function cannot accept all values in its domain,
    it is called partial. This is a problem we encounter more often than we might
    like in programming, so we need to know how to handle it. There are actually several
    programming strategies that we can use, with different benefits and weaknesses.
    Here, we will examine some of them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬æ— æ³•ç²¾ç¡®åœ°ç”¨æˆ‘ä»¬æƒ³è¦çš„ç²¾åº¦æ¥æ•æ‰å‡½æ•°çš„åŸŸã€‚åœ¨æ•°å­¦ä¸­ï¼Œå¦‚æœä¸€ä¸ªå‡½æ•°ä¸èƒ½æ¥å—å…¶åŸŸä¸­çš„æ‰€æœ‰å€¼ï¼Œå®ƒè¢«ç§°ä¸ºéƒ¨åˆ†å‡½æ•°ã€‚è¿™æ˜¯æˆ‘ä»¬å¯èƒ½åœ¨ç¼–ç¨‹ä¸­é‡åˆ°æ¯”æˆ‘ä»¬æƒ³è±¡çš„æ›´é¢‘ç¹çš„é—®é¢˜ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦çŸ¥é“å¦‚ä½•å¤„ç†å®ƒã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å‡ ç§ç¼–ç¨‹ç­–ç•¥ï¼Œå®ƒä»¬æœ‰ä¸åŒçš„ä¼˜ç‚¹å’Œç¼ºç‚¹ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†æ£€æŸ¥å…¶ä¸­çš„ä¸€äº›ã€‚
- en: 'Consider some functions on lists of numbers, such as computing the median or
    the average. In both cases, these functions donâ€™t work on all lists of numbers:
    there is no median for the empty list, and we canâ€™t compute its average either,
    because there are no elements (so trying to compute the average would result in
    a divison-by-zero error). Thus, while it is a convenient fiction to write'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘ä¸€äº›æ•°å­—åˆ—è¡¨ä¸Šçš„å‡½æ•°ï¼Œä¾‹å¦‚è®¡ç®—ä¸­ä½æ•°æˆ–å¹³å‡å€¼ã€‚åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œè¿™äº›å‡½æ•°å¹¶ä¸é€‚ç”¨äºæ‰€æœ‰æ•°å­—åˆ—è¡¨ï¼šç©ºåˆ—è¡¨æ²¡æœ‰ä¸­ä½æ•°ï¼Œæˆ‘ä»¬ä¹Ÿä¸èƒ½è®¡ç®—å®ƒçš„å¹³å‡å€¼ï¼Œå› ä¸ºæ²¡æœ‰å…ƒç´ ï¼ˆæ‰€ä»¥å°è¯•è®¡ç®—å¹³å‡å€¼ä¼šå¯¼è‡´é™¤ä»¥é›¶é”™è¯¯ï¼‰ã€‚å› æ­¤ï¼Œè™½ç„¶å°†
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'it is just that: a (bit of a) fiction. The function is only defined on non-empty
    lists.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åªæ˜¯ï¼šæœ‰ç‚¹è™šæ„ã€‚å‡½æ•°ä»…åœ¨éç©ºåˆ—è¡¨ä¸Šå®šä¹‰ã€‚
- en: We will now see how to handle this from a software engineering perspective.
    Weâ€™ll specifically work through `average` because the function is simple enough
    that we can focus on the software structure without getting lost in the solution
    details. There are at least four solutions, and one non-solution.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨å°†ä»ä¸€ä¸ªè½¯ä»¶å·¥ç¨‹çš„è§’åº¦æ¥çœ‹å¦‚ä½•å¤„ç†è¿™ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬å°†ç‰¹åˆ«é€šè¿‡`average`å‡½æ•°æ¥è¿›è¡Œï¼Œå› ä¸ºè¿™ä¸ªå‡½æ•°è¶³å¤Ÿç®€å•ï¼Œæˆ‘ä»¬å¯ä»¥ä¸“æ³¨äºè½¯ä»¶ç»“æ„ï¼Œè€Œä¸ä¼šè¿·å¤±åœ¨è§£å†³æ–¹æ¡ˆçš„ç»†èŠ‚ä¸­ã€‚è‡³å°‘æœ‰å››ç§è§£å†³æ–¹æ¡ˆå’Œä¸€ä¸ªéè§£å†³æ–¹æ¡ˆã€‚
- en: 23.1Â A Non-Solution[ğŸ”—](#(part._pd-sentinel) "Link to here")
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.1Â ä¸€ä¸ªéè§£å†³æ–¹æ¡ˆ[ğŸ”—](#(part._pd-sentinel) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'We will start with a strategy that has often been used by programmers in the
    past, but that we reject as a non-solution. This strategy is to make the above
    contract absolutely correct by returning a value in the erroneous case; this value
    is often called a sentinel. For instance, the sentinel might be `0`. Here is the
    full program:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä»ä¸€ä¸ªè¿‡å»ç¨‹åºå‘˜ç»å¸¸ä½¿ç”¨çš„ç­–ç•¥å¼€å§‹ï¼Œä½†æˆ‘ä»¬å°†å…¶æ‹’ç»ä¸ºä¸€ä¸ªéè§£å†³æ–¹æ¡ˆã€‚è¿™ä¸ªç­–ç•¥æ˜¯é€šè¿‡åœ¨é”™è¯¯æƒ…å†µä¸‹è¿”å›ä¸€ä¸ªå€¼æ¥ä½¿ä¸Šè¿°åˆåŒç»å¯¹æ­£ç¡®ï¼›è¿™ä¸ªå€¼é€šå¸¸è¢«ç§°ä¸ºå“¨å…µã€‚ä¾‹å¦‚ï¼Œå“¨å…µå¯èƒ½æ˜¯`0`ã€‚ä»¥ä¸‹æ˜¯å®Œæ•´çš„ç¨‹åºï¼š
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'and here are a few tests:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€äº›æµ‹è¯•ï¼š
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Is there a test missing here? Yes, for the empty list! Should we add it?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯å¦é—æ¼äº†æŸä¸ªæµ‹è¯•ï¼Ÿæ˜¯çš„ï¼Œå¯¹äºç©ºåˆ—è¡¨ï¼æˆ‘ä»¬åº”è¯¥æ·»åŠ å®ƒå—ï¼Ÿ
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The question is, should we be happy with this â€œsolutionâ€? There are two problems
    with it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬åº”è¯¥å¯¹è¿™ä¸ªâ€œè§£å†³æ–¹æ¡ˆâ€æ„Ÿåˆ°æ»¡æ„å—ï¼Ÿå®ƒæœ‰ä¸¤ä¸ªé—®é¢˜ã€‚
- en: First, every single use of `avg0` needs to check for whether it got back `0`
    or not. If it did not, then the answer is legitimate, and it can proceed with
    the computation. But if it did, then it has to assume that the input may have
    been illegitimate, and cannot use the answer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæ¯æ¬¡ä½¿ç”¨`avg0`éƒ½éœ€è¦æ£€æŸ¥å®ƒæ˜¯å¦è¿”å›äº†`0`ã€‚å¦‚æœæ²¡æœ‰ï¼Œé‚£ä¹ˆç­”æ¡ˆæ˜¯åˆæ³•çš„ï¼Œå®ƒå¯ä»¥ç»§ç»­è¿›è¡Œè®¡ç®—ã€‚ä½†å¦‚æœå®ƒç¡®å®è¿”å›äº†`0`ï¼Œé‚£ä¹ˆå®ƒå¿…é¡»å‡è®¾è¾“å…¥å¯èƒ½æ˜¯ä¸åˆæ³•çš„ï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨è¯¥ç­”æ¡ˆã€‚
- en: 'Second, even thatâ€™s not quite true. To understand why, we need to write a few
    more tests:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒï¼Œå³ä½¿è¿™æ ·ä¹Ÿä¸å®Œå…¨æ­£ç¡®ã€‚ä¸ºäº†ç†è§£ä¸ºä»€ä¹ˆï¼Œæˆ‘ä»¬éœ€è¦ç¼–å†™ä¸€äº›æ›´å¤šçš„æµ‹è¯•ï¼š
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So the problem is that when `avg0` returns `0`, we donâ€™t know whether thatâ€™s
    a legitimate answer or a â€œfakeâ€ answer that stands for â€œthis is not a valid inputâ€.
    So even our strategy of â€œcheck everywhereâ€ fails!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥é—®é¢˜æ˜¯ï¼Œå½“`avg0`è¿”å›`0`æ—¶ï¼Œæˆ‘ä»¬ä¸çŸ¥é“è¿™æ˜¯å¦æ˜¯ä¸€ä¸ªåˆæ³•çš„ç­”æ¡ˆæˆ–ä»£è¡¨â€œè¿™ä¸æ˜¯æœ‰æ•ˆè¾“å…¥â€çš„â€œè™šå‡â€ç­”æ¡ˆã€‚æ‰€ä»¥å³ä½¿æ˜¯æˆ‘ä»¬çš„â€œæ£€æŸ¥ä¸€åˆ‡â€ç­–ç•¥ä¹Ÿå¤±è´¥äº†ï¼
- en: 'Ah, but maybe the problem is the use of `0`! Perhaps we could use a different
    number that would work. How about `1`? Or `-1`? The question is: Is there any
    number that reasonably canâ€™t be the average of an actual input? (And in general,
    for all problems, can you be sure of this?) Well, of course not.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: å•Šï¼Œä½†ä¹Ÿè®¸é—®é¢˜æ˜¯ä½¿ç”¨äº†`0`ï¼ä¹Ÿè®¸æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªä¸åŒçš„æ•°å­—ï¼Œå®ƒä¼šèµ·ä½œç”¨ã€‚æ¯”å¦‚`1`ï¼Ÿæˆ–è€…`-1`ï¼Ÿé—®é¢˜æ˜¯ï¼šæœ‰æ²¡æœ‰ä»»ä½•æ•°å­—åˆç†åœ°ä¸èƒ½æ˜¯å®é™…è¾“å…¥çš„å¹³å‡å€¼ï¼Ÿï¼ˆå¹¶ä¸”å¯¹äºæ‰€æœ‰é—®é¢˜ï¼Œä½ èƒ½ç¡®å®šè¿™ä¸€ç‚¹å—ï¼Ÿï¼‰å½“ç„¶ä¸æ˜¯ã€‚
- en: 'Thatâ€™s why this is a non-solution. It has created several problems:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯ä¸ºä»€ä¹ˆè¿™ä¸æ˜¯ä¸€ä¸ªè§£å†³æ–¹æ¡ˆã€‚å®ƒå·²ç»é€ æˆäº†ä¸€äº›é—®é¢˜ï¼š
- en: We canâ€™t tell from the output whether the input was invalid.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ— æ³•ä»è¾“å‡ºä¸­åˆ¤æ–­è¾“å…¥æ˜¯å¦æ— æ•ˆã€‚
- en: That means every caller needs to check.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€æ¯ä¸ªè°ƒç”¨è€…éƒ½éœ€è¦è¿›è¡Œæ£€æŸ¥ã€‚
- en: A caller that forgets to check may compute with nonsense.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªå¿˜è®°æ£€æŸ¥çš„è°ƒç”¨è€…å¯èƒ½ä¼šç”¨èƒ¡è¨€ä¹±è¯­è¿›è¡Œè®¡ç®—ã€‚
- en: 'Compositionality is ruined: any function passed `average` needs to know to
    check the output (and there is nothing in the contract to warn it!).'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç»„åˆæ€§è¢«ç ´åï¼šä»»ä½•ä¼ é€’ç»™`average`çš„å‡½æ•°éƒ½éœ€è¦çŸ¥é“æ£€æŸ¥è¾“å‡ºï¼ˆè€Œä¸”åœ¨å¥‘çº¦ä¸­æ²¡æœ‰ä»»ä½•è­¦å‘Šï¼ï¼‰ã€‚
- en: Indeed, decades of experience tells us that some of the worldâ€™s most sophisticated
    programmers have not been able to handle this issue even when it matters most,
    resulting in numerous, pernicious security problems. Therefore, we should now
    regard this as a flawed approach to software construction, and never do it ourselves.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œæ•°åå¹´çš„ç»éªŒå‘Šè¯‰æˆ‘ä»¬ï¼Œä¸–ç•Œä¸Šä¸€äº›æœ€å¤æ‚çš„ç¨‹åºå‘˜ç”šè‡³åœ¨æ²¡æœ‰æœ€å…³é”®çš„æ—¶å€™ä¹Ÿæ— æ³•å¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œå¯¼è‡´äº†è®¸å¤šæœ‰å®³çš„å®‰å…¨é—®é¢˜ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ç°åœ¨åº”è¯¥å°†è¿™ç§æ–¹æ³•è§†ä¸ºè½¯ä»¶æ„å»ºä¸­çš„ä¸€ä¸ªç¼ºé™·ï¼Œå¹¶ä¸”æ°¸è¿œä¸è¦è‡ªå·±è¿™æ ·åšã€‚
- en: Letâ€™s instead look at four actual solutions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ¥çœ‹çœ‹å››ç§å®é™…çš„è§£å†³æ–¹æ¡ˆã€‚
- en: 23.2Â Exceptions[ğŸ”—](#(part._pd-exceptions) "Link to here")
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.2 å¼‚å¸¸[ğŸ”—](#(part._pd-exceptions) "é“¾æ¥åˆ°æ­¤å¤„")
- en: One technique that many languages, including Pyret, provide is called the exception.
    An exception is a special programming construct that effectively halts the computation
    because the program cannot figure out how to continue computing with the data
    it has. There are more sophisticated forms of exceptions in some languages, but
    here we focus simply on using them as a strategy for handling partiality.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: è®¸å¤šè¯­è¨€ï¼ŒåŒ…æ‹¬Pyretï¼Œæä¾›çš„ä¸€ç§æŠ€æœ¯è¢«ç§°ä¸ºå¼‚å¸¸ã€‚å¼‚å¸¸æ˜¯ä¸€ç§ç‰¹æ®Šçš„ç¼–ç¨‹ç»“æ„ï¼Œå®ƒæœ‰æ•ˆåœ°åœæ­¢äº†è®¡ç®—ï¼Œå› ä¸ºç¨‹åºæ— æ³•ç¡®å®šå¦‚ä½•ä½¿ç”¨å®ƒæ‹¥æœ‰çš„æ•°æ®ç»§ç»­è®¡ç®—ã€‚ä¸€äº›è¯­è¨€ä¸­æœ‰æ›´å¤æ‚çš„å¼‚å¸¸å½¢å¼ï¼Œä½†åœ¨è¿™é‡Œæˆ‘ä»¬åªå…³æ³¨å°†å®ƒä»¬ç”¨ä½œå¤„ç†éƒ¨åˆ†æ€§çš„ç­–ç•¥ã€‚
- en: 'Here is the average program written using an exception (we reuse `sum` from
    before):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯ä½¿ç”¨å¼‚å¸¸ç¼–å†™çš„å¹³å‡ç¨‹åºï¼ˆæˆ‘ä»¬é‡ç”¨äº†ä¹‹å‰çš„`sum`ï¼‰ï¼š
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The way `raise` works is that it terminates everything that is waiting to happen.
    For instance, if we were to write
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`raise`å·¥ä½œçš„æ–¹å¼æ˜¯ç»ˆæ­¢æ‰€æœ‰ç­‰å¾…å‘ç”Ÿçš„äº‹æƒ…ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬å†™'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'the `1 + â€¦` part never happens: the whole computation ends. `raise` creates
    exceptions.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`1 + â€¦`éƒ¨åˆ†æ°¸è¿œä¸ä¼šå‘ç”Ÿï¼šæ•´ä¸ªè®¡ç®—ç»“æŸã€‚`raise`åˆ›å»ºå¼‚å¸¸ã€‚'
- en: Again, weâ€™re missing a test. How do we write it?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ ·ï¼Œæˆ‘ä»¬ç¼ºå°‘ä¸€ä¸ªæµ‹è¯•ã€‚æˆ‘ä»¬å¦‚ä½•ç¼–å†™å®ƒï¼Ÿ
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `raises` form takes a string that it matches against that provided to `raise`.
    In act, for convenience, any sub-string of the original string is permitted: we
    can, for instance, also write `check: avg1(empty) raises "no average" avg1(empty)
    raises "empty list" end`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`raises`å½¢å¼æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¯¥å­—ç¬¦ä¸²ä¸æä¾›çš„`raise`è¿›è¡ŒåŒ¹é…ã€‚å®é™…ä¸Šï¼Œä¸ºäº†æ–¹ä¾¿ï¼Œå…è®¸ä»»ä½•åŸå§‹å­—ç¬¦ä¸²çš„å­ä¸²ï¼šä¾‹å¦‚ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å†™`check:
    avg1(empty) raises "no average" avg1(empty) raises "empty list" end`'
- en: In many programming languages, the use of exceptions is the standard way of
    dealing with partiality. It is certainly a pragmatic solution. Observe that we
    got to reuse `sum` from earlier; the contract looks clean; and we only needed
    to use `raise` at the spot where we didnâ€™t know what to do. Whatâ€™s not to like?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è®¸å¤šç¼–ç¨‹è¯­è¨€ä¸­ï¼Œä½¿ç”¨å¼‚å¸¸æ˜¯å¤„ç†éƒ¨åˆ†æ€§çš„æ ‡å‡†æ–¹å¼ã€‚è¿™å½“ç„¶æ˜¯ä¸€ä¸ªå®ç”¨çš„è§£å†³æ–¹æ¡ˆã€‚è§‚å¯Ÿä¸€ä¸‹ï¼Œæˆ‘ä»¬å¾—åˆ°äº†ä¹‹å‰é‡ç”¨çš„`sum`ï¼›å¥‘çº¦çœ‹èµ·æ¥å¾ˆå¹²å‡€ï¼›æˆ‘ä»¬åªéœ€è¦åœ¨ä¸çŸ¥é“è¯¥åšä»€ä¹ˆçš„åœ°æ–¹ä½¿ç”¨`raise`ã€‚æœ‰ä»€ä¹ˆä¸å–œæ¬¢çš„å‘¢ï¼Ÿ
- en: 'There are two main problems with exceptions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: å¼‚å¸¸æœ‰ä¸¤ä¸ªä¸»è¦é—®é¢˜ï¼š
- en: In real systems, exceptions halt a programâ€™s execution in unpredictable ways.
    A caller to `avg1` may be half-way through doing something else (e.g., it may
    have opened a file that it intends to close), but the exception causes the call
    to not finish cleanly, causing the remaining computation to not run, leaving the
    system in a messy state.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨çœŸå®ç³»ç»Ÿä¸­ï¼Œå¼‚å¸¸ä»¥ä¸å¯é¢„æµ‹çš„æ–¹å¼åœæ­¢ç¨‹åºæ‰§è¡Œã€‚`avg1`çš„è°ƒç”¨è€…å¯èƒ½æ­£åœ¨è¿›è¡Œå…¶ä»–äº‹æƒ…çš„ä¸€åŠï¼ˆä¾‹å¦‚ï¼Œå®ƒå¯èƒ½å·²ç»æ‰“å¼€äº†ä¸€ä¸ªæ‰“ç®—å…³é—­çš„æ–‡ä»¶ï¼‰ï¼Œä½†å¼‚å¸¸å¯¼è‡´è°ƒç”¨æ²¡æœ‰å¹²å‡€åœ°å®Œæˆï¼Œå¯¼è‡´å‰©ä½™çš„è®¡ç®—æ²¡æœ‰è¿è¡Œï¼Œä½¿ç³»ç»Ÿå¤„äºæ··ä¹±çŠ¶æ€ã€‚
- en: 'Relatedly, what we presented as a feature should actually be treated as a problem:
    the contract lies! Thereâ€™s no indication at all in the contract that an exception
    might occur. A programmer has to read the whole implementationâ€”<wbr>which could
    change at any timeâ€”<wbr>instead of being able to rely on its published contract,
    when the whole point of contracts was that they saved us from having to read the
    whole implementation!'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ç›¸å…³åœ°ï¼Œæˆ‘ä»¬æå‡ºä½œä¸ºä¸€ä¸ªç‰¹æ€§ï¼Œå®é™…ä¸Šåº”è¯¥è¢«è§†ä¸ºä¸€ä¸ªé—®é¢˜ï¼šå¥‘çº¦ä¸æˆç«‹ï¼å¥‘çº¦ä¸­æ ¹æœ¬æ²¡æœ‰ä»»ä½•è¿¹è±¡è¡¨æ˜å¯èƒ½ä¼šå‘ç”Ÿå¼‚å¸¸ã€‚ç¨‹åºå‘˜å¿…é¡»é˜…è¯»æ•´ä¸ªå®ç°â€”â€”<wbr>è¿™å¯èƒ½ä¼šéšæ—¶å‘ç”Ÿå˜åŒ–â€”â€”<wbr>è€Œä¸æ˜¯èƒ½å¤Ÿä¾èµ–å…¶å‘å¸ƒçš„å¥‘çº¦ï¼Œå¥‘çº¦çš„å…¨éƒ¨æ„ä¹‰åœ¨äºå®ƒä»¬è®©æˆ‘ä»¬å…äºé˜…è¯»æ•´ä¸ªå®ç°ï¼
- en: Indeed, some modern programming languages designed for large-scale programming
    (such as Go and Rust) no longer have exception constructs. Therefore, you should
    not assume that this will continue to be the â€œstandardâ€ way of doing things in
    the future.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œä¸€äº›ä¸ºå¤§è§„æ¨¡ç¼–ç¨‹è®¾è®¡çš„ç°ä»£ç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚ Go å’Œ Rustï¼‰ä¸å†æœ‰å¼‚å¸¸æ„é€ ã€‚å› æ­¤ï¼Œä½ ä¸åº”è¯¥å‡è®¾è¿™å°†ç»§ç»­æ˜¯æœªæ¥çš„â€œæ ‡å‡†â€åšæ³•ã€‚
- en: Observe that there is are two kinds of exceptions that can occur. One is as
    weâ€™ve written above. The other is when we completely ignore (or forget to even
    think about) the empty list case, and end up getting an error from Pyret, which
    is also a kind of exception. If Pyret will raise an exception anyway, does it
    make sense for us to go through the trouble of doing it ourselves?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¯èƒ½å‘ç”Ÿä¸¤ç§å¼‚å¸¸ã€‚ä¸€ç§æ˜¯æˆ‘ä»¬ä¸Šé¢å†™è¿‡çš„ã€‚å¦ä¸€ç§æ˜¯æˆ‘ä»¬å®Œå…¨å¿½ç•¥ï¼ˆæˆ–å¿˜è®°è€ƒè™‘ï¼‰ç©ºåˆ—è¡¨çš„æƒ…å†µï¼Œæœ€ç»ˆä» Pyret è·å¾—é”™è¯¯ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ç§å¼‚å¸¸ã€‚å¦‚æœ Pyret
    æ— è®ºå¦‚ä½•éƒ½ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œæˆ‘ä»¬è´¹å°½å‘¨æŠ˜è‡ªå·±æ¥åšè¿™ä»¶äº‹æœ‰æ„ä¹‰å—ï¼Ÿ
- en: 'Yes it does! For several reasons:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ç¡®å®å¦‚æ­¤ï¼æœ‰ä»¥ä¸‹å‡ ä¸ªåŸå› ï¼š
- en: First, you get to control where the exception occurs and what it says.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œä½ å¯ä»¥æ§åˆ¶å¼‚å¸¸å‘ç”Ÿçš„ä½ç½®å’Œå®ƒæ‰€è¡¨è¾¾çš„å†…å®¹ã€‚
- en: You can document that the exception will occur.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥è®°å½•ä¸‹å¼‚å¸¸å°†ä¼šå‘ç”Ÿã€‚
- en: You are less dependent on the behavior of Pyret or whatever underlying programming
    language, which can change in subtle ways.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½ å¯¹ Pyret æˆ–ä»»ä½•åº•å±‚ç¼–ç¨‹è¯­è¨€çš„è¡Œä¸ºçš„ä¾èµ–æ€§è¾ƒä½ï¼Œè¿™äº›è¯­è¨€å¯èƒ½ä¼šä»¥å¾®å¦™çš„æ–¹å¼å‘ç”Ÿå˜åŒ–ã€‚
- en: You can create an exception that is unique to you, so it canâ€™t be confused with
    other division-by-zero errors that may lurk in your program.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥åˆ›å»ºä¸€ä¸ªä»…å±äºä½ è‡ªå·±çš„å¼‚å¸¸ï¼Œè¿™æ ·å®ƒå°±ä¸ä¼šä¸å…¶ä»–å¯èƒ½æ½œä¼åœ¨ç¨‹åºä¸­çš„é™¤ä»¥é›¶é”™è¯¯æ··æ·†ã€‚
- en: 'For these reasons, itâ€™s better to check and raise an exception explicitly than
    letting it â€œfall throughâ€ to the programming language. Instead, the real problems
    with this solution are subtler: the lying contract, and the impact on program
    execution.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºè¿™äº›åŸå› ï¼Œæ˜¾å¼æ£€æŸ¥å’ŒæŠ›å‡ºå¼‚å¸¸æ¯”è®©å®ƒâ€œè·Œå…¥â€ç¼–ç¨‹è¯­è¨€æ›´å¥½ã€‚ç›¸åï¼Œè¿™ä¸ªè§£å†³æ–¹æ¡ˆçš„çœŸæ­£é—®é¢˜æ›´ä¸ºå¾®å¦™ï¼šå¥‘çº¦çš„ä¸è¯šå®ï¼Œä»¥åŠå¯¹ç¨‹åºæ‰§è¡Œçš„å½±å“ã€‚
- en: 23.3Â The Option Type[ğŸ”—](#(part._pd-option) "Link to here")
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.3 é€‰é¡¹ç±»å‹[ğŸ”—](#(part._pd-option) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Letâ€™s revisit `avg0`. The problem with it was that it returned a value that
    was not distinguishable from an actual answer. So perhaps another approach is
    to return a value that is guaranteed to be distinguishable! For this, a growing
    number of languages (including Pyret) have something like this type:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é‡æ–°å®¡è§† `avg0`ã€‚å®ƒçš„é—®é¢˜åœ¨äºå®ƒè¿”å›äº†ä¸€ä¸ªæ— æ³•ä¸å®é™…ç­”æ¡ˆåŒºåˆ†çš„å€¼ã€‚å› æ­¤ï¼Œä¹Ÿè®¸å¦ä¸€ç§æ–¹æ³•å°±æ˜¯è¿”å›ä¸€ä¸ªä¿è¯å¯ä»¥åŒºåˆ†çš„å€¼ï¼ä¸ºæ­¤ï¼Œè¶Šæ¥è¶Šå¤šçš„è¯­è¨€ï¼ˆåŒ…æ‹¬
    Pyretï¼‰éƒ½æœ‰ç±»ä¼¼è¿™æ ·çš„ç±»å‹ï¼š
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is a type we use when we arenâ€™t sure we will have an answer: `none` means
    we donâ€™t have an answer, whereas `some` means we do and `value` is that answer.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªæˆ‘ä»¬åœ¨ä¸ç¡®å®šæ˜¯å¦æœ‰ç­”æ¡ˆæ—¶ä½¿ç”¨çš„ç±»å‹ï¼š`none` è¡¨ç¤ºæˆ‘ä»¬æ²¡æœ‰ç­”æ¡ˆï¼Œè€Œ `some` è¡¨ç¤ºæˆ‘ä»¬æœ‰ç­”æ¡ˆï¼Œ`value` å°±æ˜¯é‚£ä¸ªç­”æ¡ˆã€‚
- en: 'Hereâ€™s how our program now looks:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨çœ‹çœ‹æˆ‘ä»¬çš„ç¨‹åºç°åœ¨çœ‹èµ·æ¥æ˜¯ä»€ä¹ˆæ ·å­ï¼š
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now our tests look a bit different:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æµ‹è¯•çœ‹èµ·æ¥æœ‰äº›ä¸åŒï¼š
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The good news is, the contract is now truthful. Just by looking at it, we are
    reminded that `avg0` may not always be able to compute an answer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½æ¶ˆæ¯æ˜¯ï¼Œå¥‘çº¦ç°åœ¨æ˜¯çœŸçš„äº†ã€‚åªéœ€çœ‹ä¸€ä¸‹å®ƒï¼Œæˆ‘ä»¬å°±è¢«æé†’ `avg0` å¯èƒ½å¹¶ä¸æ€»æ˜¯èƒ½å¤Ÿè®¡ç®—å‡ºç­”æ¡ˆã€‚
- en: 'Unfortunately, this imposes some cost on every user: they have to use `cases`
    to check return values and only use them if they are legitimate. However, this
    is the same thing we expected in `avg0`â€”<wbr>except we lacked a discipline for
    making sure we didnâ€™t abuse that value! So this is `avg0` done in a principled
    way.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œè¿™ç»™æ¯ä¸ªç”¨æˆ·éƒ½å¸¦æ¥äº†ä¸€äº›æˆæœ¬ï¼šä»–ä»¬å¿…é¡»ä½¿ç”¨ `cases` æ¥æ£€æŸ¥è¿”å›å€¼ï¼Œå¹¶ä¸”åªæœ‰åœ¨å®ƒä»¬æ˜¯åˆæ³•çš„æƒ…å†µä¸‹æ‰ä½¿ç”¨å®ƒä»¬ã€‚ç„¶è€Œï¼Œè¿™ä¸æˆ‘ä»¬é¢„æœŸçš„ `avg0`
    æ˜¯åŒä¸€ä»¶äº‹â€”â€”<wbr>é™¤äº†æˆ‘ä»¬æ²¡æœ‰ç¡®ä¿ä¸æ»¥ç”¨è¯¥å€¼çš„çºªå¾‹ï¼æ‰€ä»¥è¿™æ˜¯ä»¥åŸåˆ™æ–¹å¼å®Œæˆçš„ `avg0`ã€‚
- en: 23.4Â Total Domains, Dynamically[ğŸ”—](#(part._pd-total-dyn) "Link to here")
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.4 æ€»åŸŸï¼ŒåŠ¨æ€[ğŸ”—](#(part._pd-total-dyn) "é“¾æ¥åˆ°æ­¤å¤„")
- en: All these problems arise because we said that `average` (like `median`) is partial.
    However, itâ€™s only partial if we give the domain as `List<Number>`; itâ€™s actually
    a total function on the `non-empty` list of numbers. But how do we represent that?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€æœ‰è¿™äº›é—®é¢˜éƒ½æºäºæˆ‘ä»¬è¯´ `average`ï¼ˆå°±åƒ `median`ï¼‰æ˜¯éƒ¨åˆ†çš„ã€‚ç„¶è€Œï¼Œåªæœ‰å½“æˆ‘ä»¬æŠŠåŸŸä½œä¸º `List<Number>` æ—¶ï¼Œå®ƒæ‰æ˜¯éƒ¨åˆ†çš„ï¼›å®é™…ä¸Šï¼Œå®ƒæ˜¯åœ¨æ•°å­—çš„éç©ºåˆ—è¡¨ä¸Šçš„ä¸€ä¸ªå…¨å‡½æ•°ã€‚ä½†æˆ‘ä»¬å¦‚ä½•è¡¨ç¤ºå®ƒå‘¢ï¼Ÿ
- en: 'In some languages, like Pyret, we can actually express this directly:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸€äº›è¯­è¨€ä¸­ï¼Œæ¯”å¦‚ Pyretï¼Œæˆ‘ä»¬å®é™…ä¸Šå¯ä»¥ç›´æ¥è¡¨è¾¾è¿™ä¸€ç‚¹ï¼š
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This says that weâ€™re refining numeric lists to always have a `link`, i.e., to
    be non-empty. In Pyret, currently, this check is only done at run-time; in some
    other programming languages, this can be done by the type-checker itself.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€æˆ‘ä»¬æ­£åœ¨ç»†åŒ–æ•°å€¼åˆ—è¡¨ï¼Œä½¿å…¶å§‹ç»ˆæœ‰ä¸€ä¸ª `link`ï¼Œå³éç©ºã€‚åœ¨ Pyret ä¸­ï¼Œç›®å‰è¿™ä¸ªæ£€æŸ¥ä»…åœ¨è¿è¡Œæ—¶è¿›è¡Œï¼›åœ¨å…¶ä»–ä¸€äº›ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œè¿™å¯ä»¥é€šè¿‡ç±»å‹æ£€æŸ¥å™¨æœ¬èº«æ¥å®Œæˆã€‚
- en: 'This refinement lets us pretend that weâ€™re dealing with regular lists and reuse
    all existing list code, while knowing for sure we will never get a divide-by-zero
    error:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§ç»†åŒ–è®©æˆ‘ä»¬å¯ä»¥å‡è£…æˆ‘ä»¬åœ¨å¤„ç†å¸¸è§„åˆ—è¡¨ï¼Œå¹¶é‡ç”¨æ‰€æœ‰ç°æœ‰çš„åˆ—è¡¨ä»£ç ï¼ŒåŒæ—¶ç¡®ä¿¡æˆ‘ä»¬æ°¸è¿œä¸ä¼šå¾—åˆ°é™¤ä»¥é›¶çš„é”™è¯¯ï¼š
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we do try passing an empty list, we get an internal exception:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬å°è¯•ä¼ é€’ä¸€ä¸ªç©ºåˆ—è¡¨ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ªå†…éƒ¨å¼‚å¸¸ï¼š
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a pretty interesting solution. Our functionâ€™s code is clean. We donâ€™t
    deal with nonsensical values. The interface is truthful! (However, it does require
    a careful reading to observe that thereâ€™s an exception lurking underneath the
    domain.) And it lets us reuse existing code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªç›¸å½“æœ‰è¶£çš„è§£å†³æ–¹æ¡ˆã€‚æˆ‘ä»¬çš„å‡½æ•°ä»£ç å¾ˆç®€æ´ã€‚æˆ‘ä»¬ä¸å¤„ç†æ— æ„ä¹‰çš„å€¼ã€‚æ¥å£æ˜¯çœŸå®çš„ï¼ï¼ˆç„¶è€Œï¼Œå®ƒç¡®å®éœ€è¦ä»”ç»†é˜…è¯»æ‰èƒ½è§‚å¯Ÿåˆ°åŸŸä¸‹é¢éšè—ç€ä¸€ä¸ªå¼‚å¸¸ã€‚ï¼‰è€Œä¸”å®ƒè®©æˆ‘ä»¬èƒ½å¤Ÿé‡ç”¨ç°æœ‰ä»£ç ã€‚
- en: 'There are two main weaknesses:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸¤ä¸ªä¸»è¦å¼±ç‚¹ï¼š
- en: Dynamic refinements arenâ€™t found in most languages, so weâ€™d have to do more
    manual work to obtain the same solution.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åŠ¨æ€ç»†åŒ–åœ¨å¤§å¤šæ•°è¯­è¨€ä¸­å¹¶ä¸å¸¸è§ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åšæ›´å¤šæ‰‹åŠ¨å·¥ä½œæ¥è·å¾—ç›¸åŒçš„è§£å†³æ–¹æ¡ˆã€‚
- en: We donâ€™t get a static guarantee (i.e., before even running the program) that
    weâ€™ll never get an exception.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ— æ³•å¾—åˆ°ä¸€ä¸ªé™æ€ä¿è¯ï¼ˆå³åœ¨ç¨‹åºè¿è¡Œä¹‹å‰ï¼‰ï¼Œå³æˆ‘ä»¬æ°¸è¿œä¸ä¼šå¾—åˆ°ä¸€ä¸ªå¼‚å¸¸ã€‚
- en: 23.5Â Total Domains, Statically[ğŸ”—](#(part._pd-total-static) "Link to here")
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.5 æ€»åŸŸï¼Œé™æ€[ğŸ”—](#(part._pd-total-static) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'How do we make the function total with a static guarantee? That would require
    that we ensure that we can never construct an empty list! Obviously, this is not
    possible with the existing lists in Pyret. However, we can construct a new list-like
    datatype that â€œbottoms outâ€ not at empty lists but at lists of one element:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•ä½¿å‡½æ•°å…·æœ‰é™æ€ä¿è¯çš„å…¨å‡½æ•°ï¼Ÿè¿™éœ€è¦æˆ‘ä»¬ç¡®ä¿æˆ‘ä»¬æ°¸è¿œæ— æ³•æ„é€ ä¸€ä¸ªç©ºåˆ—è¡¨ï¼æ˜¾ç„¶ï¼Œåœ¨ Pyret ä¸­ç°æœ‰çš„åˆ—è¡¨ä¸­è¿™æ˜¯ä¸å¯èƒ½çš„ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ ä¸€ä¸ªæ–°çš„ç±»ä¼¼åˆ—è¡¨çš„æ•°æ®ç±»å‹ï¼Œå®ƒâ€œåº•éƒ¨â€ä¸æ˜¯ç©ºåˆ—è¡¨ï¼Œè€Œæ˜¯å•å…ƒç´ åˆ—è¡¨ï¼š
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Observe that there is simply no way to make an empty list: the smallest list
    has one element in it. Furthermore, our type checker enforces this for us.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿåˆ°æˆ‘ä»¬æ ¹æœ¬æ— æ³•åˆ›å»ºä¸€ä¸ªç©ºåˆ—è¡¨ï¼šæœ€å°çš„åˆ—è¡¨ä¸­æœ‰ä¸€ä¸ªå…ƒç´ ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬çš„ç±»å‹æ£€æŸ¥å™¨ä¼šä¸ºæˆ‘ä»¬å¼ºåˆ¶æ‰§è¡Œè¿™ä¸€ç‚¹ã€‚
- en: 'Of course, this is an entirely different datatype than a list of numbers. We
    canâ€™t, for instance, use the existing `sum` or `length` code on it. However, one
    option is to convert a `NeLoN` into a `LoN`, which is always safe, and reuse that
    code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œè¿™ä¸æ•°å­—åˆ—è¡¨å®Œå…¨ä¸åŒçš„ä¸€ç§æ•°æ®ç±»å‹ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬ä¸èƒ½ä½¿ç”¨ç°æœ‰çš„ `sum` æˆ– `length` ä»£ç ã€‚ç„¶è€Œï¼Œä¸€ä¸ªé€‰é¡¹æ˜¯å°† `NeLoN` è½¬æ¢ä¸º
    `LoN`ï¼Œè¿™æ€»æ˜¯å®‰å…¨çš„ï¼Œå¹¶é‡ç”¨é‚£æ®µä»£ç ï¼š
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can write the average in an interesting way:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥æœ‰è¶£çš„æ–¹å¼ç¼–å†™å¹³å‡å€¼ï¼š
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once again, we donâ€™t have to have any logic for dealing with errors. However,
    itâ€™s not because weâ€™re sloppy or letting Pyret deal with it or getting it checked
    at runtime or anything else: itâ€™s because there is no way for an empty list to
    arise. Thus we have both the simplest body and the most truthful interface! But
    it comes at a cost: we need to do some work to reuse existing functions.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡å¼ºè°ƒï¼Œæˆ‘ä»¬ä¸éœ€è¦ä»»ä½•å¤„ç†é”™è¯¯çš„é€»è¾‘ã€‚ç„¶è€Œï¼Œè¿™å¹¶ä¸æ˜¯å› ä¸ºæˆ‘ä»¬ç²—å¿ƒå¤§æ„ï¼Œæˆ–è€…è®© Pyret å¤„ç†å®ƒï¼Œæˆ–è€…è¿è¡Œæ—¶è¿›è¡Œæ£€æŸ¥ï¼Œæˆ–è€…å…¶ä»–ä»»ä½•äº‹æƒ…ï¼šè¿™æ˜¯å› ä¸ºç©ºåˆ—è¡¨æ ¹æœ¬ä¸å¯èƒ½å‡ºç°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æ—¢æœ‰æœ€ç®€å•çš„ä¸»ä½“ï¼Œåˆæœ‰æœ€çœŸå®çš„æ¥å£ï¼ä½†è¿™ä¹Ÿå¸¦æ¥äº†ä»£ä»·ï¼šæˆ‘ä»¬éœ€è¦åšä¸€äº›å·¥ä½œæ¥é‡ç”¨ç°æœ‰å‡½æ•°ã€‚
- en: 'This problem extends to writing tests, which is now more painful:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªé—®é¢˜ä¹Ÿæ‰©å±•åˆ°ç¼–å†™æµ‹è¯•ï¼Œç°åœ¨å˜å¾—æ›´åŠ ç—›è‹¦ï¼š
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That is, weâ€™ve lost our convenient way of writing lists. We can recover that
    by writing a helper that creates `NeLoN`s:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¤±å»äº†æ–¹ä¾¿çš„ç¼–å†™åˆ—è¡¨çš„æ–¹å¼ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ç¼–å†™ä¸€ä¸ªåˆ›å»º `NeLoN`s çš„è¾…åŠ©å‡½æ•°æ¥æ¢å¤å®ƒï¼š
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Notice that if we try to use an empty list, we get an exception:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¦‚æœæˆ‘ä»¬å°è¯•ä½¿ç”¨ç©ºåˆ—è¡¨ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ªå¼‚å¸¸ï¼š
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, itâ€™s very important to understand where the error is coming from:
    the exception is not from `avg4`, itâ€™s coming from `lon-to-nelon`, i.e., from
    the â€œinterfaceâ€ function. The bad datum never makes it as far as `avg4`! We can
    verify this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œäº†è§£é”™è¯¯æ¥æºéå¸¸é‡è¦ï¼šå¼‚å¸¸ä¸æ˜¯æ¥è‡ª`avg4`ï¼Œè€Œæ˜¯æ¥è‡ª`lon-to-nelon`ï¼Œå³â€œæ¥å£â€å‡½æ•°ã€‚åæ•°æ®æ°¸è¿œä¸ä¼šåˆ°è¾¾`avg4`ï¼æˆ‘ä»¬å¯ä»¥éªŒè¯è¿™ä¸€ç‚¹ï¼š
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Remember, thereâ€™s no way to send an empty list to `avg4`! Nevertheless, this
    suggests a trade-off: we can either use `NeLoN` explicitly but with more notational
    pain, or we can use `list` but run the risk of some confusion about exceptions.
    This is a trade-off in general, but there are better options in some languages
    ([A Note on Notation](#%28part._pd-pyret-list-constr%29)).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: è®°ä½ï¼Œæ— æ³•å°†ç©ºåˆ—è¡¨å‘é€åˆ°`avg4`ï¼å°½ç®¡å¦‚æ­¤ï¼Œè¿™è¡¨æ˜äº†ä¸€ä¸ªæƒè¡¡ï¼šæˆ‘ä»¬æ—¢å¯ä»¥æ˜¾å¼ä½¿ç”¨`NeLoN`ä½†ä¼šå¸¦æ¥æ›´å¤šçš„ç¬¦å·ç—›è‹¦ï¼Œæˆ–è€…æˆ‘ä»¬å¯ä»¥ä½¿ç”¨`list`ä½†å†’ç€ä¸€äº›å…³äºå¼‚å¸¸æ··æ·†çš„é£é™©ã€‚è¿™åœ¨ä¸€èˆ¬æƒ…å†µä¸‹æ˜¯ä¸€ä¸ªæƒè¡¡ï¼Œä½†åœ¨æŸäº›è¯­è¨€ä¸­å­˜åœ¨æ›´å¥½çš„é€‰é¡¹ï¼ˆ[å…³äºç¬¦å·çš„è¯´æ˜](#%28part._pd-pyret-list-constr%29)ï¼‰ã€‚
- en: 'So this is actually a very powerful technique: building a datatype that reflects
    exactly what we want, thereby turning a partial function into a total one. Programmers
    call this principle making illegal states unrepresentable. It may require writing
    some procedures to convert to and from other convenient representations for code
    reuse. Somewhere in those procedures there must be checks that reflect the partiality.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œè¿™å®é™…ä¸Šæ˜¯ä¸€ä¸ªéå¸¸å¼ºå¤§çš„æŠ€æœ¯ï¼šæ„å»ºä¸€ä¸ªç²¾ç¡®åæ˜ æˆ‘ä»¬æƒ³è¦çš„ç±»å‹çš„datatypï¼Œä»è€Œå°†éƒ¨åˆ†å‡½æ•°è½¬æ¢ä¸ºå…¨å‡½æ•°ã€‚ç¨‹åºå‘˜ç§°è¿™ä¸ªåŸåˆ™ä¸ºä½¿éæ³•çŠ¶æ€ä¸å¯è¡¨ç¤ºã€‚è¿™å¯èƒ½éœ€è¦ç¼–å†™ä¸€äº›å°†è½¬æ¢åˆ°å’Œä»å…¶ä»–æ–¹ä¾¿è¡¨ç¤ºçš„ä¾‹ç¨‹ï¼Œä»¥ä¾¿ä»£ç é‡ç”¨ã€‚åœ¨è¿™äº›ä¾‹ç¨‹ä¸­ï¼Œå¿…é¡»æœ‰åæ˜ éƒ¨åˆ†æ€§çš„æ£€æŸ¥ã€‚
- en: 23.6Â Summary[ğŸ”—](#(part._pd-summary) "Link to here")
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.6Â æ€»ç»“[ğŸ”—](#(part._pd-summary) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'In general, there is one non-solution:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸ï¼Œæœ‰ä¸€ä¸ªéè§£å†³æ–¹æ¡ˆï¼š
- en: Return a sentinel value. Do not ever do this unless youâ€™ve first fixed all the
    security bugs lurking in C programs from the past several decades.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿”å›ä¸€ä¸ªå“¨å…µå€¼ã€‚é™¤éä½ é¦–å…ˆä¿®å¤äº†è¿‡å»å‡ åå¹´Cç¨‹åºä¸­æ½œä¼çš„æ‰€æœ‰å®‰å…¨æ¼æ´ï¼Œå¦åˆ™æ°¸è¿œä¸è¦è¿™æ ·åšã€‚
- en: 'and there are four solutions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¶ä¸”æœ‰å››ç§è§£å†³æ–¹æ¡ˆï¼š
- en: Use `raise`. This is not very good for software engineering in general because
    exceptions are clunky, semantically complicated, and not compositional.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`raise`ã€‚è¿™å¹¶ä¸é€‚åˆä¸€èˆ¬çš„è½¯ä»¶å·¥ç¨‹ï¼Œå› ä¸ºå¼‚å¸¸ç¬¨æ‹™ã€è¯­ä¹‰å¤æ‚ï¼Œå¹¶ä¸”ä¸å…·æœ‰ç»„åˆæ€§ã€‚
- en: Use a dynamic refinement. Dynamic refinements arenâ€™t in most languages. Also,
    itâ€™s less good than each of the other solutions, but itâ€™s a decent compromise
    in many settings.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨åŠ¨æ€ç»†åŒ–ã€‚åŠ¨æ€ç»†åŒ–åœ¨å¤§å¤šæ•°è¯­è¨€ä¸­å¹¶ä¸å¸¸è§ã€‚è€Œä¸”ï¼Œå®ƒæ¯”å…¶ä»–ä»»ä½•è§£å†³æ–¹æ¡ˆéƒ½è¦å·®ï¼Œä½†åœ¨è®¸å¤šæƒ…å†µä¸‹æ˜¯ä¸€ä¸ªä¸é”™çš„æŠ˜è¡·æ–¹æ¡ˆã€‚
- en: Define a datatype to make illegal states unrepresentable. A bit of work. Pretty
    sophisticated, invaluable in some places, but not always worth the effort.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®šä¹‰ä¸€ä¸ªdatatypæ¥ä½¿éæ³•çŠ¶æ€ä¸å¯è¡¨ç¤ºã€‚è¿™æ˜¯ä¸€é¡¹å·¥ä½œã€‚ç›¸å½“å¤æ‚ï¼Œåœ¨æŸäº›åœ°æ–¹éå¸¸æœ‰ä»·å€¼ï¼Œä½†å¹¶ä¸æ€»æ˜¯å€¼å¾—ä»˜å‡ºåŠªåŠ›ã€‚
- en: 'Use `Option`. Often the ideal option, because:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`Option`ã€‚é€šå¸¸æ˜¯ä¸€ä¸ªç†æƒ³çš„é€‰æ‹©ï¼Œå› ä¸ºï¼š
- en: The type tells us to expect funny business. (`raise` hides that.)
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç±»å‹å‘Šè¯‰æˆ‘ä»¬å¯èƒ½ä¼šå‡ºç°å¥‡æ€ªçš„æƒ…å†µã€‚ï¼ˆ`raise`éšè—äº†è¿™ä¸ªä¿¡æ¯ã€‚ï¼‰
- en: We canâ€™t accidentally misuse the value. (Sentinels hide that.)
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸å¯èƒ½æ„å¤–åœ°è¯¯ç”¨è¿™ä¸ªå€¼ã€‚ï¼ˆå“¨å…µéšè—äº†è¿™ä¸ªä¿¡æ¯ã€‚ï¼‰
- en: 'Itâ€™s compositional: we can create functions to help us handle it.'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®ƒæ˜¯ç»„åˆæ€§çš„ï¼šæˆ‘ä»¬å¯ä»¥åˆ›å»ºå‡½æ•°æ¥å¸®åŠ©æˆ‘ä»¬å¤„ç†å®ƒã€‚
- en: Itâ€™s much lower overhead than the static totality solution.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®ƒçš„ overhead æ¯”é™æ€æ€»ä½“è§£å†³æ–¹æ¡ˆè¦ä½å¾—å¤šã€‚
- en: Itâ€™s more statically robust than the dynamic totality solution.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®ƒæ¯”åŠ¨æ€æ€»ä½“è§£å†³æ–¹æ¡ˆæ›´é™æ€åœ°ç¨³å¥ã€‚
- en: 'It generalizes: in practice, instead of just `none` and `some`, a real program
    will have `some` for the â€œnormalâ€ case, and a bunch of variants describing the
    different kinds of errors that are possible, with extra information in each case.
    For concrete examples of this, see [Picking Elements from Sets](Collections_of_Structured_Data.html#%28part._coll-sd-pick%29)
    on sets [Combining Answers](queues-from-lists.html#%28part._qfl-comb-ans%29) on
    queues.'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®ƒæ˜¯é€šç”¨çš„ï¼šåœ¨å®è·µä¸­ï¼Œé™¤äº†`none`å’Œ`some`ä¹‹å¤–ï¼Œä¸€ä¸ªçœŸæ­£çš„ç¨‹åºå°†ä¼šæœ‰`some`ç”¨äºâ€œæ­£å¸¸â€æƒ…å†µï¼Œä»¥åŠæè¿°å¯èƒ½å‡ºç°çš„ä¸åŒç±»å‹é”™è¯¯çš„å¤šä¸ªå˜ä½“ï¼Œæ¯ä¸ªæƒ…å†µéƒ½æœ‰é¢å¤–çš„ä¿¡æ¯ã€‚å…³äºè¿™ä¸ªçš„å…·ä½“ä¾‹å­ï¼Œè¯·å‚è§é›†åˆçš„[ä»é›†åˆä¸­é€‰å–å…ƒç´ ](Collections_of_Structured_Data.html#%28part._coll-sd-pick%29)å’Œé˜Ÿåˆ—çš„[åˆå¹¶ç­”æ¡ˆ](queues-from-lists.html#%28part._qfl-comb-ans%29)ã€‚
- en: 23.7Â A Note on Notation[ğŸ”—](#(part._pd-pyret-list-constr) "Link to here")
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.7Â å…³äºç¬¦å·çš„è¯´æ˜[ğŸ”—](#(part._pd-pyret-list-constr) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'When we wrote above that we canâ€™t get the convenience of writing, say, `[list:
    1, 2, 3]` when using `NeLoN`s, we were speaking in general. In some languages,
    we can actually make similar convenient constructors. In Pyret, for instance,
    there is a protocol for defining custom constructors; in fact, seemingly built-in
    constructors like `list` and `set` are built using this protocol. The code for
    doing this is a bit ungainly (in part because itâ€™s optimized to save some space
    and time by making the constructor-writerâ€™s life a little harder), but it only
    needs to be written once. Hereâ€™s a `nelon` constructor for `NeLoN`s:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'å½“æˆ‘ä»¬ä¸Šé¢è¯´åœ¨ä½¿ç”¨`NeLoN`sæ—¶æ— æ³•è·å¾—ç¼–å†™ï¼Œæ¯”å¦‚`[list: 1, 2, 3]`çš„ä¾¿åˆ©æ€§æ—¶ï¼Œæˆ‘ä»¬æ˜¯åœ¨ä¸€èˆ¬æ„ä¹‰ä¸Šè¯´çš„ã€‚åœ¨ä¸€äº›è¯­è¨€ä¸­ï¼Œæˆ‘ä»¬å®é™…ä¸Šå¯ä»¥åˆ›å»ºç±»ä¼¼çš„ä¾¿åˆ©æ„é€ å™¨ã€‚ä¾‹å¦‚ï¼Œåœ¨Pyretä¸­ï¼Œæœ‰ä¸€ä¸ªå®šä¹‰è‡ªå®šä¹‰æ„é€ å™¨çš„åè®®ï¼›äº‹å®ä¸Šï¼Œåƒ`list`å’Œ`set`è¿™æ ·çš„çœ‹ä¼¼å†…ç½®æ„é€ å™¨å°±æ˜¯ä½¿ç”¨è¿™ä¸ªåè®®æ„å»ºçš„ã€‚æ‰§è¡Œæ­¤æ“ä½œçš„ä»£ç æœ‰ç‚¹ç¬¨æ‹™ï¼ˆéƒ¨åˆ†åŸå› æ˜¯å› ä¸ºå®ƒé€šè¿‡ä½¿æ„é€ å™¨ç¼–å†™è€…çš„ç”Ÿæ´»æ›´å›°éš¾æ¥èŠ‚çœä¸€äº›ç©ºé—´å’Œæ—¶é—´ï¼‰ï¼Œä½†å®ƒåªéœ€è¦å†™ä¸€æ¬¡ã€‚ä»¥ä¸‹æ˜¯`NeLoN`sçš„`nelon`æ„é€ å™¨ï¼š'
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These tests show that this constructor works very much like the built-in `list`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æµ‹è¯•è¡¨æ˜è¿™ä¸ªæ„é€ å™¨éå¸¸ç±»ä¼¼äºå†…ç½®çš„`list`ï¼š
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this, we can rewrite the tests from [Total Domains, Statically](#%28part._pd-total-static%29)
    very conveniently:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥éå¸¸æ–¹ä¾¿åœ°é‡å†™æ¥è‡ª[æ€»åŸŸï¼Œé™æ€](#%28part._pd-total-static%29)çš„æµ‹è¯•ï¼š
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: thereby having our cake and eating it too!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬æ—¢å¾—åˆ°äº†è›‹ç³•ï¼Œåˆåƒäº†å®ƒï¼
- en: 23.1Â A Non-Solution[ğŸ”—](#(part._pd-sentinel) "Link to here")
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.1 ä¸€ä¸ªéè§£å†³æ–¹æ¡ˆ[ğŸ”—](#(part._pd-sentinel) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'We will start with a strategy that has often been used by programmers in the
    past, but that we reject as a non-solution. This strategy is to make the above
    contract absolutely correct by returning a value in the erroneous case; this value
    is often called a sentinel. For instance, the sentinel might be `0`. Here is the
    full program:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä»ä¸€ä¸ªè¿‡å»ç¨‹åºå‘˜ç»å¸¸ä½¿ç”¨çš„ç­–ç•¥å¼€å§‹ï¼Œä½†æˆ‘ä»¬å°†å…¶æ‹’ç»ä¸ºéè§£å†³æ–¹æ¡ˆã€‚è¿™ä¸ªç­–ç•¥æ˜¯é€šè¿‡åœ¨é”™è¯¯æƒ…å†µä¸‹è¿”å›ä¸€ä¸ªå€¼æ¥ä½¿ä¸Šè¿°åˆåŒç»å¯¹æ­£ç¡®ï¼›è¿™ä¸ªå€¼é€šå¸¸è¢«ç§°ä¸ºå“¨å…µã€‚ä¾‹å¦‚ï¼Œå“¨å…µå¯èƒ½æ˜¯`0`ã€‚ä»¥ä¸‹æ˜¯å®Œæ•´çš„ç¨‹åºï¼š
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'and here are a few tests:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯ä¸€äº›æµ‹è¯•ï¼š
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Is there a test missing here? Yes, for the empty list! Should we add it?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œç¼ºå°‘æµ‹è¯•å—ï¼Ÿæ˜¯çš„ï¼Œå¯¹äºç©ºåˆ—è¡¨ï¼æˆ‘ä»¬åº”è¯¥æ·»åŠ å®ƒå—ï¼Ÿ
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The question is, should we be happy with this â€œsolutionâ€? There are two problems
    with it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬åº”è¯¥å¯¹è¿™ä¸ªâ€œè§£å†³æ–¹æ¡ˆâ€æ„Ÿåˆ°æ»¡æ„å—ï¼Ÿå®ƒæœ‰ä¸¤ä¸ªé—®é¢˜ã€‚
- en: First, every single use of `avg0` needs to check for whether it got back `0`
    or not. If it did not, then the answer is legitimate, and it can proceed with
    the computation. But if it did, then it has to assume that the input may have
    been illegitimate, and cannot use the answer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæ¯æ¬¡ä½¿ç”¨`avg0`æ—¶éƒ½éœ€è¦æ£€æŸ¥å®ƒæ˜¯å¦è¿”å›äº†`0`ã€‚å¦‚æœæ²¡æœ‰ï¼Œé‚£ä¹ˆç­”æ¡ˆæ˜¯åˆæ³•çš„ï¼Œå®ƒå¯ä»¥ç»§ç»­è¿›è¡Œè®¡ç®—ã€‚ä½†å¦‚æœå®ƒè¿”å›äº†ï¼Œé‚£ä¹ˆå®ƒå¿…é¡»å‡è®¾è¾“å…¥å¯èƒ½æ˜¯éæ³•çš„ï¼Œå¹¶ä¸”ä¸èƒ½ä½¿ç”¨è¿™ä¸ªç­”æ¡ˆã€‚
- en: 'Second, even thatâ€™s not quite true. To understand why, we need to write a few
    more tests:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒï¼Œå³ä½¿è¿™ä¹Ÿä¸å®Œå…¨æ­£ç¡®ã€‚è¦ç†è§£ä¸ºä»€ä¹ˆï¼Œæˆ‘ä»¬éœ€è¦ç¼–å†™æ›´å¤šçš„æµ‹è¯•ï¼š
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So the problem is that when `avg0` returns `0`, we donâ€™t know whether thatâ€™s
    a legitimate answer or a â€œfakeâ€ answer that stands for â€œthis is not a valid inputâ€.
    So even our strategy of â€œcheck everywhereâ€ fails!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥é—®é¢˜æ˜¯ï¼Œå½“`avg0`è¿”å›`0`æ—¶ï¼Œæˆ‘ä»¬ä¸çŸ¥é“è¿™æ˜¯å¦æ˜¯ä¸€ä¸ªåˆæ³•çš„ç­”æ¡ˆï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªä»£è¡¨â€œè¿™ä¸æ˜¯æœ‰æ•ˆè¾“å…¥â€çš„â€œè™šå‡â€ç­”æ¡ˆã€‚æ‰€ä»¥å³ä½¿æ˜¯æˆ‘ä»¬çš„â€œæ£€æŸ¥ä¸€åˆ‡â€çš„ç­–ç•¥ä¹Ÿå¤±è´¥äº†ï¼
- en: 'Ah, but maybe the problem is the use of `0`! Perhaps we could use a different
    number that would work. How about `1`? Or `-1`? The question is: Is there any
    number that reasonably canâ€™t be the average of an actual input? (And in general,
    for all problems, can you be sure of this?) Well, of course not.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: å•Šï¼Œä½†ä¹Ÿè®¸é—®é¢˜å‡ºåœ¨`0`çš„ä½¿ç”¨ä¸Šï¼æˆ–è®¸æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªä¸åŒçš„æ•°å­—ï¼Œè¿™æ ·å®ƒå°±èƒ½æ­£å¸¸å·¥ä½œã€‚æ¯”å¦‚`1`ï¼Ÿæˆ–è€…`-1`ï¼Ÿé—®é¢˜æ˜¯ï¼šæœ‰æ²¡æœ‰ä»»ä½•æ•°å­—åˆç†åœ°ä¸èƒ½æ˜¯å®é™…è¾“å…¥çš„å¹³å‡å€¼ï¼Ÿï¼ˆå¹¶ä¸”å¯¹äºæ‰€æœ‰é—®é¢˜ï¼Œä½ èƒ½ç¡®å®šè¿™ä¸€ç‚¹å—ï¼Ÿï¼‰å½“ç„¶ä¸èƒ½ã€‚
- en: 'Thatâ€™s why this is a non-solution. It has created several problems:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯ä¸ºä»€ä¹ˆè¿™æ˜¯ä¸€ä¸ªéè§£å†³æ–¹æ¡ˆã€‚å®ƒå·²ç»é€ æˆäº†ä¸€äº›é—®é¢˜ï¼š
- en: We canâ€™t tell from the output whether the input was invalid.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ— æ³•ä»è¾“å‡ºä¸­åˆ¤æ–­è¾“å…¥æ˜¯å¦æ— æ•ˆã€‚
- en: That means every caller needs to check.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€æ¯ä¸ªè°ƒç”¨è€…éƒ½éœ€è¦è¿›è¡Œæ£€æŸ¥ã€‚
- en: A caller that forgets to check may compute with nonsense.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¿˜è®°æ£€æŸ¥çš„è°ƒç”¨è€…å¯èƒ½ä¼šè¿›è¡Œæ— æ„ä¹‰çš„è®¡ç®—ã€‚
- en: 'Compositionality is ruined: any function passed `average` needs to know to
    check the output (and there is nothing in the contract to warn it!).'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç»„åˆæ€§è¢«ç ´åäº†ï¼šä»»ä½•ä¼ é€’ç»™`average`å‡½æ•°çš„å‡½æ•°éƒ½éœ€è¦çŸ¥é“è¦æ£€æŸ¥è¾“å‡ºï¼ˆå¹¶ä¸”åˆåŒä¸­æ²¡æœ‰ä»»ä½•è­¦å‘Šï¼ï¼‰ã€‚
- en: Indeed, decades of experience tells us that some of the worldâ€™s most sophisticated
    programmers have not been able to handle this issue even when it matters most,
    resulting in numerous, pernicious security problems. Therefore, we should now
    regard this as a flawed approach to software construction, and never do it ourselves.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œå‡ åå¹´çš„ç»éªŒå‘Šè¯‰æˆ‘ä»¬ï¼Œä¸–ç•Œä¸Šä¸€äº›æœ€å¤æ‚çš„ç¨‹åºå‘˜ç”šè‡³åœ¨æ²¡æœ‰æœ€å…³é”®çš„æ—¶å€™ä¹Ÿæ— æ³•å¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œå¯¼è‡´äº†è®¸å¤šæœ‰å®³çš„å®‰å…¨é—®é¢˜ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ç°åœ¨åº”è¯¥å°†æ­¤è§†ä¸ºè½¯ä»¶æ„å»ºçš„ä¸€ä¸ªæœ‰ç¼ºé™·çš„æ–¹æ³•ï¼Œæ°¸è¿œä¸è¦è‡ªå·±è¿™æ ·åšã€‚
- en: Letâ€™s instead look at four actual solutions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ¥çœ‹çœ‹å››ä¸ªå®é™…è§£å†³æ–¹æ¡ˆã€‚
- en: 23.2Â Exceptions[ğŸ”—](#(part._pd-exceptions) "Link to here")
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.2 å¼‚å¸¸[ğŸ”—](#(part._pd-exceptions) "é“¾æ¥åˆ°æ­¤å¤„")
- en: One technique that many languages, including Pyret, provide is called the exception.
    An exception is a special programming construct that effectively halts the computation
    because the program cannot figure out how to continue computing with the data
    it has. There are more sophisticated forms of exceptions in some languages, but
    here we focus simply on using them as a strategy for handling partiality.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: è®¸å¤šè¯­è¨€ï¼ŒåŒ…æ‹¬Pyretï¼Œæä¾›çš„ä¸€ç§æŠ€æœ¯è¢«ç§°ä¸ºå¼‚å¸¸ã€‚å¼‚å¸¸æ˜¯ä¸€ç§ç‰¹æ®Šçš„ç¼–ç¨‹ç»“æ„ï¼Œå®ƒæœ‰æ•ˆåœ°ç»ˆæ­¢äº†è®¡ç®—ï¼Œå› ä¸ºç¨‹åºæ— æ³•ç¡®å®šå¦‚ä½•ä½¿ç”¨å®ƒæ‹¥æœ‰çš„æ•°æ®ç»§ç»­è®¡ç®—ã€‚ä¸€äº›è¯­è¨€ä¸­æœ‰æ›´å¤æ‚çš„å¼‚å¸¸å½¢å¼ï¼Œä½†åœ¨è¿™é‡Œæˆ‘ä»¬åªå…³æ³¨å°†å®ƒä»¬ç”¨ä½œå¤„ç†éƒ¨åˆ†æ€§çš„ç­–ç•¥ã€‚
- en: 'Here is the average program written using an exception (we reuse `sum` from
    before):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯ä¸€ä¸ªä½¿ç”¨å¼‚å¸¸ï¼ˆæˆ‘ä»¬é‡ç”¨äº†ä¹‹å‰çš„`sum`ï¼‰ç¼–å†™çš„å¹³å‡ç¨‹åºï¼š
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The way `raise` works is that it terminates everything that is waiting to happen.
    For instance, if we were to write
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`raise`çš„å·¥ä½œæ–¹å¼æ˜¯ç»ˆæ­¢æ‰€æœ‰ç­‰å¾…å‘ç”Ÿçš„äº‹æƒ…ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬å†™'
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'the `1 + â€¦` part never happens: the whole computation ends. `raise` creates
    exceptions.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`1 + â€¦`éƒ¨åˆ†æ°¸è¿œä¸ä¼šå‘ç”Ÿï¼šæ•´ä¸ªè®¡ç®—ç»“æŸã€‚`raise`åˆ›å»ºå¼‚å¸¸ã€‚'
- en: Again, weâ€™re missing a test. How do we write it?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡ï¼Œæˆ‘ä»¬ç¼ºå°‘ä¸€ä¸ªæµ‹è¯•ã€‚æˆ‘ä»¬å¦‚ä½•ç¼–å†™å®ƒï¼Ÿ
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `raises` form takes a string that it matches against that provided to `raise`.
    In act, for convenience, any sub-string of the original string is permitted: we
    can, for instance, also write `check: avg1(empty) raises "no average" avg1(empty)
    raises "empty list" end`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`raises`å½¢å¼æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¯¥å­—ç¬¦ä¸²ä¸æä¾›ç»™`raise`çš„å­—ç¬¦ä¸²è¿›è¡ŒåŒ¹é…ã€‚å®é™…ä¸Šï¼Œä¸ºäº†æ–¹ä¾¿ï¼ŒåŸå§‹å­—ç¬¦ä¸²çš„ä»»ä½•å­ä¸²éƒ½æ˜¯å…è®¸çš„ï¼šä¾‹å¦‚ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è¿™æ ·å†™`check:
    avg1(empty) raises "no average" avg1(empty) raises "empty list" end`'
- en: In many programming languages, the use of exceptions is the standard way of
    dealing with partiality. It is certainly a pragmatic solution. Observe that we
    got to reuse `sum` from earlier; the contract looks clean; and we only needed
    to use `raise` at the spot where we didnâ€™t know what to do. Whatâ€™s not to like?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è®¸å¤šç¼–ç¨‹è¯­è¨€ä¸­ï¼Œä½¿ç”¨å¼‚å¸¸æ˜¯å¤„ç†éƒ¨åˆ†æ€§çš„æ ‡å‡†æ–¹å¼ã€‚è¿™å½“ç„¶æ˜¯ä¸€ä¸ªå®ç”¨çš„è§£å†³æ–¹æ¡ˆã€‚è§‚å¯Ÿä¸€ä¸‹ï¼Œæˆ‘ä»¬å¾—åˆ°äº†é‡ç”¨ä¹‹å‰`sum`çš„æœºä¼šï¼›åˆåŒçœ‹èµ·æ¥å¾ˆå¹²å‡€ï¼›æˆ‘ä»¬åªéœ€è¦åœ¨ä¸çŸ¥é“è¯¥åšä»€ä¹ˆçš„åœ°æ–¹ä½¿ç”¨`raise`ã€‚æœ‰ä»€ä¹ˆä¸å–œæ¬¢çš„å‘¢ï¼Ÿ
- en: 'There are two main problems with exceptions:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: å¼‚å¸¸æœ‰ä¸¤ä¸ªä¸»è¦é—®é¢˜ï¼š
- en: In real systems, exceptions halt a programâ€™s execution in unpredictable ways.
    A caller to `avg1` may be half-way through doing something else (e.g., it may
    have opened a file that it intends to close), but the exception causes the call
    to not finish cleanly, causing the remaining computation to not run, leaving the
    system in a messy state.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨å®é™…ç³»ç»Ÿä¸­ï¼Œå¼‚å¸¸ä»¥ä¸å¯é¢„æµ‹çš„æ–¹å¼ç»ˆæ­¢ç¨‹åºæ‰§è¡Œã€‚è°ƒç”¨`avg1`çš„è°ƒç”¨è€…å¯èƒ½æ­£åœ¨è¿›è¡Œå…¶ä»–äº‹æƒ…çš„ä¸€åŠï¼ˆä¾‹å¦‚ï¼Œå®ƒå¯èƒ½å·²ç»æ‰“å¼€äº†ä¸€ä¸ªæ‰“ç®—å…³é—­çš„æ–‡ä»¶ï¼‰ï¼Œä½†å¼‚å¸¸å¯¼è‡´è°ƒç”¨æ²¡æœ‰å¹²å‡€åœ°å®Œæˆï¼Œå¯¼è‡´å‰©ä½™çš„è®¡ç®—æ²¡æœ‰è¿è¡Œï¼Œä½¿ç³»ç»Ÿå¤„äºæ··ä¹±çŠ¶æ€ã€‚
- en: 'Relatedly, what we presented as a feature should actually be treated as a problem:
    the contract lies! Thereâ€™s no indication at all in the contract that an exception
    might occur. A programmer has to read the whole implementationâ€”<wbr>which could
    change at any timeâ€”<wbr>instead of being able to rely on its published contract,
    when the whole point of contracts was that they saved us from having to read the
    whole implementation!'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ç›¸å…³åœ°ï¼Œæˆ‘ä»¬æå‡ºä½œä¸ºç‰¹æ€§çš„äº‹æƒ…å®é™…ä¸Šåº”è¯¥è¢«è§†ä¸ºä¸€ä¸ªé—®é¢˜ï¼šåˆåŒæœ‰è¯¯ï¼åˆåŒä¸­æ ¹æœ¬æ²¡æœ‰ä»»ä½•è¿¹è±¡è¡¨æ˜å¯èƒ½ä¼šå‘ç”Ÿå¼‚å¸¸ã€‚ç¨‹åºå‘˜å¿…é¡»é˜…è¯»æ•´ä¸ªå®ç°â€”â€”<wbr>è¿™å¯èƒ½ä¼šéšæ—¶æ”¹å˜â€”â€”<wbr>è€Œä¸æ˜¯èƒ½å¤Ÿä¾èµ–å…¶å‘å¸ƒçš„åˆåŒï¼Œå› ä¸ºåˆåŒçš„å…¨éƒ¨è¦ç‚¹æ˜¯å®ƒä»¬è®©æˆ‘ä»¬å…äºä¸å¾—ä¸é˜…è¯»æ•´ä¸ªå®ç°ï¼
- en: Indeed, some modern programming languages designed for large-scale programming
    (such as Go and Rust) no longer have exception constructs. Therefore, you should
    not assume that this will continue to be the â€œstandardâ€ way of doing things in
    the future.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: äº‹å®ä¸Šï¼Œä¸€äº›ä¸ºå¤§è§„æ¨¡ç¼–ç¨‹è®¾è®¡çš„ç°ä»£ç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚Goå’ŒRustï¼‰ä¸å†æœ‰å¼‚å¸¸ç»“æ„ã€‚å› æ­¤ï¼Œä½ ä¸åº”è¯¥å‡è®¾è¿™å°†ç»§ç»­æ˜¯æœªæ¥çš„â€œæ ‡å‡†â€åšäº‹æ–¹å¼ã€‚
- en: Observe that there is are two kinds of exceptions that can occur. One is as
    weâ€™ve written above. The other is when we completely ignore (or forget to even
    think about) the empty list case, and end up getting an error from Pyret, which
    is also a kind of exception. If Pyret will raise an exception anyway, does it
    make sense for us to go through the trouble of doing it ourselves?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¯èƒ½å‘ç”Ÿä¸¤ç§ç±»å‹çš„å¼‚å¸¸ã€‚ä¸€ç§æ˜¯æˆ‘ä»¬ä¸Šé¢å†™çš„é‚£ç§ã€‚å¦ä¸€ç§æ˜¯æˆ‘ä»¬å®Œå…¨å¿½ç•¥ï¼ˆæˆ–è€…å¿˜è®°è€ƒè™‘ï¼‰ç©ºåˆ—è¡¨çš„æƒ…å†µï¼Œæœ€ç»ˆä»Pyretå¾—åˆ°é”™è¯¯ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ç§å¼‚å¸¸ã€‚å¦‚æœPyretæ— è®ºå¦‚ä½•éƒ½ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œæˆ‘ä»¬è‡ªå·±å»å¤„ç†å®ƒæœ‰æ„ä¹‰å—ï¼Ÿ
- en: 'Yes it does! For several reasons:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¯çš„ï¼Œå®ƒç¡®å®å¦‚æ­¤ï¼æœ‰ä»¥ä¸‹å‡ ä¸ªåŸå› ï¼š
- en: First, you get to control where the exception occurs and what it says.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œä½ å¯ä»¥æ§åˆ¶å¼‚å¸¸å‘ç”Ÿçš„ä½ç½®å’Œå®ƒæ‰€æ˜¾ç¤ºçš„å†…å®¹ã€‚
- en: You can document that the exception will occur.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥è®°å½•å¼‚å¸¸å°†ä¼šå‘ç”Ÿã€‚
- en: You are less dependent on the behavior of Pyret or whatever underlying programming
    language, which can change in subtle ways.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½ å¯¹Pyretæˆ–ä»»ä½•åº•å±‚ç¼–ç¨‹è¯­è¨€çš„è¡Œä¸ºçš„ä¾èµ–æ€§æ›´å°ï¼Œè¿™äº›è¯­è¨€å¯èƒ½ä¼šä»¥å¾®å¦™çš„æ–¹å¼å‘ç”Ÿå˜åŒ–ã€‚
- en: You can create an exception that is unique to you, so it canâ€™t be confused with
    other division-by-zero errors that may lurk in your program.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥åˆ›å»ºä¸€ä¸ªåªå±äºä½ è‡ªå·±çš„å¼‚å¸¸ï¼Œè¿™æ ·å®ƒå°±ä¸ä¼šä¸å…¶ä»–å¯èƒ½æ½œä¼åœ¨ç¨‹åºä¸­çš„é™¤ä»¥é›¶é”™è¯¯æ··æ·†ã€‚
- en: 'For these reasons, itâ€™s better to check and raise an exception explicitly than
    letting it â€œfall throughâ€ to the programming language. Instead, the real problems
    with this solution are subtler: the lying contract, and the impact on program
    execution.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºè¿™äº›åŸå› ï¼Œæœ€å¥½æ˜¾å¼åœ°æ£€æŸ¥å¹¶æŠ›å‡ºå¼‚å¸¸ï¼Œè€Œä¸æ˜¯è®©å®ƒâ€œè·Œè½â€åˆ°ç¼–ç¨‹è¯­è¨€ä¸­ã€‚ç›¸åï¼Œè¿™ä¸ªè§£å†³æ–¹æ¡ˆçš„çœŸæ­£é—®é¢˜æ›´ä¸ºå¾®å¦™ï¼šä¸è¯šå®åˆçº¦å’Œç¨‹åºæ‰§è¡Œçš„å½±å“ã€‚
- en: 23.3Â The Option Type[ğŸ”—](#(part._pd-option) "Link to here")
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.3Â é€‰é¡¹ç±»å‹[ğŸ”—](#(part._pd-option) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Letâ€™s revisit `avg0`. The problem with it was that it returned a value that
    was not distinguishable from an actual answer. So perhaps another approach is
    to return a value that is guaranteed to be distinguishable! For this, a growing
    number of languages (including Pyret) have something like this type:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é‡æ–°å®¡è§†`avg0`ã€‚å®ƒçš„é—®é¢˜åœ¨äºå®ƒè¿”å›äº†ä¸€ä¸ªæ— æ³•ä¸å®é™…ç­”æ¡ˆåŒºåˆ†çš„å€¼ã€‚æ‰€ä»¥ä¹Ÿè®¸å¦ä¸€ç§æ–¹æ³•å°±æ˜¯è¿”å›ä¸€ä¸ªä¿è¯å¯ä»¥åŒºåˆ†çš„å€¼ï¼ä¸ºæ­¤ï¼Œè¶Šæ¥è¶Šå¤šçš„è¯­è¨€ï¼ˆåŒ…æ‹¬Pyretï¼‰éƒ½æœ‰ç±»ä¼¼è¿™æ ·çš„ç±»å‹ï¼š
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is a type we use when we arenâ€™t sure we will have an answer: `none` means
    we donâ€™t have an answer, whereas `some` means we do and `value` is that answer.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æˆ‘ä»¬ä¸ç¡®å®šæ˜¯å¦æœ‰ç­”æ¡ˆæ—¶ä½¿ç”¨çš„ä¸€ç§ç±»å‹ï¼š`none`è¡¨ç¤ºæˆ‘ä»¬æ²¡æœ‰ç­”æ¡ˆï¼Œè€Œ`some`è¡¨ç¤ºæˆ‘ä»¬æœ‰ç­”æ¡ˆï¼Œ`value`å°±æ˜¯é‚£ä¸ªç­”æ¡ˆã€‚
- en: 'Hereâ€™s how our program now looks:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ¥çœ‹çœ‹æˆ‘ä»¬çš„ç¨‹åºç°åœ¨æ˜¯ä»€ä¹ˆæ ·å­ï¼š
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now our tests look a bit different:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬çš„æµ‹è¯•çœ‹èµ·æ¥æœ‰äº›ä¸åŒï¼š
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The good news is, the contract is now truthful. Just by looking at it, we are
    reminded that `avg0` may not always be able to compute an answer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½æ¶ˆæ¯æ˜¯ï¼Œåˆçº¦ç°åœ¨æ˜¯çœŸçš„ã€‚ä»…ä»…é€šè¿‡æŸ¥çœ‹å®ƒï¼Œæˆ‘ä»¬å°±è¢«æé†’`avg0`å¯èƒ½å¹¶ä¸æ€»æ˜¯èƒ½å¤Ÿè®¡ç®—å‡ºç­”æ¡ˆã€‚
- en: 'Unfortunately, this imposes some cost on every user: they have to use `cases`
    to check return values and only use them if they are legitimate. However, this
    is the same thing we expected in `avg0`â€”<wbr>except we lacked a discipline for
    making sure we didnâ€™t abuse that value! So this is `avg0` done in a principled
    way.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œè¿™ç»™æ¯ä¸ªç”¨æˆ·éƒ½å¸¦æ¥äº†ä¸€äº›æˆæœ¬ï¼šä»–ä»¬å¿…é¡»ä½¿ç”¨`cases`æ¥æ£€æŸ¥è¿”å›å€¼ï¼Œå¹¶ä¸”åªæœ‰åœ¨å®ƒä»¬æ˜¯åˆæ³•çš„æƒ…å†µä¸‹æ‰ä½¿ç”¨å®ƒä»¬ã€‚ç„¶è€Œï¼Œè¿™ä¸æˆ‘ä»¬é¢„æœŸçš„`avg0`æ˜¯åŒä¸€ä»¶äº‹â€”â€”åªæ˜¯æˆ‘ä»¬ç¼ºä¹ç¡®ä¿æˆ‘ä»¬ä¸ä¼šæ»¥ç”¨è¿™ä¸ªå€¼çš„çºªå¾‹ï¼æ‰€ä»¥è¿™æ˜¯ä»¥åŸåˆ™æ–¹å¼å®Œæˆçš„`avg0`ã€‚
- en: 23.4Â Total Domains, Dynamically[ğŸ”—](#(part._pd-total-dyn) "Link to here")
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.4Â å…¨åŸŸï¼ŒåŠ¨æ€[ğŸ”—](#(part._pd-total-dyn) "é“¾æ¥åˆ°æ­¤å¤„")
- en: All these problems arise because we said that `average` (like `median`) is partial.
    However, itâ€™s only partial if we give the domain as `List<Number>`; itâ€™s actually
    a total function on the `non-empty` list of numbers. But how do we represent that?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€æœ‰è¿™äº›é—®é¢˜éƒ½æºäºæˆ‘ä»¬è¯´`average`ï¼ˆå°±åƒ`median`ä¸€æ ·ï¼‰æ˜¯éƒ¨åˆ†å‡½æ•°ã€‚ç„¶è€Œï¼Œåªæœ‰å½“æˆ‘ä»¬æŠŠåŸŸæŒ‡å®šä¸º`List<Number>`æ—¶ï¼Œå®ƒæ‰æ˜¯éƒ¨åˆ†å‡½æ•°ï¼›å®é™…ä¸Šï¼Œå®ƒæ˜¯åœ¨éç©ºæ•°å­—åˆ—è¡¨ä¸Šçš„ä¸€ä¸ªå…¨å‡½æ•°ã€‚ä½†æˆ‘ä»¬å¦‚ä½•è¡¨ç¤ºè¿™ä¸€ç‚¹å‘¢ï¼Ÿ
- en: 'In some languages, like Pyret, we can actually express this directly:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸€äº›è¯­è¨€ä¸­ï¼Œæ¯”å¦‚Pyretï¼Œæˆ‘ä»¬å®é™…ä¸Šå¯ä»¥ç›´æ¥è¡¨è¾¾è¿™ä¸€ç‚¹ï¼š
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This says that weâ€™re refining numeric lists to always have a `link`, i.e., to
    be non-empty. In Pyret, currently, this check is only done at run-time; in some
    other programming languages, this can be done by the type-checker itself.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è¡¨ç¤ºæˆ‘ä»¬æ­£åœ¨æ”¹è¿›æ•°å€¼åˆ—è¡¨ï¼Œä½¿å…¶å§‹ç»ˆåŒ…å«ä¸€ä¸ª`link`ï¼Œå³éç©ºã€‚åœ¨Pyretä¸­ï¼Œç›®å‰è¿™ä¸ªæ£€æŸ¥ä»…åœ¨è¿è¡Œæ—¶è¿›è¡Œï¼›åœ¨å…¶ä»–ä¸€äº›ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œè¿™å¯ä»¥é€šè¿‡ç±»å‹æ£€æŸ¥å™¨æœ¬èº«æ¥å®Œæˆã€‚
- en: 'This refinement lets us pretend that weâ€™re dealing with regular lists and reuse
    all existing list code, while knowing for sure we will never get a divide-by-zero
    error:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§æ”¹è¿›è®©æˆ‘ä»¬å¯ä»¥å‡è£…æˆ‘ä»¬åœ¨å¤„ç†å¸¸è§„åˆ—è¡¨ï¼Œå¹¶é‡ç”¨æ‰€æœ‰ç°æœ‰çš„åˆ—è¡¨ä»£ç ï¼ŒåŒæ—¶ç¡®ä¿¡æˆ‘ä»¬æ°¸è¿œä¸ä¼šé‡åˆ°é™¤ä»¥é›¶é”™è¯¯ï¼š
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we do try passing an empty list, we get an internal exception:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬å°è¯•ä¼ é€’ä¸€ä¸ªç©ºåˆ—è¡¨ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ªå†…éƒ¨å¼‚å¸¸ï¼š
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is a pretty interesting solution. Our functionâ€™s code is clean. We donâ€™t
    deal with nonsensical values. The interface is truthful! (However, it does require
    a careful reading to observe that thereâ€™s an exception lurking underneath the
    domain.) And it lets us reuse existing code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªç›¸å½“æœ‰è¶£çš„è§£å†³æ–¹æ¡ˆã€‚æˆ‘ä»¬çš„å‡½æ•°ä»£ç å¾ˆå¹²å‡€ã€‚æˆ‘ä»¬ä¸å¤„ç†æ— æ„ä¹‰çš„å€¼ã€‚æ¥å£æ˜¯çœŸå®çš„ï¼ï¼ˆç„¶è€Œï¼Œè¿™ç¡®å®éœ€è¦ä»”ç»†é˜…è¯»æ‰èƒ½è§‚å¯Ÿåˆ°åŸŸä¸‹éšè—çš„å¼‚å¸¸ã€‚ï¼‰è€Œä¸”å®ƒè®©æˆ‘ä»¬å¯ä»¥é‡ç”¨ç°æœ‰çš„ä»£ç ã€‚
- en: 'There are two main weaknesses:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸¤ä¸ªä¸»è¦å¼±ç‚¹ï¼š
- en: Dynamic refinements arenâ€™t found in most languages, so weâ€™d have to do more
    manual work to obtain the same solution.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åŠ¨æ€ç»†åŒ–åœ¨å¤§å¤šæ•°è¯­è¨€ä¸­éƒ½æ²¡æœ‰æ‰¾åˆ°ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åšæ›´å¤šæ‰‹åŠ¨å·¥ä½œæ¥è·å¾—ç›¸åŒçš„è§£å†³æ–¹æ¡ˆã€‚
- en: We donâ€™t get a static guarantee (i.e., before even running the program) that
    weâ€™ll never get an exception.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸èƒ½å¾—åˆ°ä¸€ä¸ªé™æ€ä¿è¯ï¼ˆå³åœ¨ç¨‹åºè¿è¡Œä¹‹å‰ï¼‰ï¼Œå³æˆ‘ä»¬æ°¸è¿œä¸ä¼šå¾—åˆ°å¼‚å¸¸ã€‚
- en: 23.5Â Total Domains, Statically[ğŸ”—](#(part._pd-total-static) "Link to here")
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.5 æ€»åŸŸï¼Œé™æ€[ğŸ”—](#(part._pd-total-static) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'How do we make the function total with a static guarantee? That would require
    that we ensure that we can never construct an empty list! Obviously, this is not
    possible with the existing lists in Pyret. However, we can construct a new list-like
    datatype that â€œbottoms outâ€ not at empty lists but at lists of one element:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•ä½¿å‡½æ•°å…·æœ‰é™æ€ä¿è¯çš„å®Œæ•´æ€§ï¼Ÿè¿™éœ€è¦æˆ‘ä»¬ç¡®ä¿æˆ‘ä»¬æ°¸è¿œä¸èƒ½æ„é€ ä¸€ä¸ªç©ºåˆ—è¡¨ï¼æ˜¾ç„¶ï¼Œåœ¨ Pyret çš„ç°æœ‰åˆ—è¡¨ä¸­è¿™æ˜¯ä¸å¯èƒ½çš„ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ ä¸€ä¸ªæ–°çš„ç±»ä¼¼åˆ—è¡¨çš„æ•°æ®ç±»å‹ï¼Œå®ƒâ€œåº•éƒ¨â€ä¸æ˜¯ç©ºåˆ—è¡¨ï¼Œè€Œæ˜¯å•å…ƒç´ åˆ—è¡¨ï¼š
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Observe that there is simply no way to make an empty list: the smallest list
    has one element in it. Furthermore, our type checker enforces this for us.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæ ¹æœ¬ä¸å¯èƒ½åˆ›å»ºä¸€ä¸ªç©ºåˆ—è¡¨ï¼šæœ€å°çš„åˆ—è¡¨ä¸­æœ‰ä¸€ä¸ªå…ƒç´ ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬çš„ç±»å‹æ£€æŸ¥å™¨ä¼šä¸ºæˆ‘ä»¬å¼ºåˆ¶æ‰§è¡Œè¿™ä¸€ç‚¹ã€‚
- en: 'Of course, this is an entirely different datatype than a list of numbers. We
    canâ€™t, for instance, use the existing `sum` or `length` code on it. However, one
    option is to convert a `NeLoN` into a `LoN`, which is always safe, and reuse that
    code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œè¿™ä¸æ•°å­—åˆ—è¡¨å®Œå…¨ä¸åŒçš„æ•°æ®ç±»å‹ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬ä¸èƒ½åœ¨å®ƒä¸Šé¢ä½¿ç”¨ç°æœ‰çš„ `sum` æˆ– `length` ä»£ç ã€‚ç„¶è€Œï¼Œä¸€ä¸ªé€‰é¡¹æ˜¯å°† `NeLoN` è½¬æ¢ä¸º
    `LoN`ï¼Œè¿™æ€»æ˜¯å®‰å…¨çš„ï¼Œå¹¶ä¸”å¯ä»¥é‡ç”¨é‚£æ®µä»£ç ï¼š
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we can write the average in an interesting way:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥ä¸€ç§æœ‰è¶£çš„æ–¹å¼å†™å‡ºå¹³å‡å€¼ï¼š
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once again, we donâ€™t have to have any logic for dealing with errors. However,
    itâ€™s not because weâ€™re sloppy or letting Pyret deal with it or getting it checked
    at runtime or anything else: itâ€™s because there is no way for an empty list to
    arise. Thus we have both the simplest body and the most truthful interface! But
    it comes at a cost: we need to do some work to reuse existing functions.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ¬¡åˆä¸€æ¬¡ï¼Œæˆ‘ä»¬ä¸éœ€è¦ä»»ä½•é€»è¾‘æ¥å¤„ç†é”™è¯¯ã€‚ç„¶è€Œï¼Œè¿™å¹¶ä¸æ˜¯å› ä¸ºæˆ‘ä»¬ç²—å¿ƒå¤§æ„ï¼Œæˆ–è€…è®© Pyret å¤„ç†å®ƒï¼Œæˆ–è€…åœ¨è¿è¡Œæ—¶è¿›è¡Œæ£€æŸ¥ï¼Œæˆ–è€…å…¶ä»–ä»»ä½•åŸå› ï¼šå› ä¸ºæ²¡æœ‰åŠæ³•äº§ç”Ÿä¸€ä¸ªç©ºåˆ—è¡¨ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æ—¢æœ‰æœ€ç®€å•çš„ä¸»ä½“ï¼Œä¹Ÿæœ‰æœ€çœŸå®çš„æ¥å£ï¼ä½†æ˜¯ï¼Œè¿™ä¹Ÿæœ‰ä»£ä»·ï¼šæˆ‘ä»¬éœ€è¦åšä¸€äº›å·¥ä½œæ¥é‡ç”¨ç°æœ‰çš„å‡½æ•°ã€‚
- en: 'This problem extends to writing tests, which is now more painful:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªé—®é¢˜ä¹Ÿæ‰©å±•åˆ°ç¼–å†™æµ‹è¯•ï¼Œç°åœ¨æ›´åŠ ç—›è‹¦ï¼š
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'That is, weâ€™ve lost our convenient way of writing lists. We can recover that
    by writing a helper that creates `NeLoN`s:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: å³ï¼Œæˆ‘ä»¬å¤±å»äº†ç¼–å†™åˆ—è¡¨çš„ä¾¿åˆ©æ–¹å¼ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ç¼–å†™ä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥æ¢å¤å®ƒï¼Œè¯¥å‡½æ•°åˆ›å»º `NeLoN`ï¼š
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Notice that if we try to use an empty list, we get an exception:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¦‚æœæˆ‘ä»¬å°è¯•ä½¿ç”¨ä¸€ä¸ªç©ºåˆ—è¡¨ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ªå¼‚å¸¸ï¼š
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'However, itâ€™s very important to understand where the error is coming from:
    the exception is not from `avg4`, itâ€™s coming from `lon-to-nelon`, i.e., from
    the â€œinterfaceâ€ function. The bad datum never makes it as far as `avg4`! We can
    verify this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œç†è§£é”™è¯¯æ¥æºéå¸¸é‡è¦ï¼šå¼‚å¸¸ä¸æ˜¯æ¥è‡ª `avg4`ï¼Œè€Œæ˜¯æ¥è‡ª `lon-to-nelon`ï¼Œå³â€œæ¥å£â€å‡½æ•°ã€‚åæ•°æ®æ°¸è¿œä¸ä¼šåˆ°è¾¾ `avg4`ï¼æˆ‘ä»¬å¯ä»¥éªŒè¯è¿™ä¸€ç‚¹ï¼š
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Remember, thereâ€™s no way to send an empty list to `avg4`! Nevertheless, this
    suggests a trade-off: we can either use `NeLoN` explicitly but with more notational
    pain, or we can use `list` but run the risk of some confusion about exceptions.
    This is a trade-off in general, but there are better options in some languages
    ([A Note on Notation](#%28part._pd-pyret-list-constr%29)).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: è®°ä½ï¼Œæ²¡æœ‰æ–¹æ³•å¯ä»¥å°†ç©ºåˆ—è¡¨å‘é€åˆ° `avg4`ï¼å°½ç®¡å¦‚æ­¤ï¼Œè¿™è¡¨æ˜äº†ä¸€ä¸ªæƒè¡¡ï¼šæˆ‘ä»¬æ—¢å¯ä»¥æ˜¾å¼ä½¿ç”¨ `NeLoN` ä½†ä¼šå¸¦æ¥æ›´å¤šçš„ç¬¦å·ç—›è‹¦ï¼Œæˆ–è€…æˆ‘ä»¬å¯ä»¥ä½¿ç”¨
    `list` ä½†å†’ç€ä¸€äº›å…³äºå¼‚å¸¸æ··æ·†çš„é£é™©ã€‚è¿™æ˜¯ä¸€ä¸ªæ™®éçš„æƒè¡¡ï¼Œä½†åœ¨æŸäº›è¯­è¨€ä¸­å­˜åœ¨æ›´å¥½çš„é€‰æ‹©ï¼ˆ[å…³äºç¬¦å·çš„è¯´æ˜](#%28part._pd-pyret-list-constr%29)ï¼‰ã€‚
- en: 'So this is actually a very powerful technique: building a datatype that reflects
    exactly what we want, thereby turning a partial function into a total one. Programmers
    call this principle making illegal states unrepresentable. It may require writing
    some procedures to convert to and from other convenient representations for code
    reuse. Somewhere in those procedures there must be checks that reflect the partiality.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œè¿™å®é™…ä¸Šæ˜¯ä¸€ä¸ªéå¸¸å¼ºå¤§çš„æŠ€æœ¯ï¼šæ„å»ºä¸€ä¸ªæ­£å¥½åæ˜ æˆ‘ä»¬æƒ³è¦çš„ç±»å‹çš„dataypeï¼Œä»è€Œå°†éƒ¨åˆ†å‡½æ•°è½¬æ¢ä¸ºå…¨å‡½æ•°ã€‚ç¨‹åºå‘˜ç§°è¿™ä¸ªåŸåˆ™ä¸ºä½¿éæ³•çŠ¶æ€ä¸å¯è¡¨ç¤ºã€‚å¯èƒ½éœ€è¦ç¼–å†™ä¸€äº›è¿‡ç¨‹æ¥è½¬æ¢åˆ°å’Œä»å…¶ä»–æ–¹ä¾¿çš„è¡¨ç¤ºå½¢å¼ä»¥å®ç°ä»£ç é‡ç”¨ã€‚åœ¨è¿™äº›è¿‡ç¨‹ä¸­ï¼Œå¿…é¡»æœ‰æ£€æŸ¥æ¥åæ˜ éƒ¨åˆ†æ€§ã€‚
- en: 23.6Â Summary[ğŸ”—](#(part._pd-summary) "Link to here")
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.6 æ¦‚è¿°[ğŸ”—](#(part._pd-summary) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'In general, there is one non-solution:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸ï¼Œæœ‰ä¸€ä¸ªéè§£å†³æ–¹æ¡ˆï¼š
- en: Return a sentinel value. Do not ever do this unless youâ€™ve first fixed all the
    security bugs lurking in C programs from the past several decades.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿”å›ä¸€ä¸ªå“¨å…µå€¼ã€‚é™¤éä½ é¦–å…ˆä¿®å¤äº†Cç¨‹åºä¸­è¿‡å»å‡ åå¹´ä¸­æ½œä¼çš„æ‰€æœ‰å®‰å…¨æ¼æ´ï¼Œå¦åˆ™æ°¸è¿œä¸è¦è¿™æ ·åšã€‚
- en: 'and there are four solutions:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¶ä¸”æœ‰å››ç§è§£å†³æ–¹æ¡ˆï¼š
- en: Use `raise`. This is not very good for software engineering in general because
    exceptions are clunky, semantically complicated, and not compositional.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`raise`ã€‚è¿™å¹¶ä¸é€‚åˆè½¯ä»¶å·¥ç¨‹ï¼Œå› ä¸ºå¼‚å¸¸ç¬¨æ‹™ï¼Œè¯­ä¹‰å¤æ‚ï¼Œå¹¶ä¸”ä¸å…·æœ‰ç»„åˆæ€§ã€‚
- en: Use a dynamic refinement. Dynamic refinements arenâ€™t in most languages. Also,
    itâ€™s less good than each of the other solutions, but itâ€™s a decent compromise
    in many settings.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨åŠ¨æ€ç»†åŒ–ã€‚åŠ¨æ€ç»†åŒ–ä¸åœ¨å¤§å¤šæ•°è¯­è¨€ä¸­ã€‚æ­¤å¤–ï¼Œå®ƒæ¯”å…¶ä»–ä»»ä½•è§£å†³æ–¹æ¡ˆéƒ½å·®ï¼Œä½†åœ¨è®¸å¤šè®¾ç½®ä¸­æ˜¯ä¸€ä¸ªåˆç†çš„æŠ˜è¡·æ–¹æ¡ˆã€‚
- en: Define a datatype to make illegal states unrepresentable. A bit of work. Pretty
    sophisticated, invaluable in some places, but not always worth the effort.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®šä¹‰ä¸€ä¸ªæ•°æ®ç±»å‹æ¥ä½¿éæ³•çŠ¶æ€ä¸å¯è¡¨ç¤ºã€‚è¿™æ˜¯ä¸€é¡¹å·¥ä½œã€‚ç›¸å½“å¤æ‚ï¼Œåœ¨æŸäº›åœ°æ–¹éå¸¸æœ‰ä»·å€¼ï¼Œä½†å¹¶ä¸æ€»æ˜¯å€¼å¾—ä»˜å‡ºåŠªåŠ›ã€‚
- en: 'Use `Option`. Often the ideal option, because:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`Option`ã€‚é€šå¸¸æ˜¯ä¸€ä¸ªç†æƒ³çš„é€‰é¡¹ï¼Œå› ä¸ºï¼š
- en: The type tells us to expect funny business. (`raise` hides that.)
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç±»å‹å‘Šè¯‰æˆ‘ä»¬é¢„æœŸä¼šæœ‰ä¸€äº›å¥‡æ€ªçš„äº‹æƒ…å‘ç”Ÿã€‚ï¼ˆ`raise`éšè—äº†è¿™ä¸€ç‚¹ã€‚ï¼‰
- en: We canâ€™t accidentally misuse the value. (Sentinels hide that.)
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸ä¼šæ„å¤–åœ°è¯¯ç”¨è¿™ä¸ªå€¼ã€‚ï¼ˆå“¨å…µéšè—äº†è¿™ä¸€ç‚¹ã€‚ï¼‰
- en: 'Itâ€™s compositional: we can create functions to help us handle it.'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®ƒæ˜¯ç»„åˆæ€§çš„ï¼šæˆ‘ä»¬å¯ä»¥åˆ›å»ºå‡½æ•°æ¥å¸®åŠ©æˆ‘ä»¬å¤„ç†å®ƒã€‚
- en: Itâ€™s much lower overhead than the static totality solution.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®ƒæ¯”é™æ€æ•´ä½“è§£å†³æ–¹æ¡ˆçš„å¼€é”€è¦ä½å¾—å¤šã€‚
- en: Itâ€™s more statically robust than the dynamic totality solution.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®ƒæ¯”åŠ¨æ€æ•´ä½“è§£å†³æ–¹æ¡ˆæ›´é™æ€ç¨³å¥ã€‚
- en: 'It generalizes: in practice, instead of just `none` and `some`, a real program
    will have `some` for the â€œnormalâ€ case, and a bunch of variants describing the
    different kinds of errors that are possible, with extra information in each case.
    For concrete examples of this, see [Picking Elements from Sets](Collections_of_Structured_Data.html#%28part._coll-sd-pick%29)
    on sets [Combining Answers](queues-from-lists.html#%28part._qfl-comb-ans%29) on
    queues.'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®ƒè¿›è¡Œäº†æ¨å¹¿ï¼šåœ¨å®è·µä¸­ï¼Œé™¤äº†`none`å’Œ`some`ä¹‹å¤–ï¼Œä¸€ä¸ªçœŸæ­£çš„ç¨‹åºå°†ä¼šæœ‰`some`ç”¨äºâ€œæ­£å¸¸â€æƒ…å†µï¼Œä»¥åŠæè¿°å¯èƒ½å‡ºç°çš„ä¸åŒç±»å‹é”™è¯¯çš„å¤šä¸ªå˜ä½“ï¼Œæ¯ä¸ªæƒ…å†µéƒ½æœ‰é¢å¤–çš„ä¿¡æ¯ã€‚å…³äºè¿™ä¸ªçš„å…·ä½“ä¾‹å­ï¼Œè¯·å‚é˜…[ä»é›†åˆä¸­é€‰å–å…ƒç´ ](Collections_of_Structured_Data.html#%28part._coll-sd-pick%29)å’Œ[åˆå¹¶ç­”æ¡ˆ](queues-from-lists.html#%28part._qfl-comb-ans%29)ã€‚
- en: 23.7Â A Note on Notation[ğŸ”—](#(part._pd-pyret-list-constr) "Link to here")
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.7 å…³äºç¬¦å·çš„è¯´æ˜[ğŸ”—](#(part._pd-pyret-list-constr) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'When we wrote above that we canâ€™t get the convenience of writing, say, `[list:
    1, 2, 3]` when using `NeLoN`s, we were speaking in general. In some languages,
    we can actually make similar convenient constructors. In Pyret, for instance,
    there is a protocol for defining custom constructors; in fact, seemingly built-in
    constructors like `list` and `set` are built using this protocol. The code for
    doing this is a bit ungainly (in part because itâ€™s optimized to save some space
    and time by making the constructor-writerâ€™s life a little harder), but it only
    needs to be written once. Hereâ€™s a `nelon` constructor for `NeLoN`s:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'å½“æˆ‘ä»¬ä¸Šé¢è¯´æˆ‘ä»¬æ— æ³•åœ¨`NeLoN`sä¸­ä½¿ç”¨æ—¶è·å¾—ç¼–å†™ï¼Œä¾‹å¦‚`[list: 1, 2, 3]`çš„ä¾¿åˆ©æ€§æ—¶ï¼Œæˆ‘ä»¬æ˜¯åœ¨ä¸€èˆ¬æ„ä¹‰ä¸Šè¯´çš„ã€‚åœ¨æŸäº›è¯­è¨€ä¸­ï¼Œæˆ‘ä»¬å®é™…ä¸Šå¯ä»¥åˆ›å»ºç±»ä¼¼çš„ä¾¿åˆ©æ„é€ å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œåœ¨Pyretä¸­ï¼Œæœ‰ä¸€ä¸ªå®šä¹‰è‡ªå®šä¹‰æ„é€ å‡½æ•°çš„åè®®ï¼›å®é™…ä¸Šï¼Œåƒ`list`å’Œ`set`è¿™æ ·çš„çœ‹ä¼¼å†…ç½®çš„æ„é€ å‡½æ•°å°±æ˜¯ä½¿ç”¨è¿™ä¸ªåè®®æ„å»ºçš„ã€‚æ‰§è¡Œæ­¤æ“ä½œçš„ä»£ç æœ‰ç‚¹ç¬¨æ‹™ï¼ˆéƒ¨åˆ†åŸå› æ˜¯å› ä¸ºå®ƒé€šè¿‡ä½¿æ„é€ å‡½æ•°ç¼–å†™è€…çš„ç”Ÿæ´»æ›´å›°éš¾æ¥èŠ‚çœä¸€äº›ç©ºé—´å’Œæ—¶é—´ï¼‰ï¼Œä½†åªéœ€è¦ç¼–å†™ä¸€æ¬¡ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ª`nelon`æ„é€ å‡½æ•°çš„ä¾‹å­ï¼š'
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'These tests show that this constructor works very much like the built-in `list`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æµ‹è¯•è¡¨æ˜è¿™ä¸ªæ„é€ å‡½æ•°éå¸¸ç±»ä¼¼äºå†…ç½®çš„`list`ï¼š
- en: '[PRE45]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With this, we can rewrite the tests from [Total Domains, Statically](#%28part._pd-total-static%29)
    very conveniently:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥éå¸¸æ–¹ä¾¿åœ°é‡å†™[æ€»åŸŸï¼Œé™æ€](#%28part._pd-total-static%29)ä¸­çš„æµ‹è¯•ï¼š
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: thereby having our cake and eating it too!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬æ—¢å¾—åˆ°äº†è›‹ç³•ï¼Œåˆåƒäº†å®ƒï¼
