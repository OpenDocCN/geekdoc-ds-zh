<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>13.2Â Mutable ListsğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>13.2Â Mutable ListsğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/mutable-lists.html">https://dcic-world.org/2025-08-27/mutable-lists.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td/></tr></table><p>Letâ€™s expand our study of updates yet again, this time looking at
updating lists. Weâ€™ll start with lists.</p><p>Imagine that Shaunae wants to use a program to maintain her shopping
list. She creates an initial list with two items:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">shaunae_list = ["bread", "coffee"]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Shaunae wants to add eggs to her list. Write a line of code to
accomplish this.</p></blockquote></blockquote><p>There are two ways you could have done this:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># approach 1
shaunae_list = shaunae_list + ["eggs"]

#approach 2
shaunae_list.append("eggs")</code></pre><p>What is the difference between these two approaches? The difference
lies in the impact on the heap.
</p><ul><li><p>The first version creates a new list containing <code data-lang="text/x-python" class="sourceCode">"eggs"</code>,
then puts the elements of the two lists together in a new list.</p></li><li><p>The second version inserts <code data-lang="text/x-python" class="sourceCode">"eggs"</code> into the existing
list in the heap.</p></li></ul><p>Letâ€™s look at the directories for each version. Hereâ€™s the final directory
for the first version:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">shaunae_list</code></pre><p>Â â†’Â 1010</p></li></ul><p>Heap</p><ul><li><p>1005:Â <code data-lang="text/x-python" class="sourceCode">List(len:2)</code></p></li><li><p>1006:Â <code data-lang="text/x-python" class="sourceCode">"bread"</code></p></li><li><p>1007:Â <code data-lang="text/x-python" class="sourceCode">"coffee"</code></p></li><li><p>1008:Â <code data-lang="text/x-python" class="sourceCode">List(len:1)</code></p></li><li><p>1009:Â <code data-lang="text/x-python" class="sourceCode">"eggs"</code></p></li><li><p>1010:Â <code data-lang="text/x-python" class="sourceCode">List(len:3)</code></p></li><li><p>1011:Â <code data-lang="text/x-python" class="sourceCode">"bread"</code></p></li><li><p>1012:Â <code data-lang="text/x-python" class="sourceCode">"coffee"</code></p></li><li><p>1013:Â <code data-lang="text/x-python" class="sourceCode">"eggs"</code></p></li></ul><p>The original version of <code data-lang="text/x-python" class="sourceCode">shaunae_list</code> is in address
1005, the list with <code data-lang="text/x-python" class="sourceCode">"eggs"</code> is in 1008, and
the combined list is in 1010.</p><p>In contrast, the final directory for the second version would look like:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">shaunae_list</code></pre><p>Â â†’Â 1010</p></li></ul><p>Heap</p><ul><li><p>1005:Â <code data-lang="text/x-python" class="sourceCode">List(len:3)</code></p></li><li><p>1006:Â <code data-lang="text/x-python" class="sourceCode">"bread"</code></p></li><li><p>1007:Â <code data-lang="text/x-python" class="sourceCode">"coffee"</code></p></li><li><p>1008:Â <code data-lang="text/x-python" class="sourceCode">"eggs"</code></p></li></ul><p>Notice here that the length and contents of the original list are
changed to include the newly-appended <code data-lang="text/x-python" class="sourceCode">"eggs"</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Which approach do you think is better? Why?</p></blockquote></blockquote><p>At first glance, the second approach might seem better because it
doesnâ€™t create additional unnecessary lists. Both approaches result in
the same contents in <code data-lang="text/x-python" class="sourceCode">shaunae_List</code>, so there seems little
benefit to using the additional space.</p><p>Unless, of course, we want to still have access to the old version of
<code data-lang="text/x-python" class="sourceCode">shaunae_list</code> later on. The old list is still in the heap
(though our current program has no name through which to access that
old list). What if we instead had written the program this way?</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">shaunae_list = ["bread", "coffee"]
prev_list = shaunae_list
shaunae_list = ["paint", "brushes"] + shaunae_list</code></pre><p>Now, if Shaunae realizes she goofed and put her art supply shopping on
the grocery list on that last update, she could â€œundoâ€ the update by
resetting her list variable to the previous list:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">shaunae_list = prev_list</code></pre><p>Undoing a modification (just like the undo feature in document-editing
tools) is just one example of where it can help to hang on to older
versions of data for a little while. The point here is not to give a
sophisticated treatment of undoing computations, but more to motivate
that there are situations in which creating a new list is preferable
to updating the old one.</p><p>When might we want to update, rather than preserve, the existing list?</p><p>Remember our discussion of aliasing? We wanted two people, Elena and
Jorge to share access to a common bank account. Might we ever want a
shared shopping list? Sure, Shaunae and her roommate Jonella do share
a shopping list, so that they can both add items while letting either
one go to the store.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Set up a shared shopping list that is accessible through two names,
<code data-lang="text/x-python" class="sourceCode">shaunae_list</code> and <code data-lang="text/x-python" class="sourceCode">jonella_list</code>. Then, add an item to
the list via one of these names and check that the item appears under
the other name.</p></blockquote></blockquote><p>You might have written something like the following:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">shaunae_list = ["bread", "coffee"]
jonella_list = shaunae_list
jonella_list.append("eggs")</code></pre><p>If you load this code at the prompt and look at both lists at the end,
youâ€™ll see they have the same values.</p><p>In contrast, had we written the code as follows, only one of them
would see the new item:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">&gt;&gt;&gt; jonella_list = ["apples"] + jonella_list
&gt;&gt;&gt; jonella_list
["apples", "bread", "coffee", "eggs"]
&gt;&gt;&gt; shaunae_list
["bread", "coffee", "eggs"]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Draw the memory diagram for the above program.</p></blockquote></blockquote><section class="SsectionLevel4" id="section 0"><h4 class="heading"><a name="(part._.Exercise__.Creating_.Lists_of_.Accounts)"/>Exercise: Creating Lists of Accounts<a href="#(part._.Exercise__.Creating_.Lists_of_.Accounts)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In <a href="mutating-variables.html#%28part._mut-top-level-vars-in-func%29" data-pltdoc="x">Mutating Top-Level Variables within Functions</a>, we wrote a function to create new accounts for the
bank. That function returned each new account as it was created. That
meant that every newly-created account had to be associated with a
name in the directory (otherwise we would not be able to access it
from the heap).</p><p>Maintaining either a list or a dictionary of all the created accounts
makes much more sense. Weâ€™d need only a single name for the collection
of accounts, but could still access individual accounts as needed. For
example, we might want an <code data-lang="text/x-python" class="sourceCode">all_accts</code> list that looks something
like the following:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">all_accts = [Account(8623, 100),
             Account(8624, 300),
             Account(8625, 225),
             ...
             ]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write a program that creates an empty <code data-lang="text/x-python" class="sourceCode">all_accts</code> list, then
adds a new <code data-lang="text/x-python" class="sourceCode">Account</code> to it each time <code data-lang="text/x-python" class="sourceCode">create_acct</code> is called. You
will need to modify <code data-lang="text/x-python" class="sourceCode">create_acct</code> in order to do this. Here is
the existing code as a starting point.</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">next_id = 1

def create_acct(init_bal: float) -&gt; Account:
  global next_id
  new_acct = Account(next_id, init_bal, [])
  next_id = next_id + 1
  return new_acct</code></pre></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Did you include a line like <code data-lang="text/x-python" class="sourceCode">global all_accts</code> in your code?
Why or why not?</p></blockquote></blockquote><p>If you used <code data-lang="text/x-python" class="sourceCode">append</code> to update the <code data-lang="text/x-python" class="sourceCode">all_accts</code> list,
then you would not need to include <code data-lang="text/x-python" class="sourceCode">global all_accts</code>. Recall
that <code data-lang="text/x-python" class="sourceCode">global</code> is needed to tell Python to update a variable in
the top-level directory rather than the local directory. If you use
<code data-lang="text/x-python" class="sourceCode">all_accts.append</code>, however, you are modifying the heap instead
of the directory. There is no need for <code data-lang="text/x-python" class="sourceCode">global</code> if your code is
only modifying heap contents.</p></section>&#13;
<h4 class="heading"><a name="(part._.Exercise__.Creating_.Lists_of_.Accounts)"/>Exercise: Creating Lists of Accounts<a href="#(part._.Exercise__.Creating_.Lists_of_.Accounts)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In <a href="mutating-variables.html#%28part._mut-top-level-vars-in-func%29" data-pltdoc="x">Mutating Top-Level Variables within Functions</a>, we wrote a function to create new accounts for the
bank. That function returned each new account as it was created. That
meant that every newly-created account had to be associated with a
name in the directory (otherwise we would not be able to access it
from the heap).</p><p>Maintaining either a list or a dictionary of all the created accounts
makes much more sense. Weâ€™d need only a single name for the collection
of accounts, but could still access individual accounts as needed. For
example, we might want an <code data-lang="text/x-python" class="sourceCode">all_accts</code> list that looks something
like the following:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">all_accts = [Account(8623, 100),
             Account(8624, 300),
             Account(8625, 225),
             ...
             ]</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write a program that creates an empty <code data-lang="text/x-python" class="sourceCode">all_accts</code> list, then
adds a new <code data-lang="text/x-python" class="sourceCode">Account</code> to it each time <code data-lang="text/x-python" class="sourceCode">create_acct</code> is called. You
will need to modify <code data-lang="text/x-python" class="sourceCode">create_acct</code> in order to do this. Here is
the existing code as a starting point.</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">next_id = 1

def create_acct(init_bal: float) -&gt; Account:
  global next_id
  new_acct = Account(next_id, init_bal, [])
  next_id = next_id + 1
  return new_acct</code></pre></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Did you include a line like <code data-lang="text/x-python" class="sourceCode">global all_accts</code> in your code?
Why or why not?</p></blockquote></blockquote><p>If you used <code data-lang="text/x-python" class="sourceCode">append</code> to update the <code data-lang="text/x-python" class="sourceCode">all_accts</code> list,
then you would not need to include <code data-lang="text/x-python" class="sourceCode">global all_accts</code>. Recall
that <code data-lang="text/x-python" class="sourceCode">global</code> is needed to tell Python to update a variable in
the top-level directory rather than the local directory. If you use
<code data-lang="text/x-python" class="sourceCode">all_accts.append</code>, however, you are modifying the heap instead
of the directory. There is no need for <code data-lang="text/x-python" class="sourceCode">global</code> if your code is
only modifying heap contents.</p>    
</body>
</html>