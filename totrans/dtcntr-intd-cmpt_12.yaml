- en: 5.1¬†From Tables to Listsüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/tables-to-lists.html](https://dcic-world.org/2025-08-27/tables-to-lists.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[5.1.1¬†Basic Statistical Questions](#%28part._table-stat-qs%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[5.1.2¬†Extracting a Column from a Table](#%28part._.Extracting_a_.Column_from_a_.Table%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[5.1.3¬†Understanding Lists](#%28part._.Understanding_.Lists%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[5.1.3.1¬†Lists as Anonymous Data](#%28part._lists-generic-data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[5.1.3.2¬†Creating Literal Lists](#%28part._.Creating_.Literal_.Lists%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[5.1.4¬†Operating on Lists](#%28part._.Operating_on_.Lists%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[5.1.4.1¬†Built-In Operations on Lists of Numbers](#%28part._.Built-.In_.Operations_on_.Lists_of_.Numbers%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[5.1.4.2¬†Built-In Operations on Lists in General](#%28part._.Built-.In_.Operations_on_.Lists_in_.General%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[5.1.4.3¬†An Aside on Naming Conventions](#%28part._.An_.Aside_on_.Naming_.Conventions%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[5.1.4.4¬†Getting Elements By Position](#%28part._.Getting_.Elements_.By_.Position%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[5.1.4.5¬†Transforming Lists](#%28part._.Transforming_.Lists%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[5.1.4.6¬†Recap: Summary of List Operations](#%28part._lists-recap%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[5.1.5¬†Lambda: Anonymous Functions](#%28part._.Lambda__.Anonymous_.Functions%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[5.1.6¬†Combining Lists and Tables](#%28part._.Combining_.Lists_and_.Tables%29)
    |'
  prefs: []
  type: TYPE_TB
- en: Previously [[Introduction to Tabular Data](intro-tabular-data.html)] we began
    to process collective data in the form of tables. Though we saw several powerful
    operations that let us quickly and easily ask sophisticated questions about our
    data, they all had two things in common. First, all were operations by rows. None
    of the operations asked questions about an entire column at a time. Second, all
    the operations not only consumed but also produced tables. However, we already
    know [[Getting Started](getting-started.html)] there are many other kinds of data,
    and sometimes we will want to compute one of them. We will now see how to achieve
    both of these things, introducing an important new type of data in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.1¬†Basic Statistical Questions[üîó](#(part._table-stat-qs) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are many more questions we might want to ask of our events data. For
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: The most-frequently used discount code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The average number of tickets per order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The largest ticket order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common number of tickets in an order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collection of unique discount codes that were used (many might have been
    available).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collection of distinct email addresses associated with orders, so we can
    contact customers (some customers may have placed multiple orders).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which school lead to the largest number of orders with a `"STUDENT"` discount.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice the kinds of operations that we are talking about: computing the maximum,
    minimum, average, median, and other basic statistics.Pyret has several built-in
    statistics functions in the [math](http://www.pyret.org/docs/latest/math.html)
    and [statistics](http://www.pyret.org/docs/latest/statistics.html) packages.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Think about whether and how you would express these questions with the operations
    you have already seen.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: In each of these cases, we need to perform a computation on a single column
    of data (even in the last question about the `"STUDENT"` discount, as we would
    filter the table to those rows, then do a computation over the `email` column).
    In order to capture these in code, we need to extract a column from the table.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this chapter, we will work with a cleaned copy of the `event-data`
    from the previous chapter. The cleaned data, which applies the transformations
    at the end of the previous chapter, is in a different tab of the same Google Sheet
    as the other versions of the event data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 5.1.2¬†Extracting a Column from a Table[üîó](#(part._.Extracting_a_.Column_from_a_.Table)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our collection of table functions includes one that we haven‚Äôt yet used, called
    `select-columns`. As the name suggests, this function produces a new table containing
    only certain columns from an existing table. Let‚Äôs extract the `tickcount` column
    so we can compute some statistics over it. We use the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/218dbd3d076ef24041ce988f1e4f6c1d.png)'
  prefs: []
  type: TYPE_IMG
- en: This focuses our attention on the numeric ticket sales, but we‚Äôre still stuck
    with a column in a table, and none of the other tables functions let us do the
    kinds of computations we might want over these numbers. Ideally, we want the collection
    of numbers on their own, without being wrapped up in the extra layer of table
    cells.
  prefs: []
  type: TYPE_NORMAL
- en: In principle, we could have a collection of operations on a single column. In
    some languages that focus solely on tables, such as [SQL](https://en.wikipedia.org/wiki/SQL),
    this is what you‚Äôll find. However, in Pyret we have many more kinds of data than
    just columns (as we‚Äôll soon see [[Introduction to Structured Data](intro-struct-data.html)],
    we can even create our own!), so it makes sense to leave the gentle cocoon of
    tables sooner or later. An extracted column is a more basic kind of datum called
    a list, which can be used to represent a sequence of data outside of a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we have used the notation `.row-n` to pull a single row from a table,
    we use a similar dot-based notion to pull out a single column. Here‚Äôs how we extract
    the `tickcount` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In response, Pyret produces the following value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we seem to have only the values that were in the cells in the column,
    without the enclosing table. Yet the numbers are still bundled up, this time in
    the `[list: ...]` notation. What is that?'
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.3¬†Understanding Lists[üîó](#(part._.Understanding_.Lists) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A list has much in common with a single-column table:'
  prefs: []
  type: TYPE_NORMAL
- en: The elements have an order, so it makes sense to talk about the ‚Äúfirst‚Äù, ‚Äúsecond‚Äù,
    ‚Äúlast‚Äù‚Äî<wbr>and so on‚Äî<wbr>element of a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All elements of a list are expected to have the same type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The crucial difference is that a list does not have a ‚Äúcolumn name‚Äù; it is anonymous.
    That is, by itself a list does not describe what it represents; this interpretation
    is done by our program.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.3.1¬†Lists as Anonymous Data[üîó](#(part._lists-generic-data) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This might sound rather abstract‚Äî<wbr>and it is‚Äî<wbr>but this isn‚Äôt actually
    a new idea in our programming experience. Consider a value like `3` or `-1`: what
    is it? It‚Äôs the same sort of thing: an anonymous value that does not describe
    what it represents; the interpretation is done by our program. In one setting
    `3` may represent an age, in another a play count; in one setting `-1` may be
    a temperature, in another the average of several temperatures. Similarly with
    a string: Is `"project"` a noun (an activity that one or more people perform)
    or a verb (as when we display something on a screen)? Likewise with images and
    so on. In fact, tables have been the exception so far in having description built
    into the data rather than being provided by a program!'
  prefs: []
  type: TYPE_NORMAL
- en: This genericity is both a virtue and a problem. Because, like other anonymous
    data, a list does not provide any interpretation of its use, if we are not careful
    we can accidentally mis-interpret the values. On the other hand, it means we can
    use the same datum in several different contexts, and one operation can be used
    in many settings.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, if we look at the list of questions we asked earlier, we see that there
    are several common operations‚Äî<wbr>maximum, minimum, average, and so on‚Äî<wbr>that
    can be asked of a list of values without regard for what the list represents (heights,
    ages, playcounts). In fact, some are specific to numbers (like average) while
    some (like maximum) can be asked of any type on which we can perform a comparison
    (like strings).
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.3.2¬†Creating Literal Lists[üîó](#(part._.Creating_.Literal_.Lists) "Link to
    here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We have already seen how we can create lists from a table, using `get-column`.
    As you might expect, however, we can also create lists directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Of course, lists are values so we can name them using variables‚Äî<wbr>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: ‚Äî<wbr>pass them to functions (as we will soon see), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Based on these examples, can you figure out how to create an empty list?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As you might have guessed, it‚Äôs `[list: ]` (the space isn‚Äôt necessary, but
    it‚Äôs a useful visual reminder of the void).'
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4¬†Operating on Lists[üîó](#(part._.Operating_on_.Lists) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 5.1.4.1¬†Built-In Operations on Lists of Numbers[üîó](#(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Pyret handily provides a useful set of operations we can already perform on
    lists. The [lists documentation](https://www.pyret.org/docs/latest/lists.html)
    describes these operations. As you might have guessed, we can already compute
    most of the answers we‚Äôve asked for at the start of the chapter. First we need
    to include some libraries that contain useful functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then access several useful functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `M.` notation means "the function inside the library `M`. The `import` statement
    in the above code gave the name `M` to the `math` library.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4.2¬†Built-In Operations on Lists in General[üîó](#(part._.Built-.In_.Operations_on_.Lists_in_.General)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Some of the useful computations in our list at the start of the chapter involved
    the `discount` column, which contains strings rather than numbers. Specifically,
    let‚Äôs consider the following question:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute the collection of unique discount codes that were used (many might have
    been available).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'None of the table functions handle a question like this. However, this is a
    common kind of question to ask about a collection of values (How many unique artists
    are in your playlist? How many unique faculty are teaching courses?). As such,
    Pyret (as most languages) provides a way to identify the unique elements of a
    list. Here‚Äôs how we get the list of all discount codes that were used in our table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `distinct` function produces a list of the unique values from the input
    list: every value in the input list appears exactly once in the output list. For
    the above code, Pyret produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: What if we wanted to exclude `"none"` from that list? After all, `"none"` isn‚Äôt
    an actual discount code, but rather one that we introduced while cleaning up the
    table. Is there a way to easily remove `"none"` from the list?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways we could do it. In the Pyret lists documentation, we find
    a function called `remove`, which removes a specific element from a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'But this operation should also sound familiar: with tables, we used `filter-with`
    to keep only those elements that meet a specific criterion. The filtering idea
    is so common that Pyret (and most other languages) provide a similar operation
    on lists. In the case of the discount codes, we could also have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between these two approaches is that `filter` is more flexible:
    we can check any characteristic of a list element using `filter`, but `remove`
    only checks whether the entire element is equal to the value that we provide.
    If instead of removing the specific string `"none"`, we had wanted to remove all
    strings that were in all-lowercase, we would have needed to use `filter`.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write a function that takes a list of words and removes those words in which
    all letters are in lowercase. (Hint: combine `string-to-lower` and `==`).'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5.1.4.3¬†An Aside on Naming Conventions[üîó](#(part._.An_.Aside_on_.Naming_.Conventions)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Our use of the plural `codes` for the list of values in the column named `discount`
    (singular) is deliberate. A list contains multiple values, so a plural is appropriate.
    In a table, in contrast, we think of a column header as naming a single value
    that appears in a specific row. Often, we speak of looking up a value in a specific
    row and column: the singular name for the column supports thinking about lookup
    in an individual row.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4.4¬†Getting Elements By Position[üîó](#(part._.Getting_.Elements_.By_.Position)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let‚Äôs look at a new analysis question: the events company recently ran an advertising
    campaign on `web.com`, and they are curious whether it paid off. To do this, they
    need to determine how many sales were made to people with `web.com` email addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a task plan ([Task Plans](processing-tables.html#%28part._task-plans%29))
    for this computation.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here‚Äôs a proposed plan, annotated with how we might implement each part:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the list of email addresses (use `get-column`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract those that came from `web.com` (use `L.filter`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Count how many email addresses remain (using `L.length`, which we hadn‚Äôt discussed
    yet, but it is in the documentation)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (As a reminder, unless you immediately see how to solve a problem, write out
    a task plan and annotate the parts you know how to do. It helps break down a programming
    problem into more manageable parts.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs discuss the second task: identifying messages from `web.com`. We know
    that email addresses are strings, so if we could determine whether an email string
    ends in `@web.com`, we‚Äôd be set. You could consider doing this by looking at the
    last 7 characters of the email string. Another option is to use a string operation
    that we haven‚Äôt yet seen called `string-split-all`, which splits a string into
    a list of substrings around a given character. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This seems pretty useful. If we split each email string around the `@` sign,
    then we can check whether the second string in the list is `web.com` (since email
    addresses should have only one `@` sign). But how would we get the second element
    out of the list produced by `string-split-all`? Here we dig into the list, as
    we did to extract rows from tables, this time using the `get` operation.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do we use `1` as the input to `get` if we want the second item in the list?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here‚Äôs the complete program for doing this check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if there is a malformed email address string that doesn‚Äôt contain
    the `@` string? What would happen? What could you do about that?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5.1.4.5¬†Transforming Lists[üîó](#(part._.Transforming_.Lists) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Imagine now that we had a list of email addresses, but instead just wanted a
    list of usernames. This doesn‚Äôt make sense for our event data, but it does make
    sense in other contexts (such as connecting messages to folders organized by students‚Äô
    usernames).
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifcally, we want to start with a list of addresses such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: and convert it to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider the list functions we have seen so far (`distinct`, `filter`, `length`)
    ‚Äì are any of them useful for this task? Can you articulate why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: One way to articulate a precise answer to this is think in terms of the inputs
    and outputs of the existing functions. Both `filter` and `distinct` return a list
    of elements from the input list, not transformed elements. `length` returns a
    number, not a list. So none of these are appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'This idea of transforming elements is similar to the `transform-column` operation
    that we previously saw on tables. The corresponding operation on lists is called
    `map`. Here‚Äôs an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '5.1.4.6¬†Recap: Summary of List Operations[üîó](#(part._lists-recap) "Link to
    here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At this point, we have seen several useful built-in functions for working with
    lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter :: (A -> Boolean), List<A> -> List<A>`, which produces a list of elements
    from the input list on which the given function returns `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map :: (A -> B), List<A> -> List<B>`, which produces a list of the results
    of calling the given function on each element of the input list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`distinct :: List<A> -> List<A>`, which produces a list of the unique elements
    that appear in the input list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length :: List<A> -> Number`, which produces the number of elements in the
    input list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, a type such as `List<A>` says that we have a list whose elements are of
    some (unspecified) type which we‚Äôll call `A`. A type variable such as this is
    useful when we want to show relationships between two types in a function contract.
    Here, the type variable `A` captures that the type of elements is the same in
    the input and output to `filter`. In `map`, however, the type of element in the
    output list could differ from that in the input list.
  prefs: []
  type: TYPE_NORMAL
- en: 'One additional built-in function that is quite useful in practice is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`member :: List<A>, Any -> Boolean`, which determines whether the given element
    is in the list. We use the type `Any` when there are no constraints on the type
    of value provided to a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many useful computations can be performed by combining these operations.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Assume you used a list of strings to represent the ingredients in a recipe.
    Here are three examples:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write the following functions on ingredient lists:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`recipes-uses`, which takes an ingredient list and an ingredient and determines
    whether the recipe uses the ingredient.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`make-vegetarian`, which takes an ingredient list and replaces all meat ingredients
    with `"tofu"`. Meat ingredients are `"pork"`, `"chicken"`, and `"beef"`.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`protein-veg-count`, which takes an ingredient list and determines how many
    ingredients are in the list that aren‚Äôt `"rice"` or `"noodles"`.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'More challenging: Write a function that takes an ingredient and a list of ingredient
    lists and produces a list of all the lists that contain the given ingredient.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hint: write examples first to make sense of the problem as needed.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Even more challenging: Try to write a function that takes two ingredient lists
    and returns all of the ingredients that are common to both lists. What issue(s)
    or limitations do you run into?'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Come back to this problem after you finish the next section.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '5.1.5¬†Lambda: Anonymous Functions[üîó](#(part._.Lambda__.Anonymous_.Functions)
    "Link to here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'NOTE: if you already saw `lam` in [Lambda: Anonymous Functions](intro-tabular-data.html#%28part._sec~3alambda-tables%29),
    feel free to skip this section, or just do the exercises at the end. Here we present
    `lam` using lists and `filter`, rather than tables and `filter-with`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs revisit the program we wrote earlier in this chapter for finding all
    of the discount codes that were used in the events table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This program might feel a bit verbose: do we really need to write a helper
    function just to perform something as simple as a `filter`? Wouldn‚Äôt it be easier
    to just write something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will Pyret produce if you run this expression?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pyret will produce an `unbound identifier` error around the use of `c` in this
    expression. What is `c`? We mean for `c` to be the elements from `codes` in turn.
    Conceptually, that‚Äôs what `filter` does, but we don‚Äôt have the mechanics right.
    When we call a function, we evaluate the arguments before the body of the function.
    Hence, the error regarding `c` being unbound. The whole point of the `real-code`
    helper function is to make `c` a parameter to a function whose body is only evaluated
    once a value for `c` is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tighten the notation as in the one-line `filter` expression, then, we have
    to find a way to tell Pyret to make a temporary function that will get its inputs
    once `filter` is running. The following notation achieves this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We have added `lam(c)` and `end` around the expression that we want to use in
    the `filter`. The `lam(c)` says "make a temporary function that takes `c` as an
    input". The `end` serves to end the function definition, as when we use `fun`.
    `lam` is short for `lambda`, a form of function definition that exists in many,
    though not all, languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference between our original expression (using the `real-code`
    helper) and this new one (using `lam`) can be seen through the program directory.
    To explain this, a little detail about how `filter` is defined under the hood.
    In part, it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Whether we pass `real-code` or the `lam` version to `filter`, the `keep` parameter
    ends up referring to a function with the same parameter and body. Since the function
    is only actually called through the `keep` name, it doesn‚Äôt matter whether or
    not a name is associated with it when it is initially defined.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, we use `lam` when we have to pass simple (single line) functions
    to operations like `filter` (or `map`). We could have just as easily used them
    when we were working with tables (`build-column`, `filter-with`, etc). Of course,
    you can continue to write out names for helper functions as we did with `real-code`
    if that makes more sense to you.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the program to extract the list of usernames from a list of email addresses
    using `lam` rather than a named helper-function.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Try again to tackle the problem from the end of the previous section: write
    a function that takes two ingredient lists and returns all of the ingredients
    that are common to both lists.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5.1.6¬†Combining Lists and Tables[üîó](#(part._.Combining_.Lists_and_.Tables) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The table functions we studied previously were primarily for processing rows.
    The list functions we‚Äôve learned in this chapter have been primarily for processing
    columns (but there are many more uses in the chapters ahead). If an analysis involves
    working with only some rows and some columns, we‚Äôll use a combination of both
    table and list functions in our program.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the events table, produce a list of names of all people who will pick
    up their tickets.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the events table, produce the average number of tickets that were ordered
    by people with email addresses that end in `".org"`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Sometimes, there will be more than one way to perform a computation:'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider a question such as "how many people with `".org"` email addresses bought
    more than 8 tickets". Propose multiple task plans that would solve this problem,
    including which table and list functions would accomplish each task.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There are several options here:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the `event-data` rows with no more than 8 tickets (using `filter-with`),
    get those rows that have `".org"` addresses (another `filter-with`), then ask
    for how many rows are in the table (using `<table>.length()`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the `event-data` rows with no more than 8 tickets and `".org"` address (using
    `filter-with` with a function that checks both conditions at once), then ask for
    how many rows are in the table (using `<table>.length()`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the `event-data` rows with no more than 8 tickets (using `filter-with`),
    extract the email addresses (using `get-column`), limit those to `".org"` (using
    `L.filter`), then get the length of the resulting list (using `L.length`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are others, but you get the idea.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which approach do you like best? Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'While there is no single correct answer, there are various considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: Are any of the intermediate results useful for other computations? While the
    second option might seem best because it filters the table once rather than twice,
    perhaps the events company has many computations to perform on larger ticket orders.
    Similarly, the company may want the list of email addresses on large orders for
    other purposes (the third option)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you want to follow a discipline of doing operations on individuals within
    the table, extracting lists only when needed to perform aggregating computations
    that aren‚Äôt available on tables?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Does one approach seem less resource-intensive than the other? This is actually
    a subtle point: you might be tempted to think that filtering over a table uses
    more resources than filtering over a list of values from one column, but this
    actually isn‚Äôt the case. We‚Äôll return to this discussion later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A company or project team sometimes sets design standards to help you make those
    decisions. In the absence of that, and especially as you are learning to program,
    consider multiple approaches when faced with such problems, then pick one to implement.
    Maintaining the ability to think flexibly about approaches is a useful skill in
    any form of design.
  prefs: []
  type: TYPE_NORMAL
- en: Until now we‚Äôve only seen how to use built-in functions over lists. Next [[Processing
    Lists](processing-lists.html)], we will study how to create our own functions
    that process lists. Once we learn that, these list processing functions will remain
    powerful but will no longer seem quite so magical, because we‚Äôll be able to build
    them for ourselves!
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.1¬†Basic Statistical Questions[üîó](#(part._table-stat-qs) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are many more questions we might want to ask of our events data. For
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: The most-frequently used discount code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The average number of tickets per order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The largest ticket order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common number of tickets in an order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collection of unique discount codes that were used (many might have been
    available).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collection of distinct email addresses associated with orders, so we can
    contact customers (some customers may have placed multiple orders).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which school lead to the largest number of orders with a `"STUDENT"` discount.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice the kinds of operations that we are talking about: computing the maximum,
    minimum, average, median, and other basic statistics.Pyret has several built-in
    statistics functions in the [math](http://www.pyret.org/docs/latest/math.html)
    and [statistics](http://www.pyret.org/docs/latest/statistics.html) packages.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Think about whether and how you would express these questions with the operations
    you have already seen.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: In each of these cases, we need to perform a computation on a single column
    of data (even in the last question about the `"STUDENT"` discount, as we would
    filter the table to those rows, then do a computation over the `email` column).
    In order to capture these in code, we need to extract a column from the table.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this chapter, we will work with a cleaned copy of the `event-data`
    from the previous chapter. The cleaned data, which applies the transformations
    at the end of the previous chapter, is in a different tab of the same Google Sheet
    as the other versions of the event data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 5.1.2¬†Extracting a Column from a Table[üîó](#(part._.Extracting_a_.Column_from_a_.Table)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our collection of table functions includes one that we haven‚Äôt yet used, called
    `select-columns`. As the name suggests, this function produces a new table containing
    only certain columns from an existing table. Let‚Äôs extract the `tickcount` column
    so we can compute some statistics over it. We use the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/218dbd3d076ef24041ce988f1e4f6c1d.png)'
  prefs: []
  type: TYPE_IMG
- en: This focuses our attention on the numeric ticket sales, but we‚Äôre still stuck
    with a column in a table, and none of the other tables functions let us do the
    kinds of computations we might want over these numbers. Ideally, we want the collection
    of numbers on their own, without being wrapped up in the extra layer of table
    cells.
  prefs: []
  type: TYPE_NORMAL
- en: In principle, we could have a collection of operations on a single column. In
    some languages that focus solely on tables, such as [SQL](https://en.wikipedia.org/wiki/SQL),
    this is what you‚Äôll find. However, in Pyret we have many more kinds of data than
    just columns (as we‚Äôll soon see [[Introduction to Structured Data](intro-struct-data.html)],
    we can even create our own!), so it makes sense to leave the gentle cocoon of
    tables sooner or later. An extracted column is a more basic kind of datum called
    a list, which can be used to represent a sequence of data outside of a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we have used the notation `.row-n` to pull a single row from a table,
    we use a similar dot-based notion to pull out a single column. Here‚Äôs how we extract
    the `tickcount` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In response, Pyret produces the following value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we seem to have only the values that were in the cells in the column,
    without the enclosing table. Yet the numbers are still bundled up, this time in
    the `[list: ...]` notation. What is that?'
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.3¬†Understanding Lists[üîó](#(part._.Understanding_.Lists) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A list has much in common with a single-column table:'
  prefs: []
  type: TYPE_NORMAL
- en: The elements have an order, so it makes sense to talk about the ‚Äúfirst‚Äù, ‚Äúsecond‚Äù,
    ‚Äúlast‚Äù‚Äî<wbr>and so on‚Äî<wbr>element of a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All elements of a list are expected to have the same type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The crucial difference is that a list does not have a ‚Äúcolumn name‚Äù; it is anonymous.
    That is, by itself a list does not describe what it represents; this interpretation
    is done by our program.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.3.1¬†Lists as Anonymous Data[üîó](#(part._lists-generic-data) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This might sound rather abstract‚Äî<wbr>and it is‚Äî<wbr>but this isn‚Äôt actually
    a new idea in our programming experience. Consider a value like `3` or `-1`: what
    is it? It‚Äôs the same sort of thing: an anonymous value that does not describe
    what it represents; the interpretation is done by our program. In one setting
    `3` may represent an age, in another a play count; in one setting `-1` may be
    a temperature, in another the average of several temperatures. Similarly with
    a string: Is `"project"` a noun (an activity that one or more people perform)
    or a verb (as when we display something on a screen)? Likewise with images and
    so on. In fact, tables have been the exception so far in having description built
    into the data rather than being provided by a program!'
  prefs: []
  type: TYPE_NORMAL
- en: This genericity is both a virtue and a problem. Because, like other anonymous
    data, a list does not provide any interpretation of its use, if we are not careful
    we can accidentally mis-interpret the values. On the other hand, it means we can
    use the same datum in several different contexts, and one operation can be used
    in many settings.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, if we look at the list of questions we asked earlier, we see that there
    are several common operations‚Äî<wbr>maximum, minimum, average, and so on‚Äî<wbr>that
    can be asked of a list of values without regard for what the list represents (heights,
    ages, playcounts). In fact, some are specific to numbers (like average) while
    some (like maximum) can be asked of any type on which we can perform a comparison
    (like strings).
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.3.2¬†Creating Literal Lists[üîó](#(part._.Creating_.Literal_.Lists) "Link to
    here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We have already seen how we can create lists from a table, using `get-column`.
    As you might expect, however, we can also create lists directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Of course, lists are values so we can name them using variables‚Äî<wbr>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: ‚Äî<wbr>pass them to functions (as we will soon see), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Based on these examples, can you figure out how to create an empty list?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As you might have guessed, it‚Äôs `[list: ]` (the space isn‚Äôt necessary, but
    it‚Äôs a useful visual reminder of the void).'
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.3.1¬†Lists as Anonymous Data[üîó](#(part._lists-generic-data) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This might sound rather abstract‚Äî<wbr>and it is‚Äî<wbr>but this isn‚Äôt actually
    a new idea in our programming experience. Consider a value like `3` or `-1`: what
    is it? It‚Äôs the same sort of thing: an anonymous value that does not describe
    what it represents; the interpretation is done by our program. In one setting
    `3` may represent an age, in another a play count; in one setting `-1` may be
    a temperature, in another the average of several temperatures. Similarly with
    a string: Is `"project"` a noun (an activity that one or more people perform)
    or a verb (as when we display something on a screen)? Likewise with images and
    so on. In fact, tables have been the exception so far in having description built
    into the data rather than being provided by a program!'
  prefs: []
  type: TYPE_NORMAL
- en: This genericity is both a virtue and a problem. Because, like other anonymous
    data, a list does not provide any interpretation of its use, if we are not careful
    we can accidentally mis-interpret the values. On the other hand, it means we can
    use the same datum in several different contexts, and one operation can be used
    in many settings.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, if we look at the list of questions we asked earlier, we see that there
    are several common operations‚Äî<wbr>maximum, minimum, average, and so on‚Äî<wbr>that
    can be asked of a list of values without regard for what the list represents (heights,
    ages, playcounts). In fact, some are specific to numbers (like average) while
    some (like maximum) can be asked of any type on which we can perform a comparison
    (like strings).
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.3.2¬†Creating Literal Lists[üîó](#(part._.Creating_.Literal_.Lists) "Link to
    here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We have already seen how we can create lists from a table, using `get-column`.
    As you might expect, however, we can also create lists directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Of course, lists are values so we can name them using variables‚Äî<wbr>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: ‚Äî<wbr>pass them to functions (as we will soon see), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Based on these examples, can you figure out how to create an empty list?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As you might have guessed, it‚Äôs `[list: ]` (the space isn‚Äôt necessary, but
    it‚Äôs a useful visual reminder of the void).'
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4¬†Operating on Lists[üîó](#(part._.Operating_on_.Lists) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 5.1.4.1¬†Built-In Operations on Lists of Numbers[üîó](#(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Pyret handily provides a useful set of operations we can already perform on
    lists. The [lists documentation](https://www.pyret.org/docs/latest/lists.html)
    describes these operations. As you might have guessed, we can already compute
    most of the answers we‚Äôve asked for at the start of the chapter. First we need
    to include some libraries that contain useful functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then access several useful functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `M.` notation means "the function inside the library `M`. The `import` statement
    in the above code gave the name `M` to the `math` library.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4.2¬†Built-In Operations on Lists in General[üîó](#(part._.Built-.In_.Operations_on_.Lists_in_.General)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Some of the useful computations in our list at the start of the chapter involved
    the `discount` column, which contains strings rather than numbers. Specifically,
    let‚Äôs consider the following question:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute the collection of unique discount codes that were used (many might have
    been available).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'None of the table functions handle a question like this. However, this is a
    common kind of question to ask about a collection of values (How many unique artists
    are in your playlist? How many unique faculty are teaching courses?). As such,
    Pyret (as most languages) provides a way to identify the unique elements of a
    list. Here‚Äôs how we get the list of all discount codes that were used in our table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `distinct` function produces a list of the unique values from the input
    list: every value in the input list appears exactly once in the output list. For
    the above code, Pyret produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: What if we wanted to exclude `"none"` from that list? After all, `"none"` isn‚Äôt
    an actual discount code, but rather one that we introduced while cleaning up the
    table. Is there a way to easily remove `"none"` from the list?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways we could do it. In the Pyret lists documentation, we find
    a function called `remove`, which removes a specific element from a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'But this operation should also sound familiar: with tables, we used `filter-with`
    to keep only those elements that meet a specific criterion. The filtering idea
    is so common that Pyret (and most other languages) provide a similar operation
    on lists. In the case of the discount codes, we could also have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between these two approaches is that `filter` is more flexible:
    we can check any characteristic of a list element using `filter`, but `remove`
    only checks whether the entire element is equal to the value that we provide.
    If instead of removing the specific string `"none"`, we had wanted to remove all
    strings that were in all-lowercase, we would have needed to use `filter`.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write a function that takes a list of words and removes those words in which
    all letters are in lowercase. (Hint: combine `string-to-lower` and `==`).'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5.1.4.3¬†An Aside on Naming Conventions[üîó](#(part._.An_.Aside_on_.Naming_.Conventions)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Our use of the plural `codes` for the list of values in the column named `discount`
    (singular) is deliberate. A list contains multiple values, so a plural is appropriate.
    In a table, in contrast, we think of a column header as naming a single value
    that appears in a specific row. Often, we speak of looking up a value in a specific
    row and column: the singular name for the column supports thinking about lookup
    in an individual row.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4.4¬†Getting Elements By Position[üîó](#(part._.Getting_.Elements_.By_.Position)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let‚Äôs look at a new analysis question: the events company recently ran an advertising
    campaign on `web.com`, and they are curious whether it paid off. To do this, they
    need to determine how many sales were made to people with `web.com` email addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a task plan ([Task Plans](processing-tables.html#%28part._task-plans%29))
    for this computation.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here‚Äôs a proposed plan, annotated with how we might implement each part:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the list of email addresses (use `get-column`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract those that came from `web.com` (use `L.filter`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Count how many email addresses remain (using `L.length`, which we hadn‚Äôt discussed
    yet, but it is in the documentation)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (As a reminder, unless you immediately see how to solve a problem, write out
    a task plan and annotate the parts you know how to do. It helps break down a programming
    problem into more manageable parts.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs discuss the second task: identifying messages from `web.com`. We know
    that email addresses are strings, so if we could determine whether an email string
    ends in `@web.com`, we‚Äôd be set. You could consider doing this by looking at the
    last 7 characters of the email string. Another option is to use a string operation
    that we haven‚Äôt yet seen called `string-split-all`, which splits a string into
    a list of substrings around a given character. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This seems pretty useful. If we split each email string around the `@` sign,
    then we can check whether the second string in the list is `web.com` (since email
    addresses should have only one `@` sign). But how would we get the second element
    out of the list produced by `string-split-all`? Here we dig into the list, as
    we did to extract rows from tables, this time using the `get` operation.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do we use `1` as the input to `get` if we want the second item in the list?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here‚Äôs the complete program for doing this check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if there is a malformed email address string that doesn‚Äôt contain
    the `@` string? What would happen? What could you do about that?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5.1.4.5¬†Transforming Lists[üîó](#(part._.Transforming_.Lists) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Imagine now that we had a list of email addresses, but instead just wanted a
    list of usernames. This doesn‚Äôt make sense for our event data, but it does make
    sense in other contexts (such as connecting messages to folders organized by students‚Äô
    usernames).
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifcally, we want to start with a list of addresses such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: and convert it to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider the list functions we have seen so far (`distinct`, `filter`, `length`)
    ‚Äì are any of them useful for this task? Can you articulate why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: One way to articulate a precise answer to this is think in terms of the inputs
    and outputs of the existing functions. Both `filter` and `distinct` return a list
    of elements from the input list, not transformed elements. `length` returns a
    number, not a list. So none of these are appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'This idea of transforming elements is similar to the `transform-column` operation
    that we previously saw on tables. The corresponding operation on lists is called
    `map`. Here‚Äôs an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '5.1.4.6¬†Recap: Summary of List Operations[üîó](#(part._lists-recap) "Link to
    here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At this point, we have seen several useful built-in functions for working with
    lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter :: (A -> Boolean), List<A> -> List<A>`, which produces a list of elements
    from the input list on which the given function returns `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map :: (A -> B), List<A> -> List<B>`, which produces a list of the results
    of calling the given function on each element of the input list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`distinct :: List<A> -> List<A>`, which produces a list of the unique elements
    that appear in the input list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length :: List<A> -> Number`, which produces the number of elements in the
    input list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, a type such as `List<A>` says that we have a list whose elements are of
    some (unspecified) type which we‚Äôll call `A`. A type variable such as this is
    useful when we want to show relationships between two types in a function contract.
    Here, the type variable `A` captures that the type of elements is the same in
    the input and output to `filter`. In `map`, however, the type of element in the
    output list could differ from that in the input list.
  prefs: []
  type: TYPE_NORMAL
- en: 'One additional built-in function that is quite useful in practice is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`member :: List<A>, Any -> Boolean`, which determines whether the given element
    is in the list. We use the type `Any` when there are no constraints on the type
    of value provided to a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many useful computations can be performed by combining these operations.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Assume you used a list of strings to represent the ingredients in a recipe.
    Here are three examples:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write the following functions on ingredient lists:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`recipes-uses`, which takes an ingredient list and an ingredient and determines
    whether the recipe uses the ingredient.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`make-vegetarian`, which takes an ingredient list and replaces all meat ingredients
    with `"tofu"`. Meat ingredients are `"pork"`, `"chicken"`, and `"beef"`.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`protein-veg-count`, which takes an ingredient list and determines how many
    ingredients are in the list that aren‚Äôt `"rice"` or `"noodles"`.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'More challenging: Write a function that takes an ingredient and a list of ingredient
    lists and produces a list of all the lists that contain the given ingredient.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hint: write examples first to make sense of the problem as needed.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Even more challenging: Try to write a function that takes two ingredient lists
    and returns all of the ingredients that are common to both lists. What issue(s)
    or limitations do you run into?'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Come back to this problem after you finish the next section.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5.1.4.1¬†Built-In Operations on Lists of Numbers[üîó](#(part._.Built-.In_.Operations_on_.Lists_of_.Numbers)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Pyret handily provides a useful set of operations we can already perform on
    lists. The [lists documentation](https://www.pyret.org/docs/latest/lists.html)
    describes these operations. As you might have guessed, we can already compute
    most of the answers we‚Äôve asked for at the start of the chapter. First we need
    to include some libraries that contain useful functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then access several useful functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `M.` notation means "the function inside the library `M`. The `import` statement
    in the above code gave the name `M` to the `math` library.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4.2¬†Built-In Operations on Lists in General[üîó](#(part._.Built-.In_.Operations_on_.Lists_in_.General)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Some of the useful computations in our list at the start of the chapter involved
    the `discount` column, which contains strings rather than numbers. Specifically,
    let‚Äôs consider the following question:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute the collection of unique discount codes that were used (many might have
    been available).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'None of the table functions handle a question like this. However, this is a
    common kind of question to ask about a collection of values (How many unique artists
    are in your playlist? How many unique faculty are teaching courses?). As such,
    Pyret (as most languages) provides a way to identify the unique elements of a
    list. Here‚Äôs how we get the list of all discount codes that were used in our table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `distinct` function produces a list of the unique values from the input
    list: every value in the input list appears exactly once in the output list. For
    the above code, Pyret produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: What if we wanted to exclude `"none"` from that list? After all, `"none"` isn‚Äôt
    an actual discount code, but rather one that we introduced while cleaning up the
    table. Is there a way to easily remove `"none"` from the list?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways we could do it. In the Pyret lists documentation, we find
    a function called `remove`, which removes a specific element from a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'But this operation should also sound familiar: with tables, we used `filter-with`
    to keep only those elements that meet a specific criterion. The filtering idea
    is so common that Pyret (and most other languages) provide a similar operation
    on lists. In the case of the discount codes, we could also have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between these two approaches is that `filter` is more flexible:
    we can check any characteristic of a list element using `filter`, but `remove`
    only checks whether the entire element is equal to the value that we provide.
    If instead of removing the specific string `"none"`, we had wanted to remove all
    strings that were in all-lowercase, we would have needed to use `filter`.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write a function that takes a list of words and removes those words in which
    all letters are in lowercase. (Hint: combine `string-to-lower` and `==`).'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5.1.4.3¬†An Aside on Naming Conventions[üîó](#(part._.An_.Aside_on_.Naming_.Conventions)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Our use of the plural `codes` for the list of values in the column named `discount`
    (singular) is deliberate. A list contains multiple values, so a plural is appropriate.
    In a table, in contrast, we think of a column header as naming a single value
    that appears in a specific row. Often, we speak of looking up a value in a specific
    row and column: the singular name for the column supports thinking about lookup
    in an individual row.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4.4¬†Getting Elements By Position[üîó](#(part._.Getting_.Elements_.By_.Position)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let‚Äôs look at a new analysis question: the events company recently ran an advertising
    campaign on `web.com`, and they are curious whether it paid off. To do this, they
    need to determine how many sales were made to people with `web.com` email addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a task plan ([Task Plans](processing-tables.html#%28part._task-plans%29))
    for this computation.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here‚Äôs a proposed plan, annotated with how we might implement each part:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the list of email addresses (use `get-column`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract those that came from `web.com` (use `L.filter`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Count how many email addresses remain (using `L.length`, which we hadn‚Äôt discussed
    yet, but it is in the documentation)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (As a reminder, unless you immediately see how to solve a problem, write out
    a task plan and annotate the parts you know how to do. It helps break down a programming
    problem into more manageable parts.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs discuss the second task: identifying messages from `web.com`. We know
    that email addresses are strings, so if we could determine whether an email string
    ends in `@web.com`, we‚Äôd be set. You could consider doing this by looking at the
    last 7 characters of the email string. Another option is to use a string operation
    that we haven‚Äôt yet seen called `string-split-all`, which splits a string into
    a list of substrings around a given character. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This seems pretty useful. If we split each email string around the `@` sign,
    then we can check whether the second string in the list is `web.com` (since email
    addresses should have only one `@` sign). But how would we get the second element
    out of the list produced by `string-split-all`? Here we dig into the list, as
    we did to extract rows from tables, this time using the `get` operation.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do we use `1` as the input to `get` if we want the second item in the list?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here‚Äôs the complete program for doing this check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if there is a malformed email address string that doesn‚Äôt contain
    the `@` string? What would happen? What could you do about that?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5.1.4.5¬†Transforming Lists[üîó](#(part._.Transforming_.Lists) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Imagine now that we had a list of email addresses, but instead just wanted a
    list of usernames. This doesn‚Äôt make sense for our event data, but it does make
    sense in other contexts (such as connecting messages to folders organized by students‚Äô
    usernames).
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifcally, we want to start with a list of addresses such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: and convert it to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider the list functions we have seen so far (`distinct`, `filter`, `length`)
    ‚Äì are any of them useful for this task? Can you articulate why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: One way to articulate a precise answer to this is think in terms of the inputs
    and outputs of the existing functions. Both `filter` and `distinct` return a list
    of elements from the input list, not transformed elements. `length` returns a
    number, not a list. So none of these are appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'This idea of transforming elements is similar to the `transform-column` operation
    that we previously saw on tables. The corresponding operation on lists is called
    `map`. Here‚Äôs an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '5.1.4.6¬†Recap: Summary of List Operations[üîó](#(part._lists-recap) "Link to
    here")'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At this point, we have seen several useful built-in functions for working with
    lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter :: (A -> Boolean), List<A> -> List<A>`, which produces a list of elements
    from the input list on which the given function returns `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map :: (A -> B), List<A> -> List<B>`, which produces a list of the results
    of calling the given function on each element of the input list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`distinct :: List<A> -> List<A>`, which produces a list of the unique elements
    that appear in the input list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length :: List<A> -> Number`, which produces the number of elements in the
    input list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, a type such as `List<A>` says that we have a list whose elements are of
    some (unspecified) type which we‚Äôll call `A`. A type variable such as this is
    useful when we want to show relationships between two types in a function contract.
    Here, the type variable `A` captures that the type of elements is the same in
    the input and output to `filter`. In `map`, however, the type of element in the
    output list could differ from that in the input list.
  prefs: []
  type: TYPE_NORMAL
- en: 'One additional built-in function that is quite useful in practice is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`member :: List<A>, Any -> Boolean`, which determines whether the given element
    is in the list. We use the type `Any` when there are no constraints on the type
    of value provided to a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many useful computations can be performed by combining these operations.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Assume you used a list of strings to represent the ingredients in a recipe.
    Here are three examples:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write the following functions on ingredient lists:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`recipes-uses`, which takes an ingredient list and an ingredient and determines
    whether the recipe uses the ingredient.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`make-vegetarian`, which takes an ingredient list and replaces all meat ingredients
    with `"tofu"`. Meat ingredients are `"pork"`, `"chicken"`, and `"beef"`.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`protein-veg-count`, which takes an ingredient list and determines how many
    ingredients are in the list that aren‚Äôt `"rice"` or `"noodles"`.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'More challenging: Write a function that takes an ingredient and a list of ingredient
    lists and produces a list of all the lists that contain the given ingredient.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hint: write examples first to make sense of the problem as needed.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Even more challenging: Try to write a function that takes two ingredient lists
    and returns all of the ingredients that are common to both lists. What issue(s)
    or limitations do you run into?'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Come back to this problem after you finish the next section.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '5.1.5¬†Lambda: Anonymous Functions[üîó](#(part._.Lambda__.Anonymous_.Functions)
    "Link to here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'NOTE: if you already saw `lam` in [Lambda: Anonymous Functions](intro-tabular-data.html#%28part._sec~3alambda-tables%29),
    feel free to skip this section, or just do the exercises at the end. Here we present
    `lam` using lists and `filter`, rather than tables and `filter-with`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs revisit the program we wrote earlier in this chapter for finding all
    of the discount codes that were used in the events table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This program might feel a bit verbose: do we really need to write a helper
    function just to perform something as simple as a `filter`? Wouldn‚Äôt it be easier
    to just write something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will Pyret produce if you run this expression?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pyret will produce an `unbound identifier` error around the use of `c` in this
    expression. What is `c`? We mean for `c` to be the elements from `codes` in turn.
    Conceptually, that‚Äôs what `filter` does, but we don‚Äôt have the mechanics right.
    When we call a function, we evaluate the arguments before the body of the function.
    Hence, the error regarding `c` being unbound. The whole point of the `real-code`
    helper function is to make `c` a parameter to a function whose body is only evaluated
    once a value for `c` is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tighten the notation as in the one-line `filter` expression, then, we have
    to find a way to tell Pyret to make a temporary function that will get its inputs
    once `filter` is running. The following notation achieves this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We have added `lam(c)` and `end` around the expression that we want to use in
    the `filter`. The `lam(c)` says "make a temporary function that takes `c` as an
    input". The `end` serves to end the function definition, as when we use `fun`.
    `lam` is short for `lambda`, a form of function definition that exists in many,
    though not all, languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference between our original expression (using the `real-code`
    helper) and this new one (using `lam`) can be seen through the program directory.
    To explain this, a little detail about how `filter` is defined under the hood.
    In part, it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Whether we pass `real-code` or the `lam` version to `filter`, the `keep` parameter
    ends up referring to a function with the same parameter and body. Since the function
    is only actually called through the `keep` name, it doesn‚Äôt matter whether or
    not a name is associated with it when it is initially defined.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, we use `lam` when we have to pass simple (single line) functions
    to operations like `filter` (or `map`). We could have just as easily used them
    when we were working with tables (`build-column`, `filter-with`, etc). Of course,
    you can continue to write out names for helper functions as we did with `real-code`
    if that makes more sense to you.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the program to extract the list of usernames from a list of email addresses
    using `lam` rather than a named helper-function.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Try again to tackle the problem from the end of the previous section: write
    a function that takes two ingredient lists and returns all of the ingredients
    that are common to both lists.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5.1.6¬†Combining Lists and Tables[üîó](#(part._.Combining_.Lists_and_.Tables) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The table functions we studied previously were primarily for processing rows.
    The list functions we‚Äôve learned in this chapter have been primarily for processing
    columns (but there are many more uses in the chapters ahead). If an analysis involves
    working with only some rows and some columns, we‚Äôll use a combination of both
    table and list functions in our program.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the events table, produce a list of names of all people who will pick
    up their tickets.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the events table, produce the average number of tickets that were ordered
    by people with email addresses that end in `".org"`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Sometimes, there will be more than one way to perform a computation:'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider a question such as "how many people with `".org"` email addresses bought
    more than 8 tickets". Propose multiple task plans that would solve this problem,
    including which table and list functions would accomplish each task.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There are several options here:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the `event-data` rows with no more than 8 tickets (using `filter-with`),
    get those rows that have `".org"` addresses (another `filter-with`), then ask
    for how many rows are in the table (using `<table>.length()`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the `event-data` rows with no more than 8 tickets and `".org"` address (using
    `filter-with` with a function that checks both conditions at once), then ask for
    how many rows are in the table (using `<table>.length()`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the `event-data` rows with no more than 8 tickets (using `filter-with`),
    extract the email addresses (using `get-column`), limit those to `".org"` (using
    `L.filter`), then get the length of the resulting list (using `L.length`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are others, but you get the idea.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which approach do you like best? Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'While there is no single correct answer, there are various considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: Are any of the intermediate results useful for other computations? While the
    second option might seem best because it filters the table once rather than twice,
    perhaps the events company has many computations to perform on larger ticket orders.
    Similarly, the company may want the list of email addresses on large orders for
    other purposes (the third option)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you want to follow a discipline of doing operations on individuals within
    the table, extracting lists only when needed to perform aggregating computations
    that aren‚Äôt available on tables?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Does one approach seem less resource-intensive than the other? This is actually
    a subtle point: you might be tempted to think that filtering over a table uses
    more resources than filtering over a list of values from one column, but this
    actually isn‚Äôt the case. We‚Äôll return to this discussion later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A company or project team sometimes sets design standards to help you make those
    decisions. In the absence of that, and especially as you are learning to program,
    consider multiple approaches when faced with such problems, then pick one to implement.
    Maintaining the ability to think flexibly about approaches is a useful skill in
    any form of design.
  prefs: []
  type: TYPE_NORMAL
- en: Until now we‚Äôve only seen how to use built-in functions over lists. Next [[Processing
    Lists](processing-lists.html)], we will study how to create our own functions
    that process lists. Once we learn that, these list processing functions will remain
    powerful but will no longer seem quite so magical, because we‚Äôll be able to build
    them for ourselves!
  prefs: []
  type: TYPE_NORMAL
