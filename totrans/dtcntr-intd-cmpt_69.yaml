- en: 24Â StagingğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 24Â é¢„æ¼”ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/staging.html](https://dcic-world.org/2025-08-27/staging.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/staging.html](https://dcic-world.org/2025-08-27/staging.html)
- en: '| Â Â Â Â [24.1Â Problem Definition](#%28part._.Problem_.Definition%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [24.1Â é—®é¢˜å®šä¹‰](#%28part._.Problem_.Definition%29) |'
- en: '| Â Â Â Â [24.2Â Initial Solution](#%28part._.Initial_.Solution%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [24.2Â åˆå§‹è§£å†³æ–¹æ¡ˆ](#%28part._.Initial_.Solution%29) |'
- en: '| Â Â Â Â [24.3Â Refactoring](#%28part._.Refactoring%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [24.3Â é‡æ„](#%28part._.Refactoring%29) |'
- en: '| Â Â Â Â [24.4Â Separating Parameters](#%28part._.Separating_.Parameters%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [24.4Â åˆ†ç¦»å‚æ•°](#%28part._.Separating_.Parameters%29) |'
- en: '| Â Â Â Â [24.5Â Context](#%28part._.Context%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [24.5Â ä¸Šä¸‹æ–‡](#%28part._.Context%29) |'
- en: 24.1Â Problem Definition[ğŸ”—](#(part._.Problem_.Definition) "Link to here")
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.1Â é—®é¢˜å®šä¹‰[ğŸ”—](#(part._.Problem_.Definition) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Earlier, we saw a detailed development of binary trees representing ancestry
    [[Creating a Datatype for Ancestor Trees](trees.html#%28part._ancestor-tree%29)].
    In what follows we donâ€™t need a lot of detail, so we will give ourselves a simplified
    version of essentially the same data definition:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹å‰ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†è¡¨ç¤ºç¥–å…ˆçš„äºŒå‰æ ‘çš„è¯¦ç»†å‘å±• [[åˆ›å»ºç¥–å…ˆæ ‘çš„æ•°æ®ç±»å‹](trees.html#%28part._ancestor-tree%29)]ã€‚åœ¨æ¥ä¸‹æ¥çš„å†…å®¹ä¸­ï¼Œæˆ‘ä»¬ä¸éœ€è¦å¤ªå¤šç»†èŠ‚ï¼Œå› æ­¤æˆ‘ä»¬å°†ç»™å‡ºä¸€ä¸ªæœ¬è´¨ä¸Šç›¸åŒçš„æ•°æ®å®šä¹‰çš„ç®€åŒ–ç‰ˆæœ¬ï¼š
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can then write functions over such as this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™å¦‚ä¸‹å‡½æ•°ï¼š
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now letâ€™s think about a slightly different function: `how-many-named`, which
    tells us how many people in a family have a particular name. Not only can more
    than one person have the same name, in some cultures itâ€™s not uncommon to use
    the same name across generations, either in successive generations or skipping
    one.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ªç¨å¾®ä¸åŒçš„å‡½æ•°ï¼š`how-many-named`ï¼Œå®ƒå‘Šè¯‰æˆ‘ä»¬ä¸€ä¸ªå®¶åº­ä¸­æœ‰å¤šå°‘äººæœ‰ä¸€ä¸ªç‰¹å®šçš„åå­—ã€‚ä¸ä»…å¯èƒ½æœ‰å¤šä¸ªäººæœ‰ç›¸åŒçš„åå­—ï¼Œåœ¨æŸäº›æ–‡åŒ–ä¸­ï¼Œè·¨ä»£ä½¿ç”¨ç›¸åŒçš„åå­—å¹¶ä¸ç½•è§ï¼Œæ— è®ºæ˜¯åœ¨è¿ç»­çš„å‡ ä»£äººä¹‹é—´è¿˜æ˜¯åœ¨è·³è¿‡ä¸€ä»£ã€‚
- en: Do Now!
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the contract for `how-many-named`? The contract for this function will
    be crucial, so make sure you do this step!
  id: totrans-15
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`how-many-named`çš„å¥‘çº¦æ˜¯ä»€ä¹ˆï¼Ÿè¿™ä¸ªå‡½æ•°çš„å¥‘çº¦å°†è‡³å…³é‡è¦ï¼Œæ‰€ä»¥è¯·ç¡®ä¿ä½ å®Œæˆè¿™ä¸€æ­¥ï¼'
- en: 'Here is one meaningful contract:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªæœ‰æ„ä¹‰çš„å¥‘çº¦ï¼š
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It takes a tree in which to search, a name to search for, and returns a count.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒéœ€è¦ä¸€ä¸ªæœç´¢çš„æ ‘ï¼Œä¸€ä¸ªè¦æœç´¢çš„åå­—ï¼Œå¹¶è¿”å›ä¸€ä¸ªè®¡æ•°ã€‚
- en: Do Now!
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define `how-many-named`.
  id: totrans-21
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®šä¹‰`how-many-named`ã€‚
- en: 24.2Â Initial Solution[ğŸ”—](#(part._.Initial_.Solution) "Link to here")
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.2Â åˆå§‹è§£å†³æ–¹æ¡ˆ[ğŸ”—](#(part._.Initial_.Solution) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Presumably you ended up with something like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: å¾ˆå¯èƒ½ä½ å¾—åˆ°äº†ç±»ä¼¼è¿™æ ·çš„ç»“æœï¼š
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Letâ€™s say you have defined this person:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾ä½ å·²ç»å®šä¹‰äº†è¿™ä¸ªäººï¼š
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With that, we can write a test like
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™ä¸€ä¸ªæµ‹è¯•ï¼Œä¾‹å¦‚
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 24.3Â Refactoring[ğŸ”—](#(part._.Refactoring) "Link to here")
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.3Â é‡æ„[ğŸ”—](#(part._.Refactoring) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Now letâ€™s apply some transformations, sometimes called code refactorings, to
    this function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬å¯¹è¿™ä¸ªå‡½æ•°åº”ç”¨ä¸€äº›è½¬æ¢ï¼Œæœ‰æ—¶ç§°ä¸ºä»£ç é‡æ„ã€‚
- en: First, notice the repeated expression. What the whole conditional is essentially
    saying is that we want to know how much this person is contributing to the overall
    count; the rest of the count stays the same regardless.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæ³¨æ„é‡å¤çš„è¡¨è¾¾å¼ã€‚æ•´ä¸ªæ¡ä»¶å®é™…ä¸Šæ˜¯åœ¨è¯´ï¼Œæˆ‘ä»¬æƒ³çŸ¥é“è¿™ä¸ªäººå¯¹æ•´ä½“è®¡æ•°è´¡çŒ®äº†å¤šå°‘ï¼›å…¶ä½™çš„è®¡æ•°ä¿æŒä¸å˜ã€‚
- en: 'One way to make this more explicit is to (perhaps surprisingly) rewrite the
    `else` to make explicit that a person with a different name contributes `0` to
    the count:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ç§ä½¿è¿™æ›´æ˜ç¡®çš„æ–¹æ³•æ˜¯ï¼ˆå¯èƒ½ä»¤äººæƒŠè®¶åœ°ï¼‰å°†`else`é‡å†™ä¸ºæ˜ç¡®æŒ‡å‡ºå…·æœ‰ä¸åŒåå­—çš„äººå¯¹è®¡æ•°è´¡çŒ®`0`ï¼š
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The reason for this somewhat odd rewrite is that it makes clear what is common
    and what is different. What is common is looking in the two parents. What changes
    is how much this person contributes, and only that depends on the conditional.
    We can therefore express this more concisely (and, if we know how to read such
    code, more meaningfully) as the following instead:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§æœ‰äº›å¥‡æ€ªçš„é‡æ–°ç¼–å†™çš„åŸå› æ˜¯å®ƒæ¸…æ¥šåœ°è¯´æ˜äº†ä»€ä¹ˆæ˜¯å…±åŒçš„ï¼Œä»€ä¹ˆæ˜¯ä¸åŒçš„ã€‚å…±åŒçš„æ˜¯åœ¨ä¸¤ä¸ªçˆ¶èŠ‚ç‚¹ä¸­æŸ¥æ‰¾ã€‚å˜åŒ–çš„æ˜¯è¿™ä¸ªäººè´¡çŒ®äº†å¤šå°‘ï¼Œè€Œä¸”åªæœ‰è¿™ä¸€ç‚¹å–å†³äºæ¡ä»¶ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥æ›´ç®€æ´åœ°ï¼ˆå¦‚æœæˆ‘ä»¬çŸ¥é“å¦‚ä½•é˜…è¯»è¿™æ ·çš„ä»£ç ï¼Œåˆ™æ›´æœ‰æ„ä¹‰ï¼‰ç”¨ä»¥ä¸‹æ–¹å¼è¡¨è¾¾ï¼š
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you have prior programming experience, this may look a bit odd to you, but
    `if` is in fact an expression, which has a value; in this case the value is either
    `0` or `1`. This value can then be used in an addition.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æœ‰è¿‡ç¼–ç¨‹ç»éªŒï¼Œè¿™å¯èƒ½ä¼šè®©ä½ è§‰å¾—æœ‰ç‚¹å¥‡æ€ªï¼Œä½†`if`å®é™…ä¸Šæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒæœ‰ä¸€ä¸ªå€¼ï¼›åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå€¼æ˜¯`0`æˆ–`1`ã€‚ç„¶åè¿™ä¸ªå€¼å¯ä»¥ç”¨äºåŠ æ³•ã€‚
- en: 'Now letâ€™s look at this code even more closely. Notice something interesting.
    We keep passing two parameters to `how-many-named`; however, only one of those
    parameters (`p`) is actually changing. The name we are looking for does not change,
    as we would expect: we are looking for the same name in the entire tree. How can
    we reflect this in the code?'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ›´ä»”ç»†åœ°çœ‹çœ‹è¿™æ®µä»£ç ã€‚æ³¨æ„ä¸€äº›æœ‰è¶£çš„äº‹æƒ…ã€‚æˆ‘ä»¬ä¸€ç›´åœ¨å‘ `how-many-named` ä¼ é€’ä¸¤ä¸ªå‚æ•°ï¼›ç„¶è€Œï¼Œå…¶ä¸­åªæœ‰ä¸€ä¸ªå‚æ•°ï¼ˆ`p`ï¼‰å®é™…ä¸Šåœ¨å˜åŒ–ã€‚æˆ‘ä»¬æ­£åœ¨å¯»æ‰¾çš„åç§°æ²¡æœ‰æ”¹å˜ï¼Œæ­£å¦‚æˆ‘ä»¬æ‰€æœŸæœ›çš„é‚£æ ·ï¼šæˆ‘ä»¬åœ¨æ•´ä¸ªæ ‘ä¸­å¯»æ‰¾ç›¸åŒçš„åç§°ã€‚æˆ‘ä»¬å¦‚ä½•åœ¨ä»£ç ä¸­åæ˜ è¿™ä¸€ç‚¹ï¼Ÿ
- en: 'First, weâ€™ll do something that looks a little useless, but itâ€™s also an innocent
    change, so it shouldnâ€™t irk us too much: weâ€™ll change the order of the arguments.
    That is, our contract changes from'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬å°†åšä¸€äº›çœ‹ä¼¼æ— ç”¨çš„æ“ä½œï¼Œä½†è¿™ä¹Ÿæ˜¯ä¸€ä¸ªæ— è¾œçš„æ”¹å˜ï¼Œæ‰€ä»¥å®ƒä¸åº”è¯¥è®©æˆ‘ä»¬å¤ªçƒ¦æ¼ï¼šæˆ‘ä»¬å°†æ”¹å˜å‚æ•°çš„é¡ºåºã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬çš„å¥‘çº¦ä»
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: to
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: to
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: so the function correspondingly changes to
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œå‡½æ•°ç›¸åº”åœ°å˜ä¸º
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What we have now done is put the â€œconstantâ€ argument first, and the â€œvaryingâ€
    argument second.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨æ‰€åšçš„æ˜¯å°†â€œå¸¸æ•°â€å‚æ•°æ”¾åœ¨ç¬¬ä¸€ä½ï¼Œå°†â€œå˜åŒ–â€å‚æ•°æ”¾åœ¨ç¬¬äºŒä½ã€‚
- en: Do Now!
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try this and make sure it works!
  id: totrans-47
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°è¯•è¿™ä¸ªæ–¹æ³•å¹¶ç¡®ä¿å®ƒå·¥ä½œï¼
- en: 'It doesnâ€™t! We have to change more than just the function header: we have to
    also change how itâ€™s called. Keep in mind itâ€™s called twice within the function
    body itself, and also from the examples. Therefore, the function as a whole reads:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒæ²¡æœ‰ï¼æˆ‘ä»¬å¿…é¡»æ”¹å˜ä¸ä»…ä»…æ˜¯å‡½æ•°å¤´ï¼šæˆ‘ä»¬è¿˜éœ€è¦æ”¹å˜å®ƒçš„è°ƒç”¨æ–¹å¼ã€‚è®°ä½ï¼Œå®ƒåœ¨å‡½æ•°ä½“å†…éƒ¨è¢«è°ƒç”¨äº†ä¸¤æ¬¡ï¼Œå¹¶ä¸”ä¹Ÿä»ç¤ºä¾‹ä¸­è°ƒç”¨ã€‚å› æ­¤ï¼Œæ•´ä¸ªå‡½æ•°çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: and the example reads `how-many-named("A", p)` instead.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¶ä¸”ç¤ºä¾‹ä¸­è¯»å–çš„æ˜¯ `how-many-named("A", p)` è€Œä¸æ˜¯ã€‚
- en: 24.4Â Separating Parameters[ğŸ”—](#(part._.Separating_.Parameters) "Link to here")
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.4 åˆ†ç¦»å‚æ•°[ğŸ”—](#(part._.Separating_.Parameters) "é“¾æ¥è‡³æ­¤")
- en: 'This sets us up for the next stage. The parameters of functions are meant to
    indicate what might vary in a function. Because the name weâ€™re looking for is
    a constant once we initially have it, weâ€™d like the actual search function to
    take only one argument: where in the tree weâ€™re searching.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ºæˆ‘ä»¬è®¾ç½®äº†ä¸‹ä¸€é˜¶æ®µã€‚å‡½æ•°çš„å‚æ•°æ—¨åœ¨è¡¨ç¤ºå‡½æ•°ä¸­å¯èƒ½å‘ç”Ÿå˜åŒ–çš„å†…å®¹ã€‚å› ä¸ºä¸€æ—¦æˆ‘ä»¬æœ€åˆå¾—åˆ°è¦å¯»æ‰¾çš„åç§°ï¼Œè¯¥åç§°å°±æ˜¯ä¸€ä¸ªå¸¸æ•°ï¼Œæˆ‘ä»¬å¸Œæœ›å®é™…çš„æœç´¢å‡½æ•°åªæ¥å—ä¸€ä¸ªå‚æ•°ï¼šæˆ‘ä»¬åœ¨æ ‘ä¸­çš„æœç´¢ä½ç½®ã€‚
- en: That is, we want the search functionâ€™s contract to be `(ABT -> Number)`. To
    achieve that, we need another function that will take the `String` part. Thus,
    the contract has to become
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: å³ï¼Œæˆ‘ä»¬å¸Œæœ›æœç´¢å‡½æ•°çš„å¥‘çº¦æ˜¯ `(ABT -> Number)`ã€‚ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦å¦ä¸€ä¸ªå‡½æ•°æ¥æ¥å— `String` éƒ¨åˆ†ã€‚å› æ­¤ï¼Œå¥‘çº¦å¿…é¡»å˜ä¸º
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: where `how-many-named` consumes a name and returns a function that will consume
    the actual tree to check.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ `how-many-named` æ¶ˆè€—ä¸€ä¸ªåç§°å¹¶è¿”å›ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°å°†æ¶ˆè€—å®é™…çš„æ ‘ä»¥è¿›è¡Œæ£€æŸ¥ã€‚
- en: 'This suggests the following function body:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è¡¨æ˜ä»¥ä¸‹å‡½æ•°ä½“ï¼š
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, this function body is not okay: the Pyret type-checker will give us
    type errors. Thatâ€™s because `how-many-named` takes one parameter, not two, as
    in the two recursive calls.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¿™ä¸ªå‡½æ•°ä½“æ˜¯ä¸æ­£ç¡®çš„ï¼šPyret ç±»å‹æ£€æŸ¥å™¨ä¼šç»™æˆ‘ä»¬ç±»å‹é”™è¯¯ã€‚è¿™æ˜¯å› ä¸º `how-many-named` åªæ¥å—ä¸€ä¸ªå‚æ•°ï¼Œè€Œä¸æ˜¯ä¸¤ä¸ªï¼Œå°±åƒåœ¨ä¸¤ä¸ªé€’å½’è°ƒç”¨ä¸­é‚£æ ·ã€‚
- en: 'How do we fix this? Remember, the whole point of this change is we donâ€™t want
    to change the name, only the tree. That means we want to recur on the inner function.
    We currently canâ€™t do this because it doesnâ€™t have a name! So we have to give
    it a name and recur on it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜ï¼Ÿè®°ä½ï¼Œè¿™ä¸ªæ”¹å˜çš„æ•´ä¸ªç›®çš„æ˜¯æˆ‘ä»¬ä¸æƒ³æ”¹å˜åç§°ï¼Œåªæƒ³æ”¹å˜æ ‘ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬æƒ³è¦åœ¨å†…éƒ¨å‡½æ•°ä¸Šé€’å½’ã€‚æˆ‘ä»¬ç›®å‰æ— æ³•è¿™æ ·åšï¼Œå› ä¸ºå®ƒæ²¡æœ‰åå­—ï¼æ‰€ä»¥æˆ‘ä»¬å¿…é¡»ç»™å®ƒä¸€ä¸ªåå­—ï¼Œå¹¶åœ¨å®ƒä¸Šé¢é€’å½’ï¼š
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This now lets us recur on just the part that should vary, leaving the name weâ€™re
    looking for unchanged (and hence, fixed for the duration of the search).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç°åœ¨è®©æˆ‘ä»¬åªå¯¹åº”è¯¥å˜åŒ–çš„éƒ¨åˆ†è¿›è¡Œé€’å½’ï¼ŒåŒæ—¶ä¿æŒæˆ‘ä»¬è¦å¯»æ‰¾çš„åç§°ä¸å˜ï¼ˆå› æ­¤ï¼Œåœ¨æœç´¢æœŸé—´ä¿æŒå›ºå®šï¼‰ã€‚
- en: Do Now!
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try the above and make sure it works.
  id: totrans-64
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°è¯•ä¸Šé¢çš„æ–¹æ³•å¹¶ç¡®ä¿å®ƒå·¥ä½œã€‚
- en: 'It still doesnâ€™t: the above body has a syntax error! This is because `how-many-named`
    does not actually return any kind of value.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ä»ç„¶ä¸è¡Œï¼šä¸Šé¢çš„å‡½æ•°ä½“æœ‰ä¸€ä¸ªè¯­æ³•é”™è¯¯ï¼è¿™æ˜¯å› ä¸º `how-many-named` å®é™…ä¸Šæ²¡æœ‰è¿”å›ä»»ä½•ç±»å‹çš„å€¼ã€‚
- en: 'What should it return? Once we provide the function with a name, we should
    get back a function that searches for that name in a tree. But we already have
    exactly such a function: `search-in`. Therefore, `how-many-named` should return
    just â€¦ `search-in`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒåº”è¯¥è¿”å›ä»€ä¹ˆï¼Ÿä¸€æ—¦æˆ‘ä»¬å‘å‡½æ•°æä¾›ä¸€ä¸ªåç§°ï¼Œæˆ‘ä»¬åº”è¯¥å¾—åˆ°ä¸€ä¸ªåœ¨æ ‘ä¸­æœç´¢è¯¥åç§°çš„å‡½æ•°ã€‚ä½†æˆ‘ä»¬å·²ç»æœ‰äº†è¿™æ ·ä¸€ä¸ªå‡½æ•°ï¼š`search-in`ã€‚å› æ­¤ï¼Œ`how-many-named`
    åº”è¯¥åªè¿”å› â€¦ `search-in`ã€‚
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This still wonâ€™t work, because we havenâ€™t changed the example. Letâ€™s update
    that: how do we use `how-many-named`? We have to call it with a name (like `"A"`);
    this returns a functionâ€”<wbr>the one bound to `search-in`â€”<wbr>which expects a
    ancestor tree. Doing so should return a count. Thus, the example should be rewritten
    as'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä»ç„¶ä¸èµ·ä½œç”¨ï¼Œå› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰æ›´æ”¹ç¤ºä¾‹ã€‚è®©æˆ‘ä»¬æ›´æ–°ä¸€ä¸‹ï¼šæˆ‘ä»¬å¦‚ä½•ä½¿ç”¨ `how-many-named`ï¼Ÿæˆ‘ä»¬å¿…é¡»ç”¨åå­—ï¼ˆä¾‹å¦‚ `"A"`ï¼‰æ¥è°ƒç”¨å®ƒï¼›è¿™ä¼šè¿”å›ä¸€ä¸ªå‡½æ•°â€”â€”<wbr>ç»‘å®šåˆ°
    `search-in` çš„å‡½æ•°â€”â€”<wbr>å®ƒæœŸæœ›ä¸€ä¸ªç¥–å…ˆæ ‘ã€‚è¿™æ ·åšåº”è¯¥ä¼šè¿”å›ä¸€ä¸ªè®¡æ•°ã€‚å› æ­¤ï¼Œç¤ºä¾‹åº”è¯¥è¢«é‡å†™ä¸º
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is an instructive way to write the example. We can, however, also write
    it more concisely. Notice that `how-many-named("A")` returns a function, and the
    way we apply a function to arguments is `(â€¦)`. Thus, we can also write this as:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ç§ç¼–å†™ç¤ºä¾‹çš„æœ‰æ•™è‚²æ„ä¹‰çš„é€”å¾„ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æ›´ç®€æ´åœ°ç¼–å†™å®ƒã€‚æ³¨æ„ï¼Œ`how-many-named("A")` è¿”å›ä¸€ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬åº”ç”¨å‡½æ•°åˆ°å‚æ•°çš„æ–¹å¼æ˜¯
    `(â€¦)`ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è¿™æ ·å†™ï¼š
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 24.5Â Context[ğŸ”—](#(part._.Context) "Link to here")
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.5Â ä¸Šä¸‹æ–‡[ğŸ”—](#(part._.Context) "é“¾æ¥åˆ°æ­¤å¤„")
- en: The transformation we just applied is generally called currying, in honor of
    Haskell Curry, who was one of the early people to describe it, though it was earlier
    discovered by Moses SchÃ¶nfinkel and even earlier by Gottlob Frege. The particular
    use of currying here, where we move more â€œstaticâ€ arguments earlier and more â€œdynamicâ€
    ones later, and split on the static-dynamic divide, is called staging. Itâ€™s a
    very useful programming technique, and furthermore, one that enables some compilers
    to produce more time-efficient programs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åˆšæ‰åº”ç”¨çš„é‚£ç§è½¬æ¢é€šå¸¸è¢«ç§°ä¸ºæŸ¯é‡ŒåŒ–ï¼Œä»¥çºªå¿µ Haskell Curryï¼Œä»–æ˜¯æœ€æ—©æè¿°å®ƒçš„äººä¹‹ä¸€ï¼Œå°½ç®¡å®ƒæ˜¯ç”± Moses SchÃ¶nfinkel æ›´æ—©å‘ç°çš„ï¼Œç”šè‡³æ›´æ—©ç”±
    Gottlob Frege å‘ç°ã€‚è¿™é‡ŒæŸ¯é‡ŒåŒ–çš„ç‰¹å®šç”¨é€”ï¼Œå³æˆ‘ä»¬æ›´æ—©åœ°å°†â€œé™æ€â€å‚æ•°ç§»åŠ¨ï¼Œæ›´æ™šåœ°å°†â€œåŠ¨æ€â€å‚æ•°ç§»åŠ¨ï¼Œå¹¶åœ¨é™æ€-åŠ¨æ€åˆ’åˆ†ä¸Šæ‹†åˆ†ï¼Œè¢«ç§°ä¸ºåˆ†é˜¶æ®µã€‚è¿™æ˜¯ä¸€ç§éå¸¸æœ‰ç”¨çš„ç¼–ç¨‹æŠ€æœ¯ï¼Œè€Œä¸”æ›´é‡è¦çš„æ˜¯ï¼Œå®ƒä½¿ä¸€äº›ç¼–è¯‘å™¨èƒ½å¤Ÿç”Ÿæˆæ›´é«˜æ•ˆçš„ç¨‹åºã€‚
- en: 'Even more subtly but importantly, the staged computation tells a different
    story than the unstaged one, and we can read this off just from the contract:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´åŠ å¾®å¦™ä½†é‡è¦çš„æ˜¯ï¼Œåˆ†é˜¶æ®µè®¡ç®—ä¸æœªåˆ†é˜¶æ®µè®¡ç®—è®²è¿°çš„æ•…äº‹ä¸åŒï¼Œæˆ‘ä»¬å¯ä»¥ä»…ä»å¥‘çº¦ä¸­è¯»å‡ºè¿™ä¸€ç‚¹ï¼š
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first one says the string could co-vary with the person. The second one
    rules out that interpretation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªè¯´å­—ç¬¦ä¸²å¯èƒ½ä¸ä¸ªäººå…±åŒå˜åŒ–ã€‚ç¬¬äºŒä¸ªæ’é™¤äº†è¿™ç§è§£é‡Šã€‚
- en: Do Now!
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is the former useful? When might we have the name also changing?
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‰è€…æœ‰ç”¨å—ï¼Ÿæˆ‘ä»¬ä»€ä¹ˆæ—¶å€™ä¼šæœ‰åå­—ä¹Ÿå˜åŒ–çš„æƒ…å†µï¼Ÿ
- en: 'Imagine a slightly different problem: we want to know how often a child has
    the same name as a parent. Then, as we traverse the tree, as the name of the person
    (potentially) keeps changing, the name weâ€™re looking for in the parent also changes.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡ä¸€ä¸ªç¨å¾®ä¸åŒçš„é—®é¢˜ï¼šæˆ‘ä»¬æƒ³çŸ¥é“ä¸€ä¸ªå­©å­æœ‰å¤šå°‘æ¬¡ä¸çˆ¶æ¯æœ‰ç›¸åŒçš„åå­—ã€‚ç„¶åï¼Œå½“æˆ‘ä»¬éå†æ ‘æ—¶ï¼Œéšç€äººçš„åå­—ï¼ˆå¯èƒ½ï¼‰ä¸æ–­å˜åŒ–ï¼Œæˆ‘ä»¬åœ¨çˆ¶æ¯ä¸­å¯»æ‰¾çš„åå­—ä¹Ÿå‘ç”Ÿäº†å˜åŒ–ã€‚
- en: Exercise
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write this function.
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™è¿™ä¸ªå‡½æ•°ã€‚
- en: In contrast, the staged type rules out that interpretation and that behavior.
    In that way, it sends a signal to the reader about how the computation might behave
    just from the type. In the same way, the unstaged type can be read as giving the
    reader a hint that the behavior could depend on both parameters changing, therefore
    accommodating a much broader range of behaviors (e.g., checking for parent-child
    or grandparent-child name reuse).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åï¼Œåˆ†é˜¶æ®µç±»å‹æ’é™¤äº†è¿™ç§è§£é‡Šå’Œè¿™ç§è¡Œä¸ºã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œå®ƒå‘è¯»è€…å‘å‡ºä¿¡å·ï¼Œè¯´æ˜è®¡ç®—å¯èƒ½çš„è¡Œä¸ºä»…ä»ç±»å‹ä¸­å°±å¯ä»¥çœ‹å‡ºã€‚åŒæ ·ï¼Œæœªåˆ†é˜¶æ®µç±»å‹å¯ä»¥è¢«è§£è¯»ä¸ºç»™è¯»è€…ä¸€ä¸ªæš—ç¤ºï¼Œè¯´æ˜è¡Œä¸ºå¯èƒ½å–å†³äºä¸¤ä¸ªå‚æ•°çš„å˜åŒ–ï¼Œå› æ­¤å¯ä»¥å®¹çº³æ›´å¹¿æ³›çš„è¡Œä¸ºèŒƒå›´ï¼ˆä¾‹å¦‚ï¼Œæ£€æŸ¥çˆ¶æ¯-å­©å­æˆ–ç¥–çˆ¶æ¯-å­©å­åå­—çš„é‡ç”¨ï¼‰ã€‚
- en: 'Thereâ€™s another very nice example of staging here: [A Little Calculus](func-as-data.html#%28part._fd-calculus%29).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªåˆ†é˜¶æ®µçš„å¥½ä¾‹å­ï¼š[ä¸€ç‚¹å¾®ç§¯åˆ†](func-as-data.html#%28part._fd-calculus%29)ã€‚
- en: 'Finally, itâ€™s worth knowing that some languages, like Haskell and OCaml, do
    this transformation automatically. In fact, they donâ€™t even have multiple-parameter
    functions: what look like multiple arguments are actually a sequence of staged
    functions. This can, in extremis, lead to a very elegant and powerful programming
    style. Pyret chose to not do this because, while this is a powerful tool in the
    hands of advanced programmers, for less experienced programmers, finding out about
    a mismatch in the number of parameters and arguments is very useful.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä¸€äº›è¯­è¨€ï¼Œå¦‚ Haskell å’Œ OCamlï¼Œä¼šè‡ªåŠ¨è¿›è¡Œè¿™ç§è½¬æ¢ã€‚äº‹å®ä¸Šï¼Œå®ƒä»¬ç”šè‡³æ²¡æœ‰å¤šå‚æ•°å‡½æ•°ï¼šçœ‹èµ·æ¥åƒå¤šä¸ªå‚æ•°å®é™…ä¸Šæ˜¯ä¸€ç³»åˆ—åˆ†é˜¶æ®µå‡½æ•°ã€‚è¿™å¯ä»¥æç«¯åœ°å¯¼è‡´ä¸€ç§éå¸¸ä¼˜é›…ä¸”å¼ºå¤§çš„ç¼–ç¨‹é£æ ¼ã€‚Pyret
    é€‰æ‹©ä¸è¿™æ ·åšï¼Œå› ä¸ºè™½ç„¶è¿™å¯¹äºé«˜çº§ç¨‹åºå‘˜æ¥è¯´æ˜¯ä¸€ä¸ªå¼ºå¤§çš„å·¥å…·ï¼Œä½†å¯¹äºç»éªŒè¾ƒå°‘çš„ç¨‹åºå‘˜æ¥è¯´ï¼Œå‘ç°å‚æ•°æ•°é‡å’Œå‚æ•°ä¹‹é—´çš„ä¸åŒ¹é…æ˜¯éå¸¸æœ‰ç”¨çš„ã€‚
- en: 24.1Â Problem Definition[ğŸ”—](#(part._.Problem_.Definition) "Link to here")
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.1Â é—®é¢˜å®šä¹‰[ğŸ”—](#(part._.Problem_.Definition) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Earlier, we saw a detailed development of binary trees representing ancestry
    [[Creating a Datatype for Ancestor Trees](trees.html#%28part._ancestor-tree%29)].
    In what follows we donâ€™t need a lot of detail, so we will give ourselves a simplified
    version of essentially the same data definition:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹å‰ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†è¡¨ç¤ºç¥–å…ˆæ ‘çš„äºŒå‰æ ‘çš„è¯¦ç»†å¼€å‘ [[åˆ›å»ºç¥–å…ˆæ ‘çš„æ•°æ®ç±»å‹](trees.html#%28part._ancestor-tree%29)]ã€‚åœ¨æ¥ä¸‹æ¥çš„å†…å®¹ä¸­ï¼Œæˆ‘ä»¬ä¸éœ€è¦å¾ˆå¤šç»†èŠ‚ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†ç»™å‡ºä¸€ä¸ªæœ¬è´¨ä¸Šç›¸åŒçš„æ•°æ®å®šä¹‰çš„ç®€åŒ–ç‰ˆæœ¬ï¼š
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can then write functions over such as this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™è¿™æ ·çš„å‡½æ•°ï¼š
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now letâ€™s think about a slightly different function: `how-many-named`, which
    tells us how many people in a family have a particular name. Not only can more
    than one person have the same name, in some cultures itâ€™s not uncommon to use
    the same name across generations, either in successive generations or skipping
    one.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ªç¨å¾®ä¸åŒçš„å‡½æ•°ï¼š`how-many-named`ï¼Œå®ƒå‘Šè¯‰æˆ‘ä»¬ä¸€ä¸ªå®¶åº­ä¸­æœ‰å¤šå°‘äººæœ‰ä¸€ä¸ªç‰¹å®šçš„åå­—ã€‚ä¸ä»…å¯èƒ½æœ‰å¤šä¸ªäººæœ‰ç›¸åŒçš„åå­—ï¼Œåœ¨æŸäº›æ–‡åŒ–ä¸­ï¼Œè·¨ä»£ä½¿ç”¨ç›¸åŒçš„åå­—ä¹Ÿä¸ç½•è§ï¼Œæ— è®ºæ˜¯è¿ç»­å‡ ä»£è¿˜æ˜¯è·³è¿‡ä¸€ä»£ã€‚
- en: Do Now!
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the contract for `how-many-named`? The contract for this function will
    be crucial, so make sure you do this step!
  id: totrans-95
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`how-many-named`çš„åˆçº¦æ˜¯ä»€ä¹ˆï¼Ÿè¿™ä¸ªå‡½æ•°çš„åˆçº¦å°†è‡³å…³é‡è¦ï¼Œæ‰€ä»¥è¯·ç¡®ä¿ä½ å®Œæˆè¿™ä¸€æ­¥ï¼'
- en: 'Here is one meaningful contract:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªæœ‰æ„ä¹‰çš„åˆçº¦ï¼š
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It takes a tree in which to search, a name to search for, and returns a count.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒæ¥å—ä¸€ä¸ªè¦æœç´¢çš„æ ‘ï¼Œä¸€ä¸ªè¦æœç´¢çš„åç§°ï¼Œå¹¶è¿”å›ä¸€ä¸ªè®¡æ•°ã€‚
- en: Do Now!
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define `how-many-named`.
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®šä¹‰`how-many-named`ã€‚
- en: 24.2Â Initial Solution[ğŸ”—](#(part._.Initial_.Solution) "Link to here")
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.2Â åˆå§‹è§£å†³æ–¹æ¡ˆ[ğŸ”—](#(part._.Initial_.Solution) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Presumably you ended up with something like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: å¾ˆå¯èƒ½ä½ å¾—åˆ°äº†ç±»ä¼¼è¿™æ ·çš„ç»“æœï¼š
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Letâ€™s say you have defined this person:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾ä½ å®šä¹‰äº†è¿™ä¸ªäººç‰©ï¼š
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With that, we can write a test like
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰äº†è¿™ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™ä¸€ä¸ªæµ‹è¯•ï¼Œä¾‹å¦‚
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 24.3Â Refactoring[ğŸ”—](#(part._.Refactoring) "Link to here")
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.3Â é‡æ„[ğŸ”—](#(part._.Refactoring) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Now letâ€™s apply some transformations, sometimes called code refactorings, to
    this function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬åº”ç”¨ä¸€äº›å˜æ¢ï¼Œæœ‰æ—¶ç§°ä¸ºä»£ç é‡æ„ï¼Œå¯¹è¿™ä¸ªå‡½æ•°è¿›è¡Œå˜æ¢ã€‚
- en: First, notice the repeated expression. What the whole conditional is essentially
    saying is that we want to know how much this person is contributing to the overall
    count; the rest of the count stays the same regardless.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæ³¨æ„é‡å¤çš„è¡¨è¾¾å¼ã€‚æ•´ä¸ªæ¡ä»¶å®é™…ä¸Šæ˜¯åœ¨è¯´ï¼Œæˆ‘ä»¬æƒ³çŸ¥é“è¿™ä¸ªäººå¯¹æ•´ä½“è®¡æ•°çš„è´¡çŒ®æœ‰å¤šå°‘ï¼›å…¶ä½™çš„è®¡æ•°ä¿æŒä¸å˜ã€‚
- en: 'One way to make this more explicit is to (perhaps surprisingly) rewrite the
    `else` to make explicit that a person with a different name contributes `0` to
    the count:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ç§ä½¿è¿™æ›´æ˜ç¡®çš„æ–¹æ³•æ˜¯ï¼ˆå¯èƒ½ä»¤äººæƒŠè®¶åœ°ï¼‰å°†`else`é‡å†™ä¸ºæ˜ç¡®æŒ‡å‡ºå…·æœ‰ä¸åŒåç§°çš„äººå¯¹è®¡æ•°è´¡çŒ®`0`ï¼š
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The reason for this somewhat odd rewrite is that it makes clear what is common
    and what is different. What is common is looking in the two parents. What changes
    is how much this person contributes, and only that depends on the conditional.
    We can therefore express this more concisely (and, if we know how to read such
    code, more meaningfully) as the following instead:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§æœ‰äº›å¥‡æ€ªçš„é‡æ–°ç¼–å†™çš„åŸå› æ˜¯å®ƒæ¸…æ¥šåœ°è¯´æ˜äº†ä»€ä¹ˆæ˜¯å…±åŒçš„ï¼Œä»€ä¹ˆæ˜¯ä¸åŒçš„ã€‚å…±åŒçš„æ˜¯æŸ¥çœ‹ä¸¤ä¸ªçˆ¶èŠ‚ç‚¹ã€‚å˜åŒ–çš„æ˜¯è¿™ä¸ªäººå¯¹è´¡çŒ®çš„å¤šå°‘ï¼Œè€Œä¸”åªæœ‰è¿™ä¸€ç‚¹å–å†³äºæ¡ä»¶ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥æ›´ç®€æ´åœ°ï¼ˆå¦‚æœæˆ‘ä»¬çŸ¥é“å¦‚ä½•é˜…è¯»è¿™æ ·çš„ä»£ç ï¼Œæ›´æœ‰æ„ä¹‰åœ°ï¼‰ç”¨ä»¥ä¸‹æ–¹å¼è¡¨è¾¾ï¼š
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you have prior programming experience, this may look a bit odd to you, but
    `if` is in fact an expression, which has a value; in this case the value is either
    `0` or `1`. This value can then be used in an addition.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æœ‰è¿‡ç¼–ç¨‹ç»éªŒï¼Œè¿™å¯èƒ½ä¼šè®©ä½ è§‰å¾—æœ‰ç‚¹å¥‡æ€ªï¼Œä½†`if`å®é™…ä¸Šæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒæœ‰ä¸€ä¸ªå€¼ï¼›åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿™ä¸ªå€¼æ˜¯`0`æˆ–`1`ã€‚è¿™ä¸ªå€¼ç„¶åå¯ä»¥ç”¨äºåŠ æ³•ã€‚
- en: 'Now letâ€™s look at this code even more closely. Notice something interesting.
    We keep passing two parameters to `how-many-named`; however, only one of those
    parameters (`p`) is actually changing. The name we are looking for does not change,
    as we would expect: we are looking for the same name in the entire tree. How can
    we reflect this in the code?'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ›´ä»”ç»†åœ°çœ‹çœ‹è¿™æ®µä»£ç ã€‚æ³¨æ„ä¸€äº›æœ‰è¶£çš„äº‹æƒ…ã€‚æˆ‘ä»¬ä¸€ç›´åœ¨å‘`how-many-named`ä¼ é€’ä¸¤ä¸ªå‚æ•°ï¼›ç„¶è€Œï¼Œå…¶ä¸­åªæœ‰ä¸€ä¸ªå‚æ•°ï¼ˆ`p`ï¼‰å®é™…ä¸Šåœ¨å˜åŒ–ã€‚æˆ‘ä»¬æ­£åœ¨å¯»æ‰¾çš„åç§°æ²¡æœ‰å˜åŒ–ï¼Œæ­£å¦‚æˆ‘ä»¬æ‰€æœŸæœ›çš„ï¼šæˆ‘ä»¬åœ¨æ•´ä¸ªæ ‘ä¸­å¯»æ‰¾ç›¸åŒçš„åç§°ã€‚æˆ‘ä»¬å¦‚ä½•åœ¨ä»£ç ä¸­åæ˜ è¿™ä¸€ç‚¹ï¼Ÿ
- en: 'First, weâ€™ll do something that looks a little useless, but itâ€™s also an innocent
    change, so it shouldnâ€™t irk us too much: weâ€™ll change the order of the arguments.
    That is, our contract changes from'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬å°†åšä¸€äº›çœ‹ä¼¼æ— ç”¨çš„ä¸œè¥¿ï¼Œä½†è¿™ä¹Ÿæ˜¯ä¸€ä¸ªæ— è¾œçš„æ”¹å˜ï¼Œæ‰€ä»¥å®ƒä¸åº”è¯¥è®©æˆ‘ä»¬å¤ªçƒ¦æ¼ï¼šæˆ‘ä»¬å°†æ”¹å˜å‚æ•°çš„é¡ºåºã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬çš„åˆçº¦ä»
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: to
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: å˜ä¸º
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: so the function correspondingly changes to
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œå‡½æ•°ç›¸åº”åœ°å˜ä¸º
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: What we have now done is put the â€œconstantâ€ argument first, and the â€œvaryingâ€
    argument second.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨æ‰€åšçš„æ˜¯å°†â€œå¸¸æ•°â€å‚æ•°æ”¾åœ¨ç¬¬ä¸€ä½ï¼Œå°†â€œå˜åŒ–â€å‚æ•°æ”¾åœ¨ç¬¬äºŒä½ã€‚
- en: Do Now!
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try this and make sure it works!
  id: totrans-127
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°è¯•è¿™ä¸ªï¼Œç¡®ä¿å®ƒå·¥ä½œï¼
- en: 'It doesnâ€™t! We have to change more than just the function header: we have to
    also change how itâ€™s called. Keep in mind itâ€™s called twice within the function
    body itself, and also from the examples. Therefore, the function as a whole reads:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒä»ç„¶ä¸è¡Œï¼æˆ‘ä»¬å¿…é¡»æ”¹å˜ä¸ä»…ä»…æ˜¯å‡½æ•°å¤´ï¼šæˆ‘ä»¬è¿˜è¦æ”¹å˜å®ƒçš„è°ƒç”¨æ–¹å¼ã€‚è®°ä½ï¼Œå®ƒåœ¨å‡½æ•°ä½“å†…éƒ¨è¢«è°ƒç”¨äº†ä¸¤æ¬¡ï¼Œä¹Ÿä»ä¾‹å­ä¸­è¢«è°ƒç”¨ã€‚å› æ­¤ï¼Œæ•´ä¸ªå‡½æ•°çš„è¯»æ³•å¦‚ä¸‹ï¼š
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: and the example reads `how-many-named("A", p)` instead.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¶ä¸”ä¾‹å­è¯»ä½œ`how-many-named("A", p)`ã€‚
- en: 24.4Â Separating Parameters[ğŸ”—](#(part._.Separating_.Parameters) "Link to here")
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.4 åˆ†ç¦»å‚æ•°[ğŸ”—](#(part._.Separating_.Parameters) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'This sets us up for the next stage. The parameters of functions are meant to
    indicate what might vary in a function. Because the name weâ€™re looking for is
    a constant once we initially have it, weâ€™d like the actual search function to
    take only one argument: where in the tree weâ€™re searching.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ºæˆ‘ä»¬è®¾ç½®äº†ä¸‹ä¸€é˜¶æ®µã€‚å‡½æ•°çš„å‚æ•°æ˜¯ç”¨æ¥æŒ‡ç¤ºå‡½æ•°ä¸­å¯èƒ½å˜åŒ–çš„å†…å®¹ã€‚å› ä¸ºæˆ‘ä»¬æ­£åœ¨å¯»æ‰¾çš„åç§°ä¸€æ—¦æˆ‘ä»¬æœ€åˆå¾—åˆ°å®ƒå°±æ˜¯ä¸€ä¸ªå¸¸æ•°ï¼Œæˆ‘ä»¬å¸Œæœ›å®é™…çš„æœç´¢å‡½æ•°åªæ¥å—ä¸€ä¸ªå‚æ•°ï¼šæˆ‘ä»¬åœ¨æ ‘ä¸­çš„æœç´¢ä½ç½®ã€‚
- en: That is, we want the search functionâ€™s contract to be `(ABT -> Number)`. To
    achieve that, we need another function that will take the `String` part. Thus,
    the contract has to become
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: å³ï¼Œæˆ‘ä»¬å¸Œæœ›æœç´¢å‡½æ•°çš„åˆçº¦æ˜¯`(ABT -> Number)`ã€‚ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦å¦ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒå°†æ¥å—`String`éƒ¨åˆ†ã€‚å› æ­¤ï¼Œåˆçº¦å¿…é¡»å˜ä¸º
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: where `how-many-named` consumes a name and returns a function that will consume
    the actual tree to check.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­`how-many-named`æ¶ˆè€—ä¸€ä¸ªåç§°å¹¶è¿”å›ä¸€ä¸ªå°†æ¶ˆè€—å®é™…æ ‘æ¥æ£€æŸ¥çš„å‡½æ•°ã€‚
- en: 'This suggests the following function body:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è¡¨æ˜ä»¥ä¸‹å‡½æ•°ä½“ï¼š
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'However, this function body is not okay: the Pyret type-checker will give us
    type errors. Thatâ€™s because `how-many-named` takes one parameter, not two, as
    in the two recursive calls.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¿™ä¸ªå‡½æ•°ä½“æ˜¯ä¸æ­£ç¡®çš„ï¼šPyretç±»å‹æ£€æŸ¥å™¨ä¼šç»™æˆ‘ä»¬ç±»å‹é”™è¯¯ã€‚è¿™æ˜¯å› ä¸º`how-many-named`åªæ¥å—ä¸€ä¸ªå‚æ•°ï¼Œè€Œä¸æ˜¯ä¸¤ä¸ªï¼Œå°±åƒåœ¨ä¸¤ä¸ªé€’å½’è°ƒç”¨ä¸­é‚£æ ·ã€‚
- en: 'How do we fix this? Remember, the whole point of this change is we donâ€™t want
    to change the name, only the tree. That means we want to recur on the inner function.
    We currently canâ€™t do this because it doesnâ€™t have a name! So we have to give
    it a name and recur on it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¯¥å¦‚ä½•ä¿®å¤è¿™ä¸ªé—®é¢˜ï¼Ÿè®°ä½ï¼Œè¿™ä¸ªæ”¹å˜çš„æ•´ä¸ªç›®çš„æ˜¯æˆ‘ä»¬ä¸æƒ³æ”¹å˜åç§°ï¼Œåªæƒ³æ”¹å˜æ ‘ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬æƒ³è¦é€’å½’è°ƒç”¨å†…éƒ¨å‡½æ•°ã€‚æˆ‘ä»¬ç›®å‰æ— æ³•è¿™æ ·åšï¼Œå› ä¸ºå®ƒæ²¡æœ‰åç§°ï¼æ‰€ä»¥æˆ‘ä»¬å¿…é¡»ç»™å®ƒä¸€ä¸ªåç§°ï¼Œå¹¶é€’å½’è°ƒç”¨å®ƒï¼š
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This now lets us recur on just the part that should vary, leaving the name weâ€™re
    looking for unchanged (and hence, fixed for the duration of the search).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨å®ƒè®©æˆ‘ä»¬å¯ä»¥é€’å½’åœ°å¤„ç†åº”è¯¥å˜åŒ–çš„éƒ¨åˆ†ï¼ŒåŒæ—¶ä¿æŒæˆ‘ä»¬æ­£åœ¨å¯»æ‰¾çš„åç§°ä¸å˜ï¼ˆå› æ­¤ï¼Œåœ¨æœç´¢æœŸé—´æ˜¯å›ºå®šçš„ï¼‰ã€‚
- en: Do Now!
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try the above and make sure it works.
  id: totrans-144
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°è¯•ä¸Šé¢çš„æ–¹æ³•å¹¶ç¡®ä¿å®ƒå·¥ä½œã€‚
- en: 'It still doesnâ€™t: the above body has a syntax error! This is because `how-many-named`
    does not actually return any kind of value.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ä»ç„¶ä¸è¡Œï¼šä¸Šé¢çš„ä¸»ä½“æœ‰ä¸€ä¸ªè¯­æ³•é”™è¯¯ï¼è¿™æ˜¯å› ä¸º`how-many-named`å®é™…ä¸Šæ²¡æœ‰è¿”å›ä»»ä½•ç±»å‹çš„å€¼ã€‚
- en: 'What should it return? Once we provide the function with a name, we should
    get back a function that searches for that name in a tree. But we already have
    exactly such a function: `search-in`. Therefore, `how-many-named` should return
    just â€¦ `search-in`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒåº”è¯¥è¿”å›ä»€ä¹ˆï¼Ÿä¸€æ—¦æˆ‘ä»¬ç»™å‡½æ•°æä¾›äº†ä¸€ä¸ªåç§°ï¼Œæˆ‘ä»¬åº”è¯¥å¾—åˆ°ä¸€ä¸ªåœ¨æ ‘ä¸­æœç´¢è¯¥åç§°çš„å‡½æ•°ã€‚ä½†æˆ‘ä»¬å·²ç»æœ‰äº†è¿™æ ·ä¸€ä¸ªå‡½æ•°ï¼š`search-in`ã€‚å› æ­¤ï¼Œ`how-many-named`åº”è¯¥åªè¿”å›â€¦
    `search-in`ã€‚
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This still wonâ€™t work, because we havenâ€™t changed the example. Letâ€™s update
    that: how do we use `how-many-named`? We have to call it with a name (like `"A"`);
    this returns a functionâ€”<wbr>the one bound to `search-in`â€”<wbr>which expects a
    ancestor tree. Doing so should return a count. Thus, the example should be rewritten
    as'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä»ç„¶ä¸ä¼šå·¥ä½œï¼Œå› ä¸ºæˆ‘ä»¬æ²¡æœ‰æ”¹å˜ä¾‹å­ã€‚è®©æˆ‘ä»¬æ›´æ–°ä¸€ä¸‹ï¼šæˆ‘ä»¬å¦‚ä½•ä½¿ç”¨`how-many-named`ï¼Ÿæˆ‘ä»¬å¿…é¡»ç”¨åç§°ï¼ˆå¦‚`"A"`ï¼‰è°ƒç”¨å®ƒï¼›è¿™è¿”å›ä¸€ä¸ªå‡½æ•°â€”â€”<wbr>ç»‘å®šåˆ°`search-in`çš„å‡½æ•°â€”â€”<wbr>å®ƒæœŸæœ›ä¸€ä¸ªç¥–å…ˆæ ‘ã€‚è¿™æ ·åšåº”è¯¥è¿”å›ä¸€ä¸ªè®¡æ•°ã€‚å› æ­¤ï¼Œä¾‹å­åº”è¯¥è¢«é‡å†™ä¸º
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is an instructive way to write the example. We can, however, also write
    it more concisely. Notice that `how-many-named("A")` returns a function, and the
    way we apply a function to arguments is `(â€¦)`. Thus, we can also write this as:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ç§å¾ˆæœ‰æ•™è‚²æ„ä¹‰çš„å†™ä¾‹å­æ–¹å¼ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æ›´ç®€æ´åœ°å†™ã€‚æ³¨æ„ï¼Œ`how-many-named("A")`è¿”å›ä¸€ä¸ªå‡½æ•°ï¼Œè€Œæˆ‘ä»¬åº”ç”¨å‡½æ•°åˆ°å‚æ•°çš„æ–¹å¼æ˜¯`(â€¦)`ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è¿™æ ·å†™ï¼š
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 24.5Â Context[ğŸ”—](#(part._.Context) "Link to here")
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.5 ä¸Šä¸‹æ–‡[ğŸ”—](#(part._.Context) "é“¾æ¥åˆ°æ­¤å¤„")
- en: The transformation we just applied is generally called currying, in honor of
    Haskell Curry, who was one of the early people to describe it, though it was earlier
    discovered by Moses SchÃ¶nfinkel and even earlier by Gottlob Frege. The particular
    use of currying here, where we move more â€œstaticâ€ arguments earlier and more â€œdynamicâ€
    ones later, and split on the static-dynamic divide, is called staging. Itâ€™s a
    very useful programming technique, and furthermore, one that enables some compilers
    to produce more time-efficient programs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åˆšæ‰åº”ç”¨çš„é‚£ç§è½¬æ¢é€šå¸¸è¢«ç§°ä¸ºæŸ¯é‡ŒåŒ–ï¼Œä»¥çºªå¿µå“ˆæ–¯å…‹å°”Â·æŸ¯é‡Œï¼Œä»–æ˜¯æœ€æ—©æè¿°è¿™ç§è½¬æ¢çš„äººä¹‹ä¸€ï¼Œå°½ç®¡å®ƒæ˜¯ç”±æ‘©è¥¿Â·ç”³èŠ¬å…‹å°”å‘ç°çš„ï¼Œç”šè‡³æ›´æ—©çš„æ˜¯æˆˆç‰¹æ´›å¸ƒÂ·å¼—é›·æ ¼ã€‚è¿™é‡ŒæŸ¯é‡ŒåŒ–çš„ç‰¹å®šç”¨é€”ï¼Œå³æˆ‘ä»¬æ›´æ—©åœ°å°†â€œé™æ€â€å‚æ•°ç§»åŠ¨ï¼Œè€Œå°†â€œåŠ¨æ€â€å‚æ•°ç§»åŠ¨å¾—æ›´æ™šï¼Œå¹¶åœ¨é™æ€-åŠ¨æ€åˆ’åˆ†ä¸Šæ‹†åˆ†ï¼Œè¢«ç§°ä¸ºåˆ†é˜¶æ®µã€‚è¿™æ˜¯ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„ç¼–ç¨‹æŠ€æœ¯ï¼Œè€Œä¸”å®ƒè¿˜ä½¿ä¸€äº›ç¼–è¯‘å™¨èƒ½å¤Ÿç”Ÿæˆæ›´é«˜æ•ˆçš„ç¨‹åºã€‚
- en: 'Even more subtly but importantly, the staged computation tells a different
    story than the unstaged one, and we can read this off just from the contract:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´åŠ å¾®å¦™ä½†é‡è¦çš„æ˜¯ï¼Œåˆ†é˜¶æ®µè®¡ç®—è®²è¿°çš„æ•…äº‹ä¸æœªåˆ†é˜¶æ®µçš„ä¸åŒï¼Œæˆ‘ä»¬å¯ä»¥ä»…ä»å¥‘çº¦ä¸­è¯»å‡ºè¿™ä¸€ç‚¹ï¼š
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first one says the string could co-vary with the person. The second one
    rules out that interpretation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªè¯´å­—ç¬¦ä¸²å¯èƒ½ä¸äººç‰©å…±åŒå˜åŒ–ã€‚ç¬¬äºŒä¸ªæ’é™¤äº†é‚£ç§è§£é‡Šã€‚
- en: Do Now!
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is the former useful? When might we have the name also changing?
  id: totrans-159
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‰è€…æœ‰ç”¨å—ï¼Ÿæˆ‘ä»¬ä»€ä¹ˆæ—¶å€™ä¼šæœ‰åå­—ä¹Ÿå˜åŒ–çš„æƒ…å†µï¼Ÿ
- en: 'Imagine a slightly different problem: we want to know how often a child has
    the same name as a parent. Then, as we traverse the tree, as the name of the person
    (potentially) keeps changing, the name weâ€™re looking for in the parent also changes.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡ä¸€ä¸ªç¨å¾®ä¸åŒçš„é—®é¢˜ï¼šæˆ‘ä»¬æƒ³çŸ¥é“ä¸€ä¸ªå­©å­ä¸çˆ¶æ¯åŒåçš„æƒ…å†µæœ‰å¤šå¸¸è§ã€‚ç„¶åï¼Œå½“æˆ‘ä»¬éå†æ ‘æ—¶ï¼Œéšç€äººç‰©ï¼ˆå¯èƒ½ï¼‰çš„åå­—ä¸æ–­å˜åŒ–ï¼Œæˆ‘ä»¬åœ¨çˆ¶æ¯é‚£é‡Œå¯»æ‰¾çš„åå­—ä¹Ÿä¼šéšä¹‹æ”¹å˜ã€‚
- en: Exercise
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write this function.
  id: totrans-163
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™è¿™ä¸ªå‡½æ•°ã€‚
- en: In contrast, the staged type rules out that interpretation and that behavior.
    In that way, it sends a signal to the reader about how the computation might behave
    just from the type. In the same way, the unstaged type can be read as giving the
    reader a hint that the behavior could depend on both parameters changing, therefore
    accommodating a much broader range of behaviors (e.g., checking for parent-child
    or grandparent-child name reuse).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸æ¯”ä¹‹ä¸‹ï¼Œåˆ†é˜¶æ®µç±»å‹è§„åˆ™æ’é™¤äº†é‚£ç§è§£é‡Šå’Œè¡Œä¸ºã€‚è¿™æ ·ï¼Œå®ƒå‘è¯»è€…ä¼ é€’äº†ä¸€ä¸ªä¿¡å·ï¼Œå³è®¡ç®—å¯èƒ½çš„è¡Œä¸ºä»…ä»ç±»å‹ä¸­å°±å¯ä»¥å¾—çŸ¥ã€‚åŒæ ·ï¼Œæœªåˆ†é˜¶æ®µç±»å‹å¯ä»¥è¢«è§£è¯»ä¸ºç»™è¯»è€…ä¸€ä¸ªæš—ç¤ºï¼Œå³è¡Œä¸ºå¯èƒ½å–å†³äºä¸¤ä¸ªå‚æ•°çš„å˜åŒ–ï¼Œå› æ­¤å¯ä»¥å®¹çº³æ›´å¹¿æ³›çš„è¡Œä¸ºèŒƒå›´ï¼ˆä¾‹å¦‚ï¼Œæ£€æŸ¥çˆ¶æ¯ä¸å­å¥³æˆ–ç¥–çˆ¶æ¯ä¸å­™å­å¥³çš„åå­—é‡å¤ï¼‰ã€‚
- en: 'Thereâ€™s another very nice example of staging here: [A Little Calculus](func-as-data.html#%28part._fd-calculus%29).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªå…³äºåˆ†é˜¶æ®µçš„éå¸¸æ£’çš„ä¾‹å­ï¼š[ä¸€ç‚¹å¾®ç§¯åˆ†](func-as-data.html#%28part._fd-calculus%29)ã€‚
- en: 'Finally, itâ€™s worth knowing that some languages, like Haskell and OCaml, do
    this transformation automatically. In fact, they donâ€™t even have multiple-parameter
    functions: what look like multiple arguments are actually a sequence of staged
    functions. This can, in extremis, lead to a very elegant and powerful programming
    style. Pyret chose to not do this because, while this is a powerful tool in the
    hands of advanced programmers, for less experienced programmers, finding out about
    a mismatch in the number of parameters and arguments is very useful.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä¸€äº›è¯­è¨€ï¼Œå¦‚ Haskell å’Œ OCamlï¼Œä¼šè‡ªåŠ¨è¿›è¡Œè¿™ç§è½¬æ¢ã€‚äº‹å®ä¸Šï¼Œå®ƒä»¬ç”šè‡³æ²¡æœ‰å¤šå‚æ•°å‡½æ•°ï¼šçœ‹èµ·æ¥åƒå¤šä¸ªå‚æ•°å®é™…ä¸Šæ˜¯ä¸€ç³»åˆ—åˆ†é˜¶æ®µå‡½æ•°ã€‚è¿™å¯ä»¥æç«¯åœ°å¯¼è‡´ä¸€ç§éå¸¸ä¼˜é›…ä¸”å¼ºå¤§çš„ç¼–ç¨‹é£æ ¼ã€‚Pyret
    é€‰æ‹©ä¸è¿™æ ·åšï¼Œå› ä¸ºè™½ç„¶è¿™å¯¹äºé«˜çº§ç¨‹åºå‘˜æ¥è¯´æ˜¯ä¸€ä¸ªå¼ºå¤§çš„å·¥å…·ï¼Œä½†å¯¹äºç»éªŒè¾ƒå°‘çš„ç¨‹åºå‘˜æ¥è¯´ï¼Œå‘ç°å‚æ•°å’Œå‚æ•°æ•°é‡ä¸åŒ¹é…æ˜¯éå¸¸æœ‰ç”¨çš„ã€‚
