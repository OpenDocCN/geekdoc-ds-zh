- en: 24¬†Stagingüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/staging.html](https://dcic-world.org/2025-08-27/staging.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[24.1¬†Problem Definition](#%28part._.Problem_.Definition%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[24.2¬†Initial Solution](#%28part._.Initial_.Solution%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[24.3¬†Refactoring](#%28part._.Refactoring%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[24.4¬†Separating Parameters](#%28part._.Separating_.Parameters%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[24.5¬†Context](#%28part._.Context%29) |'
  prefs: []
  type: TYPE_TB
- en: 24.1¬†Problem Definition[üîó](#(part._.Problem_.Definition) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Earlier, we saw a detailed development of binary trees representing ancestry
    [[Creating a Datatype for Ancestor Trees](trees.html#%28part._ancestor-tree%29)].
    In what follows we don‚Äôt need a lot of detail, so we will give ourselves a simplified
    version of essentially the same data definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then write functions over such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let‚Äôs think about a slightly different function: `how-many-named`, which
    tells us how many people in a family have a particular name. Not only can more
    than one person have the same name, in some cultures it‚Äôs not uncommon to use
    the same name across generations, either in successive generations or skipping
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the contract for `how-many-named`? The contract for this function will
    be crucial, so make sure you do this step!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here is one meaningful contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It takes a tree in which to search, a name to search for, and returns a count.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define `how-many-named`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 24.2¬†Initial Solution[üîó](#(part._.Initial_.Solution) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Presumably you ended up with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs say you have defined this person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With that, we can write a test like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 24.3¬†Refactoring[üîó](#(part._.Refactoring) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let‚Äôs apply some transformations, sometimes called code refactorings, to
    this function.
  prefs: []
  type: TYPE_NORMAL
- en: First, notice the repeated expression. What the whole conditional is essentially
    saying is that we want to know how much this person is contributing to the overall
    count; the rest of the count stays the same regardless.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to make this more explicit is to (perhaps surprisingly) rewrite the
    `else` to make explicit that a person with a different name contributes `0` to
    the count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this somewhat odd rewrite is that it makes clear what is common
    and what is different. What is common is looking in the two parents. What changes
    is how much this person contributes, and only that depends on the conditional.
    We can therefore express this more concisely (and, if we know how to read such
    code, more meaningfully) as the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you have prior programming experience, this may look a bit odd to you, but
    `if` is in fact an expression, which has a value; in this case the value is either
    `0` or `1`. This value can then be used in an addition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let‚Äôs look at this code even more closely. Notice something interesting.
    We keep passing two parameters to `how-many-named`; however, only one of those
    parameters (`p`) is actually changing. The name we are looking for does not change,
    as we would expect: we are looking for the same name in the entire tree. How can
    we reflect this in the code?'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we‚Äôll do something that looks a little useless, but it‚Äôs also an innocent
    change, so it shouldn‚Äôt irk us too much: we‚Äôll change the order of the arguments.
    That is, our contract changes from'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: so the function correspondingly changes to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: What we have now done is put the ‚Äúconstant‚Äù argument first, and the ‚Äúvarying‚Äù
    argument second.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try this and make sure it works!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It doesn‚Äôt! We have to change more than just the function header: we have to
    also change how it‚Äôs called. Keep in mind it‚Äôs called twice within the function
    body itself, and also from the examples. Therefore, the function as a whole reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: and the example reads `how-many-named("A", p)` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 24.4¬†Separating Parameters[üîó](#(part._.Separating_.Parameters) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This sets us up for the next stage. The parameters of functions are meant to
    indicate what might vary in a function. Because the name we‚Äôre looking for is
    a constant once we initially have it, we‚Äôd like the actual search function to
    take only one argument: where in the tree we‚Äôre searching.'
  prefs: []
  type: TYPE_NORMAL
- en: That is, we want the search function‚Äôs contract to be `(ABT -> Number)`. To
    achieve that, we need another function that will take the `String` part. Thus,
    the contract has to become
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: where `how-many-named` consumes a name and returns a function that will consume
    the actual tree to check.
  prefs: []
  type: TYPE_NORMAL
- en: 'This suggests the following function body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this function body is not okay: the Pyret type-checker will give us
    type errors. That‚Äôs because `how-many-named` takes one parameter, not two, as
    in the two recursive calls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we fix this? Remember, the whole point of this change is we don‚Äôt want
    to change the name, only the tree. That means we want to recur on the inner function.
    We currently can‚Äôt do this because it doesn‚Äôt have a name! So we have to give
    it a name and recur on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This now lets us recur on just the part that should vary, leaving the name we‚Äôre
    looking for unchanged (and hence, fixed for the duration of the search).
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try the above and make sure it works.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It still doesn‚Äôt: the above body has a syntax error! This is because `how-many-named`
    does not actually return any kind of value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What should it return? Once we provide the function with a name, we should
    get back a function that searches for that name in a tree. But we already have
    exactly such a function: `search-in`. Therefore, `how-many-named` should return
    just ‚Ä¶ `search-in`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This still won‚Äôt work, because we haven‚Äôt changed the example. Let‚Äôs update
    that: how do we use `how-many-named`? We have to call it with a name (like `"A"`);
    this returns a function‚Äî<wbr>the one bound to `search-in`‚Äî<wbr>which expects a
    ancestor tree. Doing so should return a count. Thus, the example should be rewritten
    as'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an instructive way to write the example. We can, however, also write
    it more concisely. Notice that `how-many-named("A")` returns a function, and the
    way we apply a function to arguments is `(‚Ä¶)`. Thus, we can also write this as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 24.5¬†Context[üîó](#(part._.Context) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The transformation we just applied is generally called currying, in honor of
    Haskell Curry, who was one of the early people to describe it, though it was earlier
    discovered by Moses Sch√∂nfinkel and even earlier by Gottlob Frege. The particular
    use of currying here, where we move more ‚Äústatic‚Äù arguments earlier and more ‚Äúdynamic‚Äù
    ones later, and split on the static-dynamic divide, is called staging. It‚Äôs a
    very useful programming technique, and furthermore, one that enables some compilers
    to produce more time-efficient programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even more subtly but importantly, the staged computation tells a different
    story than the unstaged one, and we can read this off just from the contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first one says the string could co-vary with the person. The second one
    rules out that interpretation.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is the former useful? When might we have the name also changing?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Imagine a slightly different problem: we want to know how often a child has
    the same name as a parent. Then, as we traverse the tree, as the name of the person
    (potentially) keeps changing, the name we‚Äôre looking for in the parent also changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write this function.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: In contrast, the staged type rules out that interpretation and that behavior.
    In that way, it sends a signal to the reader about how the computation might behave
    just from the type. In the same way, the unstaged type can be read as giving the
    reader a hint that the behavior could depend on both parameters changing, therefore
    accommodating a much broader range of behaviors (e.g., checking for parent-child
    or grandparent-child name reuse).
  prefs: []
  type: TYPE_NORMAL
- en: 'There‚Äôs another very nice example of staging here: [A Little Calculus](func-as-data.html#%28part._fd-calculus%29).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it‚Äôs worth knowing that some languages, like Haskell and OCaml, do
    this transformation automatically. In fact, they don‚Äôt even have multiple-parameter
    functions: what look like multiple arguments are actually a sequence of staged
    functions. This can, in extremis, lead to a very elegant and powerful programming
    style. Pyret chose to not do this because, while this is a powerful tool in the
    hands of advanced programmers, for less experienced programmers, finding out about
    a mismatch in the number of parameters and arguments is very useful.'
  prefs: []
  type: TYPE_NORMAL
- en: 24.1¬†Problem Definition[üîó](#(part._.Problem_.Definition) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Earlier, we saw a detailed development of binary trees representing ancestry
    [[Creating a Datatype for Ancestor Trees](trees.html#%28part._ancestor-tree%29)].
    In what follows we don‚Äôt need a lot of detail, so we will give ourselves a simplified
    version of essentially the same data definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then write functions over such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let‚Äôs think about a slightly different function: `how-many-named`, which
    tells us how many people in a family have a particular name. Not only can more
    than one person have the same name, in some cultures it‚Äôs not uncommon to use
    the same name across generations, either in successive generations or skipping
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the contract for `how-many-named`? The contract for this function will
    be crucial, so make sure you do this step!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here is one meaningful contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It takes a tree in which to search, a name to search for, and returns a count.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define `how-many-named`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 24.2¬†Initial Solution[üîó](#(part._.Initial_.Solution) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Presumably you ended up with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs say you have defined this person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With that, we can write a test like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 24.3¬†Refactoring[üîó](#(part._.Refactoring) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let‚Äôs apply some transformations, sometimes called code refactorings, to
    this function.
  prefs: []
  type: TYPE_NORMAL
- en: First, notice the repeated expression. What the whole conditional is essentially
    saying is that we want to know how much this person is contributing to the overall
    count; the rest of the count stays the same regardless.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to make this more explicit is to (perhaps surprisingly) rewrite the
    `else` to make explicit that a person with a different name contributes `0` to
    the count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this somewhat odd rewrite is that it makes clear what is common
    and what is different. What is common is looking in the two parents. What changes
    is how much this person contributes, and only that depends on the conditional.
    We can therefore express this more concisely (and, if we know how to read such
    code, more meaningfully) as the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you have prior programming experience, this may look a bit odd to you, but
    `if` is in fact an expression, which has a value; in this case the value is either
    `0` or `1`. This value can then be used in an addition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let‚Äôs look at this code even more closely. Notice something interesting.
    We keep passing two parameters to `how-many-named`; however, only one of those
    parameters (`p`) is actually changing. The name we are looking for does not change,
    as we would expect: we are looking for the same name in the entire tree. How can
    we reflect this in the code?'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we‚Äôll do something that looks a little useless, but it‚Äôs also an innocent
    change, so it shouldn‚Äôt irk us too much: we‚Äôll change the order of the arguments.
    That is, our contract changes from'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: so the function correspondingly changes to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: What we have now done is put the ‚Äúconstant‚Äù argument first, and the ‚Äúvarying‚Äù
    argument second.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try this and make sure it works!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It doesn‚Äôt! We have to change more than just the function header: we have to
    also change how it‚Äôs called. Keep in mind it‚Äôs called twice within the function
    body itself, and also from the examples. Therefore, the function as a whole reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: and the example reads `how-many-named("A", p)` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 24.4¬†Separating Parameters[üîó](#(part._.Separating_.Parameters) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This sets us up for the next stage. The parameters of functions are meant to
    indicate what might vary in a function. Because the name we‚Äôre looking for is
    a constant once we initially have it, we‚Äôd like the actual search function to
    take only one argument: where in the tree we‚Äôre searching.'
  prefs: []
  type: TYPE_NORMAL
- en: That is, we want the search function‚Äôs contract to be `(ABT -> Number)`. To
    achieve that, we need another function that will take the `String` part. Thus,
    the contract has to become
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: where `how-many-named` consumes a name and returns a function that will consume
    the actual tree to check.
  prefs: []
  type: TYPE_NORMAL
- en: 'This suggests the following function body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this function body is not okay: the Pyret type-checker will give us
    type errors. That‚Äôs because `how-many-named` takes one parameter, not two, as
    in the two recursive calls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we fix this? Remember, the whole point of this change is we don‚Äôt want
    to change the name, only the tree. That means we want to recur on the inner function.
    We currently can‚Äôt do this because it doesn‚Äôt have a name! So we have to give
    it a name and recur on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This now lets us recur on just the part that should vary, leaving the name we‚Äôre
    looking for unchanged (and hence, fixed for the duration of the search).
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try the above and make sure it works.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It still doesn‚Äôt: the above body has a syntax error! This is because `how-many-named`
    does not actually return any kind of value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What should it return? Once we provide the function with a name, we should
    get back a function that searches for that name in a tree. But we already have
    exactly such a function: `search-in`. Therefore, `how-many-named` should return
    just ‚Ä¶ `search-in`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This still won‚Äôt work, because we haven‚Äôt changed the example. Let‚Äôs update
    that: how do we use `how-many-named`? We have to call it with a name (like `"A"`);
    this returns a function‚Äî<wbr>the one bound to `search-in`‚Äî<wbr>which expects a
    ancestor tree. Doing so should return a count. Thus, the example should be rewritten
    as'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an instructive way to write the example. We can, however, also write
    it more concisely. Notice that `how-many-named("A")` returns a function, and the
    way we apply a function to arguments is `(‚Ä¶)`. Thus, we can also write this as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 24.5¬†Context[üîó](#(part._.Context) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The transformation we just applied is generally called currying, in honor of
    Haskell Curry, who was one of the early people to describe it, though it was earlier
    discovered by Moses Sch√∂nfinkel and even earlier by Gottlob Frege. The particular
    use of currying here, where we move more ‚Äústatic‚Äù arguments earlier and more ‚Äúdynamic‚Äù
    ones later, and split on the static-dynamic divide, is called staging. It‚Äôs a
    very useful programming technique, and furthermore, one that enables some compilers
    to produce more time-efficient programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even more subtly but importantly, the staged computation tells a different
    story than the unstaged one, and we can read this off just from the contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first one says the string could co-vary with the person. The second one
    rules out that interpretation.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is the former useful? When might we have the name also changing?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Imagine a slightly different problem: we want to know how often a child has
    the same name as a parent. Then, as we traverse the tree, as the name of the person
    (potentially) keeps changing, the name we‚Äôre looking for in the parent also changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write this function.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: In contrast, the staged type rules out that interpretation and that behavior.
    In that way, it sends a signal to the reader about how the computation might behave
    just from the type. In the same way, the unstaged type can be read as giving the
    reader a hint that the behavior could depend on both parameters changing, therefore
    accommodating a much broader range of behaviors (e.g., checking for parent-child
    or grandparent-child name reuse).
  prefs: []
  type: TYPE_NORMAL
- en: 'There‚Äôs another very nice example of staging here: [A Little Calculus](func-as-data.html#%28part._fd-calculus%29).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it‚Äôs worth knowing that some languages, like Haskell and OCaml, do
    this transformation automatically. In fact, they don‚Äôt even have multiple-parameter
    functions: what look like multiple arguments are actually a sequence of staged
    functions. This can, in extremis, lead to a very elegant and powerful programming
    style. Pyret chose to not do this because, while this is a powerful tool in the
    hands of advanced programmers, for less experienced programmers, finding out about
    a mismatch in the number of parameters and arguments is very useful.'
  prefs: []
  type: TYPE_NORMAL
