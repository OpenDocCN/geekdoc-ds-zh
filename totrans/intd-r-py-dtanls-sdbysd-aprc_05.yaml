- en: Chapter 2 Basic Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://randpythonbook.netlify.app/basic-types](https://randpythonbook.netlify.app/basic-types)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In every programming language, data is stored in different ways. Writing a program
    that manipulates data requires understanding all of the choices. That is why we
    must be concerned with the different **types** of data in our R and Python programs.
    Different types are suitable for different purposes.
  prefs: []
  type: TYPE_NORMAL
- en: There are similarities between Python’s and R’s type systems. However, there
    are may differences as well. Be prepared for these differences. There are many
    more of them in this chapter than there were in the previous chapter!
  prefs: []
  type: TYPE_NORMAL
- en: If you’re ever unsure what type a variable has, use `type()` (in Python) or
    `typeof()` (in R) to query it.
  prefs: []
  type: TYPE_NORMAL
- en: Storing an individual piece of information is simple in both languages. However,
    while Python has scalar types, R does not draw as strong of a distinction between
    scalar and compound types.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Basic Types In Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, the simplest types we frequently use are `str` (short for string),
    `int` (short for integer), `float` (short for floating point) and `bool` (short
    for Boolean). This list is not exhaustive, but these are a good collection to
    start thinking about. For a complete list of built-in types in Python, click [here](https://docs.python.org/3/library/stdtypes.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Strings are useful for processing text data such as names of people/places/things
    and messages such as texts, tweets and emails (Beazley and Kenneth) Jones [2014](#ref-python_cookbook)).
    If you are dealing with numbers, you need floating points if you have a number
    that might have a fractional part after its decimal; otherwise you’ll need an
    integer. Booleans are useful for situations where you need to record whether something
    is true or false. They are also important to understand for control-flow in section
    [11](/control-flow#control-flow).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section we will discuss the Numpy library. This library has a [broader
    collection](https://numpy.org/doc/stable/user/basics.types.html) of basic types
    that allows for finer control over any script you write.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.1 Type Conversions in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will often have to convert between types in a Python program. This is called
    **type conversion**, and it can be either implicitly or explicitly done.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `int`s are often implicitly converted to `float`s, so that arithmetic
    operations work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be disappointed if you always count on this behavior, though. For
    example, try the following piece of code on your machine. You will receive the
    following error: `TypeError: unsupported operand type(s) for +: ''float'' and
    ''str''`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Explicit conversions occur when we as programmers explicitly ask Python to perform
    a conversion. We will do this with the functions such as `int()`, `str()`, `float()`,
    and `bool()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 2.2 Basic Types In R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In R, the names of basic types are only slightly different. They are `logical`
    (instead of `bool`), `integer` (instead of `int`), `double` or `numeric` (instead
    of `float`)[⁵](#fn5), `character` (instead of `str`), `complex` (for calculations
    involving imaginary numbers), and `raw` (useful for working with bytes).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case R automatically upgraded `1` to a double. If you wanted to force
    it to be an integer, you can add a capital “L” to the end of the number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 2.2.1 Type Conversions in R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can explicitly and implicitly convert types in R just as you did in Python.
    Implicit conversion looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Explicit conversion can be achieved with functions such as `as.integer`, `as.logical`,
    `as.double`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 2.2.2 R’s Simplification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The basic types of R are a little different than the basic types of Python.
    On the one hand, Python has basic types for individual elements, and it uses separate
    types as containers for storing many elements. On the other, R uses the same type
    to store a single element as it does to store many elements. Strictly speaking,
    R does not have a scalar type.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, all of the examples we just did in R are using length one **vectors**–`logical`
    `integer` `double`, `character`, `complex`, and `raw` are the possible **modes**
    of a vector. `vector`s will be discussed further section [3](/r-vectors-versus-numpy-arrays-and-pandas-series#r-vectors-versus-numpy-arrays-and-pandas-series).
  prefs: []
  type: TYPE_NORMAL
- en: Think about which option you prefer. What are the benefits of using separate
    types for scalars and collections? What are the benefits of using the same type?
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 2.3.1 R Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Which R base type is ideal for each piece of data? Assign your answers to a
    `character` `vector` of length four called `questionOne`.
  prefs: []
  type: TYPE_NORMAL
- en: An individual’s IP address
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: whether or not an individual attended a study
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the number of seeds found in a plant
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the amount of time it takes for a car to race around a track
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Floating points are weird. What gets printed is not the same as what is stored!
    In R, you can control how many digits get printed by using the `options` function.
  prefs: []
  type: TYPE_NORMAL
- en: Assign`2/3` to `a`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`print` `a`, and copy/paste what you see into the variable `aPrint`. Make sure
    it is a `character`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a look at the documentation for `options`. Assign the value of `options()$digits`
    to `numDigitsStart`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the number of digits to `22`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, `print`, `a` and copy/paste what you see into the variable `aPrintv2`.
    Make sure it is a `character`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the output of `options()$digits` to `numDigitsEnd`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Floating points are weird. What gets stored might not be what you want. [“The
    only numbers that can be represented exactly in R’s numeric type are integers
    and fractions whose denominator is a power of 2.”](https://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f)
    As a consequence, you should never test strict equality (i.e. using `==`) between
    two floating points.
  prefs: []
  type: TYPE_NORMAL
- en: Assign the square root of 2 to `mySqrt`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the square of this variable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test (using `==`) that this variable is equal to `2`. Assign the result of this
    test to `isTwoRecoverable`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test for near equality (using `all.equal`). In other words, check that this
    variable is very close to `2`. Assign the result of this test to `closeEnough`.
    Make sure to read the documentation for this function because the return type
    can be tricky!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2.3.2 Python Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Which Python type is ideal for each piece of data? Assign your answers to a
    `list` of `str`ings called `question_one`.
  prefs: []
  type: TYPE_NORMAL
- en: An individual’s IP address
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: whether or not an individual attended a study
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the number of seeds found in a plant
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the amount of time it takes for a car to race around a track
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Floating points are weird. What gets printed is not the same as what is stored!
    In Python, you need to edit a class’s `__str__` method if you want to control
    how many digits get printed for a user-defined type/class, but we won’t do that.
    Instead, we’ll use [`str.format()`](https://docs.python.org/3/library/stdtypes.html#str.format)
    to return a string directly (instead of copy/paste-ing it).
  prefs: []
  type: TYPE_NORMAL
- en: Assign `a` to `2/3`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`print` `a`, and copy/paste what you see into the variable `a_print`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `str` that displays 22 digits of 2/3\. Call it `a_printv2`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`print` the above string'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Floating points are weird. What gets stored might not be what you want. The
    Python documentation has an excellent discussion of how storage behavior can be
    surprising. Click [here](https://docs.python.org/3/tutorial/floatingpoint.html)
    to read it.
  prefs: []
  type: TYPE_NORMAL
- en: Assign the square root of 2 to `my_sqrt`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`print` the square of this variable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test (using `==`) that this variable is equal to `2`. Assign the result of this
    test to `is_two_recoverable`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test for near equality (using `np.isclose`, which is available after running
    `import numpy as np`). In other words, check that this variable is close to `2`.
    Assign the result of this test to `close_enough`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Beazley, David M., and Brian K. (Brian Kenneth) Jones. 2014\. *Python Cookbook:
    Recipes for Mastering Python 3*. Third. pub-ora-media:adr: pub-ora-media.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: “double” is short for “double precision floating point.” In other programming
    languages, the programmer might choose how many decimal points of precision he
    or she wants.[↩](/basic-types#fnref5)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
