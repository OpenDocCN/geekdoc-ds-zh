<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Indirect Branching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Indirect Branching</h1>
<blockquote>原文：<a href="https://en.algorithmica.org/hpc/architecture/indirect/">https://en.algorithmica.org/hpc/architecture/indirect/</a></blockquote><div id="search"><input id="search-bar" type="search" placeholder="Search this book…" oninput="search()"/><div id="search-count"/><div id="search-results"/></div><header><div class="info"/></header><article><p>During assembly, all labels are converted to addresses (absolute or relative) and then encoded into jump instructions.</p><p>You can also jump by a non-constant value stored inside a register, which is called a <em>computed jump</em>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">jmp</span> <span class="nb">rax</span>
</span></span></code></pre></div><p>This has a few interesting applications related to dynamic languages and implementing more complex control flow.</p><span class="anchor" id="multiway-branch"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/architecture/indirect/#multiway-branch">#</a>Multiway Branch</h3><p>If you have already forgotten what a <code>switch</code> statement does, here is a little subroutine for calculating GPA in the American grading system:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">switch</span> <span class="p">(</span><span class="n">grade</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="sc">'A'</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mf">4.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="sc">'B'</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mf">3.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="sc">'C'</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mf">2.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="sc">'D'</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="sc">'E'</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="sc">'F'</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">NAN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>I personally don’t remember the last time I used a switch in a non-educational context. In general, switch statements are equivalent to a sequence of “if, else if, else if, else if…” and so on, and for this reason many languages don’t even have them. Nonetheless, such control flow structures are important for implementing parsers, interpreters, and other state machines, which are often comprised of a single <code>while (true)</code> loop and a <code>switch (state)</code> statement inside.</p><p>When we have control over the range of values that the variable can take, we can use the following trick utilizing computed jumps. Instead of making $n$ conditional branches, we can create a <em>branch table</em> that contains pointers/offsets to possible jump locations, and then just index it with the <code>state</code> variable taking values in the $[0, n)$ range.</p><p>Compilers use this technique when the values are densely packed together (not necessarily strictly sequentially, but it has to be worth having blank fields in the table). It can also be implemented explicitly with a <em>computed goto</em>:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">weather_in_russia</span><span class="p">(</span><span class="kt">int</span> <span class="n">season</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">&amp;&amp;</span><span class="n">winter</span><span class="p">,</span> <span class="o">&amp;&amp;</span><span class="n">spring</span><span class="p">,</span> <span class="o">&amp;&amp;</span><span class="n">summer</span><span class="p">,</span> <span class="o">&amp;&amp;</span><span class="n">fall</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="o">*</span><span class="n">table</span><span class="p">[</span><span class="n">season</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nl">winter</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">"Freezing</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nl">spring</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">"Dirty</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nl">summer</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">"Dry</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nl">fall</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">"Windy</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Switch-based code is not always straightforward for compilers to optimize, so in the context of state machines, <code>goto</code> statements are often used directly. The I/O-related part of <code>glibc</code> is full of examples.</p><span class="anchor" id="dynamic-dispatch"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/architecture/indirect/#dynamic-dispatch">#</a>Dynamic Dispatch</h3><p>Indirect branching is also instrumental in implementing runtime polymorphism.</p><p>Consider the cliché example when we have an abstract class of <code>Animal</code> with a virtual <code>.speak()</code> method, and two concrete implementations: a <code>Dog</code> that barks and a <code>Cat</code> that meows:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Animal</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">speak</span><span class="p">()</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"&lt;abstract animal sound&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Dog</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">speak</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Bark</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Cat</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">speak</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Meow</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>We want to create an animal and, without knowing its type in advance, call its <code>.speak()</code> method, which should somehow invoke the right implementation:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Dog</span> <span class="n">sparkles</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Cat</span> <span class="n">mittens</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Animal</span> <span class="o">*</span><span class="n">catdog</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="nl">sparkles</span> <span class="p">:</span> <span class="o">&amp;</span><span class="n">mittens</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">catdog</span><span class="o">-&gt;</span><span class="n">speak</span><span class="p">();</span>
</span></span></code></pre></div><p>There are many ways to implement this behavior, but C++ does it using a <em>virtual method table</em>.</p><p>For all concrete implementations of <code>Animal</code>, compiler pads all their methods (that is, their instruction sequences) so that they have the exact same length for all classes (by inserting some <a href="../layout">filler instructions</a> after <code>ret</code>) and then just writes them sequentially somewhere in the instruction memory. Then it adds a <em>run-time type information</em> field to the structure (that is, to all its instances), which is essentially just the offset in the memory region that points to the right implementation of the virtual methods of the class.</p><p>With a virtual method call, that offset field is fetched from the instance of a structure and a normal function call is made with it, using the fact that all methods and other fields of every derived class have exactly the same offsets.</p><p>Of course, this adds some overhead:</p><ul><li>You may need to spend another 15 cycles or so for the same pipeline flushing reasons as for <a href="/hpc/pipelining">branch misprediction</a>.</li><li>The compiler most likely won’t be able to inline the function call itself.</li><li>Class size increases by a couple of bytes or so (this is implementation-specific).</li><li>The binary size itself increases a little bit.</li></ul><p>For these reasons, runtime polymorphism is usually avoided in performance-critical applications.</p></article><div class="nextprev"><div class="left"><a href="https://en.algorithmica.org/hpc/architecture/functions/" id="prev-article">← Functions and Recursion</a></div><div class="right"><a href="https://en.algorithmica.org/hpc/architecture/layout/" id="next-article">Machine Code Layout →</a></div></div>    
</body>
</html>