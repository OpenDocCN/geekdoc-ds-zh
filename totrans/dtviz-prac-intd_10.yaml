- en: A Appendix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A 附录
- en: 原文：[https://socviz.co/appendix.html](https://socviz.co/appendix.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://socviz.co/appendix.html](https://socviz.co/appendix.html)
- en: This Appendix contains supplemental information about various aspects of R and
    ggplot that you are likely to run into as you use it. You are at the beginning
    of a process of discovering practical problems that are an inevitable part of
    using software. This is often frustrating. But feeling stumped is a standard experience
    for everyone who writes code. Each time you figure out the solution to your problem,
    you acquire more and more knowledge about how and why things go wrong, and more
    confidence about how to tackle the next glitch that comes along.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录包含有关 R 和 ggplot 的各种补充信息，您在使用过程中可能会遇到。您正处于一个发现实际问题的过程中，这些问题是使用软件的必然部分。这通常很令人沮丧。但感到困惑是每个编写代码的人的标准体验。每次您找到解决问题的方法，您就会获得更多关于如何以及为什么事情出错的知识，以及更多关于如何应对下一个故障的信心。
- en: A.1 A little more about R
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 关于 R 的更多内容
- en: A.1.1 How to read an R help page
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.1 如何阅读 R 帮助页面
- en: Functions, datasets, and other built-in objects in R are documented in its help
    system. You can search or browse this documentation via the “Help” tab in RStudio’s
    lower right-hand window. The quality of R’s help pages varies somewhat. They tend
    to be on the terse side. However, they all have essentially the same structure
    and it is useful to know how to read them. Figure [A.1](appendix.html#fig:ch-09-help)
    provides an overview of what to look for. Remember, functions take inputs, perform
    actions, and return outputs. Something goes in, it gets worked on, and then something
    comes out. That means you want to know what the function *requires*, what it *does*,
    and what it *returns*. What it requires is shown in the *Usage* and *Arguments*
    sections of the help page. The names of all the required and optional arguments
    are given by name and in the order the function expects them. Some arguments have
    default values. In the case of the `mean()` function the argument `na.rm` is set
    to `FALSE` by default. These will be shown in the *Usage* section. If a named
    argument has no default, you will have to give it a value. Depending on what the
    argument is, this might be a logical value, a number, a dataset, or any other
    object.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的函数、数据集和其他内置对象在它的帮助系统中进行了文档说明。您可以通过 RStudio 右下角的“帮助”标签搜索或浏览这些文档。R 的帮助页面质量参差不齐。它们往往比较简略。然而，它们都具有基本相同的结构，了解如何阅读它们是有用的。图
    [A.1](appendix.html#fig:ch-09-help) 提供了要查找内容的概述。记住，函数接受输入，执行操作，并返回输出。有东西进去，被处理，然后有东西出来。这意味着您想知道函数*需要什么*，*做什么*，以及*返回什么*。它需要的内容在帮助页面的“用法”和“参数”部分中显示。所有必需和可选参数的名称按函数期望的顺序给出。一些参数有默认值。对于
    `mean()` 函数，参数 `na.rm` 默认设置为 `FALSE`。这些将在“用法”部分中显示。如果命名参数没有默认值，您必须为其提供值。根据参数的类型，这可能是一个逻辑值、一个数字、一个数据集或任何其他对象。
- en: '![The structure of an R help page.](../Images/6ce9b70c44f6aef3373d3f1779e4bb78.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![R 帮助页面的结构。](../Images/6ce9b70c44f6aef3373d3f1779e4bb78.png)'
- en: 'Figure A.1: The structure of an R help page.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.1：R 帮助页面的结构。
- en: The other part to look at closely is the *Value* section, which tells you what
    the function returns once it has done its calculation. Again, depending on what
    the function is, this might simply be a single number or other short bit of output.
    But it could also be something as complex as a ggplot figure or a model object
    consisting of many separate parts organized as a list.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要仔细查看的部分是 *值* 部分，它告诉您函数完成计算后返回的内容。同样，根据函数的类型，这可能只是一个单一的数字或其他简短的输出。但它也可能是像
    ggplot 图表或由多个单独部分组成的列表模型对象这样复杂的东西。
- en: Well-documented packages will often have *Demos* and *Vignettes* attached to
    them. These are meant to describe the package as a whole, rather than specific
    functions. A good package vignette will often have one or more fully-worked examples
    together with a discussion describing how the package works and what it can do.
    To see if there any package vignettes, click the link at the bottom of the function’s
    help page to be taken to the package index. Any available demos, vignettes, or
    other general help will be listed at the top.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 记载良好的包通常会附有 *Demos* 和 *Vignettes*。这些旨在描述整个包，而不是特定的函数。一个好的包 vignette 通常会包含一个或多个完整工作的示例，以及一个讨论，说明包是如何工作的以及它能做什么。要查看是否有包
    vignette，点击函数帮助页面底部的链接，即可转到包索引。任何可用的演示、vignette 或其他一般帮助都将列在顶部。
- en: A.1.2 The basics of accessing and selecting things
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.2 访问和选择事物的基本原理
- en: Generally speaking, the tidyverse’s preferred methods for data subsetting, filtering,
    slicing and selecting will keep you away from the underlying mechanics of selecting
    and extracting elements of vectors, matrices, or tables of data. Carrying out
    these operations through functions like `select()`, `filter()`, `subset()`, and
    `merge()` is generally safer and more reliable than accessing elements directly.
    However, it is worth knowing the basics of these operations. Sometimes accessing
    elements directly is the most convenient thing to do. More importantly, we may
    use these techniques in small ways in our code with some regularity. Here we very
    briefly introduce some of R’s selection operators for vectors, arrays, and tables.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，tidyverse 优先的数据子集、过滤、切片和选择方法将使您远离选择和提取向量、矩阵或数据表元素的基本机制。通过像 `select()`、`filter()`、`subset()`
    和 `merge()` 这样的函数执行这些操作通常比直接访问元素更安全、更可靠。然而，了解这些操作的基本原理是值得的。有时直接访问元素是最方便的做法。更重要的是，我们可能经常以小的方式在我们的代码中使用这些技术。在这里，我们简要介绍一些
    R 的向量、数组和表选择运算符。
- en: Consider the `my_numbers` and `your_numbers` vectors again.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑 `my_numbers` 和 `your_numbers` 向量。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To access any particular element in `my_numbers`, we use square brackets. Square
    brackets are not like the parentheses after functions. They are used to pick out
    an element indexed by its position:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 `my_numbers` 中的任何特定元素，我们使用方括号。方括号不像函数后面的括号。它们用于选择由其位置索引的元素：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Putting the number *n* inside the brackets will give us (or “return”) the *n*th
    element in the vector, assuming there is one. To access a *sequence* of elements
    within a vector we can do this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字 *n* 放入括号内将给我们（或“返回”）向量中的第 *n* 个元素，假设有一个。要访问向量中元素的一个 *序列*，我们可以这样做：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This shorthand notation tells R to count from the 2nd to the 4th element, inclusive.
    We are not restricted to selecting contiguous elements, either. We can make use
    of our `c()` function again:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简写表示法告诉 R 从第 2 个元素开始计数到第 4 个元素，包括在内。我们也不受限于选择连续的元素。我们还可以再次使用我们的 `c()` 函数：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'R evaluates the expression `c(2,4)` first, and then extracts just the second
    and the fourth element from `my_numbers`, ignoring the others. You might wonder
    why we didn’t just write `my_numbers[2,3]` directly. The answer is that this notation
    is used for objects arrayed in two dimensions (i.e. something with rows and columns),
    like matrices, data frames, or tibbles. We can make a two-dimensional object by
    creating two different vectors with the `c()` function and using the `tibble()`
    function to collect them together:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: R 首先评估表达式 `c(2,4)`，然后只从 `my_numbers` 中提取第二个和第四个元素，忽略其他元素。您可能会想知道为什么我们直接写 `my_numbers[2,3]`。答案是，这种表示法用于二维排列的对象（即具有行和列的对象），如矩阵、数据框或
    tibbles。我们可以通过使用 `c()` 函数创建两个不同的向量，并使用 `tibble()` 函数将它们收集在一起来创建一个二维对象：
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: WeIn these chunks of code you will see some explanatory text set off by the
    hash symbol, `#`. In R’s syntax, the hash symbol is used to designate a comment.
    On any line of code, text that appears after a `#` symbol will be ignored by R’s
    interpreter. It won’t be evaluated and it won’t trigger a syntax error. index
    data frames, tibbles, and other arrays by row first, and then by column. Arrays
    may also have more than two dimensions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些代码块中，您将看到一些由井号符号 `#` 分隔的解释性文本。在 R 的语法中，井号符号用于指定注释。在任何代码行的 `#` 符号之后的文本将被 R
    的解释器忽略。它不会被评估，也不会触发语法错误。我们首先按行索引数据框、tibbles 和其他数组，然后按列索引。数组也可能有超过两个维度。
- en: '[PRE13]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The columns in our tibble have names. We can select elements using them, too.
    We do this by putting the name of the column in quotes where we previously put
    the index number of the column:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 tibble 的列有名称。我们也可以使用它们来选择元素。我们这样做是通过在之前放置列索引号的位置放置列的名称：
- en: '[PRE17]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we want to get all the elements of a particular column, we can leave out
    the row index. This will mean all the rows will be included for whichever column
    we select.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想获取特定列的所有元素，我们可以省略行索引。这意味着将包括我们选择的任何列的所有行。
- en: '[PRE25]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can do this the other way around, too, selecting a particular row and showing
    all columns:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以反过来操作，选择特定行并显示所有列：
- en: '[PRE27]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A better way of accessing particular columns in a data frame is via the `$`
    operator, which can be used to extract components of various sorts of object.
    This way we append the name of the column we want to the name of the object it
    belongs to:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数据框中的特定列的更好方法是使用 `$` 操作符，它可以用来提取各种类型对象的组件。这样，我们将我们想要列的名称附加到它所属的对象的名称上：
- en: '[PRE29]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Elements of many other objects can be extracted in this way, too, including
    nested objects.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他对象的元素也可以用这种方式提取，包括嵌套对象。
- en: '[PRE31]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Finally, in the case of data frames the `$` operator also lets us add new columns
    to the object. For example, we can add the first two columns together, row by
    row. To create a column in this way, we put the `$` and the name of the new column
    on the left-hand side of the assignment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在数据框的情况下，`$` 操作符还允许我们向对象添加新列。例如，我们可以将前两列逐行相加。以这种方式创建列时，我们在赋值左侧放置 `$` 和新列的名称。
- en: '[PRE37]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this book we do not generally access data via `[` or `$`. It is particularly
    bad practice to access elements by their index number only, as opposed to using
    names. In both cases, and especially the latter, it is too easy to make a mistake
    and choose the wrong columns or rows. In addition, if our table changes shape
    later on (e.g. due to the addition of new original data) then any absolute reference
    to the position of columns (rather than to their names) is very likely to break.
    Still, we do use the `c()` function for small tasks quite regularly, so it’s worth
    understanding how it can be used to pick out elements from vectors.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们通常不通过 `[` 或 `$` 访问数据。仅通过索引号访问元素，而不是使用名称，这是一种特别不好的做法。在两种情况下，尤其是后者，很容易出错并选择错误的列或行。此外，如果我们的表格以后改变了形状（例如，由于添加了新的原始数据），那么任何对列位置的绝对引用（而不是对名称的引用）很可能都会出错。尽管如此，我们确实经常使用
    `c()` 函数来完成一些小任务，因此了解如何使用它从向量中挑选元素是值得的。
- en: A.1.3 Tidy data
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.3 整洁数据
- en: Working with R and ggplot is much easier if the data you use is in the right
    shape. Ggplot wants your data to be *tidy*. For a more thorough introduction to
    the idea of tidy data, see Chapters 5 and 12 of Wickham & Grolemund (2016). To
    get a sense of what a tidy dataset looks like in R, we will follow the discussion
    in Wickham (2014). In a tidy dataset,
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的数据形状正确，使用R和ggplot将更容易。ggplot希望您的数据是*整洁的*。关于整洁数据概念的更详细介绍，请参阅Wickham & Grolemund（2016）的第5章和第12章。为了了解R中整洁数据集的样子，我们将遵循Wickham（2014）中的讨论。在一个整洁数据集中，
- en: '*Each variable is a column.*'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*每个变量都是一个列。*'
- en: '*Each observation is a row.*'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*每个观测都是一个行。*'
- en: '*Each type of observational unit forms a table.*'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*每种观测单位类型都构成一个表格。*'
- en: For most of your data analysis, the first two points are the most important.
    This third one might be a little unfamiliar. It is a feature of “normalized” data
    from the world of databases, where the goal is to represent data in a series of
    related tables with minimal duplication (Codd, 1990). Data analysis more usually
    works with a single large table of data, often with considerable duplication of
    some variables down the rows.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的大部分数据分析，前两点是最重要的。第三点可能有点不熟悉。这是数据库世界中“标准化”数据的一个特性，其目标是使用一系列相关表以最小重复来表示数据（Codd，1990）。数据分析通常使用单个大型数据表，通常在行中有相当多的某些变量的重复。
- en: Data presented in summary tables is often not “tidy” as defined here. When structuring
    our data we need to be clear about how our data is arranged. If your data is not
    tidily arranged, the chances are good that you will have more difficulty, and
    maybe a *lot* more difficulty, getting ggplot to draw the figure you want.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结表中呈现的数据通常不符合这里定义的“整洁”。在构建我们的数据时，我们需要清楚我们的数据是如何排列的。如果你的数据没有整洁地排列，那么你可能会遇到更多困难，也许会有很多困难，才能让ggplot绘制出你想要的图形。
- en: 'Table A.1: Some untidy data.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表A.1：一些不整洁的数据。
- en: '| name | treatmenta | treatmentb |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 处理a | 处理b |'
- en: '| :-- | --: | --: |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| :-- | --: | --: |'
- en: '| John Smith | NA | 18 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 约翰·史密斯 | NA | 18 |'
- en: '| Jane Doe | 4 | 1 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 简妮·多伊 | 4 | 1 |'
- en: '| Mary Johnson | 6 | 7 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 玛丽·约翰逊 | 6 | 7 |'
- en: 'Table A.2: The same data, still untidy, but in a different way.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 表A.2：相同的数据，仍然不整洁，但以不同的方式。
- en: '| treatment | John Smith | Jane Doe | Mary Johnson |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 处理 | 约翰·史密斯 | 简妮·多伊 | 玛丽·约翰逊 |'
- en: '| :-- | --: | --: | --: |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| :-- | --: | --: | --: |'
- en: '| a | NA | 4 | 6 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| a | NA | 4 | 6 |'
- en: '| b | 18 | 1 | 7 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| b | 18 | 1 | 7 |'
- en: For example consider Table [A.1](appendix.html#tab:ch-09-preg1) and Table [A.2](appendix.html#tab:ch-09-preg2)
    from Wickham’s discussion. They present the same data in different ways, but each
    would cause trouble if we tried to work with it in ggplot to make a graph. Table
    [A.3](appendix.html#tab:ch-09-preg3) shows the same data once again, this time
    in a tidied form.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑 Wickham 的讨论中的表 [A.1](appendix.html#tab:ch-09-preg1) 和表 [A.2](appendix.html#tab:ch-09-preg2)。它们以不同的方式呈现相同的数据，但如果我们尝试在
    ggplot 中使用它们来制作图表，每个都会带来麻烦。表 [A.3](appendix.html#tab:ch-09-preg3) 再次展示了相同的数据，这次是以整洁的形式。
- en: 'Hadley Wickham notes five main ways tables of data tend not to be tidy:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Hadley Wickham 指出，数据表通常不整洁的五个主要原因：
- en: '*Column headers are values, not variable names*.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*列标题是值，而不是变量名*。'
- en: '*Multiple variables are stored in one column*.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*多个变量存储在一列中*。'
- en: '*Variables are stored in both rows and columns*.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*变量存储在行和列中*。'
- en: '*Multiple types of observational units are stored in the same table*.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*同一表中存储了多种类型的观测单位*。'
- en: '*A single observational unit is stored in multiple tables*.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*单个观测单位存储在多个表中*。'
- en: 'Table A.3: Tidied data. Every variable a column, every observation a row.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表 A.3：整洁数据。每个变量为一列，每个观测为一行。
- en: '| name | treatment | n |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 处理 | n |'
- en: '| :-- | :-- | --: |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| :-- | :-- | --: |'
- en: '| Jane Doe | a | 4 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 简·多伊 | a | 4 |'
- en: '| Jane Doe | b | 1 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 简·多伊 | b | 1 |'
- en: '| John Smith | a | NA |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 约翰·史密斯 | a | NA |'
- en: '| John Smith | b | 18 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 约翰·史密斯 | b | 18 |'
- en: '| Mary Johnson | a | 6 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 玛丽·约翰逊 | a | 6 |'
- en: '| Mary Johnson | b | 7 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 玛丽·约翰逊 | b | 7 |'
- en: Data comes in an untidy form all the time, often for the good reason that it
    can be presented that way using much less space, or with far less repetition of
    labels and row elements. Figure [A.2](appendix.html#fig:ch-09-census-untidy) shows
    a the first few rows of a table of U.S. Census Bureau data about educational attainment
    in the United States. To begin with, it’s organized as a series of sub-tables
    down the spreadsheet, broken out by age and sex. Second, the underlying variable
    of interest, “Years of School Completed” is stored across several columns, with
    an additional variable (level of schooling) included across the columns also.
    It is not too hard to get the table into a slightly more regular format by eliminating
    the blank rows, and explicitly naming the sub-table rows. One can do this manually
    and get to the point where it can be read in as an Excel or CSV file. This is
    not ideal, as manually cleaning data runs against the commitment to do as much
    as possible programmatically.`readxl.tidyverse.org` We can automate the process
    somewhat. The tidyverse comes with a `readxl` package that tries to ease the pain
    a little.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 数据总是以杂乱无章的形式出现，这通常是因为以这种方式呈现可以占用更少的空间，或者标签和行元素的重复更少。图 [A.2](appendix.html#fig:ch-09-census-untidy)
    展示了美国人口普查局关于美国教育成就的表格的前几行。起初，它被组织成一系列沿工作表下方的子表，按年龄和性别划分。其次，感兴趣的底层变量“完成学年的年数”存储在几个列中，同时还包括一个额外的变量（教育水平），也跨越了这些列。通过消除空白行并明确命名子表行，可以不太困难地将表格转换成稍微更规范的格式。可以手动完成这项工作，并将其作为
    Excel 或 CSV 文件读取。这不是理想的做法，因为手动清理数据与尽可能编程化处理的承诺相矛盾。`readxl.tidyverse.org` 我们可以某种程度上自动化这个过程。tidyverse
    随带一个 `readxl` 包，试图稍微减轻一些痛苦。
- en: 'Figure A.2: Untidy data from the Census.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.2：来自人口普查的杂乱数据。
- en: '![Untidy data from the Census.](../Images/c7abcd15676ccf4d2f644bebb6b0dfab.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![来自人口普查的杂乱数据](../Images/c7abcd15676ccf4d2f644bebb6b0dfab.png)'
- en: '[PRE39]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The tidyverse has several tools to help you get the rest of the way in converting
    your data from an untidy to a tidy state. These can mostly be found in the `tidyr`
    and `dplyr` libraries. The former provides functions for converting, for example,
    wide-format data to long-format data, as well as assisting with the business of
    splitting and combining variables that are untidily stored. The latter has a tools
    that allow tidy tables to be further filtered, sliced, and analyzed at different
    grouping levels, as we have seen throughout this book.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: tidyverse 提供了几个工具来帮助您将数据从杂乱无章的状态转换为整洁状态。这些工具大多可以在 `tidyr` 和 `dplyr` 库中找到。前者提供了将宽格式数据转换为长格式数据等功能，同时协助处理那些存储不整洁的变量拆分和合并的业务。后者提供了一些工具，允许在
    ggplot 中对整洁表格进行进一步的筛选、切片和分析，正如我们在本书中看到的。
- en: With our `edu` object, we can use the `gather()` function to transform the schooling
    variables into a *key-value* arrangement. The key is the underlying variable,
    and the value is the value it takes for that observation. We create a new object,
    `edu_t` in this way.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`edu`对象，我们可以使用`gather()`函数将教育变量转换为*键值*排列。键是基础变量，值是它对该观察值的取值。我们以这种方式创建了一个新的对象，`edu_t`。
- en: '[PRE40]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The educational categories previously spread over the columns have been gathered
    into two new columns. The `school` variable is the *key* column. It contains all
    of the education categories that were previously given across the column headers,
    from 0-4 years of elementary school to four or more years of college. They are
    now stacked up on top of each other in the rows. The `freq` variable is the *value*
    column, and contains the unique value of `schooling` for each level of that variable.
    Once our data is in this long-form shape, it is ready for easy use with ggplot
    and related tidyverse tools.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之前分散在列中的教育类别已被收集到两个新的列中。`school`变量是*键*列。它包含之前在列标题中给出的所有教育类别，从0-4年的小学到四年或更长时间的大学。它们现在堆叠在行上。`freq`变量是*值*列，包含该变量每个级别的唯一`schooling`值。一旦我们的数据以这种长格式排列，就可以轻松地与ggplot和相关tidyverse工具一起使用。
- en: A.2 Common problems reading in data
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 读取数据时常见的问题
- en: Date formats
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期格式
- en: 'Date formats can be annoying. First, times and dates must be treated differently
    from ordinary numbers. Second, there are many, many different date formats, differing
    both in the precision with which they are stored and the convention they follow
    about how to display years, months, days, and so on. Consider the following data:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 日期格式可能会很烦人。首先，时间和日期必须与普通数字区分对待。其次，有许多不同的日期格式，它们在存储的精度以及它们遵循的关于如何显示年份、月份、日期等约定方面都存在差异。考虑以下数据：
- en: '[PRE44]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The data in the `date` column has been read in as a character string, but we
    want R to treat it as a date. If can’t treat it as a date, we get bad results.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`date`列中的数据已被读入为字符字符串，但我们希望R将其视为日期。如果不能将其视为日期，我们将得到错误的结果。'
- en: '![A bad date.](../Images/52465ae3bdb35038a8ba0f67225c35e2.png) Figure A.3:
    A bad date.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个错误的日期。](../Images/52465ae3bdb35038a8ba0f67225c35e2.png) 图A.3：一个错误的日期。'
- en: '[PRE46]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: What has happened? The problem is that ggplot doesn’t know `date` consists of
    dates. As a result, when we ask to plot it on the x-axis, it tries to treat the
    unique elements of `date` like a categorical variable instead. (That is, as a
    factor.) But because each date is unique, its default effort at grouping the data
    results in every group having only one observation in it (i.e., that particular
    row). The ggplot function knows something is odd about this, and tries to let
    you know. It wonders whether we’ve failed to set `group = <something>` in our
    mapping.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？问题是ggplot不知道`date`由日期组成。因此，当我们要求将其绘制在x轴上时，它试图将`date`的唯一元素视为分类变量（即因子）。但由于每个日期都是唯一的，它默认的数据分组努力导致每个组中只有一个观察值（即那一行）。ggplot函数知道这一点，并试图让你知道。它想知道我们是否在映射中未能设置`group
    = <something>`。
- en: For the sake of it, let’s see what happens when the bad date values are *not*
    unique. We will make a new data frame by stacking two copies of the data on top
    of each other. The `rbind()` function does this for us. We end up with two copies
    of every observation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看当不良日期值**不**唯一时会发生什么，让我们看看会发生什么。我们将通过将两个数据副本堆叠在一起来创建一个新的数据框。`rbind()`函数为我们完成这项工作。我们最终得到每个观察值的两个副本。
- en: '![Still bad.](../Images/773245f5dd69a1ceaa507762c031c2c0.png) Figure A.4: Still
    bad.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![仍然错误。](../Images/773245f5dd69a1ceaa507762c031c2c0.png) 图A.4：仍然错误。'
- en: '[PRE48]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now ggplot doesn’t complain at all, because there’s more than one observation
    per (inferred) group. But the plot is still wrong!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，ggplot根本不会抱怨，因为每个（推断的）组中都有多个观察值。但图表仍然错误！
- en: We will fix this problem using the `lubridate` library. It provides a suite
    of convenience functions for converting date strings in various formats and with
    various separators (such as `/` or `-` and so on) into objects of class `Date`
    that R knows about. Here our bad dates are in a month/day/year format, so we use
    `mdy()`. Consult the lubridate library’s documentation to learn more about similar
    convenience functions for converting character strings where the date components
    appear in a different order.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`lubridate`库来解决这个问题。它提供了一系列方便的函数，用于将各种格式的日期字符串以及各种分隔符（如`/`或`-`等）转换为R所认识的`Date`类对象。在这里，我们的坏日期是月/日/年的格式，因此我们使用`mdy()`。查阅`lubridate`库的文档，了解更多关于转换字符字符串中日期组件顺序不同的类似方便函数的信息。
- en: '[PRE49]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now `filldate_new` has a `Date` class. Let’s try the plot again.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`filldate_new`具有`Date`类。让我们再次尝试绘图。
- en: '![Much better.](../Images/f7c5e594b621f7ef4cb6ac4478fb6eac.png) Figure A.5:
    Much better.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![好多了。](../Images/f7c5e594b621f7ef4cb6ac4478fb6eac.png) 图A.5：好多了。'
- en: '[PRE51]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Year-only dates
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅显示年份的日期
- en: 'Many variables are measured by the year and supplied in the data as a four
    digit number rather than as a date. This can sometimes cause headaches when we
    want to plot year on the x-axis. It happens most often when the time series is
    relatively short. Consider this data:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 许多变量按年份测量，并以四位数字的形式提供数据，而不是日期。这有时在我们想在x轴上绘制年份时会引起头痛。这种情况通常发生在时间序列相对较短时。考虑以下数据：
- en: '[PRE52]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is a version of `organdata` but in a less clean format. The `year` variable
    is an integer (its class is `<int>`) and not a date. Let’s say we want to plot
    donation rate against year.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`organdata`的版本，但格式不太整洁。`year`变量是一个整数（其类是`<int>`），而不是日期。假设我们想绘制捐赠率与年份的关系图。
- en: '![Integer year shown with a decimal point.](../Images/cf406ce378ab743be8bbbd295c58ca8f.png)
    Figure A.6: Integer year shown with a decimal point.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![以小数点显示的整数年份。](../Images/cf406ce378ab743be8bbbd295c58ca8f.png) 图A.6：以小数点显示的整数年份。'
- en: '[PRE54]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The decimal point on the x-axis labels is unwanted. We could sort this out cosmetically,
    by giving `scale_x_continuous()` a set of `breaks` and `labels` that represent
    the years as characters. Alternatively, we can change the class of the `year`
    variable. For convenience, we will tell R that the `year` variable should be treated
    as a Date measure, and not an integer. We’ll use a home-cooked function, `int_to_year()`,
    that takes integers and converts them to dates.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: x轴标签上的小数点是不需要的。我们可以通过给`scale_x_continuous()`一组`breaks`和`labels`来代表年份作为字符来解决这个问题，这些`breaks`和`labels`表示年份。或者，我们可以改变`year`变量的类。为了方便，我们将告诉R，`year`变量应该被视为日期度量，而不是整数。我们将使用一个自制的函数`int_to_year()`，它接受整数并将它们转换为日期。
- en: '[PRE55]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the process, today’s day and month are introduced into the year data, but
    that is irrelevant in this case, given that our data are only observed in a yearly
    window to begin with. However, if you wish to specify a generic day and month
    for all the observations, the function allows you to do this.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，今天的日期和月份被引入到年份数据中，但在这个情况下，由于我们的数据最初只在年度窗口中观察到，所以这是无关紧要的。然而，如果你希望为所有观测指定一个通用的日期和月份，该函数允许你这样做。
- en: A.2.1 Write functions for repetitive tasks
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.1 为重复性任务编写函数
- en: If you are working with a data set that you will be making a lot of similar
    plots from, or will need to periodically look at in a way that is repetitive but
    can’t be carried out in a single step once and for all, then the chances are that
    you will start accumulating sequences of code that you find yourself using repeatedly.
    When this happens, the temptation will be to start copying and pasting these sequences
    from one analysis to the next. We can see something of this tendency in the code
    samples for this book. To make the exposition clearer, we have periodically repeated
    chunks of code that differ only in the dependent or independent variable being
    plotted.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理一个数据集，你将从中制作很多类似的图表，或者需要定期以重复的方式查看，但不能一次性完成，那么你可能会开始积累你反复使用的代码序列。当这种情况发生时，你可能会开始从一次分析复制粘贴这些序列到下一次分析。我们可以在本书的代码示例中看到这种趋势的一部分。为了使说明更清晰，我们定期重复了代码块，这些代码块只在绘制的因变量或自变量上有所不同。
- en: You should try to avoid copying and pasting code repeatedly in this way. Instead,
    this is an opportunity to write a function to help you out a little. More or less
    everything in R is accomplished through functions, and it’s not too difficult
    to write your own. This is especially the case when you begin by thinking of functions
    as a way to help you automate some local or smaller task, rather than a means
    of accomplishing some very complex task. R has the resources to help you build
    complex functions and function libraries, like ggplot itself. But we can start
    quite small, with functions that help us manage a particular dataset or data analysis.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该尽量避免以这种方式重复复制粘贴代码。相反，这是一个编写函数来帮助你一点的机会。在R中，几乎一切都可以通过函数完成，编写自己的函数并不太难。这尤其在你开始时将函数视为自动化某些局部或较小任务的方式，而不是完成某些非常复杂任务的手段时更为如此。R有资源帮助你构建复杂的函数和函数库，就像ggplot本身一样。但我们可以从非常小的函数开始，这些函数可以帮助我们管理特定的数据集或数据分析。
- en: 'Remember, functions take *inputs*, perform *actions*, and return *outputs*.
    For example, imagine a function that adds two numbers, `x` and `y`. In use, it
    might look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，函数接受**输入**，执行**操作**，并返回**输出**。例如，想象一个将两个数字`x`和`y`相加的函数。在使用时，它可能看起来像这样：
- en: '[PRE57]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'How do we *create* this function? Remember, everything is an object, so functions
    are just special kinds of object. And everything in R is done via functions. So,
    if we want to make a new function we will use an existing function do to it. In
    R, functions are created with `function()`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何**创建**这个函数？记住，一切都是一个对象，所以函数只是特殊类型的对象。在R中，所有事情都是通过函数完成的。因此，如果我们想要创建一个新的函数，我们将使用现有的函数来完成它。在R中，函数是通过`function()`创建的：
- en: '[PRE59]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You can see that `function()` is a little different from ordinary functions
    in two ways. First, the arguments we give it (here, `x` and `y`) are for the `add_xy`
    function that we are *creating*. Second, immediately after the `function(x, y)`
    statement there’s an opening brace, `{`, followed by a bit of R code that adds
    x and y, and then the closing brace `}`. That’s the content of the function. We
    assign this code to the `add_xy` object, and now we have a function that adds
    two numbers together and returns the result. The `x + y` line inside the parentheses
    is evaluated as if it were typed at the console, assuming you have told it what
    `x` and `y` are.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`function()`在两个方面与普通函数略有不同。首先，我们给它提供的参数（这里，`x`和`y`）是为我们正在**创建**的`add_xy`函数。其次，在`function(x,
    y)`语句之后立即有一个开括号`{`，后面是一段R代码，它将x和y相加，然后是闭括号`}`。这就是函数的内容。我们将此代码分配给`add_xy`对象，现在我们有一个将两个数字相加并返回结果的函数。括号内的`x
    + y`行被评估为如果它在控制台输入，假设你已经告诉了它`x`和`y`是什么。
- en: '[PRE60]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Functions can take many kinds of arguments, and we can also tell them what the
    default value of each argument should be by specifying it inside the `function(...)`
    section. Functions are little programs that have all the power of R at their disposal,
    including standard things like flow-control through `if ... else` statements and
    so on. Here, for instance, is a function that will make a scatter plot for any
    Section in the ASA data, or optionally fit a smoother to the data and plot that
    instead. Defining a function looks a little like calling one, except that we spell
    out the steps inside. We also specify the default arguments.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受许多种类的参数，我们也可以通过在`function(...)`部分指定来告诉它们每个参数的默认值。函数是拥有R所有功能的小程序，包括标准事物，如通过`if
    ... else`语句进行流程控制等。例如，这里有一个函数，可以为ASA数据中的任何部分创建散点图，或者可选地对数据进行平滑处理并绘制该结果。定义一个函数看起来有点像调用一个函数，除了我们要详细说明步骤。我们还会指定默认参数。
- en: '[PRE62]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This function is not very general. Nor is it particularly robust. But for the
    use we want to put it to, it works just fine.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数并不非常通用。它也不特别稳健。但对于我们想要使用的用途，它工作得相当不错。
- en: '[PRE63]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Figure A.7: Using a function to plot your results.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.7：使用函数来绘制结果。
- en: '![Using a function to plot your results.](../Images/2752e9cfed4f3c38227ed449f207ed3c.png)![Using
    a function to plot your results.](../Images/87dcf314f4b6be8bb89c2d3262a68d61.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![使用函数来绘制结果。](../Images/2752e9cfed4f3c38227ed449f207ed3c.png)![使用函数来绘制结果。](../Images/87dcf314f4b6be8bb89c2d3262a68d61.png)'
- en: If we were going to work with this data for long enough, we could make the function
    progressively more general. For example, we can add the special `...` argument
    (which means, roughly, “and any other named arguments”) in a way that allows us
    to pass arguments through to the `geom_smooth()` function in the way we’d expect
    if we were using it directly. With that in place, we can pick the smoothing method
    we want.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要长时间使用这些数据，我们可以使函数逐渐变得更加通用。例如，我们可以添加特殊的`...`参数（这大致意味着“和任何其他命名参数”），这样我们就可以以我们直接使用它时预期的方式将参数传递给`geom_smooth()`函数。有了这个，我们可以选择我们想要的平滑方法。
- en: '[PRE64]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Figure A.8: Our custom function can now pass arguments along to fit different
    smoothers to Section membership data.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.8：我们的自定义函数现在可以将参数传递给适合不同平滑器的章节成员数据。
- en: '![Our custom function can now pass arguments along to fit different smoothers
    to Section membership data.](../Images/e75ff4a3d54ffa56e423e228c0a57c17.png)![Our
    custom function can now pass arguments along to fit different smoothers to Section
    membership data.](../Images/71f7dc2cba63a58337cf365b42199eb6.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![我们的自定义函数现在可以将参数传递给适合不同平滑器的章节成员数据。](../Images/e75ff4a3d54ffa56e423e228c0a57c17.png)![我们的自定义函数现在可以将参数传递给适合不同平滑器的章节成员数据。](../Images/71f7dc2cba63a58337cf365b42199eb6.png)'
- en: A.3 Managing projects and files
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3 管理项目和文件
- en: A.3.1 RMarkdown and knitr
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.1 RMarkdown和knitr
- en: Markdown`en.wikipedia.org/wiki/Markdown` is a loosely-standardized way of writing
    plain text that includes information about the formatting of your document. It
    was originally developed by John Gruber, with input from Aaron Swartz. The aim
    was to make a simple format that could incorporate some structural information
    about the document (such as headings and subheadings, *emphasis*, hyperlinks,
    lists, footnotes, and so on), with minimal loss of readability in plain-text form.
    A plain-text format like HTML is much more extensive and well-defined than Markdown,
    but Markdown was meant to be simple. Over the years, and despite various weaknesses,
    it has become a *de facto* standard. Text editors and note-taking applications
    support it, and tools exist to convert Markdown not just into HTML (its original
    target output format) but many other document types as well. The most powerful
    of these is Pandoc`pandoc.org`, which can get you from markdown to many other
    formats (and *vice versa*). Pandoc is what powers RStudio’s ability to convert
    your notes to HTML, Microsoft Word, and PDF documents.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown`en.wikipedia.org/wiki/Markdown`是一种松散标准化的纯文本编写方式，其中包含有关文档格式的信息。它最初由John
    Gruber开发，Aaron Swartz提供意见。目标是创建一个简单的格式，可以包含一些关于文档的结构信息（如标题和副标题、*强调*、超链接、列表、脚注等），同时尽量减少纯文本形式的可读性损失。与Markdown相比，HTML这样的纯文本格式更为广泛和定义明确，但Markdown旨在简单。多年来，尽管存在各种弱点，它已经成为一种*事实上的*标准。文本编辑器和笔记应用都支持它，并且存在将Markdown转换为不仅仅是HTML（其原始目标输出格式）的许多其他文档类型的工具。其中最强大的是Pandoc`pandoc.org`，它可以将Markdown转换为许多其他格式（以及*反之亦然*）。Pandoc是RStudio能够将您的笔记转换为HTML、Microsoft
    Word和PDF文档的功能背后的动力。
- en: Chapter 1 of this book encourages you to take notes and organize your analysis
    using RMarkdown`rmarkdown.rstudio.com` and (behind the scenes) knitr`yihui.name/knitr`.
    These are R libraries that RStudio makes easy to use. RMarkdown extends Markdown
    by letting you intersperse your notes with chunks of R code. Code chunks can have
    labels and a few options that determine how they will behave when the file is
    processed. After writing your notes and your code, you `knit` the document (Xie,
    2015). That is, you feed your `.Rmd` file to R, which processes the code chunks,
    and produces a new `.md` where the code chunks have been replaced by their output.
    You can then turn that Markdown file into a more readable PDF or HTML document,
    or the Word document that a journal demands you send them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本书第一章鼓励您使用RMarkdown`rmarkdown.rstudio.com`和（幕后）knitr`yihui.name/knitr`来记录笔记和组织分析。这些是RStudio使其易于使用的R库。RMarkdown通过允许您在笔记中穿插R代码块来扩展Markdown。代码块可以有标签和一些选项，这些选项决定了它们在文件处理时的行为。在编写完笔记和代码后，您`knit`文档（Xie，2015）。也就是说，您将`.Rmd`文件输入到R中，R处理代码块，并生成一个新的`.md`文件，其中代码块已被它们的输出所替换。然后您可以将该Markdown文件转换为更易读的PDF或HTML文档，或者期刊要求您发送的Word文档。
- en: Behind the scenes in RStudio, this is all done using the `knitr` and `rmarkdown`
    libraries. The latter provides a `render()` function that takes you from `.Rmd`
    to HTML or PDF in a single step. Conversely, if you just want to extract the code
    you’ve written from the surrounding text, then you “tangle” the file, which results
    in an `.R` file. The strength of this approach is that is makes it much easier
    to document your work properly. There is just one file for both the data analysis
    and the writeup. The output of the analysis is created on the fly, and the code
    to do it is embedded in the paper. If you need to do multiple but identical (or
    very similar) analyses of different bits of data, RMarkdown and `knitr` can make
    generating consistent and reliable reports much easier.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在RStudio的背后，所有这些操作都是通过`knitr`和`rmarkdown`库来完成的。后者提供了一个`render()`函数，它可以将`.Rmd`文件一步转换成HTML或PDF。相反，如果你只想从周围文本中提取你编写的代码，那么你可以“编织”文件，这将生成一个`.R`文件。这种方法的优点是它使得正确地记录你的工作变得容易得多。对于数据分析和撰写报告，只需要一个文件。分析的结果会即时创建，执行它的代码被嵌入到论文中。如果你需要对不同的数据块进行多个但相同（或非常相似）的分析，RMarkdown和`knitr`可以使生成一致且可靠的报告变得容易得多。
- en: Pandoc’s flavor of Markdown is the one used in knitr and RStudio. It allows
    for a wide range of markup, and can handle many of the nuts and bolts of scholarly
    writing, such as complex tables, citations, bibliographies, references, and mathematics.
    In addition to being able to produce documents in various *file* formats, it can
    also produce many different *kinds* of document, from articles and handouts to
    websites and slide decks. RStudio’s RMarkdown website has extensive documentation
    and examples on the ins and outs of RMarkdown’s capabilities, including information
    on customizing it if you wish.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Pandoc的Markdown版本是knitr和RStudio中使用的版本。它支持广泛的标记格式，并能处理学术写作中的许多基本元素，例如复杂表格、引用、书目、参考文献和数学公式。除了能够生成各种*文件格式*的文档外，它还能生成许多不同类型的文档，从文章和讲义到网站和幻灯片。RStudio的RMarkdown网站提供了关于RMarkdown功能详尽的文档和示例，包括如果你希望对其进行自定义的信息。
- en: Writing your notes and papers in a plain text format like this has many advantages.
    It keeps your writing, your code, and your results closer together, and allows
    you to use powerful version control methods to keep track of your work and your
    results. Errors in data analysis often well up out of the gap that typically exists
    between the procedure used to produce a figure or table in a paper and the subsequent
    use of that output later. In the ordinary way of doing things, you have the code
    for your data analysis in one file, the output it produced in another, and the
    text of your paper in a third file. You do the analysis, collect the output and
    copy the relevant results into your paper, often manually reformatting them on
    the way. Each of these transitions introduces the opportunity for error. In particular,
    it is easy for a table of results to get detached from the sequence of steps that
    produced it. Almost everyone who has written a quantitative paper has been confronted
    with the problem of reading an old draft containing results or figures that need
    to be revisited or reproduced (as a result of peer-review, say) but which lack
    any information about the circumstances of their creation. Academic papers take
    a long time to get through the cycle of writing, review, revision, and publication,
    even when you’re working hard the whole time. It is not uncommon to have to return
    to something you did two years previously in order to answer some question or
    other from a reviewer. You do not want to have to do everything over from scratch
    in order to get the right answer. I am not exaggerating when I say that, whatever
    the challenges of replicating the results of someone else’s quantitative analysis,
    after a fairly short period of time authors themselves find it hard to replicate
    their *own* work. *Bit-rot* is the term of art in Computer Science for the seemingly
    inevitable process of decay that overtakes a project just because you left it
    alone on your computer for six months or more.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种纯文本格式（如）编写你的笔记和论文有许多优点。它使你的写作、你的代码和你的结果更接近，并允许你使用强大的版本控制方法来跟踪你的工作和结果。数据分析中的错误通常会在产生论文中图表或表格的流程和随后对该输出的使用之间存在的典型差距中涌现出来。在常规的操作方式中，你的数据分析代码在一个文件中，它产生的输出在另一个文件中，你的论文文本在第三个文件中。你进行数据分析，收集输出并将相关的结果复制到你的论文中，通常在途中手动重新格式化它们。这些过渡中的每一个都引入了出错的机会。特别是，结果表很容易与产生它的步骤序列分离。几乎每个写过定量论文的人都会遇到阅读旧草稿的问题，其中包含需要重新审视或再现的结果或图表（例如，由于同行评审），但缺乏关于它们创建情况的信息。即使你一直在努力工作，学术论文也要经过写作、评审、修订和发表的周期，这需要很长时间。不得不返回两年前做的事情以回答评审员的一些问题并不罕见。你不想从头开始做所有的事情才能得到正确的答案。我说作者在相对较短的时间内发现自己难以复制自己的*自己的*工作，这并不是夸张。在计算机科学中，“位腐”这个术语是指一个项目似乎不可避免地经历的过程，仅仅是因为你把它留在电脑上六个月或更长时间。
- en: For small and medium-sized projects, plain text approaches that rely on RMarkdown
    documents and the tools described here work well. Things become a little more
    complicated as projects get larger. (This is not an intrinsic flaw of plain-text
    methods, by the way. It is true no matter how you choose to organize your project.)
    In general, it is worth trying to keep your notes and analysis in a standardized
    and simple format. The final outputs of projects (such as journal articles or
    books) tend, as they approach completion, to descend into a rush of specific fixes
    and adjustments, all running against the ideal of a fully portable, reproducible
    analysis. It is worth trying to minimize the scope of the inevitable final scramble.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型和中型项目，依赖于RMarkdown文档和这里描述的工具的纯文本方法效果良好。随着项目的扩大，事情会变得稍微复杂一些。（顺便说一句，这并不是纯文本方法的固有缺陷。无论你如何选择组织你的项目，这都是事实。）一般来说，尝试保持你的笔记和分析以标准化和简单的格式存在是值得的。项目最终输出（如期刊文章或书籍）在接近完成时，往往会陷入一系列具体的修复和调整的匆忙中，所有这些都与完全可移植、可重复分析的理想背道而驰。尝试最小化不可避免的最终混乱的范围是值得的。
- en: A.3.2 Project organization
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.2 项目组织
- en: Managing projects is a large topic of its own, and one that people have strong
    opinions about. Your goal should be to make your code and data portable, reproducible,
    and self-contained. In practice that means using a project based approach in R
    Studio. When you start an analysis with some new data, create a new project containing
    the data and the R or RMarkdown code you will be working with. It should then
    be possible, in the ideal case, to move that folder to another computer that also
    has R, RStudio, and any required libraries installed, and successfully re-run
    the contents of the project.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 管理项目是一个很大的主题，而且人们对此有很强的意见。你的目标应该是使你的代码和数据可移植、可重复和自包含。在实践中，这意味着在R Studio中使用基于项目的方法。当你用一些新的数据开始分析时，创建一个包含数据和你要工作的R或RMarkdown代码的新项目。在理想情况下，然后应该可以将该文件夹移动到另一台也安装了R、RStudio和任何所需库的计算机上，并成功重新运行项目的内容。
- en: In practice that means two things. First, even though R is an object-oriented
    language, the only “real”, persistent things in your project should be the raw
    data files you start with, and the code that operates on them. The code is what
    is real. Your code manipulates the data and creates all of the objects and outputs
    you need. It’s possible to save objects in R but in general you should not need
    to do this for everyday analysis.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这意味着两件事。首先，尽管R是一种面向对象的语言，但你的项目中唯一“真实”的、持久的东西应该是你开始时的原始数据文件，以及操作它们的代码。代码才是真实的。你的代码操纵数据并创建你需要的所有对象和输出。在R中保存对象是可能的，但通常你不需要为日常分析做这件事。
- en: 'Second, your code should not refer to any file locations outside of the project
    folder. The project folder should be the “root” or ground floor for the files
    inside it. This means you should not use *absolute* file paths to save or refer
    to data or figures. Instead, use only *relative* paths. A relative path will start
    at the root of the project. So, for example, you should not load data with a command
    like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你的代码不应引用项目文件夹之外任何文件位置。项目文件夹应该是其中文件的“根”或底层。这意味着你不应该使用*绝对*文件路径来保存或引用数据或图表。相反，只使用*相对*路径。相对路径将从项目的根开始。例如，你不应该用这样的命令加载数据：
- en: '[PRE66]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Instead, because you have an R project file started in the `gss` folder you
    can use the `here()` library to specify a relative path, like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，因为你已经在`gss`文件夹中启动了一个R项目文件，你可以使用`here()`库来指定相对路径，如下所示：
- en: '[PRE67]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: While you could type the relative paths out yourself, using `here()` has the
    advantage that it will work if, for example, you use Mac OS and you send your
    project to someone working on Windows. The same rule goes for saving your work,
    as we saw at the end of Chapter @(sec:makeplot), when you save individual plots
    as PDF or PNG files.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以自己输入相对路径，但使用`here()`的优势在于，例如，如果你使用Mac OS并将你的项目发送给使用Windows的人，它仍然会工作。同样的规则也适用于保存你的工作，正如我们在第
    @(sec:makeplot) 章节末尾所看到的，当你将单个图表保存为PDF或PNG文件时。
- en: '![Folder organization for a simple project.](../Images/121f0a5c0a13ac2f29b9f15a9cd8e0b4.png)
    Figure A.9: Folder organization for a simple project.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![简单项目的文件夹组织](../Images/121f0a5c0a13ac2f29b9f15a9cd8e0b4.png) 图A.9：简单项目的文件夹组织。'
- en: Within your project folder, a little organization goes a long way. You should
    get in the habit of keeping different parts of the project in different sub-folders
    of your working directory. More complex projects may have a more complex structure,
    but you can go a long way with some simple organization. RMarkdown files can be
    in the top level of your working directory, with separate sub-folders called `data/`
    (for your CSV files), one for `figures/` (that you might save) and perhaps one
    called `docs/` for information about your project or data files files. Rstudio
    can help with organization as well through its project management features.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目文件夹内，一点组织就能走得很远。你应该养成习惯，将项目的不同部分保存在工作目录的不同子文件夹中。更复杂的项目可能有一个更复杂的结构，但一些简单的组织就能走得很远。RMarkdown文件可以放在工作目录的顶层，有单独的子文件夹叫做`data/`（用于你的CSV文件），一个用于`figures/`（你可能保存的），也许还有一个叫做`docs/`的用于你的项目或数据文件信息的文件夹。RStudio也可以通过其项目管理功能帮助你进行组织。
- en: Keeping your project organized just a little bit will prevent you from ending
    up with huge numbers of files of different kinds all sitting at the top of your
    working directory.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 只需稍微组织一下你的项目，就可以防止你最终在工作的目录顶部拥有大量不同类型的文件。
- en: A.4 Some features of this book
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.4 本书的一些特性
- en: A.4.1 Preparing the county-level maps
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.1 准备县级地图
- en: The U.S. county-level maps in the `socviz` library were prepared using shapefiles
    from the U.S. Census Bureau that were converted to GeoJSON format by Eric Celeste.`eric.clst.org/Stuff/USGeoJSON`
    The code to prepare the imported shapefile was written by Bob Rudis, and draws
    on the `rgdal` library to do the heavy lifting of importing the shapefile and
    transforming the projection. Bob’s code extracts the (county-identifying) rownames
    from the imported spatial data frame, and then moves Alaska and Hawaii to new
    locations in the bottom left of the map area, so that we can map all fifty states
    instead of just the lower forty eight.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`socviz`库中的美国县级地图是使用美国人口普查局的shapefiles准备的，这些shapefiles由Eric Celeste转换为GeoJSON格式。准备导入的shapefile的代码是由Bob
    Rudis编写的，并利用`rgdal`库进行导入shapefile和转换投影的重型工作。Bob的代码从导入的空间数据框中提取（县标识）行名，然后将阿拉斯加和夏威夷移动到地图区域的左下角，这样我们就可以绘制所有五十个州，而不仅仅是下四十八个州。'
- en: First we read in the map file, set the projection, and set up an identifying
    variable we can work with later on to merge in data. The call to `CRS()` is a
    single long line of text conforming to a technical GIS specification defining
    the projection and other details that the map is encoded in. Long lines of code
    are conventionally indicated by the backslash charater, “`\`”, when we have to
    artificially break them on the page. Do not type the backslash if you write out
    this code yourself. We assume the mapfile is named `gz_2010_us_050_00_5m.json`
    and is in the `data/geojson` subfolder of the project directory.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们读取地图文件，设置投影，并设置一个标识变量，我们可以在以后合并数据时使用。对`CRS()`的调用是一行长文本，符合技术GIS规范，定义了地图编码的投影和其他细节。当我们需要在页面上人工断行时，通常使用反斜杠字符“`\`”来表示长代码行。如果你自己编写这段代码，请不要输入反斜杠。我们假设地图文件名为`gz_2010_us_050_00_5m.json`，位于项目目录的`data/geojson`子文件夹中。
- en: '[PRE68]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: With the file imported, we then extract, rotate, shrink, and move Alaska, resetting
    the projection in the process. We also move Hawaii. The areas are identified by
    their State FIPS codes. We remove the old states and put the new ones back in,
    and remove Puerto Rico as our examples lack data for this region. If you have
    data for the area, you can move it between Texas and Florida.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 文件导入后，我们接着提取、旋转、缩小并移动阿拉斯加，在这个过程中重置投影。我们也移动夏威夷。这些区域通过它们的州FIPS代码来识别。我们移除旧州，将新州放回原位，并移除波多黎各，因为我们的示例缺乏该地区的数据。如果你有该地区的数据，你可以将它移动到德克萨斯州和佛罗里达州之间。
- en: '[PRE69]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Finally, we tidy the spatial object into a data frame that ggplot can use, and
    clean up the `id` label by stripping out a prefix from the string.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将空间对象整理成ggplot可以使用的数据框，并通过从字符串中删除前缀来清理`id`标签。
- en: '[PRE70]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: AtFor more detail and code for the merge, see `github.com/kjhealy/us-county`
    this point the `county_map` object is ready to be merged with a table of FIPS-coded
    US county data using either `merge()` or `left_join()`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在此点，`county_map`对象已准备好与FIPS编码的美国县级数据表合并，可以使用`merge()`或`left_join()`。
- en: A.4.2 This book’s plot theme, and its map theme
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.2本书的绘图主题及其地图主题
- en: 'The ggplot theme used in this book is derived principally from the work (again)
    of Bob Rudis. His `hrbrthemes` package provides `theme_ipsum()`, a compact theme
    that can be used with the Arial typeface or, in a variant, the freely available
    Roboto Condensed typeface. The main difference between the `theme_book()` used
    here and Rudis’s `theme_ipsum()` is the choice of typeface. The `hrbrthemes` package
    can be installed from GitHub in the usual way:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的ggplot主题主要来源于Bob Rudis的工作（再次）。他的`hrbrthemes`包提供了`theme_ipsum()`，这是一个紧凑的主题，可以与Arial字体一起使用，或者在一个变体中，可以免费使用的Roboto
    Condensed字体。这里使用的`theme_book()`与Rudis的`theme_ipsum()`之间的主要区别是字体的选择。`hrbrthemes`包可以通过GitHub以常规方式安装：
- en: '[PRE71]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The`github.com/kjhealy/myriad` book theme is also available on GitHub. This
    package does not include the font files themselves. These are available from Adobe,
    who make the typeface.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/kjhealy/myriad`的书籍主题也可在GitHub上找到。这个包不包括字体文件本身。这些文件可以从Adobe获得，他们制作了这种字体。'
- en: 'When drawing maps we also used a `theme_map()` function. This theme begins
    with the built-in `theme_bw()` and turns off most of the guide, scale, panel content
    that is not needed when presenting a map. It is available through the `socviz`
    library. The code looks like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当绘制地图时，我们也使用了`theme_map()`函数。这个主题从内置的`theme_bw()`开始，关闭了在展示地图时不需要的大部分指南、比例尺和面板内容。它可以通过`socviz`库获得。代码看起来是这样的：
- en: '[PRE72]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Themes are functions. Creating a theme means writing a function with a sequence
    of instructions about what thematic elements to modify, and how. We give it a
    default `base_size` argument and an empty `base_family` argument (for the font
    family). The `%+replace%` operator in the code is new to us. This is a convenience
    operator defined by ggplot and used for updating theme elements in bulk. Throughout
    the book we saw repeated use of the `+` operator to incrementally add to or tweak
    the content of a theme, as when we would do `+ theme(legend.position = "top")`.
    Using `+` added the instruction to the theme, adjusting whatever was specified
    and leaving everything else as it was. The `%+replace%` operator does something
    similar, but it has a stronger effect. We begin with `theme_bw()` and then use
    a `theme()` statement to add new content, as usual. The `%+replace%` operator
    replaces the entire element specified, rather than adding to it. Any element not
    specified in the `theme()` statement will be deleted from the new theme. So this
    is a way to create themes by both starting from existing ones, specifying new
    elements, and deleting anything not explicitly mentioned. See the documentation
    for `theme_get()` for more details. In the function here, you can see each of
    the thematic elements that are “switched off” using the `element_blank()` function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 主题是函数。创建一个主题意味着编写一个包含一系列关于如何修改主题元素及其方式的指令的函数。我们给它一个默认的 `base_size` 参数和一个空的 `base_family`
    参数（用于字体家族）。代码中的 `%+replace%` 运算符对我们来说是新的。这是一个由 ggplot 定义的便利运算符，用于批量更新主题元素。在本书中，我们看到了
    `+` 运算符的重复使用，用于递增地添加或调整主题的内容，就像我们做 `+ theme(legend.position = "top")` 一样。使用 `+`
    向主题添加了指令，调整了指定的内容，而其他内容保持不变。`%+replace%` 运算符做的是类似的事情，但它有更强的效果。我们从 `theme_bw()`
    开始，然后使用 `theme()` 语句添加新内容，就像通常一样。`%+replace%` 运算符替换了指定的整个元素，而不是添加到它。在 `theme()`
    语句中没有指定的任何元素都将从新主题中删除。因此，这是一种通过从现有主题开始、指定新元素和删除未明确提及的内容来创建主题的方法。有关 `theme_get()`
    的更多详细信息，请参阅文档。在下面的函数中，您可以看到使用 `element_blank()` 函数“关闭”的每个主题元素。
- en: A.1 A little more about R
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 关于 R 的更多了解
- en: A.1.1 How to read an R help page
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.1 如何阅读 R 帮助页面
- en: Functions, datasets, and other built-in objects in R are documented in its help
    system. You can search or browse this documentation via the “Help” tab in RStudio’s
    lower right-hand window. The quality of R’s help pages varies somewhat. They tend
    to be on the terse side. However, they all have essentially the same structure
    and it is useful to know how to read them. Figure [A.1](appendix.html#fig:ch-09-help)
    provides an overview of what to look for. Remember, functions take inputs, perform
    actions, and return outputs. Something goes in, it gets worked on, and then something
    comes out. That means you want to know what the function *requires*, what it *does*,
    and what it *returns*. What it requires is shown in the *Usage* and *Arguments*
    sections of the help page. The names of all the required and optional arguments
    are given by name and in the order the function expects them. Some arguments have
    default values. In the case of the `mean()` function the argument `na.rm` is set
    to `FALSE` by default. These will be shown in the *Usage* section. If a named
    argument has no default, you will have to give it a value. Depending on what the
    argument is, this might be a logical value, a number, a dataset, or any other
    object.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的函数、数据集和其他内置对象在它的帮助系统中进行了文档说明。您可以通过 RStudio 右下角的“帮助”标签搜索或浏览这些文档。R 的帮助页面质量参差不齐。它们往往比较简略。然而，它们都具有基本相同的结构，了解如何阅读它们是有用的。图
    [A.1](appendix.html#fig:ch-09-help) 提供了要查找内容的概述。记住，函数接受输入，执行操作，并返回输出。有东西进去，被处理，然后有东西出来。这意味着您需要知道函数*需要什么*，*做什么*，以及*返回什么*。它需要的内容在帮助页面的“用法”和“参数”部分显示。所有必需和可选参数的名称按函数期望的顺序给出。一些参数有默认值。对于
    `mean()` 函数，参数 `na.rm` 默认设置为 `FALSE`。这些将在“用法”部分中显示。如果命名参数没有默认值，您必须为其提供一个值。根据参数的类型，这可能是一个逻辑值、一个数字、一个数据集或任何其他对象。
- en: '![The structure of an R help page.](../Images/6ce9b70c44f6aef3373d3f1779e4bb78.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![R 帮助页面的结构。](../Images/6ce9b70c44f6aef3373d3f1779e4bb78.png)'
- en: 'Figure A.1: The structure of an R help page.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.1：R 帮助页面的结构。
- en: The other part to look at closely is the *Value* section, which tells you what
    the function returns once it has done its calculation. Again, depending on what
    the function is, this might simply be a single number or other short bit of output.
    But it could also be something as complex as a ggplot figure or a model object
    consisting of many separate parts organized as a list.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要仔细查看的部分是 *Value* 部分，它告诉你在函数完成计算后返回了什么。同样，根据函数的不同，这可能是单个数字或其他简短的输出。但它也可能是像
    ggplot 图形或由多个单独部分组成的列表模型对象这样复杂的东西。
- en: Well-documented packages will often have *Demos* and *Vignettes* attached to
    them. These are meant to describe the package as a whole, rather than specific
    functions. A good package vignette will often have one or more fully-worked examples
    together with a discussion describing how the package works and what it can do.
    To see if there any package vignettes, click the link at the bottom of the function’s
    help page to be taken to the package index. Any available demos, vignettes, or
    other general help will be listed at the top.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 详尽说明的软件包通常会附带 *Demos* 和 *Vignettes*。这些内容旨在整体描述软件包，而不是具体的功能。一个好的软件包 Vignette
    通常会包含一个或多个完整工作的示例，以及一个讨论，描述软件包的工作原理和功能。要查看是否有软件包 Vignettes，请点击函数帮助页面底部的链接，以跳转到软件包索引。任何可用的演示、Vignettes
    或其他一般性帮助信息将列在顶部。
- en: A.1.2 The basics of accessing and selecting things
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.2 访问和选择事物的基本原理
- en: Generally speaking, the tidyverse’s preferred methods for data subsetting, filtering,
    slicing and selecting will keep you away from the underlying mechanics of selecting
    and extracting elements of vectors, matrices, or tables of data. Carrying out
    these operations through functions like `select()`, `filter()`, `subset()`, and
    `merge()` is generally safer and more reliable than accessing elements directly.
    However, it is worth knowing the basics of these operations. Sometimes accessing
    elements directly is the most convenient thing to do. More importantly, we may
    use these techniques in small ways in our code with some regularity. Here we very
    briefly introduce some of R’s selection operators for vectors, arrays, and tables.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，tidyverse 优先的数据子集、过滤、切片和选择方法将使你远离选择和提取向量、矩阵或数据表元素的基本机制。通过 `select()`、`filter()`、`subset()`
    和 `merge()` 等函数执行这些操作通常比直接访问元素更安全、更可靠。然而，了解这些操作的基本原理是值得的。有时直接访问元素可能是最方便的做法。更重要的是，我们可能在代码中以某种规律性地以小规模使用这些技术。在这里，我们简要介绍
    R 的向量、数组和表的选择运算符。
- en: Consider the `my_numbers` and `your_numbers` vectors again.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑 `my_numbers` 和 `your_numbers` 向量。
- en: '[PRE73]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To access any particular element in `my_numbers`, we use square brackets. Square
    brackets are not like the parentheses after functions. They are used to pick out
    an element indexed by its position:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 `my_numbers` 中的任何特定元素，我们使用方括号。方括号与函数后面的圆括号不同。它们用于选择由其位置索引的元素：
- en: '[PRE74]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Putting the number *n* inside the brackets will give us (or “return”) the *n*th
    element in the vector, assuming there is one. To access a *sequence* of elements
    within a vector we can do this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字 *n* 放入方括号内将给我们（或“返回”）向量中的第 *n* 个元素，假设存在的话。要访问向量中元素的一个 *序列*，我们可以这样做：
- en: '[PRE78]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This shorthand notation tells R to count from the 2nd to the 4th element, inclusive.
    We are not restricted to selecting contiguous elements, either. We can make use
    of our `c()` function again:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简写符号告诉 R 从第 2 个元素开始计数到第 4 个元素（包括）。我们也不受限于选择连续的元素。我们可以再次使用我们的 `c()` 函数：
- en: '[PRE80]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'R evaluates the expression `c(2,4)` first, and then extracts just the second
    and the fourth element from `my_numbers`, ignoring the others. You might wonder
    why we didn’t just write `my_numbers[2,3]` directly. The answer is that this notation
    is used for objects arrayed in two dimensions (i.e. something with rows and columns),
    like matrices, data frames, or tibbles. We can make a two-dimensional object by
    creating two different vectors with the `c()` function and using the `tibble()`
    function to collect them together:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: R 首先评估表达式 `c(2,4)`，然后只从 `my_numbers` 中提取第二个和第四个元素，忽略其他元素。你可能想知道为什么我们直接写 `my_numbers[2,3]`。答案是，这种表示法用于二维排列的对象（即具有行和列的对象），如矩阵、数据框或
    tibbles。我们可以通过使用 `c()` 函数创建两个不同的向量，并使用 `tibble()` 函数将它们收集在一起来创建一个二维对象：
- en: '[PRE82]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: WeIn these chunks of code you will see some explanatory text set off by the
    hash symbol, `#`. In R’s syntax, the hash symbol is used to designate a comment.
    On any line of code, text that appears after a `#` symbol will be ignored by R’s
    interpreter. It won’t be evaluated and it won’t trigger a syntax error. index
    data frames, tibbles, and other arrays by row first, and then by column. Arrays
    may also have more than two dimensions.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些代码块中，您将看到一些由井号符号`#`分隔的解释性文本。在R的语法中，井号符号用于指定注释。在任何代码行中，出现在`#`符号之后的文本将被R的解释器忽略。它不会被评估，也不会触发语法错误。我们首先按行然后按列索引数据框、tibble和其他数组。数组也可能有超过两个维度。
- en: '[PRE86]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The columns in our tibble have names. We can select elements using them, too.
    We do this by putting the name of the column in quotes where we previously put
    the index number of the column:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们tibble中的列有名称。我们也可以通过它们来选择元素。我们这样做是通过在之前放置列索引号的位置放置列的名称：
- en: '[PRE90]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: If we want to get all the elements of a particular column, we can leave out
    the row index. This will mean all the rows will be included for whichever column
    we select.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要获取特定列的所有元素，我们可以省略行索引。这意味着将包括我们选择的任何列的所有行。
- en: '[PRE98]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We can do this the other way around, too, selecting a particular row and showing
    all columns:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以反过来操作，选择特定的行并显示所有列：
- en: '[PRE100]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'A better way of accessing particular columns in a data frame is via the `$`
    operator, which can be used to extract components of various sorts of object.
    This way we append the name of the column we want to the name of the object it
    belongs to:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据框中访问特定列的更好方法是使用`$`运算符，它可以用来提取各种类型对象的组件。这样，我们将我们想要选择的列的名称附加到它所属的对象的名称上：
- en: '[PRE102]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Elements of many other objects can be extracted in this way, too, including
    nested objects.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他对象的元素也可以用这种方式提取，包括嵌套对象。
- en: '[PRE104]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Finally, in the case of data frames the `$` operator also lets us add new columns
    to the object. For example, we can add the first two columns together, row by
    row. To create a column in this way, we put the `$` and the name of the new column
    on the left-hand side of the assignment.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在数据框的情况下，`$`运算符还允许我们向对象添加新列。例如，我们可以将前两列逐行相加。要以这种方式创建列，我们在赋值表达式的左侧放置`$`和新的列名。
- en: '[PRE110]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: In this book we do not generally access data via `[` or `$`. It is particularly
    bad practice to access elements by their index number only, as opposed to using
    names. In both cases, and especially the latter, it is too easy to make a mistake
    and choose the wrong columns or rows. In addition, if our table changes shape
    later on (e.g. due to the addition of new original data) then any absolute reference
    to the position of columns (rather than to their names) is very likely to break.
    Still, we do use the `c()` function for small tasks quite regularly, so it’s worth
    understanding how it can be used to pick out elements from vectors.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们通常不通过`[`或`$`来访问数据。仅通过索引号访问元素，而不是使用名称，这是一种特别不好的做法。在两种情况下，尤其是后者，很容易出错并选择错误的列或行。此外，如果我们的表格稍后改变了形状（例如，由于添加了新的原始数据），那么任何对列位置的绝对引用（而不是名称）很可能都会失效。尽管如此，我们仍然非常频繁地使用`c()`函数来完成小任务，因此了解它如何用于从向量中挑选元素是值得的。
- en: A.1.3 Tidy data
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.3 整洁数据
- en: Working with R and ggplot is much easier if the data you use is in the right
    shape. Ggplot wants your data to be *tidy*. For a more thorough introduction to
    the idea of tidy data, see Chapters 5 and 12 of Wickham & Grolemund (2016). To
    get a sense of what a tidy dataset looks like in R, we will follow the discussion
    in Wickham (2014). In a tidy dataset,
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用的数据形状正确，使用R和ggplot会更容易。ggplot希望你的数据是*整洁的*。要更深入地了解整洁数据的概念，请参阅Wickham & Grolemund
    (2016)的第5章和第12章。为了了解R中整洁数据集的样子，我们将遵循Wickham (2014)中的讨论。在整洁数据集中，
- en: '*Each variable is a column.*'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*每个变量都是一个列。*'
- en: '*Each observation is a row.*'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*每个观测值是一行。*'
- en: '*Each type of observational unit forms a table.*'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*每种观测单位类型构成一个表。*'
- en: For most of your data analysis, the first two points are the most important.
    This third one might be a little unfamiliar. It is a feature of “normalized” data
    from the world of databases, where the goal is to represent data in a series of
    related tables with minimal duplication (Codd, 1990). Data analysis more usually
    works with a single large table of data, often with considerable duplication of
    some variables down the rows.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的数据分析的大部分时间里，前两点是最重要的。第三点可能有点不熟悉。这是数据库世界中“标准化”数据的一个特征，其目标是使用一系列相关的表来表示数据，以最小化重复（Codd，1990）。数据分析通常使用一个大型数据表，通常在行中有相当多的变量重复。
- en: Data presented in summary tables is often not “tidy” as defined here. When structuring
    our data we need to be clear about how our data is arranged. If your data is not
    tidily arranged, the chances are good that you will have more difficulty, and
    maybe a *lot* more difficulty, getting ggplot to draw the figure you want.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以总结表形式呈现的数据通常不符合这里定义的“整洁”。在构建我们的数据时，我们需要清楚我们的数据是如何排列的。如果你的数据没有整洁地排列，那么你可能会遇到更多困难，也许会有很多困难，才能让ggplot绘制出你想要的图表。
- en: 'Table A.1: Some untidy data.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 表A.1：一些杂乱的数据。
- en: '| name | treatmenta | treatmentb |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 处理a | 处理b |'
- en: '| :-- | --: | --: |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| :-- | --: | --: |'
- en: '| John Smith | NA | 18 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 约翰·史密斯 | NA | 18 |'
- en: '| Jane Doe | 4 | 1 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 简·多伊 | 4 | 1 |'
- en: '| Mary Johnson | 6 | 7 |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 玛丽·约翰逊 | 6 | 7 |'
- en: 'Table A.2: The same data, still untidy, but in a different way.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 表A.2：相同的数据，仍然杂乱，但以不同的方式。
- en: '| treatment | John Smith | Jane Doe | Mary Johnson |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 处理 | 约翰·史密斯 | 简·多伊 | 玛丽·约翰逊 |'
- en: '| :-- | --: | --: | --: |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| :-- | --: | --: | --: |'
- en: '| a | NA | 4 | 6 |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| a | NA | 4 | 6 |'
- en: '| b | 18 | 1 | 7 |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| b | 18 | 1 | 7 |'
- en: For example consider Table [A.1](appendix.html#tab:ch-09-preg1) and Table [A.2](appendix.html#tab:ch-09-preg2)
    from Wickham’s discussion. They present the same data in different ways, but each
    would cause trouble if we tried to work with it in ggplot to make a graph. Table
    [A.3](appendix.html#tab:ch-09-preg3) shows the same data once again, this time
    in a tidied form.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑Wickham的讨论中的表[A.1](appendix.html#tab:ch-09-preg1)和表[A.2](appendix.html#tab:ch-09-preg2)。它们以不同的方式呈现相同的数据，但如果我们尝试在ggplot中使用它来制作图表，每个都会造成麻烦。表[A.3](appendix.html#tab:ch-09-preg3)再次显示了相同的数据，这次以整理过的形式呈现。
- en: 'Hadley Wickham notes five main ways tables of data tend not to be tidy:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Hadley Wickham指出，数据表通常不整洁的五个主要原因：
- en: '*Column headers are values, not variable names*.'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*列标题是值，而不是变量名*。'
- en: '*Multiple variables are stored in one column*.'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*多个变量存储在同一列中*。'
- en: '*Variables are stored in both rows and columns*.'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*变量存储在行和列中*。'
- en: '*Multiple types of observational units are stored in the same table*.'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*同一张表中存储了多种类型的观测单位*。'
- en: '*A single observational unit is stored in multiple tables*.'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*单个观测单位存储在多个表中*。'
- en: 'Table A.3: Tidied data. Every variable a column, every observation a row.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 表A.3：整理后的数据。每个变量对应一列，每个观测值对应一行。
- en: '| name | treatment | n |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 处理 | 数量 |'
- en: '| :-- | :-- | --: |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| :-- | :-- | --: |'
- en: '| Jane Doe | a | 4 |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 简·多伊 | a | 4 |'
- en: '| Jane Doe | b | 1 |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 简·多伊 | b | 1 |'
- en: '| John Smith | a | NA |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 约翰·史密斯 | a | NA |'
- en: '| John Smith | b | 18 |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 约翰·史密斯 | b | 18 |'
- en: '| Mary Johnson | a | 6 |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 玛丽·约翰逊 | a | 6 |'
- en: '| Mary Johnson | b | 7 |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 玛丽·约翰逊 | b | 7 |'
- en: Data comes in an untidy form all the time, often for the good reason that it
    can be presented that way using much less space, or with far less repetition of
    labels and row elements. Figure [A.2](appendix.html#fig:ch-09-census-untidy) shows
    a the first few rows of a table of U.S. Census Bureau data about educational attainment
    in the United States. To begin with, it’s organized as a series of sub-tables
    down the spreadsheet, broken out by age and sex. Second, the underlying variable
    of interest, “Years of School Completed” is stored across several columns, with
    an additional variable (level of schooling) included across the columns also.
    It is not too hard to get the table into a slightly more regular format by eliminating
    the blank rows, and explicitly naming the sub-table rows. One can do this manually
    and get to the point where it can be read in as an Excel or CSV file. This is
    not ideal, as manually cleaning data runs against the commitment to do as much
    as possible programmatically.`readxl.tidyverse.org` We can automate the process
    somewhat. The tidyverse comes with a `readxl` package that tries to ease the pain
    a little.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 数据总是以杂乱的形式出现，通常是因为以这种方式展示可以节省大量空间，或者减少标签和行元素的重复。图 [A.2](appendix.html#fig:ch-09-census-untidy)
    展示了美国人口普查局关于美国教育成就数据的表格的前几行。起初，它被组织成一系列沿工作表下方的子表，按年龄和性别划分。其次，感兴趣的底层变量“完成学年的年数”存储在几个列中，同时在列中也包含了一个额外的变量（教育水平）。通过消除空白行并明确命名子表行，可以不太困难地将表格转换成稍微更规范的格式。手动清理数据可以达到将其作为Excel或CSV文件读取的程度。这不是理想的做法，因为手动清理数据与尽可能编程化处理的承诺相违背。`readxl.tidyverse.org`
    我们可以某种程度上自动化这个过程。tidyverse 包含一个 `readxl` 包，试图稍微减轻一些痛苦。
- en: 'Figure A.2: Untidy data from the Census.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.2：来自人口普查的杂乱数据。
- en: '![Untidy data from the Census.](../Images/c7abcd15676ccf4d2f644bebb6b0dfab.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![来自人口普查的杂乱数据](../Images/c7abcd15676ccf4d2f644bebb6b0dfab.png)'
- en: '[PRE112]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The tidyverse has several tools to help you get the rest of the way in converting
    your data from an untidy to a tidy state. These can mostly be found in the `tidyr`
    and `dplyr` libraries. The former provides functions for converting, for example,
    wide-format data to long-format data, as well as assisting with the business of
    splitting and combining variables that are untidily stored. The latter has a tools
    that allow tidy tables to be further filtered, sliced, and analyzed at different
    grouping levels, as we have seen throughout this book.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: tidyverse 有几个工具可以帮助您将数据从杂乱状态转换为整洁状态。这些工具大多可以在 `tidyr` 和 `dplyr` 库中找到。前者提供将宽格式数据转换为长格式数据等功能，以及协助处理杂乱存储的变量拆分和合并的业务。后者有工具允许在本书中看到的各个分组级别进一步过滤、切片和分析整洁表。
- en: With our `edu` object, we can use the `gather()` function to transform the schooling
    variables into a *key-value* arrangement. The key is the underlying variable,
    and the value is the value it takes for that observation. We create a new object,
    `edu_t` in this way.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的 `edu` 对象，我们可以通过 `gather()` 函数将学校变量转换成 *键值* 排列。键是基础变量，值是它在该观测中的取值。我们以此方式创建了一个新的对象，`edu_t`。
- en: '[PRE113]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The educational categories previously spread over the columns have been gathered
    into two new columns. The `school` variable is the *key* column. It contains all
    of the education categories that were previously given across the column headers,
    from 0-4 years of elementary school to four or more years of college. They are
    now stacked up on top of each other in the rows. The `freq` variable is the *value*
    column, and contains the unique value of `schooling` for each level of that variable.
    Once our data is in this long-form shape, it is ready for easy use with ggplot
    and related tidyverse tools.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 之前分散在列中的教育类别已被收集到两个新的列中。`school` 变量是 *键* 列。它包含之前在列标题中给出的所有教育类别，从0-4年的小学教育到四年或更长的大学教育。它们现在堆叠在行上。`freq`
    变量是 *值* 列，包含该变量每个级别的独特 `schooling` 值。一旦我们的数据以这种长格式形状存在，就可以轻松地使用 ggplot 和相关的 tidyverse
    工具。
- en: A.1.1 How to read an R help page
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.1 如何阅读 R 的帮助页面
- en: Functions, datasets, and other built-in objects in R are documented in its help
    system. You can search or browse this documentation via the “Help” tab in RStudio’s
    lower right-hand window. The quality of R’s help pages varies somewhat. They tend
    to be on the terse side. However, they all have essentially the same structure
    and it is useful to know how to read them. Figure [A.1](appendix.html#fig:ch-09-help)
    provides an overview of what to look for. Remember, functions take inputs, perform
    actions, and return outputs. Something goes in, it gets worked on, and then something
    comes out. That means you want to know what the function *requires*, what it *does*,
    and what it *returns*. What it requires is shown in the *Usage* and *Arguments*
    sections of the help page. The names of all the required and optional arguments
    are given by name and in the order the function expects them. Some arguments have
    default values. In the case of the `mean()` function the argument `na.rm` is set
    to `FALSE` by default. These will be shown in the *Usage* section. If a named
    argument has no default, you will have to give it a value. Depending on what the
    argument is, this might be a logical value, a number, a dataset, or any other
    object.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: R中的函数、数据集和其他内置对象在其帮助系统中进行了文档记录。您可以通过RStudio右下角的“帮助”选项卡搜索或浏览此文档。R的帮助页面质量略有不同。它们往往比较简短。然而，它们都具有基本相同的结构，了解如何阅读它们是有用的。图A.1提供了要查找内容的概述。记住，函数接受输入，执行操作，并返回输出。有东西进去，被处理，然后有东西出来。这意味着你想要知道函数*需要什么*，*做什么*，以及*返回什么*。它需要的内容在帮助页面的*用法*和*参数*部分显示。所有必需和可选参数的名称按函数期望的顺序给出。一些参数有默认值。对于`mean()`函数，参数`na.rm`默认设置为`FALSE`。这些将在*用法*部分显示。如果命名参数没有默认值，你必须提供它的值。根据参数的不同，这可能是逻辑值、数字、数据集或任何其他对象。
- en: '![The structure of an R help page.](../Images/6ce9b70c44f6aef3373d3f1779e4bb78.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![R帮助页面的结构](../Images/6ce9b70c44f6aef3373d3f1779e4bb78.png)'
- en: 'Figure A.1: The structure of an R help page.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.1：R帮助页面的结构。
- en: The other part to look at closely is the *Value* section, which tells you what
    the function returns once it has done its calculation. Again, depending on what
    the function is, this might simply be a single number or other short bit of output.
    But it could also be something as complex as a ggplot figure or a model object
    consisting of many separate parts organized as a list.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要仔细查看的部分是*值*部分，它告诉你函数完成计算后返回的内容。同样，根据函数的不同，这可能是单个数字或其他简短的输出。但它也可能是像ggplot图或由多个单独部分组成的列表模型对象这样复杂的东西。
- en: Well-documented packages will often have *Demos* and *Vignettes* attached to
    them. These are meant to describe the package as a whole, rather than specific
    functions. A good package vignette will often have one or more fully-worked examples
    together with a discussion describing how the package works and what it can do.
    To see if there any package vignettes, click the link at the bottom of the function’s
    help page to be taken to the package index. Any available demos, vignettes, or
    other general help will be listed at the top.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 记录良好的包通常会附有*演示*和*示例*。这些旨在描述整个包，而不是特定的函数。一个好的包示例通常会有一个或多个完整工作的示例，以及一个讨论，描述包的工作方式和它能做什么。要查看是否有包示例，请点击函数帮助页面底部的链接，进入包索引。任何可用的演示、示例或其他一般性帮助都将列在顶部。
- en: A.1.2 The basics of accessing and selecting things
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.2 访问和选择事物的基本
- en: Generally speaking, the tidyverse’s preferred methods for data subsetting, filtering,
    slicing and selecting will keep you away from the underlying mechanics of selecting
    and extracting elements of vectors, matrices, or tables of data. Carrying out
    these operations through functions like `select()`, `filter()`, `subset()`, and
    `merge()` is generally safer and more reliable than accessing elements directly.
    However, it is worth knowing the basics of these operations. Sometimes accessing
    elements directly is the most convenient thing to do. More importantly, we may
    use these techniques in small ways in our code with some regularity. Here we very
    briefly introduce some of R’s selection operators for vectors, arrays, and tables.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，tidyverse推荐的用于数据子集、过滤、切片和选择的方法会让你远离选择和提取向量、矩阵或数据表元素的基本机制。通过`select()`、`filter()`、`subset()`和`merge()`等函数执行这些操作通常比直接访问元素更安全、更可靠。然而，了解这些操作的基本知识是值得的。有时直接访问元素是最方便的做法。更重要的是，我们可能经常在我们的代码中以小的方式使用这些技术。在这里，我们简要介绍R中用于向量、数组和表的某些选择运算符。
- en: Consider the `my_numbers` and `your_numbers` vectors again.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑`my_numbers`和`your_numbers`向量。
- en: '[PRE117]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'To access any particular element in `my_numbers`, we use square brackets. Square
    brackets are not like the parentheses after functions. They are used to pick out
    an element indexed by its position:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问`my_numbers`中的任何特定元素，我们使用方括号。方括号不像函数后面的括号。它们用于选择由其位置索引的元素：
- en: '[PRE118]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Putting the number *n* inside the brackets will give us (or “return”) the *n*th
    element in the vector, assuming there is one. To access a *sequence* of elements
    within a vector we can do this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号内放置数字*n*将给我们（或“返回”）向量中的第*n*个元素，假设有一个的话。要访问向量中元素的一个*序列*，我们可以这样做：
- en: '[PRE122]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'This shorthand notation tells R to count from the 2nd to the 4th element, inclusive.
    We are not restricted to selecting contiguous elements, either. We can make use
    of our `c()` function again:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简写表示法告诉R从第2个元素开始计数，到第4个元素（包括），我们不受选择连续元素的限制。我们还可以再次使用我们的`c()`函数：
- en: '[PRE124]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'R evaluates the expression `c(2,4)` first, and then extracts just the second
    and the fourth element from `my_numbers`, ignoring the others. You might wonder
    why we didn’t just write `my_numbers[2,3]` directly. The answer is that this notation
    is used for objects arrayed in two dimensions (i.e. something with rows and columns),
    like matrices, data frames, or tibbles. We can make a two-dimensional object by
    creating two different vectors with the `c()` function and using the `tibble()`
    function to collect them together:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: R首先评估表达式`c(2,4)`，然后只从`my_numbers`中提取第二个和第四个元素，忽略其他元素。你可能想知道为什么我们不直接写`my_numbers[2,3]`。答案是，这种表示法用于二维排列的对象（即有行和列的东西），如矩阵、数据框或tibble。我们可以通过使用`c()`函数创建两个不同的向量，并使用`tibble()`函数将它们收集在一起来创建一个二维对象：
- en: '[PRE126]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: WeIn these chunks of code you will see some explanatory text set off by the
    hash symbol, `#`. In R’s syntax, the hash symbol is used to designate a comment.
    On any line of code, text that appears after a `#` symbol will be ignored by R’s
    interpreter. It won’t be evaluated and it won’t trigger a syntax error. index
    data frames, tibbles, and other arrays by row first, and then by column. Arrays
    may also have more than two dimensions.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些代码块中，你会看到一些由井号符号`#`分隔的解释性文本。在R的语法中，井号符号用于指定注释。在任何代码行的任何位置，出现在`#`符号后面的文本将被R的解释器忽略。它不会被评估，也不会触发语法错误。我们首先按行索引数据框、tibble和其他数组，然后按列索引。数组也可能有超过两个维度。
- en: '[PRE130]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The columns in our tibble have names. We can select elements using them, too.
    We do this by putting the name of the column in quotes where we previously put
    the index number of the column:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们tibble中的列有名称。我们也可以使用它们来选择元素。我们这样做是通过在之前放置列索引号的位置放置列的名称：
- en: '[PRE134]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: If we want to get all the elements of a particular column, we can leave out
    the row index. This will mean all the rows will be included for whichever column
    we select.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想获取特定列的所有元素，我们可以省略行索引。这意味着将包括我们选择的任何列的所有行。
- en: '[PRE142]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'We can do this the other way around, too, selecting a particular row and showing
    all columns:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以反过来操作，选择特定行并显示所有列：
- en: '[PRE144]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'A better way of accessing particular columns in a data frame is via the `$`
    operator, which can be used to extract components of various sorts of object.
    This way we append the name of the column we want to the name of the object it
    belongs to:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据框中访问特定列的更好方法是使用 `$` 操作符，它可以用来提取各种类型对象的组件。这样，我们将我们想要访问的列的名称附加到它所属的对象的名称上：
- en: '[PRE146]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Elements of many other objects can be extracted in this way, too, including
    nested objects.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式也可以提取许多其他对象的元素，包括嵌套对象。
- en: '[PRE148]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Finally, in the case of data frames the `$` operator also lets us add new columns
    to the object. For example, we can add the first two columns together, row by
    row. To create a column in this way, we put the `$` and the name of the new column
    on the left-hand side of the assignment.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在数据框的情况下，`$` 操作符还允许我们向对象中添加新列。例如，我们可以将前两列逐行相加。要以这种方式创建一个列，我们在赋值左侧放置 `$` 和新列的名称。
- en: '[PRE154]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: In this book we do not generally access data via `[` or `$`. It is particularly
    bad practice to access elements by their index number only, as opposed to using
    names. In both cases, and especially the latter, it is too easy to make a mistake
    and choose the wrong columns or rows. In addition, if our table changes shape
    later on (e.g. due to the addition of new original data) then any absolute reference
    to the position of columns (rather than to their names) is very likely to break.
    Still, we do use the `c()` function for small tasks quite regularly, so it’s worth
    understanding how it can be used to pick out elements from vectors.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们通常不通过 `[` 或 `$` 访问数据。仅通过索引号访问元素，而不是使用名称，这是一种特别不好的做法。在两种情况下，尤其是后者，犯错误并选择错误的列或行太容易了。此外，如果我们的表格在以后发生变化（例如，由于添加了新的原始数据），那么任何对列位置的绝对引用（而不是对名称的引用）很可能都会出错。尽管如此，我们仍然经常使用
    `c()` 函数来完成小任务，因此了解它如何用于从向量中挑选元素是值得的。
- en: A.1.3 Tidy data
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.3 整洁数据
- en: Working with R and ggplot is much easier if the data you use is in the right
    shape. Ggplot wants your data to be *tidy*. For a more thorough introduction to
    the idea of tidy data, see Chapters 5 and 12 of Wickham & Grolemund (2016). To
    get a sense of what a tidy dataset looks like in R, we will follow the discussion
    in Wickham (2014). In a tidy dataset,
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的数据形状正确，使用 R 和 ggplot 的工作会容易得多。ggplot 希望你的数据是*整洁的*。要更深入地了解整洁数据的概念，请参阅 Wickham
    & Grolemund (2016) 的第 5 章和第 12 章。为了了解 R 中整洁数据集的样子，我们将遵循 Wickham (2014) 中的讨论。在一个整洁数据集中，
- en: '*Each variable is a column.*'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*每个变量是一列。*'
- en: '*Each observation is a row.*'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*每个观测是一行。*'
- en: '*Each type of observational unit forms a table.*'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*每种观测单位都形成一张表。*'
- en: For most of your data analysis, the first two points are the most important.
    This third one might be a little unfamiliar. It is a feature of “normalized” data
    from the world of databases, where the goal is to represent data in a series of
    related tables with minimal duplication (Codd, 1990). Data analysis more usually
    works with a single large table of data, often with considerable duplication of
    some variables down the rows.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的大部分数据分析，前两点是最重要的。第三点可能有点不熟悉。这是数据库世界中“标准化”数据的一个特性，其目标是用一系列相关表来表示数据，以最小化重复（Codd，1990）。数据分析通常使用单个大型数据表，通常在行中有相当多的某些变量的重复。
- en: Data presented in summary tables is often not “tidy” as defined here. When structuring
    our data we need to be clear about how our data is arranged. If your data is not
    tidily arranged, the chances are good that you will have more difficulty, and
    maybe a *lot* more difficulty, getting ggplot to draw the figure you want.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇总表中呈现的数据通常不符合这里定义的“整洁”。在构建我们的数据时，我们需要清楚我们的数据是如何排列的。如果你的数据没有整洁地排列，那么你可能会遇到更多困难，也许会有*很多*困难，才能让
    ggplot 绘制你想要的图形。
- en: 'Table A.1: Some untidy data.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 表 A.1：一些不整洁的数据。
- en: '| name | treatmenta | treatmentb |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 处理a | 处理b |'
- en: '| :-- | --: | --: |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| :-- | --: | --: |'
- en: '| John Smith | NA | 18 |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 约翰·史密斯 | NA | 18 |'
- en: '| Jane Doe | 4 | 1 |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| 简·多伊 | 4 | 1 |'
- en: '| Mary Johnson | 6 | 7 |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 玛丽·约翰逊 | 6 | 7 |'
- en: 'Table A.2: The same data, still untidy, but in a different way.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 表 A.2：相同的数据，仍然不整洁，但以不同的方式。
- en: '| treatment | John Smith | Jane Doe | Mary Johnson |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| 处理 | 约翰·史密斯 | 简·多伊 | 玛丽·约翰逊 |'
- en: '| :-- | --: | --: | --: |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| :-- | --: | --: | --: |'
- en: '| a | NA | 4 | 6 |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| a | NA | 4 | 6 |'
- en: '| b | 18 | 1 | 7 |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| b | 18 | 1 | 7 |'
- en: For example consider Table [A.1](appendix.html#tab:ch-09-preg1) and Table [A.2](appendix.html#tab:ch-09-preg2)
    from Wickham’s discussion. They present the same data in different ways, but each
    would cause trouble if we tried to work with it in ggplot to make a graph. Table
    [A.3](appendix.html#tab:ch-09-preg3) shows the same data once again, this time
    in a tidied form.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑 Wickham 的讨论中的表 [A.1](appendix.html#tab:ch-09-preg1) 和表 [A.2](appendix.html#tab:ch-09-preg2)。它们以不同的方式呈现相同的数据，但如果我们尝试在
    ggplot 中使用它们来制作图表，每个都会引起麻烦。表 [A.3](appendix.html#tab:ch-09-preg3) 再次展示了相同的数据，这次是以规范化的形式。
- en: 'Hadley Wickham notes five main ways tables of data tend not to be tidy:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Hadley Wickham 指出，数据表通常不整洁的五个主要原因：
- en: '*Column headers are values, not variable names*.'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*列标题是值，而不是变量名*。'
- en: '*Multiple variables are stored in one column*.'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*多个变量存储在一个列中*。'
- en: '*Variables are stored in both rows and columns*.'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*变量存储在行和列中*。'
- en: '*Multiple types of observational units are stored in the same table*.'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*同一表中存储了多种类型的观测单位*。'
- en: '*A single observational unit is stored in multiple tables*.'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*单个观测单位存储在多个表中*。'
- en: 'Table A.3: Tidied data. Every variable a column, every observation a row.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 表 A.3：规范化数据。每个变量对应一列，每个观测值对应一行。
- en: '| name | treatment | n |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| name | treatment | n |'
- en: '| :-- | :-- | --: |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| :-- | :-- | --: |'
- en: '| Jane Doe | a | 4 |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| 简·多伊 | a | 4 |'
- en: '| Jane Doe | b | 1 |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 简·多伊 | b | 1 |'
- en: '| John Smith | a | NA |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 约翰·史密斯 | a | NA |'
- en: '| John Smith | b | 18 |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 约翰·史密斯 | b | 18 |'
- en: '| Mary Johnson | a | 6 |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| 玛丽·约翰逊 | a | 6 |'
- en: '| Mary Johnson | b | 7 |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| 玛丽·约翰逊 | b | 7 |'
- en: Data comes in an untidy form all the time, often for the good reason that it
    can be presented that way using much less space, or with far less repetition of
    labels and row elements. Figure [A.2](appendix.html#fig:ch-09-census-untidy) shows
    a the first few rows of a table of U.S. Census Bureau data about educational attainment
    in the United States. To begin with, it’s organized as a series of sub-tables
    down the spreadsheet, broken out by age and sex. Second, the underlying variable
    of interest, “Years of School Completed” is stored across several columns, with
    an additional variable (level of schooling) included across the columns also.
    It is not too hard to get the table into a slightly more regular format by eliminating
    the blank rows, and explicitly naming the sub-table rows. One can do this manually
    and get to the point where it can be read in as an Excel or CSV file. This is
    not ideal, as manually cleaning data runs against the commitment to do as much
    as possible programmatically.`readxl.tidyverse.org` We can automate the process
    somewhat. The tidyverse comes with a `readxl` package that tries to ease the pain
    a little.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 数据总是以杂乱无章的形式出现，通常是因为以这种方式呈现可以节省大量空间，或者可以减少标签和行元素的重复。图 [A.2](appendix.html#fig:ch-09-census-untidy)
    展示了美国人口普查局关于美国教育成就数据的表格的前几行。首先，它被组织成一系列子表格，沿着工作表向下排列，按年龄和性别划分。其次，感兴趣的底层变量“完成学年的年数”存储在几个列中，同时在列中也包含了一个额外的变量（教育水平）。通过消除空白行并明确命名子表格的行，将表格转换成稍微规范一些的格式并不太难。可以手动完成这个过程，并将其作为Excel或CSV文件读取。但这并不是最佳方案，因为手动清理数据与尽可能编程化处理的承诺相违背。`readxl.tidyverse.org`
    我们可以某种程度上自动化这个过程。tidyverse 包含一个 `readxl` 包，它试图稍微减轻一些痛苦。
- en: 'Figure A.2: Untidy data from the Census.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.2：来自普查的杂乱数据。
- en: '![Untidy data from the Census.](../Images/c7abcd15676ccf4d2f644bebb6b0dfab.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![来自普查的杂乱数据。](../Images/c7abcd15676ccf4d2f644bebb6b0dfab.png)'
- en: '[PRE156]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The tidyverse has several tools to help you get the rest of the way in converting
    your data from an untidy to a tidy state. These can mostly be found in the `tidyr`
    and `dplyr` libraries. The former provides functions for converting, for example,
    wide-format data to long-format data, as well as assisting with the business of
    splitting and combining variables that are untidily stored. The latter has a tools
    that allow tidy tables to be further filtered, sliced, and analyzed at different
    grouping levels, as we have seen throughout this book.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: tidyverse 有几个工具可以帮助您将数据从杂乱状态转换为规范状态。这些工具大多可以在 `tidyr` 和 `dplyr` 库中找到。前者提供了将宽格式数据转换为长格式数据的功能，以及帮助处理存储不规范的变量拆分和合并的业务。后者有工具允许在本书中看到的分组级别上进一步过滤、切片和分析规范化的表格。
- en: With our `edu` object, we can use the `gather()` function to transform the schooling
    variables into a *key-value* arrangement. The key is the underlying variable,
    and the value is the value it takes for that observation. We create a new object,
    `edu_t` in this way.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`edu`对象，我们可以使用`gather()`函数将学校变量转换成*键值*排列。键是基础变量，值是它对该观测值所取的值。我们以这种方式创建了一个新的对象，`edu_t`。
- en: '[PRE157]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: The educational categories previously spread over the columns have been gathered
    into two new columns. The `school` variable is the *key* column. It contains all
    of the education categories that were previously given across the column headers,
    from 0-4 years of elementary school to four or more years of college. They are
    now stacked up on top of each other in the rows. The `freq` variable is the *value*
    column, and contains the unique value of `schooling` for each level of that variable.
    Once our data is in this long-form shape, it is ready for easy use with ggplot
    and related tidyverse tools.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 之前分散在列中的教育类别已被收集到两个新的列中。`school`变量是*键*列。它包含所有之前在列标题中给出的教育类别，从0-4年的小学教育到四年或更长的大学教育。它们现在堆叠在行上。`freq`变量是*值*列，包含该变量每个级别的唯一`schooling`值。一旦我们的数据以这种长格式排列，就可以轻松地与ggplot和相关tidyverse工具一起使用。
- en: A.2 Common problems reading in data
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 读取数据时常见的问题
- en: Date formats
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期格式
- en: 'Date formats can be annoying. First, times and dates must be treated differently
    from ordinary numbers. Second, there are many, many different date formats, differing
    both in the precision with which they are stored and the convention they follow
    about how to display years, months, days, and so on. Consider the following data:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 日期格式可能会令人烦恼。首先，时间和日期必须与普通数字区分对待。其次，存在许多不同的日期格式，它们在存储的精度以及关于如何显示年份、月份、日期等方面的约定上都有所不同。考虑以下数据：
- en: '[PRE161]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: The data in the `date` column has been read in as a character string, but we
    want R to treat it as a date. If can’t treat it as a date, we get bad results.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`date`列中的数据已被读入为字符字符串，但我们希望R将其视为日期。如果不能将其视为日期，我们将得到错误的结果。'
- en: '![A bad date.](../Images/52465ae3bdb35038a8ba0f67225c35e2.png) Figure A.3:
    A bad date.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '![一次糟糕的约会。](../Images/52465ae3bdb35038a8ba0f67225c35e2.png) 图A.3：一次糟糕的约会。'
- en: '[PRE163]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: What has happened? The problem is that ggplot doesn’t know `date` consists of
    dates. As a result, when we ask to plot it on the x-axis, it tries to treat the
    unique elements of `date` like a categorical variable instead. (That is, as a
    factor.) But because each date is unique, its default effort at grouping the data
    results in every group having only one observation in it (i.e., that particular
    row). The ggplot function knows something is odd about this, and tries to let
    you know. It wonders whether we’ve failed to set `group = <something>` in our
    mapping.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？问题是ggplot不知道`date`包含日期。因此，当我们要求将其绘制在x轴上时，它试图将`date`的唯一元素视为一个分类变量（即因子）。但由于每个日期都是唯一的，其默认的分组数据努力导致每个组中只有一个观测值（即那一行）。ggplot函数知道这一点，并试图让你知道。它想知道我们是否在映射中未能设置`group
    = <something>`。
- en: For the sake of it, let’s see what happens when the bad date values are *not*
    unique. We will make a new data frame by stacking two copies of the data on top
    of each other. The `rbind()` function does this for us. We end up with two copies
    of every observation.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看当糟糕的日期值不是唯一的时候会发生什么，让我们看看。我们将通过将两个数据副本堆叠在一起来创建一个新的数据框。`rbind()`函数为我们完成这项工作。我们最终得到了每个观测值的两个副本。
- en: '![Still bad.](../Images/773245f5dd69a1ceaa507762c031c2c0.png) Figure A.4: Still
    bad.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '![仍然很糟糕。](../Images/773245f5dd69a1ceaa507762c031c2c0.png) 图A.4：仍然很糟糕。'
- en: '[PRE165]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Now ggplot doesn’t complain at all, because there’s more than one observation
    per (inferred) group. But the plot is still wrong!
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，ggplot根本不会抱怨，因为每个（推断的）组中都有多个观测值。但图表仍然是不正确的！
- en: We will fix this problem using the `lubridate` library. It provides a suite
    of convenience functions for converting date strings in various formats and with
    various separators (such as `/` or `-` and so on) into objects of class `Date`
    that R knows about. Here our bad dates are in a month/day/year format, so we use
    `mdy()`. Consult the lubridate library’s documentation to learn more about similar
    convenience functions for converting character strings where the date components
    appear in a different order.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`lubridate`库来解决这个问题。它提供了一系列方便的函数，用于将各种格式的日期字符串以及各种分隔符（如`/`或`-`等）转换为R所认识的`Date`类对象。在我们的例子中，坏日期是按月/日/年格式排列的，因此我们使用`mdy()`。请查阅`lubridate`库的文档，以了解更多关于将字符字符串转换为不同顺序的日期组件的类似方便函数的信息。
- en: '[PRE166]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Now `filldate_new` has a `Date` class. Let’s try the plot again.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`filldate_new`具有`Date`类。让我们再次尝试绘制图表。
- en: '![Much better.](../Images/f7c5e594b621f7ef4cb6ac4478fb6eac.png) Figure A.5:
    Much better.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '![好多了。](../Images/f7c5e594b621f7ef4cb6ac4478fb6eac.png) 图A.5：好多了。'
- en: '[PRE168]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Year-only dates
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅包含年份的日期
- en: 'Many variables are measured by the year and supplied in the data as a four
    digit number rather than as a date. This can sometimes cause headaches when we
    want to plot year on the x-axis. It happens most often when the time series is
    relatively short. Consider this data:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 许多变量按年份测量，并以四位数字的形式提供在数据中，而不是作为日期。当我们想在x轴上绘制年份时，这有时会导致头痛。这种情况最常发生在时间序列相对较短的情况下。考虑以下数据：
- en: '[PRE169]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: This is a version of `organdata` but in a less clean format. The `year` variable
    is an integer (its class is `<int>`) and not a date. Let’s say we want to plot
    donation rate against year.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`organdata`的版本，但格式不太整洁。`year`变量是一个整数（其类为`<int>`），而不是日期。假设我们想绘制捐赠率与年份的关系图。
- en: '![Integer year shown with a decimal point.](../Images/cf406ce378ab743be8bbbd295c58ca8f.png)
    Figure A.6: Integer year shown with a decimal point.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '![以小数点显示的整数年份。](../Images/cf406ce378ab743be8bbbd295c58ca8f.png) 图A.6：以小数点显示的整数年份。'
- en: '[PRE171]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: The decimal point on the x-axis labels is unwanted. We could sort this out cosmetically,
    by giving `scale_x_continuous()` a set of `breaks` and `labels` that represent
    the years as characters. Alternatively, we can change the class of the `year`
    variable. For convenience, we will tell R that the `year` variable should be treated
    as a Date measure, and not an integer. We’ll use a home-cooked function, `int_to_year()`,
    that takes integers and converts them to dates.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: x轴标签上的小数点是不需要的。我们可以通过给`scale_x_continuous()`一组`breaks`和`labels`来解决这个问题，这些`breaks`和`labels`表示年份为字符。或者，我们可以更改`year`变量的类。为了方便，我们将告诉R，`year`变量应该被视为日期度量，而不是整数。我们将使用一个自制的函数`int_to_year()`，它接受整数并将它们转换为日期。
- en: '[PRE172]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: In the process, today’s day and month are introduced into the year data, but
    that is irrelevant in this case, given that our data are only observed in a yearly
    window to begin with. However, if you wish to specify a generic day and month
    for all the observations, the function allows you to do this.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，今天的日期和月份被引入到年份数据中，但在这个情况下，由于我们的数据最初只在年度窗口中观察到，所以这是无关紧要的。然而，如果你希望为所有观测指定一个通用的日期和月份，该函数允许你这样做。
- en: A.2.1 Write functions for repetitive tasks
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.1 编写用于重复性任务的函数
- en: If you are working with a data set that you will be making a lot of similar
    plots from, or will need to periodically look at in a way that is repetitive but
    can’t be carried out in a single step once and for all, then the chances are that
    you will start accumulating sequences of code that you find yourself using repeatedly.
    When this happens, the temptation will be to start copying and pasting these sequences
    from one analysis to the next. We can see something of this tendency in the code
    samples for this book. To make the exposition clearer, we have periodically repeated
    chunks of code that differ only in the dependent or independent variable being
    plotted.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理一个数据集，你将从中制作许多类似的图表，或者需要定期以重复的方式查看，但无法一次性完成，那么你可能会开始积累你发现自己反复使用的代码序列。当这种情况发生时，你可能会开始从一次分析复制粘贴这些序列到下一次分析。我们可以在本书的代码示例中看到这种趋势的一部分。为了使阐述更清晰，我们定期重复了代码块，这些代码块仅在绘制的依赖变量或独立变量上有所不同。
- en: You should try to avoid copying and pasting code repeatedly in this way. Instead,
    this is an opportunity to write a function to help you out a little. More or less
    everything in R is accomplished through functions, and it’s not too difficult
    to write your own. This is especially the case when you begin by thinking of functions
    as a way to help you automate some local or smaller task, rather than a means
    of accomplishing some very complex task. R has the resources to help you build
    complex functions and function libraries, like ggplot itself. But we can start
    quite small, with functions that help us manage a particular dataset or data analysis.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该尽量避免以这种方式反复复制粘贴代码。相反，这是一个写一个函数来帮助你一下的机会。在R中，几乎所有的事情都是通过函数完成的，自己写一个函数并不太难。这尤其在你开始把函数看作是自动化一些局部或较小任务的方式，而不是完成一些非常复杂任务的手段时更为明显。R有资源帮助你构建复杂的函数和函数库，就像ggplot本身一样。但我们可以从非常小的地方开始，用函数来帮助我们管理特定的数据集或数据分析。
- en: 'Remember, functions take *inputs*, perform *actions*, and return *outputs*.
    For example, imagine a function that adds two numbers, `x` and `y`. In use, it
    might look like this:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，函数接受*输入*，执行*操作*，并返回*输出*。例如，想象一个添加两个数字`x`和`y`的函数。在使用时，它可能看起来像这样：
- en: '[PRE174]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'How do we *create* this function? Remember, everything is an object, so functions
    are just special kinds of object. And everything in R is done via functions. So,
    if we want to make a new function we will use an existing function do to it. In
    R, functions are created with `function()`:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何*创建*这个函数？记住，一切都是对象，所以函数只是特殊类型的对象。在R中，所有的事情都是通过函数完成的。因此，如果我们想要创建一个新的函数，我们将使用现有的函数来完成它。在R中，函数是用`function()`创建的：
- en: '[PRE176]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: You can see that `function()` is a little different from ordinary functions
    in two ways. First, the arguments we give it (here, `x` and `y`) are for the `add_xy`
    function that we are *creating*. Second, immediately after the `function(x, y)`
    statement there’s an opening brace, `{`, followed by a bit of R code that adds
    x and y, and then the closing brace `}`. That’s the content of the function. We
    assign this code to the `add_xy` object, and now we have a function that adds
    two numbers together and returns the result. The `x + y` line inside the parentheses
    is evaluated as if it were typed at the console, assuming you have told it what
    `x` and `y` are.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`function()`在两个方面与普通函数略有不同。首先，我们给它提供的参数（这里，`x`和`y`）是为我们正在*创建*的`add_xy`函数。其次，在`function(x,
    y)`语句之后，有一个开括号`{`，后面是一段R代码，它将x和y相加，然后是闭括号`}`。这就是函数的内容。我们将这段代码分配给`add_xy`对象，现在我们有一个将两个数字相加并返回结果的函数。括号内的`x
    + y`行被评估，就像在控制台输入一样，前提是你已经告诉了它`x`和`y`是什么。
- en: '[PRE177]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Functions can take many kinds of arguments, and we can also tell them what the
    default value of each argument should be by specifying it inside the `function(...)`
    section. Functions are little programs that have all the power of R at their disposal,
    including standard things like flow-control through `if ... else` statements and
    so on. Here, for instance, is a function that will make a scatter plot for any
    Section in the ASA data, or optionally fit a smoother to the data and plot that
    instead. Defining a function looks a little like calling one, except that we spell
    out the steps inside. We also specify the default arguments.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受许多种类的参数，我们也可以通过在`function(...)`部分指定来告诉它们每个参数的默认值。函数是拥有R所有功能的小程序，包括标准的东西，如通过`if
    ... else`语句进行流程控制等等。这里，例如，有一个函数可以为ASA数据中的任何部分制作散点图，或者可选地对数据进行平滑处理并绘制该图。定义一个函数看起来有点像调用一个函数，除了我们在这里详细说明了步骤。我们还指定了默认参数。
- en: '[PRE179]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: This function is not very general. Nor is it particularly robust. But for the
    use we want to put it to, it works just fine.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数并不非常通用。它也不是特别健壮。但对于我们想要使用的用途，它工作得很好。
- en: '[PRE180]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Figure A.7: Using a function to plot your results.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.7：使用函数来绘制结果。
- en: '![Using a function to plot your results.](../Images/2752e9cfed4f3c38227ed449f207ed3c.png)![Using
    a function to plot your results.](../Images/87dcf314f4b6be8bb89c2d3262a68d61.png)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![使用函数来绘制结果](../Images/2752e9cfed4f3c38227ed449f207ed3c.png)![使用函数来绘制结果](../Images/87dcf314f4b6be8bb89c2d3262a68d61.png)'
- en: If we were going to work with this data for long enough, we could make the function
    progressively more general. For example, we can add the special `...` argument
    (which means, roughly, “and any other named arguments”) in a way that allows us
    to pass arguments through to the `geom_smooth()` function in the way we’d expect
    if we were using it directly. With that in place, we can pick the smoothing method
    we want.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要长时间使用这些数据，我们可以使函数逐渐变得更加通用。例如，我们可以添加特殊的`...`参数（这大致意味着“以及任何其他命名参数”），这样我们就可以以我们直接使用它时预期的这种方式将参数传递给`geom_smooth()`函数。有了这个，我们可以选择我们想要的平滑方法。
- en: '[PRE181]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Figure A.8: Our custom function can now pass arguments along to fit different
    smoothers to Section membership data.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.8：我们的自定义函数现在可以将参数传递给拟合不同平滑器的章节成员数据。
- en: '![Our custom function can now pass arguments along to fit different smoothers
    to Section membership data.](../Images/e75ff4a3d54ffa56e423e228c0a57c17.png)![Our
    custom function can now pass arguments along to fit different smoothers to Section
    membership data.](../Images/71f7dc2cba63a58337cf365b42199eb6.png)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![我们的自定义函数现在可以将参数传递给拟合不同平滑器的章节成员数据。](../Images/e75ff4a3d54ffa56e423e228c0a57c17.png)![我们的自定义函数现在可以将参数传递给拟合不同平滑器的章节成员数据。](../Images/71f7dc2cba63a58337cf365b42199eb6.png)'
- en: Date formats
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期格式
- en: 'Date formats can be annoying. First, times and dates must be treated differently
    from ordinary numbers. Second, there are many, many different date formats, differing
    both in the precision with which they are stored and the convention they follow
    about how to display years, months, days, and so on. Consider the following data:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 日期格式可能会很烦人。首先，时间和日期必须与普通数字区别对待。其次，有许多不同的日期格式，它们在存储的精度以及关于如何显示年、月、日等方面的约定上都有所不同。考虑以下数据：
- en: '[PRE183]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: The data in the `date` column has been read in as a character string, but we
    want R to treat it as a date. If can’t treat it as a date, we get bad results.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`date`列中的数据已被读取为字符字符串，但我们希望R将其视为日期。如果不能将其视为日期，我们将得到错误的结果。'
- en: '![A bad date.](../Images/52465ae3bdb35038a8ba0f67225c35e2.png) Figure A.3:
    A bad date.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个错误的日期。](../Images/52465ae3bdb35038a8ba0f67225c35e2.png) 图A.3：一个错误的日期。'
- en: '[PRE185]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: What has happened? The problem is that ggplot doesn’t know `date` consists of
    dates. As a result, when we ask to plot it on the x-axis, it tries to treat the
    unique elements of `date` like a categorical variable instead. (That is, as a
    factor.) But because each date is unique, its default effort at grouping the data
    results in every group having only one observation in it (i.e., that particular
    row). The ggplot function knows something is odd about this, and tries to let
    you know. It wonders whether we’ve failed to set `group = <something>` in our
    mapping.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？问题是ggplot不知道`date`包含日期。因此，当我们要求它在x轴上绘制时，它试图将`date`的唯一元素视为分类变量（即因子）。但由于每个日期都是唯一的，它默认的数据分组方法导致每个组中只有一个观测值（即那一行）。ggplot函数知道这一点，并试图让你知道。它想知道我们是否在映射中未能设置`group
    = <something>`。
- en: For the sake of it, let’s see what happens when the bad date values are *not*
    unique. We will make a new data frame by stacking two copies of the data on top
    of each other. The `rbind()` function does this for us. We end up with two copies
    of every observation.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看当错误的日期值不是唯一的时候会发生什么，我们将创建一个新的数据框，通过将数据堆叠在彼此之上。`rbind()`函数为我们完成这个操作。我们最终得到了每个观测值的两个副本。
- en: '![Still bad.](../Images/773245f5dd69a1ceaa507762c031c2c0.png) Figure A.4: Still
    bad.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '![仍然错误。](../Images/773245f5dd69a1ceaa507762c031c2c0.png) 图A.4：仍然错误。'
- en: '[PRE187]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Now ggplot doesn’t complain at all, because there’s more than one observation
    per (inferred) group. But the plot is still wrong!
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，ggplot不再抱怨，因为每个（推断的）组中都有多个观测值。但图表仍然错误！
- en: We will fix this problem using the `lubridate` library. It provides a suite
    of convenience functions for converting date strings in various formats and with
    various separators (such as `/` or `-` and so on) into objects of class `Date`
    that R knows about. Here our bad dates are in a month/day/year format, so we use
    `mdy()`. Consult the lubridate library’s documentation to learn more about similar
    convenience functions for converting character strings where the date components
    appear in a different order.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`lubridate`库来解决这个问题。它提供了一系列方便的函数，用于将各种格式的日期字符串以及各种分隔符（如`/`或`-`等）转换为R所认识的`Date`类对象。在这里，我们的坏日期是按月/日/年格式排列的，因此我们使用`mdy()`。请查阅`lubridate`库的文档，以了解更多关于将字符字符串转换为不同顺序的日期组件的类似方便函数的信息。
- en: '[PRE188]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Now `filldate_new` has a `Date` class. Let’s try the plot again.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`filldate_new`具有`Date`类。让我们再次尝试绘图。
- en: '![Much better.](../Images/f7c5e594b621f7ef4cb6ac4478fb6eac.png) Figure A.5:
    Much better.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '![好多了。](../Images/f7c5e594b621f7ef4cb6ac4478fb6eac.png) 图A.5：好多了。'
- en: '[PRE190]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Year-only dates
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅包含年份的日期
- en: 'Many variables are measured by the year and supplied in the data as a four
    digit number rather than as a date. This can sometimes cause headaches when we
    want to plot year on the x-axis. It happens most often when the time series is
    relatively short. Consider this data:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 许多变量按年份测量并以四位数字的形式提供在数据中，而不是日期。当我们想要在x轴上绘制年份时，这有时会导致头疼。这种情况在时间序列相对较短时最常见。考虑以下数据：
- en: '[PRE191]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: This is a version of `organdata` but in a less clean format. The `year` variable
    is an integer (its class is `<int>`) and not a date. Let’s say we want to plot
    donation rate against year.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`organdata`的一个版本，但格式不太整洁。`year`变量是一个整数（其类为`<int>`），而不是日期。假设我们想要绘制捐赠率与年份的关系。
- en: '![Integer year shown with a decimal point.](../Images/cf406ce378ab743be8bbbd295c58ca8f.png)
    Figure A.6: Integer year shown with a decimal point.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '![以小数点显示的整数年份。](../Images/cf406ce378ab743be8bbbd295c58ca8f.png) 图A.6：以小数点显示的整数年份。'
- en: '[PRE193]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: The decimal point on the x-axis labels is unwanted. We could sort this out cosmetically,
    by giving `scale_x_continuous()` a set of `breaks` and `labels` that represent
    the years as characters. Alternatively, we can change the class of the `year`
    variable. For convenience, we will tell R that the `year` variable should be treated
    as a Date measure, and not an integer. We’ll use a home-cooked function, `int_to_year()`,
    that takes integers and converts them to dates.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: x轴标签上的小数点是不需要的。我们可以通过给`scale_x_continuous()`一组`breaks`和`labels`来代表年份作为字符来解决这个问题，这些`breaks`和`labels`表示年份。或者，我们可以更改`year`变量的类。为了方便，我们将告诉R，`year`变量应被视为日期度量，而不是整数。我们将使用一个自制的函数`int_to_year()`，它接受整数并将它们转换为日期。
- en: '[PRE194]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: In the process, today’s day and month are introduced into the year data, but
    that is irrelevant in this case, given that our data are only observed in a yearly
    window to begin with. However, if you wish to specify a generic day and month
    for all the observations, the function allows you to do this.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，今天的日期和月份被引入到年数据中，但在此情况下并不相关，因为我们的数据最初只在一个年度窗口内被观察。然而，如果您希望为所有观察指定一个通用的日期和月份，该函数允许您这样做。
- en: A.2.1 Write functions for repetitive tasks
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.1 编写用于重复性任务的函数
- en: If you are working with a data set that you will be making a lot of similar
    plots from, or will need to periodically look at in a way that is repetitive but
    can’t be carried out in a single step once and for all, then the chances are that
    you will start accumulating sequences of code that you find yourself using repeatedly.
    When this happens, the temptation will be to start copying and pasting these sequences
    from one analysis to the next. We can see something of this tendency in the code
    samples for this book. To make the exposition clearer, we have periodically repeated
    chunks of code that differ only in the dependent or independent variable being
    plotted.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在处理一个数据集，您将从中制作许多类似的图表，或者需要定期以重复的方式查看，但无法一次性完成，那么您很可能会开始积累一系列您发现自己反复使用的代码。当这种情况发生时，您可能会开始从一次分析到下一次分析复制粘贴这些序列。我们可以在本书的代码示例中看到这种趋势的一点点。为了使阐述更清晰，我们定期重复了代码块，这些代码块仅在绘制的因变量或自变量上有所不同。
- en: You should try to avoid copying and pasting code repeatedly in this way. Instead,
    this is an opportunity to write a function to help you out a little. More or less
    everything in R is accomplished through functions, and it’s not too difficult
    to write your own. This is especially the case when you begin by thinking of functions
    as a way to help you automate some local or smaller task, rather than a means
    of accomplishing some very complex task. R has the resources to help you build
    complex functions and function libraries, like ggplot itself. But we can start
    quite small, with functions that help us manage a particular dataset or data analysis.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 您应尽量避免以这种方式重复复制粘贴代码。相反，这是一个编写函数来帮助您的机会。在R中，几乎所有的事情都是通过函数完成的，编写自己的函数并不太难。这尤其适用于您开始将函数视为自动化某些局部或较小任务的方式，而不是完成某些非常复杂任务的手段。R有资源帮助您构建复杂的函数和函数库，就像ggplot本身一样。但我们可以从非常小的函数开始，这些函数可以帮助我们管理特定的数据集或数据分析。
- en: 'Remember, functions take *inputs*, perform *actions*, and return *outputs*.
    For example, imagine a function that adds two numbers, `x` and `y`. In use, it
    might look like this:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，函数**接受输入**，**执行操作**，并**返回输出**。例如，想象一个添加两个数字`x`和`y`的函数。在使用时，它可能看起来像这样：
- en: '[PRE196]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'How do we *create* this function? Remember, everything is an object, so functions
    are just special kinds of object. And everything in R is done via functions. So,
    if we want to make a new function we will use an existing function do to it. In
    R, functions are created with `function()`:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何**创建**这个函数？记住，一切都是对象，所以函数只是特殊类型的对象。在R中，所有操作都是通过函数完成的。因此，如果我们想创建一个新的函数，我们将使用现有的函数来完成它。在R中，函数使用`function()`创建：
- en: '[PRE198]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: You can see that `function()` is a little different from ordinary functions
    in two ways. First, the arguments we give it (here, `x` and `y`) are for the `add_xy`
    function that we are *creating*. Second, immediately after the `function(x, y)`
    statement there’s an opening brace, `{`, followed by a bit of R code that adds
    x and y, and then the closing brace `}`. That’s the content of the function. We
    assign this code to the `add_xy` object, and now we have a function that adds
    two numbers together and returns the result. The `x + y` line inside the parentheses
    is evaluated as if it were typed at the console, assuming you have told it what
    `x` and `y` are.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`function()`在两个方面与普通函数略有不同。首先，我们给它提供的参数（这里，`x`和`y`）是为我们正在**创建**的`add_xy`函数。其次，在`function(x,
    y)`语句之后，有一个开括号`{`，后面是一段R代码，它添加了x和y，然后是闭括号`}`。这就是函数的内容。我们将此代码分配给`add_xy`对象，现在我们有一个将两个数字相加并返回结果的函数。括号内的`x
    + y`行被评估为如果它在控制台输入，假设你已经告诉了它`x`和`y`是什么。
- en: '[PRE199]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: Functions can take many kinds of arguments, and we can also tell them what the
    default value of each argument should be by specifying it inside the `function(...)`
    section. Functions are little programs that have all the power of R at their disposal,
    including standard things like flow-control through `if ... else` statements and
    so on. Here, for instance, is a function that will make a scatter plot for any
    Section in the ASA data, or optionally fit a smoother to the data and plot that
    instead. Defining a function looks a little like calling one, except that we spell
    out the steps inside. We also specify the default arguments.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受许多类型的参数，我们也可以通过在`function(...)`部分指定来告诉它们每个参数的默认值。函数是拥有R所有功能的小程序，包括标准事物，如通过`if
    ... else`语句进行流程控制等。例如，这里有一个函数，可以为ASA数据中的任何章节创建散点图，或者可选地拟合平滑器并绘制该图。定义函数看起来有点像调用一个函数，除了我们详细说明了步骤。我们还指定了默认参数。
- en: '[PRE201]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: This function is not very general. Nor is it particularly robust. But for the
    use we want to put it to, it works just fine.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不是很通用。它也不是特别健壮。但对我们想要使用的用途来说，它工作得很好。
- en: '[PRE202]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Figure A.7: Using a function to plot your results.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.7：使用函数绘制结果。
- en: '![Using a function to plot your results.](../Images/2752e9cfed4f3c38227ed449f207ed3c.png)![Using
    a function to plot your results.](../Images/87dcf314f4b6be8bb89c2d3262a68d61.png)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: '![使用函数绘制结果。](../Images/2752e9cfed4f3c38227ed449f207ed3c.png)![使用函数绘制结果。](../Images/87dcf314f4b6be8bb89c2d3262a68d61.png)'
- en: If we were going to work with this data for long enough, we could make the function
    progressively more general. For example, we can add the special `...` argument
    (which means, roughly, “and any other named arguments”) in a way that allows us
    to pass arguments through to the `geom_smooth()` function in the way we’d expect
    if we were using it directly. With that in place, we can pick the smoothing method
    we want.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要长时间使用这些数据，我们可以使函数逐渐变得更加通用。例如，我们可以添加特殊的`...`参数（大致意味着“和任何其他命名参数”），这样我们就可以以我们直接使用它时预期的方式将参数传递给`geom_smooth()`函数。有了这个，我们可以选择我们想要的平滑方法。
- en: '[PRE203]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Figure A.8: Our custom function can now pass arguments along to fit different
    smoothers to Section membership data.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.8：我们的自定义函数现在可以将参数传递给不同的平滑器，以适应章节成员数据。
- en: '![Our custom function can now pass arguments along to fit different smoothers
    to Section membership data.](../Images/e75ff4a3d54ffa56e423e228c0a57c17.png)![Our
    custom function can now pass arguments along to fit different smoothers to Section
    membership data.](../Images/71f7dc2cba63a58337cf365b42199eb6.png)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![我们的自定义函数现在可以将参数传递给不同的平滑器，以适应章节成员数据。](../Images/e75ff4a3d54ffa56e423e228c0a57c17.png)![我们的自定义函数现在可以将参数传递给不同的平滑器，以适应章节成员数据。](../Images/71f7dc2cba63a58337cf365b42199eb6.png)'
- en: A.3 Managing projects and files
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3 管理项目和文件
- en: A.3.1 RMarkdown and knitr
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.1 RMarkdown和knitr
- en: Markdown`en.wikipedia.org/wiki/Markdown` is a loosely-standardized way of writing
    plain text that includes information about the formatting of your document. It
    was originally developed by John Gruber, with input from Aaron Swartz. The aim
    was to make a simple format that could incorporate some structural information
    about the document (such as headings and subheadings, *emphasis*, hyperlinks,
    lists, footnotes, and so on), with minimal loss of readability in plain-text form.
    A plain-text format like HTML is much more extensive and well-defined than Markdown,
    but Markdown was meant to be simple. Over the years, and despite various weaknesses,
    it has become a *de facto* standard. Text editors and note-taking applications
    support it, and tools exist to convert Markdown not just into HTML (its original
    target output format) but many other document types as well. The most powerful
    of these is Pandoc`pandoc.org`, which can get you from markdown to many other
    formats (and *vice versa*). Pandoc is what powers RStudio’s ability to convert
    your notes to HTML, Microsoft Word, and PDF documents.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown`en.wikipedia.org/wiki/Markdown`是一种松散标准化的纯文本编写方式，其中包含有关文档格式化的信息。它最初由John
    Gruber开发，Aaron Swartz提供了意见。目标是创建一个简单的格式，可以包含一些关于文档的结构信息（例如标题和副标题、*强调*、超链接、列表、脚注等），同时尽量减少在纯文本形式中的可读性损失。与Markdown相比，HTML这样的纯文本格式更为广泛和定义明确，但Markdown旨在简单。尽管存在各种弱点，但多年来它已经成为一种*事实上的*标准。文本编辑器和笔记应用都支持它，并且存在将Markdown转换为不仅仅是HTML（其原始目标输出格式）的许多其他文档类型的工具。其中最强大的是Pandoc`pandoc.org`，它可以将Markdown转换为许多其他格式（以及*反之亦然*）。Pandoc是RStudio能够将你的笔记转换为HTML、Microsoft
    Word和PDF文档的驱动力。
- en: Chapter 1 of this book encourages you to take notes and organize your analysis
    using RMarkdown`rmarkdown.rstudio.com` and (behind the scenes) knitr`yihui.name/knitr`.
    These are R libraries that RStudio makes easy to use. RMarkdown extends Markdown
    by letting you intersperse your notes with chunks of R code. Code chunks can have
    labels and a few options that determine how they will behave when the file is
    processed. After writing your notes and your code, you `knit` the document (Xie,
    2015). That is, you feed your `.Rmd` file to R, which processes the code chunks,
    and produces a new `.md` where the code chunks have been replaced by their output.
    You can then turn that Markdown file into a more readable PDF or HTML document,
    or the Word document that a journal demands you send them.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 本书第一章鼓励你使用RMarkdown`rmarkdown.rstudio.com`和（幕后）knitr`yihui.name/knitr`来记录笔记和组织分析。这些是RStudio使使用变得容易的R库。RMarkdown通过允许你在笔记中穿插R代码块来扩展Markdown。代码块可以有标签和一些选项，这些选项决定了它们在文件处理时的行为。在写完你的笔记和代码后，你`knit`文档（Xie,
    2015）。也就是说，你将`.Rmd`文件输入到R中，R处理代码块，并生成一个新的`.md`文件，其中代码块已被它们的输出所替代。然后你可以将那个Markdown文件转换成更易读的PDF或HTML文档，或者期刊要求你发送的Word文档。
- en: Behind the scenes in RStudio, this is all done using the `knitr` and `rmarkdown`
    libraries. The latter provides a `render()` function that takes you from `.Rmd`
    to HTML or PDF in a single step. Conversely, if you just want to extract the code
    you’ve written from the surrounding text, then you “tangle” the file, which results
    in an `.R` file. The strength of this approach is that is makes it much easier
    to document your work properly. There is just one file for both the data analysis
    and the writeup. The output of the analysis is created on the fly, and the code
    to do it is embedded in the paper. If you need to do multiple but identical (or
    very similar) analyses of different bits of data, RMarkdown and `knitr` can make
    generating consistent and reliable reports much easier.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在RStudio幕后，这一切都是通过`knitr`和`rmarkdown`库来完成的。后者提供了一个`render()`函数，它可以将`.Rmd`文件一步转换成HTML或PDF。相反，如果你只想从周围文本中提取你编写的代码，那么你“tangle”文件，这将生成一个`.R`文件。这种方法的优点是它使得正确地记录你的工作变得容易得多。对于数据分析和报告，只有一个文件。分析的结果是即时创建的，执行它的代码被嵌入在论文中。如果你需要对不同的数据块进行多个但相同（或非常相似）的分析，RMarkdown和`knitr`可以使生成一致和可靠的报告变得容易得多。
- en: Pandoc’s flavor of Markdown is the one used in knitr and RStudio. It allows
    for a wide range of markup, and can handle many of the nuts and bolts of scholarly
    writing, such as complex tables, citations, bibliographies, references, and mathematics.
    In addition to being able to produce documents in various *file* formats, it can
    also produce many different *kinds* of document, from articles and handouts to
    websites and slide decks. RStudio’s RMarkdown website has extensive documentation
    and examples on the ins and outs of RMarkdown’s capabilities, including information
    on customizing it if you wish.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: Pandoc的Markdown版本是knitr和RStudio中使用的版本。它允许广泛的使用标记，并且可以处理学术写作的许多基本元素，如复杂表格、引用、参考文献、参考文献和数学。除了能够以各种*文件*格式生成文档外，它还可以生成许多不同类型的文档，从文章和讲义到网站和幻灯片。RStudio的RMarkdown网站提供了关于RMarkdown功能细节的广泛文档和示例，包括如果您希望对其进行自定义的信息。
- en: Writing your notes and papers in a plain text format like this has many advantages.
    It keeps your writing, your code, and your results closer together, and allows
    you to use powerful version control methods to keep track of your work and your
    results. Errors in data analysis often well up out of the gap that typically exists
    between the procedure used to produce a figure or table in a paper and the subsequent
    use of that output later. In the ordinary way of doing things, you have the code
    for your data analysis in one file, the output it produced in another, and the
    text of your paper in a third file. You do the analysis, collect the output and
    copy the relevant results into your paper, often manually reformatting them on
    the way. Each of these transitions introduces the opportunity for error. In particular,
    it is easy for a table of results to get detached from the sequence of steps that
    produced it. Almost everyone who has written a quantitative paper has been confronted
    with the problem of reading an old draft containing results or figures that need
    to be revisited or reproduced (as a result of peer-review, say) but which lack
    any information about the circumstances of their creation. Academic papers take
    a long time to get through the cycle of writing, review, revision, and publication,
    even when you’re working hard the whole time. It is not uncommon to have to return
    to something you did two years previously in order to answer some question or
    other from a reviewer. You do not want to have to do everything over from scratch
    in order to get the right answer. I am not exaggerating when I say that, whatever
    the challenges of replicating the results of someone else’s quantitative analysis,
    after a fairly short period of time authors themselves find it hard to replicate
    their *own* work. *Bit-rot* is the term of art in Computer Science for the seemingly
    inevitable process of decay that overtakes a project just because you left it
    alone on your computer for six months or more.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '使用像这样简单的文本格式来编写您的笔记和论文有许多优点。它使您的写作、代码和结果更加紧密地结合在一起，并允许您使用强大的版本控制方法来跟踪您的工作和结果。数据分析中的错误通常会在产生论文中图表或表格的流程与随后使用该输出的流程之间存在的典型差距中显现出来。按照常规做法，您将数据分析的代码放在一个文件中，输出结果放在另一个文件中，而论文的文本放在第三个文件中。您进行数据分析，收集输出并将相关结果复制到论文中，通常还需要在途中手动重新格式化它们。每个转换都引入了出错的机会。特别是，结果表很容易与产生它的步骤序列分离。几乎每个写过定量论文的人都会遇到阅读旧草稿的问题，其中包含需要重新审视或再现（例如，由于同行评审）的结果或图表，但这些结果或图表缺乏关于它们创建情况的任何信息。即使您一直在努力工作，学术论文的撰写、评审、修订和出版周期也需要很长时间。不得不返回两年前做的事情以回答评审员的一些问题并不罕见。您不希望不得不从头开始做所有事情才能得到正确的答案。我说作者在相当短的时间内发现自己难以复制自己的*自己的*工作，这并不是夸张。在计算机科学中，“位腐”这个术语是指一个项目似乎不可避免地会经历的过程，这个过程是因为您将其留在电脑上六个月或更长时间而发生的。 '
- en: For small and medium-sized projects, plain text approaches that rely on RMarkdown
    documents and the tools described here work well. Things become a little more
    complicated as projects get larger. (This is not an intrinsic flaw of plain-text
    methods, by the way. It is true no matter how you choose to organize your project.)
    In general, it is worth trying to keep your notes and analysis in a standardized
    and simple format. The final outputs of projects (such as journal articles or
    books) tend, as they approach completion, to descend into a rush of specific fixes
    and adjustments, all running against the ideal of a fully portable, reproducible
    analysis. It is worth trying to minimize the scope of the inevitable final scramble.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型和中型项目，依赖于 RMarkdown 文档和这里描述的工具的纯文本方法效果良好。随着项目的扩大，事情会变得稍微复杂一些。（顺便说一句，这并不是纯文本方法的固有缺陷。无论你选择如何组织项目，这都是真的。）一般来说，尝试保持你的笔记和分析以标准化和简单格式进行是有价值的。项目最终输出（如期刊文章或书籍）在接近完成时往往会陷入一系列具体的修复和调整，所有这些都在与完全可移植、可重复分析的理想相悖。尝试最小化不可避免的最终混乱的范围是值得的。
- en: A.3.2 Project organization
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.2 项目组织
- en: Managing projects is a large topic of its own, and one that people have strong
    opinions about. Your goal should be to make your code and data portable, reproducible,
    and self-contained. In practice that means using a project based approach in R
    Studio. When you start an analysis with some new data, create a new project containing
    the data and the R or RMarkdown code you will be working with. It should then
    be possible, in the ideal case, to move that folder to another computer that also
    has R, RStudio, and any required libraries installed, and successfully re-run
    the contents of the project.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 管理项目是一个庞大的主题，人们对它有着强烈的看法。你的目标应该是使你的代码和数据具有可移植性、可重复性和自包含性。在实践中，这意味着在 R Studio
    中采用基于项目的方法。当你开始使用一些新数据进行分析时，创建一个包含数据和你要使用的 R 或 RMarkdown 代码的新项目。理想情况下，你应该能够将这个文件夹移动到另一个也安装了
    R、RStudio 和任何所需库的计算机上，并成功重新运行项目的内容。
- en: In practice that means two things. First, even though R is an object-oriented
    language, the only “real”, persistent things in your project should be the raw
    data files you start with, and the code that operates on them. The code is what
    is real. Your code manipulates the data and creates all of the objects and outputs
    you need. It’s possible to save objects in R but in general you should not need
    to do this for everyday analysis.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这意味着两件事。首先，尽管 R 是一种面向对象的语言，但你的项目中唯一“真实”且持久的应该是你开始时的原始数据文件以及操作它们的代码。代码才是真实的。你的代码操纵数据并创建你需要的所有对象和输出。在
    R 中保存对象是可能的，但通常你不需要为日常分析做这件事。
- en: 'Second, your code should not refer to any file locations outside of the project
    folder. The project folder should be the “root” or ground floor for the files
    inside it. This means you should not use *absolute* file paths to save or refer
    to data or figures. Instead, use only *relative* paths. A relative path will start
    at the root of the project. So, for example, you should not load data with a command
    like this:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你的代码不应引用项目文件夹之外任何文件位置。项目文件夹应该是其中文件的“根”或底层。这意味着你不应该使用*绝对*文件路径来保存或引用数据或图表。相反，只使用*相对*路径。相对路径将从项目的根开始。例如，你不应该用这样的命令加载数据：
- en: '[PRE205]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Instead, because you have an R project file started in the `gss` folder you
    can use the `here()` library to specify a relative path, like this:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，因为你已经在 `gss` 文件夹中启动了 R 项目文件，你可以使用 `here()` 库来指定相对路径，如下所示：
- en: '[PRE206]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: While you could type the relative paths out yourself, using `here()` has the
    advantage that it will work if, for example, you use Mac OS and you send your
    project to someone working on Windows. The same rule goes for saving your work,
    as we saw at the end of Chapter @(sec:makeplot), when you save individual plots
    as PDF or PNG files.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以自己输入相对路径，但使用 `here()` 的优点是，如果例如你使用 Mac OS 并且将你的项目发送给使用 Windows 的人，它仍然会工作。我们在第
    @(sec:makeplot) 章节末尾看到，当保存单个图表为 PDF 或 PNG 文件时，这个规则同样适用。
- en: '![Folder organization for a simple project.](../Images/121f0a5c0a13ac2f29b9f15a9cd8e0b4.png)
    Figure A.9: Folder organization for a simple project.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '![简单项目的文件夹组织](../Images/121f0a5c0a13ac2f29b9f15a9cd8e0b4.png) 图 A.9：简单项目的文件夹组织。'
- en: Within your project folder, a little organization goes a long way. You should
    get in the habit of keeping different parts of the project in different sub-folders
    of your working directory. More complex projects may have a more complex structure,
    but you can go a long way with some simple organization. RMarkdown files can be
    in the top level of your working directory, with separate sub-folders called `data/`
    (for your CSV files), one for `figures/` (that you might save) and perhaps one
    called `docs/` for information about your project or data files files. Rstudio
    can help with organization as well through its project management features.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的项目文件夹中，一点点的组织就能走得很远。您应该养成习惯，将项目的不同部分保存在工作目录的不同子文件夹中。更复杂的项目可能具有更复杂的结构，但通过一些简单的组织，您也能走得很远。RMarkdown文件可以放在工作目录的顶层，有单独的子文件夹称为`data/`（用于您的CSV文件），一个用于`figures/`（您可能保存的地方），也许还有一个名为`docs/`的文件夹，用于您项目或数据文件的信息。RStudio也可以通过其项目管理功能帮助您进行组织。
- en: Keeping your project organized just a little bit will prevent you from ending
    up with huge numbers of files of different kinds all sitting at the top of your
    working directory.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 只需稍微组织一下您的项目，就可以防止您最终在您的顶层工作目录中拥有大量不同类型的文件。
- en: A.3.1 RMarkdown and knitr
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.1 RMarkdown和knitr
- en: Markdown`en.wikipedia.org/wiki/Markdown` is a loosely-standardized way of writing
    plain text that includes information about the formatting of your document. It
    was originally developed by John Gruber, with input from Aaron Swartz. The aim
    was to make a simple format that could incorporate some structural information
    about the document (such as headings and subheadings, *emphasis*, hyperlinks,
    lists, footnotes, and so on), with minimal loss of readability in plain-text form.
    A plain-text format like HTML is much more extensive and well-defined than Markdown,
    but Markdown was meant to be simple. Over the years, and despite various weaknesses,
    it has become a *de facto* standard. Text editors and note-taking applications
    support it, and tools exist to convert Markdown not just into HTML (its original
    target output format) but many other document types as well. The most powerful
    of these is Pandoc`pandoc.org`, which can get you from markdown to many other
    formats (and *vice versa*). Pandoc is what powers RStudio’s ability to convert
    your notes to HTML, Microsoft Word, and PDF documents.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown`en.wikipedia.org/wiki/Markdown`是一种松散标准化的纯文本编写方式，它包含了关于您文档格式的信息。它最初由John
    Gruber开发，Aaron Swartz提供了意见。目标是创建一个简单的格式，能够包含一些关于文档的结构信息（例如标题和副标题、*强调*、超链接、列表、脚注等），同时尽量减少在纯文本形式中的可读性损失。与Markdown相比，HTML这样的纯文本格式更为广泛和定义明确，但Markdown旨在保持简单。多年来，尽管存在各种弱点，它已经成为一种*事实上的*标准。文本编辑器和笔记应用都支持Markdown，并且存在将Markdown转换为不仅仅是HTML（其原始目标输出格式）而是许多其他文档类型的工具。其中最强大的是Pandoc`pandoc.org`，它可以将Markdown转换为许多其他格式（以及*反之亦然*）。Pandoc是RStudio能够将您的笔记转换为HTML、Microsoft
    Word和PDF文档的功能背后的动力。
- en: Chapter 1 of this book encourages you to take notes and organize your analysis
    using RMarkdown`rmarkdown.rstudio.com` and (behind the scenes) knitr`yihui.name/knitr`.
    These are R libraries that RStudio makes easy to use. RMarkdown extends Markdown
    by letting you intersperse your notes with chunks of R code. Code chunks can have
    labels and a few options that determine how they will behave when the file is
    processed. After writing your notes and your code, you `knit` the document (Xie,
    2015). That is, you feed your `.Rmd` file to R, which processes the code chunks,
    and produces a new `.md` where the code chunks have been replaced by their output.
    You can then turn that Markdown file into a more readable PDF or HTML document,
    or the Word document that a journal demands you send them.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 本书第一章鼓励您使用RMarkdown`rmarkdown.rstudio.com`和（幕后）knitr`yihui.name/knitr`来记笔记和组织分析。这些是RStudio使其易于使用的R库。RMarkdown通过允许您在笔记中穿插R代码块来扩展Markdown。代码块可以有标签和一些选项，这些选项决定了它们在文件处理时的行为。在编写完笔记和代码后，您`knit`文档（Xie，2015）。也就是说，您将`.Rmd`文件输入到R中，R处理代码块，并生成一个新的`.md`文件，其中代码块已被它们的输出所替换。然后，您可以将其Markdown文件转换为更易读的PDF或HTML文档，或者期刊要求您发送的Word文档。
- en: Behind the scenes in RStudio, this is all done using the `knitr` and `rmarkdown`
    libraries. The latter provides a `render()` function that takes you from `.Rmd`
    to HTML or PDF in a single step. Conversely, if you just want to extract the code
    you’ve written from the surrounding text, then you “tangle” the file, which results
    in an `.R` file. The strength of this approach is that is makes it much easier
    to document your work properly. There is just one file for both the data analysis
    and the writeup. The output of the analysis is created on the fly, and the code
    to do it is embedded in the paper. If you need to do multiple but identical (or
    very similar) analyses of different bits of data, RMarkdown and `knitr` can make
    generating consistent and reliable reports much easier.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在RStudio的背后，所有这些操作都是通过`knitr`和`rmarkdown`库来完成的。后者提供了一个`render()`函数，它可以将`.Rmd`文件一步转换成HTML或PDF。相反，如果你只想从周围文本中提取你编写的代码，那么你可以“编织”文件，这将生成一个`.R`文件。这种方法的优点是它使得正确地记录你的工作变得容易得多。对于数据分析和撰写报告，只需要一个文件。分析的结果会即时创建，执行它的代码被嵌入到论文中。如果你需要对不同的数据块进行多个但相同（或非常相似）的分析，RMarkdown和`knitr`可以使生成一致且可靠的报告变得容易得多。
- en: Pandoc’s flavor of Markdown is the one used in knitr and RStudio. It allows
    for a wide range of markup, and can handle many of the nuts and bolts of scholarly
    writing, such as complex tables, citations, bibliographies, references, and mathematics.
    In addition to being able to produce documents in various *file* formats, it can
    also produce many different *kinds* of document, from articles and handouts to
    websites and slide decks. RStudio’s RMarkdown website has extensive documentation
    and examples on the ins and outs of RMarkdown’s capabilities, including information
    on customizing it if you wish.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: Pandoc的Markdown版本是knitr和RStudio中使用的版本。它支持广泛的标记格式，并能处理学术写作中的许多基本元素，例如复杂表格、引用、书目、参考文献和数学公式。除了能够生成各种*文件格式*的文档外，它还能生成多种不同类型的文档，从文章和讲义到网站和幻灯片。RStudio的RMarkdown网站提供了关于RMarkdown功能详尽的文档和示例，包括如果你希望对其进行自定义的信息。
- en: Writing your notes and papers in a plain text format like this has many advantages.
    It keeps your writing, your code, and your results closer together, and allows
    you to use powerful version control methods to keep track of your work and your
    results. Errors in data analysis often well up out of the gap that typically exists
    between the procedure used to produce a figure or table in a paper and the subsequent
    use of that output later. In the ordinary way of doing things, you have the code
    for your data analysis in one file, the output it produced in another, and the
    text of your paper in a third file. You do the analysis, collect the output and
    copy the relevant results into your paper, often manually reformatting them on
    the way. Each of these transitions introduces the opportunity for error. In particular,
    it is easy for a table of results to get detached from the sequence of steps that
    produced it. Almost everyone who has written a quantitative paper has been confronted
    with the problem of reading an old draft containing results or figures that need
    to be revisited or reproduced (as a result of peer-review, say) but which lack
    any information about the circumstances of their creation. Academic papers take
    a long time to get through the cycle of writing, review, revision, and publication,
    even when you’re working hard the whole time. It is not uncommon to have to return
    to something you did two years previously in order to answer some question or
    other from a reviewer. You do not want to have to do everything over from scratch
    in order to get the right answer. I am not exaggerating when I say that, whatever
    the challenges of replicating the results of someone else’s quantitative analysis,
    after a fairly short period of time authors themselves find it hard to replicate
    their *own* work. *Bit-rot* is the term of art in Computer Science for the seemingly
    inevitable process of decay that overtakes a project just because you left it
    alone on your computer for six months or more.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种纯文本格式（如）编写你的笔记和论文有许多优点。它使你的写作、你的代码和你的结果更接近，并允许你使用强大的版本控制方法来跟踪你的工作和结果。数据分析中的错误通常会在产生论文中图表或表格的流程与随后使用该输出的流程之间存在的典型差距中涌现出来。在常规的操作方式中，你的数据分析代码在一个文件中，它产生的输出在另一个文件中，你的论文文本在第三个文件中。你进行数据分析，收集输出并将相关的结果复制到你的论文中，通常在途中手动重新格式化它们。这些过渡中的每一个都引入了出错的机会。特别是，结果表很容易与产生它的步骤序列分离。几乎每个写过定量论文的人都会遇到阅读旧草稿的问题，其中包含需要重新审视或再现的结果或图表（例如，由于同行评审），但缺乏关于它们创建情况的信息。即使你一直在努力工作，学术论文也要经过写作、评审、修订和发表的周期，这需要很长时间。不得不返回两年前做的事情以回答评审员的一些问题并不罕见。你不想从头开始做所有的事情来得到正确的答案。我说作者在相当短的时间内发现自己很难复制他们自己的工作，这并不是夸张。在计算机科学中，“位腐化”这个术语是指一个项目似乎不可避免地经历的过程，仅仅是因为你把它留在电脑上六个月或更长时间。
- en: For small and medium-sized projects, plain text approaches that rely on RMarkdown
    documents and the tools described here work well. Things become a little more
    complicated as projects get larger. (This is not an intrinsic flaw of plain-text
    methods, by the way. It is true no matter how you choose to organize your project.)
    In general, it is worth trying to keep your notes and analysis in a standardized
    and simple format. The final outputs of projects (such as journal articles or
    books) tend, as they approach completion, to descend into a rush of specific fixes
    and adjustments, all running against the ideal of a fully portable, reproducible
    analysis. It is worth trying to minimize the scope of the inevitable final scramble.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型和中型项目，依赖于RMarkdown文档和这里描述的工具的纯文本方法效果良好。随着项目的扩大，事情会变得稍微复杂一些。（顺便说一句，这并不是纯文本方法的固有缺陷。无论你如何选择组织你的项目，这都是事实。）一般来说，尝试保持你的笔记和分析以标准化和简单的格式存在是值得的。项目最终输出（如期刊文章或书籍）在接近完成时，往往会陷入一系列具体的修复和调整的匆忙中，所有这些都与完全可移植、可重复分析的理想背道而驰。尝试最小化不可避免的最终混乱的范围是值得的。
- en: A.3.2 Project organization
  id: totrans-540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.2 项目组织
- en: Managing projects is a large topic of its own, and one that people have strong
    opinions about. Your goal should be to make your code and data portable, reproducible,
    and self-contained. In practice that means using a project based approach in R
    Studio. When you start an analysis with some new data, create a new project containing
    the data and the R or RMarkdown code you will be working with. It should then
    be possible, in the ideal case, to move that folder to another computer that also
    has R, RStudio, and any required libraries installed, and successfully re-run
    the contents of the project.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 管理项目是一个庞大的主题，人们对它有着强烈的看法。你的目标应该是使你的代码和数据具有可移植性、可重复性和自包含性。在实践中，这意味着在 R Studio
    中采用基于项目的方法。当你开始使用一些新数据进行分析时，创建一个包含数据和你要使用的 R 或 RMarkdown 代码的新项目。在理想情况下，你应该能够将这个文件夹移动到另一台也安装了
    R、RStudio 和任何所需库的计算机上，并成功重新运行项目的内容。
- en: In practice that means two things. First, even though R is an object-oriented
    language, the only “real”, persistent things in your project should be the raw
    data files you start with, and the code that operates on them. The code is what
    is real. Your code manipulates the data and creates all of the objects and outputs
    you need. It’s possible to save objects in R but in general you should not need
    to do this for everyday analysis.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这意味着两件事。首先，尽管 R 是一种面向对象的语言，但你的项目中唯一“真实”的、持久的东西应该是你开始时的原始数据文件和操作它们的代码。代码才是真实的。你的代码操纵数据并创建你需要的所有对象和输出。在
    R 中保存对象是可能的，但通常你不需要在日常分析中这样做。
- en: 'Second, your code should not refer to any file locations outside of the project
    folder. The project folder should be the “root” or ground floor for the files
    inside it. This means you should not use *absolute* file paths to save or refer
    to data or figures. Instead, use only *relative* paths. A relative path will start
    at the root of the project. So, for example, you should not load data with a command
    like this:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你的代码不应该引用项目文件夹之外任何文件的位置。项目文件夹应该是其中文件的“根”或底层。这意味着你不应该使用 *绝对* 文件路径来保存或引用数据或图表。相反，只使用
    *相对* 路径。相对路径将从项目的根开始。例如，你不应该用这样的命令加载数据：
- en: '[PRE207]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Instead, because you have an R project file started in the `gss` folder you
    can use the `here()` library to specify a relative path, like this:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，因为你已经在 `gss` 文件夹中启动了 R 项目文件，你可以使用 `here()` 库来指定相对路径，如下所示：
- en: '[PRE208]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: While you could type the relative paths out yourself, using `here()` has the
    advantage that it will work if, for example, you use Mac OS and you send your
    project to someone working on Windows. The same rule goes for saving your work,
    as we saw at the end of Chapter @(sec:makeplot), when you save individual plots
    as PDF or PNG files.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以自己输入相对路径，但使用 `here()` 有一个优点，即如果你使用的是 Mac OS 并且将项目发送给使用 Windows 的人，它仍然会工作。同样的规则也适用于保存你的工作，正如我们在第
    @(sec:makeplot) 章节末尾所看到的，当你将单个图表保存为 PDF 或 PNG 文件时。
- en: '![Folder organization for a simple project.](../Images/121f0a5c0a13ac2f29b9f15a9cd8e0b4.png)
    Figure A.9: Folder organization for a simple project.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '![简单项目的文件夹组织](../Images/121f0a5c0a13ac2f29b9f15a9cd8e0b4.png) 图 A.9：简单项目的文件夹组织。'
- en: Within your project folder, a little organization goes a long way. You should
    get in the habit of keeping different parts of the project in different sub-folders
    of your working directory. More complex projects may have a more complex structure,
    but you can go a long way with some simple organization. RMarkdown files can be
    in the top level of your working directory, with separate sub-folders called `data/`
    (for your CSV files), one for `figures/` (that you might save) and perhaps one
    called `docs/` for information about your project or data files files. Rstudio
    can help with organization as well through its project management features.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目文件夹内，一点组织就能走得很远。你应该养成将项目的不同部分保存在工作目录的不同子文件夹中的习惯。更复杂的项目可能具有更复杂的结构，但通过一些简单的组织，你就能走得很远。RMarkdown
    文件可以放在工作目录的顶层，有单独的子文件夹称为 `data/`（用于你的 CSV 文件），一个用于 `figures/`（你可能保存的），也许还有一个名为
    `docs/` 的用于项目或数据文件信息的文件夹。RStudio 通过其项目管理功能也可以帮助你进行组织。
- en: Keeping your project organized just a little bit will prevent you from ending
    up with huge numbers of files of different kinds all sitting at the top of your
    working directory.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 只稍微组织一下你的项目，就可以防止你最终在顶层工作目录中拥有大量不同类型的文件。
- en: A.4 Some features of this book
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.4 本书的一些特点
- en: A.4.1 Preparing the county-level maps
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.1 准备县级地图
- en: The U.S. county-level maps in the `socviz` library were prepared using shapefiles
    from the U.S. Census Bureau that were converted to GeoJSON format by Eric Celeste.`eric.clst.org/Stuff/USGeoJSON`
    The code to prepare the imported shapefile was written by Bob Rudis, and draws
    on the `rgdal` library to do the heavy lifting of importing the shapefile and
    transforming the projection. Bob’s code extracts the (county-identifying) rownames
    from the imported spatial data frame, and then moves Alaska and Hawaii to new
    locations in the bottom left of the map area, so that we can map all fifty states
    instead of just the lower forty eight.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`socviz` 库中的美国县级地图是通过使用美国人口普查局的 shapefiles 准备的，这些 shapefiles 由 Eric Celeste
    转换为 GeoJSON 格式。`eric.clst.org/Stuff/USGeoJSON` 准备导入的 shapefile 的代码由 Bob Rudis
    编写，并利用 `rgdal` 库来完成导入 shapefile 和转换投影的重任。Bob 的代码从导入的空间数据框中提取（县标识的）行名，然后将阿拉斯加和夏威夷移动到地图区域的左下角，这样我们就可以绘制所有五十个州，而不仅仅是下方的四十八个州。'
- en: First we read in the map file, set the projection, and set up an identifying
    variable we can work with later on to merge in data. The call to `CRS()` is a
    single long line of text conforming to a technical GIS specification defining
    the projection and other details that the map is encoded in. Long lines of code
    are conventionally indicated by the backslash charater, “`\`”, when we have to
    artificially break them on the page. Do not type the backslash if you write out
    this code yourself. We assume the mapfile is named `gz_2010_us_050_00_5m.json`
    and is in the `data/geojson` subfolder of the project directory.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们读取地图文件，设置投影，并设置一个标识变量，以便我们稍后可以将其与数据合并。`CRS()` 调用是一行符合技术 GIS 规范的长文本，定义了地图编码的投影和其他细节。当我们需要在页面上人工断行时，长行代码通常用反斜杠字符
    “`\`” 表示。如果你自己编写此代码，请不要输入反斜杠。我们假设地图文件名为 `gz_2010_us_050_00_5m.json`，并且位于项目目录的
    `data/geojson` 子文件夹中。
- en: '[PRE209]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: With the file imported, we then extract, rotate, shrink, and move Alaska, resetting
    the projection in the process. We also move Hawaii. The areas are identified by
    their State FIPS codes. We remove the old states and put the new ones back in,
    and remove Puerto Rico as our examples lack data for this region. If you have
    data for the area, you can move it between Texas and Florida.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 文件导入后，我们随后提取、旋转、缩小并移动阿拉斯加，在这个过程中重置投影。我们还将夏威夷移动。这些区域通过它们的州 FIPS 码进行标识。我们移除旧州，将新州放回原位，并移除波多黎各，因为我们的示例缺乏该地区的数据。如果您有该地区的数据，您可以将它移动到德克萨斯州和佛罗里达州之间。
- en: '[PRE210]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: Finally, we tidy the spatial object into a data frame that ggplot can use, and
    clean up the `id` label by stripping out a prefix from the string.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将空间对象整理成 ggplot 可以使用的数据框，并通过从字符串中删除前缀来清理 `id` 标签。
- en: '[PRE211]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: AtFor more detail and code for the merge, see `github.com/kjhealy/us-county`
    this point the `county_map` object is ready to be merged with a table of FIPS-coded
    US county data using either `merge()` or `left_join()`.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 关于合并的更多细节和代码，请参阅 `github.com/kjhealy/us-county` 此点，`county_map` 对象现在可以与 FIPS
    编码的美国县级数据表合并，使用 `merge()` 或 `left_join()`。
- en: A.4.2 This book’s plot theme, and its map theme
  id: totrans-561
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.2 本书使用的绘图主题及其地图主题
- en: 'The ggplot theme used in this book is derived principally from the work (again)
    of Bob Rudis. His `hrbrthemes` package provides `theme_ipsum()`, a compact theme
    that can be used with the Arial typeface or, in a variant, the freely available
    Roboto Condensed typeface. The main difference between the `theme_book()` used
    here and Rudis’s `theme_ipsum()` is the choice of typeface. The `hrbrthemes` package
    can be installed from GitHub in the usual way:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的 ggplot 主题主要源自 Bob Rudis 的作品（再次）。他的 `hrbrthemes` 包提供了 `theme_ipsum()`，这是一个紧凑的主题，可以与
    Arial 字体或其变体、免费可用的 Roboto Condensed 字体一起使用。这里使用的 `theme_book()` 与 Rudis 的 `theme_ipsum()`
    之间的主要区别在于字体的选择。`hrbrthemes` 包可以通过 GitHub 以通常的方式安装：
- en: '[PRE212]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: The`github.com/kjhealy/myriad` book theme is also available on GitHub. This
    package does not include the font files themselves. These are available from Adobe,
    who make the typeface.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/kjhealy/myriad` 书籍主题也可在 GitHub 上找到。此包不包括字体文件本身。这些文件可以从 Adobe 获取，Adobe
    是该字体的制造商。'
- en: 'When drawing maps we also used a `theme_map()` function. This theme begins
    with the built-in `theme_bw()` and turns off most of the guide, scale, panel content
    that is not needed when presenting a map. It is available through the `socviz`
    library. The code looks like this:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制地图时，我们还使用了 `theme_map()` 函数。此主题以内置的 `theme_bw()` 为基础，关闭了大多数在展示地图时不需要的指南、刻度、面板内容。它通过
    `socviz` 库提供。代码看起来是这样的：
- en: '[PRE213]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Themes are functions. Creating a theme means writing a function with a sequence
    of instructions about what thematic elements to modify, and how. We give it a
    default `base_size` argument and an empty `base_family` argument (for the font
    family). The `%+replace%` operator in the code is new to us. This is a convenience
    operator defined by ggplot and used for updating theme elements in bulk. Throughout
    the book we saw repeated use of the `+` operator to incrementally add to or tweak
    the content of a theme, as when we would do `+ theme(legend.position = "top")`.
    Using `+` added the instruction to the theme, adjusting whatever was specified
    and leaving everything else as it was. The `%+replace%` operator does something
    similar, but it has a stronger effect. We begin with `theme_bw()` and then use
    a `theme()` statement to add new content, as usual. The `%+replace%` operator
    replaces the entire element specified, rather than adding to it. Any element not
    specified in the `theme()` statement will be deleted from the new theme. So this
    is a way to create themes by both starting from existing ones, specifying new
    elements, and deleting anything not explicitly mentioned. See the documentation
    for `theme_get()` for more details. In the function here, you can see each of
    the thematic elements that are “switched off” using the `element_blank()` function.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 主题是函数。创建一个主题意味着编写一个包含一系列指令的函数，这些指令说明了如何修改哪些主题元素以及如何修改。我们给它一个默认的 `base_size`
    参数和一个空的 `base_family` 参数（用于字体家族）。代码中的 `%+replace%` 操作符对我们来说是新的。这是一个由 ggplot 定义的便利操作符，用于批量更新主题元素。在整本书中，我们看到了
    `+` 操作符的重复使用，用于逐步添加或调整主题的内容，就像我们做 `+ theme(legend.position = "top")` 一样。使用 `+`
    向主题添加了指令，调整了指定的内容，而其他内容保持不变。`%+replace%` 操作符做的是类似的事情，但它有更强的效果。我们从 `theme_bw()`
    开始，然后使用 `theme()` 语句添加新内容，就像平常一样。`%+replace%` 操作符会替换整个指定的元素，而不是添加到它。在 `theme()`
    语句中没有指定的任何元素都将从新的主题中删除。因此，这是一种通过从现有主题开始、指定新元素以及删除任何未明确提及的内容来创建主题的方法。有关 `theme_get()`
    的详细信息，请参阅文档。在下面的函数中，你可以看到使用 `element_blank()` 函数“关闭”的每个主题元素。
- en: A.4.1 Preparing the county-level maps
  id: totrans-568
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.1 准备县级地图
- en: The U.S. county-level maps in the `socviz` library were prepared using shapefiles
    from the U.S. Census Bureau that were converted to GeoJSON format by Eric Celeste.`eric.clst.org/Stuff/USGeoJSON`
    The code to prepare the imported shapefile was written by Bob Rudis, and draws
    on the `rgdal` library to do the heavy lifting of importing the shapefile and
    transforming the projection. Bob’s code extracts the (county-identifying) rownames
    from the imported spatial data frame, and then moves Alaska and Hawaii to new
    locations in the bottom left of the map area, so that we can map all fifty states
    instead of just the lower forty eight.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`socviz` 库中的美国县级地图是使用美国人口普查局的 shapefiles 准备的，这些 shapefiles 由 Eric Celeste 转换为
    GeoJSON 格式。`eric.clst.org/Stuff/USGeoJSON` 准备导入的 shapefile 的代码是由 Bob Rudis 编写的，并利用
    `rgdal` 库来完成导入 shapefile 和转换投影的重工作。Bob 的代码从导入的空间数据框中提取（识别县名的）行名，然后将阿拉斯加和夏威夷移动到地图区域的左下角，这样我们就可以绘制所有五十个州，而不仅仅是下方的四十八个州。'
- en: First we read in the map file, set the projection, and set up an identifying
    variable we can work with later on to merge in data. The call to `CRS()` is a
    single long line of text conforming to a technical GIS specification defining
    the projection and other details that the map is encoded in. Long lines of code
    are conventionally indicated by the backslash charater, “`\`”, when we have to
    artificially break them on the page. Do not type the backslash if you write out
    this code yourself. We assume the mapfile is named `gz_2010_us_050_00_5m.json`
    and is in the `data/geojson` subfolder of the project directory.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们读取地图文件，设置投影，并设置一个我们可以稍后用于合并数据的识别变量。对 `CRS()` 的调用是一行符合技术 GIS 规范的文本，定义了投影和其他地图编码的细节。当我们需要在页面上人工断行时，长行代码通常用反斜杠字符
    “`\`” 表示。如果你自己编写此代码，请不要输入反斜杠。我们假设地图文件名为 `gz_2010_us_050_00_5m.json`，并且位于项目目录的
    `data/geojson` 子目录中。
- en: '[PRE214]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: With the file imported, we then extract, rotate, shrink, and move Alaska, resetting
    the projection in the process. We also move Hawaii. The areas are identified by
    their State FIPS codes. We remove the old states and put the new ones back in,
    and remove Puerto Rico as our examples lack data for this region. If you have
    data for the area, you can move it between Texas and Florida.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 文件导入后，我们接着提取、旋转、缩小和移动阿拉斯加，在此过程中重置投影。我们还将夏威夷移动。区域通过它们的州FIPS代码来识别。我们移除旧州并将新州放回原位，并移除波多黎各，因为我们的示例缺乏该地区的数据。如果您有该地区的数据，您可以在德克萨斯州和佛罗里达州之间移动它。
- en: '[PRE215]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Finally, we tidy the spatial object into a data frame that ggplot can use, and
    clean up the `id` label by stripping out a prefix from the string.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将空间对象整理成ggplot可以使用的数据框，并通过从字符串中去除前缀来清理`id`标签。
- en: '[PRE216]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: AtFor more detail and code for the merge, see `github.com/kjhealy/us-county`
    this point the `county_map` object is ready to be merged with a table of FIPS-coded
    US county data using either `merge()` or `left_join()`.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 对于合并的更多细节和代码，请参阅`github.com/kjhealy/us-county`。在此点，`county_map`对象已准备好与FIPS编码的美国县数据表合并，可以使用`merge()`或`left_join()`。
- en: A.4.2 This book’s plot theme, and its map theme
  id: totrans-577
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.2 本书使用的绘图主题及其地图主题
- en: 'The ggplot theme used in this book is derived principally from the work (again)
    of Bob Rudis. His `hrbrthemes` package provides `theme_ipsum()`, a compact theme
    that can be used with the Arial typeface or, in a variant, the freely available
    Roboto Condensed typeface. The main difference between the `theme_book()` used
    here and Rudis’s `theme_ipsum()` is the choice of typeface. The `hrbrthemes` package
    can be installed from GitHub in the usual way:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的ggplot主题主要源自（再次）Bob Rudis的工作。他的`hrbrthemes`包提供了`theme_ipsum()`，这是一个紧凑的主题，可以与Arial字体一起使用，或者在一个变体中，可以免费使用的Roboto
    Condensed字体。这里使用的`theme_book()`与Rudis的`theme_ipsum()`之间的主要区别是字体的选择。《hrbrthemes》包可以通过GitHub以常规方式安装：
- en: '[PRE217]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: The`github.com/kjhealy/myriad` book theme is also available on GitHub. This
    package does not include the font files themselves. These are available from Adobe,
    who make the typeface.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/kjhealy/myriad`这本书的主题也可在GitHub上找到。此包不包括字体文件本身。这些文件可以从Adobe获取，他们是这种字体的制造商。'
- en: 'When drawing maps we also used a `theme_map()` function. This theme begins
    with the built-in `theme_bw()` and turns off most of the guide, scale, panel content
    that is not needed when presenting a map. It is available through the `socviz`
    library. The code looks like this:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制地图时，我们还使用了`theme_map()`函数。此主题从内置的`theme_bw()`开始，关闭了大多数在展示地图时不需要的指南、刻度、面板内容。它可以通过`socviz`库获得。代码看起来是这样的：
- en: '[PRE218]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: Themes are functions. Creating a theme means writing a function with a sequence
    of instructions about what thematic elements to modify, and how. We give it a
    default `base_size` argument and an empty `base_family` argument (for the font
    family). The `%+replace%` operator in the code is new to us. This is a convenience
    operator defined by ggplot and used for updating theme elements in bulk. Throughout
    the book we saw repeated use of the `+` operator to incrementally add to or tweak
    the content of a theme, as when we would do `+ theme(legend.position = "top")`.
    Using `+` added the instruction to the theme, adjusting whatever was specified
    and leaving everything else as it was. The `%+replace%` operator does something
    similar, but it has a stronger effect. We begin with `theme_bw()` and then use
    a `theme()` statement to add new content, as usual. The `%+replace%` operator
    replaces the entire element specified, rather than adding to it. Any element not
    specified in the `theme()` statement will be deleted from the new theme. So this
    is a way to create themes by both starting from existing ones, specifying new
    elements, and deleting anything not explicitly mentioned. See the documentation
    for `theme_get()` for more details. In the function here, you can see each of
    the thematic elements that are “switched off” using the `element_blank()` function.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 主题是函数。创建一个主题意味着编写一个包含一系列指令的函数，这些指令说明了要修改哪些主题元素以及如何修改。我们给它一个默认的`base_size`参数和一个空的`base_family`参数（用于字体家族）。代码中的`%+replace%`运算符对我们来说是新的。这是一个由ggplot定义的便利运算符，用于批量更新主题元素。在整本书中，我们看到了`+`运算符的重复使用，用于逐步添加或调整主题的内容，就像我们做`+
    theme(legend.position = "top")`时一样。使用`+`会将指令添加到主题中，调整指定的内容，而其他内容保持不变。`%+replace%`运算符做的是类似的事情，但它有更强的效果。我们从`theme_bw()`开始，然后使用`theme()`语句添加新内容，就像平常一样。`%+replace%`运算符会替换整个指定的元素，而不是添加到它上面。在`theme()`语句中没有指定的任何元素都将从新主题中删除。因此，这是一种通过从现有主题开始、指定新元素以及删除未明确提及的任何内容来创建主题的方法。有关`theme_get()`的详细信息，请参阅文档。在下面的函数中，你可以看到使用`element_blank()`函数“关闭”的每个主题元素。
