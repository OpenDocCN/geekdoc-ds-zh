<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>25¬†Factoring Numbersüîó</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>25¬†Factoring Numbersüîó</h1>
<blockquote>ÂéüÊñáÔºö<a href="https://dcic-world.org/2025-08-27/factoring-numbers.html">https://dcic-world.org/2025-08-27/factoring-numbers.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td/></tr></table><p>Much of modern cryptography is founded on the difficulty of factoring
numbers. Suppose we want to factorize \(n\). We can just check whether
any of the numbers from \(2\) to \(n-1\) (indeed, up to \(\sqrt{n}\))
divides \(n\): if it does, then it‚Äôs a factor, and we recursively
factor what‚Äôs left. So that just takes a linear amount of time! Why is
this hard?</p><p>The problem is it‚Äôs linear in the ‚Äúwrong‚Äù thing: the value of the
number. However, the value of a number is, in a place notation, in the
worst case exponential in its size. So we‚Äôd have to iterate until at
least the square root of the exponential of the size, which is size
divided by 2, which is in the same big-O class, i.e., exponential in
the value. In general we don‚Äôt really know how to improve the
worst-case performance of factorization, which is why contemporary
cryptography works. (We discuss numbers elsewhere too
[<a href="avoid-recomp.html#%28part._numbers-not-constant%29" data-pltdoc="x">The Complexity of Numbers</a>].)</p><p>In practice, it is useful to have factorization algorithms that
terminate quickly. They obviously cannot be perfect; we have to
compromise instead on accuracy in one way or another: reporting a
non-prime as a prime, reporting a non-factor as a factor, etc.</p><p>One well-known algorithm is called Pollard‚Äôs rho algorithm. It will
attempt to find a factor for a number. If it succeeds, we are
guaranteed that what it found is indeed a factor. If it fails,
however, we cannot be sure that the number is actually prime: there
may be other factors lurking.</p><p>The algorithm gets its name from a picture that should be familiar from
<a href="cycle-detection.html" data-pltdoc="x">Detecting Cycles</a>:</p><p><img src="../Images/31742a6ba02914cbc2bca965912ea982.png" alt="" data-original-src="https://dcic-world.org/2025-08-27/cycle-rho.png"/></p><p>If you rotate that a little bit, you get the Greek letter
\(\rho\). The similarity, as we will see in a moment, is not a
coincidence.</p><p>Explaining the algorithm requires more number theory than we can cover
here: if you‚Äôre interested, read more about it
<a href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm">on Wikipedia</a>.
Instead, we will focus on the code.</p><p>First, we need a helper function that can compute the greatest common denominator:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun gcd(a, b):
  if b == 0:
    a
  else:
    gcd(b, num-modulo(a, b))
  end
end</code></pre><p>With that, we can define the Pollard-rho implementation. Recall that
the function may or may not succeed in finding a factor (in
particular, it must fail when given a prime!), so we use an
<code data-lang="pyret" class="sourceCode">Option</code> type to reflect the two possibilities:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pr(n):
  fun g(x): num-modulo((x * x) + 1, n) end
  fun loop(x, y, d):
    new-x = g(x)
    new-y = g(g(y))
    new-d = gcd(num-abs(new-x - new-y), n)
    ask:
      | new-d == 1 then:
        loop(new-x, new-y, new-d)
      | new-d == n then:
        none
      | otherwise:
        some(new-d)
    end
  end
  loop(2, 2, 1)
end</code></pre><p>The key step is the computation <code data-lang="pyret" class="sourceCode">g(x)</code> versus <code data-lang="pyret" class="sourceCode">g(g(x))</code>. We
can imagine <code data-lang="pyret" class="sourceCode">x</code> is the tortoise, so <code data-lang="pyret" class="sourceCode">g(x)</code> is the tortoise‚Äôs
update, while <code data-lang="pyret" class="sourceCode">y</code> is the hare, so <code data-lang="pyret" class="sourceCode">g(g(y))</code> is the hare‚Äôs
update.</p><p>Try to run the above on the following values and see what it produces:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pr(6)
pr(14)
pr(35)
pr(37)
pr(41)
pr(8)
pr(44)</code></pre><p>In general, we can check the first few numbers and see how closely
they match our intuition:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for map(n from range(2, 100)):
  cases (Option) pr(n):
    | none =&gt; num-to-string(n) + " may be prime"
    | some(v) =&gt; num-to-string(n) + " has factor " + num-to-string(v)
  end
end</code></pre><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Do you see any patterns in the above output? Does it help you make any
conjectures about the algorithm? Can you mathematically prove your
conjectures?</p></blockquote></blockquote>    
</body>
</html>