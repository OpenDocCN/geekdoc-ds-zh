["```py\ndef *name of function* (*list of formal parameters*):\n    *body of function*\n```", "```py\ndef max_val(x, y):\n    if x > y:\n        return x\n    else:\n        return y\n```", "```py\n`max_val(3, 4)`\n```", "```py\n﻿def print_name(first_name, last_name, reverse): \n   if reverse:\n      print(last_name + ', ' + first_name)\n   else:\n      print(first_name, last_name)\n```", "```py\n﻿print_name('Olga', 'Puchmajerova', False)\nprint_name('Olga', 'Puchmajerova', reverse = False)\nprint_name('Olga', last_name = 'Puchmajerova', reverse = False)\nprint_name(last_name = 'Puchmajerova', first_name = 'Olga',\n          reverse = False)\n```", "```py\nprint_name('Olga', last_name = 'Puchmajerova', False)\n```", "```py\ndef print_name(first_name, last_name, reverse = False):\n   if reverse:\n      print(last_name + ', ' + first_name)\n   else:\n      print(first_name, last_name)\n```", "```py\nprint_name('Olga', 'Puchmajerova')\nprint_name('Olga', 'Puchmajerova', True)\nprint_name('Olga', 'Puchmajerova', reverse = True)\n```", "```py\nOlga Puchmajerova\nPuchmajerova, Olga\nPuchmajerova, Olga\n```", "```py\nprint_name(last_name = 'Puchmajerova', first_name = 'Olga')\n```", "```py\n﻿min(6,4)\nmin(3,4,1,6)\n```", "```py\n﻿﻿﻿﻿def mean(*args):\n    # Assumes at least one argument and all arguments are numbers\n    # Returns the mean of the arguments\n    tot = 0\n    for a in args:\n        tot += a\n    return tot/len(args)\n```", "```py\ndef f(x): #name x used as formal parameter\n    y = 1\n    x = x + y\n    print('x =', x)\n    return x\nx = 3\ny = 2\nz = f(x) #value of x used as actual parameter\nprint('z =', z)\nprint('x =', x)\nprint('y =', y)\n```", "```py\nx = 4\nz = 4\nx = 3\ny = 2\n```", "```py\nx = 4\nz = 4\nx = abc\nx = 4\nx = 3\nz = <function f.<locals>.g at 0x1092a7510>\nx = abc\n```", "```py\ndef f():\n   print(x)\ndef g():\n   print(x)\n   x = 1\nx = 3\nf()\nx = 3\ng()\n```", "```py\nUnboundLocalError: local variable 'x' referenced before assignment\n```", "```py\n﻿Help on built-in function abs in module builtins:\n\nabs(x, /)\n    Return the absolute value of the argument.\n```", "```py\n﻿help> if\nThe \"if\" statement\n******************\n\nThe \"if\" statement is used for conditional execution:\n\n   if_stmt ::= \"if\" expression \":\" suite\n               (\"elif\" expression \":\" suite)*\n               [\"else\" \":\" suite]\n\nIt selects exactly one of the suites by evaluating the expressions one\nby one until one is found to be true (see section Boolean operations\nfor the definition of true and false); then that suite is executed\n(and no other part of the \"if\" statement is executed or evaluated).\nIf all expressions are false, the suite of the \"else\" clause, if\npresent, is executed.\n\nRelated help topics: TRUTHVALUE\n```", "```py\n﻿find_root(x, power, epsilon)\n    Assumes x and epsilon int or float, power an int,\n        epsilon > 0 & power >= 1\n    Returns float y such that y**power is within epsilon of x.\n        If such a float does not exist, it returns None\n```", "```py\n﻿def log(x, base, epsilon):\n    \"\"\"Assumes x and epsilon int or float, base an int,\n           x > 1, epsilon > 0 & power >= 1\n       Returns float y such that base**y is within epsilon of x.\"\"\"\n```", "```py\ndef square(ans):\n    return ans**2\nlow, high = find_root_bounds(99, 2)\nprint(bisection_solve(99, square, 0.01, low, high)) \n```", "```py\nlambda *sequence of variable names* : *expression*\n```", "```py\nprint(bisection_solve(99, lambda ans: ans**2, 0.01, low, high)) \n```", "```py\n﻿def create_eval_ans():\n    power = input('Enter a positive integer: ')\n    return lambda ans: ans**int(power)\n```", "```py\n﻿eval_ans = create_eval_ans()\nprint(bisection_solve(99, eval_ans, 0.01, low, high))\n```", "```py\ndef find_last(s, sub):\n    \"\"\"s and sub are non-empty strings\n       Returns the index of the last occurrence of sub in s.\n       Returns None if sub does not occur in s\"\"\" \n```"]