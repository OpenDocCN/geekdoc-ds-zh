- en: 4.1¬†Introduction to Tabular Dataüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/intro-tabular-data.html](https://dcic-world.org/2025-08-27/intro-tabular-data.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[4.1.1¬†Creating Tabular Data](#%28part._.Creating_.Tabular_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[4.1.2¬†Extracting Rows and Cell Values](#%28part._.Extracting_.Rows_and_.Cell_.Values%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[4.1.3¬†Functions over Rows](#%28part._.Functions_over_.Rows%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[4.1.4¬†Processing Rows](#%28part._.Processing_.Rows%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[4.1.4.1¬†Finding Rows](#%28part._subsec~3afinding-rows%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[4.1.4.2¬†Ordering Rows](#%28part._.Ordering_.Rows%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[4.1.4.3¬†Adding New Columns](#%28part._.Adding_.New_.Columns%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[4.1.4.4¬†Calculating New Column Values](#%28part._.Calculating_.New_.Column_.Values%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[4.1.5¬†Examples for Table-Producing Functions](#%28part._.Examples_for_.Table-.Producing_.Functions%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[4.1.6¬†Lambda: Anonymous Functions](#%28part._sec~3alambda-tables%29)
    |'
  prefs: []
  type: TYPE_TB
- en: 'Many interesting data in computing are tabular‚Äî<wbr>i.e., like a table‚Äî<wbr>in
    form. First we‚Äôll see a few examples of them, before we try to identify what they
    have in common. Here are some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An email inbox is a list of messages. For each message, your inbox stores a
    bunch of information: its sender, the subject line, the conversation it‚Äôs part
    of, the body, and quite a bit more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/17a64e6b5180eb56ebf06a02ffe39113.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'A music playlist. For each song, your music player maintains a bunch of information:
    its name, the singer, its length, its genre, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/c49e8b34342ce5900ea7036fda0dff30.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: A filesystem folder or directory. For each file, your filesystem records a name,
    a modification date, size, and other information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/b73acd1cfa429053983b7085ec7786c9.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can you come up with more examples?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'How about:'
  prefs: []
  type: TYPE_NORMAL
- en: Responses to a party invitation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A gradebook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A calendar agenda.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can think of many more in your life!
  prefs: []
  type: TYPE_NORMAL
- en: 'What do all these have in common? The characteristics of tabular data are:'
  prefs: []
  type: TYPE_NORMAL
- en: They contain information about zero or more items (i.e., individuals or artifacts)
    that share characteristics. Each item is stored in a row. Each column tracks one
    of the shared attributes across the rows. For example, each song or email message
    or file is a row. Each of their characteristics‚Äî<wbr>the song title, the message
    subject, the filename‚Äî<wbr>is a column. While some spreadsheets might swap the
    roles of rows and columns, we stick to this organization as it aligns with the
    design of data-science software libraries. This is an example of what Hadley Wickham
    calls [tidy data](https://vita.had.co.nz/papers/tidy-data.pdf).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each row has the same columns as the other rows, in the same order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A given column has the same type, but different columns can have different types.
    For instance, an email message has a sender‚Äôs name, which is a string; a subject
    line, which is a string; a sent date, which is a date; whether it‚Äôs been read,
    which is a Boolean; and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rows might be in some particular order. For instance, the emails are ordered
    by which was most recently sent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Find the characteristics of tabular data in the other examples described above,
    as well as in the ones you described.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We will now learn how to program with tables and to how to decompose tasks
    that process them. To access the functions that we‚Äôll use to do this, you need
    to set the context (at the top of the definitions window) to dcic2024\. Earlier
    editions of the book had you use `shared-gdrive` to load a file to access these
    functions. This is no longer necessary when using the dcic2024 context. In CPO,
    click on the down arrow at the top left of the screen (left of the Pyret logo),
    select ‚ÄùChoose Context‚Äú, then enter dcic2024 in the box, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/710c9c4fd77163faf8376fe746fdec28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After you click the Submit button, the definitions window will show the name
    of the context as in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6d810094e710d0cc7fbef1bae2a68941.png)'
  prefs: []
  type: TYPE_IMG
- en: '[Documentation on the function-based table operators](https://hackmd.io/@cs111/table)
    is available on a separate page outside of the Pyret documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.1¬†Creating Tabular Data[üîó](#(part._.Creating_.Tabular_.Data) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Pyret provides multiple easy ways of creating tabular data. The simplest is
    to define the datum in a program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That is, a `table` is followed by the names of the columns in their desired
    order, followed by a sequence of `row`s. Each row must contain as many data as
    the column declares, and in the same order.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Change different parts of the above example‚Äî<wbr>e.g., remove a necessary value
    from a row, add an extraneous one, remove a comma, add an extra comma, leave an
    extra comma at the end of a row‚Äî<wbr>and see what errors you get.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Note that in a table, the order of columns matters: two tables that are otherwise
    identical but with different column orders are not considered equal.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Observe that the example above uses `is-not`, i.e., the test passes, meaning
    that the tables are not equal.
  prefs: []
  type: TYPE_NORMAL
- en: The `check:` annotation here is a way of writing `is` assertions about expressions
    outside of the context of a function (and its `where` block). We‚Äôll learn more
    about `check` in [From Examples to Tests](testing.html#%28part._from-examples-to-tests%29).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table expressions create table values. These can be stored in variables just
    like numbers, strings, and images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We call these literal tables when we create them with `table`. Pyret provides
    other ways to get tabular data, too! In particular, you can [import tabular data
    from a spreadsheet](https://www.pyret.org/docs/latest/gdrive-sheets.html), so
    any mechanism that lets you create such a sheet can also be used. You might:'
  prefs: []
  type: TYPE_NORMAL
- en: create the sheet on your own,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: create a sheet collaboratively with friends,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: find data on the Web that you can import into a sheet,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: create a Google Form that you get others to fill out, and obtain a sheet out
    of their responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and so on. Let your imagination run wild! Once the data are in Pyret, it doesn‚Äôt
    matter where they came from.
  prefs: []
  type: TYPE_NORMAL
- en: With tables, we begin to explore data that contain other (smaller) pieces of
    data. We‚Äôll refer to such data as structured data. Structured data organize their
    inner data in a structured way (here, rows and columns). As with images, when
    we wrote code that reflected the structure of the final image, we will see that
    code that works with tables also follows the structure of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.2¬†Extracting Rows and Cell Values[üîó](#(part._.Extracting_.Rows_and_.Cell_.Values)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Given a table, we sometimes want to look up the value of a particular cell.
    We‚Äôll work with the following table showing the number of riders on a shuttle
    service over several months:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you put this table in the definitions pane and press Run, what will be in
    the Pyret directory once the interactions prompt appears? Would the column names
    be listed in the directory?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: As a reminder, the directory contains only those names that we assign values
    to using the form `name =` . The directory here would contain `shuttle`, which
    would be bound to the table (yes, the entire table would be in the directory!).
    The column names would not have their own entries in the directory. At the low
    level, this is because we never wrote anything of the form `colname = ...`. At
    the high level, we don‚Äôt usually build tables by creating individual columns and
    putting them together side by side. (If anything, it is more common to create
    individual rows, since rows correspond to individual observations, events, or
    entities; we didn‚Äôt do that in this example, however).
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the name associated with a table, we can lookup the value in a
    given cell (row and column) in the table. Concretely, assume we want to extract
    the number of riders in March (`1087`) so we can use it in another computation.
    How do we do that?
  prefs: []
  type: TYPE_NORMAL
- en: Pyret (and most other programming languages designed for data analysis) organizes
    tables as collections of rows with shared columns. Given that organization, we
    get to a specific cell by first isolating the row we are interested in, then retrieving
    the contents of the cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pyret numbers the rows of a table from top to bottom starting at 0 (most programming
    languages use 0 as the first position in a piece of data, for reasons we will
    see later). So if we want to see the data for March, we need to isolate row 2\.
    We write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We use the period notation to dig into a piece of structured data. Here, we
    are saying "dig into the `shuttle` table, extracting row number `2`" (which is
    really the third row since Pyret counts positions from 0).
  prefs: []
  type: TYPE_NORMAL
- en: If we run this expression at the prompt, we get
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d60ae702af1ad3975e72ce720628831a.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a new type of data called a `Row`. When Pyret displays a `Row` value,
    it shows you the column names and the corresponding values within the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the value of a specific column within a row, we write the row followed
    by the name of the column (as a string) in square brackets. Here are two equivalent
    ways of getting the value of the `riders` column from the row for March:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What names would be in the Pyret directory when using each of these approaches?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Once we have the cell value (here a `Number`), we can use it in any other computation,
    such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: (which checks whether there were at least `1000` riders in March).
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What do you expect would happen if you forgot the quotation marks and instead
    wrote:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would Pyret do and why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 4.1.3¬†Functions over Rows[üîó](#(part._.Functions_over_.Rows) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have the ability to isolate Rows from tables, we can write functions
    that ask questions about individual rows. We just saw an example of doing a computation
    over row data, when we checked whether the row for March had more than 1000 riders.
    What if we wanted to do this comparison for an arbitrary row of this table? Let‚Äôs
    write a function! We‚Äôll call it `cleared-1K`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs start with a function header and some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This shows you what examples for `Row` functions look like, as well as how we
    use `Row` as an input type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fill in the body of the function, we extract the content of the `"riders"`
    cell and compare it to `1000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Looking at the examples, both of them share the `shuttle.row-n` portion. Would
    it have been better to instead make `cleared-1K` a function that takes just the
    row position as input, such as:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the benefits and limitations to doing this?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: In general, the version that takes the `Row` input is more flexible because
    it can work with a row from any table that has a column named `"riders"`. We might
    have another table with more columns of information or different data tables for
    different years. If we modify `cleared-1K` to only take the row position as input,
    that function will have to fix which table it works with. In contrast, our original
    version leaves the specific table (`shuttle`) outside the function, which leads
    to flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function `is-winter` that takes a `Row` with a `"month"` column as input
    and produces a `Boolean` indicating whether the month in that row is one of `"Jan"`,
    `"Feb"`, or `"Mar"`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function `low-winter` that takes in `Row` with both `"month"` and `"riders"`
    columns and produces a `Boolean` indicating whether the row is a winter row with
    fewer than 1050 riders.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Practice with the program directory! Take a `Row` function and one of its `where`
    examples, and show how the program directory evolves as you evaluate the example.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 4.1.4¬†Processing Rows[üîó](#(part._.Processing_.Rows) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, we have looked at extracting individual rows by their position in the
    table and computing over them. Extracting rows by position isn‚Äôt always convenient:
    we might have hundreds or thousands of rows, and we might not know where the data
    we want even is in the table. We would much rather be able to write a small program
    that identifies the row (or rows!) that meets a specific criterion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pyret offers three different notations for processing tables: one uses functions,
    one uses methods, and one uses a SQL-like notation. This chapter uses the function-based
    notation. The SQL-like notation and the methods-based notation are shown in the
    Pyret Documentation. To use the function-based notation, you‚Äôll need to include
    the file specified in the main narrative.'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this section assumes that you have loaded the functions notations
    for working with tables.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.4.1¬†Finding Rows[üîó](#(part._subsec~3afinding-rows) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Imagine that we wanted to write a program to locate a row that has fewer than
    `1000` riders from our `shuttle` table. With what we‚Äôve studied so far, how might
    we try to write this? We could imagine using a conditional, like follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What benefits and limitations do you see to this approach?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are a couple of reasons why we might not care for this solution. First,
    if we have thousands of rows, this will be terribly painful to write. Second,
    there‚Äôs a lot of repetition here (only the row positions are changing). Third,
    it isn‚Äôt clear what to do if there aren‚Äôt any matching rows. In addition, what
    happens if there are multiple rows that meet our criterion? In some cases, we
    might want to be able to identify all of the rows that meet a condition and use
    them for a subsequent computation (like seeing whether some months have more low-ridership
    days than others).
  prefs: []
  type: TYPE_NORMAL
- en: 'This conditional is, however, the spirit of what we want to do: go through
    the rows of the table one at a time, identifying those that match some criterion.
    We just don‚Äôt want to be responsible for manually checking each row. Fortunately
    for us, Pyret knows how to do that. Pyret knows which rows are in a given table.
    Pyret can pull out those rows one position at a time and check a criterion about
    each one.'
  prefs: []
  type: TYPE_NORMAL
- en: We just need to tell Pyret what criterion we want to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we can express our criterion as a function that takes a `Row` and
    produces a `Boolean` (a Boolean because our criterion was used as the question
    part of an `if` expression in our code sketch). In this case, we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we just need a way to tell Pyret to use this criterion as it searches
    through the rows. We do this with a function called `filter-with` which takes
    two inputs: the table to process and the criterion to check on each row of the
    table.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the hood, `filter-with` works roughly like the `if` statement we outlined
    above: it takes each row one at a time and calls the given criterion function
    on it. But what does it do with the results?'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the above expression, you‚Äôll see that `filter-with` produces a table
    containing the matching row, not the row by itself. This behavior is handy if
    multiple rows match the criterion. For example, try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '(using the `is-winter` function from an exercise earlier in this chapter).
    Now we get a table with the three rows corresponding to winter months. If we want
    to be able to name this table for use in future computations, we can do so with
    our usual notation for naming values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 4.1.4.2¬†Ordering Rows[üîó](#(part._.Ordering_.Rows) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let‚Äôs ask a new question: which winter month had the fewest number of riders?.
    This question requires us to identify a specific row, namely, the winter row with
    the smallest value in the `"riders"` column.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can we do this with `filter-with`? Why or why not?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Think back to the `if` expression that motivated `filter-with`: each row is
    evaluated independently of the others. Our current question, however, requires
    comparing across rows. That‚Äôs a different operation, so we will need more than
    `filter-with`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tools for analyzing data (whether programming languages or spreadsheets) provide
    ways for users to sort rows of a table based on the values in a single column.
    That would help us here: we could sort the winter rows from smallest to largest
    value in the `"riders"` column, then extract the `"riders"` value from the first
    row. First, let‚Äôs sort the rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `order-by` function takes three inputs: the table to sort (`winter`), the
    column to sort on (`"riders"`), and a `Boolean` to indicate whether we want to
    sort in increasing order. (Had the third argument been `false`, the rows would
    be sorted in decreasing order of the values in the named column.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/50fd4ee1a960ed4942030557bea37389.png)'
  prefs: []
  type: TYPE_IMG
- en: In the sorted table, the row with the fewest riders is in the first position.
    Our original question asked us to lookup the month with the fewest riders. We
    did this earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the code to extract the name of the winter month with the fewest riders.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here are two ways to write that computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of these two ways do you prefer? Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How does each of these programs affect the program directory?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Note that this problem asked us to combine several actions that we‚Äôve already
    seen on rows: we identify rows from within a table (`filter-with`), order the
    rows (`order-by`), extract a specific row (`row-n`), then extract a cell (with
    square brackets and a column name). This is typical of how we will operate on
    tables, combining multiple operations to compute a result (much as we did with
    programs that manipulate images).'
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.4.3¬†Adding New Columns[üîó](#(part._.Adding_.New_.Columns) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Sometimes, we want to create a new column whose value is based on those of
    existing columns. For instance, our table might reflect employee records, and
    have columns named `hourly-wage` and `hours-worked`, representing the corresponding
    quantities. We would now like to extend this table with a new column to reflect
    each employee‚Äôs total wage. Assume we started with the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The table we want to end up with is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '(with the expressions in the `total-wage` column computed to their numeric
    equivalents: we used the expressions here to illustrate what we are trying to
    do).'
  prefs: []
  type: TYPE_NORMAL
- en: Previously, when we have had a computation that we performed multiple times,
    we created a helper function to do the computation.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a helper function for computing total wages given the hourly wage and
    number of hours worked.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Perhaps you came up with something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'which we could use as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the right idea, but we can actually have this function do a bit more
    work for us. The `wage` and `hours` values are in cells within the same row. So
    if we could instead get the current row as an input, we could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'But now, we are writing calls to `compute-wages` over and over! Adding computed
    columns is a sufficiently common operation that Pyret provides a table function
    called `build-column` for this purpose. We use it by providing the function to
    use to populate values in the new column as an input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new column, `total-wage`, whose value in each row is the product
    of the two named columns in that row. Pyret will put the new column at the right
    end.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.4.4¬†Calculating New Column Values[üîó](#(part._.Calculating_.New_.Column_.Values)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Sometimes, we just want to calculate new values for an existing column, rather
    than create an entirely new column. Giving raises to employees is one such example.
    Assume we wanted to give a `10%` raise to all employees making less than `20`
    an hour. We could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, `transform-column` takes a table, the name of an existing column in the
    table, and a function to update the value. The updating function takes the current
    value in the column as input and produces the new value for the column as output.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run `give-raises` on the `employees` table. What wage will show for `"Miyako"`
    in the `employees` table after `give-raises` completes. Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Like all other Pyret `Table` operations, `transform-column` produces a new table,
    leaving the original intact. Editing the original table could be problematic‚Äìwhat
    if you made a mistake? How would you recover the original table in that case?
    In general, producing new tables with any modifications, then creating a new name
    for the updated table once you have the one you want, is a less error-prone way
    of working with datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.5¬†Examples for Table-Producing Functions[üîó](#(part._.Examples_for_.Table-.Producing_.Functions)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How do we write examples for functions that produce tables? Conceptually, the
    answer is simply "make sure you got the output table that you expected". Logistically,
    writing examples for table functions seems more painful because writing out an
    expected output tables is more work than simply writing the output of a function
    that produces numbers or strings. What can we do to manage that complexity?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How might you write the `where` block for `give-raises`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here are some ideas for writing the examples practically:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simplify the input table. Rather than work with a large table with all of the
    columns you have, create a small table that has sufficient variety only in the
    columns that the function uses. For our example, we might use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Would any table with a column of numbers work here? Or are there some constraints
    on the rows or columns of the table?
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The only constraint is that your input table has to have the column names used
    in your function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remember that you can write computations in the code to construct tables. This
    saves you from doing calculations by hand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This example shows that you can write an output table directly in the `where:`
    block ‚Äì the table doesn‚Äôt need to be named outside the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new table by taking rows from an existing table. If you were instead
    writing examples for a function that involves filtering out rows of a table, it
    helps to know how to create a new table using rows of an existing one. For example,
    if we were writing a function to find all rows in which employees were working
    exactly 40 hours, we‚Äôd like to make sure that the resulting table had the first
    and fourth rows of the `employees` table. Rather than write a new `table` expression
    to create that table, we could write it as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `employees.empty()` creates a new, empty table with the same column headers
    as `employees`. We‚Äôve already seen how `row-n` extracts a row from a table. The
    `add-row` function places the given row at the end of the given table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Another tip to keep in mind: when the only thing your function does is call
    a built-in function like `transform-column` it usually suffices to write examples
    for the function you wrote to compute the new column value. It is only when your
    code is combining table operations, or doing more complex processing than a single
    call to a built-in table operation that you really need to present your own examples
    to a reader of your code.'
  prefs: []
  type: TYPE_NORMAL
- en: '4.1.6¬†Lambda: Anonymous Functions[üîó](#(part._sec~3alambda-tables) "Link to
    here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let‚Äôs revisit the program we wrote in [Finding Rows](#%28part._subsec~3afinding-rows%29)
    for finding all of the months in a table with fewer than 1000 riders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This program might feel a bit verbose: do we really need to write a helper
    function just to perform something as simple as a `filter-with`? Wouldn‚Äôt it be
    easier to just write something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will Pyret produce if you run this expression?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pyret will produce an `unbound identifier` error around the use of `r` in this
    expression. What is `r`? We mean for `r` to be the elements from `shuttle` in
    turn. Conceptually, that‚Äôs what `filter-with` does, but we don‚Äôt have the mechanics
    right. When we call a function, we evaluate the arguments before the body of the
    function. Hence, the error regarding `r` being unbound. The whole point of the
    `below-1K` helper function is to make `r` a parameter to a function whose body
    is only evaluated once a value for `r` is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tighten the notation as in the one-line `filter-with` expression, then,
    we have to find a way to tell Pyret to make a temporary function that will get
    its inputs once `filter-with` is running. The following notation achieves this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have added `lam(r)` and `end` around the expression that we want to use in
    the `filter-with`. The `lam(r)` says "make a temporary function that takes `r`
    as an input". The `end` serves to end the function definition, as when we use
    `fun`. `lam` is short for `lambda`, a form of function definition that exists
    in many, though not all, languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference between our original expression (using the `below-1K` helper)
    and this new one (using `lam`) can be seen through the program directory. To explain
    this, a little detail about how `filter-with` is defined under the hood. In part,
    it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Whether we pass `below-1K` or the `lam` version to `filter-with`, the `keep`
    parameter ends up referring to a function with the same parameter and body. Since
    the function is only actually called through the `keep` name, it doesn‚Äôt matter
    whether or not a name is associated with it when it is initially defined.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, we use `lam` when we have to pass simple (single line) functions
    to operations like `filter-with` (or `transform-column`, `build-column`, etc).
    Of course, you can continue to write out names for helper functions as we did
    with `below-1K` if that makes more sense to you.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the program to add 10 riders to each row in the `shuttle` table above,
    using `lam` rather than a named helper-function.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 4.1.1¬†Creating Tabular Data[üîó](#(part._.Creating_.Tabular_.Data) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Pyret provides multiple easy ways of creating tabular data. The simplest is
    to define the datum in a program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: That is, a `table` is followed by the names of the columns in their desired
    order, followed by a sequence of `row`s. Each row must contain as many data as
    the column declares, and in the same order.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Change different parts of the above example‚Äî<wbr>e.g., remove a necessary value
    from a row, add an extraneous one, remove a comma, add an extra comma, leave an
    extra comma at the end of a row‚Äî<wbr>and see what errors you get.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Note that in a table, the order of columns matters: two tables that are otherwise
    identical but with different column orders are not considered equal.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Observe that the example above uses `is-not`, i.e., the test passes, meaning
    that the tables are not equal.
  prefs: []
  type: TYPE_NORMAL
- en: The `check:` annotation here is a way of writing `is` assertions about expressions
    outside of the context of a function (and its `where` block). We‚Äôll learn more
    about `check` in [From Examples to Tests](testing.html#%28part._from-examples-to-tests%29).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table expressions create table values. These can be stored in variables just
    like numbers, strings, and images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We call these literal tables when we create them with `table`. Pyret provides
    other ways to get tabular data, too! In particular, you can [import tabular data
    from a spreadsheet](https://www.pyret.org/docs/latest/gdrive-sheets.html), so
    any mechanism that lets you create such a sheet can also be used. You might:'
  prefs: []
  type: TYPE_NORMAL
- en: create the sheet on your own,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: create a sheet collaboratively with friends,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: find data on the Web that you can import into a sheet,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: create a Google Form that you get others to fill out, and obtain a sheet out
    of their responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and so on. Let your imagination run wild! Once the data are in Pyret, it doesn‚Äôt
    matter where they came from.
  prefs: []
  type: TYPE_NORMAL
- en: With tables, we begin to explore data that contain other (smaller) pieces of
    data. We‚Äôll refer to such data as structured data. Structured data organize their
    inner data in a structured way (here, rows and columns). As with images, when
    we wrote code that reflected the structure of the final image, we will see that
    code that works with tables also follows the structure of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.2¬†Extracting Rows and Cell Values[üîó](#(part._.Extracting_.Rows_and_.Cell_.Values)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Given a table, we sometimes want to look up the value of a particular cell.
    We‚Äôll work with the following table showing the number of riders on a shuttle
    service over several months:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you put this table in the definitions pane and press Run, what will be in
    the Pyret directory once the interactions prompt appears? Would the column names
    be listed in the directory?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: As a reminder, the directory contains only those names that we assign values
    to using the form `name =` . The directory here would contain `shuttle`, which
    would be bound to the table (yes, the entire table would be in the directory!).
    The column names would not have their own entries in the directory. At the low
    level, this is because we never wrote anything of the form `colname = ...`. At
    the high level, we don‚Äôt usually build tables by creating individual columns and
    putting them together side by side. (If anything, it is more common to create
    individual rows, since rows correspond to individual observations, events, or
    entities; we didn‚Äôt do that in this example, however).
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the name associated with a table, we can lookup the value in a
    given cell (row and column) in the table. Concretely, assume we want to extract
    the number of riders in March (`1087`) so we can use it in another computation.
    How do we do that?
  prefs: []
  type: TYPE_NORMAL
- en: Pyret (and most other programming languages designed for data analysis) organizes
    tables as collections of rows with shared columns. Given that organization, we
    get to a specific cell by first isolating the row we are interested in, then retrieving
    the contents of the cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pyret numbers the rows of a table from top to bottom starting at 0 (most programming
    languages use 0 as the first position in a piece of data, for reasons we will
    see later). So if we want to see the data for March, we need to isolate row 2\.
    We write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We use the period notation to dig into a piece of structured data. Here, we
    are saying "dig into the `shuttle` table, extracting row number `2`" (which is
    really the third row since Pyret counts positions from 0).
  prefs: []
  type: TYPE_NORMAL
- en: If we run this expression at the prompt, we get
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d60ae702af1ad3975e72ce720628831a.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a new type of data called a `Row`. When Pyret displays a `Row` value,
    it shows you the column names and the corresponding values within the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the value of a specific column within a row, we write the row followed
    by the name of the column (as a string) in square brackets. Here are two equivalent
    ways of getting the value of the `riders` column from the row for March:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What names would be in the Pyret directory when using each of these approaches?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Once we have the cell value (here a `Number`), we can use it in any other computation,
    such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: (which checks whether there were at least `1000` riders in March).
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What do you expect would happen if you forgot the quotation marks and instead
    wrote:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would Pyret do and why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 4.1.3¬†Functions over Rows[üîó](#(part._.Functions_over_.Rows) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have the ability to isolate Rows from tables, we can write functions
    that ask questions about individual rows. We just saw an example of doing a computation
    over row data, when we checked whether the row for March had more than 1000 riders.
    What if we wanted to do this comparison for an arbitrary row of this table? Let‚Äôs
    write a function! We‚Äôll call it `cleared-1K`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs start with a function header and some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This shows you what examples for `Row` functions look like, as well as how we
    use `Row` as an input type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fill in the body of the function, we extract the content of the `"riders"`
    cell and compare it to `1000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Looking at the examples, both of them share the `shuttle.row-n` portion. Would
    it have been better to instead make `cleared-1K` a function that takes just the
    row position as input, such as:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the benefits and limitations to doing this?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: In general, the version that takes the `Row` input is more flexible because
    it can work with a row from any table that has a column named `"riders"`. We might
    have another table with more columns of information or different data tables for
    different years. If we modify `cleared-1K` to only take the row position as input,
    that function will have to fix which table it works with. In contrast, our original
    version leaves the specific table (`shuttle`) outside the function, which leads
    to flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function `is-winter` that takes a `Row` with a `"month"` column as input
    and produces a `Boolean` indicating whether the month in that row is one of `"Jan"`,
    `"Feb"`, or `"Mar"`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function `low-winter` that takes in `Row` with both `"month"` and `"riders"`
    columns and produces a `Boolean` indicating whether the row is a winter row with
    fewer than 1050 riders.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Practice with the program directory! Take a `Row` function and one of its `where`
    examples, and show how the program directory evolves as you evaluate the example.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 4.1.4¬†Processing Rows[üîó](#(part._.Processing_.Rows) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, we have looked at extracting individual rows by their position in the
    table and computing over them. Extracting rows by position isn‚Äôt always convenient:
    we might have hundreds or thousands of rows, and we might not know where the data
    we want even is in the table. We would much rather be able to write a small program
    that identifies the row (or rows!) that meets a specific criterion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pyret offers three different notations for processing tables: one uses functions,
    one uses methods, and one uses a SQL-like notation. This chapter uses the function-based
    notation. The SQL-like notation and the methods-based notation are shown in the
    Pyret Documentation. To use the function-based notation, you‚Äôll need to include
    the file specified in the main narrative.'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this section assumes that you have loaded the functions notations
    for working with tables.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.4.1¬†Finding Rows[üîó](#(part._subsec~3afinding-rows) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Imagine that we wanted to write a program to locate a row that has fewer than
    `1000` riders from our `shuttle` table. With what we‚Äôve studied so far, how might
    we try to write this? We could imagine using a conditional, like follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What benefits and limitations do you see to this approach?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are a couple of reasons why we might not care for this solution. First,
    if we have thousands of rows, this will be terribly painful to write. Second,
    there‚Äôs a lot of repetition here (only the row positions are changing). Third,
    it isn‚Äôt clear what to do if there aren‚Äôt any matching rows. In addition, what
    happens if there are multiple rows that meet our criterion? In some cases, we
    might want to be able to identify all of the rows that meet a condition and use
    them for a subsequent computation (like seeing whether some months have more low-ridership
    days than others).
  prefs: []
  type: TYPE_NORMAL
- en: 'This conditional is, however, the spirit of what we want to do: go through
    the rows of the table one at a time, identifying those that match some criterion.
    We just don‚Äôt want to be responsible for manually checking each row. Fortunately
    for us, Pyret knows how to do that. Pyret knows which rows are in a given table.
    Pyret can pull out those rows one position at a time and check a criterion about
    each one.'
  prefs: []
  type: TYPE_NORMAL
- en: We just need to tell Pyret what criterion we want to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we can express our criterion as a function that takes a `Row` and
    produces a `Boolean` (a Boolean because our criterion was used as the question
    part of an `if` expression in our code sketch). In this case, we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we just need a way to tell Pyret to use this criterion as it searches
    through the rows. We do this with a function called `filter-with` which takes
    two inputs: the table to process and the criterion to check on each row of the
    table.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the hood, `filter-with` works roughly like the `if` statement we outlined
    above: it takes each row one at a time and calls the given criterion function
    on it. But what does it do with the results?'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the above expression, you‚Äôll see that `filter-with` produces a table
    containing the matching row, not the row by itself. This behavior is handy if
    multiple rows match the criterion. For example, try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '(using the `is-winter` function from an exercise earlier in this chapter).
    Now we get a table with the three rows corresponding to winter months. If we want
    to be able to name this table for use in future computations, we can do so with
    our usual notation for naming values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 4.1.4.2¬†Ordering Rows[üîó](#(part._.Ordering_.Rows) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let‚Äôs ask a new question: which winter month had the fewest number of riders?.
    This question requires us to identify a specific row, namely, the winter row with
    the smallest value in the `"riders"` column.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can we do this with `filter-with`? Why or why not?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Think back to the `if` expression that motivated `filter-with`: each row is
    evaluated independently of the others. Our current question, however, requires
    comparing across rows. That‚Äôs a different operation, so we will need more than
    `filter-with`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tools for analyzing data (whether programming languages or spreadsheets) provide
    ways for users to sort rows of a table based on the values in a single column.
    That would help us here: we could sort the winter rows from smallest to largest
    value in the `"riders"` column, then extract the `"riders"` value from the first
    row. First, let‚Äôs sort the rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `order-by` function takes three inputs: the table to sort (`winter`), the
    column to sort on (`"riders"`), and a `Boolean` to indicate whether we want to
    sort in increasing order. (Had the third argument been `false`, the rows would
    be sorted in decreasing order of the values in the named column.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/50fd4ee1a960ed4942030557bea37389.png)'
  prefs: []
  type: TYPE_IMG
- en: In the sorted table, the row with the fewest riders is in the first position.
    Our original question asked us to lookup the month with the fewest riders. We
    did this earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the code to extract the name of the winter month with the fewest riders.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here are two ways to write that computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of these two ways do you prefer? Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How does each of these programs affect the program directory?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Note that this problem asked us to combine several actions that we‚Äôve already
    seen on rows: we identify rows from within a table (`filter-with`), order the
    rows (`order-by`), extract a specific row (`row-n`), then extract a cell (with
    square brackets and a column name). This is typical of how we will operate on
    tables, combining multiple operations to compute a result (much as we did with
    programs that manipulate images).'
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.4.3¬†Adding New Columns[üîó](#(part._.Adding_.New_.Columns) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Sometimes, we want to create a new column whose value is based on those of
    existing columns. For instance, our table might reflect employee records, and
    have columns named `hourly-wage` and `hours-worked`, representing the corresponding
    quantities. We would now like to extend this table with a new column to reflect
    each employee‚Äôs total wage. Assume we started with the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The table we want to end up with is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '(with the expressions in the `total-wage` column computed to their numeric
    equivalents: we used the expressions here to illustrate what we are trying to
    do).'
  prefs: []
  type: TYPE_NORMAL
- en: Previously, when we have had a computation that we performed multiple times,
    we created a helper function to do the computation.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a helper function for computing total wages given the hourly wage and
    number of hours worked.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Perhaps you came up with something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'which we could use as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the right idea, but we can actually have this function do a bit more
    work for us. The `wage` and `hours` values are in cells within the same row. So
    if we could instead get the current row as an input, we could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'But now, we are writing calls to `compute-wages` over and over! Adding computed
    columns is a sufficiently common operation that Pyret provides a table function
    called `build-column` for this purpose. We use it by providing the function to
    use to populate values in the new column as an input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new column, `total-wage`, whose value in each row is the product
    of the two named columns in that row. Pyret will put the new column at the right
    end.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.4.4¬†Calculating New Column Values[üîó](#(part._.Calculating_.New_.Column_.Values)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Sometimes, we just want to calculate new values for an existing column, rather
    than create an entirely new column. Giving raises to employees is one such example.
    Assume we wanted to give a `10%` raise to all employees making less than `20`
    an hour. We could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, `transform-column` takes a table, the name of an existing column in the
    table, and a function to update the value. The updating function takes the current
    value in the column as input and produces the new value for the column as output.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run `give-raises` on the `employees` table. What wage will show for `"Miyako"`
    in the `employees` table after `give-raises` completes. Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Like all other Pyret `Table` operations, `transform-column` produces a new table,
    leaving the original intact. Editing the original table could be problematic‚Äìwhat
    if you made a mistake? How would you recover the original table in that case?
    In general, producing new tables with any modifications, then creating a new name
    for the updated table once you have the one you want, is a less error-prone way
    of working with datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.4.1¬†Finding Rows[üîó](#(part._subsec~3afinding-rows) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Imagine that we wanted to write a program to locate a row that has fewer than
    `1000` riders from our `shuttle` table. With what we‚Äôve studied so far, how might
    we try to write this? We could imagine using a conditional, like follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What benefits and limitations do you see to this approach?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are a couple of reasons why we might not care for this solution. First,
    if we have thousands of rows, this will be terribly painful to write. Second,
    there‚Äôs a lot of repetition here (only the row positions are changing). Third,
    it isn‚Äôt clear what to do if there aren‚Äôt any matching rows. In addition, what
    happens if there are multiple rows that meet our criterion? In some cases, we
    might want to be able to identify all of the rows that meet a condition and use
    them for a subsequent computation (like seeing whether some months have more low-ridership
    days than others).
  prefs: []
  type: TYPE_NORMAL
- en: 'This conditional is, however, the spirit of what we want to do: go through
    the rows of the table one at a time, identifying those that match some criterion.
    We just don‚Äôt want to be responsible for manually checking each row. Fortunately
    for us, Pyret knows how to do that. Pyret knows which rows are in a given table.
    Pyret can pull out those rows one position at a time and check a criterion about
    each one.'
  prefs: []
  type: TYPE_NORMAL
- en: We just need to tell Pyret what criterion we want to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we can express our criterion as a function that takes a `Row` and
    produces a `Boolean` (a Boolean because our criterion was used as the question
    part of an `if` expression in our code sketch). In this case, we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we just need a way to tell Pyret to use this criterion as it searches
    through the rows. We do this with a function called `filter-with` which takes
    two inputs: the table to process and the criterion to check on each row of the
    table.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the hood, `filter-with` works roughly like the `if` statement we outlined
    above: it takes each row one at a time and calls the given criterion function
    on it. But what does it do with the results?'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the above expression, you‚Äôll see that `filter-with` produces a table
    containing the matching row, not the row by itself. This behavior is handy if
    multiple rows match the criterion. For example, try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '(using the `is-winter` function from an exercise earlier in this chapter).
    Now we get a table with the three rows corresponding to winter months. If we want
    to be able to name this table for use in future computations, we can do so with
    our usual notation for naming values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 4.1.4.2¬†Ordering Rows[üîó](#(part._.Ordering_.Rows) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let‚Äôs ask a new question: which winter month had the fewest number of riders?.
    This question requires us to identify a specific row, namely, the winter row with
    the smallest value in the `"riders"` column.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can we do this with `filter-with`? Why or why not?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Think back to the `if` expression that motivated `filter-with`: each row is
    evaluated independently of the others. Our current question, however, requires
    comparing across rows. That‚Äôs a different operation, so we will need more than
    `filter-with`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tools for analyzing data (whether programming languages or spreadsheets) provide
    ways for users to sort rows of a table based on the values in a single column.
    That would help us here: we could sort the winter rows from smallest to largest
    value in the `"riders"` column, then extract the `"riders"` value from the first
    row. First, let‚Äôs sort the rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `order-by` function takes three inputs: the table to sort (`winter`), the
    column to sort on (`"riders"`), and a `Boolean` to indicate whether we want to
    sort in increasing order. (Had the third argument been `false`, the rows would
    be sorted in decreasing order of the values in the named column.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/50fd4ee1a960ed4942030557bea37389.png)'
  prefs: []
  type: TYPE_IMG
- en: In the sorted table, the row with the fewest riders is in the first position.
    Our original question asked us to lookup the month with the fewest riders. We
    did this earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the code to extract the name of the winter month with the fewest riders.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here are two ways to write that computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of these two ways do you prefer? Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How does each of these programs affect the program directory?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Note that this problem asked us to combine several actions that we‚Äôve already
    seen on rows: we identify rows from within a table (`filter-with`), order the
    rows (`order-by`), extract a specific row (`row-n`), then extract a cell (with
    square brackets and a column name). This is typical of how we will operate on
    tables, combining multiple operations to compute a result (much as we did with
    programs that manipulate images).'
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.4.3¬†Adding New Columns[üîó](#(part._.Adding_.New_.Columns) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Sometimes, we want to create a new column whose value is based on those of
    existing columns. For instance, our table might reflect employee records, and
    have columns named `hourly-wage` and `hours-worked`, representing the corresponding
    quantities. We would now like to extend this table with a new column to reflect
    each employee‚Äôs total wage. Assume we started with the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The table we want to end up with is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '(with the expressions in the `total-wage` column computed to their numeric
    equivalents: we used the expressions here to illustrate what we are trying to
    do).'
  prefs: []
  type: TYPE_NORMAL
- en: Previously, when we have had a computation that we performed multiple times,
    we created a helper function to do the computation.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a helper function for computing total wages given the hourly wage and
    number of hours worked.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Perhaps you came up with something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'which we could use as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the right idea, but we can actually have this function do a bit more
    work for us. The `wage` and `hours` values are in cells within the same row. So
    if we could instead get the current row as an input, we could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'But now, we are writing calls to `compute-wages` over and over! Adding computed
    columns is a sufficiently common operation that Pyret provides a table function
    called `build-column` for this purpose. We use it by providing the function to
    use to populate values in the new column as an input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new column, `total-wage`, whose value in each row is the product
    of the two named columns in that row. Pyret will put the new column at the right
    end.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.4.4¬†Calculating New Column Values[üîó](#(part._.Calculating_.New_.Column_.Values)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Sometimes, we just want to calculate new values for an existing column, rather
    than create an entirely new column. Giving raises to employees is one such example.
    Assume we wanted to give a `10%` raise to all employees making less than `20`
    an hour. We could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Here, `transform-column` takes a table, the name of an existing column in the
    table, and a function to update the value. The updating function takes the current
    value in the column as input and produces the new value for the column as output.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run `give-raises` on the `employees` table. What wage will show for `"Miyako"`
    in the `employees` table after `give-raises` completes. Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Like all other Pyret `Table` operations, `transform-column` produces a new table,
    leaving the original intact. Editing the original table could be problematic‚Äìwhat
    if you made a mistake? How would you recover the original table in that case?
    In general, producing new tables with any modifications, then creating a new name
    for the updated table once you have the one you want, is a less error-prone way
    of working with datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.5¬†Examples for Table-Producing Functions[üîó](#(part._.Examples_for_.Table-.Producing_.Functions)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How do we write examples for functions that produce tables? Conceptually, the
    answer is simply "make sure you got the output table that you expected". Logistically,
    writing examples for table functions seems more painful because writing out an
    expected output tables is more work than simply writing the output of a function
    that produces numbers or strings. What can we do to manage that complexity?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How might you write the `where` block for `give-raises`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here are some ideas for writing the examples practically:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simplify the input table. Rather than work with a large table with all of the
    columns you have, create a small table that has sufficient variety only in the
    columns that the function uses. For our example, we might use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Would any table with a column of numbers work here? Or are there some constraints
    on the rows or columns of the table?
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The only constraint is that your input table has to have the column names used
    in your function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remember that you can write computations in the code to construct tables. This
    saves you from doing calculations by hand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This example shows that you can write an output table directly in the `where:`
    block ‚Äì the table doesn‚Äôt need to be named outside the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new table by taking rows from an existing table. If you were instead
    writing examples for a function that involves filtering out rows of a table, it
    helps to know how to create a new table using rows of an existing one. For example,
    if we were writing a function to find all rows in which employees were working
    exactly 40 hours, we‚Äôd like to make sure that the resulting table had the first
    and fourth rows of the `employees` table. Rather than write a new `table` expression
    to create that table, we could write it as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `employees.empty()` creates a new, empty table with the same column headers
    as `employees`. We‚Äôve already seen how `row-n` extracts a row from a table. The
    `add-row` function places the given row at the end of the given table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Another tip to keep in mind: when the only thing your function does is call
    a built-in function like `transform-column` it usually suffices to write examples
    for the function you wrote to compute the new column value. It is only when your
    code is combining table operations, or doing more complex processing than a single
    call to a built-in table operation that you really need to present your own examples
    to a reader of your code.'
  prefs: []
  type: TYPE_NORMAL
- en: '4.1.6¬†Lambda: Anonymous Functions[üîó](#(part._sec~3alambda-tables) "Link to
    here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let‚Äôs revisit the program we wrote in [Finding Rows](#%28part._subsec~3afinding-rows%29)
    for finding all of the months in a table with fewer than 1000 riders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This program might feel a bit verbose: do we really need to write a helper
    function just to perform something as simple as a `filter-with`? Wouldn‚Äôt it be
    easier to just write something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will Pyret produce if you run this expression?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pyret will produce an `unbound identifier` error around the use of `r` in this
    expression. What is `r`? We mean for `r` to be the elements from `shuttle` in
    turn. Conceptually, that‚Äôs what `filter-with` does, but we don‚Äôt have the mechanics
    right. When we call a function, we evaluate the arguments before the body of the
    function. Hence, the error regarding `r` being unbound. The whole point of the
    `below-1K` helper function is to make `r` a parameter to a function whose body
    is only evaluated once a value for `r` is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tighten the notation as in the one-line `filter-with` expression, then,
    we have to find a way to tell Pyret to make a temporary function that will get
    its inputs once `filter-with` is running. The following notation achieves this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We have added `lam(r)` and `end` around the expression that we want to use in
    the `filter-with`. The `lam(r)` says "make a temporary function that takes `r`
    as an input". The `end` serves to end the function definition, as when we use
    `fun`. `lam` is short for `lambda`, a form of function definition that exists
    in many, though not all, languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference between our original expression (using the `below-1K` helper)
    and this new one (using `lam`) can be seen through the program directory. To explain
    this, a little detail about how `filter-with` is defined under the hood. In part,
    it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Whether we pass `below-1K` or the `lam` version to `filter-with`, the `keep`
    parameter ends up referring to a function with the same parameter and body. Since
    the function is only actually called through the `keep` name, it doesn‚Äôt matter
    whether or not a name is associated with it when it is initially defined.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, we use `lam` when we have to pass simple (single line) functions
    to operations like `filter-with` (or `transform-column`, `build-column`, etc).
    Of course, you can continue to write out names for helper functions as we did
    with `below-1K` if that makes more sense to you.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the program to add 10 riders to each row in the `shuttle` table above,
    using `lam` rather than a named helper-function.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
