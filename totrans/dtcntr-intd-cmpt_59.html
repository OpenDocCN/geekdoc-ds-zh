<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>18.3Â Union-FindğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>18.3Â Union-FindğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/union-find.html">https://dcic-world.org/2025-08-27/union-find.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._.Implementing_with_.State%29" class="toclink" data-pltdoc="x">18.3.1Â Implementing with State</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Optimizations%29" class="toclink" data-pltdoc="x">18.3.2Â Optimizations</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Analysis%29" class="toclink" data-pltdoc="x">18.3.3Â Analysis</a></p></td></tr></table><p>We have previously [<a href="mst.html#%28part._union-find-functional%29" data-pltdoc="x">Checking Component Connectedness</a>] seen how to
check connectedness of components, but found that solution
unsatisfactory. Recall that it comes down to two set operations: we
want to construct the unions of sets, and then determine whether two
elements are in the same set.</p><p>We will now see how to do this using state.  We will
try to keep things as similar to the previous version as possible, to
enhance comparison.</p><section class="SsectionLevel4" id="section 18.3.1"><h4 class="heading">18.3.1Â <a name="(part._.Implementing_with_.State)"/>Implementing with State<a href="#(part._.Implementing_with_.State)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>First, we have to update the definition of an element, making the
<code data-lang="pyret" class="sourceCode">parent</code> field be mutable:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Element:
  | elt(val, ref parent :: Option&lt;Element&gt;)
end</code></pre><p>To determine whether two elements are in the same set, we will still
rely on <code data-lang="pyret" class="sourceCode">fynd</code>. However, as we will soon see, <code data-lang="pyret" class="sourceCode">fynd</code> no
longer needs to be given the entire set of elements. Because the only
reason <code data-lang="pyret" class="sourceCode">is-in-same-set</code> consumed that set was to pass it on to
<code data-lang="pyret" class="sourceCode">fynd</code>, we can remove it from here. Nothing else changes:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun is-in-same-set(e1 :: Element, e2 :: Element) -&gt; Boolean:
  s1 = fynd(e1)
  s2 = fynd(e2)
  identical(s1, s2)
end</code></pre><p>Updating is now the crucial difference: we use mutation to change the
value of the parent:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun update-set-with(child :: Element, parent :: Element):
  child!{parent: some(parent)}
end</code></pre><p>In <code data-lang="pyret" class="sourceCode">parent: some(parent)</code>, the first <code data-lang="pyret" class="sourceCode">parent</code> is the name of
the field, while the second one is the parameter name. In addition, we
must use <code data-lang="pyret" class="sourceCode">some</code> to satisfy the option type. Naturally, it is not
<code data-lang="pyret" class="sourceCode">none</code> because the entire point of this mutation is to change the
parent to be the other element, irrespective of what was there before.</p><p>Given this definition, <code data-lang="pyret" class="sourceCode">union</code> also stays largely unchanged,
other than the change to the return type. Previously, it needed to
return the updated set of elements; now, because the update is
performed by mutation, there is no longer any need to return anything:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun union(e1 :: Element, e2 :: Element):
  s1 = fynd(e1)
  s2 = fynd(e2)
  if identical(s1, s2):
    s1
  else:
    update-set-with(s1, s2)
  end
end</code></pre><p>Finally, <code data-lang="pyret" class="sourceCode">fynd</code>. Its implementation is now remarkably
simple. There is no longer any need to search through the
set. Previously, we had to search because after union operations have
occurred, the parent reference might have no longer been valid. Now,
any such changes are automatically reflected by mutation. Hence:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun fynd(e :: Element) -&gt; Element:
  cases (Option) e!parent:
    | none =&gt; e
    | some(p) =&gt; fynd(p)
  end
end</code></pre></section><section class="SsectionLevel4" id="section 18.3.2"><h4 class="heading">18.3.2Â <a name="(part._.Optimizations)"/>Optimizations<a href="#(part._.Optimizations)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Look again at <code data-lang="pyret" class="sourceCode">fynd</code>. In the <code data-lang="pyret" class="sourceCode">some</code> case, the element bound
to <code data-lang="pyret" class="sourceCode">e</code> is not the set name; that is obtained by recursively
traversing <code data-lang="pyret" class="sourceCode">parent</code> references. As this value returns, however,
we donâ€™t do anything to reflect this new knowledge! Instead, the next
time we try to find the parent of this element, weâ€™re going to perform
this same recursive traversal all over again.</p><p>Using mutation helps address this problem. The idea is as simple as
can be: compute the value of the parent, and update it.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun fynd(e :: Element) -&gt; Element:
  cases (Option) e!parent block:
    | none =&gt; e
    | some(p) =&gt;
      new-parent = fynd(p)
      e!{parent: some(new-parent)}
      new-parent
  end
end</code></pre><p>Note that this update will apply to every element in the recursive
chain to find the set name. Therefore, applying <code data-lang="pyret" class="sourceCode">fynd</code> to
any of those elements the next time around will benefit from
this update. This idea is called path compression.</p><p>There is one more interesting idea we can apply. This is to maintain a
rank of each element, which is roughly the depth of the tree of
elements for which that element is their set name. When we union two
elements, we then make the one with larger rank the parent of the one
with the smaller rank. This has the effect of avoiding growing very
tall paths to set name elements, instead tending towards â€œbushyâ€
trees. This too reduces the number of parents that must be traversed
to find the representative.</p></section><section class="SsectionLevel4" id="section 18.3.3"><h4 class="heading">18.3.3Â <a name="(part._.Analysis)"/>Analysis<a href="#(part._.Analysis)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>This optimized union-find data structure has a remarkble analysis. In
the worst case, of course, we must traverse the entire chain of
parents to find the name element, which takes time proportional to the
number of elements in the set. However, once we apply the above
optimizations, we never need to traverse that same chain again! In
particular, if we conduct an amortized analysis over a sequence
of set equality tests after a collection of union operations, we find
that the cost for subsequent checks is very smallâ€”<wbr/>indeed, about as
small a function can get without being constant. The
<a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure">actual analysis</a>
is quite sophisticated; it is also one of the most
remarkable algorithm analyses in all of computer science.Hereâ€™s a
<a href="https://www.youtube.com/watch?v=Hhk8ANKWGJA">brief talk</a>
by Robert Tarjan describing the history of his analysis.</p></section>&#13;
<h4 class="heading">18.3.1Â <a name="(part._.Implementing_with_.State)"/>Implementing with State<a href="#(part._.Implementing_with_.State)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>First, we have to update the definition of an element, making the
<code data-lang="pyret" class="sourceCode">parent</code> field be mutable:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Element:
  | elt(val, ref parent :: Option&lt;Element&gt;)
end</code></pre><p>To determine whether two elements are in the same set, we will still
rely on <code data-lang="pyret" class="sourceCode">fynd</code>. However, as we will soon see, <code data-lang="pyret" class="sourceCode">fynd</code> no
longer needs to be given the entire set of elements. Because the only
reason <code data-lang="pyret" class="sourceCode">is-in-same-set</code> consumed that set was to pass it on to
<code data-lang="pyret" class="sourceCode">fynd</code>, we can remove it from here. Nothing else changes:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun is-in-same-set(e1 :: Element, e2 :: Element) -&gt; Boolean:
  s1 = fynd(e1)
  s2 = fynd(e2)
  identical(s1, s2)
end</code></pre><p>Updating is now the crucial difference: we use mutation to change the
value of the parent:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun update-set-with(child :: Element, parent :: Element):
  child!{parent: some(parent)}
end</code></pre><p>In <code data-lang="pyret" class="sourceCode">parent: some(parent)</code>, the first <code data-lang="pyret" class="sourceCode">parent</code> is the name of
the field, while the second one is the parameter name. In addition, we
must use <code data-lang="pyret" class="sourceCode">some</code> to satisfy the option type. Naturally, it is not
<code data-lang="pyret" class="sourceCode">none</code> because the entire point of this mutation is to change the
parent to be the other element, irrespective of what was there before.</p><p>Given this definition, <code data-lang="pyret" class="sourceCode">union</code> also stays largely unchanged,
other than the change to the return type. Previously, it needed to
return the updated set of elements; now, because the update is
performed by mutation, there is no longer any need to return anything:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun union(e1 :: Element, e2 :: Element):
  s1 = fynd(e1)
  s2 = fynd(e2)
  if identical(s1, s2):
    s1
  else:
    update-set-with(s1, s2)
  end
end</code></pre><p>Finally, <code data-lang="pyret" class="sourceCode">fynd</code>. Its implementation is now remarkably
simple. There is no longer any need to search through the
set. Previously, we had to search because after union operations have
occurred, the parent reference might have no longer been valid. Now,
any such changes are automatically reflected by mutation. Hence:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun fynd(e :: Element) -&gt; Element:
  cases (Option) e!parent:
    | none =&gt; e
    | some(p) =&gt; fynd(p)
  end
end</code></pre>&#13;
<h4 class="heading">18.3.2Â <a name="(part._.Optimizations)"/>Optimizations<a href="#(part._.Optimizations)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Look again at <code data-lang="pyret" class="sourceCode">fynd</code>. In the <code data-lang="pyret" class="sourceCode">some</code> case, the element bound
to <code data-lang="pyret" class="sourceCode">e</code> is not the set name; that is obtained by recursively
traversing <code data-lang="pyret" class="sourceCode">parent</code> references. As this value returns, however,
we donâ€™t do anything to reflect this new knowledge! Instead, the next
time we try to find the parent of this element, weâ€™re going to perform
this same recursive traversal all over again.</p><p>Using mutation helps address this problem. The idea is as simple as
can be: compute the value of the parent, and update it.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun fynd(e :: Element) -&gt; Element:
  cases (Option) e!parent block:
    | none =&gt; e
    | some(p) =&gt;
      new-parent = fynd(p)
      e!{parent: some(new-parent)}
      new-parent
  end
end</code></pre><p>Note that this update will apply to every element in the recursive
chain to find the set name. Therefore, applying <code data-lang="pyret" class="sourceCode">fynd</code> to
any of those elements the next time around will benefit from
this update. This idea is called path compression.</p><p>There is one more interesting idea we can apply. This is to maintain a
rank of each element, which is roughly the depth of the tree of
elements for which that element is their set name. When we union two
elements, we then make the one with larger rank the parent of the one
with the smaller rank. This has the effect of avoiding growing very
tall paths to set name elements, instead tending towards â€œbushyâ€
trees. This too reduces the number of parents that must be traversed
to find the representative.</p>&#13;
<h4 class="heading">18.3.3Â <a name="(part._.Analysis)"/>Analysis<a href="#(part._.Analysis)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>This optimized union-find data structure has a remarkble analysis. In
the worst case, of course, we must traverse the entire chain of
parents to find the name element, which takes time proportional to the
number of elements in the set. However, once we apply the above
optimizations, we never need to traverse that same chain again! In
particular, if we conduct an amortized analysis over a sequence
of set equality tests after a collection of union operations, we find
that the cost for subsequent checks is very smallâ€”<wbr/>indeed, about as
small a function can get without being constant. The
<a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure">actual analysis</a>
is quite sophisticated; it is also one of the most
remarkable algorithm analyses in all of computer science.Hereâ€™s a
<a href="https://www.youtube.com/watch?v=Hhk8ANKWGJA">brief talk</a>
by Robert Tarjan describing the history of his analysis.</p>    
</body>
</html>