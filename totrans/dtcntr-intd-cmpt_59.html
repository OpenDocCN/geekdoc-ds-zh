<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>18.3Â Union-FindğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>18.3Â Union-FindğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/union-find.html">https://dcic-world.org/2025-08-27/union-find.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Implementing_with_.State%29" class="toclink" data-pltdoc="x">18.3.1<span class="hspace">Â </span>Implementing with State</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Optimizations%29" class="toclink" data-pltdoc="x">18.3.2<span class="hspace">Â </span>Optimizations</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Analysis%29" class="toclink" data-pltdoc="x">18.3.3<span class="hspace">Â </span>Analysis</a></p></td></tr></table><p>We have previously [<a href="mst.html#%28part._union-find-functional%29" data-pltdoc="x">Checking Component Connectedness</a>] seen how to
check connectedness of components, but found that solution
unsatisfactory. Recall that it comes down to two set operations: we
want to construct the unions of sets, and then determine whether two
elements are in the same set.</p><p>We will now see how to do this using state.  We will
try to keep things as similar to the previous version as possible, to
enhance comparison.</p><section class="SsectionLevel4" id="section 18.3.1"><h4 class="heading">18.3.1<span class="stt">Â </span><a name="(part._.Implementing_with_.State)"/>Implementing with State<span class="button-group"><a href="#(part._.Implementing_with_.State)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">First, we have to update the definition of an element, making the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">parent</code></span> field be <span class="emph">mutable</span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Element:
  | elt(val, ref parent :: Option&lt;Element&gt;)
end</code></pre></div></div></div><div class="SIntrapara">To determine whether two elements are in the same set, we will still
rely on <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fynd</code></span>. However, as we will soon see, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fynd</code></span> no
longer needs to be given the entire set of elements. Because the only
reason <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-in-same-set</code></span> consumed that set was to pass it on to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fynd</code></span>, we can remove it from here. Nothing else changes:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun is-in-same-set(e1 :: Element, e2 :: Element) -&gt; Boolean:
  s1 = fynd(e1)
  s2 = fynd(e2)
  identical(s1, s2)
end</code></pre></div></div></div><div class="SIntrapara">Updating is now the crucial difference: we use mutation to change the
value of the parent:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun update-set-with(child :: Element, parent :: Element):
  child!{parent: some(parent)}
end</code></pre></div></div></div><div class="SIntrapara">In <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">parent: some(parent)</code></span>, the first <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">parent</code></span> is the name of
the field, while the second one is the parameter name. In addition, we
must use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">some</code></span> to satisfy the option type. Naturally, it is not
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">none</code></span> because the entire point of this mutation is to change the
parent to be the other element, irrespective of what was there before.</div><p/><div class="SIntrapara">Given this definition, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">union</code></span> also stays largely unchanged,
other than the change to the return type. Previously, it needed to
return the updated set of elements; now, because the update is
performed by mutation, there is no longer any need to return anything:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun union(e1 :: Element, e2 :: Element):
  s1 = fynd(e1)
  s2 = fynd(e2)
  if identical(s1, s2):
    s1
  else:
    update-set-with(s1, s2)
  end
end</code></pre></div></div></div><div class="SIntrapara">Finally, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fynd</code></span>. Its implementation is now remarkably
simple. There is no longer any need to search through the
set. Previously, we had to search because after union operations have
occurred, the parent reference might have no longer been valid. Now,
any such changes are automatically reflected by mutation. Hence:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun fynd(e :: Element) -&gt; Element:
  cases (Option) e!parent:
    | none =&gt; e
    | some(p) =&gt; fynd(p)
  end
end</code></pre></div></div></div></section><section class="SsectionLevel4" id="section 18.3.2"><h4 class="heading">18.3.2<span class="stt">Â </span><a name="(part._.Optimizations)"/>Optimizations<span class="button-group"><a href="#(part._.Optimizations)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Look again at <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fynd</code></span>. In the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">some</code></span> case, the element bound
to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e</code></span> is not the set name; that is obtained by recursively
traversing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">parent</code></span> references. As this value returns, however,
we donâ€™t do anything to reflect this new knowledge! Instead, the next
time we try to find the parent of this element, weâ€™re going to perform
this same recursive traversal all over again.</p><p/><div class="SIntrapara">Using mutation helps address this problem. The idea is as simple as
can be: compute the value of the parent, and update it.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun fynd(e :: Element) -&gt; Element:
  cases (Option) e!parent block:
    | none =&gt; e
    | some(p) =&gt;
      new-parent = fynd(p)
      e!{parent: some(new-parent)}
      new-parent
  end
end</code></pre></div></div></div><div class="SIntrapara">Note that this update will apply to every element in the recursive
chain to find the set name. Therefore, applying <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fynd</code></span> to
<span class="emph">any</span> of those elements the next time around will benefit from
this update. This idea is called <span style="font-style: italic">path compression</span>.</div><p>There is one more interesting idea we can apply. This is to maintain a
<span style="font-style: italic">rank</span> of each element, which is roughly the depth of the tree of
elements for which that element is their set name. When we union two
elements, we then make the one with larger rank the parent of the one
with the smaller rank. This has the effect of avoiding growing very
tall paths to set name elements, instead tending towards â€œbushyâ€
trees. This too reduces the number of parents that must be traversed
to find the representative.</p></section><section class="SsectionLevel4" id="section 18.3.3"><h4 class="heading">18.3.3<span class="stt">Â </span><a name="(part._.Analysis)"/>Analysis<span class="button-group"><a href="#(part._.Analysis)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>This optimized union-find data structure has a remarkble analysis. In
the worst case, of course, we must traverse the entire chain of
parents to find the name element, which takes time proportional to the
number of elements in the set. However, once we apply the above
optimizations, we never need to traverse that same chain again! In
particular, if we conduct an <span class="emph">amortized</span> analysis over a sequence
of set equality tests after a collection of union operations, we find
that the cost for subsequent checks is very smallâ€”<wbr/>indeed, about as
small a function can get without being constant. The
<a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure">actual analysis</a>
is quite sophisticated; it is also one of the most
remarkable algorithm analyses in all of computer science.<span class="refelem"><span class="refcolumn"><span class="refcontent">Hereâ€™s a
<a href="https://www.youtube.com/watch?v=Hhk8ANKWGJA">brief talk</a>
by Robert Tarjan describing the history of his analysis.</span></span></span></p></section>&#13;
<h4 class="heading">18.3.1<span class="stt">Â </span><a name="(part._.Implementing_with_.State)"/>Implementing with State<span class="button-group"><a href="#(part._.Implementing_with_.State)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">First, we have to update the definition of an element, making the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">parent</code></span> field be <span class="emph">mutable</span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Element:
  | elt(val, ref parent :: Option&lt;Element&gt;)
end</code></pre></div></div></div><div class="SIntrapara">To determine whether two elements are in the same set, we will still
rely on <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fynd</code></span>. However, as we will soon see, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fynd</code></span> no
longer needs to be given the entire set of elements. Because the only
reason <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-in-same-set</code></span> consumed that set was to pass it on to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fynd</code></span>, we can remove it from here. Nothing else changes:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun is-in-same-set(e1 :: Element, e2 :: Element) -&gt; Boolean:
  s1 = fynd(e1)
  s2 = fynd(e2)
  identical(s1, s2)
end</code></pre></div></div></div><div class="SIntrapara">Updating is now the crucial difference: we use mutation to change the
value of the parent:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun update-set-with(child :: Element, parent :: Element):
  child!{parent: some(parent)}
end</code></pre></div></div></div><div class="SIntrapara">In <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">parent: some(parent)</code></span>, the first <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">parent</code></span> is the name of
the field, while the second one is the parameter name. In addition, we
must use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">some</code></span> to satisfy the option type. Naturally, it is not
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">none</code></span> because the entire point of this mutation is to change the
parent to be the other element, irrespective of what was there before.</div><p/><div class="SIntrapara">Given this definition, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">union</code></span> also stays largely unchanged,
other than the change to the return type. Previously, it needed to
return the updated set of elements; now, because the update is
performed by mutation, there is no longer any need to return anything:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun union(e1 :: Element, e2 :: Element):
  s1 = fynd(e1)
  s2 = fynd(e2)
  if identical(s1, s2):
    s1
  else:
    update-set-with(s1, s2)
  end
end</code></pre></div></div></div><div class="SIntrapara">Finally, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fynd</code></span>. Its implementation is now remarkably
simple. There is no longer any need to search through the
set. Previously, we had to search because after union operations have
occurred, the parent reference might have no longer been valid. Now,
any such changes are automatically reflected by mutation. Hence:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun fynd(e :: Element) -&gt; Element:
  cases (Option) e!parent:
    | none =&gt; e
    | some(p) =&gt; fynd(p)
  end
end</code></pre></div></div></div>&#13;
<h4 class="heading">18.3.2<span class="stt">Â </span><a name="(part._.Optimizations)"/>Optimizations<span class="button-group"><a href="#(part._.Optimizations)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Look again at <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fynd</code></span>. In the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">some</code></span> case, the element bound
to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">e</code></span> is not the set name; that is obtained by recursively
traversing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">parent</code></span> references. As this value returns, however,
we donâ€™t do anything to reflect this new knowledge! Instead, the next
time we try to find the parent of this element, weâ€™re going to perform
this same recursive traversal all over again.</p><p/><div class="SIntrapara">Using mutation helps address this problem. The idea is as simple as
can be: compute the value of the parent, and update it.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun fynd(e :: Element) -&gt; Element:
  cases (Option) e!parent block:
    | none =&gt; e
    | some(p) =&gt;
      new-parent = fynd(p)
      e!{parent: some(new-parent)}
      new-parent
  end
end</code></pre></div></div></div><div class="SIntrapara">Note that this update will apply to every element in the recursive
chain to find the set name. Therefore, applying <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fynd</code></span> to
<span class="emph">any</span> of those elements the next time around will benefit from
this update. This idea is called <span style="font-style: italic">path compression</span>.</div><p>There is one more interesting idea we can apply. This is to maintain a
<span style="font-style: italic">rank</span> of each element, which is roughly the depth of the tree of
elements for which that element is their set name. When we union two
elements, we then make the one with larger rank the parent of the one
with the smaller rank. This has the effect of avoiding growing very
tall paths to set name elements, instead tending towards â€œbushyâ€
trees. This too reduces the number of parents that must be traversed
to find the representative.</p>&#13;
<h4 class="heading">18.3.3<span class="stt">Â </span><a name="(part._.Analysis)"/>Analysis<span class="button-group"><a href="#(part._.Analysis)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>This optimized union-find data structure has a remarkble analysis. In
the worst case, of course, we must traverse the entire chain of
parents to find the name element, which takes time proportional to the
number of elements in the set. However, once we apply the above
optimizations, we never need to traverse that same chain again! In
particular, if we conduct an <span class="emph">amortized</span> analysis over a sequence
of set equality tests after a collection of union operations, we find
that the cost for subsequent checks is very smallâ€”<wbr/>indeed, about as
small a function can get without being constant. The
<a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure">actual analysis</a>
is quite sophisticated; it is also one of the most
remarkable algorithm analyses in all of computer science.<span class="refelem"><span class="refcolumn"><span class="refcontent">Hereâ€™s a
<a href="https://www.youtube.com/watch?v=Hhk8ANKWGJA">brief talk</a>
by Robert Tarjan describing the history of his analysis.</span></span></span></p>    
</body>
</html>