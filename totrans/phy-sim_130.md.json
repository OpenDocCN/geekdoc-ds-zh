["```py\ndef compute_reduced_basis(x, e, vol, IB, mu_lame, lam, method, order):\n    if method == 0: # full basis, no reduction\n        basis = np.zeros((len(x) * 2, len(x) * 2))\n        for i in range(len(x) * 2):\n            basis[i][i] = 1\n        return basis\n    elif method == 1: # polynomial basis\n        if order == 1: # linear basis, or affine basis\n            basis = np.zeros((len(x) * 2, 6)) # 1, x, y for both x- and y-displacements\n            for i in range(len(x)):\n                for d in range(2):\n                    basis[i * 2 + d][d * 3] = 1\n                    basis[i * 2 + d][d * 3 + 1] = x[i][0]\n                    basis[i * 2 + d][d * 3 + 2] = x[i][1]\n        elif order == 2: # quadratic polynomial basis \n            basis = np.zeros((len(x) * 2, 12)) # 1, x, y, x^2, xy, y^2 for both x- and y-displacements\n            for i in range(len(x)):\n                for d in range(2):\n                    basis[i * 2 + d][d * 6] = 1\n                    basis[i * 2 + d][d * 6 + 1] = x[i][0]\n                    basis[i * 2 + d][d * 6 + 2] = x[i][1]\n                    basis[i * 2 + d][d * 6 + 3] = x[i][0] * x[i][0]\n                    basis[i * 2 + d][d * 6 + 4] = x[i][0] * x[i][1]\n                    basis[i * 2 + d][d * 6 + 5] = x[i][1] * x[i][1]\n        elif order == 3: # cubic polynomial basis\n            basis = np.zeros((len(x) * 2, 20)) # 1, x, y, x^2, xy, y^2, x^3, x^2y, xy^2, y^3 for both x- and y-displacements\n            for i in range(len(x)):\n                for d in range(2):\n                    basis[i * 2 + d][d * 10] = 1\n                    basis[i * 2 + d][d * 10 + 1] = x[i][0]\n                    basis[i * 2 + d][d * 10 + 2] = x[i][1]\n                    basis[i * 2 + d][d * 10 + 3] = x[i][0] * x[i][0]\n                    basis[i * 2 + d][d * 10 + 4] = x[i][0] * x[i][1]\n                    basis[i * 2 + d][d * 10 + 5] = x[i][1] * x[i][1]\n                    basis[i * 2 + d][d * 10 + 6] = x[i][0] * x[i][0] * x[i][0]\n                    basis[i * 2 + d][d * 10 + 7] = x[i][0] * x[i][0] * x[i][1]\n                    basis[i * 2 + d][d * 10 + 8] = x[i][0] * x[i][1] * x[i][1]\n                    basis[i * 2 + d][d * 10 + 9] = x[i][1] * x[i][1] * x[i][1]\n        else:\n            print(\"unsupported order of polynomial basis for reduced DOF\")\n            exit()\n        return basis\n    else: # modal-order reduction\n        if order <= 0 or order >= len(x) * 2:\n            print(\"invalid number of target basis for modal reduction\")\n            exit()\n        IJV = NeoHookeanEnergy.hess(x, e, vol, IB, mu_lame, lam, project_PSD=False)\n        H = sparse.coo_matrix((IJV[2], (IJV[0], IJV[1])), shape=(len(x) * 2, len(x) * 2)).tocsr()\n        eigenvalues, eigenvectors = eigsh(H, k=order, which='SM') # get 'order' eigenvectors with smallest eigenvalues \n        return eigenvectors \n```", "```py\ndef search_dir(x, e, x_tilde, m, vol, IB, mu_lame, lam, y_ground, contact_area, is_DBC, reduced_basis, h):\n    projected_hess = IP_hess(x, e, x_tilde, m, vol, IB, mu_lame, lam, y_ground, contact_area, h)\n    reshaped_grad = IP_grad(x, e, x_tilde, m, vol, IB, mu_lame, lam, y_ground, contact_area, h).reshape(len(x) * 2, 1)\n    # eliminate DOF by modifying gradient and Hessian for DBC:\n    for i, j in zip(*projected_hess.nonzero()):\n        if is_DBC[int(i / 2)] | is_DBC[int(j / 2)]: \n            projected_hess[i, j] = (i == j)\n    for i in range(0, len(x)):\n        if is_DBC[i]:\n            reshaped_grad[i * 2] = reshaped_grad[i * 2 + 1] = 0.0\n    reduced_hess = reduced_basis.T.dot(projected_hess.dot(reduced_basis)) # applying chain rule\n    reduced_grad = reduced_basis.T.dot(reshaped_grad) # applying chain rule\n    return (reduced_basis.dot(spsolve(reduced_hess, -reduced_grad))).reshape(len(x), 2) # transform to full space after the solve \n```"]