["```py\n[x, e] = square_mesh.generate(side_len, n_seg)      # node positions and edge node indices\nx = np.append(x, [[0.0, side_len * 0.6]], axis=0)   # ceil origin (with normal [0.0, -1.0]) \n```", "```py\n n = np.array([0.0, -1.0])\n    for i in range(0, len(x) - 1):\n        d = n.dot(x[i] - x[-1])\n        if d < dhat:\n            s = d / dhat\n            sum += contact_area[i] * dhat * kappa / 2 * (s - 1) * math.log(s) \n```", "```py\n n = np.array([0.0, -1.0])\n    for i in range(0, len(x) - 1):\n        d = n.dot(x[i] - x[-1])\n        if d < dhat:\n            s = d / dhat\n            local_grad = contact_area[i] * dhat * (kappa / 2 * (math.log(s) / dhat + (s - 1) / d)) * n\n            g[i] += local_grad\n            g[-1] -= local_grad \n```", "```py\n n = np.array([0.0, -1.0])\n    for i in range(0, len(x) - 1):\n        d = n.dot(x[i] - x[-1])\n        if d < dhat:\n            local_hess = contact_area[i] * dhat * kappa / (2 * d * d * dhat) * (d + dhat) * np.outer(n, n)\n            index = [i, len(x) - 1]\n            for nI in range(0, 2):\n                for nJ in range(0, 2):\n                    for c in range(0, 2):\n                        for r in range(0, 2):\n                            IJV[0].append(index[nI] * 2 + r)\n                            IJV[1].append(index[nJ] * 2 + c)\n                            IJV[2] = np.append(IJV[2], ((-1) ** (nI != nJ)) * local_hess[r, c]) \n```", "```py\n n = np.array([0.0, -1.0])\n    for i in range(0, len(x) - 1):\n        p_n = (p[i] - p[-1]).dot(n)\n        if p_n < 0:\n            alpha = min(alpha, 0.9 * n.dot(x[i] - x[-1]) / -p_n) \n```", "```py\nDBC = [(n_seg + 1) * (n_seg + 1)]       # dirichlet node index\nDBC_v = [np.array([0.0, -0.5])]         # dirichlet node velocity\nDBC_limit = [np.array([0.0, -0.6])]     # dirichlet node limit position \n```", "```py\nimport numpy as np\n\ndef val(x, m, DBC, DBC_target, k):\n    sum = 0.0\n    for i in range(0, len(DBC)):\n        diff = x[DBC[i]] - DBC_target[i]\n        sum += 0.5 * k * m[DBC[i]] * diff.dot(diff)\n    return sum\n\ndef grad(x, m, DBC, DBC_target, k):\n    g = np.array([[0.0, 0.0]] * len(x))\n    for i in range(0, len(DBC)):\n        g[DBC[i]] = k * m[DBC[i]] * (x[DBC[i]] - DBC_target[i])\n    return g\n\ndef hess(x, m, DBC, DBC_target, k):\n    IJV = [[0] * 0, [0] * 0, np.array([0.0] * 0)]\n    for i in range(0, len(DBC)):\n        for d in range(0, 2):\n            IJV[0].append(DBC[i] * 2 + d)\n            IJV[1].append(DBC[i] * 2 + d)\n            IJV[2] = np.append(IJV[2], k * m[DBC[i]])\n    return IJV \n```", "```py\n DBC_target = [] # target position of each DBC in the current time step\n    for i in range(0, len(DBC)):\n        if (DBC_limit[i] - x_n[DBC[i]]).dot(DBC_v[i]) > 0:\n            DBC_target.append(x_n[DBC[i]] + h * DBC_v[i])\n        else:\n            DBC_target.append(x_n[DBC[i]]) \n```", "```py\n # check whether each DBC is satisfied\n    DBC_satisfied = [False] * len(x)\n    for i in range(0, len(DBC)):\n        if LA.norm(x[DBC[i]] - DBC_target[i]) / h < tol:\n            DBC_satisfied[DBC[i]] = True \n```", "```py\n # eliminate DOF if it's a satisfied DBC by modifying gradient and Hessian for DBC:\n    for i, j in zip(*projected_hess.nonzero()):\n        if (is_DBC[int(i / 2)] & DBC_satisfied[int(i / 2)]) | (is_DBC[int(j / 2)] & DBC_satisfied[int(j / 2)]): \n            projected_hess[i, j] = (i == j)\n    for i in range(0, len(x)):\n        if is_DBC[i] & DBC_satisfied[i]:\n            reshaped_grad[i * 2] = reshaped_grad[i * 2 + 1] = 0.0\n    return [spsolve(projected_hess, -reshaped_grad).reshape(len(x), 2), DBC_satisfied] \n```", "```py\n [p, DBC_satisfied] = search_dir(x, e, x_tilde, m, l2, k, n, o, contact_area, (x - x_n) / h, mu_lambda, is_DBC, DBC, DBC_target, DBC_stiff[0], tol, h)\n    while (LA.norm(p, inf) / h > tol) | (sum(DBC_satisfied) != len(DBC)):   # also check whether all DBCs are satisfied\n        print('Iteration', iter, ':')\n        print('residual =', LA.norm(p, inf) / h)\n\n        if (LA.norm(p, inf) / h <= tol) & (sum(DBC_satisfied) != len(DBC)):\n            # increase DBC stiffness and recompute energy value record\n            DBC_stiff[0] *= 2\n            E_last = IP_val(x, e, x_tilde, m, l2, k, n, o, contact_area, (x - x_n) / h, mu_lambda, DBC, DBC_target, DBC_stiff[0], h) \n```"]