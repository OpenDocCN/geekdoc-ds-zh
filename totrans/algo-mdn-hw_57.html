<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Memory-Level Parallelism</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Memory-Level Parallelism</h1>
<blockquote>原文：<a href="https://en.algorithmica.org/hpc/cpu-cache/mlp/">https://en.algorithmica.org/hpc/cpu-cache/mlp/</a></blockquote><div id="search"><input id="search-bar" type="search" placeholder="Search this book…" oninput="search()"/><div id="search-count"/><div id="search-results"/></div><header><div class="info"/></header><article><p>Memory requests can overlap in time: while you wait for a read request to complete, you can send a few others, which will be executed concurrently with it. This is the main reason why <a href="../bandwidth">linear iteration</a> is so much faster than <a href="../latency">pointer jumping</a>: the CPU knows which memory locations it needs to fetch next and sends memory requests far ahead of time.</p><p>The number of concurrent memory operations is large but limited, and it is different for different types of memory. When designing algorithms and especially data structures, you may want to know this number, as it limits the amount of parallelism your computation can achieve.</p><p>To find this limit theoretically for a specific memory type, you can multiply its latency (time to fetch a cache line) by its bandwidth (number of cache lines fetched per second), which gives you the average number of memory operations in progress:</p><p><figure><img src="../Images/140f45accd593c65f4ed6d9695db7d77.png" data-original-src="https://en.algorithmica.org/hpc/cpu-cache/img/latency-bandwidth.svg"/><figcaption/></figure></p><p>The latency of the L1/L2 caches is small, so there is no need for a long pipeline of pending requests, but larger memory types can sustain up to 25-40 concurrent read operations.</p><span class="anchor" id="direct-experiment"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/cpu-cache/mlp/#direct-experiment">#</a>Direct Experiment</h3><p>Let’s try to measure available memory parallelism more directly by modifying our pointer chasing benchmark so that we loop around $D$ separate cycles in parallel instead of just one:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="n">D</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="n">M</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">D</span><span class="p">][</span><span class="n">M</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">d</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">iota</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">M</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">random_shuffle</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">M</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">k</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">k</span><span class="p">[</span><span class="n">d</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">d</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">k</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">k</span><span class="p">[</span><span class="n">d</span><span class="p">]];</span>
</span></span></code></pre></div><p>Fixing the sum of the cycle lengths constant at a few select sizes and trying different $D$, we get slightly different results:</p><p><figure><img src="../Images/6d0a280245a088fb7de18b7aa488862e.png" data-original-src="https://en.algorithmica.org/hpc/cpu-cache/img/permutation-mlp.svg"/><figcaption/></figure></p><p>The L2 cache run is limited by ~6 concurrent operations, as predicted, but larger memory types all max out between 13 and 17. You can’t make use of more memory lanes as there is a conflict over logical registers. When the number of lanes is fewer than the number of registers, you can issue just one read instruction per lane:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">dec</span>     <span class="nb">edx</span>
</span></span><span class="line"><span class="cl"><span class="nf">movsx</span>   <span class="nb">rdi</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="nv">q</span><span class="p">[</span><span class="mi">0</span><span class="o">+</span><span class="nb">rdi</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">movsx</span>   <span class="nb">rsi</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="nv">q</span><span class="p">[</span><span class="mi">1048576</span><span class="o">+</span><span class="nb">rsi</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">movsx</span>   <span class="nb">rcx</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="nv">q</span><span class="p">[</span><span class="mi">2097152</span><span class="o">+</span><span class="nb">rcx</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">movsx</span>   <span class="nb">rax</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="nv">q</span><span class="p">[</span><span class="mi">3145728</span><span class="o">+</span><span class="nb">rax</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">jne</span>     <span class="nv">.L9</span>
</span></span></code></pre></div><p>But when it is over ~15, you have to use temporary memory storage:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">mov</span>     <span class="nb">edx</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="nv">q</span><span class="p">[</span><span class="mi">0</span><span class="o">+</span><span class="nb">rdx</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span>     <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">128</span><span class="o">+</span><span class="nb">rax</span><span class="o">*</span><span class="mi">4</span><span class="p">],</span> <span class="nb">edx</span>
</span></span></code></pre></div><p>You don’t always get to the maximum possible level of memory parallelism, but for most applications, a dozen concurrent requests are more than enough.</p></article><div class="nextprev"><div class="left"><a href="https://en.algorithmica.org/hpc/cpu-cache/sharing/" id="prev-article">← Memory Sharing</a></div><div class="right"><a href="https://en.algorithmica.org/hpc/cpu-cache/prefetching/" id="next-article">Prefetching →</a></div></div>    
</body>
</html>