- en: 18.2Â Making Sets Grow on TreesğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18.2 åœ¨æ ‘ä¸Šç”Ÿé•¿é›†åˆğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/sets-from-trees.html](https://dcic-world.org/2025-08-27/sets-from-trees.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/sets-from-trees.html](https://dcic-world.org/2025-08-27/sets-from-trees.html)
- en: '| Â Â Â Â [18.2.1Â Using Binary Trees](#%28part._.Using_.Binary_.Trees%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| [18.2.1 ä½¿ç”¨äºŒå‰æ ‘](#%28part._.Using_.Binary_.Trees%29) |'
- en: '| Â Â Â Â [18.2.2Â Checking the Complexity](#%28part._.Checking_the_.Complexity%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| [18.2.2 æ£€æŸ¥å¤æ‚æ€§](#%28part._.Checking_the_.Complexity%29) |'
- en: '| Â Â Â Â [18.2.3Â A Fine Balance: Tree Surgery](#%28part._sets-from-balanced-trees%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| [18.2.3 å¹³è¡¡çš„è‰ºæœ¯ï¼šæ ‘æ‰‹æœ¯](#%28part._sets-from-balanced-trees%29) |'
- en: '| Â Â Â Â Â Â [18.2.3.1Â Left-Left Case](#%28part._.Left-.Left_.Case%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| [18.2.3.1 å·¦å·¦æƒ…å†µ](#%28part._.Left-.Left_.Case%29) |'
- en: '| Â Â Â Â Â Â [18.2.3.2Â Left-Right Case](#%28part._.Left-.Right_.Case%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| [18.2.3.2 å·¦å³æƒ…å†µ](#%28part._.Left-.Right_.Case%29) |'
- en: '| Â Â Â Â Â Â [18.2.3.3Â Any Other Cases?](#%28part._.Any_.Other_.Cases_%29) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| [18.2.3.3 å…¶ä»–æƒ…å†µï¼Ÿ](#%28part._.Any_.Other_.Cases_%29) |'
- en: In [Representing Sets as Lists](sets-from-lists.html) we saw multiple list representations
    of sets. They all came with at least some operations having linear time complexityâ€”<wbr>linear
    in different ways, but always linear in at least the number of distinct elements
    in the set. Can we do better?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ [å°†é›†åˆè¡¨ç¤ºä¸ºåˆ—è¡¨](sets-from-lists.html) ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†é›†åˆçš„å¤šç§åˆ—è¡¨è¡¨ç¤ºã€‚å®ƒä»¬éƒ½è‡³å°‘åŒ…å«ä¸€äº›å…·æœ‰çº¿æ€§æ—¶é—´å¤æ‚æ€§çš„æ“ä½œâ€”â€”<wbr>ä»¥ä¸åŒçš„æ–¹å¼çº¿æ€§ï¼Œä½†æ€»æ˜¯è‡³å°‘ä¸é›†åˆä¸­ä¸åŒå…ƒç´ çš„æ•°é‡æˆçº¿æ€§å…³ç³»ã€‚æˆ‘ä»¬èƒ½åšå¾—æ›´å¥½å—ï¼Ÿ
- en: Letâ€™s start by noting that it seems better, if at all possible, to avoid storing
    duplicates. Duplicates are only problematic during insertion due to the need for
    a membership test. But if we can make membership testing cheap, then we would
    be better off using it to check for duplicates and storing only one instance of
    each value (which also saves us space). Thus, letâ€™s try to improve the time complexity
    of membership testing (and, hopefully, of other operations too).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å…ˆæ³¨æ„ï¼Œå¦‚æœå¯èƒ½çš„è¯ï¼Œé¿å…å­˜å‚¨é‡å¤é¡¹ä¼¼ä¹æ›´å¥½ã€‚é‡å¤é¡¹åªæœ‰åœ¨æ’å…¥æ—¶ç”±äºéœ€è¦æˆå‘˜æµ‹è¯•è€Œæˆä¸ºé—®é¢˜ã€‚ä½†å¦‚æœæˆ‘ä»¬èƒ½ä¾¿å®œåœ°è¿›è¡Œæˆå‘˜æµ‹è¯•ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ä¼šæ›´ä¹æ„ç”¨å®ƒæ¥æ£€æŸ¥é‡å¤é¡¹ï¼Œå¹¶ä¸”åªå­˜å‚¨æ¯ä¸ªå€¼çš„å•ä¸ªå®ä¾‹ï¼ˆè¿™ä¹ŸèŠ‚çœäº†ç©ºé—´ï¼‰ã€‚å› æ­¤ï¼Œè®©æˆ‘ä»¬å°è¯•æé«˜æˆå‘˜æµ‹è¯•çš„æ—¶é—´å¤æ‚åº¦ï¼ˆå¹¶ä¸”ï¼Œå¸Œæœ›å¦‚æ­¤ï¼Œå…¶ä»–æ“ä½œä¹Ÿæ˜¯å¦‚æ­¤ï¼‰ã€‚
- en: It seems clear that with a (duplicate-free) list representation of a set, we
    cannot really beat linear time for membership checking. This is because at each
    step, we can eliminate only one element from contention which in the worst case
    requires a linear amount of work to examine the whole set. Instead, we need to
    eliminate many more elements with each comparisonâ€”<wbr>more than just a constant.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¾ç„¶ï¼Œå¯¹äºä¸€ä¸ªï¼ˆæ— é‡å¤é¡¹ï¼‰çš„é›†åˆåˆ—è¡¨è¡¨ç¤ºï¼Œæˆ‘ä»¬å®é™…ä¸Šæ— æ³•åœ¨æˆå‘˜æ£€æŸ¥ä¸­å‡»è´¥çº¿æ€§æ—¶é—´ã€‚è¿™æ˜¯å› ä¸ºæ¯ä¸€æ­¥æˆ‘ä»¬åªèƒ½æ¶ˆé™¤ä¸€ä¸ªäº‰è®®å…ƒç´ ï¼Œåœ¨æœ€åæƒ…å†µä¸‹éœ€è¦çº¿æ€§å·¥ä½œé‡æ¥æ£€æŸ¥æ•´ä¸ªé›†åˆã€‚ç›¸åï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ¯æ¬¡æ¯”è¾ƒä¸­æ¶ˆé™¤æ›´å¤šçš„å…ƒç´ â€”â€”<wbr>è€Œä¸ä»…ä»…æ˜¯å¸¸æ•°ã€‚
- en: 'In our handy set of recurrences [[Solving Recurrences](predicting-growth.html#%28part._solving-recurrences%29)],
    one stands out: \(T(k) = T(k/2) + c\). It says that if, with a constant amount
    of work we can eliminate half the input, we can perform membership checking in
    logarithmic time. This will be our goal.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬æ–¹ä¾¿çš„é€’å½’é›†åˆ [[è§£å†³é€’å½’](predicting-growth.html#%28part._solving-recurrences%29)]
    ä¸­ï¼Œæœ‰ä¸€ä¸ªç‰¹åˆ«çªå‡ºï¼š\(T(k) = T(k/2) + c\)ã€‚å®ƒè¡¨æ˜ï¼Œå¦‚æœæˆ‘ä»¬ç”¨æ’å®šçš„å·¥ä½œé‡å¯ä»¥æ¶ˆé™¤ä¸€åŠçš„è¾“å…¥ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å¯¹æ•°æ—¶é—´å†…æ‰§è¡Œæˆå‘˜æ£€æŸ¥ã€‚è¿™æ˜¯æˆ‘ä»¬ç›®æ ‡ã€‚
- en: Before we proceed, itâ€™s worth putting logarithmic growth in perspective. Asymptotically,
    logarithmic is obviously not as nice as constant. However, logarithmic growth
    is very pleasant because it grows so slowly. For instance, if an input doubles
    from size \(k\) to \(2k\), its logarithmâ€”<wbr>and hence resource usageâ€”<wbr>grows
    only by \(\log 2k - \log k = \log 2\), which is a constant. Indeed, for just about
    all problems, practically speaking the logarithm of the input size is bounded
    by a constant (that isnâ€™t even very large). Therefore, in practice, for many programs,
    if we can shrink our resource consumption to logarithmic growth, itâ€™s probably
    time to move on and focus on improving some other part of the system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬ç»§ç»­ä¹‹å‰ï¼Œå€¼å¾—å°†å¯¹æ•°å¢é•¿æ”¾åœ¨æ­£ç¡®çš„è§†è§’ä¸­ã€‚ä»æ¸è¿‘çš„è§’åº¦æ¥çœ‹ï¼Œå¯¹æ•°æ˜¾ç„¶æ²¡æœ‰å¸¸æ•°é‚£ä¹ˆå¥½ã€‚ç„¶è€Œï¼Œå¯¹æ•°å¢é•¿æ˜¯éå¸¸ä»¤äººæ„‰å¿«çš„ï¼Œå› ä¸ºå®ƒå¢é•¿å¾—å¦‚æ­¤ç¼“æ…¢ã€‚ä¾‹å¦‚ï¼Œå¦‚æœè¾“å…¥çš„å¤§å°ä»
    \(k\) å¢åŠ åˆ° \(2k\)ï¼Œå…¶å¯¹æ•°â€”â€”<wbr>å› æ­¤èµ„æºä½¿ç”¨â€”â€”<wbr>ä»…å¢é•¿ \(\log 2k - \log k = \log 2\)ï¼Œè¿™æ˜¯ä¸€ä¸ªå¸¸æ•°ã€‚å®é™…ä¸Šï¼Œå¯¹äºå‡ ä¹æ‰€æœ‰é—®é¢˜ï¼Œä»å®é™…çš„è§’åº¦æ¥çœ‹ï¼Œè¾“å…¥å¤§å°çš„å¯¹æ•°éƒ½å—ä¸€ä¸ªå¸¸æ•°çš„é™åˆ¶ï¼ˆè¿™ä¸ªå¸¸æ•°ç”šè‡³ä¸æ˜¯å¾ˆå¤§ï¼‰ã€‚å› æ­¤ï¼Œåœ¨å®è·µä¸­ï¼Œå¯¹äºè®¸å¤šç¨‹åºï¼Œå¦‚æœæˆ‘ä»¬èƒ½å°†æˆ‘ä»¬çš„èµ„æºæ¶ˆè€—å‡å°‘åˆ°å¯¹æ•°å¢é•¿ï¼Œé‚£ä¹ˆå¯èƒ½å°±æ˜¯æ—¶å€™ç»§ç»­å‰è¿›ï¼Œä¸“æ³¨äºæ”¹è¿›ç³»ç»Ÿçš„å…¶ä»–éƒ¨åˆ†äº†ã€‚
- en: We have actually just made an extremely subtle assumption. In the list representation
    of sets, when we check one element for membership and eliminate it, we have eliminated
    only that one element. To obtain this logarithmic complexity, we need comparing
    against one element to remove an entire set of elements. Because we are constructing
    sets of numbers, we donâ€™t need to confront this issue here. Instead, we go into
    it in much more detail in [Converting Values to Ordered Values](orderability.html#%28part._hashing-values%29).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å®é™…ä¸Šåˆšåˆšåšå‡ºäº†ä¸€ä¸ªéå¸¸å¾®å¦™çš„å‡è®¾ã€‚åœ¨é›†åˆçš„åˆ—è¡¨è¡¨ç¤ºä¸­ï¼Œå½“æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸ªå…ƒç´ ä»¥ç¡®å®šå…¶æˆå‘˜èµ„æ ¼å¹¶æ¶ˆé™¤å®ƒæ—¶ï¼Œæˆ‘ä»¬åªæ¶ˆé™¤äº†é‚£ä¸ªå…ƒç´ ã€‚ä¸ºäº†è·å¾—å¯¹æ•°å¤æ‚åº¦ï¼Œæˆ‘ä»¬éœ€è¦æ¯”è¾ƒä¸€ä¸ªå…ƒç´ ä»¥æ¶ˆé™¤æ•´ä¸ªé›†åˆçš„å…ƒç´ ã€‚å› ä¸ºæˆ‘ä»¬æ­£åœ¨æ„å»ºæ•°å­—çš„é›†åˆï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨è¿™é‡Œä¸éœ€è¦é¢å¯¹è¿™ä¸ªé—®é¢˜ã€‚ç›¸åï¼Œæˆ‘ä»¬å°†åœ¨[å°†å€¼è½¬æ¢ä¸ºæœ‰åºå€¼](orderability.html#%28part._hashing-values%29)ä¸­æ›´è¯¦ç»†åœ°ä»‹ç»è¿™ä¸ªé—®é¢˜ã€‚
- en: 18.2.1Â Using Binary Trees[ğŸ”—](#(part._.Using_.Binary_.Trees) "Link to here")
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.2.1 ä½¿ç”¨äºŒå‰æ ‘[ğŸ”—](#(part._.Using_.Binary_.Trees) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Because logs come from trees.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºå¯¹æ•°æ¥è‡ªæ ‘ã€‚
- en: 'Clearly, a list representation does not let us eliminate half the elements
    with a constant amount of work; instead, we need a tree. Thus we define a binary
    tree of (for simplicity) numbers:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¾ç„¶ï¼Œåˆ—è¡¨è¡¨ç¤ºæ³•ä¸ä¼šè®©æˆ‘ä»¬é€šè¿‡æ’å®šçš„å·¥ä½œé‡æ¶ˆé™¤ä¸€åŠçš„å…ƒç´ ï¼›ç›¸åï¼Œæˆ‘ä»¬éœ€è¦ä¸€æ£µæ ‘ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªï¼ˆä¸ºäº†ç®€å•èµ·è§ï¼‰æ•°å­—çš„äºŒå‰æ ‘ï¼š
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Given this definition, letâ€™s define the membership checker:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®šè¿™ä¸ªå®šä¹‰ï¼Œè®©æˆ‘ä»¬å®šä¹‰æˆå‘˜æ£€æŸ¥å™¨ï¼š
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Oh, wait. If the element weâ€™re looking for isnâ€™t the root, what do we do? It
    could be in the left child or it could be in the right; we wonâ€™t know for sure
    until weâ€™ve examined both. Thus, we canâ€™t throw away half the elements; the only
    one we can dispose of is the value at the root. Furthermore, this property holds
    at every level of the tree. Thus, membership checking needs to examine the entire
    tree, and we still have complexity linear in the size of the set.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: å“¦ï¼Œç­‰ç­‰ã€‚å¦‚æœæˆ‘ä»¬å¯»æ‰¾çš„å…ƒç´ ä¸æ˜¯æ ¹èŠ‚ç‚¹ï¼Œæˆ‘ä»¬è¯¥æ€ä¹ˆåŠï¼Ÿå®ƒå¯èƒ½åœ¨å·¦å­èŠ‚ç‚¹ä¸­ï¼Œä¹Ÿå¯èƒ½åœ¨å³å­èŠ‚ç‚¹ä¸­ï¼›é™¤éæˆ‘ä»¬æ£€æŸ¥äº†ä¸¤è€…ï¼Œå¦åˆ™æˆ‘ä»¬æ— æ³•ç¡®å®šã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¸èƒ½ä¸¢å¼ƒä¸€åŠçš„å…ƒç´ ï¼›æˆ‘ä»¬å”¯ä¸€å¯ä»¥ä¸¢å¼ƒçš„æ˜¯æ ¹èŠ‚ç‚¹çš„å€¼ã€‚æ­¤å¤–ï¼Œè¿™ä¸ªå±æ€§åœ¨æ ‘çš„æ¯ä¸€å±‚éƒ½æˆç«‹ã€‚å› æ­¤ï¼Œæˆå‘˜æ£€æŸ¥éœ€è¦æ£€æŸ¥æ•´ä¸ªæ ‘ï¼Œæˆ‘ä»¬ä»ç„¶æœ‰ä¸é›†åˆå¤§å°æˆçº¿æ€§å¤æ‚åº¦çš„å¤æ‚åº¦ã€‚
- en: How can we improve on this? The comparison needs to help us eliminate not only
    the root but also one whole sub-tree. We can only do this if the comparison â€œspeaks
    forâ€ an entire sub-tree. It can do so if all elements in one sub-tree are less
    than or equal to the root value, and all elements in the other sub-tree are greater
    than or equal to it. Of course, we have to be consistent about which side contains
    which subset; it is conventional to put the smaller elements to the left and the
    bigger ones to the right. This refines our binary tree definition to give us a
    binary search tree (BST).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•æ”¹è¿›ï¼Ÿæ¯”è¾ƒéœ€è¦å¸®åŠ©æˆ‘ä»¬æ¶ˆé™¤çš„ä¸ä»…æ˜¯æ ¹èŠ‚ç‚¹ï¼Œè€Œä¸”æ˜¯ä¸€ä¸ªå®Œæ•´çš„å­æ ‘ã€‚æˆ‘ä»¬åªèƒ½è¿™æ ·åšï¼Œå¦‚æœæ¯”è¾ƒâ€œä»£è¡¨â€æ•´ä¸ªå­æ ‘ã€‚å®ƒå¯ä»¥è¿™æ ·åšï¼Œå¦‚æœå­æ ‘ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½å°äºæˆ–ç­‰äºæ ¹èŠ‚ç‚¹çš„å€¼ï¼Œè€Œå¦ä¸€ä¸ªå­æ ‘ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½å¤§äºæˆ–ç­‰äºå®ƒã€‚å½“ç„¶ï¼Œæˆ‘ä»¬å¿…é¡»ä¸€è‡´åœ°ç¡®å®šå“ªä¸€ä¾§åŒ…å«å“ªä¸ªå­é›†ï¼›ä¼ ç»Ÿä¸Šï¼Œå°†è¾ƒå°çš„å…ƒç´ æ”¾åœ¨å·¦è¾¹ï¼Œè¾ƒå¤§çš„å…ƒç´ æ”¾åœ¨å³è¾¹ã€‚è¿™ä½¿æˆ‘ä»¬çš„äºŒå‰æ ‘å®šä¹‰æ›´åŠ ç²¾ç¡®ï¼Œä»¥ç»™æˆ‘ä»¬ä¸€ä¸ªäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰ã€‚
- en: Do Now!
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here is a candiate predicate for recognizing when a binary tree is in fact
    a binary search tree:'
  id: totrans-24
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯ä¸€ä¸ªè¯†åˆ«äºŒå‰æ ‘å®é™…ä¸Šæ˜¯å¦ä¸ºäºŒå‰æœç´¢æ ‘çš„å€™é€‰è°“è¯ï¼š
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is this definition correct?
  id: totrans-28
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå®šä¹‰æ­£ç¡®å—ï¼Ÿ
- en: 'Itâ€™s not. To actually throw away half the tree, we need to be sure that everything
    in the left sub-tree is less than the value in the root and similarly, everything
    in the right sub-tree is greater than the root.We have used `<=` instead of `<`
    above because even though we donâ€™t want to permit duplicates when representing
    sets, in other cases we might not want to be so stringent; this way we can reuse
    the above implementation for other purposes. But the definition above performs
    only a â€œshallowâ€ comparison. Thus we could have a root a with a right child, b,
    such that b > a; and the b node could have a left child c such that c < b; but
    this does not guarantee that c > a. In fact, it is easy to construct a counter-example
    that passes this check:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸æ­£ç¡®ã€‚è¦çœŸæ­£ä¸¢å¼ƒä¸€åŠçš„æ ‘ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿å·¦å­æ ‘ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½å°äºæ ¹èŠ‚ç‚¹çš„å€¼ï¼ŒåŒæ ·ï¼Œå³å­æ ‘ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½å¤§äºæ ¹èŠ‚ç‚¹çš„å€¼ã€‚æˆ‘ä»¬ä¸Šé¢ä½¿ç”¨äº†`<=`è€Œä¸æ˜¯`<`ï¼Œå› ä¸ºå°½ç®¡æˆ‘ä»¬ä¸æƒ³åœ¨è¡¨ç¤ºé›†åˆæ—¶å…è®¸é‡å¤ï¼Œä½†åœ¨å…¶ä»–æƒ…å†µä¸‹æˆ‘ä»¬å¯èƒ½ä¸æƒ³å¦‚æ­¤ä¸¥æ ¼ï¼›è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥é‡ç”¨ä¸Šé¢çš„å®ç°æ¥ç”¨äºå…¶ä»–ç›®çš„ã€‚ä½†ä¸Šé¢çš„å®šä¹‰åªæ‰§è¡Œäº†â€œæµ…å±‚â€æ¯”è¾ƒã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯èƒ½æœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹aï¼Œå…¶å³å­èŠ‚ç‚¹bï¼Œä½¿å¾—b
    > aï¼›å¹¶ä¸”bèŠ‚ç‚¹å¯èƒ½æœ‰ä¸€ä¸ªå·¦å­èŠ‚ç‚¹cï¼Œä½¿å¾—c < bï¼›ä½†è¿™å¹¶ä¸ä¿è¯c > aã€‚äº‹å®ä¸Šï¼Œå¾ˆå®¹æ˜“æ„é€ ä¸€ä¸ªåä¾‹æ¥é€šè¿‡è¿™ä¸ªæ£€æŸ¥ï¼š
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Exercise
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fix the BST checker.
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¿®å¤BSTæ£€æŸ¥å™¨ã€‚
- en: 'With a corrected definition, we can now define a refined version of binary
    trees that are search trees:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¿®æ­£äº†å®šä¹‰ä¹‹åï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥å®šä¹‰ä¸€ä¸ªæ›´ç²¾ç¡®çš„äºŒå‰æœç´¢æ ‘ç‰ˆæœ¬ï¼š
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also remind ourselves that the purpose of this exercise was to define
    sets, and define `TSet`s to be tree sets:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥æé†’è‡ªå·±ï¼Œè¿™ä¸ªç»ƒä¹ çš„ç›®çš„æ˜¯å®šä¹‰é›†åˆï¼Œå¹¶å°† `TSet` å®šä¹‰ä¸ºæ ‘é›†åˆï¼š
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now letâ€™s implement our operations on the BST representation. First weâ€™ll write
    a template:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬åœ¨ BST è¡¨ç¤ºä¸Šå®ç°æˆ‘ä»¬çš„æ“ä½œã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å°†ç¼–å†™ä¸€ä¸ªæ¨¡æ¿ï¼š
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Observe that the data definition of a BST gives us rich information about the
    two children: they are each a BST, so we know their elements obey the ordering
    property. We can use this to define the actual operations:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼ŒBST çš„æ•°æ®å®šä¹‰ç»™æˆ‘ä»¬å…³äºä¸¤ä¸ªå­èŠ‚ç‚¹çš„ä¸°å¯Œä¿¡æ¯ï¼šå®ƒä»¬å„è‡ªéƒ½æ˜¯ä¸€ä¸ª BSTï¼Œå› æ­¤æˆ‘ä»¬çŸ¥é“å®ƒä»¬çš„å…ƒç´ éµå¾ªæ’åºå±æ€§ã€‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™ä¸€ç‚¹æ¥å®šä¹‰å®é™…çš„æ“ä½œï¼š
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In both functions we are strictly assuming the invariant of the BST, and in
    the latter case also ensuring it. Make sure you identify where, why, and how.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸¤ä¸ªå‡½æ•°ä¸­ï¼Œæˆ‘ä»¬ä¸¥æ ¼å‡è®¾ BST çš„ä¸å˜æ€§ï¼Œå¹¶åœ¨åä¸€ç§æƒ…å†µä¸‹ç¡®ä¿å®ƒã€‚ç¡®ä¿ä½ ç¡®å®šåœ¨å“ªé‡Œã€ä¸ºä»€ä¹ˆä»¥åŠå¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹ã€‚
- en: You should now be able to define the remaining operations. Of these, `size`
    clearly requires linear time (since it has to count all the elements), but because
    `is-in` and `insert` both throw away one of two children each time they recur,
    they take logarithmic time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œä½ åº”è¯¥èƒ½å¤Ÿå®šä¹‰å‰©ä½™çš„æ“ä½œã€‚åœ¨è¿™äº›æ“ä½œä¸­ï¼Œ`size` æ˜¾ç„¶éœ€è¦çº¿æ€§æ—¶é—´ï¼ˆå› ä¸ºå®ƒå¿…é¡»è®¡ç®—æ‰€æœ‰å…ƒç´ ï¼‰ï¼Œä½†ç”±äº `is-in` å’Œ `insert` æ¯æ¬¡é€’å½’éƒ½ä¼šä¸¢å¼ƒä¸¤ä¸ªå­èŠ‚ç‚¹ä¸­çš„ä¸€ä¸ªï¼Œæ‰€ä»¥å®ƒä»¬éœ€è¦å¯¹æ•°æ—¶é—´ã€‚
- en: Exercise
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose we frequently needed to compute the size of a set. We ought to be able
    to reduce the time complexity of `size` by having each tree [â˜› cache](glossary.html#%28elem._glossary-cache%29)
    its size, so that `size` could complete in constant time (note that the size of
    the tree clearly fits the criterion of a cache, since it can always be reconstructed).
    Update the data definition and all affected functions to keep track of this information
    correctly.
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬ç»å¸¸éœ€è¦è®¡ç®—é›†åˆçš„å¤§å°ã€‚æˆ‘ä»¬åº”è¯¥èƒ½å¤Ÿé€šè¿‡è®©æ¯ä¸ªæ ‘ [â˜› ç¼“å­˜](glossary.html#%28elem._glossary-cache%29)
    å…¶å¤§å°æ¥é™ä½ `size` çš„æ—¶é—´å¤æ‚åº¦ï¼Œè¿™æ · `size` å°±å¯ä»¥åœ¨å¸¸æ•°æ—¶é—´å†…å®Œæˆï¼ˆæ³¨æ„ï¼Œæ ‘çš„å¤§å°æ˜¾ç„¶ç¬¦åˆç¼“å­˜çš„å‡†åˆ™ï¼Œå› ä¸ºå®ƒæ€»æ˜¯å¯ä»¥è¢«é‡å»ºï¼‰ã€‚æ›´æ–°æ•°æ®å®šä¹‰å’Œæ‰€æœ‰å—å½±å“çš„å‡½æ•°ï¼Œä»¥æ­£ç¡®è·Ÿè¸ªè¿™äº›ä¿¡æ¯ã€‚
- en: 18.2.2Â Checking the Complexity[ğŸ”—](#(part._.Checking_the_.Complexity) "Link to
    here")
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.2.2Â æ£€æŸ¥å¤æ‚åº¦[ğŸ”—](#(part._.Checking_the_.Complexity) "é“¾æ¥è‡³æ­¤")
- en: But wait a minute. Are we actually done? Our recurrence takes the form \(T(k)
    = T(k/2) + c\), but what in our data definition guaranteed that the size of the
    child traversed by `is-in` will be half the size?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†ç­‰ç­‰ã€‚æˆ‘ä»¬çœŸçš„å®Œæˆäº†å—ï¼Ÿæˆ‘ä»¬çš„é€’å½’å½¢å¼ä¸º \(T(k) = T(k/2) + c\)ï¼Œä½†æˆ‘ä»¬çš„æ•°æ®å®šä¹‰ä¸­æœ‰ä»€ä¹ˆä¿è¯äº† `is-in` éå†çš„å­èŠ‚ç‚¹çš„å¤§å°å°†æ˜¯å¤§å°çš„ä¸€åŠï¼Ÿ
- en: Do Now!
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Construct an exampleâ€”<wbr>consisting of a sequence of `insert`s to the empty
    treeâ€”<wbr>such that the resulting tree is not balanced. Show that searching for
    certain elements in this tree will take linear, not logarithmic, time in its size.
  id: totrans-51
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ„é€ ä¸€ä¸ªä¾‹å­â€”â€”<wbr>ç”±ä¸€ç³»åˆ—å¯¹ç©ºæ ‘çš„ `insert` æ“ä½œç»„æˆâ€”â€”<wbr>ä½¿å¾—å¾—åˆ°çš„æ ‘æ˜¯ä¸å¹³è¡¡çš„ã€‚è¯æ˜åœ¨è¿™ä¸ªæ ‘ä¸­æœç´¢æŸäº›å…ƒç´ å°†éœ€è¦çº¿æ€§æ—¶é—´ï¼Œè€Œä¸æ˜¯å¯¹æ•°æ—¶é—´ã€‚
- en: Imagine starting with the empty tree and inserting the values `1`, `2`, `3`,
    and `4`, in order. The resulting tree would be
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡ä¸€ä¸‹ï¼Œä»ä¸€ä¸ªç©ºæ ‘å¼€å§‹ï¼Œä¾æ¬¡æ’å…¥å€¼ `1`ã€`2`ã€`3` å’Œ `4`ã€‚å¾—åˆ°çš„æ ‘å°†æ˜¯
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Searching for `4` in this tree would have to examine all the set elements in
    the tree. In other words, this binary search tree is degenerateâ€”<wbr>it is effectively
    a list, and we are back to having the same complexity we had earlier.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªæ ‘ä¸­æœç´¢ `4` å¿…é¡»æ£€æŸ¥æ ‘ä¸­çš„æ‰€æœ‰é›†åˆå…ƒç´ ã€‚æ¢å¥è¯è¯´ï¼Œè¿™ä¸ªäºŒå‰æœç´¢æ ‘æ˜¯é€€åŒ–çš„â€”â€”<wbr>å®ƒå®é™…ä¸Šæ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œæˆ‘ä»¬å›åˆ°äº†ä¹‹å‰ç›¸åŒçš„å¤æ‚åº¦ã€‚
- en: 'Therefore, using a binary tree, and even a BST, does not guarantee the complexity
    we want: it does only if our inputs have arrived in just the right order. However,
    we cannot assume any input ordering; instead, we would like an implementation
    that works in all cases. Thus, we must find a way to ensure that the tree is always
    balanced, so each recursive call in `is-in` really does throw away half the elements.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œä½¿ç”¨äºŒå‰æ ‘ï¼Œç”šè‡³ BSTï¼Œå¹¶ä¸èƒ½ä¿è¯æˆ‘ä»¬æƒ³è¦çš„å¤æ‚åº¦ï¼šåªæœ‰åœ¨æˆ‘ä»¬çš„è¾“å…¥æ°å¥½ä»¥æ­£ç¡®çš„é¡ºåºåˆ°è¾¾æ—¶æ‰èƒ½ä¿è¯ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ä¸èƒ½å‡è®¾ä»»ä½•è¾“å…¥é¡ºåºï¼›ç›¸åï¼Œæˆ‘ä»¬å¸Œæœ›æœ‰ä¸€ä¸ªåœ¨æ‰€æœ‰æƒ…å†µä¸‹éƒ½å·¥ä½œçš„å®ç°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¿…é¡»æ‰¾åˆ°ä¸€ç§æ–¹æ³•æ¥ç¡®ä¿æ ‘å§‹ç»ˆæ˜¯å¹³è¡¡çš„ï¼Œè¿™æ ·
    `is-in` ä¸­çš„æ¯ä¸ªé€’å½’è°ƒç”¨å®é™…ä¸Šéƒ½ä¸¢å¼ƒäº†ä¸€åŠçš„å…ƒç´ ã€‚
- en: Exercise
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that we have not talked about computing the size of the set. Even if
    we could assume that the binary tree is balanced, how do we determine the size
    in logarithmic-or-better time?
  id: totrans-58
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰è®¨è®ºå¦‚ä½•è®¡ç®—é›†åˆçš„å¤§å°ã€‚å³ä½¿æˆ‘ä»¬å¯ä»¥å‡è®¾äºŒå‰æ ‘æ˜¯å¹³è¡¡çš„ï¼Œæˆ‘ä»¬å¦‚ä½•ä»¥å¯¹æ•°æˆ–æ›´å¥½çš„æ—¶é—´ç¡®å®šå¤§å°ï¼Ÿ
- en: '18.2.3Â A Fine Balance: Tree Surgery[ğŸ”—](#(part._sets-from-balanced-trees) "Link
    to here")'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.2.3Â ç²¾ç»†å¹³è¡¡ï¼šæ ‘æ‰‹æœ¯[ğŸ”—](#(part._sets-from-balanced-trees) "é“¾æ¥è‡³æ­¤")
- en: 'Letâ€™s define a balanced binary search tree (BBST). It must obviously be a search
    tree, so letâ€™s focus on the â€œbalancedâ€ part. We have to be careful about precisely
    what this means: we canâ€™t simply expect both sides to be of equal size because
    this demands that the tree (and hence the set) have an even number of elements
    and, even more stringently, to have a size that is a power of two.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼ˆBBSTï¼‰ã€‚æ˜¾ç„¶ï¼Œå®ƒå¿…é¡»æ˜¯ä¸€ä¸ªæœç´¢æ ‘ï¼Œæ‰€ä»¥æˆ‘ä»¬å…³æ³¨â€œå¹³è¡¡â€çš„éƒ¨åˆ†ã€‚æˆ‘ä»¬å¿…é¡»å°å¿ƒåœ°ç²¾ç¡®ç†è§£è¿™æ„å‘³ç€ä»€ä¹ˆï¼šæˆ‘ä»¬ä¸èƒ½ç®€å•åœ°æœŸæœ›ä¸¤è¾¹å¤§å°ç›¸ç­‰ï¼Œå› ä¸ºè¿™è¦æ±‚æ ‘ï¼ˆä»¥åŠé›†åˆï¼‰æœ‰å¶æ•°ä¸ªå…ƒç´ ï¼Œç”šè‡³æ›´ä¸¥æ ¼çš„æ˜¯ï¼Œå¤§å°å¿…é¡»æ˜¯2çš„å¹‚ã€‚
- en: Exercise
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define a predicate for a BBST that consumes a `BT` and returns a `Boolean` indicating
    whether or not it a balanced search tree.
  id: totrans-63
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®šä¹‰ä¸€ä¸ªé’ˆå¯¹BBSTçš„è°“è¯ï¼Œå®ƒæ¶ˆè€—ä¸€ä¸ª`BT`å¹¶è¿”å›ä¸€ä¸ª`Boolean`å€¼ï¼ŒæŒ‡ç¤ºæ˜¯å¦ä¸ºå¹³è¡¡æœç´¢æ ‘ã€‚
- en: 'Therefore, we relax the notion of balance to one that is both accommodating
    and sufficient. We use the term balance factor for a node to refer to the height
    of its left child minus the height of its right child (where the height is the
    depth, in edges, of the deepest node). We allow every node of a BBST to have a
    balance factor of \(-1\), \(0\), or \(1\) (but nothing else): that is, either
    both have the same height, or the left or the right can be one taller. Note that
    this is a recursive property, but it applies at all levels, so the imbalance cannot
    accumulate making the whole tree arbitrarily imbalanced.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬å°†å¹³è¡¡çš„æ¦‚å¿µæ”¾å®½ä¸ºæ—¢é€‚åº”åˆå……åˆ†çš„å¹³è¡¡ã€‚æˆ‘ä»¬ç”¨â€œå¹³è¡¡å› å­â€è¿™ä¸ªæœ¯è¯­æ¥æŒ‡ä»£ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å­æ ‘é«˜åº¦å‡å»å…¶å³å­æ ‘é«˜åº¦ï¼ˆé«˜åº¦æ˜¯æŒ‡æœ€æ·±å±‚èŠ‚ç‚¹çš„è¾¹æ•°æ·±åº¦ï¼‰ã€‚æˆ‘ä»¬å…è®¸BBSTçš„æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªå¹³è¡¡å› å­ä¸º\(-1\)ã€\(0\)æˆ–\(1\)ï¼ˆä½†ä¸èƒ½æ˜¯å…¶ä»–å€¼ï¼‰ï¼šä¹Ÿå°±æ˜¯è¯´ï¼Œè¦ä¹ˆä¸¤è€…é«˜åº¦ç›¸åŒï¼Œè¦ä¹ˆå·¦å­æ ‘æˆ–å³å­æ ‘å¯ä»¥é«˜ä¸€ä¸ªå•ä½ã€‚è¯·æ³¨æ„ï¼Œè¿™æ˜¯ä¸€ä¸ªé€’å½’å±æ€§ï¼Œä½†å®ƒé€‚ç”¨äºæ‰€æœ‰çº§åˆ«ï¼Œå› æ­¤ä¸å¹³è¡¡ä¸ä¼šç´¯ç§¯ï¼Œä½¿å¾—æ•´ä¸ªæ ‘ä»»æ„ä¸å¹³è¡¡ã€‚
- en: Exercise
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given this definition of a BBST, show that the number of nodes is exponential
    in the height. Thus, always recurring on one branch will terminate after a logarithmic
    (in the number of nodes) number of steps.
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»™å®šBBSTçš„å®šä¹‰ï¼Œè¯æ˜èŠ‚ç‚¹æ•°æ˜¯æŒ‡æ•°çº§çš„ã€‚å› æ­¤ï¼Œæ€»æ˜¯é€’å½’åœ¨ä¸€æ¡åˆ†æ”¯ä¸Šå°†åœ¨ç»è¿‡å¯¹æ•°ï¼ˆä»¥èŠ‚ç‚¹æ•°ä¸ºåº•ï¼‰çš„æ­¥éª¤æ•°åç»ˆæ­¢ã€‚
- en: 'Here is an obvious but useful observation: every BBST is also a BST (this was
    true by the very definition of a BBST). Why does this matter? It means that a
    function that operates on a BST can just as well be applied to a BBST without
    any loss of correctness.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªæ˜æ˜¾ä½†æœ‰ç”¨çš„è§‚å¯Ÿï¼šæ¯ä¸ªBBSTä¹Ÿæ˜¯ä¸€ä¸ªBSTï¼ˆè¿™æ˜¯ç”±BBSTçš„å®šä¹‰æœ¬èº«å†³å®šçš„ï¼‰ã€‚è¿™æœ‰ä»€ä¹ˆå…³ç³»ï¼Ÿè¿™æ„å‘³ç€å¯¹BSTæ“ä½œçš„åŠŸèƒ½åŒæ ·å¯ä»¥åº”ç”¨äºBBSTï¼Œè€Œä¸ä¼šä¸¢å¤±æ­£ç¡®æ€§ã€‚
- en: So far, so easy. All that leaves is a means of creating a BBST, because itâ€™s
    responsible for ensuring balance. Itâ€™s easy to see that the constant `empty-set`
    is a BBST value. So that leaves only `insert`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œä¸€åˆ‡éƒ½å¾ˆç®€å•ã€‚å‰©ä¸‹çš„åªæ˜¯ä¸€ä¸ªåˆ›å»ºBBSTçš„æ–¹æ³•ï¼Œå› ä¸ºå®ƒè´Ÿè´£ç¡®ä¿å¹³è¡¡ã€‚å¾ˆå®¹æ˜“çœ‹å‡ºå¸¸é‡`empty-set`æ˜¯ä¸€ä¸ªBBSTå€¼ã€‚æ‰€ä»¥åªå‰©ä¸‹`insert`ã€‚
- en: Here is our situation with `insert`. Assuming we start with a BBST, we can determine
    in logarithmic time whether the element is already in the tree and, if so, ignore
    it.To implement a bag we count how many of each element are in it, which does
    not affect the treeâ€™s height. When inserting an element, given balanced trees,
    the `insert` for a BST takes only a logarithmic amount of time to perform the
    insertion. Thus, if performing the insertion does not affect the treeâ€™s balance,
    weâ€™re done. Therefore, we only need to consider cases where performing the insertion
    throws off the balance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯æˆ‘ä»¬çš„`insert`æƒ…å†µã€‚å‡è®¾æˆ‘ä»¬ä»ä¸€ä¸ªBBSTå¼€å§‹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å¯¹æ•°æ—¶é—´å†…ç¡®å®šå…ƒç´ æ˜¯å¦å·²ç»åœ¨æ ‘ä¸­ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å¿½ç•¥å®ƒã€‚ä¸ºäº†å®ç°ä¸€ä¸ªåŒ…ï¼Œæˆ‘ä»¬è®¡ç®—å…¶ä¸­æ¯ä¸ªå…ƒç´ çš„æ•°é‡ï¼Œè¿™ä¸ä¼šå½±å“æ ‘çš„é«˜åº¦ã€‚å½“æ’å…¥ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œç»™å®šå¹³è¡¡æ ‘ï¼ŒBSTçš„`insert`åªéœ€è¦å¯¹æ•°æ—¶é—´æ¥å®Œæˆæ’å…¥ã€‚å› æ­¤ï¼Œå¦‚æœæ‰§è¡Œæ’å…¥ä¸ä¼šå½±å“æ ‘çš„å¹³è¡¡ï¼Œæˆ‘ä»¬å°±å®Œæˆäº†ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åªéœ€è¦è€ƒè™‘æ‰§è¡Œæ’å…¥ä¼šç ´åå¹³è¡¡çš„æƒ…å†µã€‚
- en: 'Observe that because \(<\) and \(>\) are symmetric (likewise with \(<=\) and
    \(>=\)), we can consider insertions into one half of the tree and a symmetric
    argument handles insertions into the other half. Thus, suppose we have a tree
    that is currently balanced into which we are inserting the element \(e\). Letâ€™s
    say \(e\) is going into the left sub-tree and, by virtue of being inserted, will
    cause the entire tree to become imbalanced.Some trees, like family trees ([Data
    Design Problem â€“ Ancestry Data](trees.html#%28part._ancestor-trees%29)) represent
    real-world data. It makes no sense to â€œbalanceâ€ a family tree: it must accurately
    model whatever reality it represents. These set-representing trees, in contrast,
    are chosen by us, not dictated by some external reality, so we are free to rearrange
    them.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°å› ä¸º `<` å’Œ `>` æ˜¯å¯¹ç§°çš„ï¼ˆåŒæ ·ï¼Œ`<=` å’Œ `>=` ä¹Ÿæ˜¯å¯¹ç§°çš„ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘å°†å…ƒç´ æ’å…¥æ ‘çš„ä¸€åŠï¼Œå¹¶ä½¿ç”¨å¯¹ç§°çš„è®ºæ®æ¥å¤„ç†å¦ä¸€åŠçš„æ’å…¥ã€‚å› æ­¤ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªå½“å‰å¹³è¡¡çš„æ ‘ï¼Œæˆ‘ä»¬å°†å…ƒç´ 
    `e` æ’å…¥å…¶ä¸­ã€‚å‡è®¾ `e` å°†è¿›å…¥å·¦å­æ ‘ï¼Œå¹¶ä¸”ç”±äºæ’å…¥ï¼Œæ•´ä¸ªæ ‘å°†å˜å¾—ä¸å¹³è¡¡ã€‚æœ‰äº›æ ‘ï¼Œå¦‚å®¶è°±æ ‘ï¼ˆ[æ•°æ®è®¾è®¡é—®é¢˜ - å®¶è°±æ•°æ®](trees.html#%28part._ancestor-trees%29)ï¼‰ä»£è¡¨ç°å®ä¸–ç•Œçš„æ•°æ®ã€‚å¯¹å®¶è°±æ ‘è¿›è¡Œâ€œå¹³è¡¡â€æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼šå®ƒå¿…é¡»å‡†ç¡®æ¨¡æ‹Ÿå®ƒæ‰€ä»£è¡¨çš„ç°å®ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œè¿™äº›è¡¨ç¤ºé›†åˆçš„æ ‘æ˜¯æˆ‘ä»¬é€‰æ‹©çš„ï¼Œè€Œä¸æ˜¯ç”±å¤–éƒ¨ç°å®å†³å®šçš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥è‡ªç”±åœ°é‡æ–°æ’åˆ—å®ƒä»¬ã€‚
- en: There are two ways to proceed. One is to consider all the places where we might
    insert \(e\) in a way that causes an imbalance and determine what to do in each
    case.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥ç»§ç»­ã€‚ä¸€ç§æ–¹æ³•æ˜¯è€ƒè™‘æ‰€æœ‰å¯èƒ½å¯¼è‡´ä¸å¹³è¡¡çš„æ’å…¥ `e` çš„åœ°æ–¹ï¼Œå¹¶ç¡®å®šæ¯ç§æƒ…å†µåº”è¯¥åšä»€ä¹ˆã€‚
- en: Exercise
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Enumerate all the cases where insertion might be problematic, and dictate what
    to do in each case.
  id: totrans-75
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åˆ—ä¸¾æ‰€æœ‰å¯èƒ½å¯¼è‡´æ’å…¥é—®é¢˜çš„æ¡ˆä¾‹ï¼Œå¹¶è§„å®šæ¯ç§æƒ…å†µåº”è¯¥åšä»€ä¹ˆã€‚
- en: 'The number of cases is actually quite overwhelming (if you didnâ€™t think so,
    you missed a few...). Therefore, we instead attack the problem after it has occurred:
    allow the existing BST `insert` to insert the element, assume that we have an
    imbalanced tree, and show how to restore its balance.The insight that a tree can
    be made â€œself-balancingâ€ is quite remarkable, and there are now many solutions
    to this problem. This particular one, one of the oldest, is due to G.M. Adelson-Velskii
    and E.M. Landis. In honor of their initials it is called an AVL Tree, though the
    tree itself is quite evident; their genius is in defining re-balancing.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ…å†µçš„æ•°é‡å®é™…ä¸Šç›¸å½“å¤šï¼ˆå¦‚æœä½ æ²¡æœ‰è¿™æ ·è®¤ä¸ºï¼Œä½ å¯èƒ½é”™è¿‡äº†ä¸€äº›...ï¼‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è€Œæ˜¯åœ¨é—®é¢˜å‘ç”Ÿåæ‰è§£å†³è¿™ä¸ªé—®é¢˜ï¼šå…è®¸ç°æœ‰çš„ BST `insert` æ’å…¥å…ƒç´ ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªä¸å¹³è¡¡çš„æ ‘ï¼Œå¹¶å±•ç¤ºå¦‚ä½•æ¢å¤å…¶å¹³è¡¡ã€‚ä¸€ä¸ªæ ‘å¯ä»¥è¢«åšæˆâ€œè‡ªå¹³è¡¡â€çš„æ´å¯ŸåŠ›æ˜¯éå¸¸æ˜¾è‘—çš„ï¼Œç°åœ¨æœ‰å¾ˆå¤šäººè§£å†³äº†è¿™ä¸ªé—®é¢˜ã€‚è¿™ä¸ªç‰¹å®šçš„è§£å†³æ–¹æ¡ˆï¼Œæœ€å¤è€çš„ä¹‹ä¸€ï¼Œå½’åŠŸäº
    G.M. Adelson-Velskii å’Œ E.M. Landisã€‚ä¸ºäº†çºªå¿µä»–ä»¬çš„é¦–å­—æ¯ç¼©å†™ï¼Œå®ƒè¢«ç§°ä¸º AVL æ ‘ï¼Œå°½ç®¡æ ‘æœ¬èº«æ˜¯æ˜¾è€Œæ˜“è§çš„ï¼›ä»–ä»¬çš„å¤©æ‰åœ¨äºå®šä¹‰äº†é‡æ–°å¹³è¡¡ã€‚
- en: 'Thus, in what follows, we begin with a tree that is balanced; `insert` causes
    it to become imbalanced; we have assumed that the insertion happened in the left
    sub-tree. In particular, suppose a (sub-)tree has a balance factor of \(2\) (positive
    because weâ€™re assuming the left is imbalanced by insertion). The procedure for
    restoring balance depends critically on the following property:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œåœ¨æ¥ä¸‹æ¥çš„å†…å®¹ä¸­ï¼Œæˆ‘ä»¬ä»ä¸€ä¸ªå¹³è¡¡çš„æ ‘å¼€å§‹ï¼›`insert` ä½¿å…¶å˜å¾—ä¸å¹³è¡¡ï¼›æˆ‘ä»¬å‡è®¾æ’å…¥å‘ç”Ÿåœ¨å·¦å­æ ‘ä¸­ã€‚ç‰¹åˆ«æ˜¯ï¼Œå‡è®¾ä¸€ä¸ªï¼ˆå­ï¼‰æ ‘çš„å¹³è¡¡å› å­ä¸º `2`ï¼ˆç”±äºæˆ‘ä»¬å‡è®¾å·¦å­æ ‘ç”±äºæ’å…¥è€Œä¸å¹³è¡¡ï¼Œæ‰€ä»¥æ˜¯æ­£çš„ï¼‰ã€‚æ¢å¤å¹³è¡¡çš„ç¨‹åºå–å†³äºä»¥ä¸‹å…³é”®å±æ€§ï¼š
- en: Exercise
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that if a tree is currently balanced, i.e., the balance factor at every
    node is \(-1\), \(0\), or \(1\), then `insert` can at worst make the balance factor
    \(\pm 2\).
  id: totrans-80
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¯æ˜å¦‚æœæ ‘å½“å‰æ˜¯å¹³è¡¡çš„ï¼Œå³æ¯ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­æ˜¯ `-1`ã€`0` æˆ– `1`ï¼Œé‚£ä¹ˆ `insert` æœ€å¤šå¯ä»¥ä½¿å¹³è¡¡å› å­å˜ä¸º `Â±2`ã€‚
- en: The algorithm that follows is applied as `insert` returns from its recursion,
    i.e., on the path from the inserted value back to the root. Since this path is
    of logarithmic length in the setâ€™s size (due to the balancing property), and (as
    we shall see) performs only a constant amount of work at each step, it ensures
    that insertion also takes only logarithmic time, thus completing our challenge.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹ç®—æ³•åœ¨ `insert` ä»å…¶é€’å½’è¿”å›æ—¶åº”ç”¨ï¼Œå³ä»æ’å…¥å€¼è¿”å›æ ¹çš„è·¯å¾„ä¸Šã€‚ç”±äºè¿™ä¸ªè·¯å¾„åœ¨é›†åˆå¤§å°ä¸­æ˜¯å¯¹æ•°é•¿åº¦ï¼ˆç”±äºå¹³è¡¡å±æ€§ï¼‰ï¼Œå¹¶ä¸”ï¼ˆæ­£å¦‚æˆ‘ä»¬å°†çœ‹åˆ°çš„ï¼‰åœ¨æ¯ä¸€æ­¥åªæ‰§è¡Œå¸¸æ•°é‡çš„å·¥ä½œï¼Œè¿™ç¡®ä¿äº†æ’å…¥ä¹ŸåªèŠ±è´¹å¯¹æ•°æ—¶é—´ï¼Œä»è€Œå®Œæˆäº†æˆ‘ä»¬çš„æŒ‘æˆ˜ã€‚
- en: 'To visualize the algorithm, letâ€™s use this tree schematic:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å¯è§†åŒ–ç®—æ³•ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªæ ‘å½¢å›¾ï¼š
- en: '| Â Â Â Â p |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â p |'
- en: '| Â Â Â / \ |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â / \ |'
- en: '| Â Â qÂ Â Â C |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â qÂ Â Â Â C |'
- en: '| Â / \ |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| Â / \ |'
- en: '| AÂ Â Â B |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| AÂ Â Â Â B |'
- en: Here, \(p\) is the value of the element at the root (though we will also abuse
    terminology and use the value at a root to refer to that whole tree), \(q\) is
    the value at the root of the left sub-tree (so \(q < p\)), and \(A\), \(B\), and
    \(C\) name the respective sub-trees. We have assumed that \(e\) is being inserted
    into the left sub-tree, which means \(e < p\).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Letâ€™s say that \(C\) is of height \(k\). Before insertion, the tree rooted at
    \(q\) must have had height \(k+1\) (or else one insertion cannot create imbalance).
    In turn, this means \(A\) must have had height \(k\) or \(k-1\), and likewise
    for \(B\).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that after insertion, the tree rooted at \(q\) has height \(k+2\). Thus,
    either \(A\) or \(B\) has height \(k+1\) and the other must have height less than
    that (either \(k\) or \(k-1\)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why can they both not have height \(k+1\) after insertion?
  id: totrans-93
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This gives us two cases to consider.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 18.2.3.1Â Left-Left Case[ğŸ”—](#(part._.Left-.Left_.Case) "Link to here")
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Letâ€™s say the imbalance is in \(A\), i.e., it has height \(k+1\). Letâ€™s expand
    that tree:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '| Â Â Â Â Â Â p |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â / \ |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â qÂ Â Â C |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â / \ |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| Â Â rÂ Â Â B |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| Â / \ |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| A1Â Â A2 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: We know the following about the data in the sub-trees. Weâ€™ll use the notation
    \(T < a\) where \(T\) is a tree and \(a\) is a single value to mean every value
    in \(T\) is less than \(a\).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: \(A_1 < r\).
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(r < A_2 < q\).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(q < B < p\).
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(p < C\).
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Letâ€™s also remind ourselves of the sizes:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The height of \(A_1\) or of \(A_2\) is \(k\) (the cause of imbalance).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The height of the other \(A_i\) is \(k-1\) (see the exercise above).
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The height of \(C\) is \(k\) (initial assumption; \(k\) is arbitrary).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The height of \(B\) must be \(k-1\) or \(k\) (argued above).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Imagine this tree is a mobile, which has gotten a little skewed to the left.
    You would naturally think to suspend the mobile a little further to the left to
    bring it back into balance. That is effectively what we will do:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '| Â Â Â Â Â q |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â / \ |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| Â Â rÂ Â Â Â Â p |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| Â / \Â Â Â / \ |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| A1Â Â A2 BÂ Â C |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: Observe that this preserves each of the ordering properties above. In addition,
    the \(A\) subtree has been brought one level closer to the root than earlier relative
    to \(B\) and \(C\). This restores the balance (as you can see if you work out
    the heights of each of \(A_i\), \(B\), and \(C\)). Thus, we have also restored
    balance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 18.2.3.2Â Left-Right Case[ğŸ”—](#(part._.Left-.Right_.Case) "Link to here")
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The imbalance might instead be in \(B\). Expanding:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '| Â Â Â Â p |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â / \ |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| Â Â qÂ Â Â C |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| Â / \ |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| AÂ Â Â r |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â / \ |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| Â Â B1Â Â B2 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: 'Again, letâ€™s record what we know about data order:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: \(A < q\).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(q < B_1 < r\).
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(r < B_2 < p\).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(p < C\).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'and sizes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the height of \(C\) is \(k\).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The height of \(A\) must be \(k-1\) or \(k\).
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The height of \(B_1\) or \(B_2\) must be \(k\), but not both (see the exercise
    above). The other must be \(k-1\).
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We therefore have to somehow bring \(B_1\) and \(B_2\) one level closer to
    the root of the tree. By using the above data ordering knowledge, we can construct
    this tree:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä»¥æŸç§æ–¹å¼å°† \(B_1\) å’Œ \(B_2\) å‘æ ‘æ ¹é è¿‘ä¸€ä¸ªå±‚çº§ã€‚é€šè¿‡ä½¿ç”¨ä¸Šè¿°æ•°æ®æ’åºçŸ¥è¯†ï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºè¿™ä¸ªæ ‘ï¼š
- en: '| Â Â Â Â Â Â p |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â Â Â p |'
- en: '| Â Â Â Â Â / \ |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â Â / \ |'
- en: '| Â Â Â Â rÂ Â Â C |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â rÂ Â Â C |'
- en: '| Â Â Â / \ |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â / \ |'
- en: '| Â Â qÂ Â Â B2 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| Â Â qÂ Â Â B2 |'
- en: '| Â / \ |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| Â / \ |'
- en: '| AÂ Â Â B1 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| AÂ Â Â B1 |'
- en: 'Of course, if \(B_1\) is the problematic sub-tree, this still does not address
    the problem. However, we are now back to the previous (left-left) case; rotating
    gets us to:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œå¦‚æœ \(B_1\) æ˜¯æœ‰é—®é¢˜çš„å­æ ‘ï¼Œè¿™ä»ç„¶æ²¡æœ‰è§£å†³é—®é¢˜ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ç°åœ¨å›åˆ°äº†ä¹‹å‰çš„ï¼ˆå·¦å·¦ï¼‰æƒ…å†µï¼›æ—‹è½¬ä½¿æˆ‘ä»¬åˆ°è¾¾ï¼š
- en: '| Â Â Â Â Â Â r |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â Â Â r |'
- en: '| Â Â Â /Â Â Â Â \ |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â /Â Â Â Â \ |'
- en: '| Â Â qÂ Â Â Â Â Â p |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| Â Â qÂ Â Â Â Â Â p |'
- en: '| Â / \Â Â Â Â / \ |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| Â / \Â Â Â Â / \ |'
- en: '| AÂ Â Â B1 B2Â Â C |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| AÂ Â Â B1 B2Â Â C |'
- en: Now observe that we have precisely maintained the data ordering constraints.
    Furthermore, from the root, \(A\)â€™s lowest node is at height \(k+1\) or \(k+2\);
    so is \(B_1\)â€™s; so is \(B_2\)â€™s; and \(C\)â€™s is at \(k+2\).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è§‚å¯Ÿä¸€ä¸‹ï¼Œæˆ‘ä»¬æ°å¥½ä¿æŒäº†æ•°æ®æ’åºçº¦æŸã€‚æ­¤å¤–ï¼Œä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œ\(A\) çš„æœ€ä½èŠ‚ç‚¹åœ¨é«˜åº¦ \(k+1\) æˆ– \(k+2\)ï¼›\(B_1\) çš„ä¹Ÿæ˜¯ï¼›\(B_2\)
    çš„ä¹Ÿæ˜¯ï¼›\(C\) çš„ä¹Ÿæ˜¯ \(k+2\)ã€‚
- en: 18.2.3.3Â Any Other Cases?[ğŸ”—](#(part._.Any_.Other_.Cases_) "Link to here")
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 18.2.3.3 å…¶ä»–æƒ…å†µï¼Ÿ[ğŸ”—](#(part._.Any_.Other_.Cases_) "é“¾æ¥è‡³æ­¤")
- en: Were we a little too glib before? In the left-right case we said that only one
    of \(B_1\) or \(B_2\) could be of height \(k\) (after insertion); the other had
    to be of height \(k-1\). Actually, all we can say for sure is that the other has
    to be at most height \(k-2\).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹‹å‰æ˜¯ä¸æ˜¯æœ‰ç‚¹è¿‡äºè½»ç‡äº†ï¼Ÿåœ¨å·¦å³æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬è¯´ \(B_1\) æˆ– \(B_2\) ä¸­åªæœ‰ä¸€ä¸ªå¯ä»¥æ˜¯é«˜åº¦ \(k\)ï¼ˆåœ¨æ’å…¥åï¼‰ï¼›å¦ä¸€ä¸ªå¿…é¡»æ˜¯é«˜åº¦
    \(k-1\)ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬æ‰€èƒ½è‚¯å®šçš„æ˜¯ï¼Œå¦ä¸€ä¸ªæœ€å¤šåªèƒ½æ˜¯é«˜åº¦ \(k-2\)ã€‚
- en: Exercise
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can the height of the other tree actually be \(k-2\) instead of \(k-1\)?
  id: totrans-158
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦ä¸€æ£µæ ‘çš„é«˜åº¦å®é™…ä¸Šå¯ä»¥æ˜¯ \(k-2\) è€Œä¸æ˜¯ \(k-1\) å—ï¼Ÿ
- en: ''
  id: totrans-159
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-160
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: If so, does the solution above hold? Is there not still an imbalance of two
    in the resulting tree?
  id: totrans-161
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæ˜¯è¿™æ ·ï¼Œä¸Šé¢çš„è§£å†³æ–¹æ¡ˆä»ç„¶æˆç«‹å—ï¼Ÿç»“æœæ ‘ä¸­ä¸æ˜¯ä»ç„¶å­˜åœ¨ä¸¤ä¸ªä¸å¹³è¡¡å—ï¼Ÿ
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-163
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Is there actually a bug in the above algorithm?
  id: totrans-164
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸Šé¢çš„ç®—æ³•ä¸­å®é™…ä¸Šæœ‰é”™è¯¯å—ï¼Ÿ
- en: 18.2.1Â Using Binary Trees[ğŸ”—](#(part._.Using_.Binary_.Trees) "Link to here")
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.2.1 ä½¿ç”¨äºŒå‰æ ‘[ğŸ”—](#(part._.Using_.Binary_.Trees) "é“¾æ¥è‡³æ­¤")
- en: Because logs come from trees.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºå¯¹æ•°æ¥è‡ªæ ‘ã€‚
- en: 'Clearly, a list representation does not let us eliminate half the elements
    with a constant amount of work; instead, we need a tree. Thus we define a binary
    tree of (for simplicity) numbers:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¾ç„¶ï¼Œåˆ—è¡¨è¡¨ç¤ºæ³•ä¸èƒ½è®©æˆ‘ä»¬é€šè¿‡æ’å®šçš„å·¥ä½œé‡æ¶ˆé™¤ä¸€åŠçš„å…ƒç´ ï¼›ç›¸åï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ ‘ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªï¼ˆä¸ºäº†ç®€å•èµ·è§ï¼‰æ•°å­—çš„äºŒå‰æ ‘ï¼š
- en: '[PRE9]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Given this definition, letâ€™s define the membership checker:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¹æ®è¿™ä¸ªå®šä¹‰ï¼Œè®©æˆ‘ä»¬å®šä¹‰æˆå‘˜æ£€æŸ¥å™¨ï¼š
- en: '[PRE10]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Oh, wait. If the element weâ€™re looking for isnâ€™t the root, what do we do? It
    could be in the left child or it could be in the right; we wonâ€™t know for sure
    until weâ€™ve examined both. Thus, we canâ€™t throw away half the elements; the only
    one we can dispose of is the value at the root. Furthermore, this property holds
    at every level of the tree. Thus, membership checking needs to examine the entire
    tree, and we still have complexity linear in the size of the set.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: å“¦ï¼Œç­‰ç­‰ã€‚å¦‚æœæˆ‘ä»¬æ­£åœ¨å¯»æ‰¾çš„å…ƒç´ ä¸æ˜¯æ ¹èŠ‚ç‚¹ï¼Œæˆ‘ä»¬è¯¥æ€ä¹ˆåŠï¼Ÿå®ƒå¯èƒ½åœ¨å·¦å­èŠ‚ç‚¹æˆ–å³å­èŠ‚ç‚¹ï¼›æˆ‘ä»¬åªæœ‰åœ¨æ£€æŸ¥äº†ä¸¤ä¸ªå­èŠ‚ç‚¹ä¹‹åæ‰èƒ½ç¡®å®šã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¸èƒ½ä¸¢å¼ƒä¸€åŠçš„å…ƒç´ ï¼›æˆ‘ä»¬å”¯ä¸€å¯ä»¥ä¸¢å¼ƒçš„æ˜¯æ ¹èŠ‚ç‚¹çš„å€¼ã€‚æ­¤å¤–ï¼Œè¿™ä¸ªå±æ€§åœ¨æ ‘çš„æ¯ä¸€å±‚éƒ½æˆç«‹ã€‚å› æ­¤ï¼Œæˆå‘˜æ£€æŸ¥éœ€è¦æ£€æŸ¥æ•´ä¸ªæ ‘ï¼Œæˆ‘ä»¬ä»ç„¶æœ‰ä¸é›†åˆå¤§å°æˆçº¿æ€§å¤æ‚åº¦çš„å¤æ‚åº¦ã€‚
- en: How can we improve on this? The comparison needs to help us eliminate not only
    the root but also one whole sub-tree. We can only do this if the comparison â€œspeaks
    forâ€ an entire sub-tree. It can do so if all elements in one sub-tree are less
    than or equal to the root value, and all elements in the other sub-tree are greater
    than or equal to it. Of course, we have to be consistent about which side contains
    which subset; it is conventional to put the smaller elements to the left and the
    bigger ones to the right. This refines our binary tree definition to give us a
    binary search tree (BST).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•æ”¹è¿›è¿™ä¸€ç‚¹ï¼Ÿæ¯”è¾ƒéœ€è¦å¸®åŠ©æˆ‘ä»¬æ¶ˆé™¤çš„ä¸ä»…ä»…æ˜¯æ ¹èŠ‚ç‚¹ï¼Œè¿˜è¦æ¶ˆé™¤æ•´ä¸ªå­æ ‘ã€‚æˆ‘ä»¬åªèƒ½è¿™æ ·åšï¼Œå¦‚æœæ¯”è¾ƒâ€œä»£è¡¨â€æ•´ä¸ªå­æ ‘ã€‚å¦‚æœå­æ ‘ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½å°äºæˆ–ç­‰äºæ ¹å€¼ï¼Œè€Œå¦ä¸€ä¸ªå­æ ‘ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½å¤§äºæˆ–ç­‰äºå®ƒï¼Œé‚£ä¹ˆå®ƒå¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬å¿…é¡»ä¸€è‡´åœ°ç¡®å®šå“ªä¸€ä¾§åŒ…å«å“ªä¸ªå­é›†ï¼›æƒ¯ä¾‹æ˜¯å°†è¾ƒå°çš„å…ƒç´ æ”¾åœ¨å·¦è¾¹ï¼Œè¾ƒå¤§çš„å…ƒç´ æ”¾åœ¨å³è¾¹ã€‚è¿™ä½¿æˆ‘ä»¬çš„äºŒå‰æ ‘å®šä¹‰æ›´åŠ ç²¾ç¡®ï¼Œä»è€Œå¾—åˆ°äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰ã€‚
- en: Do Now!
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here is a candiate predicate for recognizing when a binary tree is in fact
    a binary search tree:'
  id: totrans-175
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªå€™é€‰è°“è¯ï¼Œç”¨äºè¯†åˆ«ä½•æ—¶ä¸€ä¸ªäºŒå‰æ ‘å®é™…ä¸Šæ˜¯ä¸€ä¸ªäºŒå‰æœç´¢æ ‘ï¼š
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-177
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is this definition correct?
  id: totrans-179
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå®šä¹‰æ­£ç¡®å—ï¼Ÿ
- en: 'Itâ€™s not. To actually throw away half the tree, we need to be sure that everything
    in the left sub-tree is less than the value in the root and similarly, everything
    in the right sub-tree is greater than the root.We have used `<=` instead of `<`
    above because even though we donâ€™t want to permit duplicates when representing
    sets, in other cases we might not want to be so stringent; this way we can reuse
    the above implementation for other purposes. But the definition above performs
    only a â€œshallowâ€ comparison. Thus we could have a root a with a right child, b,
    such that b > a; and the b node could have a left child c such that c < b; but
    this does not guarantee that c > a. In fact, it is easy to construct a counter-example
    that passes this check:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸æ˜¯ã€‚è¦çœŸæ­£ä¸¢å¼ƒä¸€åŠçš„æ ‘ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿å·¦å­æ ‘ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½å°äºæ ¹èŠ‚ç‚¹çš„å€¼ï¼ŒåŒæ ·ï¼Œå³å­æ ‘ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½å¤§äºæ ¹èŠ‚ç‚¹ã€‚æˆ‘ä»¬ä¸Šé¢ä½¿ç”¨äº†`<=`è€Œä¸æ˜¯`<`ï¼Œå› ä¸ºå°½ç®¡æˆ‘ä»¬ä¸å¸Œæœ›åœ¨è¡¨ç¤ºé›†åˆæ—¶å…è®¸é‡å¤ï¼Œä½†åœ¨å…¶ä»–æƒ…å†µä¸‹æˆ‘ä»¬å¯èƒ½ä¸æƒ³å¦‚æ­¤ä¸¥æ ¼ï¼›è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ä¸ºå…¶ä»–ç›®çš„é‡ç”¨ä¸Šé¢çš„å®ç°ã€‚ä½†ä¸Šé¢çš„å®šä¹‰åªæ‰§è¡Œäº†â€œæµ…å±‚â€æ¯”è¾ƒã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯èƒ½æœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹aï¼Œå…¶å³å­èŠ‚ç‚¹bï¼Œä½¿å¾—b
    > aï¼›å¹¶ä¸”bèŠ‚ç‚¹å¯èƒ½æœ‰ä¸€ä¸ªå·¦å­èŠ‚ç‚¹cï¼Œä½¿å¾—c < bï¼›ä½†è¿™å¹¶ä¸ä¿è¯c > aã€‚äº‹å®ä¸Šï¼Œå¾ˆå®¹æ˜“æ„é€ ä¸€ä¸ªåä¾‹æ¥é€šè¿‡è¿™ä¸ªæ£€æŸ¥ï¼š
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Exercise
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fix the BST checker.
  id: totrans-184
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¿®å¤BSTæ£€æŸ¥å™¨ã€‚
- en: 'With a corrected definition, we can now define a refined version of binary
    trees that are search trees:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®šä¹‰ä¿®æ­£åï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥å®šä¹‰ä¸€ä¸ªæ›´ç²¾ç»†çš„äºŒå‰æœç´¢æ ‘ç‰ˆæœ¬ï¼š
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also remind ourselves that the purpose of this exercise was to define
    sets, and define `TSet`s to be tree sets:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥æé†’è‡ªå·±ï¼Œè¿™ä¸ªç»ƒä¹ çš„ç›®çš„æ˜¯å®šä¹‰é›†åˆï¼Œå¹¶å°†`TSet`å®šä¹‰ä¸ºæ ‘é›†åˆï¼š
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now letâ€™s implement our operations on the BST representation. First weâ€™ll write
    a template:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ¥å®ç°BSTè¡¨ç¤ºä¸Šçš„æ“ä½œã€‚é¦–å…ˆæˆ‘ä»¬å°†ç¼–å†™ä¸€ä¸ªæ¨¡æ¿ï¼š
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Observe that the data definition of a BST gives us rich information about the
    two children: they are each a BST, so we know their elements obey the ordering
    property. We can use this to define the actual operations:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°BSTçš„æ•°æ®å®šä¹‰ä¸ºæˆ‘ä»¬æä¾›äº†å…³äºä¸¤ä¸ªå­èŠ‚ç‚¹çš„ä¸°å¯Œä¿¡æ¯ï¼šå®ƒä»¬å„è‡ªéƒ½æ˜¯ä¸€ä¸ªBSTï¼Œå› æ­¤æˆ‘ä»¬çŸ¥é“å®ƒä»¬çš„å…ƒç´ éµå¾ªæ’åºå±æ€§ã€‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™ä¸€ç‚¹æ¥å®šä¹‰å®é™…çš„æ“ä½œï¼š
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In both functions we are strictly assuming the invariant of the BST, and in
    the latter case also ensuring it. Make sure you identify where, why, and how.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸¤ä¸ªå‡½æ•°ä¸­ï¼Œæˆ‘ä»¬ä¸¥æ ¼å‡è®¾BSTçš„ä¸å˜æ€§è´¨ï¼Œå¹¶åœ¨åä¸€ç§æƒ…å†µä¸‹ç¡®ä¿å®ƒã€‚ç¡®ä¿ä½ ç¡®å®šåœ¨å“ªé‡Œã€ä¸ºä»€ä¹ˆä»¥åŠå¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹ã€‚
- en: You should now be able to define the remaining operations. Of these, `size`
    clearly requires linear time (since it has to count all the elements), but because
    `is-in` and `insert` both throw away one of two children each time they recur,
    they take logarithmic time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ ç°åœ¨åº”è¯¥èƒ½å¤Ÿå®šä¹‰å‰©ä½™çš„æ“ä½œã€‚åœ¨è¿™äº›æ“ä½œä¸­ï¼Œ`size`æ˜¾ç„¶éœ€è¦çº¿æ€§æ—¶é—´ï¼ˆå› ä¸ºå®ƒå¿…é¡»è®¡ç®—æ‰€æœ‰å…ƒç´ ï¼‰ï¼Œä½†ç”±äº`is-in`å’Œ`insert`æ¯æ¬¡é€’å½’éƒ½ä¼šä¸¢å¼ƒä¸¤ä¸ªå­èŠ‚ç‚¹ä¸­çš„ä¸€ä¸ªï¼Œå› æ­¤å®ƒä»¬éœ€è¦å¯¹æ•°æ—¶é—´ã€‚
- en: Exercise
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose we frequently needed to compute the size of a set. We ought to be able
    to reduce the time complexity of `size` by having each tree [â˜› cache](glossary.html#%28elem._glossary-cache%29)
    its size, so that `size` could complete in constant time (note that the size of
    the tree clearly fits the criterion of a cache, since it can always be reconstructed).
    Update the data definition and all affected functions to keep track of this information
    correctly.
  id: totrans-197
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬ç»å¸¸éœ€è¦è®¡ç®—é›†åˆçš„å¤§å°ã€‚æˆ‘ä»¬åº”è¯¥èƒ½å¤Ÿé€šè¿‡è®©æ¯ä¸ªæ ‘[â˜›ç¼“å­˜](glossary.html#%28elem._glossary-cache%29)å…¶å¤§å°æ¥é™ä½`size`çš„æ—¶é—´å¤æ‚åº¦ï¼Œè¿™æ ·`size`å°±å¯ä»¥åœ¨å¸¸æ•°æ—¶é—´å†…å®Œæˆï¼ˆæ³¨æ„ï¼Œæ ‘çš„å¤§å°æ˜¾ç„¶ç¬¦åˆç¼“å­˜çš„å‡†åˆ™ï¼Œå› ä¸ºå®ƒæ€»æ˜¯å¯ä»¥è¢«é‡å»ºï¼‰ã€‚æ›´æ–°æ•°æ®å®šä¹‰å’Œæ‰€æœ‰å—å½±å“çš„å‡½æ•°ï¼Œä»¥æ­£ç¡®è·Ÿè¸ªè¿™äº›ä¿¡æ¯ã€‚
- en: 18.2.2Â Checking the Complexity[ğŸ”—](#(part._.Checking_the_.Complexity) "Link to
    here")
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.2.2 æ£€æŸ¥å¤æ‚åº¦[ğŸ”—](#(part._.Checking_the_.Complexity) "é“¾æ¥è‡³æ­¤")
- en: But wait a minute. Are we actually done? Our recurrence takes the form \(T(k)
    = T(k/2) + c\), but what in our data definition guaranteed that the size of the
    child traversed by `is-in` will be half the size?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†ç­‰ç­‰ã€‚æˆ‘ä»¬çœŸçš„å®Œæˆäº†å—ï¼Ÿæˆ‘ä»¬çš„é€’å½’å½¢å¼ä¸º\(T(k) = T(k/2) + c\)ï¼Œä½†æˆ‘ä»¬çš„æ•°æ®å®šä¹‰ä¸­æœ‰ä»€ä¹ˆä¿è¯äº†é€šè¿‡`is-in`éå†çš„å­èŠ‚ç‚¹çš„å¤§å°å°†æ˜¯å¤§å°çš„ä¸€åŠï¼Ÿ
- en: Do Now!
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Construct an exampleâ€”<wbr>consisting of a sequence of `insert`s to the empty
    treeâ€”<wbr>such that the resulting tree is not balanced. Show that searching for
    certain elements in this tree will take linear, not logarithmic, time in its size.
  id: totrans-202
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ„é€ ä¸€ä¸ªä¾‹å­â€”â€”<wbr>ç”±ä¸€ç³»åˆ—å‘ç©ºæ ‘æ’å…¥æ“ä½œç»„æˆâ€”â€”<wbr>ä½¿å¾—å¾—åˆ°çš„æ ‘æ˜¯ä¸å¹³è¡¡çš„ã€‚è¯æ˜åœ¨è¿™ä¸ªæ ‘ä¸­æœç´¢æŸäº›å…ƒç´ å°†éœ€è¦çº¿æ€§æ—¶é—´ï¼Œè€Œä¸æ˜¯å¯¹æ•°æ—¶é—´ã€‚
- en: Imagine starting with the empty tree and inserting the values `1`, `2`, `3`,
    and `4`, in order. The resulting tree would be
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡ä¸€ä¸‹ä»ç©ºæ ‘å¼€å§‹ï¼Œå¹¶æŒ‰é¡ºåºæ’å…¥å€¼`1`ã€`2`ã€`3`å’Œ`4`ã€‚å¾—åˆ°çš„æ ‘å°†æ˜¯
- en: '[PRE17]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Searching for `4` in this tree would have to examine all the set elements in
    the tree. In other words, this binary search tree is degenerateâ€”<wbr>it is effectively
    a list, and we are back to having the same complexity we had earlier.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™æ£µæ ‘ä¸­æœç´¢`4`å¿…é¡»æ£€æŸ¥æ ‘ä¸­çš„æ‰€æœ‰é›†åˆå…ƒç´ ã€‚æ¢å¥è¯è¯´ï¼Œè¿™ä¸ªäºŒå‰æœç´¢æ ‘æ˜¯é€€åŒ–çš„â€”â€”<wbr>å®ƒå®é™…ä¸Šæ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œæˆ‘ä»¬å›åˆ°äº†ä¹‹å‰ç›¸åŒçš„å¤æ‚åº¦ã€‚
- en: 'Therefore, using a binary tree, and even a BST, does not guarantee the complexity
    we want: it does only if our inputs have arrived in just the right order. However,
    we cannot assume any input ordering; instead, we would like an implementation
    that works in all cases. Thus, we must find a way to ensure that the tree is always
    balanced, so each recursive call in `is-in` really does throw away half the elements.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œä½¿ç”¨äºŒå‰æ ‘ï¼Œç”šè‡³æ˜¯BSTï¼Œå¹¶ä¸èƒ½ä¿è¯æˆ‘ä»¬æƒ³è¦çš„å¤æ‚åº¦ï¼šåªæœ‰åœ¨æˆ‘ä»¬çš„è¾“å…¥æ°å¥½ä»¥æ­£ç¡®çš„é¡ºåºåˆ°è¾¾æ—¶æ‰èƒ½ä¿è¯ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ä¸èƒ½å‡è®¾ä»»ä½•è¾“å…¥é¡ºåºï¼›ç›¸åï¼Œæˆ‘ä»¬å¸Œæœ›æœ‰ä¸€ä¸ªåœ¨æ‰€æœ‰æƒ…å†µä¸‹éƒ½èƒ½å·¥ä½œçš„å®ç°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¿…é¡»æ‰¾åˆ°ä¸€ç§ç¡®ä¿æ ‘å§‹ç»ˆå¹³è¡¡çš„æ–¹æ³•ï¼Œè¿™æ ·`is-in`ä¸­çš„æ¯ä¸ªé€’å½’è°ƒç”¨æ‰èƒ½çœŸæ­£ä¸¢å¼ƒä¸€åŠçš„å…ƒç´ ã€‚
- en: Exercise
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that we have not talked about computing the size of the set. Even if
    we could assume that the binary tree is balanced, how do we determine the size
    in logarithmic-or-better time?
  id: totrans-209
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰è®¨è®ºè®¡ç®—é›†åˆå¤§å°çš„é—®é¢˜ã€‚å³ä½¿æˆ‘ä»¬å¯ä»¥å‡è®¾äºŒå‰æ ‘æ˜¯å¹³è¡¡çš„ï¼Œæˆ‘ä»¬å¦‚ä½•ä»¥å¯¹æ•°æˆ–æ›´å¥½çš„æ—¶é—´ç¡®å®šå¤§å°ï¼Ÿ
- en: '18.2.3Â A Fine Balance: Tree Surgery[ğŸ”—](#(part._sets-from-balanced-trees) "Link
    to here")'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.2.3Â è‰¯å¥½çš„å¹³è¡¡ï¼šæ ‘æ‰‹æœ¯[ğŸ”—](#(part._sets-from-balanced-trees) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Letâ€™s define a balanced binary search tree (BBST). It must obviously be a search
    tree, so letâ€™s focus on the â€œbalancedâ€ part. We have to be careful about precisely
    what this means: we canâ€™t simply expect both sides to be of equal size because
    this demands that the tree (and hence the set) have an even number of elements
    and, even more stringently, to have a size that is a power of two.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼ˆBBSTï¼‰ã€‚æ˜¾ç„¶ï¼Œå®ƒå¿…é¡»æ˜¯ä¸€ä¸ªæœç´¢æ ‘ï¼Œæ‰€ä»¥è®©æˆ‘ä»¬å…³æ³¨â€œå¹³è¡¡â€çš„éƒ¨åˆ†ã€‚æˆ‘ä»¬å¿…é¡»å°å¿ƒåœ°ç†è§£è¿™ç©¶ç«Ÿæ„å‘³ç€ä»€ä¹ˆï¼šæˆ‘ä»¬ä¸èƒ½ç®€å•åœ°æœŸæœ›ä¸¤è¾¹çš„å¤§å°ç›¸ç­‰ï¼Œå› ä¸ºè¿™è¦æ±‚æ ‘ï¼ˆä»¥åŠé›†åˆï¼‰æœ‰å¶æ•°ä¸ªå…ƒç´ ï¼Œç”šè‡³æ›´ä¸¥æ ¼çš„æ˜¯ï¼Œå¤§å°å¿…é¡»æ˜¯2çš„å¹‚ã€‚
- en: Exercise
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define a predicate for a BBST that consumes a `BT` and returns a `Boolean` indicating
    whether or not it a balanced search tree.
  id: totrans-214
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®šä¹‰ä¸€ä¸ªé’ˆå¯¹BBSTçš„è°“è¯ï¼Œå®ƒæ¶ˆè€—ä¸€ä¸ª`BT`å¹¶è¿”å›ä¸€ä¸ª`Boolean`å€¼ï¼ŒæŒ‡ç¤ºå®ƒæ˜¯å¦æ˜¯ä¸€ä¸ªå¹³è¡¡æœç´¢æ ‘ã€‚
- en: 'Therefore, we relax the notion of balance to one that is both accommodating
    and sufficient. We use the term balance factor for a node to refer to the height
    of its left child minus the height of its right child (where the height is the
    depth, in edges, of the deepest node). We allow every node of a BBST to have a
    balance factor of \(-1\), \(0\), or \(1\) (but nothing else): that is, either
    both have the same height, or the left or the right can be one taller. Note that
    this is a recursive property, but it applies at all levels, so the imbalance cannot
    accumulate making the whole tree arbitrarily imbalanced.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬å°†å¹³è¡¡çš„æ¦‚å¿µæ”¾å®½ï¼Œä½¿å…¶æ—¢åŒ…å®¹åˆå……åˆ†ã€‚æˆ‘ä»¬ä½¿ç”¨â€œå¹³è¡¡å› å­â€è¿™ä¸ªæœ¯è¯­æ¥æŒ‡ä»£ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å­æ ‘é«˜åº¦å‡å»å…¶å³å­æ ‘é«˜åº¦ï¼ˆé«˜åº¦æ˜¯æŒ‡æœ€æ·±å±‚èŠ‚ç‚¹åœ¨è¾¹ä¸Šçš„æ·±åº¦ï¼‰ã€‚æˆ‘ä»¬å…è®¸BBSTçš„æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªå¹³è¡¡å› å­ä¸º\(-1\)ã€\(0\)æˆ–\(1\)ï¼ˆä½†ä¸èƒ½æ˜¯å…¶ä»–å€¼ï¼‰ï¼šä¹Ÿå°±æ˜¯è¯´ï¼Œè¦ä¹ˆä¸¤è€…é«˜åº¦ç›¸åŒï¼Œè¦ä¹ˆå·¦å­æ ‘æˆ–å³å­æ ‘é«˜å‡ºä¸€ä¸ªå•ä½ã€‚è¯·æ³¨æ„ï¼Œè¿™æ˜¯ä¸€ä¸ªé€’å½’å±æ€§ï¼Œä½†å®ƒé€‚ç”¨äºæ‰€æœ‰çº§åˆ«ï¼Œå› æ­¤ä¸å¹³è¡¡ä¸ä¼šç´¯ç§¯ï¼Œä½¿å¾—æ•´ä¸ªæ ‘å˜å¾—ä»»æ„ä¸å¹³è¡¡ã€‚
- en: Exercise
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given this definition of a BBST, show that the number of nodes is exponential
    in the height. Thus, always recurring on one branch will terminate after a logarithmic
    (in the number of nodes) number of steps.
  id: totrans-218
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»™å®šBBSTçš„å®šä¹‰ï¼Œè¯æ˜èŠ‚ç‚¹æ•°æ˜¯æŒ‡æ•°çº§çš„ã€‚å› æ­¤ï¼Œæ€»æ˜¯é€’å½’åœ¨ä¸€æ¡åˆ†æ”¯ä¸Šå°†ä¼šåœ¨ç»è¿‡å¯¹æ•°ï¼ˆä»¥èŠ‚ç‚¹æ•°ä¸ºåº•ï¼‰çš„æ­¥éª¤æ•°åç»ˆæ­¢ã€‚
- en: 'Here is an obvious but useful observation: every BBST is also a BST (this was
    true by the very definition of a BBST). Why does this matter? It means that a
    function that operates on a BST can just as well be applied to a BBST without
    any loss of correctness.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªæ˜æ˜¾ä½†æœ‰ç”¨çš„è§‚å¯Ÿï¼šæ¯ä¸ªäºŒå‰å¹³è¡¡æœç´¢æ ‘ï¼ˆBBSTï¼‰ä¹Ÿéƒ½æ˜¯ä¸€ä¸ªäºŒå‰æœç´¢æ ‘ï¼ˆBBSTçš„å®šä¹‰æœ¬èº«å°±ä¿è¯äº†è¿™ä¸€ç‚¹ï¼‰ã€‚è¿™æœ‰ä»€ä¹ˆå…³ç³»å‘¢ï¼Ÿè¿™æ„å‘³ç€ï¼Œå¯¹BSTæ“ä½œçš„åŠŸèƒ½åŒæ ·å¯ä»¥åº”ç”¨äºBBSTï¼Œè€Œä¸ä¼šä¸¢å¤±æ­£ç¡®æ€§ã€‚
- en: So far, so easy. All that leaves is a means of creating a BBST, because itâ€™s
    responsible for ensuring balance. Itâ€™s easy to see that the constant `empty-set`
    is a BBST value. So that leaves only `insert`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œä¸€åˆ‡éƒ½å¾ˆç®€å•ã€‚å‰©ä¸‹çš„åªæ˜¯ä¸€ä¸ªåˆ›å»ºBBSTçš„æ–¹æ³•ï¼Œå› ä¸ºå®ƒæ˜¯è´Ÿè´£ç¡®ä¿å¹³è¡¡çš„ã€‚å¾ˆå®¹æ˜“çœ‹å‡ºå¸¸é‡`empty-set`æ˜¯ä¸€ä¸ªBBSTå€¼ã€‚æ‰€ä»¥åªå‰©ä¸‹`insert`æ“ä½œã€‚
- en: Here is our situation with `insert`. Assuming we start with a BBST, we can determine
    in logarithmic time whether the element is already in the tree and, if so, ignore
    it.To implement a bag we count how many of each element are in it, which does
    not affect the treeâ€™s height. When inserting an element, given balanced trees,
    the `insert` for a BST takes only a logarithmic amount of time to perform the
    insertion. Thus, if performing the insertion does not affect the treeâ€™s balance,
    weâ€™re done. Therefore, we only need to consider cases where performing the insertion
    throws off the balance.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯æˆ‘ä»¬çš„ `insert` æƒ…å†µã€‚å‡è®¾æˆ‘ä»¬ä»ä¸€ä¸ª BBST å¼€å§‹ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥å¯¹æ•°æ—¶é—´ç¡®å®šå…ƒç´ æ˜¯å¦å·²ç»åœ¨æ ‘ä¸­ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å¿½ç•¥å®ƒã€‚ä¸ºäº†å®ç°ä¸€ä¸ªåŒ…ï¼Œæˆ‘ä»¬è®¡ç®—å…¶ä¸­æ¯ç§å…ƒç´ çš„æ•°é‡ï¼Œè¿™ä¸ä¼šå½±å“æ ‘çš„é«˜åº¦ã€‚å½“æ’å…¥ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œç»™å®šå¹³è¡¡çš„æ ‘ï¼ŒBST
    çš„ `insert` åªéœ€è¦ä»¥å¯¹æ•°æ—¶é—´å®Œæˆæ’å…¥ã€‚å› æ­¤ï¼Œå¦‚æœæ’å…¥æ“ä½œä¸ä¼šå½±å“æ ‘çš„å¹³è¡¡ï¼Œæˆ‘ä»¬å°±å®Œæˆäº†ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åªéœ€è¦è€ƒè™‘é‚£äº›æ‰§è¡Œæ’å…¥æ“ä½œä¼šç ´åå¹³è¡¡çš„æƒ…å†µã€‚
- en: 'Observe that because \(<\) and \(>\) are symmetric (likewise with \(<=\) and
    \(>=\)), we can consider insertions into one half of the tree and a symmetric
    argument handles insertions into the other half. Thus, suppose we have a tree
    that is currently balanced into which we are inserting the element \(e\). Letâ€™s
    say \(e\) is going into the left sub-tree and, by virtue of being inserted, will
    cause the entire tree to become imbalanced.Some trees, like family trees ([Data
    Design Problem â€“ Ancestry Data](trees.html#%28part._ancestor-trees%29)) represent
    real-world data. It makes no sense to â€œbalanceâ€ a family tree: it must accurately
    model whatever reality it represents. These set-representing trees, in contrast,
    are chosen by us, not dictated by some external reality, so we are free to rearrange
    them.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°å› ä¸º `<` å’Œ `>` æ˜¯å¯¹ç§°çš„ï¼ˆåŒæ ·é€‚ç”¨äº `<=` å’Œ `>=`ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘å°†å…ƒç´ æ’å…¥æ ‘çš„ä¸€åŠï¼Œç„¶åé€šè¿‡å¯¹ç§°çš„è®ºè¯æ¥å¤„ç†å¦ä¸€åŠçš„æ’å…¥ã€‚å› æ­¤ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªå½“å‰å·²ç»å¹³è¡¡çš„æ ‘ï¼Œæˆ‘ä»¬å°†å…ƒç´ 
    `e` æ’å…¥å…¶ä¸­ã€‚å‡è®¾ `e` å°†è¿›å…¥å·¦å­æ ‘ï¼Œå¹¶ä¸”ç”±äºæ’å…¥ï¼Œæ•´ä¸ªæ ‘å°†å˜å¾—ä¸å¹³è¡¡ã€‚æœ‰äº›æ ‘ï¼Œå¦‚å®¶è°±æ ‘ï¼ˆ[æ•°æ®è®¾è®¡é—®é¢˜ â€“ å®¶è°±æ•°æ®](trees.html#%28part._ancestor-trees%29)ï¼‰ä»£è¡¨ç°å®ä¸–ç•Œçš„æ•°æ®ã€‚å¯¹å®¶è°±æ ‘è¿›è¡Œâ€œå¹³è¡¡â€æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼šå®ƒå¿…é¡»å‡†ç¡®æ¨¡æ‹Ÿå®ƒæ‰€ä»£è¡¨çš„ç°å®ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œè¿™äº›è¡¨ç¤ºé›†åˆçš„æ ‘æ˜¯æˆ‘ä»¬é€‰æ‹©çš„ï¼Œè€Œä¸æ˜¯ç”±å¤–éƒ¨ç°å®å†³å®šçš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥è‡ªç”±åœ°é‡æ–°æ’åˆ—å®ƒä»¬ã€‚
- en: There are two ways to proceed. One is to consider all the places where we might
    insert \(e\) in a way that causes an imbalance and determine what to do in each
    case.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥ç»§ç»­ã€‚ä¸€ç§æ˜¯æˆ‘ä»¬è€ƒè™‘æ‰€æœ‰å¯èƒ½å¯¼è‡´ `e` æ’å…¥å¹¶å¼•èµ·ä¸å¹³è¡¡çš„åœ°æ–¹ï¼Œå¹¶ç¡®å®šæ¯ç§æƒ…å†µä¸‹çš„å¤„ç†æ–¹æ³•ã€‚
- en: Exercise
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Enumerate all the cases where insertion might be problematic, and dictate what
    to do in each case.
  id: totrans-226
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åˆ—ä¸¾æ‰€æœ‰å¯èƒ½å¯¼è‡´é—®é¢˜çš„æ’å…¥æƒ…å†µï¼Œå¹¶è§„å®šæ¯ç§æƒ…å†µä¸‹çš„å¤„ç†æ–¹æ³•ã€‚
- en: 'The number of cases is actually quite overwhelming (if you didnâ€™t think so,
    you missed a few...). Therefore, we instead attack the problem after it has occurred:
    allow the existing BST `insert` to insert the element, assume that we have an
    imbalanced tree, and show how to restore its balance.The insight that a tree can
    be made â€œself-balancingâ€ is quite remarkable, and there are now many solutions
    to this problem. This particular one, one of the oldest, is due to G.M. Adelson-Velskii
    and E.M. Landis. In honor of their initials it is called an AVL Tree, though the
    tree itself is quite evident; their genius is in defining re-balancing.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼Œæƒ…å†µçš„æ•°é‡ç›¸å½“å¤šï¼ˆå¦‚æœä½ æ²¡æœ‰è¿™æ ·è®¤ä¸ºï¼Œä½ å¯èƒ½é—æ¼äº†ä¸€äº›...ï¼‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è€Œæ˜¯åœ¨é—®é¢˜å‘ç”Ÿåæ‰è§£å†³è¿™ä¸ªé—®é¢˜ï¼šå…è®¸ç°æœ‰çš„ BST `insert`
    æ’å…¥å…ƒç´ ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªä¸å¹³è¡¡çš„æ ‘ï¼Œå¹¶å±•ç¤ºå¦‚ä½•æ¢å¤å…¶å¹³è¡¡ã€‚ä¸€ä¸ªæ ‘å¯ä»¥è¢«åˆ¶æˆâ€œè‡ªå¹³è¡¡â€çš„æ´å¯ŸåŠ›ç›¸å½“æ˜¾è‘—ï¼Œç°åœ¨æœ‰è®¸å¤šè§£å†³æ–¹æ¡ˆæ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚è¿™ä¸ªç‰¹å®šçš„è§£å†³æ–¹æ¡ˆï¼Œæœ€å¤è€çš„ä¹‹ä¸€ï¼Œå½’åŠŸäº
    G.M. Adelson-Velskii å’Œ E.M. Landisã€‚ä¸ºäº†çºªå¿µä»–ä»¬çš„é¦–å­—æ¯ç¼©å†™ï¼Œå®ƒè¢«ç§°ä¸º AVL æ ‘ï¼Œå°½ç®¡æ ‘æœ¬èº«ç›¸å½“æ˜æ˜¾ï¼›ä»–ä»¬çš„å¤©æ‰åœ¨äºå®šä¹‰é‡æ–°å¹³è¡¡ã€‚
- en: 'Thus, in what follows, we begin with a tree that is balanced; `insert` causes
    it to become imbalanced; we have assumed that the insertion happened in the left
    sub-tree. In particular, suppose a (sub-)tree has a balance factor of \(2\) (positive
    because weâ€™re assuming the left is imbalanced by insertion). The procedure for
    restoring balance depends critically on the following property:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œåœ¨æ¥ä¸‹æ¥çš„å†…å®¹ä¸­ï¼Œæˆ‘ä»¬ä»ä¸€ä¸ªå¹³è¡¡çš„æ ‘å¼€å§‹ï¼›`insert` ä½¿å…¶å˜å¾—ä¸å¹³è¡¡ï¼›æˆ‘ä»¬å‡è®¾æ’å…¥å‘ç”Ÿåœ¨å·¦å­æ ‘ä¸­ã€‚ç‰¹åˆ«æ˜¯ï¼Œå‡è®¾ä¸€ä¸ªï¼ˆå­ï¼‰æ ‘çš„å¹³è¡¡å› å­ä¸º `2`ï¼ˆç”±äºæˆ‘ä»¬å‡è®¾å·¦å­æ ‘ç”±äºæ’å…¥è€Œä¸å¹³è¡¡ï¼Œæ‰€ä»¥æ˜¯æ­£çš„ï¼‰ã€‚æ¢å¤å¹³è¡¡çš„ç¨‹åºå…³é”®å–å†³äºä»¥ä¸‹å±æ€§ï¼š
- en: Exercise
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that if a tree is currently balanced, i.e., the balance factor at every
    node is \(-1\), \(0\), or \(1\), then `insert` can at worst make the balance factor
    \(\pm 2\).
  id: totrans-231
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¯æ˜å¦‚æœæ ‘å½“å‰æ˜¯å¹³è¡¡çš„ï¼Œå³æ¯ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­æ˜¯ `-1`ã€`0` æˆ– `1`ï¼Œé‚£ä¹ˆ `insert` æœ€å¤šå¯ä»¥ä½¿å¹³è¡¡å› å­å˜ä¸º `Â±2`ã€‚
- en: The algorithm that follows is applied as `insert` returns from its recursion,
    i.e., on the path from the inserted value back to the root. Since this path is
    of logarithmic length in the setâ€™s size (due to the balancing property), and (as
    we shall see) performs only a constant amount of work at each step, it ensures
    that insertion also takes only logarithmic time, thus completing our challenge.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹ç®—æ³•åœ¨ `insert` ä»å…¶é€’å½’è¿”å›æ—¶åº”ç”¨ï¼Œå³ä»æ’å…¥å€¼è¿”å›æ ¹çš„è·¯å¾„ä¸Šã€‚ç”±äºè¿™ä¸ªè·¯å¾„åœ¨é›†åˆå¤§å°ä¸­æ˜¯å¯¹æ•°é•¿åº¦ï¼ˆç”±äºå¹³è¡¡å±æ€§ï¼‰ï¼Œå¹¶ä¸”ï¼ˆæ­£å¦‚æˆ‘ä»¬å°†çœ‹åˆ°çš„ï¼‰åœ¨æ¯ä¸€æ­¥åªæ‰§è¡Œå¸¸æ•°é‡çš„å·¥ä½œï¼Œå› æ­¤å®ƒç¡®ä¿æ’å…¥ä¹ŸåªèŠ±è´¹å¯¹æ•°æ—¶é—´ï¼Œä»è€Œå®Œæˆæˆ‘ä»¬çš„æŒ‘æˆ˜ã€‚
- en: 'To visualize the algorithm, letâ€™s use this tree schematic:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å¯è§†åŒ–ç®—æ³•ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªæ ‘å½¢å›¾ï¼š
- en: '| Â Â Â Â p |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â p |'
- en: '| Â Â Â / \ |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â / \ |'
- en: '| Â Â qÂ Â Â C |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â  qÂ Â Â C |'
- en: '| Â / \ |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|Â Â  / \ |'
- en: '| AÂ Â Â B |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| AÂ Â Â B |'
- en: Here, \(p\) is the value of the element at the root (though we will also abuse
    terminology and use the value at a root to refer to that whole tree), \(q\) is
    the value at the root of the left sub-tree (so \(q < p\)), and \(A\), \(B\), and
    \(C\) name the respective sub-trees. We have assumed that \(e\) is being inserted
    into the left sub-tree, which means \(e < p\).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œ\(p\) æ˜¯æ ¹å…ƒç´ çš„ä»·å€¼ï¼ˆå°½ç®¡æˆ‘ä»¬ä¹Ÿä¼šæ»¥ç”¨æœ¯è¯­ï¼Œå°†æ ¹çš„å€¼ç”¨æ¥æŒ‡ä»£æ•´ä¸ªæ ‘ï¼‰ï¼Œ\(q\) æ˜¯å·¦å­æ ‘æ ¹çš„å€¼ï¼ˆå› æ­¤ \(q < p\)ï¼‰ï¼Œè€Œ \(A\)ã€\(B\)
    å’Œ \(C\) åˆ†åˆ«å‘½åå„è‡ªçš„å­æ ‘ã€‚æˆ‘ä»¬å‡è®¾ \(e\) æ­£åœ¨è¢«æ’å…¥åˆ°å·¦å­æ ‘ä¸­ï¼Œè¿™æ„å‘³ç€ \(e < p\)ã€‚
- en: Letâ€™s say that \(C\) is of height \(k\). Before insertion, the tree rooted at
    \(q\) must have had height \(k+1\) (or else one insertion cannot create imbalance).
    In turn, this means \(A\) must have had height \(k\) or \(k-1\), and likewise
    for \(B\).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾ \(C\) çš„é«˜åº¦æ˜¯ \(k\)ã€‚åœ¨æ’å…¥ä¹‹å‰ï¼Œä»¥ \(q\) ä¸ºæ ¹çš„æ ‘å¿…é¡»å…·æœ‰é«˜åº¦ \(k+1\)ï¼ˆå¦åˆ™ä¸€æ¬¡æ’å…¥æ— æ³•åˆ›å»ºä¸å¹³è¡¡ï¼‰ã€‚åè¿‡æ¥ï¼Œè¿™æ„å‘³ç€
    \(A\) å¿…é¡»å…·æœ‰é«˜åº¦ \(k\) æˆ– \(k-1\)ï¼Œå¯¹äº \(B\) ä¹Ÿæ˜¯å¦‚æ­¤ã€‚
- en: Suppose that after insertion, the tree rooted at \(q\) has height \(k+2\). Thus,
    either \(A\) or \(B\) has height \(k+1\) and the other must have height less than
    that (either \(k\) or \(k-1\)).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æ’å…¥åï¼Œä»¥ \(q\) ä¸ºæ ¹çš„æ ‘çš„é«˜åº¦æ˜¯ \(k+2\)ã€‚å› æ­¤ï¼Œ\(A\) æˆ– \(B\) çš„é«˜åº¦æ˜¯ \(k+1\)ï¼Œè€Œå¦ä¸€ä¸ªå¿…é¡»å°äºè¿™ä¸ªé«˜åº¦ï¼ˆè¦ä¹ˆæ˜¯
    \(k\)ï¼Œè¦ä¹ˆæ˜¯ \(k-1\)ï¼‰ã€‚
- en: Exercise
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why can they both not have height \(k+1\) after insertion?
  id: totrans-244
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆå®ƒä»¬åœ¨æ’å…¥åéƒ½ä¸èƒ½æœ‰ \(k+1\) çš„é«˜åº¦ï¼Ÿ
- en: This gives us two cases to consider.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç»™æˆ‘ä»¬æä¾›äº†ä¸¤ä¸ªéœ€è¦è€ƒè™‘çš„æƒ…å†µã€‚
- en: 18.2.3.1Â Left-Left Case[ğŸ”—](#(part._.Left-.Left_.Case) "Link to here")
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 18.2.3.1Â å·¦-å·¦æƒ…å†µ[ğŸ”—](#(part._.Left-.Left_.Case) "é“¾æ¥è‡³æ­¤")
- en: 'Letâ€™s say the imbalance is in \(A\), i.e., it has height \(k+1\). Letâ€™s expand
    that tree:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾ä¸å¹³è¡¡å‘ç”Ÿåœ¨ \(A\) ä¸Šï¼Œå³å®ƒçš„é«˜åº¦æ˜¯ \(k+1\)ã€‚è®©æˆ‘ä»¬å±•å¼€è¿™æ£µæ ‘ï¼š
- en: '| Â Â Â Â Â Â p |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â p |'
- en: '| Â Â Â Â Â / \ |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â Â  / \ |'
- en: '| Â Â Â Â qÂ Â Â C |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â qÂ Â Â C |'
- en: '| Â Â Â / \ |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â / \ |'
- en: '| Â Â rÂ Â Â B |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â rÂ Â Â B |'
- en: '| Â / \ |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â  / \ |'
- en: '| A1Â Â A2 |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| A1Â Â A2 |'
- en: We know the following about the data in the sub-trees. Weâ€™ll use the notation
    \(T < a\) where \(T\) is a tree and \(a\) is a single value to mean every value
    in \(T\) is less than \(a\).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çŸ¥é“å­æ ‘ä¸­çš„æ•°æ®å¦‚ä¸‹ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ \(T < a\) çš„ç¬¦å·ï¼Œå…¶ä¸­ \(T\) æ˜¯ä¸€æ£µæ ‘ï¼Œ\(a\) æ˜¯ä¸€ä¸ªå•ç‹¬çš„å€¼ï¼Œè¡¨ç¤º \(T\) ä¸­çš„æ¯ä¸ªå€¼éƒ½å°äº
    \(a\)ã€‚
- en: \(A_1 < r\).
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(A_1 < r\)ã€‚
- en: \(r < A_2 < q\).
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(r < A_2 < q\)ã€‚
- en: \(q < B < p\).
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(q < B < p\)ã€‚
- en: \(p < C\).
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(p < C\)ã€‚
- en: 'Letâ€™s also remind ourselves of the sizes:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä¹Ÿæé†’ä¸€ä¸‹è¿™äº›å¤§å°ï¼š
- en: The height of \(A_1\) or of \(A_2\) is \(k\) (the cause of imbalance).
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(A_1\) æˆ– \(A_2\) çš„é«˜åº¦æ˜¯ \(k\)ï¼ˆä¸å¹³è¡¡çš„åŸå› ï¼‰ã€‚
- en: The height of the other \(A_i\) is \(k-1\) (see the exercise above).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…¶ä»– \(A_i\) çš„é«˜åº¦æ˜¯ \(k-1\)ï¼ˆå‚è§ä¸Šé¢çš„ç»ƒä¹ ï¼‰ã€‚
- en: The height of \(C\) is \(k\) (initial assumption; \(k\) is arbitrary).
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(C\) çš„é«˜åº¦æ˜¯ \(k\)ï¼ˆåˆå§‹å‡è®¾ï¼›\(k\) æ˜¯ä»»æ„çš„ï¼‰ã€‚
- en: The height of \(B\) must be \(k-1\) or \(k\) (argued above).
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(B\) çš„é«˜åº¦å¿…é¡»æ˜¯ \(k-1\) æˆ– \(k\)ï¼ˆå¦‚ä¸Šæ‰€è¿°ï¼‰ã€‚
- en: 'Imagine this tree is a mobile, which has gotten a little skewed to the left.
    You would naturally think to suspend the mobile a little further to the left to
    bring it back into balance. That is effectively what we will do:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡è¿™æ£µæ ‘æ˜¯ä¸€ä¸ªå¯ä»¥ç§»åŠ¨çš„ç‰©ä½“ï¼Œå®ƒç¨å¾®å‘å·¦å€¾æ–œäº†ä¸€ç‚¹ã€‚ä½ ä¼šè‡ªç„¶åœ°æƒ³åˆ°å°†å…¶ç¨å¾®å‘å·¦æ‚¬æŒ‚ä»¥æ¢å¤å¹³è¡¡ã€‚è¿™æ­£æ˜¯æˆ‘ä»¬å°†è¦åšçš„ï¼š
- en: '| Â Â Â Â Â q |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â Â  q |'
- en: '| Â Â Â Â / \ |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â Â  / \ |'
- en: '| Â Â rÂ Â Â Â Â p |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â  rÂ Â Â Â Â p |'
- en: '| Â / \Â Â Â / \ |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â  / \Â Â Â / \ |'
- en: '| A1Â Â A2 BÂ Â C |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| A1Â Â A2 BÂ Â C |'
- en: Observe that this preserves each of the ordering properties above. In addition,
    the \(A\) subtree has been brought one level closer to the root than earlier relative
    to \(B\) and \(C\). This restores the balance (as you can see if you work out
    the heights of each of \(A_i\), \(B\), and \(C\)). Thus, we have also restored
    balance.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„è¿™ä¿ç•™äº†ä¸Šè¿°æ¯ä¸ªæ’åºå±æ€§ã€‚æ­¤å¤–ï¼Œ\(A\) å­æ ‘ç›¸å¯¹äº \(B\) å’Œ \(C\) å·²ç»æ¯”ä¹‹å‰æ›´æ¥è¿‘æ ¹äº†ä¸€çº§ã€‚è¿™æ¢å¤äº†å¹³è¡¡ï¼ˆå¦‚æœä½ è®¡ç®—å‡º \(A_i\)ã€\(B\)
    å’Œ \(C\) çš„æ¯ä¸ªé«˜åº¦ï¼Œä½ ä¼šçœ‹åˆ°è¿™ä¸€ç‚¹ï¼‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¹Ÿæ¢å¤äº†å¹³è¡¡ã€‚
- en: 18.2.3.2Â Left-Right Case[ğŸ”—](#(part._.Left-.Right_.Case) "Link to here")
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 18.2.3.2Â å·¦-å³æƒ…å†µ[ğŸ”—](#(part._.Left-.Right_.Case) "é“¾æ¥è‡³æ­¤")
- en: 'The imbalance might instead be in \(B\). Expanding:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹³è¡¡ä¹Ÿå¯èƒ½å‘ç”Ÿåœ¨ \(B\) ä¸Šã€‚å±•å¼€ï¼š
- en: '| Â Â Â Â p |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â p |'
- en: '| Â Â Â / \ |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â  / \ |'
- en: '| Â Â qÂ Â Â C |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| Â Â qÂ Â Â C |'
- en: '| Â / \ |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| Â / \ |'
- en: '| AÂ Â Â r |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| AÂ Â Â r |'
- en: '| Â Â Â / \ |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â / \ |'
- en: '| Â Â B1Â Â B2 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| B1Â Â B2 |'
- en: 'Again, letâ€™s record what we know about data order:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡ï¼Œè®©æˆ‘ä»¬è®°å½•æˆ‘ä»¬æ‰€çŸ¥é“çš„æ•°æ®æ’åºï¼š
- en: \(A < q\).
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(A < q\)ã€‚
- en: \(q < B_1 < r\).
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(q < B_1 < r\).
- en: \(r < B_2 < p\).
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(r < B_2 < p\)ã€‚
- en: \(p < C\).
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(p < C\).
- en: 'and sizes:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: å’Œå¤§å°ï¼š
- en: Suppose the height of \(C\) is \(k\).
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡è®¾ \(C\) çš„é«˜åº¦ä¸º \(k\)ã€‚
- en: The height of \(A\) must be \(k-1\) or \(k\).
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(A\) çš„é«˜åº¦å¿…é¡»æ˜¯ \(k-1\) æˆ– \(k\)ã€‚
- en: The height of \(B_1\) or \(B_2\) must be \(k\), but not both (see the exercise
    above). The other must be \(k-1\).
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(B_1\) æˆ– \(B_2\) çš„é«˜åº¦å¿…é¡»æ˜¯ \(k\)ï¼Œä½†ä¸èƒ½ä¸¤è€…éƒ½æ˜¯ï¼ˆè§ä¸Šé¢çš„ç»ƒä¹ ï¼‰ã€‚å¦ä¸€ä¸ªå¿…é¡»æ˜¯ \(k-1\)ã€‚
- en: 'We therefore have to somehow bring \(B_1\) and \(B_2\) one level closer to
    the root of the tree. By using the above data ordering knowledge, we can construct
    this tree:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬å¿…é¡»ä»¥æŸç§æ–¹å¼å°† \(B_1\) å’Œ \(B_2\) å‘æ ‘æ ¹æ–¹å‘æå‡ä¸€çº§ã€‚é€šè¿‡ä½¿ç”¨ä¸Šè¿°æ•°æ®æ’åºçŸ¥è¯†ï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºè¿™æ£µæ ‘ï¼š
- en: '| Â Â Â Â Â Â p |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â Â Â p |'
- en: '| Â Â Â Â Â / \ |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â Â / \ |'
- en: '| Â Â Â Â rÂ Â Â C |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â rÂ Â Â C |'
- en: '| Â Â Â / \ |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â / \ |'
- en: '| Â Â qÂ Â Â B2 |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| Â Â qÂ Â Â B2 |'
- en: '| Â / \ |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| Â / \ |'
- en: '| AÂ Â Â B1 |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| AÂ Â Â B1 |'
- en: 'Of course, if \(B_1\) is the problematic sub-tree, this still does not address
    the problem. However, we are now back to the previous (left-left) case; rotating
    gets us to:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œå¦‚æœ \(B_1\) æ˜¯æœ‰é—®é¢˜çš„å­æ ‘ï¼Œè¿™ä»ç„¶æ²¡æœ‰è§£å†³é—®é¢˜ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ç°åœ¨å›åˆ°äº†ä¹‹å‰çš„ï¼ˆå·¦-å·¦ï¼‰æƒ…å†µï¼›æ—‹è½¬ä½¿æˆ‘ä»¬åˆ°è¾¾ï¼š
- en: '| Â Â Â Â Â Â r |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â Â Â r |'
- en: '| Â Â Â /Â Â Â Â \ |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â /Â Â Â Â \ |'
- en: '| Â Â qÂ Â Â Â Â Â p |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| Â Â qÂ Â Â Â Â Â p |'
- en: '| Â / \Â Â Â Â / \ |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| Â / \Â Â Â Â / \ |'
- en: '| AÂ Â Â B1 B2Â Â C |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| AÂ Â Â B1 B2Â Â C |'
- en: Now observe that we have precisely maintained the data ordering constraints.
    Furthermore, from the root, \(A\)â€™s lowest node is at height \(k+1\) or \(k+2\);
    so is \(B_1\)â€™s; so is \(B_2\)â€™s; and \(C\)â€™s is at \(k+2\).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è§‚å¯Ÿï¼Œæˆ‘ä»¬æ°å¥½ä¿æŒäº†æ•°æ®æ’åºçº¦æŸã€‚æ­¤å¤–ï¼Œä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œ\(A\) çš„æœ€ä½èŠ‚ç‚¹ä½äºé«˜åº¦ \(k+1\) æˆ– \(k+2\)ï¼›åŒæ · \(B_1\) çš„ï¼›åŒæ ·
    \(B_2\) çš„ï¼›è€Œ \(C\) çš„ä½äº \(k+2\)ã€‚
- en: 18.2.3.3Â Any Other Cases?[ğŸ”—](#(part._.Any_.Other_.Cases_) "Link to here")
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 18.2.3.3Â å…¶ä»–æƒ…å†µï¼Ÿ[ğŸ”—](#(part._.Any_.Other_.Cases_) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Were we a little too glib before? In the left-right case we said that only one
    of \(B_1\) or \(B_2\) could be of height \(k\) (after insertion); the other had
    to be of height \(k-1\). Actually, all we can say for sure is that the other has
    to be at most height \(k-2\).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹‹å‰æ˜¯å¦è¿‡äºè½»ç‡ï¼Ÿåœ¨å·¦-å³æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬è¯´ \(B_1\) æˆ– \(B_2\) ä¸­åªæœ‰ä¸€ä¸ªå¯ä»¥æ˜¯é«˜åº¦ \(k\)ï¼ˆæ’å…¥åï¼‰ï¼›å¦ä¸€ä¸ªå¿…é¡»æ˜¯é«˜åº¦ \(k-1\)ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬æ‰€èƒ½è‚¯å®šçš„æ˜¯ï¼Œå¦ä¸€ä¸ªçš„é«˜åº¦æœ€å¤šæ˜¯
    \(k-2\)ã€‚
- en: Exercise
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can the height of the other tree actually be \(k-2\) instead of \(k-1\)?
  id: totrans-309
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦ä¸€æ£µæ ‘çš„é«˜åº¦å®é™…ä¸Šå¯ä»¥æ˜¯ \(k-2\) è€Œä¸æ˜¯ \(k-1\) å—ï¼Ÿ
- en: ''
  id: totrans-310
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-311
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: If so, does the solution above hold? Is there not still an imbalance of two
    in the resulting tree?
  id: totrans-312
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæ˜¯è¿™æ ·ï¼Œä¸Šè¿°è§£å†³æ–¹æ¡ˆæ˜¯å¦ä»ç„¶æˆç«‹ï¼Ÿç»“æœæ ‘ä¸­æ˜¯å¦ä»ç„¶å­˜åœ¨ä¸¤ä¸ªä¸å¹³è¡¡ï¼Ÿ
- en: ''
  id: totrans-313
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-314
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Is there actually a bug in the above algorithm?
  id: totrans-315
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸Šé¢çš„ç®—æ³•å®é™…ä¸Šæœ‰é”™è¯¯å—ï¼Ÿ
- en: 18.2.3.1Â Left-Left Case[ğŸ”—](#(part._.Left-.Left_.Case) "Link to here")
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 18.2.3.1Â å·¦-å·¦æƒ…å†µ[ğŸ”—](#(part._.Left-.Left_.Case) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Letâ€™s say the imbalance is in \(A\), i.e., it has height \(k+1\). Letâ€™s expand
    that tree:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾ä¸å¹³è¡¡å‘ç”Ÿåœ¨ \(A\) ä¸­ï¼Œå³å®ƒçš„é«˜åº¦ä¸º \(k+1\)ã€‚è®©æˆ‘ä»¬å±•å¼€è¿™æ£µæ ‘ï¼š
- en: '| Â Â Â Â Â Â p |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â Â Â p |'
- en: '| Â Â Â Â Â / \ |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â Â / \ |'
- en: '| Â Â Â Â qÂ Â Â C |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â qÂ Â Â C |'
- en: '| Â Â Â / \ |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â / \ |'
- en: '| Â Â rÂ Â Â B |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| Â Â rÂ Â Â B |'
- en: '| Â / \ |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| Â / \ |'
- en: '| A1Â Â A2 |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| A1Â Â A2 |'
- en: We know the following about the data in the sub-trees. Weâ€™ll use the notation
    \(T < a\) where \(T\) is a tree and \(a\) is a single value to mean every value
    in \(T\) is less than \(a\).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çŸ¥é“å­æ ‘ä¸­çš„æ•°æ®å¦‚ä¸‹ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ç¬¦å· \(T < a\)ï¼Œå…¶ä¸­ \(T\) æ˜¯ä¸€æ£µæ ‘ï¼Œ\(a\) æ˜¯ä¸€ä¸ªå•ç‹¬çš„å€¼ï¼Œè¡¨ç¤º \(T\) ä¸­çš„æ¯ä¸ªå€¼éƒ½å°äº
    \(a\)ã€‚
- en: \(A_1 < r\).
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(A_1 < r\).
- en: \(r < A_2 < q\).
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(r < A_2 < q\)ã€‚
- en: \(q < B < p\).
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(q < B < p\)ã€‚
- en: \(p < C\).
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(p < C\).
- en: 'Letâ€™s also remind ourselves of the sizes:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä¹Ÿæé†’è‡ªå·±å¤§å°ï¼š
- en: The height of \(A_1\) or of \(A_2\) is \(k\) (the cause of imbalance).
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(A_1\) æˆ– \(A_2\) çš„é«˜åº¦æ˜¯ \(k\)ï¼ˆä¸å¹³è¡¡çš„åŸå› ï¼‰ã€‚
- en: The height of the other \(A_i\) is \(k-1\) (see the exercise above).
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…¶ä»– \(A_i\) çš„é«˜åº¦æ˜¯ \(k-1\)ï¼ˆè§ä¸Šé¢çš„ç»ƒä¹ ï¼‰ã€‚
- en: The height of \(C\) is \(k\) (initial assumption; \(k\) is arbitrary).
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(C\) çš„é«˜åº¦æ˜¯ \(k\)ï¼ˆåˆå§‹å‡è®¾ï¼›\(k\) æ˜¯ä»»æ„çš„ï¼‰ã€‚
- en: The height of \(B\) must be \(k-1\) or \(k\) (argued above).
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(B\) çš„é«˜åº¦å¿…é¡»æ˜¯ \(k-1\) æˆ– \(k\)ï¼ˆä¸Šé¢å·²è®ºè¯ï¼‰ã€‚
- en: 'Imagine this tree is a mobile, which has gotten a little skewed to the left.
    You would naturally think to suspend the mobile a little further to the left to
    bring it back into balance. That is effectively what we will do:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡è¿™æ£µæ ‘æ˜¯ä¸€ä¸ªç§»åŠ¨çš„ç‰©ä½“ï¼Œå®ƒç¨å¾®å‘å·¦å€¾æ–œäº†ä¸€ç‚¹ã€‚ä½ ä¼šè‡ªç„¶åœ°æƒ³åˆ°å°†å…¶ç¨å¾®å‘å·¦æ‚¬æŒ‚ä»¥ä½¿å…¶æ¢å¤å¹³è¡¡ã€‚è¿™æ­£æ˜¯æˆ‘ä»¬å°†è¦åšçš„ï¼š
- en: '| Â Â Â Â Â q |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â Â q |'
- en: '| Â Â Â Â / \ |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â / \ |'
- en: '| Â Â rÂ Â Â Â Â p |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| Â Â rÂ Â Â Â Â p |'
- en: '| Â / \Â Â Â / \ |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| Â / \Â Â Â / \ |'
- en: '| A1Â Â A2 BÂ Â C |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| A1Â Â A2 BÂ Â C |'
- en: Observe that this preserves each of the ordering properties above. In addition,
    the \(A\) subtree has been brought one level closer to the root than earlier relative
    to \(B\) and \(C\). This restores the balance (as you can see if you work out
    the heights of each of \(A_i\), \(B\), and \(C\)). Thus, we have also restored
    balance.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°è¿™ä¿ç•™äº†ä¸Šè¿°æ¯ä¸ªæ’åºå±æ€§ã€‚æ­¤å¤–ï¼Œä¸ \(B\) å’Œ \(C\) ç›¸æ¯”ï¼Œ\(A\) å­æ ‘å·²ç»æå‡äº†ä¸€ä¸ªå±‚çº§ï¼Œæ¯”ä¹‹å‰æ›´æ¥è¿‘æ ¹èŠ‚ç‚¹ã€‚è¿™æ¢å¤äº†å¹³è¡¡ï¼ˆå¦‚æœä½ è®¡ç®—å‡º
    \(A_i\)ã€\(B\) å’Œ \(C\) çš„æ¯ä¸ªé«˜åº¦ï¼Œä½ ä¼šçœ‹åˆ°ï¼‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¹Ÿæ¢å¤äº†å¹³è¡¡ã€‚
- en: 18.2.3.2Â Left-Right Case[ğŸ”—](#(part._.Left-.Right_.Case) "Link to here")
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 18.2.3.2Â å·¦-å³æƒ…å†µ[ğŸ”—](#(part._.Left-.Right_.Case) "é“¾æ¥è‡³æ­¤")
- en: 'The imbalance might instead be in \(B\). Expanding:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹³è¡¡å¯èƒ½å‡ºç°åœ¨ \(B\) ä¸Šã€‚å±•å¼€ï¼š
- en: '| Â Â Â Â p |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â p |'
- en: '| Â Â Â / \ |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â / \ |'
- en: '| Â Â qÂ Â Â C |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| Â Â qÂ Â Â C |'
- en: '| Â / \ |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| Â / \ |'
- en: '| AÂ Â Â r |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| AÂ Â Â r |'
- en: '| Â Â Â / \ |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â / \ |'
- en: '| Â Â B1Â Â B2 |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| Â Â B1Â Â B2 |'
- en: 'Again, letâ€™s record what we know about data order:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡ï¼Œè®©æˆ‘ä»¬è®°å½•æˆ‘ä»¬æ‰€çŸ¥é“çš„æ•°æ®æ’åºï¼š
- en: \(A < q\).
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(A < q\)ã€‚
- en: \(q < B_1 < r\).
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(q < B_1 < r\)ã€‚
- en: \(r < B_2 < p\).
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(r < B_2 < p\)ã€‚
- en: \(p < C\).
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(p < C\)ã€‚
- en: 'and sizes:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: å’Œå¤§å°ï¼š
- en: Suppose the height of \(C\) is \(k\).
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡è®¾ \(C\) çš„é«˜åº¦æ˜¯ \(k\)ã€‚
- en: The height of \(A\) must be \(k-1\) or \(k\).
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(A\) çš„é«˜åº¦å¿…é¡»æ˜¯ \(k-1\) æˆ– \(k\)ã€‚
- en: The height of \(B_1\) or \(B_2\) must be \(k\), but not both (see the exercise
    above). The other must be \(k-1\).
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(B_1\) æˆ– \(B_2\) çš„é«˜åº¦å¿…é¡»æ˜¯ \(k\)ï¼Œä½†ä¸èƒ½ä¸¤è€…éƒ½æ˜¯ï¼ˆå‚è§ä¸Šé¢çš„ç»ƒä¹ ï¼‰ã€‚å¦ä¸€ä¸ªå¿…é¡»æ˜¯ \(k-1\)ã€‚
- en: 'We therefore have to somehow bring \(B_1\) and \(B_2\) one level closer to
    the root of the tree. By using the above data ordering knowledge, we can construct
    this tree:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä»¥æŸç§æ–¹å¼å°† \(B_1\) å’Œ \(B_2\) çš„å±‚çº§æå‡åˆ°æ ‘çš„æ ¹èŠ‚ç‚¹æ›´è¿‘ä¸€äº›ã€‚é€šè¿‡ä½¿ç”¨ä¸Šè¿°æ•°æ®æ’åºçŸ¥è¯†ï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºå¦‚ä¸‹æ ‘ï¼š
- en: '| Â Â Â Â Â Â p |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â Â Â p |'
- en: '| Â Â Â Â Â / \ |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â Â / \ |'
- en: '| Â Â Â Â rÂ Â Â C |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â rÂ Â Â C |'
- en: '| Â Â Â / \ |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â / \ |'
- en: '| Â Â qÂ Â Â B2 |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| Â Â qÂ Â Â B2 |'
- en: '| Â / \ |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| Â / \ |'
- en: '| AÂ Â Â B1 |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| AÂ Â Â B1 |'
- en: 'Of course, if \(B_1\) is the problematic sub-tree, this still does not address
    the problem. However, we are now back to the previous (left-left) case; rotating
    gets us to:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œå¦‚æœ \(B_1\) æ˜¯æœ‰é—®é¢˜çš„å­æ ‘ï¼Œè¿™ä»ç„¶æ²¡æœ‰è§£å†³é—®é¢˜ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ç°åœ¨å›åˆ°äº†ä¹‹å‰çš„ï¼ˆå·¦-å·¦ï¼‰æƒ…å†µï¼›æ—‹è½¬å¸¦æˆ‘ä»¬åˆ°ï¼š
- en: '| Â Â Â Â Â Â r |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â Â Â Â r |'
- en: '| Â Â Â /Â Â Â Â \ |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| Â Â Â /Â Â Â Â \ |'
- en: '| Â Â qÂ Â Â Â Â Â p |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| Â Â qÂ Â Â Â Â Â p |'
- en: '| Â / \Â Â Â Â / \ |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| Â / \Â Â Â Â / \ |'
- en: '| AÂ Â Â B1 B2Â Â C |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| AÂ Â Â B1 B2Â Â C |'
- en: Now observe that we have precisely maintained the data ordering constraints.
    Furthermore, from the root, \(A\)â€™s lowest node is at height \(k+1\) or \(k+2\);
    so is \(B_1\)â€™s; so is \(B_2\)â€™s; and \(C\)â€™s is at \(k+2\).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è§‚å¯Ÿä¸€ä¸‹ï¼Œæˆ‘ä»¬ç²¾ç¡®åœ°ä¿æŒäº†æ•°æ®æ’åºçº¦æŸã€‚æ­¤å¤–ï¼Œä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œ\(A\) çš„æœ€ä½èŠ‚ç‚¹åœ¨é«˜åº¦ \(k+1\) æˆ– \(k+2\)ï¼›\(B_1\) çš„ä¹Ÿæ˜¯ï¼›\(B_2\)
    çš„ä¹Ÿæ˜¯ï¼›\(C\) çš„åœ¨ \(k+2\)ã€‚
- en: 18.2.3.3Â Any Other Cases?[ğŸ”—](#(part._.Any_.Other_.Cases_) "Link to here")
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 18.2.3.3Â å…¶ä»–æƒ…å†µ?[ğŸ”—](#(part._.Any_.Other_.Cases_) "é“¾æ¥è‡³æ­¤")
- en: Were we a little too glib before? In the left-right case we said that only one
    of \(B_1\) or \(B_2\) could be of height \(k\) (after insertion); the other had
    to be of height \(k-1\). Actually, all we can say for sure is that the other has
    to be at most height \(k-2\).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹‹å‰æ˜¯ä¸æ˜¯æœ‰ç‚¹è¿‡äºè½»ç‡äº†ï¼Ÿåœ¨å·¦-å³æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬è¯´ \(B_1\) æˆ– \(B_2\) ä¸­åªæœ‰ä¸€ä¸ªå¯ä»¥æ˜¯é«˜åº¦ \(k\)ï¼ˆåœ¨æ’å…¥åï¼‰ï¼›å¦ä¸€ä¸ªå¿…é¡»æ˜¯é«˜åº¦
    \(k-1\)ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬æ‰€èƒ½è‚¯å®šçš„æ˜¯ï¼Œå¦ä¸€ä¸ªçš„é«˜åº¦æœ€å¤šæ˜¯ \(k-2\)ã€‚
- en: Exercise
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can the height of the other tree actually be \(k-2\) instead of \(k-1\)?
  id: totrans-379
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦ä¸€æ£µæ ‘çš„é«˜åº¦å®é™…ä¸Šå¯ä»¥æ˜¯ \(k-2\) è€Œä¸æ˜¯ \(k-1\) å—ï¼Ÿ
- en: ''
  id: totrans-380
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-381
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: If so, does the solution above hold? Is there not still an imbalance of two
    in the resulting tree?
  id: totrans-382
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæ˜¯è¿™æ ·ï¼Œä¸Šé¢çš„è§£å†³æ–¹æ¡ˆæ˜¯å¦ä»ç„¶æˆç«‹ï¼Ÿç»“æœæ ‘ä¸­ä¸æ˜¯ä»ç„¶æœ‰ä¸¤ä¸ªä¸å¹³è¡¡å—ï¼Ÿ
- en: ''
  id: totrans-383
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-384
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Is there actually a bug in the above algorithm?
  id: totrans-385
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸Šé¢çš„ç®—æ³•å®é™…ä¸Šæ˜¯å¦å­˜åœ¨é”™è¯¯ï¼Ÿ
