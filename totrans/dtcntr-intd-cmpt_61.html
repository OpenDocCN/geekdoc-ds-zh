<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>18.5Â Equality, Ordering, and HashingğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>18.5Â Equality, Ordering, and HashingğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/orderability.html">https://dcic-world.org/2025-08-27/orderability.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._hashing-values%29" class="toclink" data-pltdoc="x">18.5.1<span class="hspace">Â </span>Converting Values to Ordered Values</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._hash-in-practice%29" class="toclink" data-pltdoc="x">18.5.2<span class="hspace">Â </span>Hashing in Practice</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._eq-ord%29" class="toclink" data-pltdoc="x">18.5.3<span class="hspace">Â </span>Equality and Ordering</a></p></td></tr></table><section class="SsectionLevel4" id="section 18.5.1"><h4 class="heading">18.5.1<span class="stt">Â </span><a name="(part._hashing-values)"/><a name="(part._g~c3~b6del-encoding)"/>Converting Values to Ordered Values<span class="button-group"><a href="#(part._hashing-values)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In <a href="sets-from-trees.html" data-pltdoc="x">Making Sets Grow on Trees</a>, we noted that a single comparison needs
to eliminate an entire set of values. With numbers, we were able to
accomplish that easily: every bigger or smaller number was excluded by
a comparison. But what if the data in the set are not actually
numbers? Then we have to convert an arbitrary datum into a datatype that
permits such comparison. This is known as <span style="font-style: italic">hashing</span>.</p><p>A <span style="font-style: italic">hash function</span> consumes an arbitrary value and produces a comparable
representation of it (its <span style="font-style: italic">hash</span>)â€”<wbr/>most commonly (but not
strictly necessarily), a number. A hash function must naturally be
<span style="font-style: italic">deterministic</span>: a fixed value should always yield the same hash
(otherwise, we might conclude that an element in the set is not
actually in it, etc.). Particular uses may need additional properties,
as we discuss in <a href="#%28part._eq-ord%29" data-pltdoc="x">Equality and Ordering</a>.</p><p>Let us now consider how one can compute hashes.  If the input datatype
is a number, it can serve as its own hash. Comparison simply uses
numeric comparison (e.g., <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;</code></span>). Then, transitivity of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;</code></span>
ensures that if an element \(A\) is less than another element \(B\),
then \(A\) is also less than all the other elements bigger than
\(B\).</p><p>Suppose instead the input is a string. We can of course use the
principle above for strings: e.g., replacing number inequality with
string inequality. Strings have a <span style="font-style: italic">lexicographic</span> (or
â€œalphabeticâ€) ordering that permit them to be treated similar to
numbers.</p><p>But what if we are handed more complex datatypes?</p><p/><div class="SIntrapara">Before we answer that, consider that in practice numbers are more
efficient to compare than strings (since comparing two numbers is very
nearly constant time). Thus, although we could use strings directly,
it may be convenient to find a numeric representation of
strings. We convert each character of the string
into a number, e.g., using its
<a href="https://en.wikipedia.org/wiki/Code_point">code point</a>.
Based on that, here are two different hash functions:
</div><div class="SIntrapara"><ol><li><p/><div class="SIntrapara">Consider a list of primes as long as the string. Raise each
prime by the corresponding number, and multiply the result. For
instance, if the string is represented by the character codes
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[6, 4, 5]</code></span> (the first character has code <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">6</code></span>, the second
one <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">4</code></span>, and the third <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">5</code></span>), we get the hash
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-expt(2, 6) * num-expt(3, 4) * num-expt(5, 5)</code></pre></div></div></div><div class="SIntrapara">or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">16200000</code></span>.</div></li><li><p/><div class="SIntrapara">Simply add together all the character codes. For the above
example, this would correspond to the has
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">6 + 4 + 5</code></pre></div></div></div><div class="SIntrapara">or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">15</code></span>.</div></li></ol></div><div class="SIntrapara">The first representation is <span style="font-style: italic">invertible</span>, using the
<a href="http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic">Fundamental Theorem of Arithmetic</a>:
given the resulting number, we can reconstruct the input unambiguously
(i.e., <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">16200000</code></span> can only map to the input above, and none other).
This is also known as the <span style="font-style: italic">GÃ¶del encoding</span>. This is
computationally expensive.
The second encoding is, of course, not invertible (e.g., simply
permute the characters and, by commutativity, the sum will be the
same), but computationally much cheaper. It is also easy to implement:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun hash-of(s :: String):
  fold({(a :: Number, b :: Number): a + b},
    0,
    string-to-code-points(s))
end

check:
  hash-of("Hello") is 500
  hash-of("World!") is 553
  hash-of("ğŸ´â€â˜ ï¸") is 195692
end</code></pre></div></div></div><p>Now let us consider more general datatypes. The principle of hashing
will be similar. If we have a datatype with several variants, we can
order the variants lexicographically, and use a numeric tag to
represent the variants, and recursively encode the datum and the
variant tag. For each field of a record, we need an ordering of the
fieldsâ€”<wbr/>the lexicographic ordering of the field names sufficesâ€”<wbr/>and
must hash their contents recursively; having done so, we get in effect
a string of numbers, which we have shown how to handle.</p><p/><div class="SIntrapara">The critical thing to remember is that we donâ€™t actually need a
<span class="emph">meaningful</span> operation.<span class="refelem"><span class="refcolumn"><span class="refcontent">Observe that GÃ¶del encodings
are not â€œmeaningfulâ€, either.</span></span></span>  We donâ€™t actually care if a hash
function concludes that the hash of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">4</code></span> is less than the hash of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>! All we need is a function that is
</div><div class="SIntrapara"><ul><li><p><span class="emph">non-trivial</span>: not everything should be equal; and</p></li><li><p><span class="emph">deterministic</span>: every time we ask for a hash, we should get
the same answer.</p></li></ul></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why do we care about these two properties? Think about what would could go
wrong if each one was violated.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 18.5.2"><h4 class="heading">18.5.2<span class="stt">Â </span><a name="(part._hash-in-practice)"/>Hashing in Practice<span class="button-group"><a href="#(part._hash-in-practice)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In practice, programmers do not want hash functions to do what we have
described above. While GÃ¶del encoding is extremely expensive, even
computing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hash-of</code></span> takes time linear in the size of a string,
which can get quite expensive if strings are large or we compute
hashes often or both.</p><p>Instead, many programming languages do something very pragmatic. They
need a value that can be compared for equality and ordering
[<a href="#%28part._eq-ord%29" data-pltdoc="x">Equality and Ordering</a>]. Integers, weâ€™ve already seen, already fit this
bill very nicely. But how to obtain an integer out of <span class="emph">arbitrary</span>
values, even datatype instances, quickly?</p><p>Simple: <span class="emph">They just use the memory address of the datum.</span> Every
value has a memory address, and the language can obtain it in constant
time by looking up the directory. Granted, these values may be
allocated anywhere with respect to each other, but thatâ€™s okayâ€”<wbr/>we
only want consistency, not â€œmeaningfulnessâ€.</p><p>In practice, however, things are not quite so simple.  For instance,
suppose we want two structurally equivalent values to have the same
hash. If they are allocated in different addresses, they will hash
differently. Therefore, many languages that use such a strategy also
allow programmers to write their own hashing functions, often to work
in conjunction with this built-in notion of hashing. These end up
looking not too different from the hashing strategies we described
above. Therefore, some of that complexity is inescapable, especially
if a programmer wants structural rather than reference
equalityâ€”<wbr/>which they very often do.</p><p>In the rest of this material, we will therefore continue with the
simple hash function above, for multiple reasons. First, it is
sufficient to illustrate how hashing works. Second, in practice, when
built-in hashing does not suffice, we do write (more complex versions
of) functions like the above. And finally, because itâ€™s all laid bare,
itâ€™s easy for us to experiment with.</p></section><section class="SsectionLevel4" id="section 18.5.3"><h4 class="heading">18.5.3<span class="stt">Â </span><a name="(part._eq-ord)"/>Equality and Ordering<span class="button-group"><a href="#(part._eq-ord)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>What weâ€™ve seen [<a href="sets-from-trees.html#%28part._sets-from-balanced-trees%29" data-pltdoc="x">A Fine Balance: Tree Surgery</a>] for the construction of
balanced binary search trees is that we need some way of putting elements in
order. In the examples we used numbers because theyâ€™re a very friendly
datatype: they have several properties that we take for granted. However, not
all data have these properties.</p><p>The critical property that numbers have is that they are <span style="font-style: italic">orderable</span>. This
follows because they are <span style="font-style: italic">comparable</span>, and the comparison is
<span class="emph">ternary</span>: it produces three answers, â€œless thanâ€, â€œequal toâ€, and
â€œgreater thanâ€.</p><p>However, not all data have this property. What are data that might not have
these properties? Actually, there are multiple possible properties here: Is
something orderable? Is something even comparable?</p><p/><table cellspacing="0" cellpadding="0"><tr><td><p> </p></td><td><p><span class="hspace">Â Â </span></p></td><td><p><span style="font-weight: bold">Comparable</span></p></td><td><p><span class="hspace">Â Â </span></p></td><td><p><span style="font-weight: bold">Orderable</span></p></td></tr><tr><td><p>Numbers</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>Yes (but not Roughnums!)</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>Yes</p></td></tr><tr><td><p>Booleans</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>Yes</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>Yes</p></td></tr><tr><td><p>Data instances</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>Yes</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>Not by default</p></td></tr><tr><td><p>Roughnums</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>No</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>Yes</p></td></tr><tr><td><p>Functions</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>Not really</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>No</p></td></tr></table><p>Soâ€¦life is complicated.</p><p>That means you could potentially misuse a <span class="Smaller">BBST</span> on the wrong kind of
data. Ideally, we would want to know if weâ€™re doing this. In Pyretâ€™s type
system we chose not to build this in, but in some languages, the type system
actually lets you capture these properties.</p><p/><div class="SIntrapara">In Haskell, for instance, thereâ€™s a mechanism called the type-class; in Java,
there are interfaces. They arenâ€™t really the same, but theyâ€™re useful to
conflate for our purposes. Only things that meet a particular interface or type
class provide certain operations. For instance, in Haskell, if you want to use
<span class="stt">==</span> or <span class="stt">/=</span> (not equal), you have to be in the <span class="stt">Eq</span>
type-class. Thus the comparable datatypes above would be part of
<span class="stt">Eq</span>. Similarly, thereâ€™s a type-class <span class="stt">Ord</span>, which ensures the
availability of (and requires the implementation of) operations like <span class="stt">&lt;</span>,
<span class="stt">&gt;</span>, <span class="stt">&lt;=</span>, and <span class="stt">&gt;=</span>. In Haskell, everything that is <span class="stt">Ord</span>
must also be <span class="stt">Eq</span>, i.e., <span class="stt">Eq</span> is weaker than <span class="stt">Ord</span> (things can
be <span class="stt">Eq</span> without being <span class="stt">Ord</span>). Pyretâ€™s Roughnums contradict thatâ€¦but
Haskell is okay with it. But if you try to compare two functions in Haskell,
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(\x -&gt; x + 1) &lt; (\x -&gt; x)</span></p></td></tr></table></div><div class="SIntrapara">you get an error like
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">* No instance for (Ord (Integer -&gt; Integer))</span></p></td></tr><tr><td><p><span class="stt"/><span class="hspace">Â Â Â Â </span><span class="stt">arising from a use of `&lt;'</span></p></td></tr></table></div></section>&#13;
<h4 class="heading">18.5.1<span class="stt">Â </span><a name="(part._hashing-values)"/><a name="(part._g~c3~b6del-encoding)"/>Converting Values to Ordered Values<span class="button-group"><a href="#(part._hashing-values)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In <a href="sets-from-trees.html" data-pltdoc="x">Making Sets Grow on Trees</a>, we noted that a single comparison needs
to eliminate an entire set of values. With numbers, we were able to
accomplish that easily: every bigger or smaller number was excluded by
a comparison. But what if the data in the set are not actually
numbers? Then we have to convert an arbitrary datum into a datatype that
permits such comparison. This is known as <span style="font-style: italic">hashing</span>.</p><p>A <span style="font-style: italic">hash function</span> consumes an arbitrary value and produces a comparable
representation of it (its <span style="font-style: italic">hash</span>)â€”<wbr/>most commonly (but not
strictly necessarily), a number. A hash function must naturally be
<span style="font-style: italic">deterministic</span>: a fixed value should always yield the same hash
(otherwise, we might conclude that an element in the set is not
actually in it, etc.). Particular uses may need additional properties,
as we discuss in <a href="#%28part._eq-ord%29" data-pltdoc="x">Equality and Ordering</a>.</p><p>Let us now consider how one can compute hashes.  If the input datatype
is a number, it can serve as its own hash. Comparison simply uses
numeric comparison (e.g., <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;</code></span>). Then, transitivity of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;</code></span>
ensures that if an element \(A\) is less than another element \(B\),
then \(A\) is also less than all the other elements bigger than
\(B\).</p><p>Suppose instead the input is a string. We can of course use the
principle above for strings: e.g., replacing number inequality with
string inequality. Strings have a <span style="font-style: italic">lexicographic</span> (or
â€œalphabeticâ€) ordering that permit them to be treated similar to
numbers.</p><p>But what if we are handed more complex datatypes?</p><p/><div class="SIntrapara">Before we answer that, consider that in practice numbers are more
efficient to compare than strings (since comparing two numbers is very
nearly constant time). Thus, although we could use strings directly,
it may be convenient to find a numeric representation of
strings. We convert each character of the string
into a number, e.g., using its
<a href="https://en.wikipedia.org/wiki/Code_point">code point</a>.
Based on that, here are two different hash functions:
</div><div class="SIntrapara"><ol><li><p/><div class="SIntrapara">Consider a list of primes as long as the string. Raise each
prime by the corresponding number, and multiply the result. For
instance, if the string is represented by the character codes
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[6, 4, 5]</code></span> (the first character has code <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">6</code></span>, the second
one <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">4</code></span>, and the third <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">5</code></span>), we get the hash
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-expt(2, 6) * num-expt(3, 4) * num-expt(5, 5)</code></pre></div></div></div><div class="SIntrapara">or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">16200000</code></span>.</div></li><li><p/><div class="SIntrapara">Simply add together all the character codes. For the above
example, this would correspond to the has
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">6 + 4 + 5</code></pre></div></div></div><div class="SIntrapara">or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">15</code></span>.</div></li></ol></div><div class="SIntrapara">The first representation is <span style="font-style: italic">invertible</span>, using the
<a href="http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic">Fundamental Theorem of Arithmetic</a>:
given the resulting number, we can reconstruct the input unambiguously
(i.e., <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">16200000</code></span> can only map to the input above, and none other).
This is also known as the <span style="font-style: italic">GÃ¶del encoding</span>. This is
computationally expensive.
The second encoding is, of course, not invertible (e.g., simply
permute the characters and, by commutativity, the sum will be the
same), but computationally much cheaper. It is also easy to implement:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun hash-of(s :: String):
  fold({(a :: Number, b :: Number): a + b},
    0,
    string-to-code-points(s))
end

check:
  hash-of("Hello") is 500
  hash-of("World!") is 553
  hash-of("ğŸ´â€â˜ ï¸") is 195692
end</code></pre></div></div></div><p>Now let us consider more general datatypes. The principle of hashing
will be similar. If we have a datatype with several variants, we can
order the variants lexicographically, and use a numeric tag to
represent the variants, and recursively encode the datum and the
variant tag. For each field of a record, we need an ordering of the
fieldsâ€”<wbr/>the lexicographic ordering of the field names sufficesâ€”<wbr/>and
must hash their contents recursively; having done so, we get in effect
a string of numbers, which we have shown how to handle.</p><p/><div class="SIntrapara">The critical thing to remember is that we donâ€™t actually need a
<span class="emph">meaningful</span> operation.<span class="refelem"><span class="refcolumn"><span class="refcontent">Observe that GÃ¶del encodings
are not â€œmeaningfulâ€, either.</span></span></span>  We donâ€™t actually care if a hash
function concludes that the hash of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">4</code></span> is less than the hash of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>! All we need is a function that is
</div><div class="SIntrapara"><ul><li><p><span class="emph">non-trivial</span>: not everything should be equal; and</p></li><li><p><span class="emph">deterministic</span>: every time we ask for a hash, we should get
the same answer.</p></li></ul></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why do we care about these two properties? Think about what would could go
wrong if each one was violated.</p></blockquote></blockquote>&#13;
<h4 class="heading">18.5.2<span class="stt">Â </span><a name="(part._hash-in-practice)"/>Hashing in Practice<span class="button-group"><a href="#(part._hash-in-practice)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In practice, programmers do not want hash functions to do what we have
described above. While GÃ¶del encoding is extremely expensive, even
computing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hash-of</code></span> takes time linear in the size of a string,
which can get quite expensive if strings are large or we compute
hashes often or both.</p><p>Instead, many programming languages do something very pragmatic. They
need a value that can be compared for equality and ordering
[<a href="#%28part._eq-ord%29" data-pltdoc="x">Equality and Ordering</a>]. Integers, weâ€™ve already seen, already fit this
bill very nicely. But how to obtain an integer out of <span class="emph">arbitrary</span>
values, even datatype instances, quickly?</p><p>Simple: <span class="emph">They just use the memory address of the datum.</span> Every
value has a memory address, and the language can obtain it in constant
time by looking up the directory. Granted, these values may be
allocated anywhere with respect to each other, but thatâ€™s okayâ€”<wbr/>we
only want consistency, not â€œmeaningfulnessâ€.</p><p>In practice, however, things are not quite so simple.  For instance,
suppose we want two structurally equivalent values to have the same
hash. If they are allocated in different addresses, they will hash
differently. Therefore, many languages that use such a strategy also
allow programmers to write their own hashing functions, often to work
in conjunction with this built-in notion of hashing. These end up
looking not too different from the hashing strategies we described
above. Therefore, some of that complexity is inescapable, especially
if a programmer wants structural rather than reference
equalityâ€”<wbr/>which they very often do.</p><p>In the rest of this material, we will therefore continue with the
simple hash function above, for multiple reasons. First, it is
sufficient to illustrate how hashing works. Second, in practice, when
built-in hashing does not suffice, we do write (more complex versions
of) functions like the above. And finally, because itâ€™s all laid bare,
itâ€™s easy for us to experiment with.</p>&#13;
<h4 class="heading">18.5.3<span class="stt">Â </span><a name="(part._eq-ord)"/>Equality and Ordering<span class="button-group"><a href="#(part._eq-ord)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>What weâ€™ve seen [<a href="sets-from-trees.html#%28part._sets-from-balanced-trees%29" data-pltdoc="x">A Fine Balance: Tree Surgery</a>] for the construction of
balanced binary search trees is that we need some way of putting elements in
order. In the examples we used numbers because theyâ€™re a very friendly
datatype: they have several properties that we take for granted. However, not
all data have these properties.</p><p>The critical property that numbers have is that they are <span style="font-style: italic">orderable</span>. This
follows because they are <span style="font-style: italic">comparable</span>, and the comparison is
<span class="emph">ternary</span>: it produces three answers, â€œless thanâ€, â€œequal toâ€, and
â€œgreater thanâ€.</p><p>However, not all data have this property. What are data that might not have
these properties? Actually, there are multiple possible properties here: Is
something orderable? Is something even comparable?</p><p/><table cellspacing="0" cellpadding="0"><tr><td><p> </p></td><td><p><span class="hspace">Â Â </span></p></td><td><p><span style="font-weight: bold">Comparable</span></p></td><td><p><span class="hspace">Â Â </span></p></td><td><p><span style="font-weight: bold">Orderable</span></p></td></tr><tr><td><p>Numbers</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>Yes (but not Roughnums!)</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>Yes</p></td></tr><tr><td><p>Booleans</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>Yes</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>Yes</p></td></tr><tr><td><p>Data instances</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>Yes</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>Not by default</p></td></tr><tr><td><p>Roughnums</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>No</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>Yes</p></td></tr><tr><td><p>Functions</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>Not really</p></td><td><p><span class="hspace">Â Â </span></p></td><td><p>No</p></td></tr></table><p>Soâ€¦life is complicated.</p><p>That means you could potentially misuse a <span class="Smaller">BBST</span> on the wrong kind of
data. Ideally, we would want to know if weâ€™re doing this. In Pyretâ€™s type
system we chose not to build this in, but in some languages, the type system
actually lets you capture these properties.</p><p/><div class="SIntrapara">In Haskell, for instance, thereâ€™s a mechanism called the type-class; in Java,
there are interfaces. They arenâ€™t really the same, but theyâ€™re useful to
conflate for our purposes. Only things that meet a particular interface or type
class provide certain operations. For instance, in Haskell, if you want to use
<span class="stt">==</span> or <span class="stt">/=</span> (not equal), you have to be in the <span class="stt">Eq</span>
type-class. Thus the comparable datatypes above would be part of
<span class="stt">Eq</span>. Similarly, thereâ€™s a type-class <span class="stt">Ord</span>, which ensures the
availability of (and requires the implementation of) operations like <span class="stt">&lt;</span>,
<span class="stt">&gt;</span>, <span class="stt">&lt;=</span>, and <span class="stt">&gt;=</span>. In Haskell, everything that is <span class="stt">Ord</span>
must also be <span class="stt">Eq</span>, i.e., <span class="stt">Eq</span> is weaker than <span class="stt">Ord</span> (things can
be <span class="stt">Eq</span> without being <span class="stt">Ord</span>). Pyretâ€™s Roughnums contradict thatâ€¦but
Haskell is okay with it. But if you try to compare two functions in Haskell,
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(\x -&gt; x + 1) &lt; (\x -&gt; x)</span></p></td></tr></table></div><div class="SIntrapara">you get an error like
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">* No instance for (Ord (Integer -&gt; Integer))</span></p></td></tr><tr><td><p><span class="stt"/><span class="hspace">Â Â Â Â </span><span class="stt">arising from a use of `&lt;'</span></p></td></tr></table></div>    
</body>
</html>