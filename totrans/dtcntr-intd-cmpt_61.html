<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>18.5Â Equality, Ordering, and HashingğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>18.5Â Equality, Ordering, and HashingğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/orderability.html">https://dcic-world.org/2025-08-27/orderability.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._hashing-values%29" class="toclink" data-pltdoc="x">18.5.1Â Converting Values to Ordered Values</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._hash-in-practice%29" class="toclink" data-pltdoc="x">18.5.2Â Hashing in Practice</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._eq-ord%29" class="toclink" data-pltdoc="x">18.5.3Â Equality and Ordering</a></p></td></tr></table><section class="SsectionLevel4" id="section 18.5.1"><h4 class="heading">18.5.1Â <a name="(part._hashing-values)"/><a name="(part._g~c3~b6del-encoding)"/>Converting Values to Ordered Values<a href="#(part._hashing-values)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In <a href="sets-from-trees.html" data-pltdoc="x">Making Sets Grow on Trees</a>, we noted that a single comparison needs
to eliminate an entire set of values. With numbers, we were able to
accomplish that easily: every bigger or smaller number was excluded by
a comparison. But what if the data in the set are not actually
numbers? Then we have to convert an arbitrary datum into a datatype that
permits such comparison. This is known as hashing.</p><p>A hash function consumes an arbitrary value and produces a comparable
representation of it (its hash)â€”<wbr/>most commonly (but not
strictly necessarily), a number. A hash function must naturally be
deterministic: a fixed value should always yield the same hash
(otherwise, we might conclude that an element in the set is not
actually in it, etc.). Particular uses may need additional properties,
as we discuss in <a href="#%28part._eq-ord%29" data-pltdoc="x">Equality and Ordering</a>.</p><p>Let us now consider how one can compute hashes.  If the input datatype
is a number, it can serve as its own hash. Comparison simply uses
numeric comparison (e.g., <code data-lang="pyret" class="sourceCode">&lt;</code>). Then, transitivity of <code data-lang="pyret" class="sourceCode">&lt;</code>
ensures that if an element \(A\) is less than another element \(B\),
then \(A\) is also less than all the other elements bigger than
\(B\).</p><p>Suppose instead the input is a string. We can of course use the
principle above for strings: e.g., replacing number inequality with
string inequality. Strings have a lexicographic (or
â€œalphabeticâ€) ordering that permit them to be treated similar to
numbers.</p><p>But what if we are handed more complex datatypes?</p><p>Before we answer that, consider that in practice numbers are more
efficient to compare than strings (since comparing two numbers is very
nearly constant time). Thus, although we could use strings directly,
it may be convenient to find a numeric representation of
strings. We convert each character of the string
into a number, e.g., using its
<a href="https://en.wikipedia.org/wiki/Code_point">code point</a>.
Based on that, here are two different hash functions:
</p><ol><li><p>Consider a list of primes as long as the string. Raise each
prime by the corresponding number, and multiply the result. For
instance, if the string is represented by the character codes
<code data-lang="pyret" class="sourceCode">[6, 4, 5]</code> (the first character has code <code data-lang="pyret" class="sourceCode">6</code>, the second
one <code data-lang="pyret" class="sourceCode">4</code>, and the third <code data-lang="pyret" class="sourceCode">5</code>), we get the hash
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-expt(2, 6) * num-expt(3, 4) * num-expt(5, 5)</code></pre><p>or <code data-lang="pyret" class="sourceCode">16200000</code>.</p></li><li><p>Simply add together all the character codes. For the above
example, this would correspond to the has
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">6 + 4 + 5</code></pre><p>or <code data-lang="pyret" class="sourceCode">15</code>.</p></li></ol><p>The first representation is invertible, using the
<a href="http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic">Fundamental Theorem of Arithmetic</a>:
given the resulting number, we can reconstruct the input unambiguously
(i.e., <code data-lang="pyret" class="sourceCode">16200000</code> can only map to the input above, and none other).
This is also known as the GÃ¶del encoding. This is
computationally expensive.
The second encoding is, of course, not invertible (e.g., simply
permute the characters and, by commutativity, the sum will be the
same), but computationally much cheaper. It is also easy to implement:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun hash-of(s :: String):
  fold({(a :: Number, b :: Number): a + b},
    0,
    string-to-code-points(s))
end

check:
  hash-of("Hello") is 500
  hash-of("World!") is 553
  hash-of("ğŸ´â€â˜ ï¸") is 195692
end</code></pre><p>Now let us consider more general datatypes. The principle of hashing
will be similar. If we have a datatype with several variants, we can
order the variants lexicographically, and use a numeric tag to
represent the variants, and recursively encode the datum and the
variant tag. For each field of a record, we need an ordering of the
fieldsâ€”<wbr/>the lexicographic ordering of the field names sufficesâ€”<wbr/>and
must hash their contents recursively; having done so, we get in effect
a string of numbers, which we have shown how to handle.</p><p>The critical thing to remember is that we donâ€™t actually need a
meaningful operation.Observe that GÃ¶del encodings
are not â€œmeaningfulâ€, either.  We donâ€™t actually care if a hash
function concludes that the hash of <code data-lang="pyret" class="sourceCode">4</code> is less than the hash of
<code data-lang="pyret" class="sourceCode">3</code>! All we need is a function that is
</p><ul><li><p>non-trivial: not everything should be equal; and</p></li><li><p>deterministic: every time we ask for a hash, we should get
the same answer.</p></li></ul><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why do we care about these two properties? Think about what would could go
wrong if each one was violated.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 18.5.2"><h4 class="heading">18.5.2Â <a name="(part._hash-in-practice)"/>Hashing in Practice<a href="#(part._hash-in-practice)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In practice, programmers do not want hash functions to do what we have
described above. While GÃ¶del encoding is extremely expensive, even
computing <code data-lang="pyret" class="sourceCode">hash-of</code> takes time linear in the size of a string,
which can get quite expensive if strings are large or we compute
hashes often or both.</p><p>Instead, many programming languages do something very pragmatic. They
need a value that can be compared for equality and ordering
[<a href="#%28part._eq-ord%29" data-pltdoc="x">Equality and Ordering</a>]. Integers, weâ€™ve already seen, already fit this
bill very nicely. But how to obtain an integer out of arbitrary
values, even datatype instances, quickly?</p><p>Simple: They just use the memory address of the datum. Every
value has a memory address, and the language can obtain it in constant
time by looking up the directory. Granted, these values may be
allocated anywhere with respect to each other, but thatâ€™s okayâ€”<wbr/>we
only want consistency, not â€œmeaningfulnessâ€.</p><p>In practice, however, things are not quite so simple.  For instance,
suppose we want two structurally equivalent values to have the same
hash. If they are allocated in different addresses, they will hash
differently. Therefore, many languages that use such a strategy also
allow programmers to write their own hashing functions, often to work
in conjunction with this built-in notion of hashing. These end up
looking not too different from the hashing strategies we described
above. Therefore, some of that complexity is inescapable, especially
if a programmer wants structural rather than reference
equalityâ€”<wbr/>which they very often do.</p><p>In the rest of this material, we will therefore continue with the
simple hash function above, for multiple reasons. First, it is
sufficient to illustrate how hashing works. Second, in practice, when
built-in hashing does not suffice, we do write (more complex versions
of) functions like the above. And finally, because itâ€™s all laid bare,
itâ€™s easy for us to experiment with.</p></section><section class="SsectionLevel4" id="section 18.5.3"><h4 class="heading">18.5.3Â <a name="(part._eq-ord)"/>Equality and Ordering<a href="#(part._eq-ord)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>What weâ€™ve seen [<a href="sets-from-trees.html#%28part._sets-from-balanced-trees%29" data-pltdoc="x">A Fine Balance: Tree Surgery</a>] for the construction of
balanced binary search trees is that we need some way of putting elements in
order. In the examples we used numbers because theyâ€™re a very friendly
datatype: they have several properties that we take for granted. However, not
all data have these properties.</p><p>The critical property that numbers have is that they are orderable. This
follows because they are comparable, and the comparison is
ternary: it produces three answers, â€œless thanâ€, â€œequal toâ€, and
â€œgreater thanâ€.</p><p>However, not all data have this property. What are data that might not have
these properties? Actually, there are multiple possible properties here: Is
something orderable? Is something even comparable?</p><table cellspacing="0" cellpadding="0"><tr><td><p> </p></td><td><p>Â Â </p></td><td><p>Comparable</p></td><td><p>Â Â </p></td><td><p>Orderable</p></td></tr><tr><td><p>Numbers</p></td><td><p>Â Â </p></td><td><p>Yes (but not Roughnums!)</p></td><td><p>Â Â </p></td><td><p>Yes</p></td></tr><tr><td><p>Booleans</p></td><td><p>Â Â </p></td><td><p>Yes</p></td><td><p>Â Â </p></td><td><p>Yes</p></td></tr><tr><td><p>Data instances</p></td><td><p>Â Â </p></td><td><p>Yes</p></td><td><p>Â Â </p></td><td><p>Not by default</p></td></tr><tr><td><p>Roughnums</p></td><td><p>Â Â </p></td><td><p>No</p></td><td><p>Â Â </p></td><td><p>Yes</p></td></tr><tr><td><p>Functions</p></td><td><p>Â Â </p></td><td><p>Not really</p></td><td><p>Â Â </p></td><td><p>No</p></td></tr></table><p>Soâ€¦life is complicated.</p><p>That means you could potentially misuse a BBST on the wrong kind of
data. Ideally, we would want to know if weâ€™re doing this. In Pyretâ€™s type
system we chose not to build this in, but in some languages, the type system
actually lets you capture these properties.</p><p>In Haskell, for instance, thereâ€™s a mechanism called the type-class; in Java,
there are interfaces. They arenâ€™t really the same, but theyâ€™re useful to
conflate for our purposes. Only things that meet a particular interface or type
class provide certain operations. For instance, in Haskell, if you want to use
== or /= (not equal), you have to be in the Eq
type-class. Thus the comparable datatypes above would be part of
Eq. Similarly, thereâ€™s a type-class Ord, which ensures the
availability of (and requires the implementation of) operations like &lt;,
&gt;, &lt;=, and &gt;=. In Haskell, everything that is Ord
must also be Eq, i.e., Eq is weaker than Ord (things can
be Eq without being Ord). Pyretâ€™s Roughnums contradict thatâ€¦but
Haskell is okay with it. But if you try to compare two functions in Haskell,
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>(\x -&gt; x + 1) &lt; (\x -&gt; x)</p></td></tr></table><p>you get an error like
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>* No instance for (Ord (Integer -&gt; Integer))</p></td></tr><tr><td><p>Â Â Â Â arising from a use of `&lt;'</p></td></tr></table></section>&#13;
<h4 class="heading">18.5.1Â <a name="(part._hashing-values)"/><a name="(part._g~c3~b6del-encoding)"/>Converting Values to Ordered Values<a href="#(part._hashing-values)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In <a href="sets-from-trees.html" data-pltdoc="x">Making Sets Grow on Trees</a>, we noted that a single comparison needs
to eliminate an entire set of values. With numbers, we were able to
accomplish that easily: every bigger or smaller number was excluded by
a comparison. But what if the data in the set are not actually
numbers? Then we have to convert an arbitrary datum into a datatype that
permits such comparison. This is known as hashing.</p><p>A hash function consumes an arbitrary value and produces a comparable
representation of it (its hash)â€”<wbr/>most commonly (but not
strictly necessarily), a number. A hash function must naturally be
deterministic: a fixed value should always yield the same hash
(otherwise, we might conclude that an element in the set is not
actually in it, etc.). Particular uses may need additional properties,
as we discuss in <a href="#%28part._eq-ord%29" data-pltdoc="x">Equality and Ordering</a>.</p><p>Let us now consider how one can compute hashes.  If the input datatype
is a number, it can serve as its own hash. Comparison simply uses
numeric comparison (e.g., <code data-lang="pyret" class="sourceCode">&lt;</code>). Then, transitivity of <code data-lang="pyret" class="sourceCode">&lt;</code>
ensures that if an element \(A\) is less than another element \(B\),
then \(A\) is also less than all the other elements bigger than
\(B\).</p><p>Suppose instead the input is a string. We can of course use the
principle above for strings: e.g., replacing number inequality with
string inequality. Strings have a lexicographic (or
â€œalphabeticâ€) ordering that permit them to be treated similar to
numbers.</p><p>But what if we are handed more complex datatypes?</p><p>Before we answer that, consider that in practice numbers are more
efficient to compare than strings (since comparing two numbers is very
nearly constant time). Thus, although we could use strings directly,
it may be convenient to find a numeric representation of
strings. We convert each character of the string
into a number, e.g., using its
<a href="https://en.wikipedia.org/wiki/Code_point">code point</a>.
Based on that, here are two different hash functions:
</p><ol><li><p>Consider a list of primes as long as the string. Raise each
prime by the corresponding number, and multiply the result. For
instance, if the string is represented by the character codes
<code data-lang="pyret" class="sourceCode">[6, 4, 5]</code> (the first character has code <code data-lang="pyret" class="sourceCode">6</code>, the second
one <code data-lang="pyret" class="sourceCode">4</code>, and the third <code data-lang="pyret" class="sourceCode">5</code>), we get the hash
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-expt(2, 6) * num-expt(3, 4) * num-expt(5, 5)</code></pre><p>or <code data-lang="pyret" class="sourceCode">16200000</code>.</p></li><li><p>Simply add together all the character codes. For the above
example, this would correspond to the has
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">6 + 4 + 5</code></pre><p>or <code data-lang="pyret" class="sourceCode">15</code>.</p></li></ol><p>The first representation is invertible, using the
<a href="http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic">Fundamental Theorem of Arithmetic</a>:
given the resulting number, we can reconstruct the input unambiguously
(i.e., <code data-lang="pyret" class="sourceCode">16200000</code> can only map to the input above, and none other).
This is also known as the GÃ¶del encoding. This is
computationally expensive.
The second encoding is, of course, not invertible (e.g., simply
permute the characters and, by commutativity, the sum will be the
same), but computationally much cheaper. It is also easy to implement:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun hash-of(s :: String):
  fold({(a :: Number, b :: Number): a + b},
    0,
    string-to-code-points(s))
end

check:
  hash-of("Hello") is 500
  hash-of("World!") is 553
  hash-of("ğŸ´â€â˜ ï¸") is 195692
end</code></pre><p>Now let us consider more general datatypes. The principle of hashing
will be similar. If we have a datatype with several variants, we can
order the variants lexicographically, and use a numeric tag to
represent the variants, and recursively encode the datum and the
variant tag. For each field of a record, we need an ordering of the
fieldsâ€”<wbr/>the lexicographic ordering of the field names sufficesâ€”<wbr/>and
must hash their contents recursively; having done so, we get in effect
a string of numbers, which we have shown how to handle.</p><p>The critical thing to remember is that we donâ€™t actually need a
meaningful operation.Observe that GÃ¶del encodings
are not â€œmeaningfulâ€, either.  We donâ€™t actually care if a hash
function concludes that the hash of <code data-lang="pyret" class="sourceCode">4</code> is less than the hash of
<code data-lang="pyret" class="sourceCode">3</code>! All we need is a function that is
</p><ul><li><p>non-trivial: not everything should be equal; and</p></li><li><p>deterministic: every time we ask for a hash, we should get
the same answer.</p></li></ul><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why do we care about these two properties? Think about what would could go
wrong if each one was violated.</p></blockquote></blockquote>&#13;
<h4 class="heading">18.5.2Â <a name="(part._hash-in-practice)"/>Hashing in Practice<a href="#(part._hash-in-practice)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In practice, programmers do not want hash functions to do what we have
described above. While GÃ¶del encoding is extremely expensive, even
computing <code data-lang="pyret" class="sourceCode">hash-of</code> takes time linear in the size of a string,
which can get quite expensive if strings are large or we compute
hashes often or both.</p><p>Instead, many programming languages do something very pragmatic. They
need a value that can be compared for equality and ordering
[<a href="#%28part._eq-ord%29" data-pltdoc="x">Equality and Ordering</a>]. Integers, weâ€™ve already seen, already fit this
bill very nicely. But how to obtain an integer out of arbitrary
values, even datatype instances, quickly?</p><p>Simple: They just use the memory address of the datum. Every
value has a memory address, and the language can obtain it in constant
time by looking up the directory. Granted, these values may be
allocated anywhere with respect to each other, but thatâ€™s okayâ€”<wbr/>we
only want consistency, not â€œmeaningfulnessâ€.</p><p>In practice, however, things are not quite so simple.  For instance,
suppose we want two structurally equivalent values to have the same
hash. If they are allocated in different addresses, they will hash
differently. Therefore, many languages that use such a strategy also
allow programmers to write their own hashing functions, often to work
in conjunction with this built-in notion of hashing. These end up
looking not too different from the hashing strategies we described
above. Therefore, some of that complexity is inescapable, especially
if a programmer wants structural rather than reference
equalityâ€”<wbr/>which they very often do.</p><p>In the rest of this material, we will therefore continue with the
simple hash function above, for multiple reasons. First, it is
sufficient to illustrate how hashing works. Second, in practice, when
built-in hashing does not suffice, we do write (more complex versions
of) functions like the above. And finally, because itâ€™s all laid bare,
itâ€™s easy for us to experiment with.</p>&#13;
<h4 class="heading">18.5.3Â <a name="(part._eq-ord)"/>Equality and Ordering<a href="#(part._eq-ord)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>What weâ€™ve seen [<a href="sets-from-trees.html#%28part._sets-from-balanced-trees%29" data-pltdoc="x">A Fine Balance: Tree Surgery</a>] for the construction of
balanced binary search trees is that we need some way of putting elements in
order. In the examples we used numbers because theyâ€™re a very friendly
datatype: they have several properties that we take for granted. However, not
all data have these properties.</p><p>The critical property that numbers have is that they are orderable. This
follows because they are comparable, and the comparison is
ternary: it produces three answers, â€œless thanâ€, â€œequal toâ€, and
â€œgreater thanâ€.</p><p>However, not all data have this property. What are data that might not have
these properties? Actually, there are multiple possible properties here: Is
something orderable? Is something even comparable?</p><table cellspacing="0" cellpadding="0"><tr><td><p> </p></td><td><p>Â Â </p></td><td><p>Comparable</p></td><td><p>Â Â </p></td><td><p>Orderable</p></td></tr><tr><td><p>Numbers</p></td><td><p>Â Â </p></td><td><p>Yes (but not Roughnums!)</p></td><td><p>Â Â </p></td><td><p>Yes</p></td></tr><tr><td><p>Booleans</p></td><td><p>Â Â </p></td><td><p>Yes</p></td><td><p>Â Â </p></td><td><p>Yes</p></td></tr><tr><td><p>Data instances</p></td><td><p>Â Â </p></td><td><p>Yes</p></td><td><p>Â Â </p></td><td><p>Not by default</p></td></tr><tr><td><p>Roughnums</p></td><td><p>Â Â </p></td><td><p>No</p></td><td><p>Â Â </p></td><td><p>Yes</p></td></tr><tr><td><p>Functions</p></td><td><p>Â Â </p></td><td><p>Not really</p></td><td><p>Â Â </p></td><td><p>No</p></td></tr></table><p>Soâ€¦life is complicated.</p><p>That means you could potentially misuse a BBST on the wrong kind of
data. Ideally, we would want to know if weâ€™re doing this. In Pyretâ€™s type
system we chose not to build this in, but in some languages, the type system
actually lets you capture these properties.</p><p>In Haskell, for instance, thereâ€™s a mechanism called the type-class; in Java,
there are interfaces. They arenâ€™t really the same, but theyâ€™re useful to
conflate for our purposes. Only things that meet a particular interface or type
class provide certain operations. For instance, in Haskell, if you want to use
== or /= (not equal), you have to be in the Eq
type-class. Thus the comparable datatypes above would be part of
Eq. Similarly, thereâ€™s a type-class Ord, which ensures the
availability of (and requires the implementation of) operations like &lt;,
&gt;, &lt;=, and &gt;=. In Haskell, everything that is Ord
must also be Eq, i.e., Eq is weaker than Ord (things can
be Eq without being Ord). Pyretâ€™s Roughnums contradict thatâ€¦but
Haskell is okay with it. But if you try to compare two functions in Haskell,
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>(\x -&gt; x + 1) &lt; (\x -&gt; x)</p></td></tr></table><p>you get an error like
</p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p>* No instance for (Ord (Integer -&gt; Integer))</p></td></tr><tr><td><p>Â Â Â Â arising from a use of `&lt;'</p></td></tr></table>    
</body>
</html>