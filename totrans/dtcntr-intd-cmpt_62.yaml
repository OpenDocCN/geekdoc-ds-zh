- en: 18.6Â Sets as a Case StudyðŸ”—
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŽŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/sets-case-study.html](https://dcic-world.org/2025-08-27/sets-case-study.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Â Â Â Â [18.6.1Â Nature of the Data](#%28part._.Nature_of_the_.Data%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [18.6.2Â Nature of the Operations](#%28part._.Nature_of_the_.Operations%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [18.6.3Â Nature of the Guarantee](#%28part._.Nature_of_the_.Guarantee%29)
    |'
  prefs: []
  type: TYPE_TB
- en: We have spent a lot of time on sets. That is not only because they are useful
    in their own right, but also because they offer a window into a variety of possible
    designs. In particular, they illustrate several tradeoffs that we can make in
    the design of data structures, based on our needs.
  prefs: []
  type: TYPE_NORMAL
- en: There are several dimensions along which we can divide our designs.
  prefs: []
  type: TYPE_NORMAL
- en: 18.6.1Â Nature of the Data[ðŸ”—](#(part._.Nature_of_the_.Data) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the data cannot even be comparable for quality, then we canâ€™t construct sets
    out of them, because equality is central to the definition of a set.
  prefs: []
  type: TYPE_NORMAL
- en: If the data can be compared for equality but not for ordering, then we can only
    construct list-sets [[Representing Sets as Lists](sets-from-lists.html)], with
    their linear-time complexity. However, if we can hash the values [[Converting
    Values to Ordered Values](orderability.html#%28part._hashing-values%29)], then
    we can construct trees [[Making Sets Grow on Trees](sets-from-trees.html)] and
    hashtables [[Sets from Hashing and Arrays](hash-set-kv.html#%28part._hash-tables%29)].
    Trees give us logarithmic complexity for the most expensive atomic operations,
    while hashtables give us constant-to-linear complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 18.6.2Â Nature of the Operations[ðŸ”—](#(part._.Nature_of_the_.Operations) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another dimension of variation is the collection of operations we need. We
    began with a fairly ambitious, but standard, collection of operations [[<set-operations>](sets-from-lists.html#%28elem._set-operations%29)],
    but gradually ignored many of them. In particular, some interpretations of sets,
    like [Union-Find](union-find.html), achieve excellent complexity at the cost of
    most of these operations. [Bloom Filters](hash-set-kv.html#%28part._bloom-filters%29)
    provide another instance of this. There is a general computer science principle
    at work here: the fewer operations we need to support, the better we can (sometimes)
    make the complexity of the remaining ones.'
  prefs: []
  type: TYPE_NORMAL
- en: 18.6.3Â Nature of the Guarantee[ðŸ”—](#(part._.Nature_of_the_.Guarantee) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most subtly, there was another distinction: whether or not we needed reliable
    results. Most of our set representations are reliable. However, we also saw one
    situation [[Bloom Filters](hash-set-kv.html#%28part._bloom-filters%29)] where
    we intentionally abandoned complete reliability, replacing it with a statistical
    guarantee. In return, this gave us (potentially) much higher performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, sets provide a useful microcosm of computer science itself.
  prefs: []
  type: TYPE_NORMAL
- en: 18.6.1Â Nature of the Data[ðŸ”—](#(part._.Nature_of_the_.Data) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the data cannot even be comparable for quality, then we canâ€™t construct sets
    out of them, because equality is central to the definition of a set.
  prefs: []
  type: TYPE_NORMAL
- en: If the data can be compared for equality but not for ordering, then we can only
    construct list-sets [[Representing Sets as Lists](sets-from-lists.html)], with
    their linear-time complexity. However, if we can hash the values [[Converting
    Values to Ordered Values](orderability.html#%28part._hashing-values%29)], then
    we can construct trees [[Making Sets Grow on Trees](sets-from-trees.html)] and
    hashtables [[Sets from Hashing and Arrays](hash-set-kv.html#%28part._hash-tables%29)].
    Trees give us logarithmic complexity for the most expensive atomic operations,
    while hashtables give us constant-to-linear complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 18.6.2Â Nature of the Operations[ðŸ”—](#(part._.Nature_of_the_.Operations) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another dimension of variation is the collection of operations we need. We
    began with a fairly ambitious, but standard, collection of operations [[<set-operations>](sets-from-lists.html#%28elem._set-operations%29)],
    but gradually ignored many of them. In particular, some interpretations of sets,
    like [Union-Find](union-find.html), achieve excellent complexity at the cost of
    most of these operations. [Bloom Filters](hash-set-kv.html#%28part._bloom-filters%29)
    provide another instance of this. There is a general computer science principle
    at work here: the fewer operations we need to support, the better we can (sometimes)
    make the complexity of the remaining ones.'
  prefs: []
  type: TYPE_NORMAL
- en: 18.6.3Â Nature of the Guarantee[ðŸ”—](#(part._.Nature_of_the_.Guarantee) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most subtly, there was another distinction: whether or not we needed reliable
    results. Most of our set representations are reliable. However, we also saw one
    situation [[Bloom Filters](hash-set-kv.html#%28part._bloom-filters%29)] where
    we intentionally abandoned complete reliability, replacing it with a statistical
    guarantee. In return, this gave us (potentially) much higher performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, sets provide a useful microcosm of computer science itself.
  prefs: []
  type: TYPE_NORMAL
