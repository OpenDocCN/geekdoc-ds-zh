["```py\n[https://www.anaconda.com/distribution/](https://www.anaconda.com/distribution/)\n```", "```py\nprint('Yankees rule!')\nprint('But not in Boston!')\nprint('Yankees rule,', 'but not in Boston!')\n```", "```py\nYankees rule!\nBut not in Boston!\nYankees rule, but not in Boston!\n```", "```py\n3\nOut[1]: 3\n\n3+2\nOut[2]: 5\n\n3.0+2.0\nOut[3]: 5.0\n\n3!=2\nOut[4]: True\n```", "```py\n﻿type(3)\nOut[5]: int\n\ntype(3.0)\nOut[6]: float\n```", "```py\npi = 3\nradius = 11\narea = pi * (radius**2)\nradius = 14\n```", "```py\na = 3.14159    pi = 3.14159\nb = 11.2    diameter = 11.2\nc = a*(b**2)   area = pi*(diameter**2)\n```", "```py\nside = 1 #length of sides of a unit square\nradius = 1 #radius of a unit circle\n#subtract area of unit circle from area of unit square\narea_circle = pi*radius**2\narea_square = side*side\ndifference = area_square – area_circle\n```", "```py\n`x, y = 2, 3`\n```", "```py\nx, y = 2, 3\nx, y = y, x\nprint('x =', x)\nprint('y =', y)\n```", "```py\nx = 3\ny = 2\n```", "```py\n`if` *Boolean expression*`:              if` *Boolean expression*`:`\n    *block of code         * or  *         block of code*\n`else:`\n    *block of code*\n```", "```py\nif x%2 == 0:\n    print('Even')\nelse:\n    print('Odd')\nprint('Done with conditional')\n```", "```py\n﻿﻿﻿ ﻿x = 1111111111111111111111111111111 + 222222222222333222222222 +\\\n    3333333333333333333333333333333\n```", "```py`Long lines can also be wrapped using Python's implied line continuation. This is done with bracketing, i.e., parentheses, square brackets, and braces. For example,    ```", "```py    is interpreted as two lines (and therefore produces an “unexpected indent” syntax error whereas    ```", "```py    is interpreted as a single line because of the parentheses. Many Python programmers prefer using implied line continuations to using a backslash. Most commonly, programmers break long lines at commas or operators.    Returning to conditionals, when either the true block or the false block of a conditional contains another conditional, the conditional statements are said to be **nested**. The following code contains nested conditionals in both branches of the top-level `if` statement.    ```", "```py    The `elif` in the above code stands for “else if.”    It is often convenient to use a **compound Boolean expression** in the test of a conditional, for example,    ```", "```py    **Finger exercise:** Write a program that examines three variables—`x`, `y`, and `z`—and prints the largest odd number among them. If none of them are odd, it should print the smallest value of the three.    You can attack this exercise in a number of ways. There are eight separate cases to consider: they are all odd (one case), exactly two of them are odd (three cases), exactly one of them is odd (three cases), or none of them is odd (one case). So, a simple solution would involve a sequence of eight `if` statements, each with a single `print` statement:    ```", "```py    That gets the job done, but is rather cumbersome. Not only is it 16 lines of code, but the variables are repeatedly tested for oddness. The following code is both more elegant and more efficient:    ```", "```py    The code is based on a common programming paradigm. It starts by assigning a provisional value to a variable (`answer`), updating it when appropriate, and then printing the final value of the variable. Notice that it tests whether each variable is odd exactly once, and contains only a single print statement. This code is pretty much as well as we can do, since any correct program must check each variable for oddness and compare the values of the odd variables to find the largest of them.    Python supports **conditional expressions** as well as conditional statements. Conditional expressions are of the form    ```", "```py    If the condition evaluates to `True`, the value of the entire expression is `*expr1*`; otherwise it is `*expr2*`. For example, the statement    ```", "```py    sets `x` to the maximum of `y` and `z`. A conditional expression can appear any place an ordinary expression can appear, including within conditional expressions. So, for example,    ```", "```py    prints the maximum of `x`, `y`, and `z`.    Conditionals allow us to write programs that are more interesting than straight-line programs, but the class of branching programs is still quite limited. One way to think about the power of a class of programs is in terms of how long they can take to run. Assume that each line of code takes one unit of time to execute. If a straight-line program has `n` lines of code, it will take `n` units of time to run. What about a branching program with `n` lines of code? It might take less than `n` units of time to run, but it cannot take more, since each line of code is executed at most once.    A program for which the maximum running time is bounded by the length of the program is said to run in **constant time**. This does not mean that each time the program is run it executes the same number of steps. It means that there exists a constant, `k`, such that the program is guaranteed to take no more than `k` steps to run. This implies that the running time does not grow with the size of the input to the program.    Constant-time programs are limited in what they can do. Consider writing a program to tally the votes in an election. It would be truly surprising if one could write a program that could do this in a time that was independent of the number of votes cast. In fact, it is impossible to do so. The study of the intrinsic difficulty of problems is the topic of **computational complexity**. We will return to this topic several times in this book.    Fortunately, we need only one more programming language construct, iteration, to allow us write programs of arbitrary complexity. We get to that in Section 2.5.```", "```py`## 2.4 Strings and Input    Objects of type `str` are used to represent characters.[^(16)](#c2-fn-0008) Literals of type `str` can be written using either single or double quotes, e.g., `'abc'` or `\"abc\"`. The literal `'123'` denotes a string of three characters, not the number 123.    Try typing the following expressions in to the Python interpreter.    ```", "```py    The operator `+` is said to be **overloaded** because it has different meanings depending upon the types of the objects to which it is applied. For example, the operator `+` means addition when applied to two numbers and concatenation when applied to two strings. The operator `*` is also over­loaded. It means what you expect it to mean when its operands are both numbers. When applied to an `int` and a `str`, it is a **repetition operator**—the expression `n*s`, where `n` is an `int` and `s` is a `str`, evaluates to a `str` with `n` repeats of `s`. For example, the expression `2*'John'` has the value `'JohnJohn'`. There is a logic to this. Just as the mathematical expression `3*2` is equivalent to `2+2+2`, the expression `3*'a'` is equivalent to `'a'+'a'+'a'`.    Now try typing    ```", "```py    Each of these lines generates an error message. The first line produces the message    ```", "```py    Because `new_id` is not a literal of any type, the interpreter treats it as a name. However, since that name is not bound to any object, attempting to use it causes a runtime error. The code `'a'*'a'` produces the error message    ```", "```py    That **type checking** exists is a good thing. It turns careless (and sometimes subtle) mistakes into errors that stop execution, rather than errors that lead programs to behave in mysterious ways. The type checking in Python is not as strong as in some other programming languages (e.g., Java), but it is better in Python 3 than in Python 2\\. For example, it is clear what `<` should mean when it is used to compare two strings or two numbers. But what should the value of `'4' < 3` be`?` Rather arbitrarily, the designers of Python 2 decided that it should be `False`, because all numeric values should be less than all values of type `str`. The designers of Python 3, and most other modern languages, decided that since such expressions don't have an obvious meaning, they should generate an error message.    Strings are one of several sequence types in Python. They share the following operations with all sequence types.    *   The **length** of a string can be found using the `len` function. For example, the value of `len('abc')` is `3`. *   **Indexing** can be used to extract individual characters from a string. In Python, all indexing is zero-based. For example, typing `'abc'[0]` into the interpreter will cause it to display the string `'a'`. Typing `'abc'[3]` will produce the error message `IndexError: string index out of range`. Since Python uses `0` to indicate the first element of a string, the last element of a string of length 3 is accessed using the index `2`. Negative numbers are used to index from the end of a string. For example, the value of `'abc'[‑1]` is `'c'`. *   **Slicing** is used to extract substrings of arbitrary length. If `s` is a string, the expression `s[start:end]` denotes the substring of `s` that starts at index `start` and ends at index `end-1`. For example, `'abc'[1:3]` evaluates to `'bc'`. Why does it end at index `end-1` rather than `end`? So that expressions such as `'abc'[0:len('abc')]` have the value you might expect. If the value before the colon is omitted, it defaults to `0`. If the value after the colon is omitted, it defaults to the length of the string. Consequently, the expression `'abc'[:]` is semantically equivalent to the more verbose `'abc'[0:len('abc')]`. It is also possible to supply a third argument to select a non-contiguous slice of a string. For example, the value of the expression `'`﻿`123456789'[0:8:2]` is the string ﻿`'1357'`.    It is often convenient to convert objects of other types to strings using the `str` function. Consider, for example, the code    ```", "```py    which prints    ```", "```py    The first print statement inserts a space between `50` and `%` because Python automatically inserts a space between the arguments to `print`. The second print statement produces a more appropriate output by combining the `50` and the `%` into a single argument of type `str`.    **Type conversions** (also called **type casts**) are used often in Python code. We use the name of a type to convert values to that type. So, for example, the value of `int('3')*4` is `12`. When a `float` is converted to an `int`, the number is truncated (not rounded), e.g., the value of `int(3.9)` is the `int` `3`.    Returning to the output of our print statements, you might be wondering about that `.0` at the end of the first number printed. That appears because `1/2` is a floating-point number, and the product of an `int` and a `float` is a `float`. It can be avoided by converting `num*fraction` to an `int`. The code    ```", "```py    prints `15000000 is 50.0% of 30000000`.    Python 3.6 introduced an alternative, more compact, way to build string expressions. An **f-string** consists of the character `f` (or `F`) following by a special kind of string literal called a **formatted string literal**. Formatted string literals contain both sequences of characters (like other string literals) and expressions bracketed by curly braces. These expressions are evaluated at runtime and automatically converted to strings. The code    ```", "```py    produces the same output as the previous, more verbose, print statement. If you want to include a curly brace in the string denoted by an f-string, use two braces. E.g., ﻿`print(f'{{{3*5}}}')` prints `﻿{15}`.    The expression inside an f-string can contain modifiers that control the appearance of the output string.[^(17)](#c2-fn-0009) These modifiers are separated from the expression denoting the value to be modified by a colon. For example, the f-string ﻿ `﻿f'{3.14159:.2f}'` evaluates to the string `﻿'3.14'` because the modifier `.2f` instructs Python to truncate the string representation of a floating-point number to two digits after the decimal point. And the statement    ```", "```py    prints ﻿`15,000,000 is 50.0% of 30,000,000` because the `,` modifier instructs Python to use commas as thousands separators. We will introduce other modifiers as convenient later in the book.    ### 2.4.1 Input    Python 3 has a function, `**input**`, that can be used to get input directly from a user. The `input` function takes a string as an argument and displays it as a prompt in the shell. The function then waits for the user to type something and press the `enter` key. The line typed by the user is treated as a string and becomes the value returned by the function.    Executing the code `name = input('Enter your name: ')` will display the line    ```", "```py    in the console window. If you then type `George Washington` and press `enter`, the string `'George Washington'` will be assigned to the variable `name`. If you then execute `print('Are you really', name, '?')`, the line    ```", "```py    would be displayed. Notice that the `print` statement introduces a space before the “`?`”. It does this because when `print` is given multiple arguments, it places a space between the values associated with the arguments. The space could be avoided by executing `print('Are you really ' + name + '?')` or ﻿`print(f'Are you really {name}?')`, each of which produces a single string and passes that string as the only argument to `print`.    Now consider the code    ```", "```py    This code will always print    ```", "```py    because `input` always returns an object of type `str`, even if the user has entered something that looks like an integer. For example, if the user had entered `3`, `n` would be bound to the str `'3'` not the int `3`. So, the value of the expression `n*4` would be `'3333'` rather than `12`. The good news is that whenever a string is a valid literal of some type, a type conversion can be applied to it.    **Finger exercise:** Write code that asks the user to enter their birthday in the form mm/dd/yyyy, and then prints a string of the form `‘You were born in the year yyyy.’`    ### 2.4.2 A Digression about Character Encoding    For many years most programming languages used a standard called ASCII for the internal representation of characters. This standard included `128` characters, plenty for representing the usual set of characters appearing in English-language text—but not enough to cover the characters and accents appearing in all the world's languages.    The **Unicode** standard is a character coding system designed to support the digital processing and display of the written texts of all languages. The standard contains more than `120,000` characters—covering `129` modern and historic scripts and multiple symbol sets. The Unicode standard can be implemented using different internal character encodings. You can tell Python which encoding to use by inserting a comment of the form    ```", "```py    as the first or second line of your program. For example,    ```", "```py    instructs Python to use UTF-8, the most frequently used character encoding for webpages.[^(18)](#c2-fn-0010) If you don't have such a comment in your program, most Python implementations will default to UTF-8.    When using UTF-8, you can, text editor permitting, directly enter code like    ```", "```py    which will print    ```", "```py    You might be wondering how I managed to type the string `'`क्या आप अंग्रेज़ी बोलते हैं?`'`. I didn't. Because most of the web uses UTF-8, I was able to cut the string from a webpage and paste it directly into my program. There are ways to directly enter Unicode characters from a keyboard, but unless you have a special keyboard, they are all rather cumbersome.    ## 2.5 While Loops    Near the end of Section 2.3, we mentioned that most computational tasks cannot be accomplished using branching programs. Consider, for example, writing a program that asks for the number of X's. You might think about writing something like    ```", "```py    But it would quickly become apparent that you would need as many conditionals as there are positive integers—and there are an infinite number of those. What you want to write is a program that looks like (the following is **pseudocode**, not Python)    ```", "```py    When we want a program to do the same thing many times, we can use **iteration**. A generic iteration (also called **looping**) mechanism is shown in the box in [Figure 2-6](#c2-fig-0006). Like a conditional statement, it begins with a test. If the test evaluates to `True`, the program executes the **loop** body once, and then goes back to reevaluate the test. This process is repeated until the test evaluates to `False`, after which control passes to the code following the iteration statement.  ![c2-fig-0006.jpg](../images/c2-fig-0006.jpg)    [Figure 2-6](#c2-fig-0006a) Flowchart for iteration      We can write the kind of loop depicted in [Figure 2-6](#c2-fig-0006) using a **while** statement. Consider the code in [Figure 2-7](#c2-fig-0007).  ![c2-fig-0007.jpg](../images/c2-fig-0007.jpg)    [Figure 2-7](#c2-fig-0007a) Squaring an integer, the hard way      The code starts by binding the variable `x` to the integer `3`. It then proceeds to square `x` by using repetitive addition. The table in [Figure 2-8](#c2-fig-0008) shows the value associated with each variable each time the test at the start of the loop is reached. We constructed the table by **hand-simulating** the code, i.e., we pretended to be a Python interpreter and executed the program using pencil and paper. Using pencil and paper might seem quaint, but it is an excellent way to understand how a program behaves.[^(19)](#c2-fn-0011)  ![c2-fig-0008.jpg](../images/c2-fig-0008.jpg)    [Figure 2-8](#c2-fig-0008a) Hand simulation of a small program      The fourth time the test is reached, it evaluates to `False` and flow of control proceeds to the `print` statement following the loop. For what values of `x` will this program terminate? There are three cases to consider: `x == 0`, `x > 0`, and `x < 0`.    Suppose `x == 0`. The initial value of num_`iterations` will also be `0`, and the loop body will never be executed.    Suppose `x > 0`. The initial value of `num_iterations` will be less than `x`, and the loop body will be executed at least once. Each time the loop body is executed, the value of `num_iterations` is increased by exactly `1`. This means that since `num_iterations` started out less than `x`, after some finite number of iterations of the loop, num_`iterations` will equal `x`. At this point the loop test evaluates to `False`, and control proceeds to the code following the `while` statement.    Suppose `x < 0`. Something very bad happens. Control will enter the loop, and each iteration will move `num_iterations` farther from `x` rather than closer to it. The program will therefore continue executing the loop forever (or until something else bad, e.g., an overflow error, occurs). How might we remove this flaw in the program? Changing the test to `num_iterations < abs(x)` almost works. The loop terminates, but it prints a negative value. If the assignment statement inside the loop is also changed, to `ans = ans + abs(x)`, the code works properly.    **Finger exercise:** Replace the comment in the following code with a `while` loop.    ```", "```py    It is sometimes convenient to exit a loop without testing the loop condition. Executing a **break** statement terminates the loop in which it is contained and transfers control to the code immediately following the loop. For example, the code    ```", "```py    prints    ```", "```py    If a `break` statement is executed inside a nested loop (a loop inside another loop), the break will terminate the inner loop.    **Finger exercise:** Write a program that asks the user to input 10 integers, and then prints the largest odd number that was entered. If no odd number was entered, it should print a message to that effect.    ## 2.6 For Loops and Range    The `while` loops we have used so far are highly stylized, often iterating over a sequence of integers. Python provides a language mechanism, the `**for**` **loop**, that can be used to simplify programs containing this kind of iteration.    The general form of a `for` statement is (recall that the words in italics are descriptions of what can appear, not actual code):    ```", "```py    The variable following `for` is bound to the first value in the sequence, and the code block is executed. The variable is then assigned the second value in the sequence, and the code block is executed again. The process continues until the sequence is exhausted or a `break` statement is executed within the code block. For example, the code    ```", "```py    will print `91`. The expression (77, 11, 3) is a **tuple**. We discuss tuples in detail in Section 5\\. For now, just think of a tuple as a sequence of values.    The sequence of values bound to *variable* is most commonly generated using the built-in function `**range**`, which returns a series of integers. The `range` function takes three integer arguments: `start`, `stop`, and `step`. It produces the progression `start, start + step, start + 2*step,` etc. If `step` is positive, the last element is the largest integer such that (`start + i*step)` is strictly less than `stop`. If `step` is negative, the last element is the smallest integer such that (`start + i*step)` is greater than `stop`. For example, the expression `range(5, 40, 10)` yields the sequence `5, 15, 25, 35`, and the expression `range(40, 5, -10)` yields the sequence `40, 30, 20, 10`.    If the first argument to `range` is omitted, it defaults to `0`, and if the last argument (the step size) is omitted, it defaults to `1`. For example, `range(0, 3)` and `range(3)` both produce the sequence `0, 1, 2`. The numbers in the progression are generated on an “as needed” basis, so even expressions such as `range(1000000)` consume little memory. We will discuss `range` in more depth in Section 5.2.    Consider the code    ```", "```py    It prints    ```", "```py    The code in [Figure 2-9](#c2-fig-0009) reimplements the algorithm in [Figure 2-7](#c2-fig-0007) for squaring an integer (corrected so that it works for negative numbers). Notice that unlike the `while` loop implementation, the number of iterations is not controlled by an explicit test, and the index variable `num_iterations` is not explicitly incremented.  ![c2-fig-0009.jpg](../images/c2-fig-0009.jpg)    [Figure 2-9](#c2-fig-0009a) Using a `for` statement      Notice that the code in [Figure 2-9](#c2-fig-0009) does not change the value of `num_iterations` within the body of the `for` loop. This is typical, but not necessary, which raises the question of what happens if the index variable is modified within the `for` loop. Consider    ```", "```py    Do you think that it will print `0, 0, 1, 0`, and then halt? Or do you think it will print `0` over and over again?    The answer is `0, 0, 1, 0`. Before the first iteration of the `for` loop, the `range` function is evaluated and the first value in the sequence it yields is assigned to the index variable, `i`. At the start of each subsequent iteration of the loop, `i` is assigned the next value in the sequence. When the sequence is exhausted, the loop terminates. The above `for` loop is equivalent to the code    ```", "```py    Notice, by the way, that code with the `while` loop is considerably more cumbersome than the `for` loop. The `for` loop is a convenient linguistic mechanism.    Now, what do you think    ```", "```py    prints? Just `0`, because the arguments to the `range` function in the line with `for` are evaluated just before the first iteration of the loop, and not reevaluated for subsequent iterations.    Now, let's see how often things are evaluated when we nest loops. Consider    ```", "```py    How many times is each of the two loops executed? We already saw that the `range(x)` controlling the outer loop is evaluated the first time it is reached and not reevaluated for each iteration, so there are four iterations of the outer loop. That implies that the inner `for` loop is reached four times. The first time it is reached, the variable x = 4, so there will be four iterations. However, the next three times it is reached, x = 2, so there will be two iterations each time. Consequently, if you run    ```", "```py    it prints    ```", "```py    The `for` statement can be used in conjunction with the `**in**` **operator** to conveniently iterate over characters of a string. For example,    ```", "```py    sums the digits in the string denoted by the literal `'12345678'` and prints the total.    **Finger exercise:** Write a program that prints the sum of the prime numbers greater than 2 and less than 1000\\. Hint: you probably want to use a `for` loop that is a primality test nested inside a `for` loop that iterates over the odd integers between 3 and 999\\.    ## 2.7 Style Matters    Much of this book is devoted to helping you learn a programming language. But knowing a language and knowing how to use a language well are two different things. Consider the following two sentences:    *“Everybody knows that if a man is* *unmarried and has a lot of money, he* *needs to get married.”*    *“It is a truth universally acknowledged, that a single man in possession of a good fortune, must be in want of a wife.”*[^(20)](#c2-fn-0012)    Each is a proper English sentence, and each means approximately the same thing. But they are not equally compelling, and perhaps not equally easy to understand. Just as style matters when writing in English, style matters when writing in Python. However, while having a distinctive voice might be an asset for a novelist, it is not an asset for a programmer. The less time readers of a program have to spend thinking about things irrelevant to the meaning of the code, the better. That's why good programmers follow coding conventions designed to make programs easy to understand, rather than fun to read.    Most Python programmers follow the conventions laid out in the **PEP 8** **style guide**.[^(21)](#c2-fn-0013) Like all sets of conventions, some of its prescriptions are arbitrary. For example, it prescribes using four spaces for indents. Why four spaces and not three or five? No particularly good reason. But if everybody uses the same number of spaces, it is easier to read (and perhaps combine) code written by different people. More generally, if everyone uses the same set of conventions when writing Python, readers can concentrate on understanding the semantics of the code rather than wasting mental cycles assimilating stylistic decisions.    The most important conventions have to do with naming. We have already discussed the importance of using variable names that convey the meaning of the variable. Noun phrases work well for this. For example, we used the name `num_iterations` for a variable denoting the number of iterations. When a name includes multiple words, the convention in Python is to use an underscore (`_)` to separate the words. Again, this convention is arbitrary. Some programmers prefer to use what is often called camelCase, e.g., `numIterations`—arguing that it is faster to type and uses less space.    There are also some conventions for single-character variable names. The most important is to avoid using a lowercase L or uppercase I (which are easily confused with the number one) or an uppercase O (which is easily confused with the number zero).    That's enough about conventions for now. We will return to the topic as we introduce various aspects of Python.    We have now covered pretty much everything about Python that you need to know to start writing interesting programs that deal with numbers and strings. In the next chapter, we take a short break from learning Python, and use what you have already learned to solve some simple problems.    ## 2.8 Terms Introduced in Chapter    *   low-level language *   high-level language *   interpreted language *   compiled language *   source code *   machine code *   Python *   integrated development environment (IDE) *   Anaconda *   Spyder *   IPython console *   shell *   program (script) *   command (statement) *   object *   type *   scalar object *   non-scalar object *   literal *   floating point *   bool *   None *   operator *   expression *   value *   shell prompt *   variable *   binding *   assignment *   reserved word *   comment (in code) *   straight-line program *   branching program *   conditional *   indentation (in Python) *   nested statement *   compound expression *   constant time *   computational complexity *   conditional expression *   strings *   overloaded operator *   repetition operator *   type checking *   indexing *   slicing *   type conversion (casting) *   formatted string expression *   input *   Unicode *   iteration (looping) *   pseudocode *   while loop *   hand simulation *   break *   for loop *   tuple *   range *   in operator *   PEP 8 style guide```"]