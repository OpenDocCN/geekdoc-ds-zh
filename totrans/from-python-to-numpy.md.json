["```py\n$ rst2html.py --link-stylesheet --cloak-email-addresses \\\n                  --toc-top-backlinks --stylesheet=book.css \\\n                  --stylesheet-dirs=. book.rst book.html\n\n```", "```py\nimport numpy as np\n    import scipy as sp\n    import matplotlib.pyplot as plt\n\n```", "```py\nclass RandomWalker:\n        def __init__(self):\n            self.position = 0\n\n        def walk(self, n):\n            self.position = 0\n            for i in range(n):\n                yield self.position\n                self.position += 2*random.randint(0, 1) - 1\n\n    walker = RandomWalker()\n    walk = [position for position in walker.walk(1000)]\n\n```", "```py\n>>> from tools import timeit\n    >>> walker = RandomWalker()\n    >>> timeit(\"[position for position in walker.walk(n=10000)]\", globals())\n    10 loops, best of 3: 15.7 msec per loop\n\n```", "```py\ndef random_walk(n):\n        position = 0\n        walk = [position]\n        for i in range(n):\n            position += 2*random.randint(0, 1)-1\n            walk.append(position)\n        return walk\n\n    walk = random_walk(1000)\n\n```", "```py\n>>> from tools import timeit\n    >>> timeit(\"random_walk(n=10000)\", globals())\n    10 loops, best of 3: 15.6 msec per loop\n\n```", "```py\ndef random_walk_faster(n=1000):\n        from itertools import accumulate\n        # Only available from Python 3.6\n        steps = random.choices([-1,+1], k=n)\n        return [0]+list(accumulate(steps))\n\n     walk = random_walk_faster(1000)\n\n```", "```py\n>>> from tools import timeit\n    >>> timeit(\"random_walk_faster(n=10000)\", globals())\n    10 loops, best of 3: 2.21 msec per loop\n\n```", "```py\ndef random_walk_fastest(n=1000):\n        # No 's' in numpy choice (Python offers choice & choices)\n        steps = np.random.choice([-1,+1], n)\n        return np.cumsum(steps)\n\n    walk = random_walk_fastest(1000)\n\n```", "```py\n>>> from tools import timeit\n    >>> timeit(\"random_walk_fastest(n=10000)\", globals())\n    1000 loops, best of 3: 14 usec per loop\n\n```", "```py\ndef function_1(seq, sub):\n        return [i for i in range(len(seq) - len(sub)) if seq[i:i+len(sub)] == sub]\n\n    def function_2(seq, sub):\n        target = np.dot(sub, sub)\n        candidates = np.where(np.correlate(seq, sub, mode='valid') == target)[0]\n        check = candidates[:, np.newaxis] + np.arange(len(sub))\n        mask = np.all((np.take(seq, check) == sub), axis=-1)\n        return candidates[mask]\n\n```", "```py\n>>> Z = np.ones(4*1000000, np.float32)\n    >>> Z[...] = 0\n\n```", "```py\n>>> timeit(\"Z.view(np.float16)[...] = 0\", globals())\n    100 loops, best of 3: 2.72 msec per loop\n    >>> timeit(\"Z.view(np.int16)[...] = 0\", globals())\n    100 loops, best of 3: 2.77 msec per loop\n    >>> timeit(\"Z.view(np.int32)[...] = 0\", globals())\n    100 loops, best of 3: 1.29 msec per loop\n    >>> timeit(\"Z.view(np.float32)[...] = 0\", globals())\n    100 loops, best of 3: 1.33 msec per loop\n    >>> timeit(\"Z.view(np.int64)[...] = 0\", globals())\n    100 loops, best of 3: 874 usec per loop\n    >>> timeit(\"Z.view(np.float64)[...] = 0\", globals())\n    100 loops, best of 3: 865 usec per loop\n    >>> timeit(\"Z.view(np.complex128)[...] = 0\", globals())\n    100 loops, best of 3: 841 usec per loop\n    >>> timeit(\"Z.view(np.int8)[...] = 0\", globals())\n    100 loops, best of 3: 630 usec per loop\n\n```", "```py\nZ = np.arange(9).reshape(3,3).astype(np.int16)\n\n```", "```py\n>>> print(Z.itemsize)\n    2 >>> print(Z.shape)\n    (3, 3) >>> print(Z.ndim)\n    2\n\n```", "```py\n>>> strides = Z.shape[1]*Z.itemsize, Z.itemsize\n    >>> print(strides)\n    (6, 2) >>> print(Z.strides)\n    (6, 2)\n\n```", "```py\noffset_start = 0\n    for i in range(ndim):\n        offset_start += strides[i]*index[i]\n    offset_end = offset_start + Z.itemsize\n\n```", "```py\n>>> Z = np.arange(9).reshape(3,3).astype(np.int16)\n    >>> index = 1,1\n    >>> print(Z[index].tobytes())\n    b'\\x04\\x00'\n    >>> offset = 0\n    >>> for i in range(Z.ndim):\n    ...     offset + = Z.strides[i]*index[i]\n    >>> print(Z.tobytes()[offset_start:offset_end]\n    b'\\x04\\x00'\n\n```", "```py\n               shape[1]\n                     (=3)\n                ┌───────────┐\n\n             ┌  ┌───┬───┬───┐  ┐\n             │  │ 0 │ 1 │ 2 │  │\n             │  ├───┼───┼───┤  │\n    shape[0] │  │ 3 │ 4 │ 5 │  │ len(Z)\n     (=3)    │  ├───┼───┼───┤  │  (=3)\n             │  │ 6 │ 7 │ 8 │  │\n             └  └───┴───┴───┘  ┘\n\n```", "```py\n┌───┬───┬───┬───┬───┬───┬───┬───┬───┐\n    │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │\n    └───┴───┴───┴───┴───┴───┴───┴───┴───┘\n\n    └───────────────────────────────────┘\n                   Z.size\n                    (=9)\n\n```", "```py\n                         strides[1]\n                               (=2)\n                      ┌─────────────────────┐\n\n              ┌       ┌──────────┬──────────┐ ┐\n              │ p+00: │ 00000000 │ 00000000 │ │\n              │       ├──────────┼──────────┤ │\n              │ p+02: │ 00000000 │ 00000001 │ │ strides[0]\n              │       ├──────────┼──────────┤ │   (=2x3)\n              │ p+04  │ 00000000 │ 00000010 │ │\n              │       ├──────────┼──────────┤ ┘\n              │ p+06  │ 00000000 │ 00000011 │\n              │       ├──────────┼──────────┤\n    Z.nbytes  │ p+08: │ 00000000 │ 00000100 │\n    (=3x3x2)  │       ├──────────┼──────────┤\n              │ p+10: │ 00000000 │ 00000101 │\n              │       ├──────────┼──────────┤\n              │ p+12: │ 00000000 │ 00000110 │\n              │       ├──────────┼──────────┤\n              │ p+14: │ 00000000 │ 00000111 │\n              │       ├──────────┼──────────┤\n              │ p+16: │ 00000000 │ 00001000 │\n              └       └──────────┴──────────┘\n\n                      └─────────────────────┘\n                            Z.itemsize\n                         Z.dtype.itemsize\n                               (=2)\n\n```", "```py\nV = Z[::2,::2]\n\n```", "```py\n               shape[1]\n                     (=2)\n                ┌───────────┐\n\n             ┌  ┌───┬╌╌╌┬───┐  ┐\n             │  │ 0 │   │ 2 │  │            ┌───┬───┐\n             │  ├───┼╌╌╌┼───┤  │            │ 0 │ 2 │\n    shape[0] │  ╎   ╎   ╎   ╎  │ len(Z)  →  ├───┼───┤\n     (=2)    │  ├───┼╌╌╌┼───┤  │  (=2)      │ 6 │ 8 │\n             │  │ 6 │   │ 8 │  │            └───┴───┘\n             └  └───┴╌╌╌┴───┘  ┘\n\n```", "```py\n┌───┬╌╌╌┬───┬╌╌╌┬╌╌╌┬╌╌╌┬───┬╌╌╌┬───┐       ┌───┬───┬───┬───┐\n    │ 0 │   │ 2 │   ╎   ╎   │ 6 │   │ 8 │   →   │ 0 │ 2 │ 6 │ 8 │\n    └───┴╌╌╌┴───┴╌╌╌┴╌╌╌┴╌╌╌┴───┴╌╌╌┴───┘       └───┴───┴───┴───┘\n    └─┬─┘   └─┬─┘           └─┬─┘   └─┬─┘\n      └───┬───┘               └───┬───┘\n          └───────────┬───────────┘\n                   Z.size\n                    (=4)\n\n```", "```py\n              ┌        ┌──────────┬──────────┐ ┐             ┐\n                ┌─┤  p+00: │ 00000000 │ 00000000 │ │             │\n                │ └        ├──────────┼──────────┤ │ strides[1]  │\n              ┌─┤    p+02: │          │          │ │   (=4)      │\n              │ │ ┌        ├──────────┼──────────┤ ┘             │\n              │ └─┤  p+04  │ 00000000 │ 00000010 │               │\n              │   └        ├──────────┼──────────┤               │ strides[0]\n              │      p+06: │          │          │               │   (=12)\n              │            ├──────────┼──────────┤               │\n    Z.nbytes ─┤      p+08: │          │          │               │\n      (=8)    │            ├──────────┼──────────┤               │\n              │      p+10: │          │          │               │\n              │   ┌        ├──────────┼──────────┤               ┘\n              │ ┌─┤  p+12: │ 00000000 │ 00000110 │\n              │ │ └        ├──────────┼──────────┤\n              └─┤    p+14: │          │          │\n                │ ┌        ├──────────┼──────────┤\n                └─┤  p+16: │ 00000000 │ 00001000 │\n                  └        └──────────┴──────────┘\n\n                           └─────────────────────┘\n                                 Z.itemsize\n                              Z.dtype.itemsize\n                                    (=2)\n\n```", "```py\n>>> Z = np.zeros(9)\n    >>> Z_view = Z[:3]\n    >>> Z_view[...] = 1\n    >>> print(Z)\n    [ 1\\.  1\\.  1\\.  0\\.  0\\.  0\\.  0\\.  0\\.  0.] >>> Z = np.zeros(9)\n    >>> Z_copy = Z[[0,1,2]]\n    >>> Z_copy[...] = 1\n    >>> print(Z)\n    [ 0\\.  0\\.  0\\.  0\\.  0\\.  0\\.  0\\.  0\\.  0.]\n\n```", "```py\n>>> Z = np.zeros(9)\n    >>> index = [0,1,2]\n    >>> Z[index] = 1\n    >>> print(Z)\n    [ 1\\.  1\\.  1\\.  0\\.  0\\.  0\\.  0\\.  0\\.  0.]\n\n```", "```py\n>>> Z = np.random.uniform(0,1,(5,5))\n    >>> Z1 = Z[:3,:]\n    >>> Z2 = Z[[0,1,2], :]\n    >>> print(np.allclose(Z1,Z2))\n    True >>> print(Z1.base is Z)\n    True >>> print(Z2.base is Z)\n    False >>> print(Z2.base is None)\n    True\n\n```", "```py\n>>> Z = np.zeros((5,5))\n    >>> Z.ravel().base is Z\n    True >>> Z[::2,::2].ravel().base is Z\n    False >>> Z.flatten().base is Z\n    False\n\n```", "```py\n>>> X = np.ones(10, dtype=np.int)\n    >>> Y = np.ones(10, dtype=np.int)\n    >>> A = 2*X + 2*Y\n\n```", "```py\n>>> X = np.ones(10, dtype=np.int)\n    >>> Y = np.ones(10, dtype=np.int)\n    >>> np.multiply(X, 2, out=X)\n    >>> np.multiply(Y, 2, out=Y)\n    >>> np.add(X, Y, out=X)\n\n```", "```py\n>>> X = np.ones(1000000000, dtype=np.int)\n    >>> Y = np.ones(1000000000, dtype=np.int)\n    >>> timeit(\"X = X + 2.0*Y\", globals())\n    100 loops, best of 3: 3.61 ms per loop >>> timeit(\"X = X + 2*Y\", globals())\n    100 loops, best of 3: 3.47 ms per loop >>> timeit(\"X += 2*Y\", globals())\n    100 loops, best of 3: 2.79 ms per loop >>> timeit(\"np.add(X, Y, out=X); np.add(X, Y, out=X)\", globals())\n    1000 loops, best of 3: 1.57 ms per loop\n\n```", "```py\n>>> Z1 = np.arange(10)\n    >>> Z2 = Z1[1:-1:2]\n\n```", "```py\n   ╌╌╌┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬╌╌\n    Z1    │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │\n       ╌╌╌┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴╌╌\n       ╌╌╌╌╌╌╌┬───┬╌╌╌┬───┬╌╌╌┬───┬╌╌╌┬───┬╌╌╌╌╌╌╌╌╌╌\n    Z2        │ 1 │   │ 3 │   │ 5 │   │ 7 │\n       ╌╌╌╌╌╌╌┴───┴╌╌╌┴───┴╌╌╌┴───┴╌╌╌┴───┴╌╌╌╌╌╌╌╌╌╌\n\n```", "```py\n>>> print(Z2.base is Z1)\n    True\n\n```", "```py\n>>> step = Z2.strides[0] // Z1.strides[0]\n    >>> print(step)\n    2\n\n```", "```py\n  byte_bounds(Z1)[0]                  byte_bounds(Z1)[-1]\n              ↓                                   ↓\n       ╌╌╌┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬╌╌\n    Z1    │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │\n       ╌╌╌┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴╌╌\n\n          byte_bounds(Z2)[0]      byte_bounds(Z2)[-1]\n                  ↓                       ↓\n       ╌╌╌╌╌╌╌┬───┬╌╌╌┬───┬╌╌╌┬───┬╌╌╌┬───┬╌╌╌╌╌╌╌╌╌╌\n    Z2        │ 1 │   │ 3 │   │ 5 │   │ 7 │\n       ╌╌╌╌╌╌╌┴───┴╌╌╌┴───┴╌╌╌┴───┴╌╌╌┴───┴╌╌╌╌╌╌╌╌╌╌\n\n```", "```py\n>>> offset_start = np.byte_bounds(Z2)[0] - np.byte_bounds(Z1)[0]\n    >>> print(offset_start) # bytes\n    8\n\n    >>> offset_stop = np.byte_bounds(Z2)[-1] - np.byte_bounds(Z1)[-1]\n    >>> print(offset_stop) # bytes\n    -16\n\n```", "```py\n>>> start = offset_start // Z1.itemsize\n    >>> stop = Z1.size + offset_stop // Z1.itemsize\n    >>> print(start, stop, step)\n    1, 8, 2\n\n```", "```py\n>>> print(np.allclose(Z1[start:stop:step], Z2))\n    True\n\n```", "```py\ndef add_python(Z1,Z2):\n        return [z1+z2 for (z1,z2) in zip(Z1,Z2)]\n\n```", "```py\ndef add_numpy(Z1,Z2):\n        return np.add(Z1,Z2)\n\n```", "```py\n>>> Z1 = random.sample(range(1000), 100)\n    >>> Z2 = random.sample(range(1000), 100)\n    >>> timeit(\"add_python(Z1, Z2)\", globals())\n    1000 loops, best of 3: 68 usec per loop\n    >>> timeit(\"add_numpy(Z1, Z2)\", globals())\n    10000 loops, best of 3: 1.14 usec per loop\n\n```", "```py\n>>> Z1 = [[1, 2], [3, 4]]\n    >>> Z2 = [[5, 6], [7, 8]]\n    >>> Z1 + Z2\n    [[1, 2], [3, 4], [5, 6], [7, 8]] >>> add_python(Z1, Z2)\n    [[1, 2, 5, 6], [3, 4, 7, 8]] >>> add_numpy(Z1, Z2)\n    [[ 6  8]\n     [10 12]]\n\n```", "```py\nZ = [[0,0,0,0,0,0],\n         [0,0,0,1,0,0],\n         [0,1,0,1,0,0],\n         [0,0,1,1,0,0],\n         [0,0,0,0,0,0],\n         [0,0,0,0,0,0]]\n\n```", "```py\ndef compute_neighbours(Z):\n        shape = len(Z), len(Z[0])\n        N  = [[0,]*(shape[0]) for i in range(shape[1])]\n        for x in range(1,shape[0]-1):\n            for y in range(1,shape[1]-1):\n                N[x][y] = Z[x-1][y-1]+Z[x][y-1]+Z[x+1][y-1] \\\n                        + Z[x-1][y]            +Z[x+1][y]   \\\n                        + Z[x-1][y+1]+Z[x][y+1]+Z[x+1][y+1]\n        return N\n\n```", "```py\ndef iterate(Z):\n        N = compute_neighbours(Z)\n        for x in range(1,shape[0]-1):\n            for y in range(1,shape[1]-1):\n                 if Z[x][y] == 1 and (N[x][y] < 2 or N[x][y] > 3):\n                     Z[x][y] = 0\n                 elif Z[x][y] == 0 and N[x][y] == 3:\n                     Z[x][y] = 1\n        return Z\n\n```", "```py\n               ┏━━━┳━━━┳━━━┓───┬───┐\n            Z[:-2] ┃ 0 ┃ 1 ┃ 1 ┃ 1 │ 0 │ (left neighbours)\n                   ┗━━━┻━━━┻━━━┛───┴───┘\n                         ↓︎\n               ┌───┏━━━┳━━━┳━━━┓───┐\n       Z[1:-1] │ 0 ┃ 1 ┃ 1 ┃ 1 ┃ 0 │ (actual cells)\n               └───┗━━━┻━━━┻━━━┛───┘\n                         ↑\n           ┌───┬───┏━━━┳━━━┳━━━┓\n    Z[+2:] │ 0 │ 1 ┃ 1 ┃ 1 ┃ 0 ┃ (right neighbours)\n           └───┴───┗━━━┻━━━┻━━━┛\n\n```", "```py\nN = np.zeros(Z.shape, dtype=int)\n    N[1:-1,1:-1] += (Z[ :-2, :-2] + Z[ :-2,1:-1] + Z[ :-2,2:] +\n                     Z[1:-1, :-2]                + Z[1:-1,2:] +\n                     Z[2:  , :-2] + Z[2:  ,1:-1] + Z[2:  ,2:])\n\n```", "```py\n# Flatten arrays\n    N_ = N.ravel()\n    Z_ = Z.ravel()\n\n    # Apply rules\n    R1 = np.argwhere( (Z_==1) & (N_ < 2) )\n    R2 = np.argwhere( (Z_==1) & (N_ > 3) )\n    R3 = np.argwhere( (Z_==1) & ((N_==2) | (N_==3)) )\n    R4 = np.argwhere( (Z_==0) & (N_==3) )\n\n    # Set new values\n    Z_[R1] = 0\n    Z_[R2] = 0\n    Z_[R3] = Z_[R3]\n    Z_[R4] = 1\n\n    # Make sure borders stay null\n    Z[0,:] = Z[-1,:] = Z[:,0] = Z[:,-1] = 0\n\n```", "```py\nbirth = (N==3)[1:-1,1:-1] & (Z[1:-1,1:-1]==0)\n    survive = ((N==2) | (N==3))[1:-1,1:-1] & (Z[1:-1,1:-1]==1)\n    Z[...] = 0\n    Z[1:-1,1:-1][birth | survive] = 1\n\n```", "```py\ndef mandelbrot_python(xmin, xmax, ymin, ymax, xn, yn, maxiter, horizon=2.0):\n        def mandelbrot(z, maxiter):\n            c = z\n            for n in range(maxiter):\n                if abs(z) > horizon:\n                    return n\n                z = z*z + c\n            return maxiter\n        r1 = [xmin+i*(xmax-xmin)/xn for i in range(xn)]\n        r2 = [ymin+i*(ymax-ymin)/yn for i in range(yn)]\n        return [mandelbrot(complex(r, i),maxiter) for r in r1 for i in r2]\n\n```", "```py\ndef mandelbrot_numpy(xmin, xmax, ymin, ymax, xn, yn, maxiter, horizon=2.0):\n        X = np.linspace(xmin, xmax, xn, dtype=np.float32)\n        Y = np.linspace(ymin, ymax, yn, dtype=np.float32)\n        C = X + Y[:,None]*1j\n        N = np.zeros(C.shape, dtype=int)\n        Z = np.zeros(C.shape, np.complex64)\n        for n in range(maxiter):\n            I = np.less(abs(Z), horizon)\n            N[I] = n\n            Z[I] = Z[I]**2 + C[I]\n        N[N == maxiter-1] = 0\n        return Z, N\n\n```", "```py\n>>> xmin, xmax, xn = -2.25, +0.75, int(3000/3)\n    >>> ymin, ymax, yn = -1.25, +1.25, int(2500/3)\n    >>> maxiter = 200\n    >>> timeit(\"mandelbrot_python(xmin, xmax, ymin, ymax, xn, yn, maxiter)\", globals())\n    1 loops, best of 3: 6.1 sec per loop >>> timeit(\"mandelbrot_numpy(xmin, xmax, ymin, ymax, xn, yn, maxiter)\", globals())\n    1 loops, best of 3: 1.15 sec per loop\n\n```", "```py\ndef mandelbrot_numpy_2(xmin, xmax, ymin, ymax, xn, yn, itermax, horizon=2.0):\n        Xi, Yi = np.mgrid[0:xn, 0:yn]\n        Xi, Yi = Xi.astype(np.uint32), Yi.astype(np.uint32)\n        X = np.linspace(xmin, xmax, xn, dtype=np.float32)[Xi]\n        Y = np.linspace(ymin, ymax, yn, dtype=np.float32)[Yi]\n        C = X + Y*1j\n        N_ = np.zeros(C.shape, dtype=np.uint32)\n        Z_ = np.zeros(C.shape, dtype=np.complex64)\n        Xi.shape = Yi.shape = C.shape = xn*yn\n\n        Z = np.zeros(C.shape, np.complex64)\n        for i in range(itermax):\n            if not len(Z): break\n\n            # Compute for relevant points only\n            np.multiply(Z, Z, Z)\n            np.add(Z, C, Z)\n\n            # Failed convergence\n            I = abs(Z) > horizon\n            N_[Xi[I], Yi[I]] = i+1\n            Z_[Xi[I], Yi[I]] = Z[I]\n\n            # Keep going with those who have not diverged yet\n            np.negative(I,I)\n            Z = Z[I]\n            Xi, Yi = Xi[I], Yi[I]\n            C = C[I]\n        return Z_.T, N_.T\n\n```", "```py\n>>> timeit(\"mandelbrot_numpy_2(xmin, xmax, ymin, ymax, xn, yn, maxiter)\", globals())\n    1 loops, best of 3: 510 msec per loop\n\n```", "```py\nimport math\n    import random\n    from vec2 import vec2\n\n    class Boid:\n        def __init__(self, x=0, y=0):\n            self.position = vec2(x, y)\n            angle = random.uniform(0, 2*math.pi)\n            self.velocity = vec2(math.cos(angle), math.sin(angle))\n            self.acceleration = vec2(0, 0)\n\n```", "```py\ndef separation(self, boids):\n        count = 0\n        for other in boids:\n            d = (self.position - other.position).length()\n            if 0 < d < desired_separation:\n                count += 1\n                ...\n        if count > 0:\n            ...\n\n     def alignment(self, boids): ...\n     def cohesion(self, boids): ...\n\n```", "```py\nclass Flock:\n        def __init__(self, count=150):\n            self.boids = []\n            for i in range(count):\n                boid = Boid()\n                self.boids.append(boid)\n\n        def run(self):\n            for boid in self.boids:\n                boid.run(self.boids)\n\n```", "```py\nn = 500\n    velocity = np.zeros((n, 2), dtype=np.float32)\n    position = np.zeros((n, 2), dtype=np.float32)\n\n```", "```py\ndx = np.subtract.outer(position[:, 0], position[:, 0])\n    dy = np.subtract.outer(position[:, 1], position[:, 1])\n    distance = np.hypot(dx, dy)\n\n```", "```py\nmask_0 = (distance > 0)\n    mask_1 = (distance < 25)\n    mask_2 = (distance < 50)\n    mask_1 *= mask_0\n    mask_2 *= mask_0\n    mask_3 = mask_2\n\n```", "```py\nmask_1_count = np.maximum(mask_1.sum(axis=1), 1)\n    mask_2_count = np.maximum(mask_2.sum(axis=1), 1)\n    mask_3_count = mask_2_count\n\n```", "```py\n# Compute the average velocity of local neighbours\n    target = np.dot(mask, velocity)/count.reshape(n, 1)\n\n    # Normalize the result\n    norm = np.sqrt((target*target).sum(axis=1)).reshape(n, 1)\n    target *= np.divide(target, norm, out=target, where=norm != 0)\n\n    # Alignment at constant speed\n    target *= max_velocity\n\n    # Compute the resulting steering\n    alignment = target - velocity\n\n```", "```py\n# Compute the gravity center of local neighbours\n    center = np.dot(mask, position)/count.reshape(n, 1)\n\n    # Compute direction toward the center\n    target = center - position\n\n    # Normalize the result\n    norm = np.sqrt((target*target).sum(axis=1)).reshape(n, 1)\n    target *= np.divide(target, norm, out=target, where=norm != 0)\n\n    # Cohesion at constant speed (max_velocity)\n    target *= max_velocity\n\n    # Compute the resulting steering\n    cohesion = target - velocity\n\n```", "```py\n# Compute the repulsion force from local neighbours\n    repulsion = np.dstack((dx, dy))\n\n    # Force is inversely proportional to the distance\n    repulsion = np.divide(repulsion, distance.reshape(n, n, 1)**2, out=repulsion,\n                          where=distance.reshape(n, n, 1) != 0)\n\n    # Compute direction away from others\n    target = (repulsion*mask.reshape(n, n, 1)).sum(axis=1)/count.reshape(n, 1)\n\n    # Normalize the result\n    norm = np.sqrt((target*target).sum(axis=1)).reshape(n, 1)\n    target *= np.divide(target, norm, out=target, where=norm != 0)\n\n    # Separation at constant speed (max_velocity)\n    target *= max_velocity\n\n    # Compute the resulting steering\n    separation = target - velocity\n\n```", "```py\nacceleration = 1.5 * separation + alignment + cohesion\n    velocity += acceleration\n    position += velocity\n\n```", "```py\nv= np.array([(-0.25, -0.25),\n                 ( 0.00,  0.50),\n                 ( 0.25, -0.25),\n                 ( 0.00,  0.00)])\n    c = np.array([Path.MOVETO,\n                  Path.LINETO,\n                  Path.LINETO,\n                  Path.CLOSEPOLY])\n\n```", "```py\nn = 500\n    vertices = np.tile(v.reshape(-1), n).reshape(n, len(v), 2)\n    codes = np.tile(c.reshape(-1), n)\n\n```", "```py\ndef compute_python(X, Y):\n        result = 0\n        for i in range(len(X)):\n            for j in range(len(Y)):\n                result += X[i] * Y[j]\n        return result\n\n```", "```py\n>>> X = np.arange(1000)\n    >>> timeit(\"compute_python(X,X)\")\n    1 loops, best of 3: 0.274481 sec per loop\n\n```", "```py\ndef compute_numpy_wrong(X, Y):\n        return (X*Y).sum()\n\n```", "```py\ndef compute_numpy(X, Y):\n        Z = X.reshape(len(X),1) * Y.reshape(1,len(Y))\n        return Z.sum()\n\n```", "```py\n>>> X = np.arange(1000)\n    >>> timeit(\"compute_numpy(X,X)\")\n    10 loops, best of 3: 0.00157926 sec per loop\n\n```", "```py\ndef compute_numpy_better_1(X, Y):\n        result = 0\n        for i in range(len(X)):\n            Ysum = 0\n            for j in range(len(Y)):\n                Ysum += Y[j]\n            result += X[i]*Ysum\n        return result\n\n```", "```py\ndef compute_numpy_better_2(X, Y):\n        result = 0\n        Ysum = 0\n        for j in range(len(Y)):\n            Ysum += Y[j]\n        for i in range(len(X)):\n            result += X[i]*Ysum\n        return result\n\n```", "```py\ndef compute_numpy_better_3(x, y):\n        Ysum = 0\n        for j in range(len(Y)):\n            Ysum += Y[j]\n        Xsum = 0\n        for i in range(len(X)):\n            Xsum += X[i]\n        return Xsum*Ysum\n\n```", "```py\ndef compute_numpy_better(x, y):\n        return np.sum(y) * np.sum(x)\n\n```", "```py\n>>> X = np.arange(1000)\n    >>> timeit(\"compute_numpy_better(X,X)\")\n    1000 loops, best of 3: 3.97208e-06 sec per loop\n\n```", "```py\ndef compute_python_better(x, y):\n        return sum(x)*sum(y)\n\n```", "```py\n>>> X = np.arange(1000)\n    >>> timeit(\"compute_python_better(X,X)\")\n    1000 loops, best of 3: 0.000155677 sec per loop\n\n```", "```py\ndef build_maze(shape=(65, 65), complexity=0.75, density=0.50):\n        # Only odd shapes\n        shape = ((shape[0]//2)*2+1, (shape[1]//2)*2+1)\n\n        # Adjust complexity and density relatively to maze size\n        n_complexity = int(complexity*(shape[0]+shape[1]))\n        n_density = int(density*(shape[0]*shape[1]))\n\n        # Build actual maze\n        Z = np.zeros(shape, dtype=bool)\n\n        # Fill borders\n        Z[0, :] = Z[-1, :] = Z[:, 0] = Z[:, -1] = 1\n\n        # Islands starting point with a bias in favor of border\n        P = np.random.normal(0, 0.5, (n_density, 2))\n        P = 0.5 - np.maximum(-0.5, np.minimum(P, +0.5))\n        P = (P*[shape[1], shape[0]]).astype(int)\n        P = 2*(P//2)\n\n        # Create islands\n        for i in range(n_density):\n            # Test for early stop: if all starting point are busy, this means we\n            # won't be able to connect any island, so we stop.\n            T = Z[2:-2:2, 2:-2:2]\n            if T.sum() == T.size: break\n            x, y = P[i]\n            Z[y, x] = 1\n            for j in range(n_complexity):\n                neighbours = []\n                if x > 1:          neighbours.append([(y, x-1), (y, x-2)])\n                if x < shape[1]-2: neighbours.append([(y, x+1), (y, x+2)])\n                if y > 1:          neighbours.append([(y-1, x), (y-2, x)])\n                if y < shape[0]-2: neighbours.append([(y+1, x), (y+2, x)])\n                if len(neighbours):\n                    choice = np.random.randint(len(neighbours))\n                    next_1, next_2 = neighbours[choice]\n                    if Z[next_2] == 0:\n                        Z[next_1] = 1\n                        Z[next_2] = 1\n                        y, x = next_2\n                else:\n                    break\n        return Z\n\n```", "```py\ndef build_graph(maze):\n        height, width = maze.shape\n        graph = {(i, j): [] for j in range(width)\n                            for i in range(height) if not maze[i][j]}\n        for row, col in graph.keys():\n            if row < height - 1 and not maze[row + 1][col]:\n                graph[(row, col)].append((\"S\", (row + 1, col)))\n                graph[(row + 1, col)].append((\"N\", (row, col)))\n            if col < width - 1 and not maze[row][col + 1]:\n                graph[(row, col)].append((\"E\", (row, col + 1)))\n                graph[(row, col + 1)].append((\"W\", (row, col)))\n        return graph\n\n```", "```py\ndef breadth_first(maze, start, goal):\n        queue = deque([([start], start)])\n        visited = set()\n        graph = build_graph(maze)\n\n        while queue:\n            path, current = queue.popleft()\n            if current == goal:\n                return np.array(path)\n            if current in visited:\n                continue\n            visited.add(current)\n            for direction, neighbour in graph[current]:\n                p = list(path)\n                p.append(neighbour)\n                queue.append((p, neighbour))\n        return None\n\n```", "```py\ndef diffuse(Z):\n        # North, West, Center, East, South\n        return max(gamma*Z[0], gamma*Z[1], Z[2], gamma*Z[3], gamma*Z[4])\n\n    # Build gradient array\n    G = np.zeros(Z.shape)\n\n    # Initialize gradient at the entrance with value 1\n    G[start] = 1\n\n    # Discount factor\n    gamma = 0.99\n\n    # We iterate until value at exit is > 0\\. This requires the maze\n    # to have a solution or it will be stuck in the loop.\n    while G[goal] == 0.0:\n        G = Z * generic_filter(G, diffuse, footprint=[[0, 1, 0],\n                                                      [1, 1, 1],\n                                                      [0, 1, 0]])\n\n```", "```py\n# Build gradient array\n    G = np.zeros(Z.shape)\n\n    # Initialize gradient at the entrance with value 1\n    G[start] = 1\n\n    # Discount factor\n    gamma = 0.99\n\n    # We iterate until value at exit is > 0\\. This requires the maze\n    # to have a solution or it will be stuck in the loop.\n    G_gamma = np.empty_like(G)\n    while G[goal] == 0.0:\n        np.multiply(G, gamma, out=G_gamma)\n        N = G_gamma[0:-2,1:-1]\n        W = G_gamma[1:-1,0:-2]\n        C = G[1:-1,1:-1]\n        E = G_gamma[1:-1,2:]\n        S = G_gamma[2:,1:-1]\n        G[1:-1,1:-1] = Z[1:-1,1:-1]*np.maximum(N,np.maximum(W,\n                                    np.maximum(C,np.maximum(E,S))))\n\n```", "```py\nimport math\n    import random\n\n    def DART_sampling(width=1.0, height=1.0, r = 0.025, k=100):\n        def distance(p0, p1):\n            dx, dy = p0[0]-p1[0], p0[1]-p1[1]\n            return math.hypot(dx, dy)\n\n        points = []\n        i = 0\n        last_success = 0\n        while True:\n            x = random.uniform(0, width)\n            y = random.uniform(0, height)\n            accept = True\n            for p in points:\n                if distance(p, (x, y)) < r:\n                    accept = False\n                    break\n            if accept is True:\n                points.append((x, y))\n                if i-last_success > k:\n                    break\n                last_success = i\n            i += 1\n        return points\n\n```", "```py\n>>> l = TypedList([[1,2], [3]])\n    >>> print(l)\n    [1, 2], [3]\n    >>> print(l+1)\n    [2, 3], [4]\n\n```", "```py\ndef __init__(self, data=None, sizes=None, dtype=float)\n        \"\"\"\n        Parameters\n        ----------\n\n        data : array_like\n            An array, any object exposing the array interface, an object\n            whose __array__ method returns an array, or any (nested) sequence.\n\n        sizes:  int or 1-D array\n            If `itemsize is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If `itemsize` is 1-D array, the array will be divided into\n            elements whose successive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n\n        dtype: np.dtype\n            Any object that can be interpreted as a numpy data type.\n        \"\"\"\n\n```", "```py\n>>> L = TypedList([[0], [1,2], [3,4,5], [6,7,8,9]])\n    >>> print(L)\n    [ [0] [1 2] [3 4 5] [6 7 8] ]\n\n    >>> L = TypedList(np.arange(10), [1,2,3,4])\n    [ [0] [1 2] [3 4 5] [6 7 8] ]\n\n```", "```py\n╌╌╌╌┬───┐┌───┬───┐┌───┬───┬───┐┌───┬───┬───┬───┬╌╌╌╌╌\n        │ 0 ││ 1 │ 2 ││ 3 │ 4 │ 5 ││ 6 │ 7 │ 8 │ 9 │\n     ╌╌╌┴───┘└───┴───┘└───┴───┴───┘└───┴───┴───┴───┴╌╌╌╌╌╌\n       item 1  item 2    item 3         item 4\n\n```", "```py\nself._data = np.zeros(512, dtype=dtype)\n    self._items = np.zeros((64,2), dtype=int)\n    self._size = 0\n    self._count = 0\n\n```", "```py\nself._data = np.array(data, copy=False)\n    self._size = data.size\n    self._count = len(sizes)\n    indices = sizes.cumsum()\n    self._items = np.zeros((len(sizes),2),int)\n    self._items[1:,0] += indices[:-1]\n    self._items[0:,1] += indices\n\n```", "```py\ndef __getitem__(self, key):\n        if type(key) is int:\n            if key < 0:\n                key += len(self)\n            if key < 0 or key >= len(self):\n                raise IndexError(\"Tuple index out of range\")\n            dstart = self._items[key][0]\n            dstop  = self._items[key][1]\n            return self._data[dstart:dstop]\n\n        elif type(key) is slice:\n            istart, istop, step = key.indices(len(self))\n            if istart > istop:\n                istart,istop = istop,istart\n            dstart = self._items[istart][0]\n            if istart == istop:\n                dstop = dstart\n            else:\n                dstop  = self._items[istop-1][1]\n            return self._data[dstart:dstop]\n\n        elif isinstance(key,str):\n            return self._data[key][:self._size]\n\n        elif key is Ellipsis:\n            return self.data\n\n        else:\n            raise TypeError(\"List indices must be integers\")\n\n```", "```py\nL = TypedList([[0,0], [1,1], [0,0]])\n    L[1] = 1,1,1\n\n```", "```py\n╌╌╌╌┬───┬───┐┌───┬───┐┌───┬───┬╌╌╌╌╌\n        │ 0 │ 0 ││ 1 │ 1 ││ 2 │ 2 │\n     ╌╌╌┴───┴───┘└───┴───┘└───┴───┴╌╌╌╌╌╌\n         item 1   item 2   item 3\n\n    ╌╌╌╌┬───┬───┐┌───┬───┲━━━┓┌───┬───┬╌╌╌╌╌\n        │ 0 │ 0 ││ 1 │ 1 ┃ 1 ┃│ 2 │ 2 │\n     ╌╌╌┴───┴───┘└───┴───┺━━━┛└───┴───┴╌╌╌╌╌╌\n         item 1     item 2     item 3\n\n```", "```py\nL = TypedList([[0,0], [1,1], [0,0]])\n    del L[1]\n\n```", "```py\n╌╌╌╌┬───┬───┐┏━━━┳━━━┓┌───┬───┬╌╌╌╌╌\n        │ 0 │ 0 │┃ 1 ┃ 1 ┃│ 2 │ 2 │\n     ╌╌╌┴───┴───┘┗━━━┻━━━┛└───┴───┴╌╌╌╌╌╌\n         item 1   item 2   item 3\n\n    ╌╌╌╌┬───┬───┐┌───┬───┬╌╌╌╌╌\n        │ 0 │ 0 ││ 2 │ 2 │\n     ╌╌╌┴───┴───┘└───┴───┴╌╌╌╌╌╌\n         item 1    item 2\n\n```", "```py\nL = TypedList([[0,0], [1,1], [0,0]])\n    L.insert(1, [3,3])\n\n```", "```py\n╌╌╌╌┬───┬───┐┌───┬───┐┌───┬───┬╌╌╌╌╌\n        │ 0 │ 0 ││ 1 │ 1 ││ 2 │ 2 │\n     ╌╌╌┴───┴───┘└───┴───┘└───┴───┴╌╌╌╌╌╌\n         item 1   item 2   item 3\n\n    ╌╌╌╌┬───┬───┐┏━━━┳━━━┓┌───┬───┐┌───┬───┬╌╌╌╌╌\n        │ 0 │ 0 │┃ 3 ┃ 3 ┃│ 1 │ 1 ││ 2 │ 2 │\n     ╌╌╌┴───┴───┘┗━━━┻━━━┛└───┴───┘└───┴───┴╌╌╌╌╌╌\n         item 1   item 2   item 3   item 4\n\n```", "```py\nfrom glumpy import gloo\n\n    dtype = [(\"position\", np.float32, 2),  # x,y\n             (\"color\",    np.float32, 3)]  # r,g,b\n    V = np.zeros((3,3),dtype).view(gloo.VertexBuffer)\n    V[\"position\"][0,0] = 0.0, 0.0\n    V[\"position\"][1,1] = 0.0, 0.0\n\n```", "```py\nclass GPUData(np.ndarray):\n        def __new__(cls, *args, **kwargs):\n            return np.ndarray.__new__(cls, *args, **kwargs)\n\n        def __init__(self, *args, **kwargs):\n            pass\n\n        def __array_finalize__(self, obj):\n            if not isinstance(obj, GPUData):\n                self._extents = 0, self.size*self.itemsize\n                self.__class__.__init__(self)\n                self._pending_data = self._extents\n            else:\n                self._extents = obj._extents\n\n```", "```py\ndef __getitem__(self, key):\n        Z = np.ndarray.__getitem__(self, key)\n        if not hasattr(Z,'shape') or Z.shape == ():\n            return Z\n        Z._extents = self._compute_extents(Z)\n        return Z\n\n    def _compute_extents(self, Z):\n        if self.base is not None:\n            base = self.base.__array_interface__['data'][0]\n            view = Z.__array_interface__['data'][0]\n            offset = view - base\n            shape = np.array(Z.shape) - 1\n            strides = np.array(Z.strides)\n            size = (shape*strides).sum() + Z.itemsize\n            return offset, offset+size\n        else:\n            return 0, self.size*self.itemsize\n\n```", "```py\ndef __setitem__(self, key, value):\n        Z = np.ndarray.__getitem__(self, key)\n        if Z.shape == ():\n            key = np.mod(np.array(key)+self.shape, self.shape)\n            offset = self._extents[0]+(key * self.strides).sum()\n            size = Z.itemsize\n            self._add_pending_data(offset, offset+size)\n            key = tuple(key)\n        else:\n            Z._extents = self._compute_extents(Z)\n            self._add_pending_data(Z._extents[0], Z._extents[1])\n        np.ndarray.__setitem__(self, key, value)\n\n    def _add_pending_data(self, start, stop):\n        base = self.base\n        if isinstance(base, GPUData):\n            base._add_pending_data(start, stop)\n        else:\n            if self._pending_data is None:\n                self._pending_data = start, stop\n            else:\n                start = min(self._pending_data[0], start)\n                stop = max(self._pending_data[1], stop)\n                self._pending_data = start, stop\n\n```", "```py\ndef solution_1():\n        # Brute force\n        # 14641 (=11*11*11*11) iterations & tests\n        Z = []\n        for i in range(11):\n            for j in range(11):\n                for k in range(11):\n                    for l in range(11):\n                        if i+j+k+l == 10:\n                            Z.append((i,j,k,l))\n        return Z\n\n```", "```py\nimport itertools as it\n\n    def solution_2():\n        # Itertools\n        # 14641 (=11*11*11*11) iterations & tests\n        return [(i,j,k,l)\n                for i,j,k,l in it.product(range(11),repeat=4) if i+j+k+l == 10]\n\n```", "```py\ndef solution_3():\n        return [(a, b, c, (10 - a - b - c))\n                for a in range(11)\n                for b in range(11 - a)\n                for c in range(11 - a - b)]\n\n```", "```py\ndef solution_4():\n        X123 = np.indices((11,11,11)).reshape(3,11*11*11)\n        X4 = 10 - X123.sum(axis=0)\n        return np.vstack((X123, X4)).T[X4 > -1]\n\n```", "```py\n>>> timeit(\"solution_1()\", globals())\n    100 loops, best of 3: 1.9 msec per loop >>> timeit(\"solution_2()\", globals())\n    100 loops, best of 3: 1.67 msec per loop >>> timeit(\"solution_3()\", globals())\n    1000 loops, best of 3: 60.4 usec per loop >>> timeit(\"solution_4()\", globals())\n    1000 loops, best of 3: 54.4 usec per loop\n\n```", "```py\ndef solution_3_bis():\n        return ((a, b, c, (10 - a - b - c))\n                for a in range(11)\n                for b in range(11 - a)\n                for c in range(11 - a - b))\n\n```", "```py\n>>> timeit(\"solution_3_bis()\", globals())\n    10000 loops, best of 3: 0.643 usec per loop\n\n```", "```py\n>>> print(type(solution_3()))\n    <class 'list'> >>> print(type(solution_3_bis()))\n    <class 'generator'>\n\n```", "```py\nimport numpy as np\n    a = np.random.uniform(0, 1, 1000).astype(np.float32)\n    b = np.random.uniform(0, 1, 1000).astype(np.float32)\n    c = 2*a + 3*b\n\n```", "```py\nimport numpy as np\n    import numexpr as ne\n\n    a = np.random.uniform(0, 1, 1000).astype(np.float32)\n    b = np.random.uniform(0, 1, 1000).astype(np.float32)\n    c = ne.evaluate(\"2*a + 3*b\")\n\n```", "```py\nimport numpy as np\n\n    def evaluate(np.ndarray a, np.ndarray b):\n        cdef int i\n        cdef np.ndarray c = np.zeros_like(a)\n        for i in range(a.size):\n            c[i] = 2*a[i] + 3*b[i]\n        return c\n\n    a = np.random.uniform(0, 1, 1000).astype(np.float32)\n    b = np.random.uniform(0, 1, 1000).astype(np.float32)\n    c = evaluate(a, b)\n\n```", "```py\nfrom numba import jit\n    import numpy as np\n\n    @jit\n    def evaluate(np.ndarray a, np.ndarray b):\n        c = np.zeros_like(a)\n        for i in range(a.size):\n            c[i] = 2*a[i] + 3*b[i]\n        return c\n\n    a = np.random.uniform(0, 1, 1000).astype(np.float32)\n    b = np.random.uniform(0, 1, 1000).astype(np.float32)\n    c = evaluate(a, b)\n\n```", "```py\nimport numpy as np\n    import theano.tensor as T\n\n    x = T.fvector('x')\n    y = T.fvector('y')\n    z = 2*x + 3*y\n    f = function([x, y], z)\n\n    a = np.random.uniform(0, 1, 1000).astype(np.float32)\n    b = np.random.uniform(0, 1, 1000).astype(np.float32)\n    c = f(a, b)\n\n```", "```py\nimport numpy as np\n    import pycuda.autoinit\n    import pycuda.driver as drv\n    from pycuda.compiler import SourceModule\n\n    mod = SourceModule(\"\"\"\n        __global__ void evaluate(float *c, float *a, float *b)\n        {\n          const int i = threadIdx.x;\n          c[i] = 2*a[i] + 3*b[i];\n        }\n    \"\"\")\n\n    evaluate = mod.get_function(\"evaluate\")\n\n    a = np.random.uniform(0, 1, 1000).astype(np.float32)\n    b = np.random.uniform(0, 1, 1000).astype(np.float32)\n    c = np.zeros_like(a)\n\n    evaluate(drv.Out(c), drv.In(a), drv.In(b), block=(400,1,1), grid=(1,1))\n\n```", "```py\nimport numpy as np\n    import pyopencl as cl\n\n    a = np.random.uniform(0, 1, 1000).astype(np.float32)\n    b = np.random.uniform(0, 1, 1000).astype(np.float32)\n    c = np.empty_like(a)\n\n    ctx = cl.create_some_context()\n    queue = cl.CommandQueue(ctx)\n\n    mf = cl.mem_flags\n    gpu_a = cl.Buffer(ctx, mf.READ_ONLY | mf.COPY_HOST_PTR, hostbuf=a)\n    gpu_b = cl.Buffer(ctx, mf.READ_ONLY | mf.COPY_HOST_PTR, hostbuf=b)\n\n    evaluate = cl.Program(ctx, \"\"\"\n        __kernel void evaluate(__global const float *gpu_a;\n                               __global const float *gpu_b;\n                               __global       float *gpu_c)\n        {\n            int gid = get_global_id(0);\n            gpu_c[gid] = 2*gpu_a[gid] + 3*gpu_b[gid];\n        }\n    \"\"\").build()\n\n    gpu_c = cl.Buffer(ctx, mf.WRITE_ONLY, a.nbytes)\n    evaluate.evaluate(queue, a.shape, None, gpu_a, gpu_b, gpu_c)\n    cl.enqueue_copy(queue, c, gpu_c)\n\n```", "```py\nZ = np.zeros(9)\n\n```", "```py\n┌───┬───┬───┬───┬───┬───┬───┬───┬───┐\n    │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │\n    └───┴───┴───┴───┴───┴───┴───┴───┴───┘\n\n```", "```py\nZ = np.ones(9)\n\n```", "```py\n┌───┬───┬───┬───┬───┬───┬───┬───┬───┐\n    │ 1 │ 1 │ 1 │ 1 │ 1 │ 1 │ 1 │ 1 │ 1 │\n    └───┴───┴───┴───┴───┴───┴───┴───┴───┘\n\n```", "```py\nZ = np.array([1,0,0,0,0,0,0,1,0])\n\n```", "```py\n┌───┬───┬───┬───┬───┬───┬───┬───┬───┐\n    │ 1 │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │ 1 │ 0 │\n    └───┴───┴───┴───┴───┴───┴───┴───┴───┘\n\n```", "```py\nZ = 2*np.ones(9)\n\n```", "```py\n┌───┬───┬───┬───┬───┬───┬───┬───┬───┐\n    │ 2 │ 2 │ 2 │ 2 │ 2 │ 2 │ 2 │ 2 │ 2 │\n    └───┴───┴───┴───┴───┴───┴───┴───┴───┘\n\n```", "```py\nZ = np.arange(9)\n\n```", "```py\n┌───┬───┬───┬───┬───┬───┬───┬───┬───┐\n    │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │\n    └───┴───┴───┴───┴───┴───┴───┴───┴───┘\n\n```", "```py\nZ = np.arange(9).reshape(9,1)\n\n```", "```py\n┌───┐\n    │ 0 │\n    ├───┤\n    │ 1 │\n    ├───┤\n    │ 2 │\n    ├───┤\n    │ 3 │\n    ├───┤\n    │ 4 │\n    ├───┤\n    │ 5 │\n    ├───┤\n    │ 6 │\n    ├───┤\n    │ 7 │\n    ├───┤\n    │ 8 │\n    └───┘\n\n```", "```py\nZ = np.arange(9).reshape(3,3)\n\n```", "```py\n┌───┬───┬───┐\n    │ 0 │ 1 │ 2 │\n    ├───┼───┼───┤\n    │ 3 │ 4 │ 5 │\n    ├───┼───┼───┤\n    │ 6 │ 7 │ 8 │\n    └───┴───┴───┘\n\n```", "```py\nZ = np.random.randint(0,9,(3,3))\n\n```", "```py\n┌───┬───┬───┐\n    │ 4 │ 5 │ 7 │\n    ├───┼───┼───┤\n    │ 0 │ 2 │ 6 │\n    ├───┼───┼───┤\n    │ 8 │ 4 │ 0 │\n    └───┴───┴───┘\n\n```", "```py\nZ = np.linspace(0, 1, 5)\n\n```", "```py\n┌──────┬──────┬──────┬──────┬──────┐\n    │ 0.00 │ 0.25 │ 0.50 │ 0.75 │ 1.00 │\n    └──────┴──────┴──────┴──────┴──────┘\n\n```", "```py\nnp.grid[0:3,0:3]\n\n```", "```py\n┌───┬───┬───┐   ┌───┬───┬───┐\n    │ 0 │ 0 │ 0 │   │ 0 │ 1 │ 2 │\n    ├───┼───┼───┤   ├───┼───┼───┤\n    │ 1 │ 1 │ 1 │   │ 0 │ 1 │ 2 │\n    ├───┼───┼───┤   ├───┼───┼───┤\n    │ 2 │ 2 │ 2 │   │ 0 │ 1 │ 2 │\n    └───┴───┴───┘   └───┴───┴───┘\n\n```", "```py\nZ = np.arange(9).reshape(3,3)\n    Z[0,0]\n\n```", "```py\n┏━━━┓───┬───┐   ┏━━━┓\n    ┃ 0 ┃ 1 │ 2 │ → ┃ 0 ┃ (scalar)\n    ┗━━━┛───┼───┤   ┗━━━┛\n    │ 3 │ 4 │ 5 │\n    ├───┼───┼───┤\n    │ 6 │ 7 │ 8 │\n    └───┴───┴───┘\n\n```", "```py\nZ = np.arange(9).reshape(3,3)\n    Z[-1,-1]\n\n```", "```py\n┌───┬───┬───┐\n    │ 0 │ 1 │ 2 │\n    ├───┼───┼───┤\n    │ 3 │ 4 │ 5 │\n    ├───┼───┏━━━┓   ┏━━━┓\n    │ 6 │ 7 ┃ 8 ┃ → ┃ 8 ┃ (scalar)\n    └───┴───┗━━━┛   ┗━━━┛\n\n```", "```py\nZ = np.arange(9).reshape(3,3)\n    Z[1]\n\n```", "```py\n┌───┬───┬───┐\n    │ 0 │ 1 │ 2 │\n    ┏━━━┳━━━┳━━━┓   ┏━━━┳━━━┳━━━┓\n    ┃ 3 ┃ 4 ┃ 5 ┃ → ┃ 3 ┃ 4 ┃ 5 ┃\n    ┗━━━┻━━━┻━━━┛   ┗━━━┻━━━┻━━━┛\n    │ 6 │ 7 │ 8 │      (view)\n    └───┴───┴───┘\n\n```", "```py\nZ = np.arange(9).reshape(3,3)\n    Z[:,2]\n\n```", "```py\n┌───┬───┏━━━┓   ┏━━━┓\n    │ 0 │ 1 ┃ 2 ┃   ┃ 2 ┃\n    ├───┼───┣━━━┫   ┣━━━┫\n    │ 3 │ 4 ┃ 5 ┃ → ┃ 5 ┃ (view)\n    ├───┼───┣━━━┫   ┣━━━┫\n    │ 6 │ 7 ┃ 8 ┃   ┃ 8 ┃\n    └───┴───┗━━━┛   ┗━━━┛\n\n```", "```py\nZ = np.arange(9).reshape(3,3)\n    Z[1:,1:]\n\n```", "```py\n┌───┬───┬───┐\n    │ 0 │ 1 │ 2 │    (view)\n    ├───┏━━━┳━━━┓   ┏━━━┳━━━┓\n    │ 3 ┃ 4 ┃ 5 ┃   ┃ 4 ┃ 5 ┃\n    ├───┣━━━╋━━━┫ → ┣━━━╋━━━┫\n    │ 6 ┃ 7 ┃ 8 ┃   ┃ 7 ┃ 8 ┃\n    └───┗━━━┻━━━┛   ┗━━━┻━━━┛\n\n```", "```py\nZ = np.arange(9).reshape(3,3)\n    Z[::2,::2]\n\n```", "```py\n┏━━━┓───┏━━━┓   ┏━━━┳━━━┓\n    ┃ 0 ┃ 1 ┃ 2 ┃   ┃ 0 ┃ 2 ┃\n    ┗━━━┛───┗━━━┛ → ┣━━━╋━━━┫\n    │ 3 │ 4 │ 5 │   ┃ 6 ┃ 8 ┃\n    ┏━━━┓───┏━━━┓   ┗━━━┻━━━┛\n    ┃ 6 ┃ 7 ┃ 8 ┃    (view)\n    ┗━━━┛───┗━━━┛\n\n```", "```py\nZ = np.arange(9).reshape(3,3)\n    Z[[0,1],[0,2]]\n\n```", "```py\n┏━━━┓───┬───┐\n    ┃ 0 ┃ 1 │ 2 │\n    ┗━━━┛───┏━━━┓   ┏━━━┳━━━┓\n    │ 3 │ 4 ┃ 5 ┃ → ┃ 0 ┃ 5 ┃\n    ├───┼───┗━━━┛   ┗━━━┻━━━┛\n    │ 6 │ 7 │ 8 │    (copy)\n    └───┴───┴───┘\n\n```", "```py\nZ = np.array([0,0,0,0,0,0,0,0,0,0,1,0])\n\n```", "```py\n┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┏━━━┓───┐\n    │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 ┃ 1 ┃ 0 │\n    └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┗━━━┛───┘\n\n```", "```py\nZ = np.array([0,0,0,0,0,0,0,0,0,0,1,0]).reshape(12,1)\n\n```", "```py\n┌───┐\n    │ 0 │\n    ├───┤\n    │ 0 │\n    ├───┤\n    │ 0 │\n    ├───┤\n    │ 0 │\n    ├───┤\n    │ 0 │\n    ├───┤\n    │ 0 │\n    ├───┤\n    │ 0 │\n    ├───┤\n    │ 0 │\n    ├───┤\n    │ 0 │\n    ├───┤\n    │ 0 │\n    ┏━━━┓\n    ┃ 1 ┃\n    ┗━━━┛\n    │ 0 │\n    └───┘\n\n```", "```py\nZ = np.array([0,0,0,0,0,0,0,0,0,0,1,0]).reshape(3,4)\n\n```", "```py\n┌───┬───┬───┬───┐\n    │ 0 │ 0 │ 0 │ 0 │\n    ├───┼───┼───┼───┤\n    │ 0 │ 0 │ 0 │ 0 │\n    ├───┼───┏━━━┓───┤\n    │ 0 │ 0 ┃ 1 ┃ 0 │\n    └───┴───┗━━━┛───┘\n\n```", "```py\nZ = np.array([0,0,0,0,0,0,0,0,0,0,1,0]).reshape(4,3)\n\n```", "```py\n┌───┬───┬───┐\n    │ 0 │ 0 │ 0 │\n    ├───┼───┼───┤\n    │ 0 │ 0 │ 0 │\n    ├───┼───┼───┤\n    │ 0 │ 0 │ 0 │\n    ├───┏━━━┓───┤\n    │ 0 ┃ 1 ┃ 0 │\n    └───┗━━━┛───┘\n\n```", "```py\nZ = np.array([0,0,0,0,0,0,0,0,0,0,1,0]).reshape(6,2)\n\n```", "```py\n┌───┬───┐\n    │ 0 │ 0 │\n    ├───┼───┤\n    │ 0 │ 0 │\n    ├───┼───┤\n    │ 0 │ 0 │\n    ├───┼───┤\n    │ 0 │ 0 │\n    ├───┼───┤\n    │ 0 │ 0 │\n    ┏━━━┓───┤\n    ┃ 1 ┃ 0 │\n    ┗━━━┛───┘\n\n```", "```py\nZ = np.array([0,0,0,0,0,0,0,0,0,0,1,0]).reshape(2,6)\n\n```", "```py\n┌───┬───┬───┬───┬───┬───┐\n    │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │\n    ├───┼───┼───┼───┏━━━┓───┤\n    │ 0 │ 0 │ 0 │ 0 ┃ 1 ┃ 0 │\n    └───┴───┴───┴───┗━━━┛───┘\n\n```", "```py\nZ1 = np.arange(9).reshape(3,3)\n    Z2 = 1\n    Z1 + Z2\n\n```", "```py\n┌───┬───┬───┐   ┌───┐   ┌───┬───┬───┐   ┏━━━┓───┬───┐   ┌───┬───┬───┐\n    │ 0 │ 1 │ 2 │ + │ 1 │ = │ 0 │ 1 │ 2 │ + ┃ 1 ┃ 1 │ 1 │ = │ 1 │ 2 │ 3 │\n    ├───┼───┼───┤   └───┘   ├───┼───┼───┤   ┗━━━┛───┼───┤   ├───┼───┼───┤\n    │ 3 │ 4 │ 5 │           │ 3 │ 4 │ 5 │   │ 1 │ 1 │ 1 │   │ 4 │ 5 │ 6 │\n    ├───┼───┼───┤           ├───┼───┼───┤   ├───┼───┼───┤   ├───┼───┼───┤\n    │ 6 │ 7 │ 8 │           │ 6 │ 7 │ 8 │   │ 1 │ 1 │ 1 │   │ 7 │ 8 │ 9 │\n    └───┴───┴───┘           └───┴───┴───┘   └───┴───┴───┘   └───┴───┴───┘\n\n```", "```py\nZ1 = np.arange(9).reshape(3,3)\n    Z2 = np.arange(3)[::-1].reshape(3,1)\n    Z1 + Z2\n\n```", "```py\n┌───┬───┬───┐   ┌───┐   ┌───┬───┬───┐   ┏━━━┓───┬───┐   ┌───┬───┬───┐\n    │ 0 │ 1 │ 2 │ + │ 2 │ = │ 0 │ 1 │ 2 │ + ┃ 2 ┃ 2 │ 2 │ = │ 2 │ 3 │ 4 │\n    ├───┼───┼───┤   ├───┤   ├───┼───┼───┤   ┣━━━┫───┼───┤   ├───┼───┼───┤\n    │ 3 │ 4 │ 5 │   │ 1 │   │ 3 │ 4 │ 5 │   ┃ 1 ┃ 1 │ 1 │   │ 4 │ 5 │ 6 │\n    ├───┼───┼───┤   ├───┤   ├───┼───┼───┤   ┣━━━┫───┼───┤   ├───┼───┼───┤\n    │ 6 │ 7 │ 8 │   │ 0 │   │ 6 │ 7 │ 8 │   ┃ 0 ┃ 0 │ 0 │   │ 6 │ 7 │ 8 │\n    └───┴───┴───┘   └───┘   └───┴───┴───┘   ┗━━━┛───┴───┘   └───┴───┴───┘\n\n```", "```py\nZ1 = np.arange(9).reshape(3,3)\n    Z2 = np.arange(3)[::-1]\n    Z1 + Z2\n\n```", "```py\n┌───┬───┬───┐   ┌───┬───┬───┐   ┌───┬───┬───┐   ┏━━━┳━━━┳━━━┓   ┌───┬───┬───┐\n    │ 0 │ 1 │ 2 │ + │ 2 │ 1 │ 0 │ = │ 0 │ 1 │ 2 │ + ┃ 2 ┃ 1 ┃ 0 ┃ = │ 2 │ 2 │ 2 │\n    ├───┼───┼───┤   └───┴───┴───┘   ├───┼───┼───┤   ┗━━━┻━━━┻━━━┛   ├───┼───┼───┤\n    │ 3 │ 4 │ 5 │                   │ 3 │ 4 │ 5 │   │ 2 │ 1 │ 0 │   │ 5 │ 5 │ 5 │\n    ├───┼───┼───┤                   ├───┼───┼───┤   ├───┼───┼───┤   ├───┼───┼───┤\n    │ 6 │ 7 │ 8 │                   │ 6 │ 7 │ 8 │   │ 2 │ 1 │ 0 │   │ 8 │ 8 │ 8 │\n    └───┴───┴───┘                   └───┴───┴───┘   └───┴───┴───┘   └───┴───┴───┘\n\n```", "```py\nZ1 = np.arange(3).reshape(3,1)\n    Z2 = np.arange(3).reshape(1,3)\n    Z1 + Z2\n\n```", "```py\n┌───┐   ┌───┬───┬───┐   ┏━━━┓───┬───┐   ┏━━━┳━━━┳━━━┓   ┌───┬───┬───┐\n    │ 0 │ + │ 0 │ 1 │ 2 │ = ┃ 0 ┃ 0 │ 0 │ + ┃ 0 ┃ 1 ┃ 2 ┃ = │ 0 │ 1 │ 2 │\n    ├───┤   └───┴───┴───┘   ┣━━━┫───┼───┤   ┗━━━┻━━━┻━━━┛   ├───┼───┼───┤\n    │ 1 │                   ┃ 1 ┃ 1 │ 1 │   │ 0 │ 1 │ 2 │   │ 1 │ 2 │ 3 │\n    ├───┤                   ┣━━━┫───┼───┤   ├───┼───┼───┤   ├───┼───┼───┤\n    │ 2 │                   ┃ 2 ┃ 2 │ 2 │   │ 0 │ 1 │ 2 │   │ 2 │ 3 │ 4 │\n    └───┘                   ┗━━━┛───┴───┘   └───┴───┴───┘   └───┴───┴───┘\n\n```"]