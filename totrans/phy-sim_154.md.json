["```py\ndef reset_grid():\n    # after each transfer, the grid is reset\n    grid_m.fill(0)\n    grid_v.fill(0) \n```", "```py\n@ti.func\ndef StVK_Hencky_PK1_2D(F):\n    U, sig, V = ti.svd(F)\n    inv_sig = sig.inverse()\n    e = ti.Matrix([[ti.log(sig[0, 0]), 0], [0, ti.log(sig[1, 1])]])\n    return U @ (2 * mu * inv_sig @ e + lam * e.trace() * inv_sig) @ V.transpose() \n```", "```py\n@ti.kernel\ndef particle_to_grid_transfer():\n    for p in range(N_particles):\n        base = (x[p] / dx - 0.5).cast(int)\n        fx = x[p] / dx - base.cast(float)\n        # quadratic B-spline interpolating functions (Section 26.2)\n        w = [0.5 * (1.5 - fx) ** 2, 0.75 - (fx - 1) ** 2, 0.5 * (fx - 0.5) ** 2]\n        # gradient of the interpolating function (Section 26.2)\n        dw_dx = [fx - 1.5, 2 * (1.0 - fx), fx - 0.5]\n\n        P = StVK_Hencky_PK1_2D(F[p])\n        for i in ti.static(range(3)):\n            for j in ti.static(range(3)):\n                offset = ti.Vector([i, j])\n                weight = w[i][0] * w[j][1]\n                grad_weight = ti.Vector([(1\\. / dx) * dw_dx[i][0] * w[j][1], \n                                          w[i][0] * (1\\. / dx) * dw_dx[j][1]])\n\n                grid_m[base + offset] += weight * m[p] # mass transfer\n                grid_v[base + offset] += weight * m[p] * v[p] # momentum Transfer, PIC formulation\n                # internal force (stress) transfer\n                fi = -vol[p] * P @ F[p].transpose() @ grad_weight\n                grid_v[base + offset] += dt * fi \n```", "```py\n@ti.kernel\ndef update_grid():\n    for i, j in grid_m:\n        if grid_m[i, j] > 0:\n            grid_v[i, j] = grid_v[i, j] / grid_m[i, j] # extract updated nodal velocity from transferred nodal momentum\n\n            # Dirichlet BC near the bounding box\n            if i <= 3 or i > grid_size - 3 or j <= 2 or j > grid_size - 3:\n                grid_v[i, j] = 0 \n```", "```py\n@ti.kernel\ndef grid_to_particle_transfer():\n    for p in range(N_particles):\n        base = (x[p] / dx - 0.5).cast(int)\n        fx = x[p] / dx - base.cast(float)\n        # quadratic B-spline interpolating functions (Section 26.2)\n        w = [0.5 * (1.5 - fx) ** 2, 0.75 - (fx - 1) ** 2, 0.5 * (fx - 0.5) ** 2]\n        # gradient of the interpolating function (Section 26.2)\n        dw_dx = [fx - 1.5, 2 * (1.0 - fx), fx - 0.5]\n\n        new_v = ti.Vector.zero(float, 2)\n        v_grad_wT = ti.Matrix.zero(float, 2, 2)\n        for i in ti.static(range(3)):\n            for j in ti.static(range(3)):\n                offset = ti.Vector([i, j])\n                weight = w[i][0] * w[j][1]\n                grad_weight = ti.Vector([(1\\. / dx) * dw_dx[i][0] * w[j][1], \n                                          w[i][0] * (1\\. / dx) * dw_dx[j][1]])\n\n                new_v += weight * grid_v[base + offset]\n                v_grad_wT += grid_v[base + offset].outer_product(grad_weight)\n\n        v[p] = new_v\n        F[p] = (ti.Matrix.identity(float, 2) + dt * v_grad_wT) @ F[p] \n```", "```py\n@ti.kernel\ndef update_particle_state():\n    for p in range(N_particles):\n        x[p] += dt * v[p] # advection \n```", "```py\ndef step():\n    # a single time step of the Material Point Method (MPM) simulation\n    reset_grid()\n    particle_to_grid_transfer()\n    update_grid()\n    grid_to_particle_transfer()\n    update_particle_state() \n```"]