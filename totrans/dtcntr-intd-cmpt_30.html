<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>10.1Â Introduction to PandasğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>10.1Â Introduction to PandasğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/python-tables-Pandas.html">https://dcic-world.org/2025-08-27/python-tables-Pandas.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._.Pandas_.Table_.Basics%29" class="toclink" data-pltdoc="x">10.1.1Â Pandas Table Basics</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Core_.Datatypes__.Data.Frame_and_.Series%29" class="toclink" data-pltdoc="x">10.1.1.1Â Core Datatypes: DataFrame and Series</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Creating_and_.Loading_.Data.Frames%29" class="toclink" data-pltdoc="x">10.1.1.2Â Creating and Loading DataFrames</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Using_.Labels_and_.Indices_to_.Access_.Cells%29" class="toclink" data-pltdoc="x">10.1.1.3Â Using Labels and Indices to Access Cells</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Filtering_.Rows%29" class="toclink" data-pltdoc="x">10.1.2Â Filtering Rows</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Cleaning_and_.Normalizing_.Data%29" class="toclink" data-pltdoc="x">10.1.3Â Cleaning and Normalizing Data</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Clearing_out_unknown_values%29" class="toclink" data-pltdoc="x">10.1.3.1Â Clearing out unknown values</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Repairing_.Values_and_.Column_.Types%29" class="toclink" data-pltdoc="x">10.1.3.2Â Repairing Values and Column Types</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Computing_.New_.Columns%29" class="toclink" data-pltdoc="x">10.1.4Â Computing New Columns</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Aggregating_and_.Grouping_.Columns%29" class="toclink" data-pltdoc="x">10.1.5Â Aggregating and Grouping Columns</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Wide_.Versus_.Tall_.Data%29" class="toclink" data-pltdoc="x">10.1.6Â Wide Versus Tall Data</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Converting_.Between_.Wide_and_.Tall_.Data%29" class="toclink" data-pltdoc="x">Converting Between Wide and Tall Data</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Plotting_.Data%29" class="toclink" data-pltdoc="x">10.1.7Â Plotting Data</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Takeaways%29" class="toclink" data-pltdoc="x">10.1.8Â Takeaways</a></p></td></tr></table><p>Now itâ€™s time to transfer what we learned about tables in Pyret over
to Python. Pandas is a popular package, and youâ€™ll find many tutorial
and help sites for it online. In general, Python usually provides many
ways to approach a given task. As such, there are many ways to do
common operations in Pandas. We have chosen to present a certain
collection of ways that align with the concepts as we covered them in
Pyret.</p><p>To work in Pandas, youâ€™ll need to include the following line at the
top of your file:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">import pandas as pd</code></pre><section class="SsectionLevel4" id="section 10.1.1"><h4 class="heading">10.1.1Â <a name="(part._.Pandas_.Table_.Basics)"/>Pandas Table Basics<a href="#(part._.Pandas_.Table_.Basics)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><section class="SsectionLevel5" id="section 10.1.1.1"><h5 class="heading">10.1.1.1Â <a name="(part._.Core_.Datatypes__.Data.Frame_and_.Series)"/>Core Datatypes: DataFrame and Series<a href="#(part._.Core_.Datatypes__.Data.Frame_and_.Series)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Pandas uses the term DataFrame for a table with rows and
columns. DataFrames are built out of two more basic types:</p><ul><li><p>An array is a sequence of values that can be accessed by
position (e.g., 0, 1, ... up to one less than the length of the
array). Like lists, arrays capture a linear (ordered) collection of
values. Unlike lists, arrays are created with a limit on the number of
elements that they contain. In practice, lists are more commonly used
when elements are frequently added or removed whereas arrays are more
commonly used when elements frequently get accessed by their
position. Nearly every programming language offers both lists and
arrays; a detailed contrast is beyond the scope of this book (this
information would be covered in a data structures class).</p></li><li><p>A Series is an array in which the positions optionally have
labels in addition to the position numbers.</p></li></ul><p>In Pandas, a row is a Series in which an array of the cell values
is labeled with the column headers (this is similar to the â€˜Rowâ€˜
datatype in Pyret). A DataFrame is a series of these rows.</p></section><section class="SsectionLevel5" id="section 10.1.1.2"><h5 class="heading">10.1.1.2Â <a name="(part._.Creating_and_.Loading_.Data.Frames)"/>Creating and Loading DataFrames<a href="#(part._.Creating_and_.Loading_.Data.Frames)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>DataFrames can be created manually or loaded in from a file, as we did
in Pyret. Hereâ€™s a simple example of creating one by hand:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">data = {
    'day': ['mon','tues','wed','thurs','fri'],
    'max temp': [58, 62, 55, 59, 64]
}
temps = pd.DataFrame(data)</code></pre><p><code data-lang="text/x-python" class="sourceCode">data</code> is a dictionary that maps column names to
values. Calling <code data-lang="text/x-python" class="sourceCode">pd.DataFrame</code> creates a DataFrame from the
dictionary. (There are other ways to create DataFrames manually which
you can find by searching online.)</p><p>To load a DataFrame from a CSV file, you need either the path to the
file on your computer or the url where you can get the CSV file
online. Hereâ€™s an example of the url version. In this example, we have
the following CSV contents and we want to change the header names when
loading the file:</p><p>The following <code data-lang="text/x-python" class="sourceCode">read_csv</code> command says that the CSV file is at
<code data-lang="text/x-python" class="sourceCode">url</code>, that there are headers in the first row (numbered
<code data-lang="text/x-python" class="sourceCode">0</code>), and that we want to use the values in <code data-lang="text/x-python" class="sourceCode">names</code> as
the column labels (this will ignore whatever might be in the header
row in the CSV file).</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events_url = "https://raw.githubusercontent.com/data-centric-computing/dcic-public/main/materials/datasets/events.csv"
events = pd.read_csv(events_url, header=0,
                     names=['name','email','numtix','discount','delivery'])</code></pre><p>If we wanted to use the headers in the CSV file as the column headers,
we would leave out the <code data-lang="text/x-python" class="sourceCode">names=[...]</code> part. If the CSV had no
header row, we would write <code data-lang="text/x-python" class="sourceCode">header=None</code> instead of
<code data-lang="text/x-python" class="sourceCode">header=0</code>. (There are many more configuration options in the
<a href="https://Pandas.pydata.org/docs/reference/api/Pandas.read_csv.html">Pandas
documentation</a>, but you wonâ€™t need them for the examples in this book.)</p><p>Conceptually, the loaded DataFrame is as follows, with the labels shown in
blue and the indicies (positions) show in yellow:</p><p><img src="../Images/d63a7003f02c1f4bfd00ac93817af463.png" alt="" width="554" height="179" data-original-src="https://dcic-world.org/2025-08-27/events-table-w-labels.png"/></p><p>Since we did not specify labels for the rows, Pandas has used numeric
labels by default. At the moment, the positions and the labels are the
same for each row, but we will see that this is not always the case.</p><p>(If you look at the actual loaded table, some of the blank cells in
the discount column will contain <code data-lang="text/x-python" class="sourceCode">NaN</code>, which is the standard
Python value for â€œmissing informationâ€. We will deal with that
information shortly.</p></section><section class="SsectionLevel5" id="section 10.1.1.3"><h5 class="heading">10.1.1.3Â <a name="(part._.Using_.Labels_and_.Indices_to_.Access_.Cells)"/>Using Labels and Indices to Access Cells<a href="#(part._.Using_.Labels_and_.Indices_to_.Access_.Cells)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Rows, columns, and cells can be accessed using either their (numeric)
positions or their labels. Here are some examples:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['numtix']         # extract the numtix column as a series
events['numtix'][2]      # get the value in the numtix column, row 2
events.loc[6]            # extract row with label 6 from the DataFrame
events.loc[6]['numtix']  # get the value in row with label 6, numtix column
events.iloc[6]           # extract the row with index/position 6</code></pre><p>Notice that we used different notation for accessing a cell
depending on whether we accessed the row first or the column
first. This is because we are showing you how to access data through
either position indices or labels. Using <code data-lang="text/x-python" class="sourceCode">.loc</code> tells Pandas
that you are using a label to access a row. If you want to use the
position instead, you need to use <code data-lang="text/x-python" class="sourceCode">iloc</code> (the <code data-lang="text/x-python" class="sourceCode">i</code> stands
for â€œintegerâ€). If you are using a programmer-supplied label instead,
you can just use the label directly.</p><p>In a DataFrame, both rows and columns always have position indices and may
have labels. The <code data-lang="text/x-python" class="sourceCode">.loc</code> notation works on either rows or
columns, we just happened to illustrate the notation on the rows since
we had already created labels on the columns when we loaded <code data-lang="text/x-python" class="sourceCode">events</code>.</p></section></section><section class="SsectionLevel4" id="section 10.1.2"><h4 class="heading">10.1.2Â <a name="(part._.Filtering_.Rows)"/>Filtering Rows<a href="#(part._.Filtering_.Rows)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Back in Pyret, we filtered rows from a table by writing a function
from <code data-lang="pyret" class="sourceCode">Row</code> to <code data-lang="pyret" class="sourceCode">Boolean</code>. The <code data-lang="pyret" class="sourceCode">filter-with</code> function
applied that function to every row in the table, returning a new table
with those rows for which the predicate were true.</p><p>In Pandas, we select rows by providing an array of Booleans that has
the same length as the number of rows in the DataFrame. Filtering keeps
those rows for which the corresponding array entry is <code data-lang="text/x-python" class="sourceCode">True</code>.
For example, hereâ€™s our DataFrame diagram from before, this time with an
array to the right indicating that we want to keep rows 0, 2, and
6.</p><p><img src="../Images/0958f43b8192439a6fd898de3fbe50fb.png" alt="" width="660" height="173" data-original-src="https://dcic-world.org/2025-08-27/events-table-w-keep-array.png"/></p><p>The â€œkeepâ€ array is not part of the DataFrame. Here is the
corresponding array expressed in code, followed by the notation to use
the array to filter the DataFrame:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># which rows we want
keep = [True, False, True, False, False, False, True]</code></pre><p>Once we have the array of booleans, we use it to extract a collection
of rows using similar notation that we previously used to extract a
column. Just as we wrote <code data-lang="text/x-python" class="sourceCode">events['numtix']</code> to select the
<code data-lang="text/x-python" class="sourceCode">'numtix'</code> column, we can write <code data-lang="text/x-python" class="sourceCode">events[keep]</code> to
select a collection of rows. The DataFrame that results from filtering
(along with the <code data-lang="text/x-python" class="sourceCode">True</code> cells of the <code data-lang="text/x-python" class="sourceCode">keep</code> array for
illustration) appears as follows:</p><p><img src="../Images/0baa50e0adf5a889a71a977667d9c7e9.png" alt="" width="659" height="101" data-original-src="https://dcic-world.org/2025-08-27/events-table-filtered-result.png"/></p><p>How does Pandas know whether we want to select rows or columns? It
depends on what we provide in the square brackets: if we provide a
single label, we get the column or row with that label; if we provide
an array of booleans, we get the rows for which the corresponding row
(by position) is <code data-lang="text/x-python" class="sourceCode">True</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Look at the returned DataFrame. Do you notice anything interesting?</p></blockquote></blockquote><p>Look at the row labels and indices: the labels have been retained from
the original DataFrame (0, 2, and 6), while the indices are a sequence
of consecutive numbers starting from 0. Having both ways to reference
rowsâ€”<wbr/>one based on raw order and the other based on
programmer-provided labelsâ€”<wbr/>provides a lot of flexibility as we use
filter to isolate parts of tables that we want to work on.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Does filtering rows this way in Python keep the original
<code data-lang="text/x-python" class="sourceCode">events</code> DataFrame intact? Try it out!</p></blockquote></blockquote><p>Arrays of booleans that are used for filtering out other arrays are
called masks. Here, we have shown a simple mask that we
constructed by hand. If we had a long DataFrame, however, we would not
want to construct a mask for it by hand. Fortunately, we donâ€™t have
to. Python provides notations that let us construct masks via
expressions over a series.</p><p>Imagine that we wanted to filter the <code data-lang="text/x-python" class="sourceCode">events</code> table down to
those rows with delivery method <code data-lang="text/x-python" class="sourceCode">'email'</code>. To create a mask for
this, we first select the delivery column as a series:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['delivery']</code></pre><p>Next, we use the series in a boolean expression that states the
constraint that we want on each element of the series:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['delivery'] == 'email'</code></pre><p>Wait, whatâ€™s going on here? <code data-lang="text/x-python" class="sourceCode">events['deliver']</code> is a Series (a
labeled array of strings). <code data-lang="text/x-python" class="sourceCode">'email'</code> is a string. What does it
even mean to ask whether two values of different types be considered
equal, especially when one has many component values and the other
does not?</p><p>In this case, the <code data-lang="text/x-python" class="sourceCode">==</code> doesnâ€™t mean â€œare these equalâ€?
Instead, Python applies <code data-lang="text/x-python" class="sourceCode">== 'email'</code> to every element of the
<code data-lang="text/x-python" class="sourceCode">events['delivery']</code> Series, constructing a new Series of the
results. This idea of applying an operation to all elements of an
array is known as â€œliftingâ€. It is one of the shortcuts that Python
provides to help experienced programmers do simple common
tasks quickly and easily.</p><p>Now that we have a Series of booleans (for which events will be picked
up by email), we can use it to select those rows from the
<code data-lang="text/x-python" class="sourceCode">events</code> DataFrame:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events[events['delivery'] == 'email']</code></pre><p>The inner use of <code data-lang="text/x-python" class="sourceCode">events</code> is for creating the mask, while the
outer one is for filtering the table with that mask.</p><p>As a warning: if you search online for information on how to filter or
process DataFrame, you might find code samples that do this using for
loops. While that approach works, it isnâ€™t considered good Pandas (or
general programming) practice. Most modern languages provide built-in
constructs for iterating over lists and other sequence-style
data. These operations have more descriptive names than generic loops
(which makes them easier for other programmers to read), and are often
engineered to run more efficiently under the hood. As a general rule,
only default to basic loops if there is no built-in operator to do the
computation that you have in mind.</p></section><section class="SsectionLevel4" id="section 10.1.3"><h4 class="heading">10.1.3Â <a name="(part._.Cleaning_and_.Normalizing_.Data)"/>Cleaning and Normalizing Data<a href="#(part._.Cleaning_and_.Normalizing_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>The same operator-lifting idea that we just saw when creating masks
from DataFrames also comes into play for normalizing data. Recall that
when we worked with the <code data-lang="text/x-python" class="sourceCode">events</code> table in Pyret, we converted
all of the discount codes to lowercase. Hereâ€™s the code that does this
in Pandas:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['discount'] = events['discount'].str.lower()</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Look at the above code. Break it down and try to articulate what each
part does. Do any parts seem new or different from things weâ€™ve done
so far in Pandas?</p></blockquote></blockquote><p>On the right side of the <code data-lang="text/x-python" class="sourceCode">=</code>, we are extracting the Series of
discount codes (<code data-lang="text/x-python" class="sourceCode">events['discount']</code>), then using the lowercase
operation on strings <code data-lang="text/x-python" class="sourceCode">str.lower()</code> to convert each one,
building up a Series of the results. Normally, given a string (such as
<code data-lang="text/x-python" class="sourceCode">'BIRTHDAY'</code>), we could get a lowercase version of it by
writing just <code data-lang="text/x-python" class="sourceCode">'BIRTHDAY'.lower()</code>. Whatâ€™s the extra <code data-lang="text/x-python" class="sourceCode">str</code>
doing in there?</p><p>This is a nuance about lifting. Python can evaluate
<code data-lang="text/x-python" class="sourceCode">'BIRTHDAY'.lower()</code> because <code data-lang="text/x-python" class="sourceCode">lower()</code> is defined
directly on strings. <code data-lang="text/x-python" class="sourceCode">lower()</code> is not, however, directly
defined on Series. To bridge the gap between having Series data and
wanting to use a string operation on it, we insert <code data-lang="text/x-python" class="sourceCode">str</code> before
<code data-lang="text/x-python" class="sourceCode">lower()</code>. Effectively, this tells Python where to find the
<code data-lang="text/x-python" class="sourceCode">lower()</code> operation (in the collection of operations defined on
strings).</p><p>The left side of the above code looks like:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['discount'] = ...</code></pre><p>This tells Pandas to replace the current contents of the
<code data-lang="text/x-python" class="sourceCode">'discount'</code> series with the series on the right side of the
<code data-lang="text/x-python" class="sourceCode">=</code>. It is similar to <code data-lang="pyret" class="sourceCode">transform-column</code> from Pyret, but with a
fundamental difference: in Pyret, <code data-lang="pyret" class="sourceCode">transform-column</code> left the old
table intact and produced a new table with the new column
values. Instead, in Pandas the old column gets replaced, thus
destroying the original table. There are many nuances to having
operations destroy and replace data; the chapter on
<a href="mutating-structures.html" data-pltdoc="x">Mutating Structures</a> studies them in detail.</p><section class="SsectionLevel5" id="section 10.1.3.1"><h5 class="heading">10.1.3.1Â <a name="(part._.Clearing_out_unknown_values)"/>Clearing out unknown values<a href="#(part._.Clearing_out_unknown_values)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Now letâ€™s try a different cleaning and normalization problem: we want
the discount column to contain only known discount codes or empty
strings. The <code data-lang="text/x-python" class="sourceCode">none</code> entry in line 3 of the table should be
converted to an empty string, and we should make sure that all of the
<code data-lang="text/x-python" class="sourceCode">NaN</code> and
seemingly empty entries in the discount cells are also converted to empty
strings (as opposed to strings of multiple spaces).</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Plan out how you might do this task using mask expressions. Even if
you donâ€™t know all the specific notation for the operations you need,
you can still work out a plan for completing this task.</p></blockquote></blockquote><p>If you planned out the tasks, you might have a todo list like the
following:</p><ol><li><p>create a mask of rows with known discount codes</p></li><li><p>invert that mask (swap the false and true values)</p></li><li><p>filter the DataFrame to rows without a known discount code</p></li><li><p>replace all the discount column values in that DataFrame with an
empty string</p></li></ol><p>We have seen how to do parts of steps 1 and 3, but neither of steps 2
and 4. Letâ€™s work through the steps one by one:</p><p>Hereâ€™s the code for step 1, which creates a mask for the rows with
known discount codes:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">codes = ['birthday', 'student']     # a list of valid codes
events['discount'].isin(codes)      # which rows have valid codes</code></pre><p>Here, we use a lifted <code data-lang="text/x-python" class="sourceCode">isin</code> operator on lists to compute the mask.</p><p>For step 2, we have to swap the true and false values. We can do this
by using the negation operator <code data-lang="text/x-python" class="sourceCode">~</code> on the mask from step 1:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">~events['discount'].isin(codes)</code></pre><p>For step 3, we want to filter <code data-lang="text/x-python" class="sourceCode">events</code> with this mask. Just to
keep the code easier to read, weâ€™ll give the mask a name and then
perform the filter:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">mask = ~events['discount'].isin(codes)   # rows with INVALID codes
events[mask]</code></pre><p>Finally, we use <code data-lang="text/x-python" class="sourceCode">=</code> to set the discount column of the filtered
DataFrame to the empty string:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events[mask]['discount'] = ''</code></pre><p>Whoops â€“ this seems to have generated an error message that says
something about a â€œSettingWithCopyWarningâ€. This is a subtlety that
has to do with what happens when data gets updated under the hood (weâ€™ll learn
about subtleties of mutation in <a href="mutable-lists.html" data-pltdoc="x">Mutable Lists</a>).
For now, weâ€™ll use this alternate form that
avoids the error:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events.loc[mask,'discount'] = ''</code></pre><p>Putting it all together, the entire program looks like:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">codes = ['birthday', 'student']
mask = ~events['discount'].isin(codes)
events.loc[mask]['discount'] = ''</code></pre><p>Summarizing, the code pattern for updating values for a column in some
rows of a DataFrame is as follows:</p><ul class="compact"><li><p>make a boolean series mask for which rows to update</p></li><li><p>use the mask to select just the rows where the mask is true</p></li><li><p>use <code data-lang="text/x-python" class="sourceCode">.loc</code> with the mask and column name to select the
series of cells to update</p></li><li><p>use <code data-lang="text/x-python" class="sourceCode">=</code> to give those cells their new value</p></li></ul><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Follow the above pattern to transform all delivery values of
<code data-lang="text/x-python" class="sourceCode">'yes'</code> to <code data-lang="text/x-python" class="sourceCode">'pickup'</code>.</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 10.1.3.2"><h5 class="heading">10.1.3.2Â <a name="(part._.Repairing_.Values_and_.Column_.Types)"/>Repairing Values and Column Types<a href="#(part._.Repairing_.Values_and_.Column_.Types)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>The source file for the <code data-lang="text/x-python" class="sourceCode">events</code> table contained an error in
which someone entered the string <code data-lang="text/x-python" class="sourceCode">'three'</code> in place of the
number <code data-lang="text/x-python" class="sourceCode">3</code> for the number of tickets in the last row. We can
repair errors like this manually:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events.loc[6]['numtix'] = 3</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Make this repair and ask your Python environment to show you the
corrected table.</p></blockquote></blockquote><p>Now that the <code data-lang="text/x-python" class="sourceCode">'numtix'</code> column contains only numbers, we can
total the number of tickets that were sold:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['numtix'].sum()</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What did you get? Why?</p></blockquote></blockquote><p>Because Python environments print strings without quotation marks, the
numtix column appears to contain numbers. The failure of <code data-lang="text/x-python" class="sourceCode">sum</code>
shows that this is indeed not the case. We can inspect the types that
Python has determined for the numtix values using the <code data-lang="text/x-python" class="sourceCode">type</code>
operation:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">type(events['numtix'].loc[0])  # prints str
type(events['numtix'].loc[6])  # prints int for the corrected value</code></pre><p>What happened here? During the original call to <code data-lang="text/x-python" class="sourceCode">read_csv</code>,
Python detected both numeric and string data in the numtix column. It
therefore read in all the values as strings. Our manual repair that
replaced the string <code data-lang="text/x-python" class="sourceCode">'three'</code> with the number <code data-lang="text/x-python" class="sourceCode">3</code> fixed
the value and type for one row, but the remaining values in that
column have still been read in as integers.</p><p>Fortunately, Python provides an operation to change the type of data
within a series. The following code converts the values in the
<code data-lang="text/x-python" class="sourceCode">events['numtix']</code> series to integers, updating the series
within the DataFrame in the process.</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['numtix'] = events['numtix'].astype('int')

events['numtix'].sum()    # now this works</code></pre></section></section><section class="SsectionLevel4" id="section 10.1.4"><h4 class="heading">10.1.4Â <a name="(part._.Computing_.New_.Columns)"/>Computing New Columns<a href="#(part._.Computing_.New_.Columns)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Letâ€™s extend the events table with the total cost of tickets, while
also accounting for a discount. Weâ€™ll start by building a column for
the ticket price without any discounts. This is a straightforward
application of lifting as weâ€™ve seen it so far:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">ticket_price = 10
events['total'] = events['numtix'] * ticket_price</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use masks, operator lifting, filtering, and series updating to give a
10% discount to everyone with the â€œbirthdayâ€ discount code.</p></blockquote></blockquote><p>We do this by creating a mask for the â€œbirthdayâ€ discount, then
updating just that part of the DataFrame.</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">bday_mask = events['discount'] == 'birthday'
events.loc[bday_mask,'total'] = events['total'] * 0.90</code></pre><p>Notice that the notation for computing new columns and updating
existing ones is the same (unlike in Pyret, where we had different
operations <code data-lang="pyret" class="sourceCode">build-column</code> and <code data-lang="pyret" class="sourceCode">transform-column</code>). In
Pandas, a new column is created if the given column name doesnâ€™t
already exist in the DataFrame; otherwise, the existing column with
the given name gets updated.</p></section><section class="SsectionLevel4" id="section 10.1.5"><h4 class="heading">10.1.5Â <a name="(part._.Aggregating_and_.Grouping_.Columns)"/>Aggregating and Grouping Columns<a href="#(part._.Aggregating_and_.Grouping_.Columns)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Pandas has built-in operations for doing standard mathematical
computations over series. For example, to total the number of tickets
sold or to compute the average number of tickets per order, we can write</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['numtix'].sum()   # compute total number of tickets sold
events['numtix'].mean()  # compute average number of tickets per sale</code></pre><p>These are the same built-in operations that apply to Python lists.</p><p>Imagine now that we wanted a finer-grained look at total ticket
sales. Rather than just the total sold overall, weâ€™d like the total
sold per discount category.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How might you compute this?</p></blockquote></blockquote><p>We could imagine constructing a list of the discount codes, filtering
the ticket sales table to each code, then using <code data-lang="text/x-python" class="sourceCode">sum</code> on each
filtered table. This feels like a lot of work, however. Producing
summaries of one column (e.g., <code data-lang="text/x-python" class="sourceCode">``numtix''</code>) around the values
in another (e.g., <code data-lang="text/x-python" class="sourceCode">``discount''</code>) is a common technique in data
analysis. Spreadsheets typically provide a feature called a â€œpivot
tableâ€ that supports such a view of data.</p><p>In Pandas, we can do a computation like this using an operation called
<code data-lang="text/x-python" class="sourceCode">groupby</code>. Hereâ€™s are two examples. The first reports how many
sales (rows) were made with each discount code, while the second summarize the total
number of tickets sold by discount code:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events.groupby('discount').count()
events.groupby('discount')['numtix'].sum()</code></pre><p><code data-lang="text/x-python" class="sourceCode">groupby</code> takes the name of the column whose values will be
used to cluster rows. It returns a special type of data (called
<code data-lang="text/x-python" class="sourceCode">GroupBy</code>). From there, we can select a column and perform an
operation on it. The column selection and operation are performed on
each collection of rows in the <code data-lang="text/x-python" class="sourceCode">GroupBy</code>. The results of the
second expression in the above code are reported in a new DataFrame:</p><p><img src="../Images/0b9ecb1c08c84c777f66a57137d73fb3.png" alt="" width="143" height="104" data-original-src="https://dcic-world.org/2025-08-27/grouby-table-example.png"/></p><p>In this DataFrame, discount labels a column. The first row has the
empty string in the discount column, with 14 tickets purchased without
discount codes. There were 2 tickets purchased with a birthday
discount and 8 with a student discount.</p><p>The Pandas documentation provides a large collection of operations
that can used on <code data-lang="text/x-python" class="sourceCode">GroupBy</code> data; these cover computations such
as counting, mean, finding largest and smallest values, and performing
various other statistical operations.</p></section><section class="SsectionLevel4" id="section 10.1.6"><h4 class="heading">10.1.6Â <a name="(part._.Wide_.Versus_.Tall_.Data)"/>Wide Versus Tall Data<a href="#(part._.Wide_.Versus_.Tall_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Letâ€™s try grouping data on a different dataset. Hereâ€™s a table showing
sales data across several regions during each month of the year:</p><p><img src="../Images/ec0e7f8f6b70454dec5da967061e0316.png" alt="" width="446" height="255" data-original-src="https://dcic-world.org/2025-08-27/sales-wide.png"/></p><p>Copy the following code to load this table for yourself.</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">import pandas as pd

sales_url = "https://raw.githubusercontent.com/data-centric-computing/dcic-public/main/materials/datasets/sales-wide.csv"
col_names = ['month','division','northwest','northeast','central','southeast','southwest']
sales = pd.read_csv(sales_url, header=0, names=col_names)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Here are several questions that we might want to ask from this
dataset. For each one, develop a plan that indicates which Pandas
operations you would use to answer it. If a question seems hard to
answer with the operations you have, explain whatâ€™s difficult about
answering that question.</p><ol><li><p>In which month did the northwest region have the lowest sales?</p></li><li><p>What were the total sales per month across all regions?</p></li><li><p>Which region had the highest sales in April?</p></li><li><p>Which region had the highest sales for the entire year?</p></li></ol></blockquote></blockquote><p>For question 1, we can sort the table by northwest sales in decreasing
order, then see which month is listed in the first row.</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">s = sales.sort_values('northwest',ascending=True)
s.iloc[0]['month']</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What value would we have gotten had we used <code data-lang="text/x-python" class="sourceCode">loc</code> instead of
<code data-lang="text/x-python" class="sourceCode">iloc</code> in the above code?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Did sorting the <code data-lang="text/x-python" class="sourceCode">sales</code> table change the row order permanently?
Check by having Python show you the value of <code data-lang="text/x-python" class="sourceCode">sales</code> after you run
<code data-lang="text/x-python" class="sourceCode">sort_values</code>.</p></blockquote></blockquote><p>For question 2, we could build a new column that stores the sales data
across each row:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># we use parens around the right side to break the expression across
# multiple lines, rather than extend past the window edge
sales['total'] = (sales['northwest'] + sales['northeast'] +
                  sales['central'] + sales['southeast'] +
                  sales['southwest'])</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Did computing the <code data-lang="text/x-python" class="sourceCode">total</code> column change the row order permanently?
Check by having Python show you the value of <code data-lang="text/x-python" class="sourceCode">sales</code> after you run the
code.</p></blockquote></blockquote><p>(If you want to remove the new <code data-lang="text/x-python" class="sourceCode">total</code> column, you can do this with
<code data-lang="text/x-python" class="sourceCode">sales = sales.drop(columns='total')</code>.)</p><p>Question 3 is more challenging because we want to sort on the regions,
which are in columns rather than rows. Question 4 is even more
challenging because we want to produce sums of columns, then compare
regions. Both of these feel a bit like problems we might know how to
solve if the rows corresponded to regions rather than months, but that
isnâ€™t how our data are organized. And even if we did flip the table
around (we could, the technical term for this is <code data-lang="text/x-python" class="sourceCode">transpose</code>),
problem 4 would still feel a bit complicated by the time we computed
annual sales per region and sorted them.</p><p>What if instead our table had looked like the following? Would
questions 3 and 4 get any easier?</p><p><img src="../Images/0b8815a10314d9cdee7892b1e09f891d.png" alt="" width="249" height="234" data-original-src="https://dcic-world.org/2025-08-27/sales-tall-snippet.png"/></p><p>With the data organized this way, question 3 can be answered with a
combination of row selection and <code data-lang="text/x-python" class="sourceCode">sort_values</code>. Question 4
becomes easy to answer with a <code data-lang="text/x-python" class="sourceCode">groupby</code>. Even the code for
Question 2 gets cleaner.</p><p>The contrast between these two tables highlights that how our data are
organized can determine how easy or hard it is to process them with the
standard operations provided by table-processing packages such as
Pandas (what weâ€™re discussing here applies to other languages that
support tables, such as Pyret and R).</p><p>In general, the operations in table-processing packages were designed
to assume that there is one core observation per row (about which we
might have many smaller details or attributes), and that we will want
to aggregate and display data across rows, not across columns. Our
original treated each month as an observation, with the regions being
details. For questions 1 and 2, which focused on months, the built-in
operations sufficed to process the table. But for questions 3 and 4,
which focused on regions or combinations of regions and months, it
helps to have each month and region data be in its own row.</p><p>Tables like the original <code data-lang="text/x-python" class="sourceCode">sales</code> data are called wide
tables, whereas the second form are termed tall tables. At
the extremes, wide tables have every variable in its own column
whereas tall tables have only one column for a single value of
interest, with a separate row for each variable that contributed to
that value. Wide tables tend to be easier for people to read; as we
have seen with our sales data, tall tables can be easier to process in
code, depending on how our questions align with our variables.</p><section class="SsectionLevel5" id="section 0"><h5 class="heading"><a name="(part._.Converting_.Between_.Wide_and_.Tall_.Data)"/>Converting Between Wide and Tall Data<a href="#(part._.Converting_.Between_.Wide_and_.Tall_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Table-processing packages generally provide built-in operators for
converting between wide and tall data formats. The following Pandas
expression converts the (original) wide-format <code data-lang="text/x-python" class="sourceCode">sales</code> table into a
tall-format table, retaining the month of the year and the product
division as a label on every datapoint:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">sales.melt(id_vars=['month','division'])</code></pre><p>This basic <code data-lang="text/x-python" class="sourceCode">melt</code> expression uses default column names of
<code data-lang="text/x-python" class="sourceCode">variable</code> and <code data-lang="text/x-python" class="sourceCode">value</code> for the new columns. We can
customize those names as part of the <code data-lang="text/x-python" class="sourceCode">melt</code> call if we wish:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">sales_tall = sales.melt(id_vars=['month','division'],var_name='region',value_name='sales')</code></pre><p>Letâ€™s put the wide and tall tables side by side to visualize what
<code data-lang="text/x-python" class="sourceCode">melt</code> is doing.</p><p><img src="../Images/3a8f49b403e48f063552947c7f7f252d.png" alt="" width="800" height="253" data-original-src="https://dcic-world.org/2025-08-27/wide-tall-mapping.png"/></p><p>The columns named in <code data-lang="text/x-python" class="sourceCode">id_vars</code> remain in the original
table. For each column not named in <code data-lang="text/x-python" class="sourceCode">id_vars</code>, a row is
created with the <code data-lang="text/x-python" class="sourceCode">id_vars</code> columns, the melted-column name, and
the melted-column value for the <code data-lang="text/x-python" class="sourceCode">id_vars</code>. The above figure
color codes how cells from the wide table are arranged in the melted
tall table.</p><p>With the tall table in hand, we can proceed to answer questions 3 and
4, as well as to redo our solution to question 2:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># Question 2: total sales per month across regions
sales_tall.groupby('region').sum()

# Question 3: which region had the highest sales in April
apr_by_region = sales_tall[sales_tall['month'] == 'Apr']
apr_by_region.sort_values('sales', ascending=False).iloc[0]['region']

# Question 4: which region had the highest sales for the year
tot_sales_region = sales_tall.groupby('region').sum()
tot_sales_region.sort_values('sales',ascending=False).reset_index().iloc[0]['region']</code></pre><p>The solution to question 4 uses a new Pandas operator called
<code data-lang="text/x-python" class="sourceCode">reset_index</code>, which is needed if you want to manipulate the
output of a <code data-lang="text/x-python" class="sourceCode">group-by</code> as a regular DataFrame.</p></section></section><section class="SsectionLevel4" id="section 10.1.7"><h4 class="heading">10.1.7Â <a name="(part._.Plotting_.Data)"/>Plotting Data<a href="#(part._.Plotting_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Letâ€™s continue with the sales data as we explore plotting in Pandas.</p><p>Letâ€™s say we now want to take a seasonal view, rather than a monthly
view, and look at sales within seasons.</p><p>Letâ€™s say we wanted to see how summer sales varied over the
years. This is a good situation in which to use a line plot. To create
this, we first need to load <code data-lang="text/x-python" class="sourceCode">matplotlib</code>, the Python graphic
library:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">import matplotlib.pyplot as plt
from Pandas.plotting import register_matplotlib_converters
register_matplotlib_converters()</code></pre><p>Next, to generate the line plots, we call the <code data-lang="text/x-python" class="sourceCode">plt.plot</code>
function on the series of numbers that we want to form the points on
the plot. We can also specify the values on the axes, as shown the
following examples.</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># create a new canvas in which to make the plot
plt.figure()

# plot month column (x-axis) vs northeast sales (y-axis)
plt.plot(sales['month'],sales['northeast'])

# add central sales to the same plot
plt.plot(sales['central'])

# add labels to the y-axis and the chart overall
plt.ylabel('Monthly Sales')
plt.title('Comparing Regional Sales')

# show the plot
plt.show()</code></pre><p>Pandas will put both line plots in the same display window. In
general, each time you call <code data-lang="text/x-python" class="sourceCode">plt.figure()</code>, you create a new
window in which subsequent plot commands will appear (at least until
you ask for a plot that does not nicely overlay with the previous plot
type).</p><p>The <code data-lang="text/x-python" class="sourceCode">matplotlib</code> package offers many kinds of charts and
customizations to graph layouts. A more comprehensive look is beyond
the scope of this book; see the <a href="https://matplotlib.org/stable/index.html">matplotlib website</a> for
tutorials and many examples of more sophisticated plots.</p></section><section class="SsectionLevel4" id="section 10.1.8"><h4 class="heading">10.1.8Â <a name="(part._.Takeaways)"/>Takeaways<a href="#(part._.Takeaways)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>This chapter has been designed to give you an overview of Pandas while
pointing out key concepts in programming for data science. It is by no
means a comprehensive Pandas tutorial or reference guide: for those,
see the <a href="https://pandas.pydata.org/">Pandas website</a>.</p><p>Conceptually, we hope you will take away three high-level ideas from
this chapter:</p><ul><li><p>There are two notions for how to access specific cells in
tables and DataFrames: by numeric position (e.g., first row, second
column) or by labeled index (e.g., numtix). Both have their roles
in professional-grade data analysis programming. Filter-like
operations that extract rows from tables maintain labeled indices, but
renumber the positional ones (so that every DataFrame has a sequence
of consecutively-numbered rows).</p></li><li><p>Professional-grade programming languages sometimes â€œliftâ€
operations from single values to collections of values (e.g., using
<code data-lang="text/x-python" class="sourceCode">+</code> to add elements within similarly-sized series). Lifting can
be a powerful and timesaving tool for programmers, but they can also
lead to type confusions for both novices and experienced
programmers. You should be aware that this feature exists as you learn
new languages and packages.</p></li><li><p>Different table organizations (for the same data) are better in
different situations. Wide and tall tables are two general shapes,
each with their own affordances. You should be aware that
table-processing packages provide a variety of tools to help you
automatically reformat tables. If the computation you are trying to do
feels too complicated, stop and consider whether the problem would be
easier with a different organization of the same data.</p></li></ul></section>&#13;
<h4 class="heading">10.1.1Â <a name="(part._.Pandas_.Table_.Basics)"/>Pandas Table Basics<a href="#(part._.Pandas_.Table_.Basics)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><section class="SsectionLevel5" id="section 10.1.1.1"><h5 class="heading">10.1.1.1Â <a name="(part._.Core_.Datatypes__.Data.Frame_and_.Series)"/>Core Datatypes: DataFrame and Series<a href="#(part._.Core_.Datatypes__.Data.Frame_and_.Series)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Pandas uses the term DataFrame for a table with rows and
columns. DataFrames are built out of two more basic types:</p><ul><li><p>An array is a sequence of values that can be accessed by
position (e.g., 0, 1, ... up to one less than the length of the
array). Like lists, arrays capture a linear (ordered) collection of
values. Unlike lists, arrays are created with a limit on the number of
elements that they contain. In practice, lists are more commonly used
when elements are frequently added or removed whereas arrays are more
commonly used when elements frequently get accessed by their
position. Nearly every programming language offers both lists and
arrays; a detailed contrast is beyond the scope of this book (this
information would be covered in a data structures class).</p></li><li><p>A Series is an array in which the positions optionally have
labels in addition to the position numbers.</p></li></ul><p>In Pandas, a row is a Series in which an array of the cell values
is labeled with the column headers (this is similar to the â€˜Rowâ€˜
datatype in Pyret). A DataFrame is a series of these rows.</p></section><section class="SsectionLevel5" id="section 10.1.1.2"><h5 class="heading">10.1.1.2Â <a name="(part._.Creating_and_.Loading_.Data.Frames)"/>Creating and Loading DataFrames<a href="#(part._.Creating_and_.Loading_.Data.Frames)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>DataFrames can be created manually or loaded in from a file, as we did
in Pyret. Hereâ€™s a simple example of creating one by hand:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">data = {
    'day': ['mon','tues','wed','thurs','fri'],
    'max temp': [58, 62, 55, 59, 64]
}
temps = pd.DataFrame(data)</code></pre><p><code data-lang="text/x-python" class="sourceCode">data</code> is a dictionary that maps column names to
values. Calling <code data-lang="text/x-python" class="sourceCode">pd.DataFrame</code> creates a DataFrame from the
dictionary. (There are other ways to create DataFrames manually which
you can find by searching online.)</p><p>To load a DataFrame from a CSV file, you need either the path to the
file on your computer or the url where you can get the CSV file
online. Hereâ€™s an example of the url version. In this example, we have
the following CSV contents and we want to change the header names when
loading the file:</p><p>The following <code data-lang="text/x-python" class="sourceCode">read_csv</code> command says that the CSV file is at
<code data-lang="text/x-python" class="sourceCode">url</code>, that there are headers in the first row (numbered
<code data-lang="text/x-python" class="sourceCode">0</code>), and that we want to use the values in <code data-lang="text/x-python" class="sourceCode">names</code> as
the column labels (this will ignore whatever might be in the header
row in the CSV file).</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events_url = "https://raw.githubusercontent.com/data-centric-computing/dcic-public/main/materials/datasets/events.csv"
events = pd.read_csv(events_url, header=0,
                     names=['name','email','numtix','discount','delivery'])</code></pre><p>If we wanted to use the headers in the CSV file as the column headers,
we would leave out the <code data-lang="text/x-python" class="sourceCode">names=[...]</code> part. If the CSV had no
header row, we would write <code data-lang="text/x-python" class="sourceCode">header=None</code> instead of
<code data-lang="text/x-python" class="sourceCode">header=0</code>. (There are many more configuration options in the
<a href="https://Pandas.pydata.org/docs/reference/api/Pandas.read_csv.html">Pandas
documentation</a>, but you wonâ€™t need them for the examples in this book.)</p><p>Conceptually, the loaded DataFrame is as follows, with the labels shown in
blue and the indicies (positions) show in yellow:</p><p><img src="../Images/d63a7003f02c1f4bfd00ac93817af463.png" alt="" width="554" height="179" data-original-src="https://dcic-world.org/2025-08-27/events-table-w-labels.png"/></p><p>Since we did not specify labels for the rows, Pandas has used numeric
labels by default. At the moment, the positions and the labels are the
same for each row, but we will see that this is not always the case.</p><p>(If you look at the actual loaded table, some of the blank cells in
the discount column will contain <code data-lang="text/x-python" class="sourceCode">NaN</code>, which is the standard
Python value for â€œmissing informationâ€. We will deal with that
information shortly.</p></section><section class="SsectionLevel5" id="section 10.1.1.3"><h5 class="heading">10.1.1.3Â <a name="(part._.Using_.Labels_and_.Indices_to_.Access_.Cells)"/>Using Labels and Indices to Access Cells<a href="#(part._.Using_.Labels_and_.Indices_to_.Access_.Cells)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Rows, columns, and cells can be accessed using either their (numeric)
positions or their labels. Here are some examples:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['numtix']         # extract the numtix column as a series
events['numtix'][2]      # get the value in the numtix column, row 2
events.loc[6]            # extract row with label 6 from the DataFrame
events.loc[6]['numtix']  # get the value in row with label 6, numtix column
events.iloc[6]           # extract the row with index/position 6</code></pre><p>Notice that we used different notation for accessing a cell
depending on whether we accessed the row first or the column
first. This is because we are showing you how to access data through
either position indices or labels. Using <code data-lang="text/x-python" class="sourceCode">.loc</code> tells Pandas
that you are using a label to access a row. If you want to use the
position instead, you need to use <code data-lang="text/x-python" class="sourceCode">iloc</code> (the <code data-lang="text/x-python" class="sourceCode">i</code> stands
for â€œintegerâ€). If you are using a programmer-supplied label instead,
you can just use the label directly.</p><p>In a DataFrame, both rows and columns always have position indices and may
have labels. The <code data-lang="text/x-python" class="sourceCode">.loc</code> notation works on either rows or
columns, we just happened to illustrate the notation on the rows since
we had already created labels on the columns when we loaded <code data-lang="text/x-python" class="sourceCode">events</code>.</p></section>&#13;
<h5 class="heading">10.1.1.1Â <a name="(part._.Core_.Datatypes__.Data.Frame_and_.Series)"/>Core Datatypes: DataFrame and Series<a href="#(part._.Core_.Datatypes__.Data.Frame_and_.Series)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Pandas uses the term DataFrame for a table with rows and
columns. DataFrames are built out of two more basic types:</p><ul><li><p>An array is a sequence of values that can be accessed by
position (e.g., 0, 1, ... up to one less than the length of the
array). Like lists, arrays capture a linear (ordered) collection of
values. Unlike lists, arrays are created with a limit on the number of
elements that they contain. In practice, lists are more commonly used
when elements are frequently added or removed whereas arrays are more
commonly used when elements frequently get accessed by their
position. Nearly every programming language offers both lists and
arrays; a detailed contrast is beyond the scope of this book (this
information would be covered in a data structures class).</p></li><li><p>A Series is an array in which the positions optionally have
labels in addition to the position numbers.</p></li></ul><p>In Pandas, a row is a Series in which an array of the cell values
is labeled with the column headers (this is similar to the â€˜Rowâ€˜
datatype in Pyret). A DataFrame is a series of these rows.</p>&#13;
<h5 class="heading">10.1.1.2Â <a name="(part._.Creating_and_.Loading_.Data.Frames)"/>Creating and Loading DataFrames<a href="#(part._.Creating_and_.Loading_.Data.Frames)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>DataFrames can be created manually or loaded in from a file, as we did
in Pyret. Hereâ€™s a simple example of creating one by hand:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">data = {
    'day': ['mon','tues','wed','thurs','fri'],
    'max temp': [58, 62, 55, 59, 64]
}
temps = pd.DataFrame(data)</code></pre><p><code data-lang="text/x-python" class="sourceCode">data</code> is a dictionary that maps column names to
values. Calling <code data-lang="text/x-python" class="sourceCode">pd.DataFrame</code> creates a DataFrame from the
dictionary. (There are other ways to create DataFrames manually which
you can find by searching online.)</p><p>To load a DataFrame from a CSV file, you need either the path to the
file on your computer or the url where you can get the CSV file
online. Hereâ€™s an example of the url version. In this example, we have
the following CSV contents and we want to change the header names when
loading the file:</p><p>The following <code data-lang="text/x-python" class="sourceCode">read_csv</code> command says that the CSV file is at
<code data-lang="text/x-python" class="sourceCode">url</code>, that there are headers in the first row (numbered
<code data-lang="text/x-python" class="sourceCode">0</code>), and that we want to use the values in <code data-lang="text/x-python" class="sourceCode">names</code> as
the column labels (this will ignore whatever might be in the header
row in the CSV file).</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events_url = "https://raw.githubusercontent.com/data-centric-computing/dcic-public/main/materials/datasets/events.csv"
events = pd.read_csv(events_url, header=0,
                     names=['name','email','numtix','discount','delivery'])</code></pre><p>If we wanted to use the headers in the CSV file as the column headers,
we would leave out the <code data-lang="text/x-python" class="sourceCode">names=[...]</code> part. If the CSV had no
header row, we would write <code data-lang="text/x-python" class="sourceCode">header=None</code> instead of
<code data-lang="text/x-python" class="sourceCode">header=0</code>. (There are many more configuration options in the
<a href="https://Pandas.pydata.org/docs/reference/api/Pandas.read_csv.html">Pandas
documentation</a>, but you wonâ€™t need them for the examples in this book.)</p><p>Conceptually, the loaded DataFrame is as follows, with the labels shown in
blue and the indicies (positions) show in yellow:</p><p><img src="../Images/d63a7003f02c1f4bfd00ac93817af463.png" alt="" width="554" height="179" data-original-src="https://dcic-world.org/2025-08-27/events-table-w-labels.png"/></p><p>Since we did not specify labels for the rows, Pandas has used numeric
labels by default. At the moment, the positions and the labels are the
same for each row, but we will see that this is not always the case.</p><p>(If you look at the actual loaded table, some of the blank cells in
the discount column will contain <code data-lang="text/x-python" class="sourceCode">NaN</code>, which is the standard
Python value for â€œmissing informationâ€. We will deal with that
information shortly.</p>&#13;
<h5 class="heading">10.1.1.3Â <a name="(part._.Using_.Labels_and_.Indices_to_.Access_.Cells)"/>Using Labels and Indices to Access Cells<a href="#(part._.Using_.Labels_and_.Indices_to_.Access_.Cells)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Rows, columns, and cells can be accessed using either their (numeric)
positions or their labels. Here are some examples:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['numtix']         # extract the numtix column as a series
events['numtix'][2]      # get the value in the numtix column, row 2
events.loc[6]            # extract row with label 6 from the DataFrame
events.loc[6]['numtix']  # get the value in row with label 6, numtix column
events.iloc[6]           # extract the row with index/position 6</code></pre><p>Notice that we used different notation for accessing a cell
depending on whether we accessed the row first or the column
first. This is because we are showing you how to access data through
either position indices or labels. Using <code data-lang="text/x-python" class="sourceCode">.loc</code> tells Pandas
that you are using a label to access a row. If you want to use the
position instead, you need to use <code data-lang="text/x-python" class="sourceCode">iloc</code> (the <code data-lang="text/x-python" class="sourceCode">i</code> stands
for â€œintegerâ€). If you are using a programmer-supplied label instead,
you can just use the label directly.</p><p>In a DataFrame, both rows and columns always have position indices and may
have labels. The <code data-lang="text/x-python" class="sourceCode">.loc</code> notation works on either rows or
columns, we just happened to illustrate the notation on the rows since
we had already created labels on the columns when we loaded <code data-lang="text/x-python" class="sourceCode">events</code>.</p>&#13;
<h4 class="heading">10.1.2Â <a name="(part._.Filtering_.Rows)"/>Filtering Rows<a href="#(part._.Filtering_.Rows)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Back in Pyret, we filtered rows from a table by writing a function
from <code data-lang="pyret" class="sourceCode">Row</code> to <code data-lang="pyret" class="sourceCode">Boolean</code>. The <code data-lang="pyret" class="sourceCode">filter-with</code> function
applied that function to every row in the table, returning a new table
with those rows for which the predicate were true.</p><p>In Pandas, we select rows by providing an array of Booleans that has
the same length as the number of rows in the DataFrame. Filtering keeps
those rows for which the corresponding array entry is <code data-lang="text/x-python" class="sourceCode">True</code>.
For example, hereâ€™s our DataFrame diagram from before, this time with an
array to the right indicating that we want to keep rows 0, 2, and
6.</p><p><img src="../Images/0958f43b8192439a6fd898de3fbe50fb.png" alt="" width="660" height="173" data-original-src="https://dcic-world.org/2025-08-27/events-table-w-keep-array.png"/></p><p>The â€œkeepâ€ array is not part of the DataFrame. Here is the
corresponding array expressed in code, followed by the notation to use
the array to filter the DataFrame:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># which rows we want
keep = [True, False, True, False, False, False, True]</code></pre><p>Once we have the array of booleans, we use it to extract a collection
of rows using similar notation that we previously used to extract a
column. Just as we wrote <code data-lang="text/x-python" class="sourceCode">events['numtix']</code> to select the
<code data-lang="text/x-python" class="sourceCode">'numtix'</code> column, we can write <code data-lang="text/x-python" class="sourceCode">events[keep]</code> to
select a collection of rows. The DataFrame that results from filtering
(along with the <code data-lang="text/x-python" class="sourceCode">True</code> cells of the <code data-lang="text/x-python" class="sourceCode">keep</code> array for
illustration) appears as follows:</p><p><img src="../Images/0baa50e0adf5a889a71a977667d9c7e9.png" alt="" width="659" height="101" data-original-src="https://dcic-world.org/2025-08-27/events-table-filtered-result.png"/></p><p>How does Pandas know whether we want to select rows or columns? It
depends on what we provide in the square brackets: if we provide a
single label, we get the column or row with that label; if we provide
an array of booleans, we get the rows for which the corresponding row
(by position) is <code data-lang="text/x-python" class="sourceCode">True</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Look at the returned DataFrame. Do you notice anything interesting?</p></blockquote></blockquote><p>Look at the row labels and indices: the labels have been retained from
the original DataFrame (0, 2, and 6), while the indices are a sequence
of consecutive numbers starting from 0. Having both ways to reference
rowsâ€”<wbr/>one based on raw order and the other based on
programmer-provided labelsâ€”<wbr/>provides a lot of flexibility as we use
filter to isolate parts of tables that we want to work on.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Does filtering rows this way in Python keep the original
<code data-lang="text/x-python" class="sourceCode">events</code> DataFrame intact? Try it out!</p></blockquote></blockquote><p>Arrays of booleans that are used for filtering out other arrays are
called masks. Here, we have shown a simple mask that we
constructed by hand. If we had a long DataFrame, however, we would not
want to construct a mask for it by hand. Fortunately, we donâ€™t have
to. Python provides notations that let us construct masks via
expressions over a series.</p><p>Imagine that we wanted to filter the <code data-lang="text/x-python" class="sourceCode">events</code> table down to
those rows with delivery method <code data-lang="text/x-python" class="sourceCode">'email'</code>. To create a mask for
this, we first select the delivery column as a series:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['delivery']</code></pre><p>Next, we use the series in a boolean expression that states the
constraint that we want on each element of the series:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['delivery'] == 'email'</code></pre><p>Wait, whatâ€™s going on here? <code data-lang="text/x-python" class="sourceCode">events['deliver']</code> is a Series (a
labeled array of strings). <code data-lang="text/x-python" class="sourceCode">'email'</code> is a string. What does it
even mean to ask whether two values of different types be considered
equal, especially when one has many component values and the other
does not?</p><p>In this case, the <code data-lang="text/x-python" class="sourceCode">==</code> doesnâ€™t mean â€œare these equalâ€?
Instead, Python applies <code data-lang="text/x-python" class="sourceCode">== 'email'</code> to every element of the
<code data-lang="text/x-python" class="sourceCode">events['delivery']</code> Series, constructing a new Series of the
results. This idea of applying an operation to all elements of an
array is known as â€œliftingâ€. It is one of the shortcuts that Python
provides to help experienced programmers do simple common
tasks quickly and easily.</p><p>Now that we have a Series of booleans (for which events will be picked
up by email), we can use it to select those rows from the
<code data-lang="text/x-python" class="sourceCode">events</code> DataFrame:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events[events['delivery'] == 'email']</code></pre><p>The inner use of <code data-lang="text/x-python" class="sourceCode">events</code> is for creating the mask, while the
outer one is for filtering the table with that mask.</p><p>As a warning: if you search online for information on how to filter or
process DataFrame, you might find code samples that do this using for
loops. While that approach works, it isnâ€™t considered good Pandas (or
general programming) practice. Most modern languages provide built-in
constructs for iterating over lists and other sequence-style
data. These operations have more descriptive names than generic loops
(which makes them easier for other programmers to read), and are often
engineered to run more efficiently under the hood. As a general rule,
only default to basic loops if there is no built-in operator to do the
computation that you have in mind.</p>&#13;
<h4 class="heading">10.1.3Â <a name="(part._.Cleaning_and_.Normalizing_.Data)"/>Cleaning and Normalizing Data<a href="#(part._.Cleaning_and_.Normalizing_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>The same operator-lifting idea that we just saw when creating masks
from DataFrames also comes into play for normalizing data. Recall that
when we worked with the <code data-lang="text/x-python" class="sourceCode">events</code> table in Pyret, we converted
all of the discount codes to lowercase. Hereâ€™s the code that does this
in Pandas:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['discount'] = events['discount'].str.lower()</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Look at the above code. Break it down and try to articulate what each
part does. Do any parts seem new or different from things weâ€™ve done
so far in Pandas?</p></blockquote></blockquote><p>On the right side of the <code data-lang="text/x-python" class="sourceCode">=</code>, we are extracting the Series of
discount codes (<code data-lang="text/x-python" class="sourceCode">events['discount']</code>), then using the lowercase
operation on strings <code data-lang="text/x-python" class="sourceCode">str.lower()</code> to convert each one,
building up a Series of the results. Normally, given a string (such as
<code data-lang="text/x-python" class="sourceCode">'BIRTHDAY'</code>), we could get a lowercase version of it by
writing just <code data-lang="text/x-python" class="sourceCode">'BIRTHDAY'.lower()</code>. Whatâ€™s the extra <code data-lang="text/x-python" class="sourceCode">str</code>
doing in there?</p><p>This is a nuance about lifting. Python can evaluate
<code data-lang="text/x-python" class="sourceCode">'BIRTHDAY'.lower()</code> because <code data-lang="text/x-python" class="sourceCode">lower()</code> is defined
directly on strings. <code data-lang="text/x-python" class="sourceCode">lower()</code> is not, however, directly
defined on Series. To bridge the gap between having Series data and
wanting to use a string operation on it, we insert <code data-lang="text/x-python" class="sourceCode">str</code> before
<code data-lang="text/x-python" class="sourceCode">lower()</code>. Effectively, this tells Python where to find the
<code data-lang="text/x-python" class="sourceCode">lower()</code> operation (in the collection of operations defined on
strings).</p><p>The left side of the above code looks like:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['discount'] = ...</code></pre><p>This tells Pandas to replace the current contents of the
<code data-lang="text/x-python" class="sourceCode">'discount'</code> series with the series on the right side of the
<code data-lang="text/x-python" class="sourceCode">=</code>. It is similar to <code data-lang="pyret" class="sourceCode">transform-column</code> from Pyret, but with a
fundamental difference: in Pyret, <code data-lang="pyret" class="sourceCode">transform-column</code> left the old
table intact and produced a new table with the new column
values. Instead, in Pandas the old column gets replaced, thus
destroying the original table. There are many nuances to having
operations destroy and replace data; the chapter on
<a href="mutating-structures.html" data-pltdoc="x">Mutating Structures</a> studies them in detail.</p><section class="SsectionLevel5" id="section 10.1.3.1"><h5 class="heading">10.1.3.1Â <a name="(part._.Clearing_out_unknown_values)"/>Clearing out unknown values<a href="#(part._.Clearing_out_unknown_values)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Now letâ€™s try a different cleaning and normalization problem: we want
the discount column to contain only known discount codes or empty
strings. The <code data-lang="text/x-python" class="sourceCode">none</code> entry in line 3 of the table should be
converted to an empty string, and we should make sure that all of the
<code data-lang="text/x-python" class="sourceCode">NaN</code> and
seemingly empty entries in the discount cells are also converted to empty
strings (as opposed to strings of multiple spaces).</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Plan out how you might do this task using mask expressions. Even if
you donâ€™t know all the specific notation for the operations you need,
you can still work out a plan for completing this task.</p></blockquote></blockquote><p>If you planned out the tasks, you might have a todo list like the
following:</p><ol><li><p>create a mask of rows with known discount codes</p></li><li><p>invert that mask (swap the false and true values)</p></li><li><p>filter the DataFrame to rows without a known discount code</p></li><li><p>replace all the discount column values in that DataFrame with an
empty string</p></li></ol><p>We have seen how to do parts of steps 1 and 3, but neither of steps 2
and 4. Letâ€™s work through the steps one by one:</p><p>Hereâ€™s the code for step 1, which creates a mask for the rows with
known discount codes:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">codes = ['birthday', 'student']     # a list of valid codes
events['discount'].isin(codes)      # which rows have valid codes</code></pre><p>Here, we use a lifted <code data-lang="text/x-python" class="sourceCode">isin</code> operator on lists to compute the mask.</p><p>For step 2, we have to swap the true and false values. We can do this
by using the negation operator <code data-lang="text/x-python" class="sourceCode">~</code> on the mask from step 1:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">~events['discount'].isin(codes)</code></pre><p>For step 3, we want to filter <code data-lang="text/x-python" class="sourceCode">events</code> with this mask. Just to
keep the code easier to read, weâ€™ll give the mask a name and then
perform the filter:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">mask = ~events['discount'].isin(codes)   # rows with INVALID codes
events[mask]</code></pre><p>Finally, we use <code data-lang="text/x-python" class="sourceCode">=</code> to set the discount column of the filtered
DataFrame to the empty string:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events[mask]['discount'] = ''</code></pre><p>Whoops â€“ this seems to have generated an error message that says
something about a â€œSettingWithCopyWarningâ€. This is a subtlety that
has to do with what happens when data gets updated under the hood (weâ€™ll learn
about subtleties of mutation in <a href="mutable-lists.html" data-pltdoc="x">Mutable Lists</a>).
For now, weâ€™ll use this alternate form that
avoids the error:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events.loc[mask,'discount'] = ''</code></pre><p>Putting it all together, the entire program looks like:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">codes = ['birthday', 'student']
mask = ~events['discount'].isin(codes)
events.loc[mask]['discount'] = ''</code></pre><p>Summarizing, the code pattern for updating values for a column in some
rows of a DataFrame is as follows:</p><ul class="compact"><li><p>make a boolean series mask for which rows to update</p></li><li><p>use the mask to select just the rows where the mask is true</p></li><li><p>use <code data-lang="text/x-python" class="sourceCode">.loc</code> with the mask and column name to select the
series of cells to update</p></li><li><p>use <code data-lang="text/x-python" class="sourceCode">=</code> to give those cells their new value</p></li></ul><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Follow the above pattern to transform all delivery values of
<code data-lang="text/x-python" class="sourceCode">'yes'</code> to <code data-lang="text/x-python" class="sourceCode">'pickup'</code>.</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 10.1.3.2"><h5 class="heading">10.1.3.2Â <a name="(part._.Repairing_.Values_and_.Column_.Types)"/>Repairing Values and Column Types<a href="#(part._.Repairing_.Values_and_.Column_.Types)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>The source file for the <code data-lang="text/x-python" class="sourceCode">events</code> table contained an error in
which someone entered the string <code data-lang="text/x-python" class="sourceCode">'three'</code> in place of the
number <code data-lang="text/x-python" class="sourceCode">3</code> for the number of tickets in the last row. We can
repair errors like this manually:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events.loc[6]['numtix'] = 3</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Make this repair and ask your Python environment to show you the
corrected table.</p></blockquote></blockquote><p>Now that the <code data-lang="text/x-python" class="sourceCode">'numtix'</code> column contains only numbers, we can
total the number of tickets that were sold:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['numtix'].sum()</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What did you get? Why?</p></blockquote></blockquote><p>Because Python environments print strings without quotation marks, the
numtix column appears to contain numbers. The failure of <code data-lang="text/x-python" class="sourceCode">sum</code>
shows that this is indeed not the case. We can inspect the types that
Python has determined for the numtix values using the <code data-lang="text/x-python" class="sourceCode">type</code>
operation:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">type(events['numtix'].loc[0])  # prints str
type(events['numtix'].loc[6])  # prints int for the corrected value</code></pre><p>What happened here? During the original call to <code data-lang="text/x-python" class="sourceCode">read_csv</code>,
Python detected both numeric and string data in the numtix column. It
therefore read in all the values as strings. Our manual repair that
replaced the string <code data-lang="text/x-python" class="sourceCode">'three'</code> with the number <code data-lang="text/x-python" class="sourceCode">3</code> fixed
the value and type for one row, but the remaining values in that
column have still been read in as integers.</p><p>Fortunately, Python provides an operation to change the type of data
within a series. The following code converts the values in the
<code data-lang="text/x-python" class="sourceCode">events['numtix']</code> series to integers, updating the series
within the DataFrame in the process.</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['numtix'] = events['numtix'].astype('int')

events['numtix'].sum()    # now this works</code></pre></section>&#13;
<h5 class="heading">10.1.3.1Â <a name="(part._.Clearing_out_unknown_values)"/>Clearing out unknown values<a href="#(part._.Clearing_out_unknown_values)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Now letâ€™s try a different cleaning and normalization problem: we want
the discount column to contain only known discount codes or empty
strings. The <code data-lang="text/x-python" class="sourceCode">none</code> entry in line 3 of the table should be
converted to an empty string, and we should make sure that all of the
<code data-lang="text/x-python" class="sourceCode">NaN</code> and
seemingly empty entries in the discount cells are also converted to empty
strings (as opposed to strings of multiple spaces).</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Plan out how you might do this task using mask expressions. Even if
you donâ€™t know all the specific notation for the operations you need,
you can still work out a plan for completing this task.</p></blockquote></blockquote><p>If you planned out the tasks, you might have a todo list like the
following:</p><ol><li><p>create a mask of rows with known discount codes</p></li><li><p>invert that mask (swap the false and true values)</p></li><li><p>filter the DataFrame to rows without a known discount code</p></li><li><p>replace all the discount column values in that DataFrame with an
empty string</p></li></ol><p>We have seen how to do parts of steps 1 and 3, but neither of steps 2
and 4. Letâ€™s work through the steps one by one:</p><p>Hereâ€™s the code for step 1, which creates a mask for the rows with
known discount codes:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">codes = ['birthday', 'student']     # a list of valid codes
events['discount'].isin(codes)      # which rows have valid codes</code></pre><p>Here, we use a lifted <code data-lang="text/x-python" class="sourceCode">isin</code> operator on lists to compute the mask.</p><p>For step 2, we have to swap the true and false values. We can do this
by using the negation operator <code data-lang="text/x-python" class="sourceCode">~</code> on the mask from step 1:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">~events['discount'].isin(codes)</code></pre><p>For step 3, we want to filter <code data-lang="text/x-python" class="sourceCode">events</code> with this mask. Just to
keep the code easier to read, weâ€™ll give the mask a name and then
perform the filter:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">mask = ~events['discount'].isin(codes)   # rows with INVALID codes
events[mask]</code></pre><p>Finally, we use <code data-lang="text/x-python" class="sourceCode">=</code> to set the discount column of the filtered
DataFrame to the empty string:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events[mask]['discount'] = ''</code></pre><p>Whoops â€“ this seems to have generated an error message that says
something about a â€œSettingWithCopyWarningâ€. This is a subtlety that
has to do with what happens when data gets updated under the hood (weâ€™ll learn
about subtleties of mutation in <a href="mutable-lists.html" data-pltdoc="x">Mutable Lists</a>).
For now, weâ€™ll use this alternate form that
avoids the error:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events.loc[mask,'discount'] = ''</code></pre><p>Putting it all together, the entire program looks like:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">codes = ['birthday', 'student']
mask = ~events['discount'].isin(codes)
events.loc[mask]['discount'] = ''</code></pre><p>Summarizing, the code pattern for updating values for a column in some
rows of a DataFrame is as follows:</p><ul class="compact"><li><p>make a boolean series mask for which rows to update</p></li><li><p>use the mask to select just the rows where the mask is true</p></li><li><p>use <code data-lang="text/x-python" class="sourceCode">.loc</code> with the mask and column name to select the
series of cells to update</p></li><li><p>use <code data-lang="text/x-python" class="sourceCode">=</code> to give those cells their new value</p></li></ul><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Follow the above pattern to transform all delivery values of
<code data-lang="text/x-python" class="sourceCode">'yes'</code> to <code data-lang="text/x-python" class="sourceCode">'pickup'</code>.</p></blockquote></blockquote>&#13;
<h5 class="heading">10.1.3.2Â <a name="(part._.Repairing_.Values_and_.Column_.Types)"/>Repairing Values and Column Types<a href="#(part._.Repairing_.Values_and_.Column_.Types)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>The source file for the <code data-lang="text/x-python" class="sourceCode">events</code> table contained an error in
which someone entered the string <code data-lang="text/x-python" class="sourceCode">'three'</code> in place of the
number <code data-lang="text/x-python" class="sourceCode">3</code> for the number of tickets in the last row. We can
repair errors like this manually:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events.loc[6]['numtix'] = 3</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Make this repair and ask your Python environment to show you the
corrected table.</p></blockquote></blockquote><p>Now that the <code data-lang="text/x-python" class="sourceCode">'numtix'</code> column contains only numbers, we can
total the number of tickets that were sold:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['numtix'].sum()</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What did you get? Why?</p></blockquote></blockquote><p>Because Python environments print strings without quotation marks, the
numtix column appears to contain numbers. The failure of <code data-lang="text/x-python" class="sourceCode">sum</code>
shows that this is indeed not the case. We can inspect the types that
Python has determined for the numtix values using the <code data-lang="text/x-python" class="sourceCode">type</code>
operation:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">type(events['numtix'].loc[0])  # prints str
type(events['numtix'].loc[6])  # prints int for the corrected value</code></pre><p>What happened here? During the original call to <code data-lang="text/x-python" class="sourceCode">read_csv</code>,
Python detected both numeric and string data in the numtix column. It
therefore read in all the values as strings. Our manual repair that
replaced the string <code data-lang="text/x-python" class="sourceCode">'three'</code> with the number <code data-lang="text/x-python" class="sourceCode">3</code> fixed
the value and type for one row, but the remaining values in that
column have still been read in as integers.</p><p>Fortunately, Python provides an operation to change the type of data
within a series. The following code converts the values in the
<code data-lang="text/x-python" class="sourceCode">events['numtix']</code> series to integers, updating the series
within the DataFrame in the process.</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['numtix'] = events['numtix'].astype('int')

events['numtix'].sum()    # now this works</code></pre>&#13;
<h4 class="heading">10.1.4Â <a name="(part._.Computing_.New_.Columns)"/>Computing New Columns<a href="#(part._.Computing_.New_.Columns)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Letâ€™s extend the events table with the total cost of tickets, while
also accounting for a discount. Weâ€™ll start by building a column for
the ticket price without any discounts. This is a straightforward
application of lifting as weâ€™ve seen it so far:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">ticket_price = 10
events['total'] = events['numtix'] * ticket_price</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Use masks, operator lifting, filtering, and series updating to give a
10% discount to everyone with the â€œbirthdayâ€ discount code.</p></blockquote></blockquote><p>We do this by creating a mask for the â€œbirthdayâ€ discount, then
updating just that part of the DataFrame.</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">bday_mask = events['discount'] == 'birthday'
events.loc[bday_mask,'total'] = events['total'] * 0.90</code></pre><p>Notice that the notation for computing new columns and updating
existing ones is the same (unlike in Pyret, where we had different
operations <code data-lang="pyret" class="sourceCode">build-column</code> and <code data-lang="pyret" class="sourceCode">transform-column</code>). In
Pandas, a new column is created if the given column name doesnâ€™t
already exist in the DataFrame; otherwise, the existing column with
the given name gets updated.</p>&#13;
<h4 class="heading">10.1.5Â <a name="(part._.Aggregating_and_.Grouping_.Columns)"/>Aggregating and Grouping Columns<a href="#(part._.Aggregating_and_.Grouping_.Columns)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Pandas has built-in operations for doing standard mathematical
computations over series. For example, to total the number of tickets
sold or to compute the average number of tickets per order, we can write</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events['numtix'].sum()   # compute total number of tickets sold
events['numtix'].mean()  # compute average number of tickets per sale</code></pre><p>These are the same built-in operations that apply to Python lists.</p><p>Imagine now that we wanted a finer-grained look at total ticket
sales. Rather than just the total sold overall, weâ€™d like the total
sold per discount category.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How might you compute this?</p></blockquote></blockquote><p>We could imagine constructing a list of the discount codes, filtering
the ticket sales table to each code, then using <code data-lang="text/x-python" class="sourceCode">sum</code> on each
filtered table. This feels like a lot of work, however. Producing
summaries of one column (e.g., <code data-lang="text/x-python" class="sourceCode">``numtix''</code>) around the values
in another (e.g., <code data-lang="text/x-python" class="sourceCode">``discount''</code>) is a common technique in data
analysis. Spreadsheets typically provide a feature called a â€œpivot
tableâ€ that supports such a view of data.</p><p>In Pandas, we can do a computation like this using an operation called
<code data-lang="text/x-python" class="sourceCode">groupby</code>. Hereâ€™s are two examples. The first reports how many
sales (rows) were made with each discount code, while the second summarize the total
number of tickets sold by discount code:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">events.groupby('discount').count()
events.groupby('discount')['numtix'].sum()</code></pre><p><code data-lang="text/x-python" class="sourceCode">groupby</code> takes the name of the column whose values will be
used to cluster rows. It returns a special type of data (called
<code data-lang="text/x-python" class="sourceCode">GroupBy</code>). From there, we can select a column and perform an
operation on it. The column selection and operation are performed on
each collection of rows in the <code data-lang="text/x-python" class="sourceCode">GroupBy</code>. The results of the
second expression in the above code are reported in a new DataFrame:</p><p><img src="../Images/0b9ecb1c08c84c777f66a57137d73fb3.png" alt="" width="143" height="104" data-original-src="https://dcic-world.org/2025-08-27/grouby-table-example.png"/></p><p>In this DataFrame, discount labels a column. The first row has the
empty string in the discount column, with 14 tickets purchased without
discount codes. There were 2 tickets purchased with a birthday
discount and 8 with a student discount.</p><p>The Pandas documentation provides a large collection of operations
that can used on <code data-lang="text/x-python" class="sourceCode">GroupBy</code> data; these cover computations such
as counting, mean, finding largest and smallest values, and performing
various other statistical operations.</p>&#13;
<h4 class="heading">10.1.6Â <a name="(part._.Wide_.Versus_.Tall_.Data)"/>Wide Versus Tall Data<a href="#(part._.Wide_.Versus_.Tall_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Letâ€™s try grouping data on a different dataset. Hereâ€™s a table showing
sales data across several regions during each month of the year:</p><p><img src="../Images/ec0e7f8f6b70454dec5da967061e0316.png" alt="" width="446" height="255" data-original-src="https://dcic-world.org/2025-08-27/sales-wide.png"/></p><p>Copy the following code to load this table for yourself.</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">import pandas as pd

sales_url = "https://raw.githubusercontent.com/data-centric-computing/dcic-public/main/materials/datasets/sales-wide.csv"
col_names = ['month','division','northwest','northeast','central','southeast','southwest']
sales = pd.read_csv(sales_url, header=0, names=col_names)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Here are several questions that we might want to ask from this
dataset. For each one, develop a plan that indicates which Pandas
operations you would use to answer it. If a question seems hard to
answer with the operations you have, explain whatâ€™s difficult about
answering that question.</p><ol><li><p>In which month did the northwest region have the lowest sales?</p></li><li><p>What were the total sales per month across all regions?</p></li><li><p>Which region had the highest sales in April?</p></li><li><p>Which region had the highest sales for the entire year?</p></li></ol></blockquote></blockquote><p>For question 1, we can sort the table by northwest sales in decreasing
order, then see which month is listed in the first row.</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">s = sales.sort_values('northwest',ascending=True)
s.iloc[0]['month']</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What value would we have gotten had we used <code data-lang="text/x-python" class="sourceCode">loc</code> instead of
<code data-lang="text/x-python" class="sourceCode">iloc</code> in the above code?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Did sorting the <code data-lang="text/x-python" class="sourceCode">sales</code> table change the row order permanently?
Check by having Python show you the value of <code data-lang="text/x-python" class="sourceCode">sales</code> after you run
<code data-lang="text/x-python" class="sourceCode">sort_values</code>.</p></blockquote></blockquote><p>For question 2, we could build a new column that stores the sales data
across each row:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># we use parens around the right side to break the expression across
# multiple lines, rather than extend past the window edge
sales['total'] = (sales['northwest'] + sales['northeast'] +
                  sales['central'] + sales['southeast'] +
                  sales['southwest'])</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Did computing the <code data-lang="text/x-python" class="sourceCode">total</code> column change the row order permanently?
Check by having Python show you the value of <code data-lang="text/x-python" class="sourceCode">sales</code> after you run the
code.</p></blockquote></blockquote><p>(If you want to remove the new <code data-lang="text/x-python" class="sourceCode">total</code> column, you can do this with
<code data-lang="text/x-python" class="sourceCode">sales = sales.drop(columns='total')</code>.)</p><p>Question 3 is more challenging because we want to sort on the regions,
which are in columns rather than rows. Question 4 is even more
challenging because we want to produce sums of columns, then compare
regions. Both of these feel a bit like problems we might know how to
solve if the rows corresponded to regions rather than months, but that
isnâ€™t how our data are organized. And even if we did flip the table
around (we could, the technical term for this is <code data-lang="text/x-python" class="sourceCode">transpose</code>),
problem 4 would still feel a bit complicated by the time we computed
annual sales per region and sorted them.</p><p>What if instead our table had looked like the following? Would
questions 3 and 4 get any easier?</p><p><img src="../Images/0b8815a10314d9cdee7892b1e09f891d.png" alt="" width="249" height="234" data-original-src="https://dcic-world.org/2025-08-27/sales-tall-snippet.png"/></p><p>With the data organized this way, question 3 can be answered with a
combination of row selection and <code data-lang="text/x-python" class="sourceCode">sort_values</code>. Question 4
becomes easy to answer with a <code data-lang="text/x-python" class="sourceCode">groupby</code>. Even the code for
Question 2 gets cleaner.</p><p>The contrast between these two tables highlights that how our data are
organized can determine how easy or hard it is to process them with the
standard operations provided by table-processing packages such as
Pandas (what weâ€™re discussing here applies to other languages that
support tables, such as Pyret and R).</p><p>In general, the operations in table-processing packages were designed
to assume that there is one core observation per row (about which we
might have many smaller details or attributes), and that we will want
to aggregate and display data across rows, not across columns. Our
original treated each month as an observation, with the regions being
details. For questions 1 and 2, which focused on months, the built-in
operations sufficed to process the table. But for questions 3 and 4,
which focused on regions or combinations of regions and months, it
helps to have each month and region data be in its own row.</p><p>Tables like the original <code data-lang="text/x-python" class="sourceCode">sales</code> data are called wide
tables, whereas the second form are termed tall tables. At
the extremes, wide tables have every variable in its own column
whereas tall tables have only one column for a single value of
interest, with a separate row for each variable that contributed to
that value. Wide tables tend to be easier for people to read; as we
have seen with our sales data, tall tables can be easier to process in
code, depending on how our questions align with our variables.</p><section class="SsectionLevel5" id="section 0"><h5 class="heading"><a name="(part._.Converting_.Between_.Wide_and_.Tall_.Data)"/>Converting Between Wide and Tall Data<a href="#(part._.Converting_.Between_.Wide_and_.Tall_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Table-processing packages generally provide built-in operators for
converting between wide and tall data formats. The following Pandas
expression converts the (original) wide-format <code data-lang="text/x-python" class="sourceCode">sales</code> table into a
tall-format table, retaining the month of the year and the product
division as a label on every datapoint:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">sales.melt(id_vars=['month','division'])</code></pre><p>This basic <code data-lang="text/x-python" class="sourceCode">melt</code> expression uses default column names of
<code data-lang="text/x-python" class="sourceCode">variable</code> and <code data-lang="text/x-python" class="sourceCode">value</code> for the new columns. We can
customize those names as part of the <code data-lang="text/x-python" class="sourceCode">melt</code> call if we wish:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">sales_tall = sales.melt(id_vars=['month','division'],var_name='region',value_name='sales')</code></pre><p>Letâ€™s put the wide and tall tables side by side to visualize what
<code data-lang="text/x-python" class="sourceCode">melt</code> is doing.</p><p><img src="../Images/3a8f49b403e48f063552947c7f7f252d.png" alt="" width="800" height="253" data-original-src="https://dcic-world.org/2025-08-27/wide-tall-mapping.png"/></p><p>The columns named in <code data-lang="text/x-python" class="sourceCode">id_vars</code> remain in the original
table. For each column not named in <code data-lang="text/x-python" class="sourceCode">id_vars</code>, a row is
created with the <code data-lang="text/x-python" class="sourceCode">id_vars</code> columns, the melted-column name, and
the melted-column value for the <code data-lang="text/x-python" class="sourceCode">id_vars</code>. The above figure
color codes how cells from the wide table are arranged in the melted
tall table.</p><p>With the tall table in hand, we can proceed to answer questions 3 and
4, as well as to redo our solution to question 2:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># Question 2: total sales per month across regions
sales_tall.groupby('region').sum()

# Question 3: which region had the highest sales in April
apr_by_region = sales_tall[sales_tall['month'] == 'Apr']
apr_by_region.sort_values('sales', ascending=False).iloc[0]['region']

# Question 4: which region had the highest sales for the year
tot_sales_region = sales_tall.groupby('region').sum()
tot_sales_region.sort_values('sales',ascending=False).reset_index().iloc[0]['region']</code></pre><p>The solution to question 4 uses a new Pandas operator called
<code data-lang="text/x-python" class="sourceCode">reset_index</code>, which is needed if you want to manipulate the
output of a <code data-lang="text/x-python" class="sourceCode">group-by</code> as a regular DataFrame.</p></section>&#13;
<h5 class="heading"><a name="(part._.Converting_.Between_.Wide_and_.Tall_.Data)"/>Converting Between Wide and Tall Data<a href="#(part._.Converting_.Between_.Wide_and_.Tall_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Table-processing packages generally provide built-in operators for
converting between wide and tall data formats. The following Pandas
expression converts the (original) wide-format <code data-lang="text/x-python" class="sourceCode">sales</code> table into a
tall-format table, retaining the month of the year and the product
division as a label on every datapoint:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">sales.melt(id_vars=['month','division'])</code></pre><p>This basic <code data-lang="text/x-python" class="sourceCode">melt</code> expression uses default column names of
<code data-lang="text/x-python" class="sourceCode">variable</code> and <code data-lang="text/x-python" class="sourceCode">value</code> for the new columns. We can
customize those names as part of the <code data-lang="text/x-python" class="sourceCode">melt</code> call if we wish:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">sales_tall = sales.melt(id_vars=['month','division'],var_name='region',value_name='sales')</code></pre><p>Letâ€™s put the wide and tall tables side by side to visualize what
<code data-lang="text/x-python" class="sourceCode">melt</code> is doing.</p><p><img src="../Images/3a8f49b403e48f063552947c7f7f252d.png" alt="" width="800" height="253" data-original-src="https://dcic-world.org/2025-08-27/wide-tall-mapping.png"/></p><p>The columns named in <code data-lang="text/x-python" class="sourceCode">id_vars</code> remain in the original
table. For each column not named in <code data-lang="text/x-python" class="sourceCode">id_vars</code>, a row is
created with the <code data-lang="text/x-python" class="sourceCode">id_vars</code> columns, the melted-column name, and
the melted-column value for the <code data-lang="text/x-python" class="sourceCode">id_vars</code>. The above figure
color codes how cells from the wide table are arranged in the melted
tall table.</p><p>With the tall table in hand, we can proceed to answer questions 3 and
4, as well as to redo our solution to question 2:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># Question 2: total sales per month across regions
sales_tall.groupby('region').sum()

# Question 3: which region had the highest sales in April
apr_by_region = sales_tall[sales_tall['month'] == 'Apr']
apr_by_region.sort_values('sales', ascending=False).iloc[0]['region']

# Question 4: which region had the highest sales for the year
tot_sales_region = sales_tall.groupby('region').sum()
tot_sales_region.sort_values('sales',ascending=False).reset_index().iloc[0]['region']</code></pre><p>The solution to question 4 uses a new Pandas operator called
<code data-lang="text/x-python" class="sourceCode">reset_index</code>, which is needed if you want to manipulate the
output of a <code data-lang="text/x-python" class="sourceCode">group-by</code> as a regular DataFrame.</p>&#13;
<h4 class="heading">10.1.7Â <a name="(part._.Plotting_.Data)"/>Plotting Data<a href="#(part._.Plotting_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Letâ€™s continue with the sales data as we explore plotting in Pandas.</p><p>Letâ€™s say we now want to take a seasonal view, rather than a monthly
view, and look at sales within seasons.</p><p>Letâ€™s say we wanted to see how summer sales varied over the
years. This is a good situation in which to use a line plot. To create
this, we first need to load <code data-lang="text/x-python" class="sourceCode">matplotlib</code>, the Python graphic
library:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">import matplotlib.pyplot as plt
from Pandas.plotting import register_matplotlib_converters
register_matplotlib_converters()</code></pre><p>Next, to generate the line plots, we call the <code data-lang="text/x-python" class="sourceCode">plt.plot</code>
function on the series of numbers that we want to form the points on
the plot. We can also specify the values on the axes, as shown the
following examples.</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># create a new canvas in which to make the plot
plt.figure()

# plot month column (x-axis) vs northeast sales (y-axis)
plt.plot(sales['month'],sales['northeast'])

# add central sales to the same plot
plt.plot(sales['central'])

# add labels to the y-axis and the chart overall
plt.ylabel('Monthly Sales')
plt.title('Comparing Regional Sales')

# show the plot
plt.show()</code></pre><p>Pandas will put both line plots in the same display window. In
general, each time you call <code data-lang="text/x-python" class="sourceCode">plt.figure()</code>, you create a new
window in which subsequent plot commands will appear (at least until
you ask for a plot that does not nicely overlay with the previous plot
type).</p><p>The <code data-lang="text/x-python" class="sourceCode">matplotlib</code> package offers many kinds of charts and
customizations to graph layouts. A more comprehensive look is beyond
the scope of this book; see the <a href="https://matplotlib.org/stable/index.html">matplotlib website</a> for
tutorials and many examples of more sophisticated plots.</p>&#13;
<h4 class="heading">10.1.8Â <a name="(part._.Takeaways)"/>Takeaways<a href="#(part._.Takeaways)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>This chapter has been designed to give you an overview of Pandas while
pointing out key concepts in programming for data science. It is by no
means a comprehensive Pandas tutorial or reference guide: for those,
see the <a href="https://pandas.pydata.org/">Pandas website</a>.</p><p>Conceptually, we hope you will take away three high-level ideas from
this chapter:</p><ul><li><p>There are two notions for how to access specific cells in
tables and DataFrames: by numeric position (e.g., first row, second
column) or by labeled index (e.g., numtix). Both have their roles
in professional-grade data analysis programming. Filter-like
operations that extract rows from tables maintain labeled indices, but
renumber the positional ones (so that every DataFrame has a sequence
of consecutively-numbered rows).</p></li><li><p>Professional-grade programming languages sometimes â€œliftâ€
operations from single values to collections of values (e.g., using
<code data-lang="text/x-python" class="sourceCode">+</code> to add elements within similarly-sized series). Lifting can
be a powerful and timesaving tool for programmers, but they can also
lead to type confusions for both novices and experienced
programmers. You should be aware that this feature exists as you learn
new languages and packages.</p></li><li><p>Different table organizations (for the same data) are better in
different situations. Wide and tall tables are two general shapes,
each with their own affordances. You should be aware that
table-processing packages provide a variety of tools to help you
automatically reformat tables. If the computation you are trying to do
feels too complicated, stop and consider whether the problem would be
easier with a different organization of the same data.</p></li></ul>    
</body>
</html>