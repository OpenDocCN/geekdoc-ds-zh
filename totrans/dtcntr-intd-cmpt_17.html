<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>6.2Â Collections of Structured DatağŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>6.2Â Collections of Structured DatağŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/Collections_of_Structured_Data.html">https://dcic-world.org/2025-08-27/Collections_of_Structured_Data.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._.Lists_as_.Collective_.Data%29" class="toclink" data-pltdoc="x">6.2.1Â Lists as Collective Data</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._sets-as-collections%29" class="toclink" data-pltdoc="x">6.2.2Â Sets as Collective Data</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._coll-sd-pick%29" class="toclink" data-pltdoc="x">6.2.2.1Â Picking Elements from Sets</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Computing_with_.Sets%29" class="toclink" data-pltdoc="x">6.2.2.2Â Computing with Sets</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Combining_.Structured_and_.Collective_.Data%29" class="toclink" data-pltdoc="x">6.2.3Â Combining Structured and Collective Data</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Data_.Design_.Problem__.Representing_.Quizzes%29" class="toclink" data-pltdoc="x">6.2.4Â Data Design Problem: Representing Quizzes</a></p></td></tr></table><p>As we were looking at structured data [<a href="intro-struct-data.html" data-pltdoc="x">Introduction to Structured Data</a>],
we came across several situations where we have not one but many data:
not one song but a playlist of them, not one animal but a zoo full of
them, not one notification but several, not just one message (how we
wish!) but many in our inbox, and so on. In general, then, we rarely
have just a single structured datum: One notable exception:
consider the configuration or preference information for a
system. This might be stored in a file and updated through a user
interface. Even though there is (usually) only one configuration at a
time, it may have so many pieces that we wonâ€™t want to clutter our
program with a large number of variables; instead, we might create a
structure representing the configuration, and load just one instance
of it. In effect, what would have been unconnected variables
now become a set of linked fields.  if we know we have only
one, we might just have a few separate variables representing the
pieces without going to the effort of creating and taking apart a
structure. In general, therefore, we want to talk about
collections of structured data. Here are more examples:
</p><ul><li><p>The set of messages matching a tag.</p></li><li><p>The list of messages in a conversation.</p></li><li><p>The set of friends of a user.</p></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How are collective data different from structured data?</p></blockquote></blockquote><p>In structured data, we have a fixed number of possibly
different kinds of values. In collective data, we have a
variable number of the same kind of value. For instance, we
donâ€™t say up front how many songs must be in a playlist or how many
pages a user can have; but every one of them must be a song or a
page. (A page may, of course, be conditionally defined, but
ultimately everything in the collection is still a page.)</p><p>Observe that weâ€™ve mentioned both sets and lists
above. The difference between a set and a list is that a set has no
order, but a list has an order. This distinction is not vital now but
we will return to it later [<a href="#%28part._sets-as-collections%29" data-pltdoc="x">Sets as Collective Data</a>].</p><p>Of course, sets and lists are not the only kinds of collective data we
can have. Here are some more:
</p><ul><li><p>A family tree of people.</p></li><li><p>The filesystem on your computer.</p></li><li><p>A seating chart at a party.</p></li><li><p>A social network of pages.</p></li></ul><p>and so on. For the most part these are just as easy to program and
manipulate as the earlier collective data once we have some
experience, though some of them [<a href="Sharing_and_Equality.html#%28part._identical-eq%29" data-pltdoc="x">Re-Examining Equality</a>] can involve more subtlety.</p><p>We have already seen tables [<a href="intro-tabular-data.html" data-pltdoc="x">Introduction to Tabular Data</a>], which are
a form of collective, structured data. Now we will look at a few more,
and how to program them.</p><section class="SsectionLevel4" id="section 6.2.1"><h4 class="heading">6.2.1Â <a name="(part._.Lists_as_.Collective_.Data)"/>Lists as Collective Data<a href="#(part._.Lists_as_.Collective_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>We have already seen one example of a collection in
some depth before: lists. A list is not limited to numbers or strings;
it can contain any kind of value, including structured ones. For
instance, using our examples from earlier [<a href="intro-struct-data.html#%28part._struct-data-eg%29" data-pltdoc="x">Defining and Creating Structured Data</a>],
we can make a list of songs:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">song-list = [list: lver, so, wnkkhs]</code></pre><p>This is a three-element list where each element is a song:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  song-list.length() is 3
  song-list.first is lver
end</code></pre><p>Thus, what we have seen earlier about building functions over lists
[<a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>] applies here too. To illustrate, suppose
we wish to write the function <code data-lang="pyret" class="sourceCode">oldest-song-age</code>, which consumes a
list of songs and produces the oldest song in the list. (There may be
more than one song from the same year; the ageâ€”<wbr/>by our measureâ€”<wbr/>of
all those songs will be the same. If this happens, we just pick one of
the songs from the list. Because of this, however, it would be more
accurate to say â€œanâ€ rather than â€œtheâ€ oldest song.)</p><p>Letâ€™s work through this with examples. To keep our examples easy to
write, instead of writing out the full data for the songs, weâ€™ll refer
to them just by their variable names. Clearly, the oldest song in our
list is bound to <code data-lang="pyret" class="sourceCode">lvar</code>.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">oldest-song([list: lver, so, wnkkhs]) is lvar
oldest-song([list:       so, wnkkhs]) is wnkkhs
oldest-song([list:           wnkkhs]) is wnkkhs
oldest-song([list:                 ]) is ???</code></pre><p>What do we write in the last case? Recall that we saw this problem
earlier [<a href="processing-lists.html#%28part._my-max%29" data-pltdoc="x"><code data-lang="pyret" class="sourceCode">my-max</code>: Examples</a>]: there is no answer in the empty case. In
fact, the computation here is remarkably similar to that of
<code data-lang="pyret" class="sourceCode">my-max</code>, because it is essentially the same computation, just
asking for the minimum year (which would make the song the
oldest).</p><p>From our examples, we can see a solution structure echoing that of
<code data-lang="pyret" class="sourceCode">my-max</code>. For the empty list, we signal an error. Otherwise, we
compute the oldest song in the rest of the list, and compare its year
against that of the first. Whichever has the older year is the answer.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun oldest-song(sl :: List&lt;ITunesSong&gt;) -&gt; ITunesSong:
  cases (List) sl:
    | empty =&gt; raise("not defined for empty song lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; f
        | else =&gt;
          osr = oldest-song(r)
          if osr.year &lt; f.year:
            osr
          else:
            f
          end
      end
  end
end</code></pre><p>Note that there is no guarantee there will be only oldest song, and
this is reflected in the possibility that <code data-lang="pyret" class="sourceCode">osr.year</code> may
equal <code data-lang="pyret" class="sourceCode">f.year</code>. However, our problem statement allowed us
to pick just one such song, which is what weâ€™ve done.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Modify the solution above to <code data-lang="pyret" class="sourceCode">oldest-song-age</code>, which computes
the age of the oldest song(s).</p></blockquote></blockquote><p>Haha, just kidding! You shouldnâ€™t modify the previous solution at all!
Instead, you should leave it aloneâ€”<wbr/>it may come in handy for other
purposesâ€”<wbr/>and instead build a new function to use it:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun oldest-song-age(sl :: List&lt;ITunesSong&gt;) -&gt; Number:
  os = oldest-song(sl)
  song-age(os)
where:
  oldest-song-age(song-list) is 71
end</code></pre></section><section class="SsectionLevel4" id="section 6.2.2"><h4 class="heading">6.2.2Â <a name="(part._sets-as-collections)"/>Sets as Collective Data<a href="#(part._sets-as-collections)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>As weâ€™ve already seen, for some problems we donâ€™t care about the order
of inputs, nor about duplicates. Here are more examples where we donâ€™t
care about order or duplicates:
</p><ul><li><p>Your Web browser records which Web pages youâ€™ve
visited, and some Web sites use this information to color visited
links differently than ones you havenâ€™t seen. This color is typically
independent of how many times you have visited the page.</p></li><li><p>During an election, a poll agent might record that you have
voted, but does not need to record how many times you have voted, and
does not care about the order in which people vote.</p></li></ul><p>For such problems a list is a bad fit relative to a set. Here we will
see how Pyretâ€™s built-in sets work. In
[<a href="part_sets.html" data-pltdoc="x">Several Variations on Sets</a>] we will see how we can build sets for
ourselves.</p><p>First, we can define sets just as easily as we can lists:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import sets as S
song-set = [S.set: lver, so, wnkkhs]</code></pre><p>Of course, due to the nature of the languageâ€™s syntax, we have to
list the elements in some order. Does it matter?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How can we tell whether Pyret cares about the order?</p></blockquote></blockquote><p>Hereâ€™s the simplest way to check:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  song-set2 = [S.set: so, wnkkhs, lver]
  song-set is song-set2
end</code></pre><p>If we want to be especially cautious, we can write down all the other
orderings of the elements as well, and see that Pyret doesnâ€™t
care.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>How many different orders are there?</p></blockquote></blockquote><p>Similarly for duplicates:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  song-set3 = [S.set: lver, so, wnkkhs, so, so, lver, so]
  song-set is song-set3
  song-set3.size() is 3
end</code></pre><p>We can again try several different kinds of duplication and confirm
that sets ignore them.</p><section class="SsectionLevel5" id="section 6.2.2.1"><h5 class="heading">6.2.2.1Â <a name="(part._coll-sd-pick)"/>Picking Elements from Sets<a href="#(part._coll-sd-pick)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>This lack of an ordering, however, poses a problem. With lists, it was
meaningful to talk about the â€œfirstâ€ and corresponding â€œrestâ€. By
definition, with sets there is not â€œfirstâ€ element. In fact, Pyret
does not even offer fields similar to <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code>. In
its place is something a little more accurate but complex.</p><p>The <code data-lang="pyret" class="sourceCode">.pick</code> method returns a random element of a set. It
produces a value of type <code data-lang="pyret" class="sourceCode">Pick</code> (which we get with <code data-lang="pyret" class="sourceCode">include
pick</code>). When we pick an element, there are two
possibilities. One is that the set is empty (analogous to a list being
empty), which gives us a <code data-lang="pyret" class="sourceCode">pick-none</code> value. The other option is
called <code data-lang="pyret" class="sourceCode">pick-some</code>, which gives us an actual member of the set.</p><p>The <code data-lang="pyret" class="sourceCode">pick-some</code> variant of <code data-lang="pyret" class="sourceCode">Pick</code> has two fields, not
one. To understand why takes a momentâ€™s work. Letâ€™s explore it by
choosing an element of a set:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun an-elt(s :: S.Set):
  cases (Pick) s.pick():
    | pick-none =&gt; raise("empty set")
    | pick-some(e, r) =&gt; e
  end
end</code></pre><p>(Notice that we arenâ€™t using the <code data-lang="pyret" class="sourceCode">r</code> field in the
<code data-lang="pyret" class="sourceCode">pick-some</code> case.)</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can you guess why we didnâ€™t write examples for <code data-lang="pyret" class="sourceCode">an-elt</code>?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Run <code data-lang="pyret" class="sourceCode">an-elt(song-set)</code>. What element do you get?</p><p>Run it again. Run it five more times.</p><p>Do you get the same element every time?</p></blockquote></blockquote><p>No you donâ€™t!Well, actually, itâ€™s impossible to be certain
you donâ€™t. There is a very, very small likelihood you get the exact
same element on every one of six runs. If it happens to you, keep
running it more times!
Pyret is designed to not always return the same element
when picking from a set. This is on purpose: itâ€™s to drive home the
random nature of choosing from a set, and to prevent your program from
accidentally depending on a particular order that Pyret might use.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Given that <code data-lang="pyret" class="sourceCode">an-elt</code> does not return a predictable element, what
(if any) tests can we write for it?</p></blockquote></blockquote><p>Observe that though we canâ€™t predict which element <code data-lang="pyret" class="sourceCode">an-elt</code> will
produce, we do know it will produce an element of the set. Therefore,
what we can write are tests that ensure the resulting element is a
member of the setâ€”<wbr/>though in this case, that would not be
particularly surprising.</p></section><section class="SsectionLevel5" id="section 6.2.2.2"><h5 class="heading">6.2.2.2Â <a name="(part._.Computing_with_.Sets)"/>Computing with Sets<a href="#(part._.Computing_with_.Sets)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Once we have picked an element from a set, itâ€™s often useful to obtain
the set consisting of the remaining elements. We have already seen
that choosing the first field of a <code data-lang="pyret" class="sourceCode">pick-some</code> is similar to
taking the â€œfirstâ€ of a set. We therefore want a way to get the
â€œrestâ€ of the set. However, we want the rest to what we obtain after
excluding this particular â€œfirstâ€. Thatâ€™s what the second
field of a <code data-lang="pyret" class="sourceCode">pick-some</code> is: whatâ€™s left of the set.</p><p>Given this, we can write functions over sets that look roughly
analogous to functions over lists. For instance, suppose we want to
compute the size of a set. The function looks similar to
<code data-lang="pyret" class="sourceCode">my-len</code> [<a href="processing-lists.html#%28part._my-len%29" data-pltdoc="x">Some Example Exercises</a>]:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-set-size(s :: S.Set) -&gt; Number:
  cases (Pick) s.pick():
    | pick-none =&gt; 0
    | pick-some(e, r) =&gt;
      1 + my-set-size(r)
  end
end</code></pre><p>Though the process of deriving this is similar to that we used for
<code data-lang="pyret" class="sourceCode">my-len</code>, the random nature of picking elements makes it harder to
write examples that the actual functionâ€™s behavior will match.</p></section></section><section class="SsectionLevel4" id="section 6.2.3"><h4 class="heading">6.2.3Â <a name="(part._.Combining_.Structured_and_.Collective_.Data)"/>Combining Structured and Collective Data<a href="#(part._.Combining_.Structured_and_.Collective_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>As the above examples illustrate, a programâ€™s data organization will
often involve multiple kinds of compound data, often deeply
intertwined. Letâ€™s first think of these in pairs.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Come up with examples that combine:
</p><ul><li><p>structured and conditional data,</p></li><li><p>structured and collective data, and</p></li><li><p>conditional and collective data.</p></li></ul><p>Youâ€™ve actually seen examples of each of these above. Identify them.</p></blockquote></blockquote><p>Finally, we might even have all three at once. For instance, a
filesystem is usually a list (collective) of files and folders
(conditional) where each file has several attributes
(structured). Similarly, a social network has a set of pages
(collective) where each page is for a person, organization, or other
thing (conditional), and each page has several attributes
(structured). Therefore, as you can see, combinations of these arise
naturally in all kinds of applications that we deal with on a daily
basis.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Take three of your favorite Web sites or apps. Identify the kinds of
data they present. Classify these as structured, conditional, and
collective. How do they combine these data?</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 6.2.4"><h4 class="heading">6.2.4Â <a name="(part._.Data_.Design_.Problem__.Representing_.Quizzes)"/>Data Design Problem: Representing Quizzes<a href="#(part._.Data_.Design_.Problem__.Representing_.Quizzes)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Now that you can make collections of structured data, you can approach
creating the data and programs for fairly sophisticated
applications. Letâ€™s try out a data-design problem, where we will focus
just on creating the data definition, but not on writing the actual
functions.</p><p>Problem Statement:
Youâ€™ve been hired to help create software for giving quizzes to
students. The software will show the student a question, read in the
studentâ€™s answer, compare the studentâ€™s answer to the expected answer
(sort of like a Pyret example!), and produce the percentage of
questions that the student got right.</p><p>Your task is to create a data definition for capturing quizzes and
expected answers. Donâ€™t worry about representing the student
responses.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Propose an initial data structure for quizzes. Start by identifying
the pieces you might need and trying to write some sample questions.</p></blockquote></blockquote><p>We might imagine asking a quiz question like â€œwhat is 3 + 4?â€œ. We
would expect the student to answer <code data-lang="pyret" class="sourceCode">7</code>. What would capture this?
A piece of structured data with two fields like the following:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Question:
  basic-ques(text :: String, expect :: ???)
end</code></pre><p>Whatâ€™s a good type for the expected answer? This specific problem has
a numeric answer, but other questions might have other types of
answers. <code data-lang="pyret" class="sourceCode">Any</code> is therefore an appropriate type for the answer.</p><p>We would also need a list of <code data-lang="pyret" class="sourceCode">Question</code> to form an entire quiz.</p><p>Sometimes, quiz software allows students to ask for hints.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Assume we wanted to have some (but not all) questions with hints,
which would be text that a student could request for help with a
problem. Modify the current data definition to capture quizzes in
which some questions have hints and some do not.</p></blockquote></blockquote><p>A quiz should still be a list of questions, but the <code data-lang="pyret" class="sourceCode">Question</code>
data definition needs another variant in order to handle questions
with hints. The following would work:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Question:
  | basic-ques(text :: String, expect :: Any)
  | hint-ques(text :: String, expect :: Any, hint :: String)
end

A <code data-lang="pyret" class="sourceCode">quiz</code> is a <code data-lang="pyret" class="sourceCode">List&lt;Question&gt;</code></code></pre><p>We could imagine extending this example to introduce dependencies
between questions (such as one problem building on the skills of
another), multiple choice questions, checkbox questions, and so on.</p><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Consider the Process Being Displaced</p><blockquote class="RespCSBody"><p>Many companies have tried to improve education through software
systems that automate tasks otherwise done by teachers. There are
systems that show students a video, then give them quizzes (akin to
what you just developed) to check what they have learned. A more
extreme version interleaves videos and quizzes, thus teaching entire
courses at scale, without the need for teacher intervention.</p><p>Massively-online courses (MOOCs) are a style of course that makes
heavy use to computer automation, to enable reaching many more
students without needing more teachers. Proponents of MOOCs and
related educational technology tools have promised game-changing
impacts of such tools, promising to extend quality education to
students around the world who otherwise might lack access to quality
teachers. Technology investors (and indeed some universities) dove in
behind these technologies, hoping for an educational revolution at
scale.</p><p>Unfortunately, research and evaluation have shown that replacing
education with automated systems, even ones with sophisticated
features based on data analysis and predictions that identify skills
that students havenâ€™t quite mastered, doesnâ€™t lead to the promised
gains in learning. Why? It turns out that teaching is about more than
choosing questions, gathering student work, and giving
grades. Teachers provide encouragement, reassurance, and an
understanding of an individual studentsâ€™ situation. Todayâ€™s
computational systems donâ€™t do this. The generally-accepted wisdom
around these tools (backed by three prior decades of research) is that
they are best used to complement direct instruction by a human
teacher. In such a setting, some tools have resulted in solid
performance gains on the parts of students.</p><p>The social-responsibility takeaway here is that you need to
consider all the features of the system you might be trying to
replace with a computational approach. Algorithmic quiz-taking tools
have genuine value in some specific context, but they arenâ€™t a
replacement for all of teaching. A failure to understand the many
aspects of teaching, and which ones do and do not make it effective
for educating students, could have avoided a lot of inaccurate hype
about the promise of algorithmic instruction.</p></blockquote></blockquote></section>&#13;
<h4 class="heading">6.2.1Â <a name="(part._.Lists_as_.Collective_.Data)"/>Lists as Collective Data<a href="#(part._.Lists_as_.Collective_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>We have already seen one example of a collection in
some depth before: lists. A list is not limited to numbers or strings;
it can contain any kind of value, including structured ones. For
instance, using our examples from earlier [<a href="intro-struct-data.html#%28part._struct-data-eg%29" data-pltdoc="x">Defining and Creating Structured Data</a>],
we can make a list of songs:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">song-list = [list: lver, so, wnkkhs]</code></pre><p>This is a three-element list where each element is a song:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  song-list.length() is 3
  song-list.first is lver
end</code></pre><p>Thus, what we have seen earlier about building functions over lists
[<a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>] applies here too. To illustrate, suppose
we wish to write the function <code data-lang="pyret" class="sourceCode">oldest-song-age</code>, which consumes a
list of songs and produces the oldest song in the list. (There may be
more than one song from the same year; the ageâ€”<wbr/>by our measureâ€”<wbr/>of
all those songs will be the same. If this happens, we just pick one of
the songs from the list. Because of this, however, it would be more
accurate to say â€œanâ€ rather than â€œtheâ€ oldest song.)</p><p>Letâ€™s work through this with examples. To keep our examples easy to
write, instead of writing out the full data for the songs, weâ€™ll refer
to them just by their variable names. Clearly, the oldest song in our
list is bound to <code data-lang="pyret" class="sourceCode">lvar</code>.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">oldest-song([list: lver, so, wnkkhs]) is lvar
oldest-song([list:       so, wnkkhs]) is wnkkhs
oldest-song([list:           wnkkhs]) is wnkkhs
oldest-song([list:                 ]) is ???</code></pre><p>What do we write in the last case? Recall that we saw this problem
earlier [<a href="processing-lists.html#%28part._my-max%29" data-pltdoc="x"><code data-lang="pyret" class="sourceCode">my-max</code>: Examples</a>]: there is no answer in the empty case. In
fact, the computation here is remarkably similar to that of
<code data-lang="pyret" class="sourceCode">my-max</code>, because it is essentially the same computation, just
asking for the minimum year (which would make the song the
oldest).</p><p>From our examples, we can see a solution structure echoing that of
<code data-lang="pyret" class="sourceCode">my-max</code>. For the empty list, we signal an error. Otherwise, we
compute the oldest song in the rest of the list, and compare its year
against that of the first. Whichever has the older year is the answer.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun oldest-song(sl :: List&lt;ITunesSong&gt;) -&gt; ITunesSong:
  cases (List) sl:
    | empty =&gt; raise("not defined for empty song lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; f
        | else =&gt;
          osr = oldest-song(r)
          if osr.year &lt; f.year:
            osr
          else:
            f
          end
      end
  end
end</code></pre><p>Note that there is no guarantee there will be only oldest song, and
this is reflected in the possibility that <code data-lang="pyret" class="sourceCode">osr.year</code> may
equal <code data-lang="pyret" class="sourceCode">f.year</code>. However, our problem statement allowed us
to pick just one such song, which is what weâ€™ve done.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Modify the solution above to <code data-lang="pyret" class="sourceCode">oldest-song-age</code>, which computes
the age of the oldest song(s).</p></blockquote></blockquote><p>Haha, just kidding! You shouldnâ€™t modify the previous solution at all!
Instead, you should leave it aloneâ€”<wbr/>it may come in handy for other
purposesâ€”<wbr/>and instead build a new function to use it:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun oldest-song-age(sl :: List&lt;ITunesSong&gt;) -&gt; Number:
  os = oldest-song(sl)
  song-age(os)
where:
  oldest-song-age(song-list) is 71
end</code></pre>&#13;
<h4 class="heading">6.2.2Â <a name="(part._sets-as-collections)"/>Sets as Collective Data<a href="#(part._sets-as-collections)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>As weâ€™ve already seen, for some problems we donâ€™t care about the order
of inputs, nor about duplicates. Here are more examples where we donâ€™t
care about order or duplicates:
</p><ul><li><p>Your Web browser records which Web pages youâ€™ve
visited, and some Web sites use this information to color visited
links differently than ones you havenâ€™t seen. This color is typically
independent of how many times you have visited the page.</p></li><li><p>During an election, a poll agent might record that you have
voted, but does not need to record how many times you have voted, and
does not care about the order in which people vote.</p></li></ul><p>For such problems a list is a bad fit relative to a set. Here we will
see how Pyretâ€™s built-in sets work. In
[<a href="part_sets.html" data-pltdoc="x">Several Variations on Sets</a>] we will see how we can build sets for
ourselves.</p><p>First, we can define sets just as easily as we can lists:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import sets as S
song-set = [S.set: lver, so, wnkkhs]</code></pre><p>Of course, due to the nature of the languageâ€™s syntax, we have to
list the elements in some order. Does it matter?</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How can we tell whether Pyret cares about the order?</p></blockquote></blockquote><p>Hereâ€™s the simplest way to check:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  song-set2 = [S.set: so, wnkkhs, lver]
  song-set is song-set2
end</code></pre><p>If we want to be especially cautious, we can write down all the other
orderings of the elements as well, and see that Pyret doesnâ€™t
care.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>How many different orders are there?</p></blockquote></blockquote><p>Similarly for duplicates:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  song-set3 = [S.set: lver, so, wnkkhs, so, so, lver, so]
  song-set is song-set3
  song-set3.size() is 3
end</code></pre><p>We can again try several different kinds of duplication and confirm
that sets ignore them.</p><section class="SsectionLevel5" id="section 6.2.2.1"><h5 class="heading">6.2.2.1Â <a name="(part._coll-sd-pick)"/>Picking Elements from Sets<a href="#(part._coll-sd-pick)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>This lack of an ordering, however, poses a problem. With lists, it was
meaningful to talk about the â€œfirstâ€ and corresponding â€œrestâ€. By
definition, with sets there is not â€œfirstâ€ element. In fact, Pyret
does not even offer fields similar to <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code>. In
its place is something a little more accurate but complex.</p><p>The <code data-lang="pyret" class="sourceCode">.pick</code> method returns a random element of a set. It
produces a value of type <code data-lang="pyret" class="sourceCode">Pick</code> (which we get with <code data-lang="pyret" class="sourceCode">include
pick</code>). When we pick an element, there are two
possibilities. One is that the set is empty (analogous to a list being
empty), which gives us a <code data-lang="pyret" class="sourceCode">pick-none</code> value. The other option is
called <code data-lang="pyret" class="sourceCode">pick-some</code>, which gives us an actual member of the set.</p><p>The <code data-lang="pyret" class="sourceCode">pick-some</code> variant of <code data-lang="pyret" class="sourceCode">Pick</code> has two fields, not
one. To understand why takes a momentâ€™s work. Letâ€™s explore it by
choosing an element of a set:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun an-elt(s :: S.Set):
  cases (Pick) s.pick():
    | pick-none =&gt; raise("empty set")
    | pick-some(e, r) =&gt; e
  end
end</code></pre><p>(Notice that we arenâ€™t using the <code data-lang="pyret" class="sourceCode">r</code> field in the
<code data-lang="pyret" class="sourceCode">pick-some</code> case.)</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can you guess why we didnâ€™t write examples for <code data-lang="pyret" class="sourceCode">an-elt</code>?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Run <code data-lang="pyret" class="sourceCode">an-elt(song-set)</code>. What element do you get?</p><p>Run it again. Run it five more times.</p><p>Do you get the same element every time?</p></blockquote></blockquote><p>No you donâ€™t!Well, actually, itâ€™s impossible to be certain
you donâ€™t. There is a very, very small likelihood you get the exact
same element on every one of six runs. If it happens to you, keep
running it more times!
Pyret is designed to not always return the same element
when picking from a set. This is on purpose: itâ€™s to drive home the
random nature of choosing from a set, and to prevent your program from
accidentally depending on a particular order that Pyret might use.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Given that <code data-lang="pyret" class="sourceCode">an-elt</code> does not return a predictable element, what
(if any) tests can we write for it?</p></blockquote></blockquote><p>Observe that though we canâ€™t predict which element <code data-lang="pyret" class="sourceCode">an-elt</code> will
produce, we do know it will produce an element of the set. Therefore,
what we can write are tests that ensure the resulting element is a
member of the setâ€”<wbr/>though in this case, that would not be
particularly surprising.</p></section><section class="SsectionLevel5" id="section 6.2.2.2"><h5 class="heading">6.2.2.2Â <a name="(part._.Computing_with_.Sets)"/>Computing with Sets<a href="#(part._.Computing_with_.Sets)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Once we have picked an element from a set, itâ€™s often useful to obtain
the set consisting of the remaining elements. We have already seen
that choosing the first field of a <code data-lang="pyret" class="sourceCode">pick-some</code> is similar to
taking the â€œfirstâ€ of a set. We therefore want a way to get the
â€œrestâ€ of the set. However, we want the rest to what we obtain after
excluding this particular â€œfirstâ€. Thatâ€™s what the second
field of a <code data-lang="pyret" class="sourceCode">pick-some</code> is: whatâ€™s left of the set.</p><p>Given this, we can write functions over sets that look roughly
analogous to functions over lists. For instance, suppose we want to
compute the size of a set. The function looks similar to
<code data-lang="pyret" class="sourceCode">my-len</code> [<a href="processing-lists.html#%28part._my-len%29" data-pltdoc="x">Some Example Exercises</a>]:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-set-size(s :: S.Set) -&gt; Number:
  cases (Pick) s.pick():
    | pick-none =&gt; 0
    | pick-some(e, r) =&gt;
      1 + my-set-size(r)
  end
end</code></pre><p>Though the process of deriving this is similar to that we used for
<code data-lang="pyret" class="sourceCode">my-len</code>, the random nature of picking elements makes it harder to
write examples that the actual functionâ€™s behavior will match.</p></section>&#13;
<h5 class="heading">6.2.2.1Â <a name="(part._coll-sd-pick)"/>Picking Elements from Sets<a href="#(part._coll-sd-pick)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>This lack of an ordering, however, poses a problem. With lists, it was
meaningful to talk about the â€œfirstâ€ and corresponding â€œrestâ€. By
definition, with sets there is not â€œfirstâ€ element. In fact, Pyret
does not even offer fields similar to <code data-lang="pyret" class="sourceCode">first</code> and <code data-lang="pyret" class="sourceCode">rest</code>. In
its place is something a little more accurate but complex.</p><p>The <code data-lang="pyret" class="sourceCode">.pick</code> method returns a random element of a set. It
produces a value of type <code data-lang="pyret" class="sourceCode">Pick</code> (which we get with <code data-lang="pyret" class="sourceCode">include
pick</code>). When we pick an element, there are two
possibilities. One is that the set is empty (analogous to a list being
empty), which gives us a <code data-lang="pyret" class="sourceCode">pick-none</code> value. The other option is
called <code data-lang="pyret" class="sourceCode">pick-some</code>, which gives us an actual member of the set.</p><p>The <code data-lang="pyret" class="sourceCode">pick-some</code> variant of <code data-lang="pyret" class="sourceCode">Pick</code> has two fields, not
one. To understand why takes a momentâ€™s work. Letâ€™s explore it by
choosing an element of a set:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun an-elt(s :: S.Set):
  cases (Pick) s.pick():
    | pick-none =&gt; raise("empty set")
    | pick-some(e, r) =&gt; e
  end
end</code></pre><p>(Notice that we arenâ€™t using the <code data-lang="pyret" class="sourceCode">r</code> field in the
<code data-lang="pyret" class="sourceCode">pick-some</code> case.)</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can you guess why we didnâ€™t write examples for <code data-lang="pyret" class="sourceCode">an-elt</code>?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Run <code data-lang="pyret" class="sourceCode">an-elt(song-set)</code>. What element do you get?</p><p>Run it again. Run it five more times.</p><p>Do you get the same element every time?</p></blockquote></blockquote><p>No you donâ€™t!Well, actually, itâ€™s impossible to be certain
you donâ€™t. There is a very, very small likelihood you get the exact
same element on every one of six runs. If it happens to you, keep
running it more times!
Pyret is designed to not always return the same element
when picking from a set. This is on purpose: itâ€™s to drive home the
random nature of choosing from a set, and to prevent your program from
accidentally depending on a particular order that Pyret might use.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Given that <code data-lang="pyret" class="sourceCode">an-elt</code> does not return a predictable element, what
(if any) tests can we write for it?</p></blockquote></blockquote><p>Observe that though we canâ€™t predict which element <code data-lang="pyret" class="sourceCode">an-elt</code> will
produce, we do know it will produce an element of the set. Therefore,
what we can write are tests that ensure the resulting element is a
member of the setâ€”<wbr/>though in this case, that would not be
particularly surprising.</p>&#13;
<h5 class="heading">6.2.2.2Â <a name="(part._.Computing_with_.Sets)"/>Computing with Sets<a href="#(part._.Computing_with_.Sets)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Once we have picked an element from a set, itâ€™s often useful to obtain
the set consisting of the remaining elements. We have already seen
that choosing the first field of a <code data-lang="pyret" class="sourceCode">pick-some</code> is similar to
taking the â€œfirstâ€ of a set. We therefore want a way to get the
â€œrestâ€ of the set. However, we want the rest to what we obtain after
excluding this particular â€œfirstâ€. Thatâ€™s what the second
field of a <code data-lang="pyret" class="sourceCode">pick-some</code> is: whatâ€™s left of the set.</p><p>Given this, we can write functions over sets that look roughly
analogous to functions over lists. For instance, suppose we want to
compute the size of a set. The function looks similar to
<code data-lang="pyret" class="sourceCode">my-len</code> [<a href="processing-lists.html#%28part._my-len%29" data-pltdoc="x">Some Example Exercises</a>]:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-set-size(s :: S.Set) -&gt; Number:
  cases (Pick) s.pick():
    | pick-none =&gt; 0
    | pick-some(e, r) =&gt;
      1 + my-set-size(r)
  end
end</code></pre><p>Though the process of deriving this is similar to that we used for
<code data-lang="pyret" class="sourceCode">my-len</code>, the random nature of picking elements makes it harder to
write examples that the actual functionâ€™s behavior will match.</p>&#13;
<h4 class="heading">6.2.3Â <a name="(part._.Combining_.Structured_and_.Collective_.Data)"/>Combining Structured and Collective Data<a href="#(part._.Combining_.Structured_and_.Collective_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>As the above examples illustrate, a programâ€™s data organization will
often involve multiple kinds of compound data, often deeply
intertwined. Letâ€™s first think of these in pairs.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Come up with examples that combine:
</p><ul><li><p>structured and conditional data,</p></li><li><p>structured and collective data, and</p></li><li><p>conditional and collective data.</p></li></ul><p>Youâ€™ve actually seen examples of each of these above. Identify them.</p></blockquote></blockquote><p>Finally, we might even have all three at once. For instance, a
filesystem is usually a list (collective) of files and folders
(conditional) where each file has several attributes
(structured). Similarly, a social network has a set of pages
(collective) where each page is for a person, organization, or other
thing (conditional), and each page has several attributes
(structured). Therefore, as you can see, combinations of these arise
naturally in all kinds of applications that we deal with on a daily
basis.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Take three of your favorite Web sites or apps. Identify the kinds of
data they present. Classify these as structured, conditional, and
collective. How do they combine these data?</p></blockquote></blockquote>&#13;
<h4 class="heading">6.2.4Â <a name="(part._.Data_.Design_.Problem__.Representing_.Quizzes)"/>Data Design Problem: Representing Quizzes<a href="#(part._.Data_.Design_.Problem__.Representing_.Quizzes)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Now that you can make collections of structured data, you can approach
creating the data and programs for fairly sophisticated
applications. Letâ€™s try out a data-design problem, where we will focus
just on creating the data definition, but not on writing the actual
functions.</p><p>Problem Statement:
Youâ€™ve been hired to help create software for giving quizzes to
students. The software will show the student a question, read in the
studentâ€™s answer, compare the studentâ€™s answer to the expected answer
(sort of like a Pyret example!), and produce the percentage of
questions that the student got right.</p><p>Your task is to create a data definition for capturing quizzes and
expected answers. Donâ€™t worry about representing the student
responses.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Propose an initial data structure for quizzes. Start by identifying
the pieces you might need and trying to write some sample questions.</p></blockquote></blockquote><p>We might imagine asking a quiz question like â€œwhat is 3 + 4?â€œ. We
would expect the student to answer <code data-lang="pyret" class="sourceCode">7</code>. What would capture this?
A piece of structured data with two fields like the following:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Question:
  basic-ques(text :: String, expect :: ???)
end</code></pre><p>Whatâ€™s a good type for the expected answer? This specific problem has
a numeric answer, but other questions might have other types of
answers. <code data-lang="pyret" class="sourceCode">Any</code> is therefore an appropriate type for the answer.</p><p>We would also need a list of <code data-lang="pyret" class="sourceCode">Question</code> to form an entire quiz.</p><p>Sometimes, quiz software allows students to ask for hints.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Assume we wanted to have some (but not all) questions with hints,
which would be text that a student could request for help with a
problem. Modify the current data definition to capture quizzes in
which some questions have hints and some do not.</p></blockquote></blockquote><p>A quiz should still be a list of questions, but the <code data-lang="pyret" class="sourceCode">Question</code>
data definition needs another variant in order to handle questions
with hints. The following would work:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Question:
  | basic-ques(text :: String, expect :: Any)
  | hint-ques(text :: String, expect :: Any, hint :: String)
end

A <code data-lang="pyret" class="sourceCode">quiz</code> is a <code data-lang="pyret" class="sourceCode">List&lt;Question&gt;</code></code></pre><p>We could imagine extending this example to introduce dependencies
between questions (such as one problem building on the skills of
another), multiple choice questions, checkbox questions, and so on.</p><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Consider the Process Being Displaced</p><blockquote class="RespCSBody"><p>Many companies have tried to improve education through software
systems that automate tasks otherwise done by teachers. There are
systems that show students a video, then give them quizzes (akin to
what you just developed) to check what they have learned. A more
extreme version interleaves videos and quizzes, thus teaching entire
courses at scale, without the need for teacher intervention.</p><p>Massively-online courses (MOOCs) are a style of course that makes
heavy use to computer automation, to enable reaching many more
students without needing more teachers. Proponents of MOOCs and
related educational technology tools have promised game-changing
impacts of such tools, promising to extend quality education to
students around the world who otherwise might lack access to quality
teachers. Technology investors (and indeed some universities) dove in
behind these technologies, hoping for an educational revolution at
scale.</p><p>Unfortunately, research and evaluation have shown that replacing
education with automated systems, even ones with sophisticated
features based on data analysis and predictions that identify skills
that students havenâ€™t quite mastered, doesnâ€™t lead to the promised
gains in learning. Why? It turns out that teaching is about more than
choosing questions, gathering student work, and giving
grades. Teachers provide encouragement, reassurance, and an
understanding of an individual studentsâ€™ situation. Todayâ€™s
computational systems donâ€™t do this. The generally-accepted wisdom
around these tools (backed by three prior decades of research) is that
they are best used to complement direct instruction by a human
teacher. In such a setting, some tools have resulted in solid
performance gains on the parts of students.</p><p>The social-responsibility takeaway here is that you need to
consider all the features of the system you might be trying to
replace with a computational approach. Algorithmic quiz-taking tools
have genuine value in some specific context, but they arenâ€™t a
replacement for all of teaching. A failure to understand the many
aspects of teaching, and which ones do and do not make it effective
for educating students, could have avoided a lot of inaccurate hype
about the promise of algorithmic instruction.</p></blockquote></blockquote>    
</body>
</html>