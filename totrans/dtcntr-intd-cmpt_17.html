<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>6.2Â Collections of Structured DatağŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>6.2Â Collections of Structured DatağŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/Collections_of_Structured_Data.html">https://dcic-world.org/2025-08-27/Collections_of_Structured_Data.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Lists_as_.Collective_.Data%29" class="toclink" data-pltdoc="x">6.2.1<span class="hspace">Â </span>Lists as Collective Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._sets-as-collections%29" class="toclink" data-pltdoc="x">6.2.2<span class="hspace">Â </span>Sets as Collective Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._coll-sd-pick%29" class="toclink" data-pltdoc="x">6.2.2.1<span class="hspace">Â </span>Picking Elements from Sets</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Computing_with_.Sets%29" class="toclink" data-pltdoc="x">6.2.2.2<span class="hspace">Â </span>Computing with Sets</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Combining_.Structured_and_.Collective_.Data%29" class="toclink" data-pltdoc="x">6.2.3<span class="hspace">Â </span>Combining Structured and Collective Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Data_.Design_.Problem__.Representing_.Quizzes%29" class="toclink" data-pltdoc="x">6.2.4<span class="hspace">Â </span>Data Design Problem: Representing Quizzes</a></p></td></tr></table><p/><div class="SIntrapara">As we were looking at structured data [<a href="intro-struct-data.html" data-pltdoc="x">Introduction to Structured Data</a>],
we came across several situations where we have not one but many data:
not one song but a playlist of them, not one animal but a zoo full of
them, not one notification but several, not just one message (how we
wish!) but many in our inbox, and so on. In general, then, we rarely
have just a single structured datum: <span class="refelem"><span class="refcolumn"><span class="refcontent">One notable exception:
consider the configuration or preference information for a
system. This might be stored in a file and updated through a user
interface. Even though there is (usually) only one configuration at a
time, it may have so many pieces that we wonâ€™t want to clutter our
program with a large number of variables; instead, we might create a
structure representing the configuration, and load just one instance
of it. In effect, what would have been unconnected <span class="emph">variables</span>
now become a set of linked <span class="emph">fields</span>.</span></span></span>  if we know we have only
one, we might just have a few separate variables representing the
pieces without going to the effort of creating and taking apart a
structure. In general, therefore, we want to talk about
<span style="font-style: italic">collections</span> of structured data. Here are more examples:
</div><div class="SIntrapara"><ul><li><p>The set of messages matching a tag.</p></li><li><p>The list of messages in a conversation.</p></li><li><p>The set of friends of a user.</p></li></ul></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How are collective data different from structured data?</p></blockquote></blockquote><p>In structured data, we have a <span class="emph">fixed</span> number of <span class="emph">possibly
different</span> kinds of values. In collective data, we have a
<span class="emph">variable</span> number of <span class="emph">the same</span> kind of value. For instance, we
donâ€™t say up front how many songs must be in a playlist or how many
pages a user can have; but every one of them must be a song or a
page. (A page may, of course, be conditionally defined, but
ultimately everything in the collection is still a page.)</p><p>Observe that weâ€™ve mentioned both <span style="font-style: italic">sets</span> and <span style="font-style: italic">lists</span>
above. The difference between a set and a list is that a set has no
order, but a list has an order. This distinction is not vital now but
we will return to it later [<a href="#%28part._sets-as-collections%29" data-pltdoc="x">Sets as Collective Data</a>].</p><p/><div class="SIntrapara">Of course, sets and lists are not the only kinds of collective data we
can have. Here are some more:
</div><div class="SIntrapara"><ul><li><p>A family tree of people.</p></li><li><p>The filesystem on your computer.</p></li><li><p>A seating chart at a party.</p></li><li><p>A social network of pages.</p></li></ul></div><div class="SIntrapara">and so on. For the most part these are just as easy to program and
manipulate as the earlier collective data once we have some
experience, though some of them [<a href="Sharing_and_Equality.html#%28part._identical-eq%29" data-pltdoc="x">Re-Examining Equality</a>] can involve more subtlety.</div><p>We have already seen tables [<a href="intro-tabular-data.html" data-pltdoc="x">Introduction to Tabular Data</a>], which are
a form of collective, structured data. Now we will look at a few more,
and how to program them.</p><section class="SsectionLevel4" id="section 6.2.1"><h4 class="heading">6.2.1<span class="stt">Â </span><a name="(part._.Lists_as_.Collective_.Data)"/>Lists as Collective Data<span class="button-group"><a href="#(part._.Lists_as_.Collective_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">We have already seen one example of a collection in
some depth before: lists. A list is not limited to numbers or strings;
it can contain any kind of value, including structured ones. For
instance, using our examples from earlier [<a href="intro-struct-data.html#%28part._struct-data-eg%29" data-pltdoc="x">Defining and Creating Structured Data</a>],
we can make a list of songs:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">song-list = [list: lver, so, wnkkhs]</code></pre></div></div></div><div class="SIntrapara">This is a three-element list where each element is a song:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  song-list.length() is 3
  song-list.first is lver
end</code></pre></div></div></div><p>Thus, what we have seen earlier about building functions over lists
[<a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>] applies here too. To illustrate, suppose
we wish to write the function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">oldest-song-age</code></span>, which consumes a
list of songs and produces the oldest song in the list. (There may be
more than one song from the same year; the ageâ€”<wbr/>by our measureâ€”<wbr/>of
all those songs will be the same. If this happens, we just pick one of
the songs from the list. Because of this, however, it would be more
accurate to say â€œ<span class="emph">an</span>â€ rather than â€œ<span class="emph">the</span>â€ oldest song.)</p><p/><div class="SIntrapara">Letâ€™s work through this with examples. To keep our examples easy to
write, instead of writing out the full data for the songs, weâ€™ll refer
to them just by their variable names. Clearly, the oldest song in our
list is bound to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lvar</code></span>.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">oldest-song([list: lver, so, wnkkhs]) is lvar
oldest-song([list:       so, wnkkhs]) is wnkkhs
oldest-song([list:           wnkkhs]) is wnkkhs
oldest-song([list:                 ]) is ???</code></pre></div></div></div><p>What do we write in the last case? Recall that we saw this problem
earlier [<a href="processing-lists.html#%28part._my-max%29" data-pltdoc="x"><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>: Examples</a>]: there is no answer in the empty case. In
fact, the computation here is remarkably similar to that of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>, because it is essentially the same computation, just
asking for the <span class="emph">minimum</span> year (which would make the song the
oldest).</p><p>From our examples, we can see a solution structure echoing that of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>. For the empty list, we signal an error. Otherwise, we
compute the oldest song in the rest of the list, and compare its year
against that of the first. Whichever has the older year is the answer.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun oldest-song(sl :: List&lt;ITunesSong&gt;) -&gt; ITunesSong:
  cases (List) sl:
    | empty =&gt; raise("not defined for empty song lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; f
        | else =&gt;
          osr = oldest-song(r)
          if osr.year &lt; f.year:
            osr
          else:
            f
          end
      end
  end
end</code></pre></div></div><p>Note that there is no guarantee there will be only oldest song, and
this is reflected in the possibility that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">osr.year</code></span> may
<span class="emph">equal</span> <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f.year</code></span>. However, our problem statement allowed us
to pick just one such song, which is what weâ€™ve done.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Modify the solution above to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">oldest-song-age</code></span>, which computes
the age of the oldest song(s).</p></blockquote></blockquote><p/><div class="SIntrapara">Haha, just kidding! You shouldnâ€™t modify the previous solution at all!
Instead, you should leave it aloneâ€”<wbr/>it may come in handy for other
purposesâ€”<wbr/>and instead build a new function to use it:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun oldest-song-age(sl :: List&lt;ITunesSong&gt;) -&gt; Number:
  os = oldest-song(sl)
  song-age(os)
where:
  oldest-song-age(song-list) is 71
end</code></pre></div></div></div></section><section class="SsectionLevel4" id="section 6.2.2"><h4 class="heading">6.2.2<span class="stt">Â </span><a name="(part._sets-as-collections)"/>Sets as Collective Data<span class="button-group"><a href="#(part._sets-as-collections)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">As weâ€™ve already seen, for some problems we donâ€™t care about the order
of inputs, nor about duplicates. Here are more examples where we donâ€™t
care about order or duplicates:
</div><div class="SIntrapara"><ul><li><p>Your Web browser records which Web pages youâ€™ve
visited, and some Web sites use this information to color visited
links differently than ones you havenâ€™t seen. This color is typically
independent of how many times you have visited the page.</p></li><li><p>During an election, a poll agent might record that you have
voted, but does not need to record how many times you have voted, and
does not care about the order in which people vote.</p></li></ul></div><div class="SIntrapara">For such problems a list is a bad fit relative to a set. Here we will
see how Pyretâ€™s built-in sets work. In
[<a href="part_sets.html" data-pltdoc="x">Several Variations on Sets</a>] we will see how we can build sets for
ourselves.</div><p/><div class="SIntrapara">First, we can define sets just as easily as we can lists:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import sets as S
song-set = [S.set: lver, so, wnkkhs]</code></pre></div></div></div><div class="SIntrapara">Of course, due to the nature of the languageâ€™s syntax, we have to
list the elements in <span class="emph">some</span> order. Does it matter?</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How can we tell whether Pyret cares about the order?</p></blockquote></blockquote><p/><div class="SIntrapara">Hereâ€™s the simplest way to check:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  song-set2 = [S.set: so, wnkkhs, lver]
  song-set is song-set2
end</code></pre></div></div></div><div class="SIntrapara">If we want to be especially cautious, we can write down all the other
orderings of the elements as well, and see that Pyret doesnâ€™t
care.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>How many different orders are there?</p></blockquote></blockquote><p/><div class="SIntrapara">Similarly for duplicates:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  song-set3 = [S.set: lver, so, wnkkhs, so, so, lver, so]
  song-set is song-set3
  song-set3.size() is 3
end</code></pre></div></div></div><div class="SIntrapara">We can again try several different kinds of duplication and confirm
that sets ignore them.</div><section class="SsectionLevel5" id="section 6.2.2.1"><h5 class="heading">6.2.2.1<span class="stt">Â </span><a name="(part._coll-sd-pick)"/>Picking Elements from Sets<span class="button-group"><a href="#(part._coll-sd-pick)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>This lack of an ordering, however, poses a problem. With lists, it was
meaningful to talk about the â€œfirstâ€ and corresponding â€œrestâ€. By
definition, with sets there is not â€œfirstâ€ element. In fact, Pyret
does not even offer fields similar to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span>. In
its place is something a little more accurate but complex.</p><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.pick</code></span> method returns a random element of a set. It
produces a value of type <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Pick</code></span> (which we get with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">include
pick</code></span>). When we pick an element, there are two
possibilities. One is that the set is empty (analogous to a list being
empty), which gives us a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-none</code></span> value. The other option is
called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-some</code></span>, which gives us an actual member of the set.</p><p/><div class="SIntrapara">The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-some</code></span> variant of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Pick</code></span> has two fields, not
one. To understand why takes a momentâ€™s work. Letâ€™s explore it by
choosing an element of a set:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun an-elt(s :: S.Set):
  cases (Pick) s.pick():
    | pick-none =&gt; raise("empty set")
    | pick-some(e, r) =&gt; e
  end
end</code></pre></div></div></div><div class="SIntrapara">(Notice that we arenâ€™t using the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> field in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-some</code></span> case.)</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can you guess why we didnâ€™t write examples for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">an-elt</code></span>?</p></blockquote></blockquote><p/><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Run <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">an-elt(song-set)</code></span>. What element do you get?</p><p>Run it again. Run it five more times.</p><p>Do you get the same element every time?</p></blockquote></blockquote></div><div class="SIntrapara">No you donâ€™t!<span class="refelem"><span class="refcolumn"><span class="refcontent">Well, actually, itâ€™s impossible to be certain
you donâ€™t. There is a very, very small likelihood you get the exact
same element on every one of six runs. If it happens to you, keep
running it more times!</span></span></span>
Pyret is designed to not always return the same element
when picking from a set. This is on purpose: itâ€™s to drive home the
random nature of choosing from a set, and to prevent your program from
accidentally depending on a particular order that Pyret might use.</div><p/><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Given that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">an-elt</code></span> does not return a predictable element, what
(if any) tests can we write for it?</p></blockquote></blockquote></div><div class="SIntrapara">Observe that though we canâ€™t predict <span class="emph">which</span> element <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">an-elt</code></span> will
produce, we do know it will produce an element of the set. Therefore,
what we can write are tests that ensure the resulting element is a
member of the setâ€”<wbr/>though in this case, that would not be
particularly surprising.</div></section><section class="SsectionLevel5" id="section 6.2.2.2"><h5 class="heading">6.2.2.2<span class="stt">Â </span><a name="(part._.Computing_with_.Sets)"/>Computing with Sets<span class="button-group"><a href="#(part._.Computing_with_.Sets)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Once we have picked an element from a set, itâ€™s often useful to obtain
the set consisting of the remaining elements. We have already seen
that choosing the first field of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-some</code></span> is similar to
taking the â€œfirstâ€ of a set. We therefore want a way to get the
â€œrestâ€ of the set. However, we want the rest to what we obtain after
excluding <span class="emph">this particular</span> â€œfirstâ€. Thatâ€™s what the second
field of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-some</code></span> is: whatâ€™s left of the set.</p><p/><div class="SIntrapara">Given this, we can write functions over sets that look roughly
analogous to functions over lists. For instance, suppose we want to
compute the size of a set. The function looks similar to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span> [<a href="processing-lists.html#%28part._my-len%29" data-pltdoc="x">Some Example Exercises</a>]:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-set-size(s :: S.Set) -&gt; Number:
  cases (Pick) s.pick():
    | pick-none =&gt; 0
    | pick-some(e, r) =&gt;
      1 + my-set-size(r)
  end
end</code></pre></div></div></div><div class="SIntrapara">Though the process of deriving this is similar to that we used for
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>, the random nature of picking elements makes it harder to
write examples that the actual functionâ€™s behavior will match.</div></section></section><section class="SsectionLevel4" id="section 6.2.3"><h4 class="heading">6.2.3<span class="stt">Â </span><a name="(part._.Combining_.Structured_and_.Collective_.Data)"/>Combining Structured and Collective Data<span class="button-group"><a href="#(part._.Combining_.Structured_and_.Collective_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>As the above examples illustrate, a programâ€™s data organization will
often involve multiple kinds of compound data, often deeply
intertwined. Letâ€™s first think of these in pairs.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p/><div class="SIntrapara">Come up with examples that combine:
</div><div class="SIntrapara"><ul><li><p>structured and conditional data,</p></li><li><p>structured and collective data, and</p></li><li><p>conditional and collective data.</p></li></ul></div><p>Youâ€™ve actually seen examples of each of these above. Identify them.</p></blockquote></blockquote><p>Finally, we might even have all three at once. For instance, a
filesystem is usually a list (collective) of files and folders
(conditional) where each file has several attributes
(structured). Similarly, a social network has a set of pages
(collective) where each page is for a person, organization, or other
thing (conditional), and each page has several attributes
(structured). Therefore, as you can see, combinations of these arise
naturally in all kinds of applications that we deal with on a daily
basis.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Take three of your favorite Web sites or apps. Identify the kinds of
data they present. Classify these as structured, conditional, and
collective. How do they combine these data?</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 6.2.4"><h4 class="heading">6.2.4<span class="stt">Â </span><a name="(part._.Data_.Design_.Problem__.Representing_.Quizzes)"/>Data Design Problem: Representing Quizzes<span class="button-group"><a href="#(part._.Data_.Design_.Problem__.Representing_.Quizzes)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Now that you can make collections of structured data, you can approach
creating the data and programs for fairly sophisticated
applications. Letâ€™s try out a data-design problem, where we will focus
just on creating the data definition, but not on writing the actual
functions.</p><p><span style="font-weight: bold">Problem Statement</span>:
Youâ€™ve been hired to help create software for giving quizzes to
students. The software will show the student a question, read in the
studentâ€™s answer, compare the studentâ€™s answer to the expected answer
(sort of like a Pyret example!), and produce the percentage of
questions that the student got right.</p><p>Your task is to create a data definition for capturing quizzes and
expected answers. Donâ€™t worry about representing the student
responses.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Propose an initial data structure for quizzes. Start by identifying
the pieces you might need and trying to write some sample questions.</p></blockquote></blockquote><p>We might imagine asking a quiz question like â€œwhat is 3 + 4?â€œ. We
would expect the student to answer <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span>. What would capture this?
A piece of structured data with two fields like the following:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Question:
  basic-ques(text :: String, expect :: ???)
end</code></pre></div></div><p>Whatâ€™s a good type for the expected answer? This specific problem has
a numeric answer, but other questions might have other types of
answers. <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Any</code></span> is therefore an appropriate type for the answer.</p><p>We would also need a list of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Question</code></span> to form an entire quiz.</p><p>Sometimes, quiz software allows students to ask for hints.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Assume we wanted to have some (but not all) questions with hints,
which would be text that a student could request for help with a
problem. Modify the current data definition to capture quizzes in
which some questions have hints and some do not.</p></blockquote></blockquote><p>A quiz should still be a list of questions, but the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Question</code></span>
data definition needs another variant in order to handle questions
with hints. The following would work:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Question:
  | basic-ques(text :: String, expect :: Any)
  | hint-ques(text :: String, expect :: Any, hint :: String)
end

A <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">quiz</code></span> is a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">List&lt;Question&gt;</code></span></code></pre></div></div><p>We could imagine extending this example to introduce dependencies
between questions (such as one problem building on the skills of
another), multiple choice questions, checkbox questions, and so on.</p><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Consider the Process Being Displaced</p><blockquote class="RespCSBody"><p>Many companies have tried to improve education through software
systems that automate tasks otherwise done by teachers. There are
systems that show students a video, then give them quizzes (akin to
what you just developed) to check what they have learned. A more
extreme version interleaves videos and quizzes, thus teaching entire
courses at scale, without the need for teacher intervention.</p><p>Massively-online courses (MOOCs) are a style of course that makes
heavy use to computer automation, to enable reaching many more
students without needing more teachers. Proponents of MOOCs and
related educational technology tools have promised game-changing
impacts of such tools, promising to extend quality education to
students around the world who otherwise might lack access to quality
teachers. Technology investors (and indeed some universities) dove in
behind these technologies, hoping for an educational revolution at
scale.</p><p>Unfortunately, research and evaluation have shown that replacing
education with automated systems, even ones with sophisticated
features based on data analysis and predictions that identify skills
that students havenâ€™t quite mastered, doesnâ€™t lead to the promised
gains in learning. Why? It turns out that teaching is about more than
choosing questions, gathering student work, and giving
grades. Teachers provide encouragement, reassurance, and an
understanding of an individual studentsâ€™ situation. Todayâ€™s
computational systems donâ€™t do this. The generally-accepted wisdom
around these tools (backed by three prior decades of research) is that
they are best used to <span class="emph">complement</span> direct instruction by a human
teacher. In such a setting, some tools have resulted in solid
performance gains on the parts of students.</p><p>The social-responsibility takeaway here is that you need to
<span class="emph">consider all the features of the system you might be trying to
replace with a computational approach</span>. Algorithmic quiz-taking tools
have genuine value in some specific context, but they arenâ€™t a
replacement for all of teaching. A failure to understand the many
aspects of teaching, and which ones do and do not make it effective
for educating students, could have avoided a lot of inaccurate hype
about the promise of algorithmic instruction.</p></blockquote></blockquote></section>&#13;
<h4 class="heading">6.2.1<span class="stt">Â </span><a name="(part._.Lists_as_.Collective_.Data)"/>Lists as Collective Data<span class="button-group"><a href="#(part._.Lists_as_.Collective_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">We have already seen one example of a collection in
some depth before: lists. A list is not limited to numbers or strings;
it can contain any kind of value, including structured ones. For
instance, using our examples from earlier [<a href="intro-struct-data.html#%28part._struct-data-eg%29" data-pltdoc="x">Defining and Creating Structured Data</a>],
we can make a list of songs:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">song-list = [list: lver, so, wnkkhs]</code></pre></div></div></div><div class="SIntrapara">This is a three-element list where each element is a song:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  song-list.length() is 3
  song-list.first is lver
end</code></pre></div></div></div><p>Thus, what we have seen earlier about building functions over lists
[<a href="processing-lists.html" data-pltdoc="x">Processing Lists</a>] applies here too. To illustrate, suppose
we wish to write the function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">oldest-song-age</code></span>, which consumes a
list of songs and produces the oldest song in the list. (There may be
more than one song from the same year; the ageâ€”<wbr/>by our measureâ€”<wbr/>of
all those songs will be the same. If this happens, we just pick one of
the songs from the list. Because of this, however, it would be more
accurate to say â€œ<span class="emph">an</span>â€ rather than â€œ<span class="emph">the</span>â€ oldest song.)</p><p/><div class="SIntrapara">Letâ€™s work through this with examples. To keep our examples easy to
write, instead of writing out the full data for the songs, weâ€™ll refer
to them just by their variable names. Clearly, the oldest song in our
list is bound to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lvar</code></span>.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">oldest-song([list: lver, so, wnkkhs]) is lvar
oldest-song([list:       so, wnkkhs]) is wnkkhs
oldest-song([list:           wnkkhs]) is wnkkhs
oldest-song([list:                 ]) is ???</code></pre></div></div></div><p>What do we write in the last case? Recall that we saw this problem
earlier [<a href="processing-lists.html#%28part._my-max%29" data-pltdoc="x"><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>: Examples</a>]: there is no answer in the empty case. In
fact, the computation here is remarkably similar to that of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>, because it is essentially the same computation, just
asking for the <span class="emph">minimum</span> year (which would make the song the
oldest).</p><p>From our examples, we can see a solution structure echoing that of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-max</code></span>. For the empty list, we signal an error. Otherwise, we
compute the oldest song in the rest of the list, and compare its year
against that of the first. Whichever has the older year is the answer.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun oldest-song(sl :: List&lt;ITunesSong&gt;) -&gt; ITunesSong:
  cases (List) sl:
    | empty =&gt; raise("not defined for empty song lists")
    | link(f, r) =&gt;
      cases (List) r:
        | empty =&gt; f
        | else =&gt;
          osr = oldest-song(r)
          if osr.year &lt; f.year:
            osr
          else:
            f
          end
      end
  end
end</code></pre></div></div><p>Note that there is no guarantee there will be only oldest song, and
this is reflected in the possibility that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">osr.year</code></span> may
<span class="emph">equal</span> <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">f.year</code></span>. However, our problem statement allowed us
to pick just one such song, which is what weâ€™ve done.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Modify the solution above to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">oldest-song-age</code></span>, which computes
the age of the oldest song(s).</p></blockquote></blockquote><p/><div class="SIntrapara">Haha, just kidding! You shouldnâ€™t modify the previous solution at all!
Instead, you should leave it aloneâ€”<wbr/>it may come in handy for other
purposesâ€”<wbr/>and instead build a new function to use it:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun oldest-song-age(sl :: List&lt;ITunesSong&gt;) -&gt; Number:
  os = oldest-song(sl)
  song-age(os)
where:
  oldest-song-age(song-list) is 71
end</code></pre></div></div></div>&#13;
<h4 class="heading">6.2.2<span class="stt">Â </span><a name="(part._sets-as-collections)"/>Sets as Collective Data<span class="button-group"><a href="#(part._sets-as-collections)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">As weâ€™ve already seen, for some problems we donâ€™t care about the order
of inputs, nor about duplicates. Here are more examples where we donâ€™t
care about order or duplicates:
</div><div class="SIntrapara"><ul><li><p>Your Web browser records which Web pages youâ€™ve
visited, and some Web sites use this information to color visited
links differently than ones you havenâ€™t seen. This color is typically
independent of how many times you have visited the page.</p></li><li><p>During an election, a poll agent might record that you have
voted, but does not need to record how many times you have voted, and
does not care about the order in which people vote.</p></li></ul></div><div class="SIntrapara">For such problems a list is a bad fit relative to a set. Here we will
see how Pyretâ€™s built-in sets work. In
[<a href="part_sets.html" data-pltdoc="x">Several Variations on Sets</a>] we will see how we can build sets for
ourselves.</div><p/><div class="SIntrapara">First, we can define sets just as easily as we can lists:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import sets as S
song-set = [S.set: lver, so, wnkkhs]</code></pre></div></div></div><div class="SIntrapara">Of course, due to the nature of the languageâ€™s syntax, we have to
list the elements in <span class="emph">some</span> order. Does it matter?</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How can we tell whether Pyret cares about the order?</p></blockquote></blockquote><p/><div class="SIntrapara">Hereâ€™s the simplest way to check:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  song-set2 = [S.set: so, wnkkhs, lver]
  song-set is song-set2
end</code></pre></div></div></div><div class="SIntrapara">If we want to be especially cautious, we can write down all the other
orderings of the elements as well, and see that Pyret doesnâ€™t
care.</div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>How many different orders are there?</p></blockquote></blockquote><p/><div class="SIntrapara">Similarly for duplicates:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  song-set3 = [S.set: lver, so, wnkkhs, so, so, lver, so]
  song-set is song-set3
  song-set3.size() is 3
end</code></pre></div></div></div><div class="SIntrapara">We can again try several different kinds of duplication and confirm
that sets ignore them.</div><section class="SsectionLevel5" id="section 6.2.2.1"><h5 class="heading">6.2.2.1<span class="stt">Â </span><a name="(part._coll-sd-pick)"/>Picking Elements from Sets<span class="button-group"><a href="#(part._coll-sd-pick)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>This lack of an ordering, however, poses a problem. With lists, it was
meaningful to talk about the â€œfirstâ€ and corresponding â€œrestâ€. By
definition, with sets there is not â€œfirstâ€ element. In fact, Pyret
does not even offer fields similar to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span>. In
its place is something a little more accurate but complex.</p><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.pick</code></span> method returns a random element of a set. It
produces a value of type <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Pick</code></span> (which we get with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">include
pick</code></span>). When we pick an element, there are two
possibilities. One is that the set is empty (analogous to a list being
empty), which gives us a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-none</code></span> value. The other option is
called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-some</code></span>, which gives us an actual member of the set.</p><p/><div class="SIntrapara">The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-some</code></span> variant of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Pick</code></span> has two fields, not
one. To understand why takes a momentâ€™s work. Letâ€™s explore it by
choosing an element of a set:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun an-elt(s :: S.Set):
  cases (Pick) s.pick():
    | pick-none =&gt; raise("empty set")
    | pick-some(e, r) =&gt; e
  end
end</code></pre></div></div></div><div class="SIntrapara">(Notice that we arenâ€™t using the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> field in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-some</code></span> case.)</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can you guess why we didnâ€™t write examples for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">an-elt</code></span>?</p></blockquote></blockquote><p/><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Run <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">an-elt(song-set)</code></span>. What element do you get?</p><p>Run it again. Run it five more times.</p><p>Do you get the same element every time?</p></blockquote></blockquote></div><div class="SIntrapara">No you donâ€™t!<span class="refelem"><span class="refcolumn"><span class="refcontent">Well, actually, itâ€™s impossible to be certain
you donâ€™t. There is a very, very small likelihood you get the exact
same element on every one of six runs. If it happens to you, keep
running it more times!</span></span></span>
Pyret is designed to not always return the same element
when picking from a set. This is on purpose: itâ€™s to drive home the
random nature of choosing from a set, and to prevent your program from
accidentally depending on a particular order that Pyret might use.</div><p/><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Given that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">an-elt</code></span> does not return a predictable element, what
(if any) tests can we write for it?</p></blockquote></blockquote></div><div class="SIntrapara">Observe that though we canâ€™t predict <span class="emph">which</span> element <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">an-elt</code></span> will
produce, we do know it will produce an element of the set. Therefore,
what we can write are tests that ensure the resulting element is a
member of the setâ€”<wbr/>though in this case, that would not be
particularly surprising.</div></section><section class="SsectionLevel5" id="section 6.2.2.2"><h5 class="heading">6.2.2.2<span class="stt">Â </span><a name="(part._.Computing_with_.Sets)"/>Computing with Sets<span class="button-group"><a href="#(part._.Computing_with_.Sets)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Once we have picked an element from a set, itâ€™s often useful to obtain
the set consisting of the remaining elements. We have already seen
that choosing the first field of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-some</code></span> is similar to
taking the â€œfirstâ€ of a set. We therefore want a way to get the
â€œrestâ€ of the set. However, we want the rest to what we obtain after
excluding <span class="emph">this particular</span> â€œfirstâ€. Thatâ€™s what the second
field of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-some</code></span> is: whatâ€™s left of the set.</p><p/><div class="SIntrapara">Given this, we can write functions over sets that look roughly
analogous to functions over lists. For instance, suppose we want to
compute the size of a set. The function looks similar to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span> [<a href="processing-lists.html#%28part._my-len%29" data-pltdoc="x">Some Example Exercises</a>]:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-set-size(s :: S.Set) -&gt; Number:
  cases (Pick) s.pick():
    | pick-none =&gt; 0
    | pick-some(e, r) =&gt;
      1 + my-set-size(r)
  end
end</code></pre></div></div></div><div class="SIntrapara">Though the process of deriving this is similar to that we used for
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>, the random nature of picking elements makes it harder to
write examples that the actual functionâ€™s behavior will match.</div></section>&#13;
<h5 class="heading">6.2.2.1<span class="stt">Â </span><a name="(part._coll-sd-pick)"/>Picking Elements from Sets<span class="button-group"><a href="#(part._coll-sd-pick)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>This lack of an ordering, however, poses a problem. With lists, it was
meaningful to talk about the â€œfirstâ€ and corresponding â€œrestâ€. By
definition, with sets there is not â€œfirstâ€ element. In fact, Pyret
does not even offer fields similar to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">first</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rest</code></span>. In
its place is something a little more accurate but complex.</p><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">.pick</code></span> method returns a random element of a set. It
produces a value of type <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Pick</code></span> (which we get with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">include
pick</code></span>). When we pick an element, there are two
possibilities. One is that the set is empty (analogous to a list being
empty), which gives us a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-none</code></span> value. The other option is
called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-some</code></span>, which gives us an actual member of the set.</p><p/><div class="SIntrapara">The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-some</code></span> variant of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Pick</code></span> has two fields, not
one. To understand why takes a momentâ€™s work. Letâ€™s explore it by
choosing an element of a set:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun an-elt(s :: S.Set):
  cases (Pick) s.pick():
    | pick-none =&gt; raise("empty set")
    | pick-some(e, r) =&gt; e
  end
end</code></pre></div></div></div><div class="SIntrapara">(Notice that we arenâ€™t using the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">r</code></span> field in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-some</code></span> case.)</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can you guess why we didnâ€™t write examples for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">an-elt</code></span>?</p></blockquote></blockquote><p/><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Run <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">an-elt(song-set)</code></span>. What element do you get?</p><p>Run it again. Run it five more times.</p><p>Do you get the same element every time?</p></blockquote></blockquote></div><div class="SIntrapara">No you donâ€™t!<span class="refelem"><span class="refcolumn"><span class="refcontent">Well, actually, itâ€™s impossible to be certain
you donâ€™t. There is a very, very small likelihood you get the exact
same element on every one of six runs. If it happens to you, keep
running it more times!</span></span></span>
Pyret is designed to not always return the same element
when picking from a set. This is on purpose: itâ€™s to drive home the
random nature of choosing from a set, and to prevent your program from
accidentally depending on a particular order that Pyret might use.</div><p/><div class="SIntrapara"><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Given that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">an-elt</code></span> does not return a predictable element, what
(if any) tests can we write for it?</p></blockquote></blockquote></div><div class="SIntrapara">Observe that though we canâ€™t predict <span class="emph">which</span> element <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">an-elt</code></span> will
produce, we do know it will produce an element of the set. Therefore,
what we can write are tests that ensure the resulting element is a
member of the setâ€”<wbr/>though in this case, that would not be
particularly surprising.</div>&#13;
<h5 class="heading">6.2.2.2<span class="stt">Â </span><a name="(part._.Computing_with_.Sets)"/>Computing with Sets<span class="button-group"><a href="#(part._.Computing_with_.Sets)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Once we have picked an element from a set, itâ€™s often useful to obtain
the set consisting of the remaining elements. We have already seen
that choosing the first field of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-some</code></span> is similar to
taking the â€œfirstâ€ of a set. We therefore want a way to get the
â€œrestâ€ of the set. However, we want the rest to what we obtain after
excluding <span class="emph">this particular</span> â€œfirstâ€. Thatâ€™s what the second
field of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pick-some</code></span> is: whatâ€™s left of the set.</p><p/><div class="SIntrapara">Given this, we can write functions over sets that look roughly
analogous to functions over lists. For instance, suppose we want to
compute the size of a set. The function looks similar to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span> [<a href="processing-lists.html#%28part._my-len%29" data-pltdoc="x">Some Example Exercises</a>]:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-set-size(s :: S.Set) -&gt; Number:
  cases (Pick) s.pick():
    | pick-none =&gt; 0
    | pick-some(e, r) =&gt;
      1 + my-set-size(r)
  end
end</code></pre></div></div></div><div class="SIntrapara">Though the process of deriving this is similar to that we used for
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-len</code></span>, the random nature of picking elements makes it harder to
write examples that the actual functionâ€™s behavior will match.</div>&#13;
<h4 class="heading">6.2.3<span class="stt">Â </span><a name="(part._.Combining_.Structured_and_.Collective_.Data)"/>Combining Structured and Collective Data<span class="button-group"><a href="#(part._.Combining_.Structured_and_.Collective_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>As the above examples illustrate, a programâ€™s data organization will
often involve multiple kinds of compound data, often deeply
intertwined. Letâ€™s first think of these in pairs.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p/><div class="SIntrapara">Come up with examples that combine:
</div><div class="SIntrapara"><ul><li><p>structured and conditional data,</p></li><li><p>structured and collective data, and</p></li><li><p>conditional and collective data.</p></li></ul></div><p>Youâ€™ve actually seen examples of each of these above. Identify them.</p></blockquote></blockquote><p>Finally, we might even have all three at once. For instance, a
filesystem is usually a list (collective) of files and folders
(conditional) where each file has several attributes
(structured). Similarly, a social network has a set of pages
(collective) where each page is for a person, organization, or other
thing (conditional), and each page has several attributes
(structured). Therefore, as you can see, combinations of these arise
naturally in all kinds of applications that we deal with on a daily
basis.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Take three of your favorite Web sites or apps. Identify the kinds of
data they present. Classify these as structured, conditional, and
collective. How do they combine these data?</p></blockquote></blockquote>&#13;
<h4 class="heading">6.2.4<span class="stt">Â </span><a name="(part._.Data_.Design_.Problem__.Representing_.Quizzes)"/>Data Design Problem: Representing Quizzes<span class="button-group"><a href="#(part._.Data_.Design_.Problem__.Representing_.Quizzes)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Now that you can make collections of structured data, you can approach
creating the data and programs for fairly sophisticated
applications. Letâ€™s try out a data-design problem, where we will focus
just on creating the data definition, but not on writing the actual
functions.</p><p><span style="font-weight: bold">Problem Statement</span>:
Youâ€™ve been hired to help create software for giving quizzes to
students. The software will show the student a question, read in the
studentâ€™s answer, compare the studentâ€™s answer to the expected answer
(sort of like a Pyret example!), and produce the percentage of
questions that the student got right.</p><p>Your task is to create a data definition for capturing quizzes and
expected answers. Donâ€™t worry about representing the student
responses.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Propose an initial data structure for quizzes. Start by identifying
the pieces you might need and trying to write some sample questions.</p></blockquote></blockquote><p>We might imagine asking a quiz question like â€œwhat is 3 + 4?â€œ. We
would expect the student to answer <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span>. What would capture this?
A piece of structured data with two fields like the following:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Question:
  basic-ques(text :: String, expect :: ???)
end</code></pre></div></div><p>Whatâ€™s a good type for the expected answer? This specific problem has
a numeric answer, but other questions might have other types of
answers. <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Any</code></span> is therefore an appropriate type for the answer.</p><p>We would also need a list of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Question</code></span> to form an entire quiz.</p><p>Sometimes, quiz software allows students to ask for hints.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Assume we wanted to have some (but not all) questions with hints,
which would be text that a student could request for help with a
problem. Modify the current data definition to capture quizzes in
which some questions have hints and some do not.</p></blockquote></blockquote><p>A quiz should still be a list of questions, but the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Question</code></span>
data definition needs another variant in order to handle questions
with hints. The following would work:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Question:
  | basic-ques(text :: String, expect :: Any)
  | hint-ques(text :: String, expect :: Any, hint :: String)
end

A <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">quiz</code></span> is a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">List&lt;Question&gt;</code></span></code></pre></div></div><p>We could imagine extending this example to introduce dependencies
between questions (such as one problem building on the skills of
another), multiple choice questions, checkbox questions, and so on.</p><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Consider the Process Being Displaced</p><blockquote class="RespCSBody"><p>Many companies have tried to improve education through software
systems that automate tasks otherwise done by teachers. There are
systems that show students a video, then give them quizzes (akin to
what you just developed) to check what they have learned. A more
extreme version interleaves videos and quizzes, thus teaching entire
courses at scale, without the need for teacher intervention.</p><p>Massively-online courses (MOOCs) are a style of course that makes
heavy use to computer automation, to enable reaching many more
students without needing more teachers. Proponents of MOOCs and
related educational technology tools have promised game-changing
impacts of such tools, promising to extend quality education to
students around the world who otherwise might lack access to quality
teachers. Technology investors (and indeed some universities) dove in
behind these technologies, hoping for an educational revolution at
scale.</p><p>Unfortunately, research and evaluation have shown that replacing
education with automated systems, even ones with sophisticated
features based on data analysis and predictions that identify skills
that students havenâ€™t quite mastered, doesnâ€™t lead to the promised
gains in learning. Why? It turns out that teaching is about more than
choosing questions, gathering student work, and giving
grades. Teachers provide encouragement, reassurance, and an
understanding of an individual studentsâ€™ situation. Todayâ€™s
computational systems donâ€™t do this. The generally-accepted wisdom
around these tools (backed by three prior decades of research) is that
they are best used to <span class="emph">complement</span> direct instruction by a human
teacher. In such a setting, some tools have resulted in solid
performance gains on the parts of students.</p><p>The social-responsibility takeaway here is that you need to
<span class="emph">consider all the features of the system you might be trying to
replace with a computational approach</span>. Algorithmic quiz-taking tools
have genuine value in some specific context, but they arenâ€™t a
replacement for all of teaching. A failure to understand the many
aspects of teaching, and which ones do and do not make it effective
for educating students, could have avoided a lot of inaccurate hype
about the promise of algorithmic instruction.</p></blockquote></blockquote>    
</body>
</html>