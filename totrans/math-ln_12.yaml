- en: 12\. Differential CalculusÔÉÅ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://leanprover-community.github.io/mathematics_in_lean/C12_Differential_Calculus.html](https://leanprover-community.github.io/mathematics_in_lean/C12_Differential_Calculus.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*[Mathematics in Lean](index.html)* **   12\. Differential Calculus'
  prefs: []
  type: TYPE_NORMAL
- en: '[View page source](_sources/C12_Differential_Calculus.rst.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: We now consider the formalization of notions from *analysis*, starting with
    differentiation in this chapter and turning integration and measure theory in
    the next. In [Section 12.1](#elementary-differential-calculus), we stick with
    the setting of functions from the real numbers to the real numbers, which is familiar
    from any introductory calculus class. In [Section 12.2](#normed-spaces), we then
    consider the notion of a derivative in a much broader setting.
  prefs: []
  type: TYPE_NORMAL
- en: '## 12.1\. Elementary Differential Calculus[ÔÉÅ](#elementary-differential-calculus
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Let `f` be a function from the reals to the reals. There is a difference between
    talking about the derivative of `f` at a single point and talking about the derivative
    function. In Mathlib, the first notion is represented as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can also express that `f` is differentiable at a point without specifying
    its derivative there by writing `DifferentiableAt ‚Ñù`. We specify `‚Ñù` explicitly
    because in a slightly more general context, when talking about functions from
    `‚ÑÇ` to `‚ÑÇ`, we want to be able to distinguish between being differentiable in
    the real sense and being differentiable in the sense of the complex derivative.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be inconvenient to have to provide a proof of differentiability every
    time we want to refer to a derivative. So Mathlib provides a function `deriv f
    : ‚Ñù ‚Üí ‚Ñù` that is defined for any function `f : ‚Ñù ‚Üí ‚Ñù` but is defined to take the
    value `0` at any point where `f` is not differentiable.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Of course there are many lemmas about `deriv` that do require differentiability
    assumptions. For instance, you should think about a counterexample to the next
    lemma without the differentiability assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, however, there are statements that can avoid differentiability
    assumptions by taking advantage of the fact that the value of `deriv` defaults
    to zero when the function is not differentiable. So making sense of the following
    statement requires knowing the precise definition of `deriv`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can even state Rolle‚Äôs theorem without any differentiability assumptions,
    which seems even weirder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this trick does not work for the general mean value theorem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Lean can automatically compute some simple derivatives using the `simp` tactic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]  ## 12.2\. Differential Calculus in Normed Spaces[ÔÉÅ](#differential-calculus-in-normed-spaces
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.1\. Normed spaces[ÔÉÅ](#id3 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Differentiation can be generalized beyond `‚Ñù` using the notion of a *normed
    vector space*, which encapsulates both direction and distance. We start with the
    notion of a *normed group*, which is an additive commutative group equipped with
    a real-valued norm function satisfying the following conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Every normed space is a metric space with distance function \(d(x, y) = \| x
    - y \|\), and hence it is also a topological space. Lean and Mathlib know this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In order to use the notion of a norm with concepts from linear algebra, we add
    the assumption `NormedSpace ‚Ñù E` on top of `NormedAddGroup E`. This stipulates
    that `E` is a vector space over `‚Ñù` and that scalar multiplication satisfies the
    following condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A complete normed space is known as a *Banach space*. Every finite-dimensional
    vector space is complete.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In all the previous examples, we used the real numbers as the base field. More
    generally, we can make sense of calculus with a vector space over any *nontrivially
    normed field*. These are fields that are equipped with a real-valued norm that
    is multiplicative and has the property that not every element has norm zero or
    one (equivalently, there is an element whose norm is bigger than one).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A finite-dimensional vector space over a nontrivially normed field is complete
    as long as the field itself is complete.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.2\. Continuous linear maps[ÔÉÅ](#continuous-linear-maps "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now turn to the morphisms in the category of normed spaces, namely, continuous
    linear maps. In Mathlib, the type of `ùïú`-linear continuous maps between normed
    spaces `E` and `F` is written `E ‚ÜíL[ùïú] F`. They are implemented as *bundled maps*,
    which means that an element of this type a structure that that includes the function
    itself and the properties of being linear and continuous. Lean will insert a coercion
    so that a continuous linear map can be treated as a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Continuous linear maps have an operator norm that is characterized by the following
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There is also a notion of bundled continuous linear *isomorphism*. Their type
    of such isomorphisms is `E ‚âÉL[ùïú] F`.
  prefs: []
  type: TYPE_NORMAL
- en: As a challenging exercise, you can prove the Banach-Steinhaus theorem, also
    known as the Uniform Boundedness Principle. The principle states that a family
    of continuous linear maps from a Banach space into a normed space is pointwise
    bounded, then the norms of these linear maps are uniformly bounded. The main ingredient
    is Baire‚Äôs theorem `nonempty_interior_of_iUnion_of_closed`. (You proved a version
    of this in the topology chapter.) Minor ingredients include `continuous_linear_map.opNorm_le_of_shell`,
    `interior_subset` and `interior_iInter_subset` and `isClosed_le`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.3\. Asymptotic comparisons[ÔÉÅ](#asymptotic-comparisons "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Defining differentiability also requires asymptotic comparisons. Mathlib has
    an extensive library covering the big O and little o relations, whose definitions
    are shown below. Opening the `asymptotics` locale allows us to use the corresponding
    notation. Here we will only use little o to define differentiability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.4\. Differentiability[ÔÉÅ](#differentiability "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are now ready to discuss differentiable functions between normed spaces.
    In analogy the elementary one-dimensional, Mathlib defines a predicate `HasFDerivAt`
    and a function `fderiv`. Here the letter ‚Äúf‚Äù stands for *Fr√©chet*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We also have iterated derivatives that take values in the type of multilinear
    maps `E [√ón]‚ÜíL[ùïú] F`, and we have continuously differential functions. The type
    `‚Ñï‚àû` is `‚Ñï` with an additional element `‚àû` that is bigger than every natural number.
    So \(\mathcal{C}^\infty\) functions are functions `f` that satisfy `ContDiff ùïú
    ‚ä§ f`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The differentiability parameter in `ContDiff` can also take value `œâ : WithTop
    ‚Ñï‚àû` to denote analytic functions.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a stricter notion of differentiability called `HasStrictFDerivAt`,
    which is used in the statement of the inverse function theorem and the statement
    of the implicit function theorem, both of which are in Mathlib. Over `‚Ñù` or `‚ÑÇ`,
    continuously differentiable functions are strictly differentiable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The local inverse theorem is stated using an operation that produces an inverse
    function from a function and the assumptions that the function is strictly differentiable
    at a point `a` and that its derivative is an isomorphism.
  prefs: []
  type: TYPE_NORMAL
- en: The first example below gets this local inverse. The next one states that it
    is indeed a local inverse from the left and from the right, and that it is strictly
    differentiable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This has been only a quick tour of the differential calculus in Mathlib. The
    library contains many variations that we have not discussed. For example, you
    may want to use one-sided derivatives in the one-dimensional setting. The means
    to do so are found in Mathlib in a more general context; see `HasFDerivWithinAt`
    or the even more general `HasFDerivAtFilter`. [Previous](C11_Topology.html "11\.
    Topology") [Next](C13_Integration_and_Measure_Theory.html "13\. Integration and
    Measure Theory")
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ¬© Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). We now consider the formalization
    of notions from *analysis*, starting with differentiation in this chapter and
    turning integration and measure theory in the next. In [Section 12.1](#elementary-differential-calculus),
    we stick with the setting of functions from the real numbers to the real numbers,
    which is familiar from any introductory calculus class. In [Section 12.2](#normed-spaces),
    we then consider the notion of a derivative in a much broader setting.
  prefs: []
  type: TYPE_NORMAL
- en: '## 12.1\. Elementary Differential Calculus[ÔÉÅ](#elementary-differential-calculus
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Let `f` be a function from the reals to the reals. There is a difference between
    talking about the derivative of `f` at a single point and talking about the derivative
    function. In Mathlib, the first notion is represented as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can also express that `f` is differentiable at a point without specifying
    its derivative there by writing `DifferentiableAt ‚Ñù`. We specify `‚Ñù` explicitly
    because in a slightly more general context, when talking about functions from
    `‚ÑÇ` to `‚ÑÇ`, we want to be able to distinguish between being differentiable in
    the real sense and being differentiable in the sense of the complex derivative.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be inconvenient to have to provide a proof of differentiability every
    time we want to refer to a derivative. So Mathlib provides a function `deriv f
    : ‚Ñù ‚Üí ‚Ñù` that is defined for any function `f : ‚Ñù ‚Üí ‚Ñù` but is defined to take the
    value `0` at any point where `f` is not differentiable.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Of course there are many lemmas about `deriv` that do require differentiability
    assumptions. For instance, you should think about a counterexample to the next
    lemma without the differentiability assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, however, there are statements that can avoid differentiability
    assumptions by taking advantage of the fact that the value of `deriv` defaults
    to zero when the function is not differentiable. So making sense of the following
    statement requires knowing the precise definition of `deriv`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can even state Rolle‚Äôs theorem without any differentiability assumptions,
    which seems even weirder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this trick does not work for the general mean value theorem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Lean can automatically compute some simple derivatives using the `simp` tactic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]  ## 12.2\. Differential Calculus in Normed Spaces[ÔÉÅ](#differential-calculus-in-normed-spaces
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.1\. Normed spaces[ÔÉÅ](#id3 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Differentiation can be generalized beyond `‚Ñù` using the notion of a *normed
    vector space*, which encapsulates both direction and distance. We start with the
    notion of a *normed group*, which is an additive commutative group equipped with
    a real-valued norm function satisfying the following conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Every normed space is a metric space with distance function \(d(x, y) = \| x
    - y \|\), and hence it is also a topological space. Lean and Mathlib know this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In order to use the notion of a norm with concepts from linear algebra, we add
    the assumption `NormedSpace ‚Ñù E` on top of `NormedAddGroup E`. This stipulates
    that `E` is a vector space over `‚Ñù` and that scalar multiplication satisfies the
    following condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: A complete normed space is known as a *Banach space*. Every finite-dimensional
    vector space is complete.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In all the previous examples, we used the real numbers as the base field. More
    generally, we can make sense of calculus with a vector space over any *nontrivially
    normed field*. These are fields that are equipped with a real-valued norm that
    is multiplicative and has the property that not every element has norm zero or
    one (equivalently, there is an element whose norm is bigger than one).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A finite-dimensional vector space over a nontrivially normed field is complete
    as long as the field itself is complete.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.2\. Continuous linear maps[ÔÉÅ](#continuous-linear-maps "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now turn to the morphisms in the category of normed spaces, namely, continuous
    linear maps. In Mathlib, the type of `ùïú`-linear continuous maps between normed
    spaces `E` and `F` is written `E ‚ÜíL[ùïú] F`. They are implemented as *bundled maps*,
    which means that an element of this type a structure that that includes the function
    itself and the properties of being linear and continuous. Lean will insert a coercion
    so that a continuous linear map can be treated as a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Continuous linear maps have an operator norm that is characterized by the following
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There is also a notion of bundled continuous linear *isomorphism*. Their type
    of such isomorphisms is `E ‚âÉL[ùïú] F`.
  prefs: []
  type: TYPE_NORMAL
- en: As a challenging exercise, you can prove the Banach-Steinhaus theorem, also
    known as the Uniform Boundedness Principle. The principle states that a family
    of continuous linear maps from a Banach space into a normed space is pointwise
    bounded, then the norms of these linear maps are uniformly bounded. The main ingredient
    is Baire‚Äôs theorem `nonempty_interior_of_iUnion_of_closed`. (You proved a version
    of this in the topology chapter.) Minor ingredients include `continuous_linear_map.opNorm_le_of_shell`,
    `interior_subset` and `interior_iInter_subset` and `isClosed_le`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.3\. Asymptotic comparisons[ÔÉÅ](#asymptotic-comparisons "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Defining differentiability also requires asymptotic comparisons. Mathlib has
    an extensive library covering the big O and little o relations, whose definitions
    are shown below. Opening the `asymptotics` locale allows us to use the corresponding
    notation. Here we will only use little o to define differentiability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.4\. Differentiability[ÔÉÅ](#differentiability "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are now ready to discuss differentiable functions between normed spaces.
    In analogy the elementary one-dimensional, Mathlib defines a predicate `HasFDerivAt`
    and a function `fderiv`. Here the letter ‚Äúf‚Äù stands for *Fr√©chet*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We also have iterated derivatives that take values in the type of multilinear
    maps `E [√ón]‚ÜíL[ùïú] F`, and we have continuously differential functions. The type
    `‚Ñï‚àû` is `‚Ñï` with an additional element `‚àû` that is bigger than every natural number.
    So \(\mathcal{C}^\infty\) functions are functions `f` that satisfy `ContDiff ùïú
    ‚ä§ f`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The differentiability parameter in `ContDiff` can also take value `œâ : WithTop
    ‚Ñï‚àû` to denote analytic functions.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a stricter notion of differentiability called `HasStrictFDerivAt`,
    which is used in the statement of the inverse function theorem and the statement
    of the implicit function theorem, both of which are in Mathlib. Over `‚Ñù` or `‚ÑÇ`,
    continuously differentiable functions are strictly differentiable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The local inverse theorem is stated using an operation that produces an inverse
    function from a function and the assumptions that the function is strictly differentiable
    at a point `a` and that its derivative is an isomorphism.
  prefs: []
  type: TYPE_NORMAL
- en: The first example below gets this local inverse. The next one states that it
    is indeed a local inverse from the left and from the right, and that it is strictly
    differentiable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This has been only a quick tour of the differential calculus in Mathlib. The
    library contains many variations that we have not discussed. For example, you
    may want to use one-sided derivatives in the one-dimensional setting. The means
    to do so are found in Mathlib in a more general context; see `HasFDerivWithinAt`
    or the even more general `HasFDerivAtFilter`.  ## 12.1\. Elementary Differential
    Calculus[ÔÉÅ](#elementary-differential-calculus "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Let `f` be a function from the reals to the reals. There is a difference between
    talking about the derivative of `f` at a single point and talking about the derivative
    function. In Mathlib, the first notion is represented as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We can also express that `f` is differentiable at a point without specifying
    its derivative there by writing `DifferentiableAt ‚Ñù`. We specify `‚Ñù` explicitly
    because in a slightly more general context, when talking about functions from
    `‚ÑÇ` to `‚ÑÇ`, we want to be able to distinguish between being differentiable in
    the real sense and being differentiable in the sense of the complex derivative.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be inconvenient to have to provide a proof of differentiability every
    time we want to refer to a derivative. So Mathlib provides a function `deriv f
    : ‚Ñù ‚Üí ‚Ñù` that is defined for any function `f : ‚Ñù ‚Üí ‚Ñù` but is defined to take the
    value `0` at any point where `f` is not differentiable.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Of course there are many lemmas about `deriv` that do require differentiability
    assumptions. For instance, you should think about a counterexample to the next
    lemma without the differentiability assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, however, there are statements that can avoid differentiability
    assumptions by taking advantage of the fact that the value of `deriv` defaults
    to zero when the function is not differentiable. So making sense of the following
    statement requires knowing the precise definition of `deriv`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We can even state Rolle‚Äôs theorem without any differentiability assumptions,
    which seems even weirder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this trick does not work for the general mean value theorem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Lean can automatically compute some simple derivatives using the `simp` tactic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '## 12.2\. Differential Calculus in Normed Spaces[ÔÉÅ](#differential-calculus-in-normed-spaces
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.1\. Normed spaces[ÔÉÅ](#id3 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Differentiation can be generalized beyond `‚Ñù` using the notion of a *normed
    vector space*, which encapsulates both direction and distance. We start with the
    notion of a *normed group*, which is an additive commutative group equipped with
    a real-valued norm function satisfying the following conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Every normed space is a metric space with distance function \(d(x, y) = \| x
    - y \|\), and hence it is also a topological space. Lean and Mathlib know this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In order to use the notion of a norm with concepts from linear algebra, we add
    the assumption `NormedSpace ‚Ñù E` on top of `NormedAddGroup E`. This stipulates
    that `E` is a vector space over `‚Ñù` and that scalar multiplication satisfies the
    following condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: A complete normed space is known as a *Banach space*. Every finite-dimensional
    vector space is complete.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In all the previous examples, we used the real numbers as the base field. More
    generally, we can make sense of calculus with a vector space over any *nontrivially
    normed field*. These are fields that are equipped with a real-valued norm that
    is multiplicative and has the property that not every element has norm zero or
    one (equivalently, there is an element whose norm is bigger than one).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: A finite-dimensional vector space over a nontrivially normed field is complete
    as long as the field itself is complete.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.2\. Continuous linear maps[ÔÉÅ](#continuous-linear-maps "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now turn to the morphisms in the category of normed spaces, namely, continuous
    linear maps. In Mathlib, the type of `ùïú`-linear continuous maps between normed
    spaces `E` and `F` is written `E ‚ÜíL[ùïú] F`. They are implemented as *bundled maps*,
    which means that an element of this type a structure that that includes the function
    itself and the properties of being linear and continuous. Lean will insert a coercion
    so that a continuous linear map can be treated as a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Continuous linear maps have an operator norm that is characterized by the following
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: There is also a notion of bundled continuous linear *isomorphism*. Their type
    of such isomorphisms is `E ‚âÉL[ùïú] F`.
  prefs: []
  type: TYPE_NORMAL
- en: As a challenging exercise, you can prove the Banach-Steinhaus theorem, also
    known as the Uniform Boundedness Principle. The principle states that a family
    of continuous linear maps from a Banach space into a normed space is pointwise
    bounded, then the norms of these linear maps are uniformly bounded. The main ingredient
    is Baire‚Äôs theorem `nonempty_interior_of_iUnion_of_closed`. (You proved a version
    of this in the topology chapter.) Minor ingredients include `continuous_linear_map.opNorm_le_of_shell`,
    `interior_subset` and `interior_iInter_subset` and `isClosed_le`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.3\. Asymptotic comparisons[ÔÉÅ](#asymptotic-comparisons "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Defining differentiability also requires asymptotic comparisons. Mathlib has
    an extensive library covering the big O and little o relations, whose definitions
    are shown below. Opening the `asymptotics` locale allows us to use the corresponding
    notation. Here we will only use little o to define differentiability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.4\. Differentiability[ÔÉÅ](#differentiability "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are now ready to discuss differentiable functions between normed spaces.
    In analogy the elementary one-dimensional, Mathlib defines a predicate `HasFDerivAt`
    and a function `fderiv`. Here the letter ‚Äúf‚Äù stands for *Fr√©chet*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We also have iterated derivatives that take values in the type of multilinear
    maps `E [√ón]‚ÜíL[ùïú] F`, and we have continuously differential functions. The type
    `‚Ñï‚àû` is `‚Ñï` with an additional element `‚àû` that is bigger than every natural number.
    So \(\mathcal{C}^\infty\) functions are functions `f` that satisfy `ContDiff ùïú
    ‚ä§ f`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The differentiability parameter in `ContDiff` can also take value `œâ : WithTop
    ‚Ñï‚àû` to denote analytic functions.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a stricter notion of differentiability called `HasStrictFDerivAt`,
    which is used in the statement of the inverse function theorem and the statement
    of the implicit function theorem, both of which are in Mathlib. Over `‚Ñù` or `‚ÑÇ`,
    continuously differentiable functions are strictly differentiable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The local inverse theorem is stated using an operation that produces an inverse
    function from a function and the assumptions that the function is strictly differentiable
    at a point `a` and that its derivative is an isomorphism.
  prefs: []
  type: TYPE_NORMAL
- en: The first example below gets this local inverse. The next one states that it
    is indeed a local inverse from the left and from the right, and that it is strictly
    differentiable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This has been only a quick tour of the differential calculus in Mathlib. The
    library contains many variations that we have not discussed. For example, you
    may want to use one-sided derivatives in the one-dimensional setting. The means
    to do so are found in Mathlib in a more general context; see `HasFDerivWithinAt`
    or the even more general `HasFDerivAtFilter`.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.1\. Normed spaces[ÔÉÅ](#id3 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Differentiation can be generalized beyond `‚Ñù` using the notion of a *normed
    vector space*, which encapsulates both direction and distance. We start with the
    notion of a *normed group*, which is an additive commutative group equipped with
    a real-valued norm function satisfying the following conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Every normed space is a metric space with distance function \(d(x, y) = \| x
    - y \|\), and hence it is also a topological space. Lean and Mathlib know this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In order to use the notion of a norm with concepts from linear algebra, we add
    the assumption `NormedSpace ‚Ñù E` on top of `NormedAddGroup E`. This stipulates
    that `E` is a vector space over `‚Ñù` and that scalar multiplication satisfies the
    following condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: A complete normed space is known as a *Banach space*. Every finite-dimensional
    vector space is complete.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In all the previous examples, we used the real numbers as the base field. More
    generally, we can make sense of calculus with a vector space over any *nontrivially
    normed field*. These are fields that are equipped with a real-valued norm that
    is multiplicative and has the property that not every element has norm zero or
    one (equivalently, there is an element whose norm is bigger than one).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: A finite-dimensional vector space over a nontrivially normed field is complete
    as long as the field itself is complete.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.2\. Continuous linear maps[ÔÉÅ](#continuous-linear-maps "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now turn to the morphisms in the category of normed spaces, namely, continuous
    linear maps. In Mathlib, the type of `ùïú`-linear continuous maps between normed
    spaces `E` and `F` is written `E ‚ÜíL[ùïú] F`. They are implemented as *bundled maps*,
    which means that an element of this type a structure that that includes the function
    itself and the properties of being linear and continuous. Lean will insert a coercion
    so that a continuous linear map can be treated as a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Continuous linear maps have an operator norm that is characterized by the following
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: There is also a notion of bundled continuous linear *isomorphism*. Their type
    of such isomorphisms is `E ‚âÉL[ùïú] F`.
  prefs: []
  type: TYPE_NORMAL
- en: As a challenging exercise, you can prove the Banach-Steinhaus theorem, also
    known as the Uniform Boundedness Principle. The principle states that a family
    of continuous linear maps from a Banach space into a normed space is pointwise
    bounded, then the norms of these linear maps are uniformly bounded. The main ingredient
    is Baire‚Äôs theorem `nonempty_interior_of_iUnion_of_closed`. (You proved a version
    of this in the topology chapter.) Minor ingredients include `continuous_linear_map.opNorm_le_of_shell`,
    `interior_subset` and `interior_iInter_subset` and `isClosed_le`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.3\. Asymptotic comparisons[ÔÉÅ](#asymptotic-comparisons "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Defining differentiability also requires asymptotic comparisons. Mathlib has
    an extensive library covering the big O and little o relations, whose definitions
    are shown below. Opening the `asymptotics` locale allows us to use the corresponding
    notation. Here we will only use little o to define differentiability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.4\. Differentiability[ÔÉÅ](#differentiability "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are now ready to discuss differentiable functions between normed spaces.
    In analogy the elementary one-dimensional, Mathlib defines a predicate `HasFDerivAt`
    and a function `fderiv`. Here the letter ‚Äúf‚Äù stands for *Fr√©chet*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We also have iterated derivatives that take values in the type of multilinear
    maps `E [√ón]‚ÜíL[ùïú] F`, and we have continuously differential functions. The type
    `‚Ñï‚àû` is `‚Ñï` with an additional element `‚àû` that is bigger than every natural number.
    So \(\mathcal{C}^\infty\) functions are functions `f` that satisfy `ContDiff ùïú
    ‚ä§ f`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The differentiability parameter in `ContDiff` can also take value `œâ : WithTop
    ‚Ñï‚àû` to denote analytic functions.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a stricter notion of differentiability called `HasStrictFDerivAt`,
    which is used in the statement of the inverse function theorem and the statement
    of the implicit function theorem, both of which are in Mathlib. Over `‚Ñù` or `‚ÑÇ`,
    continuously differentiable functions are strictly differentiable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The local inverse theorem is stated using an operation that produces an inverse
    function from a function and the assumptions that the function is strictly differentiable
    at a point `a` and that its derivative is an isomorphism.
  prefs: []
  type: TYPE_NORMAL
- en: The first example below gets this local inverse. The next one states that it
    is indeed a local inverse from the left and from the right, and that it is strictly
    differentiable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This has been only a quick tour of the differential calculus in Mathlib. The
    library contains many variations that we have not discussed. For example, you
    may want to use one-sided derivatives in the one-dimensional setting. The means
    to do so are found in Mathlib in a more general context; see `HasFDerivWithinAt`
    or the even more general `HasFDerivAtFilter`.*
  prefs: []
  type: TYPE_NORMAL
