- en: 25Â Factoring NumbersğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 25Â åˆ†è§£æ•°å­—ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/factoring-numbers.html](https://dcic-world.org/2025-08-27/factoring-numbers.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/factoring-numbers.html](https://dcic-world.org/2025-08-27/factoring-numbers.html)
- en: '|  |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Much of modern cryptography is founded on the difficulty of factoring numbers.
    Suppose we want to factorize \(n\). We can just check whether any of the numbers
    from \(2\) to \(n-1\) (indeed, up to \(\sqrt{n}\)) divides \(n\): if it does,
    then itâ€™s a factor, and we recursively factor whatâ€™s left. So that just takes
    a linear amount of time! Why is this hard?'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ç°ä»£å¯†ç å­¦çš„å¾ˆå¤§ä¸€éƒ¨åˆ†å»ºç«‹åœ¨åˆ†è§£æ•°å­—çš„å›°éš¾æ€§ä¹‹ä¸Šã€‚å‡è®¾æˆ‘ä»¬æƒ³è¦åˆ†è§£ \(n\)ã€‚æˆ‘ä»¬å¯ä»¥ç®€å•åœ°æ£€æŸ¥ä» \(2\) åˆ° \(n-1\)ï¼ˆå®é™…ä¸Šï¼Œç›´åˆ° \(\sqrt{n}\)ï¼‰çš„ä»»ä½•æ•°å­—æ˜¯å¦å¯ä»¥æ•´é™¤
    \(n\)ï¼šå¦‚æœå¯ä»¥ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯ä¸€ä¸ªå› å­ï¼Œç„¶åæˆ‘ä»¬é€’å½’åœ°åˆ†è§£å‰©ä¸‹çš„éƒ¨åˆ†ã€‚è¿™åªéœ€è¦çº¿æ€§æ—¶é—´ï¼ä¸ºä»€ä¹ˆè¿™å¾ˆéš¾ï¼Ÿ
- en: 'The problem is itâ€™s linear in the â€œwrongâ€ thing: the value of the number. However,
    the value of a number is, in a place notation, in the worst case exponential in
    its size. So weâ€™d have to iterate until at least the square root of the exponential
    of the size, which is size divided by 2, which is in the same big-O class, i.e.,
    exponential in the value. In general we donâ€™t really know how to improve the worst-case
    performance of factorization, which is why contemporary cryptography works. (We
    discuss numbers elsewhere too [[The Complexity of Numbers](avoid-recomp.html#%28part._numbers-not-constant%29)].)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜åœ¨äºå®ƒåœ¨â€œé”™è¯¯â€çš„äº‹ç‰©ä¸Šå‘ˆçº¿æ€§ï¼šæ•°å­—çš„å€¼ã€‚ç„¶è€Œï¼Œåœ¨ä½è¡¨ç¤ºæ³•ä¸­ï¼Œä¸€ä¸ªæ•°å­—çš„å€¼åœ¨æœ€åæƒ…å†µä¸‹æ˜¯å®ƒå¤§å°çš„æŒ‡æ•°çº§ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¿…é¡»è¿­ä»£ç›´åˆ°è‡³å°‘æ˜¯å¤§å°æŒ‡æ•°çš„å¹³æ–¹æ ¹ï¼Œå³å¤§å°é™¤ä»¥2ï¼Œè¿™å±äºç›¸åŒçš„
    big-O ç±»ï¼Œå³å€¼çš„æŒ‡æ•°çº§ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæˆ‘ä»¬å®é™…ä¸Šä¸çŸ¥é“å¦‚ä½•æ”¹è¿›å› å­åˆ†è§£çš„æœ€åæƒ…å†µæ€§èƒ½ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆå½“ä»£å¯†ç å­¦å·¥ä½œã€‚ï¼ˆæˆ‘ä»¬ä¹Ÿåœ¨å…¶ä»–åœ°æ–¹è®¨è®ºäº†æ•°å­— [[æ•°å­—çš„å¤æ‚æ€§](avoid-recomp.html#%28part._numbers-not-constant%29)]ã€‚ï¼‰
- en: 'In practice, it is useful to have factorization algorithms that terminate quickly.
    They obviously cannot be perfect; we have to compromise instead on accuracy in
    one way or another: reporting a non-prime as a prime, reporting a non-factor as
    a factor, etc.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®è·µä¸­ï¼Œæ‹¥æœ‰å¿«é€Ÿç»ˆæ­¢çš„å› å­åˆ†è§£ç®—æ³•æ˜¯æœ‰ç”¨çš„ã€‚æ˜¾ç„¶ï¼Œå®ƒä»¬ä¸èƒ½æ˜¯å®Œç¾çš„ï¼›æˆ‘ä»¬ä¸å¾—ä¸åœ¨æŸç§ç¨‹åº¦ä¸Šåœ¨å‡†ç¡®æ€§ä¸Šåšå‡ºå¦¥åï¼šæŠ¥å‘Šä¸€ä¸ªéè´¨æ•°ä¸ºè´¨æ•°ï¼ŒæŠ¥å‘Šä¸€ä¸ªéå› å­ä¸ºå› å­ç­‰ã€‚
- en: 'One well-known algorithm is called Pollardâ€™s rho algorithm. It will attempt
    to find a factor for a number. If it succeeds, we are guaranteed that what it
    found is indeed a factor. If it fails, however, we cannot be sure that the number
    is actually prime: there may be other factors lurking.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªè‘—åçš„ç®—æ³•è¢«ç§°ä¸º Pollard çš„ rho ç®—æ³•ã€‚å®ƒå°†å°è¯•æ‰¾åˆ°ä¸€ä¸ªæ•°å­—çš„å› å­ã€‚å¦‚æœå®ƒæˆåŠŸäº†ï¼Œæˆ‘ä»¬å¯ä»¥ä¿è¯å®ƒæ‰¾åˆ°çš„ç¡®å®æ˜¯ä¸€ä¸ªå› å­ã€‚å¦‚æœå¤±è´¥äº†ï¼Œç„¶è€Œï¼Œæˆ‘ä»¬æ— æ³•ç¡®å®šè¯¥æ•°å­—å®é™…ä¸Šæ˜¯å¦æ˜¯è´¨æ•°ï¼šå¯èƒ½è¿˜æœ‰å…¶ä»–éšè—çš„å› å­ã€‚
- en: 'The algorithm gets its name from a picture that should be familiar from [Detecting
    Cycles](cycle-detection.html):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: è¯¥ç®—æ³•çš„åå­—æ¥æºäºä¸€ä¸ªåº”è¯¥ä» [æ£€æµ‹å¾ªç¯](cycle-detection.html) ä¸­ç†Ÿæ‚‰çš„å›¾ç‰‡ï¼š
- en: '![](../Images/31742a6ba02914cbc2bca965912ea982.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/31742a6ba02914cbc2bca965912ea982.png)'
- en: If you rotate that a little bit, you get the Greek letter \(\rho\). The similarity,
    as we will see in a moment, is not a coincidence.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ç¨å¾®æ—‹è½¬ä¸€ä¸‹ï¼Œä½ ä¼šå¾—åˆ°å¸Œè…Šå­—æ¯ \(\rho\)ã€‚è¿™ç§ç›¸ä¼¼æ€§ï¼Œæ­£å¦‚æˆ‘ä»¬ç¨åå°†çœ‹åˆ°çš„ï¼Œä¸æ˜¯å·§åˆã€‚
- en: 'Explaining the algorithm requires more number theory than we can cover here:
    if youâ€™re interested, read more about it [on Wikipedia](https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm).
    Instead, we will focus on the code.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: è§£é‡Šè¿™ä¸ªç®—æ³•éœ€è¦æ¯”æˆ‘ä»¬è¿™é‡Œèƒ½æ¶µç›–çš„æ›´å¤šæ•°è®ºï¼šå¦‚æœä½ æ„Ÿå…´è¶£ï¼Œæ›´å¤šå…³äºå®ƒ [åœ¨ç»´åŸºç™¾ç§‘ä¸Š](https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm)
    çš„ä¿¡æ¯ã€‚ç›¸åï¼Œæˆ‘ä»¬å°†ä¸“æ³¨äºä»£ç ã€‚
- en: 'First, we need a helper function that can compute the greatest common denominator:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥è®¡ç®—æœ€å¤§å…¬çº¦æ•°ï¼š
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With that, we can define the Pollard-rho implementation. Recall that the function
    may or may not succeed in finding a factor (in particular, it must fail when given
    a prime!), so we use an `Option` type to reflect the two possibilities:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰äº†è¿™ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ Pollard-rho å®ç°æ–¹æ³•ã€‚å›æƒ³ä¸€ä¸‹ï¼Œè¯¥å‡½æ•°å¯èƒ½æˆåŠŸä¹Ÿå¯èƒ½ä¸æˆåŠŸåœ°åœ¨æ‰¾åˆ°å› å­ï¼ˆç‰¹åˆ«æ˜¯ï¼Œå½“ç»™å®šä¸€ä¸ªè´¨æ•°æ—¶ï¼Œå®ƒå¿…é¡»å¤±è´¥ï¼ï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨
    `Option` ç±»å‹æ¥åæ˜ ä¸¤ç§å¯èƒ½æ€§ï¼š
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The key step is the computation `g(x)` versus `g(g(x))`. We can imagine `x`
    is the tortoise, so `g(x)` is the tortoiseâ€™s update, while `y` is the hare, so
    `g(g(y))` is the hareâ€™s update.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: å…³é”®æ­¥éª¤æ˜¯è®¡ç®— `g(x)` ä¸ `g(g(x))`ã€‚æˆ‘ä»¬å¯ä»¥æƒ³è±¡ `x` æ˜¯ä¹Œé¾Ÿï¼Œæ‰€ä»¥ `g(x)` æ˜¯ä¹Œé¾Ÿçš„æ›´æ–°ï¼Œè€Œ `y` æ˜¯å…”å­ï¼Œæ‰€ä»¥ `g(g(y))`
    æ˜¯å…”å­çš„æ›´æ–°ã€‚
- en: 'Try to run the above on the following values and see what it produces:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: å°è¯•åœ¨ä»¥ä¸‹å€¼ä¸Šè¿è¡Œä¸Šè¿°ä»£ç ï¼Œçœ‹çœ‹å®ƒä¼šäº§ç”Ÿä»€ä¹ˆç»“æœï¼š
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In general, we can check the first few numbers and see how closely they match
    our intuition:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸ï¼Œæˆ‘ä»¬å¯ä»¥æ£€æŸ¥å‰å‡ ä¸ªæ•°å­—ï¼Œçœ‹çœ‹å®ƒä»¬å¦‚ä½•æ¥è¿‘æˆ‘ä»¬çš„ç›´è§‰ï¼š
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Exercise
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see any patterns in the above output? Does it help you make any conjectures
    about the algorithm? Can you mathematically prove your conjectures?
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ åœ¨ä¸Šé¢çš„è¾“å‡ºä¸­çœ‹åˆ°äº†ä»»ä½•æ¨¡å¼å—ï¼Ÿè¿™å¯¹ä½ å¯¹ç®—æ³•åšå‡ºä»»ä½•çŒœæƒ³æœ‰å¸®åŠ©å—ï¼Ÿä½ èƒ½ç”¨æ•°å­¦æ–¹æ³•è¯æ˜ä½ çš„çŒœæƒ³å—ï¼Ÿ
