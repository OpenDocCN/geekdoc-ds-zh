- en: 25¬†Factoring Numbersüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/factoring-numbers.html](https://dcic-world.org/2025-08-27/factoring-numbers.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'Much of modern cryptography is founded on the difficulty of factoring numbers.
    Suppose we want to factorize \(n\). We can just check whether any of the numbers
    from \(2\) to \(n-1\) (indeed, up to \(\sqrt{n}\)) divides \(n\): if it does,
    then it‚Äôs a factor, and we recursively factor what‚Äôs left. So that just takes
    a linear amount of time! Why is this hard?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is it‚Äôs linear in the ‚Äúwrong‚Äù thing: the value of the number. However,
    the value of a number is, in a place notation, in the worst case exponential in
    its size. So we‚Äôd have to iterate until at least the square root of the exponential
    of the size, which is size divided by 2, which is in the same big-O class, i.e.,
    exponential in the value. In general we don‚Äôt really know how to improve the worst-case
    performance of factorization, which is why contemporary cryptography works. (We
    discuss numbers elsewhere too [[The Complexity of Numbers](avoid-recomp.html#%28part._numbers-not-constant%29)].)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, it is useful to have factorization algorithms that terminate quickly.
    They obviously cannot be perfect; we have to compromise instead on accuracy in
    one way or another: reporting a non-prime as a prime, reporting a non-factor as
    a factor, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One well-known algorithm is called Pollard‚Äôs rho algorithm. It will attempt
    to find a factor for a number. If it succeeds, we are guaranteed that what it
    found is indeed a factor. If it fails, however, we cannot be sure that the number
    is actually prime: there may be other factors lurking.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm gets its name from a picture that should be familiar from [Detecting
    Cycles](cycle-detection.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/31742a6ba02914cbc2bca965912ea982.png)'
  prefs: []
  type: TYPE_IMG
- en: If you rotate that a little bit, you get the Greek letter \(\rho\). The similarity,
    as we will see in a moment, is not a coincidence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explaining the algorithm requires more number theory than we can cover here:
    if you‚Äôre interested, read more about it [on Wikipedia](https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm).
    Instead, we will focus on the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a helper function that can compute the greatest common denominator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we can define the Pollard-rho implementation. Recall that the function
    may or may not succeed in finding a factor (in particular, it must fail when given
    a prime!), so we use an `Option` type to reflect the two possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The key step is the computation `g(x)` versus `g(g(x))`. We can imagine `x`
    is the tortoise, so `g(x)` is the tortoise‚Äôs update, while `y` is the hare, so
    `g(g(y))` is the hare‚Äôs update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to run the above on the following values and see what it produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, we can check the first few numbers and see how closely they match
    our intuition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see any patterns in the above output? Does it help you make any conjectures
    about the algorithm? Can you mathematically prove your conjectures?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
