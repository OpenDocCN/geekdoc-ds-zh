<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>28Â Pyret for Racketeers and SchemersğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>28Â Pyret for Racketeers and SchemersğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/p4rs.html">https://dcic-world.org/2025-08-27/p4rs.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._.Numbers__.Strings__and_.Booleans%29" class="toclink" data-pltdoc="x">28.1Â Numbers, Strings, and Booleans</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Infix_.Expressions%29" class="toclink" data-pltdoc="x">28.2Â Infix Expressions</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Function_.Definition_and_.Application%29" class="toclink" data-pltdoc="x">28.3Â Function Definition and Application</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Tests%29" class="toclink" data-pltdoc="x">28.4Â Tests</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Variable_.Names%29" class="toclink" data-pltdoc="x">28.5Â Variable Names</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Data_.Definitions%29" class="toclink" data-pltdoc="x">28.6Â Data Definitions</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Conditionals%29" class="toclink" data-pltdoc="x">28.7Â Conditionals</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Lists%29" class="toclink" data-pltdoc="x">28.8Â Lists</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.First-.Class_.Functions%29" class="toclink" data-pltdoc="x">28.9Â First-Class Functions</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Annotations%29" class="toclink" data-pltdoc="x">28.10Â Annotations</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.What_.Else_%29" class="toclink" data-pltdoc="x">28.11Â What Else?</a></p></td></tr></table><p>If youâ€™ve programmed before in a language like Scheme or the student
levels of Racket (or the WeScheme programming environment), or for
that matter even in certain parts of OCaml, Haskell, Scala, Erlang,
Clojure, or other languages, you will find many parts of Pyret very
familiar. This chapter is specifically written to help you make the
transition from (student) Racket/Scheme/WeScheme (abbreviated â€œRSWâ€)
to Pyret by showing you how to convert the syntax. Most of what we say
applies to all these languages, though in some cases we will refer
specifically to Racket (and WeScheme) features not found in Scheme.</p><p>In every example below, the two programs will produce the same results.</p><section class="SsectionLevel3" id="section 28.1"><h3 class="heading">28.1Â <a name="(part._.Numbers__.Strings__and_.Booleans)"/>Numbers, Strings, and Booleans<a href="#(part._.Numbers__.Strings__and_.Booleans)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Numbers are very similar between the two. Like Scheme, Pyret
implements arbitrary-precision numbers and rationals. Some of the more
exotic numeric systems of Scheme (such as complex numbers) arenâ€™t in
Pyret; Pyret also treats imprecise numbers slightly differently.</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>1</p></td><td><p><code data-lang="pyret" class="sourceCode">1</code></p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>1/2</p></td><td><p><code data-lang="pyret" class="sourceCode">1/2</code></p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>#i3.14</p></td><td><p><code data-lang="pyret" class="sourceCode">~3.14</code></p></td></tr></table><p>Strings are also very similar, though Pyret allows you to use
single-quotes as well.</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>"Hello,Â world!"</p></td><td><p><code data-lang="pyret" class="sourceCode">"Hello, world!"</code></p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>"\"Hello\",Â heÂ said"</p></td><td><p><code data-lang="pyret" class="sourceCode">"\"Hello\", he said"</code></p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>"\"Hello\",Â heÂ said"</p></td><td><p><code data-lang="pyret" class="sourceCode">'"Hello", he said'</code></p></td></tr></table><p>Booleans have the same names:</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>true</p></td><td><p><code data-lang="pyret" class="sourceCode">true</code></p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>false</p></td><td><p><code data-lang="pyret" class="sourceCode">false</code></p></td></tr></table></section><section class="SsectionLevel3" id="section 28.2"><h3 class="heading">28.2Â <a name="(part._.Infix_.Expressions)"/>Infix Expressions<a href="#(part._.Infix_.Expressions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Pyret uses an infix syntax, reminiscent of many other textual
programming languages:</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(+Â 1Â 2)</p></td><td><p><code data-lang="pyret" class="sourceCode">1 + 2</code></p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(*Â (-Â 4Â 2)Â 5)</p></td><td><p><code data-lang="pyret" class="sourceCode">(4 - 2) * 5</code></p></td></tr></table><p>Note that Pyret does not have rules about orders of precedence between
operators, so when you mix operators, you have to parenthesize the
expression to make your intent clear. When you chain the same
operator you donâ€™t need to parenthesize; chaining associates to the
left in both languages:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(/Â 1Â 2Â 3Â 4)</p></td><td><p><code data-lang="pyret" class="sourceCode">1 / 2 / 3 / 4</code></p></td></tr></table><p>These both evaluate to 1/24.</p></section><section class="SsectionLevel3" id="section 28.3"><h3 class="heading">28.3Â <a name="(part._.Function_.Definition_and_.Application)"/>Function Definition and Application<a href="#(part._.Function_.Definition_and_.Application)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Function definition and application in Pyret have an infix syntax,
more reminiscent of many other textual programming
languages. Application uses a syntax familiar from conventional
algebra books:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(distÂ 3Â 4)</p></td><td><p><code data-lang="pyret" class="sourceCode">dist(3, 4)</code></p></td></tr></table><p>Application correspondingly uses a similar syntax in function headers,
and infix in the body:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>(defineÂ (distÂ xÂ y)</td></tr><tr><td>Â Â (sqrtÂ (+Â (*Â xÂ x)</td></tr><tr><td>Â Â Â Â Â Â Â Â Â Â Â (*Â yÂ y))))</td></tr></table></blockquote></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun dist(x, y):
  num-sqrt((x * x) +
           (y * y))
end</code></pre></td></tr></table></section><section class="SsectionLevel3" id="section 28.4"><h3 class="heading">28.4Â <a name="(part._.Tests)"/>Tests<a href="#(part._.Tests)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>There are essentially three different ways of writing the equivalent
of Racketâ€™s check-expect tests. They can be translated into
check blocks:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(check-expectÂ 1Â 1)</p></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  1 is 1
end</code></pre></td></tr></table><p>Note that multiple tests can be put into a single block:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>(check-expectÂ 1Â 1)</td></tr><tr><td>(check-expectÂ 2Â 2)</td></tr></table></blockquote></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  1 is 1
  2 is 2
end</code></pre></td></tr></table><p>The second way is this: as an alias for <code data-lang="pyret" class="sourceCode">check</code> we can also write
<code data-lang="pyret" class="sourceCode">examples</code>. The two are functionally identical, but they capture
the human difference between examples (which explore the
problem, and are written before attempting a solution) and
tests (which try to find bugs in the solution, and are written
to probe its design).</p><p>The third way is to write a <code data-lang="pyret" class="sourceCode">where</code> block to accompany a function
definition. For instance:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun double(n):
  n + n
where:
  double(0) is 0
  double(10) is 20
  double(-1) is -2
end</code></pre><p>These can even be written for internal functions (i.e., functions
contained inside other functions), which isnâ€™t true for
check-expect.</p><p>In Pyret, unlike in Racket, a testing block can contain a
documentation string. This is used by Pyret when reporting test
successes and failures. For instance, try to run and see what you get:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check "squaring always produces non-negatives":
  (0 * 0) is 0
  (-2 * -2) is 4
  (3 * 3) is 9
end</code></pre><p>This is useful for documenting the purpose of a testing block.</p><p>Just as in Racket, there are many testing operators in Pyret (in
addition to <code data-lang="pyret" class="sourceCode">is</code>). See
<a href="https://www.pyret.org/docs/latest/testing.html">the
documentation</a>.</p></section><section class="SsectionLevel3" id="section 28.5"><h3 class="heading">28.5Â <a name="(part._.Variable_.Names)"/>Variable Names<a href="#(part._.Variable_.Names)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Both languages have a fairly permissive system for naming
variables. While you can use CamelCase and under_scores in both, it is
conventional to instead use what is known as
<a href="http://c2.com/cgi/wiki?KebabCase">kebab-case</a>.This name is inaccurate. The word â€œkebabâ€
just means â€œmeatâ€. The skewer is the â€œshishâ€. Therefore, it ought
to at least be called â€œshish kebab caseâ€. Thus:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>this-is-a-name</p></td><td><p><code data-lang="pyret" class="sourceCode">this-is-a-name</code></p></td></tr></table><p>Even though Pyret has infix subtraction, the language can
unambiguously tell apart <code data-lang="pyret" class="sourceCode">this-name</code> (a variable) from
<code data-lang="pyret" class="sourceCode">this - name</code> (a subtraction expression) because the <code data-lang="pyret" class="sourceCode">-</code> in
the latter must be surrounded by spaces.</p><p>Despite this spacing convention, Pyret does not permit some of the
more exotic names permitted by Scheme. For instance, one can write
</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>(defineÂ e^i*piÂ -1)</td></tr></table></blockquote><p>in Scheme but that is not a valid variable name in Pyret.</p></section><section class="SsectionLevel3" id="section 28.6"><h3 class="heading">28.6Â <a name="(part._.Data_.Definitions)"/>Data Definitions<a href="#(part._.Data_.Definitions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Pyret diverges from Racket (and even more so from Scheme) in its
handling of data definitions. First, we will see how to define a
structure:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(define-structÂ ptÂ (xÂ y))</p></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Point:
  | pt(x, y)
end</code></pre></td></tr></table><p>This might seem like a fair bit of overkill, but weâ€™ll see in a moment
why itâ€™s useful. Meanwhile, itâ€™s worth observing that when you have
only a single kind of datum in a data definition, it feels unwieldy to
take up so many lines. Writing it on one line is valid, but now it
feels ugly to have the <code data-lang="pyret" class="sourceCode">|</code> in the middle:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Point: | pt(x, y) end</code></pre><p>Therefore, Pyret permits you to drop the initial <code data-lang="pyret" class="sourceCode">|</code>, resulting
in the more readable
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Point: pt(x, y) end</code></pre><p>Now suppose we have two kinds of points. In the student languages of
Racket, we would describe this with a comment:
</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>;;Â AÂ PointÂ isÂ either</td></tr><tr><td>;;Â -Â (ptÂ numberÂ number),Â or</td></tr><tr><td>;;Â -Â (pt3dÂ numberÂ numberÂ number)</td></tr></table></blockquote><p>In Pyret, we can express this directly:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Point:
  | pt(x, y)
  | pt3d(x, y, z)
end</code></pre><p>In short, Racket optimizes for the single-variant case, whereas Pyret
optimizes for the multi-variant case. As a result, it is difficult to
clearly express the multi-variant case in Racket, while it is unwieldy
to express the single-variant case in Pyret.</p><p>For structures, both Racket and Pyret expose constructors, selectors,
and predicates. Constructors are just functions:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(ptÂ 1Â 2)</p></td><td><p><code data-lang="pyret" class="sourceCode">pt(1, 2)</code></p></td></tr></table><p>Predicates are also functions with a particular naming scheme:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(pt?Â x)</p></td><td><p>is-pt(x)</p></td></tr></table><p>and they behave the same way (returning true if the argument
was constructed by that constructor, and false otherwise). In
contrast, selection is different in the two languages (and we will see
more about selection below, with <code data-lang="pyret" class="sourceCode">cases</code>):
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(pt-xÂ v)</p></td><td><p><code data-lang="pyret" class="sourceCode">v.x</code></p></td></tr></table><p>Note that in the Racket case, pt-x checks that the parameter
was constructed by pt before extracting the value of the
x field. Thus, pt-x and pt3d-x are two different
functions and neither one can be used in place of the other. In
contast, in Pyret, <code data-lang="pyret" class="sourceCode">.x</code> extracts an <code data-lang="pyret" class="sourceCode">x</code> field of any value
that has such a field, without attention to how it was
constructed. Thus, we can use <code data-lang="pyret" class="sourceCode">.x</code> on a value whether it was
constructed by <code data-lang="pyret" class="sourceCode">pt</code> or <code data-lang="pyret" class="sourceCode">pt3d</code> (or indeed anything else with
that field). In contrast, <code data-lang="pyret" class="sourceCode">cases</code> does pay attention to this
distinction.</p></section><section class="SsectionLevel3" id="section 28.7"><h3 class="heading">28.7Â <a name="(part._.Conditionals)"/>Conditionals<a href="#(part._.Conditionals)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>There are several kinds of conditionals in Pyret, one more than in the
Racket student languages.</p><p>General conditionals can be written using <code data-lang="pyret" class="sourceCode">if</code>, corresponding to
Racketâ€™s <code data-lang="pyret" class="sourceCode">if</code> but with more syntax.</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>(ifÂ full-moon</td></tr><tr><td>Â Â Â Â "howl"</td></tr><tr><td>Â Â Â Â "meow")</td></tr></table></blockquote></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if full-moon:
  "howl"
else:
  "meow"
end</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>(ifÂ full-moon</td></tr><tr><td>Â Â Â Â "howl"</td></tr><tr><td>Â Â Â Â (ifÂ new-moon</td></tr><tr><td>Â Â Â Â Â Â Â Â "bark"</td></tr><tr><td>Â Â Â Â Â Â Â Â "meow"))</td></tr></table></blockquote></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if full-moon:
  "howl"
else if new-moon:
  "bark"
else:
  "meow"
end</code></pre></td></tr></table><p>Note that <code data-lang="pyret" class="sourceCode">if</code> includes <code data-lang="pyret" class="sourceCode">else if</code>, which makes it possible
to list a collection of questions at the same level of indentation,
which if in Racket does not have. The corresponding code in
Racket would be written
</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>(cond</td></tr><tr><td>Â Â [full-moonÂ "howl"]</td></tr><tr><td>Â Â [new-moonÂ "bark"]</td></tr><tr><td>Â Â [elseÂ "meow"])</td></tr></table></blockquote><p>to restore the indentation. There is a similar construct in Pyret
called <code data-lang="pyret" class="sourceCode">ask</code>, designed to parallel <code data-lang="pyret" class="sourceCode">cond</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ask:
  | full-moon then: "howl"
  | new-moon then:  "bark"
  | otherwise:      "meow"
end</code></pre><p>In Racket, we also use <code data-lang="pyret" class="sourceCode">cond</code> to dispatch on a datatype:
</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>(cond</td></tr><tr><td>Â Â [(pt?Â v)Â Â Â (+Â (pt-xÂ v)Â (pt-yÂ v))]</td></tr><tr><td>Â Â [(pt3d?Â v)Â (+Â (pt-xÂ v)Â (pt-zÂ v))])</td></tr></table></blockquote><p>We could write this in close parallel in Pyret:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ask:
  | is-pt(v)   then: v.x + v.y
  | is-pt3d(v) then: v.x + v.z
end</code></pre><p>or even as:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if is-pt(v):
  v.x + v.y
else if is-pt3d(v):
  v.x + v.z
end</code></pre><p>(As in Racket student languages, the Pyret versions will signal an
error if no branch of the conditional matched.)</p><p>However, Pyret provides a special syntax just for data
definitions:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (Point) v:
  | pt(x, y)      =&gt; x + y
  | pt3d(x, y, z) =&gt; x + z
end</code></pre><p>This checks that <code data-lang="pyret" class="sourceCode">v</code> is a <code data-lang="pyret" class="sourceCode">Point</code>, provides a clean
syntactic way of identifying the different branches, and makes
it possible to give a concise local name to each field position
instead of having to use selectors like <code data-lang="pyret" class="sourceCode">.x</code>. In general, in
Pyret we prefer to use <code data-lang="pyret" class="sourceCode">cases</code> to process data
definitions. However, there are times when, for instance, there many
variants of data but a function processes only very few of them. In
such situations, it makes more sense to explicitly use predicates and
selectors.</p></section><section class="SsectionLevel3" id="section 28.8"><h3 class="heading">28.8Â <a name="(part._.Lists)"/>Lists<a href="#(part._.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>In Racket, depending on the language level, lists are created using
either cons or list, with empty for the empty
list. The corresponding notions in Pyret are called <code data-lang="pyret" class="sourceCode">link</code>,
<code data-lang="pyret" class="sourceCode">list</code>, and <code data-lang="pyret" class="sourceCode">empty</code>, respectively. <code data-lang="pyret" class="sourceCode">link</code> is a
two-argument function, just as in Racket:</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(consÂ 1Â empty)</p></td><td><p><code data-lang="pyret" class="sourceCode">link(1, empty)</code></p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(listÂ 1Â 2Â 3)</p></td><td><p><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code></p></td></tr></table><p>Note that the syntax <code data-lang="pyret" class="sourceCode">[1, 2, 3]</code>, which represents lists in many
languages, is not legal in Pyret: lists are not privileged with
their own syntax. Rather, we must use an explicit constructor:
just as <code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code> constructs a list, <code data-lang="pyret" class="sourceCode">[set: 1, 2,
3]</code> constructs a set instead of a list.In fact, we can
<a href="https://www.pyret.org/docs/latest/Expressions.html#%28part._s~3aconstruct-expr%29">create our own constructors</a>
and use them with this syntax.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Try typing <code data-lang="pyret" class="sourceCode">[1, 2, 3]</code> and see the error message.</p></blockquote></blockquote><p>This shows us how to construct lists. To take them apart, we use
<code data-lang="pyret" class="sourceCode">cases</code>. There are two variants, <code data-lang="pyret" class="sourceCode">empty</code> and <code data-lang="pyret" class="sourceCode">link</code>
(which we used to construct the lists):
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>(cond</td></tr><tr><td>Â Â [(empty?Â l)Â 0]</td></tr><tr><td>Â Â [(cons?Â l)</td></tr><tr><td>Â Â Â (+Â (firstÂ l)</td></tr><tr><td>Â Â Â Â Â Â (gÂ (restÂ l)))])</td></tr></table></blockquote></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (List) l:
  | empty      =&gt; 0
  | link(f, r) =&gt; f + g(r)
end</code></pre></td></tr></table><p>It is conventional to call the fields <code data-lang="pyret" class="sourceCode">f</code> and <code data-lang="pyret" class="sourceCode">r</code> (for
â€œfirstâ€ and â€œrestâ€). Of course, this convention does not work if
there are other things by the same name; in particular, when writing a
nested destructuring of a list, we conventionally write <code data-lang="pyret" class="sourceCode">fr</code> and
<code data-lang="pyret" class="sourceCode">rr</code> (for â€œfirst of the restâ€ and â€œrest of the restâ€).</p></section><section class="SsectionLevel3" id="section 28.9"><h3 class="heading">28.9Â <a name="(part._.First-.Class_.Functions)"/>First-Class Functions<a href="#(part._.First-.Class_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>The equivalent of Racketâ€™s lambda is Pyretâ€™s <code data-lang="pyret" class="sourceCode">lam</code>:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(lambdaÂ (xÂ y)Â (+Â xÂ y))</p></td><td><p><code data-lang="pyret" class="sourceCode">lam(x, y): x + y end</code></p></td></tr></table></section><section class="SsectionLevel3" id="section 28.10"><h3 class="heading">28.10Â <a name="(part._.Annotations)"/>Annotations<a href="#(part._.Annotations)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>In student Racket languages, annotations are usually written as comments:
</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>;Â square:Â NumberÂ -&gt;Â Number</td></tr><tr><td>;Â sort-nums:Â List&lt;Number&gt;Â -&gt;Â List&lt;Number&gt;</td></tr><tr><td>;Â sort:Â List&lt;T&gt;Â *Â (TÂ *Â TÂ -&gt;Â Boolean)Â -&gt;Â List&lt;T&gt;</td></tr></table></blockquote><p>In Pyret, we write the annotations directly on the parameters and
return values. Pyret will check them to a limited extent dynamically,
and can check them statically with its type checker. The corresponding
annotations to those above would be written as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun square(n :: Number) -&gt; Number: ...

fun sort-nums(l :: List&lt;Number&gt;) -&gt; List&lt;Number&gt;: ...

fun sort&lt;T&gt;(l :: List&lt;T&gt;, cmp :: (T, T -&gt; Boolean)) -&gt; List&lt;T&gt;: ...</code></pre></section><section class="SsectionLevel3" id="section 28.11"><h3 class="heading">28.11Â <a name="(part._.What_.Else_)"/>What Else?<a href="#(part._.What_.Else_)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>If there are other parts of Scheme or Racket syntax that you would
like to see translated, please
<a href="http://cs.brown.edu/~sk/Contact/">let us know</a>.</p></section>&#13;
<h3 class="heading">28.1Â <a name="(part._.Numbers__.Strings__and_.Booleans)"/>Numbers, Strings, and Booleans<a href="#(part._.Numbers__.Strings__and_.Booleans)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Numbers are very similar between the two. Like Scheme, Pyret
implements arbitrary-precision numbers and rationals. Some of the more
exotic numeric systems of Scheme (such as complex numbers) arenâ€™t in
Pyret; Pyret also treats imprecise numbers slightly differently.</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>1</p></td><td><p><code data-lang="pyret" class="sourceCode">1</code></p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>1/2</p></td><td><p><code data-lang="pyret" class="sourceCode">1/2</code></p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>#i3.14</p></td><td><p><code data-lang="pyret" class="sourceCode">~3.14</code></p></td></tr></table><p>Strings are also very similar, though Pyret allows you to use
single-quotes as well.</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>"Hello,Â world!"</p></td><td><p><code data-lang="pyret" class="sourceCode">"Hello, world!"</code></p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>"\"Hello\",Â heÂ said"</p></td><td><p><code data-lang="pyret" class="sourceCode">"\"Hello\", he said"</code></p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>"\"Hello\",Â heÂ said"</p></td><td><p><code data-lang="pyret" class="sourceCode">'"Hello", he said'</code></p></td></tr></table><p>Booleans have the same names:</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>true</p></td><td><p><code data-lang="pyret" class="sourceCode">true</code></p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>false</p></td><td><p><code data-lang="pyret" class="sourceCode">false</code></p></td></tr></table>&#13;
<h3 class="heading">28.2Â <a name="(part._.Infix_.Expressions)"/>Infix Expressions<a href="#(part._.Infix_.Expressions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Pyret uses an infix syntax, reminiscent of many other textual
programming languages:</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(+Â 1Â 2)</p></td><td><p><code data-lang="pyret" class="sourceCode">1 + 2</code></p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(*Â (-Â 4Â 2)Â 5)</p></td><td><p><code data-lang="pyret" class="sourceCode">(4 - 2) * 5</code></p></td></tr></table><p>Note that Pyret does not have rules about orders of precedence between
operators, so when you mix operators, you have to parenthesize the
expression to make your intent clear. When you chain the same
operator you donâ€™t need to parenthesize; chaining associates to the
left in both languages:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(/Â 1Â 2Â 3Â 4)</p></td><td><p><code data-lang="pyret" class="sourceCode">1 / 2 / 3 / 4</code></p></td></tr></table><p>These both evaluate to 1/24.</p>&#13;
<h3 class="heading">28.3Â <a name="(part._.Function_.Definition_and_.Application)"/>Function Definition and Application<a href="#(part._.Function_.Definition_and_.Application)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Function definition and application in Pyret have an infix syntax,
more reminiscent of many other textual programming
languages. Application uses a syntax familiar from conventional
algebra books:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(distÂ 3Â 4)</p></td><td><p><code data-lang="pyret" class="sourceCode">dist(3, 4)</code></p></td></tr></table><p>Application correspondingly uses a similar syntax in function headers,
and infix in the body:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>(defineÂ (distÂ xÂ y)</td></tr><tr><td>Â Â (sqrtÂ (+Â (*Â xÂ x)</td></tr><tr><td>Â Â Â Â Â Â Â Â Â Â Â (*Â yÂ y))))</td></tr></table></blockquote></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun dist(x, y):
  num-sqrt((x * x) +
           (y * y))
end</code></pre></td></tr></table>&#13;
<h3 class="heading">28.4Â <a name="(part._.Tests)"/>Tests<a href="#(part._.Tests)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>There are essentially three different ways of writing the equivalent
of Racketâ€™s check-expect tests. They can be translated into
check blocks:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(check-expectÂ 1Â 1)</p></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  1 is 1
end</code></pre></td></tr></table><p>Note that multiple tests can be put into a single block:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>(check-expectÂ 1Â 1)</td></tr><tr><td>(check-expectÂ 2Â 2)</td></tr></table></blockquote></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  1 is 1
  2 is 2
end</code></pre></td></tr></table><p>The second way is this: as an alias for <code data-lang="pyret" class="sourceCode">check</code> we can also write
<code data-lang="pyret" class="sourceCode">examples</code>. The two are functionally identical, but they capture
the human difference between examples (which explore the
problem, and are written before attempting a solution) and
tests (which try to find bugs in the solution, and are written
to probe its design).</p><p>The third way is to write a <code data-lang="pyret" class="sourceCode">where</code> block to accompany a function
definition. For instance:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun double(n):
  n + n
where:
  double(0) is 0
  double(10) is 20
  double(-1) is -2
end</code></pre><p>These can even be written for internal functions (i.e., functions
contained inside other functions), which isnâ€™t true for
check-expect.</p><p>In Pyret, unlike in Racket, a testing block can contain a
documentation string. This is used by Pyret when reporting test
successes and failures. For instance, try to run and see what you get:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check "squaring always produces non-negatives":
  (0 * 0) is 0
  (-2 * -2) is 4
  (3 * 3) is 9
end</code></pre><p>This is useful for documenting the purpose of a testing block.</p><p>Just as in Racket, there are many testing operators in Pyret (in
addition to <code data-lang="pyret" class="sourceCode">is</code>). See
<a href="https://www.pyret.org/docs/latest/testing.html">the
documentation</a>.</p>&#13;
<h3 class="heading">28.5Â <a name="(part._.Variable_.Names)"/>Variable Names<a href="#(part._.Variable_.Names)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Both languages have a fairly permissive system for naming
variables. While you can use CamelCase and under_scores in both, it is
conventional to instead use what is known as
<a href="http://c2.com/cgi/wiki?KebabCase">kebab-case</a>.This name is inaccurate. The word â€œkebabâ€
just means â€œmeatâ€. The skewer is the â€œshishâ€. Therefore, it ought
to at least be called â€œshish kebab caseâ€. Thus:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>this-is-a-name</p></td><td><p><code data-lang="pyret" class="sourceCode">this-is-a-name</code></p></td></tr></table><p>Even though Pyret has infix subtraction, the language can
unambiguously tell apart <code data-lang="pyret" class="sourceCode">this-name</code> (a variable) from
<code data-lang="pyret" class="sourceCode">this - name</code> (a subtraction expression) because the <code data-lang="pyret" class="sourceCode">-</code> in
the latter must be surrounded by spaces.</p><p>Despite this spacing convention, Pyret does not permit some of the
more exotic names permitted by Scheme. For instance, one can write
</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>(defineÂ e^i*piÂ -1)</td></tr></table></blockquote><p>in Scheme but that is not a valid variable name in Pyret.</p>&#13;
<h3 class="heading">28.6Â <a name="(part._.Data_.Definitions)"/>Data Definitions<a href="#(part._.Data_.Definitions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Pyret diverges from Racket (and even more so from Scheme) in its
handling of data definitions. First, we will see how to define a
structure:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(define-structÂ ptÂ (xÂ y))</p></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Point:
  | pt(x, y)
end</code></pre></td></tr></table><p>This might seem like a fair bit of overkill, but weâ€™ll see in a moment
why itâ€™s useful. Meanwhile, itâ€™s worth observing that when you have
only a single kind of datum in a data definition, it feels unwieldy to
take up so many lines. Writing it on one line is valid, but now it
feels ugly to have the <code data-lang="pyret" class="sourceCode">|</code> in the middle:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Point: | pt(x, y) end</code></pre><p>Therefore, Pyret permits you to drop the initial <code data-lang="pyret" class="sourceCode">|</code>, resulting
in the more readable
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Point: pt(x, y) end</code></pre><p>Now suppose we have two kinds of points. In the student languages of
Racket, we would describe this with a comment:
</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>;;Â AÂ PointÂ isÂ either</td></tr><tr><td>;;Â -Â (ptÂ numberÂ number),Â or</td></tr><tr><td>;;Â -Â (pt3dÂ numberÂ numberÂ number)</td></tr></table></blockquote><p>In Pyret, we can express this directly:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Point:
  | pt(x, y)
  | pt3d(x, y, z)
end</code></pre><p>In short, Racket optimizes for the single-variant case, whereas Pyret
optimizes for the multi-variant case. As a result, it is difficult to
clearly express the multi-variant case in Racket, while it is unwieldy
to express the single-variant case in Pyret.</p><p>For structures, both Racket and Pyret expose constructors, selectors,
and predicates. Constructors are just functions:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(ptÂ 1Â 2)</p></td><td><p><code data-lang="pyret" class="sourceCode">pt(1, 2)</code></p></td></tr></table><p>Predicates are also functions with a particular naming scheme:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(pt?Â x)</p></td><td><p>is-pt(x)</p></td></tr></table><p>and they behave the same way (returning true if the argument
was constructed by that constructor, and false otherwise). In
contrast, selection is different in the two languages (and we will see
more about selection below, with <code data-lang="pyret" class="sourceCode">cases</code>):
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(pt-xÂ v)</p></td><td><p><code data-lang="pyret" class="sourceCode">v.x</code></p></td></tr></table><p>Note that in the Racket case, pt-x checks that the parameter
was constructed by pt before extracting the value of the
x field. Thus, pt-x and pt3d-x are two different
functions and neither one can be used in place of the other. In
contast, in Pyret, <code data-lang="pyret" class="sourceCode">.x</code> extracts an <code data-lang="pyret" class="sourceCode">x</code> field of any value
that has such a field, without attention to how it was
constructed. Thus, we can use <code data-lang="pyret" class="sourceCode">.x</code> on a value whether it was
constructed by <code data-lang="pyret" class="sourceCode">pt</code> or <code data-lang="pyret" class="sourceCode">pt3d</code> (or indeed anything else with
that field). In contrast, <code data-lang="pyret" class="sourceCode">cases</code> does pay attention to this
distinction.</p>&#13;
<h3 class="heading">28.7Â <a name="(part._.Conditionals)"/>Conditionals<a href="#(part._.Conditionals)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>There are several kinds of conditionals in Pyret, one more than in the
Racket student languages.</p><p>General conditionals can be written using <code data-lang="pyret" class="sourceCode">if</code>, corresponding to
Racketâ€™s <code data-lang="pyret" class="sourceCode">if</code> but with more syntax.</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>(ifÂ full-moon</td></tr><tr><td>Â Â Â Â "howl"</td></tr><tr><td>Â Â Â Â "meow")</td></tr></table></blockquote></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if full-moon:
  "howl"
else:
  "meow"
end</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>(ifÂ full-moon</td></tr><tr><td>Â Â Â Â "howl"</td></tr><tr><td>Â Â Â Â (ifÂ new-moon</td></tr><tr><td>Â Â Â Â Â Â Â Â "bark"</td></tr><tr><td>Â Â Â Â Â Â Â Â "meow"))</td></tr></table></blockquote></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if full-moon:
  "howl"
else if new-moon:
  "bark"
else:
  "meow"
end</code></pre></td></tr></table><p>Note that <code data-lang="pyret" class="sourceCode">if</code> includes <code data-lang="pyret" class="sourceCode">else if</code>, which makes it possible
to list a collection of questions at the same level of indentation,
which if in Racket does not have. The corresponding code in
Racket would be written
</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>(cond</td></tr><tr><td>Â Â [full-moonÂ "howl"]</td></tr><tr><td>Â Â [new-moonÂ "bark"]</td></tr><tr><td>Â Â [elseÂ "meow"])</td></tr></table></blockquote><p>to restore the indentation. There is a similar construct in Pyret
called <code data-lang="pyret" class="sourceCode">ask</code>, designed to parallel <code data-lang="pyret" class="sourceCode">cond</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ask:
  | full-moon then: "howl"
  | new-moon then:  "bark"
  | otherwise:      "meow"
end</code></pre><p>In Racket, we also use <code data-lang="pyret" class="sourceCode">cond</code> to dispatch on a datatype:
</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>(cond</td></tr><tr><td>Â Â [(pt?Â v)Â Â Â (+Â (pt-xÂ v)Â (pt-yÂ v))]</td></tr><tr><td>Â Â [(pt3d?Â v)Â (+Â (pt-xÂ v)Â (pt-zÂ v))])</td></tr></table></blockquote><p>We could write this in close parallel in Pyret:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ask:
  | is-pt(v)   then: v.x + v.y
  | is-pt3d(v) then: v.x + v.z
end</code></pre><p>or even as:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if is-pt(v):
  v.x + v.y
else if is-pt3d(v):
  v.x + v.z
end</code></pre><p>(As in Racket student languages, the Pyret versions will signal an
error if no branch of the conditional matched.)</p><p>However, Pyret provides a special syntax just for data
definitions:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (Point) v:
  | pt(x, y)      =&gt; x + y
  | pt3d(x, y, z) =&gt; x + z
end</code></pre><p>This checks that <code data-lang="pyret" class="sourceCode">v</code> is a <code data-lang="pyret" class="sourceCode">Point</code>, provides a clean
syntactic way of identifying the different branches, and makes
it possible to give a concise local name to each field position
instead of having to use selectors like <code data-lang="pyret" class="sourceCode">.x</code>. In general, in
Pyret we prefer to use <code data-lang="pyret" class="sourceCode">cases</code> to process data
definitions. However, there are times when, for instance, there many
variants of data but a function processes only very few of them. In
such situations, it makes more sense to explicitly use predicates and
selectors.</p>&#13;
<h3 class="heading">28.8Â <a name="(part._.Lists)"/>Lists<a href="#(part._.Lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>In Racket, depending on the language level, lists are created using
either cons or list, with empty for the empty
list. The corresponding notions in Pyret are called <code data-lang="pyret" class="sourceCode">link</code>,
<code data-lang="pyret" class="sourceCode">list</code>, and <code data-lang="pyret" class="sourceCode">empty</code>, respectively. <code data-lang="pyret" class="sourceCode">link</code> is a
two-argument function, just as in Racket:</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(consÂ 1Â empty)</p></td><td><p><code data-lang="pyret" class="sourceCode">link(1, empty)</code></p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(listÂ 1Â 2Â 3)</p></td><td><p><code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code></p></td></tr></table><p>Note that the syntax <code data-lang="pyret" class="sourceCode">[1, 2, 3]</code>, which represents lists in many
languages, is not legal in Pyret: lists are not privileged with
their own syntax. Rather, we must use an explicit constructor:
just as <code data-lang="pyret" class="sourceCode">[list: 1, 2, 3]</code> constructs a list, <code data-lang="pyret" class="sourceCode">[set: 1, 2,
3]</code> constructs a set instead of a list.In fact, we can
<a href="https://www.pyret.org/docs/latest/Expressions.html#%28part._s~3aconstruct-expr%29">create our own constructors</a>
and use them with this syntax.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Try typing <code data-lang="pyret" class="sourceCode">[1, 2, 3]</code> and see the error message.</p></blockquote></blockquote><p>This shows us how to construct lists. To take them apart, we use
<code data-lang="pyret" class="sourceCode">cases</code>. There are two variants, <code data-lang="pyret" class="sourceCode">empty</code> and <code data-lang="pyret" class="sourceCode">link</code>
(which we used to construct the lists):
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>(cond</td></tr><tr><td>Â Â [(empty?Â l)Â 0]</td></tr><tr><td>Â Â [(cons?Â l)</td></tr><tr><td>Â Â Â (+Â (firstÂ l)</td></tr><tr><td>Â Â Â Â Â Â (gÂ (restÂ l)))])</td></tr></table></blockquote></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cases (List) l:
  | empty      =&gt; 0
  | link(f, r) =&gt; f + g(r)
end</code></pre></td></tr></table><p>It is conventional to call the fields <code data-lang="pyret" class="sourceCode">f</code> and <code data-lang="pyret" class="sourceCode">r</code> (for
â€œfirstâ€ and â€œrestâ€). Of course, this convention does not work if
there are other things by the same name; in particular, when writing a
nested destructuring of a list, we conventionally write <code data-lang="pyret" class="sourceCode">fr</code> and
<code data-lang="pyret" class="sourceCode">rr</code> (for â€œfirst of the restâ€ and â€œrest of the restâ€).</p>&#13;
<h3 class="heading">28.9Â <a name="(part._.First-.Class_.Functions)"/>First-Class Functions<a href="#(part._.First-.Class_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>The equivalent of Racketâ€™s lambda is Pyretâ€™s <code data-lang="pyret" class="sourceCode">lam</code>:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>RSW</p></td><td><p>Pyret</p></td></tr><tr><td><p>(lambdaÂ (xÂ y)Â (+Â xÂ y))</p></td><td><p><code data-lang="pyret" class="sourceCode">lam(x, y): x + y end</code></p></td></tr></table>&#13;
<h3 class="heading">28.10Â <a name="(part._.Annotations)"/>Annotations<a href="#(part._.Annotations)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>In student Racket languages, annotations are usually written as comments:
</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td>;Â square:Â NumberÂ -&gt;Â Number</td></tr><tr><td>;Â sort-nums:Â List&lt;Number&gt;Â -&gt;Â List&lt;Number&gt;</td></tr><tr><td>;Â sort:Â List&lt;T&gt;Â *Â (TÂ *Â TÂ -&gt;Â Boolean)Â -&gt;Â List&lt;T&gt;</td></tr></table></blockquote><p>In Pyret, we write the annotations directly on the parameters and
return values. Pyret will check them to a limited extent dynamically,
and can check them statically with its type checker. The corresponding
annotations to those above would be written as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun square(n :: Number) -&gt; Number: ...

fun sort-nums(l :: List&lt;Number&gt;) -&gt; List&lt;Number&gt;: ...

fun sort&lt;T&gt;(l :: List&lt;T&gt;, cmp :: (T, T -&gt; Boolean)) -&gt; List&lt;T&gt;: ...</code></pre>&#13;
<h3 class="heading">28.11Â <a name="(part._.What_.Else_)"/>What Else?<a href="#(part._.What_.Else_)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>If there are other parts of Scheme or Racket syntax that you would
like to see translated, please
<a href="http://cs.brown.edu/~sk/Contact/">let us know</a>.</p>    
</body>
</html>