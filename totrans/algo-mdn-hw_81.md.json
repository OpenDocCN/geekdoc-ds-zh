["```cpp\nvoid add(int k, int x); // react to a[k] += x (zero-based indexing) int sum(int k);         // return the sum of the first k elements (from 0 to k - 1) \n```", "```cpp\nstruct segtree {  int lb, rb;                         // the range this node is responsible for int s = 0;                          // the sum of elements [lb, rb) segtree *l = nullptr, *r = nullptr; // pointers to its children  segtree(int lb, int rb) : lb(lb), rb(rb) { if (lb + 1 < rb) { // if the node is not a leaf, create children int m = (lb + rb) / 2; l = new segtree(lb, m); r = new segtree(m, rb); } }   void add(int k, int x) { /* react to a[k] += x */ } int sum(int k) { /* compute the sum of the first k elements */ } }; \n```", "```cpp\nif (lb + 1 == rb) {  s = a[lb]; // the node is a leaf -- its sum is just the element a[lb] } else {  int t = (lb + rb) / 2; l = new segtree(lb, t); r = new segtree(t, rb); s = l->s + r->s; // we can use the sums of children that we've just calculated } \n```", "```cpp\nvoid add(int k, int x) {  s += x; if (l != nullptr) { // check whether it is a leaf node if (k < l->rb) l->add(k, x); else r->add(k, x); } } \n```", "```cpp\nint sum(int lq, int rq) {  if (rb <= lq && rb <= rq) // if we're fully inside the query, return the sum return s; if (rq <= lb || lq >= rb) // if we don't intersect with the query, return zero return 0; return l->sum(lq, rq) + r->sum(lq, rq); } \n```", "```cpp\nint sum(int k) {  if (rb <= k) return s; if (lb >= k) return 0; return l->sum(k) + r->sum(k); } \n```", "```cpp\nint t[4 * N]; // contains the node sums \n```", "```cpp\nvoid add(int k, int x, int v = 1, int l = 0, int r = N) {  t[v] += x; if (l + 1 < r) { int m = (l + r) / 2; if (k < m) add(k, x, 2 * v, l, m); else add(k, x, 2 * v + 1, m, r); } } \n```", "```cpp\nint sum(int k, int v = 1, int l = 0, int r = N) {  if (l >= k) return 0; if (r <= k) return t[v]; int m = (l + r) / 2; return sum(k, 2 * v, l, m) + sum(k, 2 * v + 1, m, r); } \n```", "```cpp\nvoid add(int k, int x) {  int v = 1, l = 0, r = N; while (l + 1 < r) { t[v] += x; v <<= 1; int m = (l + r) >> 1; if (k < m) r = m; else l = m, v++; } t[v] += x; } \n```", "```cpp\nint sum(int k) {  int v = 1, l = 0, r = N, s = 0; while (true) { int m = (l + r) >> 1; v <<= 1; if (k >= m) { s += t[v++]; if (k == m) break; l = m; } else { r = m; } } return s; } \n```", "```cpp\nint t[2 * N]; \n```", "```cpp\nvoid add(int k, int x) {  k += N; while (k != 0) { t[k] += x; k >>= 1; } } \n```", "```cpp\nint sum(int l, int r) {  l += N; r += N - 1; int s = 0; while (l <= r) { if ( l & 1) s += t[l++]; // l is a right child: add it and move to a cousin if (~r & 1) s += t[r--]; // r is a left child: add it and move to a cousin l >>= 1, r >>= 1; } return s; } \n```", "```cpp\nint sum(int k) {  int s = 0; k += N - 1; while (k != 0) { if (~k & 1) // if k is a right child s += t[k--]; k = k >> 1; } return s; } \n```", "```cpp\nconst int last_layer = 1 << __lg(2 * N - 1);   // calculate the index of the leaf k int leaf(int k) {  k += last_layer; k -= (k >= 2 * N) * N; return k; } \n```", "```cpp\nvoid add(int k, int x) {  k = leaf(k); while (k != 0) { t[k] += x; k >>= 1; } }   int sum(int k) {  k = leaf(k - 1); int s = 0; while (k != 0) { if (~k & 1) s += t[k--]; k >>= 1; } return s; } \n```", "```cpp\nint sum(int k) {  k = leaf(k - 1); int s = 0; while (k != 0) { s += (~k & 1) ? t[k] : 0; // will be replaced with a cmov k = (k - 1) >> 1; } return s; } \n```", "```cpp\nint t[N + 1]; // +1 because we use use one-based indexing \n```", "```cpp\nint lowbit(int x) {  return x & -x; } \n```", "```cpp\n+90 = 64 + 16 + 8 + 2 = (0)10110\n-90 = 00000 - 10110   = (1)01010\n    â†’ (+90) & (-90)   = (0)00010 \n```", "```cpp\nint sum(int k) {  int s = 0; for (; k != 0; k -= lowbit(k)) s += t[k]; return s; } \n```", "```cpp\nint sum(int k) {  int s = 0; for (; k != 0; k &= k - 1) s += t[k]; return s; } \n```", "```cpp\n// [l, r) int sum (int l, int r) {  return sum(r) - sum(l); } \n```", "```cpp\nvoid add(int k, int x) {  for (k += 1; k <= N; k += k & -k) t[k] += x; } \n```", "```cpp\ninline constexpr int hole(int k) {  return k + (k >> 10); }   int t[hole(N) + 1];   void add(int k, int x) {  for (k += 1; k <= N; k += k & -k) t[hole(k)] += x; }   int sum(int k) {  int res = 0; for (; k != 0; k &= k - 1) res += t[hole(k)]; return res; } \n```", "```cpp\nconst int b = 4, B = (1 << b); // cache line size (in integers, not bytes)  // the height of the tree over an n-element array constexpr int height(int n) {  return (n <= B ? 1 : height(n / B) + 1); }   // where the h-th layer starts constexpr int offset(int h) {  int s = 0, n = N; while (h--) { n = (n + B - 1) / B; s += n * B; } return s; }   constexpr int H = height(N); alignas(64) int t[offset(H)]; // an array for storing nodes \n```", "```cpp\nint sum(int k) {  int s = 0; for (int h = 0; h < H; h++) s += t[offset(h) + (k >> (h * b))]; return s; } \n```", "```cpp\nstruct Precalc {  alignas(64) int mask[B][B];   constexpr Precalc() : mask{} { for (int k = 0; k < B; k++) for (int i = 0; i < B; i++) mask[k][i] = (i > k ? -1 : 0); } };   constexpr Precalc T; \n```", "```cpp\ntypedef int vec __attribute__ (( vector_size(32) ));   constexpr int round(int k) {  return k & ~(B - 1); // = k / B * B }   void add(int k, int x) {  vec v = x + vec{}; for (int h = 0; h < H; h++) { auto a = (vec*) &t[offset(h) + round(k)]; auto m = (vec*) T.mask[k % B]; for (int i = 0; i < B / 8; i++) a[i] += v & m[i]; k >>= b; } } \n```"]