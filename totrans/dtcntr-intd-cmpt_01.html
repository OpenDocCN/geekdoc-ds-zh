<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>IÂ IntroductionğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>IÂ IntroductionğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/booklet_intro.html">https://dcic-world.org/2025-08-27/booklet_intro.html</a></blockquote><section class="SsectionLevel2" id="section 1"><h2 class="heading">1Â <a name="(part._.Overview)"/>Overview<a href="#(part._.Overview)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h2><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._.What_.This_.Book_is_.About%29" class="toclink" data-pltdoc="x">1.1Â What This Book is About</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.The_.Values_.That_.Drive_.This_.Book%29" class="toclink" data-pltdoc="x">1.2Â The Values That Drive This Book</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Our_.Perspective_on_.Data%29" class="toclink" data-pltdoc="x">1.3Â Our Perspective on Data</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.What_.Makes_.This_.Book_.Unique%29" class="toclink" data-pltdoc="x">1.4Â What Makes This Book Unique</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Who_.This_.Book_is_.For%29" class="toclink" data-pltdoc="x">1.5Â Who This Book is For</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._book-style%29" class="toclink" data-pltdoc="x">1.6Â The Structure of This Book</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._book-org%29" class="toclink" data-pltdoc="x">1.7Â Organization of the Material</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Our_.Programming_.Language_.Choice%29" class="toclink" data-pltdoc="x">1.8Â Our Programming Language Choice</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Programming_.Tools%29" class="toclink" data-pltdoc="x">1.9Â Programming Tools</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Sending_.Us_.Feedback__.Errors__and_.Comments%29" class="toclink" data-pltdoc="x">1.10Â Sending Us Feedback, Errors, and Comments</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Staying_.Up-.To-.Date%29" class="toclink" data-pltdoc="x">1.11Â Staying Up-To-Date</a></p></td></tr></table><section class="SsectionLevel3" id="section 1.1"><h3 class="heading">1.1Â <a name="(part._.What_.This_.Book_is_.About)"/>What This Book is About<a href="#(part._.What_.This_.Book_is_.About)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>This book is an introduction to computer science. It will teach you to program,
and do so in ways that are of practical value and importance. However, it will
also go beyond programming to computer science, a rich, deep, fascinating, and
beautiful intellectual discipline. You will learn many useful things that you
can apply right away, but we will also show you some of what lies beneath and
beyond.</p><p>Most of all, we want to give you ways of thinking about solving problems
using computation.  Some of these ways are technical methods, such as working
from data and examples to construct solutions to problems. Others are
scientific methods, such as ways of making sure that programs are reliable and
do what they claim. Finally, some are social, thinking about the impacts that
programs have on people.</p></section><section class="SsectionLevel3" id="section 1.2"><h3 class="heading">1.2Â <a name="(part._.The_.Values_.That_.Drive_.This_.Book)"/>The Values That Drive This Book<a href="#(part._.The_.Values_.That_.Drive_.This_.Book)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Our perspective is guided by our decades of experience as software developers,
researchers, and educators. This has instilled in us the following beliefs:
</p><ul><li><p>Software is not written only to be run. It must also be written to be
read and maintained by others. Often, that â€œotherâ€ person is you, six months
later, who has forgotten what they did and why.</p></li><li><p>Programmers are responsible for their software
meeting its desired goals and being reliable. This is
reflected in a variety of disciplines inside computer science, such as testing
and verification.</p></li><li><p>Programs ought to be be amenable to prediction. We need to know, as much
as possible, before a program runs, how it will behave. This behavior includes
not only technical characteristics such as running time, space, power, and so
on, but also social impacts, benefits, and harms. Programmers have been
notoriously poor at thinking about the latter.</p></li></ul></section><section class="SsectionLevel3" id="section 1.3"><h3 class="heading">1.3Â <a name="(part._.Our_.Perspective_on_.Data)"/>Our Perspective on Data<a href="#(part._.Our_.Perspective_on_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>These concerns intersect with our belief about how computer science has evolved
as a discipline. It is a truism that we live in a world awash with data, but
what consequence does that have?</p><p>At a computational level, data have had a profound effect. Traditionally, the
only way to make a program better was to improve the program directly,
which often meant making it more complicated and impacting the values we
discuss above. But there are classes of programs for which there is another method: simply give the
same program more or better data, and the program can improve. These
data-driven programs lie at the heart of many innovations we see around
us.</p><p>In addition to this technical effect, data can have a profound pedagogic
impact, too. Most introductory programming is plagued by artificial data
that have no real meaning, interest, or consequence (and often, artificial
problems to accompany them). With real data, learners can personalize their
education, focusing on problems they find meaningful, enriching, or just plain
funâ€”<wbr/>asking and answering questions they find worthwhile. Indeed, from this
perspective, programs interrogate data: that is, programs are tools
for answering questions. In turn, the emphasis on real data and real questions
enables us to discuss the social impacts of computing.</p><p>These phenomena have given rise to whole new areas of study, typically
called data science.  However, typical data science curricula also have many
limitations. They pay little attention to what we know about the difficulties
of learning to program. They have little emphasis on software reliability. And
they fail to recognize that their data are often quite limited in their
structure. These limitations, where data science typically ends, are where
computer science begins. In particular, the structure of data serve as a point
of departure for thinking about and achieving some of the values aboveâ€”<wbr/>performance, reliability, and predictabilityâ€”<wbr/>using the many tools of computer
science.</p></section><section class="SsectionLevel3" id="section 1.4"><h3 class="heading">1.4Â <a name="(part._.What_.Makes_.This_.Book_.Unique)"/>What Makes This Book Unique<a href="#(part._.What_.Makes_.This_.Book_.Unique)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>First, we propose a new perspective on structuring computing curricula,
which we call data centricity.For more about this, read
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/kf-data-centric/">our essay</a>.
We view a data-centric curriculum as
</p><blockquote><p>data centric = data science + data structures</p></blockquote><p>in that order: we begin with ideas from data science, before shifting to
classical ideas from data structures and the rest of computer science. This
book lays out this vision concretely and in detail.</p><p>Second, computing education talks a great deal about
notional machinesâ€”<wbr/>abstractions of program behavior meant to help
students understand how programs workâ€”<wbr/>but few curricula actually use one. We
take notional machines seriously, developing a sequence of them and weaving
them through the curriculum. This ties to our belief that programs are not only
objects that run, but also objects that we reason about.</p><p>Third, we weave content on socially-responsible computing into the
text. Unlike other efforts that focus on exposing students to ethics
or the pitfalls of technology in general, we aim to show students how
the constructs and concepts that they are turning into code
right now can lead to adverse impacts unless used with
care. In keeping with our focus on testing and concrete examples, we
introduce several topics by getting students to think about
assumptions at the level of concrete data. This material is called out
explicitly throughout the book.</p><p>Finally, this book is deeply informed by recent and ongoing research
results. Our choices of material, order of presentation, programming methods,
and more are driven by what we know from the research literature. In many
cases, we ourselves are the ones doing the research, so the curriculum and
research live in a symbiotic relationship. You can find our papers
(some with each other, others not)
<a href="https://cs.brown.edu/~kfisler/Pubs/index.html">on</a>
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/">our</a>
<a href="https://www.ccs.neu.edu/home/blerner/papers.html">respective</a>
<a href="https://jpolitz.github.io">pages</a>.</p></section><section class="SsectionLevel3" id="section 1.5"><h3 class="heading">1.5Â <a name="(part._.Who_.This_.Book_is_.For)"/>Who This Book is For<a href="#(part._.Who_.This_.Book_is_.For)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>This book is written primarily for students who are in the early stages of
computing education at the tertiary level (college or university). However,
manyâ€”<wbr/>especially the earlierâ€”<wbr/>parts of it are also suitable for secondary
education (in the USA, for instance, roughly grades 6â€“12, or ages
12â€“18). Indeed, we see a natural continuum between secondary and tertiary
education, and think this book can serve as a useful bridge between the two.</p></section><section class="SsectionLevel3" id="section 1.6"><h3 class="heading">1.6Â <a name="(part._book-style)"/>The Structure of This Book<a href="#(part._book-style)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Unlike some other textbooks, this one does not follow a top-down
narrative.  Rather it has the flow of a conversation, with
backtracking.  We will often build up programs incrementally, just as
a pair of programmers would.  We will include mistakes, not because we
donâ€™t know better, but because this is the best way for you
to learn.  Including mistakes makes it impossible for you to read
passively: you must instead engage with the material, because you can
never be sure of the veracity of what youâ€™re reading.</p><p>At the end, youâ€™ll always get to the right answer.  However, this
non-linear path is more frustrating in the short term (you will often
be tempted to say, â€œJust tell me the answer, already!â€), and it
makes the book a poor reference guide (you canâ€™t open up to a random
page and be sure what it says is correct).  However, that feeling of
frustration is the sensation of learning.  We donâ€™t know of a way
around it.</p><p>We use visual formatting to highlight some of these points. Thus,
in several places you will encounter this:</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>This is an exercise.  Do try it.</p></blockquote></blockquote><p>This is a traditional textbook exercise.  Itâ€™s something you need to
do on your own.  If youâ€™re using this book as part of a course, this
may very well have been assigned as homework.  In contrast, you will
also find exercise-like questions that look like this:</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Thereâ€™s an activity here!  Do you see it?</p></blockquote></blockquote><p>When you get to one of these, stop.  Read, think, and formulate
an answer before you proceed.  You must do this because this is
actually an exercise, but the answer is already in the
bookâ€”<wbr/>most often in the text immediately following (i.e., in the part
youâ€™re reading right now)â€”<wbr/>or is something you can determine for
yourself by running a program.  If you just read on, youâ€™ll see the
answer without having thought about it (or not see it at all, if the
instructions are to run a program), so you will get to neither (a)
test your knowledge, nor (b) improve your intuitions.  In other words,
these are additional, explicit attempts to encourage active learning.
Ultimately, however, we can only encourage it; itâ€™s up to you to
practice it.</p><p>Specific strategies for program design and development get highlighted
in boxes that look like this:</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: How to ...</p><blockquote class="StrategyBody"><p>hereâ€™s a summary of how to do something.</p></blockquote></blockquote><p>Finally, we also call out content on socially-responsible computing
with visually distinctive regions like this:</p><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Did you consider ...</p><blockquote class="RespCSBody"><p>Here are social pitfalls from using
material naively.</p></blockquote></blockquote></section><section class="SsectionLevel3" id="section 1.7"><h3 class="heading">1.7Â <a name="(part._book-org)"/>Organization of the Material<a href="#(part._book-org)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Because this book covers what would be considered multiple semesters
worth of material at the tertiary level in the USA, we have divided it
into seven main booklets. Later booklets depend on some earlier ones,
but the earlier ones can be treated as a stand-alone book that arrives
at a satisfying ending for a student or course that does not proceed
further.</p><ol><li><p><a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>:
An introduction to programming for beginners that teaches programming
and rudimentary data analysis. It introduces core programming concepts
through composing images and processing tables, before covering lists
and trees. The notional machine throughout this section is based on
substitution.</p><p>Dependencies: None!</p></li><li><p><a href="booklet_pyret-to-python.html" data-pltdoc="x">From Pyret to Python</a>:
Students learn to transfer their knowledge from Pyret to
Python, highlighting similarities and differences between the
languages and their traditional programming styles
(â€œparadigmsâ€). Students are also introduced to Pandas, as a
real-world table-processing system.</p><p>Dependencies: <a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>.</p></li><li><p><a href="booklet_programming-with-state.html" data-pltdoc="x">Programming With State</a>:
Students learn the subtleties of state and aliasing. Much of the
coverage is in both Python and Pyret. This contrast lets students
understand how multiple languages can approach the same topic; the
ways in which the underlying ideas are actually the same; but also
some key differences that provide insight. The notional machine grows
to cover state and aliasing by separating the naming environment (here
called the directory) from a heap of structured data values.</p><p>Dependencies: <a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a> is
essential. <a href="booklet_pyret-to-python.html" data-pltdoc="x">From Pyret to Python</a> is helpful to follow
the Python portions of this booklet, but a student can
do the Pyret parts without having seen Python.</p></li><li><p><a href="booklet_algo-analysis.html" data-pltdoc="x">Algorithm Analysis</a>:
Students are introduced to multiple techniques for analyzing
algorithms.</p><p>Dependencies: <a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>. There is
no dependency on state.</p></li><li><p><a href="booklet_data-with-analysis.html" data-pltdoc="x">Data Structures with Analysis</a>:
Students are introduced to more advanced data structures through a
lens of algorithm analysis, which motivates their revision and
variation.</p><p>Dependencies: <a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a> and
<a href="booklet_algo-analysis.html" data-pltdoc="x">Algorithm Analysis</a> are essential
everywhere. <a href="booklet_programming-with-state.html" data-pltdoc="x">Programming With State</a> is necessary for
some material.</p></li><li><p><a href="booklet_advanced.html" data-pltdoc="x">Advanced Topics</a>:
Students cover a grab-bag of interesting computer science
topics in program design and algorithmic programming. Relative to the
other material, this content is either more subtle, more advanced, or
less essential in a mainstream course.</p><p>Dependencies: All the material depends on
<a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>. Some material depends on
<a href="booklet_algo-analysis.html" data-pltdoc="x">Algorithm Analysis</a> and/or
<a href="booklet_programming-with-state.html" data-pltdoc="x">Programming With State</a>.</p></li><li><p><a href="booklet_interaction.html" data-pltdoc="x">Interactive Programs</a>:
Students can write interactive programs with relatively few dependencies!</p><p>Dependencies: <a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>.</p></li></ol><p>This decomposition into booklets allows flexibility in offering
several different kinds of courses at very different levels of
sophistication. For instance, we already offer two very different
courses by remixing this material, which others could follow:
</p><ul><li><p>An introductory course can use
<a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>,
<a href="booklet_pyret-to-python.html" data-pltdoc="x">From Pyret to Python</a>,
and <a href="booklet_programming-with-state.html" data-pltdoc="x">Programming With State</a>
to
cover the data-centric view of computer science and leaving students
with basic skills in Python. This corresponds to
<a href="https://cs.brown.edu/courses/csci0111/">CSCI 0111</a>
at Brown University.</p></li><li><p>A more advanced course can start with
<a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>,
then do
<a href="booklet_algo-analysis.html" data-pltdoc="x">Algorithm Analysis</a> (perhaps in increments),
followed by
<a href="booklet_data-with-analysis.html" data-pltdoc="x">Data Structures with Analysis</a>,
before returning to
<a href="booklet_programming-with-state.html" data-pltdoc="x">Programming With State</a>,
while interspersing content from
<a href="booklet_advanced.html" data-pltdoc="x">Advanced Topics</a>. This corresponds to
<a href="https://cs.brown.edu/courses/csci0190/">CSCI 0190</a>
at Brown University.</p></li></ul><p>The course pages archive all prior instances of the
courses, which include all the assignments and related materials. Readers are
welcome to use these in their own courses.</p><p>Many of these courses will have entering students who have programmed with state
before (in Python, Java, Scratch, or other languages). In our experience, most
of these students have been given either vastly incomplete, or outright
misleading, explanations of and metaphors for state (e.g., â€œa variable is a
boxâ€).  Thus, they have a poor understanding of it beyond the absolute basics,
especially when they get to important topics like aliasing. As a result, many
of these students have found it both novel and insightful to properly
understand how state really works through our notional machine. For that
reason, we recommend going through that material slowly and carefully.</p><p>We of course invite readers to create their own mashups of the
chapters within the sections. We would love to hear about othersâ€™ designs.</p></section><section class="SsectionLevel3" id="section 1.8"><h3 class="heading">1.8Â <a name="(part._.Our_.Programming_.Language_.Choice)"/>Our Programming Language Choice<a href="#(part._.Our_.Programming_.Language_.Choice)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>If we wanted to get rich, weâ€™d have written this book entirely in Python. As of
this writing, Python is enjoying its instructional-use heyday (just like Java
before it, C++ before that, C before that, Pascal earlier, and so on).
And there are, indeed, many attractive aspects of Python, not least its presence
next to bullet points on job listings. However, weâ€™ve been <a href="pyret-vs-python.html" data-pltdoc="x">repeatedly frustrated by Python</a> as an entrypoint into
learning programming.</p><p>As a result, this book features two programming languages. It starts with a
language, called
<a href="https://www.pyret.org/">Pyret</a>,
that we designed to address our needs and frustrations. It has been expressly
designed for the style of programming in this book, so the two can grow in
harmony. It draws on Python, but also on many other excellent programming
languages. Beginning programmers can therefore rest in the knowledge they are
being cared for, while programmers with past acquaintance of the language
menagerie, from serpents to dromedaries, should find Pyret familiar and
comfortable.</p><p>Then, recognizing the value of Python both as a standard language of
communication and for its extensive libraries, the <a href="part_state.html" data-pltdoc="x">Programming with State (in Both Pyret and Python)</a> part
of this book explicitly covers Python.  Rather than starting from scratch in
Python, we present a systematic and gradual transition to it from the earlier
material. We believe this will make you learn general programming better than
if you had seen only one programming language. However, we believe this will
help you understand Python better, too: just like you learn to appreciate your
own language, country, or culture better once youâ€™ve stepped outside and been
exposed to other ones.</p></section><section class="SsectionLevel3" id="section 1.9"><h3 class="heading">1.9Â <a name="(part._.Programming_.Tools)"/>Programming Tools<a href="#(part._.Programming_.Tools)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p><a href="https://code.pyret.org/">CPO</a> (an abbreviation of
code.pyret.org) is our default programming environment for Pyret.
It runs entirely in the browser and uses Google Drive
for authentication and file storage.</p><p>Pyret support is also available for VSCode. To install it, visit
<a href="https://code.visualstudio.com">https://code.visualstudio.com</a>.
Once you have installed it, click the Extensions tab on the left and
search for Pyret. You should install the "Pyret Interactive Editor for VSCode".</p><p>CPO and VSCode differ only in their support for loading spreadsheet
data. CPO is designed to work with Google Sheets, while VSCode does
not support Google Sheets, and instead expects students to load data from
local CSV files. Unless the book says otherwise, all code can be run in
either tool, and the interface for editing and interacting with programs
is the same. If there are differences, the book will present both
versions. In such cases, code that could run only in VSCode will be
labeled with the VSCode icon, as follows:</p><blockquote class="VSCode"><p class="vscode-icon" title="VS Code only"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">include csv</code></pre></blockquote><p>We do not recommend any
particular Python environment. Any Python editor that allows you to
use pytest and load external data files should work fine.</p></section><section class="SsectionLevel3" id="section 1.10"><h3 class="heading">1.10Â <a name="(part._.Sending_.Us_.Feedback__.Errors__and_.Comments)"/>Sending Us Feedback, Errors, and Comments<a href="#(part._.Sending_.Us_.Feedback__.Errors__and_.Comments)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>As you work through the book, you may spot typos, notice points
where we could have been clearer, or have a suggestion for a future
release. You can pass these along to us by filing an issue on our
<a href="https://github.com/data-centric-computing/dcic-public">public GitHub site</a>. Thanks in advance!</p></section><section class="SsectionLevel3" id="section 1.11"><h3 class="heading">1.11Â <a name="(part._.Staying_.Up-.To-.Date)"/>Staying Up-To-Date<a href="#(part._.Staying_.Up-.To-.Date)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>You can subscribe to our very-low-volume mailing list,
<a href="https://groups.google.com/g/dcic-notifications">dcic-notifications</a>.</p></section></section><section class="SsectionLevel2" id="section 2"><h2 class="heading">2Â <a name="(part._.Acknowledgments)"/>Acknowledgments<a href="#(part._.Acknowledgments)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h2><p>This book has benefited from the attention of many.</p><p>Special thanks to the students at Brown University, who have been
drafted into acting as a crucible for every iteration of this
book. They have supported it with unusual grace, creating a welcoming
and rewarding environment for pedagogic effort. Thanks also to our
academic homesâ€”<wbr/>Brown, Northeastern, and UC San Diegoâ€”<wbr/>for comfort
and encouragement.</p><p>The following people have helpfully provided information on typos and other infelicities:
</p><blockquote><p>Abhabongse Janthong,
Alex Hayworth, Alex Kleiman,
Athyuttam Eleti,
Benjamin S. Shapiro,
Cheng Xie,
Daniel Cai,
Danil Braun,
Dave Lee,
David Cooper,   Doug Kearns,    Ebube Chuba,
Egg (on discord), Evelyn Mitchell,  frodokomodo (on github),
Laura Pozzi, Gavin Sinclair,
Ggbb (from Discord), Graeme McCutcheon, Gregor Grasselli, gregshubert (on github),  Harrison Pincket,
Igor Moreno Santos,
Iuliu Balibanu,
Joann Ordille,  Jason Bennett,
Jeremy Siek,
jiad (from Discord),
Jonathan Zhou,
John (Spike) Hughes,
Jon Sailor,
Jonathan Zhou,   Josh Paley,
Kelechi Ukadike,
Kendrick Cole,
Kishore Vancheeshwaran,  Laura Pozzi, Marc Smith,
Mark Smucker,
Mehmet Fatih KÃ¶ksal, Michael Morehouse, Noah Tye,
Oyendrila Dobe, RafaÅ‚ GwoÅºdziÅ„ski,
rawalplawit (on github),  Raymond Plante,
Ricardo Vela,   Samuel Ainsworth,
Samuel Kortchmar,
timotree (on github),  Yukai Chou,
Zach Amiton. </p></blockquote><p>The following have done the same, but in much greater quantity or depth:
</p><blockquote><p>Dorai Sitaram,
John Palmer,
Kartik Singhal,
Kenichi Asai,
Lev Litichevskiy.</p></blockquote><p>Even amongst the problem-spotters, one is hors catÃ©gorie:
</p><blockquote><p>Sorawee Porncharoenwase.</p></blockquote><p>Daniel Patterson has helped us think about where to switch
between Pyret and Python, while also helping with content on using
Pyret with VSCode.</p><p>This book is completely dependent on Pyret, and thus on the
<a href="https://www.pyret.org/crew/">many people</a> who have
created and sustained it.</p><p>We thank
<a href="https://practicaltypography.com/">Matthew Butterick</a>
for his help with book styling (though the ultimate style is ours, so donâ€™t blame him!).</p><p>Many, many years ago, Alejandro SchÃ¤ffer introduced SK to the idea of
nature as a fat-fingered typist. Alejandroâ€™s fingerprints are over
many parts of this book, even if he wouldnâ€™t
necessarily approve of what has come of his patient instruction.</p><p>We are deeply inspired by the work and ideas of
Matthias Felleisen, Matthew Flatt, and Robby Findler.
Matthias, in particular, inspired our ideas on program design. Even where we
disagree, he continues to engage with and challenge our ideas in ways that
force us to grow and improve. Our work is better than it would be in
incalculable ways due to his influence.</p><p>The chapter on <a href="games-reactive.html" data-pltdoc="x">Interactive Games as Reactive Systems</a> is translated from
<a href="https://world.cs.brown.edu/">How to Design Worlds</a>,
and owes thanks to all the people acknowledged there.</p><p>This book is written in
<a href="https://docs.racket-lang.org/scribble/">Scribble</a>,
the authoring tool of choice for the discerning programmer.</p><p>We thank
<a href="https://cloudconvert.com/">cloudconvert</a>
for their free conversion tools.</p></section>&#13;
<h2 class="heading">1Â <a name="(part._.Overview)"/>Overview<a href="#(part._.Overview)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h2><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._.What_.This_.Book_is_.About%29" class="toclink" data-pltdoc="x">1.1Â What This Book is About</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.The_.Values_.That_.Drive_.This_.Book%29" class="toclink" data-pltdoc="x">1.2Â The Values That Drive This Book</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Our_.Perspective_on_.Data%29" class="toclink" data-pltdoc="x">1.3Â Our Perspective on Data</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.What_.Makes_.This_.Book_.Unique%29" class="toclink" data-pltdoc="x">1.4Â What Makes This Book Unique</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Who_.This_.Book_is_.For%29" class="toclink" data-pltdoc="x">1.5Â Who This Book is For</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._book-style%29" class="toclink" data-pltdoc="x">1.6Â The Structure of This Book</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._book-org%29" class="toclink" data-pltdoc="x">1.7Â Organization of the Material</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Our_.Programming_.Language_.Choice%29" class="toclink" data-pltdoc="x">1.8Â Our Programming Language Choice</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Programming_.Tools%29" class="toclink" data-pltdoc="x">1.9Â Programming Tools</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Sending_.Us_.Feedback__.Errors__and_.Comments%29" class="toclink" data-pltdoc="x">1.10Â Sending Us Feedback, Errors, and Comments</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Staying_.Up-.To-.Date%29" class="toclink" data-pltdoc="x">1.11Â Staying Up-To-Date</a></p></td></tr></table><section class="SsectionLevel3" id="section 1.1"><h3 class="heading">1.1Â <a name="(part._.What_.This_.Book_is_.About)"/>What This Book is About<a href="#(part._.What_.This_.Book_is_.About)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>This book is an introduction to computer science. It will teach you to program,
and do so in ways that are of practical value and importance. However, it will
also go beyond programming to computer science, a rich, deep, fascinating, and
beautiful intellectual discipline. You will learn many useful things that you
can apply right away, but we will also show you some of what lies beneath and
beyond.</p><p>Most of all, we want to give you ways of thinking about solving problems
using computation.  Some of these ways are technical methods, such as working
from data and examples to construct solutions to problems. Others are
scientific methods, such as ways of making sure that programs are reliable and
do what they claim. Finally, some are social, thinking about the impacts that
programs have on people.</p></section><section class="SsectionLevel3" id="section 1.2"><h3 class="heading">1.2Â <a name="(part._.The_.Values_.That_.Drive_.This_.Book)"/>The Values That Drive This Book<a href="#(part._.The_.Values_.That_.Drive_.This_.Book)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Our perspective is guided by our decades of experience as software developers,
researchers, and educators. This has instilled in us the following beliefs:
</p><ul><li><p>Software is not written only to be run. It must also be written to be
read and maintained by others. Often, that â€œotherâ€ person is you, six months
later, who has forgotten what they did and why.</p></li><li><p>Programmers are responsible for their software
meeting its desired goals and being reliable. This is
reflected in a variety of disciplines inside computer science, such as testing
and verification.</p></li><li><p>Programs ought to be be amenable to prediction. We need to know, as much
as possible, before a program runs, how it will behave. This behavior includes
not only technical characteristics such as running time, space, power, and so
on, but also social impacts, benefits, and harms. Programmers have been
notoriously poor at thinking about the latter.</p></li></ul></section><section class="SsectionLevel3" id="section 1.3"><h3 class="heading">1.3Â <a name="(part._.Our_.Perspective_on_.Data)"/>Our Perspective on Data<a href="#(part._.Our_.Perspective_on_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>These concerns intersect with our belief about how computer science has evolved
as a discipline. It is a truism that we live in a world awash with data, but
what consequence does that have?</p><p>At a computational level, data have had a profound effect. Traditionally, the
only way to make a program better was to improve the program directly,
which often meant making it more complicated and impacting the values we
discuss above. But there are classes of programs for which there is another method: simply give the
same program more or better data, and the program can improve. These
data-driven programs lie at the heart of many innovations we see around
us.</p><p>In addition to this technical effect, data can have a profound pedagogic
impact, too. Most introductory programming is plagued by artificial data
that have no real meaning, interest, or consequence (and often, artificial
problems to accompany them). With real data, learners can personalize their
education, focusing on problems they find meaningful, enriching, or just plain
funâ€”<wbr/>asking and answering questions they find worthwhile. Indeed, from this
perspective, programs interrogate data: that is, programs are tools
for answering questions. In turn, the emphasis on real data and real questions
enables us to discuss the social impacts of computing.</p><p>These phenomena have given rise to whole new areas of study, typically
called data science.  However, typical data science curricula also have many
limitations. They pay little attention to what we know about the difficulties
of learning to program. They have little emphasis on software reliability. And
they fail to recognize that their data are often quite limited in their
structure. These limitations, where data science typically ends, are where
computer science begins. In particular, the structure of data serve as a point
of departure for thinking about and achieving some of the values aboveâ€”<wbr/>performance, reliability, and predictabilityâ€”<wbr/>using the many tools of computer
science.</p></section><section class="SsectionLevel3" id="section 1.4"><h3 class="heading">1.4Â <a name="(part._.What_.Makes_.This_.Book_.Unique)"/>What Makes This Book Unique<a href="#(part._.What_.Makes_.This_.Book_.Unique)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>First, we propose a new perspective on structuring computing curricula,
which we call data centricity.For more about this, read
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/kf-data-centric/">our essay</a>.
We view a data-centric curriculum as
</p><blockquote><p>data centric = data science + data structures</p></blockquote><p>in that order: we begin with ideas from data science, before shifting to
classical ideas from data structures and the rest of computer science. This
book lays out this vision concretely and in detail.</p><p>Second, computing education talks a great deal about
notional machinesâ€”<wbr/>abstractions of program behavior meant to help
students understand how programs workâ€”<wbr/>but few curricula actually use one. We
take notional machines seriously, developing a sequence of them and weaving
them through the curriculum. This ties to our belief that programs are not only
objects that run, but also objects that we reason about.</p><p>Third, we weave content on socially-responsible computing into the
text. Unlike other efforts that focus on exposing students to ethics
or the pitfalls of technology in general, we aim to show students how
the constructs and concepts that they are turning into code
right now can lead to adverse impacts unless used with
care. In keeping with our focus on testing and concrete examples, we
introduce several topics by getting students to think about
assumptions at the level of concrete data. This material is called out
explicitly throughout the book.</p><p>Finally, this book is deeply informed by recent and ongoing research
results. Our choices of material, order of presentation, programming methods,
and more are driven by what we know from the research literature. In many
cases, we ourselves are the ones doing the research, so the curriculum and
research live in a symbiotic relationship. You can find our papers
(some with each other, others not)
<a href="https://cs.brown.edu/~kfisler/Pubs/index.html">on</a>
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/">our</a>
<a href="https://www.ccs.neu.edu/home/blerner/papers.html">respective</a>
<a href="https://jpolitz.github.io">pages</a>.</p></section><section class="SsectionLevel3" id="section 1.5"><h3 class="heading">1.5Â <a name="(part._.Who_.This_.Book_is_.For)"/>Who This Book is For<a href="#(part._.Who_.This_.Book_is_.For)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>This book is written primarily for students who are in the early stages of
computing education at the tertiary level (college or university). However,
manyâ€”<wbr/>especially the earlierâ€”<wbr/>parts of it are also suitable for secondary
education (in the USA, for instance, roughly grades 6â€“12, or ages
12â€“18). Indeed, we see a natural continuum between secondary and tertiary
education, and think this book can serve as a useful bridge between the two.</p></section><section class="SsectionLevel3" id="section 1.6"><h3 class="heading">1.6Â <a name="(part._book-style)"/>The Structure of This Book<a href="#(part._book-style)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Unlike some other textbooks, this one does not follow a top-down
narrative.  Rather it has the flow of a conversation, with
backtracking.  We will often build up programs incrementally, just as
a pair of programmers would.  We will include mistakes, not because we
donâ€™t know better, but because this is the best way for you
to learn.  Including mistakes makes it impossible for you to read
passively: you must instead engage with the material, because you can
never be sure of the veracity of what youâ€™re reading.</p><p>At the end, youâ€™ll always get to the right answer.  However, this
non-linear path is more frustrating in the short term (you will often
be tempted to say, â€œJust tell me the answer, already!â€), and it
makes the book a poor reference guide (you canâ€™t open up to a random
page and be sure what it says is correct).  However, that feeling of
frustration is the sensation of learning.  We donâ€™t know of a way
around it.</p><p>We use visual formatting to highlight some of these points. Thus,
in several places you will encounter this:</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>This is an exercise.  Do try it.</p></blockquote></blockquote><p>This is a traditional textbook exercise.  Itâ€™s something you need to
do on your own.  If youâ€™re using this book as part of a course, this
may very well have been assigned as homework.  In contrast, you will
also find exercise-like questions that look like this:</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Thereâ€™s an activity here!  Do you see it?</p></blockquote></blockquote><p>When you get to one of these, stop.  Read, think, and formulate
an answer before you proceed.  You must do this because this is
actually an exercise, but the answer is already in the
bookâ€”<wbr/>most often in the text immediately following (i.e., in the part
youâ€™re reading right now)â€”<wbr/>or is something you can determine for
yourself by running a program.  If you just read on, youâ€™ll see the
answer without having thought about it (or not see it at all, if the
instructions are to run a program), so you will get to neither (a)
test your knowledge, nor (b) improve your intuitions.  In other words,
these are additional, explicit attempts to encourage active learning.
Ultimately, however, we can only encourage it; itâ€™s up to you to
practice it.</p><p>Specific strategies for program design and development get highlighted
in boxes that look like this:</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: How to ...</p><blockquote class="StrategyBody"><p>hereâ€™s a summary of how to do something.</p></blockquote></blockquote><p>Finally, we also call out content on socially-responsible computing
with visually distinctive regions like this:</p><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Did you consider ...</p><blockquote class="RespCSBody"><p>Here are social pitfalls from using
material naively.</p></blockquote></blockquote></section><section class="SsectionLevel3" id="section 1.7"><h3 class="heading">1.7Â <a name="(part._book-org)"/>Organization of the Material<a href="#(part._book-org)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Because this book covers what would be considered multiple semesters
worth of material at the tertiary level in the USA, we have divided it
into seven main booklets. Later booklets depend on some earlier ones,
but the earlier ones can be treated as a stand-alone book that arrives
at a satisfying ending for a student or course that does not proceed
further.</p><ol><li><p><a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>:
An introduction to programming for beginners that teaches programming
and rudimentary data analysis. It introduces core programming concepts
through composing images and processing tables, before covering lists
and trees. The notional machine throughout this section is based on
substitution.</p><p>Dependencies: None!</p></li><li><p><a href="booklet_pyret-to-python.html" data-pltdoc="x">From Pyret to Python</a>:
Students learn to transfer their knowledge from Pyret to
Python, highlighting similarities and differences between the
languages and their traditional programming styles
(â€œparadigmsâ€). Students are also introduced to Pandas, as a
real-world table-processing system.</p><p>Dependencies: <a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>.</p></li><li><p><a href="booklet_programming-with-state.html" data-pltdoc="x">Programming With State</a>:
Students learn the subtleties of state and aliasing. Much of the
coverage is in both Python and Pyret. This contrast lets students
understand how multiple languages can approach the same topic; the
ways in which the underlying ideas are actually the same; but also
some key differences that provide insight. The notional machine grows
to cover state and aliasing by separating the naming environment (here
called the directory) from a heap of structured data values.</p><p>Dependencies: <a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a> is
essential. <a href="booklet_pyret-to-python.html" data-pltdoc="x">From Pyret to Python</a> is helpful to follow
the Python portions of this booklet, but a student can
do the Pyret parts without having seen Python.</p></li><li><p><a href="booklet_algo-analysis.html" data-pltdoc="x">Algorithm Analysis</a>:
Students are introduced to multiple techniques for analyzing
algorithms.</p><p>Dependencies: <a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>. There is
no dependency on state.</p></li><li><p><a href="booklet_data-with-analysis.html" data-pltdoc="x">Data Structures with Analysis</a>:
Students are introduced to more advanced data structures through a
lens of algorithm analysis, which motivates their revision and
variation.</p><p>Dependencies: <a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a> and
<a href="booklet_algo-analysis.html" data-pltdoc="x">Algorithm Analysis</a> are essential
everywhere. <a href="booklet_programming-with-state.html" data-pltdoc="x">Programming With State</a> is necessary for
some material.</p></li><li><p><a href="booklet_advanced.html" data-pltdoc="x">Advanced Topics</a>:
Students cover a grab-bag of interesting computer science
topics in program design and algorithmic programming. Relative to the
other material, this content is either more subtle, more advanced, or
less essential in a mainstream course.</p><p>Dependencies: All the material depends on
<a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>. Some material depends on
<a href="booklet_algo-analysis.html" data-pltdoc="x">Algorithm Analysis</a> and/or
<a href="booklet_programming-with-state.html" data-pltdoc="x">Programming With State</a>.</p></li><li><p><a href="booklet_interaction.html" data-pltdoc="x">Interactive Programs</a>:
Students can write interactive programs with relatively few dependencies!</p><p>Dependencies: <a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>.</p></li></ol><p>This decomposition into booklets allows flexibility in offering
several different kinds of courses at very different levels of
sophistication. For instance, we already offer two very different
courses by remixing this material, which others could follow:
</p><ul><li><p>An introductory course can use
<a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>,
<a href="booklet_pyret-to-python.html" data-pltdoc="x">From Pyret to Python</a>,
and <a href="booklet_programming-with-state.html" data-pltdoc="x">Programming With State</a>
to
cover the data-centric view of computer science and leaving students
with basic skills in Python. This corresponds to
<a href="https://cs.brown.edu/courses/csci0111/">CSCI 0111</a>
at Brown University.</p></li><li><p>A more advanced course can start with
<a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>,
then do
<a href="booklet_algo-analysis.html" data-pltdoc="x">Algorithm Analysis</a> (perhaps in increments),
followed by
<a href="booklet_data-with-analysis.html" data-pltdoc="x">Data Structures with Analysis</a>,
before returning to
<a href="booklet_programming-with-state.html" data-pltdoc="x">Programming With State</a>,
while interspersing content from
<a href="booklet_advanced.html" data-pltdoc="x">Advanced Topics</a>. This corresponds to
<a href="https://cs.brown.edu/courses/csci0190/">CSCI 0190</a>
at Brown University.</p></li></ul><p>The course pages archive all prior instances of the
courses, which include all the assignments and related materials. Readers are
welcome to use these in their own courses.</p><p>Many of these courses will have entering students who have programmed with state
before (in Python, Java, Scratch, or other languages). In our experience, most
of these students have been given either vastly incomplete, or outright
misleading, explanations of and metaphors for state (e.g., â€œa variable is a
boxâ€).  Thus, they have a poor understanding of it beyond the absolute basics,
especially when they get to important topics like aliasing. As a result, many
of these students have found it both novel and insightful to properly
understand how state really works through our notional machine. For that
reason, we recommend going through that material slowly and carefully.</p><p>We of course invite readers to create their own mashups of the
chapters within the sections. We would love to hear about othersâ€™ designs.</p></section><section class="SsectionLevel3" id="section 1.8"><h3 class="heading">1.8Â <a name="(part._.Our_.Programming_.Language_.Choice)"/>Our Programming Language Choice<a href="#(part._.Our_.Programming_.Language_.Choice)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>If we wanted to get rich, weâ€™d have written this book entirely in Python. As of
this writing, Python is enjoying its instructional-use heyday (just like Java
before it, C++ before that, C before that, Pascal earlier, and so on).
And there are, indeed, many attractive aspects of Python, not least its presence
next to bullet points on job listings. However, weâ€™ve been <a href="pyret-vs-python.html" data-pltdoc="x">repeatedly frustrated by Python</a> as an entrypoint into
learning programming.</p><p>As a result, this book features two programming languages. It starts with a
language, called
<a href="https://www.pyret.org/">Pyret</a>,
that we designed to address our needs and frustrations. It has been expressly
designed for the style of programming in this book, so the two can grow in
harmony. It draws on Python, but also on many other excellent programming
languages. Beginning programmers can therefore rest in the knowledge they are
being cared for, while programmers with past acquaintance of the language
menagerie, from serpents to dromedaries, should find Pyret familiar and
comfortable.</p><p>Then, recognizing the value of Python both as a standard language of
communication and for its extensive libraries, the <a href="part_state.html" data-pltdoc="x">Programming with State (in Both Pyret and Python)</a> part
of this book explicitly covers Python.  Rather than starting from scratch in
Python, we present a systematic and gradual transition to it from the earlier
material. We believe this will make you learn general programming better than
if you had seen only one programming language. However, we believe this will
help you understand Python better, too: just like you learn to appreciate your
own language, country, or culture better once youâ€™ve stepped outside and been
exposed to other ones.</p></section><section class="SsectionLevel3" id="section 1.9"><h3 class="heading">1.9Â <a name="(part._.Programming_.Tools)"/>Programming Tools<a href="#(part._.Programming_.Tools)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p><a href="https://code.pyret.org/">CPO</a> (an abbreviation of
code.pyret.org) is our default programming environment for Pyret.
It runs entirely in the browser and uses Google Drive
for authentication and file storage.</p><p>Pyret support is also available for VSCode. To install it, visit
<a href="https://code.visualstudio.com">https://code.visualstudio.com</a>.
Once you have installed it, click the Extensions tab on the left and
search for Pyret. You should install the "Pyret Interactive Editor for VSCode".</p><p>CPO and VSCode differ only in their support for loading spreadsheet
data. CPO is designed to work with Google Sheets, while VSCode does
not support Google Sheets, and instead expects students to load data from
local CSV files. Unless the book says otherwise, all code can be run in
either tool, and the interface for editing and interacting with programs
is the same. If there are differences, the book will present both
versions. In such cases, code that could run only in VSCode will be
labeled with the VSCode icon, as follows:</p><blockquote class="VSCode"><p class="vscode-icon" title="VS Code only"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">include csv</code></pre></blockquote><p>We do not recommend any
particular Python environment. Any Python editor that allows you to
use pytest and load external data files should work fine.</p></section><section class="SsectionLevel3" id="section 1.10"><h3 class="heading">1.10Â <a name="(part._.Sending_.Us_.Feedback__.Errors__and_.Comments)"/>Sending Us Feedback, Errors, and Comments<a href="#(part._.Sending_.Us_.Feedback__.Errors__and_.Comments)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>As you work through the book, you may spot typos, notice points
where we could have been clearer, or have a suggestion for a future
release. You can pass these along to us by filing an issue on our
<a href="https://github.com/data-centric-computing/dcic-public">public GitHub site</a>. Thanks in advance!</p></section><section class="SsectionLevel3" id="section 1.11"><h3 class="heading">1.11Â <a name="(part._.Staying_.Up-.To-.Date)"/>Staying Up-To-Date<a href="#(part._.Staying_.Up-.To-.Date)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>You can subscribe to our very-low-volume mailing list,
<a href="https://groups.google.com/g/dcic-notifications">dcic-notifications</a>.</p></section>&#13;
<h3 class="heading">1.1Â <a name="(part._.What_.This_.Book_is_.About)"/>What This Book is About<a href="#(part._.What_.This_.Book_is_.About)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>This book is an introduction to computer science. It will teach you to program,
and do so in ways that are of practical value and importance. However, it will
also go beyond programming to computer science, a rich, deep, fascinating, and
beautiful intellectual discipline. You will learn many useful things that you
can apply right away, but we will also show you some of what lies beneath and
beyond.</p><p>Most of all, we want to give you ways of thinking about solving problems
using computation.  Some of these ways are technical methods, such as working
from data and examples to construct solutions to problems. Others are
scientific methods, such as ways of making sure that programs are reliable and
do what they claim. Finally, some are social, thinking about the impacts that
programs have on people.</p>&#13;
<h3 class="heading">1.2Â <a name="(part._.The_.Values_.That_.Drive_.This_.Book)"/>The Values That Drive This Book<a href="#(part._.The_.Values_.That_.Drive_.This_.Book)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Our perspective is guided by our decades of experience as software developers,
researchers, and educators. This has instilled in us the following beliefs:
</p><ul><li><p>Software is not written only to be run. It must also be written to be
read and maintained by others. Often, that â€œotherâ€ person is you, six months
later, who has forgotten what they did and why.</p></li><li><p>Programmers are responsible for their software
meeting its desired goals and being reliable. This is
reflected in a variety of disciplines inside computer science, such as testing
and verification.</p></li><li><p>Programs ought to be be amenable to prediction. We need to know, as much
as possible, before a program runs, how it will behave. This behavior includes
not only technical characteristics such as running time, space, power, and so
on, but also social impacts, benefits, and harms. Programmers have been
notoriously poor at thinking about the latter.</p></li></ul>&#13;
<h3 class="heading">1.3Â <a name="(part._.Our_.Perspective_on_.Data)"/>Our Perspective on Data<a href="#(part._.Our_.Perspective_on_.Data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>These concerns intersect with our belief about how computer science has evolved
as a discipline. It is a truism that we live in a world awash with data, but
what consequence does that have?</p><p>At a computational level, data have had a profound effect. Traditionally, the
only way to make a program better was to improve the program directly,
which often meant making it more complicated and impacting the values we
discuss above. But there are classes of programs for which there is another method: simply give the
same program more or better data, and the program can improve. These
data-driven programs lie at the heart of many innovations we see around
us.</p><p>In addition to this technical effect, data can have a profound pedagogic
impact, too. Most introductory programming is plagued by artificial data
that have no real meaning, interest, or consequence (and often, artificial
problems to accompany them). With real data, learners can personalize their
education, focusing on problems they find meaningful, enriching, or just plain
funâ€”<wbr/>asking and answering questions they find worthwhile. Indeed, from this
perspective, programs interrogate data: that is, programs are tools
for answering questions. In turn, the emphasis on real data and real questions
enables us to discuss the social impacts of computing.</p><p>These phenomena have given rise to whole new areas of study, typically
called data science.  However, typical data science curricula also have many
limitations. They pay little attention to what we know about the difficulties
of learning to program. They have little emphasis on software reliability. And
they fail to recognize that their data are often quite limited in their
structure. These limitations, where data science typically ends, are where
computer science begins. In particular, the structure of data serve as a point
of departure for thinking about and achieving some of the values aboveâ€”<wbr/>performance, reliability, and predictabilityâ€”<wbr/>using the many tools of computer
science.</p>&#13;
<h3 class="heading">1.4Â <a name="(part._.What_.Makes_.This_.Book_.Unique)"/>What Makes This Book Unique<a href="#(part._.What_.Makes_.This_.Book_.Unique)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>First, we propose a new perspective on structuring computing curricula,
which we call data centricity.For more about this, read
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/kf-data-centric/">our essay</a>.
We view a data-centric curriculum as
</p><blockquote><p>data centric = data science + data structures</p></blockquote><p>in that order: we begin with ideas from data science, before shifting to
classical ideas from data structures and the rest of computer science. This
book lays out this vision concretely and in detail.</p><p>Second, computing education talks a great deal about
notional machinesâ€”<wbr/>abstractions of program behavior meant to help
students understand how programs workâ€”<wbr/>but few curricula actually use one. We
take notional machines seriously, developing a sequence of them and weaving
them through the curriculum. This ties to our belief that programs are not only
objects that run, but also objects that we reason about.</p><p>Third, we weave content on socially-responsible computing into the
text. Unlike other efforts that focus on exposing students to ethics
or the pitfalls of technology in general, we aim to show students how
the constructs and concepts that they are turning into code
right now can lead to adverse impacts unless used with
care. In keeping with our focus on testing and concrete examples, we
introduce several topics by getting students to think about
assumptions at the level of concrete data. This material is called out
explicitly throughout the book.</p><p>Finally, this book is deeply informed by recent and ongoing research
results. Our choices of material, order of presentation, programming methods,
and more are driven by what we know from the research literature. In many
cases, we ourselves are the ones doing the research, so the curriculum and
research live in a symbiotic relationship. You can find our papers
(some with each other, others not)
<a href="https://cs.brown.edu/~kfisler/Pubs/index.html">on</a>
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/">our</a>
<a href="https://www.ccs.neu.edu/home/blerner/papers.html">respective</a>
<a href="https://jpolitz.github.io">pages</a>.</p>&#13;
<h3 class="heading">1.5Â <a name="(part._.Who_.This_.Book_is_.For)"/>Who This Book is For<a href="#(part._.Who_.This_.Book_is_.For)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>This book is written primarily for students who are in the early stages of
computing education at the tertiary level (college or university). However,
manyâ€”<wbr/>especially the earlierâ€”<wbr/>parts of it are also suitable for secondary
education (in the USA, for instance, roughly grades 6â€“12, or ages
12â€“18). Indeed, we see a natural continuum between secondary and tertiary
education, and think this book can serve as a useful bridge between the two.</p>&#13;
<h3 class="heading">1.6Â <a name="(part._book-style)"/>The Structure of This Book<a href="#(part._book-style)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Unlike some other textbooks, this one does not follow a top-down
narrative.  Rather it has the flow of a conversation, with
backtracking.  We will often build up programs incrementally, just as
a pair of programmers would.  We will include mistakes, not because we
donâ€™t know better, but because this is the best way for you
to learn.  Including mistakes makes it impossible for you to read
passively: you must instead engage with the material, because you can
never be sure of the veracity of what youâ€™re reading.</p><p>At the end, youâ€™ll always get to the right answer.  However, this
non-linear path is more frustrating in the short term (you will often
be tempted to say, â€œJust tell me the answer, already!â€), and it
makes the book a poor reference guide (you canâ€™t open up to a random
page and be sure what it says is correct).  However, that feeling of
frustration is the sensation of learning.  We donâ€™t know of a way
around it.</p><p>We use visual formatting to highlight some of these points. Thus,
in several places you will encounter this:</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>This is an exercise.  Do try it.</p></blockquote></blockquote><p>This is a traditional textbook exercise.  Itâ€™s something you need to
do on your own.  If youâ€™re using this book as part of a course, this
may very well have been assigned as homework.  In contrast, you will
also find exercise-like questions that look like this:</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Thereâ€™s an activity here!  Do you see it?</p></blockquote></blockquote><p>When you get to one of these, stop.  Read, think, and formulate
an answer before you proceed.  You must do this because this is
actually an exercise, but the answer is already in the
bookâ€”<wbr/>most often in the text immediately following (i.e., in the part
youâ€™re reading right now)â€”<wbr/>or is something you can determine for
yourself by running a program.  If you just read on, youâ€™ll see the
answer without having thought about it (or not see it at all, if the
instructions are to run a program), so you will get to neither (a)
test your knowledge, nor (b) improve your intuitions.  In other words,
these are additional, explicit attempts to encourage active learning.
Ultimately, however, we can only encourage it; itâ€™s up to you to
practice it.</p><p>Specific strategies for program design and development get highlighted
in boxes that look like this:</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: How to ...</p><blockquote class="StrategyBody"><p>hereâ€™s a summary of how to do something.</p></blockquote></blockquote><p>Finally, we also call out content on socially-responsible computing
with visually distinctive regions like this:</p><blockquote class="RespCS"><p class="RespCSHeader">Responsible Computing: Did you consider ...</p><blockquote class="RespCSBody"><p>Here are social pitfalls from using
material naively.</p></blockquote></blockquote>&#13;
<h3 class="heading">1.7Â <a name="(part._book-org)"/>Organization of the Material<a href="#(part._book-org)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Because this book covers what would be considered multiple semesters
worth of material at the tertiary level in the USA, we have divided it
into seven main booklets. Later booklets depend on some earlier ones,
but the earlier ones can be treated as a stand-alone book that arrives
at a satisfying ending for a student or course that does not proceed
further.</p><ol><li><p><a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>:
An introduction to programming for beginners that teaches programming
and rudimentary data analysis. It introduces core programming concepts
through composing images and processing tables, before covering lists
and trees. The notional machine throughout this section is based on
substitution.</p><p>Dependencies: None!</p></li><li><p><a href="booklet_pyret-to-python.html" data-pltdoc="x">From Pyret to Python</a>:
Students learn to transfer their knowledge from Pyret to
Python, highlighting similarities and differences between the
languages and their traditional programming styles
(â€œparadigmsâ€). Students are also introduced to Pandas, as a
real-world table-processing system.</p><p>Dependencies: <a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>.</p></li><li><p><a href="booklet_programming-with-state.html" data-pltdoc="x">Programming With State</a>:
Students learn the subtleties of state and aliasing. Much of the
coverage is in both Python and Pyret. This contrast lets students
understand how multiple languages can approach the same topic; the
ways in which the underlying ideas are actually the same; but also
some key differences that provide insight. The notional machine grows
to cover state and aliasing by separating the naming environment (here
called the directory) from a heap of structured data values.</p><p>Dependencies: <a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a> is
essential. <a href="booklet_pyret-to-python.html" data-pltdoc="x">From Pyret to Python</a> is helpful to follow
the Python portions of this booklet, but a student can
do the Pyret parts without having seen Python.</p></li><li><p><a href="booklet_algo-analysis.html" data-pltdoc="x">Algorithm Analysis</a>:
Students are introduced to multiple techniques for analyzing
algorithms.</p><p>Dependencies: <a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>. There is
no dependency on state.</p></li><li><p><a href="booklet_data-with-analysis.html" data-pltdoc="x">Data Structures with Analysis</a>:
Students are introduced to more advanced data structures through a
lens of algorithm analysis, which motivates their revision and
variation.</p><p>Dependencies: <a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a> and
<a href="booklet_algo-analysis.html" data-pltdoc="x">Algorithm Analysis</a> are essential
everywhere. <a href="booklet_programming-with-state.html" data-pltdoc="x">Programming With State</a> is necessary for
some material.</p></li><li><p><a href="booklet_advanced.html" data-pltdoc="x">Advanced Topics</a>:
Students cover a grab-bag of interesting computer science
topics in program design and algorithmic programming. Relative to the
other material, this content is either more subtle, more advanced, or
less essential in a mainstream course.</p><p>Dependencies: All the material depends on
<a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>. Some material depends on
<a href="booklet_algo-analysis.html" data-pltdoc="x">Algorithm Analysis</a> and/or
<a href="booklet_programming-with-state.html" data-pltdoc="x">Programming With State</a>.</p></li><li><p><a href="booklet_interaction.html" data-pltdoc="x">Interactive Programs</a>:
Students can write interactive programs with relatively few dependencies!</p><p>Dependencies: <a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>.</p></li></ol><p>This decomposition into booklets allows flexibility in offering
several different kinds of courses at very different levels of
sophistication. For instance, we already offer two very different
courses by remixing this material, which others could follow:
</p><ul><li><p>An introductory course can use
<a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>,
<a href="booklet_pyret-to-python.html" data-pltdoc="x">From Pyret to Python</a>,
and <a href="booklet_programming-with-state.html" data-pltdoc="x">Programming With State</a>
to
cover the data-centric view of computer science and leaving students
with basic skills in Python. This corresponds to
<a href="https://cs.brown.edu/courses/csci0111/">CSCI 0111</a>
at Brown University.</p></li><li><p>A more advanced course can start with
<a href="booklet_intro-to-programming.html" data-pltdoc="x">Introduction to Programming</a>,
then do
<a href="booklet_algo-analysis.html" data-pltdoc="x">Algorithm Analysis</a> (perhaps in increments),
followed by
<a href="booklet_data-with-analysis.html" data-pltdoc="x">Data Structures with Analysis</a>,
before returning to
<a href="booklet_programming-with-state.html" data-pltdoc="x">Programming With State</a>,
while interspersing content from
<a href="booklet_advanced.html" data-pltdoc="x">Advanced Topics</a>. This corresponds to
<a href="https://cs.brown.edu/courses/csci0190/">CSCI 0190</a>
at Brown University.</p></li></ul><p>The course pages archive all prior instances of the
courses, which include all the assignments and related materials. Readers are
welcome to use these in their own courses.</p><p>Many of these courses will have entering students who have programmed with state
before (in Python, Java, Scratch, or other languages). In our experience, most
of these students have been given either vastly incomplete, or outright
misleading, explanations of and metaphors for state (e.g., â€œa variable is a
boxâ€).  Thus, they have a poor understanding of it beyond the absolute basics,
especially when they get to important topics like aliasing. As a result, many
of these students have found it both novel and insightful to properly
understand how state really works through our notional machine. For that
reason, we recommend going through that material slowly and carefully.</p><p>We of course invite readers to create their own mashups of the
chapters within the sections. We would love to hear about othersâ€™ designs.</p>&#13;
<h3 class="heading">1.8Â <a name="(part._.Our_.Programming_.Language_.Choice)"/>Our Programming Language Choice<a href="#(part._.Our_.Programming_.Language_.Choice)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>If we wanted to get rich, weâ€™d have written this book entirely in Python. As of
this writing, Python is enjoying its instructional-use heyday (just like Java
before it, C++ before that, C before that, Pascal earlier, and so on).
And there are, indeed, many attractive aspects of Python, not least its presence
next to bullet points on job listings. However, weâ€™ve been <a href="pyret-vs-python.html" data-pltdoc="x">repeatedly frustrated by Python</a> as an entrypoint into
learning programming.</p><p>As a result, this book features two programming languages. It starts with a
language, called
<a href="https://www.pyret.org/">Pyret</a>,
that we designed to address our needs and frustrations. It has been expressly
designed for the style of programming in this book, so the two can grow in
harmony. It draws on Python, but also on many other excellent programming
languages. Beginning programmers can therefore rest in the knowledge they are
being cared for, while programmers with past acquaintance of the language
menagerie, from serpents to dromedaries, should find Pyret familiar and
comfortable.</p><p>Then, recognizing the value of Python both as a standard language of
communication and for its extensive libraries, the <a href="part_state.html" data-pltdoc="x">Programming with State (in Both Pyret and Python)</a> part
of this book explicitly covers Python.  Rather than starting from scratch in
Python, we present a systematic and gradual transition to it from the earlier
material. We believe this will make you learn general programming better than
if you had seen only one programming language. However, we believe this will
help you understand Python better, too: just like you learn to appreciate your
own language, country, or culture better once youâ€™ve stepped outside and been
exposed to other ones.</p>&#13;
<h3 class="heading">1.9Â <a name="(part._.Programming_.Tools)"/>Programming Tools<a href="#(part._.Programming_.Tools)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p><a href="https://code.pyret.org/">CPO</a> (an abbreviation of
code.pyret.org) is our default programming environment for Pyret.
It runs entirely in the browser and uses Google Drive
for authentication and file storage.</p><p>Pyret support is also available for VSCode. To install it, visit
<a href="https://code.visualstudio.com">https://code.visualstudio.com</a>.
Once you have installed it, click the Extensions tab on the left and
search for Pyret. You should install the "Pyret Interactive Editor for VSCode".</p><p>CPO and VSCode differ only in their support for loading spreadsheet
data. CPO is designed to work with Google Sheets, while VSCode does
not support Google Sheets, and instead expects students to load data from
local CSV files. Unless the book says otherwise, all code can be run in
either tool, and the interface for editing and interacting with programs
is the same. If there are differences, the book will present both
versions. In such cases, code that could run only in VSCode will be
labeled with the VSCode icon, as follows:</p><blockquote class="VSCode"><p class="vscode-icon" title="VS Code only"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">include csv</code></pre></blockquote><p>We do not recommend any
particular Python environment. Any Python editor that allows you to
use pytest and load external data files should work fine.</p>&#13;
<h3 class="heading">1.10Â <a name="(part._.Sending_.Us_.Feedback__.Errors__and_.Comments)"/>Sending Us Feedback, Errors, and Comments<a href="#(part._.Sending_.Us_.Feedback__.Errors__and_.Comments)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>As you work through the book, you may spot typos, notice points
where we could have been clearer, or have a suggestion for a future
release. You can pass these along to us by filing an issue on our
<a href="https://github.com/data-centric-computing/dcic-public">public GitHub site</a>. Thanks in advance!</p>&#13;
<h3 class="heading">1.11Â <a name="(part._.Staying_.Up-.To-.Date)"/>Staying Up-To-Date<a href="#(part._.Staying_.Up-.To-.Date)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>You can subscribe to our very-low-volume mailing list,
<a href="https://groups.google.com/g/dcic-notifications">dcic-notifications</a>.</p>&#13;
<h2 class="heading">2Â <a name="(part._.Acknowledgments)"/>Acknowledgments<a href="#(part._.Acknowledgments)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h2><p>This book has benefited from the attention of many.</p><p>Special thanks to the students at Brown University, who have been
drafted into acting as a crucible for every iteration of this
book. They have supported it with unusual grace, creating a welcoming
and rewarding environment for pedagogic effort. Thanks also to our
academic homesâ€”<wbr/>Brown, Northeastern, and UC San Diegoâ€”<wbr/>for comfort
and encouragement.</p><p>The following people have helpfully provided information on typos and other infelicities:
</p><blockquote><p>Abhabongse Janthong,
Alex Hayworth, Alex Kleiman,
Athyuttam Eleti,
Benjamin S. Shapiro,
Cheng Xie,
Daniel Cai,
Danil Braun,
Dave Lee,
David Cooper,   Doug Kearns,    Ebube Chuba,
Egg (on discord), Evelyn Mitchell,  frodokomodo (on github),
Laura Pozzi, Gavin Sinclair,
Ggbb (from Discord), Graeme McCutcheon, Gregor Grasselli, gregshubert (on github),  Harrison Pincket,
Igor Moreno Santos,
Iuliu Balibanu,
Joann Ordille,  Jason Bennett,
Jeremy Siek,
jiad (from Discord),
Jonathan Zhou,
John (Spike) Hughes,
Jon Sailor,
Jonathan Zhou,   Josh Paley,
Kelechi Ukadike,
Kendrick Cole,
Kishore Vancheeshwaran,  Laura Pozzi, Marc Smith,
Mark Smucker,
Mehmet Fatih KÃ¶ksal, Michael Morehouse, Noah Tye,
Oyendrila Dobe, RafaÅ‚ GwoÅºdziÅ„ski,
rawalplawit (on github),  Raymond Plante,
Ricardo Vela,   Samuel Ainsworth,
Samuel Kortchmar,
timotree (on github),  Yukai Chou,
Zach Amiton. </p></blockquote><p>The following have done the same, but in much greater quantity or depth:
</p><blockquote><p>Dorai Sitaram,
John Palmer,
Kartik Singhal,
Kenichi Asai,
Lev Litichevskiy.</p></blockquote><p>Even amongst the problem-spotters, one is hors catÃ©gorie:
</p><blockquote><p>Sorawee Porncharoenwase.</p></blockquote><p>Daniel Patterson has helped us think about where to switch
between Pyret and Python, while also helping with content on using
Pyret with VSCode.</p><p>This book is completely dependent on Pyret, and thus on the
<a href="https://www.pyret.org/crew/">many people</a> who have
created and sustained it.</p><p>We thank
<a href="https://practicaltypography.com/">Matthew Butterick</a>
for his help with book styling (though the ultimate style is ours, so donâ€™t blame him!).</p><p>Many, many years ago, Alejandro SchÃ¤ffer introduced SK to the idea of
nature as a fat-fingered typist. Alejandroâ€™s fingerprints are over
many parts of this book, even if he wouldnâ€™t
necessarily approve of what has come of his patient instruction.</p><p>We are deeply inspired by the work and ideas of
Matthias Felleisen, Matthew Flatt, and Robby Findler.
Matthias, in particular, inspired our ideas on program design. Even where we
disagree, he continues to engage with and challenge our ideas in ways that
force us to grow and improve. Our work is better than it would be in
incalculable ways due to his influence.</p><p>The chapter on <a href="games-reactive.html" data-pltdoc="x">Interactive Games as Reactive Systems</a> is translated from
<a href="https://world.cs.brown.edu/">How to Design Worlds</a>,
and owes thanks to all the people acknowledged there.</p><p>This book is written in
<a href="https://docs.racket-lang.org/scribble/">Scribble</a>,
the authoring tool of choice for the discerning programmer.</p><p>We thank
<a href="https://cloudconvert.com/">cloudconvert</a>
for their free conversion tools.</p>    
</body>
</html>