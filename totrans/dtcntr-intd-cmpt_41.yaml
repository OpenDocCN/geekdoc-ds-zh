- en: 13.1¬†Mutating Variablesüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/mutating-variables.html](https://dcic-world.org/2025-08-27/mutating-variables.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[13.1.1¬†Mutating Variables in Memory](#%28part._mutating-vars-memory%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[13.1.2¬†Variable Mutation and Aliasing](#%28part._var-mut-aliasing%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[13.1.3¬†Mutating Variables versus Mutating Data Fields](#%28part._.Mutating_.Variables_versus_.Mutating_.Data_.Fields%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[13.1.4¬†Mutating Parameters in Function Calls](#%28part._.Mutating_.Parameters_in_.Function_.Calls%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[13.1.5¬†Mutating Top-Level Variables within Functions](#%28part._mut-top-level-vars-in-func%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[13.1.6¬†The Many Roles of Variables](#%28part._.The_.Many_.Roles_of_.Variables%29)
    |'
  prefs: []
  type: TYPE_TB
- en: 13.1.1¬†Mutating Variables in Memory[üîó](#(part._mutating-vars-memory) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have introduced the idea of the heap, let‚Äôs revisit our use of
    a variable to compute the sum of elements in a list. Here again is the code we
    wrote for this earlier (in [Introducing `For` Loops](intro-python.html#%28part._python-for-loops%29)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let‚Äôs see how the directory and heap update as we run this code. In [Basic Data
    and the Heap](mutating-structures.html#%28part._basic-data-heap%29), we pointed
    out that basic data (such as numbers, strings, and booleans) don‚Äôt get put in
    the heap because they have no internal structure. Those values are stored in the
    directory itself. Therefore, the initial value for `run_total` is stored within
    the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `for` loop also sets up a directory entry, this time for the variable `num`
    that is used to refer to the list elements. When the loop starts, `num` takes
    on the first value in the list. Thus, the directory appears as:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `for` loop, we compute a new value for `run_total`. The use of `=`
    tells Python to modify the value of `run_total`.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this modification get made in the directory or the heap?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Since basic data values are stored only in the directory, this update modifies
    the contents of the directory. The heap isn‚Äôt involved:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This process continues: Python advances `num` to the next list element'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: then modifies the value of `run_total`
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This process continues until all of the list elements have been processed.
    When the for-loop ends, the directory contents are:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are two takeaways from this example:'
  prefs: []
  type: TYPE_NORMAL
- en: When we use `=` to update the value associated with a variable, the variable‚Äôs
    entry in the directory changes to reflect the new value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`For` loops introduce a name into the directory (the one the programmer chose
    to refer to the individual list elements). As the loop progresses, Python updates
    the value associated with that name to refer to each successive element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Draw the sequence of directory contents for the following program:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Draw the sequence of directory contents for the following program:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: 13.1.2¬†Variable Mutation and Aliasing[üîó](#(part._var-mut-aliasing) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Mutating Structures](mutating-structures.html), we saw how a statement
    of the form `elena.acct.balance = 500` resulted in a change to `jorge.acct.balance`.
    Does this same effect occur if we update the value of a variable directly, rather
    than a field? Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do the directory and heap look like after running this code?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Since `x` and `y` are assigned basic values, there are no values in the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If we now evaluate `y = 3`, does the value of `x` change?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It does not. The value associated with `y` in the directory changes, but there
    is no connection between `x` and `y` in the directory. The statement `x = y` says
    ‚Äúget the value of `y` and associate it with `x` in the directory‚Äù. Immediately
    after this statement, `y` and `x` refer to the same value, but this relationship
    is neither tracked nor maintained. If we associate either variable with a new
    value, as we do with `y = 3`, the directory entry for that variable‚Äî<wbr>and only
    the directory entry for that variable‚Äî<wbr>are changed to reflect the new value.
    Thus, the directory after we evaluate `y = 3` appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This example highlights that aliasing occurs only when two variables refer to
    the same piece of data with components, not when variables refer to basic data.
    This is because data with components are stored in the heap, with heap address
    stored in the directory. Note, though, that uses of `varname = ...` still affect
    the directory, even when the values are data with components.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, what is the value of `ac2.balance`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the directory and heap contents for this program and check your prediction.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: All three of these lines results in changes in the directory; the first two
    result in changes in the heap, but only because we made new pieces of data. `ac1`
    and `ac2` are alises immediately after running the second line, but the third
    line breaks that relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, what is the value of `ac3.balance`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the directory and heap contents for this program and check your prediction.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since the value of `savings` is stored in `ac3.balance`, and not the name `savings`
    itself, updating the value of `savings` on the third line does not affect `ac3.balance`.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1.3¬†Mutating Variables versus Mutating Data Fields[üîó](#(part._.Mutating_.Variables_versus_.Mutating_.Data_.Fields)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We‚Äôve now seen two different forms of updates in programs: updates to fields
    of structured data in [Mutating Structures](mutating-structures.html), and updates
    to the values associated with names when computing over lists with `for` loops.
    At a quick glance, these two forms of update look similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Both use the `=` operator and compute a new value on the right side. The left
    sides, however, are subtly different: one is a field within structured data, while
    the other is a name in the directory. This difference turns out to be significant:
    the first form changes a value stored in the heap but leaves the directory unchanged,
    while the second updates the directory but leaves the heap unchanged.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you might not appreciate why this difference is significant.
    But for now, let‚Äôs summarize how each of these forms impacts each of the directory
    and the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategy: Rules for updating the directory and the heap'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Summarizing, the rules for how the directory and memory update are as follows:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: We add to the heap when a data constructor is used
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: We update the heap when a field of existing data is reassigned
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: We add to the directory when a name is used for the first time (this includes
    parameters and internal variables when a function is called)
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: We update the directory when a name that is already in the directory is subsequently
    assigned a new value)
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, what is the value of `ac3.balance`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the directory and heap contents for this program and check your prediction.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This example combines updates to variables and updates to fields. On the third
    line, `ac2` and `ac3` refer to the same address in the heap (which contains the
    `Account` with id `8728`. Immediately after updating `ac2.balance` on the fourth
    line, the balance in both `ac2` and `ac3` is 500\. Line six, however, creates
    a new `Account` in the heap and updates the directory to have `ac2` refer to that
    new `Account`. From that point on, `ac2` and `ac3` refer to different accounts,
    so the update to the balance in `ac2` on the seventh line does not affect `ac3`.
  prefs: []
  type: TYPE_NORMAL
- en: This example illustrates the subtleties and impacts of different uses of `=`.
    Programs behave differently depending on whether the left side of the `=` is a
    variable name or a field reference, and on whether the right side is basic data
    or data with components. We will continue to work with these various combinations
    to build your understanding of when and how to use each one.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1.4¬†Mutating Parameters in Function Calls[üîó](#(part._.Mutating_.Parameters_in_.Function_.Calls)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Function Composition and the Directory](Conditionals_and_Booleans.html#%28part._func-comp-directory%29),
    we showed how function calls create their own local directory segments to store
    any names that get introduced while running the function. Now that we have the
    ability to update the values associated with variables, we should revisit this
    topic to understand what happens when these updates occur within functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs use these two functions in a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the values of `x` and `a` when the program has finished?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let‚Äôs draw out the directory and heap for this program.
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to distinguish local directories from the global one ‚Äì easiest
    for now might be to add a form for local-env-with-heap that uses the label ‚ÄúLocal
    Directory (fun name)‚Äù.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the first two lines but before the function calls, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`15`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1014
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1014:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calling `add10` creates a local directory containing the name of the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`15`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1014:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Wait ‚Äì why is the heap listed alongside the local directory? Only the directory
    gets localized during function calls. The same heap is used at all times.
  prefs: []
  type: TYPE_NORMAL
- en: The body of `add10` now updates the value of `num` in the directory to 25\.
    This does not affect the value of `x` in the top-level directory, for the same
    reasons we explained in [Variable Mutation and Aliasing](#%28part._var-mut-aliasing%29)
    regarding the lack of aliasing between variables that refer to basic data. Thus,
    once the function finishes and the local directory is deleted, the value associated
    with `x` is unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let‚Äôs evaluate the call `deposit10(a)`. As with `add10`, we create a local
    directory and create an entry for the parameter. What gets associated with that
    parameter in the directory, however?
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1014
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1014:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why didn‚Äôt we create a new `Account` datum when we made the function call?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Remember our rule for when we create new data in the heap: we only create heap
    data when we explicitly use a constructor. The function call does not involve
    creating a new `Account`. Whatever is associated with the name `a` gets associated
    with the parameter name `ac`. In other words, we have created an alias between
    `a` and `ac`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the body of `deposit10`, we update the balance of `ac`, which is also the
    balance of `a` due to the aliasing. Since there is no local heap, when the function
    call is over, the new balance persists in `a`.
  prefs: []
  type: TYPE_NORMAL
- en: All we‚Äôve done here is put together pieces that we‚Äôve already seen, just in
    a new context. We‚Äôre passing parameters and updating either the (local) directory
    or the heap according to how we have used `=`. But this example highlights a detail
    that initially confuses many people when they start writing functions that update
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategy: Updating Values within Functions'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you want a function to update a value and have that update persist after
    the function completes, you must put that value inside a piece of data. You cannot
    have it be basic data associated with a variable name.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 13.1.5¬†Mutating Top-Level Variables within Functions[üîó](#(part._mut-top-level-vars-in-func)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let‚Äôs return to our banking example to illustrate a situation where the ability
    to update variables is extremely useful. Consider our current process for creating
    new accounts in the bank by looking at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Notice that each time we create an `Account` we have to take care to increase
    the id number? What if we made a typo or accidentally forgot to do this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now we‚Äôd have multiple accounts with the same ID number, when we really need
    these numbers to be unique across all accounts. To avoid such problems, we should
    instead have a function for creating accounts that takes the initial balance as
    input and uses a guaranteed-unique ID number.
  prefs: []
  type: TYPE_NORMAL
- en: 'How might we write such a function? The challenge is to be able to generate
    unique ID numbers each time. What if we used a variable to store the next available
    ID number, updating it each time we created a new account? That function might
    look at follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs run this program, creating new accounts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Copy this code into Python and run it. Check that each of `ac5`, `ac6`, and
    `ac7` have unique ID numbers.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happened? All three of these have the same ID of `8000`. It looks like
    our update to `nextID` just didn‚Äôt work. Actually, it did work, but to understand
    how, we have to look at what happened in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the memory diagram for this example.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'After we set up `nextID` and define the function, our memory diagram appears
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`8000`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let‚Äôs evaluate `ac5 = create_acct(435)`. We call `create_acct`, which yields
    the following local directory after creating the `Account` but before updating
    `nextID`.
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`435`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1015
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1015:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think happens when we run `nextID = nextID + 1`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let‚Äôs run this carefully. Python first evaluates the right side of the `=` (`nextID
    + 1`). `nextID` is not in the local directory, so Python retrieves its value (`8000`)
    from the top-level directory. Thus, this computation becomes `nextID = 8001`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question here is how Python treats `nextID = 8001`: we currently have both
    the local directory for the function call and the top-level directory. Which one
    should get the new value of `nextID`? Since the local directory is active, Python
    sets the value of `nextID` there.'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`435`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1015
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`8001`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1015:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let‚Äôs repeat that: Python computed `nextID + 1` using the `nextID` value from
    the top-level directory since there was no value for `nextID` in the local directory.
    But the setting of the value of `nextID` could and did occur in the local directory.
    Thus, when `create_acct` finishes, the value of `nextID` in the top-level directory
    is unchanged. As a result, all of the accounts get the same value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The computuation we are trying to do‚Äî<wbr>updating the top-level variable‚Äî<wbr>is
    just fine. The problem is that Python (reasonably) defaults to the local directory.
    To make this work, we need to tell Python that we want to make updates to `next_id`
    in the top-level directory. Here‚Äôs the version of `create_acct` that does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `global` keyword tells Python to make updates to the given variable in the
    top-level directory, not the local directory. Once we make this modification,
    each account we create will get a unique ID number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Responsible Computing: Keeping IDs Unpredictable'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'While this general pattern of generating unique IDs works, in practice we shouldn‚Äôt
    use consecutive numbers. Consecutive numbers are guessable: if there is an account
    `8000` there must be an account `8001`, and so on. Guessable account numbers could
    make it easier for someone who keeps trying to guess valid IDs to use to log into
    websites or otherwise access information.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Instead, we would use a computation that is less predictable than ‚Äúadd 1‚Äù when
    storing the `nextID` value. For now, the pattern we have shown you is fine. If
    you were building a real system, however, you‚Äôd want to make that computation
    a bit more sophisticated.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 13.1.6¬†The Many Roles of Variables[üîó](#(part._.The_.Many_.Roles_of_.Variables)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At this point, we have used the single coding construct of a variable in the
    directory for multiple purposes. It‚Äôs worth stepping back and calling those out
    explicitly. In general, variables serve one of the following purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Tracking progress of a computation (e.g., the running value of a result in a
    `for`-loop)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maintaining information across multiple calls to a single function (e.g., the
    `next-id` variable)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Naming a local or intermediate value in a computation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each of these uses involves a different programming pattern. The first creates
    a variable locally within a function. The second two create top-level variables
    and require using `global` in functions that modify the contents. The third is
    different from the second, however, in that the third is only meant to be used
    by a single function. Ideally, there would be a way to not expose the variable
    to all functions in the third case. Indeed, many programming languages (including
    Pyret) make it easy to do that. This is harder to achieve with introductory-level
    concepts in Python, however. The fourth is more about local names rather than
    variables, in that our code never updates the value after the variable is created.
  prefs: []
  type: TYPE_NORMAL
- en: We call out these three roles precisely because they invoke different code patterns,
    despite using the same fine-grained concept (assigning a new value to a variable).
    When you look at a new programming problem, you can ask yourself whether the problem
    involves one of these purposes, and use that to guide your choice of pattern to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1.1¬†Mutating Variables in Memory[üîó](#(part._mutating-vars-memory) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have introduced the idea of the heap, let‚Äôs revisit our use of
    a variable to compute the sum of elements in a list. Here again is the code we
    wrote for this earlier (in [Introducing `For` Loops](intro-python.html#%28part._python-for-loops%29)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Let‚Äôs see how the directory and heap update as we run this code. In [Basic Data
    and the Heap](mutating-structures.html#%28part._basic-data-heap%29), we pointed
    out that basic data (such as numbers, strings, and booleans) don‚Äôt get put in
    the heap because they have no internal structure. Those values are stored in the
    directory itself. Therefore, the initial value for `run_total` is stored within
    the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `for` loop also sets up a directory entry, this time for the variable `num`
    that is used to refer to the list elements. When the loop starts, `num` takes
    on the first value in the list. Thus, the directory appears as:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `for` loop, we compute a new value for `run_total`. The use of `=`
    tells Python to modify the value of `run_total`.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this modification get made in the directory or the heap?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Since basic data values are stored only in the directory, this update modifies
    the contents of the directory. The heap isn‚Äôt involved:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This process continues: Python advances `num` to the next list element'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: then modifies the value of `run_total`
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This process continues until all of the list elements have been processed.
    When the for-loop ends, the directory contents are:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are two takeaways from this example:'
  prefs: []
  type: TYPE_NORMAL
- en: When we use `=` to update the value associated with a variable, the variable‚Äôs
    entry in the directory changes to reflect the new value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`For` loops introduce a name into the directory (the one the programmer chose
    to refer to the individual list elements). As the loop progresses, Python updates
    the value associated with that name to refer to each successive element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Draw the sequence of directory contents for the following program:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Draw the sequence of directory contents for the following program:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: 13.1.2¬†Variable Mutation and Aliasing[üîó](#(part._var-mut-aliasing) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Mutating Structures](mutating-structures.html), we saw how a statement
    of the form `elena.acct.balance = 500` resulted in a change to `jorge.acct.balance`.
    Does this same effect occur if we update the value of a variable directly, rather
    than a field? Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do the directory and heap look like after running this code?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Since `x` and `y` are assigned basic values, there are no values in the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If we now evaluate `y = 3`, does the value of `x` change?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It does not. The value associated with `y` in the directory changes, but there
    is no connection between `x` and `y` in the directory. The statement `x = y` says
    ‚Äúget the value of `y` and associate it with `x` in the directory‚Äù. Immediately
    after this statement, `y` and `x` refer to the same value, but this relationship
    is neither tracked nor maintained. If we associate either variable with a new
    value, as we do with `y = 3`, the directory entry for that variable‚Äî<wbr>and only
    the directory entry for that variable‚Äî<wbr>are changed to reflect the new value.
    Thus, the directory after we evaluate `y = 3` appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This example highlights that aliasing occurs only when two variables refer to
    the same piece of data with components, not when variables refer to basic data.
    This is because data with components are stored in the heap, with heap address
    stored in the directory. Note, though, that uses of `varname = ...` still affect
    the directory, even when the values are data with components.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, what is the value of `ac2.balance`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the directory and heap contents for this program and check your prediction.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: All three of these lines results in changes in the directory; the first two
    result in changes in the heap, but only because we made new pieces of data. `ac1`
    and `ac2` are alises immediately after running the second line, but the third
    line breaks that relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, what is the value of `ac3.balance`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the directory and heap contents for this program and check your prediction.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since the value of `savings` is stored in `ac3.balance`, and not the name `savings`
    itself, updating the value of `savings` on the third line does not affect `ac3.balance`.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1.3¬†Mutating Variables versus Mutating Data Fields[üîó](#(part._.Mutating_.Variables_versus_.Mutating_.Data_.Fields)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We‚Äôve now seen two different forms of updates in programs: updates to fields
    of structured data in [Mutating Structures](mutating-structures.html), and updates
    to the values associated with names when computing over lists with `for` loops.
    At a quick glance, these two forms of update look similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Both use the `=` operator and compute a new value on the right side. The left
    sides, however, are subtly different: one is a field within structured data, while
    the other is a name in the directory. This difference turns out to be significant:
    the first form changes a value stored in the heap but leaves the directory unchanged,
    while the second updates the directory but leaves the heap unchanged.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you might not appreciate why this difference is significant.
    But for now, let‚Äôs summarize how each of these forms impacts each of the directory
    and the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategy: Rules for updating the directory and the heap'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Summarizing, the rules for how the directory and memory update are as follows:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: We add to the heap when a data constructor is used
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: We update the heap when a field of existing data is reassigned
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: We add to the directory when a name is used for the first time (this includes
    parameters and internal variables when a function is called)
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: We update the directory when a name that is already in the directory is subsequently
    assigned a new value)
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the following code, what is the value of `ac3.balance`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the directory and heap contents for this program and check your prediction.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This example combines updates to variables and updates to fields. On the third
    line, `ac2` and `ac3` refer to the same address in the heap (which contains the
    `Account` with id `8728`. Immediately after updating `ac2.balance` on the fourth
    line, the balance in both `ac2` and `ac3` is 500\. Line six, however, creates
    a new `Account` in the heap and updates the directory to have `ac2` refer to that
    new `Account`. From that point on, `ac2` and `ac3` refer to different accounts,
    so the update to the balance in `ac2` on the seventh line does not affect `ac3`.
  prefs: []
  type: TYPE_NORMAL
- en: This example illustrates the subtleties and impacts of different uses of `=`.
    Programs behave differently depending on whether the left side of the `=` is a
    variable name or a field reference, and on whether the right side is basic data
    or data with components. We will continue to work with these various combinations
    to build your understanding of when and how to use each one.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1.4¬†Mutating Parameters in Function Calls[üîó](#(part._.Mutating_.Parameters_in_.Function_.Calls)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Function Composition and the Directory](Conditionals_and_Booleans.html#%28part._func-comp-directory%29),
    we showed how function calls create their own local directory segments to store
    any names that get introduced while running the function. Now that we have the
    ability to update the values associated with variables, we should revisit this
    topic to understand what happens when these updates occur within functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs use these two functions in a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the values of `x` and `a` when the program has finished?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let‚Äôs draw out the directory and heap for this program.
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to distinguish local directories from the global one ‚Äì easiest
    for now might be to add a form for local-env-with-heap that uses the label ‚ÄúLocal
    Directory (fun name)‚Äù.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the first two lines but before the function calls, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`15`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1014
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1014:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calling `add10` creates a local directory containing the name of the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`15`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1014:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Wait ‚Äì why is the heap listed alongside the local directory? Only the directory
    gets localized during function calls. The same heap is used at all times.
  prefs: []
  type: TYPE_NORMAL
- en: The body of `add10` now updates the value of `num` in the directory to 25\.
    This does not affect the value of `x` in the top-level directory, for the same
    reasons we explained in [Variable Mutation and Aliasing](#%28part._var-mut-aliasing%29)
    regarding the lack of aliasing between variables that refer to basic data. Thus,
    once the function finishes and the local directory is deleted, the value associated
    with `x` is unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let‚Äôs evaluate the call `deposit10(a)`. As with `add10`, we create a local
    directory and create an entry for the parameter. What gets associated with that
    parameter in the directory, however?
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1014
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1014:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why didn‚Äôt we create a new `Account` datum when we made the function call?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Remember our rule for when we create new data in the heap: we only create heap
    data when we explicitly use a constructor. The function call does not involve
    creating a new `Account`. Whatever is associated with the name `a` gets associated
    with the parameter name `ac`. In other words, we have created an alias between
    `a` and `ac`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the body of `deposit10`, we update the balance of `ac`, which is also the
    balance of `a` due to the aliasing. Since there is no local heap, when the function
    call is over, the new balance persists in `a`.
  prefs: []
  type: TYPE_NORMAL
- en: All we‚Äôve done here is put together pieces that we‚Äôve already seen, just in
    a new context. We‚Äôre passing parameters and updating either the (local) directory
    or the heap according to how we have used `=`. But this example highlights a detail
    that initially confuses many people when they start writing functions that update
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategy: Updating Values within Functions'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you want a function to update a value and have that update persist after
    the function completes, you must put that value inside a piece of data. You cannot
    have it be basic data associated with a variable name.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 13.1.5¬†Mutating Top-Level Variables within Functions[üîó](#(part._mut-top-level-vars-in-func)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let‚Äôs return to our banking example to illustrate a situation where the ability
    to update variables is extremely useful. Consider our current process for creating
    new accounts in the bank by looking at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Notice that each time we create an `Account` we have to take care to increase
    the id number? What if we made a typo or accidentally forgot to do this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Now we‚Äôd have multiple accounts with the same ID number, when we really need
    these numbers to be unique across all accounts. To avoid such problems, we should
    instead have a function for creating accounts that takes the initial balance as
    input and uses a guaranteed-unique ID number.
  prefs: []
  type: TYPE_NORMAL
- en: 'How might we write such a function? The challenge is to be able to generate
    unique ID numbers each time. What if we used a variable to store the next available
    ID number, updating it each time we created a new account? That function might
    look at follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs run this program, creating new accounts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Copy this code into Python and run it. Check that each of `ac5`, `ac6`, and
    `ac7` have unique ID numbers.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happened? All three of these have the same ID of `8000`. It looks like
    our update to `nextID` just didn‚Äôt work. Actually, it did work, but to understand
    how, we have to look at what happened in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Draw the memory diagram for this example.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'After we set up `nextID` and define the function, our memory diagram appears
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`8000`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let‚Äôs evaluate `ac5 = create_acct(435)`. We call `create_acct`, which yields
    the following local directory after creating the `Account` but before updating
    `nextID`.
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`435`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1015
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1015:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think happens when we run `nextID = nextID + 1`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let‚Äôs run this carefully. Python first evaluates the right side of the `=` (`nextID
    + 1`). `nextID` is not in the local directory, so Python retrieves its value (`8000`)
    from the top-level directory. Thus, this computation becomes `nextID = 8001`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question here is how Python treats `nextID = 8001`: we currently have both
    the local directory for the function call and the top-level directory. Which one
    should get the new value of `nextID`? Since the local directory is active, Python
    sets the value of `nextID` there.'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`435`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1015
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†`8001`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1015:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let‚Äôs repeat that: Python computed `nextID + 1` using the `nextID` value from
    the top-level directory since there was no value for `nextID` in the local directory.
    But the setting of the value of `nextID` could and did occur in the local directory.
    Thus, when `create_acct` finishes, the value of `nextID` in the top-level directory
    is unchanged. As a result, all of the accounts get the same value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The computuation we are trying to do‚Äî<wbr>updating the top-level variable‚Äî<wbr>is
    just fine. The problem is that Python (reasonably) defaults to the local directory.
    To make this work, we need to tell Python that we want to make updates to `next_id`
    in the top-level directory. Here‚Äôs the version of `create_acct` that does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The `global` keyword tells Python to make updates to the given variable in the
    top-level directory, not the local directory. Once we make this modification,
    each account we create will get a unique ID number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Responsible Computing: Keeping IDs Unpredictable'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'While this general pattern of generating unique IDs works, in practice we shouldn‚Äôt
    use consecutive numbers. Consecutive numbers are guessable: if there is an account
    `8000` there must be an account `8001`, and so on. Guessable account numbers could
    make it easier for someone who keeps trying to guess valid IDs to use to log into
    websites or otherwise access information.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Instead, we would use a computation that is less predictable than ‚Äúadd 1‚Äù when
    storing the `nextID` value. For now, the pattern we have shown you is fine. If
    you were building a real system, however, you‚Äôd want to make that computation
    a bit more sophisticated.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 13.1.6¬†The Many Roles of Variables[üîó](#(part._.The_.Many_.Roles_of_.Variables)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At this point, we have used the single coding construct of a variable in the
    directory for multiple purposes. It‚Äôs worth stepping back and calling those out
    explicitly. In general, variables serve one of the following purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Tracking progress of a computation (e.g., the running value of a result in a
    `for`-loop)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maintaining information across multiple calls to a single function (e.g., the
    `next-id` variable)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Naming a local or intermediate value in a computation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each of these uses involves a different programming pattern. The first creates
    a variable locally within a function. The second two create top-level variables
    and require using `global` in functions that modify the contents. The third is
    different from the second, however, in that the third is only meant to be used
    by a single function. Ideally, there would be a way to not expose the variable
    to all functions in the third case. Indeed, many programming languages (including
    Pyret) make it easy to do that. This is harder to achieve with introductory-level
    concepts in Python, however. The fourth is more about local names rather than
    variables, in that our code never updates the value after the variable is created.
  prefs: []
  type: TYPE_NORMAL
- en: We call out these three roles precisely because they invoke different code patterns,
    despite using the same fine-grained concept (assigning a new value to a variable).
    When you look at a new programming problem, you can ask yourself whether the problem
    involves one of these purposes, and use that to guide your choice of pattern to
    use.
  prefs: []
  type: TYPE_NORMAL
