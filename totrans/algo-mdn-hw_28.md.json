["```cpp\nconst int N = 1e6, T = 1e9 / N; int a[N], b[N];   void timeit(int (*f)(int, int)) {  clock_t start = clock();   int checksum = 0;   for (int t = 0; t < T; t++) for (int i = 0; i < n; i++) checksum ^= f(a[i], b[i]);  float seconds = float(clock() - start) / CLOCKS_PER_SEC;   printf(\"checksum: %d\\n\", checksum); printf(\"%.2f ns per call\\n\", 1e9 * seconds / N / T); }   int main() {  for (int i = 0; i < N; i++) a[i] = rand(), b[i] = rand();  timeit(std::gcd); timeit(my_gcd); timeit(my_another_gcd); // ...  return 0; } \n```", "```cpp\nint gcd(int a, int b); // to be implemented  // for data structures, you also need to create a setup function // (unless the same preprocessing step for all versions would suffice)  int main() {  const int N = 1e6, T = 1e9 / N; int a[N], b[N]; // careful: local arrays are allocated on the stack and may cause stack overflow // for large arrays, allocate with \"new\" or create a global array  for (int i = 0; i < N; i++) a[i] = rand(), b[i] = rand();   int checksum = 0;   clock_t start = clock();   for (int t = 0; t < T; t++) for (int i = 0; i < n; i++) checksum += gcd(a[i], b[i]);  float seconds = float(clock() - start) / CLOCKS_PER_SEC;   printf(\"%d\\n\", checksum); printf(\"%.2f ns per call\\n\", 1e9 * seconds / N / T);  return 0; } \n```", "```cpp\n#include \"gcd.hh\"  int gcd(int a, int b) {  if (b == 0) return a; else return gcd(b, a % b); } \n```", "```cpp\nint main(int argc, char* argv[]) {  int N = (argc > 1 ? atoi(argv[1]) : 1e6); const int T = 1e9 / N;   // ... } \n```", "```cpp\n#ifndef N #define N 1000000 #endif  const int T = 1e9 / N; \n```", "```cpp\ncompile = g++ -std=c++17 -O3 -march=native -Wall   %: %.cc gcd.hh  $(compile) $< -o $@   %.s: %.cc gcd.hh  $(compile) -S -fverbose-asm $< -o $@   %.run: %  @./$<   .PHONY: %.run \n```", "```cpp\ndef bench(source, n=2**20):  !make -s {source} if _exit_code != 0: raise Exception(\"Compilation failed\") res = !./{source} {n} {q} duration = float(res[0].split()[0]) return duration \n```", "```cpp\nns = list(int(1.17**k) for k in range(30, 60)) baseline = [bench('std_lower_bound', n=n) for n in ns] results = [bench('my_binary_search', n=n) for n in ns]   # plotting relative speedup for different array sizes import matplotlib.pyplot as plt   plt.plot(ns, [x / y for x, y in zip(baseline, results)]) plt.show() \n```"]