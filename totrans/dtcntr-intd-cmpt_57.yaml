- en: 18.1Â Representing Sets as ListsğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18.1 è¡¨ç¤ºé›†åˆä¸ºåˆ—è¡¨ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/sets-from-lists.html](https://dcic-world.org/2025-08-27/sets-from-lists.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/sets-from-lists.html](https://dcic-world.org/2025-08-27/sets-from-lists.html)
- en: '| Â Â Â Â [18.1.1Â Representation Choices](#%28part._.Representation_.Choices%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| 18.1.1 è¡¨ç¤ºé€‰æ‹©ï¼ˆ#(part._.Representation_.Choices)ï¼‰ |'
- en: '| Â Â Â Â [18.1.2Â Time Complexity](#%28part._.Time_.Complexity%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 18.1.2 æ—¶é—´å¤æ‚åº¦ï¼ˆ#(part._.Time_.Complexity)ï¼‰ |'
- en: '| Â Â Â Â [18.1.3Â Choosing Between Representations](#%28part._choosing-set-reps%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| 18.1.3 åœ¨è¡¨ç¤ºä¹‹é—´é€‰æ‹©ï¼ˆ#(part._choosing-set-reps)ï¼‰ |'
- en: '| Â Â Â Â [18.1.4Â Other Operations](#%28part._.Other_.Operations%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 18.1.4 å…¶ä»–æ“ä½œï¼ˆ#(part._.Other_.Operations)ï¼‰ |'
- en: Earlier [[Sets as Collective Data](Collections_of_Structured_Data.html#%28part._sets-as-collections%29)]
    we introduced sets. Recall that the elements of a set have no specific order,
    and ignore duplicates.If these ideas are not familiar, please read [Sets as Collective
    Data](Collections_of_Structured_Data.html#%28part._sets-as-collections%29), since
    they will be important when discussing the representation of sets. At that time
    we relied on Pyretâ€™s built-in representation of sets. Now we will discuss how
    to build sets for ourselves. In what follows, we will focus only on sets of numbers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[[é›†åˆä½œä¸ºé›†ä½“æ•°æ®](Collections_of_Structured_Data.html#(part._sets-as-collections))]ä¸­ï¼Œæˆ‘ä»¬ä»‹ç»äº†é›†åˆã€‚å›æƒ³ä¸€ä¸‹ï¼Œé›†åˆçš„å…ƒç´ æ²¡æœ‰ç‰¹å®šçš„é¡ºåºï¼Œå¹¶ä¸”å¿½ç•¥é‡å¤ã€‚å¦‚æœè¿™äº›æ¦‚å¿µä¸ç†Ÿæ‚‰ï¼Œè¯·é˜…è¯»[é›†åˆä½œä¸ºé›†ä½“æ•°æ®](Collections_of_Structured_Data.html#(part._sets-as-collections))ï¼Œå› ä¸ºå®ƒä»¬åœ¨è®¨è®ºé›†åˆè¡¨ç¤ºæ—¶å°†éå¸¸é‡è¦ã€‚å½“æ—¶æˆ‘ä»¬ä¾èµ–äºPyretçš„å†…ç½®é›†åˆè¡¨ç¤ºã€‚ç°åœ¨æˆ‘ä»¬å°†è®¨è®ºå¦‚ä½•ä¸ºè‡ªå·±æ„å»ºé›†åˆã€‚åœ¨ä»¥ä¸‹å†…å®¹ä¸­ï¼Œæˆ‘ä»¬å°†ä»…å…³æ³¨æ•°å­—é›†åˆã€‚
- en: We will start by discussing how to represent sets using lists. Intuitively,
    using lists to represent sets of data seems problematic, because lists respect
    both order and duplication. For instance,
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†é¦–å…ˆè®¨è®ºå¦‚ä½•ä½¿ç”¨åˆ—è¡¨è¡¨ç¤ºé›†åˆã€‚ç›´è§‚ä¸Šçœ‹ï¼Œä½¿ç”¨åˆ—è¡¨æ¥è¡¨ç¤ºæ•°æ®é›†åˆä¼¼ä¹æœ‰é—®é¢˜ï¼Œå› ä¸ºåˆ—è¡¨æ—¢å°Šé‡é¡ºåºåˆå…è®¸é‡å¤ã€‚ä¾‹å¦‚ï¼Œ
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: fails, but the corresponding sets are equal.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: å¤±è´¥ï¼Œä½†ç›¸åº”çš„é›†åˆæ˜¯ç›¸ç­‰çš„ã€‚
- en: In principle, we want sets to obey the following interface:Note that a type
    called `Set` is already built into Pyret, so below we will use the name `LSet`
    for a set represented as a list.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åŸåˆ™ä¸Šï¼Œæˆ‘ä»¬å¸Œæœ›é›†åˆéµå®ˆä»¥ä¸‹æ¥å£ï¼šè¯·æ³¨æ„ï¼Œåä¸º`Set`çš„ç±»å‹å·²ç»å†…ç½®åˆ°Pyretä¸­ï¼Œå› æ­¤ä»¥ä¸‹æˆ‘ä»¬å°†ä½¿ç”¨`LSet`æ¥è¡¨ç¤ºåˆ—è¡¨è¡¨ç¤ºçš„é›†åˆã€‚
- en: <set-operations> ::=
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <set-operations> ::=
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We may also find it also useful to have functions such as
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½è¿˜ä¼šå‘ç°ä»¥ä¸‹å‡½æ•°ä¹Ÿå¾ˆæœ‰ç”¨ï¼š
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: which, combined with `mt-set`, easily gives us a `to-set` function.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸`mt-set`ç»“åˆï¼Œå¯ä»¥å¾ˆå®¹æ˜“åœ°ç»™æˆ‘ä»¬ä¸€ä¸ª`to-set`å‡½æ•°ã€‚
- en: 'Sets can contain many kinds of values, but not necessarily any kind: we need
    to be able to check for two values being equal (which is a requirement for a set,
    but not for a list!), which canâ€™t be done with all values (such as functions).
    We discuss the nuances of this elsewhere [[Equality and Ordering](orderability.html#%28part._eq-ord%29)].
    For now, we can ignore these issues by focusing on sets of (non-rough)numbers.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: é›†åˆå¯ä»¥åŒ…å«è®¸å¤šç§ç±»çš„å€¼ï¼Œä½†ä¸ä¸€å®šæ˜¯ä»»ä½•ä¸€ç§ï¼šæˆ‘ä»¬éœ€è¦èƒ½å¤Ÿæ£€æŸ¥ä¸¤ä¸ªå€¼æ˜¯å¦ç›¸ç­‰ï¼ˆè¿™æ˜¯é›†åˆçš„è¦æ±‚ï¼Œä½†ä¸æ˜¯åˆ—è¡¨çš„è¦æ±‚ï¼ï¼‰ï¼Œè€Œå¹¶éæ‰€æœ‰å€¼ï¼ˆå¦‚å‡½æ•°ï¼‰éƒ½å¯ä»¥è¿™æ ·åšã€‚æˆ‘ä»¬å°†åœ¨å…¶ä»–åœ°æ–¹è®¨è®ºè¿™ä¸€é—®é¢˜çš„ç»†å¾®å·®åˆ«[[ç­‰ä»·ä¸æ’åº](orderability.html#(part._eq-ord))]ã€‚ç›®å‰ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸“æ³¨äºï¼ˆéç²—ç³™çš„ï¼‰æ•°å­—é›†åˆæ¥å¿½ç•¥è¿™äº›é—®é¢˜ã€‚
- en: 18.1.1Â Representation Choices[ğŸ”—](#(part._.Representation_.Choices) "Link to
    here")
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.1.1 è¡¨ç¤ºé€‰æ‹©[ğŸ”—](#(part._.Representation_.Choices) "é“¾æ¥åˆ°æ­¤å¤„")
- en: The empty list can stand in for the empty setâ€”<wbr>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ç©ºåˆ—è¡¨å¯ä»¥ä»£è¡¨ç©ºé›†åˆâ€”<wbr>
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: â€”<wbr>and we can presumably define `size` as
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: â€”<wbr>æˆ‘ä»¬å¯ä»¥å‡è®¾å®šä¹‰`size`ä¸º
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, this [â˜› reduction](glossary.html#%28elem._glossary-reduction%29) (of
    sets to lists) can be dangerous:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¿™ç§[â˜›å‡å°‘](glossary.html#(elem._glossary-reduction))ï¼ˆå°†é›†åˆå‡å°‘åˆ°åˆ—è¡¨ï¼‰å¯èƒ½æ˜¯å±é™©çš„ï¼š
- en: There is a subtle difference between lists and sets. The list
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åˆ—è¡¨å’Œé›†åˆä¹‹é—´å­˜åœ¨ç»†å¾®çš„å·®åˆ«ã€‚åˆ—è¡¨
- en: '[PRE5]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: is not the same as
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å¹¶ä¸ç›¸åŒ
- en: '[PRE6]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'because the first list has length two whereas the second has length one. Treated
    as a set, however, the two are the same: they both have size one. Thus, our implementation
    of `size` above is incorrect if we donâ€™t take into account duplicates (either
    during insertion or while computing the size).'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å› ä¸ºç¬¬ä¸€ä¸ªåˆ—è¡¨é•¿åº¦ä¸ºä¸¤ä¸ªï¼Œè€Œç¬¬äºŒä¸ªåˆ—è¡¨é•¿åº¦ä¸ºä¸€ä¸ªã€‚ç„¶è€Œï¼Œå¦‚æœå°†å®ƒä»¬è§†ä¸ºé›†åˆï¼Œåˆ™ä¸¤è€…ç›¸åŒï¼šå®ƒä»¬çš„å¤§å°éƒ½æ˜¯ä¸€ã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬ä¸è€ƒè™‘é‡å¤ï¼ˆæ— è®ºæ˜¯åœ¨æ’å…¥æ—¶è¿˜æ˜¯åœ¨è®¡ç®—å¤§å°æ—¶ï¼‰ï¼Œæˆ‘ä»¬ä¸Šé¢çš„`size`å®ç°æ˜¯ä¸æ­£ç¡®çš„ã€‚
- en: We might falsely make assumptions about the order in which elements are retrieved
    from the set due to the ordering guaranteed provided by the underlying list representation.
    This might hide bugs that we donâ€™t discover until we change the representation.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ç”±äºåº•å±‚åˆ—è¡¨è¡¨ç¤ºæä¾›çš„é¡ºåºä¿è¯ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šé”™è¯¯åœ°å‡è®¾ä»é›†åˆä¸­æ£€ç´¢å…ƒç´ é¡ºåºã€‚è¿™å¯èƒ½ä¼šéšè—æˆ‘ä»¬ç›´åˆ°æ›´æ”¹è¡¨ç¤ºæ—¶æ‰å‘ç°çš„bugã€‚
- en: We might have chosen a set representation because we didnâ€™t need to care about
    order, and expected lots of duplicate items. A list representation might store
    all the duplicates, resulting in significantly more memory use (and slower programs)
    than we expected.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é€‰æ‹©é›†åˆè¡¨ç¤ºå¯èƒ½æ˜¯å› ä¸ºæˆ‘ä»¬ä¸éœ€è¦å…³å¿ƒé¡ºåºï¼Œå¹¶ä¸”é¢„æœŸä¼šæœ‰å¾ˆå¤šé‡å¤é¡¹ã€‚åˆ—è¡¨è¡¨ç¤ºå¯èƒ½å­˜å‚¨æ‰€æœ‰é‡å¤é¡¹ï¼Œè¿™ä¼šå¯¼è‡´æ¯”é¢„æœŸæ›´å¤šçš„å†…å­˜ä½¿ç”¨ï¼ˆä»¥åŠæ›´æ…¢çš„ç¨‹åºï¼‰ã€‚
- en: To avoid these perils, we have to be precise about how weâ€™re going to use lists
    to represent sets. One key question (but not the only one, as weâ€™ll soon see [[Choosing
    Between Representations](#%28part._choosing-set-reps%29)]) is what to do about
    duplicates. One possibility is for `insert` to check whether an element is already
    in the set and, if so, leave the representation unchanged; this incurs a cost
    during insertion but avoids unnecessary duplication and lets us use `length` to
    implement `size`. The other option is to define `insert` as `link`â€”<wbr>literally,
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†é¿å…è¿™äº›å±é™©ï¼Œæˆ‘ä»¬å¿…é¡»ç²¾ç¡®åœ°è¯´æ˜æˆ‘ä»¬å¦‚ä½•ä½¿ç”¨åˆ—è¡¨æ¥è¡¨ç¤ºé›†åˆã€‚ä¸€ä¸ªå…³é”®é—®é¢˜ï¼ˆä½†ä¸æ˜¯å”¯ä¸€çš„é—®é¢˜ï¼Œå› ä¸ºæˆ‘ä»¬å¾ˆå¿«å°±ä¼šçœ‹åˆ° [[é€‰æ‹©è¡¨ç¤ºæ³•](#%28part._choosing-set-reps%29)]ï¼‰æ˜¯å…³äºé‡å¤é¡¹çš„å¤„ç†ã€‚ä¸€ç§å¯èƒ½æ€§æ˜¯è®©
    `insert` æ£€æŸ¥ä¸€ä¸ªå…ƒç´ æ˜¯å¦å·²ç»åœ¨é›†åˆä¸­ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™ä¿æŒè¡¨ç¤ºä¸å˜ï¼›è¿™ä¼šåœ¨æ’å…¥æ—¶äº§ç”Ÿæˆæœ¬ï¼Œä½†å¯ä»¥é¿å…ä¸å¿…è¦çš„é‡å¤ï¼Œå¹¶å…è®¸æˆ‘ä»¬ä½¿ç”¨ `length` æ¥å®ç°
    `size`ã€‚å¦ä¸€ç§é€‰æ‹©æ˜¯å°† `insert` å®šä¹‰ä¸º `link`â€”<wbr>å®é™…ä¸Šï¼Œ
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: â€”<wbr>and have some other procedure perform the filtering of duplicates.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: â€”<wbr>å¹¶è®©å…¶ä»–ç¨‹åºæ‰§è¡Œé‡å¤é¡¹çš„è¿‡æ»¤ã€‚
- en: 18.1.2Â Time Complexity[ğŸ”—](#(part._.Time_.Complexity) "Link to here")
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.1.2 æ—¶é—´å¤æ‚åº¦[ğŸ”—](#(part._.Time_.Complexity) "é“¾æ¥è‡³æ­¤")
- en: 'What is the complexity of this representation of sets? Letâ€™s consider just
    `insert`, `is-in`, and `size`. Suppose the size of the set is \(k\) (where, to
    avoid ambiguity, we let \(k\) represent the number of distinct elements). The
    complexity of these operations depends on whether or not we store duplicates:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§é›†åˆè¡¨ç¤ºæ³•çš„å¤æ‚åº¦æ˜¯å¤šå°‘ï¼Ÿè®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹ `insert`ã€`is-in` å’Œ `size`ã€‚å‡è®¾é›†åˆçš„å¤§å°æ˜¯ \(k\)ï¼ˆä¸ºäº†é¿å…æ­§ä¹‰ï¼Œæˆ‘ä»¬è®© \(k\)
    ä»£è¡¨ä¸åŒå…ƒç´ çš„æ•°é‡ï¼‰ã€‚è¿™äº›æ“ä½œçš„å¤æ‚åº¦å–å†³äºæˆ‘ä»¬æ˜¯å¦å­˜å‚¨é‡å¤é¡¹ï¼š
- en: If we donâ€™t store duplicates, then `size` is simply `length`, which takes time
    linear in \(k\). Similarly, `is-in` only needs to traverse the list once to determine
    whether or not an element is present, which also takes time linear in \(k\). But
    `insert` needs to check whether an element is already present, which takes time
    linear in \(k\), followed by at most a constant-time operation (`link`).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ä¸å­˜å‚¨é‡å¤é¡¹ï¼Œé‚£ä¹ˆ `size` å°±æ˜¯ `length`ï¼Œå®ƒçš„æ—¶é—´å¤æ‚åº¦æ˜¯çº¿æ€§çš„ \(k\)ã€‚åŒæ ·ï¼Œ`is-in` åªéœ€è¦éå†åˆ—è¡¨ä¸€æ¬¡æ¥ç¡®å®šä¸€ä¸ªå…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Œè¿™ä¹Ÿéœ€è¦çº¿æ€§
    \(k\) çš„æ—¶é—´ã€‚ä½†æ˜¯ `insert` éœ€è¦æ£€æŸ¥ä¸€ä¸ªå…ƒç´ æ˜¯å¦å·²ç»å­˜åœ¨ï¼Œè¿™éœ€è¦çº¿æ€§ \(k\) çš„æ—¶é—´ï¼Œç„¶åæœ€å¤šæ‰§è¡Œä¸€ä¸ªå¸¸æ•°æ—¶é—´çš„æ“ä½œï¼ˆ`link`ï¼‰ã€‚
- en: 'If we do store duplicates, then `insert` is constant time: it simply `link`s
    on the new element without regard to whether it already is in the set representation.
    `is-in` traverses the list once, but the number of elements it needs to visit
    could be significantly greater than \(k\), depending on how many duplicates have
    been added. Finally, `size` needs to check whether or not each element is duplicated
    before counting it.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬å­˜å‚¨é‡å¤é¡¹ï¼Œé‚£ä¹ˆ `insert` æ˜¯å¸¸æ•°æ—¶é—´ï¼šå®ƒç®€å•åœ° `link`s åœ¨æ–°å…ƒç´ ä¸Šï¼Œè€Œä¸è€ƒè™‘å®ƒæ˜¯å¦å·²ç»åœ¨é›†åˆè¡¨ç¤ºä¸­ã€‚`is-in` éå†åˆ—è¡¨ä¸€æ¬¡ï¼Œä½†éœ€è¦è®¿é—®çš„å…ƒç´ æ•°é‡å¯èƒ½æ¯”
    \(k\) å¤§å¾—å¤šï¼Œè¿™å–å†³äºæ·»åŠ äº†å¤šå°‘é‡å¤é¡¹ã€‚æœ€åï¼Œ`size` éœ€è¦æ£€æŸ¥æ¯ä¸ªå…ƒç´ æ˜¯å¦é‡å¤ï¼Œç„¶åå†è¿›è¡Œè®¡æ•°ã€‚
- en: Do Now!
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the time complexity of `size` if the list has duplicates?
  id: totrans-39
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœåˆ—è¡¨ä¸­æœ‰é‡å¤é¡¹ï¼Œ`size` çš„æ—¶é—´å¤æ‚åº¦æ˜¯å¤šå°‘ï¼Ÿ
- en: One implementation of `size` is
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`size` çš„ä¸€ç§å®ç°æ˜¯'
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Letâ€™s now compute the complexity of the body of the function, assuming the number
    of distinct elements in `s` is \(k\) but the actual number of elements in `s`
    is \(d\), where \(d \geq k\). To compute the time to run `size` on \(d\) elements,
    \(T(d)\), we should determine the number of operations in each question and answer.
    The first question has a constant number of operations, and the first answer also
    a constant. The second question also has a constant number of operations. Its
    answer is a conditional, whose first question (`r.member(f)` needs to traverse
    the entire list, and hence has \(O([k \rightarrow d])\) operations. If it succeeds,
    we recur on something of size \(T(d-1)\); else we do the same but perform a constant
    more operations. Thus \(T(0)\) is a constant, while the recurrence (in big-Oh
    terms) is
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ¥è®¡ç®—å‡½æ•°ä½“çš„å¤æ‚åº¦ï¼Œå‡è®¾ `s` ä¸­ä¸åŒå…ƒç´ çš„æ•°é‡æ˜¯ \(k\)ï¼Œä½† `s` ä¸­å®é™…å…ƒç´ çš„æ•°é‡æ˜¯ \(d\)ï¼Œå…¶ä¸­ \(d \geq k\)ã€‚ä¸ºäº†è®¡ç®—åœ¨
    \(d\) ä¸ªå…ƒç´ ä¸Šè¿è¡Œ `size` çš„æ—¶é—´ \(T(d)\)ï¼Œæˆ‘ä»¬åº”è¯¥ç¡®å®šæ¯ä¸ªé—®é¢˜ä¸­çš„æ“ä½œæ•°é‡ã€‚ç¬¬ä¸€ä¸ªé—®é¢˜æœ‰å¸¸æ•°ä¸ªæ“ä½œï¼Œç¬¬ä¸€ä¸ªç­”æ¡ˆä¹Ÿæ˜¯å¸¸æ•°ã€‚ç¬¬äºŒä¸ªé—®é¢˜ä¹Ÿæœ‰å¸¸æ•°ä¸ªæ“ä½œã€‚å…¶ç­”æ¡ˆæ˜¯æ¡ä»¶æ€§çš„ï¼Œå…¶ç¬¬ä¸€ä¸ªé—®é¢˜ï¼ˆ`r.member(f)`
    éœ€è¦éå†æ•´ä¸ªåˆ—è¡¨ï¼Œå› æ­¤æœ‰ \(O([k \rightarrow d])\) ä¸ªæ“ä½œã€‚å¦‚æœæˆåŠŸï¼Œæˆ‘ä»¬é€’å½’åˆ°å¤§å°ä¸º \(T(d-1)\) çš„æŸä¸ªä¸œè¥¿ä¸Šï¼›å¦åˆ™æˆ‘ä»¬åšåŒæ ·çš„äº‹æƒ…ï¼Œä½†æ‰§è¡Œå¸¸æ•°ä¸ªé¢å¤–çš„æ“ä½œã€‚å› æ­¤
    \(T(0)\) æ˜¯å¸¸æ•°ï¼Œè€Œé€’å½’ï¼ˆåœ¨å¤§ O è¡¨ç¤ºæ³•ä¸­ï¼‰æ˜¯
- en: \begin{equation*}T(d) = d + T(d-1)\end{equation*}
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}T(d) = d + T(d-1)\end{equation*}
- en: Thus \(T \in O([d \rightarrow d^2])\). Note that this is quadratic in the number
    of elements in the list, which may be much bigger than the size of the set.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ \(T \in O([d \rightarrow d^2])\)ã€‚è¯·æ³¨æ„ï¼Œè¿™æ˜¯åˆ—è¡¨ä¸­å…ƒç´ æ•°é‡çš„å¹³æ–¹ï¼Œè¿™å¯èƒ½ä¼šè¿œå¤§äºé›†åˆçš„å¤§å°ã€‚
- en: 18.1.3Â Choosing Between Representations[ğŸ”—](#(part._choosing-set-reps) "Link
    to here")
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.1.3Â åœ¨è¡¨ç¤ºä¹‹é—´è¿›è¡Œé€‰æ‹©[ğŸ”—](#(part._choosing-set-reps) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Now that we have two representations with different complexities, itâ€™s worth
    thinking about how to choose between them. To do so, letâ€™s build up the following
    table. The table distinguishes between the interface (the set) and the implementation
    (the list), becauseâ€”<wbr>owing to duplicates in the representationâ€”<wbr>these
    two may not be the same. In the table weâ€™ll consider just two of the most common
    operations, insertion and membership checking:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†ä¸¤ç§å…·æœ‰ä¸åŒå¤æ‚åº¦çš„è¡¨ç¤ºï¼Œå€¼å¾—æ€è€ƒå¦‚ä½•åœ¨è¿™ä¸¤è€…ä¹‹é—´è¿›è¡Œé€‰æ‹©ã€‚ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œè®©æˆ‘ä»¬æ„å»ºä»¥ä¸‹è¡¨æ ¼ã€‚è¯¥è¡¨æ ¼åŒºåˆ†äº†æ¥å£ï¼ˆé›†åˆï¼‰å’Œå®ç°ï¼ˆåˆ—è¡¨ï¼‰ï¼Œå› ä¸ºâ€”â€”ç”±äºè¡¨ç¤ºä¸­çš„é‡å¤é¡¹â€”â€”è¿™ä¸¤ä¸ªå¯èƒ½å¹¶ä¸ç›¸åŒã€‚åœ¨è¡¨æ ¼ä¸­ï¼Œæˆ‘ä»¬å°†è€ƒè™‘æœ€å¸¸è§æ“ä½œä¸­çš„ä¸¤ä¸ªï¼šæ’å…¥å’Œæˆå‘˜æ£€æŸ¥ï¼š
- en: '|  |  | With Duplicates |  | Without Duplicates |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  |  | åŒ…å«é‡å¤é¡¹ |  | ä¸åŒ…å«é‡å¤é¡¹ |'
- en: '|  |  | `insert` |  | `is-in` |  | `insert` |  | `is-in` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `æ’å…¥` |  | `å­˜åœ¨æ€§æ£€æŸ¥` |  | `æ’å…¥` |  | `å­˜åœ¨æ€§æ£€æŸ¥` |'
- en: '| Size of Set |  | constant |  | linear |  | linear |  | linear |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| é›†åˆå¤§å° |  | å¸¸æ•° |  | çº¿æ€§ |  | çº¿æ€§ |  | çº¿æ€§ |'
- en: '| Size of List |  | constant |  | linear |  | linear |  | linear |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| åˆ—è¡¨å¤§å° |  | å¸¸æ•° |  | çº¿æ€§ |  | çº¿æ€§ |  | çº¿æ€§ |'
- en: 'A naive reading of this would suggest that the representation with duplicates
    is better because itâ€™s sometimes constant and sometimes linear, whereas the version
    without duplicates is always linear. However, this masks a very important distinction:
    what the linear means. When there are no duplicates, the size of the list is the
    same as the size of the set. However, with duplicates, the size of the list can
    be arbitrarily larger than that of the set!'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹æ­¤çš„ç®€å•é˜…è¯»å¯èƒ½ä¼šè®©äººè®¤ä¸ºåŒ…å«é‡å¤é¡¹çš„è¡¨ç¤ºæ›´å¥½ï¼Œå› ä¸ºå®ƒæœ‰æ—¶æ˜¯å¸¸æ•°ï¼Œæœ‰æ—¶æ˜¯çº¿æ€§ï¼Œè€Œæ²¡æœ‰ä»»ä½•é‡å¤é¡¹çš„ç‰ˆæœ¬å§‹ç»ˆæ˜¯çº¿æ€§çš„ã€‚ç„¶è€Œï¼Œè¿™æ©ç›–äº†ä¸€ä¸ªéå¸¸é‡è¦çš„åŒºåˆ«ï¼šçº¿æ€§å…·ä½“æ„å‘³ç€ä»€ä¹ˆã€‚å½“æ²¡æœ‰é‡å¤é¡¹æ—¶ï¼Œåˆ—è¡¨çš„å¤§å°ä¸é›†åˆçš„å¤§å°ç›¸åŒã€‚ç„¶è€Œï¼Œæœ‰é‡å¤é¡¹æ—¶ï¼Œåˆ—è¡¨çš„å¤§å°å¯ä»¥ä»»æ„å¤§äºé›†åˆçš„å¤§å°ï¼
- en: 'Based on this, we can draw several lessons:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºäºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºå‡ ä¸ªæ•™è®­ï¼š
- en: Which representation we choose is a matter of how much duplication we expect.
    If there wonâ€™t be many duplicates, then the version that stores duplicates pays
    a small extra price in return for some faster operations.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é€‰æ‹©å“ªç§è¡¨ç¤ºå–å†³äºæˆ‘ä»¬æœŸæœ›æœ‰å¤šå°‘é‡å¤é¡¹ã€‚å¦‚æœä¸ä¼šæœ‰å¾ˆå¤šé‡å¤é¡¹ï¼Œé‚£ä¹ˆå­˜å‚¨é‡å¤é¡¹çš„ç‰ˆæœ¬ä¼šä¸ºä¸€äº›æ›´å¿«çš„æ“ä½œä»˜å‡ºå°‘é‡çš„é¢å¤–ä»£ä»·ã€‚
- en: 'Which representation we choose is also a matter of how often we expect each
    operation to be performed. The representation without duplication is â€œin the middleâ€:
    everything is roughly equally expensive (in the worst case). With duplicates is
    â€œat the extremesâ€: very cheap insertion, potentially very expensive membership.
    But if we will mostly only insert without checking membership, and especially
    if we know membership checking will only occur in situations where weâ€™re willing
    to wait, then permitting duplicates may in fact be the smart choice. (When might
    we ever be in such a situation? Suppose your set represents a backup data structure;
    then we add lots of data but very rarelyâ€”<wbr>indeed, only in case of some catastropheâ€”<wbr>ever
    need to look for things in it.)'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é€‰æ‹©å“ªç§è¡¨ç¤ºæ³•ä¹Ÿæ˜¯ä¸€ä¸ªé—®é¢˜ï¼Œå³æˆ‘ä»¬é¢„è®¡æ¯ä¸ªæ“ä½œä¼šæ‰§è¡Œå¤šå°‘æ¬¡ã€‚æ²¡æœ‰é‡å¤çš„è¡¨ç¤ºæ³•â€œå¤„äºä¸­é—´â€ï¼šåœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œæ‰€æœ‰æ“ä½œçš„æˆæœ¬å¤§è‡´ç›¸åŒã€‚æœ‰é‡å¤çš„è¡¨ç¤ºæ³•â€œå¤„äºæç«¯â€ï¼šæ’å…¥éå¸¸ä¾¿å®œï¼Œæˆå‘˜èµ„æ ¼å¯èƒ½éå¸¸æ˜‚è´µã€‚ä½†å¦‚æœæˆ‘ä»¬ä¸»è¦åªæ’å…¥è€Œä¸æ£€æŸ¥æˆå‘˜èµ„æ ¼ï¼Œå°¤å…¶æ˜¯å¦‚æœæˆ‘ä»¬çŸ¥é“æˆå‘˜èµ„æ ¼æ£€æŸ¥åªä¼šåœ¨æˆ‘ä»¬æ„¿æ„ç­‰å¾…çš„æƒ…å†µä¸‹å‘ç”Ÿï¼Œé‚£ä¹ˆå…è®¸é‡å¤å®é™…ä¸Šå¯èƒ½æ˜¯ä¸€ä¸ªæ˜æ™ºçš„é€‰æ‹©ã€‚ï¼ˆæˆ‘ä»¬ä»€ä¹ˆæ—¶å€™ä¼šå¤„äºè¿™ç§æƒ…å†µï¼Ÿå‡è®¾ä½ çš„é›†åˆä»£è¡¨ä¸€ä¸ªå¤‡ä»½æ•°æ®ç»“æ„ï¼›é‚£ä¹ˆæˆ‘ä»¬æ·»åŠ å¤§é‡æ•°æ®ï¼Œä½†å®é™…ä¸Šï¼Œåªæœ‰åœ¨æŸäº›ç¾éš¾â€”â€”<wbr>ç¡®å®ï¼Œåªæœ‰åœ¨æŸäº›ç¾éš¾â€”â€”<wbr>çš„æƒ…å†µä¸‹æ‰éœ€è¦åœ¨å…¶ä¸­æŸ¥æ‰¾ä¸œè¥¿ã€‚ï¼‰
- en: Another way to cast these insights is that our form of analysis is too weak.
    In situations where the complexity depends so heavily on a particular sequence
    of operations, big-Oh is too loose and we should instead study the complexity
    of specific sequences of operations. We will address precisely this question later
    [[Halloween Analysis](amortized-analysis.html)].
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¦ä¸€ç§è¡¨è¾¾è¿™äº›è§è§£çš„æ–¹å¼æ˜¯æˆ‘ä»¬çš„åˆ†ææ–¹æ³•å¤ªå¼±äº†ã€‚åœ¨å¤æ‚åº¦é«˜åº¦ä¾èµ–äºç‰¹å®šæ“ä½œåºåˆ—çš„æƒ…å†µä¸‹ï¼Œå¤§Oè¡¨ç¤ºæ³•å¤ªå®½æ¾äº†ï¼Œæˆ‘ä»¬åº”è¯¥ç ”ç©¶ç‰¹å®šæ“ä½œåºåˆ—çš„å¤æ‚åº¦ã€‚æˆ‘ä»¬å°†åœ¨ç¨åç²¾ç¡®åœ°è§£å†³è¿™ä¸ªé—®é¢˜
    [[ä¸‡åœ£èŠ‚åˆ†æ](amortized-analysis.html)]ã€‚
- en: Moreover, there is no reason a program should use only one representation. It
    could well begin with one representation, then switch to another as it better
    understands its workload. The only thing it would need to do to switch is to convert
    all existing data between the representations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å¤–ï¼Œç¨‹åºæ²¡æœ‰ç†ç”±åªä½¿ç”¨ä¸€ç§è¡¨ç¤ºæ³•ã€‚å®ƒå®Œå…¨å¯ä»¥å¼€å§‹ä½¿ç”¨ä¸€ç§è¡¨ç¤ºæ³•ï¼Œç„¶åéšç€å®ƒæ›´å¥½åœ°ç†è§£å…¶å·¥ä½œè´Ÿè½½è€Œåˆ‡æ¢åˆ°å¦ä¸€ç§è¡¨ç¤ºæ³•ã€‚å®ƒéœ€è¦åšçš„å”¯ä¸€äº‹æƒ…æ˜¯å°†ç°æœ‰æ•°æ®åœ¨è¡¨ç¤ºæ³•ä¹‹é—´è¿›è¡Œè½¬æ¢ã€‚
- en: 'How might this play out above? Observe that data conversion is very cheap in
    one direction: since every list without duplicates is automatically also a list
    with (potential) duplicates, converting in that direction is trivial (the representation
    stays unchanged, only its interpretation changes). The other direction is harder:
    we have to filter duplicates (which takes time quadratic in the number of elements
    in the list). Thus, a program can make an initial guess about its workload and
    pick a representation accordingly, but maintain statistics as it runs and, when
    it finds its assumption is wrong, switch representationsâ€”<wbr>and can do so as
    many times as needed.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åœ¨ä¸Šé¢ä¼šå¦‚ä½•è¡¨ç°ï¼Ÿæ³¨æ„æ•°æ®è½¬æ¢åœ¨ä¸€ä¸ªæ–¹å‘ä¸Šéå¸¸ä¾¿å®œï¼šç”±äºæ¯ä¸ªæ²¡æœ‰é‡å¤çš„åˆ—è¡¨è‡ªåŠ¨ä¹Ÿæ˜¯ä¸€ä¸ªåŒ…å«ï¼ˆæ½œåœ¨ï¼‰é‡å¤çš„åˆ—è¡¨ï¼Œæ‰€ä»¥åœ¨é‚£ä¸ªæ–¹å‘ä¸Šçš„è½¬æ¢æ˜¯å¾®ä¸è¶³é“çš„ï¼ˆè¡¨ç¤ºæ³•ä¿æŒä¸å˜ï¼Œåªæ˜¯å…¶è§£é‡Šå‘ç”Ÿäº†å˜åŒ–ï¼‰ã€‚å¦ä¸€ä¸ªæ–¹å‘åˆ™æ›´å›°éš¾ï¼šæˆ‘ä»¬å¿…é¡»è¿‡æ»¤é‡å¤é¡¹ï¼ˆè¿™éœ€è¦ä¸åˆ—è¡¨ä¸­å…ƒç´ æ•°é‡æˆå¹³æ–¹çš„æ—¶é—´ï¼‰ã€‚å› æ­¤ï¼Œç¨‹åºå¯ä»¥å¯¹å…¶å·¥ä½œè´Ÿè½½åšå‡ºåˆå§‹çŒœæµ‹å¹¶ç›¸åº”åœ°é€‰æ‹©è¡¨ç¤ºæ³•ï¼Œä½†éšç€ç¨‹åºçš„è¿è¡Œï¼Œå¦‚æœå®ƒå‘ç°å…¶å‡è®¾æ˜¯é”™è¯¯çš„ï¼Œåˆ™å¯ä»¥åˆ‡æ¢è¡¨ç¤ºæ³•â€”â€”<wbr>å¹¶ä¸”å¯ä»¥æŒ‰éœ€å¤šæ¬¡åˆ‡æ¢ã€‚
- en: 18.1.4Â Other Operations[ğŸ”—](#(part._.Other_.Operations) "Link to here")
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.1.4Â å…¶ä»–æ“ä½œ[ğŸ”—](#(part._.Other_.Operations) "é“¾æ¥è‡³æ­¤")
- en: Exercise
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement the remaining operations catalogued above ([<set-operations>](#%28elem._set-operations%29))
    under each list representation.
  id: totrans-61
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨æ¯ä¸ªåˆ—è¡¨è¡¨ç¤ºæ³•ä¸‹å®ç°ä¸Šè¿°åˆ—å‡ºçš„å‰©ä½™æ“ä½œ ([<set-operations>](#%28elem._set-operations%29))ã€‚
- en: Exercise
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement the operation
  id: totrans-64
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®ç°è¿™ä¸ªæ“ä½œ
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: under each list representation (renaming `Set` appropriately. What difference
    do you see?
  id: totrans-68
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨æ¯ä¸ªåˆ—è¡¨è¡¨ç¤ºæ³•ä¸‹ï¼ˆé€‚å½“åœ°é‡å‘½å`Set`ã€‚ä½ çœ‹åˆ°äº†ä»€ä¹ˆä¸åŒï¼Ÿ
- en: Do Now!
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¿›è¡Œï¼
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Suppose youâ€™re asked to extend sets with these operations, as the set analog
    of `first` and `rest`:'
  id: totrans-71
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‡è®¾ä½ è¢«è¦æ±‚æ‰©å±•é›†åˆä»¥åŒ…å«è¿™äº›æ“ä½œï¼Œä½œä¸º`first`å’Œ`rest`çš„é›†åˆç±»ä¼¼ç‰©ï¼š
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-73
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: You should refuse to do so! Do you see why?
  id: totrans-75
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ åº”è¯¥æ‹’ç»è¿™æ ·åšï¼ä½ æ˜ç™½ä¸ºä»€ä¹ˆå—ï¼Ÿ
- en: With lists the â€œfirstâ€ element is well-defined, whereas sets are defined to
    have no ordering. Indeed, just to make sure users of your sets donâ€™t accidentally
    assume anything about your implementation (e.g., if you implement `one` using
    `first`, they may notice that `one` always returns the element most recently added
    to the list), you really ought to return a random element of the set on each invocation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºåˆ—è¡¨ï¼Œâ€œç¬¬ä¸€ä¸ªâ€å…ƒç´ æ˜¯æ˜ç¡®å®šä¹‰çš„ï¼Œè€Œé›†åˆè¢«å®šä¹‰ä¸ºæ²¡æœ‰é¡ºåºã€‚å®é™…ä¸Šï¼Œä¸ºäº†ç¡®ä¿ä½ çš„é›†åˆç”¨æˆ·ä¸ä¼šæ„å¤–åœ°å‡è®¾ä½ çš„å®ç°ï¼ˆä¾‹å¦‚ï¼Œå¦‚æœä½ ä½¿ç”¨`first`å®ç°`one`ï¼Œä»–ä»¬å¯èƒ½ä¼šæ³¨æ„åˆ°`one`æ€»æ˜¯è¿”å›æœ€è¿‘æ·»åŠ åˆ°åˆ—è¡¨ä¸­çš„å…ƒç´ ï¼‰ï¼Œä½ çœŸçš„åº”è¯¥åœ¨æ¯æ¬¡è°ƒç”¨æ—¶è¿”å›é›†åˆä¸­çš„ä¸€ä¸ªéšæœºå…ƒç´ ã€‚
- en: Unfortunately, returning a random element means the above interface is unusable.
    Suppose `s` is bound to a set containing `1`, `2`, and `3`. Say the first time
    `one(s)` is invoked it returns `2`, and the second time `1`. (This already means
    `one` is not a function.) The third time it may again return `2`. Thus `others`
    has to remember which element was returned the last time `one` was called, and
    return the set sans that element. Suppose we now invoke `one` on the result of
    calling `others`. That means we might have a situation where `one(s)` produces
    the same result as `one(others(s))`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œè¿”å›ä¸€ä¸ªéšæœºå…ƒç´ æ„å‘³ç€ä¸Šè¿°æ¥å£ä¸å¯ç”¨ã€‚å‡è®¾`s`ç»‘å®šåˆ°ä¸€ä¸ªåŒ…å«`1`ã€`2`å’Œ`3`çš„é›†åˆã€‚å‡è®¾ç¬¬ä¸€æ¬¡è°ƒç”¨`one(s)`è¿”å›`2`ï¼Œç¬¬äºŒæ¬¡è¿”å›`1`ã€‚ï¼ˆè¿™å·²ç»æ„å‘³ç€`one`ä¸æ˜¯ä¸€ä¸ªå‡½æ•°ã€‚ï¼‰ç¬¬ä¸‰æ¬¡å®ƒå¯èƒ½å†æ¬¡è¿”å›`2`ã€‚å› æ­¤`others`å¿…é¡»è®°ä½ä¸Šæ¬¡è°ƒç”¨`one`æ—¶è¿”å›çš„å…ƒç´ ï¼Œå¹¶è¿”å›æ²¡æœ‰è¯¥å…ƒç´ çš„é›†åˆã€‚å‡è®¾æˆ‘ä»¬ç°åœ¨åœ¨è°ƒç”¨`others`çš„ç»“æœä¸Šè°ƒç”¨`one`ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯èƒ½æœ‰ä¸€ä¸ªæƒ…å†µï¼Œå…¶ä¸­`one(s)`äº§ç”Ÿä¸`one(others(s))`ç›¸åŒçš„ç»“æœã€‚
- en: Exercise
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is it unreasonable for `one(s)` to produce the same result as `one(others(s))`?
  id: totrans-80
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆ`one(s)`äº§ç”Ÿä¸`one(others(s))`ç›¸åŒçš„ç»“æœæ˜¯ä¸åˆç†çš„ï¼Ÿ
- en: Exercise
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose you wanted to extend sets with a `subset` operation that partitioned
    the set according to some condition. What would its type be?
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‡è®¾ä½ æƒ³é€šè¿‡ä¸€ä¸ª`subset`æ“ä½œæ¥æ‰©å±•é›†åˆï¼Œè¯¥æ“ä½œæ ¹æ®æŸäº›æ¡ä»¶å¯¹é›†åˆè¿›è¡Œåˆ†åŒºã€‚å®ƒçš„ç±»å‹ä¼šæ˜¯ä»€ä¹ˆï¼Ÿ
- en: Exercise
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The types we have written above are not as crisp as they could be. Define a
    `has-no-duplicates` predicate, refine the relevant types with it, and check that
    the functions really do satisfy this criterion.
  id: totrans-86
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸Šé¢å†™å‡ºçš„ç±»å‹ä¸å¦‚å®ƒä»¬å¯èƒ½çš„é‚£æ ·æ¸…æ™°ã€‚å®šä¹‰ä¸€ä¸ª`has-no-duplicates`è°“è¯ï¼Œç”¨å®ƒæ¥ç»†åŒ–ç›¸å…³çš„ç±»å‹ï¼Œå¹¶æ£€æŸ¥å‡½æ•°æ˜¯å¦çœŸçš„æ»¡è¶³è¿™ä¸ªæ ‡å‡†ã€‚
- en: 18.1.1Â Representation Choices[ğŸ”—](#(part._.Representation_.Choices) "Link to
    here")
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.1.1Â è¡¨ç¤ºé€‰æ‹©[ğŸ”—](#(part._.Representation_.Choices) "é“¾æ¥è‡³æ­¤")
- en: The empty list can stand in for the empty setâ€”<wbr>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ç©ºåˆ—è¡¨å¯ä»¥ä»£è¡¨ç©ºé›†åˆâ€”<wbr>
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: â€”<wbr>and we can presumably define `size` as
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: â€”<wbr>å¹¶ä¸”æˆ‘ä»¬å¯ä»¥å‡è®¾å®šä¹‰`size`ä¸º
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, this [â˜› reduction](glossary.html#%28elem._glossary-reduction%29) (of
    sets to lists) can be dangerous:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¿™ç§[â˜›å‡å°‘](glossary.html#%28elem._glossary-reduction%29)ï¼ˆå°†é›†åˆè½¬æ¢ä¸ºåˆ—è¡¨ï¼‰å¯èƒ½æ˜¯å±é™©çš„ï¼š
- en: There is a subtle difference between lists and sets. The list
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åˆ—è¡¨å’Œé›†åˆä¹‹é—´å­˜åœ¨å¾®å¦™çš„åŒºåˆ«ã€‚åˆ—è¡¨
- en: '[PRE13]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: is not the same as
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: è¿™ä¸åŒäº
- en: '[PRE14]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'because the first list has length two whereas the second has length one. Treated
    as a set, however, the two are the same: they both have size one. Thus, our implementation
    of `size` above is incorrect if we donâ€™t take into account duplicates (either
    during insertion or while computing the size).'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å› ä¸ºç¬¬ä¸€ä¸ªåˆ—è¡¨é•¿åº¦ä¸ºä¸¤ä¸ªï¼Œè€Œç¬¬äºŒä¸ªé•¿åº¦ä¸ºä¸€ä¸ªã€‚ç„¶è€Œï¼Œä½œä¸ºä¸€ä¸ªé›†åˆï¼Œè¿™ä¸¤ä¸ªæ˜¯ç›¸åŒçš„ï¼šå®ƒä»¬çš„å¤§å°éƒ½æ˜¯ä¸€ã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬ä¸è€ƒè™‘é‡å¤é¡¹ï¼ˆæ— è®ºæ˜¯åœ¨æ’å…¥æ—¶è¿˜æ˜¯åœ¨è®¡ç®—å¤§å°æœŸé—´ï¼‰ï¼Œæˆ‘ä»¬ä¸Šé¢å®ç°çš„`size`æ˜¯ä¸æ­£ç¡®çš„ã€‚
- en: We might falsely make assumptions about the order in which elements are retrieved
    from the set due to the ordering guaranteed provided by the underlying list representation.
    This might hide bugs that we donâ€™t discover until we change the representation.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½ä¼šç”±äºåº•å±‚åˆ—è¡¨è¡¨ç¤ºæä¾›çš„æ’åºä¿è¯è€Œé”™è¯¯åœ°å‡è®¾ä»é›†åˆä¸­æ£€ç´¢å…ƒç´ çš„é¡ºåºã€‚è¿™å¯èƒ½ä¼šéšè—æˆ‘ä»¬ç›´åˆ°æ›´æ”¹è¡¨ç¤ºæ—¶æ‰å‘ç°çš„é”™è¯¯ã€‚
- en: We might have chosen a set representation because we didnâ€™t need to care about
    order, and expected lots of duplicate items. A list representation might store
    all the duplicates, resulting in significantly more memory use (and slower programs)
    than we expected.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½é€‰æ‹©äº†é›†åˆè¡¨ç¤ºï¼Œå› ä¸ºæˆ‘ä»¬ä¸éœ€è¦å…³å¿ƒé¡ºåºï¼Œå¹¶ä¸”é¢„æœŸä¼šæœ‰å¾ˆå¤šé‡å¤é¡¹ã€‚åˆ—è¡¨è¡¨ç¤ºå¯èƒ½ä¼šå­˜å‚¨æ‰€æœ‰é‡å¤é¡¹ï¼Œå¯¼è‡´æ¯”æˆ‘ä»¬é¢„æœŸçš„æ›´å¤šå†…å­˜ä½¿ç”¨ï¼ˆä»¥åŠæ›´æ…¢çš„ç¨‹åºï¼‰ã€‚
- en: To avoid these perils, we have to be precise about how weâ€™re going to use lists
    to represent sets. One key question (but not the only one, as weâ€™ll soon see [[Choosing
    Between Representations](#%28part._choosing-set-reps%29)]) is what to do about
    duplicates. One possibility is for `insert` to check whether an element is already
    in the set and, if so, leave the representation unchanged; this incurs a cost
    during insertion but avoids unnecessary duplication and lets us use `length` to
    implement `size`. The other option is to define `insert` as `link`â€”<wbr>literally,
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†é¿å…è¿™äº›å±é™©ï¼Œæˆ‘ä»¬å¿…é¡»ç²¾ç¡®åœ°è¯´æ˜æˆ‘ä»¬å°†å¦‚ä½•ä½¿ç”¨åˆ—è¡¨æ¥è¡¨ç¤ºé›†åˆã€‚ä¸€ä¸ªå…³é”®é—®é¢˜ï¼ˆä½†ä¸æ˜¯å”¯ä¸€çš„é—®é¢˜ï¼Œå› ä¸ºæˆ‘ä»¬å¾ˆå¿«å°±ä¼šçœ‹åˆ° [[é€‰æ‹©è¡¨ç¤ºæ–¹å¼](#%28part._choosing-set-reps%29)])
    æ˜¯å¦‚ä½•å¤„ç†é‡å¤é¡¹ã€‚ä¸€ç§å¯èƒ½æ€§æ˜¯è®©`insert`æ£€æŸ¥ä¸€ä¸ªå…ƒç´ æ˜¯å¦å·²ç»åœ¨é›†åˆä¸­ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™ä¿æŒè¡¨ç¤ºä¸å˜ï¼›è¿™ä¼šåœ¨æ’å…¥æœŸé—´äº§ç”Ÿæˆæœ¬ï¼Œä½†å¯ä»¥é¿å…ä¸å¿…è¦çš„é‡å¤ï¼Œå¹¶å…è®¸æˆ‘ä»¬ä½¿ç”¨`length`æ¥å®ç°`size`ã€‚å¦ä¸€ç§é€‰æ‹©æ˜¯å°†`insert`å®šä¹‰ä¸º`link`â€”<wbr>å®é™…ä¸Šï¼Œ
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: â€”<wbr>and have some other procedure perform the filtering of duplicates.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: â€”<wbr>å¹¶ä¸”è®©å…¶ä»–ç¨‹åºæ‰§è¡Œé‡å¤é¡¹çš„è¿‡æ»¤ã€‚
- en: 18.1.2Â Time Complexity[ğŸ”—](#(part._.Time_.Complexity) "Link to here")
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.1.2Â æ—¶é—´å¤æ‚åº¦[ğŸ”—](#(part._.Time_.Complexity) "é“¾æ¥è‡³æ­¤")
- en: 'What is the complexity of this representation of sets? Letâ€™s consider just
    `insert`, `is-in`, and `size`. Suppose the size of the set is \(k\) (where, to
    avoid ambiguity, we let \(k\) represent the number of distinct elements). The
    complexity of these operations depends on whether or not we store duplicates:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§é›†åˆè¡¨ç¤ºçš„å¤æ‚åº¦æ˜¯å¤šå°‘ï¼Ÿè®©æˆ‘ä»¬è€ƒè™‘ `insert`ã€`is-in` å’Œ `size`ã€‚å‡è®¾é›†åˆçš„å¤§å°æ˜¯ \(k\)ï¼ˆä¸ºäº†é¿å…æ­§ä¹‰ï¼Œæˆ‘ä»¬è®© \(k\)
    ä»£è¡¨ä¸åŒå…ƒç´ çš„æ•°é‡ï¼‰ã€‚è¿™äº›æ“ä½œçš„æ—¶é—´å¤æ‚åº¦å–å†³äºæˆ‘ä»¬æ˜¯å¦å­˜å‚¨é‡å¤é¡¹ï¼š
- en: If we donâ€™t store duplicates, then `size` is simply `length`, which takes time
    linear in \(k\). Similarly, `is-in` only needs to traverse the list once to determine
    whether or not an element is present, which also takes time linear in \(k\). But
    `insert` needs to check whether an element is already present, which takes time
    linear in \(k\), followed by at most a constant-time operation (`link`).
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ä¸å­˜å‚¨é‡å¤é¡¹ï¼Œé‚£ä¹ˆ `size` å°±æ˜¯ `length`ï¼Œå®ƒçš„æ—¶é—´å¤æ‚åº¦æ˜¯ \(k\) çš„çº¿æ€§æ—¶é—´ã€‚åŒæ ·ï¼Œ`is-in` åªéœ€è¦éå†åˆ—è¡¨ä¸€æ¬¡æ¥ç¡®å®šä¸€ä¸ªå…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Œè¿™ä¹Ÿéœ€è¦
    \(k\) çš„çº¿æ€§æ—¶é—´ã€‚ä½†æ˜¯ `insert` éœ€è¦æ£€æŸ¥ä¸€ä¸ªå…ƒç´ æ˜¯å¦å·²ç»å­˜åœ¨ï¼Œè¿™éœ€è¦ \(k\) çš„çº¿æ€§æ—¶é—´ï¼Œç„¶åæœ€å¤šæ‰§è¡Œä¸€ä¸ªå¸¸æ•°æ—¶é—´çš„æ“ä½œï¼ˆ`link`ï¼‰ã€‚
- en: 'If we do store duplicates, then `insert` is constant time: it simply `link`s
    on the new element without regard to whether it already is in the set representation.
    `is-in` traverses the list once, but the number of elements it needs to visit
    could be significantly greater than \(k\), depending on how many duplicates have
    been added. Finally, `size` needs to check whether or not each element is duplicated
    before counting it.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ç¡®å®å­˜å‚¨é‡å¤é¡¹ï¼Œé‚£ä¹ˆ `insert` æ˜¯å¸¸æ•°æ—¶é—´ï¼šå®ƒç®€å•åœ° `link` æ–°å…ƒç´ ï¼Œè€Œä¸è€ƒè™‘å®ƒæ˜¯å¦å·²ç»åœ¨é›†åˆè¡¨ç¤ºæ³•ä¸­ã€‚`is-in` éå†åˆ—è¡¨ä¸€æ¬¡ï¼Œä½†å®ƒéœ€è¦è®¿é—®çš„å…ƒç´ æ•°é‡å¯èƒ½æ˜¾è‘—å¤§äº
    \(k\)ï¼Œè¿™å–å†³äºæ·»åŠ äº†å¤šå°‘é‡å¤é¡¹ã€‚æœ€åï¼Œ`size` éœ€è¦æ£€æŸ¥æ¯ä¸ªå…ƒç´ æ˜¯å¦é‡å¤ï¼Œç„¶åå†è®¡æ•°ã€‚
- en: Do Now!
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the time complexity of `size` if the list has duplicates?
  id: totrans-109
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœåˆ—è¡¨ä¸­æœ‰é‡å¤é¡¹ï¼Œ`size` çš„æ—¶é—´å¤æ‚åº¦æ˜¯å¤šå°‘ï¼Ÿ
- en: One implementation of `size` is
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`size` çš„ä¸€ç§å®ç°æ˜¯'
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Letâ€™s now compute the complexity of the body of the function, assuming the number
    of distinct elements in `s` is \(k\) but the actual number of elements in `s`
    is \(d\), where \(d \geq k\). To compute the time to run `size` on \(d\) elements,
    \(T(d)\), we should determine the number of operations in each question and answer.
    The first question has a constant number of operations, and the first answer also
    a constant. The second question also has a constant number of operations. Its
    answer is a conditional, whose first question (`r.member(f)` needs to traverse
    the entire list, and hence has \(O([k \rightarrow d])\) operations. If it succeeds,
    we recur on something of size \(T(d-1)\); else we do the same but perform a constant
    more operations. Thus \(T(0)\) is a constant, while the recurrence (in big-Oh
    terms) is
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æ¥è®¡ç®—å‡½æ•°ä½“çš„å¤æ‚åº¦ï¼Œå‡è®¾ `s` ä¸­çš„ä¸åŒå…ƒç´ æ•°é‡æ˜¯ \(k\)ï¼Œä½† `s` ä¸­çš„å®é™…å…ƒç´ æ•°é‡æ˜¯ \(d\)ï¼Œå…¶ä¸­ \(d \geq k\)ã€‚ä¸ºäº†è®¡ç®—åœ¨
    \(d\) ä¸ªå…ƒç´ ä¸Šè¿è¡Œ `size` çš„æ—¶é—´ \(T(d)\)ï¼Œæˆ‘ä»¬åº”è¯¥ç¡®å®šæ¯ä¸ªé—®é¢˜çš„æ“ä½œæ•°ã€‚ç¬¬ä¸€ä¸ªé—®é¢˜æœ‰å¸¸æ•°ä¸ªæ“ä½œï¼Œç¬¬ä¸€ä¸ªç­”æ¡ˆä¹Ÿæ˜¯å¸¸æ•°ã€‚ç¬¬äºŒä¸ªé—®é¢˜ä¹Ÿæœ‰å¸¸æ•°ä¸ªæ“ä½œã€‚å®ƒçš„ç­”æ¡ˆæ˜¯æ¡ä»¶æ€§çš„ï¼Œå…¶ç¬¬ä¸€ä¸ªé—®é¢˜ï¼ˆ`r.member(f)`
    éœ€è¦éå†æ•´ä¸ªåˆ—è¡¨ï¼Œå› æ­¤æœ‰ \(O([k \rightarrow d])\) ä¸ªæ“ä½œã€‚å¦‚æœæˆåŠŸï¼Œæˆ‘ä»¬é€’å½’åˆ°å¤§å°ä¸º \(T(d-1)\) çš„æŸä¸ªä¸œè¥¿ä¸Šï¼›å¦åˆ™æˆ‘ä»¬åšåŒæ ·çš„äº‹æƒ…ï¼Œä½†æ‰§è¡Œå¸¸æ•°ä¸ªé¢å¤–çš„æ“ä½œã€‚å› æ­¤
    \(T(0)\) æ˜¯å¸¸æ•°ï¼Œè€Œé€’å½’ï¼ˆåœ¨å¤§ O è¡¨ç¤ºæ³•ä¸­ï¼‰æ˜¯
- en: \begin{equation*}T(d) = d + T(d-1)\end{equation*}
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}T(d) = d + T(d-1)\end{equation*}
- en: Thus \(T \in O([d \rightarrow d^2])\). Note that this is quadratic in the number
    of elements in the list, which may be much bigger than the size of the set.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ \(T \in O([d \rightarrow d^2])\)ã€‚æ³¨æ„ï¼Œè¿™åœ¨åˆ—è¡¨å…ƒç´ çš„æ•°é‡ä¸Šæ˜¯äºŒæ¬¡çš„ï¼Œè¿™å¯èƒ½ä¼šè¿œå¤§äºé›†åˆçš„å¤§å°ã€‚
- en: 18.1.3Â Choosing Between Representations[ğŸ”—](#(part._choosing-set-reps) "Link
    to here")
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.1.3Â é€‰æ‹©è¡¨ç¤ºæ³•[ğŸ”—](#(part._choosing-set-reps) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Now that we have two representations with different complexities, itâ€™s worth
    thinking about how to choose between them. To do so, letâ€™s build up the following
    table. The table distinguishes between the interface (the set) and the implementation
    (the list), becauseâ€”<wbr>owing to duplicates in the representationâ€”<wbr>these
    two may not be the same. In the table weâ€™ll consider just two of the most common
    operations, insertion and membership checking:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†ä¸¤ç§å…·æœ‰ä¸åŒå¤æ‚åº¦çš„è¡¨ç¤ºæ³•ï¼Œå€¼å¾—è€ƒè™‘å¦‚ä½•åœ¨è¿™ä¸¤è€…ä¹‹é—´è¿›è¡Œé€‰æ‹©ã€‚ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œè®©æˆ‘ä»¬æ„å»ºä»¥ä¸‹è¡¨æ ¼ã€‚è¯¥è¡¨åŒºåˆ†äº†æ¥å£ï¼ˆé›†åˆï¼‰å’Œå®ç°ï¼ˆåˆ—è¡¨ï¼‰ï¼Œå› ä¸ºâ€”â€”ç”±äºè¡¨ç¤ºæ³•ä¸­çš„é‡å¤é¡¹â€”â€”è¿™ä¸¤ä¸ªå¯èƒ½ä¸åŒã€‚åœ¨è¡¨ä¸­ï¼Œæˆ‘ä»¬å°†è€ƒè™‘æœ€å¸¸è§æ“ä½œä¸­çš„ä¸¤ä¸ªï¼Œå³æ’å…¥å’Œæˆå‘˜æ£€æŸ¥ï¼š
- en: '|  |  | With Duplicates |  | Without Duplicates |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  |  | æœ‰é‡å¤é¡¹ |  | æ— é‡å¤é¡¹ |'
- en: '|  |  | `insert` |  | `is-in` |  | `insert` |  | `is-in` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `insert` |  | `is-in` |  | `insert` |  | `is-in` |'
- en: '| Size of Set |  | constant |  | linear |  | linear |  | linear |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| é›†åˆå¤§å° |  | å¸¸æ•° |  | çº¿æ€§ |  | çº¿æ€§ |  | çº¿æ€§ |'
- en: '| Size of List |  | constant |  | linear |  | linear |  | linear |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| åˆ—è¡¨å¤§å° |  | å¸¸æ•° |  | çº¿æ€§ |  | çº¿æ€§ |  | çº¿æ€§ |'
- en: 'A naive reading of this would suggest that the representation with duplicates
    is better because itâ€™s sometimes constant and sometimes linear, whereas the version
    without duplicates is always linear. However, this masks a very important distinction:
    what the linear means. When there are no duplicates, the size of the list is the
    same as the size of the set. However, with duplicates, the size of the list can
    be arbitrarily larger than that of the set!'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹æ­¤çš„ç›´è§‚ç†è§£å¯èƒ½ä¼šè®©äººè®¤ä¸ºåŒ…å«é‡å¤é¡¹çš„è¡¨ç¤ºå½¢å¼æ›´å¥½ï¼Œå› ä¸ºå®ƒæœ‰æ—¶æ˜¯å¸¸æ•°ï¼Œæœ‰æ—¶æ˜¯çº¿æ€§çš„ï¼Œè€Œæ— éœ€é‡å¤çš„ç‰ˆæœ¬å§‹ç»ˆæ˜¯çº¿æ€§çš„ã€‚ç„¶è€Œï¼Œè¿™æ©ç›–äº†ä¸€ä¸ªéå¸¸é‡è¦çš„åŒºåˆ«ï¼šçº¿æ€§æ„å‘³ç€ä»€ä¹ˆã€‚å½“æ²¡æœ‰é‡å¤é¡¹æ—¶ï¼Œåˆ—è¡¨çš„å¤§å°ä¸é›†åˆçš„å¤§å°ç›¸åŒã€‚ç„¶è€Œï¼Œæœ‰é‡å¤é¡¹æ—¶ï¼Œåˆ—è¡¨çš„å¤§å°å¯ä»¥ä»»æ„å¤§äºé›†åˆçš„å¤§å°ï¼
- en: 'Based on this, we can draw several lessons:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºäºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºå‡ ä¸ªæ•™è®­ï¼š
- en: Which representation we choose is a matter of how much duplication we expect.
    If there wonâ€™t be many duplicates, then the version that stores duplicates pays
    a small extra price in return for some faster operations.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é€‰æ‹©å“ªç§è¡¨ç¤ºå½¢å¼å–å†³äºæˆ‘ä»¬é¢„è®¡ä¼šæœ‰å¤šå°‘é‡å¤ã€‚å¦‚æœæ²¡æœ‰å¾ˆå¤šé‡å¤é¡¹ï¼Œé‚£ä¹ˆå­˜å‚¨é‡å¤é¡¹çš„ç‰ˆæœ¬åœ¨æ¢å–ä¸€äº›æ›´å¿«æ“ä½œçš„åŒæ—¶ï¼Œåªéœ€æ”¯ä»˜ä¸€å°éƒ¨åˆ†é¢å¤–æˆæœ¬ã€‚
- en: 'Which representation we choose is also a matter of how often we expect each
    operation to be performed. The representation without duplication is â€œin the middleâ€:
    everything is roughly equally expensive (in the worst case). With duplicates is
    â€œat the extremesâ€: very cheap insertion, potentially very expensive membership.
    But if we will mostly only insert without checking membership, and especially
    if we know membership checking will only occur in situations where weâ€™re willing
    to wait, then permitting duplicates may in fact be the smart choice. (When might
    we ever be in such a situation? Suppose your set represents a backup data structure;
    then we add lots of data but very rarelyâ€”<wbr>indeed, only in case of some catastropheâ€”<wbr>ever
    need to look for things in it.)'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é€‰æ‹©å“ªç§è¡¨ç¤ºå½¢å¼ä¹Ÿæ˜¯ä¸€ä¸ªé—®é¢˜ï¼Œå³æˆ‘ä»¬é¢„è®¡æ¯ç§æ“ä½œä¼šæ‰§è¡Œå¤šå°‘æ¬¡ã€‚æ— é‡å¤çš„è¡¨ç¤ºå½¢å¼â€œå¤„äºä¸­é—´â€ï¼šæ‰€æœ‰æ“ä½œçš„æˆæœ¬å¤§è‡´ç›¸åŒï¼ˆåœ¨æœ€åçš„æƒ…å†µä¸‹ï¼‰ã€‚åŒ…å«é‡å¤é¡¹çš„è¡¨ç¤ºå½¢å¼â€œå¤„äºæç«¯â€ï¼šæ’å…¥éå¸¸ä¾¿å®œï¼Œè€Œæˆå‘˜èµ„æ ¼æ£€æŸ¥å¯èƒ½éå¸¸æ˜‚è´µã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬ä¸»è¦åªæ’å…¥è€Œä¸æ£€æŸ¥æˆå‘˜èµ„æ ¼ï¼Œå°¤å…¶æ˜¯å¦‚æœæˆ‘ä»¬çŸ¥é“æˆå‘˜èµ„æ ¼æ£€æŸ¥åªä¼šåœ¨æˆ‘ä»¬æ„¿æ„ç­‰å¾…çš„æƒ…å†µä¸‹å‘ç”Ÿï¼Œé‚£ä¹ˆå…è®¸é‡å¤å®é™…ä¸Šå¯èƒ½æ˜¯ä¸€ä¸ªæ˜æ™ºçš„é€‰æ‹©ã€‚ï¼ˆæˆ‘ä»¬ä½•æ—¶ä¼šå¤„äºè¿™ç§æƒ…å†µï¼Ÿå‡è®¾ä½ çš„é›†åˆä»£è¡¨ä¸€ä¸ªå¤‡ä»½æ•°æ®ç»“æ„ï¼›é‚£ä¹ˆæˆ‘ä»¬ä¼šæ·»åŠ å¤§é‡æ•°æ®ï¼Œä½†å®é™…ä¸Šï¼Œåªæœ‰åœ¨æŸäº›ç¾éš¾â€”â€”<wbr>ç¡®å®ï¼Œåªæœ‰åœ¨æŸäº›ç¾éš¾â€”â€”<wbr>çš„æƒ…å†µä¸‹æ‰éœ€è¦åœ¨å…¶ä¸­æŸ¥æ‰¾ä¸œè¥¿ã€‚ï¼‰
- en: Another way to cast these insights is that our form of analysis is too weak.
    In situations where the complexity depends so heavily on a particular sequence
    of operations, big-Oh is too loose and we should instead study the complexity
    of specific sequences of operations. We will address precisely this question later
    [[Halloween Analysis](amortized-analysis.html)].
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¦ä¸€ç§è¡¨è¾¾è¿™äº›è§è§£çš„æ–¹å¼æ˜¯ï¼Œæˆ‘ä»¬çš„åˆ†ææ–¹æ³•å¤ªå¼±ã€‚åœ¨å¤æ‚åº¦é«˜åº¦ä¾èµ–äºç‰¹å®šæ“ä½œåºåˆ—çš„æƒ…å†µä¸‹ï¼Œå¤§Oè¡¨ç¤ºæ³•å¤ªå®½æ¾äº†ï¼Œæˆ‘ä»¬åº”è¯¥ç ”ç©¶ç‰¹å®šæ“ä½œåºåˆ—çš„å¤æ‚åº¦ã€‚æˆ‘ä»¬å°†åœ¨ç¨åç²¾ç¡®åœ°è§£å†³è¿™ä¸ªé—®é¢˜
    [[ä¸‡åœ£èŠ‚åˆ†æ](amortized-analysis.html)]ã€‚
- en: Moreover, there is no reason a program should use only one representation. It
    could well begin with one representation, then switch to another as it better
    understands its workload. The only thing it would need to do to switch is to convert
    all existing data between the representations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å¤–ï¼Œç¨‹åºæ²¡æœ‰ç†ç”±åªä½¿ç”¨ä¸€ç§è¡¨ç¤ºå½¢å¼ã€‚å®ƒå®Œå…¨å¯ä»¥å¼€å§‹ä½¿ç”¨ä¸€ç§è¡¨ç¤ºå½¢å¼ï¼Œç„¶åéšç€å¯¹å…¶å·¥ä½œè´Ÿè½½ç†è§£çš„åŠ æ·±è€Œåˆ‡æ¢åˆ°å¦ä¸€ç§è¡¨ç¤ºå½¢å¼ã€‚å®ƒéœ€è¦åšçš„å”¯ä¸€ä¸€ä»¶äº‹å°±æ˜¯å°†ç°æœ‰æ•°æ®åœ¨è¡¨ç¤ºå½¢å¼ä¹‹é—´è¿›è¡Œè½¬æ¢ã€‚
- en: 'How might this play out above? Observe that data conversion is very cheap in
    one direction: since every list without duplicates is automatically also a list
    with (potential) duplicates, converting in that direction is trivial (the representation
    stays unchanged, only its interpretation changes). The other direction is harder:
    we have to filter duplicates (which takes time quadratic in the number of elements
    in the list). Thus, a program can make an initial guess about its workload and
    pick a representation accordingly, but maintain statistics as it runs and, when
    it finds its assumption is wrong, switch representationsâ€”<wbr>and can do so as
    many times as needed.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§æƒ…å†µä¼šå¦‚ä½•å‘å±•ï¼Ÿè§‚å¯Ÿå‘ç°ï¼Œæ•°æ®è½¬æ¢åœ¨ä¸€ä¸ªæ–¹å‘ä¸Šéå¸¸ä¾¿å®œï¼šç”±äºæ¯ä¸ªä¸åŒ…å«é‡å¤é¡¹çš„åˆ—è¡¨è‡ªåŠ¨ä¹Ÿæ˜¯ä¸€ä¸ªåŒ…å«ï¼ˆæ½œåœ¨ï¼‰é‡å¤é¡¹çš„åˆ—è¡¨ï¼Œæ‰€ä»¥åœ¨é‚£ä¸ªæ–¹å‘ä¸Šçš„è½¬æ¢æ˜¯å¾®ä¸è¶³é“çš„ï¼ˆè¡¨ç¤ºå½¢å¼ä¿æŒä¸å˜ï¼Œåªæ˜¯å…¶è§£é‡Šå‘ç”Ÿäº†å˜åŒ–ï¼‰ã€‚å¦ä¸€ä¸ªæ–¹å‘åˆ™æ›´å›°éš¾ï¼šæˆ‘ä»¬å¿…é¡»è¿‡æ»¤é‡å¤é¡¹ï¼ˆè¿™éœ€è¦ä¸åˆ—è¡¨ä¸­å…ƒç´ æ•°é‡æˆå¹³æ–¹çš„æ—¶é—´ï¼‰ã€‚å› æ­¤ï¼Œä¸€ä¸ªç¨‹åºå¯ä»¥å¯¹å…¶å·¥ä½œè´Ÿè½½åšå‡ºåˆå§‹çŒœæµ‹ï¼Œå¹¶ç›¸åº”åœ°é€‰æ‹©è¡¨ç¤ºå½¢å¼ï¼Œä½†éšç€ç¨‹åºçš„è¿è¡Œï¼Œç»´æŠ¤ç»Ÿè®¡æ•°æ®ï¼Œå½“å®ƒå‘ç°å…¶å‡è®¾é”™è¯¯æ—¶ï¼Œåˆ‡æ¢è¡¨ç¤ºå½¢å¼â€”â€”<wbr>å¹¶ä¸”å¯ä»¥æŒ‰éœ€å¤šæ¬¡åˆ‡æ¢ã€‚
- en: 18.1.4Â Other Operations[ğŸ”—](#(part._.Other_.Operations) "Link to here")
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.1.4 å…¶ä»–æ“ä½œ[ğŸ”—](#(part._.Other_.Operations) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Exercise
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement the remaining operations catalogued above ([<set-operations>](#%28elem._set-operations%29))
    under each list representation.
  id: totrans-131
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨æ¯ç§åˆ—è¡¨è¡¨ç¤ºæ³•ä¸‹å®ç°ä¸Šè¿°åˆ—å‡ºçš„å‰©ä½™æ“ä½œ ([<é›†åˆæ“ä½œ>](#%28elem._é›†åˆæ“ä½œ%29))ã€‚
- en: Exercise
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement the operation
  id: totrans-134
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®ç°æ“ä½œ
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-136
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: under each list representation (renaming `Set` appropriately. What difference
    do you see?
  id: totrans-138
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨æ¯ç§åˆ—è¡¨è¡¨ç¤ºæ³•ä¸‹ï¼ˆé€‚å½“åœ°é‡å‘½å `Set`ã€‚ä½ çœ‹åˆ°äº†ä»€ä¹ˆåŒºåˆ«ï¼Ÿï¼‰
- en: Do Now!
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Suppose youâ€™re asked to extend sets with these operations, as the set analog
    of `first` and `rest`:'
  id: totrans-141
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‡è®¾ä½ è¢«è¦æ±‚æ‰©å±•é›†åˆï¼Œä»¥ `first` å’Œ `rest` çš„é›†åˆç±»ä¼¼ç‰©æ¥æ“ä½œï¼š
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-143
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ''
  id: totrans-144
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: You should refuse to do so! Do you see why?
  id: totrans-145
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ åº”è¯¥æ‹’ç»è¿™æ ·åšï¼ä½ æ˜ç™½ä¸ºä»€ä¹ˆå—ï¼Ÿ
- en: With lists the â€œfirstâ€ element is well-defined, whereas sets are defined to
    have no ordering. Indeed, just to make sure users of your sets donâ€™t accidentally
    assume anything about your implementation (e.g., if you implement `one` using
    `first`, they may notice that `one` always returns the element most recently added
    to the list), you really ought to return a random element of the set on each invocation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºåˆ—è¡¨ï¼Œâ€œç¬¬ä¸€ä¸ªâ€å…ƒç´ æ˜¯æ˜ç¡®å®šä¹‰çš„ï¼Œè€Œé›†åˆè¢«å®šä¹‰ä¸ºæ²¡æœ‰é¡ºåºã€‚å®é™…ä¸Šï¼Œä¸ºäº†ç¡®ä¿é›†åˆçš„ç”¨æˆ·ä¸ä¼šæ„å¤–åœ°å‡è®¾å…³äºä½ çš„å®ç°ï¼ˆä¾‹å¦‚ï¼Œå¦‚æœä½ ä½¿ç”¨ `first` å®ç°
    `one`ï¼Œä»–ä»¬å¯èƒ½ä¼šæ³¨æ„åˆ° `one` æ€»æ˜¯è¿”å›æœ€è¿‘æ·»åŠ åˆ°åˆ—è¡¨ä¸­çš„å…ƒç´ ï¼‰ï¼Œä½ çœŸçš„åº”è¯¥åœ¨æ¯æ¬¡è°ƒç”¨æ—¶è¿”å›é›†åˆä¸­çš„ä¸€ä¸ªéšæœºå…ƒç´ ã€‚
- en: Unfortunately, returning a random element means the above interface is unusable.
    Suppose `s` is bound to a set containing `1`, `2`, and `3`. Say the first time
    `one(s)` is invoked it returns `2`, and the second time `1`. (This already means
    `one` is not a function.) The third time it may again return `2`. Thus `others`
    has to remember which element was returned the last time `one` was called, and
    return the set sans that element. Suppose we now invoke `one` on the result of
    calling `others`. That means we might have a situation where `one(s)` produces
    the same result as `one(others(s))`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œè¿”å›ä¸€ä¸ªéšæœºå…ƒç´ æ„å‘³ç€ä¸Šè¿°æ¥å£æ— æ³•ä½¿ç”¨ã€‚å‡è®¾ `s` è¢«ç»‘å®šåˆ°ä¸€ä¸ªåŒ…å« `1`ã€`2` å’Œ `3` çš„é›†åˆä¸­ã€‚å‡è®¾ç¬¬ä¸€æ¬¡è°ƒç”¨ `one(s)`
    è¿”å› `2`ï¼Œç¬¬äºŒæ¬¡è¿”å› `1`ã€‚ï¼ˆè¿™å·²ç»æ„å‘³ç€ `one` ä¸æ˜¯ä¸€ä¸ªå‡½æ•°ã€‚ï¼‰ç¬¬ä¸‰æ¬¡å®ƒå¯èƒ½å†æ¬¡è¿”å› `2`ã€‚å› æ­¤ `others` å¿…é¡»è®°ä½ä¸Šæ¬¡è°ƒç”¨ `one`
    æ—¶è¿”å›çš„å…ƒç´ ï¼Œå¹¶è¿”å›æ²¡æœ‰è¯¥å…ƒç´ çš„é›†åˆã€‚å‡è®¾æˆ‘ä»¬ç°åœ¨åœ¨è°ƒç”¨ `others` çš„ç»“æœä¸Šè°ƒç”¨ `one`ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯èƒ½é‡åˆ° `one(s)` å’Œ `one(others(s))`
    äº§ç”Ÿç›¸åŒç»“æœçš„æƒ…å†µã€‚
- en: Exercise
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is it unreasonable for `one(s)` to produce the same result as `one(others(s))`?
  id: totrans-150
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆ `one(s)` å’Œ `one(others(s))` äº§ç”Ÿç›¸åŒçš„ç»“æœæ˜¯ä¸åˆç†çš„ï¼Ÿ
- en: Exercise
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose you wanted to extend sets with a `subset` operation that partitioned
    the set according to some condition. What would its type be?
  id: totrans-153
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‡è®¾ä½ æƒ³è¦æ‰©å±•é›†åˆï¼Œä»¥ä¸€ä¸ª `subset` æ“ä½œæ¥æ ¹æ®æŸäº›æ¡ä»¶å¯¹é›†åˆè¿›è¡Œåˆ†åŒºã€‚å®ƒçš„ç±»å‹ä¼šæ˜¯ä»€ä¹ˆï¼Ÿ
- en: Exercise
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The types we have written above are not as crisp as they could be. Define a
    `has-no-duplicates` predicate, refine the relevant types with it, and check that
    the functions really do satisfy this criterion.
  id: totrans-156
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸Šé¢å†™å‡ºçš„ç±»å‹å¹¶ä¸åƒå®ƒä»¬æœ¬å¯ä»¥çš„é‚£æ ·æ¸…æ™°ã€‚å®šä¹‰ä¸€ä¸ª `has-no-duplicates` æ–­è¨€ï¼Œç”¨å®ƒæ¥ç»†åŒ–ç›¸å…³çš„ç±»å‹ï¼Œå¹¶æ£€æŸ¥è¿™äº›å‡½æ•°æ˜¯å¦çœŸçš„æ»¡è¶³è¿™ä¸ªæ ‡å‡†ã€‚
