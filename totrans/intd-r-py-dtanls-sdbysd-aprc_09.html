<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Chapter 6 Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Chapter 6 Functions</h1>
<blockquote>原文：<a href="https://randpythonbook.netlify.app/functions">https://randpythonbook.netlify.app/functions</a></blockquote>
<div id="functions" class="section level1 hasAnchor">

<p>This text has already covered how to <em>use</em> functions that come to us pre-made. At least we have discussed how to use them in a one-off way–just write the name of the function, write some parentheses after that name, and then plug in any requisite arguments by writing them in a comma-separated way between those two parentheses. This is how it works in both R and Python.</p>
<p>In this section we take a look at how to <em>define</em> our own functions. This will not only help us to understand pre-made functions, but it will also be useful if we need some extra functionality that isn’t already provided to us.</p>
<p>Writing our own functions is also useful for “packaging up” computations. The utility of this will become apparent very soon. Consider the task of estimating a regression model. If you have a function that performs all of the required calculations, then</p>
<ul>
<li>you can estimate models without having to think about lower-level details or write any code yourself, and</li>
<li>you can re-use this function every time you fit any model on any data set for any project.</li>
</ul>
<div id="defining-r-functions" class="section level2 hasAnchor">
<h2><span class="header-section-number">6.1</span> Defining R Functions<a aria-label="Anchor link to header" class="anchor-section" href="/functions#defining-r-functions"/></h2>
<p>To create a function in R, we need another function called <code>function()</code>. We give the output of <code>function()</code> a name in the same way we give names to any other variable in R, by using the assignment operator <code>&lt;-</code> . Here’s an example of a toy function called <code>addOne()</code>. Here <code>myInput</code> is a placeholder that refers to whatever the user of the function ends up plugging in.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb91-1" title="1">addOne &lt;-<span class="st"> </span><span class="cf">function</span>(myInput){  <span class="co"># define the function</span></a>
<a class="sourceLine" id="cb91-2" title="2">  myOutput &lt;-<span class="st"> </span>myInput <span class="op">+</span><span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb91-3" title="3">  <span class="kw">return</span>(myOutput)</a>
<a class="sourceLine" id="cb91-4" title="4">}</a>
<a class="sourceLine" id="cb91-5" title="5"><span class="kw">addOne</span>(<span class="dv">41</span>) <span class="co"># call/invoke/use the function </span></a>
<a class="sourceLine" id="cb91-6" title="6"><span class="co">## [1] 42</span></a></code></pre></div>
<p>Below the definition, the function is called with an input of <code>41</code>. When this happens, the following sequence of events occurs</p>
<ul>
<li>The value <code>41</code> is assigned to <code>myInput</code></li>
<li><code>myOutput</code> is given the value <code>42</code></li>
<li><code>myOutput</code>, which is <code>42</code>, is returned from the function</li>
<li>the temporary variables <code>myInput</code> and <code>myOutput</code> are destroyed.</li>
</ul>
<p>We get the desired answer, and all the unnecessary intermediate variables are cleaned up and thrown away after they are no longer needed.</p>
<div class="rmd-caution">
<p>If you are interested in writing a function, I recommend that you first write the logic outside of a function. This initial code will be easier to debug because your temporary variables will not be destroyed after the final result has been obtained. Once you are happy with the working code, you can copy and paste the logic into a function definition, and replace permanent variables with function inputs like <code>myInput</code> above.</p>
</div>
</div>
<div id="defining-python-functions" class="section level2 hasAnchor">
<h2><span class="header-section-number">6.2</span> Defining Python Functions<a aria-label="Anchor link to header" class="anchor-section" href="/functions#defining-python-functions"/></h2>
<p>To create a function in Python, we use the <code>def</code> statement (instead of the <code>function()</code> function in R). The desired name of the function comes next. After that, the formal parameters come, comma-separated inside parentheses, just like in R.</p>
<p>Defining a function in Python is a little more concise. There is no assignment operator like there is in R, there are no curly braces, and <code>return</code> isn’t a function like it is in R, so there is no need to use parentheses after it. There is one syntactic addition, though–we need a colon (<code>:</code>) at the end of the first line of the definition.</p>
<p>Here is an example of a toy function called <code>add_one()</code>.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb92-1" title="1"><span class="kw">def</span> add_one(my_input):  <span class="co"># define the function</span></a>
<a class="sourceLine" id="cb92-2" title="2">    my_output <span class="op">=</span> my_input <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb92-3" title="3">    <span class="cf">return</span> my_output</a>
<a class="sourceLine" id="cb92-4" title="4">add_one(<span class="dv">41</span>) <span class="co"># call/invoke/use the function </span></a>
<a class="sourceLine" id="cb92-5" title="5"><span class="co">## 42</span></a></code></pre></div>
<p>Below the definition, the function is called with an input of <code>41</code>. When this happens, the following sequence of events occurs</p>
<ul>
<li>The value <code>41</code> is assigned to <code>my_input</code></li>
<li><code>my_output</code> is given the value <code>42</code></li>
<li><code>my_output</code>, which is <code>42</code>, is returned from the function</li>
<li>the temporary variables <code>my_input</code> and <code>my_output</code> are destroyed.</li>
</ul>
<p>We get the desired answer, and all the unnecessary intermediate variables are cleaned up and thrown away after they are no longer needed.</p>
</div>
<div id="more-details-on-rs-user-defined-functions" class="section level2 hasAnchor">
<h2><span class="header-section-number">6.3</span> More Details On R’s User-Defined Functions<a aria-label="Anchor link to header" class="anchor-section" href="/functions#more-details-on-rs-user-defined-functions"/></h2>
<p>Technically, in R, functions are <a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Function-objects">defined as three things bundled together</a>:</p>
<ol style="list-style-type: decimal">
<li>a <strong>formal argument list</strong> (also known as <em>formals</em>),</li>
<li>a <strong>body</strong>, and</li>
<li>a <strong>parent environment</strong>.</li>
</ol>
<p>The <em>formal argument list</em> is exactly what it sounds like. It is the list of arguments a function takes. You can access a function’s formal argument list using the <code>formals()</code> function. Note that it is not the <em>actual</em> arguments a user will plug in–that isn’t knowable at the time the function is created in the first place.</p>
<p>Here is another function that takes a parameter called <code>whichNumber</code> that comes with a <strong>default argument</strong> of <code>1</code>. If the caller of the function does not specify what she wants to add to <code>myInput</code>, <code>addNumber()</code> will use <code>1</code> as the default. This default value shows up in the output of <code>formals(addNumber)</code>.</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb93-1" title="1">addNumber &lt;-<span class="st"> </span><span class="cf">function</span>(myInput, <span class="dt">whichNumber =</span> <span class="dv">1</span>){  </a>
<a class="sourceLine" id="cb93-2" title="2">  myOutput &lt;-<span class="st"> </span>myInput <span class="op">+</span><span class="st"> </span>whichNumber</a>
<a class="sourceLine" id="cb93-3" title="3">  <span class="kw">return</span>(myOutput)</a>
<a class="sourceLine" id="cb93-4" title="4">}</a>
<a class="sourceLine" id="cb93-5" title="5"><span class="kw">addNumber</span>(<span class="dv">3</span>) <span class="co"># no second argument being provided by the user here</span></a>
<a class="sourceLine" id="cb93-6" title="6"><span class="co">## [1] 4</span></a>
<a class="sourceLine" id="cb93-7" title="7"><span class="kw">formals</span>(addNumber)</a>
<a class="sourceLine" id="cb93-8" title="8"><span class="co">## $myInput</span></a>
<a class="sourceLine" id="cb93-9" title="9"><span class="co">## </span></a>
<a class="sourceLine" id="cb93-10" title="10"><span class="co">## </span></a>
<a class="sourceLine" id="cb93-11" title="11"><span class="co">## $whichNumber</span></a>
<a class="sourceLine" id="cb93-12" title="12"><span class="co">## [1] 1</span></a></code></pre></div>
<p>The function’s <em>body</em> is also exactly what it sounds like. It is the work that a function performs. You can access a function’s body using the the <code>body()</code> function.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb94-1" title="1">addNumber &lt;-<span class="st"> </span><span class="cf">function</span>(myInput, <span class="dt">whichNumber =</span> <span class="dv">1</span>){  </a>
<a class="sourceLine" id="cb94-2" title="2">  myOutput &lt;-<span class="st"> </span>myInput <span class="op">+</span><span class="st"> </span>whichNumber</a>
<a class="sourceLine" id="cb94-3" title="3">  <span class="kw">return</span>(myOutput)</a>
<a class="sourceLine" id="cb94-4" title="4">}</a>
<a class="sourceLine" id="cb94-5" title="5"><span class="kw">body</span>(addNumber)</a>
<a class="sourceLine" id="cb94-6" title="6"><span class="co">## {</span></a>
<a class="sourceLine" id="cb94-7" title="7"><span class="co">##     myOutput &lt;- myInput + whichNumber</span></a>
<a class="sourceLine" id="cb94-8" title="8"><span class="co">##     return(myOutput)</span></a>
<a class="sourceLine" id="cb94-9" title="9"><span class="co">## }</span></a></code></pre></div>
<p>Every function you create also has a <em>parent environment</em><a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a>. You can get/set this using the <code>environment()</code> function. Environments help a function know which variables it is allowed to use and how to use them. The parent environment of a function is where the function was <em>created</em>, and it contains variables outside of the body that the function can also use. The rules of which variables a function can use are called <em>scoping</em>. When you create functions in R, you are primarily using <strong>lexical scoping</strong>. This is discussed in more detail in section <a href="/functions#function-scope-in-r">6.5</a>.</p>
<div class="rmd-details">
<p>There is a lot more information about environments that isn’t provided in this text. For instance, a user-defined function also has <a href="http://adv-r.had.co.nz/Environments.html#function-envs">binding, execution, and calling environments associated with it</a>, and environments are used in creating package namespaces, which are important when two packages each have a function with the same name.</p>
</div>
</div>
<div id="more-details-on-pythons-user-defined-functions" class="section level2 hasAnchor">
<h2><span class="header-section-number">6.4</span> More details on Python’s user-defined functions<a aria-label="Anchor link to header" class="anchor-section" href="/functions#more-details-on-pythons-user-defined-functions"/></h2>
<p>Roughly, Python functions have the same things R functions have. They have a <strong>formal parameter list</strong>, a body, and there are <a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces">namespaces</a> created that help organize which variables the function can access, as well as which pieces of code can call this new function. A namespace is just a “mapping from names to objects.”</p>
<p>These three concepts are analogous to those in R. The names are just a bit different sometimes, and it isn’t organized in the same way. To access these bits of information, you need to access the <em>special attributes</em> of a function. User-defined functions in Python have a lot of pieces of information attached to them. If you’d like to see all of them, you can visit <a href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types">this page of documentation</a>.</p>
<!-- Below is a table, taken straight from [the documentation](https://docs.python.org/3/reference/datamodel.html#objects-values-and-types), of all each user-defined function's .  -->
<!-- | Attribute |  Meaning | -->
<!-- |-----------|-------------------| -->
<!-- `__doc__`  | The function’s documentation string, or `None` if unavailable; not inherited by subclasses. -->
<!-- `__name__` | The function’s name.   -->
<!-- `__qualname__` | The function’s qualified name.     -->
<!-- `__module__` | The name of the module the function was defined in, or None if unavailable. -->
<!-- `__defaults__` | A tuple containing default argument values for those arguments that have defaults, or None if no arguments have a default value. -->
<!-- `__code__` |   The code object representing the compiled function body. -->
<!-- `__globals__`  | A reference to the dictionary that holds the function’s global variables — the global namespace of the module in which the function was defined. -->
<!-- `__dict__` |   The namespace supporting arbitrary function attributes. -->
<!-- `__closure__` | `None` or a tuple of cells that contain bindings for the function’s free variables. See below for information on the `cell_contents` attribute. -->
<!-- `__annotations__` | A dict containing annotations of parameters. The keys of the dict are the parameter names, and 'return' for the return annotation, if provided. -->
<!-- `__kwdefaults__` | A dict containing defaults for keyword-only parameters. -->
<p>So, for instance, let’s try to find the <em>formal parameter list</em> of a user-defined function below. This is, again, the collection of inputs a function takes. Just like in R, this is not the <em>actual</em> arguments a user will plug in–that isn’t knowable at the time the function is created.<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a> Here we have another function called <code>add_number()</code> that takes a parameter <code>which_number</code> that is accompanied by a default argument of <code>1</code>.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb95-1" title="1"><span class="kw">def</span> add_number(my_input, which_number <span class="op">=</span> <span class="dv">1</span>): <span class="co"># define a function</span></a>
<a class="sourceLine" id="cb95-2" title="2">    my_output <span class="op">=</span> my_input <span class="op">+</span> which_number</a>
<a class="sourceLine" id="cb95-3" title="3">    <span class="cf">return</span> my_output</a>
<a class="sourceLine" id="cb95-4" title="4">add_number(<span class="dv">3</span>) <span class="co"># no second argument being provided by the user here</span></a>
<a class="sourceLine" id="cb95-5" title="5"><span class="co">## 4</span></a>
<a class="sourceLine" id="cb95-6" title="6">add_number.__code__.co_varnames <span class="co"># note this also contains *my_output*</span></a>
<a class="sourceLine" id="cb95-7" title="7"><span class="co">## ('my_input', 'which_number', 'my_output')</span></a>
<a class="sourceLine" id="cb95-8" title="8">add_number.__defaults__</a>
<a class="sourceLine" id="cb95-9" title="9"><span class="co">## (1,)</span></a></code></pre></div>
<p>The <code>__code__</code> attribute has much more to offer. To see a list of names of all its contents, you can use <code>dir(add_number.__code__)</code>.</p>
<div class="rmd-details">
<p>Don’t worry if the notation <code>add_number.__code__</code> looks strange. The dot (<code>.</code>) operator will become more clear in the future chapter on <em>object-oriented programming</em>. For now, just think of <code>__code__</code> as being an object <em>belonging to</em> <code>add_number</code>. Objects that belong to other objects are called <strong>attributes</strong> in Python. The dot operator helps us access attributes <em>inside</em> other objects. It also helps us access objects belonging to modules that we <code>import</code> into our scripts.</p>
</div>
</div>
<div id="function-scope-in-r" class="section level2 hasAnchor">
<h2><span class="header-section-number">6.5</span> Function Scope in R<a aria-label="Anchor link to header" class="anchor-section" href="/functions#function-scope-in-r"/></h2>
<p>R uses <strong>lexical scoping</strong>. This means, in R, </p>
<ol style="list-style-type: decimal">
<li>functions can use <em>local</em> variables that are defined inside themselves,<br/>
</li>
<li>functions can use <em>global</em> variables defined in the environment where the function itself was <em>defined</em> in, and</li>
<li>functions <em>cannot</em> necessarily use <em>global</em> variables defined in the environment where the function was <em>called</em> in, and</li>
<li>functions will prefer <em>local</em> variables to <em>global</em> variables if there is a name clash.</li>
</ol>
<p>The first characteristic is obvious. The second and third are import to distinguish between. Consider the following code below. <code>sillyFunction()</code> can access <code>a</code> because <code>sillyFunction()</code> and <code>a</code> are defined in the same place.</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb96-1" title="1">a &lt;-<span class="st"> </span><span class="dv">3</span></a>
<a class="sourceLine" id="cb96-2" title="2">sillyFunction &lt;-<span class="st"> </span><span class="cf">function</span>(){</a>
<a class="sourceLine" id="cb96-3" title="3">  <span class="kw">return</span>(a <span class="op">+</span><span class="st"> </span><span class="dv">20</span>) </a>
<a class="sourceLine" id="cb96-4" title="4">}</a>
<a class="sourceLine" id="cb96-5" title="5"><span class="kw">environment</span>(sillyFunction) <span class="co"># the env. it was defined in contains a</span></a>
<a class="sourceLine" id="cb96-6" title="6"><span class="co">## &lt;environment: R_GlobalEnv&gt;</span></a>
<a class="sourceLine" id="cb96-7" title="7"><span class="kw">sillyFunction</span>()</a>
<a class="sourceLine" id="cb96-8" title="8"><span class="co">## [1] 23</span></a></code></pre></div>
<p>On the other hand, the following example will not work because <code>a</code> and <code>anotherSillyFunc()</code> are not defined in the same place. Calling the function is not the same as defining a function.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb97-1" title="1">anotherSillyFunc &lt;-<span class="st"> </span><span class="cf">function</span>(){</a>
<a class="sourceLine" id="cb97-2" title="2">  <span class="kw">return</span>(a <span class="op">+</span><span class="st"> </span><span class="dv">20</span>) </a>
<a class="sourceLine" id="cb97-3" title="3">}</a>
<a class="sourceLine" id="cb97-4" title="4">highLevelFunc &lt;-<span class="st"> </span><span class="cf">function</span>(){</a>
<a class="sourceLine" id="cb97-5" title="5">  a &lt;-<span class="st"> </span><span class="dv">99</span></a>
<a class="sourceLine" id="cb97-6" title="6">  <span class="co"># this isn't the global environment anotherSillyFunc() was defined in</span></a>
<a class="sourceLine" id="cb97-7" title="7">  <span class="kw">cat</span>(<span class="st">"environment inside highLevelFunc(): "</span>, <span class="kw">environment</span>())</a>
<a class="sourceLine" id="cb97-8" title="8">  <span class="kw">anotherSillyFunc</span>()</a>
<a class="sourceLine" id="cb97-9" title="9">}</a></code></pre></div>
<p>Finally, here is a demonstration of a function preferring one <code>a</code> over another. When <code>sillyFunction()</code> attempts to access <code>a</code>, it first looks in its own body, and so the innermost one gets used. On the other hand, <code>print(a)</code> shows <code>3</code>, the global variable.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb98-1" title="1">a &lt;-<span class="st"> </span><span class="dv">3</span></a>
<a class="sourceLine" id="cb98-2" title="2">sillyFunction &lt;-<span class="st"> </span><span class="cf">function</span>(){</a>
<a class="sourceLine" id="cb98-3" title="3">  a &lt;-<span class="st"> </span><span class="dv">20</span></a>
<a class="sourceLine" id="cb98-4" title="4">  <span class="kw">return</span>(a <span class="op">+</span><span class="st"> </span><span class="dv">20</span>) </a>
<a class="sourceLine" id="cb98-5" title="5">}</a>
<a class="sourceLine" id="cb98-6" title="6"><span class="kw">sillyFunction</span>()</a>
<a class="sourceLine" id="cb98-7" title="7"><span class="co">## [1] 40</span></a>
<a class="sourceLine" id="cb98-8" title="8"><span class="kw">print</span>(a)</a>
<a class="sourceLine" id="cb98-9" title="9"><span class="co">## [1] 3</span></a></code></pre></div>
<p>The same concept applies if you create functions within functions. The inner function <code>innerFunc()</code> looks “inside-out” for variables, but only in the place it was defined.</p>
<p>Below we call <code>outerFunc()</code>, which then calls <code>innerFunc()</code>. <code>innerFunc()</code> can refer to the variable <code>b</code>, because it lies in the same environment in which <code>innerFunc()</code> was created. Interestingly, <code>innerFunc()</code> can also refer to the variable <code>a</code>, because that variable was captured by <code>outerFunc()</code>, which provides access to <code>innerFunc()</code>.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb99-1" title="1">a &lt;-<span class="st"> "outside both"</span></a>
<a class="sourceLine" id="cb99-2" title="2">outerFunc &lt;-<span class="st"> </span><span class="cf">function</span>(){</a>
<a class="sourceLine" id="cb99-3" title="3">  b &lt;-<span class="st"> "inside one"</span></a>
<a class="sourceLine" id="cb99-4" title="4">  innerFunc &lt;-<span class="st"> </span><span class="cf">function</span>(){</a>
<a class="sourceLine" id="cb99-5" title="5">    <span class="kw">print</span>(a) </a>
<a class="sourceLine" id="cb99-6" title="6">    <span class="kw">print</span>(b)</a>
<a class="sourceLine" id="cb99-7" title="7">  }</a>
<a class="sourceLine" id="cb99-8" title="8">  <span class="kw">return</span>(<span class="kw">innerFunc</span>())</a>
<a class="sourceLine" id="cb99-9" title="9">}</a>
<a class="sourceLine" id="cb99-10" title="10"><span class="kw">outerFunc</span>()</a>
<a class="sourceLine" id="cb99-11" title="11"><span class="co">## [1] "outside both"</span></a>
<a class="sourceLine" id="cb99-12" title="12"><span class="co">## [1] "inside one"</span></a></code></pre></div>
<p>Here’s another interesting example. If we ask <code>outerFunc()</code> to return the function <code>innerFunc()</code> (not the return object of <code>innerFunct()</code>…functions are objects, too!), then we might be surprised to see that <code>innerFunc()</code> can still successfully refer to <code>b</code>, even though it doesn’t exist inside the <em>calling environment.</em> But don’t be surprised! What matters is what was available when the function was <em>created</em>.</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb100-1" title="1">outerFuncV2 &lt;-<span class="st"> </span><span class="cf">function</span>(){</a>
<a class="sourceLine" id="cb100-2" title="2">  b &lt;-<span class="st"> "inside one"</span></a>
<a class="sourceLine" id="cb100-3" title="3">  innerFunc &lt;-<span class="st"> </span><span class="cf">function</span>(){</a>
<a class="sourceLine" id="cb100-4" title="4">    <span class="kw">print</span>(b)</a>
<a class="sourceLine" id="cb100-5" title="5">  }</a>
<a class="sourceLine" id="cb100-6" title="6">  <span class="kw">return</span>(innerFunc) <span class="co"># note the missing inner parentheses!</span></a>
<a class="sourceLine" id="cb100-7" title="7">}</a>
<a class="sourceLine" id="cb100-8" title="8">myFunc &lt;-<span class="st"> </span><span class="kw">outerFuncV2</span>() <span class="co"># get a new function</span></a>
<a class="sourceLine" id="cb100-9" title="9"><span class="kw">ls</span>(<span class="kw">environment</span>(myFunc)) <span class="co"># list all data attached to this function</span></a>
<a class="sourceLine" id="cb100-10" title="10"><span class="co">## [1] "b"         "innerFunc"</span></a>
<a class="sourceLine" id="cb100-11" title="11"><span class="kw">myFunc</span>()</a>
<a class="sourceLine" id="cb100-12" title="12"><span class="co">## [1] "inside one"</span></a></code></pre></div>
<p>We use this property all the time when we create functions that return other functions. This is discussed in more detail in chapter <a href="/an-introduction-to-functional-programming#an-introduction-to-functional-programming">15</a>. In the above example, <code>outerFuncV2()</code>, the function that returned another function, is called a <em>function factory</em>.</p>
<div class="rmd-details">
<p>Sometimes people will refer to R’s functions as <strong>closures</strong> to emphasize that they are capturing variables from the parent environment in which they were created, to emphasize the data that they are bundled with.</p>
</div>
</div>
<div id="function-scope-in-python" class="section level2 hasAnchor">
<h2><span class="header-section-number">6.6</span> Function Scope in Python<a aria-label="Anchor link to header" class="anchor-section" href="/functions#function-scope-in-python"/></h2>
<p>Python uses <strong>lexical scoping</strong> just like R. This means, in Python,</p>
<ol style="list-style-type: decimal">
<li>functions can use <em>local</em> variables that are defined inside themselves,<br/>
</li>
<li>functions have an order of preference for which variable to prefer in the case of a name clash, and</li>
<li>functions can sometimes use variables defined outside itself, but that ability depends on where the function and variable were <em>defined</em>, not where the function was <em>called</em>.</li>
</ol>
<p>Regarding characteristics (2) and (3), there is a famous acronym that describes the rules Python follows when finding and choosing variables: <strong>LEGB</strong>.</p>
<ul>
<li>L: Local,</li>
<li>E: Enclosing,</li>
<li>G: Global, and</li>
<li>B: Built-in.</li>
</ul>
<p>A Python function will search for a variable in these namespaces in this order.<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a>.</p>
<p>“<em>Local</em>” refers to variables that are defined inside of the function’s block. The function below uses the local <code>a</code> over the global one.</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb101-1" title="1">a <span class="op">=</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb101-2" title="2"><span class="kw">def</span> silly_function():</a>
<a class="sourceLine" id="cb101-3" title="3">    a <span class="op">=</span> <span class="dv">22</span> <span class="co"># local a</span></a>
<a class="sourceLine" id="cb101-4" title="4">    <span class="bu">print</span>(<span class="st">"local variables are "</span>, <span class="bu">locals</span>())</a>
<a class="sourceLine" id="cb101-5" title="5">    <span class="cf">return</span> a <span class="op">+</span> <span class="dv">20</span></a>
<a class="sourceLine" id="cb101-6" title="6">silly_function()</a>
<a class="sourceLine" id="cb101-7" title="7"><span class="co">## local variables are  {'a': 22}</span></a>
<a class="sourceLine" id="cb101-8" title="8"><span class="co">## 42</span></a>
<a class="sourceLine" id="cb101-9" title="9">silly_function.__code__.co_nlocals <span class="co"># number of local variables</span></a>
<a class="sourceLine" id="cb101-10" title="10"><span class="co">## 1</span></a>
<a class="sourceLine" id="cb101-11" title="11">silly_function.__code__.co_varnames <span class="co"># names of local variables</span></a>
<a class="sourceLine" id="cb101-12" title="12"><span class="co">## ('a',)</span></a></code></pre></div>
<p>“<em>Enclosing</em>” refers to variables that were defined in the enclosing namespace, but not the global namespace. These variables are sometimes called <strong>free variables.</strong> In the example below, there is no local <code>a</code> variable for <code>inner_func()</code>, but there is a global one, and one in the enclosing namespace. <code>inner_func()</code> chooses the one in the enclosing namespace. Moreover, <code>inner_func()</code> has its own copy of <code>a</code> to use, even after <code>a</code> was initially destroyed upon the completion of the call to <code>outer_func()</code>.</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb102-1" title="1">a <span class="op">=</span> <span class="st">"outside both"</span></a>
<a class="sourceLine" id="cb102-2" title="2"><span class="kw">def</span> outer_func():</a>
<a class="sourceLine" id="cb102-3" title="3">    a <span class="op">=</span> <span class="st">"inside one"</span></a>
<a class="sourceLine" id="cb102-4" title="4">    <span class="kw">def</span> inner_func():</a>
<a class="sourceLine" id="cb102-5" title="5">        <span class="bu">print</span>(a)</a>
<a class="sourceLine" id="cb102-6" title="6">    <span class="cf">return</span> inner_func</a>
<a class="sourceLine" id="cb102-7" title="7">my_new_func <span class="op">=</span> outer_func()</a>
<a class="sourceLine" id="cb102-8" title="8">my_new_func()</a>
<a class="sourceLine" id="cb102-9" title="9"><span class="co">## inside one</span></a>
<a class="sourceLine" id="cb102-10" title="10">my_new_func.__code__.co_freevars</a>
<a class="sourceLine" id="cb102-11" title="11"><span class="co">## ('a',)</span></a></code></pre></div>
<p>“<em>Global</em>” scope contains variables defined in the module-level namespace. If the code in the below example was the entirety of your script, then <code>a</code> would be a global variable.</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb103-1" title="1">a <span class="op">=</span> <span class="st">"outside both"</span></a>
<a class="sourceLine" id="cb103-2" title="2"><span class="kw">def</span> outer_func():</a>
<a class="sourceLine" id="cb103-3" title="3">    b <span class="op">=</span> <span class="st">"inside one"</span></a>
<a class="sourceLine" id="cb103-4" title="4">    <span class="kw">def</span> inner_func():</a>
<a class="sourceLine" id="cb103-5" title="5">        <span class="bu">print</span>(a) </a>
<a class="sourceLine" id="cb103-6" title="6">    inner_func()</a>
<a class="sourceLine" id="cb103-7" title="7">outer_func()</a>
<a class="sourceLine" id="cb103-8" title="8"><span class="co">## outside both</span></a></code></pre></div>
<p>Just like in R, Python functions <strong>cannot</strong> necessarily find variables where the function was <em>called</em>. For example, here is some code that mimics the above R example. Both <code>a</code> and <code>b</code> are accessible from within <code>inner_func()</code>. That is due to LEGB.</p>
<p>However, if we start using <code>outer_func()</code> inside another function, <em>calling</em> it in another function, when it was <em>defined</em> somewhere else, well then it doesn’t have access to variables in the call site. You might be surprised at how the following code functions. Does this print the right string: <code>"this is the a I want to use now!"</code> No!</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb104-1" title="1">a <span class="op">=</span> <span class="st">"outside both"</span></a>
<a class="sourceLine" id="cb104-2" title="2"><span class="kw">def</span> outer_func():</a>
<a class="sourceLine" id="cb104-3" title="3">    b <span class="op">=</span> <span class="st">"inside one"</span></a>
<a class="sourceLine" id="cb104-4" title="4">    <span class="kw">def</span> inner_func():</a>
<a class="sourceLine" id="cb104-5" title="5">        <span class="bu">print</span>(a) </a>
<a class="sourceLine" id="cb104-6" title="6">        <span class="bu">print</span>(b)</a>
<a class="sourceLine" id="cb104-7" title="7">    <span class="cf">return</span> inner_func() </a>
<a class="sourceLine" id="cb104-8" title="8"><span class="kw">def</span> third_func():</a>
<a class="sourceLine" id="cb104-9" title="9">    a <span class="op">=</span> <span class="st">"this is the a I want to use now!"</span></a>
<a class="sourceLine" id="cb104-10" title="10">    outer_func()</a>
<a class="sourceLine" id="cb104-11" title="11">third_func() </a></code></pre></div>
<pre><code>## outside both
## inside one</code></pre>
<p>If you feel like you understand lexical scoping, great! You should be ready to take on chapter <a href="/an-introduction-to-functional-programming#an-introduction-to-functional-programming">15</a>, then. If not, keep playing around with examples. Without understanding the scoping rules R and Python share, writing your own functions will persistently feel more difficult than it really is.</p>
</div>
<div id="modifying-a-functions-arguments" class="section level2 hasAnchor">
<h2><span class="header-section-number">6.7</span> Modifying a Function’s Arguments<a aria-label="Anchor link to header" class="anchor-section" href="/functions#modifying-a-functions-arguments"/></h2>
<p>Can/should we modify a function’s argument? The flexibility to do this sounds empowering; however, not doing it is recommended because it makes programs easier to reason about.</p>
<div id="passing-by-value-in-r" class="section level3 hasAnchor">
<h3><span class="header-section-number">6.7.1</span> Passing By Value In R<a aria-label="Anchor link to header" class="anchor-section" href="/functions#passing-by-value-in-r"/></h3>
<p>In R, it is <em>difficult</em> for a function to modify one of its argument.<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a> Consider the following code.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb106-1" title="1">a &lt;-<span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb106-2" title="2">f &lt;-<span class="st"> </span><span class="cf">function</span>(arg){</a>
<a class="sourceLine" id="cb106-3" title="3">  arg &lt;-<span class="st"> </span><span class="dv">2</span> <span class="co"># modifying a temporary variable, not a</span></a>
<a class="sourceLine" id="cb106-4" title="4">  <span class="kw">return</span>(arg)</a>
<a class="sourceLine" id="cb106-5" title="5">}</a>
<a class="sourceLine" id="cb106-6" title="6"><span class="kw">print</span>(<span class="kw">f</span>(a))</a>
<a class="sourceLine" id="cb106-7" title="7"><span class="co">## [1] 2</span></a>
<a class="sourceLine" id="cb106-8" title="8"><span class="kw">print</span>(a)</a>
<a class="sourceLine" id="cb106-9" title="9"><span class="co">## [1] 1</span></a></code></pre></div>
<p>The function <code>f</code> has an argument called <code>arg</code>. When <code>f(a)</code> is performed, changes are made to a <em>copy</em> of <code>a</code>. When a function constructs a copy of all input variables inside its body, this is called <strong>pass-by-value</strong> semantics. This copy is a temporary intermediate value that only serves as a starting point for the function to produce a return value of <code>2</code>.</p>
<p><code>arg</code> could have been called <code>a</code>, and the same behavior will take place. However, giving these two things different names is helpful to remind you and others that R copies its arguments.</p>
<p>It is still possible to modify <code>a</code>, but I don’t recommend doing this either. I will discuss this more in subsection <a href="/functions#modifying-a-functions-arguments">6.7</a>.</p>
</div>
<div id="passing-by-assignment-in-python" class="section level3 hasAnchor">
<h3><span class="header-section-number">6.7.2</span> Passing By Assignment In Python<a aria-label="Anchor link to header" class="anchor-section" href="/functions#passing-by-assignment-in-python"/></h3>
<p>The story is more complicated in Python. Python functions have <strong>pass-by-assignment</strong> semantics. This is something that is very unique to Python. What this means is that your ability to modify the arguments of a function depends on</p>
<ul>
<li>what the type of the argument is, and</li>
<li>what you’re trying to do to it.</li>
</ul>
<p>We will go throw some examples first, and then explain why this works the way it does. Here is some code that is analogous to the example above.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb107-1" title="1">a <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb107-2" title="2"><span class="kw">def</span> f(arg):</a>
<a class="sourceLine" id="cb107-3" title="3">    arg <span class="op">=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb107-4" title="4">    <span class="cf">return</span> arg</a>
<a class="sourceLine" id="cb107-5" title="5"><span class="bu">print</span>(f(a))</a>
<a class="sourceLine" id="cb107-6" title="6"><span class="co">## 2</span></a>
<a class="sourceLine" id="cb107-7" title="7"><span class="bu">print</span>(a)</a>
<a class="sourceLine" id="cb107-8" title="8"><span class="co">## 1</span></a></code></pre></div>
<p>In this case, <code>a</code> is not modified. That is because <code>a</code> is an <code>int</code>. <code>int</code>s are <strong>immutable</strong> in Python, which means that their <a href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types">value</a> cannot be changed after they are created, either inside or outside of the function’s scope. However, consider the case when <code>a</code> is a <code>list</code>, which is a <strong>mutable</strong> type. A mutable type is one that can have its value changed after its created.</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb108-1" title="1">a <span class="op">=</span> [<span class="dv">999</span>]</a>
<a class="sourceLine" id="cb108-2" title="2"><span class="kw">def</span> f(arg):</a>
<a class="sourceLine" id="cb108-3" title="3">    arg[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb108-4" title="4">    <span class="cf">return</span> arg</a>
<a class="sourceLine" id="cb108-5" title="5"/>
<a class="sourceLine" id="cb108-6" title="6"><span class="bu">print</span>(f(a))</a>
<a class="sourceLine" id="cb108-7" title="7"><span class="co">## [2]</span></a>
<a class="sourceLine" id="cb108-8" title="8"><span class="bu">print</span>(a) <span class="co"># not [999] anymore!</span></a>
<a class="sourceLine" id="cb108-9" title="9"><span class="co">## [2]</span></a></code></pre></div>
<p>In this case <code>a</code> <em>is</em> modified. Changing the value of the argument <em>inside</em> the function effects changes to that variable outside of the function.</p>
<p>Ready to be confused? Here is a tricky third example. What happens if we take in a list, but try to do something else with it.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb109-1" title="1">a <span class="op">=</span> [<span class="dv">999</span>]</a>
<a class="sourceLine" id="cb109-2" title="2"><span class="kw">def</span> f(arg):</a>
<a class="sourceLine" id="cb109-3" title="3">    arg <span class="op">=</span> [<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb109-4" title="4">    <span class="cf">return</span> arg</a>
<a class="sourceLine" id="cb109-5" title="5"/>
<a class="sourceLine" id="cb109-6" title="6"><span class="bu">print</span>(f(a))</a>
<a class="sourceLine" id="cb109-7" title="7"><span class="co">## [2]</span></a>
<a class="sourceLine" id="cb109-8" title="8"><span class="bu">print</span>(a) <span class="co"># didn't change this time :(</span></a>
<a class="sourceLine" id="cb109-9" title="9"><span class="co">## [999]</span></a></code></pre></div>
<p>That time <code>a</code> did not permanently change in the global scope. Why does this happen? I thought <code>list</code>s were mutable!</p>
<p>The reason behind all of this doesn’t even have anything to do with functions, per se. Rather, it has to do with how Python manages, <a href="https://docs.python.org/3/reference/datamodel.html#objects-values-and-types">objects, values, and types</a>. It also has to do with what happens during <a href="https://docs.python.org/3/reference/executionmodel.html#naming-and-binding">assignment</a>.</p>
<p>Let’s revisit the above code, but bring everything out of a function. Python is pass-by-assignment, so all we have to do is understand how assignment works. Starting with the immutable <code>int</code> example, we have the following.</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb110-1" title="1"><span class="co"># old code: </span></a>
<a class="sourceLine" id="cb110-2" title="2"><span class="co"># a = 1</span></a>
<a class="sourceLine" id="cb110-3" title="3"><span class="co"># def f(arg):</span></a>
<a class="sourceLine" id="cb110-4" title="4"><span class="co">#     arg = 2</span></a>
<a class="sourceLine" id="cb110-5" title="5"><span class="co">#     return arg</span></a>
<a class="sourceLine" id="cb110-6" title="6">a <span class="op">=</span> <span class="dv">1</span>    <span class="co"># still done in global scope</span></a>
<a class="sourceLine" id="cb110-7" title="7">arg <span class="op">=</span> a  <span class="co"># arg is a name that is bound to the object a refers to</span></a>
<a class="sourceLine" id="cb110-8" title="8">arg <span class="op">=</span> <span class="dv">2</span>  <span class="co"># arg is a name that is bound to the object 2</span></a>
<a class="sourceLine" id="cb110-9" title="9"><span class="bu">print</span>(arg <span class="kw">is</span> a)</a>
<a class="sourceLine" id="cb110-10" title="10"><span class="co">## False</span></a>
<a class="sourceLine" id="cb110-11" title="11"><span class="bu">print</span>(<span class="bu">id</span>(a), <span class="bu">id</span>(arg)) <span class="co"># different!`</span></a>
<a class="sourceLine" id="cb110-12" title="12"><span class="co">## 139774560007520 139774560007552</span></a>
<a class="sourceLine" id="cb110-13" title="13"><span class="bu">print</span>(a)</a>
<a class="sourceLine" id="cb110-14" title="14"><span class="co">## 1</span></a></code></pre></div>
<div class="rmd-details">
<p>The <a href="https://docs.python.org/3/library/functions.html#id"><code>id()</code></a> function returns the <strong>identity</strong> of an object, which is kind of like its memory address. Identities of objects are unique and constant. If two variables, <code>a</code> and <code>b</code> say, have the same identity, <code>a is b</code> will evaluate to <code>True</code>. Otherwise, it will evaluate to <code>False</code>.</p>
</div>
<p>In the first line, the <em>name</em> <code>a</code> is bound to the <em>object</em> <code>1</code>. In the second line, the name <code>arg</code> is bound to the <em>object</em> that is referred to by the <em>name</em> <code>a</code>. After the second line finishes, <code>arg</code> and <code>a</code> are two names for the same object (a fact that you can confirm by inserting <code>arg is a</code> immediately after this line).</p>
<p>In the third line, <code>arg</code> is bound to <code>2</code>. The variable <code>arg</code> can be changed, but only by re-binding it with a separate object. Re-binding <code>arg</code> does not change the value referred to by <code>a</code> because <code>a</code> still refers to <code>1</code>, an object separate from <code>2</code>. There is no reason to re-bind <code>a</code> because it wasn’t mentioned at all in the third line.</p>
<p>If we go back to the first function example, it’s basically the same idea. The only difference, however, is that <code>arg</code> is in its own scope. Let’s look at a simplified version of our second code chunk that uses a mutable list.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb111-1" title="1">a <span class="op">=</span> [<span class="dv">999</span>]</a>
<a class="sourceLine" id="cb111-2" title="2"><span class="co"># old code:</span></a>
<a class="sourceLine" id="cb111-3" title="3"><span class="co"># def f(arg):</span></a>
<a class="sourceLine" id="cb111-4" title="4"><span class="co">#     arg[0] = 2</span></a>
<a class="sourceLine" id="cb111-5" title="5"><span class="co">#     return arg</span></a>
<a class="sourceLine" id="cb111-6" title="6">arg <span class="op">=</span> a</a>
<a class="sourceLine" id="cb111-7" title="7">arg[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb111-8" title="8"><span class="bu">print</span>(arg)</a>
<a class="sourceLine" id="cb111-9" title="9"><span class="co">## [2]</span></a>
<a class="sourceLine" id="cb111-10" title="10"><span class="bu">print</span>(a)</a>
<a class="sourceLine" id="cb111-11" title="11"><span class="co">## [2]</span></a>
<a class="sourceLine" id="cb111-12" title="12"><span class="bu">print</span>(arg <span class="kw">is</span> a)</a>
<a class="sourceLine" id="cb111-13" title="13"><span class="co">## True</span></a></code></pre></div>
<p>In this example, when we run <code>arg = a</code>, the name <code>arg</code> is bound to the same object that is bound to <code>a</code>. This much is the same. The only difference here, though, is that because lists are mutable, changing the first element of <code>arg</code> is done “in place”, and all variables can access the mutated object.</p>
<p>Why did the third example produce unexpected results? The difference is in the line <code>arg = [2]</code>. This rebinds the name <code>arg</code> to a different variable. <code>list</code>s are still mutable, but this has nothing to do with re-binding–re-binding a name works no matter what type of object you’re binding it to. In this case we are re-binding <code>arg</code> to a completely different list.</p>
</div>
</div>
<div id="accessing-and-modifying-captured-variables" class="section level2 hasAnchor">
<h2><span class="header-section-number">6.8</span> Accessing and Modifying Captured Variables<a aria-label="Anchor link to header" class="anchor-section" href="/functions#accessing-and-modifying-captured-variables"/></h2>
<p>In the last section, we were talking about variables that were passed in as function arguments. Here we are talking about variables that are <strong>captured</strong>. They are not passed in as variables, but they are still used inside a function. In general, even though it is possible to access and modify non-local captured variables in both languages, it is not a good idea.</p>
<div id="accessing-captured-variables-in-r" class="section level3 hasAnchor">
<h3><span class="header-section-number">6.8.1</span> Accessing Captured Variables in R<a aria-label="Anchor link to header" class="anchor-section" href="/functions#accessing-captured-variables-in-r"/></h3>
<p>As Hadley Wickham writes in <a href="https://adv-r.hadley.nz/functions#dynamic-lookup">his book</a>, “[l]exical scoping determines where, but not when to look for values.” R has <strong>dynamic lookup</strong>, meaning code inside a function will only try to access a referred-to variable when the function is <em>running</em>, not when it is defined.</p>
<p>Consider the R code below. The <code>dataReadyForModeling()</code> function is created in the global environment, and the global environment contains a Boolean variable called <code>dataAreClean</code>.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb112-1" title="1"><span class="co"># R</span></a>
<a class="sourceLine" id="cb112-2" title="2">dataAreClean &lt;-<span class="st"> </span><span class="ot">TRUE</span></a>
<a class="sourceLine" id="cb112-3" title="3">dataReadyForModeling &lt;-<span class="st"> </span><span class="cf">function</span>(){</a>
<a class="sourceLine" id="cb112-4" title="4">  <span class="kw">return</span>(dataAreClean)</a>
<a class="sourceLine" id="cb112-5" title="5">}</a>
<a class="sourceLine" id="cb112-6" title="6">dataAreClean &lt;-<span class="st"> </span><span class="ot">FALSE</span></a>
<a class="sourceLine" id="cb112-7" title="7"><span class="co"># readyToDoSecondPart() # what happens if we call it now?</span></a></code></pre></div>
<p>Now imagine sharing some code with a collaborator. Imagine, further, that your collaborator is the subject-matter expert, and knows little about R programming. Suppose that he changes <code>dataAreClean</code>, a global variable in the script, after he is done . Shouldn’t this induce a relatively trivial change to the overall program?</p>
<p>Let’s explore this hypothetical further. Consider what could happen if any of the following (very typical) conditions are true:</p>
<ul>
<li>you or your collaborators aren’t sure what <code>dataReadyForModeling()</code> will return because you don’t understand dynamic lookup, or</li>
<li>it’s difficult to visually keep track of all assignments to <code>dataAreClean</code> (e.g. your script is quite long or it changes often), or</li>
<li>you are not running code sequentially (e.g. you are repeatedly testing chunks at a time instead of clearing out your memory and <code>source()</code>ing from scratch, over and over again).</li>
</ul>
<p>In each of these situations, understanding of the program would be compromised. However, if you follow the above principle of never referring to non-local variables in function code, all members of the group could do their own work separately, minimizing the dependence on one another.</p>
<p>Another reason violating this could be troublesome is if you define a function that refers to a nonexistent variable. <em>Defining</em> the function will never throw an error because R will assume that variable is defined in the global environment. <em>Calling</em> the function might throw an error, unless you accidentally defined the variable, or if you forgot to delete a variable whose name you no longer want to use. Defining <code>myFunc()</code> with the code below will not throw an error, even if you think it should!</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb113-1" title="1"><span class="co"># R</span></a>
<a class="sourceLine" id="cb113-2" title="2">myFunc &lt;-<span class="st"> </span><span class="cf">function</span>(){</a>
<a class="sourceLine" id="cb113-3" title="3">  <span class="kw">return</span>(varigbleNameWithTypo) <span class="co">#varigble?</span></a>
<a class="sourceLine" id="cb113-4" title="4">}</a></code></pre></div>
</div>
<div id="accessing-captured-variables-in-python" class="section level3 hasAnchor">
<h3><span class="header-section-number">6.8.2</span> Accessing Captured Variables in Python<a aria-label="Anchor link to header" class="anchor-section" href="/functions#accessing-captured-variables-in-python"/></h3>
<p>It is the same exact situation in Python. Consider <code>everything_is_safe()</code>, a function that is analogous to <code>dataReadyForModeling()</code>.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb114-1" title="1"><span class="co"># python</span></a>
<a class="sourceLine" id="cb114-2" title="2">missile_launch_codes_set <span class="op">=</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb114-3" title="3"><span class="kw">def</span> everything_is_safe():</a>
<a class="sourceLine" id="cb114-4" title="4">    <span class="cf">return</span> <span class="kw">not</span> missile_launch_codes_set</a>
<a class="sourceLine" id="cb114-5" title="5"/>
<a class="sourceLine" id="cb114-6" title="6">missile_launch_codes_set <span class="op">=</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb114-7" title="7">everything_is_safe()</a>
<a class="sourceLine" id="cb114-8" title="8"><span class="co">## True</span></a></code></pre></div>
<p>We can also define <code>my_func()</code>, which is analogous to <code>myFunc()</code>. Defining this function doesn’t throw an error either.</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb115-1" title="1"><span class="co"># python</span></a>
<a class="sourceLine" id="cb115-2" title="2"><span class="kw">def</span> my_func():</a>
<a class="sourceLine" id="cb115-3" title="3">    <span class="cf">return</span> varigble_name_with_typo</a></code></pre></div>
<p>So stay away from referring to variables outside the body of your function!</p>
</div>
<div id="modifying-captured-variables-in-r" class="section level3 hasAnchor">
<h3><span class="header-section-number">6.8.3</span> Modifying Captured Variables In R<a aria-label="Anchor link to header" class="anchor-section" href="/functions#modifying-captured-variables-in-r"/></h3>
<p>Now what if we want to be extra bad, and in addition to <em>accessing</em> global variables, we <em>modify</em> them, too?</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb116-1" title="1">a &lt;-<span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb116-2" title="2">makeATwo &lt;-<span class="st"> </span><span class="cf">function</span>(arg){</a>
<a class="sourceLine" id="cb116-3" title="3">  arg &lt;-<span class="st"> </span><span class="dv">2</span></a>
<a class="sourceLine" id="cb116-4" title="4">  a &lt;&lt;-<span class="st"> </span>arg</a>
<a class="sourceLine" id="cb116-5" title="5">}</a>
<a class="sourceLine" id="cb116-6" title="6"><span class="kw">print</span>(<span class="kw">makeATwo</span>(a))</a>
<a class="sourceLine" id="cb116-7" title="7"><span class="co">## [1] 2</span></a>
<a class="sourceLine" id="cb116-8" title="8"><span class="kw">print</span>(a)</a>
<a class="sourceLine" id="cb116-9" title="9"><span class="co">## [1] 2</span></a></code></pre></div>
<p>In the program above, <code>makeATwo()</code> copies <code>a</code> into <code>arg</code>. It then assigns <code>2</code> to that copy. <strong>Then it takes that <code>2</code> and writes it to the global <code>a</code> variable in the parent environment.</strong> It does this using R’s super assignment operator <code>&lt;&lt;-</code>. Regardless of the inputs passed in to this function, it will always assign exactly <code>2</code> to <code>a</code>, no matter what.</p>
<p>This is problematic because you are pre-occupying your mind with one function: <code>makeATwo()</code>. Whenever you write code that depends on <code>a</code> (or on things that depend on <code>a</code>, or on things that depended on things that depend on <code>a</code>, or …), you’ll have to repeatedly interrupt your train of thought to <em>try</em> and remember if what you’re doing is going to be okay with the current and future <code>makeATwo()</code> call sites.</p>
</div>
<div id="modifying-captured-variables-in-python" class="section level3 hasAnchor">
<h3><span class="header-section-number">6.8.4</span> Modifying Captured Variables In Python<a aria-label="Anchor link to header" class="anchor-section" href="/functions#modifying-captured-variables-in-python"/></h3>
<p>There is something in Python that is similar to R’s super assignment operator (<code>&lt;&lt;-</code>). It is the <code>global</code> keyword. This keyword will let you modify global variables from inside a function.</p>
<div class="rmd-details">
<p>The upside to the <code>global</code> keyword is that it makes hunting for <strong>side effects</strong> relatively easy (A function’s side effects are changes it makes to non-local variables). Yes, this keyword should be used sparingly, even more sparingly than merely referring to global variables, but if you are ever debugging, and you want to hunt down places where variables are surprisingly being changed, you can hit <code>Ctrl-F</code> and search for the phrase “global.”</p>
</div>
<div class="sourceCode" id="cb117"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb117-1" title="1">a <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb117-2" title="2"><span class="kw">def</span> increment_a():</a>
<a class="sourceLine" id="cb117-3" title="3">    <span class="kw">global</span> a</a>
<a class="sourceLine" id="cb117-4" title="4">    a <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb117-5" title="5">[increment_a() <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>)]</a>
<a class="sourceLine" id="cb117-6" title="6"><span class="co">## [None, None, None, None, None, None, None, None, None, None]</span></a>
<a class="sourceLine" id="cb117-7" title="7"><span class="bu">print</span>(a)</a>
<a class="sourceLine" id="cb117-8" title="8"><span class="co">## 11</span></a></code></pre></div>
</div>
</div>
<div id="exercises-4" class="section level2 hasAnchor">
<h2><span class="header-section-number">6.9</span> Exercises<a aria-label="Anchor link to header" class="anchor-section" href="/functions#exercises-4"/></h2>
<div id="r-questions-4" class="section level3 hasAnchor">
<h3><span class="header-section-number">6.9.1</span> R Questions<a aria-label="Anchor link to header" class="anchor-section" href="/functions#r-questions-4"/></h3>
<ol style="list-style-type: decimal">
<li/>
</ol>
<p>Suppose you have a matrix <span class="math inline">\(\mathbf{X} \in \mathbb{R}^{n \times p}\)</span> and a column vector <span class="math inline">\(\mathbf{y} \in \mathbb{R}^{n}\)</span>. To estimate the linear regression model
<span class="math display">\[\begin{equation} 
\mathbf{y} = \mathbf{X}\boldsymbol{\beta} + \epsilon,
\end{equation}\]</span>
where <span class="math inline">\(\boldsymbol{\beta} \in \mathbb{R}^p\)</span> is a column vector of errors, you can use calculus instead of numerical optimization. The formula for the least squares estimate of <span class="math inline">\(\boldsymbol{\beta}\)</span> is
<span class="math display">\[\begin{equation} 
\hat{\boldsymbol{\beta}} = (\mathbf{X}^\intercal \mathbf{X})^{-1} \mathbf{X}^\intercal \mathbf{y}.
\end{equation}\]</span></p>
<p>Once this <span class="math inline">\(p\)</span>-dimensional vector is found, you can also obtain the <em>predicted (or fitted) values</em></p>
<p><span class="math display">\[\begin{equation} 
\hat{\mathbf{y}} := \mathbf{X}\hat{\boldsymbol{\beta}},
\end{equation}\]</span>
and the <em>residuals (or errors)</em></p>
<p><span class="math display">\[\begin{equation} 
\mathbf{y} - \hat{\mathbf{y}}
\end{equation}\]</span></p>
<p>Write a function called <code>getLinModEstimates()</code> that takes in two arguments in the following order:</p>
<ul>
<li>the <code>vector</code> of response data <span class="math inline">\(\mathbf{y}\)</span></li>
<li>the <code>matrix</code> of predictors <span class="math inline">\(\mathbf{X}\)</span>.</li>
</ul>
<p>Have it return a named <code>list</code> with three outputs inside:</p>
<ul>
<li>the coefficient estimates as a <code>vector</code>,</li>
<li>a <code>vector</code> of fitted values, and</li>
<li>a <code>vector</code> of residuals.</li>
</ul>
<p>The three elements of the returned list should have the names <code>coefficients</code>, <code>fitVals</code>, and <code>residuals</code>.</p>
<ol start="2" style="list-style-type: decimal">
<li/>
</ol>
<p>Write a function called <code>monteCarlo</code> that</p>
<ul>
<li>takes as an input a function <code>sim(n)</code> that simulates <code>n</code> scalar variables,<br/>
</li>
<li>takes as an input a function that evaluates <span class="math inline">\(f(x)\)</span> on each random variable sample and that ideally takes in all of the random variables as a <code>vector</code>, and</li>
<li>returns a function that takes one integer-valued argument (<code>num_sims</code>) and outputs a length one <code>vector</code>.</li>
</ul>
<p>Assume <code>sim(n)</code> only has one argument: <code>n</code>, which is the number of simulations desired. <code>sim(n)</code>’s output should be a length <code>n</code> <code>vector</code>.</p>
<p>The output of this returned function should be a Monte Carlo estimate of the expectation: <span class="math inline">\(\mathbb{E}[f(X)] \approx \frac{1}{n}\sum_{i=1}^n f(X^i)\)</span>.</p>
<ol start="3" style="list-style-type: decimal">
<li/>
</ol>
<p>Write a function called <code>myDFT()</code> that computes the <strong>Discrete Fourier Transform</strong> of a <code>vector</code> and returns another <code>vector</code>. Feel free to check your work against <code>spec.pgram()</code>, <code>fft()</code>, or <code>astsa::mvspec()</code>, but do not include calls to those functions in your submission. Also, you should be aware that different functions transform and scale the answer differently, so be sure to read the documentation of any function you use to test against.</p>
<p>Given data <span class="math inline">\(x_1,x_2,\ldots,x_n\)</span>, <span class="math inline">\(i = \sqrt{-1}\)</span>, and the <strong>Fourier/fundamental frequencies</strong> <span class="math inline">\(\omega_j= j/n\)</span> for <span class="math inline">\(j=0,1,\ldots,n-1\)</span>, we define the discrete Fourier transform (DFT) as:</p>
<p><span class="math display">\[\begin{equation} \label{eq:DFT}
d(\omega_j)= n^{-1/2} \sum_{t=1}^n x_t e^{-2 \pi i \omega_j t}
\end{equation}\]</span></p>
</div>
<div id="python-questions-4" class="section level3 hasAnchor">
<h3><span class="header-section-number">6.9.2</span> Python Questions<a aria-label="Anchor link to header" class="anchor-section" href="/functions#python-questions-4"/></h3>
<ol style="list-style-type: decimal">
<li/>
</ol>
<p>Estimating statistical models often involves some form of optimization, and often times, optimization is performed numerically. One of the most famous optimization algorithms is <strong>Newton’s method</strong>.</p>
<p>Suppose you have a function <span class="math inline">\(f(x)\)</span> that takes a scalar-valued input and returns a scalar as well. Also, suppose you have the function’s derivative <span class="math inline">\(f'(x)\)</span>, its second derivative <span class="math inline">\(f''(x)\)</span>, and a starting point guess for what the minimizing input of <span class="math inline">\(f(x)\)</span> is: <span class="math inline">\(x_0\)</span>.</p>
<p>The algorithm repeatedly applies the following recursion:</p>
<p><span class="math display">\[\begin{equation} 
x_{n+1} = x_{n} - \frac{f'(x_n)}{f''(x_{n})}.
\end{equation}\]</span>
Under appropriate regularity conditions for <span class="math inline">\(f\)</span>, after many iterations of the above recursion, when <span class="math inline">\(\tilde{n}\)</span> is very large, <span class="math inline">\(x_{\tilde{n}}\)</span> will be nearly the same as <span class="math inline">\(x_{\tilde{n}-1}\)</span>, and <span class="math inline">\(x_{\tilde{n}}\)</span> is pretty close to <span class="math inline">\(\text{argmin}_x f(x)\)</span>. In other words, <span class="math inline">\(x_{\tilde{n}}\)</span> is the minimizer of <span class="math inline">\(f\)</span>, and a root of <span class="math inline">\(f'\)</span>.</p>
<ol style="list-style-type: lower-alpha">
<li>Write a function called <code>f</code> that takes a <code>float</code> <code>x</code> and returns <span class="math inline">\((x-42)^2 - 33\)</span>.</li>
<li>Write a function called <code>f_prime</code> that takes a <code>float</code> and returns the derivative of the above.</li>
<li>Write a function called <code>f_dub_prime</code> that takes a <code>float</code> and returns an evaluation of the second derivative of <span class="math inline">\(f\)</span>.</li>
<li>Theoretically, what is the minimizer of <span class="math inline">\(f\)</span>? Assign your answer to the variable <code>best_x</code>.</li>
<li>Write a function called <code>minimize()</code> that takes three arguments, and performs <strong>ten iterations</strong> of Newton’s algorithm, after which it returns <span class="math inline">\(x_{10}\)</span>. Don’t be afraid of copy/pasting ten or so lines of code. We haven’t learned loops yet, so that’s fine. The ordered arguments are:
<ul>
<li>the function that evaluates the derivative of the function you’re interested in,</li>
<li>the function that evaluates the second derivative of your objective function,</li>
<li>an initial guess of the minimizer.</li>
</ul></li>
<li>Test your function by plugging in the above functions, and use a starting point of <span class="math inline">\(10\)</span>. Assign the output to a variable called <code>x_ten</code>.</li>
</ol>
<ol start="2" style="list-style-type: decimal">
<li/>
</ol>
<p>Write a function called <code>smw_inverse(A,U,C,V)</code> that returns the inverse of a matrix using the <strong>Sherman-Morrison-Woodbury formula</strong> <span class="citation">(Guttman <a href="#ref-woodbury">1946</a>)</span>. Have it take the arguments <span class="math inline">\(A\)</span>, <span class="math inline">\(U\)</span>, <span class="math inline">\(C\)</span>, and <span class="math inline">\(V\)</span> in that order and as Numpy <code>ndarray</code>s. Assume that <code>A</code> is a diagonal matrix.</p>
<p><span class="math display">\[\begin{equation} 
(A + UCV)^{-1} = A^{-1} - A^{-1}U(C^{-1} + VA^{-1}U)^{-1}V A^{-1}
\end{equation}\]</span>
Despite being difficult to remember, this formula can be quite handy for speeding up matrix inversions when <span class="math inline">\(A\)</span> and <span class="math inline">\(C\)</span> are easier to invert (e.g. if <span class="math inline">\(A\)</span> is diagonal and <span class="math inline">\(C\)</span> is a scalar). The formula often shows up a lot in applications where you multiply matrices together (there are many such examples).</p>
<p>To check your work, pick certain inputs, and make sure your formula corresponds with the naive, left-hand-side approach.</p>

</div>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-woodbury">
<p>Guttman, Louis. 1946. “Enlargement Methods for Computing the Inverse Matrix.” <em>The Annals of Mathematical Statistics</em> 17 (3): 336–43. <a href="https://doi.org/10.1214/aoms/1177730946">https://doi.org/10.1214/aoms/1177730946</a>.</p>
</div>
</div>
<div class="footnotes">
<hr/>
<ol start="10">
<li id="fn10"><p>Primitive functions are functions that contain no R code and are internally implemented in C. These are the only type of function in R that don’t have a parent environment.<a class="footnote-back" href="/functions#fnref10">↩</a></p></li>
<li id="fn11"><p>You might have noticed that Python uses two different words to prevent confusion. Unlike R, Python uses the word “parameter” (instead of “argument”) to refer to the inputs a function takes, and “arguments” to the specific values a user plugs in.<a class="footnote-back" href="/functions#fnref11">↩</a></p></li>
<li id="fn12"><p>Functions aren’t the only thing that get their own namespace. <a href="https://docs.python.org/3/tutorial/classes.html#a-first-look-at-classes">Classes do, too</a>. More information on classes is provided in Chapter <a href="/an-introduction-to-object-oriented-programming#an-introduction-to-object-oriented-programming">14</a><a class="footnote-back" href="/functions#fnref12">↩</a></p></li>
<li id="fn13"><p>There are some exceptions to this, but it’s generally true.<a class="footnote-back" href="/functions#fnref13">↩</a></p></li>
</ol>
</div>
                
</body>
</html>