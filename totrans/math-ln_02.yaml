- en: 2\. Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://leanprover-community.github.io/mathematics_in_lean/C02_Basics.html](https://leanprover-community.github.io/mathematics_in_lean/C02_Basics.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*[Mathematics in Lean](index.html)* **   2\. Basics'
  prefs: []
  type: TYPE_NORMAL
- en: '[View page source](_sources/C02_Basics.rst.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is designed to introduce you to the nuts and bolts of mathematical
    reasoning in Lean: calculating, applying lemmas and theorems, and reasoning about
    generic structures.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.1\. Calculating[](#calculating "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We generally learn to carry out mathematical calculations without thinking of
    them as proofs. But when we justify each step in a calculation, as Lean requires
    us to do, the net result is a proof that the left-hand side of the calculation
    is equal to the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: In Lean, stating a theorem is tantamount to stating a goal, namely, the goal
    of proving the theorem. Lean provides the rewriting tactic `rw`, to replace the
    left-hand side of an identity by the right-hand side in the goal. If `a`, `b`,
    and `c` are real numbers, `mul_assoc a b c` is the identity `a * b * c = a * (b
    * c)` and `mul_comm a b` is the identity `a * b = b * a`. Lean provides automation
    that generally eliminates the need to refer the facts like these explicitly, but
    they are useful for the purposes of illustration. In Lean, multiplication associates
    to the left, so the left-hand side of `mul_assoc` could also be written `(a *
    b) * c`. However, it is generally good style to be mindful of Lean’s notational
    conventions and leave out parentheses when Lean does as well.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try out `rw`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `import` lines at the beginning of the associated examples file import the
    theory of the real numbers from Mathlib, as well as useful automation. For the
    sake of brevity, we generally suppress information like this in the textbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are welcome to make changes to see what happens. You can type the `ℝ` character
    as `\R` or `\real` in VS Code. The symbol doesn’t appear until you hit space or
    the tab key. If you hover over a symbol when reading a Lean file, VS Code will
    show you the syntax that can be used to enter it. If you are curious to see all
    available abbreviations, you can hit Ctrl-Shift-P and then type abbreviations
    to get access to the `Lean 4: Show Unicode Input Abbreviations` command. If your
    keyboard does not have an easily accessible backslash, you can change the leading
    character by changing the `lean4.input.leader` setting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a cursor is in the middle of a tactic proof, Lean reports on the current
    *proof state* in the *Lean Infoview* window. As you move your cursor past each
    step of the proof, you can see the state change. A typical proof state in Lean
    might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The lines before the one that begins with `⊢` denote the *context*: they are
    the objects and assumptions currently at play. In this example, these include
    two objects, `x` and `y`, each a natural number. They also include three assumptions,
    labelled `h₁`, `h₂`, and `h₃`. In Lean, everything in a context is labelled with
    an identifier. You can type these subscripted labels as `h\1`, `h\2`, and `h\3`,
    but any legal identifiers would do: you can use `h1`, `h2`, `h3` instead, or `foo`,
    `bar`, and `baz`. The last line represents the *goal*, that is, the fact to be
    proved. Sometimes people use *target* for the fact to be proved, and *goal* for
    the combination of the context and the target. In practice, the intended meaning
    is usually clear.'
  prefs: []
  type: TYPE_NORMAL
- en: Try proving these identities, in each case replacing `sorry` by a tactic proof.
    With the `rw` tactic, you can use a left arrow (`\l`) to reverse an identity.
    For example, `rw [← mul_assoc a b c]` replaces `a * (b * c)` by `a * b * c` in
    the current goal. Note that the left-pointing arrow refers to going from right
    to left in the identity provided by `mul_assoc`, it has nothing to do with the
    left or right side of the goal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can also use identities like `mul_assoc` and `mul_comm` without arguments.
    In this case, the rewrite tactic tries to match the left-hand side with an expression
    in the goal, using the first pattern it finds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can also provide *partial* information. For example, `mul_comm a` matches
    any pattern of the form `a * ?` and rewrites it to `? * a`. Try doing the first
    of these examples without providing any arguments at all, and the second with
    only one argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `rw` with facts from the local context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Try these, using the theorem `sub_self` for the second one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Multiple rewrite commands can be carried out with a single command, by listing
    the relevant identities separated by commas inside the square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You still see the incremental progress by placing the cursor after a comma in
    any list of rewrites.
  prefs: []
  type: TYPE_NORMAL
- en: Another trick is that we can declare variables once and for all outside an example
    or theorem. Lean then includes them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspection of the tactic state at the beginning of the above proof reveals
    that Lean indeed included all variables. We can delimit the scope of the declaration
    by putting it in a `section ... end` block. Finally, recall from the introduction
    that Lean provides us with a command to determine the type of an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#check` command works for both objects and facts. In response to the command
    `#check a`, Lean reports that `a` has type `ℝ`. In response to the command `#check
    mul_comm a b`, Lean reports that `mul_comm a b` is a proof of the fact `a * b
    = b * a`. The command `#check (a : ℝ)` states our expectation that the type of
    `a` is `ℝ`, and Lean will raise an error if that is not the case. We will explain
    the output of the last three `#check` commands later, but in the meanwhile, you
    can take a look at them, and experiment with some `#check` commands of your own.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try some more examples. The theorem `two_mul a` says that `2 * a = a +
    a`. The theorems `add_mul` and `mul_add` express the distributivity of multiplication
    over addition, and the theorem `add_assoc` expresses the associativity of addition.
    Use the `#check` command to see the precise statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Whereas it is possible to figure out what is going on in this proof by stepping
    through it in the editor, it is hard to read on its own. Lean provides a more
    structured way of writing proofs like this using the `calc` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the proof does *not* begin with `by`: an expression that begins
    with `calc` is a *proof term*. A `calc` expression can also be used inside a tactic
    proof, but Lean interprets it as the instruction to use the resulting proof term
    to solve the goal. The `calc` syntax is finicky: the underscores and justification
    have to be in the format indicated above. Lean uses indentation to determine things
    like where a block of tactics or a `calc` block begins and ends; try changing
    the indentation in the proof above to see what happens.'
  prefs: []
  type: TYPE_NORMAL
- en: One way to write a `calc` proof is to outline it first using the `sorry` tactic
    for justification, make sure Lean accepts the expression modulo these, and then
    justify the individual steps using tactics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Try proving the following identity using both a pure `rw` proof and a more
    structured `calc` proof:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The following exercise is a little more challenging. You can use the theorems
    listed underneath.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can also perform rewriting in an assumption in the context. For example,
    `rw [mul_comm a b] at hyp` replaces `a * b` by `b * a` in the assumption `hyp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the last step, the `exact` tactic can use `hyp` to solve the goal because
    at that point `hyp` matches the goal exactly.
  prefs: []
  type: TYPE_NORMAL
- en: We close this section by noting that Mathlib provides a useful bit of automation
    with a `ring` tactic, which is designed to prove identities in any commutative
    ring as long as they follow purely from the ring axioms, without using any local
    assumption.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `ring` tactic is imported indirectly when we import `Mathlib.Data.Real.Basic`,
    but we will see in the next section that it can be used for calculations on structures
    other than the real numbers. It can be imported explicitly with the command `import
    Mathlib.Tactic`. We will see there are similar tactics for other common kind of
    algebraic structures.
  prefs: []
  type: TYPE_NORMAL
- en: There is a variation of `rw` called `nth_rw` that allows you to replace only
    particular instances of an expression in the goal. Possible matches are enumerated
    starting with 1, so in the following example, `nth_rw 2 [h]` replaces the second
    occurrence of `a + b` with `c`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '## 2.2\. Proving Identities in Algebraic Structures[](#proving-identities-in-algebraic-structures
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically, a ring consists of a collection of objects, \(R\), operations
    \(+\) \(\times\), and constants \(0\) and \(1\), and an operation \(x \mapsto
    -x\) such that:'
  prefs: []
  type: TYPE_NORMAL
- en: \(R\) with \(+\) is an *abelian group*, with \(0\) as the additive identity
    and negation as inverse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplication is associative with identity \(1\), and multiplication distributes
    over addition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Lean, the collection of objects is represented as a *type*, `R`. The ring
    axioms are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You will learn more about the square brackets in the first line later, but for
    the time being, suffice it to say that the declaration gives us a type, `R`, and
    a ring structure on `R`. Lean then allows us to use generic ring notation with
    elements of `R`, and to make use of a library of theorems about rings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The names of some of the theorems should look familiar: they are exactly the
    ones we used to calculate with the real numbers in the last section. Lean is good
    not only for proving things about concrete mathematical structures like the natural
    numbers and the integers, but also for proving things about abstract structures,
    characterized axiomatically, like rings. Moreover, Lean supports *generic reasoning*
    about both abstract and concrete structures, and can be trained to recognize appropriate
    instances. So any theorem about rings can be applied to concrete rings like the
    integers, `ℤ`, the rational numbers, `ℚ`, and the complex numbers `ℂ`. It can
    also be applied to any instance of an abstract structure that extends rings, such
    as any ordered ring or any field.'
  prefs: []
  type: TYPE_NORMAL
- en: Not all important properties of the real numbers hold in an arbitrary ring,
    however. For example, multiplication on the real numbers is commutative, but that
    does not hold in general. If you have taken a course in linear algebra, you will
    recognize that, for every \(n\), the \(n\) by \(n\) matrices of real numbers form
    a ring in which commutativity usually fails. If we declare `R` to be a *commutative*
    ring, in fact, all the theorems in the last section continue to hold when we replace
    `ℝ` by `R`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We leave it to you to check that all the other proofs go through unchanged.
    Notice that when a proof is short, like `by ring` or `by linarith` or `by sorry`,
    it is common (and permissible) to put it on the same line as the `by`. Good proof-writing
    style should strike a balance between concision and readability.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this section is to strengthen the skills you have developed in the
    last section and apply them to reasoning axiomatically about rings. We will start
    with the axioms listed above, and use them to derive other facts. Most of the
    facts we prove are already in Mathlib. We will give the versions we prove the
    same names to help you learn the contents of the library as well as the naming
    conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lean provides an organizational mechanism similar to those used in programming
    languages: when a definition or theorem `foo` is introduced in a *namespace* `bar`,
    its full name is `bar.foo`. The command `open bar` later *opens* the namespace,
    which allows us to use the shorter name `foo`. To avoid errors due to name clashes,
    in the next example we put our versions of the library theorems in a new namespace
    called `MyRing.`'
  prefs: []
  type: TYPE_NORMAL
- en: The next example shows that we do not need `add_zero` or `add_neg_cancel` as
    ring axioms, because they follow from the other axioms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The net effect is that we can temporarily reprove a theorem in the library,
    and then go on using the library version after that. But don’t cheat! In the exercises
    that follow, take care to use only the general facts about rings that we have
    proved earlier in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '(If you are paying careful attention, you may have noticed that we changed
    the round brackets in `(R : Type*)` for curly brackets in `{R : Type*}`. This
    declares `R` to be an *implicit argument*. We will explain what this means in
    a moment, but don’t worry about it in the meanwhile.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a useful theorem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Prove the companion version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Use these to prove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With enough planning, you can do each of them with three rewrites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now explain the use of the curly braces. Imagine you are in a situation
    where you have `a`, `b`, and `c` in your context, as well as a hypothesis `h :
    a + b = a + c`, and you would like to draw the conclusion `b = c`. In Lean, you
    can apply a theorem to hypotheses and facts just the same way that you can apply
    them to objects, so you might think that `add_left_cancel a b c h` is a proof
    of the fact `b = c`. But notice that explicitly writing `a`, `b`, and `c` is redundant,
    because the hypothesis `h` makes it clear that those are the objects we have in
    mind. In this case, typing a few extra characters is not onerous, but if we wanted
    to apply `add_left_cancel` to more complicated expressions, writing them would
    be tedious. In cases like these, Lean allows us to mark arguments as *implicit*,
    meaning that they are supposed to be left out and inferred by other means, such
    as later arguments and hypotheses. The curly brackets in `{a b c : R}` do exactly
    that. So, given the statement of the theorem above, the correct expression is
    simply `add_left_cancel h`.'
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate, let us show that `a * 0 = 0` follows from the ring axioms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used a new trick! If you step through the proof, you can see what is
    going on. The `have` tactic introduces a new goal, `a * 0 + a * 0 = a * 0 + 0`,
    with the same context as the original goal. The fact that the next line is indented
    indicates that Lean is expecting a block of tactics that serves to prove this
    new goal. The indentation therefore promotes a modular style of proof: the indented
    subproof establishes the goal that was introduced by the `have`. After that, we
    are back to proving the original goal, except a new hypothesis `h` has been added:
    having proved it, we are now free to use it. At this point, the goal is exactly
    the result of `add_left_cancel h`.'
  prefs: []
  type: TYPE_NORMAL
- en: We could equally well have closed the proof with `apply add_left_cancel h` or
    `exact add_left_cancel h`. The `exact` tactic takes as argument a proof term which
    completely proves the current goal, without creating any new goal. The `apply`
    tactic is a variant whose argument is not necessarily a complete proof. The missing
    pieces are either inferred automatically by Lean or become new goals to prove.
    While the `exact` tactic is technically redundant since it is strictly less powerful
    than `apply`, it makes proof scripts slightly clearer to human readers and easier
    to maintain when the library evolves.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that multiplication is not assumed to be commutative, so the following
    theorem also requires some work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: By now, you should also be able replace each `sorry` in the next exercise with
    a proof, still using only facts about rings that we have established in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We had to use the annotation `(-0 : R)` instead of `0` in the third theorem
    because without specifying `R` it is impossible for Lean to infer which `0` we
    have in mind, and by default it would be interpreted as a natural number.'
  prefs: []
  type: TYPE_NORMAL
- en: In Lean, subtraction in a ring is provably equal to addition of the additive
    inverse.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'On the real numbers, it is *defined* that way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The proof term `rfl` is short for “reflexivity”. Presenting it as a proof of
    `a - b = a + -b` forces Lean to unfold the definition and recognize both sides
    as being the same. The `rfl` tactic does the same. This is an instance of what
    is known as a *definitional equality* in Lean’s underlying logic. This means that
    not only can one rewrite with `sub_eq_add_neg` to replace `a - b = a + -b`, but
    in some contexts, when dealing with the real numbers, you can use the two sides
    of the equation interchangeably. For example, you now have enough information
    to prove the theorem `self_sub` from the last section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Show that you can prove this using `rw`, but if you replace the arbitrary ring
    `R` by the real numbers, you can also prove it using either `apply` or `exact`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lean knows that `1 + 1 = 2` holds in any ring. With a bit of effort, you can
    use that to prove the theorem `two_mul` from the last section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We close this section by noting that some of the facts about addition and negation
    that we established above do not need the full strength of the ring axioms, or
    even commutativity of addition. The weaker notion of a *group* can be axiomatized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It is conventional to use additive notation when the group operation is commutative,
    and multiplicative notation otherwise. So Lean defines a multiplicative version
    as well as the additive version (and also their abelian variants, `AddCommGroup`
    and `CommGroup`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you are feeling cocky, try proving the following facts about groups, using
    only these axioms. You will need to prove a number of helper lemmas along the
    way. The proofs we have carried out in this section provide some hints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Explicitly invoking those lemmas is tedious, so Mathlib provides tactics similar
    to ring in order to cover most uses: group is for non-commutative multiplicative
    groups, abel for abelian additive groups, and noncomm_ring for non-commutative
    rings. It may seem odd that the algebraic structures are called Ring and CommRing
    while the tactics are named noncomm_ring and ring. This is partly for historical
    reasons, but also for the convenience of using a shorter name for the tactic that
    deals with commutative rings, since it is used more often.  ## 2.3\. Using Theorems
    and Lemmas[](#using-theorems-and-lemmas "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting is great for proving equations, but what about other sorts of theorems?
    For example, how can we prove an inequality, like the fact that \(a + e^b \le
    a + e^c\) holds whenever \(b \le c\)? We have already seen that theorems can be
    applied to arguments and hypotheses, and that the `apply` and `exact` tactics
    can be used to solve goals. In this section, we will make good use of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the library theorems `le_refl` and `le_trans`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As we explain in more detail in [Section 3.1](C03_Logic.html#implication-and-the-universal-quantifier),
    the implicit parentheses in the statement of `le_trans` associate to the right,
    so it should be interpreted as `a ≤ b → (b ≤ c → a ≤ c)`. The library designers
    have set the arguments `a`, `b` and `c` to `le_trans` implicit, so that Lean will
    *not* let you provide them explicitly (unless you really insist, as we will discuss
    later). Rather, it expects to infer them from the context in which they are used.
    For example, when hypotheses `h : a ≤ b` and `h'' : b ≤ c` are in the context,
    all the following work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `apply` tactic takes a proof of a general statement or implication, tries
    to match the conclusion with the current goal, and leaves the hypotheses, if any,
    as new goals. If the given proof matches the goal exactly (modulo *definitional*
    equality), you can use the `exact` tactic instead of `apply`. So, all of these
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first example, applying `le_trans` creates two goals, and we use the
    dots to indicate where the proof of each begins. The dots are optional, but they
    serve to *focus* the goal: within the block introduced by the dot, only one goal
    is visible, and it must be completed before the end of the block. Here we end
    the first block by starting a new one with another dot. We could just as well
    have decreased the indentation. In the third example and in the last example,
    we avoid going into tactic mode entirely: `le_trans h₀ h₁` and `le_refl x` are
    the proof terms we need.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few more library theorems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Use them together with `apply` and `exact` to prove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, Lean has a tactic that does this sort of thing automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `linarith` tactic is designed to handle *linear arithmetic*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In addition to equations and inequalities in the context, `linarith` will use
    additional inequalities that you pass as arguments. In the next example, `exp_le_exp.mpr
    h'` is a proof of `exp b ≤ exp c`, as we will explain in a moment. Notice that,
    in Lean, we write `f x` to denote the application of a function `f` to the argument
    `x`, exactly the same way we write `h x` to denote the result of applying a fact
    or theorem `h` to the argument `x`. Parentheses are only needed for compound arguments,
    as in `f (x + y)`. Without the parentheses, `f x + y` would be parsed as `(f x)
    + y`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here are some more theorems in the library that can be used to establish inequalities
    on the real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the theorems, `exp_le_exp`, `exp_lt_exp` use a *bi-implication*, which
    represents the phrase “if and only if.” (You can type it in VS Code with `\lr`
    or `\iff`). We will discuss this connective in greater detail in the next chapter.
    Such a theorem can be used with `rw` to rewrite a goal to an equivalent one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, however, we will use the fact that if `h : A ↔ B` is such
    an equivalence, then `h.mp` establishes the forward direction, `A → B`, and `h.mpr`
    establishes the reverse direction, `B → A`. Here, `mp` stands for “modus ponens”
    and `mpr` stands for “modus ponens reverse.” You can also use `h.1` and `h.2`
    for `h.mp` and `h.mpr`, respectively, if you prefer. Thus the following proof
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The first line, `apply add_lt_add_of_lt_of_le`, creates two goals, and once
    again we use a dot to separate the proof of the first from the proof of the second.
  prefs: []
  type: TYPE_NORMAL
- en: Try the following examples on your own. The example in the middle shows you
    that the `norm_num` tactic can be used to solve concrete numeric goals.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'From these examples, it should be clear that being able to find the library
    theorems you need constitutes an important part of formalization. There are a
    number of strategies you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: You can browse Mathlib in its [GitHub repository](https://github.com/leanprover-community/mathlib4).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the API documentation on the Mathlib [web pages](https://leanprover-community.github.io/mathlib4_docs/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use Loogle <https://loogle.lean-lang.org> to search Lean and Mathlib
    definitions and theorems by patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can rely on Mathlib naming conventions and Ctrl-space completion in the
    editor to guess a theorem name (or Cmd-space on a Mac keyboard). In Lean, a theorem
    named `A_of_B_of_C` establishes something of the form `A` from hypotheses of the
    form `B` and `C`, where `A`, `B`, and `C` approximate the way we might read the
    goals out loud. So a theorem establishing something like `x + y ≤ ...` will probably
    start with `add_le`. Typing `add_le` and hitting Ctrl-space will give you some
    helpful choices. Note that hitting Ctrl-space twice displays more information
    about the available completions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you right-click on an existing theorem name in VS Code, the editor will show
    a menu with the option to jump to the file where the theorem is defined, and you
    can find similar theorems nearby.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `apply?` tactic, which tries to find the relevant theorem in
    the library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To try out `apply?` in this example, delete the `exact` command and uncomment
    the previous line. Using these tricks, see if you can find what you need to do
    the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Using the same tricks, confirm that `linarith` instead of `apply?` can also
    finish the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of an inequality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Mathlib tends to put spaces around binary operations like `*` and `^`, but in
    this example, the more compressed format increases readability. There are a number
    of things worth noticing. First, an expression `s ≥ t` is definitionally equivalent
    to `t ≤ s`. In principle, this means one should be able to use them interchangeably.
    But some of Lean’s automation does not recognize the equivalence, so Mathlib tends
    to favor `≤` over `≥`. Second, we have used the `ring` tactic extensively. It
    is a real timesaver! Finally, notice that in the second line of the second `calc`
    proof, instead of writing `by exact add_le_add (le_refl _) h`, we can simply write
    the proof term `add_le_add (le_refl _) h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the only cleverness in the proof above is figuring out the hypothesis
    `h`. Once we have it, the second calculation involves only linear arithmetic,
    and `linarith` can handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: How nice! We challenge you to use these ideas to prove the following theorem.
    You can use the theorem `abs_le'.mpr`. You will also need the `constructor` tactic
    to split a conjunction to two goals; see [Section 3.4](C03_Logic.html#conjunction-and-biimplication).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If you managed to solve this, congratulations! You are well on your way to
    becoming a master formalizer.  ## 2.4\. More examples using apply and rw[](#more-examples-using-apply-and-rw
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `min` function on the real numbers is uniquely characterized by the following
    three facts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Can you guess the names of the theorems that characterize `max` in a similar
    way?
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have to apply `min` to a pair of arguments `a` and `b` by writing
    `min a b` rather than `min (a, b)`. Formally, `min` is a function of type `ℝ →
    ℝ → ℝ`. When we write a type like this with multiple arrows, the convention is
    that the implicit parentheses associate to the right, so the type is interpreted
    as `ℝ → (ℝ → ℝ)`. The net effect is that if `a` and `b` have type `ℝ` then `min
    a` has type `ℝ → ℝ` and `min a b` has type `ℝ`, so `min` acts like a function
    of two arguments, as we expect. Handling multiple arguments in this way is known
    as *currying*, after the logician Haskell Curry.
  prefs: []
  type: TYPE_NORMAL
- en: The order of operations in Lean can also take some getting used to. Function
    application binds tighter than infix operations, so the expression `min a b +
    c` is interpreted as `(min a b) + c`. With time, these conventions will become
    second nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the theorem `le_antisymm`, we can show that two real numbers are equal
    if each is less than or equal to the other. Using this and the facts above, we
    can show that `min` is commutative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have used dots to separate proofs of different goals. Our usage is
    inconsistent: at the outer level, we use dots and indentation for both goals,
    whereas for the nested proofs, we use dots only until a single goal remains. Both
    conventions are reasonable and useful. We also use the `show` tactic to structure
    the proof and indicate what is being proved in each block. The proof still works
    without the `show` commands, but using them makes the proof easier to read and
    maintain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It may bother you that the proof is repetitive. To foreshadow skills you will
    learn later on, we note that one way to avoid the repetition is to state a local
    lemma and then use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We will say more about the universal quantifier in [Section 3.1](C03_Logic.html#implication-and-the-universal-quantifier),
    but suffice it to say here that the hypothesis `h` says that the desired inequality
    holds for any `x` and `y`, and the `intro` tactic introduces an arbitrary `x`
    and `y` to establish the conclusion. The first `apply` after `le_antisymm` implicitly
    uses `h a b`, whereas the second one uses `h b a`.
  prefs: []
  type: TYPE_NORMAL
- en: Another solution is to use the `repeat` tactic, which applies a tactic (or a
    block) as many times as it can.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We encourage you to prove the following as exercises. You can use either of
    the tricks just described to shorten the first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you are welcome to prove the associativity of `max` as well.
  prefs: []
  type: TYPE_NORMAL
- en: It is an interesting fact that `min` distributes over `max` the way that multiplication
    distributes over addition, and vice-versa. In other words, on the real numbers,
    we have the identity `min a (max b c) = max (min a b) (min a c)` as well as the
    corresponding version with `max` and `min` switched. But in the next section we
    will see that this does *not* follow from the transitivity and reflexivity of
    `≤` and the characterizing properties of `min` and `max` enumerated above. We
    need to use the fact that `≤` on the real numbers is a *total order*, which is
    to say, it satisfies `∀ x y, x ≤ y ∨ y ≤ x`. Here the disjunction symbol, `∨`,
    represents “or”. In the first case, we have `min x y = x`, and in the second case,
    we have `min x y = y`. We will learn how to reason by cases in [Section 3.5](C03_Logic.html#disjunction),
    but for now we will stick to examples that don’t require the case split.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one such example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: It is clear that `aux` provides one of the two inequalities needed to prove
    the equality, but applying it to suitable values yields the other direction as
    well. As a hint, you can use the theorem `add_neg_cancel_right` and the `linarith`
    tactic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lean’s naming convention is made manifest in the library’s name for the triangle
    inequality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Use it to prove the following variant, using also `add_sub_cancel_right`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: See if you can do this in three lines or less. You can use the theorem `sub_add_cancel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important relation that we will make use of in the sections to come
    is the divisibility relation on the natural numbers, `x ∣ y`. Be careful: the
    divisibility symbol is *not* the ordinary bar on your keyboard. Rather, it is
    a unicode character obtained by typing `\|` in VS Code. By convention, Mathlib
    uses `dvd` to refer to it in theorem names.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last example, the exponent is a natural number, and applying `dvd_mul_left`
    forces Lean to expand the definition of `x^2` to `x^1 * x`. See if you can guess
    the names of the theorems you need to prove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'With respect to divisibility, the *greatest common divisor*, `gcd`, and least
    common multiple, `lcm`, are analogous to `min` and `max`. Since every number divides
    `0`, `0` is really the greatest element with respect to divisibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'See if you can guess the names of the theorems you will need to prove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Hint: you can use `dvd_antisymm`, but if you do, Lean will complain that the
    expression is ambiguous between the generic theorem and the version `Nat.dvd_antisymm`,
    the one specifically for the natural numbers. You can use `_root_.dvd_antisymm`
    to specify the generic one; either one will work.  ## 2.5\. Proving Facts about
    Algebraic Structures[](#proving-facts-about-algebraic-structures "Link to this
    heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Section 2.2](#proving-identities-in-algebraic-structures), we saw that
    many common identities governing the real numbers hold in more general classes
    of algebraic structures, such as commutative rings. We can use any axioms we want
    to describe an algebraic structure, not just equations. For example, a *partial
    order* consists of a set with a binary relation that is reflexive, transitive,
    and antisymmetric. like `≤` on the real numbers. Lean knows about partial orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here we are adopting the Mathlib convention of using letters like `α`, `β`,
    and `γ` (entered as `\a`, `\b`, and `\g`) for arbitrary types. The library often
    uses letters like `R` and `G` for the carriers of algebraic structures like rings
    and groups, respectively, but in general Greek letters are used for types, especially
    when there is little or no structure associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: Associated to any partial order, `≤`, there is also a *strict partial order*,
    `<`, which acts somewhat like `<` on the real numbers. Saying that `x` is less
    than `y` in this order is equivalent to saying that it is less-than-or-equal to
    `y` and not equal to `y`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the symbol `∧` stands for “and,” the symbol `¬` stands for
    “not,” and `x ≠ y` abbreviates `¬ (x = y)`. In [Chapter 3](C03_Logic.html#logic),
    you will learn how to use these logical connectives to *prove* that `<` has the
    properties indicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *lattice* is a structure that extends a partial order with operations `⊓`
    and `⊔` that are analogous to `min` and `max` on the real numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The characterizations of `⊓` and `⊔` justify calling them the *greatest lower
    bound* and *least upper bound*, respectively. You can type them in VS code using
    `\glb` and `\lub`. The symbols are also often called then *infimum* and the *supremum*,
    and Mathlib refers to them as `inf` and `sup` in theorem names. To further complicate
    matters, they are also often called *meet* and *join*. Therefore, if you work
    with lattices, you have to keep the following dictionary in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '`⊓` is the *greatest lower bound*, *infimum*, or *meet*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`⊔` is the *least upper bound*, *supremum*, or *join*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some instances of lattices include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`min` and `max` on any total order, such as the integers or real numbers with
    `≤`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`∩` and `∪` on the collection of subsets of some domain, with the ordering
    `⊆`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`∧` and `∨` on boolean truth values, with ordering `x ≤ y` if either `x` is
    false or `y` is true'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcd` and `lcm` on the natural numbers (or positive natural numbers), with
    the divisibility ordering, `∣`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the collection of linear subspaces of a vector space, where the greatest lower
    bound is given by the intersection, the least upper bound is given by the sum
    of the two spaces, and the ordering is inclusion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the collection of topologies on a set (or, in Lean, a type), where the greatest
    lower bound of two topologies consists of the topology that is generated by their
    union, the least upper bound is their intersection, and the ordering is reverse
    inclusion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can check that, as with `min` / `max` and `gcd` / `lcm`, you can prove the
    commutativity and associativity of the infimum and supremum using only their characterizing
    axioms, together with `le_refl` and `le_trans`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `apply le_trans` when seeing a goal `x ≤ z` is not a great idea. Indeed
    Lean has no way to guess which intermediate element `y` we want to use. So `apply
    le_trans` produces three goals that look like `x ≤ ?a`, `?a ≤ z` and `α` where
    `?a` (probably with a more complicated auto-generated name) stands for the mysterious
    `y`. The last goal, with type `α`, is to provide the value of `y`. It comes lasts
    because Lean hopes to automatically infer it from the proof of the first goal
    `x ≤ ?a`. In order to avoid this unappealing situation, you can use the `calc`
    tactic to explicitly provide `y`. Alternatively, you can use the `trans` tactic
    which takes `y` as an argument and produces the expected goals `x ≤ y` and `y
    ≤ z`. Of course you can also avoid this issue by providing directly a full proof
    such as `exact le_trans inf_le_left inf_le_right`, but this requires a lot more
    planning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You can find these theorems in the Mathlib as `inf_comm`, `inf_assoc`, `sup_comm`,
    and `sup_assoc`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another good exercise is to prove the *absorption laws* using only those axioms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: These can be found in Mathlib with the names `inf_sup_self` and `sup_inf_self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lattice that satisfies the additional identities `x ⊓ (y ⊔ z) = (x ⊓ y) ⊔
    (x ⊓ z)` and `x ⊔ (y ⊓ z) = (x ⊔ y) ⊓ (x ⊔ z)` is called a *distributive lattice*.
    Lean knows about these too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The left and right versions are easily shown to be equivalent, given the commutativity
    of `⊓` and `⊔`. It is a good exercise to show that not every lattice is distributive
    by providing an explicit description of a nondistributive lattice with finitely
    many elements. It is also a good exercise to show that in any lattice, either
    distributivity law implies the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to combine axiomatic structures into larger ones. For example,
    a *strict ordered ring* consists of a ring together with a partial order on the
    carrier satisfying additional axioms that say that the ring operations are compatible
    with the order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[Chapter 3](C03_Logic.html#logic) will provide the means to derive the following
    from `mul_pos` and the definition of `<`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'It is then an extended exercise to show that many common facts used to reason
    about arithmetic and the ordering on the real numbers hold generically for any
    ordered ring. Here are a couple of examples you can try, using only properties
    of rings, partial orders, and the facts enumerated in the last two examples (beware
    that those rings are not assumed to be commutative, so the ring tactic is not
    available):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here is one last example. A *metric space* consists of a set equipped
    with a notion of distance, `dist x y`, mapping any pair of elements to a real
    number. The distance function is assumed to satisfy the following axioms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Having mastered this section, you can show that it follows from these axioms
    that distances are always nonnegative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We recommend making use of the theorem `nonneg_of_mul_nonneg_left`. As you may
    have guessed, this theorem is called `dist_nonneg` in Mathlib. [Previous](C01_Introduction.html
    "1\. Introduction") [Next](C03_Logic.html "3\. Logic")
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: © Copyright 2020-2025, Jeremy Avigad, Patrick Massot. Text licensed under CC
    BY 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme)
    provided by [Read the Docs](https://readthedocs.org). This chapter is designed
    to introduce you to the nuts and bolts of mathematical reasoning in Lean: calculating,
    applying lemmas and theorems, and reasoning about generic structures.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.1\. Calculating[](#calculating "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We generally learn to carry out mathematical calculations without thinking of
    them as proofs. But when we justify each step in a calculation, as Lean requires
    us to do, the net result is a proof that the left-hand side of the calculation
    is equal to the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: In Lean, stating a theorem is tantamount to stating a goal, namely, the goal
    of proving the theorem. Lean provides the rewriting tactic `rw`, to replace the
    left-hand side of an identity by the right-hand side in the goal. If `a`, `b`,
    and `c` are real numbers, `mul_assoc a b c` is the identity `a * b * c = a * (b
    * c)` and `mul_comm a b` is the identity `a * b = b * a`. Lean provides automation
    that generally eliminates the need to refer the facts like these explicitly, but
    they are useful for the purposes of illustration. In Lean, multiplication associates
    to the left, so the left-hand side of `mul_assoc` could also be written `(a *
    b) * c`. However, it is generally good style to be mindful of Lean’s notational
    conventions and leave out parentheses when Lean does as well.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try out `rw`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `import` lines at the beginning of the associated examples file import the
    theory of the real numbers from Mathlib, as well as useful automation. For the
    sake of brevity, we generally suppress information like this in the textbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are welcome to make changes to see what happens. You can type the `ℝ` character
    as `\R` or `\real` in VS Code. The symbol doesn’t appear until you hit space or
    the tab key. If you hover over a symbol when reading a Lean file, VS Code will
    show you the syntax that can be used to enter it. If you are curious to see all
    available abbreviations, you can hit Ctrl-Shift-P and then type abbreviations
    to get access to the `Lean 4: Show Unicode Input Abbreviations` command. If your
    keyboard does not have an easily accessible backslash, you can change the leading
    character by changing the `lean4.input.leader` setting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a cursor is in the middle of a tactic proof, Lean reports on the current
    *proof state* in the *Lean Infoview* window. As you move your cursor past each
    step of the proof, you can see the state change. A typical proof state in Lean
    might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The lines before the one that begins with `⊢` denote the *context*: they are
    the objects and assumptions currently at play. In this example, these include
    two objects, `x` and `y`, each a natural number. They also include three assumptions,
    labelled `h₁`, `h₂`, and `h₃`. In Lean, everything in a context is labelled with
    an identifier. You can type these subscripted labels as `h\1`, `h\2`, and `h\3`,
    but any legal identifiers would do: you can use `h1`, `h2`, `h3` instead, or `foo`,
    `bar`, and `baz`. The last line represents the *goal*, that is, the fact to be
    proved. Sometimes people use *target* for the fact to be proved, and *goal* for
    the combination of the context and the target. In practice, the intended meaning
    is usually clear.'
  prefs: []
  type: TYPE_NORMAL
- en: Try proving these identities, in each case replacing `sorry` by a tactic proof.
    With the `rw` tactic, you can use a left arrow (`\l`) to reverse an identity.
    For example, `rw [← mul_assoc a b c]` replaces `a * (b * c)` by `a * b * c` in
    the current goal. Note that the left-pointing arrow refers to going from right
    to left in the identity provided by `mul_assoc`, it has nothing to do with the
    left or right side of the goal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: You can also use identities like `mul_assoc` and `mul_comm` without arguments.
    In this case, the rewrite tactic tries to match the left-hand side with an expression
    in the goal, using the first pattern it finds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: You can also provide *partial* information. For example, `mul_comm a` matches
    any pattern of the form `a * ?` and rewrites it to `? * a`. Try doing the first
    of these examples without providing any arguments at all, and the second with
    only one argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `rw` with facts from the local context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Try these, using the theorem `sub_self` for the second one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Multiple rewrite commands can be carried out with a single command, by listing
    the relevant identities separated by commas inside the square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: You still see the incremental progress by placing the cursor after a comma in
    any list of rewrites.
  prefs: []
  type: TYPE_NORMAL
- en: Another trick is that we can declare variables once and for all outside an example
    or theorem. Lean then includes them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspection of the tactic state at the beginning of the above proof reveals
    that Lean indeed included all variables. We can delimit the scope of the declaration
    by putting it in a `section ... end` block. Finally, recall from the introduction
    that Lean provides us with a command to determine the type of an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#check` command works for both objects and facts. In response to the command
    `#check a`, Lean reports that `a` has type `ℝ`. In response to the command `#check
    mul_comm a b`, Lean reports that `mul_comm a b` is a proof of the fact `a * b
    = b * a`. The command `#check (a : ℝ)` states our expectation that the type of
    `a` is `ℝ`, and Lean will raise an error if that is not the case. We will explain
    the output of the last three `#check` commands later, but in the meanwhile, you
    can take a look at them, and experiment with some `#check` commands of your own.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try some more examples. The theorem `two_mul a` says that `2 * a = a +
    a`. The theorems `add_mul` and `mul_add` express the distributivity of multiplication
    over addition, and the theorem `add_assoc` expresses the associativity of addition.
    Use the `#check` command to see the precise statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Whereas it is possible to figure out what is going on in this proof by stepping
    through it in the editor, it is hard to read on its own. Lean provides a more
    structured way of writing proofs like this using the `calc` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the proof does *not* begin with `by`: an expression that begins
    with `calc` is a *proof term*. A `calc` expression can also be used inside a tactic
    proof, but Lean interprets it as the instruction to use the resulting proof term
    to solve the goal. The `calc` syntax is finicky: the underscores and justification
    have to be in the format indicated above. Lean uses indentation to determine things
    like where a block of tactics or a `calc` block begins and ends; try changing
    the indentation in the proof above to see what happens.'
  prefs: []
  type: TYPE_NORMAL
- en: One way to write a `calc` proof is to outline it first using the `sorry` tactic
    for justification, make sure Lean accepts the expression modulo these, and then
    justify the individual steps using tactics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Try proving the following identity using both a pure `rw` proof and a more
    structured `calc` proof:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The following exercise is a little more challenging. You can use the theorems
    listed underneath.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We can also perform rewriting in an assumption in the context. For example,
    `rw [mul_comm a b] at hyp` replaces `a * b` by `b * a` in the assumption `hyp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: In the last step, the `exact` tactic can use `hyp` to solve the goal because
    at that point `hyp` matches the goal exactly.
  prefs: []
  type: TYPE_NORMAL
- en: We close this section by noting that Mathlib provides a useful bit of automation
    with a `ring` tactic, which is designed to prove identities in any commutative
    ring as long as they follow purely from the ring axioms, without using any local
    assumption.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The `ring` tactic is imported indirectly when we import `Mathlib.Data.Real.Basic`,
    but we will see in the next section that it can be used for calculations on structures
    other than the real numbers. It can be imported explicitly with the command `import
    Mathlib.Tactic`. We will see there are similar tactics for other common kind of
    algebraic structures.
  prefs: []
  type: TYPE_NORMAL
- en: There is a variation of `rw` called `nth_rw` that allows you to replace only
    particular instances of an expression in the goal. Possible matches are enumerated
    starting with 1, so in the following example, `nth_rw 2 [h]` replaces the second
    occurrence of `a + b` with `c`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '## 2.2\. Proving Identities in Algebraic Structures[](#proving-identities-in-algebraic-structures
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically, a ring consists of a collection of objects, \(R\), operations
    \(+\) \(\times\), and constants \(0\) and \(1\), and an operation \(x \mapsto
    -x\) such that:'
  prefs: []
  type: TYPE_NORMAL
- en: \(R\) with \(+\) is an *abelian group*, with \(0\) as the additive identity
    and negation as inverse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplication is associative with identity \(1\), and multiplication distributes
    over addition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Lean, the collection of objects is represented as a *type*, `R`. The ring
    axioms are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: You will learn more about the square brackets in the first line later, but for
    the time being, suffice it to say that the declaration gives us a type, `R`, and
    a ring structure on `R`. Lean then allows us to use generic ring notation with
    elements of `R`, and to make use of a library of theorems about rings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The names of some of the theorems should look familiar: they are exactly the
    ones we used to calculate with the real numbers in the last section. Lean is good
    not only for proving things about concrete mathematical structures like the natural
    numbers and the integers, but also for proving things about abstract structures,
    characterized axiomatically, like rings. Moreover, Lean supports *generic reasoning*
    about both abstract and concrete structures, and can be trained to recognize appropriate
    instances. So any theorem about rings can be applied to concrete rings like the
    integers, `ℤ`, the rational numbers, `ℚ`, and the complex numbers `ℂ`. It can
    also be applied to any instance of an abstract structure that extends rings, such
    as any ordered ring or any field.'
  prefs: []
  type: TYPE_NORMAL
- en: Not all important properties of the real numbers hold in an arbitrary ring,
    however. For example, multiplication on the real numbers is commutative, but that
    does not hold in general. If you have taken a course in linear algebra, you will
    recognize that, for every \(n\), the \(n\) by \(n\) matrices of real numbers form
    a ring in which commutativity usually fails. If we declare `R` to be a *commutative*
    ring, in fact, all the theorems in the last section continue to hold when we replace
    `ℝ` by `R`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We leave it to you to check that all the other proofs go through unchanged.
    Notice that when a proof is short, like `by ring` or `by linarith` or `by sorry`,
    it is common (and permissible) to put it on the same line as the `by`. Good proof-writing
    style should strike a balance between concision and readability.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this section is to strengthen the skills you have developed in the
    last section and apply them to reasoning axiomatically about rings. We will start
    with the axioms listed above, and use them to derive other facts. Most of the
    facts we prove are already in Mathlib. We will give the versions we prove the
    same names to help you learn the contents of the library as well as the naming
    conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lean provides an organizational mechanism similar to those used in programming
    languages: when a definition or theorem `foo` is introduced in a *namespace* `bar`,
    its full name is `bar.foo`. The command `open bar` later *opens* the namespace,
    which allows us to use the shorter name `foo`. To avoid errors due to name clashes,
    in the next example we put our versions of the library theorems in a new namespace
    called `MyRing.`'
  prefs: []
  type: TYPE_NORMAL
- en: The next example shows that we do not need `add_zero` or `add_neg_cancel` as
    ring axioms, because they follow from the other axioms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The net effect is that we can temporarily reprove a theorem in the library,
    and then go on using the library version after that. But don’t cheat! In the exercises
    that follow, take care to use only the general facts about rings that we have
    proved earlier in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '(If you are paying careful attention, you may have noticed that we changed
    the round brackets in `(R : Type*)` for curly brackets in `{R : Type*}`. This
    declares `R` to be an *implicit argument*. We will explain what this means in
    a moment, but don’t worry about it in the meanwhile.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a useful theorem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Prove the companion version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Use these to prove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: With enough planning, you can do each of them with three rewrites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now explain the use of the curly braces. Imagine you are in a situation
    where you have `a`, `b`, and `c` in your context, as well as a hypothesis `h :
    a + b = a + c`, and you would like to draw the conclusion `b = c`. In Lean, you
    can apply a theorem to hypotheses and facts just the same way that you can apply
    them to objects, so you might think that `add_left_cancel a b c h` is a proof
    of the fact `b = c`. But notice that explicitly writing `a`, `b`, and `c` is redundant,
    because the hypothesis `h` makes it clear that those are the objects we have in
    mind. In this case, typing a few extra characters is not onerous, but if we wanted
    to apply `add_left_cancel` to more complicated expressions, writing them would
    be tedious. In cases like these, Lean allows us to mark arguments as *implicit*,
    meaning that they are supposed to be left out and inferred by other means, such
    as later arguments and hypotheses. The curly brackets in `{a b c : R}` do exactly
    that. So, given the statement of the theorem above, the correct expression is
    simply `add_left_cancel h`.'
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate, let us show that `a * 0 = 0` follows from the ring axioms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used a new trick! If you step through the proof, you can see what is
    going on. The `have` tactic introduces a new goal, `a * 0 + a * 0 = a * 0 + 0`,
    with the same context as the original goal. The fact that the next line is indented
    indicates that Lean is expecting a block of tactics that serves to prove this
    new goal. The indentation therefore promotes a modular style of proof: the indented
    subproof establishes the goal that was introduced by the `have`. After that, we
    are back to proving the original goal, except a new hypothesis `h` has been added:
    having proved it, we are now free to use it. At this point, the goal is exactly
    the result of `add_left_cancel h`.'
  prefs: []
  type: TYPE_NORMAL
- en: We could equally well have closed the proof with `apply add_left_cancel h` or
    `exact add_left_cancel h`. The `exact` tactic takes as argument a proof term which
    completely proves the current goal, without creating any new goal. The `apply`
    tactic is a variant whose argument is not necessarily a complete proof. The missing
    pieces are either inferred automatically by Lean or become new goals to prove.
    While the `exact` tactic is technically redundant since it is strictly less powerful
    than `apply`, it makes proof scripts slightly clearer to human readers and easier
    to maintain when the library evolves.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that multiplication is not assumed to be commutative, so the following
    theorem also requires some work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: By now, you should also be able replace each `sorry` in the next exercise with
    a proof, still using only facts about rings that we have established in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'We had to use the annotation `(-0 : R)` instead of `0` in the third theorem
    because without specifying `R` it is impossible for Lean to infer which `0` we
    have in mind, and by default it would be interpreted as a natural number.'
  prefs: []
  type: TYPE_NORMAL
- en: In Lean, subtraction in a ring is provably equal to addition of the additive
    inverse.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'On the real numbers, it is *defined* that way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The proof term `rfl` is short for “reflexivity”. Presenting it as a proof of
    `a - b = a + -b` forces Lean to unfold the definition and recognize both sides
    as being the same. The `rfl` tactic does the same. This is an instance of what
    is known as a *definitional equality* in Lean’s underlying logic. This means that
    not only can one rewrite with `sub_eq_add_neg` to replace `a - b = a + -b`, but
    in some contexts, when dealing with the real numbers, you can use the two sides
    of the equation interchangeably. For example, you now have enough information
    to prove the theorem `self_sub` from the last section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Show that you can prove this using `rw`, but if you replace the arbitrary ring
    `R` by the real numbers, you can also prove it using either `apply` or `exact`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lean knows that `1 + 1 = 2` holds in any ring. With a bit of effort, you can
    use that to prove the theorem `two_mul` from the last section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'We close this section by noting that some of the facts about addition and negation
    that we established above do not need the full strength of the ring axioms, or
    even commutativity of addition. The weaker notion of a *group* can be axiomatized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: It is conventional to use additive notation when the group operation is commutative,
    and multiplicative notation otherwise. So Lean defines a multiplicative version
    as well as the additive version (and also their abelian variants, `AddCommGroup`
    and `CommGroup`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: If you are feeling cocky, try proving the following facts about groups, using
    only these axioms. You will need to prove a number of helper lemmas along the
    way. The proofs we have carried out in this section provide some hints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Explicitly invoking those lemmas is tedious, so Mathlib provides tactics similar
    to ring in order to cover most uses: group is for non-commutative multiplicative
    groups, abel for abelian additive groups, and noncomm_ring for non-commutative
    rings. It may seem odd that the algebraic structures are called Ring and CommRing
    while the tactics are named noncomm_ring and ring. This is partly for historical
    reasons, but also for the convenience of using a shorter name for the tactic that
    deals with commutative rings, since it is used more often.  ## 2.3\. Using Theorems
    and Lemmas[](#using-theorems-and-lemmas "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting is great for proving equations, but what about other sorts of theorems?
    For example, how can we prove an inequality, like the fact that \(a + e^b \le
    a + e^c\) holds whenever \(b \le c\)? We have already seen that theorems can be
    applied to arguments and hypotheses, and that the `apply` and `exact` tactics
    can be used to solve goals. In this section, we will make good use of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the library theorems `le_refl` and `le_trans`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'As we explain in more detail in [Section 3.1](C03_Logic.html#implication-and-the-universal-quantifier),
    the implicit parentheses in the statement of `le_trans` associate to the right,
    so it should be interpreted as `a ≤ b → (b ≤ c → a ≤ c)`. The library designers
    have set the arguments `a`, `b` and `c` to `le_trans` implicit, so that Lean will
    *not* let you provide them explicitly (unless you really insist, as we will discuss
    later). Rather, it expects to infer them from the context in which they are used.
    For example, when hypotheses `h : a ≤ b` and `h'' : b ≤ c` are in the context,
    all the following work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The `apply` tactic takes a proof of a general statement or implication, tries
    to match the conclusion with the current goal, and leaves the hypotheses, if any,
    as new goals. If the given proof matches the goal exactly (modulo *definitional*
    equality), you can use the `exact` tactic instead of `apply`. So, all of these
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first example, applying `le_trans` creates two goals, and we use the
    dots to indicate where the proof of each begins. The dots are optional, but they
    serve to *focus* the goal: within the block introduced by the dot, only one goal
    is visible, and it must be completed before the end of the block. Here we end
    the first block by starting a new one with another dot. We could just as well
    have decreased the indentation. In the third example and in the last example,
    we avoid going into tactic mode entirely: `le_trans h₀ h₁` and `le_refl x` are
    the proof terms we need.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few more library theorems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Use them together with `apply` and `exact` to prove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, Lean has a tactic that does this sort of thing automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The `linarith` tactic is designed to handle *linear arithmetic*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: In addition to equations and inequalities in the context, `linarith` will use
    additional inequalities that you pass as arguments. In the next example, `exp_le_exp.mpr
    h'` is a proof of `exp b ≤ exp c`, as we will explain in a moment. Notice that,
    in Lean, we write `f x` to denote the application of a function `f` to the argument
    `x`, exactly the same way we write `h x` to denote the result of applying a fact
    or theorem `h` to the argument `x`. Parentheses are only needed for compound arguments,
    as in `f (x + y)`. Without the parentheses, `f x + y` would be parsed as `(f x)
    + y`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Here are some more theorems in the library that can be used to establish inequalities
    on the real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the theorems, `exp_le_exp`, `exp_lt_exp` use a *bi-implication*, which
    represents the phrase “if and only if.” (You can type it in VS Code with `\lr`
    or `\iff`). We will discuss this connective in greater detail in the next chapter.
    Such a theorem can be used with `rw` to rewrite a goal to an equivalent one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, however, we will use the fact that if `h : A ↔ B` is such
    an equivalence, then `h.mp` establishes the forward direction, `A → B`, and `h.mpr`
    establishes the reverse direction, `B → A`. Here, `mp` stands for “modus ponens”
    and `mpr` stands for “modus ponens reverse.” You can also use `h.1` and `h.2`
    for `h.mp` and `h.mpr`, respectively, if you prefer. Thus the following proof
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The first line, `apply add_lt_add_of_lt_of_le`, creates two goals, and once
    again we use a dot to separate the proof of the first from the proof of the second.
  prefs: []
  type: TYPE_NORMAL
- en: Try the following examples on your own. The example in the middle shows you
    that the `norm_num` tactic can be used to solve concrete numeric goals.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'From these examples, it should be clear that being able to find the library
    theorems you need constitutes an important part of formalization. There are a
    number of strategies you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: You can browse Mathlib in its [GitHub repository](https://github.com/leanprover-community/mathlib4).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the API documentation on the Mathlib [web pages](https://leanprover-community.github.io/mathlib4_docs/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use Loogle <https://loogle.lean-lang.org> to search Lean and Mathlib
    definitions and theorems by patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can rely on Mathlib naming conventions and Ctrl-space completion in the
    editor to guess a theorem name (or Cmd-space on a Mac keyboard). In Lean, a theorem
    named `A_of_B_of_C` establishes something of the form `A` from hypotheses of the
    form `B` and `C`, where `A`, `B`, and `C` approximate the way we might read the
    goals out loud. So a theorem establishing something like `x + y ≤ ...` will probably
    start with `add_le`. Typing `add_le` and hitting Ctrl-space will give you some
    helpful choices. Note that hitting Ctrl-space twice displays more information
    about the available completions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you right-click on an existing theorem name in VS Code, the editor will show
    a menu with the option to jump to the file where the theorem is defined, and you
    can find similar theorems nearby.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `apply?` tactic, which tries to find the relevant theorem in
    the library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'To try out `apply?` in this example, delete the `exact` command and uncomment
    the previous line. Using these tricks, see if you can find what you need to do
    the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Using the same tricks, confirm that `linarith` instead of `apply?` can also
    finish the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of an inequality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Mathlib tends to put spaces around binary operations like `*` and `^`, but in
    this example, the more compressed format increases readability. There are a number
    of things worth noticing. First, an expression `s ≥ t` is definitionally equivalent
    to `t ≤ s`. In principle, this means one should be able to use them interchangeably.
    But some of Lean’s automation does not recognize the equivalence, so Mathlib tends
    to favor `≤` over `≥`. Second, we have used the `ring` tactic extensively. It
    is a real timesaver! Finally, notice that in the second line of the second `calc`
    proof, instead of writing `by exact add_le_add (le_refl _) h`, we can simply write
    the proof term `add_le_add (le_refl _) h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the only cleverness in the proof above is figuring out the hypothesis
    `h`. Once we have it, the second calculation involves only linear arithmetic,
    and `linarith` can handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: How nice! We challenge you to use these ideas to prove the following theorem.
    You can use the theorem `abs_le'.mpr`. You will also need the `constructor` tactic
    to split a conjunction to two goals; see [Section 3.4](C03_Logic.html#conjunction-and-biimplication).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'If you managed to solve this, congratulations! You are well on your way to
    becoming a master formalizer.  ## 2.4\. More examples using apply and rw[](#more-examples-using-apply-and-rw
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `min` function on the real numbers is uniquely characterized by the following
    three facts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Can you guess the names of the theorems that characterize `max` in a similar
    way?
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have to apply `min` to a pair of arguments `a` and `b` by writing
    `min a b` rather than `min (a, b)`. Formally, `min` is a function of type `ℝ →
    ℝ → ℝ`. When we write a type like this with multiple arrows, the convention is
    that the implicit parentheses associate to the right, so the type is interpreted
    as `ℝ → (ℝ → ℝ)`. The net effect is that if `a` and `b` have type `ℝ` then `min
    a` has type `ℝ → ℝ` and `min a b` has type `ℝ`, so `min` acts like a function
    of two arguments, as we expect. Handling multiple arguments in this way is known
    as *currying*, after the logician Haskell Curry.
  prefs: []
  type: TYPE_NORMAL
- en: The order of operations in Lean can also take some getting used to. Function
    application binds tighter than infix operations, so the expression `min a b +
    c` is interpreted as `(min a b) + c`. With time, these conventions will become
    second nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the theorem `le_antisymm`, we can show that two real numbers are equal
    if each is less than or equal to the other. Using this and the facts above, we
    can show that `min` is commutative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have used dots to separate proofs of different goals. Our usage is
    inconsistent: at the outer level, we use dots and indentation for both goals,
    whereas for the nested proofs, we use dots only until a single goal remains. Both
    conventions are reasonable and useful. We also use the `show` tactic to structure
    the proof and indicate what is being proved in each block. The proof still works
    without the `show` commands, but using them makes the proof easier to read and
    maintain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It may bother you that the proof is repetitive. To foreshadow skills you will
    learn later on, we note that one way to avoid the repetition is to state a local
    lemma and then use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: We will say more about the universal quantifier in [Section 3.1](C03_Logic.html#implication-and-the-universal-quantifier),
    but suffice it to say here that the hypothesis `h` says that the desired inequality
    holds for any `x` and `y`, and the `intro` tactic introduces an arbitrary `x`
    and `y` to establish the conclusion. The first `apply` after `le_antisymm` implicitly
    uses `h a b`, whereas the second one uses `h b a`.
  prefs: []
  type: TYPE_NORMAL
- en: Another solution is to use the `repeat` tactic, which applies a tactic (or a
    block) as many times as it can.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: We encourage you to prove the following as exercises. You can use either of
    the tricks just described to shorten the first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you are welcome to prove the associativity of `max` as well.
  prefs: []
  type: TYPE_NORMAL
- en: It is an interesting fact that `min` distributes over `max` the way that multiplication
    distributes over addition, and vice-versa. In other words, on the real numbers,
    we have the identity `min a (max b c) = max (min a b) (min a c)` as well as the
    corresponding version with `max` and `min` switched. But in the next section we
    will see that this does *not* follow from the transitivity and reflexivity of
    `≤` and the characterizing properties of `min` and `max` enumerated above. We
    need to use the fact that `≤` on the real numbers is a *total order*, which is
    to say, it satisfies `∀ x y, x ≤ y ∨ y ≤ x`. Here the disjunction symbol, `∨`,
    represents “or”. In the first case, we have `min x y = x`, and in the second case,
    we have `min x y = y`. We will learn how to reason by cases in [Section 3.5](C03_Logic.html#disjunction),
    but for now we will stick to examples that don’t require the case split.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one such example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: It is clear that `aux` provides one of the two inequalities needed to prove
    the equality, but applying it to suitable values yields the other direction as
    well. As a hint, you can use the theorem `add_neg_cancel_right` and the `linarith`
    tactic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lean’s naming convention is made manifest in the library’s name for the triangle
    inequality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Use it to prove the following variant, using also `add_sub_cancel_right`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: See if you can do this in three lines or less. You can use the theorem `sub_add_cancel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important relation that we will make use of in the sections to come
    is the divisibility relation on the natural numbers, `x ∣ y`. Be careful: the
    divisibility symbol is *not* the ordinary bar on your keyboard. Rather, it is
    a unicode character obtained by typing `\|` in VS Code. By convention, Mathlib
    uses `dvd` to refer to it in theorem names.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last example, the exponent is a natural number, and applying `dvd_mul_left`
    forces Lean to expand the definition of `x^2` to `x^1 * x`. See if you can guess
    the names of the theorems you need to prove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'With respect to divisibility, the *greatest common divisor*, `gcd`, and least
    common multiple, `lcm`, are analogous to `min` and `max`. Since every number divides
    `0`, `0` is really the greatest element with respect to divisibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'See if you can guess the names of the theorems you will need to prove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Hint: you can use `dvd_antisymm`, but if you do, Lean will complain that the
    expression is ambiguous between the generic theorem and the version `Nat.dvd_antisymm`,
    the one specifically for the natural numbers. You can use `_root_.dvd_antisymm`
    to specify the generic one; either one will work.  ## 2.5\. Proving Facts about
    Algebraic Structures[](#proving-facts-about-algebraic-structures "Link to this
    heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Section 2.2](#proving-identities-in-algebraic-structures), we saw that
    many common identities governing the real numbers hold in more general classes
    of algebraic structures, such as commutative rings. We can use any axioms we want
    to describe an algebraic structure, not just equations. For example, a *partial
    order* consists of a set with a binary relation that is reflexive, transitive,
    and antisymmetric. like `≤` on the real numbers. Lean knows about partial orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Here we are adopting the Mathlib convention of using letters like `α`, `β`,
    and `γ` (entered as `\a`, `\b`, and `\g`) for arbitrary types. The library often
    uses letters like `R` and `G` for the carriers of algebraic structures like rings
    and groups, respectively, but in general Greek letters are used for types, especially
    when there is little or no structure associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: Associated to any partial order, `≤`, there is also a *strict partial order*,
    `<`, which acts somewhat like `<` on the real numbers. Saying that `x` is less
    than `y` in this order is equivalent to saying that it is less-than-or-equal to
    `y` and not equal to `y`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the symbol `∧` stands for “and,” the symbol `¬` stands for
    “not,” and `x ≠ y` abbreviates `¬ (x = y)`. In [Chapter 3](C03_Logic.html#logic),
    you will learn how to use these logical connectives to *prove* that `<` has the
    properties indicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *lattice* is a structure that extends a partial order with operations `⊓`
    and `⊔` that are analogous to `min` and `max` on the real numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The characterizations of `⊓` and `⊔` justify calling them the *greatest lower
    bound* and *least upper bound*, respectively. You can type them in VS code using
    `\glb` and `\lub`. The symbols are also often called then *infimum* and the *supremum*,
    and Mathlib refers to them as `inf` and `sup` in theorem names. To further complicate
    matters, they are also often called *meet* and *join*. Therefore, if you work
    with lattices, you have to keep the following dictionary in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '`⊓` is the *greatest lower bound*, *infimum*, or *meet*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`⊔` is the *least upper bound*, *supremum*, or *join*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some instances of lattices include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`min` and `max` on any total order, such as the integers or real numbers with
    `≤`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`∩` and `∪` on the collection of subsets of some domain, with the ordering
    `⊆`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`∧` and `∨` on boolean truth values, with ordering `x ≤ y` if either `x` is
    false or `y` is true'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcd` and `lcm` on the natural numbers (or positive natural numbers), with
    the divisibility ordering, `∣`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the collection of linear subspaces of a vector space, where the greatest lower
    bound is given by the intersection, the least upper bound is given by the sum
    of the two spaces, and the ordering is inclusion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the collection of topologies on a set (or, in Lean, a type), where the greatest
    lower bound of two topologies consists of the topology that is generated by their
    union, the least upper bound is their intersection, and the ordering is reverse
    inclusion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can check that, as with `min` / `max` and `gcd` / `lcm`, you can prove the
    commutativity and associativity of the infimum and supremum using only their characterizing
    axioms, together with `le_refl` and `le_trans`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `apply le_trans` when seeing a goal `x ≤ z` is not a great idea. Indeed
    Lean has no way to guess which intermediate element `y` we want to use. So `apply
    le_trans` produces three goals that look like `x ≤ ?a`, `?a ≤ z` and `α` where
    `?a` (probably with a more complicated auto-generated name) stands for the mysterious
    `y`. The last goal, with type `α`, is to provide the value of `y`. It comes lasts
    because Lean hopes to automatically infer it from the proof of the first goal
    `x ≤ ?a`. In order to avoid this unappealing situation, you can use the `calc`
    tactic to explicitly provide `y`. Alternatively, you can use the `trans` tactic
    which takes `y` as an argument and produces the expected goals `x ≤ y` and `y
    ≤ z`. Of course you can also avoid this issue by providing directly a full proof
    such as `exact le_trans inf_le_left inf_le_right`, but this requires a lot more
    planning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: You can find these theorems in the Mathlib as `inf_comm`, `inf_assoc`, `sup_comm`,
    and `sup_assoc`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another good exercise is to prove the *absorption laws* using only those axioms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: These can be found in Mathlib with the names `inf_sup_self` and `sup_inf_self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lattice that satisfies the additional identities `x ⊓ (y ⊔ z) = (x ⊓ y) ⊔
    (x ⊓ z)` and `x ⊔ (y ⊓ z) = (x ⊔ y) ⊓ (x ⊔ z)` is called a *distributive lattice*.
    Lean knows about these too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'The left and right versions are easily shown to be equivalent, given the commutativity
    of `⊓` and `⊔`. It is a good exercise to show that not every lattice is distributive
    by providing an explicit description of a nondistributive lattice with finitely
    many elements. It is also a good exercise to show that in any lattice, either
    distributivity law implies the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to combine axiomatic structures into larger ones. For example,
    a *strict ordered ring* consists of a ring together with a partial order on the
    carrier satisfying additional axioms that say that the ring operations are compatible
    with the order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[Chapter 3](C03_Logic.html#logic) will provide the means to derive the following
    from `mul_pos` and the definition of `<`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'It is then an extended exercise to show that many common facts used to reason
    about arithmetic and the ordering on the real numbers hold generically for any
    ordered ring. Here are a couple of examples you can try, using only properties
    of rings, partial orders, and the facts enumerated in the last two examples (beware
    that those rings are not assumed to be commutative, so the ring tactic is not
    available):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here is one last example. A *metric space* consists of a set equipped
    with a notion of distance, `dist x y`, mapping any pair of elements to a real
    number. The distance function is assumed to satisfy the following axioms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Having mastered this section, you can show that it follows from these axioms
    that distances are always nonnegative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: We recommend making use of the theorem `nonneg_of_mul_nonneg_left`. As you may
    have guessed, this theorem is called `dist_nonneg` in Mathlib.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1\. Calculating[](#calculating "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We generally learn to carry out mathematical calculations without thinking of
    them as proofs. But when we justify each step in a calculation, as Lean requires
    us to do, the net result is a proof that the left-hand side of the calculation
    is equal to the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: In Lean, stating a theorem is tantamount to stating a goal, namely, the goal
    of proving the theorem. Lean provides the rewriting tactic `rw`, to replace the
    left-hand side of an identity by the right-hand side in the goal. If `a`, `b`,
    and `c` are real numbers, `mul_assoc a b c` is the identity `a * b * c = a * (b
    * c)` and `mul_comm a b` is the identity `a * b = b * a`. Lean provides automation
    that generally eliminates the need to refer the facts like these explicitly, but
    they are useful for the purposes of illustration. In Lean, multiplication associates
    to the left, so the left-hand side of `mul_assoc` could also be written `(a *
    b) * c`. However, it is generally good style to be mindful of Lean’s notational
    conventions and leave out parentheses when Lean does as well.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try out `rw`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: The `import` lines at the beginning of the associated examples file import the
    theory of the real numbers from Mathlib, as well as useful automation. For the
    sake of brevity, we generally suppress information like this in the textbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are welcome to make changes to see what happens. You can type the `ℝ` character
    as `\R` or `\real` in VS Code. The symbol doesn’t appear until you hit space or
    the tab key. If you hover over a symbol when reading a Lean file, VS Code will
    show you the syntax that can be used to enter it. If you are curious to see all
    available abbreviations, you can hit Ctrl-Shift-P and then type abbreviations
    to get access to the `Lean 4: Show Unicode Input Abbreviations` command. If your
    keyboard does not have an easily accessible backslash, you can change the leading
    character by changing the `lean4.input.leader` setting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a cursor is in the middle of a tactic proof, Lean reports on the current
    *proof state* in the *Lean Infoview* window. As you move your cursor past each
    step of the proof, you can see the state change. A typical proof state in Lean
    might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'The lines before the one that begins with `⊢` denote the *context*: they are
    the objects and assumptions currently at play. In this example, these include
    two objects, `x` and `y`, each a natural number. They also include three assumptions,
    labelled `h₁`, `h₂`, and `h₃`. In Lean, everything in a context is labelled with
    an identifier. You can type these subscripted labels as `h\1`, `h\2`, and `h\3`,
    but any legal identifiers would do: you can use `h1`, `h2`, `h3` instead, or `foo`,
    `bar`, and `baz`. The last line represents the *goal*, that is, the fact to be
    proved. Sometimes people use *target* for the fact to be proved, and *goal* for
    the combination of the context and the target. In practice, the intended meaning
    is usually clear.'
  prefs: []
  type: TYPE_NORMAL
- en: Try proving these identities, in each case replacing `sorry` by a tactic proof.
    With the `rw` tactic, you can use a left arrow (`\l`) to reverse an identity.
    For example, `rw [← mul_assoc a b c]` replaces `a * (b * c)` by `a * b * c` in
    the current goal. Note that the left-pointing arrow refers to going from right
    to left in the identity provided by `mul_assoc`, it has nothing to do with the
    left or right side of the goal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: You can also use identities like `mul_assoc` and `mul_comm` without arguments.
    In this case, the rewrite tactic tries to match the left-hand side with an expression
    in the goal, using the first pattern it finds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: You can also provide *partial* information. For example, `mul_comm a` matches
    any pattern of the form `a * ?` and rewrites it to `? * a`. Try doing the first
    of these examples without providing any arguments at all, and the second with
    only one argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `rw` with facts from the local context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Try these, using the theorem `sub_self` for the second one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Multiple rewrite commands can be carried out with a single command, by listing
    the relevant identities separated by commas inside the square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: You still see the incremental progress by placing the cursor after a comma in
    any list of rewrites.
  prefs: []
  type: TYPE_NORMAL
- en: Another trick is that we can declare variables once and for all outside an example
    or theorem. Lean then includes them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspection of the tactic state at the beginning of the above proof reveals
    that Lean indeed included all variables. We can delimit the scope of the declaration
    by putting it in a `section ... end` block. Finally, recall from the introduction
    that Lean provides us with a command to determine the type of an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#check` command works for both objects and facts. In response to the command
    `#check a`, Lean reports that `a` has type `ℝ`. In response to the command `#check
    mul_comm a b`, Lean reports that `mul_comm a b` is a proof of the fact `a * b
    = b * a`. The command `#check (a : ℝ)` states our expectation that the type of
    `a` is `ℝ`, and Lean will raise an error if that is not the case. We will explain
    the output of the last three `#check` commands later, but in the meanwhile, you
    can take a look at them, and experiment with some `#check` commands of your own.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try some more examples. The theorem `two_mul a` says that `2 * a = a +
    a`. The theorems `add_mul` and `mul_add` express the distributivity of multiplication
    over addition, and the theorem `add_assoc` expresses the associativity of addition.
    Use the `#check` command to see the precise statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Whereas it is possible to figure out what is going on in this proof by stepping
    through it in the editor, it is hard to read on its own. Lean provides a more
    structured way of writing proofs like this using the `calc` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the proof does *not* begin with `by`: an expression that begins
    with `calc` is a *proof term*. A `calc` expression can also be used inside a tactic
    proof, but Lean interprets it as the instruction to use the resulting proof term
    to solve the goal. The `calc` syntax is finicky: the underscores and justification
    have to be in the format indicated above. Lean uses indentation to determine things
    like where a block of tactics or a `calc` block begins and ends; try changing
    the indentation in the proof above to see what happens.'
  prefs: []
  type: TYPE_NORMAL
- en: One way to write a `calc` proof is to outline it first using the `sorry` tactic
    for justification, make sure Lean accepts the expression modulo these, and then
    justify the individual steps using tactics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Try proving the following identity using both a pure `rw` proof and a more
    structured `calc` proof:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: The following exercise is a little more challenging. You can use the theorems
    listed underneath.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: We can also perform rewriting in an assumption in the context. For example,
    `rw [mul_comm a b] at hyp` replaces `a * b` by `b * a` in the assumption `hyp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: In the last step, the `exact` tactic can use `hyp` to solve the goal because
    at that point `hyp` matches the goal exactly.
  prefs: []
  type: TYPE_NORMAL
- en: We close this section by noting that Mathlib provides a useful bit of automation
    with a `ring` tactic, which is designed to prove identities in any commutative
    ring as long as they follow purely from the ring axioms, without using any local
    assumption.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: The `ring` tactic is imported indirectly when we import `Mathlib.Data.Real.Basic`,
    but we will see in the next section that it can be used for calculations on structures
    other than the real numbers. It can be imported explicitly with the command `import
    Mathlib.Tactic`. We will see there are similar tactics for other common kind of
    algebraic structures.
  prefs: []
  type: TYPE_NORMAL
- en: There is a variation of `rw` called `nth_rw` that allows you to replace only
    particular instances of an expression in the goal. Possible matches are enumerated
    starting with 1, so in the following example, `nth_rw 2 [h]` replaces the second
    occurrence of `a + b` with `c`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '## 2.2\. Proving Identities in Algebraic Structures[](#proving-identities-in-algebraic-structures
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically, a ring consists of a collection of objects, \(R\), operations
    \(+\) \(\times\), and constants \(0\) and \(1\), and an operation \(x \mapsto
    -x\) such that:'
  prefs: []
  type: TYPE_NORMAL
- en: \(R\) with \(+\) is an *abelian group*, with \(0\) as the additive identity
    and negation as inverse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplication is associative with identity \(1\), and multiplication distributes
    over addition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Lean, the collection of objects is represented as a *type*, `R`. The ring
    axioms are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: You will learn more about the square brackets in the first line later, but for
    the time being, suffice it to say that the declaration gives us a type, `R`, and
    a ring structure on `R`. Lean then allows us to use generic ring notation with
    elements of `R`, and to make use of a library of theorems about rings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The names of some of the theorems should look familiar: they are exactly the
    ones we used to calculate with the real numbers in the last section. Lean is good
    not only for proving things about concrete mathematical structures like the natural
    numbers and the integers, but also for proving things about abstract structures,
    characterized axiomatically, like rings. Moreover, Lean supports *generic reasoning*
    about both abstract and concrete structures, and can be trained to recognize appropriate
    instances. So any theorem about rings can be applied to concrete rings like the
    integers, `ℤ`, the rational numbers, `ℚ`, and the complex numbers `ℂ`. It can
    also be applied to any instance of an abstract structure that extends rings, such
    as any ordered ring or any field.'
  prefs: []
  type: TYPE_NORMAL
- en: Not all important properties of the real numbers hold in an arbitrary ring,
    however. For example, multiplication on the real numbers is commutative, but that
    does not hold in general. If you have taken a course in linear algebra, you will
    recognize that, for every \(n\), the \(n\) by \(n\) matrices of real numbers form
    a ring in which commutativity usually fails. If we declare `R` to be a *commutative*
    ring, in fact, all the theorems in the last section continue to hold when we replace
    `ℝ` by `R`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: We leave it to you to check that all the other proofs go through unchanged.
    Notice that when a proof is short, like `by ring` or `by linarith` or `by sorry`,
    it is common (and permissible) to put it on the same line as the `by`. Good proof-writing
    style should strike a balance between concision and readability.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this section is to strengthen the skills you have developed in the
    last section and apply them to reasoning axiomatically about rings. We will start
    with the axioms listed above, and use them to derive other facts. Most of the
    facts we prove are already in Mathlib. We will give the versions we prove the
    same names to help you learn the contents of the library as well as the naming
    conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lean provides an organizational mechanism similar to those used in programming
    languages: when a definition or theorem `foo` is introduced in a *namespace* `bar`,
    its full name is `bar.foo`. The command `open bar` later *opens* the namespace,
    which allows us to use the shorter name `foo`. To avoid errors due to name clashes,
    in the next example we put our versions of the library theorems in a new namespace
    called `MyRing.`'
  prefs: []
  type: TYPE_NORMAL
- en: The next example shows that we do not need `add_zero` or `add_neg_cancel` as
    ring axioms, because they follow from the other axioms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: The net effect is that we can temporarily reprove a theorem in the library,
    and then go on using the library version after that. But don’t cheat! In the exercises
    that follow, take care to use only the general facts about rings that we have
    proved earlier in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '(If you are paying careful attention, you may have noticed that we changed
    the round brackets in `(R : Type*)` for curly brackets in `{R : Type*}`. This
    declares `R` to be an *implicit argument*. We will explain what this means in
    a moment, but don’t worry about it in the meanwhile.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a useful theorem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Prove the companion version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Use these to prove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: With enough planning, you can do each of them with three rewrites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now explain the use of the curly braces. Imagine you are in a situation
    where you have `a`, `b`, and `c` in your context, as well as a hypothesis `h :
    a + b = a + c`, and you would like to draw the conclusion `b = c`. In Lean, you
    can apply a theorem to hypotheses and facts just the same way that you can apply
    them to objects, so you might think that `add_left_cancel a b c h` is a proof
    of the fact `b = c`. But notice that explicitly writing `a`, `b`, and `c` is redundant,
    because the hypothesis `h` makes it clear that those are the objects we have in
    mind. In this case, typing a few extra characters is not onerous, but if we wanted
    to apply `add_left_cancel` to more complicated expressions, writing them would
    be tedious. In cases like these, Lean allows us to mark arguments as *implicit*,
    meaning that they are supposed to be left out and inferred by other means, such
    as later arguments and hypotheses. The curly brackets in `{a b c : R}` do exactly
    that. So, given the statement of the theorem above, the correct expression is
    simply `add_left_cancel h`.'
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate, let us show that `a * 0 = 0` follows from the ring axioms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used a new trick! If you step through the proof, you can see what is
    going on. The `have` tactic introduces a new goal, `a * 0 + a * 0 = a * 0 + 0`,
    with the same context as the original goal. The fact that the next line is indented
    indicates that Lean is expecting a block of tactics that serves to prove this
    new goal. The indentation therefore promotes a modular style of proof: the indented
    subproof establishes the goal that was introduced by the `have`. After that, we
    are back to proving the original goal, except a new hypothesis `h` has been added:
    having proved it, we are now free to use it. At this point, the goal is exactly
    the result of `add_left_cancel h`.'
  prefs: []
  type: TYPE_NORMAL
- en: We could equally well have closed the proof with `apply add_left_cancel h` or
    `exact add_left_cancel h`. The `exact` tactic takes as argument a proof term which
    completely proves the current goal, without creating any new goal. The `apply`
    tactic is a variant whose argument is not necessarily a complete proof. The missing
    pieces are either inferred automatically by Lean or become new goals to prove.
    While the `exact` tactic is technically redundant since it is strictly less powerful
    than `apply`, it makes proof scripts slightly clearer to human readers and easier
    to maintain when the library evolves.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that multiplication is not assumed to be commutative, so the following
    theorem also requires some work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: By now, you should also be able replace each `sorry` in the next exercise with
    a proof, still using only facts about rings that we have established in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'We had to use the annotation `(-0 : R)` instead of `0` in the third theorem
    because without specifying `R` it is impossible for Lean to infer which `0` we
    have in mind, and by default it would be interpreted as a natural number.'
  prefs: []
  type: TYPE_NORMAL
- en: In Lean, subtraction in a ring is provably equal to addition of the additive
    inverse.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'On the real numbers, it is *defined* that way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'The proof term `rfl` is short for “reflexivity”. Presenting it as a proof of
    `a - b = a + -b` forces Lean to unfold the definition and recognize both sides
    as being the same. The `rfl` tactic does the same. This is an instance of what
    is known as a *definitional equality* in Lean’s underlying logic. This means that
    not only can one rewrite with `sub_eq_add_neg` to replace `a - b = a + -b`, but
    in some contexts, when dealing with the real numbers, you can use the two sides
    of the equation interchangeably. For example, you now have enough information
    to prove the theorem `self_sub` from the last section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Show that you can prove this using `rw`, but if you replace the arbitrary ring
    `R` by the real numbers, you can also prove it using either `apply` or `exact`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lean knows that `1 + 1 = 2` holds in any ring. With a bit of effort, you can
    use that to prove the theorem `two_mul` from the last section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'We close this section by noting that some of the facts about addition and negation
    that we established above do not need the full strength of the ring axioms, or
    even commutativity of addition. The weaker notion of a *group* can be axiomatized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: It is conventional to use additive notation when the group operation is commutative,
    and multiplicative notation otherwise. So Lean defines a multiplicative version
    as well as the additive version (and also their abelian variants, `AddCommGroup`
    and `CommGroup`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: If you are feeling cocky, try proving the following facts about groups, using
    only these axioms. You will need to prove a number of helper lemmas along the
    way. The proofs we have carried out in this section provide some hints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Explicitly invoking those lemmas is tedious, so Mathlib provides tactics similar
    to ring in order to cover most uses: group is for non-commutative multiplicative
    groups, abel for abelian additive groups, and noncomm_ring for non-commutative
    rings. It may seem odd that the algebraic structures are called Ring and CommRing
    while the tactics are named noncomm_ring and ring. This is partly for historical
    reasons, but also for the convenience of using a shorter name for the tactic that
    deals with commutative rings, since it is used more often.'
  prefs: []
  type: TYPE_NORMAL
- en: '## 2.3\. Using Theorems and Lemmas[](#using-theorems-and-lemmas "Link to this
    heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting is great for proving equations, but what about other sorts of theorems?
    For example, how can we prove an inequality, like the fact that \(a + e^b \le
    a + e^c\) holds whenever \(b \le c\)? We have already seen that theorems can be
    applied to arguments and hypotheses, and that the `apply` and `exact` tactics
    can be used to solve goals. In this section, we will make good use of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the library theorems `le_refl` and `le_trans`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'As we explain in more detail in [Section 3.1](C03_Logic.html#implication-and-the-universal-quantifier),
    the implicit parentheses in the statement of `le_trans` associate to the right,
    so it should be interpreted as `a ≤ b → (b ≤ c → a ≤ c)`. The library designers
    have set the arguments `a`, `b` and `c` to `le_trans` implicit, so that Lean will
    *not* let you provide them explicitly (unless you really insist, as we will discuss
    later). Rather, it expects to infer them from the context in which they are used.
    For example, when hypotheses `h : a ≤ b` and `h'' : b ≤ c` are in the context,
    all the following work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'The `apply` tactic takes a proof of a general statement or implication, tries
    to match the conclusion with the current goal, and leaves the hypotheses, if any,
    as new goals. If the given proof matches the goal exactly (modulo *definitional*
    equality), you can use the `exact` tactic instead of `apply`. So, all of these
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first example, applying `le_trans` creates two goals, and we use the
    dots to indicate where the proof of each begins. The dots are optional, but they
    serve to *focus* the goal: within the block introduced by the dot, only one goal
    is visible, and it must be completed before the end of the block. Here we end
    the first block by starting a new one with another dot. We could just as well
    have decreased the indentation. In the third example and in the last example,
    we avoid going into tactic mode entirely: `le_trans h₀ h₁` and `le_refl x` are
    the proof terms we need.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few more library theorems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'Use them together with `apply` and `exact` to prove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, Lean has a tactic that does this sort of thing automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: The `linarith` tactic is designed to handle *linear arithmetic*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: In addition to equations and inequalities in the context, `linarith` will use
    additional inequalities that you pass as arguments. In the next example, `exp_le_exp.mpr
    h'` is a proof of `exp b ≤ exp c`, as we will explain in a moment. Notice that,
    in Lean, we write `f x` to denote the application of a function `f` to the argument
    `x`, exactly the same way we write `h x` to denote the result of applying a fact
    or theorem `h` to the argument `x`. Parentheses are only needed for compound arguments,
    as in `f (x + y)`. Without the parentheses, `f x + y` would be parsed as `(f x)
    + y`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Here are some more theorems in the library that can be used to establish inequalities
    on the real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the theorems, `exp_le_exp`, `exp_lt_exp` use a *bi-implication*, which
    represents the phrase “if and only if.” (You can type it in VS Code with `\lr`
    or `\iff`). We will discuss this connective in greater detail in the next chapter.
    Such a theorem can be used with `rw` to rewrite a goal to an equivalent one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, however, we will use the fact that if `h : A ↔ B` is such
    an equivalence, then `h.mp` establishes the forward direction, `A → B`, and `h.mpr`
    establishes the reverse direction, `B → A`. Here, `mp` stands for “modus ponens”
    and `mpr` stands for “modus ponens reverse.” You can also use `h.1` and `h.2`
    for `h.mp` and `h.mpr`, respectively, if you prefer. Thus the following proof
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: The first line, `apply add_lt_add_of_lt_of_le`, creates two goals, and once
    again we use a dot to separate the proof of the first from the proof of the second.
  prefs: []
  type: TYPE_NORMAL
- en: Try the following examples on your own. The example in the middle shows you
    that the `norm_num` tactic can be used to solve concrete numeric goals.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'From these examples, it should be clear that being able to find the library
    theorems you need constitutes an important part of formalization. There are a
    number of strategies you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: You can browse Mathlib in its [GitHub repository](https://github.com/leanprover-community/mathlib4).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the API documentation on the Mathlib [web pages](https://leanprover-community.github.io/mathlib4_docs/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use Loogle <https://loogle.lean-lang.org> to search Lean and Mathlib
    definitions and theorems by patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can rely on Mathlib naming conventions and Ctrl-space completion in the
    editor to guess a theorem name (or Cmd-space on a Mac keyboard). In Lean, a theorem
    named `A_of_B_of_C` establishes something of the form `A` from hypotheses of the
    form `B` and `C`, where `A`, `B`, and `C` approximate the way we might read the
    goals out loud. So a theorem establishing something like `x + y ≤ ...` will probably
    start with `add_le`. Typing `add_le` and hitting Ctrl-space will give you some
    helpful choices. Note that hitting Ctrl-space twice displays more information
    about the available completions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you right-click on an existing theorem name in VS Code, the editor will show
    a menu with the option to jump to the file where the theorem is defined, and you
    can find similar theorems nearby.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `apply?` tactic, which tries to find the relevant theorem in
    the library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'To try out `apply?` in this example, delete the `exact` command and uncomment
    the previous line. Using these tricks, see if you can find what you need to do
    the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Using the same tricks, confirm that `linarith` instead of `apply?` can also
    finish the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of an inequality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Mathlib tends to put spaces around binary operations like `*` and `^`, but in
    this example, the more compressed format increases readability. There are a number
    of things worth noticing. First, an expression `s ≥ t` is definitionally equivalent
    to `t ≤ s`. In principle, this means one should be able to use them interchangeably.
    But some of Lean’s automation does not recognize the equivalence, so Mathlib tends
    to favor `≤` over `≥`. Second, we have used the `ring` tactic extensively. It
    is a real timesaver! Finally, notice that in the second line of the second `calc`
    proof, instead of writing `by exact add_le_add (le_refl _) h`, we can simply write
    the proof term `add_le_add (le_refl _) h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the only cleverness in the proof above is figuring out the hypothesis
    `h`. Once we have it, the second calculation involves only linear arithmetic,
    and `linarith` can handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: How nice! We challenge you to use these ideas to prove the following theorem.
    You can use the theorem `abs_le'.mpr`. You will also need the `constructor` tactic
    to split a conjunction to two goals; see [Section 3.4](C03_Logic.html#conjunction-and-biimplication).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: If you managed to solve this, congratulations! You are well on your way to becoming
    a master formalizer.
  prefs: []
  type: TYPE_NORMAL
- en: '## 2.4\. More examples using apply and rw[](#more-examples-using-apply-and-rw
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `min` function on the real numbers is uniquely characterized by the following
    three facts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Can you guess the names of the theorems that characterize `max` in a similar
    way?
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have to apply `min` to a pair of arguments `a` and `b` by writing
    `min a b` rather than `min (a, b)`. Formally, `min` is a function of type `ℝ →
    ℝ → ℝ`. When we write a type like this with multiple arrows, the convention is
    that the implicit parentheses associate to the right, so the type is interpreted
    as `ℝ → (ℝ → ℝ)`. The net effect is that if `a` and `b` have type `ℝ` then `min
    a` has type `ℝ → ℝ` and `min a b` has type `ℝ`, so `min` acts like a function
    of two arguments, as we expect. Handling multiple arguments in this way is known
    as *currying*, after the logician Haskell Curry.
  prefs: []
  type: TYPE_NORMAL
- en: The order of operations in Lean can also take some getting used to. Function
    application binds tighter than infix operations, so the expression `min a b +
    c` is interpreted as `(min a b) + c`. With time, these conventions will become
    second nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the theorem `le_antisymm`, we can show that two real numbers are equal
    if each is less than or equal to the other. Using this and the facts above, we
    can show that `min` is commutative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have used dots to separate proofs of different goals. Our usage is
    inconsistent: at the outer level, we use dots and indentation for both goals,
    whereas for the nested proofs, we use dots only until a single goal remains. Both
    conventions are reasonable and useful. We also use the `show` tactic to structure
    the proof and indicate what is being proved in each block. The proof still works
    without the `show` commands, but using them makes the proof easier to read and
    maintain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It may bother you that the proof is repetitive. To foreshadow skills you will
    learn later on, we note that one way to avoid the repetition is to state a local
    lemma and then use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: We will say more about the universal quantifier in [Section 3.1](C03_Logic.html#implication-and-the-universal-quantifier),
    but suffice it to say here that the hypothesis `h` says that the desired inequality
    holds for any `x` and `y`, and the `intro` tactic introduces an arbitrary `x`
    and `y` to establish the conclusion. The first `apply` after `le_antisymm` implicitly
    uses `h a b`, whereas the second one uses `h b a`.
  prefs: []
  type: TYPE_NORMAL
- en: Another solution is to use the `repeat` tactic, which applies a tactic (or a
    block) as many times as it can.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: We encourage you to prove the following as exercises. You can use either of
    the tricks just described to shorten the first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you are welcome to prove the associativity of `max` as well.
  prefs: []
  type: TYPE_NORMAL
- en: It is an interesting fact that `min` distributes over `max` the way that multiplication
    distributes over addition, and vice-versa. In other words, on the real numbers,
    we have the identity `min a (max b c) = max (min a b) (min a c)` as well as the
    corresponding version with `max` and `min` switched. But in the next section we
    will see that this does *not* follow from the transitivity and reflexivity of
    `≤` and the characterizing properties of `min` and `max` enumerated above. We
    need to use the fact that `≤` on the real numbers is a *total order*, which is
    to say, it satisfies `∀ x y, x ≤ y ∨ y ≤ x`. Here the disjunction symbol, `∨`,
    represents “or”. In the first case, we have `min x y = x`, and in the second case,
    we have `min x y = y`. We will learn how to reason by cases in [Section 3.5](C03_Logic.html#disjunction),
    but for now we will stick to examples that don’t require the case split.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one such example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: It is clear that `aux` provides one of the two inequalities needed to prove
    the equality, but applying it to suitable values yields the other direction as
    well. As a hint, you can use the theorem `add_neg_cancel_right` and the `linarith`
    tactic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lean’s naming convention is made manifest in the library’s name for the triangle
    inequality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'Use it to prove the following variant, using also `add_sub_cancel_right`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: See if you can do this in three lines or less. You can use the theorem `sub_add_cancel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important relation that we will make use of in the sections to come
    is the divisibility relation on the natural numbers, `x ∣ y`. Be careful: the
    divisibility symbol is *not* the ordinary bar on your keyboard. Rather, it is
    a unicode character obtained by typing `\|` in VS Code. By convention, Mathlib
    uses `dvd` to refer to it in theorem names.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last example, the exponent is a natural number, and applying `dvd_mul_left`
    forces Lean to expand the definition of `x^2` to `x^1 * x`. See if you can guess
    the names of the theorems you need to prove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'With respect to divisibility, the *greatest common divisor*, `gcd`, and least
    common multiple, `lcm`, are analogous to `min` and `max`. Since every number divides
    `0`, `0` is really the greatest element with respect to divisibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'See if you can guess the names of the theorems you will need to prove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'Hint: you can use `dvd_antisymm`, but if you do, Lean will complain that the
    expression is ambiguous between the generic theorem and the version `Nat.dvd_antisymm`,
    the one specifically for the natural numbers. You can use `_root_.dvd_antisymm`
    to specify the generic one; either one will work.'
  prefs: []
  type: TYPE_NORMAL
- en: '## 2.5\. Proving Facts about Algebraic Structures[](#proving-facts-about-algebraic-structures
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Section 2.2](#proving-identities-in-algebraic-structures), we saw that
    many common identities governing the real numbers hold in more general classes
    of algebraic structures, such as commutative rings. We can use any axioms we want
    to describe an algebraic structure, not just equations. For example, a *partial
    order* consists of a set with a binary relation that is reflexive, transitive,
    and antisymmetric. like `≤` on the real numbers. Lean knows about partial orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Here we are adopting the Mathlib convention of using letters like `α`, `β`,
    and `γ` (entered as `\a`, `\b`, and `\g`) for arbitrary types. The library often
    uses letters like `R` and `G` for the carriers of algebraic structures like rings
    and groups, respectively, but in general Greek letters are used for types, especially
    when there is little or no structure associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: Associated to any partial order, `≤`, there is also a *strict partial order*,
    `<`, which acts somewhat like `<` on the real numbers. Saying that `x` is less
    than `y` in this order is equivalent to saying that it is less-than-or-equal to
    `y` and not equal to `y`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the symbol `∧` stands for “and,” the symbol `¬` stands for
    “not,” and `x ≠ y` abbreviates `¬ (x = y)`. In [Chapter 3](C03_Logic.html#logic),
    you will learn how to use these logical connectives to *prove* that `<` has the
    properties indicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *lattice* is a structure that extends a partial order with operations `⊓`
    and `⊔` that are analogous to `min` and `max` on the real numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'The characterizations of `⊓` and `⊔` justify calling them the *greatest lower
    bound* and *least upper bound*, respectively. You can type them in VS code using
    `\glb` and `\lub`. The symbols are also often called then *infimum* and the *supremum*,
    and Mathlib refers to them as `inf` and `sup` in theorem names. To further complicate
    matters, they are also often called *meet* and *join*. Therefore, if you work
    with lattices, you have to keep the following dictionary in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '`⊓` is the *greatest lower bound*, *infimum*, or *meet*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`⊔` is the *least upper bound*, *supremum*, or *join*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some instances of lattices include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`min` and `max` on any total order, such as the integers or real numbers with
    `≤`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`∩` and `∪` on the collection of subsets of some domain, with the ordering
    `⊆`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`∧` and `∨` on boolean truth values, with ordering `x ≤ y` if either `x` is
    false or `y` is true'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcd` and `lcm` on the natural numbers (or positive natural numbers), with
    the divisibility ordering, `∣`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the collection of linear subspaces of a vector space, where the greatest lower
    bound is given by the intersection, the least upper bound is given by the sum
    of the two spaces, and the ordering is inclusion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the collection of topologies on a set (or, in Lean, a type), where the greatest
    lower bound of two topologies consists of the topology that is generated by their
    union, the least upper bound is their intersection, and the ordering is reverse
    inclusion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can check that, as with `min` / `max` and `gcd` / `lcm`, you can prove the
    commutativity and associativity of the infimum and supremum using only their characterizing
    axioms, together with `le_refl` and `le_trans`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `apply le_trans` when seeing a goal `x ≤ z` is not a great idea. Indeed
    Lean has no way to guess which intermediate element `y` we want to use. So `apply
    le_trans` produces three goals that look like `x ≤ ?a`, `?a ≤ z` and `α` where
    `?a` (probably with a more complicated auto-generated name) stands for the mysterious
    `y`. The last goal, with type `α`, is to provide the value of `y`. It comes lasts
    because Lean hopes to automatically infer it from the proof of the first goal
    `x ≤ ?a`. In order to avoid this unappealing situation, you can use the `calc`
    tactic to explicitly provide `y`. Alternatively, you can use the `trans` tactic
    which takes `y` as an argument and produces the expected goals `x ≤ y` and `y
    ≤ z`. Of course you can also avoid this issue by providing directly a full proof
    such as `exact le_trans inf_le_left inf_le_right`, but this requires a lot more
    planning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: You can find these theorems in the Mathlib as `inf_comm`, `inf_assoc`, `sup_comm`,
    and `sup_assoc`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another good exercise is to prove the *absorption laws* using only those axioms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: These can be found in Mathlib with the names `inf_sup_self` and `sup_inf_self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lattice that satisfies the additional identities `x ⊓ (y ⊔ z) = (x ⊓ y) ⊔
    (x ⊓ z)` and `x ⊔ (y ⊓ z) = (x ⊔ y) ⊓ (x ⊔ z)` is called a *distributive lattice*.
    Lean knows about these too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'The left and right versions are easily shown to be equivalent, given the commutativity
    of `⊓` and `⊔`. It is a good exercise to show that not every lattice is distributive
    by providing an explicit description of a nondistributive lattice with finitely
    many elements. It is also a good exercise to show that in any lattice, either
    distributivity law implies the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to combine axiomatic structures into larger ones. For example,
    a *strict ordered ring* consists of a ring together with a partial order on the
    carrier satisfying additional axioms that say that the ring operations are compatible
    with the order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[Chapter 3](C03_Logic.html#logic) will provide the means to derive the following
    from `mul_pos` and the definition of `<`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'It is then an extended exercise to show that many common facts used to reason
    about arithmetic and the ordering on the real numbers hold generically for any
    ordered ring. Here are a couple of examples you can try, using only properties
    of rings, partial orders, and the facts enumerated in the last two examples (beware
    that those rings are not assumed to be commutative, so the ring tactic is not
    available):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here is one last example. A *metric space* consists of a set equipped
    with a notion of distance, `dist x y`, mapping any pair of elements to a real
    number. The distance function is assumed to satisfy the following axioms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'Having mastered this section, you can show that it follows from these axioms
    that distances are always nonnegative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: We recommend making use of the theorem `nonneg_of_mul_nonneg_left`. As you may
    have guessed, this theorem is called `dist_nonneg` in Mathlib.*
  prefs: []
  type: TYPE_NORMAL
