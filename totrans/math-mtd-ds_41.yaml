- en: 5.6\. Erdős-Rényi random graph and stochastic blockmodel#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://mmids-textbook.github.io/chap05_specgraph/06_sbm/roch-mmids-specgraph-sbm.html](https://mmids-textbook.github.io/chap05_specgraph/06_sbm/roch-mmids-specgraph-sbm.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A natural way to test an algorithm is by running it on a simulated dataset whose
    “ground truth” is known. We encountered this idea for instance in clustering,
    where we used a mixture of Gaussians; there, the ground truth was the mixture
    component from which a data point was generated. What is an appropriate stochastic
    model in the context of network analysis?
  prefs: []
  type: TYPE_NORMAL
- en: In fact there are many models of random graphs, i.e., graphs whose edges are
    picked at random. Which one to use depends on the task at hand. For graph partitioning,
    one requires a graph with a “planted partition”. The stochastic blockmodel is
    a canonical example of such a model. We begin with a more general setting.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.1\. Inhomogeneous Erdős-Rényi random graph[#](#inhomogeneous-erdos-renyi-random-graph
    "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simple approach to generating a random graph is to include each edge *independently*.
    More precisely, let \(V = [n]\) be a set of \(n\) vertices. Consider a symmetric
    matrix \(M = (m_{i,j}) \in [0,1]^{n \times n}\) with arbitrary entries in \([0,1]\).
    The entry \(m_{i,j} = m_{j,i}\) is the probability that edge \(\{i,j\}\) is present
    (i.e., that \(\{i,j\} \in E\)), independently of all other edges. The outcome
    is a random graph \(G = (V, E)\) with random adjacency matrix \(A = (A_{i,j})
    \in \{0,1\}^{n \times n}\). This model is known as an inhomogeneous Erdős-Rényi
    (ER) random graph\(\idx{inhomogeneous Erdős-Rényi random graph}\xdi\).
  prefs: []
  type: TYPE_NORMAL
- en: Observe that
  prefs: []
  type: TYPE_NORMAL
- en: \[ \E[A_{i,j}] = 1 \cdot m_{i,j} + 0 \cdot (1 - m_{i,j}) = m_{i,j}. \]
  prefs: []
  type: TYPE_NORMAL
- en: Indeed each entry \(A_{i,j}\) is a Bernoulli random variable with success probability
    \(m_{i,j}\). In other words, in matrix form, we have
  prefs: []
  type: TYPE_NORMAL
- en: \[ \E[A] = M, \]
  prefs: []
  type: TYPE_NORMAL
- en: that is, \(M\) is the expected adjacency matrix. Note in particular that \(M\)
    is deterministic while \(A\) is random (which is why we use lowercase entries
    for \(M\) but uppercase entries for \(A\)).
  prefs: []
  type: TYPE_NORMAL
- en: An important special case is obtained when \(m_{i,j} = m_{j,i} = p \in (0,1)\)
    for all \(i \neq j\) and \(m_{k,k} = 0\) for all \(k\). That is, each possible
    edge between two distinct vertices is present with the same probability \(p\).
    This model is known simply as an Erdős-Rényi (ER) random graph\(\idx{Erdős-Rényi
    random graph}\xdi\). Put differently,
  prefs: []
  type: TYPE_NORMAL
- en: \[ \E[A] = M = p (J - I_{n \times n}), \]
  prefs: []
  type: TYPE_NORMAL
- en: where \(J \in \mathbb{R}^{n \times n}\) is the all-one matrix. In this calculation,
    we subtract the identity matrix to account for the fact that the diagonal is \(0\).
  prefs: []
  type: TYPE_NORMAL
- en: The properties of this model are very well-studied. We give a couple of examples
    next. For an event \(\mathcal{F}\), the indicator random variable \(\mathbf{1}_{\mathcal{F}}\)
    is \(1\) if \(\mathcal{F}\) occurs, and \(0\) otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '**EXAMPLE:** Let \(G = (V, E)\) be an ER graph with \(n\) vertices. The parameter
    \(p\) can be interpreted as an edge density. Indeed, let’s compute the expected
    number of edges \(G\). By summing over all pairs and using linearity of expectation,
    we have'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{align*} \E[|E|] &= \E \left[\sum_{i < j} \mathbf{1}_{\{i,j\} \in E}\right]\\
    &= \sum_{i < j} \E \left[\mathbf{1}_{\{i,j\} \in E}\right]\\ &= \binom{n}{2} p.
    \end{align*}\]
  prefs: []
  type: TYPE_NORMAL
- en: Or, put differently, we have shown that the expected edge density \(\E\left[|E|/\binom{n}{2}\right]\)
    is \(p\).
  prefs: []
  type: TYPE_NORMAL
- en: A similar calculation gives the expected number of triangles. Denote by \(T_3\)
    the number of triangles in \(G\), that is, the number of triples \(i, j , k\)
    of distinct vertices such that \(\{i,j\}, \{j,k\}, \{i,k\} \in E\) (i.e., all
    edges between them are present). Then
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{align*} \E[|T_3|] &= \E \left[\sum_{i < j < k} \mathbf{1}_{\{i,j\},
    \{j,k\}, \{i,k\} \in E}\right]\\ &= \E \left[\sum_{i < j < k} \mathbf{1}_{\{i,j\}
    \in E} \mathbf{1}_{\{j,k\} \in E} \mathbf{1}_{\{i,k\} \in E}\right]\\ &= \sum_{i
    < j < k} \E \left[\mathbf{1}_{\{i,j\} \in E}\right] \E \left[\mathbf{1}_{\{j,k\}
    \in E}\right] \E\left[\mathbf{1}_{\{i,k\} \in E}\right]\\ &= \binom{n}{3} p^3.
    \end{align*}\]
  prefs: []
  type: TYPE_NORMAL
- en: We used the independence of the edges on the third line. Or, put differently,
    we have shown that the expected triangle density \(\E\left[|T_3|/\binom{n}{3}\right]\)
    is \(p^3\). \(\lhd\)
  prefs: []
  type: TYPE_NORMAL
- en: We implement the generation of an inhomogeneous ER graph using NetworkX. We
    first initialize a pseudorandom number generator `rng`. To determine whether an
    edge is present between `i` and `j`, we generate a uniform random variable `rng.random()`
    (see [`numpy.random.Generator.random`](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.random.html))
    and add the edge with `G.add_edge(i, j)` if the random variable is `< M[i, j]`
    – an event which indeed occurs with the desired probability (check it!).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**NUMERICAL CORNER:** Here is an example usage. We generate probabilities \(m_{i,j}\)
    uniformly at random between \(0\) and \(1\).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We draw the resulting graph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/a5a1fbd0498f23ac9641301349d2049a81e0c0429cbc15d654f9a3d72005ae43.png](../Images/c257b8bf58fbbcb0fd5cc44a281cb855.png)'
  prefs: []
  type: TYPE_IMG
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: The following subroutine generates an ER graph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To confirm our previous calculations, below is the implementation of a routine
    to estimate the edge density for an ER graph with a fixed parameter \(p\). Recall
    that the edge density is defined as the number of edges present divided by the
    number of possible edges (i.e., the number of pairs of distinct vertices). The
    routine takes advantage of the *Law of Large Numbers* by generating a large number
    of sample graphs, computing their edge density, and then taking the mean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**NUMERICAL CORNER:** On a small example, we indeed get that the edge density
    is roughly \(p\).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**TRY IT!** Modify the code above to estimate the density of triangles. ([Open
    In Colab](https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_specgraph_notebook.ipynb))
    \(\ddagger\)'
  prefs: []
  type: TYPE_NORMAL
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: When \(n\), the number of vertices, is large, random graphs tend to exhibit
    large-scale emergent behavior. One classical example involves the probability
    of being connected in an ER graph. To illustrate, below is code to estimate that
    probability over a range of edge densities \(p\) (with help from Claude and ChatGPT).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**NUMERICAL CORNER:** We run the code for `n` equal to `100`. What do you observe?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/04efd601c9047c499cb95d5acf06604fe4f0dda7ba32a3531fb3632e84836f7f.png](../Images/a6ba5ed9893af4c1125c90607e734d1d.png)'
  prefs: []
  type: TYPE_IMG
- en: The probability of being connected starts out at \(0\) when \(p\) is small,
    which is not surprising since it implies that the graph has a relatively small
    number of edges. But then that probability increases – rapidly – to \(1\) as \(p\)
    crosses a threshold. This is referred to as the phase transition of the ER graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be shown rigorously that the transition occurs at roughly \(p = \log
    n/n\). That is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: which is consistent with the plot.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRY IT!** Taking a larger `n` would produce a sharper transition. Try it
    for yourself. Also try drawing one random sample for increasing values of \(p\)
    around the threshold. What do you observe? ([Open In Colab](https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_specgraph_notebook.ipynb))
    \(\ddagger\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**TRY IT!** Many other properties exhibit such sharp threshold behavior. Modify
    the code to to estimate the probability that a clique of size 4 exists in the
    graph. ([Open In Colab](https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_specgraph_notebook.ipynb))
    \(\ddagger\)'
  prefs: []
  type: TYPE_NORMAL
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.2\. Stochastic blockmodel[#](#stochastic-blockmodel "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We return to our original motivation. How can we create a random graph with
    a planted partition? The stochastic blockmodel (SBM) is such a model. Here we
    imagine that \([n]\) is partitioned into two disjoint sets \(C_1\) and \(C_2\),
    referred to as blocks. We set \(z(i) = j\) if vertex \(i\) is in block \(C_j\).
    We also encode the block assignment with a matrix \(Z \in \{0,1\}^{n \times 2}\)
    where row \(i\) is \(\mathbf{e}_j^T\) if vertex \(i\) is assigned to block \(C_j\).
  prefs: []
  type: TYPE_NORMAL
- en: Let \(b_{i,j} \in [0,1]\) be the probability that a vertex in block \(C_i\)
    and a vertex in block \(C_j\) are connected by an edge, independently of all other
    edges. We enforce \(b_{1,2} = b_{2,1}\). We collect these probabilities in the
    following matrix
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split} B = \begin{pmatrix} b_{1,1} & b_{1,2}\\ b_{2,1} & b_{2,2} \end{pmatrix}.
    \end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: By our assumption, the matrix \(B\) is symmetric.
  prefs: []
  type: TYPE_NORMAL
- en: We typically take
  prefs: []
  type: TYPE_NORMAL
- en: \[ \min\{b_{1,1}, b_{2,2}\} > b_{1,2}, \]
  prefs: []
  type: TYPE_NORMAL
- en: that is, edges are more likely between vertices in the same block than between
    vertices in different blocks. That corresponds to the intuition that, in social
    networks or other types of networks, members of the same group (i.e., block) tend
    to interact more frequently with each other than with members of different groups.
    For instance, friends within the same social circle are more likely to be connected
    than with people outside their circle. That is related to the concept of homophily
    which describes the tendency of individuals to associate and bond with similar
    others.
  prefs: []
  type: TYPE_NORMAL
- en: This is a special case of the inhomogeneous ER graph model. What is the corresponding
    \(M\) matrix? Note that, for each pair of vertex \(1 \leq i < j \leq n\), edge
    \(\{i,j\}\) is present in \(E\) with probability
  prefs: []
  type: TYPE_NORMAL
- en: \[ m_{i,j} := b_{z(i), z(j)} = Z_{i,\cdot} B Z_{j,\cdot}^T \]
  prefs: []
  type: TYPE_NORMAL
- en: where recall that \(Z_{i,\cdot}\) is row \(i\) of matrix \(Z\).
  prefs: []
  type: TYPE_NORMAL
- en: In matrix form, this is saying that
  prefs: []
  type: TYPE_NORMAL
- en: \[ M = Z B Z^T. \]
  prefs: []
  type: TYPE_NORMAL
- en: So, given \(B\) and \(Z\), we can generate an SBM as a special case of an inhomogeneous
    ER graph.
  prefs: []
  type: TYPE_NORMAL
- en: We implement the SBM model. We use blocks numbered \(0\) and \(1\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**NUMERICAL CORNER:** Here is an example usage. We first pick a block assignment
    at random. Specifically, blocks are assigned randomly with [`numpy.random.Generator.choice`](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.choice.html#numpy.random.Generator.choice).
    It produces two blocks by assigning each vertex with equal probability to either
    block, independently of all other choices.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We draw the graph with colored nodes based on block assignments. The “good”
    cut is clearly visible in this layout.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/d1593cbfb628739bb8775c68e246ec22340e23b00f2eb233dba14c8732005001.png](../Images/201aa17bc70e38e3e3d759bd8e23f659.png)'
  prefs: []
  type: TYPE_IMG
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: We introduce a subroutine which assigns blocks at random as follows. Let \(\beta_1,
    \beta_2 \in [0,1]\) with \(\beta_1 + \beta_2 = 1\) be the probability that a vertex
    belongs respectively to block \(1\) and \(2\). We collect these probabilities
    in the following vector
  prefs: []
  type: TYPE_NORMAL
- en: \[ \bbeta = (\beta_1, \beta_2). \]
  prefs: []
  type: TYPE_NORMAL
- en: We pick block \(z(i) \in \{1,2\}\) for each vertex \(1 \leq i \leq n\) according
    to the distribution \(\bbeta\), independently of all other vertices \(\neq i\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**NUMERICAL CORNER:** Here is an example usage.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Observe that the blocks are more unbalanced this time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/e6e9218d9f5e632ff4be76353cc005764f4073c93101c433f9f5d807555d263b.png](../Images/5a952a9ded70a63b063836a0fbfee569.png)'
  prefs: []
  type: TYPE_IMG
- en: To test our spectral partitioning algorithm, we run `spectral_cut2`, which indeed
    recovers the ground truth.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/15d02996eaea304f0dcdfdd6ab0c5fbec79eb564e0310ff803ea4e6321a23e34.png](../Images/c37ee75c9c1055f8bebc79a73fe4606f.png)'
  prefs: []
  type: TYPE_IMG
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: The following code computes the fraction of incorrectly assigned vertices. Note
    that it considers *two* assignments corresponding to swapping the labels `0` and
    `1` which cannot be inferred.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**NUMERICAL CORNER:** We confirm on our previous example that the ground truth
    was perfectly recovered.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: One expects that the ground truth is harder to recover if the probability of
    an edge between blocks is close to that within blocks, which makes the community
    structure more murky. To test this hypothesis, we modify our previous example
    by significantly increasing the inter-block probability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We run `spectral_cut2`. It recovers the ground truth only partially this time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: '***Self-assessment quiz*** *(with help from Claude, Gemini, and ChatGPT)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**1** In a stochastic blockmodel (SBM), what does \(b_{i,j}\) represent?'
  prefs: []
  type: TYPE_NORMAL
- en: a) The probability that vertex \(i\) is assigned to block \(j\).
  prefs: []
  type: TYPE_NORMAL
- en: b) The probability that there is an edge between any two vertices.
  prefs: []
  type: TYPE_NORMAL
- en: c) The probability that there is an edge between a vertex in block \(C_i\) and
    a vertex in block \(C_j\).
  prefs: []
  type: TYPE_NORMAL
- en: d) The weight of the edge between vertex \(i\) and vertex \(j\).
  prefs: []
  type: TYPE_NORMAL
- en: '**2** Consider the following graph generated using NetworkX in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph](../Images/3b340cd5c7599903fa112649b21082f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Which of the following models could have produced this graph?
  prefs: []
  type: TYPE_NORMAL
- en: a) An Erdős-Rényi (ER) random graph.
  prefs: []
  type: TYPE_NORMAL
- en: b) A stochastic blockmodel (SBM) with two communities.
  prefs: []
  type: TYPE_NORMAL
- en: c) A symmetric stochastic blockmodel (SSBM) with two equal-sized communities
    (i.e., where in addition \(b_{1,1} = b_{2,2}\)).
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above.
  prefs: []
  type: TYPE_NORMAL
- en: '**3** Consider an Erdős-Rényi (ER) random graph with \(n\) vertices and edge
    probability \(p\). The expected number of edges in the graph is:'
  prefs: []
  type: TYPE_NORMAL
- en: a) \(n^2p\)
  prefs: []
  type: TYPE_NORMAL
- en: b) \(\binom{n}{2}p\)
  prefs: []
  type: TYPE_NORMAL
- en: c) \(np\)
  prefs: []
  type: TYPE_NORMAL
- en: d) \(n(n-1)p\)
  prefs: []
  type: TYPE_NORMAL
- en: '**4** Consider the following Python code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Which of the following best describes the graph generated by this code?
  prefs: []
  type: TYPE_NORMAL
- en: a) An Erdős-Rényi (ER) random graph with \(n=5\) vertices and edge probability
    \(p=0.4\).
  prefs: []
  type: TYPE_NORMAL
- en: b) A stochastic blockmodel (SBM) with \(n=5\) vertices and intra-block probability
    \(p=0.4\).
  prefs: []
  type: TYPE_NORMAL
- en: c) A symmetric stochastic blockmodel (SSBM) with \(n=5\) vertices and inter-block
    probability \(p=0.4\).
  prefs: []
  type: TYPE_NORMAL
- en: d) An inhomogeneous Erdős-Rényi (ER) random graph with \(n=5\) vertices and
    edge probabilities given by a matrix \(M\).
  prefs: []
  type: TYPE_NORMAL
- en: '**5** In the stochastic blockmodel, what happens to the difficulty of recovering
    the community structure if the inter-block connection probability \(b_{1,2}\)
    is close to the intra-block connection probability \(b_{1,1}\)?'
  prefs: []
  type: TYPE_NORMAL
- en: a) It becomes easier.
  prefs: []
  type: TYPE_NORMAL
- en: b) It remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: c) It becomes harder.
  prefs: []
  type: TYPE_NORMAL
- en: d) None of the above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 1: c. Justification: The text defines \(b_{i,j}\) as “the probability
    that a vertex in block \(C_i\) and a vertex in block \(C_j\) are connected by
    an edge.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 2: d. Justification: The graph consists of two cliques (complete
    subgraphs) of size 3 each, one with vertices 0, 1, and 2 and another with vertices
    3, 4, and 5\. There are no edges between the two cliques. It has a positive probability
    of occurring under any ER, SBM, or SSBM random graph model where all edge probabilities
    are in \((0,1)\).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 3: b. Justification: The text states: “Let’s compute the expected
    number of edges \(G\). By summing over all pairs and using linearity of expectation,
    we have \(\mathbb{E}[|E|] = \mathbb{E} [\sum_{i<j} \mathbf{1}_{\{i,j\} \in E}]
    = \sum_{i<j} \mathbb{E} [\mathbf{1}_{\{i,j\} \in E}] = \binom{n}{2}p\).”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 4: a. Justification: The code generates an ER random graph with
    \(n=5\) vertices, where each edge is included independently with probability \(p=0.4\).
    This is evident from the nested loop structure and the condition `if rng.random()
    < p` for adding edges.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 5: c. Justification: When the inter-block connection probability
    \(b_{1,2}\) is close to the intra-block connection probability \(b_{1,1}\), the
    community structure becomes harder to recover because the distinction between
    the blocks is less clear.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.1\. Inhomogeneous Erdős-Rényi random graph[#](#inhomogeneous-erdos-renyi-random-graph
    "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simple approach to generating a random graph is to include each edge *independently*.
    More precisely, let \(V = [n]\) be a set of \(n\) vertices. Consider a symmetric
    matrix \(M = (m_{i,j}) \in [0,1]^{n \times n}\) with arbitrary entries in \([0,1]\).
    The entry \(m_{i,j} = m_{j,i}\) is the probability that edge \(\{i,j\}\) is present
    (i.e., that \(\{i,j\} \in E\)), independently of all other edges. The outcome
    is a random graph \(G = (V, E)\) with random adjacency matrix \(A = (A_{i,j})
    \in \{0,1\}^{n \times n}\). This model is known as an inhomogeneous Erdős-Rényi
    (ER) random graph\(\idx{inhomogeneous Erdős-Rényi random graph}\xdi\).
  prefs: []
  type: TYPE_NORMAL
- en: Observe that
  prefs: []
  type: TYPE_NORMAL
- en: \[ \E[A_{i,j}] = 1 \cdot m_{i,j} + 0 \cdot (1 - m_{i,j}) = m_{i,j}. \]
  prefs: []
  type: TYPE_NORMAL
- en: Indeed each entry \(A_{i,j}\) is a Bernoulli random variable with success probability
    \(m_{i,j}\). In other words, in matrix form, we have
  prefs: []
  type: TYPE_NORMAL
- en: \[ \E[A] = M, \]
  prefs: []
  type: TYPE_NORMAL
- en: that is, \(M\) is the expected adjacency matrix. Note in particular that \(M\)
    is deterministic while \(A\) is random (which is why we use lowercase entries
    for \(M\) but uppercase entries for \(A\)).
  prefs: []
  type: TYPE_NORMAL
- en: An important special case is obtained when \(m_{i,j} = m_{j,i} = p \in (0,1)\)
    for all \(i \neq j\) and \(m_{k,k} = 0\) for all \(k\). That is, each possible
    edge between two distinct vertices is present with the same probability \(p\).
    This model is known simply as an Erdős-Rényi (ER) random graph\(\idx{Erdős-Rényi
    random graph}\xdi\). Put differently,
  prefs: []
  type: TYPE_NORMAL
- en: \[ \E[A] = M = p (J - I_{n \times n}), \]
  prefs: []
  type: TYPE_NORMAL
- en: where \(J \in \mathbb{R}^{n \times n}\) is the all-one matrix. In this calculation,
    we subtract the identity matrix to account for the fact that the diagonal is \(0\).
  prefs: []
  type: TYPE_NORMAL
- en: The properties of this model are very well-studied. We give a couple of examples
    next. For an event \(\mathcal{F}\), the indicator random variable \(\mathbf{1}_{\mathcal{F}}\)
    is \(1\) if \(\mathcal{F}\) occurs, and \(0\) otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '**EXAMPLE:** Let \(G = (V, E)\) be an ER graph with \(n\) vertices. The parameter
    \(p\) can be interpreted as an edge density. Indeed, let’s compute the expected
    number of edges \(G\). By summing over all pairs and using linearity of expectation,
    we have'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{align*} \E[|E|] &= \E \left[\sum_{i < j} \mathbf{1}_{\{i,j\} \in E}\right]\\
    &= \sum_{i < j} \E \left[\mathbf{1}_{\{i,j\} \in E}\right]\\ &= \binom{n}{2} p.
    \end{align*}\]
  prefs: []
  type: TYPE_NORMAL
- en: Or, put differently, we have shown that the expected edge density \(\E\left[|E|/\binom{n}{2}\right]\)
    is \(p\).
  prefs: []
  type: TYPE_NORMAL
- en: A similar calculation gives the expected number of triangles. Denote by \(T_3\)
    the number of triangles in \(G\), that is, the number of triples \(i, j , k\)
    of distinct vertices such that \(\{i,j\}, \{j,k\}, \{i,k\} \in E\) (i.e., all
    edges between them are present). Then
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{align*} \E[|T_3|] &= \E \left[\sum_{i < j < k} \mathbf{1}_{\{i,j\},
    \{j,k\}, \{i,k\} \in E}\right]\\ &= \E \left[\sum_{i < j < k} \mathbf{1}_{\{i,j\}
    \in E} \mathbf{1}_{\{j,k\} \in E} \mathbf{1}_{\{i,k\} \in E}\right]\\ &= \sum_{i
    < j < k} \E \left[\mathbf{1}_{\{i,j\} \in E}\right] \E \left[\mathbf{1}_{\{j,k\}
    \in E}\right] \E\left[\mathbf{1}_{\{i,k\} \in E}\right]\\ &= \binom{n}{3} p^3.
    \end{align*}\]
  prefs: []
  type: TYPE_NORMAL
- en: We used the independence of the edges on the third line. Or, put differently,
    we have shown that the expected triangle density \(\E\left[|T_3|/\binom{n}{3}\right]\)
    is \(p^3\). \(\lhd\)
  prefs: []
  type: TYPE_NORMAL
- en: We implement the generation of an inhomogeneous ER graph using NetworkX. We
    first initialize a pseudorandom number generator `rng`. To determine whether an
    edge is present between `i` and `j`, we generate a uniform random variable `rng.random()`
    (see [`numpy.random.Generator.random`](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.random.html))
    and add the edge with `G.add_edge(i, j)` if the random variable is `< M[i, j]`
    – an event which indeed occurs with the desired probability (check it!).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**NUMERICAL CORNER:** Here is an example usage. We generate probabilities \(m_{i,j}\)
    uniformly at random between \(0\) and \(1\).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We draw the resulting graph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/a5a1fbd0498f23ac9641301349d2049a81e0c0429cbc15d654f9a3d72005ae43.png](../Images/c257b8bf58fbbcb0fd5cc44a281cb855.png)'
  prefs: []
  type: TYPE_IMG
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: The following subroutine generates an ER graph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To confirm our previous calculations, below is the implementation of a routine
    to estimate the edge density for an ER graph with a fixed parameter \(p\). Recall
    that the edge density is defined as the number of edges present divided by the
    number of possible edges (i.e., the number of pairs of distinct vertices). The
    routine takes advantage of the *Law of Large Numbers* by generating a large number
    of sample graphs, computing their edge density, and then taking the mean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**NUMERICAL CORNER:** On a small example, we indeed get that the edge density
    is roughly \(p\).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**TRY IT!** Modify the code above to estimate the density of triangles. ([Open
    In Colab](https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_specgraph_notebook.ipynb))
    \(\ddagger\)'
  prefs: []
  type: TYPE_NORMAL
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: When \(n\), the number of vertices, is large, random graphs tend to exhibit
    large-scale emergent behavior. One classical example involves the probability
    of being connected in an ER graph. To illustrate, below is code to estimate that
    probability over a range of edge densities \(p\) (with help from Claude and ChatGPT).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**NUMERICAL CORNER:** We run the code for `n` equal to `100`. What do you observe?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/04efd601c9047c499cb95d5acf06604fe4f0dda7ba32a3531fb3632e84836f7f.png](../Images/a6ba5ed9893af4c1125c90607e734d1d.png)'
  prefs: []
  type: TYPE_IMG
- en: The probability of being connected starts out at \(0\) when \(p\) is small,
    which is not surprising since it implies that the graph has a relatively small
    number of edges. But then that probability increases – rapidly – to \(1\) as \(p\)
    crosses a threshold. This is referred to as the phase transition of the ER graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be shown rigorously that the transition occurs at roughly \(p = \log
    n/n\). That is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: which is consistent with the plot.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRY IT!** Taking a larger `n` would produce a sharper transition. Try it
    for yourself. Also try drawing one random sample for increasing values of \(p\)
    around the threshold. What do you observe? ([Open In Colab](https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_specgraph_notebook.ipynb))
    \(\ddagger\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**TRY IT!** Many other properties exhibit such sharp threshold behavior. Modify
    the code to to estimate the probability that a clique of size 4 exists in the
    graph. ([Open In Colab](https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_specgraph_notebook.ipynb))
    \(\ddagger\)'
  prefs: []
  type: TYPE_NORMAL
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.2\. Stochastic blockmodel[#](#stochastic-blockmodel "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We return to our original motivation. How can we create a random graph with
    a planted partition? The stochastic blockmodel (SBM) is such a model. Here we
    imagine that \([n]\) is partitioned into two disjoint sets \(C_1\) and \(C_2\),
    referred to as blocks. We set \(z(i) = j\) if vertex \(i\) is in block \(C_j\).
    We also encode the block assignment with a matrix \(Z \in \{0,1\}^{n \times 2}\)
    where row \(i\) is \(\mathbf{e}_j^T\) if vertex \(i\) is assigned to block \(C_j\).
  prefs: []
  type: TYPE_NORMAL
- en: Let \(b_{i,j} \in [0,1]\) be the probability that a vertex in block \(C_i\)
    and a vertex in block \(C_j\) are connected by an edge, independently of all other
    edges. We enforce \(b_{1,2} = b_{2,1}\). We collect these probabilities in the
    following matrix
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split} B = \begin{pmatrix} b_{1,1} & b_{1,2}\\ b_{2,1} & b_{2,2} \end{pmatrix}.
    \end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: By our assumption, the matrix \(B\) is symmetric.
  prefs: []
  type: TYPE_NORMAL
- en: We typically take
  prefs: []
  type: TYPE_NORMAL
- en: \[ \min\{b_{1,1}, b_{2,2}\} > b_{1,2}, \]
  prefs: []
  type: TYPE_NORMAL
- en: that is, edges are more likely between vertices in the same block than between
    vertices in different blocks. That corresponds to the intuition that, in social
    networks or other types of networks, members of the same group (i.e., block) tend
    to interact more frequently with each other than with members of different groups.
    For instance, friends within the same social circle are more likely to be connected
    than with people outside their circle. That is related to the concept of homophily
    which describes the tendency of individuals to associate and bond with similar
    others.
  prefs: []
  type: TYPE_NORMAL
- en: This is a special case of the inhomogeneous ER graph model. What is the corresponding
    \(M\) matrix? Note that, for each pair of vertex \(1 \leq i < j \leq n\), edge
    \(\{i,j\}\) is present in \(E\) with probability
  prefs: []
  type: TYPE_NORMAL
- en: \[ m_{i,j} := b_{z(i), z(j)} = Z_{i,\cdot} B Z_{j,\cdot}^T \]
  prefs: []
  type: TYPE_NORMAL
- en: where recall that \(Z_{i,\cdot}\) is row \(i\) of matrix \(Z\).
  prefs: []
  type: TYPE_NORMAL
- en: In matrix form, this is saying that
  prefs: []
  type: TYPE_NORMAL
- en: \[ M = Z B Z^T. \]
  prefs: []
  type: TYPE_NORMAL
- en: So, given \(B\) and \(Z\), we can generate an SBM as a special case of an inhomogeneous
    ER graph.
  prefs: []
  type: TYPE_NORMAL
- en: We implement the SBM model. We use blocks numbered \(0\) and \(1\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**NUMERICAL CORNER:** Here is an example usage. We first pick a block assignment
    at random. Specifically, blocks are assigned randomly with [`numpy.random.Generator.choice`](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.choice.html#numpy.random.Generator.choice).
    It produces two blocks by assigning each vertex with equal probability to either
    block, independently of all other choices.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We draw the graph with colored nodes based on block assignments. The “good”
    cut is clearly visible in this layout.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/d1593cbfb628739bb8775c68e246ec22340e23b00f2eb233dba14c8732005001.png](../Images/201aa17bc70e38e3e3d759bd8e23f659.png)'
  prefs: []
  type: TYPE_IMG
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: We introduce a subroutine which assigns blocks at random as follows. Let \(\beta_1,
    \beta_2 \in [0,1]\) with \(\beta_1 + \beta_2 = 1\) be the probability that a vertex
    belongs respectively to block \(1\) and \(2\). We collect these probabilities
    in the following vector
  prefs: []
  type: TYPE_NORMAL
- en: \[ \bbeta = (\beta_1, \beta_2). \]
  prefs: []
  type: TYPE_NORMAL
- en: We pick block \(z(i) \in \{1,2\}\) for each vertex \(1 \leq i \leq n\) according
    to the distribution \(\bbeta\), independently of all other vertices \(\neq i\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**NUMERICAL CORNER:** Here is an example usage.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Observe that the blocks are more unbalanced this time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/e6e9218d9f5e632ff4be76353cc005764f4073c93101c433f9f5d807555d263b.png](../Images/5a952a9ded70a63b063836a0fbfee569.png)'
  prefs: []
  type: TYPE_IMG
- en: To test our spectral partitioning algorithm, we run `spectral_cut2`, which indeed
    recovers the ground truth.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/15d02996eaea304f0dcdfdd6ab0c5fbec79eb564e0310ff803ea4e6321a23e34.png](../Images/c37ee75c9c1055f8bebc79a73fe4606f.png)'
  prefs: []
  type: TYPE_IMG
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: The following code computes the fraction of incorrectly assigned vertices. Note
    that it considers *two* assignments corresponding to swapping the labels `0` and
    `1` which cannot be inferred.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '**NUMERICAL CORNER:** We confirm on our previous example that the ground truth
    was perfectly recovered.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: One expects that the ground truth is harder to recover if the probability of
    an edge between blocks is close to that within blocks, which makes the community
    structure more murky. To test this hypothesis, we modify our previous example
    by significantly increasing the inter-block probability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We run `spectral_cut2`. It recovers the ground truth only partially this time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: '***Self-assessment quiz*** *(with help from Claude, Gemini, and ChatGPT)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**1** In a stochastic blockmodel (SBM), what does \(b_{i,j}\) represent?'
  prefs: []
  type: TYPE_NORMAL
- en: a) The probability that vertex \(i\) is assigned to block \(j\).
  prefs: []
  type: TYPE_NORMAL
- en: b) The probability that there is an edge between any two vertices.
  prefs: []
  type: TYPE_NORMAL
- en: c) The probability that there is an edge between a vertex in block \(C_i\) and
    a vertex in block \(C_j\).
  prefs: []
  type: TYPE_NORMAL
- en: d) The weight of the edge between vertex \(i\) and vertex \(j\).
  prefs: []
  type: TYPE_NORMAL
- en: '**2** Consider the following graph generated using NetworkX in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph](../Images/3b340cd5c7599903fa112649b21082f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Which of the following models could have produced this graph?
  prefs: []
  type: TYPE_NORMAL
- en: a) An Erdős-Rényi (ER) random graph.
  prefs: []
  type: TYPE_NORMAL
- en: b) A stochastic blockmodel (SBM) with two communities.
  prefs: []
  type: TYPE_NORMAL
- en: c) A symmetric stochastic blockmodel (SSBM) with two equal-sized communities
    (i.e., where in addition \(b_{1,1} = b_{2,2}\)).
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above.
  prefs: []
  type: TYPE_NORMAL
- en: '**3** Consider an Erdős-Rényi (ER) random graph with \(n\) vertices and edge
    probability \(p\). The expected number of edges in the graph is:'
  prefs: []
  type: TYPE_NORMAL
- en: a) \(n^2p\)
  prefs: []
  type: TYPE_NORMAL
- en: b) \(\binom{n}{2}p\)
  prefs: []
  type: TYPE_NORMAL
- en: c) \(np\)
  prefs: []
  type: TYPE_NORMAL
- en: d) \(n(n-1)p\)
  prefs: []
  type: TYPE_NORMAL
- en: '**4** Consider the following Python code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Which of the following best describes the graph generated by this code?
  prefs: []
  type: TYPE_NORMAL
- en: a) An Erdős-Rényi (ER) random graph with \(n=5\) vertices and edge probability
    \(p=0.4\).
  prefs: []
  type: TYPE_NORMAL
- en: b) A stochastic blockmodel (SBM) with \(n=5\) vertices and intra-block probability
    \(p=0.4\).
  prefs: []
  type: TYPE_NORMAL
- en: c) A symmetric stochastic blockmodel (SSBM) with \(n=5\) vertices and inter-block
    probability \(p=0.4\).
  prefs: []
  type: TYPE_NORMAL
- en: d) An inhomogeneous Erdős-Rényi (ER) random graph with \(n=5\) vertices and
    edge probabilities given by a matrix \(M\).
  prefs: []
  type: TYPE_NORMAL
- en: '**5** In the stochastic blockmodel, what happens to the difficulty of recovering
    the community structure if the inter-block connection probability \(b_{1,2}\)
    is close to the intra-block connection probability \(b_{1,1}\)?'
  prefs: []
  type: TYPE_NORMAL
- en: a) It becomes easier.
  prefs: []
  type: TYPE_NORMAL
- en: b) It remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: c) It becomes harder.
  prefs: []
  type: TYPE_NORMAL
- en: d) None of the above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 1: c. Justification: The text defines \(b_{i,j}\) as “the probability
    that a vertex in block \(C_i\) and a vertex in block \(C_j\) are connected by
    an edge.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 2: d. Justification: The graph consists of two cliques (complete
    subgraphs) of size 3 each, one with vertices 0, 1, and 2 and another with vertices
    3, 4, and 5\. There are no edges between the two cliques. It has a positive probability
    of occurring under any ER, SBM, or SSBM random graph model where all edge probabilities
    are in \((0,1)\).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 3: b. Justification: The text states: “Let’s compute the expected
    number of edges \(G\). By summing over all pairs and using linearity of expectation,
    we have \(\mathbb{E}[|E|] = \mathbb{E} [\sum_{i<j} \mathbf{1}_{\{i,j\} \in E}]
    = \sum_{i<j} \mathbb{E} [\mathbf{1}_{\{i,j\} \in E}] = \binom{n}{2}p\).”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 4: a. Justification: The code generates an ER random graph with
    \(n=5\) vertices, where each edge is included independently with probability \(p=0.4\).
    This is evident from the nested loop structure and the condition `if rng.random()
    < p` for adding edges.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 5: c. Justification: When the inter-block connection probability
    \(b_{1,2}\) is close to the intra-block connection probability \(b_{1,1}\), the
    community structure becomes harder to recover because the distinction between
    the blocks is less clear.'
  prefs: []
  type: TYPE_NORMAL
