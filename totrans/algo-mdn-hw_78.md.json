["```cpp\nint lower_bound(int x) {  int l = 0, r = n - 1; while (l < r) { int m = (l + r) / 2; if (t[m] >= x) r = m; else l = m + 1; } return t[l]; } \n```", "```cpp\ntemplate <class _Compare, class _ForwardIterator, class _Tp> _LIBCPP_CONSTEXPR_AFTER_CXX17 _ForwardIterator __lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp) {  typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type; difference_type __len = _VSTD::distance(__first, __last); while (__len != 0) { difference_type __l2 = _VSTD::__half_positive(__len); _ForwardIterator __m = __first; _VSTD::advance(__m, __l2); if (__comp(*__m, __value_)) { __first = ++__m; __len -= __l2 + 1; } else __len = __l2; } return __first; } \n```", "```cpp\n │35:   mov    %rax,%rdx 0.52 │      sar    %rdx 0.33 │      lea    (%rsi,%rdx,4),%rcx 4.30 │      cmp    (%rcx),%edi 65.39 │    ↓ jle    b0 0.07 │      sub    %rdx,%rax 9.32 │      lea    0x4(%rcx),%rsi 0.06 │      dec    %rax 1.37 │      test   %rax,%rax 1.11 │    ↑ jg     35 \n```", "```cpp\nint lower_bound(int x) {  int *base = t, len = n; while (len > 1) { int half = len / 2; if (base[half - 1] < x) { base += half; len = len - half; } else { len = half; } } return *base; } \n```", "```cpp\nint lower_bound(int x) {  int *base = t, len = n; while (len > 1) { int half = len / 2; if (base[half - 1] < x) base += half; len -= half; // = ceil(len / 2) } return *base; } \n```", "```cpp\nint lower_bound(int x) {  int *base = t, len = n; while (len > 1) { int half = len / 2; base += (base[half - 1] < x) * half; // will be replaced with a \"cmov\" len -= half; } return *base; } \n```", "```cpp\nint lower_bound(int x) {  int *base = t, len = n; while (len > 1) { int half = len / 2; len -= half; __builtin_prefetch(&base[len / 2 - 1]); __builtin_prefetch(&base[half + len / 2 - 1]); base += (base[half - 1] < x) * half; } return *base; } \n```", "```cpp\nint lower_bound(int x) {  int l = 0, r = n - 1; while (l < r) { int m = l + rand() % (r - l); if (t[m] >= x) r = m; else l = m + 1; } return t[l]; } \n```", "```cpp\nint a[n], t[n + 1]; // the original sorted array and the eytzinger array we build //              ^ we need one element more because of one-based indexing  void eytzinger(int k = 1) {  static int i = 0; // <- careful running it on multiple arrays if (k <= n) { eytzinger(2 * k); t[k] = a[i++]; eytzinger(2 * k + 1); } } \n```", "```cpp\nint k = 1; while (k <= n)  k = 2 * k + (t[k] < x); \n```", "```cpp\n    array:  0 1 2 3 4 5 6 7 8 9                            \neytzinger:  6 3 7 1 5 8 9 0 2 4                            \n1st range:  ------------?------  k := 2*k     = 2   (6 ≥ 3)\n2nd range:  ------?------        k := 2*k     = 4   (3 ≥ 3)\n3rd range:  --?----              k := 2*k + 1 = 9   (1 < 3)\n4th range:      ?--              k := 2*k + 1 = 19  (2 < 3)\n5th range:        !                                        \n\n```", "```cpp\nint lower_bound(int x) {  int k = 1; while (k <= n) k = 2 * k + (t[k] < x); k >>= __builtin_ffs(~k); return t[k]; } \n```", "```cpp\n2 * 2 * k           = 4 * k\n2 * 2 * k + 1       = 4 * k + 1\n2 * (2 * k + 1)     = 4 * k + 2\n2 * (2 * k + 1) + 1 = 4 * k + 3 \n```", "```cpp\nt = (int*) std::aligned_alloc(64, 4 * (n + 1)); \n```", "```cpp\nint lower_bound(int x) {  int k = 1; while (k <= n) { __builtin_prefetch(t + k * 16); k = 2 * k + (t[k] < x); } k >>= __builtin_ffs(~k); return t[k]; } \n```", "```cpp\n__builtin_prefetch(t + k * 32); \n```", "```cpp\nt[0] = -1; // an element that is less than x iters = std::__lg(n + 1);   int lower_bound(int x) {  int k = 1;   for (int i = 0; i < iters; i++) k = 2 * k + (t[k] < x);   int *loc = (k <= n ? t + k : t); k = 2 * k + (*loc < x);   k >>= __builtin_ffs(~k);   return t[k]; } \n```"]