["```\n> > k2  =  0\n> > do i  =  1,  n_sites\n> >   do j  =  1,  n_neigh(i)\n> >   k2  =  k2  +  1\n> >   counter  =  0\n> >   counter2  =  0\n> >   do n  =  1,  n_max\n> >   do np  =  n,  n_max\n> >   do l  =  0,  l_max\n> >   if(  skip_soap_component(l,  np,  n)  )cycle\n> > \n> >   counter  =  counter+1\n> >   do m  =  0,  l\n> >   k  =  1  +  l*(l+1)/2  +  m\n> >   counter2  =  counter2  +  1\n> >   multiplicity  =  multiplicity_array(counter2)\n> >   soap_rad_der(counter,  k2)  =  soap_rad_der(counter,  k2)  +  multiplicity  *  real(  cnk_rad_der(k,  n,  k2)  *  conjg(cnk(k,  np,  i))  +  cnk(k,  n,  i)  *  conjg(cnk_rad_der(k,  np,  k2))  )\n> >   soap_azi_der(counter,  k2)  =  soap_azi_der(counter,  k2)  +  multiplicity  *  real(  cnk_azi_der(k,  n,  k2)  *  conjg(cnk(k,  np,  i))  +  cnk(k,  n,  i)  *  conjg(cnk_azi_der(k,  np,  k2))  )\n> >   soap_pol_der(counter,  k2)  =  soap_pol_der(counter,  k2)  +  multiplicity  *  real(  cnk_pol_der(k,  n,  k2)  *  conjg(cnk(k,  np,  i))  +  cnk(k,  n,  i)  *  conjg(cnk_pol_der(k,  np,  k2))  )\n> >   end do\n> >  end do\n> >  end do\n> >  end do\n> > \n> >   soap_rad_der(1:n_soap,  k2)  =  soap_rad_der(1:n_soap,  k2)  /  sqrt_dot_p(i)  -  soap(1:n_soap,  i)  /  sqrt_dot_p(i)**3  *  dot_product(  soap(1:n_soap,  i),  soap_rad_der(1:n_soap,  k2)  )\n> >   soap_azi_der(1:n_soap,  k2)  =  soap_azi_der(1:n_soap,  k2)  /  sqrt_dot_p(i)  -  soap(1:n_soap,  i)  /  sqrt_dot_p(i)**3  *  dot_product(  soap(1:n_soap,  i),  soap_azi_der(1:n_soap,  k2)  )\n> >   soap_pol_der(1:n_soap,  k2)  =  soap_pol_der(1:n_soap,  k2)  /  sqrt_dot_p(i)  -  soap(1:n_soap,  i)  /  sqrt_dot_p(i)**3  *  dot_product(  soap(1:n_soap,  i),  soap_pol_der(1:n_soap,  k2)  )\n> > \n> >   if(  j  ==  1  )then\n> >   k3  =  k2\n> >   else\n> >   soap_cart_der(1,  1:n_soap,  k2)  =  dsin(thetas(k2))  *  dcos(phis(k2))  *  soap_rad_der(1:n_soap,  k2)  -  dcos(thetas(k2))  *  dcos(phis(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)  -  dsin(phis(k2))  /  rjs(k2)  *  soap_azi_der(1:n_soap,  k2)\n> >   soap_cart_der(2,  1:n_soap,  k2)  =  dsin(thetas(k2))  *  dsin(phis(k2))  *  soap_rad_der(1:n_soap,  k2)  -  dcos(thetas(k2))  *  dsin(phis(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)  +  dcos(phis(k2))  /  rjs(k2)  *  soap_azi_der(1:n_soap,  k2)\n> >   soap_cart_der(3,  1:n_soap,  k2)  =  dcos(thetas(k2))  *  soap_rad_der(1:n_soap,  k2)  +  dsin(thetas(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)\n> >   soap_cart_der(1,  1:n_soap,  k3)  =  soap_cart_der(1,  1:n_soap,  k3)  -  soap_cart_der(1,  1:n_soap,  k2)\n> >   soap_cart_der(2,  1:n_soap,  k3)  =  soap_cart_der(2,  1:n_soap,  k3)  -  soap_cart_der(2,  1:n_soap,  k2)\n> >   soap_cart_der(3,  1:n_soap,  k3)  =  soap_cart_der(3,  1:n_soap,  k3)  -  soap_cart_der(3,  1:n_soap,  k2)\n> >   end if\n> >  end do\n> > end do \n> > ```", "```\n>  !omp target teams distribute parallel do private (i)\n>   do k2  =  1,  k2_max\n>   i=list_of_i(k2)\n>   counter  =  0\n>   counter2  =  0\n>   do n  =  1,  n_max\n>   do np  =  n,  n_max\n>   do l  =  0,  l_max\n>   if(  skip_soap_component(l,  np,  n)  )  then\n>  cycle\n>  endif\n>   counter  =  counter+1\n>   do m  =  0,  l\n>   k  =  1  +  l*(l+1)/2  +  m\n>   counter2  =  counter2  +  1\n>   multiplicity  =  multiplicity_array(counter2)\n>   tsoap_rad_der(k2,counter)  =  tsoap_rad_der(k2,counter)  +  multiplicity  *  real(  tcnk_rad_der(k2,k,n)  *  conjg(tcnk(i,k,np))  +  tcnk(i,k,n)  *  conjg(tcnk_rad_der(k2,k,np))  )\n>   tsoap_azi_der(k2,counter)  =  tsoap_azi_der(k2,counter)  +  multiplicity  *  real(  tcnk_azi_der(k2,k,n)  *  conjg(tcnk(i,k,np))  +  tcnk(i,k,n)  *  conjg(tcnk_azi_der(k2,k,np))  )\n>   tsoap_pol_der(k2,counter)  =  tsoap_pol_der(k2,counter)  +  multiplicity  *  real(  tcnk_pol_der(k2,k,n)  *  conjg(tcnk(i,k,np))  +  tcnk(i,k,n)  *  conjg(tcnk_pol_der(k2,k,np))  )\n>   end do\n>  end do\n>  end do\n>  end do\n>  end do\n> \n> ! Before the next part the variables are transposed again to their original layout.\n> \n>   !omp target teams  distribute private(i)\n>   do k2  =  1,  k2_max\n>   i=list_of_i(k2)\n>   locdot=0.d0\n> \n>   !omp parallel do reduction(+:locdot_rad_der,locdot_azi_der,locdot_pol_der)\n>   do is=1,nsoap\n>   locdot_rad_der=locdot_rad_der+soap(is,  i)  *  soap_rad_der(is,  k2)\n>   locdot_azi_der=locdot_azi_der+soap(is,  i)  *  soap_azi_der(is,  k2)\n>   locdot_pol_der=locdot_pol_der+soap(is,  i)  *  soap_pol_der(is,  k2)\n>   enddo\n>   dot_soap_rad_der(k2)=  locdot_rad_der\n>   dot_soap_azi_der(k2)=  locdot_azi_der\n>   dot_soap_pol_der(k2)=  locdot_pol_der\n>   end do\n> \n>   !omp target teams distribute\n>   do k2  =  1,  k2_max\n>   i=list_of_i(k2)\n> \n>   !omp parallel do\n>   do is=1,nsoap\n>   soap_rad_der(is,  k2)  =  soap_rad_der(is,  k2)  /  sqrt_dot_p(i)  -  soap(is,  i)  /  sqrt_dot_p(i)**3  *  dot_soap_rad_der(k2)\n>   soap_azi_der(is,  k2)  =  soap_azi_der(is,  k2)  /  sqrt_dot_p(i)  -  soap(is,  i)  /  sqrt_dot_p(i)**3  *  dot_soap_azi_der(k2)\n>   soap_pol_der(is,  k2)  =  soap_pol_der(is,  k2)  /  sqrt_dot_p(i)  -  soap(is,  i)  /  sqrt_dot_p(i)**3  *  dot_soap_pol_der(k2)\n>   end do\n>  end do\n> \n>   !omp teams distribute private(k3)\n>   do k2  =  1,  k2_max\n>   k3=list_k2k3(k2)\n> \n>   !omp parallel do private (is)\n>   do is=1,n_soap\n>   if(  k3  /=  k2)then\n>   soap_cart_der(1,  is,  k2)  =  dsin(thetas(k2))  *  dcos(phis(k2))  *  soap_rad_der(1:n_soap,  k2)  -  dcos(thetas(k2))  *  dcos(phis(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)  -  dsin(phis(k2))  /  rjs(k2)  *  soap_azi_der(is,  k2)\n>   soap_cart_der(2,  is,  k2)  =  dsin(thetas(k2))  *  dsin(phis(k2))  *  soap_rad_der(1:n_soap,  k2)  -  dcos(thetas(k2))  *  dsin(phis(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)  +  dcos(phis(k2))  /  rjs(k2)  *  soap_azi_der(is,  k2)\n>   soap_cart_der(3,  is,  k2)  =  dcos(thetas(k2))  *  soap_rad_der(is,  k2)  +  dsin(thetas(k2))  /  rjs(k2)  *  soap_pol_der(is,  k2)\n>   end if\n>  end do\n>  end do\n> \n>   !omp teams distribute private(k3)\n>   do i  =  1,  n_sites\n>   k3=list_k3(i)\n> \n>   !omp parallel do private(is, k2)\n>   do is=1,n_soap\n>   do k2=k3+1,k3+n_neigh(i)\n>   soap_cart_der(1,  is,  k3)  =  soap_cart_der(1,  is,  k3)  -  soap_cart_der(1,  is,  k2)\n>   soap_cart_der(2,  is,  k3)  =  soap_cart_der(2,  is,  k3)  -  soap_cart_der(2,  is,  k2)\n>   soap_cart_der(3,  is,  k3)  =  soap_cart_der(3,  is,  k3)  -  soap_cart_der(3,  is,  k2)\n>   end do\n>  end do\n>  end do \n> ```", "```\n    $ module  load  rocm/6.0.3\n    $ hipify-clang  --perl \n    ```", "```\n    $ hipify-perl  program.cu  >  program.cu.hip \n    ```", "```\n    $ hipcc  --offload-arch=gfx90a  -o  program.hip.exe  program.cu.hip \n    ```", "```\n    $ singularity  pull  docker://nvcr.io/nvidia/cuda:11.4.3-devel-ubuntu20.04 \n    ```", "```\n    $ module  load  rocm/6.0.3\n    $ singularity  shell  -B  $PWD,/opt:/opt  cuda_11.4.0-devel-ubuntu20.04.sif \n    ```", "```\n    $ export  PATH=/opt/rocm-6.0.3/bin:$PATH \n    ```", "```\n    $ hipify-clang  program.cu  -o  hip_program.cu.hip  --cuda-path=/usr/local/cuda-11.4  -I  /usr/local/cuda-11.4/include \n    ```", "```\n> $ git  clone  https://github.com/ENCCS/gpu-programming.git\n> $ cd  gpu-programming/content/examples/exercise_hipify\n> $ ls \n> ```", "```\n    $ git  clone  -b  clacc/main  https://github.com/llvm-doe-org/llvm-project.git\n    $ cd  llvm-project\n    $ mkdir  build  &&  cd  build\n    $ cmake  -DCMAKE_INSTALL_PREFIX=../install  \\\n      -DCMAKE_BUILD_TYPE=Release  \\\n      -DLLVM_ENABLE_PROJECTS=\"clang;lld\"  \\\n      -DLLVM_ENABLE_RUNTIMES=openmp  \\\n      -DLLVM_TARGETS_TO_BUILD=\"host;AMDGPU\"  \\\n      -DCMAKE_C_COMPILER=gcc  \\\n      -DCMAKE_CXX_COMPILER=g++  \\\n      ../llvm\n    $ make\n    $ make  install \n    ```", "```\n> $ export  PATH=/scratch/project_465002387/clacc/llvm-project/install/bin:$PATH\n> $ export  LD_LIBRARY_PATH=/scratch/project_465002387/clacc/llvm-project/install/lib:$LD_LIBRARY_PATH \n> ```", "```\n    $ clang  -fopenacc-print=omp  -fopenacc-structured-ref-count-omp=no-ompx-hold  openACC_code.c  >  openMP_code.c \n    ```", "```\n    module load CrayEnv\n    module load PrgEnv-cray\n    module load craype-accel-amd-gfx90a\n    module load rocm/6.0.3\n\n    cc -fopenmp -o executable openMP_code.c \n    ```", "```\n$ git  clone  https://github.com/ENCCS/gpu-programming.git\n$ cd  gpu-programming/content/examples/exercise_clacc\n$ ls \n```", "```\n> $ dpct  program.cu\n> $ cd  dpct_output/\n> $ icpx  -fsycl  program.dp.cpp \n> ```", "```\n> > k2  =  0\n> > do i  =  1,  n_sites\n> >   do j  =  1,  n_neigh(i)\n> >   k2  =  k2  +  1\n> >   counter  =  0\n> >   counter2  =  0\n> >   do n  =  1,  n_max\n> >   do np  =  n,  n_max\n> >   do l  =  0,  l_max\n> >   if(  skip_soap_component(l,  np,  n)  )cycle\n> > \n> >   counter  =  counter+1\n> >   do m  =  0,  l\n> >   k  =  1  +  l*(l+1)/2  +  m\n> >   counter2  =  counter2  +  1\n> >   multiplicity  =  multiplicity_array(counter2)\n> >   soap_rad_der(counter,  k2)  =  soap_rad_der(counter,  k2)  +  multiplicity  *  real(  cnk_rad_der(k,  n,  k2)  *  conjg(cnk(k,  np,  i))  +  cnk(k,  n,  i)  *  conjg(cnk_rad_der(k,  np,  k2))  )\n> >   soap_azi_der(counter,  k2)  =  soap_azi_der(counter,  k2)  +  multiplicity  *  real(  cnk_azi_der(k,  n,  k2)  *  conjg(cnk(k,  np,  i))  +  cnk(k,  n,  i)  *  conjg(cnk_azi_der(k,  np,  k2))  )\n> >   soap_pol_der(counter,  k2)  =  soap_pol_der(counter,  k2)  +  multiplicity  *  real(  cnk_pol_der(k,  n,  k2)  *  conjg(cnk(k,  np,  i))  +  cnk(k,  n,  i)  *  conjg(cnk_pol_der(k,  np,  k2))  )\n> >   end do\n> >  end do\n> >  end do\n> >  end do\n> > \n> >   soap_rad_der(1:n_soap,  k2)  =  soap_rad_der(1:n_soap,  k2)  /  sqrt_dot_p(i)  -  soap(1:n_soap,  i)  /  sqrt_dot_p(i)**3  *  dot_product(  soap(1:n_soap,  i),  soap_rad_der(1:n_soap,  k2)  )\n> >   soap_azi_der(1:n_soap,  k2)  =  soap_azi_der(1:n_soap,  k2)  /  sqrt_dot_p(i)  -  soap(1:n_soap,  i)  /  sqrt_dot_p(i)**3  *  dot_product(  soap(1:n_soap,  i),  soap_azi_der(1:n_soap,  k2)  )\n> >   soap_pol_der(1:n_soap,  k2)  =  soap_pol_der(1:n_soap,  k2)  /  sqrt_dot_p(i)  -  soap(1:n_soap,  i)  /  sqrt_dot_p(i)**3  *  dot_product(  soap(1:n_soap,  i),  soap_pol_der(1:n_soap,  k2)  )\n> > \n> >   if(  j  ==  1  )then\n> >   k3  =  k2\n> >   else\n> >   soap_cart_der(1,  1:n_soap,  k2)  =  dsin(thetas(k2))  *  dcos(phis(k2))  *  soap_rad_der(1:n_soap,  k2)  -  dcos(thetas(k2))  *  dcos(phis(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)  -  dsin(phis(k2))  /  rjs(k2)  *  soap_azi_der(1:n_soap,  k2)\n> >   soap_cart_der(2,  1:n_soap,  k2)  =  dsin(thetas(k2))  *  dsin(phis(k2))  *  soap_rad_der(1:n_soap,  k2)  -  dcos(thetas(k2))  *  dsin(phis(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)  +  dcos(phis(k2))  /  rjs(k2)  *  soap_azi_der(1:n_soap,  k2)\n> >   soap_cart_der(3,  1:n_soap,  k2)  =  dcos(thetas(k2))  *  soap_rad_der(1:n_soap,  k2)  +  dsin(thetas(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)\n> >   soap_cart_der(1,  1:n_soap,  k3)  =  soap_cart_der(1,  1:n_soap,  k3)  -  soap_cart_der(1,  1:n_soap,  k2)\n> >   soap_cart_der(2,  1:n_soap,  k3)  =  soap_cart_der(2,  1:n_soap,  k3)  -  soap_cart_der(2,  1:n_soap,  k2)\n> >   soap_cart_der(3,  1:n_soap,  k3)  =  soap_cart_der(3,  1:n_soap,  k3)  -  soap_cart_der(3,  1:n_soap,  k2)\n> >   end if\n> >  end do\n> > end do \n> > ```", "```\n>  !omp target teams distribute parallel do private (i)\n>   do k2  =  1,  k2_max\n>   i=list_of_i(k2)\n>   counter  =  0\n>   counter2  =  0\n>   do n  =  1,  n_max\n>   do np  =  n,  n_max\n>   do l  =  0,  l_max\n>   if(  skip_soap_component(l,  np,  n)  )  then\n>  cycle\n>  endif\n>   counter  =  counter+1\n>   do m  =  0,  l\n>   k  =  1  +  l*(l+1)/2  +  m\n>   counter2  =  counter2  +  1\n>   multiplicity  =  multiplicity_array(counter2)\n>   tsoap_rad_der(k2,counter)  =  tsoap_rad_der(k2,counter)  +  multiplicity  *  real(  tcnk_rad_der(k2,k,n)  *  conjg(tcnk(i,k,np))  +  tcnk(i,k,n)  *  conjg(tcnk_rad_der(k2,k,np))  )\n>   tsoap_azi_der(k2,counter)  =  tsoap_azi_der(k2,counter)  +  multiplicity  *  real(  tcnk_azi_der(k2,k,n)  *  conjg(tcnk(i,k,np))  +  tcnk(i,k,n)  *  conjg(tcnk_azi_der(k2,k,np))  )\n>   tsoap_pol_der(k2,counter)  =  tsoap_pol_der(k2,counter)  +  multiplicity  *  real(  tcnk_pol_der(k2,k,n)  *  conjg(tcnk(i,k,np))  +  tcnk(i,k,n)  *  conjg(tcnk_pol_der(k2,k,np))  )\n>   end do\n>  end do\n>  end do\n>  end do\n>  end do\n> \n> ! Before the next part the variables are transposed again to their original layout.\n> \n>   !omp target teams  distribute private(i)\n>   do k2  =  1,  k2_max\n>   i=list_of_i(k2)\n>   locdot=0.d0\n> \n>   !omp parallel do reduction(+:locdot_rad_der,locdot_azi_der,locdot_pol_der)\n>   do is=1,nsoap\n>   locdot_rad_der=locdot_rad_der+soap(is,  i)  *  soap_rad_der(is,  k2)\n>   locdot_azi_der=locdot_azi_der+soap(is,  i)  *  soap_azi_der(is,  k2)\n>   locdot_pol_der=locdot_pol_der+soap(is,  i)  *  soap_pol_der(is,  k2)\n>   enddo\n>   dot_soap_rad_der(k2)=  locdot_rad_der\n>   dot_soap_azi_der(k2)=  locdot_azi_der\n>   dot_soap_pol_der(k2)=  locdot_pol_der\n>   end do\n> \n>   !omp target teams distribute\n>   do k2  =  1,  k2_max\n>   i=list_of_i(k2)\n> \n>   !omp parallel do\n>   do is=1,nsoap\n>   soap_rad_der(is,  k2)  =  soap_rad_der(is,  k2)  /  sqrt_dot_p(i)  -  soap(is,  i)  /  sqrt_dot_p(i)**3  *  dot_soap_rad_der(k2)\n>   soap_azi_der(is,  k2)  =  soap_azi_der(is,  k2)  /  sqrt_dot_p(i)  -  soap(is,  i)  /  sqrt_dot_p(i)**3  *  dot_soap_azi_der(k2)\n>   soap_pol_der(is,  k2)  =  soap_pol_der(is,  k2)  /  sqrt_dot_p(i)  -  soap(is,  i)  /  sqrt_dot_p(i)**3  *  dot_soap_pol_der(k2)\n>   end do\n>  end do\n> \n>   !omp teams distribute private(k3)\n>   do k2  =  1,  k2_max\n>   k3=list_k2k3(k2)\n> \n>   !omp parallel do private (is)\n>   do is=1,n_soap\n>   if(  k3  /=  k2)then\n>   soap_cart_der(1,  is,  k2)  =  dsin(thetas(k2))  *  dcos(phis(k2))  *  soap_rad_der(1:n_soap,  k2)  -  dcos(thetas(k2))  *  dcos(phis(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)  -  dsin(phis(k2))  /  rjs(k2)  *  soap_azi_der(is,  k2)\n>   soap_cart_der(2,  is,  k2)  =  dsin(thetas(k2))  *  dsin(phis(k2))  *  soap_rad_der(1:n_soap,  k2)  -  dcos(thetas(k2))  *  dsin(phis(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)  +  dcos(phis(k2))  /  rjs(k2)  *  soap_azi_der(is,  k2)\n>   soap_cart_der(3,  is,  k2)  =  dcos(thetas(k2))  *  soap_rad_der(is,  k2)  +  dsin(thetas(k2))  /  rjs(k2)  *  soap_pol_der(is,  k2)\n>   end if\n>  end do\n>  end do\n> \n>   !omp teams distribute private(k3)\n>   do i  =  1,  n_sites\n>   k3=list_k3(i)\n> \n>   !omp parallel do private(is, k2)\n>   do is=1,n_soap\n>   do k2=k3+1,k3+n_neigh(i)\n>   soap_cart_der(1,  is,  k3)  =  soap_cart_der(1,  is,  k3)  -  soap_cart_der(1,  is,  k2)\n>   soap_cart_der(2,  is,  k3)  =  soap_cart_der(2,  is,  k3)  -  soap_cart_der(2,  is,  k2)\n>   soap_cart_der(3,  is,  k3)  =  soap_cart_der(3,  is,  k3)  -  soap_cart_der(3,  is,  k2)\n>   end do\n>  end do\n>  end do \n> ```", "```\n    $ module  load  rocm/6.0.3\n    $ hipify-clang  --perl \n    ```", "```\n    $ hipify-perl  program.cu  >  program.cu.hip \n    ```", "```\n    $ hipcc  --offload-arch=gfx90a  -o  program.hip.exe  program.cu.hip \n    ```", "```\n    $ singularity  pull  docker://nvcr.io/nvidia/cuda:11.4.3-devel-ubuntu20.04 \n    ```", "```\n    $ module  load  rocm/6.0.3\n    $ singularity  shell  -B  $PWD,/opt:/opt  cuda_11.4.0-devel-ubuntu20.04.sif \n    ```", "```\n    $ export  PATH=/opt/rocm-6.0.3/bin:$PATH \n    ```", "```\n    $ hipify-clang  program.cu  -o  hip_program.cu.hip  --cuda-path=/usr/local/cuda-11.4  -I  /usr/local/cuda-11.4/include \n    ```", "```\n> $ git  clone  https://github.com/ENCCS/gpu-programming.git\n> $ cd  gpu-programming/content/examples/exercise_hipify\n> $ ls \n> ```", "```\n    $ git  clone  -b  clacc/main  https://github.com/llvm-doe-org/llvm-project.git\n    $ cd  llvm-project\n    $ mkdir  build  &&  cd  build\n    $ cmake  -DCMAKE_INSTALL_PREFIX=../install  \\\n      -DCMAKE_BUILD_TYPE=Release  \\\n      -DLLVM_ENABLE_PROJECTS=\"clang;lld\"  \\\n      -DLLVM_ENABLE_RUNTIMES=openmp  \\\n      -DLLVM_TARGETS_TO_BUILD=\"host;AMDGPU\"  \\\n      -DCMAKE_C_COMPILER=gcc  \\\n      -DCMAKE_CXX_COMPILER=g++  \\\n      ../llvm\n    $ make\n    $ make  install \n    ```", "```\n> $ export  PATH=/scratch/project_465002387/clacc/llvm-project/install/bin:$PATH\n> $ export  LD_LIBRARY_PATH=/scratch/project_465002387/clacc/llvm-project/install/lib:$LD_LIBRARY_PATH \n> ```", "```\n    $ clang  -fopenacc-print=omp  -fopenacc-structured-ref-count-omp=no-ompx-hold  openACC_code.c  >  openMP_code.c \n    ```", "```\n    module load CrayEnv\n    module load PrgEnv-cray\n    module load craype-accel-amd-gfx90a\n    module load rocm/6.0.3\n\n    cc -fopenmp -o executable openMP_code.c \n    ```", "```\n$ git  clone  https://github.com/ENCCS/gpu-programming.git\n$ cd  gpu-programming/content/examples/exercise_clacc\n$ ls \n```", "```\n> $ dpct  program.cu\n> $ cd  dpct_output/\n> $ icpx  -fsycl  program.dp.cpp \n> ```", "```\n> > k2  =  0\n> > do i  =  1,  n_sites\n> >   do j  =  1,  n_neigh(i)\n> >   k2  =  k2  +  1\n> >   counter  =  0\n> >   counter2  =  0\n> >   do n  =  1,  n_max\n> >   do np  =  n,  n_max\n> >   do l  =  0,  l_max\n> >   if(  skip_soap_component(l,  np,  n)  )cycle\n> > \n> >   counter  =  counter+1\n> >   do m  =  0,  l\n> >   k  =  1  +  l*(l+1)/2  +  m\n> >   counter2  =  counter2  +  1\n> >   multiplicity  =  multiplicity_array(counter2)\n> >   soap_rad_der(counter,  k2)  =  soap_rad_der(counter,  k2)  +  multiplicity  *  real(  cnk_rad_der(k,  n,  k2)  *  conjg(cnk(k,  np,  i))  +  cnk(k,  n,  i)  *  conjg(cnk_rad_der(k,  np,  k2))  )\n> >   soap_azi_der(counter,  k2)  =  soap_azi_der(counter,  k2)  +  multiplicity  *  real(  cnk_azi_der(k,  n,  k2)  *  conjg(cnk(k,  np,  i))  +  cnk(k,  n,  i)  *  conjg(cnk_azi_der(k,  np,  k2))  )\n> >   soap_pol_der(counter,  k2)  =  soap_pol_der(counter,  k2)  +  multiplicity  *  real(  cnk_pol_der(k,  n,  k2)  *  conjg(cnk(k,  np,  i))  +  cnk(k,  n,  i)  *  conjg(cnk_pol_der(k,  np,  k2))  )\n> >   end do\n> >  end do\n> >  end do\n> >  end do\n> > \n> >   soap_rad_der(1:n_soap,  k2)  =  soap_rad_der(1:n_soap,  k2)  /  sqrt_dot_p(i)  -  soap(1:n_soap,  i)  /  sqrt_dot_p(i)**3  *  dot_product(  soap(1:n_soap,  i),  soap_rad_der(1:n_soap,  k2)  )\n> >   soap_azi_der(1:n_soap,  k2)  =  soap_azi_der(1:n_soap,  k2)  /  sqrt_dot_p(i)  -  soap(1:n_soap,  i)  /  sqrt_dot_p(i)**3  *  dot_product(  soap(1:n_soap,  i),  soap_azi_der(1:n_soap,  k2)  )\n> >   soap_pol_der(1:n_soap,  k2)  =  soap_pol_der(1:n_soap,  k2)  /  sqrt_dot_p(i)  -  soap(1:n_soap,  i)  /  sqrt_dot_p(i)**3  *  dot_product(  soap(1:n_soap,  i),  soap_pol_der(1:n_soap,  k2)  )\n> > \n> >   if(  j  ==  1  )then\n> >   k3  =  k2\n> >   else\n> >   soap_cart_der(1,  1:n_soap,  k2)  =  dsin(thetas(k2))  *  dcos(phis(k2))  *  soap_rad_der(1:n_soap,  k2)  -  dcos(thetas(k2))  *  dcos(phis(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)  -  dsin(phis(k2))  /  rjs(k2)  *  soap_azi_der(1:n_soap,  k2)\n> >   soap_cart_der(2,  1:n_soap,  k2)  =  dsin(thetas(k2))  *  dsin(phis(k2))  *  soap_rad_der(1:n_soap,  k2)  -  dcos(thetas(k2))  *  dsin(phis(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)  +  dcos(phis(k2))  /  rjs(k2)  *  soap_azi_der(1:n_soap,  k2)\n> >   soap_cart_der(3,  1:n_soap,  k2)  =  dcos(thetas(k2))  *  soap_rad_der(1:n_soap,  k2)  +  dsin(thetas(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)\n> >   soap_cart_der(1,  1:n_soap,  k3)  =  soap_cart_der(1,  1:n_soap,  k3)  -  soap_cart_der(1,  1:n_soap,  k2)\n> >   soap_cart_der(2,  1:n_soap,  k3)  =  soap_cart_der(2,  1:n_soap,  k3)  -  soap_cart_der(2,  1:n_soap,  k2)\n> >   soap_cart_der(3,  1:n_soap,  k3)  =  soap_cart_der(3,  1:n_soap,  k3)  -  soap_cart_der(3,  1:n_soap,  k2)\n> >   end if\n> >  end do\n> > end do \n> > ```", "```\n>  !omp target teams distribute parallel do private (i)\n>   do k2  =  1,  k2_max\n>   i=list_of_i(k2)\n>   counter  =  0\n>   counter2  =  0\n>   do n  =  1,  n_max\n>   do np  =  n,  n_max\n>   do l  =  0,  l_max\n>   if(  skip_soap_component(l,  np,  n)  )  then\n>  cycle\n>  endif\n>   counter  =  counter+1\n>   do m  =  0,  l\n>   k  =  1  +  l*(l+1)/2  +  m\n>   counter2  =  counter2  +  1\n>   multiplicity  =  multiplicity_array(counter2)\n>   tsoap_rad_der(k2,counter)  =  tsoap_rad_der(k2,counter)  +  multiplicity  *  real(  tcnk_rad_der(k2,k,n)  *  conjg(tcnk(i,k,np))  +  tcnk(i,k,n)  *  conjg(tcnk_rad_der(k2,k,np))  )\n>   tsoap_azi_der(k2,counter)  =  tsoap_azi_der(k2,counter)  +  multiplicity  *  real(  tcnk_azi_der(k2,k,n)  *  conjg(tcnk(i,k,np))  +  tcnk(i,k,n)  *  conjg(tcnk_azi_der(k2,k,np))  )\n>   tsoap_pol_der(k2,counter)  =  tsoap_pol_der(k2,counter)  +  multiplicity  *  real(  tcnk_pol_der(k2,k,n)  *  conjg(tcnk(i,k,np))  +  tcnk(i,k,n)  *  conjg(tcnk_pol_der(k2,k,np))  )\n>   end do\n>  end do\n>  end do\n>  end do\n>  end do\n> \n> ! Before the next part the variables are transposed again to their original layout.\n> \n>   !omp target teams  distribute private(i)\n>   do k2  =  1,  k2_max\n>   i=list_of_i(k2)\n>   locdot=0.d0\n> \n>   !omp parallel do reduction(+:locdot_rad_der,locdot_azi_der,locdot_pol_der)\n>   do is=1,nsoap\n>   locdot_rad_der=locdot_rad_der+soap(is,  i)  *  soap_rad_der(is,  k2)\n>   locdot_azi_der=locdot_azi_der+soap(is,  i)  *  soap_azi_der(is,  k2)\n>   locdot_pol_der=locdot_pol_der+soap(is,  i)  *  soap_pol_der(is,  k2)\n>   enddo\n>   dot_soap_rad_der(k2)=  locdot_rad_der\n>   dot_soap_azi_der(k2)=  locdot_azi_der\n>   dot_soap_pol_der(k2)=  locdot_pol_der\n>   end do\n> \n>   !omp target teams distribute\n>   do k2  =  1,  k2_max\n>   i=list_of_i(k2)\n> \n>   !omp parallel do\n>   do is=1,nsoap\n>   soap_rad_der(is,  k2)  =  soap_rad_der(is,  k2)  /  sqrt_dot_p(i)  -  soap(is,  i)  /  sqrt_dot_p(i)**3  *  dot_soap_rad_der(k2)\n>   soap_azi_der(is,  k2)  =  soap_azi_der(is,  k2)  /  sqrt_dot_p(i)  -  soap(is,  i)  /  sqrt_dot_p(i)**3  *  dot_soap_azi_der(k2)\n>   soap_pol_der(is,  k2)  =  soap_pol_der(is,  k2)  /  sqrt_dot_p(i)  -  soap(is,  i)  /  sqrt_dot_p(i)**3  *  dot_soap_pol_der(k2)\n>   end do\n>  end do\n> \n>   !omp teams distribute private(k3)\n>   do k2  =  1,  k2_max\n>   k3=list_k2k3(k2)\n> \n>   !omp parallel do private (is)\n>   do is=1,n_soap\n>   if(  k3  /=  k2)then\n>   soap_cart_der(1,  is,  k2)  =  dsin(thetas(k2))  *  dcos(phis(k2))  *  soap_rad_der(1:n_soap,  k2)  -  dcos(thetas(k2))  *  dcos(phis(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)  -  dsin(phis(k2))  /  rjs(k2)  *  soap_azi_der(is,  k2)\n>   soap_cart_der(2,  is,  k2)  =  dsin(thetas(k2))  *  dsin(phis(k2))  *  soap_rad_der(1:n_soap,  k2)  -  dcos(thetas(k2))  *  dsin(phis(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)  +  dcos(phis(k2))  /  rjs(k2)  *  soap_azi_der(is,  k2)\n>   soap_cart_der(3,  is,  k2)  =  dcos(thetas(k2))  *  soap_rad_der(is,  k2)  +  dsin(thetas(k2))  /  rjs(k2)  *  soap_pol_der(is,  k2)\n>   end if\n>  end do\n>  end do\n> \n>   !omp teams distribute private(k3)\n>   do i  =  1,  n_sites\n>   k3=list_k3(i)\n> \n>   !omp parallel do private(is, k2)\n>   do is=1,n_soap\n>   do k2=k3+1,k3+n_neigh(i)\n>   soap_cart_der(1,  is,  k3)  =  soap_cart_der(1,  is,  k3)  -  soap_cart_der(1,  is,  k2)\n>   soap_cart_der(2,  is,  k3)  =  soap_cart_der(2,  is,  k3)  -  soap_cart_der(2,  is,  k2)\n>   soap_cart_der(3,  is,  k3)  =  soap_cart_der(3,  is,  k3)  -  soap_cart_der(3,  is,  k2)\n>   end do\n>  end do\n>  end do \n> ```", "```\n> > k2  =  0\n> > do i  =  1,  n_sites\n> >   do j  =  1,  n_neigh(i)\n> >   k2  =  k2  +  1\n> >   counter  =  0\n> >   counter2  =  0\n> >   do n  =  1,  n_max\n> >   do np  =  n,  n_max\n> >   do l  =  0,  l_max\n> >   if(  skip_soap_component(l,  np,  n)  )cycle\n> > \n> >   counter  =  counter+1\n> >   do m  =  0,  l\n> >   k  =  1  +  l*(l+1)/2  +  m\n> >   counter2  =  counter2  +  1\n> >   multiplicity  =  multiplicity_array(counter2)\n> >   soap_rad_der(counter,  k2)  =  soap_rad_der(counter,  k2)  +  multiplicity  *  real(  cnk_rad_der(k,  n,  k2)  *  conjg(cnk(k,  np,  i))  +  cnk(k,  n,  i)  *  conjg(cnk_rad_der(k,  np,  k2))  )\n> >   soap_azi_der(counter,  k2)  =  soap_azi_der(counter,  k2)  +  multiplicity  *  real(  cnk_azi_der(k,  n,  k2)  *  conjg(cnk(k,  np,  i))  +  cnk(k,  n,  i)  *  conjg(cnk_azi_der(k,  np,  k2))  )\n> >   soap_pol_der(counter,  k2)  =  soap_pol_der(counter,  k2)  +  multiplicity  *  real(  cnk_pol_der(k,  n,  k2)  *  conjg(cnk(k,  np,  i))  +  cnk(k,  n,  i)  *  conjg(cnk_pol_der(k,  np,  k2))  )\n> >   end do\n> >  end do\n> >  end do\n> >  end do\n> > \n> >   soap_rad_der(1:n_soap,  k2)  =  soap_rad_der(1:n_soap,  k2)  /  sqrt_dot_p(i)  -  soap(1:n_soap,  i)  /  sqrt_dot_p(i)**3  *  dot_product(  soap(1:n_soap,  i),  soap_rad_der(1:n_soap,  k2)  )\n> >   soap_azi_der(1:n_soap,  k2)  =  soap_azi_der(1:n_soap,  k2)  /  sqrt_dot_p(i)  -  soap(1:n_soap,  i)  /  sqrt_dot_p(i)**3  *  dot_product(  soap(1:n_soap,  i),  soap_azi_der(1:n_soap,  k2)  )\n> >   soap_pol_der(1:n_soap,  k2)  =  soap_pol_der(1:n_soap,  k2)  /  sqrt_dot_p(i)  -  soap(1:n_soap,  i)  /  sqrt_dot_p(i)**3  *  dot_product(  soap(1:n_soap,  i),  soap_pol_der(1:n_soap,  k2)  )\n> > \n> >   if(  j  ==  1  )then\n> >   k3  =  k2\n> >   else\n> >   soap_cart_der(1,  1:n_soap,  k2)  =  dsin(thetas(k2))  *  dcos(phis(k2))  *  soap_rad_der(1:n_soap,  k2)  -  dcos(thetas(k2))  *  dcos(phis(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)  -  dsin(phis(k2))  /  rjs(k2)  *  soap_azi_der(1:n_soap,  k2)\n> >   soap_cart_der(2,  1:n_soap,  k2)  =  dsin(thetas(k2))  *  dsin(phis(k2))  *  soap_rad_der(1:n_soap,  k2)  -  dcos(thetas(k2))  *  dsin(phis(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)  +  dcos(phis(k2))  /  rjs(k2)  *  soap_azi_der(1:n_soap,  k2)\n> >   soap_cart_der(3,  1:n_soap,  k2)  =  dcos(thetas(k2))  *  soap_rad_der(1:n_soap,  k2)  +  dsin(thetas(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)\n> >   soap_cart_der(1,  1:n_soap,  k3)  =  soap_cart_der(1,  1:n_soap,  k3)  -  soap_cart_der(1,  1:n_soap,  k2)\n> >   soap_cart_der(2,  1:n_soap,  k3)  =  soap_cart_der(2,  1:n_soap,  k3)  -  soap_cart_der(2,  1:n_soap,  k2)\n> >   soap_cart_der(3,  1:n_soap,  k3)  =  soap_cart_der(3,  1:n_soap,  k3)  -  soap_cart_der(3,  1:n_soap,  k2)\n> >   end if\n> >  end do\n> > end do \n> > ```", "```\n>  !omp target teams distribute parallel do private (i)\n>   do k2  =  1,  k2_max\n>   i=list_of_i(k2)\n>   counter  =  0\n>   counter2  =  0\n>   do n  =  1,  n_max\n>   do np  =  n,  n_max\n>   do l  =  0,  l_max\n>   if(  skip_soap_component(l,  np,  n)  )  then\n>  cycle\n>  endif\n>   counter  =  counter+1\n>   do m  =  0,  l\n>   k  =  1  +  l*(l+1)/2  +  m\n>   counter2  =  counter2  +  1\n>   multiplicity  =  multiplicity_array(counter2)\n>   tsoap_rad_der(k2,counter)  =  tsoap_rad_der(k2,counter)  +  multiplicity  *  real(  tcnk_rad_der(k2,k,n)  *  conjg(tcnk(i,k,np))  +  tcnk(i,k,n)  *  conjg(tcnk_rad_der(k2,k,np))  )\n>   tsoap_azi_der(k2,counter)  =  tsoap_azi_der(k2,counter)  +  multiplicity  *  real(  tcnk_azi_der(k2,k,n)  *  conjg(tcnk(i,k,np))  +  tcnk(i,k,n)  *  conjg(tcnk_azi_der(k2,k,np))  )\n>   tsoap_pol_der(k2,counter)  =  tsoap_pol_der(k2,counter)  +  multiplicity  *  real(  tcnk_pol_der(k2,k,n)  *  conjg(tcnk(i,k,np))  +  tcnk(i,k,n)  *  conjg(tcnk_pol_der(k2,k,np))  )\n>   end do\n>  end do\n>  end do\n>  end do\n>  end do\n> \n> ! Before the next part the variables are transposed again to their original layout.\n> \n>   !omp target teams  distribute private(i)\n>   do k2  =  1,  k2_max\n>   i=list_of_i(k2)\n>   locdot=0.d0\n> \n>   !omp parallel do reduction(+:locdot_rad_der,locdot_azi_der,locdot_pol_der)\n>   do is=1,nsoap\n>   locdot_rad_der=locdot_rad_der+soap(is,  i)  *  soap_rad_der(is,  k2)\n>   locdot_azi_der=locdot_azi_der+soap(is,  i)  *  soap_azi_der(is,  k2)\n>   locdot_pol_der=locdot_pol_der+soap(is,  i)  *  soap_pol_der(is,  k2)\n>   enddo\n>   dot_soap_rad_der(k2)=  locdot_rad_der\n>   dot_soap_azi_der(k2)=  locdot_azi_der\n>   dot_soap_pol_der(k2)=  locdot_pol_der\n>   end do\n> \n>   !omp target teams distribute\n>   do k2  =  1,  k2_max\n>   i=list_of_i(k2)\n> \n>   !omp parallel do\n>   do is=1,nsoap\n>   soap_rad_der(is,  k2)  =  soap_rad_der(is,  k2)  /  sqrt_dot_p(i)  -  soap(is,  i)  /  sqrt_dot_p(i)**3  *  dot_soap_rad_der(k2)\n>   soap_azi_der(is,  k2)  =  soap_azi_der(is,  k2)  /  sqrt_dot_p(i)  -  soap(is,  i)  /  sqrt_dot_p(i)**3  *  dot_soap_azi_der(k2)\n>   soap_pol_der(is,  k2)  =  soap_pol_der(is,  k2)  /  sqrt_dot_p(i)  -  soap(is,  i)  /  sqrt_dot_p(i)**3  *  dot_soap_pol_der(k2)\n>   end do\n>  end do\n> \n>   !omp teams distribute private(k3)\n>   do k2  =  1,  k2_max\n>   k3=list_k2k3(k2)\n> \n>   !omp parallel do private (is)\n>   do is=1,n_soap\n>   if(  k3  /=  k2)then\n>   soap_cart_der(1,  is,  k2)  =  dsin(thetas(k2))  *  dcos(phis(k2))  *  soap_rad_der(1:n_soap,  k2)  -  dcos(thetas(k2))  *  dcos(phis(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)  -  dsin(phis(k2))  /  rjs(k2)  *  soap_azi_der(is,  k2)\n>   soap_cart_der(2,  is,  k2)  =  dsin(thetas(k2))  *  dsin(phis(k2))  *  soap_rad_der(1:n_soap,  k2)  -  dcos(thetas(k2))  *  dsin(phis(k2))  /  rjs(k2)  *  soap_pol_der(1:n_soap,  k2)  +  dcos(phis(k2))  /  rjs(k2)  *  soap_azi_der(is,  k2)\n>   soap_cart_der(3,  is,  k2)  =  dcos(thetas(k2))  *  soap_rad_der(is,  k2)  +  dsin(thetas(k2))  /  rjs(k2)  *  soap_pol_der(is,  k2)\n>   end if\n>  end do\n>  end do\n> \n>   !omp teams distribute private(k3)\n>   do i  =  1,  n_sites\n>   k3=list_k3(i)\n> \n>   !omp parallel do private(is, k2)\n>   do is=1,n_soap\n>   do k2=k3+1,k3+n_neigh(i)\n>   soap_cart_der(1,  is,  k3)  =  soap_cart_der(1,  is,  k3)  -  soap_cart_der(1,  is,  k2)\n>   soap_cart_der(2,  is,  k3)  =  soap_cart_der(2,  is,  k3)  -  soap_cart_der(2,  is,  k2)\n>   soap_cart_der(3,  is,  k3)  =  soap_cart_der(3,  is,  k3)  -  soap_cart_der(3,  is,  k2)\n>   end do\n>  end do\n>  end do \n> ```", "```\n    $ module  load  rocm/6.0.3\n    $ hipify-clang  --perl \n    ```", "```\n    $ hipify-perl  program.cu  >  program.cu.hip \n    ```", "```\n    $ hipcc  --offload-arch=gfx90a  -o  program.hip.exe  program.cu.hip \n    ```", "```\n    $ singularity  pull  docker://nvcr.io/nvidia/cuda:11.4.3-devel-ubuntu20.04 \n    ```", "```\n    $ module  load  rocm/6.0.3\n    $ singularity  shell  -B  $PWD,/opt:/opt  cuda_11.4.0-devel-ubuntu20.04.sif \n    ```", "```\n    $ export  PATH=/opt/rocm-6.0.3/bin:$PATH \n    ```", "```\n    $ hipify-clang  program.cu  -o  hip_program.cu.hip  --cuda-path=/usr/local/cuda-11.4  -I  /usr/local/cuda-11.4/include \n    ```", "```\n> $ git  clone  https://github.com/ENCCS/gpu-programming.git\n> $ cd  gpu-programming/content/examples/exercise_hipify\n> $ ls \n> ```", "```\n    $ git  clone  -b  clacc/main  https://github.com/llvm-doe-org/llvm-project.git\n    $ cd  llvm-project\n    $ mkdir  build  &&  cd  build\n    $ cmake  -DCMAKE_INSTALL_PREFIX=../install  \\\n      -DCMAKE_BUILD_TYPE=Release  \\\n      -DLLVM_ENABLE_PROJECTS=\"clang;lld\"  \\\n      -DLLVM_ENABLE_RUNTIMES=openmp  \\\n      -DLLVM_TARGETS_TO_BUILD=\"host;AMDGPU\"  \\\n      -DCMAKE_C_COMPILER=gcc  \\\n      -DCMAKE_CXX_COMPILER=g++  \\\n      ../llvm\n    $ make\n    $ make  install \n    ```", "```\n> $ export  PATH=/scratch/project_465002387/clacc/llvm-project/install/bin:$PATH\n> $ export  LD_LIBRARY_PATH=/scratch/project_465002387/clacc/llvm-project/install/lib:$LD_LIBRARY_PATH \n> ```", "```\n    $ clang  -fopenacc-print=omp  -fopenacc-structured-ref-count-omp=no-ompx-hold  openACC_code.c  >  openMP_code.c \n    ```", "```\n    module load CrayEnv\n    module load PrgEnv-cray\n    module load craype-accel-amd-gfx90a\n    module load rocm/6.0.3\n\n    cc -fopenmp -o executable openMP_code.c \n    ```", "```\n$ git  clone  https://github.com/ENCCS/gpu-programming.git\n$ cd  gpu-programming/content/examples/exercise_clacc\n$ ls \n```", "```\n> $ dpct  program.cu\n> $ cd  dpct_output/\n> $ icpx  -fsycl  program.dp.cpp \n> ```", "```\n    $ module  load  rocm/6.0.3\n    $ hipify-clang  --perl \n    ```", "```\n    $ hipify-perl  program.cu  >  program.cu.hip \n    ```", "```\n    $ hipcc  --offload-arch=gfx90a  -o  program.hip.exe  program.cu.hip \n    ```", "```\n    $ singularity  pull  docker://nvcr.io/nvidia/cuda:11.4.3-devel-ubuntu20.04 \n    ```", "```\n    $ module  load  rocm/6.0.3\n    $ singularity  shell  -B  $PWD,/opt:/opt  cuda_11.4.0-devel-ubuntu20.04.sif \n    ```", "```\n    $ export  PATH=/opt/rocm-6.0.3/bin:$PATH \n    ```", "```\n    $ hipify-clang  program.cu  -o  hip_program.cu.hip  --cuda-path=/usr/local/cuda-11.4  -I  /usr/local/cuda-11.4/include \n    ```", "```\n> $ git  clone  https://github.com/ENCCS/gpu-programming.git\n> $ cd  gpu-programming/content/examples/exercise_hipify\n> $ ls \n> ```", "```\n    $ module  load  rocm/6.0.3\n    $ hipify-clang  --perl \n    ```", "```\n    $ hipify-perl  program.cu  >  program.cu.hip \n    ```", "```\n    $ hipcc  --offload-arch=gfx90a  -o  program.hip.exe  program.cu.hip \n    ```", "```\n    $ singularity  pull  docker://nvcr.io/nvidia/cuda:11.4.3-devel-ubuntu20.04 \n    ```", "```\n    $ module  load  rocm/6.0.3\n    $ singularity  shell  -B  $PWD,/opt:/opt  cuda_11.4.0-devel-ubuntu20.04.sif \n    ```", "```\n    $ export  PATH=/opt/rocm-6.0.3/bin:$PATH \n    ```", "```\n    $ hipify-clang  program.cu  -o  hip_program.cu.hip  --cuda-path=/usr/local/cuda-11.4  -I  /usr/local/cuda-11.4/include \n    ```", "```\n> $ git  clone  https://github.com/ENCCS/gpu-programming.git\n> $ cd  gpu-programming/content/examples/exercise_hipify\n> $ ls \n> ```", "```\n    $ git  clone  -b  clacc/main  https://github.com/llvm-doe-org/llvm-project.git\n    $ cd  llvm-project\n    $ mkdir  build  &&  cd  build\n    $ cmake  -DCMAKE_INSTALL_PREFIX=../install  \\\n      -DCMAKE_BUILD_TYPE=Release  \\\n      -DLLVM_ENABLE_PROJECTS=\"clang;lld\"  \\\n      -DLLVM_ENABLE_RUNTIMES=openmp  \\\n      -DLLVM_TARGETS_TO_BUILD=\"host;AMDGPU\"  \\\n      -DCMAKE_C_COMPILER=gcc  \\\n      -DCMAKE_CXX_COMPILER=g++  \\\n      ../llvm\n    $ make\n    $ make  install \n    ```", "```\n> $ export  PATH=/scratch/project_465002387/clacc/llvm-project/install/bin:$PATH\n> $ export  LD_LIBRARY_PATH=/scratch/project_465002387/clacc/llvm-project/install/lib:$LD_LIBRARY_PATH \n> ```", "```\n    $ clang  -fopenacc-print=omp  -fopenacc-structured-ref-count-omp=no-ompx-hold  openACC_code.c  >  openMP_code.c \n    ```", "```\n    module load CrayEnv\n    module load PrgEnv-cray\n    module load craype-accel-amd-gfx90a\n    module load rocm/6.0.3\n\n    cc -fopenmp -o executable openMP_code.c \n    ```", "```\n$ git  clone  https://github.com/ENCCS/gpu-programming.git\n$ cd  gpu-programming/content/examples/exercise_clacc\n$ ls \n```", "```\n> $ dpct  program.cu\n> $ cd  dpct_output/\n> $ icpx  -fsycl  program.dp.cpp \n> ```"]