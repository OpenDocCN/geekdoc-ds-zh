<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Flags and Targets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Flags and Targets</h1>
<blockquote>原文：<a href="https://en.algorithmica.org/hpc/compilation/flags/">https://en.algorithmica.org/hpc/compilation/flags/</a></blockquote><div id="search"><input id="search-bar" type="search" placeholder="Search this book…" oninput="search()"/><div id="search-count"/><div id="search-results"/></div><header><div class="info"/></header><article><p>The first step of getting high performance from the compiler is to ask for it, which is done with over a hundred different compiler options, attributes, and pragmas.</p><span class="anchor" id="optimization-levels"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/compilation/flags/#optimization-levels">#</a>Optimization Levels</h3><p>There are 4 <em>and a half</em> main levels of optimization for speed in GCC:</p><ul><li><code>-O0</code> is the default one that does no optimizations (although, in a sense, it does optimize: for compilation time).</li><li><code>-O1</code> (also aliased as <code>-O</code>) does a few “low-hanging fruit” optimizations, almost not affecting the compilation time.</li><li><code>-O2</code> enables all optimizations that are known to have little to no negative side effects and take a reasonable time to complete (this is what most projects use for production builds).</li><li><code>-O3</code> does very aggressive optimization, enabling almost all <em>correct</em> optimizations implemented in GCC.</li><li><code>-Ofast</code> does everything in <code>-O3</code>, plus a few more optimizations flags that may break strict standard compliance, but not in a way that would be critical for most applications (e.g., floating-point operations may be rearranged so that the result is off by a few bits in the mantissa).</li></ul><p>There are also many other optimization flags that are not included even in <code>-Ofast</code>, because they are very situational, and enabling them by default is more likely to hurt performance rather than improve it — we will talk about some of them in <a href="../situational">the next section</a>.</p><span class="anchor" id="specifying-targets"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/compilation/flags/#specifying-targets">#</a>Specifying Targets</h3><p>The next thing you may want to do is to tell the compiler more about the computer(s) this code is supposed to be run on: the smaller the set of platforms is, the better. By default, it will generate binaries that can run on any relatively new (&gt;2000) x86 CPU. The simplest way to narrow it down is to pass <code>-march</code> flag to specify the exact microarchitecture: <code>-march=haswell</code>. If you are compiling on the same computer that will run the binary, you can use <code>-march=native</code> for auto-detection.</p><p>The instruction sets are generally backward-compatible, so it is often enough to just use the name of the oldest microarchitecture you need to support. A more robust approach is to list specific features that the CPU is guaranteed to have: <code>-mavx2</code>, <code>-mpopcnt</code>. When you just want to <em>tune</em> the program for a particular machine without using any instructions that may crash it on incompatible CPUs, you can use the <code>-mtune</code> flag (by default <code>-march=x</code> also implies <code>-mtune=x</code>).</p><p>These options can also be specified for a compilation unit with pragmas instead of compilation flags:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#pragma GCC optimize("O3")
</span></span></span><span class="line"><span class="cl"><span class="cp">#pragma GCC target("avx2")
</span></span></span></code></pre></div><p>This is useful when you need to optimize a single high-performance procedure without increasing the build time for the entire project.</p><span class="anchor" id="multiversioned-functions"/><h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/compilation/flags/#multiversioned-functions">#</a>Multiversioned Functions</h3><p>Sometimes you may also want to provide several architecture-specific implementations in a single library. You can use attribute-based syntax to select between multiversioned functions automatically during compile time:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">__attribute__</span><span class="p">((</span> <span class="n">target</span><span class="p">(</span><span class="s">"default"</span><span class="p">)</span> <span class="p">))</span> <span class="c1">// fallback implementation
</span></span></span><span class="line"><span class="cl"><span class="c1"/><span class="kt">int</span> <span class="n">popcnt</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">i</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">__attribute__</span><span class="p">((</span> <span class="n">target</span><span class="p">(</span><span class="s">"popcnt"</span><span class="p">)</span> <span class="p">))</span> <span class="c1">// used if popcnt flag is enabled
</span></span></span><span class="line"><span class="cl"><span class="c1"/><span class="kt">int</span> <span class="n">popcnt</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">__builtin_popcount</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>In Clang, you can’t use pragmas to set target and optimization flags from the source code, but you can use attributes the same way as in GCC.</p></article><div class="nextprev"><div class="left"><a href="https://en.algorithmica.org/hpc/compilation/stages/" id="prev-article">← Stages of Compilation</a></div><div class="right"><a href="https://en.algorithmica.org/hpc/compilation/situational/" id="next-article">Situational Optimizations →</a></div></div>    
</body>
</html>