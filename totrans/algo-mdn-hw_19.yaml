- en: Flags and Targets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标志和目标
- en: 原文：[https://en.algorithmica.org/hpc/compilation/flags/](https://en.algorithmica.org/hpc/compilation/flags/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/compilation/flags/](https://en.algorithmica.org/hpc/compilation/flags/)
- en: The first step of getting high performance from the compiler is to ask for it,
    which is done with over a hundred different compiler options, attributes, and
    pragmas.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从编译器获得高性能的第一步是请求它，这通过超过一百种不同的编译器选项、属性和指令来完成。
- en: '### [#](https://en.algorithmica.org/hpc/compilation/flags/#optimization-levels)Optimization
    Levels'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/compilation/flags/#optimization-levels)
    优化级别'
- en: 'There are 4 *and a half* main levels of optimization for speed in GCC:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: GCC中有4个半主要优化级别用于提高速度：
- en: '`-O0` is the default one that does no optimizations (although, in a sense,
    it does optimize: for compilation time).'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-O0` 是默认选项，它不进行任何优化（尽管从某种意义上说，它确实进行了优化：优化编译时间）。'
- en: '`-O1` (also aliased as `-O`) does a few “low-hanging fruit” optimizations,
    almost not affecting the compilation time.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-O1`（也称为 `-O`）执行一些“低垂的果实”优化，几乎不影响编译时间。'
- en: '`-O2` enables all optimizations that are known to have little to no negative
    side effects and take a reasonable time to complete (this is what most projects
    use for production builds).'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-O2` 启用所有已知具有很少或没有负面影响的优化，并且完成时间合理（这是大多数项目用于生产构建的优化级别）。'
- en: '`-O3` does very aggressive optimization, enabling almost all *correct* optimizations
    implemented in GCC.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-O3` 执行非常激进的优化，几乎启用了GCC中实现的几乎所有*正确*的优化。'
- en: '`-Ofast` does everything in `-O3`, plus a few more optimizations flags that
    may break strict standard compliance, but not in a way that would be critical
    for most applications (e.g., floating-point operations may be rearranged so that
    the result is off by a few bits in the mantissa).'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Ofast` 执行了 `-O3` 所有的操作，并额外包含了一些可能会破坏严格标准兼容性的优化标志，但这种方式不会对大多数应用造成关键性的影响（例如，浮点运算可能会重新排列，导致尾数偏移几个位）。'
- en: There are also many other optimization flags that are not included even in `-Ofast`,
    because they are very situational, and enabling them by default is more likely
    to hurt performance rather than improve it — we will talk about some of them in
    [the next section](../situational).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他优化标志，甚至不在 `-Ofast` 中，因为它们非常特定，默认启用它们更有可能损害性能而不是提高性能——我们将在下一节中讨论其中的一些。
- en: '### [#](https://en.algorithmica.org/hpc/compilation/flags/#specifying-targets)Specifying
    Targets'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/compilation/flags/#specifying-targets)
    指定目标'
- en: 'The next thing you may want to do is to tell the compiler more about the computer(s)
    this code is supposed to be run on: the smaller the set of platforms is, the better.
    By default, it will generate binaries that can run on any relatively new (>2000)
    x86 CPU. The simplest way to narrow it down is to pass `-march` flag to specify
    the exact microarchitecture: `-march=haswell`. If you are compiling on the same
    computer that will run the binary, you can use `-march=native` for auto-detection.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步你可能想要做的是告诉编译器更多关于此代码预期在哪些计算机上运行的信息：平台集合越小，越好。默认情况下，它将生成可以在任何相对较新的（>2000）x86
    CPU上运行的二进制文件。最简单的方法是通过传递 `-march` 标志来指定确切的微架构：`-march=haswell`。如果你在将运行二进制文件的同一台计算机上编译，可以使用
    `-march=native` 进行自动检测。
- en: 'The instruction sets are generally backward-compatible, so it is often enough
    to just use the name of the oldest microarchitecture you need to support. A more
    robust approach is to list specific features that the CPU is guaranteed to have:
    `-mavx2`, `-mpopcnt`. When you just want to *tune* the program for a particular
    machine without using any instructions that may crash it on incompatible CPUs,
    you can use the `-mtune` flag (by default `-march=x` also implies `-mtune=x`).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 指令集通常是向后兼容的，所以通常只需要使用你需要的最老微架构的名称就足够了。一种更稳健的方法是列出CPU保证具有的特定功能：`-mavx2`，`-mpopcnt`。当你只想针对特定机器调整程序，而不使用可能在不兼容CPU上崩溃的指令时，可以使用`-mtune`标志（默认情况下，`-march=x`
    也隐含 `-mtune=x`）。
- en: 'These options can also be specified for a compilation unit with pragmas instead
    of compilation flags:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项也可以通过使用编译器指令（pragmas）而不是编译标志来指定一个编译单元：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is useful when you need to optimize a single high-performance procedure
    without increasing the build time for the entire project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要优化单个高性能过程而不增加整个项目的构建时间时，这很有用。
- en: '### [#](https://en.algorithmica.org/hpc/compilation/flags/#multiversioned-functions)Multiversioned
    Functions'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/compilation/flags/#multiversioned-functions)
    多版本函数'
- en: 'Sometimes you may also want to provide several architecture-specific implementations
    in a single library. You can use attribute-based syntax to select between multiversioned
    functions automatically during compile time:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能也希望在单个库中提供几个特定架构的实现。你可以使用基于属性的语法在编译时自动选择多版本函数：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In Clang, you can’t use pragmas to set target and optimization flags from the
    source code, but you can use attributes the same way as in GCC. [← Stages of Compilation](https://en.algorithmica.org/hpc/compilation/stages/)[Situational
    Optimizations →](https://en.algorithmica.org/hpc/compilation/situational/)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clang中，你不能使用预处理指令从源代码中设置目标和优化标志，但你可以使用属性，就像在GCC中一样。[← 编译阶段](https://en.algorithmica.org/hpc/compilation/stages/)[情境优化
    →](https://en.algorithmica.org/hpc/compilation/situational/)
