- en: Flags and Targets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://en.algorithmica.org/hpc/compilation/flags/](https://en.algorithmica.org/hpc/compilation/flags/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The first step of getting high performance from the compiler is to ask for it,
    which is done with over a hundred different compiler options, attributes, and
    pragmas.
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/compilation/flags/#optimization-levels)Optimization
    Levels'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are 4 *and a half* main levels of optimization for speed in GCC:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-O0` is the default one that does no optimizations (although, in a sense,
    it does optimize: for compilation time).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-O1` (also aliased as `-O`) does a few “low-hanging fruit” optimizations,
    almost not affecting the compilation time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-O2` enables all optimizations that are known to have little to no negative
    side effects and take a reasonable time to complete (this is what most projects
    use for production builds).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-O3` does very aggressive optimization, enabling almost all *correct* optimizations
    implemented in GCC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Ofast` does everything in `-O3`, plus a few more optimizations flags that
    may break strict standard compliance, but not in a way that would be critical
    for most applications (e.g., floating-point operations may be rearranged so that
    the result is off by a few bits in the mantissa).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also many other optimization flags that are not included even in `-Ofast`,
    because they are very situational, and enabling them by default is more likely
    to hurt performance rather than improve it — we will talk about some of them in
    [the next section](../situational).
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/compilation/flags/#specifying-targets)Specifying
    Targets'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing you may want to do is to tell the compiler more about the computer(s)
    this code is supposed to be run on: the smaller the set of platforms is, the better.
    By default, it will generate binaries that can run on any relatively new (>2000)
    x86 CPU. The simplest way to narrow it down is to pass `-march` flag to specify
    the exact microarchitecture: `-march=haswell`. If you are compiling on the same
    computer that will run the binary, you can use `-march=native` for auto-detection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The instruction sets are generally backward-compatible, so it is often enough
    to just use the name of the oldest microarchitecture you need to support. A more
    robust approach is to list specific features that the CPU is guaranteed to have:
    `-mavx2`, `-mpopcnt`. When you just want to *tune* the program for a particular
    machine without using any instructions that may crash it on incompatible CPUs,
    you can use the `-mtune` flag (by default `-march=x` also implies `-mtune=x`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'These options can also be specified for a compilation unit with pragmas instead
    of compilation flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is useful when you need to optimize a single high-performance procedure
    without increasing the build time for the entire project.
  prefs: []
  type: TYPE_NORMAL
- en: '### [#](https://en.algorithmica.org/hpc/compilation/flags/#multiversioned-functions)Multiversioned
    Functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you may also want to provide several architecture-specific implementations
    in a single library. You can use attribute-based syntax to select between multiversioned
    functions automatically during compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In Clang, you can’t use pragmas to set target and optimization flags from the
    source code, but you can use attributes the same way as in GCC. [← Stages of Compilation](https://en.algorithmica.org/hpc/compilation/stages/)[Situational
    Optimizations →](https://en.algorithmica.org/hpc/compilation/situational/)
  prefs: []
  type: TYPE_NORMAL
