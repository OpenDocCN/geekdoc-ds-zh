["```py\nground_n = np.array([0.1, 1.0])     # normal of the slope\nground_n /= np.linalg.norm(ground_n)    # normalize ground normal vector just in case\nground_o = np.array([0.0, -1.0])    # a point on the slope \n```", "```py\nimport math\nimport numpy as np\n\ndhat = 0.01\nkappa = 1e5\n\ndef val(x, n, o, contact_area):\n    sum = 0.0\n    for i in range(0, len(x)):\n        d = n.dot(x[i] - o)\n        if d < dhat:\n            s = d / dhat\n            sum += contact_area[i] * dhat * kappa / 2 * (s - 1) * math.log(s)\n    return sum\n\ndef grad(x, n, o, contact_area):\n    g = np.array([[0.0, 0.0]] * len(x))\n    for i in range(0, len(x)):\n        d = n.dot(x[i] - o)\n        if d < dhat:\n            s = d / dhat\n            g[i] = contact_area[i] * dhat * (kappa / 2 * (math.log(s) / dhat + (s - 1) / d)) * n\n    return g\n\ndef hess(x, n, o, contact_area):\n    IJV = [[0] * 0, [0] * 0, np.array([0.0] * 0)]\n    for i in range(0, len(x)):\n        d = n.dot(x[i] - o)\n        if d < dhat:\n            local_hess = contact_area[i] * dhat * kappa / (2 * d * d * dhat) * (d + dhat) * np.outer(n, n)\n            for c in range(0, 2):\n                for r in range(0, 2):\n                    IJV[0].append(i * 2 + r)\n                    IJV[1].append(i * 2 + c)\n                    IJV[2] = np.append(IJV[2], local_hess[r, c])\n    return IJV \n```", "```py\ndef init_step_size(x, n, o, p):\n    alpha = 1\n    for i in range(0, len(x)):\n        p_n = p[i].dot(n)\n        if p_n < 0:\n            alpha = min(alpha, 0.9 * n.dot(x[i] - o) / -p_n)\n    return alpha \n```", "```py\n pygame.draw.aaline(screen, (0, 0, 255), screen_projection([ground_o[0] - 3.0 * ground_n[1], ground_o[1] + 3.0 * ground_n[0]]), \n        screen_projection([ground_o[0] + 3.0 * ground_n[1], ground_o[1] - 3.0 * ground_n[0]]))   # slope \n```"]