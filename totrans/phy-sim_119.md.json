["```py\ndouble getSmallestPositiveRealRoot_cubic(double a, double b, double c, double d,\n    double tol)\n{\n    // return negative value if no positive real root is found\n    double t = -1;\n\n    if (abs(a) <= tol)\n        t = getSmallestPositiveRealRoot_quad(b, c, d, tol); // covered in the 2D case\n    else {\n        complex<double> i(0, 1);\n        complex<double> delta0(b * b - 3 * a * c, 0);\n        complex<double> delta1(2 * b * b * b - 9 * a * b * c + 27 * a * a * d, 0);\n        complex<double> C = pow((delta1 + sqrt(delta1 * delta1 - 4.0 * delta0 * delta0 * delta0)) / 2.0, 1.0 / 3.0);\n        if (std::abs(C) == 0.0) // a corner case\n            C = pow((delta1 - sqrt(delta1 * delta1 - 4.0 * delta0 * delta0 * delta0)) / 2.0, 1.0 / 3.0);\n\n        complex<double> u2 = (-1.0 + sqrt(3.0) * i) / 2.0;\n        complex<double> u3 = (-1.0 - sqrt(3.0) * i) / 2.0;\n\n        complex<double> t1 = (b + C + delta0 / C) / (-3.0 * a);\n        complex<double> t2 = (b + u2 * C + delta0 / (u2 * C)) / (-3.0 * a);\n        complex<double> t3 = (b + u3 * C + delta0 / (u3 * C)) / (-3.0 * a);\n\n        if ((abs(imag(t1)) < tol) && (real(t1) > 0))\n            t = real(t1);\n        if ((abs(imag(t2)) < tol) && (real(t2) > 0) && ((real(t2) < t) || (t < 0)))\n            t = real(t2);\n        if ((abs(imag(t3)) < tol) && (real(t3) > 0) && ((real(t3) < t) || (t < 0)))\n            t = real(t3);\n    }\n    return t;\n} \n```"]