- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PLOTTING AND MORE ABOUT CLASSES
  prefs: []
  type: TYPE_NORMAL
- en: Often text is the best way to communicate information, but sometimes there is
    a lot of truth to the Chinese proverb, 圖片的意義可以表達近萬字. Yet most programs rely on
    textual output to communicate with their users. Why? Because in many programming
    languages, presenting visual data is too hard. Fortunately, it is simple to do
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1 Plotting Using Matplotlib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Matplotlib** is a Python library module that provides **plotting** facilities
    very much like those in MATLAB, “a high-level technical computing language and
    interactive environment for algorithm development, data visualization, data analysis,
    and numeric computation.” [^(80)](#c13-fn-0001) Later in the book we will look
    other Python libraries that provide other MATLAB-like capabilities. In this chapter,
    we focus on some simple ways of plotting data. A complete user''s guide to the
    plotting capabilities of Matplotlib is at the website'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will not try to provide a user's guide or a complete tutorial here. Instead,
    in this chapter we will merely provide a few example plots and explain the code
    that generated them. We introduce many other plotting features in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a simple example that uses `plt.plot` to produce a single plot.
    Executing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: will produce a plot similar to, but not identical to, the one in [Figure 13-1](#c13-fig-0001).
    Your plot will probably have a colored line.[^(81)](#c13-fn-0002) Also, if you
    run this code with the default parameter settings of most installations of Matplotlib,
    the line will probably not be as thick as the line in [Figure 13-1](#c13-fig-0001).
    We have used nonstandard default values for line width and font sizes so that
    the figures will reproduce better in black and white. We discuss how this is done
    later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Where the plot appears on your monitor depends upon the Python environment you
    are using. In the version of Spyder used to produce this edition of this book,
    it appears, by default, in something called the “Plots pane.”
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0001.jpg](../images/c13-fig-0001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-1](#c13-fig-0001a) A simple plot'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to produce multiple **figures** and to write them to files. These
    files can have any name you like. By default, they will all have the file extension
    `.png`, but you can change this to other formats (e.g., `.jpg`) using the keyword
    parameter `format`.
  prefs: []
  type: TYPE_NORMAL
- en: The code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: produces and saves to files named `Figure-Jane.png` and `Figure-Addie.png` the
    two plots in [Figure 13-2](#c13-fig-0002).
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0002.jpg](../images/c13-fig-0002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-2](#c13-fig-0002a) Contents of Figure-Jane.png (left) and Figure-Addie.png
    (right)'
  prefs: []
  type: TYPE_NORMAL
- en: Observe that the last call to `plt.plot` is passed only one argument. This argument
    supplies the `y` values. The corresponding `x` values default to the sequence
    yielded by `range(len([5, 6, 10, 3]))`, which is why they range from `0` to `3`
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib has a notion of **current figure**. Executing `plt.figure(x)` sets
    the current figure to the figure numbered `x`. Subsequently executed calls of
    plotting functions implicitly refer to that figure until another invocation of
    `plt.figure` occurs. This explains why the figure written to the file `Figure-Addie.png`
    was the second figure created.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at another example. The code on the left side of [Figure 13-3](#c13-fig-0003)
    produces the plot on the left in [Figure 13-4](#c13-fig-0004).
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0003.jpg](../images/c13-fig-0003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-3](#c13-fig-0003a) Produce plots showing compound growth'
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0004.jpg](../images/c13-fig-0004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-4](#c13-fig-0004a) Plots showing compound growth'
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the code, we can deduce that this is a plot showing the growth
    of an initial investment of `$10,000` at an annually compounded interest rate
    of `5%`. However, this cannot be easily inferred by looking only at the plot itself.
    That's a bad thing. All plots should have informative titles, and all axes should
    be labeled. If we add to the end of our code the lines on the right of [Figure
    13-3](#c13-fig-0003), we get the plot on the right in [Figure 13-4](#c13-fig-0004).
  prefs: []
  type: TYPE_NORMAL
- en: For every plotted curve, there is an optional argument that is a format string
    indicating the color and line type of the plot. The letters and symbols of the
    format string are derived from those used in MATLAB and are composed of a color
    indicator followed by an optional line-style indicator. The default format string
    is `'b-'`, which produces a solid blue line. To plot the growth in principal with
    black circles, replace the call `plt.plot(values)` by `plt.plot(values, 'ko')`,
    which produces the plot in [Figure 13-5](#c13-fig-0005). For a complete list of
    color and line-style indicators, see
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![c13-fig-0005.jpg](../images/c13-fig-0005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-5](#c13-fig-0005a) Another plot of compound growth'
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to change the type size and line width used in plots. This
    can be done using keyword arguments in individual calls to functions. For example,
    the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: produces the intentionally bizarre-looking plot in [Figure 13-6](#c13-fig-0006).
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0006.jpg](../images/c13-fig-0006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-6](#c13-fig-0006a) Strange-looking plot'
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to change the default values, which are known as “rc settings.”
    (The name “rc” is derived from the `.rc` file extension used for runtime configuration
    files in Unix.) These values are stored in a dictionary-like variable that can
    be accessed via the name `plt.rcParams`. So, for example, you can set the default
    line width to 6 points[^(82)](#c13-fn-0003) by executing the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are an enormous number of `rcParams` settings. A complete list can be
    found at
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you don't want to worry about customizing individual parameters, there are
    pre-defined style sheets. A description of these can be found at
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The values used in most of the remaining examples in this book were set with
    the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you are viewing plots on a color display, you will have little reason to
    change the default settings. We customized the settings so that it would be easier
    to read the plots when we shrank them to fit on the page and converted them to
    grayscale.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2 Plotting Mortgages, an Extended Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter 10, we worked our way through a hierarchy of mortgages as a way of
    illustrating the use of subclassing. We concluded that chapter by observing that
    “our program should be producing plots designed to show how the mortgage behaves
    over time.” [Figure 13-7](#c13-fig-0007) enhances class `Mortgage` by adding methods
    that make it convenient to produce such plots. (The function `find_payment`, which
    appears in Figure 10-10, is discussed in Section 10.4.)
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0007.jpg](../images/c13-fig-0007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-7](#c13-fig-0007a) Class `Mortgage` with plotting methods'
  prefs: []
  type: TYPE_NORMAL
- en: The nontrivial methods in class `Mortgage` are `plot_tot_paid` and `plot_net`.
    The method `plot_tot_paid` plots the cumulative total of the payments made. The
    method `plot_net` plots an approximation to the total cost of the mortgage over
    time by plotting the cash expended minus the equity acquired by paying off part
    of the loan.[^(83)](#c13-fn-0004)
  prefs: []
  type: TYPE_NORMAL
- en: "The expression `np.array(self.outstanding)` in the function `plot_net` performs\
    \ a type conversion. Thus far, we have been calling the plotting functions of\
    \ Matplotlib with arguments of type `list`. Under the covers, Matplotlib has been\
    \ converting these lists into a different type, `**array**`, which is part of\
    \ the `numpy` module. The importation `\uFEFFimport numpy as np` and the invocation\
    \ `np.array` makes this explicit."
  prefs: []
  type: TYPE_NORMAL
- en: '`**Numpy**` is a Python module that provides tools for scientific computing.
    In addition to providing multi‑dimensional arrays, it provides a variety of mathematical
    capabilities. We will see more of `numpy` later in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many convenient ways to manipulate arrays that are not readily available
    for lists. In particular, expressions can be formed using arrays and arithmetic
    operators. There are a number of ways to create arrays in `numpy`, but the most
    common one is to first create a list, and then convert it. Consider the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The expression `a1*2` multiplies each element of `a1` by the constant `2`. The
    expression `a1 + 3` adds the integer `3` to each element of `a1`. The expression
    `a1 ‑ a2` subtracts each element of `a2` from the corresponding element of `a1`
    (If the arrays had been of different length, an error would have occurred.) The
    expression `a1*a2` multiplies each element of `a1` by the corresponding element
    of `a2`. When the above code is run it prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 13-8](#c13-fig-0008) repeats the three subclasses of `Mortgage` from
    Figure 10-11\. Each has a distinct `__init__` method that overrides the `__init__`
    method in `Mortgage`. The subclass `Two_rate` also overrides the `make_payment`
    method of `Mortgage`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0008.jpg](../images/c13-fig-0008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-8](#c13-fig-0008a) Subclasses of `Mortgage`'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-9](#c13-fig-0009) and [Figure 13-10](#c13-fig-0010) contain functions
    `that` can be used to generate plots intended to provide insight about different
    kinds of mortgages.'
  prefs: []
  type: TYPE_NORMAL
- en: The function `compare_mortgages,` [Figure 13-9](#c13-fig-0009), creates a list
    of different kinds of mortgages and simulates making a series of payments on each.
    It then calls `plot_mortgages,` [Figure 13-10](#c13-fig-0010), to produce the
    plots.
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0009.jpg](../images/c13-fig-0009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-9](#c13-fig-0009a) Compare mortgages'
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0010.jpg](../images/c13-fig-0010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-10](#c13-fig-0010a) Generate mortgage plots'
  prefs: []
  type: TYPE_NORMAL
- en: The function `plot_mortgages` in [Figure 13-10](#c13-fig-0010)uses the plotting
    methods in `Mortgage` to produce plots containing information about each of three
    kinds of mortgages. The loop in `plot_mortgages` uses the index `i` to select
    elements from the lists `morts` and `styles` so that different kinds of mortgages
    are represented in a consistent way across figures. For example, since the third
    element in `morts` is a variable-rate mortgage and the third element in `styles`
    is `'k:'`, the variable-rate mortgage is always plotted using a black dotted line.
    The local function `label_plot` is used to generate appropriate titles and axis
    labels for each plot. The calls of `plt.figure` ensure that titles and labels
    are associated with the appropriate plot.
  prefs: []
  type: TYPE_NORMAL
- en: The call
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: produces plots ([Figure 13-11 through 13-13](#c13-fig-0011)) that compare three
    kinds of mortgages.
  prefs: []
  type: TYPE_NORMAL
- en: The plot shown in [Figure 13-11](#c13-fig-0011), which was produced by invocations
    of `plot_payments`, simply plots each payment of each mortgage against time. The
    box containing the key appears where it does because of the value supplied to
    the keyword argument `loc` used in the call to `plt.legend`. When `loc` is bound
    to `'best',` the location is chosen automatically. This plot makes it clear how
    the monthly payments vary (or don't) over time but doesn't shed much light on
    the relative costs of each kind of mortgage.
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0011.jpg](../images/c13-fig-0011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-11](#c13-fig-0011a) Monthly payments of different kinds of mortgages'
  prefs: []
  type: TYPE_NORMAL
- en: The plot in [Figure 13-12](#c13-fig-0012) was produced by invocations of `plot_tot_pd`.
    It compares the cost of each kind of mortgage by plotting the cumulative costs
    that have been incurred at the start of each month.
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0012.jpg](../images/c13-fig-0012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-12](#c13-fig-0012a) Cost over time of different kinds of mortgages'
  prefs: []
  type: TYPE_NORMAL
- en: The plots in [Figure 13-13](#c13-fig-0013) show the remaining debt (on the left)
    and the total net cost of having the mortgage (on the right).
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0013.jpg](../images/c13-fig-0013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-13](#c13-fig-0013a) Balance remaining and net cost for different
    kinds of mortgages'
  prefs: []
  type: TYPE_NORMAL
- en: 13.3 An Interactive Plot for an Infectious Disease
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I put the final touches on this book, I am at home following “social distancing”
    restrictions related to restricting the spread of the Covid-19 disease. Like many
    respiratory viruses, the SARS-CoV-2 virus is spread primarily by human-to-human
    contact. Social distancing is designed to reduce contacts between humans, and
    thus limit the spread of the disease caused by the virus.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-14](#c13-fig-0014) contains a simplistic simulation of incidence
    of an infectious disease over time. The parameter `fixed` is a dictionary defining
    the initial values for key variables related to the spread of infections. The
    parameter `variable` is a dictionary defining variables related to social distancing.
    Later, we show how the value of `variable` can be changed in an interactive plot.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0014.jpg](../images/c13-fig-0014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-14](#c13-fig-0014a) Simulation of spread of an infectious disease'
  prefs: []
  type: TYPE_NORMAL
- en: Later in the book, we talk in detail about simulation models. Here, however,
    we are focused on interactive plotting, and the purpose of the simulation is to
    provide us with something interesting to plot. If you don't understand the details
    of the simulation, that's okay.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-15](#c13-fig-0015) contains a function that produces a static plot
    showing the number of infected people on each day. It also contains a **text box**
    showing the total number of infected people. The statement starting with `txt_box
    = plt.text` instructs Python to start the text specified by the third argument
    of `plt.text` at a location specified by the first two arguments. The expression
    `plt.xlim()[1]/2` places the left edge of the text halfway between the left end
    of the x-axis (0 for this plot) and the right end of the x-axis. The expression
    `plt.ylim()[1]/1.25` places the text 80% of the way from the bottom of the y-axis
    (0 on this plot) to the top of the y-axis.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0015.jpg](../images/c13-fig-0015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-15](#c13-fig-0015a) Function to plot history of infection'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-16](#c13-fig-0016) uses the functions in [Figure 13-14](#c13-fig-0014)
    and [Figure 13-15](#c13-fig-0015) to produce a plot, [Figure 13-17](#c13-fig-0017),
    showing the number of infected people—assuming no social distancing. The values
    in `fixed` are not based on a specific disease. It might seem surprising to assume
    that on average an individual comes into “contact” with 50 people a day. Keep
    in mind, however, that this number includes indirect contact, e.g., riding on
    the same bus as an infected person or touching an object that might have had a
    pathogen deposited on it by an infected person.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0016.jpg](../images/c13-fig-0016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-16](#c13-fig-0016a) Produce plot with a single set of parameters'
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0017.jpg](../images/c13-fig-0017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-17](#c13-fig-0017a) Static plot of number of infections'
  prefs: []
  type: TYPE_NORMAL
- en: "The plot shows a rapid rise in the number of current infections, followed by\
    \ a rapid decline to a stable state of zero current infections. The rapid growth\
    \ occurs because each infected person infects multiple other people, so the number\
    \ of people capable of spreading the infection grows exponentially. The steady\
    \ state of no new infections occurs because the population has achieved **herd\
    \ immunity**. When a sufficiently large fraction of a population is immune to\
    \ a disease (and we are assuming that people who have recovered from this disease\
    \ cannot get it again), there are long periods when nobody contracts the disease,\
    \ which eventually leads to there being nobody left to spread it.[^(84)](#c13-fn-0005)\
    \ If we want to explore the impact of different parameter settings, we could change\
    \ the values of some of the variables in `fixed`, and produce another plot. That,\
    \ however, is a rather cumbersome way to explore “what if” scenarios. Instead,\
    \ let's produce a figure that contains **sliders**[^(85)](#c13-fn-0006) that can\
    \ be used to dynamically alter the key parameters related to social distancing:\
    \ \uFEFF`reduced_contacts_per_day`, `\uFEFFred_start`, and `red_end`."
  prefs: []
  type: TYPE_NORMAL
- en: 'The figure will have four independent components: the main plot and one slider
    for each of the elements of the dictionary `variable`. We start by describing
    the layout of the figure by specifying its overall dimensions (12 inches wide
    and 8.5 inches high), the location (specified in the same way as for a text box),
    and dimensions (relative to the size of the entire figure) of each component.
    We also bind a name to each of these components, so that we can refer to them
    later.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The next lines of code define three sliders, one for each value we want to vary.
    First, we import a module that contains a class `Slider`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create three sliders, binding each to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next, we provide a function, `update`, that updates the plot based upon the
    current values of the sliders.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to instruct Python to call `update` whenever the value of a slider
    is changed. This is a bit tricky. The `Slider` class contains a method, `on_changed`,
    which takes an argument of type `function` that is invoked whenever the slider
    is changed. This function always takes exactly one argument, a number representing
    the current value of the slider. In our case, however, each time a slider is changed
    we want to run the simulation using the values of all three sliders and the values
    the dictionary `fixed`.
  prefs: []
  type: TYPE_NORMAL
- en: We solve the problem by introducing a new function that is a suitable argument
    for `on_changed`. The function `slider_update` takes the mandated numeric argument,
    but it doesn't use it. Instead, the lambda expression defining `slider_update`
    captures the objects to which `fixed`, `infection_plot`, `txt_box`, and the three
    sliders are bound. It then calls `update` with these arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we plot the curve of infections and update the text box in the portion
    of the figure bound to `infections_ax`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When this code is run, it produces the plot in [Figure 13-18](#c13-fig-0018).[^(86)](#c13-fn-0007)
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0018.jpg](../images/c13-fig-0018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-18](#c13-fig-0018a) Interactive plot with initial slider values'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can easily experiment with many combinations of slider values, one of
    which is shown in [Figure 13-19](#c13-fig-0019).
  prefs: []
  type: TYPE_NORMAL
- en: '![c13-fig-0019.jpg](../images/c13-fig-0019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 13-19](#c13-fig-0019a) Interactive plot with changed slider values'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-19](#c13-fig-0019) shows that if contacts are reduced to an average
    of 25 a day after 20 days and held at the level for 40 weeks, the total number
    of infections is reduced. More significantly, the peak number of infections (and
    therefore the maximum burden on the healthcare system) is dramatically reduced.
    This is frequently referred to as **flattening the curve**.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.4 Terms Introduced in Chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: plot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matplotlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: figure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: current figure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: rcParams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: numpy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: interactive plot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: text box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: herd immunity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: slider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: flattening the curve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
