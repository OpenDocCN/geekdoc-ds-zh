<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>19Â State and EqualityğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>19Â State and EqualityğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/state-in-pyret.html">https://dcic-world.org/2025-08-27/state-in-pyret.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._boxes%29" class="toclink" data-pltdoc="x">19.1<span class="hspace">Â </span>Boxes: A Canonical Mutable Structure</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Mutation_and_.Types%29" class="toclink" data-pltdoc="x">19.2<span class="hspace">Â </span>Mutation and Types</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Mutation_and_.Equality%29" class="toclink" data-pltdoc="x">19.3<span class="hspace">Â </span>Mutation and Equality</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Another_.Equality_.Predicate%29" class="toclink" data-pltdoc="x">19.4<span class="hspace">Â </span>Another Equality Predicate</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._equality-hierarchy%29" class="toclink" data-pltdoc="x">19.5<span class="hspace">Â </span>A Hierarchy of Equality</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Space_and_.Time_.Complexity%29" class="toclink" data-pltdoc="x">19.6<span class="hspace">Â </span>Space and Time Complexity</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._sem-identical%29" class="toclink" data-pltdoc="x">19.7<span class="hspace">Â </span>What it Means to be Identical</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._comp-func%29" class="toclink" data-pltdoc="x">19.8<span class="hspace">Â </span>Comparing Functions</a></p></td></tr></table><p>In <a href="mutating-structures.html" data-pltdoc="x">Mutating Structures</a>, we introduced the notion of mutable
data. We also saw the impact it has on testing. Underlying testing is
some notion of <span class="emph">equality</span>: when we write a test in Pyret using
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span>, we are implicitly making a statement about equality between
the two sides. Here we will examine equality in the presence of state
in more detail.</p><section class="SsectionLevel3" id="section 19.1"><h3 class="heading">19.1<span class="stt">Â </span><a name="(part._boxes)"/>Boxes: A Canonical Mutable Structure<span class="button-group"><a href="#(part._boxes)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">In <a href="mutating-structures.html" data-pltdoc="x">Mutating Structures</a> we saw a motivating example using bank
accounts. To focus our study of equality, it can be convenient to have
an even simpler mutable data structure, called a <span style="font-style: italic">box</span> (which you
will find in other programming languages as well). A box has only one
fieldâ€”<wbr/>the value being boxedâ€”<wbr/>and supports just three operations:
</div><div class="SIntrapara"><ol><li><p><span class="stt">box</span> consumes a value and creates a mutable box
containing that value.</p></li><li><p><span class="stt">unbox-now</span> consumes a box and returns the value contained in
the box.</p></li><li><p><span class="stt">set-box-now</span> consumes a box, a new value, and <span class="emph">changes</span>
the box to contain the value. All subsequent <span class="stt">unbox-now</span>s of that
box will now return the new valueâ€”<wbr/>unless it is mutated again.</p></li></ol></div><div class="SIntrapara">Here are the corresponding definitions in Pyret:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Box&lt;T&gt;:
  | box(ref v :: T)
end

fun unbox-now&lt;T&gt;(b :: Box&lt;T&gt;) -&gt; T:
  b!v
end

fun set-box-now&lt;T&gt;(b :: Box&lt;T&gt;, new-v :: T) -&gt; Box&lt;T&gt;:
  b!{v: new-v}
end</code></pre></div></div></div><div class="SIntrapara">Observe that we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b!v</code></span> to extract the current value, and use
the naming convention of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-now</code></span> to make clear these are stateful
operations, so the value now may not be the same as the value later.</div></section><section class="SsectionLevel3" id="section 19.2"><h3 class="heading">19.2<span class="stt">Â </span><a name="(part._.Mutation_and_.Types)"/>Mutation and Types<span class="button-group"><a href="#(part._.Mutation_and_.Types)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>In terms of types, whenever we replace the value in a box, we want it
to be type-consistent with what was previously there. Otherwise it
would be very difficult to program against a box, because the type of
its content would keep changing.</p><p/><div class="SIntrapara">These definitions obey the following tests:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  n1 = box(1)
  n2 = box(2)
  set-box-now(n1, 3)
  set-box-now(n2, 4)
  unbox-now(n1) is 3
  unbox-now(n2) is 4
end</code></pre></div></div></div><div class="SIntrapara">However, we cannot write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">set-box-now(n1, "hi")</code></span>, because that
would violate the type of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n1</code></span>, which is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Box&lt;Number&gt;</code></span>. We
could make this explicit by writing
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n1 :: Box&lt;Number&gt; = box(1)</code></pre></div></div></div><div class="SIntrapara">if we wanted to be explicit. However, note that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n1</code></span> being a box
of numbers does not preclude us from having a box of strings:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n3 :: Box&lt;String&gt; = box("hello")</code></pre></div></div></div><div class="SIntrapara">or indeed a box of any other type. We just need its type to remain
<span class="emph">consistent</span>, whatever that type is.</div><p>This is a general rule we want to follow with mutable data: the new
value must be the same type as the old value. This gives programs a
consistent interface to program against. For instance, above, we know
that we can always perform numeric operations against the value
extracted from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n1</code></span>â€”<wbr/>there is no danger that it will suddenly
produce a string. This discipline can either be enforced by a system
of annotations, or has to be manually maintained by the programmer.</p></section><section class="SsectionLevel3" id="section 19.3"><h3 class="heading">19.3<span class="stt">Â </span><a name="(part._.Mutation_and_.Equality)"/>Mutation and Equality<span class="button-group"><a href="#(part._.Mutation_and_.Equality)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Weâ€™ve already seen [<a href="Sharing_and_Equality.html#%28part._identical-eq%29" data-pltdoc="x">Re-Examining Equality</a>] that equality is
subtle. Itâ€™s about to become much subtler with the introduction of
mutation!</p><p/><div class="SIntrapara">As a running example, weâ€™ll work with:
</div><div class="SIntrapara"><a name="(elem._three-boxes)"/>&lt;<span style="font-style: italic">three-boxes</span>&gt; ::=</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â </span><span class="stt">b1 = box(7)</span></p></td></tr><tr><td><p><span class="hspace">Â Â </span><span class="stt">b2 = box(7)</span></p></td></tr><tr><td><p><span class="hspace">Â Â </span><span class="stt">b3 = b1</span></p></td></tr></table></div><div class="SIntrapara">Observe that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b3</code></span> are referring to the <span class="emph">same</span>
box, while <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b2</code></span> is referring to a different one. We can see this
from a memory diagram:</div><div class="HeapExpr"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">b1</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1001</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">b2</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1002</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">b3</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1001</span></div></li></ul></div><div class="HeapPart"><p>Heap</p><ul><li><p><span class="heapref source">1001</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">box(7)</code></span></p></li><li><p><span class="heapref source">1002</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">box(7)</code></span></p></li></ul></div><p/><div class="clear"/></div><p/><div class="SIntrapara">We can confirm this using the following tests:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  b1 is-not%(identical) b2
  b1 is%(identical) b3
  b2 is-not%(identical) b3
end</code></pre></div></div></div><div class="SIntrapara">In other words, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b3</code></span> are aliases for the same box,
but neither is an alias to the box referred to by <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b2</code></span>. Since
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> is <span style="font-style: italic">transitive</span>, it follows from the first two
tests that the third test must also pass (and thankfully, Pyret
confirms this for us!).</div><p>Now, you might wonder why we have used <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> and not
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> [<a href="Sharing_and_Equality.html#%28part._equal-always%29" data-pltdoc="x">Notations for Equality</a>], i.e., plain old
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Letâ€™s try that:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  b1 is b3
  b1 is b2
end</code></pre></div></div></div><div class="SIntrapara">What do you see?</div></blockquote></blockquote><p/><div class="SIntrapara">Itâ€™s unsurprising that the first test, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1 is b3</code></span>,
passes. However, the second, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1 is b2</code></span>, fails! And the name
suggests why: the two are not guaranteed to <span class="emph">always</span> be
equal. That is, suppose we were to modify the box referred to by
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">set-box-now(b1, 8)</code></pre></div></div></div><div class="SIntrapara">Sure enough, the values in the boxes are not the same, but because
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b3</code></span> are aliases, their values change in lock-step
(more accurately, there is only one valueâ€”<wbr/>the box at <span class="heapref sink">1001</span>):
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  unbox-now(b1) is-not unbox-now(b2)
  unbox-now(b1) is unbox-now(b3)
end</code></pre></div></div></div></section><section class="SsectionLevel3" id="section 19.4"><h3 class="heading">19.4<span class="stt">Â </span><a name="(part._.Another_.Equality_.Predicate)"/>Another Equality Predicate<span class="button-group"><a href="#(part._.Another_.Equality_.Predicate)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Suppose we return to the state where we have defined the three boxes
[<a href="#%28elem._three-boxes%29" data-pltdoc="x">&lt;<span style="font-style: italic">three-boxes</span>&gt;</a>] but not mutated <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1</code></span>. That is, when
<span class="emph">printed</span>, all three boxes have the same value, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">box(7)</code></span>. We
have seen that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b3</code></span> are <span class="emph">both</span>
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> to each other. However, we
have also seen that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b2</code></span> are <span class="emph">neither</span> of
those. This is somewhat frustrating, because there is clearly some
sense in which they are â€œequalâ€: at the moment, they contain the
same value, even if later on one of them might not.</p><p/><div class="SIntrapara">Therefore, Pyret offers a <span class="emph">third</span> equality predicate that is
designed for just these situations: it is (as you might guess) called
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  b1 is%(equal-now) b2
  b2 is%(equal-now) b3
end</code></pre></div></div></div><div class="SIntrapara">The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-now</code></span> in the name reminds us that these values are equal at
the moment, but may not be equal later. Sure enough, if we add
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">set-box-now(b1, 8)</code></pre></div></div></div><div class="SIntrapara">back into the program, the above <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span> tests fail: now,
they are no longer equal!</div><p/><div class="SIntrapara">Recall that the other two equality predicates have an binary operator
notation: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span> for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;=&gt;</code></span> for
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>. Similarly, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span> has the binary operator
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=~</code></span>. You should view that as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=</code></span> with hand-waving <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">~</code></span>:
itâ€™s equal for now, but donâ€™t expect it to remain so. That is, we can
rewrite the above tests as:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  equal-now(b1, b2) is true
  (b2 =~ b3) is true
end</code></pre></div></div></div><div class="SIntrapara">Whether they pass, of course, depends on the state of the program:
whether <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b2</code></span>, or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b3</code></span> has had its content modified.</div></section><section class="SsectionLevel3" id="section 19.5"><h3 class="heading">19.5<span class="stt">Â </span><a name="(part._equality-hierarchy)"/>A Hierarchy of Equality<span class="button-group"><a href="#(part._equality-hierarchy)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>As you might guess, the equality operators have a hierarchy of
implication. That is, if one operator is true of two expressions, the
other necessarily is, but not vice versa.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can you work out this hierarchy of implication?</p></blockquote></blockquote><p>Observe that if two expressions are <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>, then they are
aliases, i.e., they are referring to one and the same
value. Therefore, the values produced by those expressions must be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>. If they are always equal, then clearly at any
given moment, they must also be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>.</p><p>Even if two expressions are not <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>, they may be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>. This would never be true of mutable data (because
there is the possibility of a future mutation), but it can be true of
immutable data that have the same structure and contents. In that
case, if they are always equal, then again they must be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>.</p><p>However, the converses are not true.</p><p>If two data are <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>, they <span class="emph">may</span> not be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>: if they are mutable, a future mutation may change
the equality, as we have seen above. Similarly, two data may be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> but not be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>, because they reside
at different heap addresses and are therefore truly different data.</p><p>In most languages, it is common to have two equality operators,
corresponding to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> (known as <span style="font-style: italic">reference equality</span>)
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span> (known as <span style="font-style: italic">structural equality</span>). Pyret is
rare in having a third operator, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>. For
most programs, this is in fact the most useful equality operator: it
is not overly bothered with details of aliasing, which can be
difficult to predict; at the same time it makes decisions that stand
the test of time, thereby forming a useful basis for various
optimizations (which may not even be conscious of their temporal
assumptions). This is why <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> in testing uses
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> by default, and forces users to explicitly pick a
different primitive if they want it.</p></section><section class="SsectionLevel3" id="section 19.6"><h3 class="heading">19.6<span class="stt">Â </span><a name="(part._.Space_and_.Time_.Complexity)"/>Space and Time Complexity<span class="button-group"><a href="#(part._.Space_and_.Time_.Complexity)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> always takes constant time. Indeed, some programs use
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> precisely <span class="emph">because</span> they want constant-time
equality, carefully structuring their program so that values that
should be considered equal are aliases to the same value. Of course,
maintaining this programming discipline is tricky.</p><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span> both must traverse at least
the immutable part of data. Therefore, they take time proportional to
the smaller datum (because if the two data are of different size, they
must not be equal anyway, so there is no need to visit the extra
data). The difference is that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> reduces to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> at references, thereby performing less computation
than <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span> would.</p></section><section class="SsectionLevel3" id="section 19.7"><h3 class="heading">19.7<span class="stt">Â </span><a name="(part._sem-identical)"/>What it Means to be Identical<span class="button-group"><a href="#(part._sem-identical)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">Return for a moment to the state where we have just defined the three
boxes [<a href="#%28elem._three-boxes%29" data-pltdoc="x">&lt;<span style="font-style: italic">three-boxes</span>&gt;</a>]. We could have written the
following:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hold-b1-value = unbox-now(b1)
set-box-now(b1, hold-b1-value + 1)</code></pre></div></div></div><div class="SIntrapara">Now, we can compare the contents of the various boxes:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1-id-b2 = unbox-now(b1) == unbox-now(b2)
b1-id-b3 = unbox-now(b1) == unbox-now(b3)</code></pre></div></div></div><div class="SIntrapara">And at the end of performing comparisons, we can restore them:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">set-box-now(b1, hold-b1-value)</code></pre></div></div></div><div class="SIntrapara">Observe that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1-id-b2</code></span> would be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span> but <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1-id-b3</code></span>
would be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>. And notice that this would always be true when
the two expressions are identical, but not otherwise.</div><p>Thus, at the end there has been no change, but by making the change we
can check which values are and arenâ€™t aliases of others. In other
words, this<span class="emph">represents the essence of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span></span>.</p><p>In practice, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> does not behave this way: it would be
too disruptive. It is also not the most efficient implementation
possible, when Pyret can simply check the memory addresses being the
same. Nevertheless, it does demonstrate the basic idea behind
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>: two values are <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> precisely when, when
you make changes to one, you see the changes manifest on the â€œotherâ€
(i.e., there is really only one value, but with potentially multiple
names for it).</p></section><section class="SsectionLevel3" id="section 19.8"><h3 class="heading">19.8<span class="stt">Â </span><a name="(part._comp-func)"/>Comparing Functions<span class="button-group"><a href="#(part._comp-func)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>We havenâ€™t actually provided the full truth about equality because we
havenâ€™t discussed functions. Defining equality for functionsâ€”<wbr/>especially
<span style="font-style: italic">extensional equality</span>, namely whether two functions have the same
graph, i.e., for each input produce the same outputâ€”<wbr/>is complicated
(a euphemism for impossible) due to the Halting Problem.</p><p>Because of this, most languages have tended to use approximations for
function equality, most commonly reference equality. This is, however,
a very weak approximation: even if the exact same function text in the
same environment is allocated as two different closures, these would
not be reference-equal. At least when this is done as part of the
definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>, it makes sense; if other operators do
this, however, they are actively <span class="emph">lying</span>, which is something the
equality operators do not usually do.</p><p>There is one other approach we can take: simply disallow function
comparison. This is what Pyret does: all three equality operators
above will result in an error if you try to compare two
functions. (You can compare against just one function, however, and
you will get the answer <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>.) This ensures that the
languageâ€™s comparison operators are never trusted falsely.</p><p>Pyret did have the choice of allowing reference equality for
functions inside <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> and erroring only in the other two
cases. Had it done so, however, it would have violated the chain of
implication above [<a href="#%28part._equality-hierarchy%29" data-pltdoc="x">A Hierarchy of Equality</a>]. The present design
is arguably more elegant. Programmers who do want to use reference
equality on functions can simply embed the functions inside a mutable
structure like boxes.</p><p>There is one problem with erroring when comparing two functions: a
completely generic procedure that compares two arbitrary values may
error if both of the values given are functions. Because this can
cause unpredictable program failure, Pyret offers a <span style="font-style: italic">three-valued</span>
version of each of the above three operators (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical3</code></span>,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always3</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now3</code></span>), all of which return
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">EqualityResult</code></span> values that correspond to truth, falsity, and
ignorance (returned in the case when both arguments are
functions). Programmers can use this in place of the Boolean-valued
comparison operators if they are uncertain about the types of the
parameters.</p></section>&#13;
<h3 class="heading">19.1<span class="stt">Â </span><a name="(part._boxes)"/>Boxes: A Canonical Mutable Structure<span class="button-group"><a href="#(part._boxes)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">In <a href="mutating-structures.html" data-pltdoc="x">Mutating Structures</a> we saw a motivating example using bank
accounts. To focus our study of equality, it can be convenient to have
an even simpler mutable data structure, called a <span style="font-style: italic">box</span> (which you
will find in other programming languages as well). A box has only one
fieldâ€”<wbr/>the value being boxedâ€”<wbr/>and supports just three operations:
</div><div class="SIntrapara"><ol><li><p><span class="stt">box</span> consumes a value and creates a mutable box
containing that value.</p></li><li><p><span class="stt">unbox-now</span> consumes a box and returns the value contained in
the box.</p></li><li><p><span class="stt">set-box-now</span> consumes a box, a new value, and <span class="emph">changes</span>
the box to contain the value. All subsequent <span class="stt">unbox-now</span>s of that
box will now return the new valueâ€”<wbr/>unless it is mutated again.</p></li></ol></div><div class="SIntrapara">Here are the corresponding definitions in Pyret:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Box&lt;T&gt;:
  | box(ref v :: T)
end

fun unbox-now&lt;T&gt;(b :: Box&lt;T&gt;) -&gt; T:
  b!v
end

fun set-box-now&lt;T&gt;(b :: Box&lt;T&gt;, new-v :: T) -&gt; Box&lt;T&gt;:
  b!{v: new-v}
end</code></pre></div></div></div><div class="SIntrapara">Observe that we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b!v</code></span> to extract the current value, and use
the naming convention of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-now</code></span> to make clear these are stateful
operations, so the value now may not be the same as the value later.</div>&#13;
<h3 class="heading">19.2<span class="stt">Â </span><a name="(part._.Mutation_and_.Types)"/>Mutation and Types<span class="button-group"><a href="#(part._.Mutation_and_.Types)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>In terms of types, whenever we replace the value in a box, we want it
to be type-consistent with what was previously there. Otherwise it
would be very difficult to program against a box, because the type of
its content would keep changing.</p><p/><div class="SIntrapara">These definitions obey the following tests:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  n1 = box(1)
  n2 = box(2)
  set-box-now(n1, 3)
  set-box-now(n2, 4)
  unbox-now(n1) is 3
  unbox-now(n2) is 4
end</code></pre></div></div></div><div class="SIntrapara">However, we cannot write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">set-box-now(n1, "hi")</code></span>, because that
would violate the type of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n1</code></span>, which is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Box&lt;Number&gt;</code></span>. We
could make this explicit by writing
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n1 :: Box&lt;Number&gt; = box(1)</code></pre></div></div></div><div class="SIntrapara">if we wanted to be explicit. However, note that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n1</code></span> being a box
of numbers does not preclude us from having a box of strings:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n3 :: Box&lt;String&gt; = box("hello")</code></pre></div></div></div><div class="SIntrapara">or indeed a box of any other type. We just need its type to remain
<span class="emph">consistent</span>, whatever that type is.</div><p>This is a general rule we want to follow with mutable data: the new
value must be the same type as the old value. This gives programs a
consistent interface to program against. For instance, above, we know
that we can always perform numeric operations against the value
extracted from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n1</code></span>â€”<wbr/>there is no danger that it will suddenly
produce a string. This discipline can either be enforced by a system
of annotations, or has to be manually maintained by the programmer.</p>&#13;
<h3 class="heading">19.3<span class="stt">Â </span><a name="(part._.Mutation_and_.Equality)"/>Mutation and Equality<span class="button-group"><a href="#(part._.Mutation_and_.Equality)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Weâ€™ve already seen [<a href="Sharing_and_Equality.html#%28part._identical-eq%29" data-pltdoc="x">Re-Examining Equality</a>] that equality is
subtle. Itâ€™s about to become much subtler with the introduction of
mutation!</p><p/><div class="SIntrapara">As a running example, weâ€™ll work with:
</div><div class="SIntrapara"><a name="(elem._three-boxes)"/>&lt;<span style="font-style: italic">three-boxes</span>&gt; ::=</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â </span><span class="stt">b1 = box(7)</span></p></td></tr><tr><td><p><span class="hspace">Â Â </span><span class="stt">b2 = box(7)</span></p></td></tr><tr><td><p><span class="hspace">Â Â </span><span class="stt">b3 = b1</span></p></td></tr></table></div><div class="SIntrapara">Observe that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b3</code></span> are referring to the <span class="emph">same</span>
box, while <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b2</code></span> is referring to a different one. We can see this
from a memory diagram:</div><div class="HeapExpr"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">b1</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1001</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">b2</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1002</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">b3</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1001</span></div></li></ul></div><div class="HeapPart"><p>Heap</p><ul><li><p><span class="heapref source">1001</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">box(7)</code></span></p></li><li><p><span class="heapref source">1002</span>:<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">box(7)</code></span></p></li></ul></div><p/><div class="clear"/></div><p/><div class="SIntrapara">We can confirm this using the following tests:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  b1 is-not%(identical) b2
  b1 is%(identical) b3
  b2 is-not%(identical) b3
end</code></pre></div></div></div><div class="SIntrapara">In other words, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b3</code></span> are aliases for the same box,
but neither is an alias to the box referred to by <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b2</code></span>. Since
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> is <span style="font-style: italic">transitive</span>, it follows from the first two
tests that the third test must also pass (and thankfully, Pyret
confirms this for us!).</div><p>Now, you might wonder why we have used <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> and not
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> [<a href="Sharing_and_Equality.html#%28part._equal-always%29" data-pltdoc="x">Notations for Equality</a>], i.e., plain old
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Letâ€™s try that:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  b1 is b3
  b1 is b2
end</code></pre></div></div></div><div class="SIntrapara">What do you see?</div></blockquote></blockquote><p/><div class="SIntrapara">Itâ€™s unsurprising that the first test, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1 is b3</code></span>,
passes. However, the second, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1 is b2</code></span>, fails! And the name
suggests why: the two are not guaranteed to <span class="emph">always</span> be
equal. That is, suppose we were to modify the box referred to by
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">set-box-now(b1, 8)</code></pre></div></div></div><div class="SIntrapara">Sure enough, the values in the boxes are not the same, but because
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b3</code></span> are aliases, their values change in lock-step
(more accurately, there is only one valueâ€”<wbr/>the box at <span class="heapref sink">1001</span>):
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  unbox-now(b1) is-not unbox-now(b2)
  unbox-now(b1) is unbox-now(b3)
end</code></pre></div></div></div>&#13;
<h3 class="heading">19.4<span class="stt">Â </span><a name="(part._.Another_.Equality_.Predicate)"/>Another Equality Predicate<span class="button-group"><a href="#(part._.Another_.Equality_.Predicate)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Suppose we return to the state where we have defined the three boxes
[<a href="#%28elem._three-boxes%29" data-pltdoc="x">&lt;<span style="font-style: italic">three-boxes</span>&gt;</a>] but not mutated <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1</code></span>. That is, when
<span class="emph">printed</span>, all three boxes have the same value, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">box(7)</code></span>. We
have seen that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b3</code></span> are <span class="emph">both</span>
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> to each other. However, we
have also seen that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b2</code></span> are <span class="emph">neither</span> of
those. This is somewhat frustrating, because there is clearly some
sense in which they are â€œequalâ€: at the moment, they contain the
same value, even if later on one of them might not.</p><p/><div class="SIntrapara">Therefore, Pyret offers a <span class="emph">third</span> equality predicate that is
designed for just these situations: it is (as you might guess) called
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  b1 is%(equal-now) b2
  b2 is%(equal-now) b3
end</code></pre></div></div></div><div class="SIntrapara">The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-now</code></span> in the name reminds us that these values are equal at
the moment, but may not be equal later. Sure enough, if we add
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">set-box-now(b1, 8)</code></pre></div></div></div><div class="SIntrapara">back into the program, the above <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span> tests fail: now,
they are no longer equal!</div><p/><div class="SIntrapara">Recall that the other two equality predicates have an binary operator
notation: <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span> for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;=&gt;</code></span> for
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>. Similarly, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span> has the binary operator
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=~</code></span>. You should view that as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=</code></span> with hand-waving <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">~</code></span>:
itâ€™s equal for now, but donâ€™t expect it to remain so. That is, we can
rewrite the above tests as:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  equal-now(b1, b2) is true
  (b2 =~ b3) is true
end</code></pre></div></div></div><div class="SIntrapara">Whether they pass, of course, depends on the state of the program:
whether <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b2</code></span>, or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b3</code></span> has had its content modified.</div>&#13;
<h3 class="heading">19.5<span class="stt">Â </span><a name="(part._equality-hierarchy)"/>A Hierarchy of Equality<span class="button-group"><a href="#(part._equality-hierarchy)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>As you might guess, the equality operators have a hierarchy of
implication. That is, if one operator is true of two expressions, the
other necessarily is, but not vice versa.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can you work out this hierarchy of implication?</p></blockquote></blockquote><p>Observe that if two expressions are <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>, then they are
aliases, i.e., they are referring to one and the same
value. Therefore, the values produced by those expressions must be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>. If they are always equal, then clearly at any
given moment, they must also be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>.</p><p>Even if two expressions are not <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>, they may be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>. This would never be true of mutable data (because
there is the possibility of a future mutation), but it can be true of
immutable data that have the same structure and contents. In that
case, if they are always equal, then again they must be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>.</p><p>However, the converses are not true.</p><p>If two data are <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>, they <span class="emph">may</span> not be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>: if they are mutable, a future mutation may change
the equality, as we have seen above. Similarly, two data may be
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> but not be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>, because they reside
at different heap addresses and are therefore truly different data.</p><p>In most languages, it is common to have two equality operators,
corresponding to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> (known as <span style="font-style: italic">reference equality</span>)
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span> (known as <span style="font-style: italic">structural equality</span>). Pyret is
rare in having a third operator, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>. For
most programs, this is in fact the most useful equality operator: it
is not overly bothered with details of aliasing, which can be
difficult to predict; at the same time it makes decisions that stand
the test of time, thereby forming a useful basis for various
optimizations (which may not even be conscious of their temporal
assumptions). This is why <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> in testing uses
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> by default, and forces users to explicitly pick a
different primitive if they want it.</p>&#13;
<h3 class="heading">19.6<span class="stt">Â </span><a name="(part._.Space_and_.Time_.Complexity)"/>Space and Time Complexity<span class="button-group"><a href="#(part._.Space_and_.Time_.Complexity)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> always takes constant time. Indeed, some programs use
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> precisely <span class="emph">because</span> they want constant-time
equality, carefully structuring their program so that values that
should be considered equal are aliases to the same value. Of course,
maintaining this programming discipline is tricky.</p><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span> both must traverse at least
the immutable part of data. Therefore, they take time proportional to
the smaller datum (because if the two data are of different size, they
must not be equal anyway, so there is no need to visit the extra
data). The difference is that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> reduces to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> at references, thereby performing less computation
than <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span> would.</p>&#13;
<h3 class="heading">19.7<span class="stt">Â </span><a name="(part._sem-identical)"/>What it Means to be Identical<span class="button-group"><a href="#(part._sem-identical)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">Return for a moment to the state where we have just defined the three
boxes [<a href="#%28elem._three-boxes%29" data-pltdoc="x">&lt;<span style="font-style: italic">three-boxes</span>&gt;</a>]. We could have written the
following:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hold-b1-value = unbox-now(b1)
set-box-now(b1, hold-b1-value + 1)</code></pre></div></div></div><div class="SIntrapara">Now, we can compare the contents of the various boxes:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1-id-b2 = unbox-now(b1) == unbox-now(b2)
b1-id-b3 = unbox-now(b1) == unbox-now(b3)</code></pre></div></div></div><div class="SIntrapara">And at the end of performing comparisons, we can restore them:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">set-box-now(b1, hold-b1-value)</code></pre></div></div></div><div class="SIntrapara">Observe that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1-id-b2</code></span> would be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span> but <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1-id-b3</code></span>
would be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>. And notice that this would always be true when
the two expressions are identical, but not otherwise.</div><p>Thus, at the end there has been no change, but by making the change we
can check which values are and arenâ€™t aliases of others. In other
words, this<span class="emph">represents the essence of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span></span>.</p><p>In practice, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> does not behave this way: it would be
too disruptive. It is also not the most efficient implementation
possible, when Pyret can simply check the memory addresses being the
same. Nevertheless, it does demonstrate the basic idea behind
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>: two values are <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> precisely when, when
you make changes to one, you see the changes manifest on the â€œotherâ€
(i.e., there is really only one value, but with potentially multiple
names for it).</p>&#13;
<h3 class="heading">19.8<span class="stt">Â </span><a name="(part._comp-func)"/>Comparing Functions<span class="button-group"><a href="#(part._comp-func)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>We havenâ€™t actually provided the full truth about equality because we
havenâ€™t discussed functions. Defining equality for functionsâ€”<wbr/>especially
<span style="font-style: italic">extensional equality</span>, namely whether two functions have the same
graph, i.e., for each input produce the same outputâ€”<wbr/>is complicated
(a euphemism for impossible) due to the Halting Problem.</p><p>Because of this, most languages have tended to use approximations for
function equality, most commonly reference equality. This is, however,
a very weak approximation: even if the exact same function text in the
same environment is allocated as two different closures, these would
not be reference-equal. At least when this is done as part of the
definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span>, it makes sense; if other operators do
this, however, they are actively <span class="emph">lying</span>, which is something the
equality operators do not usually do.</p><p>There is one other approach we can take: simply disallow function
comparison. This is what Pyret does: all three equality operators
above will result in an error if you try to compare two
functions. (You can compare against just one function, however, and
you will get the answer <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>.) This ensures that the
languageâ€™s comparison operators are never trusted falsely.</p><p>Pyret did have the choice of allowing reference equality for
functions inside <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> and erroring only in the other two
cases. Had it done so, however, it would have violated the chain of
implication above [<a href="#%28part._equality-hierarchy%29" data-pltdoc="x">A Hierarchy of Equality</a>]. The present design
is arguably more elegant. Programmers who do want to use reference
equality on functions can simply embed the functions inside a mutable
structure like boxes.</p><p>There is one problem with erroring when comparing two functions: a
completely generic procedure that compares two arbitrary values may
error if both of the values given are functions. Because this can
cause unpredictable program failure, Pyret offers a <span style="font-style: italic">three-valued</span>
version of each of the above three operators (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical3</code></span>,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always3</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now3</code></span>), all of which return
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">EqualityResult</code></span> values that correspond to truth, falsity, and
ignorance (returned in the case when both arguments are
functions). Programmers can use this in place of the Boolean-valued
comparison operators if they are uncertain about the types of the
parameters.</p>    
</body>
</html>