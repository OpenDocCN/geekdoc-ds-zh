<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>19Â State and EqualityğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>19Â State and EqualityğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/state-in-pyret.html">https://dcic-world.org/2025-08-27/state-in-pyret.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._boxes%29" class="toclink" data-pltdoc="x">19.1Â Boxes: A Canonical Mutable Structure</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Mutation_and_.Types%29" class="toclink" data-pltdoc="x">19.2Â Mutation and Types</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Mutation_and_.Equality%29" class="toclink" data-pltdoc="x">19.3Â Mutation and Equality</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Another_.Equality_.Predicate%29" class="toclink" data-pltdoc="x">19.4Â Another Equality Predicate</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._equality-hierarchy%29" class="toclink" data-pltdoc="x">19.5Â A Hierarchy of Equality</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Space_and_.Time_.Complexity%29" class="toclink" data-pltdoc="x">19.6Â Space and Time Complexity</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._sem-identical%29" class="toclink" data-pltdoc="x">19.7Â What it Means to be Identical</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._comp-func%29" class="toclink" data-pltdoc="x">19.8Â Comparing Functions</a></p></td></tr></table><p>In <a href="mutating-structures.html" data-pltdoc="x">Mutating Structures</a>, we introduced the notion of mutable
data. We also saw the impact it has on testing. Underlying testing is
some notion of equality: when we write a test in Pyret using
<code data-lang="pyret" class="sourceCode">is</code>, we are implicitly making a statement about equality between
the two sides. Here we will examine equality in the presence of state
in more detail.</p><section class="SsectionLevel3" id="section 19.1"><h3 class="heading">19.1Â <a name="(part._boxes)"/>Boxes: A Canonical Mutable Structure<a href="#(part._boxes)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>In <a href="mutating-structures.html" data-pltdoc="x">Mutating Structures</a> we saw a motivating example using bank
accounts. To focus our study of equality, it can be convenient to have
an even simpler mutable data structure, called a box (which you
will find in other programming languages as well). A box has only one
fieldâ€”<wbr/>the value being boxedâ€”<wbr/>and supports just three operations:
</p><ol><li><p>box consumes a value and creates a mutable box
containing that value.</p></li><li><p>unbox-now consumes a box and returns the value contained in
the box.</p></li><li><p>set-box-now consumes a box, a new value, and changes
the box to contain the value. All subsequent unbox-nows of that
box will now return the new valueâ€”<wbr/>unless it is mutated again.</p></li></ol><p>Here are the corresponding definitions in Pyret:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Box&lt;T&gt;:
  | box(ref v :: T)
end

fun unbox-now&lt;T&gt;(b :: Box&lt;T&gt;) -&gt; T:
  b!v
end

fun set-box-now&lt;T&gt;(b :: Box&lt;T&gt;, new-v :: T) -&gt; Box&lt;T&gt;:
  b!{v: new-v}
end</code></pre><p>Observe that we use <code data-lang="pyret" class="sourceCode">b!v</code> to extract the current value, and use
the naming convention of <code data-lang="pyret" class="sourceCode">-now</code> to make clear these are stateful
operations, so the value now may not be the same as the value later.</p></section><section class="SsectionLevel3" id="section 19.2"><h3 class="heading">19.2Â <a name="(part._.Mutation_and_.Types)"/>Mutation and Types<a href="#(part._.Mutation_and_.Types)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>In terms of types, whenever we replace the value in a box, we want it
to be type-consistent with what was previously there. Otherwise it
would be very difficult to program against a box, because the type of
its content would keep changing.</p><p>These definitions obey the following tests:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  n1 = box(1)
  n2 = box(2)
  set-box-now(n1, 3)
  set-box-now(n2, 4)
  unbox-now(n1) is 3
  unbox-now(n2) is 4
end</code></pre><p>However, we cannot write <code data-lang="pyret" class="sourceCode">set-box-now(n1, "hi")</code>, because that
would violate the type of <code data-lang="pyret" class="sourceCode">n1</code>, which is <code data-lang="pyret" class="sourceCode">Box&lt;Number&gt;</code>. We
could make this explicit by writing
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n1 :: Box&lt;Number&gt; = box(1)</code></pre><p>if we wanted to be explicit. However, note that <code data-lang="pyret" class="sourceCode">n1</code> being a box
of numbers does not preclude us from having a box of strings:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n3 :: Box&lt;String&gt; = box("hello")</code></pre><p>or indeed a box of any other type. We just need its type to remain
consistent, whatever that type is.</p><p>This is a general rule we want to follow with mutable data: the new
value must be the same type as the old value. This gives programs a
consistent interface to program against. For instance, above, we know
that we can always perform numeric operations against the value
extracted from <code data-lang="pyret" class="sourceCode">n1</code>â€”<wbr/>there is no danger that it will suddenly
produce a string. This discipline can either be enforced by a system
of annotations, or has to be manually maintained by the programmer.</p></section><section class="SsectionLevel3" id="section 19.3"><h3 class="heading">19.3Â <a name="(part._.Mutation_and_.Equality)"/>Mutation and Equality<a href="#(part._.Mutation_and_.Equality)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Weâ€™ve already seen [<a href="Sharing_and_Equality.html#%28part._identical-eq%29" data-pltdoc="x">Re-Examining Equality</a>] that equality is
subtle. Itâ€™s about to become much subtler with the introduction of
mutation!</p><p>As a running example, weâ€™ll work with:
</p><a name="(elem._three-boxes)"/>&lt;three-boxes&gt; ::=<table cellspacing="0" cellpadding="0"><tr><td><p>Â Â b1 = box(7)</p></td></tr><tr><td><p>Â Â b2 = box(7)</p></td></tr><tr><td><p>Â Â b3 = b1</p></td></tr></table><p>Observe that <code data-lang="pyret" class="sourceCode">b1</code> and <code data-lang="pyret" class="sourceCode">b3</code> are referring to the same
box, while <code data-lang="pyret" class="sourceCode">b2</code> is referring to a different one. We can see this
from a memory diagram:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">b1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">b2</code></pre><p>Â â†’Â 1002</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">b3</code></pre><p>Â â†’Â 1001</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">box(7)</code></p></li><li><p>1002:Â <code data-lang="pyret" class="sourceCode">box(7)</code></p></li></ul><p>We can confirm this using the following tests:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  b1 is-not%(identical) b2
  b1 is%(identical) b3
  b2 is-not%(identical) b3
end</code></pre><p>In other words, <code data-lang="pyret" class="sourceCode">b1</code> and <code data-lang="pyret" class="sourceCode">b3</code> are aliases for the same box,
but neither is an alias to the box referred to by <code data-lang="pyret" class="sourceCode">b2</code>. Since
<code data-lang="pyret" class="sourceCode">identical</code> is transitive, it follows from the first two
tests that the third test must also pass (and thankfully, Pyret
confirms this for us!).</p><p>Now, you might wonder why we have used <code data-lang="pyret" class="sourceCode">identical</code> and not
<code data-lang="pyret" class="sourceCode">equal-always</code> [<a href="Sharing_and_Equality.html#%28part._equal-always%29" data-pltdoc="x">Notations for Equality</a>], i.e., plain old
<code data-lang="pyret" class="sourceCode">is</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Letâ€™s try that:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  b1 is b3
  b1 is b2
end</code></pre><p>What do you see?</p></blockquote></blockquote><p>Itâ€™s unsurprising that the first test, <code data-lang="pyret" class="sourceCode">b1 is b3</code>,
passes. However, the second, <code data-lang="pyret" class="sourceCode">b1 is b2</code>, fails! And the name
suggests why: the two are not guaranteed to always be
equal. That is, suppose we were to modify the box referred to by
<code data-lang="pyret" class="sourceCode">b1</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">set-box-now(b1, 8)</code></pre><p>Sure enough, the values in the boxes are not the same, but because
<code data-lang="pyret" class="sourceCode">b1</code> and <code data-lang="pyret" class="sourceCode">b3</code> are aliases, their values change in lock-step
(more accurately, there is only one valueâ€”<wbr/>the box at 1001):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  unbox-now(b1) is-not unbox-now(b2)
  unbox-now(b1) is unbox-now(b3)
end</code></pre></section><section class="SsectionLevel3" id="section 19.4"><h3 class="heading">19.4Â <a name="(part._.Another_.Equality_.Predicate)"/>Another Equality Predicate<a href="#(part._.Another_.Equality_.Predicate)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Suppose we return to the state where we have defined the three boxes
[<a href="#%28elem._three-boxes%29" data-pltdoc="x">&lt;three-boxes&gt;</a>] but not mutated <code data-lang="pyret" class="sourceCode">b1</code>. That is, when
printed, all three boxes have the same value, <code data-lang="pyret" class="sourceCode">box(7)</code>. We
have seen that <code data-lang="pyret" class="sourceCode">b1</code> and <code data-lang="pyret" class="sourceCode">b3</code> are both
<code data-lang="pyret" class="sourceCode">equal-always</code> and <code data-lang="pyret" class="sourceCode">identical</code> to each other. However, we
have also seen that <code data-lang="pyret" class="sourceCode">b1</code> and <code data-lang="pyret" class="sourceCode">b2</code> are neither of
those. This is somewhat frustrating, because there is clearly some
sense in which they are â€œequalâ€: at the moment, they contain the
same value, even if later on one of them might not.</p><p>Therefore, Pyret offers a third equality predicate that is
designed for just these situations: it is (as you might guess) called
<code data-lang="pyret" class="sourceCode">equal-now</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  b1 is%(equal-now) b2
  b2 is%(equal-now) b3
end</code></pre><p>The <code data-lang="pyret" class="sourceCode">-now</code> in the name reminds us that these values are equal at
the moment, but may not be equal later. Sure enough, if we add
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">set-box-now(b1, 8)</code></pre><p>back into the program, the above <code data-lang="pyret" class="sourceCode">equal-now</code> tests fail: now,
they are no longer equal!</p><p>Recall that the other two equality predicates have an binary operator
notation: <code data-lang="pyret" class="sourceCode">==</code> for <code data-lang="pyret" class="sourceCode">equal-always</code> and <code data-lang="pyret" class="sourceCode">&lt;=&gt;</code> for
<code data-lang="pyret" class="sourceCode">identical</code>. Similarly, <code data-lang="pyret" class="sourceCode">equal-now</code> has the binary operator
<code data-lang="pyret" class="sourceCode">=~</code>. You should view that as <code data-lang="pyret" class="sourceCode">=</code> with hand-waving <code data-lang="pyret" class="sourceCode">~</code>:
itâ€™s equal for now, but donâ€™t expect it to remain so. That is, we can
rewrite the above tests as:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  equal-now(b1, b2) is true
  (b2 =~ b3) is true
end</code></pre><p>Whether they pass, of course, depends on the state of the program:
whether <code data-lang="pyret" class="sourceCode">b1</code>, <code data-lang="pyret" class="sourceCode">b2</code>, or <code data-lang="pyret" class="sourceCode">b3</code> has had its content modified.</p></section><section class="SsectionLevel3" id="section 19.5"><h3 class="heading">19.5Â <a name="(part._equality-hierarchy)"/>A Hierarchy of Equality<a href="#(part._equality-hierarchy)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>As you might guess, the equality operators have a hierarchy of
implication. That is, if one operator is true of two expressions, the
other necessarily is, but not vice versa.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can you work out this hierarchy of implication?</p></blockquote></blockquote><p>Observe that if two expressions are <code data-lang="pyret" class="sourceCode">identical</code>, then they are
aliases, i.e., they are referring to one and the same
value. Therefore, the values produced by those expressions must be
<code data-lang="pyret" class="sourceCode">equal-always</code>. If they are always equal, then clearly at any
given moment, they must also be <code data-lang="pyret" class="sourceCode">equal-now</code>.</p><p>Even if two expressions are not <code data-lang="pyret" class="sourceCode">identical</code>, they may be
<code data-lang="pyret" class="sourceCode">equal-always</code>. This would never be true of mutable data (because
there is the possibility of a future mutation), but it can be true of
immutable data that have the same structure and contents. In that
case, if they are always equal, then again they must be
<code data-lang="pyret" class="sourceCode">equal-now</code>.</p><p>However, the converses are not true.</p><p>If two data are <code data-lang="pyret" class="sourceCode">equal-now</code>, they may not be
<code data-lang="pyret" class="sourceCode">equal-always</code>: if they are mutable, a future mutation may change
the equality, as we have seen above. Similarly, two data may be
<code data-lang="pyret" class="sourceCode">equal-always</code> but not be <code data-lang="pyret" class="sourceCode">identical</code>, because they reside
at different heap addresses and are therefore truly different data.</p><p>In most languages, it is common to have two equality operators,
corresponding to <code data-lang="pyret" class="sourceCode">identical</code> (known as reference equality)
and <code data-lang="pyret" class="sourceCode">equal-now</code> (known as structural equality). Pyret is
rare in having a third operator, <code data-lang="pyret" class="sourceCode">equal-always</code>. For
most programs, this is in fact the most useful equality operator: it
is not overly bothered with details of aliasing, which can be
difficult to predict; at the same time it makes decisions that stand
the test of time, thereby forming a useful basis for various
optimizations (which may not even be conscious of their temporal
assumptions). This is why <code data-lang="pyret" class="sourceCode">is</code> in testing uses
<code data-lang="pyret" class="sourceCode">equal-always</code> by default, and forces users to explicitly pick a
different primitive if they want it.</p></section><section class="SsectionLevel3" id="section 19.6"><h3 class="heading">19.6Â <a name="(part._.Space_and_.Time_.Complexity)"/>Space and Time Complexity<a href="#(part._.Space_and_.Time_.Complexity)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p><code data-lang="pyret" class="sourceCode">identical</code> always takes constant time. Indeed, some programs use
<code data-lang="pyret" class="sourceCode">identical</code> precisely because they want constant-time
equality, carefully structuring their program so that values that
should be considered equal are aliases to the same value. Of course,
maintaining this programming discipline is tricky.</p><p><code data-lang="pyret" class="sourceCode">equal-always</code> and <code data-lang="pyret" class="sourceCode">equal-now</code> both must traverse at least
the immutable part of data. Therefore, they take time proportional to
the smaller datum (because if the two data are of different size, they
must not be equal anyway, so there is no need to visit the extra
data). The difference is that <code data-lang="pyret" class="sourceCode">equal-always</code> reduces to
<code data-lang="pyret" class="sourceCode">identical</code> at references, thereby performing less computation
than <code data-lang="pyret" class="sourceCode">equal-now</code> would.</p></section><section class="SsectionLevel3" id="section 19.7"><h3 class="heading">19.7Â <a name="(part._sem-identical)"/>What it Means to be Identical<a href="#(part._sem-identical)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Return for a moment to the state where we have just defined the three
boxes [<a href="#%28elem._three-boxes%29" data-pltdoc="x">&lt;three-boxes&gt;</a>]. We could have written the
following:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hold-b1-value = unbox-now(b1)
set-box-now(b1, hold-b1-value + 1)</code></pre><p>Now, we can compare the contents of the various boxes:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1-id-b2 = unbox-now(b1) == unbox-now(b2)
b1-id-b3 = unbox-now(b1) == unbox-now(b3)</code></pre><p>And at the end of performing comparisons, we can restore them:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">set-box-now(b1, hold-b1-value)</code></pre><p>Observe that <code data-lang="pyret" class="sourceCode">b1-id-b2</code> would be <code data-lang="pyret" class="sourceCode">false</code> but <code data-lang="pyret" class="sourceCode">b1-id-b3</code>
would be <code data-lang="pyret" class="sourceCode">true</code>. And notice that this would always be true when
the two expressions are identical, but not otherwise.</p><p>Thus, at the end there has been no change, but by making the change we
can check which values are and arenâ€™t aliases of others. In other
words, thisrepresents the essence of <code data-lang="pyret" class="sourceCode">identical</code>.</p><p>In practice, <code data-lang="pyret" class="sourceCode">identical</code> does not behave this way: it would be
too disruptive. It is also not the most efficient implementation
possible, when Pyret can simply check the memory addresses being the
same. Nevertheless, it does demonstrate the basic idea behind
<code data-lang="pyret" class="sourceCode">identical</code>: two values are <code data-lang="pyret" class="sourceCode">identical</code> precisely when, when
you make changes to one, you see the changes manifest on the â€œotherâ€
(i.e., there is really only one value, but with potentially multiple
names for it).</p></section><section class="SsectionLevel3" id="section 19.8"><h3 class="heading">19.8Â <a name="(part._comp-func)"/>Comparing Functions<a href="#(part._comp-func)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>We havenâ€™t actually provided the full truth about equality because we
havenâ€™t discussed functions. Defining equality for functionsâ€”<wbr/>especially
extensional equality, namely whether two functions have the same
graph, i.e., for each input produce the same outputâ€”<wbr/>is complicated
(a euphemism for impossible) due to the Halting Problem.</p><p>Because of this, most languages have tended to use approximations for
function equality, most commonly reference equality. This is, however,
a very weak approximation: even if the exact same function text in the
same environment is allocated as two different closures, these would
not be reference-equal. At least when this is done as part of the
definition of <code data-lang="pyret" class="sourceCode">identical</code>, it makes sense; if other operators do
this, however, they are actively lying, which is something the
equality operators do not usually do.</p><p>There is one other approach we can take: simply disallow function
comparison. This is what Pyret does: all three equality operators
above will result in an error if you try to compare two
functions. (You can compare against just one function, however, and
you will get the answer <code data-lang="pyret" class="sourceCode">false</code>.) This ensures that the
languageâ€™s comparison operators are never trusted falsely.</p><p>Pyret did have the choice of allowing reference equality for
functions inside <code data-lang="pyret" class="sourceCode">identical</code> and erroring only in the other two
cases. Had it done so, however, it would have violated the chain of
implication above [<a href="#%28part._equality-hierarchy%29" data-pltdoc="x">A Hierarchy of Equality</a>]. The present design
is arguably more elegant. Programmers who do want to use reference
equality on functions can simply embed the functions inside a mutable
structure like boxes.</p><p>There is one problem with erroring when comparing two functions: a
completely generic procedure that compares two arbitrary values may
error if both of the values given are functions. Because this can
cause unpredictable program failure, Pyret offers a three-valued
version of each of the above three operators (<code data-lang="pyret" class="sourceCode">identical3</code>,
<code data-lang="pyret" class="sourceCode">equal-always3</code> and <code data-lang="pyret" class="sourceCode">equal-now3</code>), all of which return
<code data-lang="pyret" class="sourceCode">EqualityResult</code> values that correspond to truth, falsity, and
ignorance (returned in the case when both arguments are
functions). Programmers can use this in place of the Boolean-valued
comparison operators if they are uncertain about the types of the
parameters.</p></section>&#13;
<h3 class="heading">19.1Â <a name="(part._boxes)"/>Boxes: A Canonical Mutable Structure<a href="#(part._boxes)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>In <a href="mutating-structures.html" data-pltdoc="x">Mutating Structures</a> we saw a motivating example using bank
accounts. To focus our study of equality, it can be convenient to have
an even simpler mutable data structure, called a box (which you
will find in other programming languages as well). A box has only one
fieldâ€”<wbr/>the value being boxedâ€”<wbr/>and supports just three operations:
</p><ol><li><p>box consumes a value and creates a mutable box
containing that value.</p></li><li><p>unbox-now consumes a box and returns the value contained in
the box.</p></li><li><p>set-box-now consumes a box, a new value, and changes
the box to contain the value. All subsequent unbox-nows of that
box will now return the new valueâ€”<wbr/>unless it is mutated again.</p></li></ol><p>Here are the corresponding definitions in Pyret:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Box&lt;T&gt;:
  | box(ref v :: T)
end

fun unbox-now&lt;T&gt;(b :: Box&lt;T&gt;) -&gt; T:
  b!v
end

fun set-box-now&lt;T&gt;(b :: Box&lt;T&gt;, new-v :: T) -&gt; Box&lt;T&gt;:
  b!{v: new-v}
end</code></pre><p>Observe that we use <code data-lang="pyret" class="sourceCode">b!v</code> to extract the current value, and use
the naming convention of <code data-lang="pyret" class="sourceCode">-now</code> to make clear these are stateful
operations, so the value now may not be the same as the value later.</p>&#13;
<h3 class="heading">19.2Â <a name="(part._.Mutation_and_.Types)"/>Mutation and Types<a href="#(part._.Mutation_and_.Types)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>In terms of types, whenever we replace the value in a box, we want it
to be type-consistent with what was previously there. Otherwise it
would be very difficult to program against a box, because the type of
its content would keep changing.</p><p>These definitions obey the following tests:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  n1 = box(1)
  n2 = box(2)
  set-box-now(n1, 3)
  set-box-now(n2, 4)
  unbox-now(n1) is 3
  unbox-now(n2) is 4
end</code></pre><p>However, we cannot write <code data-lang="pyret" class="sourceCode">set-box-now(n1, "hi")</code>, because that
would violate the type of <code data-lang="pyret" class="sourceCode">n1</code>, which is <code data-lang="pyret" class="sourceCode">Box&lt;Number&gt;</code>. We
could make this explicit by writing
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n1 :: Box&lt;Number&gt; = box(1)</code></pre><p>if we wanted to be explicit. However, note that <code data-lang="pyret" class="sourceCode">n1</code> being a box
of numbers does not preclude us from having a box of strings:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">n3 :: Box&lt;String&gt; = box("hello")</code></pre><p>or indeed a box of any other type. We just need its type to remain
consistent, whatever that type is.</p><p>This is a general rule we want to follow with mutable data: the new
value must be the same type as the old value. This gives programs a
consistent interface to program against. For instance, above, we know
that we can always perform numeric operations against the value
extracted from <code data-lang="pyret" class="sourceCode">n1</code>â€”<wbr/>there is no danger that it will suddenly
produce a string. This discipline can either be enforced by a system
of annotations, or has to be manually maintained by the programmer.</p>&#13;
<h3 class="heading">19.3Â <a name="(part._.Mutation_and_.Equality)"/>Mutation and Equality<a href="#(part._.Mutation_and_.Equality)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Weâ€™ve already seen [<a href="Sharing_and_Equality.html#%28part._identical-eq%29" data-pltdoc="x">Re-Examining Equality</a>] that equality is
subtle. Itâ€™s about to become much subtler with the introduction of
mutation!</p><p>As a running example, weâ€™ll work with:
</p><a name="(elem._three-boxes)"/>&lt;three-boxes&gt; ::=<table cellspacing="0" cellpadding="0"><tr><td><p>Â Â b1 = box(7)</p></td></tr><tr><td><p>Â Â b2 = box(7)</p></td></tr><tr><td><p>Â Â b3 = b1</p></td></tr></table><p>Observe that <code data-lang="pyret" class="sourceCode">b1</code> and <code data-lang="pyret" class="sourceCode">b3</code> are referring to the same
box, while <code data-lang="pyret" class="sourceCode">b2</code> is referring to a different one. We can see this
from a memory diagram:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">b1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">b2</code></pre><p>Â â†’Â 1002</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">b3</code></pre><p>Â â†’Â 1001</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">box(7)</code></p></li><li><p>1002:Â <code data-lang="pyret" class="sourceCode">box(7)</code></p></li></ul><p>We can confirm this using the following tests:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  b1 is-not%(identical) b2
  b1 is%(identical) b3
  b2 is-not%(identical) b3
end</code></pre><p>In other words, <code data-lang="pyret" class="sourceCode">b1</code> and <code data-lang="pyret" class="sourceCode">b3</code> are aliases for the same box,
but neither is an alias to the box referred to by <code data-lang="pyret" class="sourceCode">b2</code>. Since
<code data-lang="pyret" class="sourceCode">identical</code> is transitive, it follows from the first two
tests that the third test must also pass (and thankfully, Pyret
confirms this for us!).</p><p>Now, you might wonder why we have used <code data-lang="pyret" class="sourceCode">identical</code> and not
<code data-lang="pyret" class="sourceCode">equal-always</code> [<a href="Sharing_and_Equality.html#%28part._equal-always%29" data-pltdoc="x">Notations for Equality</a>], i.e., plain old
<code data-lang="pyret" class="sourceCode">is</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Letâ€™s try that:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  b1 is b3
  b1 is b2
end</code></pre><p>What do you see?</p></blockquote></blockquote><p>Itâ€™s unsurprising that the first test, <code data-lang="pyret" class="sourceCode">b1 is b3</code>,
passes. However, the second, <code data-lang="pyret" class="sourceCode">b1 is b2</code>, fails! And the name
suggests why: the two are not guaranteed to always be
equal. That is, suppose we were to modify the box referred to by
<code data-lang="pyret" class="sourceCode">b1</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">set-box-now(b1, 8)</code></pre><p>Sure enough, the values in the boxes are not the same, but because
<code data-lang="pyret" class="sourceCode">b1</code> and <code data-lang="pyret" class="sourceCode">b3</code> are aliases, their values change in lock-step
(more accurately, there is only one valueâ€”<wbr/>the box at 1001):
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  unbox-now(b1) is-not unbox-now(b2)
  unbox-now(b1) is unbox-now(b3)
end</code></pre>&#13;
<h3 class="heading">19.4Â <a name="(part._.Another_.Equality_.Predicate)"/>Another Equality Predicate<a href="#(part._.Another_.Equality_.Predicate)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Suppose we return to the state where we have defined the three boxes
[<a href="#%28elem._three-boxes%29" data-pltdoc="x">&lt;three-boxes&gt;</a>] but not mutated <code data-lang="pyret" class="sourceCode">b1</code>. That is, when
printed, all three boxes have the same value, <code data-lang="pyret" class="sourceCode">box(7)</code>. We
have seen that <code data-lang="pyret" class="sourceCode">b1</code> and <code data-lang="pyret" class="sourceCode">b3</code> are both
<code data-lang="pyret" class="sourceCode">equal-always</code> and <code data-lang="pyret" class="sourceCode">identical</code> to each other. However, we
have also seen that <code data-lang="pyret" class="sourceCode">b1</code> and <code data-lang="pyret" class="sourceCode">b2</code> are neither of
those. This is somewhat frustrating, because there is clearly some
sense in which they are â€œequalâ€: at the moment, they contain the
same value, even if later on one of them might not.</p><p>Therefore, Pyret offers a third equality predicate that is
designed for just these situations: it is (as you might guess) called
<code data-lang="pyret" class="sourceCode">equal-now</code>:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  b1 is%(equal-now) b2
  b2 is%(equal-now) b3
end</code></pre><p>The <code data-lang="pyret" class="sourceCode">-now</code> in the name reminds us that these values are equal at
the moment, but may not be equal later. Sure enough, if we add
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">set-box-now(b1, 8)</code></pre><p>back into the program, the above <code data-lang="pyret" class="sourceCode">equal-now</code> tests fail: now,
they are no longer equal!</p><p>Recall that the other two equality predicates have an binary operator
notation: <code data-lang="pyret" class="sourceCode">==</code> for <code data-lang="pyret" class="sourceCode">equal-always</code> and <code data-lang="pyret" class="sourceCode">&lt;=&gt;</code> for
<code data-lang="pyret" class="sourceCode">identical</code>. Similarly, <code data-lang="pyret" class="sourceCode">equal-now</code> has the binary operator
<code data-lang="pyret" class="sourceCode">=~</code>. You should view that as <code data-lang="pyret" class="sourceCode">=</code> with hand-waving <code data-lang="pyret" class="sourceCode">~</code>:
itâ€™s equal for now, but donâ€™t expect it to remain so. That is, we can
rewrite the above tests as:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  equal-now(b1, b2) is true
  (b2 =~ b3) is true
end</code></pre><p>Whether they pass, of course, depends on the state of the program:
whether <code data-lang="pyret" class="sourceCode">b1</code>, <code data-lang="pyret" class="sourceCode">b2</code>, or <code data-lang="pyret" class="sourceCode">b3</code> has had its content modified.</p>&#13;
<h3 class="heading">19.5Â <a name="(part._equality-hierarchy)"/>A Hierarchy of Equality<a href="#(part._equality-hierarchy)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>As you might guess, the equality operators have a hierarchy of
implication. That is, if one operator is true of two expressions, the
other necessarily is, but not vice versa.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Can you work out this hierarchy of implication?</p></blockquote></blockquote><p>Observe that if two expressions are <code data-lang="pyret" class="sourceCode">identical</code>, then they are
aliases, i.e., they are referring to one and the same
value. Therefore, the values produced by those expressions must be
<code data-lang="pyret" class="sourceCode">equal-always</code>. If they are always equal, then clearly at any
given moment, they must also be <code data-lang="pyret" class="sourceCode">equal-now</code>.</p><p>Even if two expressions are not <code data-lang="pyret" class="sourceCode">identical</code>, they may be
<code data-lang="pyret" class="sourceCode">equal-always</code>. This would never be true of mutable data (because
there is the possibility of a future mutation), but it can be true of
immutable data that have the same structure and contents. In that
case, if they are always equal, then again they must be
<code data-lang="pyret" class="sourceCode">equal-now</code>.</p><p>However, the converses are not true.</p><p>If two data are <code data-lang="pyret" class="sourceCode">equal-now</code>, they may not be
<code data-lang="pyret" class="sourceCode">equal-always</code>: if they are mutable, a future mutation may change
the equality, as we have seen above. Similarly, two data may be
<code data-lang="pyret" class="sourceCode">equal-always</code> but not be <code data-lang="pyret" class="sourceCode">identical</code>, because they reside
at different heap addresses and are therefore truly different data.</p><p>In most languages, it is common to have two equality operators,
corresponding to <code data-lang="pyret" class="sourceCode">identical</code> (known as reference equality)
and <code data-lang="pyret" class="sourceCode">equal-now</code> (known as structural equality). Pyret is
rare in having a third operator, <code data-lang="pyret" class="sourceCode">equal-always</code>. For
most programs, this is in fact the most useful equality operator: it
is not overly bothered with details of aliasing, which can be
difficult to predict; at the same time it makes decisions that stand
the test of time, thereby forming a useful basis for various
optimizations (which may not even be conscious of their temporal
assumptions). This is why <code data-lang="pyret" class="sourceCode">is</code> in testing uses
<code data-lang="pyret" class="sourceCode">equal-always</code> by default, and forces users to explicitly pick a
different primitive if they want it.</p>&#13;
<h3 class="heading">19.6Â <a name="(part._.Space_and_.Time_.Complexity)"/>Space and Time Complexity<a href="#(part._.Space_and_.Time_.Complexity)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p><code data-lang="pyret" class="sourceCode">identical</code> always takes constant time. Indeed, some programs use
<code data-lang="pyret" class="sourceCode">identical</code> precisely because they want constant-time
equality, carefully structuring their program so that values that
should be considered equal are aliases to the same value. Of course,
maintaining this programming discipline is tricky.</p><p><code data-lang="pyret" class="sourceCode">equal-always</code> and <code data-lang="pyret" class="sourceCode">equal-now</code> both must traverse at least
the immutable part of data. Therefore, they take time proportional to
the smaller datum (because if the two data are of different size, they
must not be equal anyway, so there is no need to visit the extra
data). The difference is that <code data-lang="pyret" class="sourceCode">equal-always</code> reduces to
<code data-lang="pyret" class="sourceCode">identical</code> at references, thereby performing less computation
than <code data-lang="pyret" class="sourceCode">equal-now</code> would.</p>&#13;
<h3 class="heading">19.7Â <a name="(part._sem-identical)"/>What it Means to be Identical<a href="#(part._sem-identical)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>Return for a moment to the state where we have just defined the three
boxes [<a href="#%28elem._three-boxes%29" data-pltdoc="x">&lt;three-boxes&gt;</a>]. We could have written the
following:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">hold-b1-value = unbox-now(b1)
set-box-now(b1, hold-b1-value + 1)</code></pre><p>Now, we can compare the contents of the various boxes:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">b1-id-b2 = unbox-now(b1) == unbox-now(b2)
b1-id-b3 = unbox-now(b1) == unbox-now(b3)</code></pre><p>And at the end of performing comparisons, we can restore them:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">set-box-now(b1, hold-b1-value)</code></pre><p>Observe that <code data-lang="pyret" class="sourceCode">b1-id-b2</code> would be <code data-lang="pyret" class="sourceCode">false</code> but <code data-lang="pyret" class="sourceCode">b1-id-b3</code>
would be <code data-lang="pyret" class="sourceCode">true</code>. And notice that this would always be true when
the two expressions are identical, but not otherwise.</p><p>Thus, at the end there has been no change, but by making the change we
can check which values are and arenâ€™t aliases of others. In other
words, thisrepresents the essence of <code data-lang="pyret" class="sourceCode">identical</code>.</p><p>In practice, <code data-lang="pyret" class="sourceCode">identical</code> does not behave this way: it would be
too disruptive. It is also not the most efficient implementation
possible, when Pyret can simply check the memory addresses being the
same. Nevertheless, it does demonstrate the basic idea behind
<code data-lang="pyret" class="sourceCode">identical</code>: two values are <code data-lang="pyret" class="sourceCode">identical</code> precisely when, when
you make changes to one, you see the changes manifest on the â€œotherâ€
(i.e., there is really only one value, but with potentially multiple
names for it).</p>&#13;
<h3 class="heading">19.8Â <a name="(part._comp-func)"/>Comparing Functions<a href="#(part._comp-func)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h3><p>We havenâ€™t actually provided the full truth about equality because we
havenâ€™t discussed functions. Defining equality for functionsâ€”<wbr/>especially
extensional equality, namely whether two functions have the same
graph, i.e., for each input produce the same outputâ€”<wbr/>is complicated
(a euphemism for impossible) due to the Halting Problem.</p><p>Because of this, most languages have tended to use approximations for
function equality, most commonly reference equality. This is, however,
a very weak approximation: even if the exact same function text in the
same environment is allocated as two different closures, these would
not be reference-equal. At least when this is done as part of the
definition of <code data-lang="pyret" class="sourceCode">identical</code>, it makes sense; if other operators do
this, however, they are actively lying, which is something the
equality operators do not usually do.</p><p>There is one other approach we can take: simply disallow function
comparison. This is what Pyret does: all three equality operators
above will result in an error if you try to compare two
functions. (You can compare against just one function, however, and
you will get the answer <code data-lang="pyret" class="sourceCode">false</code>.) This ensures that the
languageâ€™s comparison operators are never trusted falsely.</p><p>Pyret did have the choice of allowing reference equality for
functions inside <code data-lang="pyret" class="sourceCode">identical</code> and erroring only in the other two
cases. Had it done so, however, it would have violated the chain of
implication above [<a href="#%28part._equality-hierarchy%29" data-pltdoc="x">A Hierarchy of Equality</a>]. The present design
is arguably more elegant. Programmers who do want to use reference
equality on functions can simply embed the functions inside a mutable
structure like boxes.</p><p>There is one problem with erroring when comparing two functions: a
completely generic procedure that compares two arbitrary values may
error if both of the values given are functions. Because this can
cause unpredictable program failure, Pyret offers a three-valued
version of each of the above three operators (<code data-lang="pyret" class="sourceCode">identical3</code>,
<code data-lang="pyret" class="sourceCode">equal-always3</code> and <code data-lang="pyret" class="sourceCode">equal-now3</code>), all of which return
<code data-lang="pyret" class="sourceCode">EqualityResult</code> values that correspond to truth, falsity, and
ignorance (returned in the case when both arguments are
functions). Programmers can use this in place of the Boolean-valued
comparison operators if they are uncertain about the types of the
parameters.</p>    
</body>
</html>