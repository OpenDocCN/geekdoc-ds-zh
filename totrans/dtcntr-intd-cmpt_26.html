<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>9.1Â From Pyret to PythonğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>9.1Â From Pyret to PythonğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/intro-python.html">https://dcic-world.org/2025-08-27/intro-python.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Expressions__.Functions__and_.Types%29" class="toclink" data-pltdoc="x">9.1.1<span class="hspace">Â </span>Expressions, Functions, and Types</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Returning_.Values_from_.Functions%29" class="toclink" data-pltdoc="x">9.1.2<span class="hspace">Â </span>Returning Values from Functions</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._testing-python%29" class="toclink" data-pltdoc="x">9.1.3<span class="hspace">Â </span>Examples and Test Cases</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.An_.Aside_on_.Numbers%29" class="toclink" data-pltdoc="x">9.1.4<span class="hspace">Â </span>An Aside on Numbers</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._conditionals-python%29" class="toclink" data-pltdoc="x">9.1.5<span class="hspace">Â </span>Conditionals</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._python-create-process-lists%29" class="toclink" data-pltdoc="x">9.1.6<span class="hspace">Â </span>Creating and Processing
Lists</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Filters__.Maps__and_.Friends%29" class="toclink" data-pltdoc="x">9.1.6.1<span class="hspace">Â </span>Filters, Maps, and Friends</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._python-data-with-components%29" class="toclink" data-pltdoc="x">9.1.7<span class="hspace">Â </span>Data with Components</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Accessing_.Fields_within_.Dataclasses%29" class="toclink" data-pltdoc="x">9.1.7.1<span class="hspace">Â </span>Accessing Fields within Dataclasses</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._python-traverse-lists%29" class="toclink" data-pltdoc="x">9.1.8<span class="hspace">Â </span>Traversing Lists</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._python-for-loops%29" class="toclink" data-pltdoc="x">9.1.8.1<span class="hspace">Â </span>Introducing <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">For</code></span> Loops</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements%29" class="toclink" data-pltdoc="x">9.1.8.2<span class="hspace">Â </span>An Aside on Order of Processing List Elements</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._python-funcs-produce-lists%29" class="toclink" data-pltdoc="x">9.1.8.3<span class="hspace">Â </span>Using <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">For</code></span> Loops in Functions that Produce Lists</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Summary__.The_.List-.Processing_.Template_for_.Python%29" class="toclink" data-pltdoc="x">9.1.8.4<span class="hspace">Â </span>Summary: The List-Processing Template for Python</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret%29" class="toclink" data-pltdoc="x">9.1.8.5<span class="hspace">Â </span><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> loops in Pyret</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â Â Â </span><a href="#%28part._.Variables_that_can_change%29" class="toclink" data-pltdoc="x">9.1.8.5.1<span class="hspace">Â </span>Variables that can change</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â Â Â </span><a href="#%28part._block_notation%29" class="toclink" data-pltdoc="x">9.1.8.5.2<span class="hspace">Â </span>block notation</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â Â Â </span><a href="#%28part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works%29" class="toclink" data-pltdoc="x">9.1.8.5.3<span class="hspace">Â </span>How <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> works</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â Â Â </span><a href="#%28part._.Testing_and_variables_that_can_change%29" class="toclink" data-pltdoc="x">9.1.8.5.4<span class="hspace">Â </span>Testing and variables that can change</a></p></td></tr></table><p>Through our work in Pyret to this point, weâ€™ve covered several core
programming skills: how to work with tables, how to design good
examples, the basics of creating datatypes, and how to work with the
fundamental computational building blocks of functions, conditionals,
and repetition (through <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>, as well as
recursion). Youâ€™ve got a solid initial toolkit, as well as a wide
world of other possible programs ahead of you!</p><p>But weâ€™re going to shift gears for a little while and show you how to
work in Python instead. Why?</p><p>Seeing how the same concepts play out in multiple languages can help
you distinguish core computational ideas from the notations and idioms
of specific languages. If you plan to write programs as part of your
professional work, youâ€™ll inevitably have to work in different
languages at different times: weâ€™re giving you a chance to practice
that skill in a controlled and gentle setting.</p><p>Why do we call this gentle? Because the notations in Pyret were
designed partly with this transition in mind. Youâ€™ll find many
similarities between Pyret and Python at a notational level, yet also
some interesting differences that highlight some philosophical
differences that underlie languages. The next set of programs that we
want to write (specifically, data-rich programs where the data must be
updated and maintained over time) fit nicely with certain features of
Python that you havenâ€™t seen in Pyret. <span class="refelem"><span class="refcolumn"><span class="refcontent">A future release will contain material that contrasts the strengths and weaknesses of the two languages.</span></span></span></p><p>We highlight the basic notational differences between Pyret and Python
by redoing some of our earlier code examples in Python.</p><section class="SsectionLevel4" id="section 9.1.1"><h4 class="heading">9.1.1<span class="stt">Â </span><a name="(part._.Expressions__.Functions__and_.Types)"/>Expressions, Functions, and Types<span class="button-group"><a href="#(part._.Expressions__.Functions__and_.Types)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Back in <a href="From_Repeated_Expressions_to_Functions.html#%28part._pen-cost-pyret%29" data-pltdoc="x">Functions Practice: Cost of pens</a>, we introduced the notation for functions and types
using an example of computing the cost of an order of pens. An order
consisted of a number of pens and a message to be printed on the
pens. Each pen cost 25 cents, plus 2 cents per character for the
message. Here was the original Pyret code:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String) -&gt; Number:
  doc: ```total cost for pens, each 25 cents
          plus 2 cents per message character```
  num-pens * (0.25 + (string-length(message) * 0.02))
end</code></pre></div></div><p>Hereâ€™s the corresponding Python code:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def pen_cost(num_pens: int, message: str) -&gt; float:
    """total cost for pens, each at 25 cents plus
       2 cents per message character"""
    return num_pens * (0.25 + (len(message) * 0.02))</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What notational differences do you see between the two versions?</p></blockquote></blockquote><p>Hereâ€™s a summary of the differences:</p><ul><li><p>Python uses <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def</code></span> instead of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun</code></span>.</p></li><li><p>Python uses underscores in names (like <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pen_cost</code></span>)
instead of hyphens as in Pyret.</p></li><li><p>The type names are written differently: Python uses <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">str</code></span>
and <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">int</code></span> instead of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">String</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>. In
addition, Python uses only a single colon before the type whereas
Pyret uses a double colon.</p></li><li><p>Python has different types for different kinds of numbers:
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">int</code></span> is for integers, while <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">float</code></span> is for decimals.
Pyret just used a single type (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>)
for all numbers.</p></li><li><p>Python doesnâ€™t label the documentation string (as Pyret does with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">doc:</code></span>).</p></li><li><p>There is no <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span> annotation in Python. Instead, Python
uses indentation to locate the end of an if/else statement, function, or
other multi-line construct.</p></li><li><p>Python labels the outputs of functions with <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">return</code></span>.</p></li></ul><p>These are minor differences in notation, which you will get used to as
you write more programs in Python.</p><p>There are differences beyond the notational ones. One that arises with
this sample program arises around how the language uses types. In
Pyret, if you put a type annotation on a parameter then pass it a
value of a different type, youâ€™ll get an error message. Python ignores
the type annotations (unless you bring in additional tools for
checking types). Python types are like notes for programmers, but they
arenâ€™t enforced when programs run.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p/><div class="SIntrapara">Convert the following <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">moon-weight</code></span> function from <a href="From_Repeated_Expressions_to_Functions.html#%28part._moon-weight-pyret%29" data-pltdoc="x">Functions Practice: Moon Weight</a> into Python:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun moon-weight(earth-weight :: Number) -&gt; Number:
  doc:" Compute weight on moon from weight on earth"
  earth-weight * 1/6
end</code></pre></div></div></div></blockquote></blockquote></section><section class="SsectionLevel4" id="section 9.1.2"><h4 class="heading">9.1.2<span class="stt">Â </span><a name="(part._.Returning_.Values_from_.Functions)"/>Returning Values from Functions<span class="button-group"><a href="#(part._.Returning_.Values_from_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In Pyret, a function body consisted of optional statements to name
intermediate values, followed by a single expression. The value of
that single expression is the result of calling the function. In
Pyret, every function produces a result, so there is no need to label
where the result comes from.</p><p>As we will see, Python is different: not all â€œfunctionsâ€ return
results (note the name change from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun</code></span> to
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def</code></span>).<span class="refelem"><span class="refcolumn"><span class="refcontent">In mathematics, functions have results by
definition. Programmers sometimes distinguish between the terms â€œfunctionâ€
and â€œprocedureâ€: both refer to parameterized computations, but only
the former returns a result to the surrounding computation. Some
programmers and languages do, however, use the term â€œfunctionâ€ more
loosely to cover both kinds of parameterized computations.</span></span></span>  Moreover,
the result isnâ€™t necessarily the last expression of the
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def</code></span>. In Python, the keyword <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">return</code></span> explicitly labels
the expression whose value serves as the result of the function.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Put these two definitions in a Python file.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def add1v1(x: int) -&gt; int:
    return x + 1

def add1v2(x: int) -&gt; int:
    x + 1</code></pre></div></div></div><p>At the Python prompt, call each function in turn. What do you notice
about the result from using each function?</p></blockquote></blockquote><p>Hopefully, you noticed that using <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">add1v1</code></span> displays an answer
after the prompt, while using <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">add1v2</code></span> does not. This
difference has consequences for composing functions.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Try evaluating the following two expressions at the Python prompt:
what happens in each case?</p><p><span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">3 * add1v1(4)</code></span></p><p><span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">3 * add1v2(4)</code></span></p></blockquote></blockquote><p>This example illustrates why <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">return</code></span> is essential in Python:
without it, no value is returned, which means you canâ€™t use the result
of a function within another expression. So what use is
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">add1v2</code></span> then? Hold that question; weâ€™ll return to it in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p></section><section class="SsectionLevel4" id="section 9.1.3"><h4 class="heading">9.1.3<span class="stt">Â </span><a name="(part._testing-python)"/>Examples and Test Cases<span class="button-group"><a href="#(part._testing-python)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In Pyret, we included examples with every function using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where:</code></span>
blocks. We also had the ability to write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:</code></span> blocks for more
extensive tests. As a reminder, here was the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pen-cost</code></span> code
including a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where:</code></span> block:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String) -&gt; Number:
  doc: ```total cost for pens, each 25 cents
       plus 2 cents per message character```
  num-pens * (0.25 + (string-length(message) * 0.02))
where:
  pen-cost(1, "hi") is 0.29
  pen-cost(10, "smile") is 3.50
end</code></pre></div></div><p>Python does not have a notion of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where:</code></span> blocks, or a
distinction between examples and tests. There are a couple of
different testing packages for Python; here we will use <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pytest</code></span>,
a standard lightweight framework that resembles the form of testing
that we did in Pyret.<span class="refelem"><span class="refcolumn"><span class="refcontent">How you set up pytest and your test
file contents will vary according to your Python IDE. We assume
instructors will provide separate instructions that align with their
tool choices.</span></span></span> To use <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pytest</code></span>, we put both examples
and tests in a separate function. Hereâ€™s an example of this for the
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pen_cost</code></span> function:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">import pytest

def pen_cost(num_pens: int, message: str) -&gt; float:
    """total cost for pens, each at 25 cents plus
       2 cents per message character"""
    return num_pens * (0.25 + (len(message) * 0.02))

def test_pens():
  assert pen_cost(1, "hi") == 0.29
  assert pen_cost(10, "smile") == 3.50</code></pre></div></div><p>Things to note about this code:</p><ul><li><p>Weâ€™ve imported <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pytest</code></span>, the lightweight Python testing
library.</p></li><li><p>The examples have moved into a function (here
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">test_pens</code></span>) that takes no inputs. Note that the names of
functions that contain test cases must have names that start with
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">test_</code></span> in order for <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pytest</code></span> to find them.</p></li><li><p/><div class="SIntrapara">In Python, individual tests have the form
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert EXPRESSION == EXPECTED_ANS</code></pre></div></div></div><div class="SIntrapara">rather than the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> form from Pyret.</div></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Add one more test to the Python code, corresponding to the Pyret test
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pen-cost(3, "wow") is 0.93</code></pre></div></div></div><div class="SIntrapara">Make sure to run the test.</div></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Did you actually try to run the test?</p></blockquote></blockquote><p>Whoa! Something weird happened: the test failed. Stop and think
about that: <span class="emph">the same test that worked in Pyret failed in
Python</span>. How can that be?</p></section><section class="SsectionLevel4" id="section 9.1.4"><h4 class="heading">9.1.4<span class="stt">Â </span><a name="(part._.An_.Aside_on_.Numbers)"/>An Aside on Numbers<span class="button-group"><a href="#(part._.An_.Aside_on_.Numbers)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>It turns out that different programming languages make different
decisions about how to represent and manage real (non-integer)
numbers. Sometimes, differences in these representations lead to
subtle quantitative differences in computed values. As a simple
example, letâ€™s look at two seemingly simple real numbers <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/2</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/3</code></span>. Hereâ€™s what we get when we type these two numbers at a
Pyret prompt:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0.5</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/3</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode"><span class="rationalNumber">0.<span class="rationalRepeat">3</span></span></code></pre></div></div></td></tr></table></div><p>If we type these same two numbers in a Python console, we instead get:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0.5</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/3</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0.3333333333333333</code></pre></div></div></td></tr></table></div><p>Notice that the answers look different for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/3</code></span>. As you may (or
may not!) recall from an earlier math class, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/3</code></span> is an example of a
non-terminating, repeating decimal. In plain terms, if we tried to
write out the exact value of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/3</code></span> in decimal form, we would need
to write an infinite sequence of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>. Mathematicians denote this
by putting a horizontal bar over the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>. This is the notation we
see in Pyret. Python, in contrast, writes out a partial sequence of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>s.</p><p>Underneath this distinction lies some interesting details about
representing numbers in computers. Computers donâ€™t have infinite space
to store numbers (or anything else, for that matter): when a program
needs to work with a non-terminating decimal, the underlying language
can either:</p><ul><li><p>approximate the number (by chopping off the infinite sequence
of digits at some point), then work only with the approximated value
going forward, or</p></li><li><p>store additional information about the number that may enable doing
more precise computation with it later (though there are always some
numbers that cannot be represented exactly in finite space).</p></li></ul><p>Python takes the first approach. As a result, computations with the
approximated values sometimes yield approximated results. This is what
happens with our new <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pen_cost</code></span> test case. While
mathematically, the computation should result in <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">0.93</code></span>, the
approximations yield <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">0.9299999999999999</code></span> instead.</p><p>So how do we write tests in this situation? We need to tell Python
that the answer should be â€œcloseâ€ to <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">0.93</code></span>, within the error
range of approximations. Hereâ€™s what that looks like:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert pen_cost(3, "wow") == pytest.approx(0.93)</code></pre></div></div></div><div class="SIntrapara">We wrapped the exact answer we wanted in <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pytest.approx</code></span>, to
indicate that weâ€™ll accept any answer that is nearly the value we
specified. You can control the number of decimal points of precision
if you want to, but the default of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Â± 2.3e-06</code></span> often suffices.</div></section><section class="SsectionLevel4" id="section 9.1.5"><h4 class="heading">9.1.5<span class="stt">Â </span><a name="(part._conditionals-python)"/>Conditionals<span class="button-group"><a href="#(part._conditionals-python)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Continuing with our original <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pen_cost</code></span> example, hereâ€™s the
Python version of the function that computed shipping costs on an
order:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def add_shipping(order_amt: float) -&gt; float:
    """increase order price by costs for shipping"""
    if order_amt == 0:
      return 0
    elif order_amt &lt;= 10:
      return order_amt + 4
    elif (order_amt &gt; 10) and (order_amt &lt; 30):
      return order_amt + 8
    else:
      return order_amt + 12</code></pre></div></div><p>The main difference to notice here is that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">else if</code></span> is written
as the single-word <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elif</code></span> in Python. We use <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">return</code></span> to
mark the functionâ€™s results in each branch of the conditional.
Otherwise, the conditional constructs are quite similar across the
two languages.</p><p>You may have noticed that Python does not require an explicit
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span> annotation on <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span>-expressions or functions. Instead,
Python looks at the indentation of your code to determine when a
construct has ended. For example, in the code sample for
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pen_cost</code></span> and <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">test_pens</code></span>, Python determines that the
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pen_cost</code></span> function has ended because it detects a new
definition (for <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">test_pens</code></span>) at the left edge of the program
text. The same principle holds for ending conditionals.</p><p>Weâ€™ll return to this point about indentation, and see more examples,
as we work more with Python.</p></section><section class="SsectionLevel4" id="section 9.1.6"><h4 class="heading">9.1.6<span class="stt">Â </span><a name="(part._python-create-process-lists)"/>Creating and Processing
Lists<span class="button-group"><a href="#(part._python-create-process-lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>As an example of lists, letâ€™s assume weâ€™ve been playing a game that
involves making words out of a collection of letters. In Pyret, we
could have written a sample word list as follows:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">words = [list: "banana", "bean", "falafel", "leaf"]</code></pre></div></div><p>In Python, this definition would look like:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">words = ["banana", "bean", "falafel", "leaf"]</code></pre></div></div><p>The only difference here is that Python does not use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list:</code></span>
label that is needed in Pyret.</p><section class="SsectionLevel5" id="section 9.1.6.1"><h5 class="heading">9.1.6.1<span class="stt">Â </span><a name="(part._.Filters__.Maps__and_.Friends)"/>Filters, Maps, and Friends<span class="button-group"><a href="#(part._.Filters__.Maps__and_.Friends)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>When we first learned about lists in Pyret, we started with common
built-in functions such as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member</code></span>
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length</code></span>. We also saw the use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lambda</code></span> to help us use
some of these functions concisely. These same functions, including
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lambda</code></span>, also exist in Python. Here are some samples (<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">#</code></span> is the comment character in Python):</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">words = ["banana", "bean", "falafel", "leaf"]

# filter and member
words_with_b = list(filter(lambda wd: "b" in wd, words))
# filter and length
short_words = list(filter(lambda wd: len(wd) &lt; 5, words))
# map and length
word_lengths = list(map(len, words))</code></pre></div></div><p>Note that you have to wrap calls to <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">filter</code></span> (and <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">map</code></span>)
with a use of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">list()</code></span>. Internally, Python has these functions
return a type of data that we havenâ€™t yet discussed (and donâ€™t
need). Using <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">list</code></span> converts the returned data into a list. If
you omit the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">list</code></span>, you wonâ€™t be able to chain certain
functions together. For example, if we tried to compute the length of
the result of a <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">map</code></span> without first converting to a
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">list</code></span>, weâ€™d get an error:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">len(map(len,b))</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">TypeError: object of type 'map' has no len()</code></pre></div></div></td></tr></table><p>Donâ€™t worry if this error message makes no sense at the moment (we
havenâ€™t yet learned what an â€œobjectâ€ is). The point is that if you see
an error like this while using the result of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">filter</code></span> or
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">map</code></span>, you likely forgot to wrap the result in <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">list</code></span>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Practice Pythonâ€™s list functions by writing expressions for the following
problems. Use only the list functions we have shown you so far.</p><ul><li><p>Given a list of numbers, convert it to a list of strings <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">"pos"</code></span>, <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">"neg"</code></span>, <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">"zero"</code></span>, based on the sign of each number.</p></li><li><p>Given a list of strings, is the length of any string equal to 5?</p></li><li><p>Given a list of numbers, produce a list of the even numbers between 10 and 20 from that list.</p></li></ul></blockquote></blockquote><p>Weâ€™re intentionally focusing on computations that use Pythonâ€™s built-in
functions for processing lists, rather than showing you how to write
you own (as we did with recursion in Pyret). While you can write
recursive functions to process lists in Pyret, a different style of
program is more conventional for that purpose. Weâ€™ll look at that in
the chapter on <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p></section></section><section class="SsectionLevel4" id="section 9.1.7"><h4 class="heading">9.1.7<span class="stt">Â </span><a name="(part._python-data-with-components)"/>Data with Components<span class="button-group"><a href="#(part._python-data-with-components)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>An analog to a Pyret data definition (without variants) is called a <span class="emph">dataclass</span> in
Python.<span class="refelem"><span class="refcolumn"><span class="refcontent">Those experienced with Python may wonder why we are
using dataclasses instead of dictionaries or raw classes. Compared to
dictionaries, dataclasses allow the use of type hints and capture that
our data has a fixed collection of fields. Compared to raw classes,
dataclasses generate a lot of boilerplate code that makes them much
lighterweight than raw classes.</span></span></span> Hereâ€™s an example of a todo-list
datatype in Pyret and its corresponding Python code:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode"># a todo item in Pyret
data ToDoItemData:
  | todoItem(descr :: String,
             due :: Date,
             tags :: List&lt;String&gt;
end</code></pre></div></div><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">------------------------------------------
# the same todo item in Python

# to allow use of dataclasses
from dataclasses import dataclass
# to allow dates as a type (in the ToDoItem)
from datetime import date

@dataclass
class ToDoItem:
    descr: str
    due: date
    tags: list

# a sample list of ToDoItem
myTD = [ToDoItem("buy milk", date(2020, 7, 27), ["shopping", "home"]),
        ToDoItem("grade hwk", date(2020, 7, 27), ["teaching"]),
        ToDoItem("meet students", date(2020, 7, 26), ["research"])
       ]</code></pre></div></div><p>Things to note:</p><ul><li><p>There is a single name for the type and the constructor, rather
than separate names as we had in Pyret.</p></li><li><p>There are no commas between field names (but each has to be on
its own line in Python)</p></li><li><p>There is no way to specify the type of the contents of the list
in Python (at least, not without using more advance packages for
writing types)</p></li><li><p>The <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">@dataclass</code></span> annotation is needed before
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">class</code></span>.</p></li><li><p>Dataclasses donâ€™t support creating datatypes with multiple
variants, like we did frequently in Pyret. Doing that needs more
advanced concepts than we will cover in this book.</p></li></ul><section class="SsectionLevel5" id="section 9.1.7.1"><h5 class="heading">9.1.7.1<span class="stt">Â </span><a name="(part._.Accessing_.Fields_within_.Dataclasses)"/>Accessing Fields within Dataclasses<span class="button-group"><a href="#(part._.Accessing_.Fields_within_.Dataclasses)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>In Pyret, we extracted a field from structured data by using a dot
(period) to â€œdig intoâ€ the datum and access the field. The same
notation works in Python:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">travel = ToDoItem("buy tickets", date(2020, 7, 30), ["vacation"])</code></pre></div></div></blockquote></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">travel.descr</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"buy tickets"</code></pre></div></div></td></tr></table></div></section></section><section class="SsectionLevel4" id="section 9.1.8"><h4 class="heading">9.1.8<span class="stt">Â </span><a name="(part._python-traverse-lists)"/>Traversing Lists<span class="button-group"><a href="#(part._python-traverse-lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><section class="SsectionLevel5" id="section 9.1.8.1"><h5 class="heading">9.1.8.1<span class="stt">Â </span><a name="(part._python-for-loops)"/>Introducing <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">For</code></span> Loops<span class="button-group"><a href="#(part._python-for-loops)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">In Pyret, we typically write recursive functions to compute summary values over
lists. As a reminder, hereâ€™s a Pyret function that sums the numbers in
a list:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(numlist :: List&lt;Number&gt;) -&gt; Number:
  cases (List) numlist:
    | empty =&gt; 0
    | link(fst, rst) =&gt; fst + sum-list(rst)
  end
end</code></pre></div></div></div><p>In Python, it is unusual to break a list into its first and rest
components and process the rest recursively. Instead, we use a construct called a <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> to
visit each element of a list in turn. Hereâ€™s the form of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span>,
using a concrete (example) list of odd numbers:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for num in [5, 1, 7, 3]:
   # do something with num</code></pre></div></div><p/><div class="SIntrapara">The name <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></span> here is of our choosing, just as with the names
of parameters to a function in Pyret.  When a <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> loop
evaluates, each item in the list is referred to as <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></span> in
turn. Thus, this <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> example is equivalent to writing the
following:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># do something with 5
# do something with 1
# do something with 7
# do something with 3</code></pre></div></div></div><div class="SIntrapara">The <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> construct saves us from writing the common code
multiple times, and also handles the fact that the lists we are
processing can be of arbitrary length (so we canâ€™t predict how many
times to write the common code).</div><p>Letâ€™s now use <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> to compute the running sum of a list. Weâ€™ll
start by figuring out the repeated computation with our concrete list
again. At first, letâ€™s express the repeated computation just in
prose. In Pyret, our repeated computation was along the lines of â€œadd
the first item to the sum of the rest of the itemsâ€. Weâ€™ve already
said that we cannot easily access the â€œrest of the itemsâ€ in Python,
so we need to rephrase this. Hereâ€™s an alternative:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># set a running total to 0
# add 5 to the running total
# add 1 to the running total
# add 7 to the running total
# add 3 to the running total</code></pre></div></div></div><div class="SIntrapara">Note that this framing refers not to the â€œrest of the computationâ€,
but rather to the computation that has happened so far (the â€œrunning
totalâ€). If you happened to work through the chapter on <a href="processing-lists.html#%28part._running-sum-eg-code%29" data-pltdoc="x"><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>: Examples and Code</a>, this framing might be familiar.</div><p>Letâ€™s convert this prose sketch to code by replacing each line of the
sketch with concrete code. We do this by setting up a variable named
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></span> and updating its value for each element.</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = run_total + 5
run_total = run_total + 1
run_total = run_total + 7
run_total = run_total + 3</code></pre></div></div></div><div class="SIntrapara">This idea that you can give a new value to an existing variable name
is something we havenâ€™t seen before. In fact, when we first saw how to
name values (in <a href="Naming_Values.html#%28part._program-directory%29" data-pltdoc="x">The Program Directory</a>), we explicitly said that
Pyret doesnâ€™t let
you do this (at least, not with the constructs that we showed you). Python does. Weâ€™ll explore the consequences of this ability in
more depth shortly (in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>). For now, letâ€™s just use that ability so we can
learn the pattern for traversing lists. First, letâ€™s collapse the repeated lines of code
into a single use of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span>:</div><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
for num in [5, 1, 7, 3]:
   run_total = run_total + num</code></pre></div></div></div><div class="SIntrapara">This code works fine for a specific list, but our Pyret version took
the list to sum as a parameter to a function. To achieve this in
Python, we wrap the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> in a function as we have done for
other examples earlier in this chapter. This is the final version.</div><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def sum_list(numlist : list) -&gt; float:
    """sum a list of numbers"""
    run_total = 0
    for num in numlist:
        run_total = run_total + num
    return(run_total)</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write a set of tests for <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">sum_list</code></span> (the Python version).</p></blockquote></blockquote><p>Now that the Python version is done, letâ€™s compare it to the original Pyret
version:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(numlist :: List&lt;Number&gt;) -&gt; Number:
  cases (List) numlist:
    | empty =&gt; 0
    | link(fst, rst) =&gt; fst + sum-list(rst)
  end
end</code></pre></div></div><p>Here are some things to notice about the two pieces of code:</p><ul><li><p>The Python version needs a variable (here <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></span>) to
hold the result of the computation as we build it up while traversing
(working through) the list.</p></li><li><p>The initial value of that variable is the answer we returned in
the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> case in Pyret.</p></li><li><p>The computation in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> case of the Pyret function is
used to update that variable in the body of the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span>.</p></li><li><p>After the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> has finished processing all items in the
list, the Python version returns the value in the variable as the
result of the function.</p></li></ul></section><section class="SsectionLevel5" id="section 9.1.8.2"><h5 class="heading">9.1.8.2<span class="stt">Â </span><a name="(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)"/>An Aside on Order of Processing List Elements<span class="button-group"><a href="#(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Thereâ€™s another subtlety here if we consider how the two programs run:
the Python version sums the elements from left to right, whereas
the Pyret version sums them right to left. Concretely, the sequence of
values of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></span> are computed as:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = 0 + 5
run_total = 5 + 1
run_total = 6 + 7
run_total = 13 + 3</code></pre></div></div></div><div class="SIntrapara">In contrast, the Pyret version unrolls as:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum_list([list: 5, 1, 7, 3])
5 + sum_list([list: 1, 7, 3])
5 + 1 + sum_list([list: 7, 3])
5 + 1 + 7 + sum_list([list: 3])
5 + 1 + 7 + 3 + sum_list([list:])
5 + 1 + 7 + 3 + 0
5 + 1 + 7 + 3
5 + 1 + 10
5 + 11
16</code></pre></div></div></div><div class="SIntrapara">As a reminder, the Pyret version did this because the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span> in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> case can only reduce to an answer once the sum of the rest
of the list has been computed. Even though we as humans see the chain
of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span> operations in each line of the Pyret unrolling, Pyret sees
only the expression <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fst + sum-list(rst)</code></span>, which requires the
function call to finish before the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span> executes.</div><p>In the case of summing a list, we donâ€™t notice the difference between
the two versions because the sum is the same whether we compute it
left-to-right or right-to-left. In other functions we write, this
difference may start to matter.</p></section><section class="SsectionLevel5" id="section 9.1.8.3"><h5 class="heading">9.1.8.3<span class="stt">Â </span><a name="(part._python-funcs-produce-lists)"/>Using <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">For</code></span> Loops in Functions that Produce Lists<span class="button-group"><a href="#(part._python-funcs-produce-lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Letâ€™s practice using <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> loops on another function that
traverses lists, this time one that produces a list. Specifically,
letâ€™s write a program that takes a list of strings and produces a list
of words within that list that contain the letter <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">"z"</code></span>.</p><p>As in our <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">sum_list</code></span> function, we will need a variable to store
the resulting list as we build it up. The following code calls this
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">zlist</code></span>. The code also shows how to use <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">in</code></span> to check
whether a character is in a string (it also works for checking whether
an item is in a list) and how to add an element to the end of a list
(<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">append</code></span>).</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def all_z_words(wordlist : list) -&gt; list:
    """produce list of words from the input that contain z"""
    zlist = [] # start with an empty list
    for wd in wordlist:
        if "z" in wd:
            zlist = [wd] + zlist
    return(zlist)</code></pre></div></div></div><div class="SIntrapara">This code follows the structure of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">sum_list</code></span>, in that we
update the value of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">zlist</code></span> using an expression similar to what
we would have used in Pyret. <span class="refelem"><span class="refcolumn"><span class="refcontent">For those with prior Python
experience who would have used <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">zlist.append</code></span> here, hold that
thought. We will get there in <a href="mutable-lists.html" data-pltdoc="x">Mutable Lists</a>.</span></span></span></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write tests for <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">all_z_words</code></span>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a second version of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">all_z_words</code></span> using
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">filter</code></span>. Be sure to write tests for it!</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Contrast these two versions and the corresponding tests. Did you
notice anything interesting?</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 9.1.8.4"><h5 class="heading">9.1.8.4<span class="stt">Â </span><a name="(part._.Summary__.The_.List-.Processing_.Template_for_.Python)"/>Summary: The List-Processing Template for Python<span class="button-group"><a href="#(part._.Summary__.The_.List-.Processing_.Template_for_.Python)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Just as we had a template for writing list-processing functions in
Pyret, there is a corresponding template in Python based on
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> loops. As a reminder, that pattern is as follow:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def func(lst: list):
  result = ...  # what to return if the input list is empty
  for item in lst:
    # combine item with the result so far
    result = ... item ... result
  return result</code></pre></div></div><p>Keep this template in mind as you learn to write functions over lists
in Python.</p></section><section class="SsectionLevel5" id="section 9.1.8.5"><h5 class="heading">9.1.8.5<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> loops in Pyret<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><span class="refelem"><span class="refcolumn"><span class="refcontent">This section can be read
without reading the rest of this chapter, so if you have been directed to it
before being introduced to Python, do not worry! While the content below mirrors
similar constructs that exist in Python, it is introduced on its own.</span></span></span></p><p>The previous sections introduced <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> loops in Python, and showed a
template for processing lists with them. Pyret can
do similar, using the following pattern:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun func(lst :: List) block:
  var result = ...  # what to return if the input list is empty
  for each(item from lst):
    # combine item with the result so far
    result := ... item ... result
  end
  result
end</code></pre></div></div><p>There are a few new language features used in this example, introduced in the
following several sections.</p><section class="SsectionLevel6" id="section 9.1.8.5.1"><h5 class="heading">9.1.8.5.1<span class="stt">Â </span><a name="(part._.Variables_that_can_change)"/>Variables that can change<span class="button-group"><a href="#(part._.Variables_that_can_change)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>First, note that we introduce the variable <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">result</code></span> with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var result</code></span>
â€“ this means that it can <span class="emph">vary</span>, which is important for the use with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span>.</p><p>By default, all variables in the program directory can never be changed. i.e.,
if I define a variable <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x</code></span>, I can not redefine it later:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x = 10
# ...
x = 20 # produces shadowing error</code></pre></div></div><p>If we do want to change (or mutate) a variable in the directory later, we can, but we must
declare the variable can change â€“ as in, when we define it, rather than writing
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x = 10</code></span>, we must write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var x = 10</code></span>. Then, when we want to
<span class="emph">update</span> it, we can do so with the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">:=</code></span> operator, as is done in the template above.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var x = 10
# ... x points to 10 in directory
x := 20
# ... x now points to 20 in directory</code></pre></div></div><p>Note that trying to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">:=</code></span> on a variable that was not declared using
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var</code></span> will produce an error, and variables can still only ever be declared
once (whether with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var x = ...</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x = ...</code></span>).</p></section><section class="SsectionLevel6" id="section 9.1.8.5.2"><h5 class="heading">9.1.8.5.2<span class="stt">Â </span><a name="(part._block_notation)"/>block notation<span class="button-group"><a href="#(part._block_notation)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Another new language feature shown in these examples is that since Pyret
functions by default expect only a single (non-definition) expression, we have
to add the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">block</code></span> annotation at the top, indicating that the body of the
function is multiple expressions, with the final one being what the function
evaluates to.</p><p>As another example, if we tried to write:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function():
  1
  2
end</code></pre></div></div><p>Pyret would (rightly) error â€“ since the function returns the last expression in
its body, the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> will be ignored â€“ and is most likely a mistake! Perhaps
the goal was to write:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function():
  1 + 2
end</code></pre></div></div><p>However, since a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> expression exists only to modify a variable,
functions that contain them <span class="emph">will</span> always have multiple expressions, and so
we need to communicate to Pyret that this is not a mistake. Adding <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">block</code></span>
before the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">:</code></span> that begins the function (or, in general, wrapping any
expressions in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">block:</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span>) communicates to Pyret that we
understand that there are multiple expressions, and just want to evaluate to the
last one. So, if we truly wanted to write a function as our first example, we
could do that with:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function() block:
  1
  2
end</code></pre></div></div></section><section class="SsectionLevel6" id="section 9.1.8.5.3"><h5 class="heading">9.1.8.5.3<span class="stt">Â </span><a name="(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)"/>How <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> works<span class="button-group"><a href="#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>A <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> expression runs its body once for each element in the input
list, adding an entry to the program directory for each element as it goes. It
does not produce any value directly, so much instead rely on modifying variables
(described above) to produce a computation.</p><p>Consider summing a list of numbers. We could write a function that does this,
following our pattern, as:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(lst :: List) block:
  var run_total = 0
  for each(item from lst):
    run_total := item + run_total
  end
  run_total
where:
  sum-list([list: 5, 1, 7, 3]) is 16
end</code></pre></div></div><p>On the concrete test input <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 5, 1, 7, 3]</code></span>, the loop runs four times,
once with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">item</code></span> set to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">5</code></span>, then with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">item</code></span> set to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>,
then with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">item</code></span> set to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span>, and finally with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">item</code></span> set to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>.</p><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> construct saves us from writing the common code
multiple times, and also handles the fact that the lists we are
processing can be of arbitrary length (so we canâ€™t predict how many
times to write the common code). Thus, what happens is:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = run_total + 5
run_total = run_total + 1
run_total = run_total + 7
run_total = run_total + 3</code></pre></div></div></section><section class="SsectionLevel6" id="section 9.1.8.5.4"><h5 class="heading">9.1.8.5.4<span class="stt">Â </span><a name="(part._.Testing_and_variables_that_can_change)"/>Testing and variables that can change<span class="button-group"><a href="#(part._.Testing_and_variables_that_can_change)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>We intentionally showed a very particular pattern of using variables that can
change. While there are other uses (explored in part in
<a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>), a main reason to stay with this particular
template is the difficulty in testing and correspondingly, understanding, code
that uses them in other ways.</p><p>In particular, note that the pattern means that we never define a variables that
can change <span class="emph">outside</span> a function, which means it can never be used by
different functions, or multiple function calls. Each time the function runs, a
new variable is created, it is modified in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> loop, and then
the value is returned, and the entry in the program directory is removed.</p><p>Consider what happens if we donâ€™t follow our pattern. Letâ€™s say we had the
following problem:</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Given a list of numbers, return the prefix of the list (i.e., all
elements, starting from the beginning) that sums to less than 100.</p></blockquote></blockquote><p>Having learned about mutable variables, but not following the pattern, you might
come up with code like this:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var count = 0

fun prefix-under-100(l :: List) -&gt; List:
  var output = [list: ]
  for each(elt from l):
    count := count + elt
    when (count &lt; 100):
      output := output + [list: elt]
    end
  end
end</code></pre></div></div><p>Now, this might seem reasonable â€“ weâ€™ve used a new construct, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">when</code></span>,
which is an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression that has no <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">else</code></span> â€“ this only makes
sense to do inside of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> block, where we donâ€™t need a value as a
result. It is equivalent to:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if (count &lt; 100):
  output := output + [list: elt]
else:
  nothing
end</code></pre></div></div><p>Where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nothing</code></span> is a value that is used in Pyret to indicate that there is
no particular value of importance.</p><p>But what happens when we use this function?</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
    prefix-under-100([list: 20, 30, 40]) is [list: 20, 30, 40]
    prefix-under-100([list: 80, 20, 10]) is [list: 80]
end</code></pre></div></div><p>The first two tests pass, but the last one doesnâ€™t. Why? If we run the first one
again, things are even more confusing, i.e., if instead of the above, we ran
this <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check</code></span> block:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
    prefix-under-100([list: 20, 30, 40]) is [list: 20, 30, 40]
    prefix-under-100([list: 80, 20, 10]) is [list: 80]
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
end</code></pre></div></div><p>Now the test that passed at first no longer passes!</p><p>What we are seeing is that since the variable is outside the function, it is
<span class="emph">shared</span> across different calls to the function. It is added to the program
directory once, and each time we call <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">prefix-under-100</code></span>, the program
directory entry is changed, but it is never reset.</p><p>Intentionally, all other uses of mutation have been on directory entries that
were created only for the body of the function, which meant that when the
function exited, they were removed. But now, we are always modifying the single
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">count</code></span> variable. This means that every time we call
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">prefix-under-100</code></span>, it behaves differently, because it not only do we have
to understand the code in the body of the function, we have to know the current
value of the count variable, which is not something we can figure out by just
looking at the code!</p><p>Functions that behave like this are said to have "side effects", and they are
much harder to test and much harder to understand, and as a result, much more
likely to have bugs! While the above example is wrong in a relatively
straightforward way, side effects can cause extremely subtle bugs that only
happen when functions are called in particular orders â€“ orders that may only
arised in very specific situations, making them hard to understand or reproduce.</p><p>While there are some places where doing this is necessary, almost all code can
be written without side effects, and will be much more reliable. We will explore
some cases where we might want to do this in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p></section></section></section>&#13;
<h4 class="heading">9.1.1<span class="stt">Â </span><a name="(part._.Expressions__.Functions__and_.Types)"/>Expressions, Functions, and Types<span class="button-group"><a href="#(part._.Expressions__.Functions__and_.Types)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Back in <a href="From_Repeated_Expressions_to_Functions.html#%28part._pen-cost-pyret%29" data-pltdoc="x">Functions Practice: Cost of pens</a>, we introduced the notation for functions and types
using an example of computing the cost of an order of pens. An order
consisted of a number of pens and a message to be printed on the
pens. Each pen cost 25 cents, plus 2 cents per character for the
message. Here was the original Pyret code:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String) -&gt; Number:
  doc: ```total cost for pens, each 25 cents
          plus 2 cents per message character```
  num-pens * (0.25 + (string-length(message) * 0.02))
end</code></pre></div></div><p>Hereâ€™s the corresponding Python code:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def pen_cost(num_pens: int, message: str) -&gt; float:
    """total cost for pens, each at 25 cents plus
       2 cents per message character"""
    return num_pens * (0.25 + (len(message) * 0.02))</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What notational differences do you see between the two versions?</p></blockquote></blockquote><p>Hereâ€™s a summary of the differences:</p><ul><li><p>Python uses <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def</code></span> instead of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun</code></span>.</p></li><li><p>Python uses underscores in names (like <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pen_cost</code></span>)
instead of hyphens as in Pyret.</p></li><li><p>The type names are written differently: Python uses <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">str</code></span>
and <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">int</code></span> instead of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">String</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>. In
addition, Python uses only a single colon before the type whereas
Pyret uses a double colon.</p></li><li><p>Python has different types for different kinds of numbers:
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">int</code></span> is for integers, while <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">float</code></span> is for decimals.
Pyret just used a single type (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>)
for all numbers.</p></li><li><p>Python doesnâ€™t label the documentation string (as Pyret does with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">doc:</code></span>).</p></li><li><p>There is no <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span> annotation in Python. Instead, Python
uses indentation to locate the end of an if/else statement, function, or
other multi-line construct.</p></li><li><p>Python labels the outputs of functions with <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">return</code></span>.</p></li></ul><p>These are minor differences in notation, which you will get used to as
you write more programs in Python.</p><p>There are differences beyond the notational ones. One that arises with
this sample program arises around how the language uses types. In
Pyret, if you put a type annotation on a parameter then pass it a
value of a different type, youâ€™ll get an error message. Python ignores
the type annotations (unless you bring in additional tools for
checking types). Python types are like notes for programmers, but they
arenâ€™t enforced when programs run.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p/><div class="SIntrapara">Convert the following <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">moon-weight</code></span> function from <a href="From_Repeated_Expressions_to_Functions.html#%28part._moon-weight-pyret%29" data-pltdoc="x">Functions Practice: Moon Weight</a> into Python:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun moon-weight(earth-weight :: Number) -&gt; Number:
  doc:" Compute weight on moon from weight on earth"
  earth-weight * 1/6
end</code></pre></div></div></div></blockquote></blockquote>&#13;
<h4 class="heading">9.1.2<span class="stt">Â </span><a name="(part._.Returning_.Values_from_.Functions)"/>Returning Values from Functions<span class="button-group"><a href="#(part._.Returning_.Values_from_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In Pyret, a function body consisted of optional statements to name
intermediate values, followed by a single expression. The value of
that single expression is the result of calling the function. In
Pyret, every function produces a result, so there is no need to label
where the result comes from.</p><p>As we will see, Python is different: not all â€œfunctionsâ€ return
results (note the name change from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun</code></span> to
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def</code></span>).<span class="refelem"><span class="refcolumn"><span class="refcontent">In mathematics, functions have results by
definition. Programmers sometimes distinguish between the terms â€œfunctionâ€
and â€œprocedureâ€: both refer to parameterized computations, but only
the former returns a result to the surrounding computation. Some
programmers and languages do, however, use the term â€œfunctionâ€ more
loosely to cover both kinds of parameterized computations.</span></span></span>  Moreover,
the result isnâ€™t necessarily the last expression of the
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def</code></span>. In Python, the keyword <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">return</code></span> explicitly labels
the expression whose value serves as the result of the function.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Put these two definitions in a Python file.
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def add1v1(x: int) -&gt; int:
    return x + 1

def add1v2(x: int) -&gt; int:
    x + 1</code></pre></div></div></div><p>At the Python prompt, call each function in turn. What do you notice
about the result from using each function?</p></blockquote></blockquote><p>Hopefully, you noticed that using <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">add1v1</code></span> displays an answer
after the prompt, while using <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">add1v2</code></span> does not. This
difference has consequences for composing functions.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Try evaluating the following two expressions at the Python prompt:
what happens in each case?</p><p><span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">3 * add1v1(4)</code></span></p><p><span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">3 * add1v2(4)</code></span></p></blockquote></blockquote><p>This example illustrates why <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">return</code></span> is essential in Python:
without it, no value is returned, which means you canâ€™t use the result
of a function within another expression. So what use is
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">add1v2</code></span> then? Hold that question; weâ€™ll return to it in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p>&#13;
<h4 class="heading">9.1.3<span class="stt">Â </span><a name="(part._testing-python)"/>Examples and Test Cases<span class="button-group"><a href="#(part._testing-python)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In Pyret, we included examples with every function using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where:</code></span>
blocks. We also had the ability to write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:</code></span> blocks for more
extensive tests. As a reminder, here was the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pen-cost</code></span> code
including a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where:</code></span> block:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String) -&gt; Number:
  doc: ```total cost for pens, each 25 cents
       plus 2 cents per message character```
  num-pens * (0.25 + (string-length(message) * 0.02))
where:
  pen-cost(1, "hi") is 0.29
  pen-cost(10, "smile") is 3.50
end</code></pre></div></div><p>Python does not have a notion of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where:</code></span> blocks, or a
distinction between examples and tests. There are a couple of
different testing packages for Python; here we will use <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pytest</code></span>,
a standard lightweight framework that resembles the form of testing
that we did in Pyret.<span class="refelem"><span class="refcolumn"><span class="refcontent">How you set up pytest and your test
file contents will vary according to your Python IDE. We assume
instructors will provide separate instructions that align with their
tool choices.</span></span></span> To use <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pytest</code></span>, we put both examples
and tests in a separate function. Hereâ€™s an example of this for the
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pen_cost</code></span> function:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">import pytest

def pen_cost(num_pens: int, message: str) -&gt; float:
    """total cost for pens, each at 25 cents plus
       2 cents per message character"""
    return num_pens * (0.25 + (len(message) * 0.02))

def test_pens():
  assert pen_cost(1, "hi") == 0.29
  assert pen_cost(10, "smile") == 3.50</code></pre></div></div><p>Things to note about this code:</p><ul><li><p>Weâ€™ve imported <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pytest</code></span>, the lightweight Python testing
library.</p></li><li><p>The examples have moved into a function (here
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">test_pens</code></span>) that takes no inputs. Note that the names of
functions that contain test cases must have names that start with
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">test_</code></span> in order for <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pytest</code></span> to find them.</p></li><li><p/><div class="SIntrapara">In Python, individual tests have the form
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert EXPRESSION == EXPECTED_ANS</code></pre></div></div></div><div class="SIntrapara">rather than the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> form from Pyret.</div></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><div class="SIntrapara">Add one more test to the Python code, corresponding to the Pyret test
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pen-cost(3, "wow") is 0.93</code></pre></div></div></div><div class="SIntrapara">Make sure to run the test.</div></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Did you actually try to run the test?</p></blockquote></blockquote><p>Whoa! Something weird happened: the test failed. Stop and think
about that: <span class="emph">the same test that worked in Pyret failed in
Python</span>. How can that be?</p>&#13;
<h4 class="heading">9.1.4<span class="stt">Â </span><a name="(part._.An_.Aside_on_.Numbers)"/>An Aside on Numbers<span class="button-group"><a href="#(part._.An_.Aside_on_.Numbers)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>It turns out that different programming languages make different
decisions about how to represent and manage real (non-integer)
numbers. Sometimes, differences in these representations lead to
subtle quantitative differences in computed values. As a simple
example, letâ€™s look at two seemingly simple real numbers <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/2</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/3</code></span>. Hereâ€™s what we get when we type these two numbers at a
Pyret prompt:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0.5</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/3</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode"><span class="rationalNumber">0.<span class="rationalRepeat">3</span></span></code></pre></div></div></td></tr></table></div><p>If we type these same two numbers in a Python console, we instead get:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0.5</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/3</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0.3333333333333333</code></pre></div></div></td></tr></table></div><p>Notice that the answers look different for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/3</code></span>. As you may (or
may not!) recall from an earlier math class, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/3</code></span> is an example of a
non-terminating, repeating decimal. In plain terms, if we tried to
write out the exact value of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/3</code></span> in decimal form, we would need
to write an infinite sequence of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>. Mathematicians denote this
by putting a horizontal bar over the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>. This is the notation we
see in Pyret. Python, in contrast, writes out a partial sequence of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>s.</p><p>Underneath this distinction lies some interesting details about
representing numbers in computers. Computers donâ€™t have infinite space
to store numbers (or anything else, for that matter): when a program
needs to work with a non-terminating decimal, the underlying language
can either:</p><ul><li><p>approximate the number (by chopping off the infinite sequence
of digits at some point), then work only with the approximated value
going forward, or</p></li><li><p>store additional information about the number that may enable doing
more precise computation with it later (though there are always some
numbers that cannot be represented exactly in finite space).</p></li></ul><p>Python takes the first approach. As a result, computations with the
approximated values sometimes yield approximated results. This is what
happens with our new <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pen_cost</code></span> test case. While
mathematically, the computation should result in <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">0.93</code></span>, the
approximations yield <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">0.9299999999999999</code></span> instead.</p><p>So how do we write tests in this situation? We need to tell Python
that the answer should be â€œcloseâ€ to <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">0.93</code></span>, within the error
range of approximations. Hereâ€™s what that looks like:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert pen_cost(3, "wow") == pytest.approx(0.93)</code></pre></div></div></div><div class="SIntrapara">We wrapped the exact answer we wanted in <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pytest.approx</code></span>, to
indicate that weâ€™ll accept any answer that is nearly the value we
specified. You can control the number of decimal points of precision
if you want to, but the default of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Â± 2.3e-06</code></span> often suffices.</div>&#13;
<h4 class="heading">9.1.5<span class="stt">Â </span><a name="(part._conditionals-python)"/>Conditionals<span class="button-group"><a href="#(part._conditionals-python)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Continuing with our original <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pen_cost</code></span> example, hereâ€™s the
Python version of the function that computed shipping costs on an
order:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def add_shipping(order_amt: float) -&gt; float:
    """increase order price by costs for shipping"""
    if order_amt == 0:
      return 0
    elif order_amt &lt;= 10:
      return order_amt + 4
    elif (order_amt &gt; 10) and (order_amt &lt; 30):
      return order_amt + 8
    else:
      return order_amt + 12</code></pre></div></div><p>The main difference to notice here is that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">else if</code></span> is written
as the single-word <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elif</code></span> in Python. We use <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">return</code></span> to
mark the functionâ€™s results in each branch of the conditional.
Otherwise, the conditional constructs are quite similar across the
two languages.</p><p>You may have noticed that Python does not require an explicit
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span> annotation on <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span>-expressions or functions. Instead,
Python looks at the indentation of your code to determine when a
construct has ended. For example, in the code sample for
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pen_cost</code></span> and <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">test_pens</code></span>, Python determines that the
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">pen_cost</code></span> function has ended because it detects a new
definition (for <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">test_pens</code></span>) at the left edge of the program
text. The same principle holds for ending conditionals.</p><p>Weâ€™ll return to this point about indentation, and see more examples,
as we work more with Python.</p>&#13;
<h4 class="heading">9.1.6<span class="stt">Â </span><a name="(part._python-create-process-lists)"/>Creating and Processing
Lists<span class="button-group"><a href="#(part._python-create-process-lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>As an example of lists, letâ€™s assume weâ€™ve been playing a game that
involves making words out of a collection of letters. In Pyret, we
could have written a sample word list as follows:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">words = [list: "banana", "bean", "falafel", "leaf"]</code></pre></div></div><p>In Python, this definition would look like:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">words = ["banana", "bean", "falafel", "leaf"]</code></pre></div></div><p>The only difference here is that Python does not use the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">list:</code></span>
label that is needed in Pyret.</p><section class="SsectionLevel5" id="section 9.1.6.1"><h5 class="heading">9.1.6.1<span class="stt">Â </span><a name="(part._.Filters__.Maps__and_.Friends)"/>Filters, Maps, and Friends<span class="button-group"><a href="#(part._.Filters__.Maps__and_.Friends)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>When we first learned about lists in Pyret, we started with common
built-in functions such as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member</code></span>
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length</code></span>. We also saw the use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lambda</code></span> to help us use
some of these functions concisely. These same functions, including
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lambda</code></span>, also exist in Python. Here are some samples (<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">#</code></span> is the comment character in Python):</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">words = ["banana", "bean", "falafel", "leaf"]

# filter and member
words_with_b = list(filter(lambda wd: "b" in wd, words))
# filter and length
short_words = list(filter(lambda wd: len(wd) &lt; 5, words))
# map and length
word_lengths = list(map(len, words))</code></pre></div></div><p>Note that you have to wrap calls to <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">filter</code></span> (and <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">map</code></span>)
with a use of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">list()</code></span>. Internally, Python has these functions
return a type of data that we havenâ€™t yet discussed (and donâ€™t
need). Using <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">list</code></span> converts the returned data into a list. If
you omit the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">list</code></span>, you wonâ€™t be able to chain certain
functions together. For example, if we tried to compute the length of
the result of a <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">map</code></span> without first converting to a
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">list</code></span>, weâ€™d get an error:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">len(map(len,b))</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">TypeError: object of type 'map' has no len()</code></pre></div></div></td></tr></table><p>Donâ€™t worry if this error message makes no sense at the moment (we
havenâ€™t yet learned what an â€œobjectâ€ is). The point is that if you see
an error like this while using the result of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">filter</code></span> or
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">map</code></span>, you likely forgot to wrap the result in <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">list</code></span>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Practice Pythonâ€™s list functions by writing expressions for the following
problems. Use only the list functions we have shown you so far.</p><ul><li><p>Given a list of numbers, convert it to a list of strings <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">"pos"</code></span>, <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">"neg"</code></span>, <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">"zero"</code></span>, based on the sign of each number.</p></li><li><p>Given a list of strings, is the length of any string equal to 5?</p></li><li><p>Given a list of numbers, produce a list of the even numbers between 10 and 20 from that list.</p></li></ul></blockquote></blockquote><p>Weâ€™re intentionally focusing on computations that use Pythonâ€™s built-in
functions for processing lists, rather than showing you how to write
you own (as we did with recursion in Pyret). While you can write
recursive functions to process lists in Pyret, a different style of
program is more conventional for that purpose. Weâ€™ll look at that in
the chapter on <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p></section>&#13;
<h5 class="heading">9.1.6.1<span class="stt">Â </span><a name="(part._.Filters__.Maps__and_.Friends)"/>Filters, Maps, and Friends<span class="button-group"><a href="#(part._.Filters__.Maps__and_.Friends)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>When we first learned about lists in Pyret, we started with common
built-in functions such as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map</code></span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">member</code></span>
and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">length</code></span>. We also saw the use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lambda</code></span> to help us use
some of these functions concisely. These same functions, including
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">lambda</code></span>, also exist in Python. Here are some samples (<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">#</code></span> is the comment character in Python):</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">words = ["banana", "bean", "falafel", "leaf"]

# filter and member
words_with_b = list(filter(lambda wd: "b" in wd, words))
# filter and length
short_words = list(filter(lambda wd: len(wd) &lt; 5, words))
# map and length
word_lengths = list(map(len, words))</code></pre></div></div><p>Note that you have to wrap calls to <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">filter</code></span> (and <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">map</code></span>)
with a use of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">list()</code></span>. Internally, Python has these functions
return a type of data that we havenâ€™t yet discussed (and donâ€™t
need). Using <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">list</code></span> converts the returned data into a list. If
you omit the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">list</code></span>, you wonâ€™t be able to chain certain
functions together. For example, if we tried to compute the length of
the result of a <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">map</code></span> without first converting to a
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">list</code></span>, weâ€™d get an error:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">len(map(len,b))</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">TypeError: object of type 'map' has no len()</code></pre></div></div></td></tr></table><p>Donâ€™t worry if this error message makes no sense at the moment (we
havenâ€™t yet learned what an â€œobjectâ€ is). The point is that if you see
an error like this while using the result of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">filter</code></span> or
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">map</code></span>, you likely forgot to wrap the result in <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">list</code></span>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Practice Pythonâ€™s list functions by writing expressions for the following
problems. Use only the list functions we have shown you so far.</p><ul><li><p>Given a list of numbers, convert it to a list of strings <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">"pos"</code></span>, <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">"neg"</code></span>, <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">"zero"</code></span>, based on the sign of each number.</p></li><li><p>Given a list of strings, is the length of any string equal to 5?</p></li><li><p>Given a list of numbers, produce a list of the even numbers between 10 and 20 from that list.</p></li></ul></blockquote></blockquote><p>Weâ€™re intentionally focusing on computations that use Pythonâ€™s built-in
functions for processing lists, rather than showing you how to write
you own (as we did with recursion in Pyret). While you can write
recursive functions to process lists in Pyret, a different style of
program is more conventional for that purpose. Weâ€™ll look at that in
the chapter on <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p>&#13;
<h4 class="heading">9.1.7<span class="stt">Â </span><a name="(part._python-data-with-components)"/>Data with Components<span class="button-group"><a href="#(part._python-data-with-components)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>An analog to a Pyret data definition (without variants) is called a <span class="emph">dataclass</span> in
Python.<span class="refelem"><span class="refcolumn"><span class="refcontent">Those experienced with Python may wonder why we are
using dataclasses instead of dictionaries or raw classes. Compared to
dictionaries, dataclasses allow the use of type hints and capture that
our data has a fixed collection of fields. Compared to raw classes,
dataclasses generate a lot of boilerplate code that makes them much
lighterweight than raw classes.</span></span></span> Hereâ€™s an example of a todo-list
datatype in Pyret and its corresponding Python code:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode"># a todo item in Pyret
data ToDoItemData:
  | todoItem(descr :: String,
             due :: Date,
             tags :: List&lt;String&gt;
end</code></pre></div></div><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">------------------------------------------
# the same todo item in Python

# to allow use of dataclasses
from dataclasses import dataclass
# to allow dates as a type (in the ToDoItem)
from datetime import date

@dataclass
class ToDoItem:
    descr: str
    due: date
    tags: list

# a sample list of ToDoItem
myTD = [ToDoItem("buy milk", date(2020, 7, 27), ["shopping", "home"]),
        ToDoItem("grade hwk", date(2020, 7, 27), ["teaching"]),
        ToDoItem("meet students", date(2020, 7, 26), ["research"])
       ]</code></pre></div></div><p>Things to note:</p><ul><li><p>There is a single name for the type and the constructor, rather
than separate names as we had in Pyret.</p></li><li><p>There are no commas between field names (but each has to be on
its own line in Python)</p></li><li><p>There is no way to specify the type of the contents of the list
in Python (at least, not without using more advance packages for
writing types)</p></li><li><p>The <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">@dataclass</code></span> annotation is needed before
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">class</code></span>.</p></li><li><p>Dataclasses donâ€™t support creating datatypes with multiple
variants, like we did frequently in Pyret. Doing that needs more
advanced concepts than we will cover in this book.</p></li></ul><section class="SsectionLevel5" id="section 9.1.7.1"><h5 class="heading">9.1.7.1<span class="stt">Â </span><a name="(part._.Accessing_.Fields_within_.Dataclasses)"/>Accessing Fields within Dataclasses<span class="button-group"><a href="#(part._.Accessing_.Fields_within_.Dataclasses)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>In Pyret, we extracted a field from structured data by using a dot
(period) to â€œdig intoâ€ the datum and access the field. The same
notation works in Python:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">travel = ToDoItem("buy tickets", date(2020, 7, 30), ["vacation"])</code></pre></div></div></blockquote></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">travel.descr</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"buy tickets"</code></pre></div></div></td></tr></table></div></section>&#13;
<h5 class="heading">9.1.7.1<span class="stt">Â </span><a name="(part._.Accessing_.Fields_within_.Dataclasses)"/>Accessing Fields within Dataclasses<span class="button-group"><a href="#(part._.Accessing_.Fields_within_.Dataclasses)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>In Pyret, we extracted a field from structured data by using a dot
(period) to â€œdig intoâ€ the datum and access the field. The same
notation works in Python:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">travel = ToDoItem("buy tickets", date(2020, 7, 30), ["vacation"])</code></pre></div></div></blockquote></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">travel.descr</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"buy tickets"</code></pre></div></div></td></tr></table></div>&#13;
<h4 class="heading">9.1.8<span class="stt">Â </span><a name="(part._python-traverse-lists)"/>Traversing Lists<span class="button-group"><a href="#(part._python-traverse-lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><section class="SsectionLevel5" id="section 9.1.8.1"><h5 class="heading">9.1.8.1<span class="stt">Â </span><a name="(part._python-for-loops)"/>Introducing <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">For</code></span> Loops<span class="button-group"><a href="#(part._python-for-loops)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">In Pyret, we typically write recursive functions to compute summary values over
lists. As a reminder, hereâ€™s a Pyret function that sums the numbers in
a list:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(numlist :: List&lt;Number&gt;) -&gt; Number:
  cases (List) numlist:
    | empty =&gt; 0
    | link(fst, rst) =&gt; fst + sum-list(rst)
  end
end</code></pre></div></div></div><p>In Python, it is unusual to break a list into its first and rest
components and process the rest recursively. Instead, we use a construct called a <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> to
visit each element of a list in turn. Hereâ€™s the form of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span>,
using a concrete (example) list of odd numbers:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for num in [5, 1, 7, 3]:
   # do something with num</code></pre></div></div><p/><div class="SIntrapara">The name <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></span> here is of our choosing, just as with the names
of parameters to a function in Pyret.  When a <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> loop
evaluates, each item in the list is referred to as <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></span> in
turn. Thus, this <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> example is equivalent to writing the
following:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># do something with 5
# do something with 1
# do something with 7
# do something with 3</code></pre></div></div></div><div class="SIntrapara">The <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> construct saves us from writing the common code
multiple times, and also handles the fact that the lists we are
processing can be of arbitrary length (so we canâ€™t predict how many
times to write the common code).</div><p>Letâ€™s now use <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> to compute the running sum of a list. Weâ€™ll
start by figuring out the repeated computation with our concrete list
again. At first, letâ€™s express the repeated computation just in
prose. In Pyret, our repeated computation was along the lines of â€œadd
the first item to the sum of the rest of the itemsâ€. Weâ€™ve already
said that we cannot easily access the â€œrest of the itemsâ€ in Python,
so we need to rephrase this. Hereâ€™s an alternative:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># set a running total to 0
# add 5 to the running total
# add 1 to the running total
# add 7 to the running total
# add 3 to the running total</code></pre></div></div></div><div class="SIntrapara">Note that this framing refers not to the â€œrest of the computationâ€,
but rather to the computation that has happened so far (the â€œrunning
totalâ€). If you happened to work through the chapter on <a href="processing-lists.html#%28part._running-sum-eg-code%29" data-pltdoc="x"><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>: Examples and Code</a>, this framing might be familiar.</div><p>Letâ€™s convert this prose sketch to code by replacing each line of the
sketch with concrete code. We do this by setting up a variable named
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></span> and updating its value for each element.</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = run_total + 5
run_total = run_total + 1
run_total = run_total + 7
run_total = run_total + 3</code></pre></div></div></div><div class="SIntrapara">This idea that you can give a new value to an existing variable name
is something we havenâ€™t seen before. In fact, when we first saw how to
name values (in <a href="Naming_Values.html#%28part._program-directory%29" data-pltdoc="x">The Program Directory</a>), we explicitly said that
Pyret doesnâ€™t let
you do this (at least, not with the constructs that we showed you). Python does. Weâ€™ll explore the consequences of this ability in
more depth shortly (in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>). For now, letâ€™s just use that ability so we can
learn the pattern for traversing lists. First, letâ€™s collapse the repeated lines of code
into a single use of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span>:</div><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
for num in [5, 1, 7, 3]:
   run_total = run_total + num</code></pre></div></div></div><div class="SIntrapara">This code works fine for a specific list, but our Pyret version took
the list to sum as a parameter to a function. To achieve this in
Python, we wrap the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> in a function as we have done for
other examples earlier in this chapter. This is the final version.</div><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def sum_list(numlist : list) -&gt; float:
    """sum a list of numbers"""
    run_total = 0
    for num in numlist:
        run_total = run_total + num
    return(run_total)</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write a set of tests for <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">sum_list</code></span> (the Python version).</p></blockquote></blockquote><p>Now that the Python version is done, letâ€™s compare it to the original Pyret
version:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(numlist :: List&lt;Number&gt;) -&gt; Number:
  cases (List) numlist:
    | empty =&gt; 0
    | link(fst, rst) =&gt; fst + sum-list(rst)
  end
end</code></pre></div></div><p>Here are some things to notice about the two pieces of code:</p><ul><li><p>The Python version needs a variable (here <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></span>) to
hold the result of the computation as we build it up while traversing
(working through) the list.</p></li><li><p>The initial value of that variable is the answer we returned in
the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> case in Pyret.</p></li><li><p>The computation in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> case of the Pyret function is
used to update that variable in the body of the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span>.</p></li><li><p>After the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> has finished processing all items in the
list, the Python version returns the value in the variable as the
result of the function.</p></li></ul></section><section class="SsectionLevel5" id="section 9.1.8.2"><h5 class="heading">9.1.8.2<span class="stt">Â </span><a name="(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)"/>An Aside on Order of Processing List Elements<span class="button-group"><a href="#(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Thereâ€™s another subtlety here if we consider how the two programs run:
the Python version sums the elements from left to right, whereas
the Pyret version sums them right to left. Concretely, the sequence of
values of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></span> are computed as:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = 0 + 5
run_total = 5 + 1
run_total = 6 + 7
run_total = 13 + 3</code></pre></div></div></div><div class="SIntrapara">In contrast, the Pyret version unrolls as:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum_list([list: 5, 1, 7, 3])
5 + sum_list([list: 1, 7, 3])
5 + 1 + sum_list([list: 7, 3])
5 + 1 + 7 + sum_list([list: 3])
5 + 1 + 7 + 3 + sum_list([list:])
5 + 1 + 7 + 3 + 0
5 + 1 + 7 + 3
5 + 1 + 10
5 + 11
16</code></pre></div></div></div><div class="SIntrapara">As a reminder, the Pyret version did this because the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span> in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> case can only reduce to an answer once the sum of the rest
of the list has been computed. Even though we as humans see the chain
of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span> operations in each line of the Pyret unrolling, Pyret sees
only the expression <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fst + sum-list(rst)</code></span>, which requires the
function call to finish before the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span> executes.</div><p>In the case of summing a list, we donâ€™t notice the difference between
the two versions because the sum is the same whether we compute it
left-to-right or right-to-left. In other functions we write, this
difference may start to matter.</p></section><section class="SsectionLevel5" id="section 9.1.8.3"><h5 class="heading">9.1.8.3<span class="stt">Â </span><a name="(part._python-funcs-produce-lists)"/>Using <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">For</code></span> Loops in Functions that Produce Lists<span class="button-group"><a href="#(part._python-funcs-produce-lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Letâ€™s practice using <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> loops on another function that
traverses lists, this time one that produces a list. Specifically,
letâ€™s write a program that takes a list of strings and produces a list
of words within that list that contain the letter <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">"z"</code></span>.</p><p>As in our <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">sum_list</code></span> function, we will need a variable to store
the resulting list as we build it up. The following code calls this
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">zlist</code></span>. The code also shows how to use <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">in</code></span> to check
whether a character is in a string (it also works for checking whether
an item is in a list) and how to add an element to the end of a list
(<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">append</code></span>).</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def all_z_words(wordlist : list) -&gt; list:
    """produce list of words from the input that contain z"""
    zlist = [] # start with an empty list
    for wd in wordlist:
        if "z" in wd:
            zlist = [wd] + zlist
    return(zlist)</code></pre></div></div></div><div class="SIntrapara">This code follows the structure of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">sum_list</code></span>, in that we
update the value of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">zlist</code></span> using an expression similar to what
we would have used in Pyret. <span class="refelem"><span class="refcolumn"><span class="refcontent">For those with prior Python
experience who would have used <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">zlist.append</code></span> here, hold that
thought. We will get there in <a href="mutable-lists.html" data-pltdoc="x">Mutable Lists</a>.</span></span></span></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write tests for <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">all_z_words</code></span>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a second version of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">all_z_words</code></span> using
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">filter</code></span>. Be sure to write tests for it!</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Contrast these two versions and the corresponding tests. Did you
notice anything interesting?</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 9.1.8.4"><h5 class="heading">9.1.8.4<span class="stt">Â </span><a name="(part._.Summary__.The_.List-.Processing_.Template_for_.Python)"/>Summary: The List-Processing Template for Python<span class="button-group"><a href="#(part._.Summary__.The_.List-.Processing_.Template_for_.Python)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Just as we had a template for writing list-processing functions in
Pyret, there is a corresponding template in Python based on
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> loops. As a reminder, that pattern is as follow:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def func(lst: list):
  result = ...  # what to return if the input list is empty
  for item in lst:
    # combine item with the result so far
    result = ... item ... result
  return result</code></pre></div></div><p>Keep this template in mind as you learn to write functions over lists
in Python.</p></section><section class="SsectionLevel5" id="section 9.1.8.5"><h5 class="heading">9.1.8.5<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> loops in Pyret<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><span class="refelem"><span class="refcolumn"><span class="refcontent">This section can be read
without reading the rest of this chapter, so if you have been directed to it
before being introduced to Python, do not worry! While the content below mirrors
similar constructs that exist in Python, it is introduced on its own.</span></span></span></p><p>The previous sections introduced <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> loops in Python, and showed a
template for processing lists with them. Pyret can
do similar, using the following pattern:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun func(lst :: List) block:
  var result = ...  # what to return if the input list is empty
  for each(item from lst):
    # combine item with the result so far
    result := ... item ... result
  end
  result
end</code></pre></div></div><p>There are a few new language features used in this example, introduced in the
following several sections.</p><section class="SsectionLevel6" id="section 9.1.8.5.1"><h5 class="heading">9.1.8.5.1<span class="stt">Â </span><a name="(part._.Variables_that_can_change)"/>Variables that can change<span class="button-group"><a href="#(part._.Variables_that_can_change)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>First, note that we introduce the variable <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">result</code></span> with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var result</code></span>
â€“ this means that it can <span class="emph">vary</span>, which is important for the use with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span>.</p><p>By default, all variables in the program directory can never be changed. i.e.,
if I define a variable <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x</code></span>, I can not redefine it later:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x = 10
# ...
x = 20 # produces shadowing error</code></pre></div></div><p>If we do want to change (or mutate) a variable in the directory later, we can, but we must
declare the variable can change â€“ as in, when we define it, rather than writing
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x = 10</code></span>, we must write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var x = 10</code></span>. Then, when we want to
<span class="emph">update</span> it, we can do so with the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">:=</code></span> operator, as is done in the template above.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var x = 10
# ... x points to 10 in directory
x := 20
# ... x now points to 20 in directory</code></pre></div></div><p>Note that trying to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">:=</code></span> on a variable that was not declared using
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var</code></span> will produce an error, and variables can still only ever be declared
once (whether with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var x = ...</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x = ...</code></span>).</p></section><section class="SsectionLevel6" id="section 9.1.8.5.2"><h5 class="heading">9.1.8.5.2<span class="stt">Â </span><a name="(part._block_notation)"/>block notation<span class="button-group"><a href="#(part._block_notation)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Another new language feature shown in these examples is that since Pyret
functions by default expect only a single (non-definition) expression, we have
to add the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">block</code></span> annotation at the top, indicating that the body of the
function is multiple expressions, with the final one being what the function
evaluates to.</p><p>As another example, if we tried to write:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function():
  1
  2
end</code></pre></div></div><p>Pyret would (rightly) error â€“ since the function returns the last expression in
its body, the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> will be ignored â€“ and is most likely a mistake! Perhaps
the goal was to write:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function():
  1 + 2
end</code></pre></div></div><p>However, since a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> expression exists only to modify a variable,
functions that contain them <span class="emph">will</span> always have multiple expressions, and so
we need to communicate to Pyret that this is not a mistake. Adding <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">block</code></span>
before the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">:</code></span> that begins the function (or, in general, wrapping any
expressions in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">block:</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span>) communicates to Pyret that we
understand that there are multiple expressions, and just want to evaluate to the
last one. So, if we truly wanted to write a function as our first example, we
could do that with:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function() block:
  1
  2
end</code></pre></div></div></section><section class="SsectionLevel6" id="section 9.1.8.5.3"><h5 class="heading">9.1.8.5.3<span class="stt">Â </span><a name="(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)"/>How <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> works<span class="button-group"><a href="#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>A <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> expression runs its body once for each element in the input
list, adding an entry to the program directory for each element as it goes. It
does not produce any value directly, so much instead rely on modifying variables
(described above) to produce a computation.</p><p>Consider summing a list of numbers. We could write a function that does this,
following our pattern, as:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(lst :: List) block:
  var run_total = 0
  for each(item from lst):
    run_total := item + run_total
  end
  run_total
where:
  sum-list([list: 5, 1, 7, 3]) is 16
end</code></pre></div></div><p>On the concrete test input <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 5, 1, 7, 3]</code></span>, the loop runs four times,
once with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">item</code></span> set to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">5</code></span>, then with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">item</code></span> set to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>,
then with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">item</code></span> set to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span>, and finally with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">item</code></span> set to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>.</p><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> construct saves us from writing the common code
multiple times, and also handles the fact that the lists we are
processing can be of arbitrary length (so we canâ€™t predict how many
times to write the common code). Thus, what happens is:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = run_total + 5
run_total = run_total + 1
run_total = run_total + 7
run_total = run_total + 3</code></pre></div></div></section><section class="SsectionLevel6" id="section 9.1.8.5.4"><h5 class="heading">9.1.8.5.4<span class="stt">Â </span><a name="(part._.Testing_and_variables_that_can_change)"/>Testing and variables that can change<span class="button-group"><a href="#(part._.Testing_and_variables_that_can_change)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>We intentionally showed a very particular pattern of using variables that can
change. While there are other uses (explored in part in
<a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>), a main reason to stay with this particular
template is the difficulty in testing and correspondingly, understanding, code
that uses them in other ways.</p><p>In particular, note that the pattern means that we never define a variables that
can change <span class="emph">outside</span> a function, which means it can never be used by
different functions, or multiple function calls. Each time the function runs, a
new variable is created, it is modified in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> loop, and then
the value is returned, and the entry in the program directory is removed.</p><p>Consider what happens if we donâ€™t follow our pattern. Letâ€™s say we had the
following problem:</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Given a list of numbers, return the prefix of the list (i.e., all
elements, starting from the beginning) that sums to less than 100.</p></blockquote></blockquote><p>Having learned about mutable variables, but not following the pattern, you might
come up with code like this:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var count = 0

fun prefix-under-100(l :: List) -&gt; List:
  var output = [list: ]
  for each(elt from l):
    count := count + elt
    when (count &lt; 100):
      output := output + [list: elt]
    end
  end
end</code></pre></div></div><p>Now, this might seem reasonable â€“ weâ€™ve used a new construct, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">when</code></span>,
which is an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression that has no <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">else</code></span> â€“ this only makes
sense to do inside of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> block, where we donâ€™t need a value as a
result. It is equivalent to:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if (count &lt; 100):
  output := output + [list: elt]
else:
  nothing
end</code></pre></div></div><p>Where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nothing</code></span> is a value that is used in Pyret to indicate that there is
no particular value of importance.</p><p>But what happens when we use this function?</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
    prefix-under-100([list: 20, 30, 40]) is [list: 20, 30, 40]
    prefix-under-100([list: 80, 20, 10]) is [list: 80]
end</code></pre></div></div><p>The first two tests pass, but the last one doesnâ€™t. Why? If we run the first one
again, things are even more confusing, i.e., if instead of the above, we ran
this <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check</code></span> block:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
    prefix-under-100([list: 20, 30, 40]) is [list: 20, 30, 40]
    prefix-under-100([list: 80, 20, 10]) is [list: 80]
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
end</code></pre></div></div><p>Now the test that passed at first no longer passes!</p><p>What we are seeing is that since the variable is outside the function, it is
<span class="emph">shared</span> across different calls to the function. It is added to the program
directory once, and each time we call <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">prefix-under-100</code></span>, the program
directory entry is changed, but it is never reset.</p><p>Intentionally, all other uses of mutation have been on directory entries that
were created only for the body of the function, which meant that when the
function exited, they were removed. But now, we are always modifying the single
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">count</code></span> variable. This means that every time we call
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">prefix-under-100</code></span>, it behaves differently, because it not only do we have
to understand the code in the body of the function, we have to know the current
value of the count variable, which is not something we can figure out by just
looking at the code!</p><p>Functions that behave like this are said to have "side effects", and they are
much harder to test and much harder to understand, and as a result, much more
likely to have bugs! While the above example is wrong in a relatively
straightforward way, side effects can cause extremely subtle bugs that only
happen when functions are called in particular orders â€“ orders that may only
arised in very specific situations, making them hard to understand or reproduce.</p><p>While there are some places where doing this is necessary, almost all code can
be written without side effects, and will be much more reliable. We will explore
some cases where we might want to do this in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p></section></section>&#13;
<h5 class="heading">9.1.8.1<span class="stt">Â </span><a name="(part._python-for-loops)"/>Introducing <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">For</code></span> Loops<span class="button-group"><a href="#(part._python-for-loops)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p/><div class="SIntrapara">In Pyret, we typically write recursive functions to compute summary values over
lists. As a reminder, hereâ€™s a Pyret function that sums the numbers in
a list:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(numlist :: List&lt;Number&gt;) -&gt; Number:
  cases (List) numlist:
    | empty =&gt; 0
    | link(fst, rst) =&gt; fst + sum-list(rst)
  end
end</code></pre></div></div></div><p>In Python, it is unusual to break a list into its first and rest
components and process the rest recursively. Instead, we use a construct called a <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> to
visit each element of a list in turn. Hereâ€™s the form of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span>,
using a concrete (example) list of odd numbers:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for num in [5, 1, 7, 3]:
   # do something with num</code></pre></div></div><p/><div class="SIntrapara">The name <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></span> here is of our choosing, just as with the names
of parameters to a function in Pyret.  When a <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> loop
evaluates, each item in the list is referred to as <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">num</code></span> in
turn. Thus, this <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> example is equivalent to writing the
following:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># do something with 5
# do something with 1
# do something with 7
# do something with 3</code></pre></div></div></div><div class="SIntrapara">The <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> construct saves us from writing the common code
multiple times, and also handles the fact that the lists we are
processing can be of arbitrary length (so we canâ€™t predict how many
times to write the common code).</div><p>Letâ€™s now use <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> to compute the running sum of a list. Weâ€™ll
start by figuring out the repeated computation with our concrete list
again. At first, letâ€™s express the repeated computation just in
prose. In Pyret, our repeated computation was along the lines of â€œadd
the first item to the sum of the rest of the itemsâ€. Weâ€™ve already
said that we cannot easily access the â€œrest of the itemsâ€ in Python,
so we need to rephrase this. Hereâ€™s an alternative:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># set a running total to 0
# add 5 to the running total
# add 1 to the running total
# add 7 to the running total
# add 3 to the running total</code></pre></div></div></div><div class="SIntrapara">Note that this framing refers not to the â€œrest of the computationâ€,
but rather to the computation that has happened so far (the â€œrunning
totalâ€). If you happened to work through the chapter on <a href="processing-lists.html#%28part._running-sum-eg-code%29" data-pltdoc="x"><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">my-running-sum</code></span>: Examples and Code</a>, this framing might be familiar.</div><p>Letâ€™s convert this prose sketch to code by replacing each line of the
sketch with concrete code. We do this by setting up a variable named
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></span> and updating its value for each element.</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = run_total + 5
run_total = run_total + 1
run_total = run_total + 7
run_total = run_total + 3</code></pre></div></div></div><div class="SIntrapara">This idea that you can give a new value to an existing variable name
is something we havenâ€™t seen before. In fact, when we first saw how to
name values (in <a href="Naming_Values.html#%28part._program-directory%29" data-pltdoc="x">The Program Directory</a>), we explicitly said that
Pyret doesnâ€™t let
you do this (at least, not with the constructs that we showed you). Python does. Weâ€™ll explore the consequences of this ability in
more depth shortly (in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>). For now, letâ€™s just use that ability so we can
learn the pattern for traversing lists. First, letâ€™s collapse the repeated lines of code
into a single use of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span>:</div><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
for num in [5, 1, 7, 3]:
   run_total = run_total + num</code></pre></div></div></div><div class="SIntrapara">This code works fine for a specific list, but our Pyret version took
the list to sum as a parameter to a function. To achieve this in
Python, we wrap the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> in a function as we have done for
other examples earlier in this chapter. This is the final version.</div><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def sum_list(numlist : list) -&gt; float:
    """sum a list of numbers"""
    run_total = 0
    for num in numlist:
        run_total = run_total + num
    return(run_total)</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write a set of tests for <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">sum_list</code></span> (the Python version).</p></blockquote></blockquote><p>Now that the Python version is done, letâ€™s compare it to the original Pyret
version:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(numlist :: List&lt;Number&gt;) -&gt; Number:
  cases (List) numlist:
    | empty =&gt; 0
    | link(fst, rst) =&gt; fst + sum-list(rst)
  end
end</code></pre></div></div><p>Here are some things to notice about the two pieces of code:</p><ul><li><p>The Python version needs a variable (here <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></span>) to
hold the result of the computation as we build it up while traversing
(working through) the list.</p></li><li><p>The initial value of that variable is the answer we returned in
the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> case in Pyret.</p></li><li><p>The computation in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> case of the Pyret function is
used to update that variable in the body of the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span>.</p></li><li><p>After the <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> has finished processing all items in the
list, the Python version returns the value in the variable as the
result of the function.</p></li></ul>&#13;
<h5 class="heading">9.1.8.2<span class="stt">Â </span><a name="(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)"/>An Aside on Order of Processing List Elements<span class="button-group"><a href="#(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Thereâ€™s another subtlety here if we consider how the two programs run:
the Python version sums the elements from left to right, whereas
the Pyret version sums them right to left. Concretely, the sequence of
values of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total</code></span> are computed as:</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = 0 + 5
run_total = 5 + 1
run_total = 6 + 7
run_total = 13 + 3</code></pre></div></div></div><div class="SIntrapara">In contrast, the Pyret version unrolls as:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum_list([list: 5, 1, 7, 3])
5 + sum_list([list: 1, 7, 3])
5 + 1 + sum_list([list: 7, 3])
5 + 1 + 7 + sum_list([list: 3])
5 + 1 + 7 + 3 + sum_list([list:])
5 + 1 + 7 + 3 + 0
5 + 1 + 7 + 3
5 + 1 + 10
5 + 11
16</code></pre></div></div></div><div class="SIntrapara">As a reminder, the Pyret version did this because the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span> in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">link</code></span> case can only reduce to an answer once the sum of the rest
of the list has been computed. Even though we as humans see the chain
of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span> operations in each line of the Pyret unrolling, Pyret sees
only the expression <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fst + sum-list(rst)</code></span>, which requires the
function call to finish before the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">+</code></span> executes.</div><p>In the case of summing a list, we donâ€™t notice the difference between
the two versions because the sum is the same whether we compute it
left-to-right or right-to-left. In other functions we write, this
difference may start to matter.</p>&#13;
<h5 class="heading">9.1.8.3<span class="stt">Â </span><a name="(part._python-funcs-produce-lists)"/>Using <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">For</code></span> Loops in Functions that Produce Lists<span class="button-group"><a href="#(part._python-funcs-produce-lists)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Letâ€™s practice using <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> loops on another function that
traverses lists, this time one that produces a list. Specifically,
letâ€™s write a program that takes a list of strings and produces a list
of words within that list that contain the letter <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">"z"</code></span>.</p><p>As in our <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">sum_list</code></span> function, we will need a variable to store
the resulting list as we build it up. The following code calls this
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">zlist</code></span>. The code also shows how to use <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">in</code></span> to check
whether a character is in a string (it also works for checking whether
an item is in a list) and how to add an element to the end of a list
(<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">append</code></span>).</p><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def all_z_words(wordlist : list) -&gt; list:
    """produce list of words from the input that contain z"""
    zlist = [] # start with an empty list
    for wd in wordlist:
        if "z" in wd:
            zlist = [wd] + zlist
    return(zlist)</code></pre></div></div></div><div class="SIntrapara">This code follows the structure of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">sum_list</code></span>, in that we
update the value of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">zlist</code></span> using an expression similar to what
we would have used in Pyret. <span class="refelem"><span class="refcolumn"><span class="refcontent">For those with prior Python
experience who would have used <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">zlist.append</code></span> here, hold that
thought. We will get there in <a href="mutable-lists.html" data-pltdoc="x">Mutable Lists</a>.</span></span></span></div><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write tests for <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">all_z_words</code></span>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a second version of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">all_z_words</code></span> using
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">filter</code></span>. Be sure to write tests for it!</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Contrast these two versions and the corresponding tests. Did you
notice anything interesting?</p></blockquote></blockquote>&#13;
<h5 class="heading">9.1.8.4<span class="stt">Â </span><a name="(part._.Summary__.The_.List-.Processing_.Template_for_.Python)"/>Summary: The List-Processing Template for Python<span class="button-group"><a href="#(part._.Summary__.The_.List-.Processing_.Template_for_.Python)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Just as we had a template for writing list-processing functions in
Pyret, there is a corresponding template in Python based on
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> loops. As a reminder, that pattern is as follow:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def func(lst: list):
  result = ...  # what to return if the input list is empty
  for item in lst:
    # combine item with the result so far
    result = ... item ... result
  return result</code></pre></div></div><p>Keep this template in mind as you learn to write functions over lists
in Python.</p>&#13;
<h5 class="heading">9.1.8.5<span class="stt">Â </span><a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)"/><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> loops in Pyret<span class="button-group"><a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><span class="refelem"><span class="refcolumn"><span class="refcontent">This section can be read
without reading the rest of this chapter, so if you have been directed to it
before being introduced to Python, do not worry! While the content below mirrors
similar constructs that exist in Python, it is introduced on its own.</span></span></span></p><p>The previous sections introduced <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for</code></span> loops in Python, and showed a
template for processing lists with them. Pyret can
do similar, using the following pattern:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun func(lst :: List) block:
  var result = ...  # what to return if the input list is empty
  for each(item from lst):
    # combine item with the result so far
    result := ... item ... result
  end
  result
end</code></pre></div></div><p>There are a few new language features used in this example, introduced in the
following several sections.</p><section class="SsectionLevel6" id="section 9.1.8.5.1"><h5 class="heading">9.1.8.5.1<span class="stt">Â </span><a name="(part._.Variables_that_can_change)"/>Variables that can change<span class="button-group"><a href="#(part._.Variables_that_can_change)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>First, note that we introduce the variable <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">result</code></span> with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var result</code></span>
â€“ this means that it can <span class="emph">vary</span>, which is important for the use with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span>.</p><p>By default, all variables in the program directory can never be changed. i.e.,
if I define a variable <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x</code></span>, I can not redefine it later:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x = 10
# ...
x = 20 # produces shadowing error</code></pre></div></div><p>If we do want to change (or mutate) a variable in the directory later, we can, but we must
declare the variable can change â€“ as in, when we define it, rather than writing
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x = 10</code></span>, we must write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var x = 10</code></span>. Then, when we want to
<span class="emph">update</span> it, we can do so with the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">:=</code></span> operator, as is done in the template above.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var x = 10
# ... x points to 10 in directory
x := 20
# ... x now points to 20 in directory</code></pre></div></div><p>Note that trying to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">:=</code></span> on a variable that was not declared using
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var</code></span> will produce an error, and variables can still only ever be declared
once (whether with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var x = ...</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x = ...</code></span>).</p></section><section class="SsectionLevel6" id="section 9.1.8.5.2"><h5 class="heading">9.1.8.5.2<span class="stt">Â </span><a name="(part._block_notation)"/>block notation<span class="button-group"><a href="#(part._block_notation)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Another new language feature shown in these examples is that since Pyret
functions by default expect only a single (non-definition) expression, we have
to add the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">block</code></span> annotation at the top, indicating that the body of the
function is multiple expressions, with the final one being what the function
evaluates to.</p><p>As another example, if we tried to write:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function():
  1
  2
end</code></pre></div></div><p>Pyret would (rightly) error â€“ since the function returns the last expression in
its body, the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> will be ignored â€“ and is most likely a mistake! Perhaps
the goal was to write:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function():
  1 + 2
end</code></pre></div></div><p>However, since a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> expression exists only to modify a variable,
functions that contain them <span class="emph">will</span> always have multiple expressions, and so
we need to communicate to Pyret that this is not a mistake. Adding <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">block</code></span>
before the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">:</code></span> that begins the function (or, in general, wrapping any
expressions in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">block:</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span>) communicates to Pyret that we
understand that there are multiple expressions, and just want to evaluate to the
last one. So, if we truly wanted to write a function as our first example, we
could do that with:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function() block:
  1
  2
end</code></pre></div></div></section><section class="SsectionLevel6" id="section 9.1.8.5.3"><h5 class="heading">9.1.8.5.3<span class="stt">Â </span><a name="(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)"/>How <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> works<span class="button-group"><a href="#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>A <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> expression runs its body once for each element in the input
list, adding an entry to the program directory for each element as it goes. It
does not produce any value directly, so much instead rely on modifying variables
(described above) to produce a computation.</p><p>Consider summing a list of numbers. We could write a function that does this,
following our pattern, as:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(lst :: List) block:
  var run_total = 0
  for each(item from lst):
    run_total := item + run_total
  end
  run_total
where:
  sum-list([list: 5, 1, 7, 3]) is 16
end</code></pre></div></div><p>On the concrete test input <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 5, 1, 7, 3]</code></span>, the loop runs four times,
once with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">item</code></span> set to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">5</code></span>, then with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">item</code></span> set to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>,
then with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">item</code></span> set to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span>, and finally with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">item</code></span> set to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>.</p><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> construct saves us from writing the common code
multiple times, and also handles the fact that the lists we are
processing can be of arbitrary length (so we canâ€™t predict how many
times to write the common code). Thus, what happens is:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = run_total + 5
run_total = run_total + 1
run_total = run_total + 7
run_total = run_total + 3</code></pre></div></div></section><section class="SsectionLevel6" id="section 9.1.8.5.4"><h5 class="heading">9.1.8.5.4<span class="stt">Â </span><a name="(part._.Testing_and_variables_that_can_change)"/>Testing and variables that can change<span class="button-group"><a href="#(part._.Testing_and_variables_that_can_change)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>We intentionally showed a very particular pattern of using variables that can
change. While there are other uses (explored in part in
<a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>), a main reason to stay with this particular
template is the difficulty in testing and correspondingly, understanding, code
that uses them in other ways.</p><p>In particular, note that the pattern means that we never define a variables that
can change <span class="emph">outside</span> a function, which means it can never be used by
different functions, or multiple function calls. Each time the function runs, a
new variable is created, it is modified in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> loop, and then
the value is returned, and the entry in the program directory is removed.</p><p>Consider what happens if we donâ€™t follow our pattern. Letâ€™s say we had the
following problem:</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Given a list of numbers, return the prefix of the list (i.e., all
elements, starting from the beginning) that sums to less than 100.</p></blockquote></blockquote><p>Having learned about mutable variables, but not following the pattern, you might
come up with code like this:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var count = 0

fun prefix-under-100(l :: List) -&gt; List:
  var output = [list: ]
  for each(elt from l):
    count := count + elt
    when (count &lt; 100):
      output := output + [list: elt]
    end
  end
end</code></pre></div></div><p>Now, this might seem reasonable â€“ weâ€™ve used a new construct, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">when</code></span>,
which is an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression that has no <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">else</code></span> â€“ this only makes
sense to do inside of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> block, where we donâ€™t need a value as a
result. It is equivalent to:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if (count &lt; 100):
  output := output + [list: elt]
else:
  nothing
end</code></pre></div></div><p>Where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nothing</code></span> is a value that is used in Pyret to indicate that there is
no particular value of importance.</p><p>But what happens when we use this function?</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
    prefix-under-100([list: 20, 30, 40]) is [list: 20, 30, 40]
    prefix-under-100([list: 80, 20, 10]) is [list: 80]
end</code></pre></div></div><p>The first two tests pass, but the last one doesnâ€™t. Why? If we run the first one
again, things are even more confusing, i.e., if instead of the above, we ran
this <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check</code></span> block:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
    prefix-under-100([list: 20, 30, 40]) is [list: 20, 30, 40]
    prefix-under-100([list: 80, 20, 10]) is [list: 80]
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
end</code></pre></div></div><p>Now the test that passed at first no longer passes!</p><p>What we are seeing is that since the variable is outside the function, it is
<span class="emph">shared</span> across different calls to the function. It is added to the program
directory once, and each time we call <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">prefix-under-100</code></span>, the program
directory entry is changed, but it is never reset.</p><p>Intentionally, all other uses of mutation have been on directory entries that
were created only for the body of the function, which meant that when the
function exited, they were removed. But now, we are always modifying the single
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">count</code></span> variable. This means that every time we call
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">prefix-under-100</code></span>, it behaves differently, because it not only do we have
to understand the code in the body of the function, we have to know the current
value of the count variable, which is not something we can figure out by just
looking at the code!</p><p>Functions that behave like this are said to have "side effects", and they are
much harder to test and much harder to understand, and as a result, much more
likely to have bugs! While the above example is wrong in a relatively
straightforward way, side effects can cause extremely subtle bugs that only
happen when functions are called in particular orders â€“ orders that may only
arised in very specific situations, making them hard to understand or reproduce.</p><p>While there are some places where doing this is necessary, almost all code can
be written without side effects, and will be much more reliable. We will explore
some cases where we might want to do this in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p></section>&#13;
<h5 class="heading">9.1.8.5.1<span class="stt">Â </span><a name="(part._.Variables_that_can_change)"/>Variables that can change<span class="button-group"><a href="#(part._.Variables_that_can_change)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>First, note that we introduce the variable <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">result</code></span> with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var result</code></span>
â€“ this means that it can <span class="emph">vary</span>, which is important for the use with
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span>.</p><p>By default, all variables in the program directory can never be changed. i.e.,
if I define a variable <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x</code></span>, I can not redefine it later:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x = 10
# ...
x = 20 # produces shadowing error</code></pre></div></div><p>If we do want to change (or mutate) a variable in the directory later, we can, but we must
declare the variable can change â€“ as in, when we define it, rather than writing
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x = 10</code></span>, we must write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var x = 10</code></span>. Then, when we want to
<span class="emph">update</span> it, we can do so with the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">:=</code></span> operator, as is done in the template above.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var x = 10
# ... x points to 10 in directory
x := 20
# ... x now points to 20 in directory</code></pre></div></div><p>Note that trying to use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">:=</code></span> on a variable that was not declared using
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var</code></span> will produce an error, and variables can still only ever be declared
once (whether with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var x = ...</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x = ...</code></span>).</p>&#13;
<h5 class="heading">9.1.8.5.2<span class="stt">Â </span><a name="(part._block_notation)"/>block notation<span class="button-group"><a href="#(part._block_notation)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Another new language feature shown in these examples is that since Pyret
functions by default expect only a single (non-definition) expression, we have
to add the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">block</code></span> annotation at the top, indicating that the body of the
function is multiple expressions, with the final one being what the function
evaluates to.</p><p>As another example, if we tried to write:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function():
  1
  2
end</code></pre></div></div><p>Pyret would (rightly) error â€“ since the function returns the last expression in
its body, the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span> will be ignored â€“ and is most likely a mistake! Perhaps
the goal was to write:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function():
  1 + 2
end</code></pre></div></div><p>However, since a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> expression exists only to modify a variable,
functions that contain them <span class="emph">will</span> always have multiple expressions, and so
we need to communicate to Pyret that this is not a mistake. Adding <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">block</code></span>
before the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">:</code></span> that begins the function (or, in general, wrapping any
expressions in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">block:</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">end</code></span>) communicates to Pyret that we
understand that there are multiple expressions, and just want to evaluate to the
last one. So, if we truly wanted to write a function as our first example, we
could do that with:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function() block:
  1
  2
end</code></pre></div></div>&#13;
<h5 class="heading">9.1.8.5.3<span class="stt">Â </span><a name="(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)"/>How <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> works<span class="button-group"><a href="#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>A <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> expression runs its body once for each element in the input
list, adding an entry to the program directory for each element as it goes. It
does not produce any value directly, so much instead rely on modifying variables
(described above) to produce a computation.</p><p>Consider summing a list of numbers. We could write a function that does this,
following our pattern, as:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(lst :: List) block:
  var run_total = 0
  for each(item from lst):
    run_total := item + run_total
  end
  run_total
where:
  sum-list([list: 5, 1, 7, 3]) is 16
end</code></pre></div></div><p>On the concrete test input <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">[list: 5, 1, 7, 3]</code></span>, the loop runs four times,
once with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">item</code></span> set to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">5</code></span>, then with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">item</code></span> set to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1</code></span>,
then with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">item</code></span> set to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">7</code></span>, and finally with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">item</code></span> set to
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">3</code></span>.</p><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> construct saves us from writing the common code
multiple times, and also handles the fact that the lists we are
processing can be of arbitrary length (so we canâ€™t predict how many
times to write the common code). Thus, what happens is:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = run_total + 5
run_total = run_total + 1
run_total = run_total + 7
run_total = run_total + 3</code></pre></div></div>&#13;
<h5 class="heading">9.1.8.5.4<span class="stt">Â </span><a name="(part._.Testing_and_variables_that_can_change)"/>Testing and variables that can change<span class="button-group"><a href="#(part._.Testing_and_variables_that_can_change)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>We intentionally showed a very particular pattern of using variables that can
change. While there are other uses (explored in part in
<a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>), a main reason to stay with this particular
template is the difficulty in testing and correspondingly, understanding, code
that uses them in other ways.</p><p>In particular, note that the pattern means that we never define a variables that
can change <span class="emph">outside</span> a function, which means it can never be used by
different functions, or multiple function calls. Each time the function runs, a
new variable is created, it is modified in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> loop, and then
the value is returned, and the entry in the program directory is removed.</p><p>Consider what happens if we donâ€™t follow our pattern. Letâ€™s say we had the
following problem:</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Given a list of numbers, return the prefix of the list (i.e., all
elements, starting from the beginning) that sums to less than 100.</p></blockquote></blockquote><p>Having learned about mutable variables, but not following the pattern, you might
come up with code like this:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var count = 0

fun prefix-under-100(l :: List) -&gt; List:
  var output = [list: ]
  for each(elt from l):
    count := count + elt
    when (count &lt; 100):
      output := output + [list: elt]
    end
  end
end</code></pre></div></div><p>Now, this might seem reasonable â€“ weâ€™ve used a new construct, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">when</code></span>,
which is an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if</code></span> expression that has no <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">else</code></span> â€“ this only makes
sense to do inside of a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">for each</code></span> block, where we donâ€™t need a value as a
result. It is equivalent to:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if (count &lt; 100):
  output := output + [list: elt]
else:
  nothing
end</code></pre></div></div><p>Where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">nothing</code></span> is a value that is used in Pyret to indicate that there is
no particular value of importance.</p><p>But what happens when we use this function?</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
    prefix-under-100([list: 20, 30, 40]) is [list: 20, 30, 40]
    prefix-under-100([list: 80, 20, 10]) is [list: 80]
end</code></pre></div></div><p>The first two tests pass, but the last one doesnâ€™t. Why? If we run the first one
again, things are even more confusing, i.e., if instead of the above, we ran
this <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check</code></span> block:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
    prefix-under-100([list: 20, 30, 40]) is [list: 20, 30, 40]
    prefix-under-100([list: 80, 20, 10]) is [list: 80]
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
end</code></pre></div></div><p>Now the test that passed at first no longer passes!</p><p>What we are seeing is that since the variable is outside the function, it is
<span class="emph">shared</span> across different calls to the function. It is added to the program
directory once, and each time we call <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">prefix-under-100</code></span>, the program
directory entry is changed, but it is never reset.</p><p>Intentionally, all other uses of mutation have been on directory entries that
were created only for the body of the function, which meant that when the
function exited, they were removed. But now, we are always modifying the single
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">count</code></span> variable. This means that every time we call
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">prefix-under-100</code></span>, it behaves differently, because it not only do we have
to understand the code in the body of the function, we have to know the current
value of the count variable, which is not something we can figure out by just
looking at the code!</p><p>Functions that behave like this are said to have "side effects", and they are
much harder to test and much harder to understand, and as a result, much more
likely to have bugs! While the above example is wrong in a relatively
straightforward way, side effects can cause extremely subtle bugs that only
happen when functions are called in particular orders â€“ orders that may only
arised in very specific situations, making them hard to understand or reproduce.</p><p>While there are some places where doing this is necessary, almost all code can
be written without side effects, and will be much more reliable. We will explore
some cases where we might want to do this in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p>    
</body>
</html>