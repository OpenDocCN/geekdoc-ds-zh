<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>9.1Â From Pyret to PythonğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>9.1Â From Pyret to PythonğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/intro-python.html">https://dcic-world.org/2025-08-27/intro-python.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._.Expressions__.Functions__and_.Types%29" class="toclink" data-pltdoc="x">9.1.1Â Expressions, Functions, and Types</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Returning_.Values_from_.Functions%29" class="toclink" data-pltdoc="x">9.1.2Â Returning Values from Functions</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._testing-python%29" class="toclink" data-pltdoc="x">9.1.3Â Examples and Test Cases</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.An_.Aside_on_.Numbers%29" class="toclink" data-pltdoc="x">9.1.4Â An Aside on Numbers</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._conditionals-python%29" class="toclink" data-pltdoc="x">9.1.5Â Conditionals</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._python-create-process-lists%29" class="toclink" data-pltdoc="x">9.1.6Â Creating and Processing
Lists</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Filters__.Maps__and_.Friends%29" class="toclink" data-pltdoc="x">9.1.6.1Â Filters, Maps, and Friends</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._python-data-with-components%29" class="toclink" data-pltdoc="x">9.1.7Â Data with Components</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Accessing_.Fields_within_.Dataclasses%29" class="toclink" data-pltdoc="x">9.1.7.1Â Accessing Fields within Dataclasses</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._python-traverse-lists%29" class="toclink" data-pltdoc="x">9.1.8Â Traversing Lists</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._python-for-loops%29" class="toclink" data-pltdoc="x">9.1.8.1Â Introducing <code data-lang="text/x-python" class="sourceCode">For</code> Loops</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements%29" class="toclink" data-pltdoc="x">9.1.8.2Â An Aside on Order of Processing List Elements</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._python-funcs-produce-lists%29" class="toclink" data-pltdoc="x">9.1.8.3Â Using <code data-lang="text/x-python" class="sourceCode">For</code> Loops in Functions that Produce Lists</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Summary__.The_.List-.Processing_.Template_for_.Python%29" class="toclink" data-pltdoc="x">9.1.8.4Â Summary: The List-Processing Template for Python</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret%29" class="toclink" data-pltdoc="x">9.1.8.5Â <code data-lang="pyret" class="sourceCode">for each</code> loops in Pyret</a></p></td></tr><tr><td><p>Â Â Â Â Â Â Â Â <a href="#%28part._.Variables_that_can_change%29" class="toclink" data-pltdoc="x">9.1.8.5.1Â Variables that can change</a></p></td></tr><tr><td><p>Â Â Â Â Â Â Â Â <a href="#%28part._block_notation%29" class="toclink" data-pltdoc="x">9.1.8.5.2Â block notation</a></p></td></tr><tr><td><p>Â Â Â Â Â Â Â Â <a href="#%28part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works%29" class="toclink" data-pltdoc="x">9.1.8.5.3Â How <code data-lang="pyret" class="sourceCode">for each</code> works</a></p></td></tr><tr><td><p>Â Â Â Â Â Â Â Â <a href="#%28part._.Testing_and_variables_that_can_change%29" class="toclink" data-pltdoc="x">9.1.8.5.4Â Testing and variables that can change</a></p></td></tr></table><p>Through our work in Pyret to this point, weâ€™ve covered several core
programming skills: how to work with tables, how to design good
examples, the basics of creating datatypes, and how to work with the
fundamental computational building blocks of functions, conditionals,
and repetition (through <code data-lang="pyret" class="sourceCode">filter</code> and <code data-lang="pyret" class="sourceCode">map</code>, as well as
recursion). Youâ€™ve got a solid initial toolkit, as well as a wide
world of other possible programs ahead of you!</p><p>But weâ€™re going to shift gears for a little while and show you how to
work in Python instead. Why?</p><p>Seeing how the same concepts play out in multiple languages can help
you distinguish core computational ideas from the notations and idioms
of specific languages. If you plan to write programs as part of your
professional work, youâ€™ll inevitably have to work in different
languages at different times: weâ€™re giving you a chance to practice
that skill in a controlled and gentle setting.</p><p>Why do we call this gentle? Because the notations in Pyret were
designed partly with this transition in mind. Youâ€™ll find many
similarities between Pyret and Python at a notational level, yet also
some interesting differences that highlight some philosophical
differences that underlie languages. The next set of programs that we
want to write (specifically, data-rich programs where the data must be
updated and maintained over time) fit nicely with certain features of
Python that you havenâ€™t seen in Pyret. A future release will contain material that contrasts the strengths and weaknesses of the two languages.</p><p>We highlight the basic notational differences between Pyret and Python
by redoing some of our earlier code examples in Python.</p><section class="SsectionLevel4" id="section 9.1.1"><h4 class="heading">9.1.1Â <a name="(part._.Expressions__.Functions__and_.Types)"/>Expressions, Functions, and Types<a href="#(part._.Expressions__.Functions__and_.Types)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Back in <a href="From_Repeated_Expressions_to_Functions.html#%28part._pen-cost-pyret%29" data-pltdoc="x">Functions Practice: Cost of pens</a>, we introduced the notation for functions and types
using an example of computing the cost of an order of pens. An order
consisted of a number of pens and a message to be printed on the
pens. Each pen cost 25 cents, plus 2 cents per character for the
message. Here was the original Pyret code:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String) -&gt; Number:
  doc: ```total cost for pens, each 25 cents
          plus 2 cents per message character```
  num-pens * (0.25 + (string-length(message) * 0.02))
end</code></pre><p>Hereâ€™s the corresponding Python code:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def pen_cost(num_pens: int, message: str) -&gt; float:
    """total cost for pens, each at 25 cents plus
       2 cents per message character"""
    return num_pens * (0.25 + (len(message) * 0.02))</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What notational differences do you see between the two versions?</p></blockquote></blockquote><p>Hereâ€™s a summary of the differences:</p><ul><li><p>Python uses <code data-lang="text/x-python" class="sourceCode">def</code> instead of <code data-lang="pyret" class="sourceCode">fun</code>.</p></li><li><p>Python uses underscores in names (like <code data-lang="text/x-python" class="sourceCode">pen_cost</code>)
instead of hyphens as in Pyret.</p></li><li><p>The type names are written differently: Python uses <code data-lang="text/x-python" class="sourceCode">str</code>
and <code data-lang="text/x-python" class="sourceCode">int</code> instead of <code data-lang="pyret" class="sourceCode">String</code> and <code data-lang="pyret" class="sourceCode">Number</code>. In
addition, Python uses only a single colon before the type whereas
Pyret uses a double colon.</p></li><li><p>Python has different types for different kinds of numbers:
<code data-lang="text/x-python" class="sourceCode">int</code> is for integers, while <code data-lang="text/x-python" class="sourceCode">float</code> is for decimals.
Pyret just used a single type (<code data-lang="pyret" class="sourceCode">Number</code>)
for all numbers.</p></li><li><p>Python doesnâ€™t label the documentation string (as Pyret does with
<code data-lang="pyret" class="sourceCode">doc:</code>).</p></li><li><p>There is no <code data-lang="pyret" class="sourceCode">end</code> annotation in Python. Instead, Python
uses indentation to locate the end of an if/else statement, function, or
other multi-line construct.</p></li><li><p>Python labels the outputs of functions with <code data-lang="text/x-python" class="sourceCode">return</code>.</p></li></ul><p>These are minor differences in notation, which you will get used to as
you write more programs in Python.</p><p>There are differences beyond the notational ones. One that arises with
this sample program arises around how the language uses types. In
Pyret, if you put a type annotation on a parameter then pass it a
value of a different type, youâ€™ll get an error message. Python ignores
the type annotations (unless you bring in additional tools for
checking types). Python types are like notes for programmers, but they
arenâ€™t enforced when programs run.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p/><p>Convert the following <code data-lang="pyret" class="sourceCode">moon-weight</code> function from <a href="From_Repeated_Expressions_to_Functions.html#%28part._moon-weight-pyret%29" data-pltdoc="x">Functions Practice: Moon Weight</a> into Python:
</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun moon-weight(earth-weight :: Number) -&gt; Number:
  doc:" Compute weight on moon from weight on earth"
  earth-weight * 1/6
end</code></pre></blockquote></blockquote></section><section class="SsectionLevel4" id="section 9.1.2"><h4 class="heading">9.1.2Â <a name="(part._.Returning_.Values_from_.Functions)"/>Returning Values from Functions<a href="#(part._.Returning_.Values_from_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In Pyret, a function body consisted of optional statements to name
intermediate values, followed by a single expression. The value of
that single expression is the result of calling the function. In
Pyret, every function produces a result, so there is no need to label
where the result comes from.</p><p>As we will see, Python is different: not all â€œfunctionsâ€ return
results (note the name change from <code data-lang="pyret" class="sourceCode">fun</code> to
<code data-lang="text/x-python" class="sourceCode">def</code>).In mathematics, functions have results by
definition. Programmers sometimes distinguish between the terms â€œfunctionâ€
and â€œprocedureâ€: both refer to parameterized computations, but only
the former returns a result to the surrounding computation. Some
programmers and languages do, however, use the term â€œfunctionâ€ more
loosely to cover both kinds of parameterized computations.  Moreover,
the result isnâ€™t necessarily the last expression of the
<code data-lang="text/x-python" class="sourceCode">def</code>. In Python, the keyword <code data-lang="text/x-python" class="sourceCode">return</code> explicitly labels
the expression whose value serves as the result of the function.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><p>Put these two definitions in a Python file.
</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def add1v1(x: int) -&gt; int:
    return x + 1

def add1v2(x: int) -&gt; int:
    x + 1</code></pre><p>At the Python prompt, call each function in turn. What do you notice
about the result from using each function?</p></blockquote></blockquote><p>Hopefully, you noticed that using <code data-lang="text/x-python" class="sourceCode">add1v1</code> displays an answer
after the prompt, while using <code data-lang="text/x-python" class="sourceCode">add1v2</code> does not. This
difference has consequences for composing functions.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Try evaluating the following two expressions at the Python prompt:
what happens in each case?</p><p><code data-lang="text/x-python" class="sourceCode">3 * add1v1(4)</code></p><p><code data-lang="text/x-python" class="sourceCode">3 * add1v2(4)</code></p></blockquote></blockquote><p>This example illustrates why <code data-lang="text/x-python" class="sourceCode">return</code> is essential in Python:
without it, no value is returned, which means you canâ€™t use the result
of a function within another expression. So what use is
<code data-lang="text/x-python" class="sourceCode">add1v2</code> then? Hold that question; weâ€™ll return to it in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p></section><section class="SsectionLevel4" id="section 9.1.3"><h4 class="heading">9.1.3Â <a name="(part._testing-python)"/>Examples and Test Cases<a href="#(part._testing-python)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In Pyret, we included examples with every function using <code data-lang="pyret" class="sourceCode">where:</code>
blocks. We also had the ability to write <code data-lang="pyret" class="sourceCode">check:</code> blocks for more
extensive tests. As a reminder, here was the <code data-lang="pyret" class="sourceCode">pen-cost</code> code
including a <code data-lang="pyret" class="sourceCode">where:</code> block:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String) -&gt; Number:
  doc: ```total cost for pens, each 25 cents
       plus 2 cents per message character```
  num-pens * (0.25 + (string-length(message) * 0.02))
where:
  pen-cost(1, "hi") is 0.29
  pen-cost(10, "smile") is 3.50
end</code></pre><p>Python does not have a notion of <code data-lang="pyret" class="sourceCode">where:</code> blocks, or a
distinction between examples and tests. There are a couple of
different testing packages for Python; here we will use <code data-lang="text/x-python" class="sourceCode">pytest</code>,
a standard lightweight framework that resembles the form of testing
that we did in Pyret.How you set up pytest and your test
file contents will vary according to your Python IDE. We assume
instructors will provide separate instructions that align with their
tool choices. To use <code data-lang="text/x-python" class="sourceCode">pytest</code>, we put both examples
and tests in a separate function. Hereâ€™s an example of this for the
<code data-lang="text/x-python" class="sourceCode">pen_cost</code> function:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">import pytest

def pen_cost(num_pens: int, message: str) -&gt; float:
    """total cost for pens, each at 25 cents plus
       2 cents per message character"""
    return num_pens * (0.25 + (len(message) * 0.02))

def test_pens():
  assert pen_cost(1, "hi") == 0.29
  assert pen_cost(10, "smile") == 3.50</code></pre><p>Things to note about this code:</p><ul><li><p>Weâ€™ve imported <code data-lang="text/x-python" class="sourceCode">pytest</code>, the lightweight Python testing
library.</p></li><li><p>The examples have moved into a function (here
<code data-lang="text/x-python" class="sourceCode">test_pens</code>) that takes no inputs. Note that the names of
functions that contain test cases must have names that start with
<code data-lang="text/x-python" class="sourceCode">test_</code> in order for <code data-lang="text/x-python" class="sourceCode">pytest</code> to find them.</p></li><li><p/><p>In Python, individual tests have the form
</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert EXPRESSION == EXPECTED_ANS</code></pre><p>rather than the <code data-lang="pyret" class="sourceCode">is</code> form from Pyret.</p></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><p>Add one more test to the Python code, corresponding to the Pyret test
</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pen-cost(3, "wow") is 0.93</code></pre><p>Make sure to run the test.</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Did you actually try to run the test?</p></blockquote></blockquote><p>Whoa! Something weird happened: the test failed. Stop and think
about that: the same test that worked in Pyret failed in
Python. How can that be?</p></section><section class="SsectionLevel4" id="section 9.1.4"><h4 class="heading">9.1.4Â <a name="(part._.An_.Aside_on_.Numbers)"/>An Aside on Numbers<a href="#(part._.An_.Aside_on_.Numbers)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>It turns out that different programming languages make different
decisions about how to represent and manage real (non-integer)
numbers. Sometimes, differences in these representations lead to
subtle quantitative differences in computed values. As a simple
example, letâ€™s look at two seemingly simple real numbers <code data-lang="pyret" class="sourceCode">1/2</code> and
<code data-lang="pyret" class="sourceCode">1/3</code>. Hereâ€™s what we get when we type these two numbers at a
Pyret prompt:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/2</code></pre></blockquote></td></tr></table></td></tr><tr><td><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0.5</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/3</code></pre></blockquote></td></tr></table></td></tr><tr><td><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0.3</code></pre></td></tr></table><p>If we type these same two numbers in a Python console, we instead get:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/2</code></pre></blockquote></td></tr></table></td></tr><tr><td><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0.5</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/3</code></pre></blockquote></td></tr></table></td></tr><tr><td><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0.3333333333333333</code></pre></td></tr></table><p>Notice that the answers look different for <code data-lang="pyret" class="sourceCode">1/3</code>. As you may (or
may not!) recall from an earlier math class, <code data-lang="pyret" class="sourceCode">1/3</code> is an example of a
non-terminating, repeating decimal. In plain terms, if we tried to
write out the exact value of <code data-lang="pyret" class="sourceCode">1/3</code> in decimal form, we would need
to write an infinite sequence of <code data-lang="pyret" class="sourceCode">3</code>. Mathematicians denote this
by putting a horizontal bar over the <code data-lang="pyret" class="sourceCode">3</code>. This is the notation we
see in Pyret. Python, in contrast, writes out a partial sequence of
<code data-lang="pyret" class="sourceCode">3</code>s.</p><p>Underneath this distinction lies some interesting details about
representing numbers in computers. Computers donâ€™t have infinite space
to store numbers (or anything else, for that matter): when a program
needs to work with a non-terminating decimal, the underlying language
can either:</p><ul><li><p>approximate the number (by chopping off the infinite sequence
of digits at some point), then work only with the approximated value
going forward, or</p></li><li><p>store additional information about the number that may enable doing
more precise computation with it later (though there are always some
numbers that cannot be represented exactly in finite space).</p></li></ul><p>Python takes the first approach. As a result, computations with the
approximated values sometimes yield approximated results. This is what
happens with our new <code data-lang="text/x-python" class="sourceCode">pen_cost</code> test case. While
mathematically, the computation should result in <code data-lang="text/x-python" class="sourceCode">0.93</code>, the
approximations yield <code data-lang="text/x-python" class="sourceCode">0.9299999999999999</code> instead.</p><p>So how do we write tests in this situation? We need to tell Python
that the answer should be â€œcloseâ€ to <code data-lang="text/x-python" class="sourceCode">0.93</code>, within the error
range of approximations. Hereâ€™s what that looks like:</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert pen_cost(3, "wow") == pytest.approx(0.93)</code></pre><p>We wrapped the exact answer we wanted in <code data-lang="text/x-python" class="sourceCode">pytest.approx</code>, to
indicate that weâ€™ll accept any answer that is nearly the value we
specified. You can control the number of decimal points of precision
if you want to, but the default of <code data-lang="pyret" class="sourceCode">Â± 2.3e-06</code> often suffices.</p></section><section class="SsectionLevel4" id="section 9.1.5"><h4 class="heading">9.1.5Â <a name="(part._conditionals-python)"/>Conditionals<a href="#(part._conditionals-python)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Continuing with our original <code data-lang="text/x-python" class="sourceCode">pen_cost</code> example, hereâ€™s the
Python version of the function that computed shipping costs on an
order:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def add_shipping(order_amt: float) -&gt; float:
    """increase order price by costs for shipping"""
    if order_amt == 0:
      return 0
    elif order_amt &lt;= 10:
      return order_amt + 4
    elif (order_amt &gt; 10) and (order_amt &lt; 30):
      return order_amt + 8
    else:
      return order_amt + 12</code></pre><p>The main difference to notice here is that <code data-lang="pyret" class="sourceCode">else if</code> is written
as the single-word <code data-lang="text/x-python" class="sourceCode">elif</code> in Python. We use <code data-lang="text/x-python" class="sourceCode">return</code> to
mark the functionâ€™s results in each branch of the conditional.
Otherwise, the conditional constructs are quite similar across the
two languages.</p><p>You may have noticed that Python does not require an explicit
<code data-lang="pyret" class="sourceCode">end</code> annotation on <code data-lang="pyret" class="sourceCode">if</code>-expressions or functions. Instead,
Python looks at the indentation of your code to determine when a
construct has ended. For example, in the code sample for
<code data-lang="text/x-python" class="sourceCode">pen_cost</code> and <code data-lang="text/x-python" class="sourceCode">test_pens</code>, Python determines that the
<code data-lang="text/x-python" class="sourceCode">pen_cost</code> function has ended because it detects a new
definition (for <code data-lang="text/x-python" class="sourceCode">test_pens</code>) at the left edge of the program
text. The same principle holds for ending conditionals.</p><p>Weâ€™ll return to this point about indentation, and see more examples,
as we work more with Python.</p></section><section class="SsectionLevel4" id="section 9.1.6"><h4 class="heading">9.1.6Â <a name="(part._python-create-process-lists)"/>Creating and Processing
Lists<a href="#(part._python-create-process-lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>As an example of lists, letâ€™s assume weâ€™ve been playing a game that
involves making words out of a collection of letters. In Pyret, we
could have written a sample word list as follows:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">words = [list: "banana", "bean", "falafel", "leaf"]</code></pre><p>In Python, this definition would look like:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">words = ["banana", "bean", "falafel", "leaf"]</code></pre><p>The only difference here is that Python does not use the <code data-lang="pyret" class="sourceCode">list:</code>
label that is needed in Pyret.</p><section class="SsectionLevel5" id="section 9.1.6.1"><h5 class="heading">9.1.6.1Â <a name="(part._.Filters__.Maps__and_.Friends)"/>Filters, Maps, and Friends<a href="#(part._.Filters__.Maps__and_.Friends)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>When we first learned about lists in Pyret, we started with common
built-in functions such as <code data-lang="pyret" class="sourceCode">filter</code>, <code data-lang="pyret" class="sourceCode">map</code>, <code data-lang="pyret" class="sourceCode">member</code>
and <code data-lang="pyret" class="sourceCode">length</code>. We also saw the use of <code data-lang="pyret" class="sourceCode">lambda</code> to help us use
some of these functions concisely. These same functions, including
<code data-lang="pyret" class="sourceCode">lambda</code>, also exist in Python. Here are some samples (<code data-lang="text/x-python" class="sourceCode">#</code> is the comment character in Python):</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">words = ["banana", "bean", "falafel", "leaf"]

# filter and member
words_with_b = list(filter(lambda wd: "b" in wd, words))
# filter and length
short_words = list(filter(lambda wd: len(wd) &lt; 5, words))
# map and length
word_lengths = list(map(len, words))</code></pre><p>Note that you have to wrap calls to <code data-lang="text/x-python" class="sourceCode">filter</code> (and <code data-lang="text/x-python" class="sourceCode">map</code>)
with a use of <code data-lang="text/x-python" class="sourceCode">list()</code>. Internally, Python has these functions
return a type of data that we havenâ€™t yet discussed (and donâ€™t
need). Using <code data-lang="text/x-python" class="sourceCode">list</code> converts the returned data into a list. If
you omit the <code data-lang="text/x-python" class="sourceCode">list</code>, you wonâ€™t be able to chain certain
functions together. For example, if we tried to compute the length of
the result of a <code data-lang="text/x-python" class="sourceCode">map</code> without first converting to a
<code data-lang="text/x-python" class="sourceCode">list</code>, weâ€™d get an error:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">len(map(len,b))</code></pre></blockquote></td></tr></table></td></tr><tr><td><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">TypeError: object of type 'map' has no len()</code></pre></td></tr></table><p>Donâ€™t worry if this error message makes no sense at the moment (we
havenâ€™t yet learned what an â€œobjectâ€ is). The point is that if you see
an error like this while using the result of <code data-lang="text/x-python" class="sourceCode">filter</code> or
<code data-lang="text/x-python" class="sourceCode">map</code>, you likely forgot to wrap the result in <code data-lang="text/x-python" class="sourceCode">list</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Practice Pythonâ€™s list functions by writing expressions for the following
problems. Use only the list functions we have shown you so far.</p><ul><li><p>Given a list of numbers, convert it to a list of strings <code data-lang="text/x-python" class="sourceCode">"pos"</code>, <code data-lang="text/x-python" class="sourceCode">"neg"</code>, <code data-lang="text/x-python" class="sourceCode">"zero"</code>, based on the sign of each number.</p></li><li><p>Given a list of strings, is the length of any string equal to 5?</p></li><li><p>Given a list of numbers, produce a list of the even numbers between 10 and 20 from that list.</p></li></ul></blockquote></blockquote><p>Weâ€™re intentionally focusing on computations that use Pythonâ€™s built-in
functions for processing lists, rather than showing you how to write
you own (as we did with recursion in Pyret). While you can write
recursive functions to process lists in Pyret, a different style of
program is more conventional for that purpose. Weâ€™ll look at that in
the chapter on <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p></section></section><section class="SsectionLevel4" id="section 9.1.7"><h4 class="heading">9.1.7Â <a name="(part._python-data-with-components)"/>Data with Components<a href="#(part._python-data-with-components)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>An analog to a Pyret data definition (without variants) is called a dataclass in
Python.Those experienced with Python may wonder why we are
using dataclasses instead of dictionaries or raw classes. Compared to
dictionaries, dataclasses allow the use of type hints and capture that
our data has a fixed collection of fields. Compared to raw classes,
dataclasses generate a lot of boilerplate code that makes them much
lighterweight than raw classes. Hereâ€™s an example of a todo-list
datatype in Pyret and its corresponding Python code:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode"># a todo item in Pyret
data ToDoItemData:
  | todoItem(descr :: String,
             due :: Date,
             tags :: List&lt;String&gt;
end</code></pre><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">------------------------------------------
# the same todo item in Python

# to allow use of dataclasses
from dataclasses import dataclass
# to allow dates as a type (in the ToDoItem)
from datetime import date

@dataclass
class ToDoItem:
    descr: str
    due: date
    tags: list

# a sample list of ToDoItem
myTD = [ToDoItem("buy milk", date(2020, 7, 27), ["shopping", "home"]),
        ToDoItem("grade hwk", date(2020, 7, 27), ["teaching"]),
        ToDoItem("meet students", date(2020, 7, 26), ["research"])
       ]</code></pre><p>Things to note:</p><ul><li><p>There is a single name for the type and the constructor, rather
than separate names as we had in Pyret.</p></li><li><p>There are no commas between field names (but each has to be on
its own line in Python)</p></li><li><p>There is no way to specify the type of the contents of the list
in Python (at least, not without using more advance packages for
writing types)</p></li><li><p>The <code data-lang="text/x-python" class="sourceCode">@dataclass</code> annotation is needed before
<code data-lang="text/x-python" class="sourceCode">class</code>.</p></li><li><p>Dataclasses donâ€™t support creating datatypes with multiple
variants, like we did frequently in Pyret. Doing that needs more
advanced concepts than we will cover in this book.</p></li></ul><section class="SsectionLevel5" id="section 9.1.7.1"><h5 class="heading">9.1.7.1Â <a name="(part._.Accessing_.Fields_within_.Dataclasses)"/>Accessing Fields within Dataclasses<a href="#(part._.Accessing_.Fields_within_.Dataclasses)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>In Pyret, we extracted a field from structured data by using a dot
(period) to â€œdig intoâ€ the datum and access the field. The same
notation works in Python:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">travel = ToDoItem("buy tickets", date(2020, 7, 30), ["vacation"])</code></pre></blockquote></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">travel.descr</code></pre></blockquote></td></tr></table></td></tr><tr><td><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"buy tickets"</code></pre></td></tr></table></section></section><section class="SsectionLevel4" id="section 9.1.8"><h4 class="heading">9.1.8Â <a name="(part._python-traverse-lists)"/>Traversing Lists<a href="#(part._python-traverse-lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><section class="SsectionLevel5" id="section 9.1.8.1"><h5 class="heading">9.1.8.1Â <a name="(part._python-for-loops)"/>Introducing <code data-lang="text/x-python" class="sourceCode">For</code> Loops<a href="#(part._python-for-loops)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p/><p>In Pyret, we typically write recursive functions to compute summary values over
lists. As a reminder, hereâ€™s a Pyret function that sums the numbers in
a list:
</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(numlist :: List&lt;Number&gt;) -&gt; Number:
  cases (List) numlist:
    | empty =&gt; 0
    | link(fst, rst) =&gt; fst + sum-list(rst)
  end
end</code></pre><p>In Python, it is unusual to break a list into its first and rest
components and process the rest recursively. Instead, we use a construct called a <code data-lang="text/x-python" class="sourceCode">for</code> to
visit each element of a list in turn. Hereâ€™s the form of <code data-lang="text/x-python" class="sourceCode">for</code>,
using a concrete (example) list of odd numbers:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for num in [5, 1, 7, 3]:
   # do something with num</code></pre><p/><p>The name <code data-lang="text/x-python" class="sourceCode">num</code> here is of our choosing, just as with the names
of parameters to a function in Pyret.  When a <code data-lang="text/x-python" class="sourceCode">for</code> loop
evaluates, each item in the list is referred to as <code data-lang="text/x-python" class="sourceCode">num</code> in
turn. Thus, this <code data-lang="text/x-python" class="sourceCode">for</code> example is equivalent to writing the
following:
</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># do something with 5
# do something with 1
# do something with 7
# do something with 3</code></pre><p>The <code data-lang="text/x-python" class="sourceCode">for</code> construct saves us from writing the common code
multiple times, and also handles the fact that the lists we are
processing can be of arbitrary length (so we canâ€™t predict how many
times to write the common code).</p><p>Letâ€™s now use <code data-lang="text/x-python" class="sourceCode">for</code> to compute the running sum of a list. Weâ€™ll
start by figuring out the repeated computation with our concrete list
again. At first, letâ€™s express the repeated computation just in
prose. In Pyret, our repeated computation was along the lines of â€œadd
the first item to the sum of the rest of the itemsâ€. Weâ€™ve already
said that we cannot easily access the â€œrest of the itemsâ€ in Python,
so we need to rephrase this. Hereâ€™s an alternative:</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># set a running total to 0
# add 5 to the running total
# add 1 to the running total
# add 7 to the running total
# add 3 to the running total</code></pre><p>Note that this framing refers not to the â€œrest of the computationâ€,
but rather to the computation that has happened so far (the â€œrunning
totalâ€). If you happened to work through the chapter on <a href="processing-lists.html#%28part._running-sum-eg-code%29" data-pltdoc="x"><code data-lang="pyret" class="sourceCode">my-running-sum</code>: Examples and Code</a>, this framing might be familiar.</p><p>Letâ€™s convert this prose sketch to code by replacing each line of the
sketch with concrete code. We do this by setting up a variable named
<code data-lang="text/x-python" class="sourceCode">run_total</code> and updating its value for each element.</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = run_total + 5
run_total = run_total + 1
run_total = run_total + 7
run_total = run_total + 3</code></pre><p>This idea that you can give a new value to an existing variable name
is something we havenâ€™t seen before. In fact, when we first saw how to
name values (in <a href="Naming_Values.html#%28part._program-directory%29" data-pltdoc="x">The Program Directory</a>), we explicitly said that
Pyret doesnâ€™t let
you do this (at least, not with the constructs that we showed you). Python does. Weâ€™ll explore the consequences of this ability in
more depth shortly (in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>). For now, letâ€™s just use that ability so we can
learn the pattern for traversing lists. First, letâ€™s collapse the repeated lines of code
into a single use of <code data-lang="text/x-python" class="sourceCode">for</code>:</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
for num in [5, 1, 7, 3]:
   run_total = run_total + num</code></pre><p>This code works fine for a specific list, but our Pyret version took
the list to sum as a parameter to a function. To achieve this in
Python, we wrap the <code data-lang="text/x-python" class="sourceCode">for</code> in a function as we have done for
other examples earlier in this chapter. This is the final version.</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def sum_list(numlist : list) -&gt; float:
    """sum a list of numbers"""
    run_total = 0
    for num in numlist:
        run_total = run_total + num
    return(run_total)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write a set of tests for <code data-lang="text/x-python" class="sourceCode">sum_list</code> (the Python version).</p></blockquote></blockquote><p>Now that the Python version is done, letâ€™s compare it to the original Pyret
version:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(numlist :: List&lt;Number&gt;) -&gt; Number:
  cases (List) numlist:
    | empty =&gt; 0
    | link(fst, rst) =&gt; fst + sum-list(rst)
  end
end</code></pre><p>Here are some things to notice about the two pieces of code:</p><ul><li><p>The Python version needs a variable (here <code data-lang="text/x-python" class="sourceCode">run_total</code>) to
hold the result of the computation as we build it up while traversing
(working through) the list.</p></li><li><p>The initial value of that variable is the answer we returned in
the <code data-lang="pyret" class="sourceCode">empty</code> case in Pyret.</p></li><li><p>The computation in the <code data-lang="pyret" class="sourceCode">link</code> case of the Pyret function is
used to update that variable in the body of the <code data-lang="text/x-python" class="sourceCode">for</code>.</p></li><li><p>After the <code data-lang="text/x-python" class="sourceCode">for</code> has finished processing all items in the
list, the Python version returns the value in the variable as the
result of the function.</p></li></ul></section><section class="SsectionLevel5" id="section 9.1.8.2"><h5 class="heading">9.1.8.2Â <a name="(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)"/>An Aside on Order of Processing List Elements<a href="#(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Thereâ€™s another subtlety here if we consider how the two programs run:
the Python version sums the elements from left to right, whereas
the Pyret version sums them right to left. Concretely, the sequence of
values of <code data-lang="text/x-python" class="sourceCode">run_total</code> are computed as:</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = 0 + 5
run_total = 5 + 1
run_total = 6 + 7
run_total = 13 + 3</code></pre><p>In contrast, the Pyret version unrolls as:
</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum_list([list: 5, 1, 7, 3])
5 + sum_list([list: 1, 7, 3])
5 + 1 + sum_list([list: 7, 3])
5 + 1 + 7 + sum_list([list: 3])
5 + 1 + 7 + 3 + sum_list([list:])
5 + 1 + 7 + 3 + 0
5 + 1 + 7 + 3
5 + 1 + 10
5 + 11
16</code></pre><p>As a reminder, the Pyret version did this because the <code data-lang="pyret" class="sourceCode">+</code> in the
<code data-lang="pyret" class="sourceCode">link</code> case can only reduce to an answer once the sum of the rest
of the list has been computed. Even though we as humans see the chain
of <code data-lang="pyret" class="sourceCode">+</code> operations in each line of the Pyret unrolling, Pyret sees
only the expression <code data-lang="pyret" class="sourceCode">fst + sum-list(rst)</code>, which requires the
function call to finish before the <code data-lang="pyret" class="sourceCode">+</code> executes.</p><p>In the case of summing a list, we donâ€™t notice the difference between
the two versions because the sum is the same whether we compute it
left-to-right or right-to-left. In other functions we write, this
difference may start to matter.</p></section><section class="SsectionLevel5" id="section 9.1.8.3"><h5 class="heading">9.1.8.3Â <a name="(part._python-funcs-produce-lists)"/>Using <code data-lang="text/x-python" class="sourceCode">For</code> Loops in Functions that Produce Lists<a href="#(part._python-funcs-produce-lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s practice using <code data-lang="text/x-python" class="sourceCode">for</code> loops on another function that
traverses lists, this time one that produces a list. Specifically,
letâ€™s write a program that takes a list of strings and produces a list
of words within that list that contain the letter <code data-lang="text/x-python" class="sourceCode">"z"</code>.</p><p>As in our <code data-lang="text/x-python" class="sourceCode">sum_list</code> function, we will need a variable to store
the resulting list as we build it up. The following code calls this
<code data-lang="text/x-python" class="sourceCode">zlist</code>. The code also shows how to use <code data-lang="text/x-python" class="sourceCode">in</code> to check
whether a character is in a string (it also works for checking whether
an item is in a list) and how to add an element to the end of a list
(<code data-lang="text/x-python" class="sourceCode">append</code>).</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def all_z_words(wordlist : list) -&gt; list:
    """produce list of words from the input that contain z"""
    zlist = [] # start with an empty list
    for wd in wordlist:
        if "z" in wd:
            zlist = [wd] + zlist
    return(zlist)</code></pre><p>This code follows the structure of <code data-lang="text/x-python" class="sourceCode">sum_list</code>, in that we
update the value of <code data-lang="text/x-python" class="sourceCode">zlist</code> using an expression similar to what
we would have used in Pyret. For those with prior Python
experience who would have used <code data-lang="text/x-python" class="sourceCode">zlist.append</code> here, hold that
thought. We will get there in <a href="mutable-lists.html" data-pltdoc="x">Mutable Lists</a>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write tests for <code data-lang="text/x-python" class="sourceCode">all_z_words</code>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a second version of <code data-lang="text/x-python" class="sourceCode">all_z_words</code> using
<code data-lang="text/x-python" class="sourceCode">filter</code>. Be sure to write tests for it!</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Contrast these two versions and the corresponding tests. Did you
notice anything interesting?</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 9.1.8.4"><h5 class="heading">9.1.8.4Â <a name="(part._.Summary__.The_.List-.Processing_.Template_for_.Python)"/>Summary: The List-Processing Template for Python<a href="#(part._.Summary__.The_.List-.Processing_.Template_for_.Python)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Just as we had a template for writing list-processing functions in
Pyret, there is a corresponding template in Python based on
<code data-lang="text/x-python" class="sourceCode">for</code> loops. As a reminder, that pattern is as follow:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def func(lst: list):
  result = ...  # what to return if the input list is empty
  for item in lst:
    # combine item with the result so far
    result = ... item ... result
  return result</code></pre><p>Keep this template in mind as you learn to write functions over lists
in Python.</p></section><section class="SsectionLevel5" id="section 9.1.8.5"><h5 class="heading">9.1.8.5Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)"/><code data-lang="pyret" class="sourceCode">for each</code> loops in Pyret<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>This section can be read
without reading the rest of this chapter, so if you have been directed to it
before being introduced to Python, do not worry! While the content below mirrors
similar constructs that exist in Python, it is introduced on its own.</p><p>The previous sections introduced <code data-lang="text/x-python" class="sourceCode">for</code> loops in Python, and showed a
template for processing lists with them. Pyret can
do similar, using the following pattern:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun func(lst :: List) block:
  var result = ...  # what to return if the input list is empty
  for each(item from lst):
    # combine item with the result so far
    result := ... item ... result
  end
  result
end</code></pre><p>There are a few new language features used in this example, introduced in the
following several sections.</p><section class="SsectionLevel6" id="section 9.1.8.5.1"><h5 class="heading">9.1.8.5.1Â <a name="(part._.Variables_that_can_change)"/>Variables that can change<a href="#(part._.Variables_that_can_change)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>First, note that we introduce the variable <code data-lang="pyret" class="sourceCode">result</code> with <code data-lang="pyret" class="sourceCode">var result</code>
â€“ this means that it can vary, which is important for the use with
<code data-lang="pyret" class="sourceCode">for each</code>.</p><p>By default, all variables in the program directory can never be changed. i.e.,
if I define a variable <code data-lang="pyret" class="sourceCode">x</code>, I can not redefine it later:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x = 10
# ...
x = 20 # produces shadowing error</code></pre><p>If we do want to change (or mutate) a variable in the directory later, we can, but we must
declare the variable can change â€“ as in, when we define it, rather than writing
<code data-lang="pyret" class="sourceCode">x = 10</code>, we must write <code data-lang="pyret" class="sourceCode">var x = 10</code>. Then, when we want to
update it, we can do so with the <code data-lang="pyret" class="sourceCode">:=</code> operator, as is done in the template above.</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var x = 10
# ... x points to 10 in directory
x := 20
# ... x now points to 20 in directory</code></pre><p>Note that trying to use <code data-lang="pyret" class="sourceCode">:=</code> on a variable that was not declared using
<code data-lang="pyret" class="sourceCode">var</code> will produce an error, and variables can still only ever be declared
once (whether with <code data-lang="pyret" class="sourceCode">var x = ...</code> or <code data-lang="pyret" class="sourceCode">x = ...</code>).</p></section><section class="SsectionLevel6" id="section 9.1.8.5.2"><h5 class="heading">9.1.8.5.2Â <a name="(part._block_notation)"/>block notation<a href="#(part._block_notation)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Another new language feature shown in these examples is that since Pyret
functions by default expect only a single (non-definition) expression, we have
to add the <code data-lang="pyret" class="sourceCode">block</code> annotation at the top, indicating that the body of the
function is multiple expressions, with the final one being what the function
evaluates to.</p><p>As another example, if we tried to write:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function():
  1
  2
end</code></pre><p>Pyret would (rightly) error â€“ since the function returns the last expression in
its body, the <code data-lang="pyret" class="sourceCode">1</code> will be ignored â€“ and is most likely a mistake! Perhaps
the goal was to write:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function():
  1 + 2
end</code></pre><p>However, since a <code data-lang="pyret" class="sourceCode">for each</code> expression exists only to modify a variable,
functions that contain them will always have multiple expressions, and so
we need to communicate to Pyret that this is not a mistake. Adding <code data-lang="pyret" class="sourceCode">block</code>
before the <code data-lang="pyret" class="sourceCode">:</code> that begins the function (or, in general, wrapping any
expressions in <code data-lang="pyret" class="sourceCode">block:</code> and <code data-lang="pyret" class="sourceCode">end</code>) communicates to Pyret that we
understand that there are multiple expressions, and just want to evaluate to the
last one. So, if we truly wanted to write a function as our first example, we
could do that with:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function() block:
  1
  2
end</code></pre></section><section class="SsectionLevel6" id="section 9.1.8.5.3"><h5 class="heading">9.1.8.5.3Â <a name="(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)"/>How <code data-lang="pyret" class="sourceCode">for each</code> works<a href="#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>A <code data-lang="pyret" class="sourceCode">for each</code> expression runs its body once for each element in the input
list, adding an entry to the program directory for each element as it goes. It
does not produce any value directly, so much instead rely on modifying variables
(described above) to produce a computation.</p><p>Consider summing a list of numbers. We could write a function that does this,
following our pattern, as:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(lst :: List) block:
  var run_total = 0
  for each(item from lst):
    run_total := item + run_total
  end
  run_total
where:
  sum-list([list: 5, 1, 7, 3]) is 16
end</code></pre><p>On the concrete test input <code data-lang="pyret" class="sourceCode">[list: 5, 1, 7, 3]</code>, the loop runs four times,
once with <code data-lang="pyret" class="sourceCode">item</code> set to <code data-lang="pyret" class="sourceCode">5</code>, then with <code data-lang="pyret" class="sourceCode">item</code> set to <code data-lang="pyret" class="sourceCode">1</code>,
then with <code data-lang="pyret" class="sourceCode">item</code> set to <code data-lang="pyret" class="sourceCode">7</code>, and finally with <code data-lang="pyret" class="sourceCode">item</code> set to
<code data-lang="pyret" class="sourceCode">3</code>.</p><p>The <code data-lang="pyret" class="sourceCode">for each</code> construct saves us from writing the common code
multiple times, and also handles the fact that the lists we are
processing can be of arbitrary length (so we canâ€™t predict how many
times to write the common code). Thus, what happens is:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = run_total + 5
run_total = run_total + 1
run_total = run_total + 7
run_total = run_total + 3</code></pre></section><section class="SsectionLevel6" id="section 9.1.8.5.4"><h5 class="heading">9.1.8.5.4Â <a name="(part._.Testing_and_variables_that_can_change)"/>Testing and variables that can change<a href="#(part._.Testing_and_variables_that_can_change)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>We intentionally showed a very particular pattern of using variables that can
change. While there are other uses (explored in part in
<a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>), a main reason to stay with this particular
template is the difficulty in testing and correspondingly, understanding, code
that uses them in other ways.</p><p>In particular, note that the pattern means that we never define a variables that
can change outside a function, which means it can never be used by
different functions, or multiple function calls. Each time the function runs, a
new variable is created, it is modified in the <code data-lang="pyret" class="sourceCode">for each</code> loop, and then
the value is returned, and the entry in the program directory is removed.</p><p>Consider what happens if we donâ€™t follow our pattern. Letâ€™s say we had the
following problem:</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Given a list of numbers, return the prefix of the list (i.e., all
elements, starting from the beginning) that sums to less than 100.</p></blockquote></blockquote><p>Having learned about mutable variables, but not following the pattern, you might
come up with code like this:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var count = 0

fun prefix-under-100(l :: List) -&gt; List:
  var output = [list: ]
  for each(elt from l):
    count := count + elt
    when (count &lt; 100):
      output := output + [list: elt]
    end
  end
end</code></pre><p>Now, this might seem reasonable â€“ weâ€™ve used a new construct, <code data-lang="pyret" class="sourceCode">when</code>,
which is an <code data-lang="pyret" class="sourceCode">if</code> expression that has no <code data-lang="pyret" class="sourceCode">else</code> â€“ this only makes
sense to do inside of a <code data-lang="pyret" class="sourceCode">for each</code> block, where we donâ€™t need a value as a
result. It is equivalent to:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if (count &lt; 100):
  output := output + [list: elt]
else:
  nothing
end</code></pre><p>Where <code data-lang="pyret" class="sourceCode">nothing</code> is a value that is used in Pyret to indicate that there is
no particular value of importance.</p><p>But what happens when we use this function?</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
    prefix-under-100([list: 20, 30, 40]) is [list: 20, 30, 40]
    prefix-under-100([list: 80, 20, 10]) is [list: 80]
end</code></pre><p>The first two tests pass, but the last one doesnâ€™t. Why? If we run the first one
again, things are even more confusing, i.e., if instead of the above, we ran
this <code data-lang="pyret" class="sourceCode">check</code> block:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
    prefix-under-100([list: 20, 30, 40]) is [list: 20, 30, 40]
    prefix-under-100([list: 80, 20, 10]) is [list: 80]
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
end</code></pre><p>Now the test that passed at first no longer passes!</p><p>What we are seeing is that since the variable is outside the function, it is
shared across different calls to the function. It is added to the program
directory once, and each time we call <code data-lang="pyret" class="sourceCode">prefix-under-100</code>, the program
directory entry is changed, but it is never reset.</p><p>Intentionally, all other uses of mutation have been on directory entries that
were created only for the body of the function, which meant that when the
function exited, they were removed. But now, we are always modifying the single
<code data-lang="pyret" class="sourceCode">count</code> variable. This means that every time we call
<code data-lang="pyret" class="sourceCode">prefix-under-100</code>, it behaves differently, because it not only do we have
to understand the code in the body of the function, we have to know the current
value of the count variable, which is not something we can figure out by just
looking at the code!</p><p>Functions that behave like this are said to have "side effects", and they are
much harder to test and much harder to understand, and as a result, much more
likely to have bugs! While the above example is wrong in a relatively
straightforward way, side effects can cause extremely subtle bugs that only
happen when functions are called in particular orders â€“ orders that may only
arised in very specific situations, making them hard to understand or reproduce.</p><p>While there are some places where doing this is necessary, almost all code can
be written without side effects, and will be much more reliable. We will explore
some cases where we might want to do this in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p></section></section></section>&#13;
<h4 class="heading">9.1.1Â <a name="(part._.Expressions__.Functions__and_.Types)"/>Expressions, Functions, and Types<a href="#(part._.Expressions__.Functions__and_.Types)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Back in <a href="From_Repeated_Expressions_to_Functions.html#%28part._pen-cost-pyret%29" data-pltdoc="x">Functions Practice: Cost of pens</a>, we introduced the notation for functions and types
using an example of computing the cost of an order of pens. An order
consisted of a number of pens and a message to be printed on the
pens. Each pen cost 25 cents, plus 2 cents per character for the
message. Here was the original Pyret code:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String) -&gt; Number:
  doc: ```total cost for pens, each 25 cents
          plus 2 cents per message character```
  num-pens * (0.25 + (string-length(message) * 0.02))
end</code></pre><p>Hereâ€™s the corresponding Python code:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def pen_cost(num_pens: int, message: str) -&gt; float:
    """total cost for pens, each at 25 cents plus
       2 cents per message character"""
    return num_pens * (0.25 + (len(message) * 0.02))</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What notational differences do you see between the two versions?</p></blockquote></blockquote><p>Hereâ€™s a summary of the differences:</p><ul><li><p>Python uses <code data-lang="text/x-python" class="sourceCode">def</code> instead of <code data-lang="pyret" class="sourceCode">fun</code>.</p></li><li><p>Python uses underscores in names (like <code data-lang="text/x-python" class="sourceCode">pen_cost</code>)
instead of hyphens as in Pyret.</p></li><li><p>The type names are written differently: Python uses <code data-lang="text/x-python" class="sourceCode">str</code>
and <code data-lang="text/x-python" class="sourceCode">int</code> instead of <code data-lang="pyret" class="sourceCode">String</code> and <code data-lang="pyret" class="sourceCode">Number</code>. In
addition, Python uses only a single colon before the type whereas
Pyret uses a double colon.</p></li><li><p>Python has different types for different kinds of numbers:
<code data-lang="text/x-python" class="sourceCode">int</code> is for integers, while <code data-lang="text/x-python" class="sourceCode">float</code> is for decimals.
Pyret just used a single type (<code data-lang="pyret" class="sourceCode">Number</code>)
for all numbers.</p></li><li><p>Python doesnâ€™t label the documentation string (as Pyret does with
<code data-lang="pyret" class="sourceCode">doc:</code>).</p></li><li><p>There is no <code data-lang="pyret" class="sourceCode">end</code> annotation in Python. Instead, Python
uses indentation to locate the end of an if/else statement, function, or
other multi-line construct.</p></li><li><p>Python labels the outputs of functions with <code data-lang="text/x-python" class="sourceCode">return</code>.</p></li></ul><p>These are minor differences in notation, which you will get used to as
you write more programs in Python.</p><p>There are differences beyond the notational ones. One that arises with
this sample program arises around how the language uses types. In
Pyret, if you put a type annotation on a parameter then pass it a
value of a different type, youâ€™ll get an error message. Python ignores
the type annotations (unless you bring in additional tools for
checking types). Python types are like notes for programmers, but they
arenâ€™t enforced when programs run.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p/><p>Convert the following <code data-lang="pyret" class="sourceCode">moon-weight</code> function from <a href="From_Repeated_Expressions_to_Functions.html#%28part._moon-weight-pyret%29" data-pltdoc="x">Functions Practice: Moon Weight</a> into Python:
</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun moon-weight(earth-weight :: Number) -&gt; Number:
  doc:" Compute weight on moon from weight on earth"
  earth-weight * 1/6
end</code></pre></blockquote></blockquote>&#13;
<h4 class="heading">9.1.2Â <a name="(part._.Returning_.Values_from_.Functions)"/>Returning Values from Functions<a href="#(part._.Returning_.Values_from_.Functions)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In Pyret, a function body consisted of optional statements to name
intermediate values, followed by a single expression. The value of
that single expression is the result of calling the function. In
Pyret, every function produces a result, so there is no need to label
where the result comes from.</p><p>As we will see, Python is different: not all â€œfunctionsâ€ return
results (note the name change from <code data-lang="pyret" class="sourceCode">fun</code> to
<code data-lang="text/x-python" class="sourceCode">def</code>).In mathematics, functions have results by
definition. Programmers sometimes distinguish between the terms â€œfunctionâ€
and â€œprocedureâ€: both refer to parameterized computations, but only
the former returns a result to the surrounding computation. Some
programmers and languages do, however, use the term â€œfunctionâ€ more
loosely to cover both kinds of parameterized computations.  Moreover,
the result isnâ€™t necessarily the last expression of the
<code data-lang="text/x-python" class="sourceCode">def</code>. In Python, the keyword <code data-lang="text/x-python" class="sourceCode">return</code> explicitly labels
the expression whose value serves as the result of the function.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><p>Put these two definitions in a Python file.
</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def add1v1(x: int) -&gt; int:
    return x + 1

def add1v2(x: int) -&gt; int:
    x + 1</code></pre><p>At the Python prompt, call each function in turn. What do you notice
about the result from using each function?</p></blockquote></blockquote><p>Hopefully, you noticed that using <code data-lang="text/x-python" class="sourceCode">add1v1</code> displays an answer
after the prompt, while using <code data-lang="text/x-python" class="sourceCode">add1v2</code> does not. This
difference has consequences for composing functions.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Try evaluating the following two expressions at the Python prompt:
what happens in each case?</p><p><code data-lang="text/x-python" class="sourceCode">3 * add1v1(4)</code></p><p><code data-lang="text/x-python" class="sourceCode">3 * add1v2(4)</code></p></blockquote></blockquote><p>This example illustrates why <code data-lang="text/x-python" class="sourceCode">return</code> is essential in Python:
without it, no value is returned, which means you canâ€™t use the result
of a function within another expression. So what use is
<code data-lang="text/x-python" class="sourceCode">add1v2</code> then? Hold that question; weâ€™ll return to it in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p>&#13;
<h4 class="heading">9.1.3Â <a name="(part._testing-python)"/>Examples and Test Cases<a href="#(part._testing-python)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>In Pyret, we included examples with every function using <code data-lang="pyret" class="sourceCode">where:</code>
blocks. We also had the ability to write <code data-lang="pyret" class="sourceCode">check:</code> blocks for more
extensive tests. As a reminder, here was the <code data-lang="pyret" class="sourceCode">pen-cost</code> code
including a <code data-lang="pyret" class="sourceCode">where:</code> block:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun pen-cost(num-pens :: Number, message :: String) -&gt; Number:
  doc: ```total cost for pens, each 25 cents
       plus 2 cents per message character```
  num-pens * (0.25 + (string-length(message) * 0.02))
where:
  pen-cost(1, "hi") is 0.29
  pen-cost(10, "smile") is 3.50
end</code></pre><p>Python does not have a notion of <code data-lang="pyret" class="sourceCode">where:</code> blocks, or a
distinction between examples and tests. There are a couple of
different testing packages for Python; here we will use <code data-lang="text/x-python" class="sourceCode">pytest</code>,
a standard lightweight framework that resembles the form of testing
that we did in Pyret.How you set up pytest and your test
file contents will vary according to your Python IDE. We assume
instructors will provide separate instructions that align with their
tool choices. To use <code data-lang="text/x-python" class="sourceCode">pytest</code>, we put both examples
and tests in a separate function. Hereâ€™s an example of this for the
<code data-lang="text/x-python" class="sourceCode">pen_cost</code> function:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">import pytest

def pen_cost(num_pens: int, message: str) -&gt; float:
    """total cost for pens, each at 25 cents plus
       2 cents per message character"""
    return num_pens * (0.25 + (len(message) * 0.02))

def test_pens():
  assert pen_cost(1, "hi") == 0.29
  assert pen_cost(10, "smile") == 3.50</code></pre><p>Things to note about this code:</p><ul><li><p>Weâ€™ve imported <code data-lang="text/x-python" class="sourceCode">pytest</code>, the lightweight Python testing
library.</p></li><li><p>The examples have moved into a function (here
<code data-lang="text/x-python" class="sourceCode">test_pens</code>) that takes no inputs. Note that the names of
functions that contain test cases must have names that start with
<code data-lang="text/x-python" class="sourceCode">test_</code> in order for <code data-lang="text/x-python" class="sourceCode">pytest</code> to find them.</p></li><li><p/><p>In Python, individual tests have the form
</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert EXPRESSION == EXPECTED_ANS</code></pre><p>rather than the <code data-lang="pyret" class="sourceCode">is</code> form from Pyret.</p></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p/><p>Add one more test to the Python code, corresponding to the Pyret test
</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pen-cost(3, "wow") is 0.93</code></pre><p>Make sure to run the test.</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Did you actually try to run the test?</p></blockquote></blockquote><p>Whoa! Something weird happened: the test failed. Stop and think
about that: the same test that worked in Pyret failed in
Python. How can that be?</p>&#13;
<h4 class="heading">9.1.4Â <a name="(part._.An_.Aside_on_.Numbers)"/>An Aside on Numbers<a href="#(part._.An_.Aside_on_.Numbers)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>It turns out that different programming languages make different
decisions about how to represent and manage real (non-integer)
numbers. Sometimes, differences in these representations lead to
subtle quantitative differences in computed values. As a simple
example, letâ€™s look at two seemingly simple real numbers <code data-lang="pyret" class="sourceCode">1/2</code> and
<code data-lang="pyret" class="sourceCode">1/3</code>. Hereâ€™s what we get when we type these two numbers at a
Pyret prompt:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/2</code></pre></blockquote></td></tr></table></td></tr><tr><td><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0.5</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/3</code></pre></blockquote></td></tr></table></td></tr><tr><td><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0.3</code></pre></td></tr></table><p>If we type these same two numbers in a Python console, we instead get:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/2</code></pre></blockquote></td></tr></table></td></tr><tr><td><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0.5</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1/3</code></pre></blockquote></td></tr></table></td></tr><tr><td><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">0.3333333333333333</code></pre></td></tr></table><p>Notice that the answers look different for <code data-lang="pyret" class="sourceCode">1/3</code>. As you may (or
may not!) recall from an earlier math class, <code data-lang="pyret" class="sourceCode">1/3</code> is an example of a
non-terminating, repeating decimal. In plain terms, if we tried to
write out the exact value of <code data-lang="pyret" class="sourceCode">1/3</code> in decimal form, we would need
to write an infinite sequence of <code data-lang="pyret" class="sourceCode">3</code>. Mathematicians denote this
by putting a horizontal bar over the <code data-lang="pyret" class="sourceCode">3</code>. This is the notation we
see in Pyret. Python, in contrast, writes out a partial sequence of
<code data-lang="pyret" class="sourceCode">3</code>s.</p><p>Underneath this distinction lies some interesting details about
representing numbers in computers. Computers donâ€™t have infinite space
to store numbers (or anything else, for that matter): when a program
needs to work with a non-terminating decimal, the underlying language
can either:</p><ul><li><p>approximate the number (by chopping off the infinite sequence
of digits at some point), then work only with the approximated value
going forward, or</p></li><li><p>store additional information about the number that may enable doing
more precise computation with it later (though there are always some
numbers that cannot be represented exactly in finite space).</p></li></ul><p>Python takes the first approach. As a result, computations with the
approximated values sometimes yield approximated results. This is what
happens with our new <code data-lang="text/x-python" class="sourceCode">pen_cost</code> test case. While
mathematically, the computation should result in <code data-lang="text/x-python" class="sourceCode">0.93</code>, the
approximations yield <code data-lang="text/x-python" class="sourceCode">0.9299999999999999</code> instead.</p><p>So how do we write tests in this situation? We need to tell Python
that the answer should be â€œcloseâ€ to <code data-lang="text/x-python" class="sourceCode">0.93</code>, within the error
range of approximations. Hereâ€™s what that looks like:</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert pen_cost(3, "wow") == pytest.approx(0.93)</code></pre><p>We wrapped the exact answer we wanted in <code data-lang="text/x-python" class="sourceCode">pytest.approx</code>, to
indicate that weâ€™ll accept any answer that is nearly the value we
specified. You can control the number of decimal points of precision
if you want to, but the default of <code data-lang="pyret" class="sourceCode">Â± 2.3e-06</code> often suffices.</p>&#13;
<h4 class="heading">9.1.5Â <a name="(part._conditionals-python)"/>Conditionals<a href="#(part._conditionals-python)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Continuing with our original <code data-lang="text/x-python" class="sourceCode">pen_cost</code> example, hereâ€™s the
Python version of the function that computed shipping costs on an
order:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def add_shipping(order_amt: float) -&gt; float:
    """increase order price by costs for shipping"""
    if order_amt == 0:
      return 0
    elif order_amt &lt;= 10:
      return order_amt + 4
    elif (order_amt &gt; 10) and (order_amt &lt; 30):
      return order_amt + 8
    else:
      return order_amt + 12</code></pre><p>The main difference to notice here is that <code data-lang="pyret" class="sourceCode">else if</code> is written
as the single-word <code data-lang="text/x-python" class="sourceCode">elif</code> in Python. We use <code data-lang="text/x-python" class="sourceCode">return</code> to
mark the functionâ€™s results in each branch of the conditional.
Otherwise, the conditional constructs are quite similar across the
two languages.</p><p>You may have noticed that Python does not require an explicit
<code data-lang="pyret" class="sourceCode">end</code> annotation on <code data-lang="pyret" class="sourceCode">if</code>-expressions or functions. Instead,
Python looks at the indentation of your code to determine when a
construct has ended. For example, in the code sample for
<code data-lang="text/x-python" class="sourceCode">pen_cost</code> and <code data-lang="text/x-python" class="sourceCode">test_pens</code>, Python determines that the
<code data-lang="text/x-python" class="sourceCode">pen_cost</code> function has ended because it detects a new
definition (for <code data-lang="text/x-python" class="sourceCode">test_pens</code>) at the left edge of the program
text. The same principle holds for ending conditionals.</p><p>Weâ€™ll return to this point about indentation, and see more examples,
as we work more with Python.</p>&#13;
<h4 class="heading">9.1.6Â <a name="(part._python-create-process-lists)"/>Creating and Processing
Lists<a href="#(part._python-create-process-lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>As an example of lists, letâ€™s assume weâ€™ve been playing a game that
involves making words out of a collection of letters. In Pyret, we
could have written a sample word list as follows:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">words = [list: "banana", "bean", "falafel", "leaf"]</code></pre><p>In Python, this definition would look like:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">words = ["banana", "bean", "falafel", "leaf"]</code></pre><p>The only difference here is that Python does not use the <code data-lang="pyret" class="sourceCode">list:</code>
label that is needed in Pyret.</p><section class="SsectionLevel5" id="section 9.1.6.1"><h5 class="heading">9.1.6.1Â <a name="(part._.Filters__.Maps__and_.Friends)"/>Filters, Maps, and Friends<a href="#(part._.Filters__.Maps__and_.Friends)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>When we first learned about lists in Pyret, we started with common
built-in functions such as <code data-lang="pyret" class="sourceCode">filter</code>, <code data-lang="pyret" class="sourceCode">map</code>, <code data-lang="pyret" class="sourceCode">member</code>
and <code data-lang="pyret" class="sourceCode">length</code>. We also saw the use of <code data-lang="pyret" class="sourceCode">lambda</code> to help us use
some of these functions concisely. These same functions, including
<code data-lang="pyret" class="sourceCode">lambda</code>, also exist in Python. Here are some samples (<code data-lang="text/x-python" class="sourceCode">#</code> is the comment character in Python):</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">words = ["banana", "bean", "falafel", "leaf"]

# filter and member
words_with_b = list(filter(lambda wd: "b" in wd, words))
# filter and length
short_words = list(filter(lambda wd: len(wd) &lt; 5, words))
# map and length
word_lengths = list(map(len, words))</code></pre><p>Note that you have to wrap calls to <code data-lang="text/x-python" class="sourceCode">filter</code> (and <code data-lang="text/x-python" class="sourceCode">map</code>)
with a use of <code data-lang="text/x-python" class="sourceCode">list()</code>. Internally, Python has these functions
return a type of data that we havenâ€™t yet discussed (and donâ€™t
need). Using <code data-lang="text/x-python" class="sourceCode">list</code> converts the returned data into a list. If
you omit the <code data-lang="text/x-python" class="sourceCode">list</code>, you wonâ€™t be able to chain certain
functions together. For example, if we tried to compute the length of
the result of a <code data-lang="text/x-python" class="sourceCode">map</code> without first converting to a
<code data-lang="text/x-python" class="sourceCode">list</code>, weâ€™d get an error:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">len(map(len,b))</code></pre></blockquote></td></tr></table></td></tr><tr><td><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">TypeError: object of type 'map' has no len()</code></pre></td></tr></table><p>Donâ€™t worry if this error message makes no sense at the moment (we
havenâ€™t yet learned what an â€œobjectâ€ is). The point is that if you see
an error like this while using the result of <code data-lang="text/x-python" class="sourceCode">filter</code> or
<code data-lang="text/x-python" class="sourceCode">map</code>, you likely forgot to wrap the result in <code data-lang="text/x-python" class="sourceCode">list</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Practice Pythonâ€™s list functions by writing expressions for the following
problems. Use only the list functions we have shown you so far.</p><ul><li><p>Given a list of numbers, convert it to a list of strings <code data-lang="text/x-python" class="sourceCode">"pos"</code>, <code data-lang="text/x-python" class="sourceCode">"neg"</code>, <code data-lang="text/x-python" class="sourceCode">"zero"</code>, based on the sign of each number.</p></li><li><p>Given a list of strings, is the length of any string equal to 5?</p></li><li><p>Given a list of numbers, produce a list of the even numbers between 10 and 20 from that list.</p></li></ul></blockquote></blockquote><p>Weâ€™re intentionally focusing on computations that use Pythonâ€™s built-in
functions for processing lists, rather than showing you how to write
you own (as we did with recursion in Pyret). While you can write
recursive functions to process lists in Pyret, a different style of
program is more conventional for that purpose. Weâ€™ll look at that in
the chapter on <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p></section>&#13;
<h5 class="heading">9.1.6.1Â <a name="(part._.Filters__.Maps__and_.Friends)"/>Filters, Maps, and Friends<a href="#(part._.Filters__.Maps__and_.Friends)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>When we first learned about lists in Pyret, we started with common
built-in functions such as <code data-lang="pyret" class="sourceCode">filter</code>, <code data-lang="pyret" class="sourceCode">map</code>, <code data-lang="pyret" class="sourceCode">member</code>
and <code data-lang="pyret" class="sourceCode">length</code>. We also saw the use of <code data-lang="pyret" class="sourceCode">lambda</code> to help us use
some of these functions concisely. These same functions, including
<code data-lang="pyret" class="sourceCode">lambda</code>, also exist in Python. Here are some samples (<code data-lang="text/x-python" class="sourceCode">#</code> is the comment character in Python):</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">words = ["banana", "bean", "falafel", "leaf"]

# filter and member
words_with_b = list(filter(lambda wd: "b" in wd, words))
# filter and length
short_words = list(filter(lambda wd: len(wd) &lt; 5, words))
# map and length
word_lengths = list(map(len, words))</code></pre><p>Note that you have to wrap calls to <code data-lang="text/x-python" class="sourceCode">filter</code> (and <code data-lang="text/x-python" class="sourceCode">map</code>)
with a use of <code data-lang="text/x-python" class="sourceCode">list()</code>. Internally, Python has these functions
return a type of data that we havenâ€™t yet discussed (and donâ€™t
need). Using <code data-lang="text/x-python" class="sourceCode">list</code> converts the returned data into a list. If
you omit the <code data-lang="text/x-python" class="sourceCode">list</code>, you wonâ€™t be able to chain certain
functions together. For example, if we tried to compute the length of
the result of a <code data-lang="text/x-python" class="sourceCode">map</code> without first converting to a
<code data-lang="text/x-python" class="sourceCode">list</code>, weâ€™d get an error:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">len(map(len,b))</code></pre></blockquote></td></tr></table></td></tr><tr><td><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">TypeError: object of type 'map' has no len()</code></pre></td></tr></table><p>Donâ€™t worry if this error message makes no sense at the moment (we
havenâ€™t yet learned what an â€œobjectâ€ is). The point is that if you see
an error like this while using the result of <code data-lang="text/x-python" class="sourceCode">filter</code> or
<code data-lang="text/x-python" class="sourceCode">map</code>, you likely forgot to wrap the result in <code data-lang="text/x-python" class="sourceCode">list</code>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Practice Pythonâ€™s list functions by writing expressions for the following
problems. Use only the list functions we have shown you so far.</p><ul><li><p>Given a list of numbers, convert it to a list of strings <code data-lang="text/x-python" class="sourceCode">"pos"</code>, <code data-lang="text/x-python" class="sourceCode">"neg"</code>, <code data-lang="text/x-python" class="sourceCode">"zero"</code>, based on the sign of each number.</p></li><li><p>Given a list of strings, is the length of any string equal to 5?</p></li><li><p>Given a list of numbers, produce a list of the even numbers between 10 and 20 from that list.</p></li></ul></blockquote></blockquote><p>Weâ€™re intentionally focusing on computations that use Pythonâ€™s built-in
functions for processing lists, rather than showing you how to write
you own (as we did with recursion in Pyret). While you can write
recursive functions to process lists in Pyret, a different style of
program is more conventional for that purpose. Weâ€™ll look at that in
the chapter on <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p>&#13;
<h4 class="heading">9.1.7Â <a name="(part._python-data-with-components)"/>Data with Components<a href="#(part._python-data-with-components)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>An analog to a Pyret data definition (without variants) is called a dataclass in
Python.Those experienced with Python may wonder why we are
using dataclasses instead of dictionaries or raw classes. Compared to
dictionaries, dataclasses allow the use of type hints and capture that
our data has a fixed collection of fields. Compared to raw classes,
dataclasses generate a lot of boilerplate code that makes them much
lighterweight than raw classes. Hereâ€™s an example of a todo-list
datatype in Pyret and its corresponding Python code:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode"># a todo item in Pyret
data ToDoItemData:
  | todoItem(descr :: String,
             due :: Date,
             tags :: List&lt;String&gt;
end</code></pre><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">------------------------------------------
# the same todo item in Python

# to allow use of dataclasses
from dataclasses import dataclass
# to allow dates as a type (in the ToDoItem)
from datetime import date

@dataclass
class ToDoItem:
    descr: str
    due: date
    tags: list

# a sample list of ToDoItem
myTD = [ToDoItem("buy milk", date(2020, 7, 27), ["shopping", "home"]),
        ToDoItem("grade hwk", date(2020, 7, 27), ["teaching"]),
        ToDoItem("meet students", date(2020, 7, 26), ["research"])
       ]</code></pre><p>Things to note:</p><ul><li><p>There is a single name for the type and the constructor, rather
than separate names as we had in Pyret.</p></li><li><p>There are no commas between field names (but each has to be on
its own line in Python)</p></li><li><p>There is no way to specify the type of the contents of the list
in Python (at least, not without using more advance packages for
writing types)</p></li><li><p>The <code data-lang="text/x-python" class="sourceCode">@dataclass</code> annotation is needed before
<code data-lang="text/x-python" class="sourceCode">class</code>.</p></li><li><p>Dataclasses donâ€™t support creating datatypes with multiple
variants, like we did frequently in Pyret. Doing that needs more
advanced concepts than we will cover in this book.</p></li></ul><section class="SsectionLevel5" id="section 9.1.7.1"><h5 class="heading">9.1.7.1Â <a name="(part._.Accessing_.Fields_within_.Dataclasses)"/>Accessing Fields within Dataclasses<a href="#(part._.Accessing_.Fields_within_.Dataclasses)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>In Pyret, we extracted a field from structured data by using a dot
(period) to â€œdig intoâ€ the datum and access the field. The same
notation works in Python:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">travel = ToDoItem("buy tickets", date(2020, 7, 30), ["vacation"])</code></pre></blockquote></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">travel.descr</code></pre></blockquote></td></tr></table></td></tr><tr><td><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"buy tickets"</code></pre></td></tr></table></section>&#13;
<h5 class="heading">9.1.7.1Â <a name="(part._.Accessing_.Fields_within_.Dataclasses)"/>Accessing Fields within Dataclasses<a href="#(part._.Accessing_.Fields_within_.Dataclasses)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>In Pyret, we extracted a field from structured data by using a dot
(period) to â€œdig intoâ€ the datum and access the field. The same
notation works in Python:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">travel = ToDoItem("buy tickets", date(2020, 7, 30), ["vacation"])</code></pre></blockquote></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">travel.descr</code></pre></blockquote></td></tr></table></td></tr><tr><td><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"buy tickets"</code></pre></td></tr></table>&#13;
<h4 class="heading">9.1.8Â <a name="(part._python-traverse-lists)"/>Traversing Lists<a href="#(part._python-traverse-lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><section class="SsectionLevel5" id="section 9.1.8.1"><h5 class="heading">9.1.8.1Â <a name="(part._python-for-loops)"/>Introducing <code data-lang="text/x-python" class="sourceCode">For</code> Loops<a href="#(part._python-for-loops)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p/><p>In Pyret, we typically write recursive functions to compute summary values over
lists. As a reminder, hereâ€™s a Pyret function that sums the numbers in
a list:
</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(numlist :: List&lt;Number&gt;) -&gt; Number:
  cases (List) numlist:
    | empty =&gt; 0
    | link(fst, rst) =&gt; fst + sum-list(rst)
  end
end</code></pre><p>In Python, it is unusual to break a list into its first and rest
components and process the rest recursively. Instead, we use a construct called a <code data-lang="text/x-python" class="sourceCode">for</code> to
visit each element of a list in turn. Hereâ€™s the form of <code data-lang="text/x-python" class="sourceCode">for</code>,
using a concrete (example) list of odd numbers:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for num in [5, 1, 7, 3]:
   # do something with num</code></pre><p/><p>The name <code data-lang="text/x-python" class="sourceCode">num</code> here is of our choosing, just as with the names
of parameters to a function in Pyret.  When a <code data-lang="text/x-python" class="sourceCode">for</code> loop
evaluates, each item in the list is referred to as <code data-lang="text/x-python" class="sourceCode">num</code> in
turn. Thus, this <code data-lang="text/x-python" class="sourceCode">for</code> example is equivalent to writing the
following:
</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># do something with 5
# do something with 1
# do something with 7
# do something with 3</code></pre><p>The <code data-lang="text/x-python" class="sourceCode">for</code> construct saves us from writing the common code
multiple times, and also handles the fact that the lists we are
processing can be of arbitrary length (so we canâ€™t predict how many
times to write the common code).</p><p>Letâ€™s now use <code data-lang="text/x-python" class="sourceCode">for</code> to compute the running sum of a list. Weâ€™ll
start by figuring out the repeated computation with our concrete list
again. At first, letâ€™s express the repeated computation just in
prose. In Pyret, our repeated computation was along the lines of â€œadd
the first item to the sum of the rest of the itemsâ€. Weâ€™ve already
said that we cannot easily access the â€œrest of the itemsâ€ in Python,
so we need to rephrase this. Hereâ€™s an alternative:</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># set a running total to 0
# add 5 to the running total
# add 1 to the running total
# add 7 to the running total
# add 3 to the running total</code></pre><p>Note that this framing refers not to the â€œrest of the computationâ€,
but rather to the computation that has happened so far (the â€œrunning
totalâ€). If you happened to work through the chapter on <a href="processing-lists.html#%28part._running-sum-eg-code%29" data-pltdoc="x"><code data-lang="pyret" class="sourceCode">my-running-sum</code>: Examples and Code</a>, this framing might be familiar.</p><p>Letâ€™s convert this prose sketch to code by replacing each line of the
sketch with concrete code. We do this by setting up a variable named
<code data-lang="text/x-python" class="sourceCode">run_total</code> and updating its value for each element.</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = run_total + 5
run_total = run_total + 1
run_total = run_total + 7
run_total = run_total + 3</code></pre><p>This idea that you can give a new value to an existing variable name
is something we havenâ€™t seen before. In fact, when we first saw how to
name values (in <a href="Naming_Values.html#%28part._program-directory%29" data-pltdoc="x">The Program Directory</a>), we explicitly said that
Pyret doesnâ€™t let
you do this (at least, not with the constructs that we showed you). Python does. Weâ€™ll explore the consequences of this ability in
more depth shortly (in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>). For now, letâ€™s just use that ability so we can
learn the pattern for traversing lists. First, letâ€™s collapse the repeated lines of code
into a single use of <code data-lang="text/x-python" class="sourceCode">for</code>:</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
for num in [5, 1, 7, 3]:
   run_total = run_total + num</code></pre><p>This code works fine for a specific list, but our Pyret version took
the list to sum as a parameter to a function. To achieve this in
Python, we wrap the <code data-lang="text/x-python" class="sourceCode">for</code> in a function as we have done for
other examples earlier in this chapter. This is the final version.</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def sum_list(numlist : list) -&gt; float:
    """sum a list of numbers"""
    run_total = 0
    for num in numlist:
        run_total = run_total + num
    return(run_total)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write a set of tests for <code data-lang="text/x-python" class="sourceCode">sum_list</code> (the Python version).</p></blockquote></blockquote><p>Now that the Python version is done, letâ€™s compare it to the original Pyret
version:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(numlist :: List&lt;Number&gt;) -&gt; Number:
  cases (List) numlist:
    | empty =&gt; 0
    | link(fst, rst) =&gt; fst + sum-list(rst)
  end
end</code></pre><p>Here are some things to notice about the two pieces of code:</p><ul><li><p>The Python version needs a variable (here <code data-lang="text/x-python" class="sourceCode">run_total</code>) to
hold the result of the computation as we build it up while traversing
(working through) the list.</p></li><li><p>The initial value of that variable is the answer we returned in
the <code data-lang="pyret" class="sourceCode">empty</code> case in Pyret.</p></li><li><p>The computation in the <code data-lang="pyret" class="sourceCode">link</code> case of the Pyret function is
used to update that variable in the body of the <code data-lang="text/x-python" class="sourceCode">for</code>.</p></li><li><p>After the <code data-lang="text/x-python" class="sourceCode">for</code> has finished processing all items in the
list, the Python version returns the value in the variable as the
result of the function.</p></li></ul></section><section class="SsectionLevel5" id="section 9.1.8.2"><h5 class="heading">9.1.8.2Â <a name="(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)"/>An Aside on Order of Processing List Elements<a href="#(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Thereâ€™s another subtlety here if we consider how the two programs run:
the Python version sums the elements from left to right, whereas
the Pyret version sums them right to left. Concretely, the sequence of
values of <code data-lang="text/x-python" class="sourceCode">run_total</code> are computed as:</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = 0 + 5
run_total = 5 + 1
run_total = 6 + 7
run_total = 13 + 3</code></pre><p>In contrast, the Pyret version unrolls as:
</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum_list([list: 5, 1, 7, 3])
5 + sum_list([list: 1, 7, 3])
5 + 1 + sum_list([list: 7, 3])
5 + 1 + 7 + sum_list([list: 3])
5 + 1 + 7 + 3 + sum_list([list:])
5 + 1 + 7 + 3 + 0
5 + 1 + 7 + 3
5 + 1 + 10
5 + 11
16</code></pre><p>As a reminder, the Pyret version did this because the <code data-lang="pyret" class="sourceCode">+</code> in the
<code data-lang="pyret" class="sourceCode">link</code> case can only reduce to an answer once the sum of the rest
of the list has been computed. Even though we as humans see the chain
of <code data-lang="pyret" class="sourceCode">+</code> operations in each line of the Pyret unrolling, Pyret sees
only the expression <code data-lang="pyret" class="sourceCode">fst + sum-list(rst)</code>, which requires the
function call to finish before the <code data-lang="pyret" class="sourceCode">+</code> executes.</p><p>In the case of summing a list, we donâ€™t notice the difference between
the two versions because the sum is the same whether we compute it
left-to-right or right-to-left. In other functions we write, this
difference may start to matter.</p></section><section class="SsectionLevel5" id="section 9.1.8.3"><h5 class="heading">9.1.8.3Â <a name="(part._python-funcs-produce-lists)"/>Using <code data-lang="text/x-python" class="sourceCode">For</code> Loops in Functions that Produce Lists<a href="#(part._python-funcs-produce-lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s practice using <code data-lang="text/x-python" class="sourceCode">for</code> loops on another function that
traverses lists, this time one that produces a list. Specifically,
letâ€™s write a program that takes a list of strings and produces a list
of words within that list that contain the letter <code data-lang="text/x-python" class="sourceCode">"z"</code>.</p><p>As in our <code data-lang="text/x-python" class="sourceCode">sum_list</code> function, we will need a variable to store
the resulting list as we build it up. The following code calls this
<code data-lang="text/x-python" class="sourceCode">zlist</code>. The code also shows how to use <code data-lang="text/x-python" class="sourceCode">in</code> to check
whether a character is in a string (it also works for checking whether
an item is in a list) and how to add an element to the end of a list
(<code data-lang="text/x-python" class="sourceCode">append</code>).</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def all_z_words(wordlist : list) -&gt; list:
    """produce list of words from the input that contain z"""
    zlist = [] # start with an empty list
    for wd in wordlist:
        if "z" in wd:
            zlist = [wd] + zlist
    return(zlist)</code></pre><p>This code follows the structure of <code data-lang="text/x-python" class="sourceCode">sum_list</code>, in that we
update the value of <code data-lang="text/x-python" class="sourceCode">zlist</code> using an expression similar to what
we would have used in Pyret. For those with prior Python
experience who would have used <code data-lang="text/x-python" class="sourceCode">zlist.append</code> here, hold that
thought. We will get there in <a href="mutable-lists.html" data-pltdoc="x">Mutable Lists</a>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write tests for <code data-lang="text/x-python" class="sourceCode">all_z_words</code>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a second version of <code data-lang="text/x-python" class="sourceCode">all_z_words</code> using
<code data-lang="text/x-python" class="sourceCode">filter</code>. Be sure to write tests for it!</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Contrast these two versions and the corresponding tests. Did you
notice anything interesting?</p></blockquote></blockquote></section><section class="SsectionLevel5" id="section 9.1.8.4"><h5 class="heading">9.1.8.4Â <a name="(part._.Summary__.The_.List-.Processing_.Template_for_.Python)"/>Summary: The List-Processing Template for Python<a href="#(part._.Summary__.The_.List-.Processing_.Template_for_.Python)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Just as we had a template for writing list-processing functions in
Pyret, there is a corresponding template in Python based on
<code data-lang="text/x-python" class="sourceCode">for</code> loops. As a reminder, that pattern is as follow:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def func(lst: list):
  result = ...  # what to return if the input list is empty
  for item in lst:
    # combine item with the result so far
    result = ... item ... result
  return result</code></pre><p>Keep this template in mind as you learn to write functions over lists
in Python.</p></section><section class="SsectionLevel5" id="section 9.1.8.5"><h5 class="heading">9.1.8.5Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)"/><code data-lang="pyret" class="sourceCode">for each</code> loops in Pyret<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>This section can be read
without reading the rest of this chapter, so if you have been directed to it
before being introduced to Python, do not worry! While the content below mirrors
similar constructs that exist in Python, it is introduced on its own.</p><p>The previous sections introduced <code data-lang="text/x-python" class="sourceCode">for</code> loops in Python, and showed a
template for processing lists with them. Pyret can
do similar, using the following pattern:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun func(lst :: List) block:
  var result = ...  # what to return if the input list is empty
  for each(item from lst):
    # combine item with the result so far
    result := ... item ... result
  end
  result
end</code></pre><p>There are a few new language features used in this example, introduced in the
following several sections.</p><section class="SsectionLevel6" id="section 9.1.8.5.1"><h5 class="heading">9.1.8.5.1Â <a name="(part._.Variables_that_can_change)"/>Variables that can change<a href="#(part._.Variables_that_can_change)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>First, note that we introduce the variable <code data-lang="pyret" class="sourceCode">result</code> with <code data-lang="pyret" class="sourceCode">var result</code>
â€“ this means that it can vary, which is important for the use with
<code data-lang="pyret" class="sourceCode">for each</code>.</p><p>By default, all variables in the program directory can never be changed. i.e.,
if I define a variable <code data-lang="pyret" class="sourceCode">x</code>, I can not redefine it later:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x = 10
# ...
x = 20 # produces shadowing error</code></pre><p>If we do want to change (or mutate) a variable in the directory later, we can, but we must
declare the variable can change â€“ as in, when we define it, rather than writing
<code data-lang="pyret" class="sourceCode">x = 10</code>, we must write <code data-lang="pyret" class="sourceCode">var x = 10</code>. Then, when we want to
update it, we can do so with the <code data-lang="pyret" class="sourceCode">:=</code> operator, as is done in the template above.</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var x = 10
# ... x points to 10 in directory
x := 20
# ... x now points to 20 in directory</code></pre><p>Note that trying to use <code data-lang="pyret" class="sourceCode">:=</code> on a variable that was not declared using
<code data-lang="pyret" class="sourceCode">var</code> will produce an error, and variables can still only ever be declared
once (whether with <code data-lang="pyret" class="sourceCode">var x = ...</code> or <code data-lang="pyret" class="sourceCode">x = ...</code>).</p></section><section class="SsectionLevel6" id="section 9.1.8.5.2"><h5 class="heading">9.1.8.5.2Â <a name="(part._block_notation)"/>block notation<a href="#(part._block_notation)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Another new language feature shown in these examples is that since Pyret
functions by default expect only a single (non-definition) expression, we have
to add the <code data-lang="pyret" class="sourceCode">block</code> annotation at the top, indicating that the body of the
function is multiple expressions, with the final one being what the function
evaluates to.</p><p>As another example, if we tried to write:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function():
  1
  2
end</code></pre><p>Pyret would (rightly) error â€“ since the function returns the last expression in
its body, the <code data-lang="pyret" class="sourceCode">1</code> will be ignored â€“ and is most likely a mistake! Perhaps
the goal was to write:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function():
  1 + 2
end</code></pre><p>However, since a <code data-lang="pyret" class="sourceCode">for each</code> expression exists only to modify a variable,
functions that contain them will always have multiple expressions, and so
we need to communicate to Pyret that this is not a mistake. Adding <code data-lang="pyret" class="sourceCode">block</code>
before the <code data-lang="pyret" class="sourceCode">:</code> that begins the function (or, in general, wrapping any
expressions in <code data-lang="pyret" class="sourceCode">block:</code> and <code data-lang="pyret" class="sourceCode">end</code>) communicates to Pyret that we
understand that there are multiple expressions, and just want to evaluate to the
last one. So, if we truly wanted to write a function as our first example, we
could do that with:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function() block:
  1
  2
end</code></pre></section><section class="SsectionLevel6" id="section 9.1.8.5.3"><h5 class="heading">9.1.8.5.3Â <a name="(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)"/>How <code data-lang="pyret" class="sourceCode">for each</code> works<a href="#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>A <code data-lang="pyret" class="sourceCode">for each</code> expression runs its body once for each element in the input
list, adding an entry to the program directory for each element as it goes. It
does not produce any value directly, so much instead rely on modifying variables
(described above) to produce a computation.</p><p>Consider summing a list of numbers. We could write a function that does this,
following our pattern, as:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(lst :: List) block:
  var run_total = 0
  for each(item from lst):
    run_total := item + run_total
  end
  run_total
where:
  sum-list([list: 5, 1, 7, 3]) is 16
end</code></pre><p>On the concrete test input <code data-lang="pyret" class="sourceCode">[list: 5, 1, 7, 3]</code>, the loop runs four times,
once with <code data-lang="pyret" class="sourceCode">item</code> set to <code data-lang="pyret" class="sourceCode">5</code>, then with <code data-lang="pyret" class="sourceCode">item</code> set to <code data-lang="pyret" class="sourceCode">1</code>,
then with <code data-lang="pyret" class="sourceCode">item</code> set to <code data-lang="pyret" class="sourceCode">7</code>, and finally with <code data-lang="pyret" class="sourceCode">item</code> set to
<code data-lang="pyret" class="sourceCode">3</code>.</p><p>The <code data-lang="pyret" class="sourceCode">for each</code> construct saves us from writing the common code
multiple times, and also handles the fact that the lists we are
processing can be of arbitrary length (so we canâ€™t predict how many
times to write the common code). Thus, what happens is:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = run_total + 5
run_total = run_total + 1
run_total = run_total + 7
run_total = run_total + 3</code></pre></section><section class="SsectionLevel6" id="section 9.1.8.5.4"><h5 class="heading">9.1.8.5.4Â <a name="(part._.Testing_and_variables_that_can_change)"/>Testing and variables that can change<a href="#(part._.Testing_and_variables_that_can_change)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>We intentionally showed a very particular pattern of using variables that can
change. While there are other uses (explored in part in
<a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>), a main reason to stay with this particular
template is the difficulty in testing and correspondingly, understanding, code
that uses them in other ways.</p><p>In particular, note that the pattern means that we never define a variables that
can change outside a function, which means it can never be used by
different functions, or multiple function calls. Each time the function runs, a
new variable is created, it is modified in the <code data-lang="pyret" class="sourceCode">for each</code> loop, and then
the value is returned, and the entry in the program directory is removed.</p><p>Consider what happens if we donâ€™t follow our pattern. Letâ€™s say we had the
following problem:</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Given a list of numbers, return the prefix of the list (i.e., all
elements, starting from the beginning) that sums to less than 100.</p></blockquote></blockquote><p>Having learned about mutable variables, but not following the pattern, you might
come up with code like this:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var count = 0

fun prefix-under-100(l :: List) -&gt; List:
  var output = [list: ]
  for each(elt from l):
    count := count + elt
    when (count &lt; 100):
      output := output + [list: elt]
    end
  end
end</code></pre><p>Now, this might seem reasonable â€“ weâ€™ve used a new construct, <code data-lang="pyret" class="sourceCode">when</code>,
which is an <code data-lang="pyret" class="sourceCode">if</code> expression that has no <code data-lang="pyret" class="sourceCode">else</code> â€“ this only makes
sense to do inside of a <code data-lang="pyret" class="sourceCode">for each</code> block, where we donâ€™t need a value as a
result. It is equivalent to:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if (count &lt; 100):
  output := output + [list: elt]
else:
  nothing
end</code></pre><p>Where <code data-lang="pyret" class="sourceCode">nothing</code> is a value that is used in Pyret to indicate that there is
no particular value of importance.</p><p>But what happens when we use this function?</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
    prefix-under-100([list: 20, 30, 40]) is [list: 20, 30, 40]
    prefix-under-100([list: 80, 20, 10]) is [list: 80]
end</code></pre><p>The first two tests pass, but the last one doesnâ€™t. Why? If we run the first one
again, things are even more confusing, i.e., if instead of the above, we ran
this <code data-lang="pyret" class="sourceCode">check</code> block:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
    prefix-under-100([list: 20, 30, 40]) is [list: 20, 30, 40]
    prefix-under-100([list: 80, 20, 10]) is [list: 80]
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
end</code></pre><p>Now the test that passed at first no longer passes!</p><p>What we are seeing is that since the variable is outside the function, it is
shared across different calls to the function. It is added to the program
directory once, and each time we call <code data-lang="pyret" class="sourceCode">prefix-under-100</code>, the program
directory entry is changed, but it is never reset.</p><p>Intentionally, all other uses of mutation have been on directory entries that
were created only for the body of the function, which meant that when the
function exited, they were removed. But now, we are always modifying the single
<code data-lang="pyret" class="sourceCode">count</code> variable. This means that every time we call
<code data-lang="pyret" class="sourceCode">prefix-under-100</code>, it behaves differently, because it not only do we have
to understand the code in the body of the function, we have to know the current
value of the count variable, which is not something we can figure out by just
looking at the code!</p><p>Functions that behave like this are said to have "side effects", and they are
much harder to test and much harder to understand, and as a result, much more
likely to have bugs! While the above example is wrong in a relatively
straightforward way, side effects can cause extremely subtle bugs that only
happen when functions are called in particular orders â€“ orders that may only
arised in very specific situations, making them hard to understand or reproduce.</p><p>While there are some places where doing this is necessary, almost all code can
be written without side effects, and will be much more reliable. We will explore
some cases where we might want to do this in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p></section></section>&#13;
<h5 class="heading">9.1.8.1Â <a name="(part._python-for-loops)"/>Introducing <code data-lang="text/x-python" class="sourceCode">For</code> Loops<a href="#(part._python-for-loops)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p/><p>In Pyret, we typically write recursive functions to compute summary values over
lists. As a reminder, hereâ€™s a Pyret function that sums the numbers in
a list:
</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(numlist :: List&lt;Number&gt;) -&gt; Number:
  cases (List) numlist:
    | empty =&gt; 0
    | link(fst, rst) =&gt; fst + sum-list(rst)
  end
end</code></pre><p>In Python, it is unusual to break a list into its first and rest
components and process the rest recursively. Instead, we use a construct called a <code data-lang="text/x-python" class="sourceCode">for</code> to
visit each element of a list in turn. Hereâ€™s the form of <code data-lang="text/x-python" class="sourceCode">for</code>,
using a concrete (example) list of odd numbers:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">for num in [5, 1, 7, 3]:
   # do something with num</code></pre><p/><p>The name <code data-lang="text/x-python" class="sourceCode">num</code> here is of our choosing, just as with the names
of parameters to a function in Pyret.  When a <code data-lang="text/x-python" class="sourceCode">for</code> loop
evaluates, each item in the list is referred to as <code data-lang="text/x-python" class="sourceCode">num</code> in
turn. Thus, this <code data-lang="text/x-python" class="sourceCode">for</code> example is equivalent to writing the
following:
</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># do something with 5
# do something with 1
# do something with 7
# do something with 3</code></pre><p>The <code data-lang="text/x-python" class="sourceCode">for</code> construct saves us from writing the common code
multiple times, and also handles the fact that the lists we are
processing can be of arbitrary length (so we canâ€™t predict how many
times to write the common code).</p><p>Letâ€™s now use <code data-lang="text/x-python" class="sourceCode">for</code> to compute the running sum of a list. Weâ€™ll
start by figuring out the repeated computation with our concrete list
again. At first, letâ€™s express the repeated computation just in
prose. In Pyret, our repeated computation was along the lines of â€œadd
the first item to the sum of the rest of the itemsâ€. Weâ€™ve already
said that we cannot easily access the â€œrest of the itemsâ€ in Python,
so we need to rephrase this. Hereâ€™s an alternative:</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode"># set a running total to 0
# add 5 to the running total
# add 1 to the running total
# add 7 to the running total
# add 3 to the running total</code></pre><p>Note that this framing refers not to the â€œrest of the computationâ€,
but rather to the computation that has happened so far (the â€œrunning
totalâ€). If you happened to work through the chapter on <a href="processing-lists.html#%28part._running-sum-eg-code%29" data-pltdoc="x"><code data-lang="pyret" class="sourceCode">my-running-sum</code>: Examples and Code</a>, this framing might be familiar.</p><p>Letâ€™s convert this prose sketch to code by replacing each line of the
sketch with concrete code. We do this by setting up a variable named
<code data-lang="text/x-python" class="sourceCode">run_total</code> and updating its value for each element.</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = run_total + 5
run_total = run_total + 1
run_total = run_total + 7
run_total = run_total + 3</code></pre><p>This idea that you can give a new value to an existing variable name
is something we havenâ€™t seen before. In fact, when we first saw how to
name values (in <a href="Naming_Values.html#%28part._program-directory%29" data-pltdoc="x">The Program Directory</a>), we explicitly said that
Pyret doesnâ€™t let
you do this (at least, not with the constructs that we showed you). Python does. Weâ€™ll explore the consequences of this ability in
more depth shortly (in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>). For now, letâ€™s just use that ability so we can
learn the pattern for traversing lists. First, letâ€™s collapse the repeated lines of code
into a single use of <code data-lang="text/x-python" class="sourceCode">for</code>:</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
for num in [5, 1, 7, 3]:
   run_total = run_total + num</code></pre><p>This code works fine for a specific list, but our Pyret version took
the list to sum as a parameter to a function. To achieve this in
Python, we wrap the <code data-lang="text/x-python" class="sourceCode">for</code> in a function as we have done for
other examples earlier in this chapter. This is the final version.</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def sum_list(numlist : list) -&gt; float:
    """sum a list of numbers"""
    run_total = 0
    for num in numlist:
        run_total = run_total + num
    return(run_total)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write a set of tests for <code data-lang="text/x-python" class="sourceCode">sum_list</code> (the Python version).</p></blockquote></blockquote><p>Now that the Python version is done, letâ€™s compare it to the original Pyret
version:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(numlist :: List&lt;Number&gt;) -&gt; Number:
  cases (List) numlist:
    | empty =&gt; 0
    | link(fst, rst) =&gt; fst + sum-list(rst)
  end
end</code></pre><p>Here are some things to notice about the two pieces of code:</p><ul><li><p>The Python version needs a variable (here <code data-lang="text/x-python" class="sourceCode">run_total</code>) to
hold the result of the computation as we build it up while traversing
(working through) the list.</p></li><li><p>The initial value of that variable is the answer we returned in
the <code data-lang="pyret" class="sourceCode">empty</code> case in Pyret.</p></li><li><p>The computation in the <code data-lang="pyret" class="sourceCode">link</code> case of the Pyret function is
used to update that variable in the body of the <code data-lang="text/x-python" class="sourceCode">for</code>.</p></li><li><p>After the <code data-lang="text/x-python" class="sourceCode">for</code> has finished processing all items in the
list, the Python version returns the value in the variable as the
result of the function.</p></li></ul>&#13;
<h5 class="heading">9.1.8.2Â <a name="(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)"/>An Aside on Order of Processing List Elements<a href="#(part._.An_.Aside_on_.Order_of_.Processing_.List_.Elements)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Thereâ€™s another subtlety here if we consider how the two programs run:
the Python version sums the elements from left to right, whereas
the Pyret version sums them right to left. Concretely, the sequence of
values of <code data-lang="text/x-python" class="sourceCode">run_total</code> are computed as:</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = 0 + 5
run_total = 5 + 1
run_total = 6 + 7
run_total = 13 + 3</code></pre><p>In contrast, the Pyret version unrolls as:
</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sum_list([list: 5, 1, 7, 3])
5 + sum_list([list: 1, 7, 3])
5 + 1 + sum_list([list: 7, 3])
5 + 1 + 7 + sum_list([list: 3])
5 + 1 + 7 + 3 + sum_list([list:])
5 + 1 + 7 + 3 + 0
5 + 1 + 7 + 3
5 + 1 + 10
5 + 11
16</code></pre><p>As a reminder, the Pyret version did this because the <code data-lang="pyret" class="sourceCode">+</code> in the
<code data-lang="pyret" class="sourceCode">link</code> case can only reduce to an answer once the sum of the rest
of the list has been computed. Even though we as humans see the chain
of <code data-lang="pyret" class="sourceCode">+</code> operations in each line of the Pyret unrolling, Pyret sees
only the expression <code data-lang="pyret" class="sourceCode">fst + sum-list(rst)</code>, which requires the
function call to finish before the <code data-lang="pyret" class="sourceCode">+</code> executes.</p><p>In the case of summing a list, we donâ€™t notice the difference between
the two versions because the sum is the same whether we compute it
left-to-right or right-to-left. In other functions we write, this
difference may start to matter.</p>&#13;
<h5 class="heading">9.1.8.3Â <a name="(part._python-funcs-produce-lists)"/>Using <code data-lang="text/x-python" class="sourceCode">For</code> Loops in Functions that Produce Lists<a href="#(part._python-funcs-produce-lists)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Letâ€™s practice using <code data-lang="text/x-python" class="sourceCode">for</code> loops on another function that
traverses lists, this time one that produces a list. Specifically,
letâ€™s write a program that takes a list of strings and produces a list
of words within that list that contain the letter <code data-lang="text/x-python" class="sourceCode">"z"</code>.</p><p>As in our <code data-lang="text/x-python" class="sourceCode">sum_list</code> function, we will need a variable to store
the resulting list as we build it up. The following code calls this
<code data-lang="text/x-python" class="sourceCode">zlist</code>. The code also shows how to use <code data-lang="text/x-python" class="sourceCode">in</code> to check
whether a character is in a string (it also works for checking whether
an item is in a list) and how to add an element to the end of a list
(<code data-lang="text/x-python" class="sourceCode">append</code>).</p><p/><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def all_z_words(wordlist : list) -&gt; list:
    """produce list of words from the input that contain z"""
    zlist = [] # start with an empty list
    for wd in wordlist:
        if "z" in wd:
            zlist = [wd] + zlist
    return(zlist)</code></pre><p>This code follows the structure of <code data-lang="text/x-python" class="sourceCode">sum_list</code>, in that we
update the value of <code data-lang="text/x-python" class="sourceCode">zlist</code> using an expression similar to what
we would have used in Pyret. For those with prior Python
experience who would have used <code data-lang="text/x-python" class="sourceCode">zlist.append</code> here, hold that
thought. We will get there in <a href="mutable-lists.html" data-pltdoc="x">Mutable Lists</a>.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write tests for <code data-lang="text/x-python" class="sourceCode">all_z_words</code>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write a second version of <code data-lang="text/x-python" class="sourceCode">all_z_words</code> using
<code data-lang="text/x-python" class="sourceCode">filter</code>. Be sure to write tests for it!</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Contrast these two versions and the corresponding tests. Did you
notice anything interesting?</p></blockquote></blockquote>&#13;
<h5 class="heading">9.1.8.4Â <a name="(part._.Summary__.The_.List-.Processing_.Template_for_.Python)"/>Summary: The List-Processing Template for Python<a href="#(part._.Summary__.The_.List-.Processing_.Template_for_.Python)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Just as we had a template for writing list-processing functions in
Pyret, there is a corresponding template in Python based on
<code data-lang="text/x-python" class="sourceCode">for</code> loops. As a reminder, that pattern is as follow:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def func(lst: list):
  result = ...  # what to return if the input list is empty
  for item in lst:
    # combine item with the result so far
    result = ... item ... result
  return result</code></pre><p>Keep this template in mind as you learn to write functions over lists
in Python.</p>&#13;
<h5 class="heading">9.1.8.5Â <a name="(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)"/><code data-lang="pyret" class="sourceCode">for each</code> loops in Pyret<a href="#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___loops_in_.Pyret)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>This section can be read
without reading the rest of this chapter, so if you have been directed to it
before being introduced to Python, do not worry! While the content below mirrors
similar constructs that exist in Python, it is introduced on its own.</p><p>The previous sections introduced <code data-lang="text/x-python" class="sourceCode">for</code> loops in Python, and showed a
template for processing lists with them. Pyret can
do similar, using the following pattern:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun func(lst :: List) block:
  var result = ...  # what to return if the input list is empty
  for each(item from lst):
    # combine item with the result so far
    result := ... item ... result
  end
  result
end</code></pre><p>There are a few new language features used in this example, introduced in the
following several sections.</p><section class="SsectionLevel6" id="section 9.1.8.5.1"><h5 class="heading">9.1.8.5.1Â <a name="(part._.Variables_that_can_change)"/>Variables that can change<a href="#(part._.Variables_that_can_change)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>First, note that we introduce the variable <code data-lang="pyret" class="sourceCode">result</code> with <code data-lang="pyret" class="sourceCode">var result</code>
â€“ this means that it can vary, which is important for the use with
<code data-lang="pyret" class="sourceCode">for each</code>.</p><p>By default, all variables in the program directory can never be changed. i.e.,
if I define a variable <code data-lang="pyret" class="sourceCode">x</code>, I can not redefine it later:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x = 10
# ...
x = 20 # produces shadowing error</code></pre><p>If we do want to change (or mutate) a variable in the directory later, we can, but we must
declare the variable can change â€“ as in, when we define it, rather than writing
<code data-lang="pyret" class="sourceCode">x = 10</code>, we must write <code data-lang="pyret" class="sourceCode">var x = 10</code>. Then, when we want to
update it, we can do so with the <code data-lang="pyret" class="sourceCode">:=</code> operator, as is done in the template above.</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var x = 10
# ... x points to 10 in directory
x := 20
# ... x now points to 20 in directory</code></pre><p>Note that trying to use <code data-lang="pyret" class="sourceCode">:=</code> on a variable that was not declared using
<code data-lang="pyret" class="sourceCode">var</code> will produce an error, and variables can still only ever be declared
once (whether with <code data-lang="pyret" class="sourceCode">var x = ...</code> or <code data-lang="pyret" class="sourceCode">x = ...</code>).</p></section><section class="SsectionLevel6" id="section 9.1.8.5.2"><h5 class="heading">9.1.8.5.2Â <a name="(part._block_notation)"/>block notation<a href="#(part._block_notation)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Another new language feature shown in these examples is that since Pyret
functions by default expect only a single (non-definition) expression, we have
to add the <code data-lang="pyret" class="sourceCode">block</code> annotation at the top, indicating that the body of the
function is multiple expressions, with the final one being what the function
evaluates to.</p><p>As another example, if we tried to write:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function():
  1
  2
end</code></pre><p>Pyret would (rightly) error â€“ since the function returns the last expression in
its body, the <code data-lang="pyret" class="sourceCode">1</code> will be ignored â€“ and is most likely a mistake! Perhaps
the goal was to write:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function():
  1 + 2
end</code></pre><p>However, since a <code data-lang="pyret" class="sourceCode">for each</code> expression exists only to modify a variable,
functions that contain them will always have multiple expressions, and so
we need to communicate to Pyret that this is not a mistake. Adding <code data-lang="pyret" class="sourceCode">block</code>
before the <code data-lang="pyret" class="sourceCode">:</code> that begins the function (or, in general, wrapping any
expressions in <code data-lang="pyret" class="sourceCode">block:</code> and <code data-lang="pyret" class="sourceCode">end</code>) communicates to Pyret that we
understand that there are multiple expressions, and just want to evaluate to the
last one. So, if we truly wanted to write a function as our first example, we
could do that with:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function() block:
  1
  2
end</code></pre></section><section class="SsectionLevel6" id="section 9.1.8.5.3"><h5 class="heading">9.1.8.5.3Â <a name="(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)"/>How <code data-lang="pyret" class="sourceCode">for each</code> works<a href="#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>A <code data-lang="pyret" class="sourceCode">for each</code> expression runs its body once for each element in the input
list, adding an entry to the program directory for each element as it goes. It
does not produce any value directly, so much instead rely on modifying variables
(described above) to produce a computation.</p><p>Consider summing a list of numbers. We could write a function that does this,
following our pattern, as:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(lst :: List) block:
  var run_total = 0
  for each(item from lst):
    run_total := item + run_total
  end
  run_total
where:
  sum-list([list: 5, 1, 7, 3]) is 16
end</code></pre><p>On the concrete test input <code data-lang="pyret" class="sourceCode">[list: 5, 1, 7, 3]</code>, the loop runs four times,
once with <code data-lang="pyret" class="sourceCode">item</code> set to <code data-lang="pyret" class="sourceCode">5</code>, then with <code data-lang="pyret" class="sourceCode">item</code> set to <code data-lang="pyret" class="sourceCode">1</code>,
then with <code data-lang="pyret" class="sourceCode">item</code> set to <code data-lang="pyret" class="sourceCode">7</code>, and finally with <code data-lang="pyret" class="sourceCode">item</code> set to
<code data-lang="pyret" class="sourceCode">3</code>.</p><p>The <code data-lang="pyret" class="sourceCode">for each</code> construct saves us from writing the common code
multiple times, and also handles the fact that the lists we are
processing can be of arbitrary length (so we canâ€™t predict how many
times to write the common code). Thus, what happens is:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = run_total + 5
run_total = run_total + 1
run_total = run_total + 7
run_total = run_total + 3</code></pre></section><section class="SsectionLevel6" id="section 9.1.8.5.4"><h5 class="heading">9.1.8.5.4Â <a name="(part._.Testing_and_variables_that_can_change)"/>Testing and variables that can change<a href="#(part._.Testing_and_variables_that_can_change)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>We intentionally showed a very particular pattern of using variables that can
change. While there are other uses (explored in part in
<a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>), a main reason to stay with this particular
template is the difficulty in testing and correspondingly, understanding, code
that uses them in other ways.</p><p>In particular, note that the pattern means that we never define a variables that
can change outside a function, which means it can never be used by
different functions, or multiple function calls. Each time the function runs, a
new variable is created, it is modified in the <code data-lang="pyret" class="sourceCode">for each</code> loop, and then
the value is returned, and the entry in the program directory is removed.</p><p>Consider what happens if we donâ€™t follow our pattern. Letâ€™s say we had the
following problem:</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Given a list of numbers, return the prefix of the list (i.e., all
elements, starting from the beginning) that sums to less than 100.</p></blockquote></blockquote><p>Having learned about mutable variables, but not following the pattern, you might
come up with code like this:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var count = 0

fun prefix-under-100(l :: List) -&gt; List:
  var output = [list: ]
  for each(elt from l):
    count := count + elt
    when (count &lt; 100):
      output := output + [list: elt]
    end
  end
end</code></pre><p>Now, this might seem reasonable â€“ weâ€™ve used a new construct, <code data-lang="pyret" class="sourceCode">when</code>,
which is an <code data-lang="pyret" class="sourceCode">if</code> expression that has no <code data-lang="pyret" class="sourceCode">else</code> â€“ this only makes
sense to do inside of a <code data-lang="pyret" class="sourceCode">for each</code> block, where we donâ€™t need a value as a
result. It is equivalent to:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if (count &lt; 100):
  output := output + [list: elt]
else:
  nothing
end</code></pre><p>Where <code data-lang="pyret" class="sourceCode">nothing</code> is a value that is used in Pyret to indicate that there is
no particular value of importance.</p><p>But what happens when we use this function?</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
    prefix-under-100([list: 20, 30, 40]) is [list: 20, 30, 40]
    prefix-under-100([list: 80, 20, 10]) is [list: 80]
end</code></pre><p>The first two tests pass, but the last one doesnâ€™t. Why? If we run the first one
again, things are even more confusing, i.e., if instead of the above, we ran
this <code data-lang="pyret" class="sourceCode">check</code> block:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
    prefix-under-100([list: 20, 30, 40]) is [list: 20, 30, 40]
    prefix-under-100([list: 80, 20, 10]) is [list: 80]
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
end</code></pre><p>Now the test that passed at first no longer passes!</p><p>What we are seeing is that since the variable is outside the function, it is
shared across different calls to the function. It is added to the program
directory once, and each time we call <code data-lang="pyret" class="sourceCode">prefix-under-100</code>, the program
directory entry is changed, but it is never reset.</p><p>Intentionally, all other uses of mutation have been on directory entries that
were created only for the body of the function, which meant that when the
function exited, they were removed. But now, we are always modifying the single
<code data-lang="pyret" class="sourceCode">count</code> variable. This means that every time we call
<code data-lang="pyret" class="sourceCode">prefix-under-100</code>, it behaves differently, because it not only do we have
to understand the code in the body of the function, we have to know the current
value of the count variable, which is not something we can figure out by just
looking at the code!</p><p>Functions that behave like this are said to have "side effects", and they are
much harder to test and much harder to understand, and as a result, much more
likely to have bugs! While the above example is wrong in a relatively
straightforward way, side effects can cause extremely subtle bugs that only
happen when functions are called in particular orders â€“ orders that may only
arised in very specific situations, making them hard to understand or reproduce.</p><p>While there are some places where doing this is necessary, almost all code can
be written without side effects, and will be much more reliable. We will explore
some cases where we might want to do this in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p></section>&#13;
<h5 class="heading">9.1.8.5.1Â <a name="(part._.Variables_that_can_change)"/>Variables that can change<a href="#(part._.Variables_that_can_change)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>First, note that we introduce the variable <code data-lang="pyret" class="sourceCode">result</code> with <code data-lang="pyret" class="sourceCode">var result</code>
â€“ this means that it can vary, which is important for the use with
<code data-lang="pyret" class="sourceCode">for each</code>.</p><p>By default, all variables in the program directory can never be changed. i.e.,
if I define a variable <code data-lang="pyret" class="sourceCode">x</code>, I can not redefine it later:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x = 10
# ...
x = 20 # produces shadowing error</code></pre><p>If we do want to change (or mutate) a variable in the directory later, we can, but we must
declare the variable can change â€“ as in, when we define it, rather than writing
<code data-lang="pyret" class="sourceCode">x = 10</code>, we must write <code data-lang="pyret" class="sourceCode">var x = 10</code>. Then, when we want to
update it, we can do so with the <code data-lang="pyret" class="sourceCode">:=</code> operator, as is done in the template above.</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var x = 10
# ... x points to 10 in directory
x := 20
# ... x now points to 20 in directory</code></pre><p>Note that trying to use <code data-lang="pyret" class="sourceCode">:=</code> on a variable that was not declared using
<code data-lang="pyret" class="sourceCode">var</code> will produce an error, and variables can still only ever be declared
once (whether with <code data-lang="pyret" class="sourceCode">var x = ...</code> or <code data-lang="pyret" class="sourceCode">x = ...</code>).</p>&#13;
<h5 class="heading">9.1.8.5.2Â <a name="(part._block_notation)"/>block notation<a href="#(part._block_notation)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Another new language feature shown in these examples is that since Pyret
functions by default expect only a single (non-definition) expression, we have
to add the <code data-lang="pyret" class="sourceCode">block</code> annotation at the top, indicating that the body of the
function is multiple expressions, with the final one being what the function
evaluates to.</p><p>As another example, if we tried to write:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function():
  1
  2
end</code></pre><p>Pyret would (rightly) error â€“ since the function returns the last expression in
its body, the <code data-lang="pyret" class="sourceCode">1</code> will be ignored â€“ and is most likely a mistake! Perhaps
the goal was to write:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function():
  1 + 2
end</code></pre><p>However, since a <code data-lang="pyret" class="sourceCode">for each</code> expression exists only to modify a variable,
functions that contain them will always have multiple expressions, and so
we need to communicate to Pyret that this is not a mistake. Adding <code data-lang="pyret" class="sourceCode">block</code>
before the <code data-lang="pyret" class="sourceCode">:</code> that begins the function (or, in general, wrapping any
expressions in <code data-lang="pyret" class="sourceCode">block:</code> and <code data-lang="pyret" class="sourceCode">end</code>) communicates to Pyret that we
understand that there are multiple expressions, and just want to evaluate to the
last one. So, if we truly wanted to write a function as our first example, we
could do that with:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun my-function() block:
  1
  2
end</code></pre>&#13;
<h5 class="heading">9.1.8.5.3Â <a name="(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)"/>How <code data-lang="pyret" class="sourceCode">for each</code> works<a href="#(part._.How___struct_traverse-element___procedure____lib_render-cond_rkt_38_12___works)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>A <code data-lang="pyret" class="sourceCode">for each</code> expression runs its body once for each element in the input
list, adding an entry to the program directory for each element as it goes. It
does not produce any value directly, so much instead rely on modifying variables
(described above) to produce a computation.</p><p>Consider summing a list of numbers. We could write a function that does this,
following our pattern, as:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun sum-list(lst :: List) block:
  var run_total = 0
  for each(item from lst):
    run_total := item + run_total
  end
  run_total
where:
  sum-list([list: 5, 1, 7, 3]) is 16
end</code></pre><p>On the concrete test input <code data-lang="pyret" class="sourceCode">[list: 5, 1, 7, 3]</code>, the loop runs four times,
once with <code data-lang="pyret" class="sourceCode">item</code> set to <code data-lang="pyret" class="sourceCode">5</code>, then with <code data-lang="pyret" class="sourceCode">item</code> set to <code data-lang="pyret" class="sourceCode">1</code>,
then with <code data-lang="pyret" class="sourceCode">item</code> set to <code data-lang="pyret" class="sourceCode">7</code>, and finally with <code data-lang="pyret" class="sourceCode">item</code> set to
<code data-lang="pyret" class="sourceCode">3</code>.</p><p>The <code data-lang="pyret" class="sourceCode">for each</code> construct saves us from writing the common code
multiple times, and also handles the fact that the lists we are
processing can be of arbitrary length (so we canâ€™t predict how many
times to write the common code). Thus, what happens is:</p><p/><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">run_total = 0
run_total = run_total + 5
run_total = run_total + 1
run_total = run_total + 7
run_total = run_total + 3</code></pre>&#13;
<h5 class="heading">9.1.8.5.4Â <a name="(part._.Testing_and_variables_that_can_change)"/>Testing and variables that can change<a href="#(part._.Testing_and_variables_that_can_change)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>We intentionally showed a very particular pattern of using variables that can
change. While there are other uses (explored in part in
<a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>), a main reason to stay with this particular
template is the difficulty in testing and correspondingly, understanding, code
that uses them in other ways.</p><p>In particular, note that the pattern means that we never define a variables that
can change outside a function, which means it can never be used by
different functions, or multiple function calls. Each time the function runs, a
new variable is created, it is modified in the <code data-lang="pyret" class="sourceCode">for each</code> loop, and then
the value is returned, and the entry in the program directory is removed.</p><p>Consider what happens if we donâ€™t follow our pattern. Letâ€™s say we had the
following problem:</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Given a list of numbers, return the prefix of the list (i.e., all
elements, starting from the beginning) that sums to less than 100.</p></blockquote></blockquote><p>Having learned about mutable variables, but not following the pattern, you might
come up with code like this:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">var count = 0

fun prefix-under-100(l :: List) -&gt; List:
  var output = [list: ]
  for each(elt from l):
    count := count + elt
    when (count &lt; 100):
      output := output + [list: elt]
    end
  end
end</code></pre><p>Now, this might seem reasonable â€“ weâ€™ve used a new construct, <code data-lang="pyret" class="sourceCode">when</code>,
which is an <code data-lang="pyret" class="sourceCode">if</code> expression that has no <code data-lang="pyret" class="sourceCode">else</code> â€“ this only makes
sense to do inside of a <code data-lang="pyret" class="sourceCode">for each</code> block, where we donâ€™t need a value as a
result. It is equivalent to:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">if (count &lt; 100):
  output := output + [list: elt]
else:
  nothing
end</code></pre><p>Where <code data-lang="pyret" class="sourceCode">nothing</code> is a value that is used in Pyret to indicate that there is
no particular value of importance.</p><p>But what happens when we use this function?</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
    prefix-under-100([list: 20, 30, 40]) is [list: 20, 30, 40]
    prefix-under-100([list: 80, 20, 10]) is [list: 80]
end</code></pre><p>The first two tests pass, but the last one doesnâ€™t. Why? If we run the first one
again, things are even more confusing, i.e., if instead of the above, we ran
this <code data-lang="pyret" class="sourceCode">check</code> block:</p><p/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
    prefix-under-100([list: 20, 30, 40]) is [list: 20, 30, 40]
    prefix-under-100([list: 80, 20, 10]) is [list: 80]
    prefix-under-100([list: 1, 2, 3]) is [list: 1, 2, 3]
end</code></pre><p>Now the test that passed at first no longer passes!</p><p>What we are seeing is that since the variable is outside the function, it is
shared across different calls to the function. It is added to the program
directory once, and each time we call <code data-lang="pyret" class="sourceCode">prefix-under-100</code>, the program
directory entry is changed, but it is never reset.</p><p>Intentionally, all other uses of mutation have been on directory entries that
were created only for the body of the function, which meant that when the
function exited, they were removed. But now, we are always modifying the single
<code data-lang="pyret" class="sourceCode">count</code> variable. This means that every time we call
<code data-lang="pyret" class="sourceCode">prefix-under-100</code>, it behaves differently, because it not only do we have
to understand the code in the body of the function, we have to know the current
value of the count variable, which is not something we can figure out by just
looking at the code!</p><p>Functions that behave like this are said to have "side effects", and they are
much harder to test and much harder to understand, and as a result, much more
likely to have bugs! While the above example is wrong in a relatively
straightforward way, side effects can cause extremely subtle bugs that only
happen when functions are called in particular orders â€“ orders that may only
arised in very specific situations, making them hard to understand or reproduce.</p><p>While there are some places where doing this is necessary, almost all code can
be written without side effects, and will be much more reliable. We will explore
some cases where we might want to do this in <a href="mutating-variables.html" data-pltdoc="x">Mutating Variables</a>.</p>    
</body>
</html>