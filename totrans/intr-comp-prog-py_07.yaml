- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RECURSION AND GLOBAL VARIABLES
  prefs: []
  type: TYPE_NORMAL
- en: You may have heard of **recursion**, and in all likelihood think of it as a
    rather subtle programming technique. That's a charming urban legend spread by
    computer scientists to make people think that we are smarter than we really are.
    Recursion is an important idea, but it's not so subtle, and it is more than a
    programming technique.
  prefs: []
  type: TYPE_NORMAL
- en: As a descriptive method, recursion is widely used, even by people who would
    never dream of writing a program. Consider part of the legal code of the United
    States defining the notion of a “birthright” citizenship. Roughly speaking, the
    definition is as follows
  prefs: []
  type: TYPE_NORMAL
- en: Any child born inside the United States or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any child born in wedlock outside the United States, one of whose parents is
    a citizen of the United States.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first part is simple; if you are born in the United States, you are a birthright
    citizen (such as Barack Obama). If you are not born in the U.S., it depends upon
    whether your parents were U.S. citizens at the time of your birth. And whether
    your parents were U.S. citizens might depend upon whether their parents were U.S.
    citizens, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In general, a recursive definition is made up of two parts. There is at least
    one **base case** that directly specifies the result for a special case (case
    1 in the example above), and there is at least one **recursive (inductive) case**
    (case 2 in the example above) that defines the answer in terms of the answer to
    the question on some other input, typically a simpler version of the same problem.
    It is the presence of a base case that keeps a recursive definition from being
    a circular definition.[^(39)](#c6-fn-0001)
  prefs: []
  type: TYPE_NORMAL
- en: The world's simplest recursive definition is probably the factorial function
    (typically written in mathematics using !) on natural numbers.[^(40)](#c6-fn-0002)
    The classic **inductive definition** is
  prefs: []
  type: TYPE_NORMAL
- en: '![c6-fig-5001.jpg](../images/c6-fig-5001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![c6-fig-5002.jpg](../images/c6-fig-5002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first equation defines the base case. The second equation defines factorial
    for all natural numbers, except the base case, in terms of the factorial of the
    previous number.
  prefs: []
  type: TYPE_NORMAL
- en: "[Figure 6-1](#c6-fig-0003) contains both an iterative (`\uFEFFfact_iter`) and\
    \ a recursive (`\uFEFFfact_rec`) implementation of factorial."
  prefs: []
  type: TYPE_NORMAL
- en: '![c6-fig-0001.jpg](../images/c6-fig-0001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 6-1](#c6-fig-0003a) Iterative and recursive implementations of factorial'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-1](#c6-fig-0003) Iterative and recursive implementations of factorial'
  prefs: []
  type: TYPE_NORMAL
- en: This function is sufficiently simple that neither implementation is hard to
    follow. Still, the second is a more direct translation of the original recursive
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: It almost seems like cheating to implement `fact_rec` by calling `fact_rec`
    from within the body of `fact_rec`. It works for the same reason that the iterative
    implementation works. We know that the iteration in `fact_iter` will terminate
    because `n` starts out positive and each time around the loop it is reduced by
    1\. This means that it cannot be greater than `1` forever. Similarly, if `fact_rec`
    is called with 1, it returns a value without making a recursive call. When it
    does make a recursive call, it always does so with a value one less than the value
    with which it was called. Eventually, the recursion terminates with the call `fact_rec(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** The harmonic sum of an integer, n > 0, can be calculated
    using the formula ![c6-fig-5003.jpg](../images/c6-fig-5003.jpg). Write a recursive
    function that computes this.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Fibonacci Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Fibonacci sequence is another common mathematical function that is usually
    defined recursively. “They breed like rabbits,” is often used to describe a population
    that the speaker thinks is growing too quickly. In the year 1202, the Italian
    mathematician Leonardo of Pisa, also known as Fibonacci, developed a formula to
    quantify this notion, albeit with some not terribly realistic assumptions.[^(41)](#c6-fn-0003)
  prefs: []
  type: TYPE_NORMAL
- en: Suppose a newly born pair of rabbits, one male and one female, are put in a
    pen (or worse, released in the wild). Suppose further that the rabbits can mate
    at the age of one month (which, astonishingly, some breeds can) and have a one-month
    gestation period (which, astonishingly, some breeds do). Finally, suppose that
    these mythical rabbits never die (not a property of any known breed of rabbit),
    and that the female always produces one new pair (one male, one female) every
    month from its second month on. How many female rabbits will there be at the end
    of six months?
  prefs: []
  type: TYPE_NORMAL
- en: On the last day of the first month (call it month `0`), there will be one female
    (ready to conceive on the first day of the next month). On the last day of the
    second month, there will still be only one female (since she will not give birth
    until the first day of the next month). On the last day of the next month, there
    will be two females (one pregnant and one not). On the last day of the next month,
    there will be three females (two pregnant and one not). And so on. Let's look
    at this progression in tabular form, [Figure 6-2](#c6-fig-0004).
  prefs: []
  type: TYPE_NORMAL
- en: '![c6-fig-0002.jpg](../images/c6-fig-0002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 6-2](#c6-fig-0004a) Growth in population of female rabbits'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that for month `n > 1`, `females(n) = females(n‑1) + females(n-2)`. This
    is not an accident. Each female that was alive in month `n-1` will still be alive
    in month `n`. In addition, each female that was alive in month `n‑2` will produce
    one new female in month `n`. The new females can be added to the females in month
    `n-1` to get the number of females in month `n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-2](#c6-fig-0004) Growth in population of female rabbits'
  prefs: []
  type: TYPE_NORMAL
- en: The growth in population is described naturally by the **recurrence**[^(42)](#c6-fn-0004)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This definition is different from the recursive definition of factorial:'
  prefs: []
  type: TYPE_NORMAL
- en: It has two base cases, not just one. In general, we can have as many base cases
    as we want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the recursive case, there are two recursive calls, not just one. Again, there
    can be as many as we want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 6-3](#c6-fig-0005) contains a straightforward implementation of the
    Fibonacci recurrence,[^(43)](#c6-fn-0005) along with a function that can be used
    to test it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c6-fig-0003.jpg](../images/c6-fig-0003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 6-3](#c6-fig-0005a) Recursive implementation of Fibonacci sequence'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the code is the easy part of solving this problem. Once we went from
    the vague statement of a problem about bunnies to a set of recursive equations,
    the code almost wrote itself. Finding some kind of abstract way to express a solution
    to the problem at hand is often the hardest step in building a useful program.
    We will talk much more about this later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: As you might guess, this is not a perfect model for the growth of rabbit populations
    in the wild. In 1859, Thomas Austin, an Australian farmer, imported 24 rabbits
    from England to be used as targets in hunts. Some escaped. Ten years later, approximately
    two million rabbits were shot or trapped each year in Australia, with no noticeable
    impact on the population. That's a lot of rabbits, but not anywhere close to the
    `120`^(th) Fibonacci numbe`r`.[^(44)](#c6-fn-0006)
  prefs: []
  type: TYPE_NORMAL
- en: Though the Fibonacci sequence does not actually provide a perfect model of the
    growth of rabbit populations, it does have many interesting mathematical properties.
    Fibonacci numbers are also common in nature. For example, for most flowers the
    number of petals is a Fibonacci number.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** When the implementation of `fib` in [Figure 6-3](#c6-fig-0005)
    is used to compute `fib(5)`, how many times does it compute the value of `fib(2)`
    on the way to computing `fib(5)`?'
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 Palindromes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recursion is also useful for many problems that do not involve numbers. [Figure
    6-4](#c6-fig-0006) contains a function, `is_palindrome,` that checks whether a
    string reads the same way backwards and forwards.
  prefs: []
  type: TYPE_NORMAL
- en: '![c6-fig-0004.jpg](../images/c6-fig-0004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 6-4](#c6-fig-0006a) Palindrome testing'
  prefs: []
  type: TYPE_NORMAL
- en: The function `is_palindrome` contains two internal **helper functions**. This
    should be of no interest to clients of the function, who should care only that
    the implementation of `is_palindrome` meets its specification. But you should
    care, because there are things to learn by examining the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The helper function `to_chars` converts all letters to lowercase and removes
    all non-letters. It starts by using a built-in method on strings to generate a
    string that is identical to `s`, except that all uppercase letters have been converted
    to lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: The helper function `is_pal` uses recursion to do the real work. The two base
    cases are strings of length zero or one. This means that the recursive part of
    the implementation is reached only on strings of length two or more. The conjunction[^(45)](#c6-fn-0007)
    in the `else` clause is evaluated from left to right. The code first checks whether
    the first and last characters are the same, and if they are, goes on to check
    whether the string minus those two characters is a palindrome. That the second
    conjunct is not evaluated unless the first conjunct evaluates to `True` is semantically
    irrelevant in this example. However, later in the book we will see examples where
    this kind of **short-circuit evaluation** of Boolean expressions is semantically
    relevant.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation of `is_palindrome` is an example of an important problem-solving
    principle known as **divide-and-conquer**. (This principle is related to but slightly
    different from divide-and-conquer algorithms, which are discussed in Chapter 12.)
    The problem-solving principle is to conquer a hard problem by breaking it into
    a set of subproblems with the properties
  prefs: []
  type: TYPE_NORMAL
- en: The subproblems are easier to solve than the original problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solutions of the subproblems can be combined to solve the original problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Divide-and-conquer is an old idea. Julius Caesar practiced what the Romans referred
    to as *divide et impera* (divide and rule). The British practiced it brilliantly
    to control the Indian subcontinent. Benjamin Franklin was well aware of the British
    expertise in using this technique, prompting him to say at the signing of the
    U.S. Declaration of Independence, “We must all hang together, or assuredly we
    shall all hang separately.”
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we solve the problem by breaking the original problem into a simpler
    version of the same problem (checking whether a shorter string is a palindrome)
    and a simple thing we know how to do (comparing single characters), and then combine
    the solutions with the logical operator `and`. [Figure 6-5](#c6-fig-0007) contains
    some code that can be used to visualize how this works.
  prefs: []
  type: TYPE_NORMAL
- en: '![c6-fig-0005.jpg](../images/c6-fig-0005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 6-5](#c6-fig-0007a) Code to visualize palindrome testing'
  prefs: []
  type: TYPE_NORMAL
- en: Executing the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 6.3 Global Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you tried calling `fib` with a large number, you probably noticed that it
    took a very long time to run. Suppose we want to know how many recursive calls
    are made. We could do a careful analysis of the code and figure it out, and in
    Chapter 11 we will talk about how to do that. Another approach is to add some
    code that counts the number of calls. One way to do that uses **global variables**.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, all of the functions we have written communicate with their environment
    solely through their parameters and return values. For the most part, this is
    exactly as it should be. It typically leads to programs that are relatively easy
    to read, test, and debug. Once in a while, however, global variables come in handy.
    Consider the code in [Figure 6-6](#c6-fig-0008).
  prefs: []
  type: TYPE_NORMAL
- en: '![c6-fig-0006.jpg](../images/c6-fig-0006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 6-6](#c6-fig-0008a) Using a global variable'
  prefs: []
  type: TYPE_NORMAL
- en: In each function, the line of code `global` `num_fib_calls` tells Python that
    the name `num_fib_calls` should be defined outside of the function in which the
    line of code appears. Had we not included the code `global num_fib_calls`, the
    name `num_fib_calls` would have been local to each of the functions `fib` and
    `test_fib`, because `num_fib_calls` occurs on the left-hand side of an assignment
    statement in both `fib` and `test_fib`. The functions `fib` and `test_fib` both
    have unfettered access to the object referenced by the variable `num_fib_calls`.
    The function `test_fib` binds `num_fib_calls` to `0` each time it calls `fib`,
    and `fib` increments the value of `num_fib_calls` each time `fib` is entered.
  prefs: []
  type: TYPE_NORMAL
- en: The call `test_fib(6)` produces the output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We introduce the topic of global variables with some trepidation. Since the
    1970s, card-carrying computer scientists have inveighed against them, for good
    reason. The indiscriminate use of global variables can lead to lots of problems.
    The key to making programs readable is locality. People read programs a piece
    at a time, and the less context needed to understand each piece, the better. Since
    global variables can be modified or read in a wide variety of places, their sloppy
    use can destroy locality. Nevertheless, there are a few times when they are just
    what is needed. The most common use of global variables is probably to define
    a **global constant** that will be used in many places. For example, someone writing
    a physics-related program might want to define the speed of light, C, once, and
    then use it in multiple functions.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 Terms Introduced in Chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: base case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: recursive (inductive) case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: inductive definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: recurrence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: helper functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: short-circuit evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: divide-and-conquer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: global variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: global constant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
