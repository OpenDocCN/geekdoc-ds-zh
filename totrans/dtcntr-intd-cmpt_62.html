<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>18.6Â Sets as a Case StudyðŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>18.6Â Sets as a Case StudyðŸ”—</h1>
<blockquote>åŽŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/sets-case-study.html">https://dcic-world.org/2025-08-27/sets-case-study.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Nature_of_the_.Data%29" class="toclink" data-pltdoc="x">18.6.1<span class="hspace">Â </span>Nature of the Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Nature_of_the_.Operations%29" class="toclink" data-pltdoc="x">18.6.2<span class="hspace">Â </span>Nature of the Operations</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Nature_of_the_.Guarantee%29" class="toclink" data-pltdoc="x">18.6.3<span class="hspace">Â </span>Nature of the Guarantee</a></p></td></tr></table><p>We have spent a lot of time on sets. That is not only because they are
useful in their own right, but also because they offer a window into a
variety of possible designs. In particular, they illustrate several
tradeoffs that we can make in the design of data structures, based on
our needs.</p><p>There are several dimensions along which we can divide our designs.</p><section class="SsectionLevel4" id="section 18.6.1"><h4 class="heading">18.6.1<span class="stt">Â </span><a name="(part._.Nature_of_the_.Data)"/>Nature of the Data<span class="button-group"><a href="#(part._.Nature_of_the_.Data)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>If the data cannot even be comparable for quality, then we canâ€™t
construct sets out of them, because equality is central to the
definition of a set.</p><p>If the data can be compared for equality but not for ordering, then we
can only construct list-sets [<a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>], with their
linear-time complexity. <span class="emph">However</span>, if we can <span class="emph">hash</span> the
values [<a href="orderability.html#%28part._hashing-values%29" data-pltdoc="x">Converting Values to Ordered Values</a>], then we can construct trees
[<a href="sets-from-trees.html" data-pltdoc="x">Making Sets Grow on Trees</a>] and hashtables
[<a href="hash-set-kv.html#%28part._hash-tables%29" data-pltdoc="x">Sets from Hashing and Arrays</a>]. Trees give us logarithmic complexity for the
most expensive atomic operations, while hashtables give us
constant-to-linear complexity.</p></section><section class="SsectionLevel4" id="section 18.6.2"><h4 class="heading">18.6.2<span class="stt">Â </span><a name="(part._.Nature_of_the_.Operations)"/>Nature of the Operations<span class="button-group"><a href="#(part._.Nature_of_the_.Operations)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Another dimension of variation is the collection of operations we
need. We began with a fairly ambitious, but standard, collection of
operations [<a href="sets-from-lists.html#%28elem._set-operations%29" data-pltdoc="x">&lt;<span style="font-style: italic">set-operations</span>&gt;</a>], but gradually ignored many of
them. In particular, some interpretations of sets, like
<a href="union-find.html" data-pltdoc="x">Union-Find</a>, achieve excellent complexity at the cost of
<span class="emph">most</span> of these operations. <a href="hash-set-kv.html#%28part._bloom-filters%29" data-pltdoc="x">Bloom Filters</a> provide
another instance of this. There is a general computer science
principle at work here: the fewer operations we need to support, the
better we can (sometimes) make the complexity of the remaining ones.</p></section><section class="SsectionLevel4" id="section 18.6.3"><h4 class="heading">18.6.3<span class="stt">Â </span><a name="(part._.Nature_of_the_.Guarantee)"/>Nature of the Guarantee<span class="button-group"><a href="#(part._.Nature_of_the_.Guarantee)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Most subtly, there was another distinction: whether or not we needed
reliable results. Most of our set representations are
reliable. However, we also saw one situation
[<a href="hash-set-kv.html#%28part._bloom-filters%29" data-pltdoc="x">Bloom Filters</a>] where we intentionally abandoned complete
reliability, replacing it with a statistical guarantee. In return,
this gave us (potentially) much higher performance.</p><p>Thus, sets provide a useful microcosm of computer science itself.</p></section>&#13;
<h4 class="heading">18.6.1<span class="stt">Â </span><a name="(part._.Nature_of_the_.Data)"/>Nature of the Data<span class="button-group"><a href="#(part._.Nature_of_the_.Data)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>If the data cannot even be comparable for quality, then we canâ€™t
construct sets out of them, because equality is central to the
definition of a set.</p><p>If the data can be compared for equality but not for ordering, then we
can only construct list-sets [<a href="sets-from-lists.html" data-pltdoc="x">Representing Sets as Lists</a>], with their
linear-time complexity. <span class="emph">However</span>, if we can <span class="emph">hash</span> the
values [<a href="orderability.html#%28part._hashing-values%29" data-pltdoc="x">Converting Values to Ordered Values</a>], then we can construct trees
[<a href="sets-from-trees.html" data-pltdoc="x">Making Sets Grow on Trees</a>] and hashtables
[<a href="hash-set-kv.html#%28part._hash-tables%29" data-pltdoc="x">Sets from Hashing and Arrays</a>]. Trees give us logarithmic complexity for the
most expensive atomic operations, while hashtables give us
constant-to-linear complexity.</p>&#13;
<h4 class="heading">18.6.2<span class="stt">Â </span><a name="(part._.Nature_of_the_.Operations)"/>Nature of the Operations<span class="button-group"><a href="#(part._.Nature_of_the_.Operations)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Another dimension of variation is the collection of operations we
need. We began with a fairly ambitious, but standard, collection of
operations [<a href="sets-from-lists.html#%28elem._set-operations%29" data-pltdoc="x">&lt;<span style="font-style: italic">set-operations</span>&gt;</a>], but gradually ignored many of
them. In particular, some interpretations of sets, like
<a href="union-find.html" data-pltdoc="x">Union-Find</a>, achieve excellent complexity at the cost of
<span class="emph">most</span> of these operations. <a href="hash-set-kv.html#%28part._bloom-filters%29" data-pltdoc="x">Bloom Filters</a> provide
another instance of this. There is a general computer science
principle at work here: the fewer operations we need to support, the
better we can (sometimes) make the complexity of the remaining ones.</p>&#13;
<h4 class="heading">18.6.3<span class="stt">Â </span><a name="(part._.Nature_of_the_.Guarantee)"/>Nature of the Guarantee<span class="button-group"><a href="#(part._.Nature_of_the_.Guarantee)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Most subtly, there was another distinction: whether or not we needed
reliable results. Most of our set representations are
reliable. However, we also saw one situation
[<a href="hash-set-kv.html#%28part._bloom-filters%29" data-pltdoc="x">Bloom Filters</a>] where we intentionally abandoned complete
reliability, replacing it with a statistical guarantee. In return,
this gave us (potentially) much higher performance.</p><p>Thus, sets provide a useful microcosm of computer science itself.</p>    
</body>
</html>