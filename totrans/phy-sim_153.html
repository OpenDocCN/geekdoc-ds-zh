<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Simulation Setup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Simulation Setup</h1>
<blockquote>原文：<a href="https://phys-sim-book.github.io/lec29.1-simulation_setup.html">https://phys-sim-book.github.io/lec29.1-simulation_setup.html</a></blockquote>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"/>

<p>In this section, we define the physical and numerical setup required for implementing a minimal MPM simulation of <strong>Two Colliding Elastic Blocks in 2D</strong>. We walk through the definition of simulation properties, initialization of particle positions and velocities, and data structures used throughout the simulation.</p>
<h3 id="physical-and-numerical-parameters"><a class="header" href="#physical-and-numerical-parameters">Physical and Numerical Parameters</a></h3>
<p>We begin by setting up the discretization of the simulation domain and the material parameters of the block:</p>
<p><a name="imp:lec29:property_def"/>
<strong>Implementation 30.1.1 (Physical and Numerical Parameters, simulator.py).</strong></p>
<pre><code class="language-python"># simulation setup
grid_size = 128 # background Eulerian grid's resolution, in 2D is [128, 128]
dx = 1.0 / grid_size # the domain size is [1m, 1m] in 2D, so dx for each cell is (1/128)m
dt = 2e-4 # time step size in second
ppc = 8 # average particles per cell

density = 1000 # mass density, unit: kg / m^3
E, nu = 1e4, 0.3 # block's Young's modulus and Poisson's ratio
mu, lam = E / (2 * (1 + nu)), E * nu / ((1 + nu) * (1 - 2 * nu)) # Lame parameters
</code></pre>
<p>These parameters define a uniform dense background grid, particle resolution, and time integration step size. The entire simulation domain spans from <code>[0, 0]</code> to <code>[1, 1]</code> meters, and we aim for around 8 particles per grid cell on average. The blocks are set to have mass density at <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"/><span class="mord">1000</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>, Young's modulus at <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"/><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">a</span></span></span></span>, and Poisson's ratio at <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">0.3</span></span></span></span>.</p>
<h3 id="initial-particle-sampling-and-scene-setup"><a class="header" href="#initial-particle-sampling-and-scene-setup">Initial Particle Sampling and Scene Setup</a></h3>
<p>We sample particles from two rectangular regions using <strong>uniform grid sampling</strong>. These two boxes are placed symmetrically on the left and right sides of the domain and are initialized with opposite velocities to simulate a head-on collision.</p>
<p>Compared to Poisson disk sampling, uniform sampling is easier to implement for analytic shapes, such as boxes and spheres, due to its structured nature and simple parametrization. However, this regularity can lead to <strong>aliasing artifacts</strong>, such as visible patterns or striping in the simulation, which may introduce unnatural structured noise into the result.</p>
<p>Here we adopt uniform sampling <strong>for simplicity and clarity</strong>, keeping the focus on the MPM pipeline itself.</p>
<p><a name="imp:lec29:setting"/>
<strong>Implementation 30.1.2 (Initial Particle Sampling and Scene Setup, simulator.py).</strong></p>
<pre><code class="language-python"># uniformly sampling material particles
def uniform_grid(x0, y0, x1, y1, dx):
    xx, yy = np.meshgrid(np.arange(x0, x1 + dx, dx), np.arange(y0, y1 + dx, dx))
    return np.column_stack((xx.ravel(), yy.ravel()))

box1_samples = uniform_grid(0.2, 0.4, 0.4, 0.6, dx / np.sqrt(ppc))
box1_velocities = np.tile(np.array([10.0, 0]), (len(box1_samples), 1))
box2_samples = uniform_grid(0.6, 0.4, 0.8, 0.6, dx / np.sqrt(ppc))
box2_velocities = np.tile(np.array([-10.0, 0]), (len(box1_samples), 1))
all_samples = np.concatenate([box1_samples, box2_samples], axis=0)
all_velocities = np.concatenate([box1_velocities, box2_velocities], axis=0)
</code></pre>
<p>Each block consists of uniformly distributed material points representing a homogeneous elastic body. The left block is given an initial velocity of ([+10, 0]) m/s, and the right block ([-10, 0]) m/s, setting up a symmetric, head-on collision scenario with <strong>zero net linear momentum</strong>. This configuration mimics a controlled impact experiment.</p>
<h3 id="particle-and-grid-data-fields"><a class="header" href="#particle-and-grid-data-fields">Particle and Grid Data Fields</a></h3>
<p>We define data fields to represent the state of each material point (particle) and background grid node. For particles, this includes position, velocity, volume, mass, and deformation gradient, following <a href="./lec26.1-material_particles.html">Material Particles</a>. For the grid, we define nodal mass and velocity fields using dense arrays, which are sufficient for small-scale simulations. These can be further optimized using sparse grid structures—a direction we leave as future work for interested readers.</p>
<p><a name="imp:lec29:data_def"/>
<strong>Implementation 30.1.3 (Particle and Grid Data Fields, simulator.py).</strong></p>
<pre><code class="language-python"># material particles data
N_particles = len(all_samples)
x = ti.Vector.field(2, float, N_particles) # the position of particles
x.from_numpy(all_samples)
v = ti.Vector.field(2, float, N_particles) # the velocity of particles
v.from_numpy(all_velocities)
vol = ti.field(float, N_particles)         # the volume of particle
vol.fill(0.2 * 0.4 / N_particles) # get the volume of each particle as V_rest / N_particles
m = ti.field(float, N_particles)           # the mass of particle
m.fill(vol[0] * density)
F = ti.Matrix.field(2, 2, float, N_particles)  # the deformation gradient of particles
F.from_numpy(np.tile(np.eye(2), (N_particles, 1, 1)))

# grid data
grid_m = ti.field(float, (grid_size, grid_size))
grid_v = ti.Vector.field(2, float, (grid_size, grid_size))
</code></pre>

                        
</body>
</html>