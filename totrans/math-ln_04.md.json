["```py\nvariable  {α  :  Type*}\nvariable  (s  t  u  :  Set  α)\nopen  Set\n\nexample  (h  :  s  ⊆  t)  :  s  ∩  u  ⊆  t  ∩  u  :=  by\n  rw  [subset_def,  inter_def,  inter_def]\n  rw  [subset_def]  at  h\n  simp  only  [mem_setOf]\n  rintro  x  ⟨xs,  xu⟩\n  exact  ⟨h  _  xs,  xu⟩\n\nexample  (h  :  s  ⊆  t)  :  s  ∩  u  ⊆  t  ∩  u  :=  by\n  simp  only  [subset_def,  mem_inter_iff]  at  *\n  rintro  x  ⟨xs,  xu⟩\n  exact  ⟨h  _  xs,  xu⟩ \n```", "```py\nexample  (h  :  s  ⊆  t)  :  s  ∩  u  ⊆  t  ∩  u  :=  by\n  intro  x  xsu\n  exact  ⟨h  xsu.1,  xsu.2⟩ \n```", "```py\nexample  (h  :  s  ⊆  t)  :  s  ∩  u  ⊆  t  ∩  u  :=\n  fun  x  ⟨xs,  xu⟩  ↦  ⟨h  xs,  xu⟩ \n```", "```py\nexample  :  s  ∩  (t  ∪  u)  ⊆  s  ∩  t  ∪  s  ∩  u  :=  by\n  intro  x  hx\n  have  xs  :  x  ∈  s  :=  hx.1\n  have  xtu  :  x  ∈  t  ∪  u  :=  hx.2\n  rcases  xtu  with  xt  |  xu\n  ·  left\n  show  x  ∈  s  ∩  t\n  exact  ⟨xs,  xt⟩\n  ·  right\n  show  x  ∈  s  ∩  u\n  exact  ⟨xs,  xu⟩ \n```", "```py\nexample  :  s  ∩  (t  ∪  u)  ⊆  s  ∩  t  ∪  s  ∩  u  :=  by\n  rintro  x  ⟨xs,  xt  |  xu⟩\n  ·  left;  exact  ⟨xs,  xt⟩\n  ·  right;  exact  ⟨xs,  xu⟩ \n```", "```py\nexample  :  s  ∩  t  ∪  s  ∩  u  ⊆  s  ∩  (t  ∪  u)  :=  by\n  sorry \n```", "```py\nexample  :  (s  \\  t)  \\  u  ⊆  s  \\  (t  ∪  u)  :=  by\n  intro  x  xstu\n  have  xs  :  x  ∈  s  :=  xstu.1.1\n  have  xnt  :  x  ∉  t  :=  xstu.1.2\n  have  xnu  :  x  ∉  u  :=  xstu.2\n  constructor\n  ·  exact  xs\n  intro  xtu\n  -- x ∈ t ∨ x ∈ u\n  rcases  xtu  with  xt  |  xu\n  ·  show  False;  exact  xnt  xt\n  ·  show  False;  exact  xnu  xu\n\nexample  :  (s  \\  t)  \\  u  ⊆  s  \\  (t  ∪  u)  :=  by\n  rintro  x  ⟨⟨xs,  xnt⟩,  xnu⟩\n  use  xs\n  rintro  (xt  |  xu)  <;>  contradiction \n```", "```py\nexample  :  s  \\  (t  ∪  u)  ⊆  (s  \\  t)  \\  u  :=  by\n  sorry \n```", "```py\nexample  :  s  ∩  t  =  t  ∩  s  :=  by\n  ext  x\n  simp  only  [mem_inter_iff]\n  constructor\n  ·  rintro  ⟨xs,  xt⟩;  exact  ⟨xt,  xs⟩\n  ·  rintro  ⟨xt,  xs⟩;  exact  ⟨xs,  xt⟩ \n```", "```py\nexample  :  s  ∩  t  =  t  ∩  s  :=\n  Set.ext  fun  x  ↦  ⟨fun  ⟨xs,  xt⟩  ↦  ⟨xt,  xs⟩,  fun  ⟨xt,  xs⟩  ↦  ⟨xs,  xt⟩⟩ \n```", "```py\nexample  :  s  ∩  t  =  t  ∩  s  :=  by  ext  x;  simp  [and_comm] \n```", "```py\nexample  :  s  ∩  t  =  t  ∩  s  :=  by\n  apply  Subset.antisymm\n  ·  rintro  x  ⟨xs,  xt⟩;  exact  ⟨xt,  xs⟩\n  ·  rintro  x  ⟨xt,  xs⟩;  exact  ⟨xs,  xt⟩ \n```", "```py\nexample  :  s  ∩  t  =  t  ∩  s  :=\n  Subset.antisymm  sorry  sorry \n```", "```py\nexample  :  s  ∩  (s  ∪  t)  =  s  :=  by\n  sorry\n\nexample  :  s  ∪  s  ∩  t  =  s  :=  by\n  sorry\n\nexample  :  s  \\  t  ∪  t  =  s  ∪  t  :=  by\n  sorry\n\nexample  :  s  \\  t  ∪  t  \\  s  =  (s  ∪  t)  \\  (s  ∩  t)  :=  by\n  sorry \n```", "```py\ndef  evens  :  Set  ℕ  :=\n  {  n  |  Even  n  }\n\ndef  odds  :  Set  ℕ  :=\n  {  n  |  ¬Even  n  }\n\nexample  :  evens  ∪  odds  =  univ  :=  by\n  rw  [evens,  odds]\n  ext  n\n  simp  [-Nat.not_even_iff_odd]\n  apply  Classical.em \n```", "```py\nexample  (x  :  ℕ)  (h  :  x  ∈  (∅  :  Set  ℕ))  :  False  :=\n  h\n\nexample  (x  :  ℕ)  :  x  ∈  (univ  :  Set  ℕ)  :=\n  trivial \n```", "```py\nexample  :  {  n  |  Nat.Prime  n  }  ∩  {  n  |  n  >  2  }  ⊆  {  n  |  ¬Even  n  }  :=  by\n  sorry \n```", "```py\n#print  Prime\n\n#print  Nat.Prime\n\nexample  (n  :  ℕ)  :  Prime  n  ↔  Nat.Prime  n  :=\n  Nat.prime_iff.symm\n\nexample  (n  :  ℕ)  (h  :  Prime  n)  :  Nat.Prime  n  :=  by\n  rw  [Nat.prime_iff]\n  exact  h \n```", "```py\nexample  (n  :  ℕ)  (h  :  Prime  n)  :  Nat.Prime  n  :=  by\n  rwa  [Nat.prime_iff] \n```", "```py\nvariable  (s  t  :  Set  ℕ)\n\nexample  (h₀  :  ∀  x  ∈  s,  ¬Even  x)  (h₁  :  ∀  x  ∈  s,  Prime  x)  :  ∀  x  ∈  s,  ¬Even  x  ∧  Prime  x  :=  by\n  intro  x  xs\n  constructor\n  ·  apply  h₀  x  xs\n  apply  h₁  x  xs\n\nexample  (h  :  ∃  x  ∈  s,  ¬Even  x  ∧  Prime  x)  :  ∃  x  ∈  s,  Prime  x  :=  by\n  rcases  h  with  ⟨x,  xs,  _,  prime_x⟩\n  use  x,  xs \n```", "```py\nsection\nvariable  (ssubt  :  s  ⊆  t)\n\nexample  (h₀  :  ∀  x  ∈  t,  ¬Even  x)  (h₁  :  ∀  x  ∈  t,  Prime  x)  :  ∀  x  ∈  s,  ¬Even  x  ∧  Prime  x  :=  by\n  sorry\n\nexample  (h  :  ∃  x  ∈  s,  ¬Even  x  ∧  Prime  x)  :  ∃  x  ∈  t,  Prime  x  :=  by\n  sorry\n\nend \n```", "```py\nvariable  {α  I  :  Type*}\nvariable  (A  B  :  I  →  Set  α)\nvariable  (s  :  Set  α)\n\nopen  Set\n\nexample  :  (s  ∩  ⋃  i,  A  i)  =  ⋃  i,  A  i  ∩  s  :=  by\n  ext  x\n  simp  only  [mem_inter_iff,  mem_iUnion]\n  constructor\n  ·  rintro  ⟨xs,  ⟨i,  xAi⟩⟩\n  exact  ⟨i,  xAi,  xs⟩\n  rintro  ⟨i,  xAi,  xs⟩\n  exact  ⟨xs,  ⟨i,  xAi⟩⟩\n\nexample  :  (⋂  i,  A  i  ∩  B  i)  =  (⋂  i,  A  i)  ∩  ⋂  i,  B  i  :=  by\n  ext  x\n  simp  only  [mem_inter_iff,  mem_iInter]\n  constructor\n  ·  intro  h\n  constructor\n  ·  intro  i\n  exact  (h  i).1\n  intro  i\n  exact  (h  i).2\n  rintro  ⟨h1,  h2⟩  i\n  constructor\n  ·  exact  h1  i\n  exact  h2  i \n```", "```py\nexample  :  (s  ∪  ⋂  i,  A  i)  =  ⋂  i,  A  i  ∪  s  :=  by\n  sorry \n```", "```py\ndef  primes  :  Set  ℕ  :=\n  {  x  |  Nat.Prime  x  }\n\nexample  :  (⋃  p  ∈  primes,  {  x  |  p  ^  2  ∣  x  })  =  {  x  |  ∃  p  ∈  primes,  p  ^  2  ∣  x  }  :=by\n  ext\n  rw  [mem_iUnion₂]\n  simp\n\nexample  :  (⋃  p  ∈  primes,  {  x  |  p  ^  2  ∣  x  })  =  {  x  |  ∃  p  ∈  primes,  p  ^  2  ∣  x  }  :=  by\n  ext\n  simp\n\nexample  :  (⋂  p  ∈  primes,  {  x  |  ¬p  ∣  x  })  ⊆  {  x  |  x  =  1  }  :=  by\n  intro  x\n  contrapose!\n  simp\n  apply  Nat.exists_prime_and_dvd \n```", "```py\nexample  :  (⋃  p  ∈  primes,  {  x  |  x  ≤  p  })  =  univ  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  (s  :  Set  (Set  α))\n\nexample  :  ⋃₀  s  =  ⋃  t  ∈  s,  t  :=  by\n  ext  x\n  rw  [mem_iUnion₂]\n  simp\n\nexample  :  ⋂₀  s  =  ⋂  t  ∈  s,  t  :=  by\n  ext  x\n  rw  [mem_iInter₂]\n  rfl \n```", "```py\nvariable  {α  β  :  Type*}\nvariable  (f  :  α  →  β)\nvariable  (s  t  :  Set  α)\nvariable  (u  v  :  Set  β)\n\nopen  Function\nopen  Set\n\nexample  :  f  ⁻¹'  (u  ∩  v)  =  f  ⁻¹'  u  ∩  f  ⁻¹'  v  :=  by\n  ext\n  rfl \n```", "```py\nexample  :  f  ''  (s  ∪  t)  =  f  ''  s  ∪  f  ''  t  :=  by\n  ext  y;  constructor\n  ·  rintro  ⟨x,  xs  |  xt,  rfl⟩\n  ·  left\n  use  x,  xs\n  right\n  use  x,  xt\n  rintro  (⟨x,  xs,  rfl⟩  |  ⟨x,  xt,  rfl⟩)\n  ·  use  x,  Or.inl  xs\n  use  x,  Or.inr  xt \n```", "```py\nexample  :  s  ⊆  f  ⁻¹'  (f  ''  s)  :=  by\n  intro  x  xs\n  show  f  x  ∈  f  ''  s\n  use  x,  xs \n```", "```py\nexample  :  f  ''  s  ⊆  v  ↔  s  ⊆  f  ⁻¹'  v  :=  by\n  sorry \n```", "```py\nexample  (h  :  Injective  f)  :  f  ⁻¹'  (f  ''  s)  ⊆  s  :=  by\n  sorry\n\nexample  :  f  ''  (f  ⁻¹'  u)  ⊆  u  :=  by\n  sorry\n\nexample  (h  :  Surjective  f)  :  u  ⊆  f  ''  (f  ⁻¹'  u)  :=  by\n  sorry\n\nexample  (h  :  s  ⊆  t)  :  f  ''  s  ⊆  f  ''  t  :=  by\n  sorry\n\nexample  (h  :  u  ⊆  v)  :  f  ⁻¹'  u  ⊆  f  ⁻¹'  v  :=  by\n  sorry\n\nexample  :  f  ⁻¹'  (u  ∪  v)  =  f  ⁻¹'  u  ∪  f  ⁻¹'  v  :=  by\n  sorry\n\nexample  :  f  ''  (s  ∩  t)  ⊆  f  ''  s  ∩  f  ''  t  :=  by\n  sorry\n\nexample  (h  :  Injective  f)  :  f  ''  s  ∩  f  ''  t  ⊆  f  ''  (s  ∩  t)  :=  by\n  sorry\n\nexample  :  f  ''  s  \\  f  ''  t  ⊆  f  ''  (s  \\  t)  :=  by\n  sorry\n\nexample  :  f  ⁻¹'  u  \\  f  ⁻¹'  v  ⊆  f  ⁻¹'  (u  \\  v)  :=  by\n  sorry\n\nexample  :  f  ''  s  ∩  v  =  f  ''  (s  ∩  f  ⁻¹'  v)  :=  by\n  sorry\n\nexample  :  f  ''  (s  ∩  f  ⁻¹'  u)  ⊆  f  ''  s  ∩  u  :=  by\n  sorry\n\nexample  :  s  ∩  f  ⁻¹'  u  ⊆  f  ⁻¹'  (f  ''  s  ∩  u)  :=  by\n  sorry\n\nexample  :  s  ∪  f  ⁻¹'  u  ⊆  f  ⁻¹'  (f  ''  s  ∪  u)  :=  by\n  sorry \n```", "```py\nvariable  {I  :  Type*}  (A  :  I  →  Set  α)  (B  :  I  →  Set  β)\n\nexample  :  (f  ''  ⋃  i,  A  i)  =  ⋃  i,  f  ''  A  i  :=  by\n  sorry\n\nexample  :  (f  ''  ⋂  i,  A  i)  ⊆  ⋂  i,  f  ''  A  i  :=  by\n  sorry\n\nexample  (i  :  I)  (injf  :  Injective  f)  :  (⋂  i,  f  ''  A  i)  ⊆  f  ''  ⋂  i,  A  i  :=  by\n  sorry\n\nexample  :  (f  ⁻¹'  ⋃  i,  B  i)  =  ⋃  i,  f  ⁻¹'  B  i  :=  by\n  sorry\n\nexample  :  (f  ⁻¹'  ⋂  i,  B  i)  =  ⋂  i,  f  ⁻¹'  B  i  :=  by\n  sorry \n```", "```py\nexample  :  InjOn  f  s  ↔  ∀  x₁  ∈  s,  ∀  x₂  ∈  s,  f  x₁  =  f  x₂  →  x₁  =  x₂  :=\n  Iff.refl  _ \n```", "```py\nopen  Set  Real\n\nexample  :  InjOn  log  {  x  |  x  >  0  }  :=  by\n  intro  x  xpos  y  ypos\n  intro  e\n  -- log x = log y\n  calc\n  x  =  exp  (log  x)  :=  by  rw  [exp_log  xpos]\n  _  =  exp  (log  y)  :=  by  rw  [e]\n  _  =  y  :=  by  rw  [exp_log  ypos]\n\nexample  :  range  exp  =  {  y  |  y  >  0  }  :=  by\n  ext  y;  constructor\n  ·  rintro  ⟨x,  rfl⟩\n  apply  exp_pos\n  intro  ypos\n  use  log  y\n  rw  [exp_log  ypos] \n```", "```py\nexample  :  InjOn  sqrt  {  x  |  x  ≥  0  }  :=  by\n  sorry\n\nexample  :  InjOn  (fun  x  ↦  x  ^  2)  {  x  :  ℝ  |  x  ≥  0  }  :=  by\n  sorry\n\nexample  :  sqrt  ''  {  x  |  x  ≥  0  }  =  {  y  |  y  ≥  0  }  :=  by\n  sorry\n\nexample  :  (range  fun  x  ↦  x  ^  2)  =  {  y  :  ℝ  |  y  ≥  0  }  :=  by\n  sorry \n```", "```py\nvariable  {α  β  :  Type*}  [Inhabited  α]\n\n#check  (default  :  α)\n\nvariable  (P  :  α  →  Prop)  (h  :  ∃  x,  P  x)\n\n#check  Classical.choose  h\n\nexample  :  P  (Classical.choose  h)  :=\n  Classical.choose_spec  h \n```", "```py\nnoncomputable  section\n\nopen  Classical\n\ndef  inverse  (f  :  α  →  β)  :  β  →  α  :=  fun  y  :  β  ↦\n  if  h  :  ∃  x,  f  x  =  y  then  Classical.choose  h  else  default\n\ntheorem  inverse_spec  {f  :  α  →  β}  (y  :  β)  (h  :  ∃  x,  f  x  =  y)  :  f  (inverse  f  y)  =  y  :=  by\n  rw  [inverse,  dif_pos  h]\n  exact  Classical.choose_spec  h \n```", "```py\nvariable  (f  :  α  →  β)\n\nopen  Function\n\nexample  :  Injective  f  ↔  LeftInverse  (inverse  f)  f  :=\n  sorry\n\nexample  :  Surjective  f  ↔  RightInverse  (inverse  f)  f  :=\n  sorry \n```", "```py\ntheorem  Cantor  :  ∀  f  :  α  →  Set  α,  ¬Surjective  f  :=  by\n  intro  f  surjf\n  let  S  :=  {  i  |  i  ∉  f  i  }\n  rcases  surjf  S  with  ⟨j,  h⟩\n  have  h₁  :  j  ∉  f  j  :=  by\n  intro  h'\n  have  :  j  ∉  f  j  :=  by  rwa  [h]  at  h'\n  contradiction\n  have  h₂  :  j  ∈  S\n  sorry\n  have  h₃  :  j  ∉  S\n  sorry\n  contradiction \n```", "```py\nnoncomputable  section\nopen  Classical\nvariable  {α  β  :  Type*}  [Nonempty  β] \n```", "```py\n#check  (invFun  g  :  α  →  β)\n#check  (leftInverse_invFun  :  Injective  g  →  LeftInverse  (invFun  g)  g)\n#check  (leftInverse_invFun  :  Injective  g  →  ∀  y,  invFun  g  (g  y)  =  y)\n#check  (invFun_eq  :  (∃  y,  g  y  =  x)  →  g  (invFun  g  x)  =  x) \n```", "```py\nvariable  (f  :  α  →  β)  (g  :  β  →  α)\n\ndef  sbAux  :  ℕ  →  Set  α\n  |  0  =>  univ  \\  g  ''  univ\n  |  n  +  1  =>  g  ''  (f  ''  sbAux  n)\n\ndef  sbSet  :=\n  ⋃  n,  sbAux  f  g  n \n```", "```py\ndef  sbFun  (x  :  α)  :  β  :=\n  if  x  ∈  sbSet  f  g  then  f  x  else  invFun  g  x \n```", "```py\ntheorem  sb_right_inv  {x  :  α}  (hx  :  x  ∉  sbSet  f  g)  :  g  (invFun  g  x)  =  x  :=  by\n  have  :  x  ∈  g  ''  univ  :=  by\n  contrapose!  hx\n  rw  [sbSet,  mem_iUnion]\n  use  0\n  rw  [sbAux,  mem_diff]\n  sorry\n  have  :  ∃  y,  g  y  =  x  :=  by\n  sorry\n  sorry \n```", "```py\ntheorem  sb_injective  (hf  :  Injective  f)  :  Injective  (sbFun  f  g)  :=  by\n  set  A  :=  sbSet  f  g  with  A_def\n  set  h  :=  sbFun  f  g  with  h_def\n  intro  x₁  x₂\n  intro  (hxeq  :  h  x₁  =  h  x₂)\n  show  x₁  =  x₂\n  simp  only  [h_def,  sbFun,  ←  A_def]  at  hxeq\n  by_cases  xA  :  x₁  ∈  A  ∨  x₂  ∈  A\n  ·  wlog  x₁A  :  x₁  ∈  A  generalizing  x₁  x₂  hxeq  xA\n  ·  symm\n  apply  this  hxeq.symm  xA.symm  (xA.resolve_left  x₁A)\n  have  x₂A  :  x₂  ∈  A  :=  by\n  apply  _root_.not_imp_self.mp\n  intro  (x₂nA  :  x₂  ∉  A)\n  rw  [if_pos  x₁A,  if_neg  x₂nA]  at  hxeq\n  rw  [A_def,  sbSet,  mem_iUnion]  at  x₁A\n  have  x₂eq  :  x₂  =  g  (f  x₁)  :=  by\n  sorry\n  rcases  x₁A  with  ⟨n,  hn⟩\n  rw  [A_def,  sbSet,  mem_iUnion]\n  use  n  +  1\n  simp  [sbAux]\n  exact  ⟨x₁,  hn,  x₂eq.symm⟩\n  sorry\n  push_neg  at  xA\n  sorry \n```", "```py\ntheorem  sb_surjective  (hg  :  Injective  g)  :  Surjective  (sbFun  f  g)  :=  by\n  set  A  :=  sbSet  f  g  with  A_def\n  set  h  :=  sbFun  f  g  with  h_def\n  intro  y\n  by_cases  gyA  :  g  y  ∈  A\n  ·  rw  [A_def,  sbSet,  mem_iUnion]  at  gyA\n  rcases  gyA  with  ⟨n,  hn⟩\n  rcases  n  with  _  |  n\n  ·  simp  [sbAux]  at  hn\n  simp  [sbAux]  at  hn\n  rcases  hn  with  ⟨x,  xmem,  hx⟩\n  use  x\n  have  :  x  ∈  A  :=  by\n  rw  [A_def,  sbSet,  mem_iUnion]\n  exact  ⟨n,  xmem⟩\n  rw  [h_def,  sbFun,  if_pos  this]\n  apply  hg  hx\n\n  sorry \n```", "```py\ntheorem  schroeder_bernstein  {f  :  α  →  β}  {g  :  β  →  α}  (hf  :  Injective  f)  (hg  :  Injective  g)  :\n  ∃  h  :  α  →  β,  Bijective  h  :=\n  ⟨sbFun  f  g,  sb_injective  f  g  hf,  sb_surjective  f  g  hg⟩ \n```", "```py\nvariable  {α  :  Type*}\nvariable  (s  t  u  :  Set  α)\nopen  Set\n\nexample  (h  :  s  ⊆  t)  :  s  ∩  u  ⊆  t  ∩  u  :=  by\n  rw  [subset_def,  inter_def,  inter_def]\n  rw  [subset_def]  at  h\n  simp  only  [mem_setOf]\n  rintro  x  ⟨xs,  xu⟩\n  exact  ⟨h  _  xs,  xu⟩\n\nexample  (h  :  s  ⊆  t)  :  s  ∩  u  ⊆  t  ∩  u  :=  by\n  simp  only  [subset_def,  mem_inter_iff]  at  *\n  rintro  x  ⟨xs,  xu⟩\n  exact  ⟨h  _  xs,  xu⟩ \n```", "```py\nexample  (h  :  s  ⊆  t)  :  s  ∩  u  ⊆  t  ∩  u  :=  by\n  intro  x  xsu\n  exact  ⟨h  xsu.1,  xsu.2⟩ \n```", "```py\nexample  (h  :  s  ⊆  t)  :  s  ∩  u  ⊆  t  ∩  u  :=\n  fun  x  ⟨xs,  xu⟩  ↦  ⟨h  xs,  xu⟩ \n```", "```py\nexample  :  s  ∩  (t  ∪  u)  ⊆  s  ∩  t  ∪  s  ∩  u  :=  by\n  intro  x  hx\n  have  xs  :  x  ∈  s  :=  hx.1\n  have  xtu  :  x  ∈  t  ∪  u  :=  hx.2\n  rcases  xtu  with  xt  |  xu\n  ·  left\n  show  x  ∈  s  ∩  t\n  exact  ⟨xs,  xt⟩\n  ·  right\n  show  x  ∈  s  ∩  u\n  exact  ⟨xs,  xu⟩ \n```", "```py\nexample  :  s  ∩  (t  ∪  u)  ⊆  s  ∩  t  ∪  s  ∩  u  :=  by\n  rintro  x  ⟨xs,  xt  |  xu⟩\n  ·  left;  exact  ⟨xs,  xt⟩\n  ·  right;  exact  ⟨xs,  xu⟩ \n```", "```py\nexample  :  s  ∩  t  ∪  s  ∩  u  ⊆  s  ∩  (t  ∪  u)  :=  by\n  sorry \n```", "```py\nexample  :  (s  \\  t)  \\  u  ⊆  s  \\  (t  ∪  u)  :=  by\n  intro  x  xstu\n  have  xs  :  x  ∈  s  :=  xstu.1.1\n  have  xnt  :  x  ∉  t  :=  xstu.1.2\n  have  xnu  :  x  ∉  u  :=  xstu.2\n  constructor\n  ·  exact  xs\n  intro  xtu\n  -- x ∈ t ∨ x ∈ u\n  rcases  xtu  with  xt  |  xu\n  ·  show  False;  exact  xnt  xt\n  ·  show  False;  exact  xnu  xu\n\nexample  :  (s  \\  t)  \\  u  ⊆  s  \\  (t  ∪  u)  :=  by\n  rintro  x  ⟨⟨xs,  xnt⟩,  xnu⟩\n  use  xs\n  rintro  (xt  |  xu)  <;>  contradiction \n```", "```py\nexample  :  s  \\  (t  ∪  u)  ⊆  (s  \\  t)  \\  u  :=  by\n  sorry \n```", "```py\nexample  :  s  ∩  t  =  t  ∩  s  :=  by\n  ext  x\n  simp  only  [mem_inter_iff]\n  constructor\n  ·  rintro  ⟨xs,  xt⟩;  exact  ⟨xt,  xs⟩\n  ·  rintro  ⟨xt,  xs⟩;  exact  ⟨xs,  xt⟩ \n```", "```py\nexample  :  s  ∩  t  =  t  ∩  s  :=\n  Set.ext  fun  x  ↦  ⟨fun  ⟨xs,  xt⟩  ↦  ⟨xt,  xs⟩,  fun  ⟨xt,  xs⟩  ↦  ⟨xs,  xt⟩⟩ \n```", "```py\nexample  :  s  ∩  t  =  t  ∩  s  :=  by  ext  x;  simp  [and_comm] \n```", "```py\nexample  :  s  ∩  t  =  t  ∩  s  :=  by\n  apply  Subset.antisymm\n  ·  rintro  x  ⟨xs,  xt⟩;  exact  ⟨xt,  xs⟩\n  ·  rintro  x  ⟨xt,  xs⟩;  exact  ⟨xs,  xt⟩ \n```", "```py\nexample  :  s  ∩  t  =  t  ∩  s  :=\n  Subset.antisymm  sorry  sorry \n```", "```py\nexample  :  s  ∩  (s  ∪  t)  =  s  :=  by\n  sorry\n\nexample  :  s  ∪  s  ∩  t  =  s  :=  by\n  sorry\n\nexample  :  s  \\  t  ∪  t  =  s  ∪  t  :=  by\n  sorry\n\nexample  :  s  \\  t  ∪  t  \\  s  =  (s  ∪  t)  \\  (s  ∩  t)  :=  by\n  sorry \n```", "```py\ndef  evens  :  Set  ℕ  :=\n  {  n  |  Even  n  }\n\ndef  odds  :  Set  ℕ  :=\n  {  n  |  ¬Even  n  }\n\nexample  :  evens  ∪  odds  =  univ  :=  by\n  rw  [evens,  odds]\n  ext  n\n  simp  [-Nat.not_even_iff_odd]\n  apply  Classical.em \n```", "```py\nexample  (x  :  ℕ)  (h  :  x  ∈  (∅  :  Set  ℕ))  :  False  :=\n  h\n\nexample  (x  :  ℕ)  :  x  ∈  (univ  :  Set  ℕ)  :=\n  trivial \n```", "```py\nexample  :  {  n  |  Nat.Prime  n  }  ∩  {  n  |  n  >  2  }  ⊆  {  n  |  ¬Even  n  }  :=  by\n  sorry \n```", "```py\n#print  Prime\n\n#print  Nat.Prime\n\nexample  (n  :  ℕ)  :  Prime  n  ↔  Nat.Prime  n  :=\n  Nat.prime_iff.symm\n\nexample  (n  :  ℕ)  (h  :  Prime  n)  :  Nat.Prime  n  :=  by\n  rw  [Nat.prime_iff]\n  exact  h \n```", "```py\nexample  (n  :  ℕ)  (h  :  Prime  n)  :  Nat.Prime  n  :=  by\n  rwa  [Nat.prime_iff] \n```", "```py\nvariable  (s  t  :  Set  ℕ)\n\nexample  (h₀  :  ∀  x  ∈  s,  ¬Even  x)  (h₁  :  ∀  x  ∈  s,  Prime  x)  :  ∀  x  ∈  s,  ¬Even  x  ∧  Prime  x  :=  by\n  intro  x  xs\n  constructor\n  ·  apply  h₀  x  xs\n  apply  h₁  x  xs\n\nexample  (h  :  ∃  x  ∈  s,  ¬Even  x  ∧  Prime  x)  :  ∃  x  ∈  s,  Prime  x  :=  by\n  rcases  h  with  ⟨x,  xs,  _,  prime_x⟩\n  use  x,  xs \n```", "```py\nsection\nvariable  (ssubt  :  s  ⊆  t)\n\nexample  (h₀  :  ∀  x  ∈  t,  ¬Even  x)  (h₁  :  ∀  x  ∈  t,  Prime  x)  :  ∀  x  ∈  s,  ¬Even  x  ∧  Prime  x  :=  by\n  sorry\n\nexample  (h  :  ∃  x  ∈  s,  ¬Even  x  ∧  Prime  x)  :  ∃  x  ∈  t,  Prime  x  :=  by\n  sorry\n\nend \n```", "```py\nvariable  {α  I  :  Type*}\nvariable  (A  B  :  I  →  Set  α)\nvariable  (s  :  Set  α)\n\nopen  Set\n\nexample  :  (s  ∩  ⋃  i,  A  i)  =  ⋃  i,  A  i  ∩  s  :=  by\n  ext  x\n  simp  only  [mem_inter_iff,  mem_iUnion]\n  constructor\n  ·  rintro  ⟨xs,  ⟨i,  xAi⟩⟩\n  exact  ⟨i,  xAi,  xs⟩\n  rintro  ⟨i,  xAi,  xs⟩\n  exact  ⟨xs,  ⟨i,  xAi⟩⟩\n\nexample  :  (⋂  i,  A  i  ∩  B  i)  =  (⋂  i,  A  i)  ∩  ⋂  i,  B  i  :=  by\n  ext  x\n  simp  only  [mem_inter_iff,  mem_iInter]\n  constructor\n  ·  intro  h\n  constructor\n  ·  intro  i\n  exact  (h  i).1\n  intro  i\n  exact  (h  i).2\n  rintro  ⟨h1,  h2⟩  i\n  constructor\n  ·  exact  h1  i\n  exact  h2  i \n```", "```py\nexample  :  (s  ∪  ⋂  i,  A  i)  =  ⋂  i,  A  i  ∪  s  :=  by\n  sorry \n```", "```py\ndef  primes  :  Set  ℕ  :=\n  {  x  |  Nat.Prime  x  }\n\nexample  :  (⋃  p  ∈  primes,  {  x  |  p  ^  2  ∣  x  })  =  {  x  |  ∃  p  ∈  primes,  p  ^  2  ∣  x  }  :=by\n  ext\n  rw  [mem_iUnion₂]\n  simp\n\nexample  :  (⋃  p  ∈  primes,  {  x  |  p  ^  2  ∣  x  })  =  {  x  |  ∃  p  ∈  primes,  p  ^  2  ∣  x  }  :=  by\n  ext\n  simp\n\nexample  :  (⋂  p  ∈  primes,  {  x  |  ¬p  ∣  x  })  ⊆  {  x  |  x  =  1  }  :=  by\n  intro  x\n  contrapose!\n  simp\n  apply  Nat.exists_prime_and_dvd \n```", "```py\nexample  :  (⋃  p  ∈  primes,  {  x  |  x  ≤  p  })  =  univ  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  (s  :  Set  (Set  α))\n\nexample  :  ⋃₀  s  =  ⋃  t  ∈  s,  t  :=  by\n  ext  x\n  rw  [mem_iUnion₂]\n  simp\n\nexample  :  ⋂₀  s  =  ⋂  t  ∈  s,  t  :=  by\n  ext  x\n  rw  [mem_iInter₂]\n  rfl \n```", "```py\nvariable  {α  β  :  Type*}\nvariable  (f  :  α  →  β)\nvariable  (s  t  :  Set  α)\nvariable  (u  v  :  Set  β)\n\nopen  Function\nopen  Set\n\nexample  :  f  ⁻¹'  (u  ∩  v)  =  f  ⁻¹'  u  ∩  f  ⁻¹'  v  :=  by\n  ext\n  rfl \n```", "```py\nexample  :  f  ''  (s  ∪  t)  =  f  ''  s  ∪  f  ''  t  :=  by\n  ext  y;  constructor\n  ·  rintro  ⟨x,  xs  |  xt,  rfl⟩\n  ·  left\n  use  x,  xs\n  right\n  use  x,  xt\n  rintro  (⟨x,  xs,  rfl⟩  |  ⟨x,  xt,  rfl⟩)\n  ·  use  x,  Or.inl  xs\n  use  x,  Or.inr  xt \n```", "```py\nexample  :  s  ⊆  f  ⁻¹'  (f  ''  s)  :=  by\n  intro  x  xs\n  show  f  x  ∈  f  ''  s\n  use  x,  xs \n```", "```py\nexample  :  f  ''  s  ⊆  v  ↔  s  ⊆  f  ⁻¹'  v  :=  by\n  sorry \n```", "```py\nexample  (h  :  Injective  f)  :  f  ⁻¹'  (f  ''  s)  ⊆  s  :=  by\n  sorry\n\nexample  :  f  ''  (f  ⁻¹'  u)  ⊆  u  :=  by\n  sorry\n\nexample  (h  :  Surjective  f)  :  u  ⊆  f  ''  (f  ⁻¹'  u)  :=  by\n  sorry\n\nexample  (h  :  s  ⊆  t)  :  f  ''  s  ⊆  f  ''  t  :=  by\n  sorry\n\nexample  (h  :  u  ⊆  v)  :  f  ⁻¹'  u  ⊆  f  ⁻¹'  v  :=  by\n  sorry\n\nexample  :  f  ⁻¹'  (u  ∪  v)  =  f  ⁻¹'  u  ∪  f  ⁻¹'  v  :=  by\n  sorry\n\nexample  :  f  ''  (s  ∩  t)  ⊆  f  ''  s  ∩  f  ''  t  :=  by\n  sorry\n\nexample  (h  :  Injective  f)  :  f  ''  s  ∩  f  ''  t  ⊆  f  ''  (s  ∩  t)  :=  by\n  sorry\n\nexample  :  f  ''  s  \\  f  ''  t  ⊆  f  ''  (s  \\  t)  :=  by\n  sorry\n\nexample  :  f  ⁻¹'  u  \\  f  ⁻¹'  v  ⊆  f  ⁻¹'  (u  \\  v)  :=  by\n  sorry\n\nexample  :  f  ''  s  ∩  v  =  f  ''  (s  ∩  f  ⁻¹'  v)  :=  by\n  sorry\n\nexample  :  f  ''  (s  ∩  f  ⁻¹'  u)  ⊆  f  ''  s  ∩  u  :=  by\n  sorry\n\nexample  :  s  ∩  f  ⁻¹'  u  ⊆  f  ⁻¹'  (f  ''  s  ∩  u)  :=  by\n  sorry\n\nexample  :  s  ∪  f  ⁻¹'  u  ⊆  f  ⁻¹'  (f  ''  s  ∪  u)  :=  by\n  sorry \n```", "```py\nvariable  {I  :  Type*}  (A  :  I  →  Set  α)  (B  :  I  →  Set  β)\n\nexample  :  (f  ''  ⋃  i,  A  i)  =  ⋃  i,  f  ''  A  i  :=  by\n  sorry\n\nexample  :  (f  ''  ⋂  i,  A  i)  ⊆  ⋂  i,  f  ''  A  i  :=  by\n  sorry\n\nexample  (i  :  I)  (injf  :  Injective  f)  :  (⋂  i,  f  ''  A  i)  ⊆  f  ''  ⋂  i,  A  i  :=  by\n  sorry\n\nexample  :  (f  ⁻¹'  ⋃  i,  B  i)  =  ⋃  i,  f  ⁻¹'  B  i  :=  by\n  sorry\n\nexample  :  (f  ⁻¹'  ⋂  i,  B  i)  =  ⋂  i,  f  ⁻¹'  B  i  :=  by\n  sorry \n```", "```py\nexample  :  InjOn  f  s  ↔  ∀  x₁  ∈  s,  ∀  x₂  ∈  s,  f  x₁  =  f  x₂  →  x₁  =  x₂  :=\n  Iff.refl  _ \n```", "```py\nopen  Set  Real\n\nexample  :  InjOn  log  {  x  |  x  >  0  }  :=  by\n  intro  x  xpos  y  ypos\n  intro  e\n  -- log x = log y\n  calc\n  x  =  exp  (log  x)  :=  by  rw  [exp_log  xpos]\n  _  =  exp  (log  y)  :=  by  rw  [e]\n  _  =  y  :=  by  rw  [exp_log  ypos]\n\nexample  :  range  exp  =  {  y  |  y  >  0  }  :=  by\n  ext  y;  constructor\n  ·  rintro  ⟨x,  rfl⟩\n  apply  exp_pos\n  intro  ypos\n  use  log  y\n  rw  [exp_log  ypos] \n```", "```py\nexample  :  InjOn  sqrt  {  x  |  x  ≥  0  }  :=  by\n  sorry\n\nexample  :  InjOn  (fun  x  ↦  x  ^  2)  {  x  :  ℝ  |  x  ≥  0  }  :=  by\n  sorry\n\nexample  :  sqrt  ''  {  x  |  x  ≥  0  }  =  {  y  |  y  ≥  0  }  :=  by\n  sorry\n\nexample  :  (range  fun  x  ↦  x  ^  2)  =  {  y  :  ℝ  |  y  ≥  0  }  :=  by\n  sorry \n```", "```py\nvariable  {α  β  :  Type*}  [Inhabited  α]\n\n#check  (default  :  α)\n\nvariable  (P  :  α  →  Prop)  (h  :  ∃  x,  P  x)\n\n#check  Classical.choose  h\n\nexample  :  P  (Classical.choose  h)  :=\n  Classical.choose_spec  h \n```", "```py\nnoncomputable  section\n\nopen  Classical\n\ndef  inverse  (f  :  α  →  β)  :  β  →  α  :=  fun  y  :  β  ↦\n  if  h  :  ∃  x,  f  x  =  y  then  Classical.choose  h  else  default\n\ntheorem  inverse_spec  {f  :  α  →  β}  (y  :  β)  (h  :  ∃  x,  f  x  =  y)  :  f  (inverse  f  y)  =  y  :=  by\n  rw  [inverse,  dif_pos  h]\n  exact  Classical.choose_spec  h \n```", "```py\nvariable  (f  :  α  →  β)\n\nopen  Function\n\nexample  :  Injective  f  ↔  LeftInverse  (inverse  f)  f  :=\n  sorry\n\nexample  :  Surjective  f  ↔  RightInverse  (inverse  f)  f  :=\n  sorry \n```", "```py\ntheorem  Cantor  :  ∀  f  :  α  →  Set  α,  ¬Surjective  f  :=  by\n  intro  f  surjf\n  let  S  :=  {  i  |  i  ∉  f  i  }\n  rcases  surjf  S  with  ⟨j,  h⟩\n  have  h₁  :  j  ∉  f  j  :=  by\n  intro  h'\n  have  :  j  ∉  f  j  :=  by  rwa  [h]  at  h'\n  contradiction\n  have  h₂  :  j  ∈  S\n  sorry\n  have  h₃  :  j  ∉  S\n  sorry\n  contradiction \n```", "```py\nnoncomputable  section\nopen  Classical\nvariable  {α  β  :  Type*}  [Nonempty  β] \n```", "```py\n#check  (invFun  g  :  α  →  β)\n#check  (leftInverse_invFun  :  Injective  g  →  LeftInverse  (invFun  g)  g)\n#check  (leftInverse_invFun  :  Injective  g  →  ∀  y,  invFun  g  (g  y)  =  y)\n#check  (invFun_eq  :  (∃  y,  g  y  =  x)  →  g  (invFun  g  x)  =  x) \n```", "```py\nvariable  (f  :  α  →  β)  (g  :  β  →  α)\n\ndef  sbAux  :  ℕ  →  Set  α\n  |  0  =>  univ  \\  g  ''  univ\n  |  n  +  1  =>  g  ''  (f  ''  sbAux  n)\n\ndef  sbSet  :=\n  ⋃  n,  sbAux  f  g  n \n```", "```py\ndef  sbFun  (x  :  α)  :  β  :=\n  if  x  ∈  sbSet  f  g  then  f  x  else  invFun  g  x \n```", "```py\ntheorem  sb_right_inv  {x  :  α}  (hx  :  x  ∉  sbSet  f  g)  :  g  (invFun  g  x)  =  x  :=  by\n  have  :  x  ∈  g  ''  univ  :=  by\n  contrapose!  hx\n  rw  [sbSet,  mem_iUnion]\n  use  0\n  rw  [sbAux,  mem_diff]\n  sorry\n  have  :  ∃  y,  g  y  =  x  :=  by\n  sorry\n  sorry \n```", "```py\ntheorem  sb_injective  (hf  :  Injective  f)  :  Injective  (sbFun  f  g)  :=  by\n  set  A  :=  sbSet  f  g  with  A_def\n  set  h  :=  sbFun  f  g  with  h_def\n  intro  x₁  x₂\n  intro  (hxeq  :  h  x₁  =  h  x₂)\n  show  x₁  =  x₂\n  simp  only  [h_def,  sbFun,  ←  A_def]  at  hxeq\n  by_cases  xA  :  x₁  ∈  A  ∨  x₂  ∈  A\n  ·  wlog  x₁A  :  x₁  ∈  A  generalizing  x₁  x₂  hxeq  xA\n  ·  symm\n  apply  this  hxeq.symm  xA.symm  (xA.resolve_left  x₁A)\n  have  x₂A  :  x₂  ∈  A  :=  by\n  apply  _root_.not_imp_self.mp\n  intro  (x₂nA  :  x₂  ∉  A)\n  rw  [if_pos  x₁A,  if_neg  x₂nA]  at  hxeq\n  rw  [A_def,  sbSet,  mem_iUnion]  at  x₁A\n  have  x₂eq  :  x₂  =  g  (f  x₁)  :=  by\n  sorry\n  rcases  x₁A  with  ⟨n,  hn⟩\n  rw  [A_def,  sbSet,  mem_iUnion]\n  use  n  +  1\n  simp  [sbAux]\n  exact  ⟨x₁,  hn,  x₂eq.symm⟩\n  sorry\n  push_neg  at  xA\n  sorry \n```", "```py\ntheorem  sb_surjective  (hg  :  Injective  g)  :  Surjective  (sbFun  f  g)  :=  by\n  set  A  :=  sbSet  f  g  with  A_def\n  set  h  :=  sbFun  f  g  with  h_def\n  intro  y\n  by_cases  gyA  :  g  y  ∈  A\n  ·  rw  [A_def,  sbSet,  mem_iUnion]  at  gyA\n  rcases  gyA  with  ⟨n,  hn⟩\n  rcases  n  with  _  |  n\n  ·  simp  [sbAux]  at  hn\n  simp  [sbAux]  at  hn\n  rcases  hn  with  ⟨x,  xmem,  hx⟩\n  use  x\n  have  :  x  ∈  A  :=  by\n  rw  [A_def,  sbSet,  mem_iUnion]\n  exact  ⟨n,  xmem⟩\n  rw  [h_def,  sbFun,  if_pos  this]\n  apply  hg  hx\n\n  sorry \n```", "```py\ntheorem  schroeder_bernstein  {f  :  α  →  β}  {g  :  β  →  α}  (hf  :  Injective  f)  (hg  :  Injective  g)  :\n  ∃  h  :  α  →  β,  Bijective  h  :=\n  ⟨sbFun  f  g,  sb_injective  f  g  hf,  sb_surjective  f  g  hg⟩ \n```", "```py\nvariable  {α  :  Type*}\nvariable  (s  t  u  :  Set  α)\nopen  Set\n\nexample  (h  :  s  ⊆  t)  :  s  ∩  u  ⊆  t  ∩  u  :=  by\n  rw  [subset_def,  inter_def,  inter_def]\n  rw  [subset_def]  at  h\n  simp  only  [mem_setOf]\n  rintro  x  ⟨xs,  xu⟩\n  exact  ⟨h  _  xs,  xu⟩\n\nexample  (h  :  s  ⊆  t)  :  s  ∩  u  ⊆  t  ∩  u  :=  by\n  simp  only  [subset_def,  mem_inter_iff]  at  *\n  rintro  x  ⟨xs,  xu⟩\n  exact  ⟨h  _  xs,  xu⟩ \n```", "```py\nexample  (h  :  s  ⊆  t)  :  s  ∩  u  ⊆  t  ∩  u  :=  by\n  intro  x  xsu\n  exact  ⟨h  xsu.1,  xsu.2⟩ \n```", "```py\nexample  (h  :  s  ⊆  t)  :  s  ∩  u  ⊆  t  ∩  u  :=\n  fun  x  ⟨xs,  xu⟩  ↦  ⟨h  xs,  xu⟩ \n```", "```py\nexample  :  s  ∩  (t  ∪  u)  ⊆  s  ∩  t  ∪  s  ∩  u  :=  by\n  intro  x  hx\n  have  xs  :  x  ∈  s  :=  hx.1\n  have  xtu  :  x  ∈  t  ∪  u  :=  hx.2\n  rcases  xtu  with  xt  |  xu\n  ·  left\n  show  x  ∈  s  ∩  t\n  exact  ⟨xs,  xt⟩\n  ·  right\n  show  x  ∈  s  ∩  u\n  exact  ⟨xs,  xu⟩ \n```", "```py\nexample  :  s  ∩  (t  ∪  u)  ⊆  s  ∩  t  ∪  s  ∩  u  :=  by\n  rintro  x  ⟨xs,  xt  |  xu⟩\n  ·  left;  exact  ⟨xs,  xt⟩\n  ·  right;  exact  ⟨xs,  xu⟩ \n```", "```py\nexample  :  s  ∩  t  ∪  s  ∩  u  ⊆  s  ∩  (t  ∪  u)  :=  by\n  sorry \n```", "```py\nexample  :  (s  \\  t)  \\  u  ⊆  s  \\  (t  ∪  u)  :=  by\n  intro  x  xstu\n  have  xs  :  x  ∈  s  :=  xstu.1.1\n  have  xnt  :  x  ∉  t  :=  xstu.1.2\n  have  xnu  :  x  ∉  u  :=  xstu.2\n  constructor\n  ·  exact  xs\n  intro  xtu\n  -- x ∈ t ∨ x ∈ u\n  rcases  xtu  with  xt  |  xu\n  ·  show  False;  exact  xnt  xt\n  ·  show  False;  exact  xnu  xu\n\nexample  :  (s  \\  t)  \\  u  ⊆  s  \\  (t  ∪  u)  :=  by\n  rintro  x  ⟨⟨xs,  xnt⟩,  xnu⟩\n  use  xs\n  rintro  (xt  |  xu)  <;>  contradiction \n```", "```py\nexample  :  s  \\  (t  ∪  u)  ⊆  (s  \\  t)  \\  u  :=  by\n  sorry \n```", "```py\nexample  :  s  ∩  t  =  t  ∩  s  :=  by\n  ext  x\n  simp  only  [mem_inter_iff]\n  constructor\n  ·  rintro  ⟨xs,  xt⟩;  exact  ⟨xt,  xs⟩\n  ·  rintro  ⟨xt,  xs⟩;  exact  ⟨xs,  xt⟩ \n```", "```py\nexample  :  s  ∩  t  =  t  ∩  s  :=\n  Set.ext  fun  x  ↦  ⟨fun  ⟨xs,  xt⟩  ↦  ⟨xt,  xs⟩,  fun  ⟨xt,  xs⟩  ↦  ⟨xs,  xt⟩⟩ \n```", "```py\nexample  :  s  ∩  t  =  t  ∩  s  :=  by  ext  x;  simp  [and_comm] \n```", "```py\nexample  :  s  ∩  t  =  t  ∩  s  :=  by\n  apply  Subset.antisymm\n  ·  rintro  x  ⟨xs,  xt⟩;  exact  ⟨xt,  xs⟩\n  ·  rintro  x  ⟨xt,  xs⟩;  exact  ⟨xs,  xt⟩ \n```", "```py\nexample  :  s  ∩  t  =  t  ∩  s  :=\n  Subset.antisymm  sorry  sorry \n```", "```py\nexample  :  s  ∩  (s  ∪  t)  =  s  :=  by\n  sorry\n\nexample  :  s  ∪  s  ∩  t  =  s  :=  by\n  sorry\n\nexample  :  s  \\  t  ∪  t  =  s  ∪  t  :=  by\n  sorry\n\nexample  :  s  \\  t  ∪  t  \\  s  =  (s  ∪  t)  \\  (s  ∩  t)  :=  by\n  sorry \n```", "```py\ndef  evens  :  Set  ℕ  :=\n  {  n  |  Even  n  }\n\ndef  odds  :  Set  ℕ  :=\n  {  n  |  ¬Even  n  }\n\nexample  :  evens  ∪  odds  =  univ  :=  by\n  rw  [evens,  odds]\n  ext  n\n  simp  [-Nat.not_even_iff_odd]\n  apply  Classical.em \n```", "```py\nexample  (x  :  ℕ)  (h  :  x  ∈  (∅  :  Set  ℕ))  :  False  :=\n  h\n\nexample  (x  :  ℕ)  :  x  ∈  (univ  :  Set  ℕ)  :=\n  trivial \n```", "```py\nexample  :  {  n  |  Nat.Prime  n  }  ∩  {  n  |  n  >  2  }  ⊆  {  n  |  ¬Even  n  }  :=  by\n  sorry \n```", "```py\n#print  Prime\n\n#print  Nat.Prime\n\nexample  (n  :  ℕ)  :  Prime  n  ↔  Nat.Prime  n  :=\n  Nat.prime_iff.symm\n\nexample  (n  :  ℕ)  (h  :  Prime  n)  :  Nat.Prime  n  :=  by\n  rw  [Nat.prime_iff]\n  exact  h \n```", "```py\nexample  (n  :  ℕ)  (h  :  Prime  n)  :  Nat.Prime  n  :=  by\n  rwa  [Nat.prime_iff] \n```", "```py\nvariable  (s  t  :  Set  ℕ)\n\nexample  (h₀  :  ∀  x  ∈  s,  ¬Even  x)  (h₁  :  ∀  x  ∈  s,  Prime  x)  :  ∀  x  ∈  s,  ¬Even  x  ∧  Prime  x  :=  by\n  intro  x  xs\n  constructor\n  ·  apply  h₀  x  xs\n  apply  h₁  x  xs\n\nexample  (h  :  ∃  x  ∈  s,  ¬Even  x  ∧  Prime  x)  :  ∃  x  ∈  s,  Prime  x  :=  by\n  rcases  h  with  ⟨x,  xs,  _,  prime_x⟩\n  use  x,  xs \n```", "```py\nsection\nvariable  (ssubt  :  s  ⊆  t)\n\nexample  (h₀  :  ∀  x  ∈  t,  ¬Even  x)  (h₁  :  ∀  x  ∈  t,  Prime  x)  :  ∀  x  ∈  s,  ¬Even  x  ∧  Prime  x  :=  by\n  sorry\n\nexample  (h  :  ∃  x  ∈  s,  ¬Even  x  ∧  Prime  x)  :  ∃  x  ∈  t,  Prime  x  :=  by\n  sorry\n\nend \n```", "```py\nvariable  {α  I  :  Type*}\nvariable  (A  B  :  I  →  Set  α)\nvariable  (s  :  Set  α)\n\nopen  Set\n\nexample  :  (s  ∩  ⋃  i,  A  i)  =  ⋃  i,  A  i  ∩  s  :=  by\n  ext  x\n  simp  only  [mem_inter_iff,  mem_iUnion]\n  constructor\n  ·  rintro  ⟨xs,  ⟨i,  xAi⟩⟩\n  exact  ⟨i,  xAi,  xs⟩\n  rintro  ⟨i,  xAi,  xs⟩\n  exact  ⟨xs,  ⟨i,  xAi⟩⟩\n\nexample  :  (⋂  i,  A  i  ∩  B  i)  =  (⋂  i,  A  i)  ∩  ⋂  i,  B  i  :=  by\n  ext  x\n  simp  only  [mem_inter_iff,  mem_iInter]\n  constructor\n  ·  intro  h\n  constructor\n  ·  intro  i\n  exact  (h  i).1\n  intro  i\n  exact  (h  i).2\n  rintro  ⟨h1,  h2⟩  i\n  constructor\n  ·  exact  h1  i\n  exact  h2  i \n```", "```py\nexample  :  (s  ∪  ⋂  i,  A  i)  =  ⋂  i,  A  i  ∪  s  :=  by\n  sorry \n```", "```py\ndef  primes  :  Set  ℕ  :=\n  {  x  |  Nat.Prime  x  }\n\nexample  :  (⋃  p  ∈  primes,  {  x  |  p  ^  2  ∣  x  })  =  {  x  |  ∃  p  ∈  primes,  p  ^  2  ∣  x  }  :=by\n  ext\n  rw  [mem_iUnion₂]\n  simp\n\nexample  :  (⋃  p  ∈  primes,  {  x  |  p  ^  2  ∣  x  })  =  {  x  |  ∃  p  ∈  primes,  p  ^  2  ∣  x  }  :=  by\n  ext\n  simp\n\nexample  :  (⋂  p  ∈  primes,  {  x  |  ¬p  ∣  x  })  ⊆  {  x  |  x  =  1  }  :=  by\n  intro  x\n  contrapose!\n  simp\n  apply  Nat.exists_prime_and_dvd \n```", "```py\nexample  :  (⋃  p  ∈  primes,  {  x  |  x  ≤  p  })  =  univ  :=  by\n  sorry \n```", "```py\nvariable  {α  :  Type*}  (s  :  Set  (Set  α))\n\nexample  :  ⋃₀  s  =  ⋃  t  ∈  s,  t  :=  by\n  ext  x\n  rw  [mem_iUnion₂]\n  simp\n\nexample  :  ⋂₀  s  =  ⋂  t  ∈  s,  t  :=  by\n  ext  x\n  rw  [mem_iInter₂]\n  rfl \n```", "```py\nvariable  {α  β  :  Type*}\nvariable  (f  :  α  →  β)\nvariable  (s  t  :  Set  α)\nvariable  (u  v  :  Set  β)\n\nopen  Function\nopen  Set\n\nexample  :  f  ⁻¹'  (u  ∩  v)  =  f  ⁻¹'  u  ∩  f  ⁻¹'  v  :=  by\n  ext\n  rfl \n```", "```py\nexample  :  f  ''  (s  ∪  t)  =  f  ''  s  ∪  f  ''  t  :=  by\n  ext  y;  constructor\n  ·  rintro  ⟨x,  xs  |  xt,  rfl⟩\n  ·  left\n  use  x,  xs\n  right\n  use  x,  xt\n  rintro  (⟨x,  xs,  rfl⟩  |  ⟨x,  xt,  rfl⟩)\n  ·  use  x,  Or.inl  xs\n  use  x,  Or.inr  xt \n```", "```py\nexample  :  s  ⊆  f  ⁻¹'  (f  ''  s)  :=  by\n  intro  x  xs\n  show  f  x  ∈  f  ''  s\n  use  x,  xs \n```", "```py\nexample  :  f  ''  s  ⊆  v  ↔  s  ⊆  f  ⁻¹'  v  :=  by\n  sorry \n```", "```py\nexample  (h  :  Injective  f)  :  f  ⁻¹'  (f  ''  s)  ⊆  s  :=  by\n  sorry\n\nexample  :  f  ''  (f  ⁻¹'  u)  ⊆  u  :=  by\n  sorry\n\nexample  (h  :  Surjective  f)  :  u  ⊆  f  ''  (f  ⁻¹'  u)  :=  by\n  sorry\n\nexample  (h  :  s  ⊆  t)  :  f  ''  s  ⊆  f  ''  t  :=  by\n  sorry\n\nexample  (h  :  u  ⊆  v)  :  f  ⁻¹'  u  ⊆  f  ⁻¹'  v  :=  by\n  sorry\n\nexample  :  f  ⁻¹'  (u  ∪  v)  =  f  ⁻¹'  u  ∪  f  ⁻¹'  v  :=  by\n  sorry\n\nexample  :  f  ''  (s  ∩  t)  ⊆  f  ''  s  ∩  f  ''  t  :=  by\n  sorry\n\nexample  (h  :  Injective  f)  :  f  ''  s  ∩  f  ''  t  ⊆  f  ''  (s  ∩  t)  :=  by\n  sorry\n\nexample  :  f  ''  s  \\  f  ''  t  ⊆  f  ''  (s  \\  t)  :=  by\n  sorry\n\nexample  :  f  ⁻¹'  u  \\  f  ⁻¹'  v  ⊆  f  ⁻¹'  (u  \\  v)  :=  by\n  sorry\n\nexample  :  f  ''  s  ∩  v  =  f  ''  (s  ∩  f  ⁻¹'  v)  :=  by\n  sorry\n\nexample  :  f  ''  (s  ∩  f  ⁻¹'  u)  ⊆  f  ''  s  ∩  u  :=  by\n  sorry\n\nexample  :  s  ∩  f  ⁻¹'  u  ⊆  f  ⁻¹'  (f  ''  s  ∩  u)  :=  by\n  sorry\n\nexample  :  s  ∪  f  ⁻¹'  u  ⊆  f  ⁻¹'  (f  ''  s  ∪  u)  :=  by\n  sorry \n```", "```py\nvariable  {I  :  Type*}  (A  :  I  →  Set  α)  (B  :  I  →  Set  β)\n\nexample  :  (f  ''  ⋃  i,  A  i)  =  ⋃  i,  f  ''  A  i  :=  by\n  sorry\n\nexample  :  (f  ''  ⋂  i,  A  i)  ⊆  ⋂  i,  f  ''  A  i  :=  by\n  sorry\n\nexample  (i  :  I)  (injf  :  Injective  f)  :  (⋂  i,  f  ''  A  i)  ⊆  f  ''  ⋂  i,  A  i  :=  by\n  sorry\n\nexample  :  (f  ⁻¹'  ⋃  i,  B  i)  =  ⋃  i,  f  ⁻¹'  B  i  :=  by\n  sorry\n\nexample  :  (f  ⁻¹'  ⋂  i,  B  i)  =  ⋂  i,  f  ⁻¹'  B  i  :=  by\n  sorry \n```", "```py\nexample  :  InjOn  f  s  ↔  ∀  x₁  ∈  s,  ∀  x₂  ∈  s,  f  x₁  =  f  x₂  →  x₁  =  x₂  :=\n  Iff.refl  _ \n```", "```py\nopen  Set  Real\n\nexample  :  InjOn  log  {  x  |  x  >  0  }  :=  by\n  intro  x  xpos  y  ypos\n  intro  e\n  -- log x = log y\n  calc\n  x  =  exp  (log  x)  :=  by  rw  [exp_log  xpos]\n  _  =  exp  (log  y)  :=  by  rw  [e]\n  _  =  y  :=  by  rw  [exp_log  ypos]\n\nexample  :  range  exp  =  {  y  |  y  >  0  }  :=  by\n  ext  y;  constructor\n  ·  rintro  ⟨x,  rfl⟩\n  apply  exp_pos\n  intro  ypos\n  use  log  y\n  rw  [exp_log  ypos] \n```", "```py\nexample  :  InjOn  sqrt  {  x  |  x  ≥  0  }  :=  by\n  sorry\n\nexample  :  InjOn  (fun  x  ↦  x  ^  2)  {  x  :  ℝ  |  x  ≥  0  }  :=  by\n  sorry\n\nexample  :  sqrt  ''  {  x  |  x  ≥  0  }  =  {  y  |  y  ≥  0  }  :=  by\n  sorry\n\nexample  :  (range  fun  x  ↦  x  ^  2)  =  {  y  :  ℝ  |  y  ≥  0  }  :=  by\n  sorry \n```", "```py\nvariable  {α  β  :  Type*}  [Inhabited  α]\n\n#check  (default  :  α)\n\nvariable  (P  :  α  →  Prop)  (h  :  ∃  x,  P  x)\n\n#check  Classical.choose  h\n\nexample  :  P  (Classical.choose  h)  :=\n  Classical.choose_spec  h \n```", "```py\nnoncomputable  section\n\nopen  Classical\n\ndef  inverse  (f  :  α  →  β)  :  β  →  α  :=  fun  y  :  β  ↦\n  if  h  :  ∃  x,  f  x  =  y  then  Classical.choose  h  else  default\n\ntheorem  inverse_spec  {f  :  α  →  β}  (y  :  β)  (h  :  ∃  x,  f  x  =  y)  :  f  (inverse  f  y)  =  y  :=  by\n  rw  [inverse,  dif_pos  h]\n  exact  Classical.choose_spec  h \n```", "```py\nvariable  (f  :  α  →  β)\n\nopen  Function\n\nexample  :  Injective  f  ↔  LeftInverse  (inverse  f)  f  :=\n  sorry\n\nexample  :  Surjective  f  ↔  RightInverse  (inverse  f)  f  :=\n  sorry \n```", "```py\ntheorem  Cantor  :  ∀  f  :  α  →  Set  α,  ¬Surjective  f  :=  by\n  intro  f  surjf\n  let  S  :=  {  i  |  i  ∉  f  i  }\n  rcases  surjf  S  with  ⟨j,  h⟩\n  have  h₁  :  j  ∉  f  j  :=  by\n  intro  h'\n  have  :  j  ∉  f  j  :=  by  rwa  [h]  at  h'\n  contradiction\n  have  h₂  :  j  ∈  S\n  sorry\n  have  h₃  :  j  ∉  S\n  sorry\n  contradiction \n```", "```py\nnoncomputable  section\nopen  Classical\nvariable  {α  β  :  Type*}  [Nonempty  β] \n```", "```py\n#check  (invFun  g  :  α  →  β)\n#check  (leftInverse_invFun  :  Injective  g  →  LeftInverse  (invFun  g)  g)\n#check  (leftInverse_invFun  :  Injective  g  →  ∀  y,  invFun  g  (g  y)  =  y)\n#check  (invFun_eq  :  (∃  y,  g  y  =  x)  →  g  (invFun  g  x)  =  x) \n```", "```py\nvariable  (f  :  α  →  β)  (g  :  β  →  α)\n\ndef  sbAux  :  ℕ  →  Set  α\n  |  0  =>  univ  \\  g  ''  univ\n  |  n  +  1  =>  g  ''  (f  ''  sbAux  n)\n\ndef  sbSet  :=\n  ⋃  n,  sbAux  f  g  n \n```", "```py\ndef  sbFun  (x  :  α)  :  β  :=\n  if  x  ∈  sbSet  f  g  then  f  x  else  invFun  g  x \n```", "```py\ntheorem  sb_right_inv  {x  :  α}  (hx  :  x  ∉  sbSet  f  g)  :  g  (invFun  g  x)  =  x  :=  by\n  have  :  x  ∈  g  ''  univ  :=  by\n  contrapose!  hx\n  rw  [sbSet,  mem_iUnion]\n  use  0\n  rw  [sbAux,  mem_diff]\n  sorry\n  have  :  ∃  y,  g  y  =  x  :=  by\n  sorry\n  sorry \n```", "```py\ntheorem  sb_injective  (hf  :  Injective  f)  :  Injective  (sbFun  f  g)  :=  by\n  set  A  :=  sbSet  f  g  with  A_def\n  set  h  :=  sbFun  f  g  with  h_def\n  intro  x₁  x₂\n  intro  (hxeq  :  h  x₁  =  h  x₂)\n  show  x₁  =  x₂\n  simp  only  [h_def,  sbFun,  ←  A_def]  at  hxeq\n  by_cases  xA  :  x₁  ∈  A  ∨  x₂  ∈  A\n  ·  wlog  x₁A  :  x₁  ∈  A  generalizing  x₁  x₂  hxeq  xA\n  ·  symm\n  apply  this  hxeq.symm  xA.symm  (xA.resolve_left  x₁A)\n  have  x₂A  :  x₂  ∈  A  :=  by\n  apply  _root_.not_imp_self.mp\n  intro  (x₂nA  :  x₂  ∉  A)\n  rw  [if_pos  x₁A,  if_neg  x₂nA]  at  hxeq\n  rw  [A_def,  sbSet,  mem_iUnion]  at  x₁A\n  have  x₂eq  :  x₂  =  g  (f  x₁)  :=  by\n  sorry\n  rcases  x₁A  with  ⟨n,  hn⟩\n  rw  [A_def,  sbSet,  mem_iUnion]\n  use  n  +  1\n  simp  [sbAux]\n  exact  ⟨x₁,  hn,  x₂eq.symm⟩\n  sorry\n  push_neg  at  xA\n  sorry \n```", "```py\ntheorem  sb_surjective  (hg  :  Injective  g)  :  Surjective  (sbFun  f  g)  :=  by\n  set  A  :=  sbSet  f  g  with  A_def\n  set  h  :=  sbFun  f  g  with  h_def\n  intro  y\n  by_cases  gyA  :  g  y  ∈  A\n  ·  rw  [A_def,  sbSet,  mem_iUnion]  at  gyA\n  rcases  gyA  with  ⟨n,  hn⟩\n  rcases  n  with  _  |  n\n  ·  simp  [sbAux]  at  hn\n  simp  [sbAux]  at  hn\n  rcases  hn  with  ⟨x,  xmem,  hx⟩\n  use  x\n  have  :  x  ∈  A  :=  by\n  rw  [A_def,  sbSet,  mem_iUnion]\n  exact  ⟨n,  xmem⟩\n  rw  [h_def,  sbFun,  if_pos  this]\n  apply  hg  hx\n\n  sorry \n```", "```py\ntheorem  schroeder_bernstein  {f  :  α  →  β}  {g  :  β  →  α}  (hf  :  Injective  f)  (hg  :  Injective  g)  :\n  ∃  h  :  α  →  β,  Bijective  h  :=\n  ⟨sbFun  f  g,  sb_injective  f  g  hf,  sb_surjective  f  g  hg⟩ \n```"]