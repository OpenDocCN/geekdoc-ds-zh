- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: INTRODUCTION TO PYTHON
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python简介**'
- en: Though each programming language is different (though not as different as their
    designers would have us believe), they can be related along some dimensions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每种编程语言都是不同的（虽然没有设计者们所认为的那样不同），但它们可以在某些维度上关联。
- en: '**Low-level versus high-level** refers to whether we program using instructions
    and data objects at the level of the machine (e.g., move 64 bits of data from
    this location to that location) or whether we program using more abstract operations
    (e.g., pop up a menu on the screen) that have been provided by the language designer.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低级与高级**指的是我们是否使用机器级别的指令和数据对象进行编程（例如，将64位数据从这个位置移动到那个位置），或者我们是否使用语言设计者提供的更抽象的操作（例如，在屏幕上弹出菜单）进行编程。'
- en: '**General versus targeted to an application domain** refers to whether the
    primitive operations of the programming language are widely applicable or are
    fine-tuned to a domain. For example, SQL is designed for extracting information
    from relational databases, but you wouldn''t want to use it build an operating
    system.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用与特定于应用领域**指的是编程语言的原始操作是广泛适用还是针对某一领域进行细化。例如，SQL旨在从关系数据库中提取信息，但你不希望用它来构建操作系统。'
- en: '**Interpreted versus compiled** refers to whether the sequence of instructions
    written by the programmer, called **source code**, is executed directly (by an
    interpreter) or whether it is first converted (by a compiler) into a sequence
    of machine-level primitive operations. (In the early days of computers, people
    had to write source code in a language close to the **machine code** that could
    be directly interpreted by the computer hardware.) There are advantages to both
    approaches. It is often easier to debug programs written in languages that are
    designed to be interpreted, because the interpreter can produce error messages
    that are easy to relate to the source code. Compiled languages usually produce
    programs that run more quickly and use less space.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解释执行与编译执行**指的是程序员编写的指令序列（称为**源代码**）是否被直接执行（通过解释器），或者是否首先被转换（通过编译器）为一系列机器级原始操作。（在计算机的早期，人们必须用接近**机器代码**的语言编写源代码，以便计算机硬件可以直接解释。）这两种方法各有优劣。通常，调试那些设计为解释执行的语言编写的程序更容易，因为解释器能够产生易于与源代码关联的错误信息。编译语言通常生成运行更快且占用更少空间的程序。'
- en: In this book, we use **Python**. However, this book is not about Python. It
    will certainly help you learn Python, and that's a good thing. What is much more
    important, however, is that you will learn something about how to write programs
    that solve problems. You can transfer this skill to any programming language.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用**Python**。然而，这本书并不是关于Python的。它当然会帮助你学习Python，这很好。然而，更重要的是，你将学习如何编写解决问题的程序。你可以将这种技能转移到任何编程语言上。
- en: Python is a general-purpose programming language you can use effectively to
    build almost any kind of program that does not need direct access to the computer's
    hardware. Python is not optimal for programs that have high reliability constraints
    (because of its weak static semantic checking) or that are built and maintained
    by many people or over a long period of time (again because of the weak static
    semantic checking).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种通用编程语言，你可以有效地使用它构建几乎任何不需要直接访问计算机硬件的程序。对于具有高可靠性约束的程序（由于其弱静态语义检查）或由多人或在长时间内构建和维护的程序（同样因为弱静态语义检查），Python并不是最佳选择。
- en: Python does have several advantages over many other languages. It is a relatively
    simple language that is easy to learn. Because Python is designed to be interpreted,
    it can provide the kind of runtime feedback that is especially helpful to novice
    programmers. A large and growing number of freely available libraries interface
    to Python and provide useful extended functionality. We use several of these libraries
    in this book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python确实比许多其他语言具有多个优势。它是一种相对简单、易于学习的语言。由于Python被设计为解释执行，它能提供对初学者程序员特别有帮助的运行时反馈。大量不断增长的可自由获取的库与Python接口，提供了有用的扩展功能。本书中使用了其中的多个库。
- en: We are ready to introduce some of the basic elements of Python. These are common
    to almost all programming languages in concept, though not in detail.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备介绍一些Python的基本元素。这些在概念上几乎所有编程语言都是共同的，尽管在细节上有所不同。
- en: This book is not just an introduction to Python. It uses Python as a vehicle
    to present concepts related to computational problem solving and thinking. The
    language is presented in dribs and drabs, as needed for this ulterior purpose.
    Python features that we don't need for that purpose are not presented at all.
    We feel comfortable about not covering every detail because excellent online resources
    describe every aspect of the language. We suggest that you use these free online
    resources as needed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不仅仅是Python的介绍。它使用Python作为工具来呈现与计算问题解决和思维相关的概念。语言的呈现是按需逐步进行的。我们不需要的Python特性则完全不予展示。我们对没有涵盖每个细节感到放心，因为优秀的在线资源描述了语言的每一个方面。我们建议根据需要使用这些免费的在线资源。
- en: Python is a living language. Since its introduction by Guido von Rossum in 1990,
    it has undergone many changes. For the first decade of its life, Python was a
    little known and little used language. That changed with the arrival of Python
    2.0 in 2000\. In addition to incorporating important improvements to the language
    itself, it marked a shift in the evolutionary path of the language. Many groups
    began developing libraries that interfaced seamlessly with Python, and continuing
    support and development of the Python ecosystem became a community-based activity.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种活语言。自1990年由Guido van Rossum引入以来，它经历了许多变化。在其生命的头十年，Python是一种鲜为人知且使用不多的语言。2000年Python
    2.0的到来改变了这一现状。除了对语言本身的重要改进外，它还标志着语言演变路径的转变。许多团体开始开发与Python无缝接口的库，Python生态系统的持续支持和开发成为了一项社区活动。
- en: Python 3.0 was released at the end of 2008\. This version of Python cleaned
    up many of the inconsistencies in the design of Python 2\. However, Python 3 is
    not backward compatible. This means that most programs and libraries written for
    earlier versions of Python cannot be run using implementations of Python 3\.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.0于2008年底发布。这个版本的Python清理了Python 2设计中的许多不一致性。然而，Python 3不向后兼容。这意味着为早期版本的Python编写的大多数程序和库无法使用Python
    3的实现运行。
- en: By now, all of the important public domain Python libraries have been ported
    to Python 3\. Today, there is no reason to use Python 2.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在，所有重要的公共领域Python库都已移植到Python 3。今天，没有理由使用Python 2。
- en: 2.1 Installing Python and Python IDEs
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 安装Python和Python IDE
- en: Once upon time, programmers used general-purpose text editors to enter their
    programs. Today, most programmers prefer to use a text editor that is part of
    an **integrated development environment** (**IDE**).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 曾几何时，程序员使用通用文本编辑器输入他们的程序。如今，大多数程序员更喜欢使用**集成开发环境**（**IDE**）中的文本编辑器。
- en: The first Python IDE, IDLE,[⁹](#c2-fn-0001) came as part of the standard Python
    installation package. As Python has grown in popularity, other IDEs have sprung
    up. These newer IDEs often incorporate some of the more popular Python libraries
    and provide facilities not provided by IDLE. **Anaconda** and Canopy are among
    the more popular of these IDEs. The code appearing in this book was created and
    tested using Anaconda.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个Python IDE，IDLE，作为标准Python安装包的一部分而出现。随着Python的普及，其他IDE应运而生。这些较新的IDE通常集成了一些更流行的Python库，并提供IDLE未提供的功能。**Anaconda**和Canopy是这些IDE中更受欢迎的选择。本书中的代码是在Anaconda中创建和测试的。
- en: IDEs are applications, just like any other application on your computer. Start
    one the same way you would start any other application, e.g., by double-clicking
    on an icon. All of the Python IDEs provide
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: IDE是应用程序，就像计算机上的任何其他应用程序一样。启动一个IDE的方式与启动其他应用程序相同，例如，通过双击图标。
- en: A text editor with syntax highlighting, auto completion, and smart indentation,
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供具有语法高亮、自动补全和智能缩进的文本编辑器，
- en: A shell with syntax highlighting, and
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有语法高亮的命令行，
- en: An integrated debugger, which you can safely ignore for now.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个集成调试器，目前可以安全地忽略它。
- en: This would be a good time to install Anaconda (or some other IDE) on your computer,
    so that you can run the examples in the book, and, more importantly, attempt the
    programming finger exercises. To install Anaconda, go to
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是安装Anaconda（或其他IDE）的好时机，以便你可以运行书中的示例，更重要的是，尝试编程练习。要安装Anaconda，请访问
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: and follow the instructions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 并遵循说明。
- en: Once the installation is complete, start the application `Anaconda-Navigator`.
    A window containing a collection of Python tools will appear. The window will
    look something like [Figure 2-1](#c2-fig-0001).[^(10)](#c2-fn-0002) For now, the
    only tool we will use is `**Spyder**`. When you launch Spyder (by clicking on
    its `Launch` button, of all things), a window similar to [Figure 2-2](#c2-fig-0002)
    will open.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，启动应用程序`Anaconda-Navigator`。将出现一个包含 Python 工具集合的窗口。该窗口看起来类似于[图 2-1](#c2-fig-0001)。目前，我们唯一要使用的工具是`**Spyder**`。当你启动
    Spyder（通过点击它的`Launch`按钮）时，将打开一个类似于[图 2-2](#c2-fig-0002)的窗口。
- en: '![c2-fig-0001.jpg](../images/c2-fig-0001.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0001.jpg](../images/c2-fig-0001.jpg)'
- en: '[Figure 2-1](#c2-fig-0001a) Anaconda startup window'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](#c2-fig-0001a) Anaconda 启动窗口'
- en: '![c2-fig-0002.jpg](../images/c2-fig-0002.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0002.jpg](../images/c2-fig-0002.jpg)'
- en: '[Figure 2-2](#c2-fig-0002a) Spyder window'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-2](#c2-fig-0002a) Spyder 窗口'
- en: The pane on the lower right of [Figure 2-2](#c2-fig-0002) is an **IPython console**
    running an interactive Python **shell**. You can type and execute Python commands
    in this window. The pane on the upper right is a help window. It is often convenient
    to close that window (by clicking on the `x`), so that more real estate is available
    for the IPython console. The pane on the left is an edit window into which you
    can type programs that can be saved and run. The toolbar at the top of the window
    makes it easy to perform various tasks such as opening files and printing programs.[^(11)](#c2-fn-0003)
    Documentation for `Spyder` can be found at [https://www.spyder-ide.org/](https://www.spyder-ide.org/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-2](#c2-fig-0002)右下角的窗格是一个运行交互式 Python **shell** 的 **IPython 控制台**。你可以在这个窗口中输入并执行
    Python 命令。右上角的窗格是一个帮助窗口。通常，关闭该窗口（通过点击 `x`）会更方便，这样可以为 IPython 控制台提供更多空间。左侧的窗格是一个编辑窗口，你可以在其中输入可以保存和运行的程序。窗口顶部的工具栏使打开文件和打印程序等各种任务变得容易。[^(11)](#c2-fn-0003)
    `Spyder` 的文档可以在 [https://www.spyder-ide.org/](https://www.spyder-ide.org/) 找到。'
- en: 2.2  The Basic Elements of Python
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2  Python 的基本元素
- en: A Python **program**, sometimes called a **script**, is a sequence of definitions
    and commands. The Python interpreter in the shell evaluates the definitions and
    executes the commands.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python **程序**有时称为 **脚本**，是一系列定义和命令的序列。Shell 中的 Python 解释器评估定义并执行命令。
- en: We recommend that you start a Python shell (e.g., by starting `Spyder`) now,
    and use it to try the examples contained in the rest of this chapter. And, for
    that matter, in the rest of the book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你现在启动一个 Python shell（例如，通过启动`Spyder`），并使用它尝试本章其余部分中的示例。事实上，在本书的其余部分中也可以这样做。
- en: A **command**, often called a **statement**, instructs the interpreter to do
    something. For example, the statement `print('Yankees rule!')` instructs the interpreter
    to call the function[^(12)](#c2-fn-0004) `print`, which outputs the string `Yankees
    rule!` to the window associated with the shell.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令**，通常称为 **语句**，指示解释器执行某项操作。例如，语句 `print(''Yankees rule!'')` 指示解释器调用函数[^(12)](#c2-fn-0004)
    `print`，该函数将字符串 `Yankees rule!` 输出到与 shell 关联的窗口。'
- en: The sequence of commands
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的序列
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: causes the interpreter to produce the output
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 导致解释器产生输出
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that two values were passed to `print` in the third statement. The `print`
    function takes a variable number of arguments separated by commas and prints them,
    separated by a space character, in the order in which they appear.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第三条语句中传递了两个值给 `print`。`print` 函数接受由逗号分隔的可变数量的参数，并按出现顺序以空格字符分隔输出。
- en: 2.2.1 Objects, Expressions, and Numerical Types
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 对象、表达式和数值类型
- en: '**Objects** are the core things that Python programs manipulate. Each object
    has a **type** that defines what programs can do with that object.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象**是 Python 程序操作的核心事物。每个对象都有一个 **类型**，定义了程序可以对该对象执行的操作。'
- en: Types are either scalar or non-scalar. **Scalar** objects are indivisible. Think
    of them as the atoms of the language.[^(13)](#c2-fn-0005) **Non-scalar** objects,
    for example strings, have internal structure.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类型分为标量和非标量。**标量**对象是不可分割的。可以将它们视为语言的原子。[^(13)](#c2-fn-0005) **非标量**对象，例如字符串，具有内部结构。
- en: Many types of objects can be denoted by **literals** in the text of a program.
    For example, the text `2` is a literal representing a number and the text `'abc'`
    is a literal representing a string.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 许多类型的对象可以通过程序文本中的 **字面量** 来表示。例如，文本 `2` 是表示数字的字面量，而文本 `'abc'` 是表示字符串的字面量。
- en: 'Python has four types of scalar objects:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有四种类型的标量对象：
- en: '`**int**` is used to represent integers. Literals of type `int` are written
    in the way we typically denote integers (e.g., `-3` or `5` or `10002)`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**int**` 用于表示整数。类型为 `int` 的字面量是以我们通常表示整数的方式书写的（例如，`-3` 或 `5` 或 `10002`）。'
- en: '`**float**` is used to represent real numbers. Literals of type `float` always
    include a decimal point (e.g., `3.0` or `3.17` or `-28.72)`. (It is also possible
    to write literals of type `float` using scientific notation. For example, the
    literal `1.6E3` stands for 1.6*10³, i.e., it is the same as 1600.0.) You might
    wonder why this type is not called `real`. Within the computer, values of type
    `float` are stored as **floating-point numbers**. This representation, which is
    used by all modern programming languages, has many advantages. However, under
    some situations it causes floating-point arithmetic to behave in ways that are
    slightly different from arithmetic on real numbers. We discuss this in Section
    3.3.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**float**` 用于表示实数。类型为 `float` 的字面量总是包含小数点（例如，`3.0` 或 `3.17` 或 `-28.72`）。 （也可以使用科学记数法来书写类型为
    `float` 的字面量。例如，字面量 `1.6E3` 代表 1.6*10³，即它与 1600.0 相同。）你可能会想知道为什么这个类型不叫 `real`。在计算机内部，类型为
    `float` 的值以 **浮点数** 的形式存储。这种表示法被所有现代编程语言采用，具有许多优点。然而，在某些情况下，它会导致浮点运算的行为与实数运算略有不同。我们将在第
    3.3 节中讨论这个问题。'
- en: '`**bool**` is used to represent the Boolean values `True` and `False`.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**bool**` 用于表示布尔值 `True` 和 `False`。'
- en: '`**None**` is a type with a single value. We will say more about `None` in
    Section 4.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**None**` 是一种只有一个值的类型。我们将在第 4 节中详细讨论 `None`。'
- en: Objects and **operators** can be combined to form **expressions**, each of which
    evaluates to an object of some type. This is called the **value** of the expression.
    For example, the expression `3 + 2` denotes the object `5` of type `int`, and
    the expression `3.0 + 2.0` denotes the object `5.0` of type `float`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对象和 **运算符** 可以组合形成 **表达式**，每个表达式的值为某种类型的对象。这称为表达式的 **值**。例如，表达式 `3 + 2` 表示类型为
    `int` 的对象 `5`，而表达式 `3.0 + 2.0` 表示类型为 `float` 的对象 `5.0`。
- en: The `==` operator is used to test whether two expressions evaluate to the same
    value, and the `!=` operator is used to test whether two expressions evaluate
    to different values. A single `=` means something quite different, as we will
    see in Section 2.2.2\. Be forewarned—you will make the mistake of typing “`=`”
    when you meant to type “`==`”. Keep an eye out for this error.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`==` 运算符用于测试两个表达式是否评估为相同的值，而 `!=` 运算符用于测试两个表达式是否评估为不同的值。单个 `=` 意味着完全不同的东西，正如我们将在第
    2.2.2 节中看到的。请提前警告——你会犯下将“`=`”输入成“`==`”的错误。注意这个错误。'
- en: "In a Spyder console, something that looks like \uFEFF`In [1]:` is a **shell\
    \ prompt** indicating that the interpreter is expecting the user to type some\
    \ Python code into the shell. The line below the prompt is produced when the interpreter\
    \ evaluates the Python code entered at the prompt, as illustrated by the following\
    \ interaction with the interpreter:"
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spyder 控制台中，类似于 `In [1]:` 的内容是 **shell 提示符**，表明解释器正在等待用户输入一些 Python 代码。提示符下方的行是在解释器评估用户输入的
    Python 代码时产生的，下面是与解释器的一个交互示例：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The built-in Python function `type` can be used to find out the type of an
    object:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 Python 函数 `type` 可用于查找对象的类型：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Operators on objects of type `int` and `float` are listed in [Figure 2-3](#c2-fig-0003).
    The arithmetic operators have the usual precedence. For example, `*` binds more
    tightly than `+`, so the expression `x+y*2` is evaluated by first multiplying
    `y` by `2` and then adding the result to `x.` The order of evaluation can be changed
    by using parentheses to group subexpressions, e.g., `(x+y)*2` first adds `x` and
    `y`, and then multiplies the result by `2`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 `int` 和 `float` 的对象的运算符列在 [图 2-3](#c2-fig-0003) 中。算术运算符具有通常的优先级。例如，`*` 的优先级高于
    `+`，因此表达式 `x+y*2` 会先计算 `y` 乘以 `2`，然后再将结果加到 `x` 上。可以通过使用括号来改变评估顺序，例如 `(x+y)*2`
    会先将 `x` 和 `y` 相加，然后再将结果乘以 `2`。
- en: '![c2-fig-0003.jpg](../images/c2-fig-0003.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0003.jpg](../images/c2-fig-0003.jpg)'
- en: '[Figure 2-3](#c2-fig-0003a) Operators on types `int` and `float`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](#c2-fig-0003a) 类型 `int` 和 `float` 的运算符'
- en: 'The primitive operators on type `bool` are `and`, `or`, and `not`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `bool` 的基本运算符是 `and`、`or` 和 `not`：
- en: '`**a and b**` is `True` if both `a` and `b` are `True`, and `False` otherwise.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**a 和 b**` 为 `True` 当且仅当 `a` 和 `b` 都为 `True`，否则为 `False`。'
- en: '`**a or b**` is `True` if at least one of `a` or `b` is `True`, and `False`
    otherwise.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**a 或 b**` 为 `True` 当至少一个 `a` 或 `b` 为 `True`，否则为 `False`。'
- en: '`**not a**` is `True` if `a` is `False`, and `False` if `a` is `True`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**not a**` 在`a`为`False`时为`True`，而在`a`为`True`时为`False`。'
- en: 2.2.2 Variables and Assignment
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 变量与赋值
- en: '**Variables** provide a way to associate names with objects. Consider the code'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**提供了一种将名称与对象关联的方法。考虑以下代码'
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code first **binds** the names `pi` and `radius` to different objects of
    type `int`.[^(14)](#c2-fn-0006) It then binds the name `area` to a third object
    of type `int`. This is depicted on the left side of [Figure 2-4](#c2-fig-0004).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先**绑定**了名称`pi`和`radius`到不同的`int`类型对象上。[^(14)](#c2-fn-0006) 然后将名称`area`绑定到第三个`int`类型的对象。这在[图2-4](#c2-fig-0004)的左侧进行了描述。
- en: '![c2-fig-0004.jpg](../images/c2-fig-0004.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0004.jpg](../images/c2-fig-0004.jpg)'
- en: '[Figure 2-4](#c2-fig-0004a) Binding of variables to objects'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-4](#c2-fig-0004a) 变量与对象的绑定'
- en: If the program then executes `radius = 14`, the name `radius` is rebound to
    a different object of type `int`, as shown on the right side of [Figure 2-4](#c2-fig-0004).
    Note that this assignment has no effect on the value to which `area` is bound.
    It is still bound to the object denoted by the expression `3*(11**2)`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序接着执行`radius = 14`，那么名称`radius`将重新绑定到不同的`int`类型对象上，如[图2-4](#c2-fig-0004)右侧所示。请注意，这个赋值对`area`绑定的值没有影响。它仍然绑定于表达式`3*(11**2)`所表示的对象。
- en: 'In Python, *a variable is just a name***,** nothing more. Remember this—it
    is important. An **assignment** statement associates the name to the left of the
    `=` symbol with the object denoted by the expression to the right of the `=` symbol.
    Remember this too: an object can have one, more than one, or no name associated
    with it.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，*变量仅仅是一个名称*，**没有更多的意义**。记住这一点——这很重要。一个**赋值**语句将`=`符号左侧的名称与`=`符号右侧表达式所表示的对象关联起来。也请记住：一个对象可以有一个、多个或没有与之关联的名称。
- en: Perhaps we shouldn't have said, “a variable is *just* a name.” Despite what
    Juliet said,[^(15)](#c2-fn-0007) names matter. Programming languages let us describe
    computations so that computers can execute them. This does not mean that only
    computers read programs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们不应该说，“变量*仅仅*是一个名称。”尽管朱丽叶这么说过，[^(15)](#c2-fn-0007) 名称是重要的。编程语言让我们描述计算，以便计算机可以执行它们。这并不意味着只有计算机在阅读程序。
- en: As you will soon discover, it's not always easy to write programs that work
    correctly. Experienced programmers will confirm that they spend a great deal of
    time reading programs in an attempt to understand why they behave as they do.
    It is therefore of critical importance to write programs so that they are easy
    to read. Apt choice of variable names plays an important role in enhancing readability.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你很快会发现的，编写正确工作的程序并不总是容易。经验丰富的程序员会确认，他们花费了大量时间阅读程序，以尝试理解它们为何以这样的方式运行。因此，编写易于阅读的程序是至关重要的。恰当选择变量名称在增强可读性方面起着重要作用。
- en: Consider the two code fragments
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这两个代码片段
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As far as Python is concerned, the code fragments are not different. When executed,
    they will do the same thing. To a human reader, however, they are quite different.
    When we read the fragment on the left, there is no *a priori* reason to suspect
    that anything is amiss. However, a quick glance at the code on the right should
    prompt us to suspect that something is wrong. Either the variable should have
    been named `radius` rather than `diameter`, or `diameter` should have been divided
    by `2.0` in the calculation of the area.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就Python而言，这些代码片段没有区别。当执行时，它们将执行相同的操作。然而，对于人类读者来说，它们却截然不同。当我们阅读左侧的片段时，没有*先验*的理由怀疑有什么问题。然而，快速看一下右侧的代码应该会让我们怀疑某些地方不对。要么变量应该命名为`radius`而不是`diameter`，要么在计算面积时应该将`diameter`除以`2.0`。
- en: In Python, variable names can contain uppercase and lowercase letters, digits
    (though they cannot start with a digit), and the special character `_` (underscore).
    Python variable names are case-sensitive e.g., `Romeo` and `romeo` are different
    names. Finally, a few **reserved words** (sometimes called **keywords**) in Python
    that have built-in meanings and cannot be used as variable names. Different versions
    of Python have slightly different lists of reserved words. The reserved words
    in Python 3.8 are
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，变量名可以包含大写和小写字母、数字（虽然不能以数字开头）以及特殊字符`_`（下划线）。Python的变量名区分大小写，例如，`Romeo`和`romeo`是不同的名称。最后，Python中有一些**保留字**（有时称为**关键字**），这些字有内置的意义，不能用作变量名。不同版本的Python有略微不同的保留字列表。Python
    3.8中的保留字包括：
- en: '| `and` | `break` | `elif` | `for` | `in` | `not` | `True` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `and` | `break` | `elif` | `for` | `in` | `not` | `True` |'
- en: '| `as` | `class` | `else` | `from` | `is` | `or` | `try` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `as` | `class` | `else` | `from` | `is` | `or` | `try` |'
- en: '| `assert` | `continue` | `except` | `global` | `lambda` | `pass` | `while`
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `assert` | `continue` | `except` | `global` | `lambda` | `pass` | `while`
    |'
- en: '| `async` | `def` | `False` | `if` | `nonlocal` | `raise` | `with` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `async` | `def` | `False` | `if` | `nonlocal` | `raise` | `with` |'
- en: '| `await` | `del` | `finally` | `import` | `None` | `return` | `yiel` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `await` | `del` | `finally` | `import` | `None` | `return` | `yield` |'
- en: Another good way to enhance the readability of code is to add **comments**.
    Text following the symbol `#` is not interpreted by Python. For example, we might
    write
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 提高代码可读性的另一个好方法是添加 **注释**。符号 `#` 后面的文本不会被 Python 解释。例如，我们可能会写
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Python allows multiple assignment. The statement
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许多重赋值。语句
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: binds `x` to `2` and `y` to `3`. All of the expressions on the right-hand side
    of the assignment are evaluated before any bindings are changed. This is convenient
    since it allows you to use multiple assignment to swap the bindings of two variables.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `x` 绑定到 `2`，将 `y` 绑定到 `3`。赋值右侧的所有表达式在任何绑定改变之前都会被评估。这很方便，因为它允许你使用多重赋值来交换两个变量的绑定。
- en: For example, the code
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，代码
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: will print
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将打印
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 2.3 Branching Programs
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 分支程序
- en: The kinds of computations we have been looking at so far are called **straight-line
    programs**. They execute one statement after another in the order in which they
    appear and stop when they run out of statements. The kinds of computations we
    can describe with straight-line programs are not very interesting. In fact, they
    are downright boring.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们正在查看的计算类型称为 **直线程序**。它们按照出现的顺序一个接一个地执行语句，并在用尽语句时停止。我们可以用直线程序描述的计算类型并不是很有趣。事实上，它们实在是太无聊了。
- en: '**Branching** programs are more interesting. The simplest branching statement
    is a **conditional**. As shown in the box in [Figure 2-5, a](#c2-fig-0005) conditional
    statement has three parts:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**分支**程序更有趣。最简单的分支语句是 **条件**。如[图2-5](#c2-fig-0005)所示，条件语句有三个部分：'
- en: A test, i.e., an expression that evaluates to either `True` or `False`
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个测试，即评估为 `True` 或 `False` 的表达式
- en: A block of code that is executed if the test evaluates to `True`
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果测试评估为 `True`，则执行的代码块
- en: An optional block of code that is executed if the test evaluates to `False`
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果测试评估为 `False`，则执行的可选代码块
- en: After a conditional statement is executed, execution resumes at the code following
    the statement.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在条件语句执行后，执行将继续在语句后的代码处。
- en: '![c2-fig-0005.jpg](../images/c2-fig-0005.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![c2-fig-0005.jpg](../images/c2-fig-0005.jpg)'
- en: '[Figure 2-5](#c2-fig-0005a) Flowchart for conditional statement'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-5](#c2-fig-0005a) 条件语句的流程图'
- en: In Python, a conditional statement has the form
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，条件语句的形式是
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In describing the form of Python statements, we use italics to identify the
    kinds of code that could occur at that point in a program. For example, *Boolean
    expression*indicates that any expression that evaluates to `True` or `False` can
    follow the reserved word `if`, and *block of code* indicates that any sequence
    of Python statements can follow `else:`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述 Python 语句的形式时，我们使用斜体来标识在程序的某一点可能出现的代码类型。例如，*布尔表达式*表示任何评估为 `True` 或 `False`
    的表达式可以跟在保留字 `if` 后，而 *代码块* 表示任何 Python 语句序列可以跟在 `else:` 后。
- en: 'Consider the following program that prints “Even” if the value of the variable
    `x` is even and “Odd” otherwise:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下程序，如果变量 `x` 的值为偶数，则打印“Even”，否则打印“Odd”：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The expression `x%2 == 0` evaluates to `True` when the remainder of `x` divided
    by `2` is `0`, and `False` otherwise. Remember that `==` is used for comparison,
    since `=` is reserved for assignment.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `x` 除以 `2` 的余数为 `0` 时，表达式 `x%2 == 0` 评估为 `True`，否则为 `False`。请记住，`==` 用于比较，而
    `=` 是用于赋值的。
- en: '**Indentation** is semantically meaningful in Python. For example, if the last
    statement in the above code were indented, it would be part of the block of code
    associated with the `else`, rather than the block of code following the conditional
    statement.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**缩进** 在 Python 中具有语义意义。例如，如果上述代码中的最后一条语句被缩进，它将属于与 `else` 相关的代码块，而不是条件语句后的代码块。'
- en: Python is unusual in using indentation this way. Most other programming languages
    use bracketing symbols to delineate blocks of code, e.g., C encloses blocks in
    set braces, `{` `}`. An advantage of the Python approach is that it ensures that
    the visual structure of a program is an accurate representation of its semantic
    structure. Because indentation is semantically important, the notion of a line
    is also important. A line of code that is too long to read easily can be broken
    into multiple lines on the screen by ending each line on the screen, other than
    the last one, with a backslash (\). For example,
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在使用缩进方面是非常特殊的。大多数其他编程语言使用括号符号来划分代码块，例如，C语言使用花括号`{` `}`来封闭代码块。Python 方法的一个优点是，它确保程序的视觉结构准确地代表其语义结构。由于缩进在语义上很重要，行的概念也很重要。过长的代码行可以通过在屏幕上每一行的末尾（除了最后一行）加上反斜杠（\）来拆分为多行。比如，
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: "[PRE14] \uFEFF \uFEFFx = 1111111111111111111111111111111 + 222222222222333222222222\
    \ +     3333333333333333333333333333333 [PRE15] \uFEFF \uFEFFx = (1111111111111111111111111111111\
    \ + 222222222222333222222222 +     3333333333333333333333333333333) [PRE16] if\
    \ x%2 == 0:     if x%3 == 0:         print('Divisible by 2 and 3')     else: \
    \        print('Divisible by 2 and not by 3') elif x%3 == 0:     print('Divisible\
    \ by 3 and not by 2') [PRE17] if x < y and x < z:     print('x is least') elif\
    \ y < z:     print('y is least') else:     print('z is least') [PRE18] \uFEFF\uFEFF\
    if x%2 != 0 and y%2 != 0 and z%2 != 0:     print(max(x, y, z)) if x%2 != 0 and\
    \ y%2 != 0 and z%2 == 0:     print(max(x, y)) if x%2 != 0 and y%2 == 0 and z%2\
    \ != 0:     print(max(x, z)) if x%2 == 0 and y%2 != 0 and z%2 != 0:     print(max(y,\
    \ z)) if x%2 != 0 and y%2 == 0 and z%2 == 0:     print(x) if x%2 == 0 and y%2\
    \ != 0 and z%2 == 0:     print(y) if x%2 == 0 and y%2 == 0 and z%2 != 0:     print(z)\
    \ if x%2 == 0 and y%2 == 0 and z%2 == 0:     print(min(x, y, z)) [PRE19] \uFEFF\
    \uFEFFanswer = min(x, y, z) if x%2 != 0:     answer = x if y%2 != 0 and y > answer:\
    \     answer = y if z%2 != 0 and z > answer:     answer = z print(answer) [PRE20]\
    \ \uFEFF\uFEFF*expr1* if *condition* else *expr2* [PRE21] x = y if y > z else\
    \ z [PRE22] print((x if x > z else z) if x > y else (y if y > z else z)) [PRE23]`\
    \  [PRE24] `'a'` 3*4 `3*'a'` 3+4 `'a'+'a'` [PRE25] new_id `'a'*'a'` [PRE26] NameError:\
    \ name 'new_id' is not defined [PRE27] TypeError: can't multiply sequence by non-int\
    \ of type ‘str'  [PRE28] \uFEFFnum = 30000000 fraction = 1/2 print(num*fraction,\
    \ 'is', fraction*100, '%', 'of', num) print(num*fraction, 'is', str(fraction*100)\
    \ + '%', 'of', num) [PRE29] \uFEFF15000000.0 is 50.0 % of 30000000 15000000.0\
    \ is 50.0% of 30000000 [PRE30] \uFEFFprint(int(num*fraction), 'is', str(fraction*100)\
    \ + '%', 'of', num) [PRE31] \uFEFF \uFEFFprint(f'{int(num*fraction)} is {fraction*100}%\
    \ of {num}') [PRE32] print(f'{num*fraction:,.0f} is {fraction*100}% of {num:,}')\
    \ [PRE33] `Enter your name:` [PRE34] Are you really George Washington ? [PRE35]\
    \ \uFEFF\uFEFFn = input('Enter an int: ') print(type(n)) [PRE36] <class ‘str'>\
    \ [PRE37] `# -*- coding: *encoding name* -*-` [PRE38] # -*- coding: utf-8 -*-\
    \ [PRE39] print('Mluvíš anglicky?') print(`'`क्या आप अंग्रेज़ी बोलते हैं?`'`)\
    \ [PRE40] Mluvíš anglicky? क्या आप अंग्रेज़ी बोलते हैं? [PRE41] num_x = int(input('How\
    \ many times should I print the letter X? ')) to_print = '' if num_x == 1:   \
    \  to_print = 'X' elif num_x == 2:     to_print = 'XX' elif num_x == 3:     to_print\
    \ = 'XXX' #… print(to_print) [PRE42] num_x = int(input('How many times should\
    \ I print the letter X? ')) to_print = '' # concatenate X to to_print num_x times\
    \ print(to_print) [PRE43] num_x = int(input('How many times should I print the\
    \ letter X? ')) to_print = '' #concatenate X to to_print num_x times print(to_print)\
    \ [PRE44] #Find a positive integer that is divisible by both 11 and 12 x = 1 while\
    \ True:     if x%11 == 0 and x%12 == 0:         break     x = x + 1 print(x, 'is\
    \ divisible by 11 and 12') [PRE45] 132 is divisible by 11 and 12 [PRE46] `for`\
    \ *variable* `in` *sequence*`:`      *code block* [PRE47] \uFEFFtotal = 0 for\
    \ num in (77, 11, 3):     total = total + num print(total) [PRE48] x = 4 for i\
    \ in range(x):     print(i) [PRE49] 0 1 2 3 [PRE50] for i in range(2):     print(i)\
    \     i = 0     print(i) [PRE51] \uFEFFindex = 0 last_index = 1 while index <=\
    \ last_index:     i = index     print(i)     i = 0     print(i)     index = index\
    \ + 1 [PRE52] \uFEFFx = 1 for i in range(x):     print(i)     x = 4 [PRE53] x\
    \ = 4 for j in range(x):     for i in range(x):         x = 2 [PRE54] \uFEFF`x\
    \ = 3 for j in range(x):     print('Iteration of outer loop')     for i in range(x):\
    \         print('    Iteration of inner loop')         x = 2` [PRE55] \uFEFFIteration\
    \ of outer loop     Iteration of inner loop     Iteration of inner loop     Iteration\
    \ of inner loop Iteration of outer loop     Iteration of inner loop     Iteration\
    \ of inner loop Iteration of outer loop     Iteration of inner loop     Iteration\
    \ of inner loop [PRE56] total = 0 for c in '12345678':     total = total + int(c)\
    \ print(total) [PRE57]`"
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
