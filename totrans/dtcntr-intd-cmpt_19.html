<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>7.1Â TreesðŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>7.1Â TreesðŸ”—</h1>
<blockquote>åŽŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/trees.html">https://dcic-world.org/2025-08-27/trees.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._ancestor-trees%29" class="toclink" data-pltdoc="x">7.1.1<span class="hspace">Â </span>Data Design Problem â€“ Ancestry Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._compute-parents-table%29" class="toclink" data-pltdoc="x">7.1.1.1<span class="hspace">Â </span>Computing Genetic Parents from an Ancestry Table</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Computing_.Grandparents_from_an_.Ancestry_.Table%29" class="toclink" data-pltdoc="x">7.1.1.2<span class="hspace">Â </span>Computing Grandparents from an Ancestry Table</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._ancestor-tree%29" class="toclink" data-pltdoc="x">7.1.1.3<span class="hspace">Â </span>Creating a Datatype for Ancestor Trees</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Programs_to_.Process_.Ancestor_.Trees%29" class="toclink" data-pltdoc="x">7.1.2<span class="hspace">Â </span>Programs to Process Ancestor Trees</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Summarizing_.How_to_.Approach_.Tree_.Problems%29" class="toclink" data-pltdoc="x">7.1.3<span class="hspace">Â </span>Summarizing How to Approach Tree Problems</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Study_.Questions%29" class="toclink" data-pltdoc="x">7.1.4<span class="hspace">Â </span>Study Questions</a></p></td></tr></table><section class="SsectionLevel4" id="section 7.1.1"><h4 class="heading">7.1.1<span class="stt">Â </span><a name="(part._ancestor-trees)"/>Data Design Problem â€“ Ancestry Data<span class="button-group"><a href="#(part._ancestor-trees)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Imagine that we wanted to manage ancestry information for
purposes of a medical research study. Specifically, we want to record
peopleâ€™s birthyear, eye colors, and genetic parents. Hereâ€™s a
sample table of such data, with one row for each person:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ancestors = table: name, birthyear, eyecolor, female-parent, male-parent
  row: "Anna", 1997, "blue", "Susan", "Charlie"
  row: "Susan", 1971, "blue", "Ellen", "Bill"
  row: "Charlie", 1972, "green", "", ""
  row: "Ellen", 1945, "brown", "Laura", "John"
  row: "John", 1922, "brown", "", "Robert"
  row: "Laura", 1922, "brown", "", ""
  row: "Robert", 1895, "blue", "", ""
end</code></pre></div></div><p>For our research, we want to be able to answer questions such as the following:</p><ul><li><p>Who are the genetic grandparents of a specific person?</p></li><li><p>How frequent is each eye color?</p></li><li><p>Is one specific person an ancestor of another specific person?</p></li><li><p>How many generations do we have information for?</p></li><li><p>Does oneâ€™s eye color correlate with the ages of their genetic
parents when they were born?</p></li></ul><p>Letâ€™s start with the first question:</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How would you compute a list of the known grandparents for a given
person? For purposes of this chapter, you may assume that each person
has a unique name (while this isnâ€™t realistic in practice, it will
simplify our computations for the time being; we will revisit it later
in the chapter).</p><p>(Hint: Make a task plan. Does it suggest any particular helper functions?)</p></blockquote></blockquote><p>Our task plan has two key steps: find the names of the genetic
parents of the named person, then find the names of the parents of
each of those people. Both steps share the need to compute the known
parents from a name, so we should create a helper function for that
(weâ€™ll call it <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">parents-of</code></span>). Since this sounds like a routine
table program, we can use it for a bit of review:</p><section class="SsectionLevel5" id="section 7.1.1.1"><h5 class="heading">7.1.1.1<span class="stt">Â </span><a name="(part._compute-parents-table)"/>Computing Genetic Parents from an Ancestry Table<span class="button-group"><a href="#(part._compute-parents-table)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>How do we compute a list of someoneâ€™s genetic parents? Letâ€™s sketch a
task plan for that:</p><ul><li><p>filter the table to find the person</p></li><li><p>extract the name of the female parent</p></li><li><p>extract the name of the male parent</p></li><li><p>make a list of those names</p></li></ul><p>These are tasks we have seen before, so we can translate this
plan directly into code:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "Return list of names of known parents of given name"
  matches = filter-with(anc-table, lam(r): r["name"] == who end)
  if matches.length() &gt; 0:
    person-row = matches.row-n(0)
    [list:
      person-row["female-parent"],
      person-row["male-parent"]]
  else:
    empty
  end
where:
  parents-of(ancestors, "Anna")
    is [list: "Susan", "Charlie"]
  parents-of(ancestors, "Kathi") is empty
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Are you satisfied with this program? With the examples included in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> block? Write down any critiques you have.</p></blockquote></blockquote><p>There are arguably some issues here. How many of these did you catch?</p><ul><li><p>The examples are weak: none of them consider people for
whom we are missing information on at least one parent.</p></li><li><p>The list of names returned in the case of an unknown parent
includes the empty string, which isnâ€™t actually a name. This could
cause problems if we use this list of names in a subsequent
computation (such as to compute the names of someoneâ€™s grandparents).</p></li><li><p>If empty strings are not part of the output list, then weâ€™d get
the same result from asking for the parents of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Robert"</code></span> (who is
in the table) as for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Kathi"</code></span> (who is not). These are
fundamentally different cases, which arguably demand different
outputs so we can tell them apart.</p></li></ul><p>To fix these problems, we need to remove the empty strings from the
produced list of parents and return something other than the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> list when a name is not in the table. Since the output of
this function is a list of strings, itâ€™s hard to see what to return
that couldnâ€™t be confused for a valid list of names. Our solution for
now is to have Pyret throw an error (like the ones you get when Pyret
is not able to finish running your program). Hereâ€™s a solution that
handles both problems:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "Return list of names of known parents of given name"
  matches = filter-with(anc-table, lam(r): r["name"] == who end)
  if matches.length() &gt; 0:
    person-row = matches.row-n(0)
    names =
     [list: person-row["female-parent"],
       person-row["male-parent"]]
    L.filter(lam(n): not(n == "") end, names)
  else:
    raise("No such person " + who)
  end
where:
  parents-of(ancestors, "Anna") is [list: "Susan", "Charlie"]
  parents-of(ancestors, "John") is [list: "Robert"]
  parents-of(ancestors, "Robert") is empty
  parents-of(ancestors, "Kathi") raises "No such person"
end</code></pre></div></div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raise</code></span> construct tells Pyret to halt the program and produce
an error message. The error message does not have to match the
expected output type of the program. If you run this function with a
name that is not in the table, youâ€™ll see an error appear in the
interactions pane, with no result returned.</p><p>Within the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> block, we see how to check whether an
expression will yield an error: instead of using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> to check
the equality of values, we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raises</code></span> to check whether the
provided string is a sub-string of the actual error produced by the
program.</p></section><section class="SsectionLevel5" id="section 7.1.1.2"><h5 class="heading">7.1.1.2<span class="stt">Â </span><a name="(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)"/>Computing Grandparents from an Ancestry Table<span class="button-group"><a href="#(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Once we have the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">parents-of</code></span> function, we should be able to
compute the grandparents by computing parents of parents, as follows:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun grandparents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "compute list of known grandparents in the table"
  # glue together lists of mother's parents and father's parents
  plist = parents-of(anc-table, who) # gives a list of two names
  parents-of(anc-table, plist.first) +
    parents-of(anc-table, plist.rest.first)
where:
  grandparents-of(ancestors, "Anna") is [list: "Ellen", "Bill"]
  grandparents-of(ancestors, "Laura") is [list:]
  grandparents-of(ancestors, "John") is [list: ]
  grandparents-of(ancestors, "Kathi") is [list:]
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Look back at our sample ancestry tree: for which people would this
correctly compute the list of grandparents?</p></blockquote></blockquote><p>This <span class="RktSym">grandparents-of</span><span class="RktMeta"/> code works fine for someone who has both
parents in the table. For someone without two parents, however, the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">plist</code></span> will have fewer than two names, so the expression
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">plist.rest.first</code></span> (if not <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">plist.first</code></span>) will yield an
error.</p><p>Hereâ€™s a version that checks the number of parents before computing
the set of grandparents:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun grandparents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "compute list of known grandparents in the table"
  # glue together lists of mother's parents and father's parents
  plist = parents-of(anc-table, who) # gives a list of two names
  if plist.length() == 2:
    parents-of(anc-table, plist.first) + parents-of(anc-table, plist.rest.first)
  else if plist.length() == 1:
    parents-of(anc-table, plist.first)
  else: empty
  end
where:
  grandparents-of(ancestors, "Anna") is [list: "Ellen", "Bill"]
  grandparents-of(ancestors, "Laura") is [list:]
  grandparents-of(ancestors, "John") is [list: ]
  grandparents-of(ancestors, "Kathi") raises "No such person"
end</code></pre></div></div><p>What if we now wanted to gather up all of someoneâ€™s ancestors? Since
we donâ€™t know how many generations there are, weâ€™d need to use
recursion. This approach would also be expensive, since weâ€™d end up
filtering over the table over and over, which checks every row of the
table in each use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>.</p><p>Look back at the ancestry tree picture.  We donâ€™t do any complicated
filtering there â€“ we just follow the line in the picture immediately
from a person to their mother or father.  Can we get that idea in code
instead? Yes, through datatypes.</p></section><section class="SsectionLevel5" id="section 7.1.1.3"><h5 class="heading">7.1.1.3<span class="stt">Â </span><a name="(part._ancestor-tree)"/>Creating a Datatype for Ancestor Trees<span class="button-group"><a href="#(part._ancestor-tree)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>For this approach, we want to create a datatype for Ancestor Trees
that has a variant (constructor) for setting up a person. Look
back at our picture â€“ what information makes up a person? Their
name, their mother, and their father (along with birthyear and
eyecolor, which arenâ€™t shown in the picture).  This suggests the following
datatype, which basically turns a row into a person value:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: ________,
      father :: ________
      )
end</code></pre></div></div><p>For example, annaâ€™s row might look like:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anna-row = person("Anna", 1997, "blue", ???, ???)</code></pre></div></div><p/><div class="SIntrapara">What type do we put in the blanks?  A quick brainstorm yields
several ideas:
</div><div class="SIntrapara"><ul><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">person</code></span></p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">List&lt;person&gt;</code></span></p></li><li><p>some new datatype</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span></p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">String</code></span></p></li></ul></div><div class="SIntrapara">Which should it be?</div><p>If we use a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">String</code></span>, weâ€™re back to the table row, and we donâ€™t
end up with a way to easily get from one person to another. We should
therefore make this an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span>.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: AncTree,
      father :: AncTree
      )
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span> starting from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Anna</code></span> using this definition.</p></blockquote></blockquote><p>Did you get stuck? What do we do when we run out of known people? To
handle that, we must add an option in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span> definition to
capture people for whom we donâ€™t know anything.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | noInfo
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: AncTree,
      father :: AncTree
      )
end</code></pre></div></div><p>Hereâ€™s Annaâ€™s tree written in this datatype:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anna-tree =
  person("Anna", 1997, "blue",
    person("Susan", 1971, "blue",
      person("Ellen", 1945, "brown",
        person("Laura", 1920, "blue", noInfo, noInfo),
        person("John", 1920, "green",
          noInfo,
          person("Robert", 1893, "brown", noInfo, noInfo))),
      person("Bill", 1946, "blue", noInfo, noInfo)),
    person("Charlie", 1972, "green", noInfo, noInfo))</code></pre></div></div><p>We could also have named each person data individually.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">robert-tree = person("Robert", 1893, "brown", noInfo, noInfo)
laura-tree = person("Laura", 1920, "blue", noInfo, noInfo)
john-tree = person("John", 1920, "green", noInfo, robert-tree)
ellen-tree = person("Ellen", 1945, "brown", laura-tree, john-tree)
bill-tree = person("Bill", 1946, "blue", noInfo, noInfo)
susan-tree = person("Susan", 1971, "blue", ellen-tree, bill-tree)
charlie-tree = person("Charlie", 1972, "green", noInfo, noInfo)
anna-tree2 = person("Anna", 1997, "blue", susan-tree, charlie-tree)</code></pre></div></div><p>The latter gives you pieces of the tree to use as other examples, but
loses the structure that is visible in the indentation of the first
version. You could get to pieces of the first version by digging into
the data, such as writing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anna-tree.mother.mother</code></span> to get to the
tree starting from "Ellen".</p><p>Hereâ€™s the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">parents-of</code></span> function written against <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span>:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of-tree(tr :: AncTree) -&gt; List&lt;String&gt;:
  cases (AncTree) tr:
    | noInfo =&gt; empty
    | person(n, y, e, m, f) =&gt; [list: m.name, f.name]
      # person bit more complicated if parent is missing
  end
end</code></pre></div></div></section></section><section class="SsectionLevel4" id="section 7.1.2"><h4 class="heading">7.1.2<span class="stt">Â </span><a name="(part._.Programs_to_.Process_.Ancestor_.Trees)"/>Programs to Process Ancestor Trees<span class="button-group"><a href="#(part._.Programs_to_.Process_.Ancestor_.Trees)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>How would we write a function to determine whether anyone in the tree
had a particular name? To be clear, we are trying to fill in the
following code:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun in-tree(at :: AncTree, name :: String) -&gt; Boolean:
  doc: "determine whether name is in the tree"
  ...</code></pre></div></div><p>How do we get started?  Add some examples, remembering to check both
cases of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span> definition:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun in-tree(at :: AncTree, name :: String) -&gt; Boolean:
  doc: "determine whether name is in the tree"
  ...
where:
  in-tree(anna-tree, "Anna") is true
  in-tree(anna-tree, "Ellen") is true
  in-tree(ellen-tree, "Anna") is false
  in-tree(noInfo, "Ellen") is false
end</code></pre></div></div><p>What next? When we were working on lists, we talked about
the <span class="emph">template</span>, a skeleton of code that we knew we could write
based on the structure of the data. The template names the pieces of
each kind of data, and makes recursive calls on pieces that have the
same type.  Hereâ€™s the template over the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span> filled in:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun in-tree(at :: AncTree, name :: String) -&gt; Boolean:
  doc: "determine whether name is in the tree"
  cases (AncTree) at:     # comes from AncTree being data with cases
    | noInfo =&gt; ...
    | person(n, y, e, m, f) =&gt; ... in-tree(m, name) ... in-tree(f, name)
  end
where:
  in-tree(anna-tree, "Anna") is true
  in-tree(anna-tree, "Ellen") is true
  in-tree(ellen-tree, "Anna") is false
  in-tree(noInfo, "Ellen") is false
end</code></pre></div></div><p>To finish the code, we need to think about how to fill in the
ellipses.</p><ul><li><p>When the tree is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">noInfo</code></span>, it has no more people, so the answer
should be false (as worked out in the examples).</p></li><li><p>When the tree is a person, there are three possibilities: we
could be at a person with the name weâ€™re looking for, or the name
could be in the motherâ€™s tree, or the name could be in the fatherâ€™s
tree.</p><p>We know how to check whether the personâ€™s name matches the one
we are looking for. The recursive calls already ask about the name
being in the motherâ€™s tree or fatherâ€™s tree.  We just need to combine
those pieces into one Boolean answer. Since there are three
possibilities, we should combine them with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">or</code></span></p></li></ul><p>Hereâ€™s the final code:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun in-tree(at :: AncTree, name :: String) -&gt; Boolean:
  doc: "determine whether name is in the tree"
  cases (AncTree) at:     # comes from AncTree being data with cases
    | noInfo =&gt; false
    | person(n, y, e, m, f) =&gt; (name == n) or in-tree(m, name) or in-tree(f, name)
      # n is the same as at.name
      # m is the same as at.mother
  end
where:
  in-tree(anna-tree, "Anna") is true
  in-tree(anna-tree, "Ellen") is true
  in-tree(ellen-tree, "Anna") is false
  in-tree(noInfo, "Ellen") is false
end</code></pre></div></div></section><section class="SsectionLevel4" id="section 7.1.3"><h4 class="heading">7.1.3<span class="stt">Â </span><a name="(part._.Summarizing_.How_to_.Approach_.Tree_.Problems)"/>Summarizing How to Approach Tree Problems<span class="button-group"><a href="#(part._.Summarizing_.How_to_.Approach_.Tree_.Problems)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>We design tree programs using the same design recipe that we covered
on lists:</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Writing a Program Over Trees</p><blockquote class="StrategyBody"><ul><li><p>Write the datatype for your tree, including a base/leaf case</p></li><li><p>Write examples of your trees for use in testing</p></li><li><p>Write the function name, parameters, and types (the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun</code></span>
line)</p></li><li><p>Write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> checks for your code</p></li><li><p>Write the template, including the cases and recursive
calls. Hereâ€™s the template again for an ancestor tree, for an
arbitrary function called treeF:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun treeF(name :: String, t :: AncTree) -&gt; Boolean:
  cases (AncTree) anct:
    | unknown =&gt; ...
    | person(n, y, e, m, f) =&gt;
     ... treeF(name, m) ... treeF(name, f)
  end
end</code></pre></div></div></li><li><p>Fill in the template with details specific to the problem</p></li><li><p>Test your code using your examples</p></li></ul></blockquote></blockquote></section><section class="SsectionLevel4" id="section 7.1.4"><h4 class="heading">7.1.4<span class="stt">Â </span><a name="(part._.Study_.Questions)"/>Study Questions<span class="button-group"><a href="#(part._.Study_.Questions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><ul><li><p>Think of writing in-tree on a table (using filter-by) vs writing
it on a tree. How many times might each approach compare the name
being sought against a name in the table/tree?</p></li><li><p>Why do we need to use a recursive function to process the tree?</p></li><li><p>In what order will we check the names in the tree version?</p></li></ul><p>For practice, try problems such as</p><ul><li><p>How many blue-eyed people are in the tree?</p></li><li><p>How many people are in the tree?</p></li><li><p>How many generations are in the tree?</p></li><li><p>How many people have a given name in a tree?</p></li><li><p>How many people have names starting with "A"?</p></li><li><p>... and so on</p></li></ul></section>&#13;
<h4 class="heading">7.1.1<span class="stt">Â </span><a name="(part._ancestor-trees)"/>Data Design Problem â€“ Ancestry Data<span class="button-group"><a href="#(part._ancestor-trees)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Imagine that we wanted to manage ancestry information for
purposes of a medical research study. Specifically, we want to record
peopleâ€™s birthyear, eye colors, and genetic parents. Hereâ€™s a
sample table of such data, with one row for each person:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ancestors = table: name, birthyear, eyecolor, female-parent, male-parent
  row: "Anna", 1997, "blue", "Susan", "Charlie"
  row: "Susan", 1971, "blue", "Ellen", "Bill"
  row: "Charlie", 1972, "green", "", ""
  row: "Ellen", 1945, "brown", "Laura", "John"
  row: "John", 1922, "brown", "", "Robert"
  row: "Laura", 1922, "brown", "", ""
  row: "Robert", 1895, "blue", "", ""
end</code></pre></div></div><p>For our research, we want to be able to answer questions such as the following:</p><ul><li><p>Who are the genetic grandparents of a specific person?</p></li><li><p>How frequent is each eye color?</p></li><li><p>Is one specific person an ancestor of another specific person?</p></li><li><p>How many generations do we have information for?</p></li><li><p>Does oneâ€™s eye color correlate with the ages of their genetic
parents when they were born?</p></li></ul><p>Letâ€™s start with the first question:</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How would you compute a list of the known grandparents for a given
person? For purposes of this chapter, you may assume that each person
has a unique name (while this isnâ€™t realistic in practice, it will
simplify our computations for the time being; we will revisit it later
in the chapter).</p><p>(Hint: Make a task plan. Does it suggest any particular helper functions?)</p></blockquote></blockquote><p>Our task plan has two key steps: find the names of the genetic
parents of the named person, then find the names of the parents of
each of those people. Both steps share the need to compute the known
parents from a name, so we should create a helper function for that
(weâ€™ll call it <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">parents-of</code></span>). Since this sounds like a routine
table program, we can use it for a bit of review:</p><section class="SsectionLevel5" id="section 7.1.1.1"><h5 class="heading">7.1.1.1<span class="stt">Â </span><a name="(part._compute-parents-table)"/>Computing Genetic Parents from an Ancestry Table<span class="button-group"><a href="#(part._compute-parents-table)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>How do we compute a list of someoneâ€™s genetic parents? Letâ€™s sketch a
task plan for that:</p><ul><li><p>filter the table to find the person</p></li><li><p>extract the name of the female parent</p></li><li><p>extract the name of the male parent</p></li><li><p>make a list of those names</p></li></ul><p>These are tasks we have seen before, so we can translate this
plan directly into code:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "Return list of names of known parents of given name"
  matches = filter-with(anc-table, lam(r): r["name"] == who end)
  if matches.length() &gt; 0:
    person-row = matches.row-n(0)
    [list:
      person-row["female-parent"],
      person-row["male-parent"]]
  else:
    empty
  end
where:
  parents-of(ancestors, "Anna")
    is [list: "Susan", "Charlie"]
  parents-of(ancestors, "Kathi") is empty
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Are you satisfied with this program? With the examples included in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> block? Write down any critiques you have.</p></blockquote></blockquote><p>There are arguably some issues here. How many of these did you catch?</p><ul><li><p>The examples are weak: none of them consider people for
whom we are missing information on at least one parent.</p></li><li><p>The list of names returned in the case of an unknown parent
includes the empty string, which isnâ€™t actually a name. This could
cause problems if we use this list of names in a subsequent
computation (such as to compute the names of someoneâ€™s grandparents).</p></li><li><p>If empty strings are not part of the output list, then weâ€™d get
the same result from asking for the parents of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Robert"</code></span> (who is
in the table) as for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Kathi"</code></span> (who is not). These are
fundamentally different cases, which arguably demand different
outputs so we can tell them apart.</p></li></ul><p>To fix these problems, we need to remove the empty strings from the
produced list of parents and return something other than the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> list when a name is not in the table. Since the output of
this function is a list of strings, itâ€™s hard to see what to return
that couldnâ€™t be confused for a valid list of names. Our solution for
now is to have Pyret throw an error (like the ones you get when Pyret
is not able to finish running your program). Hereâ€™s a solution that
handles both problems:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "Return list of names of known parents of given name"
  matches = filter-with(anc-table, lam(r): r["name"] == who end)
  if matches.length() &gt; 0:
    person-row = matches.row-n(0)
    names =
     [list: person-row["female-parent"],
       person-row["male-parent"]]
    L.filter(lam(n): not(n == "") end, names)
  else:
    raise("No such person " + who)
  end
where:
  parents-of(ancestors, "Anna") is [list: "Susan", "Charlie"]
  parents-of(ancestors, "John") is [list: "Robert"]
  parents-of(ancestors, "Robert") is empty
  parents-of(ancestors, "Kathi") raises "No such person"
end</code></pre></div></div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raise</code></span> construct tells Pyret to halt the program and produce
an error message. The error message does not have to match the
expected output type of the program. If you run this function with a
name that is not in the table, youâ€™ll see an error appear in the
interactions pane, with no result returned.</p><p>Within the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> block, we see how to check whether an
expression will yield an error: instead of using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> to check
the equality of values, we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raises</code></span> to check whether the
provided string is a sub-string of the actual error produced by the
program.</p></section><section class="SsectionLevel5" id="section 7.1.1.2"><h5 class="heading">7.1.1.2<span class="stt">Â </span><a name="(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)"/>Computing Grandparents from an Ancestry Table<span class="button-group"><a href="#(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Once we have the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">parents-of</code></span> function, we should be able to
compute the grandparents by computing parents of parents, as follows:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun grandparents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "compute list of known grandparents in the table"
  # glue together lists of mother's parents and father's parents
  plist = parents-of(anc-table, who) # gives a list of two names
  parents-of(anc-table, plist.first) +
    parents-of(anc-table, plist.rest.first)
where:
  grandparents-of(ancestors, "Anna") is [list: "Ellen", "Bill"]
  grandparents-of(ancestors, "Laura") is [list:]
  grandparents-of(ancestors, "John") is [list: ]
  grandparents-of(ancestors, "Kathi") is [list:]
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Look back at our sample ancestry tree: for which people would this
correctly compute the list of grandparents?</p></blockquote></blockquote><p>This <span class="RktSym">grandparents-of</span><span class="RktMeta"/> code works fine for someone who has both
parents in the table. For someone without two parents, however, the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">plist</code></span> will have fewer than two names, so the expression
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">plist.rest.first</code></span> (if not <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">plist.first</code></span>) will yield an
error.</p><p>Hereâ€™s a version that checks the number of parents before computing
the set of grandparents:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun grandparents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "compute list of known grandparents in the table"
  # glue together lists of mother's parents and father's parents
  plist = parents-of(anc-table, who) # gives a list of two names
  if plist.length() == 2:
    parents-of(anc-table, plist.first) + parents-of(anc-table, plist.rest.first)
  else if plist.length() == 1:
    parents-of(anc-table, plist.first)
  else: empty
  end
where:
  grandparents-of(ancestors, "Anna") is [list: "Ellen", "Bill"]
  grandparents-of(ancestors, "Laura") is [list:]
  grandparents-of(ancestors, "John") is [list: ]
  grandparents-of(ancestors, "Kathi") raises "No such person"
end</code></pre></div></div><p>What if we now wanted to gather up all of someoneâ€™s ancestors? Since
we donâ€™t know how many generations there are, weâ€™d need to use
recursion. This approach would also be expensive, since weâ€™d end up
filtering over the table over and over, which checks every row of the
table in each use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>.</p><p>Look back at the ancestry tree picture.  We donâ€™t do any complicated
filtering there â€“ we just follow the line in the picture immediately
from a person to their mother or father.  Can we get that idea in code
instead? Yes, through datatypes.</p></section><section class="SsectionLevel5" id="section 7.1.1.3"><h5 class="heading">7.1.1.3<span class="stt">Â </span><a name="(part._ancestor-tree)"/>Creating a Datatype for Ancestor Trees<span class="button-group"><a href="#(part._ancestor-tree)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>For this approach, we want to create a datatype for Ancestor Trees
that has a variant (constructor) for setting up a person. Look
back at our picture â€“ what information makes up a person? Their
name, their mother, and their father (along with birthyear and
eyecolor, which arenâ€™t shown in the picture).  This suggests the following
datatype, which basically turns a row into a person value:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: ________,
      father :: ________
      )
end</code></pre></div></div><p>For example, annaâ€™s row might look like:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anna-row = person("Anna", 1997, "blue", ???, ???)</code></pre></div></div><p/><div class="SIntrapara">What type do we put in the blanks?  A quick brainstorm yields
several ideas:
</div><div class="SIntrapara"><ul><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">person</code></span></p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">List&lt;person&gt;</code></span></p></li><li><p>some new datatype</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span></p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">String</code></span></p></li></ul></div><div class="SIntrapara">Which should it be?</div><p>If we use a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">String</code></span>, weâ€™re back to the table row, and we donâ€™t
end up with a way to easily get from one person to another. We should
therefore make this an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span>.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: AncTree,
      father :: AncTree
      )
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span> starting from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Anna</code></span> using this definition.</p></blockquote></blockquote><p>Did you get stuck? What do we do when we run out of known people? To
handle that, we must add an option in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span> definition to
capture people for whom we donâ€™t know anything.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | noInfo
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: AncTree,
      father :: AncTree
      )
end</code></pre></div></div><p>Hereâ€™s Annaâ€™s tree written in this datatype:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anna-tree =
  person("Anna", 1997, "blue",
    person("Susan", 1971, "blue",
      person("Ellen", 1945, "brown",
        person("Laura", 1920, "blue", noInfo, noInfo),
        person("John", 1920, "green",
          noInfo,
          person("Robert", 1893, "brown", noInfo, noInfo))),
      person("Bill", 1946, "blue", noInfo, noInfo)),
    person("Charlie", 1972, "green", noInfo, noInfo))</code></pre></div></div><p>We could also have named each person data individually.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">robert-tree = person("Robert", 1893, "brown", noInfo, noInfo)
laura-tree = person("Laura", 1920, "blue", noInfo, noInfo)
john-tree = person("John", 1920, "green", noInfo, robert-tree)
ellen-tree = person("Ellen", 1945, "brown", laura-tree, john-tree)
bill-tree = person("Bill", 1946, "blue", noInfo, noInfo)
susan-tree = person("Susan", 1971, "blue", ellen-tree, bill-tree)
charlie-tree = person("Charlie", 1972, "green", noInfo, noInfo)
anna-tree2 = person("Anna", 1997, "blue", susan-tree, charlie-tree)</code></pre></div></div><p>The latter gives you pieces of the tree to use as other examples, but
loses the structure that is visible in the indentation of the first
version. You could get to pieces of the first version by digging into
the data, such as writing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anna-tree.mother.mother</code></span> to get to the
tree starting from "Ellen".</p><p>Hereâ€™s the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">parents-of</code></span> function written against <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span>:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of-tree(tr :: AncTree) -&gt; List&lt;String&gt;:
  cases (AncTree) tr:
    | noInfo =&gt; empty
    | person(n, y, e, m, f) =&gt; [list: m.name, f.name]
      # person bit more complicated if parent is missing
  end
end</code></pre></div></div></section>&#13;
<h5 class="heading">7.1.1.1<span class="stt">Â </span><a name="(part._compute-parents-table)"/>Computing Genetic Parents from an Ancestry Table<span class="button-group"><a href="#(part._compute-parents-table)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>How do we compute a list of someoneâ€™s genetic parents? Letâ€™s sketch a
task plan for that:</p><ul><li><p>filter the table to find the person</p></li><li><p>extract the name of the female parent</p></li><li><p>extract the name of the male parent</p></li><li><p>make a list of those names</p></li></ul><p>These are tasks we have seen before, so we can translate this
plan directly into code:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "Return list of names of known parents of given name"
  matches = filter-with(anc-table, lam(r): r["name"] == who end)
  if matches.length() &gt; 0:
    person-row = matches.row-n(0)
    [list:
      person-row["female-parent"],
      person-row["male-parent"]]
  else:
    empty
  end
where:
  parents-of(ancestors, "Anna")
    is [list: "Susan", "Charlie"]
  parents-of(ancestors, "Kathi") is empty
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Are you satisfied with this program? With the examples included in the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> block? Write down any critiques you have.</p></blockquote></blockquote><p>There are arguably some issues here. How many of these did you catch?</p><ul><li><p>The examples are weak: none of them consider people for
whom we are missing information on at least one parent.</p></li><li><p>The list of names returned in the case of an unknown parent
includes the empty string, which isnâ€™t actually a name. This could
cause problems if we use this list of names in a subsequent
computation (such as to compute the names of someoneâ€™s grandparents).</p></li><li><p>If empty strings are not part of the output list, then weâ€™d get
the same result from asking for the parents of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Robert"</code></span> (who is
in the table) as for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">"Kathi"</code></span> (who is not). These are
fundamentally different cases, which arguably demand different
outputs so we can tell them apart.</p></li></ul><p>To fix these problems, we need to remove the empty strings from the
produced list of parents and return something other than the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">empty</code></span> list when a name is not in the table. Since the output of
this function is a list of strings, itâ€™s hard to see what to return
that couldnâ€™t be confused for a valid list of names. Our solution for
now is to have Pyret throw an error (like the ones you get when Pyret
is not able to finish running your program). Hereâ€™s a solution that
handles both problems:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "Return list of names of known parents of given name"
  matches = filter-with(anc-table, lam(r): r["name"] == who end)
  if matches.length() &gt; 0:
    person-row = matches.row-n(0)
    names =
     [list: person-row["female-parent"],
       person-row["male-parent"]]
    L.filter(lam(n): not(n == "") end, names)
  else:
    raise("No such person " + who)
  end
where:
  parents-of(ancestors, "Anna") is [list: "Susan", "Charlie"]
  parents-of(ancestors, "John") is [list: "Robert"]
  parents-of(ancestors, "Robert") is empty
  parents-of(ancestors, "Kathi") raises "No such person"
end</code></pre></div></div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raise</code></span> construct tells Pyret to halt the program and produce
an error message. The error message does not have to match the
expected output type of the program. If you run this function with a
name that is not in the table, youâ€™ll see an error appear in the
interactions pane, with no result returned.</p><p>Within the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> block, we see how to check whether an
expression will yield an error: instead of using <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> to check
the equality of values, we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raises</code></span> to check whether the
provided string is a sub-string of the actual error produced by the
program.</p>&#13;
<h5 class="heading">7.1.1.2<span class="stt">Â </span><a name="(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)"/>Computing Grandparents from an Ancestry Table<span class="button-group"><a href="#(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Once we have the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">parents-of</code></span> function, we should be able to
compute the grandparents by computing parents of parents, as follows:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun grandparents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "compute list of known grandparents in the table"
  # glue together lists of mother's parents and father's parents
  plist = parents-of(anc-table, who) # gives a list of two names
  parents-of(anc-table, plist.first) +
    parents-of(anc-table, plist.rest.first)
where:
  grandparents-of(ancestors, "Anna") is [list: "Ellen", "Bill"]
  grandparents-of(ancestors, "Laura") is [list:]
  grandparents-of(ancestors, "John") is [list: ]
  grandparents-of(ancestors, "Kathi") is [list:]
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Look back at our sample ancestry tree: for which people would this
correctly compute the list of grandparents?</p></blockquote></blockquote><p>This <span class="RktSym">grandparents-of</span><span class="RktMeta"/> code works fine for someone who has both
parents in the table. For someone without two parents, however, the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">plist</code></span> will have fewer than two names, so the expression
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">plist.rest.first</code></span> (if not <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">plist.first</code></span>) will yield an
error.</p><p>Hereâ€™s a version that checks the number of parents before computing
the set of grandparents:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun grandparents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "compute list of known grandparents in the table"
  # glue together lists of mother's parents and father's parents
  plist = parents-of(anc-table, who) # gives a list of two names
  if plist.length() == 2:
    parents-of(anc-table, plist.first) + parents-of(anc-table, plist.rest.first)
  else if plist.length() == 1:
    parents-of(anc-table, plist.first)
  else: empty
  end
where:
  grandparents-of(ancestors, "Anna") is [list: "Ellen", "Bill"]
  grandparents-of(ancestors, "Laura") is [list:]
  grandparents-of(ancestors, "John") is [list: ]
  grandparents-of(ancestors, "Kathi") raises "No such person"
end</code></pre></div></div><p>What if we now wanted to gather up all of someoneâ€™s ancestors? Since
we donâ€™t know how many generations there are, weâ€™d need to use
recursion. This approach would also be expensive, since weâ€™d end up
filtering over the table over and over, which checks every row of the
table in each use of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">filter</code></span>.</p><p>Look back at the ancestry tree picture.  We donâ€™t do any complicated
filtering there â€“ we just follow the line in the picture immediately
from a person to their mother or father.  Can we get that idea in code
instead? Yes, through datatypes.</p>&#13;
<h5 class="heading">7.1.1.3<span class="stt">Â </span><a name="(part._ancestor-tree)"/>Creating a Datatype for Ancestor Trees<span class="button-group"><a href="#(part._ancestor-tree)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>For this approach, we want to create a datatype for Ancestor Trees
that has a variant (constructor) for setting up a person. Look
back at our picture â€“ what information makes up a person? Their
name, their mother, and their father (along with birthyear and
eyecolor, which arenâ€™t shown in the picture).  This suggests the following
datatype, which basically turns a row into a person value:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: ________,
      father :: ________
      )
end</code></pre></div></div><p>For example, annaâ€™s row might look like:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anna-row = person("Anna", 1997, "blue", ???, ???)</code></pre></div></div><p/><div class="SIntrapara">What type do we put in the blanks?  A quick brainstorm yields
several ideas:
</div><div class="SIntrapara"><ul><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">person</code></span></p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">List&lt;person&gt;</code></span></p></li><li><p>some new datatype</p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span></p></li><li><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">String</code></span></p></li></ul></div><div class="SIntrapara">Which should it be?</div><p>If we use a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">String</code></span>, weâ€™re back to the table row, and we donâ€™t
end up with a way to easily get from one person to another. We should
therefore make this an <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span>.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: AncTree,
      father :: AncTree
      )
end</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span> starting from <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Anna</code></span> using this definition.</p></blockquote></blockquote><p>Did you get stuck? What do we do when we run out of known people? To
handle that, we must add an option in the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span> definition to
capture people for whom we donâ€™t know anything.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | noInfo
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: AncTree,
      father :: AncTree
      )
end</code></pre></div></div><p>Hereâ€™s Annaâ€™s tree written in this datatype:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anna-tree =
  person("Anna", 1997, "blue",
    person("Susan", 1971, "blue",
      person("Ellen", 1945, "brown",
        person("Laura", 1920, "blue", noInfo, noInfo),
        person("John", 1920, "green",
          noInfo,
          person("Robert", 1893, "brown", noInfo, noInfo))),
      person("Bill", 1946, "blue", noInfo, noInfo)),
    person("Charlie", 1972, "green", noInfo, noInfo))</code></pre></div></div><p>We could also have named each person data individually.</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">robert-tree = person("Robert", 1893, "brown", noInfo, noInfo)
laura-tree = person("Laura", 1920, "blue", noInfo, noInfo)
john-tree = person("John", 1920, "green", noInfo, robert-tree)
ellen-tree = person("Ellen", 1945, "brown", laura-tree, john-tree)
bill-tree = person("Bill", 1946, "blue", noInfo, noInfo)
susan-tree = person("Susan", 1971, "blue", ellen-tree, bill-tree)
charlie-tree = person("Charlie", 1972, "green", noInfo, noInfo)
anna-tree2 = person("Anna", 1997, "blue", susan-tree, charlie-tree)</code></pre></div></div><p>The latter gives you pieces of the tree to use as other examples, but
loses the structure that is visible in the indentation of the first
version. You could get to pieces of the first version by digging into
the data, such as writing <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anna-tree.mother.mother</code></span> to get to the
tree starting from "Ellen".</p><p>Hereâ€™s the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">parents-of</code></span> function written against <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span>:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of-tree(tr :: AncTree) -&gt; List&lt;String&gt;:
  cases (AncTree) tr:
    | noInfo =&gt; empty
    | person(n, y, e, m, f) =&gt; [list: m.name, f.name]
      # person bit more complicated if parent is missing
  end
end</code></pre></div></div>&#13;
<h4 class="heading">7.1.2<span class="stt">Â </span><a name="(part._.Programs_to_.Process_.Ancestor_.Trees)"/>Programs to Process Ancestor Trees<span class="button-group"><a href="#(part._.Programs_to_.Process_.Ancestor_.Trees)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>How would we write a function to determine whether anyone in the tree
had a particular name? To be clear, we are trying to fill in the
following code:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun in-tree(at :: AncTree, name :: String) -&gt; Boolean:
  doc: "determine whether name is in the tree"
  ...</code></pre></div></div><p>How do we get started?  Add some examples, remembering to check both
cases of the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span> definition:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun in-tree(at :: AncTree, name :: String) -&gt; Boolean:
  doc: "determine whether name is in the tree"
  ...
where:
  in-tree(anna-tree, "Anna") is true
  in-tree(anna-tree, "Ellen") is true
  in-tree(ellen-tree, "Anna") is false
  in-tree(noInfo, "Ellen") is false
end</code></pre></div></div><p>What next? When we were working on lists, we talked about
the <span class="emph">template</span>, a skeleton of code that we knew we could write
based on the structure of the data. The template names the pieces of
each kind of data, and makes recursive calls on pieces that have the
same type.  Hereâ€™s the template over the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">AncTree</code></span> filled in:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun in-tree(at :: AncTree, name :: String) -&gt; Boolean:
  doc: "determine whether name is in the tree"
  cases (AncTree) at:     # comes from AncTree being data with cases
    | noInfo =&gt; ...
    | person(n, y, e, m, f) =&gt; ... in-tree(m, name) ... in-tree(f, name)
  end
where:
  in-tree(anna-tree, "Anna") is true
  in-tree(anna-tree, "Ellen") is true
  in-tree(ellen-tree, "Anna") is false
  in-tree(noInfo, "Ellen") is false
end</code></pre></div></div><p>To finish the code, we need to think about how to fill in the
ellipses.</p><ul><li><p>When the tree is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">noInfo</code></span>, it has no more people, so the answer
should be false (as worked out in the examples).</p></li><li><p>When the tree is a person, there are three possibilities: we
could be at a person with the name weâ€™re looking for, or the name
could be in the motherâ€™s tree, or the name could be in the fatherâ€™s
tree.</p><p>We know how to check whether the personâ€™s name matches the one
we are looking for. The recursive calls already ask about the name
being in the motherâ€™s tree or fatherâ€™s tree.  We just need to combine
those pieces into one Boolean answer. Since there are three
possibilities, we should combine them with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">or</code></span></p></li></ul><p>Hereâ€™s the final code:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun in-tree(at :: AncTree, name :: String) -&gt; Boolean:
  doc: "determine whether name is in the tree"
  cases (AncTree) at:     # comes from AncTree being data with cases
    | noInfo =&gt; false
    | person(n, y, e, m, f) =&gt; (name == n) or in-tree(m, name) or in-tree(f, name)
      # n is the same as at.name
      # m is the same as at.mother
  end
where:
  in-tree(anna-tree, "Anna") is true
  in-tree(anna-tree, "Ellen") is true
  in-tree(ellen-tree, "Anna") is false
  in-tree(noInfo, "Ellen") is false
end</code></pre></div></div>&#13;
<h4 class="heading">7.1.3<span class="stt">Â </span><a name="(part._.Summarizing_.How_to_.Approach_.Tree_.Problems)"/>Summarizing How to Approach Tree Problems<span class="button-group"><a href="#(part._.Summarizing_.How_to_.Approach_.Tree_.Problems)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>We design tree programs using the same design recipe that we covered
on lists:</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Writing a Program Over Trees</p><blockquote class="StrategyBody"><ul><li><p>Write the datatype for your tree, including a base/leaf case</p></li><li><p>Write examples of your trees for use in testing</p></li><li><p>Write the function name, parameters, and types (the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun</code></span>
line)</p></li><li><p>Write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> checks for your code</p></li><li><p>Write the template, including the cases and recursive
calls. Hereâ€™s the template again for an ancestor tree, for an
arbitrary function called treeF:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun treeF(name :: String, t :: AncTree) -&gt; Boolean:
  cases (AncTree) anct:
    | unknown =&gt; ...
    | person(n, y, e, m, f) =&gt;
     ... treeF(name, m) ... treeF(name, f)
  end
end</code></pre></div></div></li><li><p>Fill in the template with details specific to the problem</p></li><li><p>Test your code using your examples</p></li></ul></blockquote></blockquote>&#13;
<h4 class="heading">7.1.4<span class="stt">Â </span><a name="(part._.Study_.Questions)"/>Study Questions<span class="button-group"><a href="#(part._.Study_.Questions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><ul><li><p>Think of writing in-tree on a table (using filter-by) vs writing
it on a tree. How many times might each approach compare the name
being sought against a name in the table/tree?</p></li><li><p>Why do we need to use a recursive function to process the tree?</p></li><li><p>In what order will we check the names in the tree version?</p></li></ul><p>For practice, try problems such as</p><ul><li><p>How many blue-eyed people are in the tree?</p></li><li><p>How many people are in the tree?</p></li><li><p>How many generations are in the tree?</p></li><li><p>How many people have a given name in a tree?</p></li><li><p>How many people have names starting with "A"?</p></li><li><p>... and so on</p></li></ul>    
</body>
</html>