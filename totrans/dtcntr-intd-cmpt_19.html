<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>7.1Â TreesðŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>7.1Â TreesðŸ”—</h1>
<blockquote>åŽŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/trees.html">https://dcic-world.org/2025-08-27/trees.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._ancestor-trees%29" class="toclink" data-pltdoc="x">7.1.1Â Data Design Problem â€“ Ancestry Data</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._compute-parents-table%29" class="toclink" data-pltdoc="x">7.1.1.1Â Computing Genetic Parents from an Ancestry Table</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Computing_.Grandparents_from_an_.Ancestry_.Table%29" class="toclink" data-pltdoc="x">7.1.1.2Â Computing Grandparents from an Ancestry Table</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._ancestor-tree%29" class="toclink" data-pltdoc="x">7.1.1.3Â Creating a Datatype for Ancestor Trees</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Programs_to_.Process_.Ancestor_.Trees%29" class="toclink" data-pltdoc="x">7.1.2Â Programs to Process Ancestor Trees</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Summarizing_.How_to_.Approach_.Tree_.Problems%29" class="toclink" data-pltdoc="x">7.1.3Â Summarizing How to Approach Tree Problems</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Study_.Questions%29" class="toclink" data-pltdoc="x">7.1.4Â Study Questions</a></p></td></tr></table><section class="SsectionLevel4" id="section 7.1.1"><h4 class="heading">7.1.1Â <a name="(part._ancestor-trees)"/>Data Design Problem â€“ Ancestry Data<a href="#(part._ancestor-trees)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h4><p>Imagine that we wanted to manage ancestry information for
purposes of a medical research study. Specifically, we want to record
peopleâ€™s birthyear, eye colors, and genetic parents. Hereâ€™s a
sample table of such data, with one row for each person:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ancestors = table: name, birthyear, eyecolor, female-parent, male-parent
  row: "Anna", 1997, "blue", "Susan", "Charlie"
  row: "Susan", 1971, "blue", "Ellen", "Bill"
  row: "Charlie", 1972, "green", "", ""
  row: "Ellen", 1945, "brown", "Laura", "John"
  row: "John", 1922, "brown", "", "Robert"
  row: "Laura", 1922, "brown", "", ""
  row: "Robert", 1895, "blue", "", ""
end</code></pre><p>For our research, we want to be able to answer questions such as the following:</p><ul><li><p>Who are the genetic grandparents of a specific person?</p></li><li><p>How frequent is each eye color?</p></li><li><p>Is one specific person an ancestor of another specific person?</p></li><li><p>How many generations do we have information for?</p></li><li><p>Does oneâ€™s eye color correlate with the ages of their genetic
parents when they were born?</p></li></ul><p>Letâ€™s start with the first question:</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How would you compute a list of the known grandparents for a given
person? For purposes of this chapter, you may assume that each person
has a unique name (while this isnâ€™t realistic in practice, it will
simplify our computations for the time being; we will revisit it later
in the chapter).</p><p>(Hint: Make a task plan. Does it suggest any particular helper functions?)</p></blockquote></blockquote><p>Our task plan has two key steps: find the names of the genetic
parents of the named person, then find the names of the parents of
each of those people. Both steps share the need to compute the known
parents from a name, so we should create a helper function for that
(weâ€™ll call it <code data-lang="pyret" class="sourceCode">parents-of</code>). Since this sounds like a routine
table program, we can use it for a bit of review:</p><section class="SsectionLevel5" id="section 7.1.1.1"><h5 class="heading">7.1.1.1Â <a name="(part._compute-parents-table)"/>Computing Genetic Parents from an Ancestry Table<a href="#(part._compute-parents-table)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h5><p>How do we compute a list of someoneâ€™s genetic parents? Letâ€™s sketch a
task plan for that:</p><ul><li><p>filter the table to find the person</p></li><li><p>extract the name of the female parent</p></li><li><p>extract the name of the male parent</p></li><li><p>make a list of those names</p></li></ul><p>These are tasks we have seen before, so we can translate this
plan directly into code:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "Return list of names of known parents of given name"
  matches = filter-with(anc-table, lam(r): r["name"] == who end)
  if matches.length() &gt; 0:
    person-row = matches.row-n(0)
    [list:
      person-row["female-parent"],
      person-row["male-parent"]]
  else:
    empty
  end
where:
  parents-of(ancestors, "Anna")
    is [list: "Susan", "Charlie"]
  parents-of(ancestors, "Kathi") is empty
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Are you satisfied with this program? With the examples included in the
<code data-lang="pyret" class="sourceCode">where</code> block? Write down any critiques you have.</p></blockquote></blockquote><p>There are arguably some issues here. How many of these did you catch?</p><ul><li><p>The examples are weak: none of them consider people for
whom we are missing information on at least one parent.</p></li><li><p>The list of names returned in the case of an unknown parent
includes the empty string, which isnâ€™t actually a name. This could
cause problems if we use this list of names in a subsequent
computation (such as to compute the names of someoneâ€™s grandparents).</p></li><li><p>If empty strings are not part of the output list, then weâ€™d get
the same result from asking for the parents of <code data-lang="pyret" class="sourceCode">"Robert"</code> (who is
in the table) as for <code data-lang="pyret" class="sourceCode">"Kathi"</code> (who is not). These are
fundamentally different cases, which arguably demand different
outputs so we can tell them apart.</p></li></ul><p>To fix these problems, we need to remove the empty strings from the
produced list of parents and return something other than the
<code data-lang="pyret" class="sourceCode">empty</code> list when a name is not in the table. Since the output of
this function is a list of strings, itâ€™s hard to see what to return
that couldnâ€™t be confused for a valid list of names. Our solution for
now is to have Pyret throw an error (like the ones you get when Pyret
is not able to finish running your program). Hereâ€™s a solution that
handles both problems:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "Return list of names of known parents of given name"
  matches = filter-with(anc-table, lam(r): r["name"] == who end)
  if matches.length() &gt; 0:
    person-row = matches.row-n(0)
    names =
     [list: person-row["female-parent"],
       person-row["male-parent"]]
    L.filter(lam(n): not(n == "") end, names)
  else:
    raise("No such person " + who)
  end
where:
  parents-of(ancestors, "Anna") is [list: "Susan", "Charlie"]
  parents-of(ancestors, "John") is [list: "Robert"]
  parents-of(ancestors, "Robert") is empty
  parents-of(ancestors, "Kathi") raises "No such person"
end</code></pre><p>The <code data-lang="pyret" class="sourceCode">raise</code> construct tells Pyret to halt the program and produce
an error message. The error message does not have to match the
expected output type of the program. If you run this function with a
name that is not in the table, youâ€™ll see an error appear in the
interactions pane, with no result returned.</p><p>Within the <code data-lang="pyret" class="sourceCode">where</code> block, we see how to check whether an
expression will yield an error: instead of using <code data-lang="pyret" class="sourceCode">is</code> to check
the equality of values, we use <code data-lang="pyret" class="sourceCode">raises</code> to check whether the
provided string is a sub-string of the actual error produced by the
program.</p></section><section class="SsectionLevel5" id="section 7.1.1.2"><h5 class="heading">7.1.1.2Â <a name="(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)"/>Computing Grandparents from an Ancestry Table<a href="#(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h5><p>Once we have the <code data-lang="pyret" class="sourceCode">parents-of</code> function, we should be able to
compute the grandparents by computing parents of parents, as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun grandparents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "compute list of known grandparents in the table"
  # glue together lists of mother's parents and father's parents
  plist = parents-of(anc-table, who) # gives a list of two names
  parents-of(anc-table, plist.first) +
    parents-of(anc-table, plist.rest.first)
where:
  grandparents-of(ancestors, "Anna") is [list: "Ellen", "Bill"]
  grandparents-of(ancestors, "Laura") is [list:]
  grandparents-of(ancestors, "John") is [list: ]
  grandparents-of(ancestors, "Kathi") is [list:]
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Look back at our sample ancestry tree: for which people would this
correctly compute the list of grandparents?</p></blockquote></blockquote><p>This grandparents-of code works fine for someone who has both
parents in the table. For someone without two parents, however, the
<code data-lang="pyret" class="sourceCode">plist</code> will have fewer than two names, so the expression
<code data-lang="pyret" class="sourceCode">plist.rest.first</code> (if not <code data-lang="pyret" class="sourceCode">plist.first</code>) will yield an
error.</p><p>Hereâ€™s a version that checks the number of parents before computing
the set of grandparents:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun grandparents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "compute list of known grandparents in the table"
  # glue together lists of mother's parents and father's parents
  plist = parents-of(anc-table, who) # gives a list of two names
  if plist.length() == 2:
    parents-of(anc-table, plist.first) + parents-of(anc-table, plist.rest.first)
  else if plist.length() == 1:
    parents-of(anc-table, plist.first)
  else: empty
  end
where:
  grandparents-of(ancestors, "Anna") is [list: "Ellen", "Bill"]
  grandparents-of(ancestors, "Laura") is [list:]
  grandparents-of(ancestors, "John") is [list: ]
  grandparents-of(ancestors, "Kathi") raises "No such person"
end</code></pre><p>What if we now wanted to gather up all of someoneâ€™s ancestors? Since
we donâ€™t know how many generations there are, weâ€™d need to use
recursion. This approach would also be expensive, since weâ€™d end up
filtering over the table over and over, which checks every row of the
table in each use of <code data-lang="pyret" class="sourceCode">filter</code>.</p><p>Look back at the ancestry tree picture.  We donâ€™t do any complicated
filtering there â€“ we just follow the line in the picture immediately
from a person to their mother or father.  Can we get that idea in code
instead? Yes, through datatypes.</p></section><section class="SsectionLevel5" id="section 7.1.1.3"><h5 class="heading">7.1.1.3Â <a name="(part._ancestor-tree)"/>Creating a Datatype for Ancestor Trees<a href="#(part._ancestor-tree)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h5><p>For this approach, we want to create a datatype for Ancestor Trees
that has a variant (constructor) for setting up a person. Look
back at our picture â€“ what information makes up a person? Their
name, their mother, and their father (along with birthyear and
eyecolor, which arenâ€™t shown in the picture).  This suggests the following
datatype, which basically turns a row into a person value:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: ________,
      father :: ________
      )
end</code></pre><p>For example, annaâ€™s row might look like:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anna-row = person("Anna", 1997, "blue", ???, ???)</code></pre><p>What type do we put in the blanks?  A quick brainstorm yields
several ideas:
</p><ul><li><p><code data-lang="pyret" class="sourceCode">person</code></p></li><li><p><code data-lang="pyret" class="sourceCode">List&lt;person&gt;</code></p></li><li><p>some new datatype</p></li><li><p><code data-lang="pyret" class="sourceCode">AncTree</code></p></li><li><p><code data-lang="pyret" class="sourceCode">String</code></p></li></ul><p>Which should it be?</p><p>If we use a <code data-lang="pyret" class="sourceCode">String</code>, weâ€™re back to the table row, and we donâ€™t
end up with a way to easily get from one person to another. We should
therefore make this an <code data-lang="pyret" class="sourceCode">AncTree</code>.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: AncTree,
      father :: AncTree
      )
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write the <code data-lang="pyret" class="sourceCode">AncTree</code> starting from <code data-lang="pyret" class="sourceCode">Anna</code> using this definition.</p></blockquote></blockquote><p>Did you get stuck? What do we do when we run out of known people? To
handle that, we must add an option in the <code data-lang="pyret" class="sourceCode">AncTree</code> definition to
capture people for whom we donâ€™t know anything.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | noInfo
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: AncTree,
      father :: AncTree
      )
end</code></pre><p>Hereâ€™s Annaâ€™s tree written in this datatype:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anna-tree =
  person("Anna", 1997, "blue",
    person("Susan", 1971, "blue",
      person("Ellen", 1945, "brown",
        person("Laura", 1920, "blue", noInfo, noInfo),
        person("John", 1920, "green",
          noInfo,
          person("Robert", 1893, "brown", noInfo, noInfo))),
      person("Bill", 1946, "blue", noInfo, noInfo)),
    person("Charlie", 1972, "green", noInfo, noInfo))</code></pre><p>We could also have named each person data individually.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">robert-tree = person("Robert", 1893, "brown", noInfo, noInfo)
laura-tree = person("Laura", 1920, "blue", noInfo, noInfo)
john-tree = person("John", 1920, "green", noInfo, robert-tree)
ellen-tree = person("Ellen", 1945, "brown", laura-tree, john-tree)
bill-tree = person("Bill", 1946, "blue", noInfo, noInfo)
susan-tree = person("Susan", 1971, "blue", ellen-tree, bill-tree)
charlie-tree = person("Charlie", 1972, "green", noInfo, noInfo)
anna-tree2 = person("Anna", 1997, "blue", susan-tree, charlie-tree)</code></pre><p>The latter gives you pieces of the tree to use as other examples, but
loses the structure that is visible in the indentation of the first
version. You could get to pieces of the first version by digging into
the data, such as writing <code data-lang="pyret" class="sourceCode">anna-tree.mother.mother</code> to get to the
tree starting from "Ellen".</p><p>Hereâ€™s the <code data-lang="pyret" class="sourceCode">parents-of</code> function written against <code data-lang="pyret" class="sourceCode">AncTree</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of-tree(tr :: AncTree) -&gt; List&lt;String&gt;:
  cases (AncTree) tr:
    | noInfo =&gt; empty
    | person(n, y, e, m, f) =&gt; [list: m.name, f.name]
      # person bit more complicated if parent is missing
  end
end</code></pre></section></section><section class="SsectionLevel4" id="section 7.1.2"><h4 class="heading">7.1.2Â <a name="(part._.Programs_to_.Process_.Ancestor_.Trees)"/>Programs to Process Ancestor Trees<a href="#(part._.Programs_to_.Process_.Ancestor_.Trees)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h4><p>How would we write a function to determine whether anyone in the tree
had a particular name? To be clear, we are trying to fill in the
following code:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun in-tree(at :: AncTree, name :: String) -&gt; Boolean:
  doc: "determine whether name is in the tree"
  ...</code></pre><p>How do we get started?  Add some examples, remembering to check both
cases of the <code data-lang="pyret" class="sourceCode">AncTree</code> definition:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun in-tree(at :: AncTree, name :: String) -&gt; Boolean:
  doc: "determine whether name is in the tree"
  ...
where:
  in-tree(anna-tree, "Anna") is true
  in-tree(anna-tree, "Ellen") is true
  in-tree(ellen-tree, "Anna") is false
  in-tree(noInfo, "Ellen") is false
end</code></pre><p>What next? When we were working on lists, we talked about
the template, a skeleton of code that we knew we could write
based on the structure of the data. The template names the pieces of
each kind of data, and makes recursive calls on pieces that have the
same type.  Hereâ€™s the template over the <code data-lang="pyret" class="sourceCode">AncTree</code> filled in:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun in-tree(at :: AncTree, name :: String) -&gt; Boolean:
  doc: "determine whether name is in the tree"
  cases (AncTree) at:     # comes from AncTree being data with cases
    | noInfo =&gt; ...
    | person(n, y, e, m, f) =&gt; ... in-tree(m, name) ... in-tree(f, name)
  end
where:
  in-tree(anna-tree, "Anna") is true
  in-tree(anna-tree, "Ellen") is true
  in-tree(ellen-tree, "Anna") is false
  in-tree(noInfo, "Ellen") is false
end</code></pre><p>To finish the code, we need to think about how to fill in the
ellipses.</p><ul><li><p>When the tree is <code data-lang="pyret" class="sourceCode">noInfo</code>, it has no more people, so the answer
should be false (as worked out in the examples).</p></li><li><p>When the tree is a person, there are three possibilities: we
could be at a person with the name weâ€™re looking for, or the name
could be in the motherâ€™s tree, or the name could be in the fatherâ€™s
tree.</p><p>We know how to check whether the personâ€™s name matches the one
we are looking for. The recursive calls already ask about the name
being in the motherâ€™s tree or fatherâ€™s tree.  We just need to combine
those pieces into one Boolean answer. Since there are three
possibilities, we should combine them with <code data-lang="pyret" class="sourceCode">or</code></p></li></ul><p>Hereâ€™s the final code:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun in-tree(at :: AncTree, name :: String) -&gt; Boolean:
  doc: "determine whether name is in the tree"
  cases (AncTree) at:     # comes from AncTree being data with cases
    | noInfo =&gt; false
    | person(n, y, e, m, f) =&gt; (name == n) or in-tree(m, name) or in-tree(f, name)
      # n is the same as at.name
      # m is the same as at.mother
  end
where:
  in-tree(anna-tree, "Anna") is true
  in-tree(anna-tree, "Ellen") is true
  in-tree(ellen-tree, "Anna") is false
  in-tree(noInfo, "Ellen") is false
end</code></pre></section><section class="SsectionLevel4" id="section 7.1.3"><h4 class="heading">7.1.3Â <a name="(part._.Summarizing_.How_to_.Approach_.Tree_.Problems)"/>Summarizing How to Approach Tree Problems<a href="#(part._.Summarizing_.How_to_.Approach_.Tree_.Problems)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h4><p>We design tree programs using the same design recipe that we covered
on lists:</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Writing a Program Over Trees</p><blockquote class="StrategyBody"><ul><li><p>Write the datatype for your tree, including a base/leaf case</p></li><li><p>Write examples of your trees for use in testing</p></li><li><p>Write the function name, parameters, and types (the <code data-lang="pyret" class="sourceCode">fun</code>
line)</p></li><li><p>Write <code data-lang="pyret" class="sourceCode">where</code> checks for your code</p></li><li><p>Write the template, including the cases and recursive
calls. Hereâ€™s the template again for an ancestor tree, for an
arbitrary function called treeF:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun treeF(name :: String, t :: AncTree) -&gt; Boolean:
  cases (AncTree) anct:
    | unknown =&gt; ...
    | person(n, y, e, m, f) =&gt;
     ... treeF(name, m) ... treeF(name, f)
  end
end</code></pre></li><li><p>Fill in the template with details specific to the problem</p></li><li><p>Test your code using your examples</p></li></ul></blockquote></blockquote></section><section class="SsectionLevel4" id="section 7.1.4"><h4 class="heading">7.1.4Â <a name="(part._.Study_.Questions)"/>Study Questions<a href="#(part._.Study_.Questions)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h4><ul><li><p>Think of writing in-tree on a table (using filter-by) vs writing
it on a tree. How many times might each approach compare the name
being sought against a name in the table/tree?</p></li><li><p>Why do we need to use a recursive function to process the tree?</p></li><li><p>In what order will we check the names in the tree version?</p></li></ul><p>For practice, try problems such as</p><ul><li><p>How many blue-eyed people are in the tree?</p></li><li><p>How many people are in the tree?</p></li><li><p>How many generations are in the tree?</p></li><li><p>How many people have a given name in a tree?</p></li><li><p>How many people have names starting with "A"?</p></li><li><p>... and so on</p></li></ul></section>&#13;
<h4 class="heading">7.1.1Â <a name="(part._ancestor-trees)"/>Data Design Problem â€“ Ancestry Data<a href="#(part._ancestor-trees)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h4><p>Imagine that we wanted to manage ancestry information for
purposes of a medical research study. Specifically, we want to record
peopleâ€™s birthyear, eye colors, and genetic parents. Hereâ€™s a
sample table of such data, with one row for each person:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ancestors = table: name, birthyear, eyecolor, female-parent, male-parent
  row: "Anna", 1997, "blue", "Susan", "Charlie"
  row: "Susan", 1971, "blue", "Ellen", "Bill"
  row: "Charlie", 1972, "green", "", ""
  row: "Ellen", 1945, "brown", "Laura", "John"
  row: "John", 1922, "brown", "", "Robert"
  row: "Laura", 1922, "brown", "", ""
  row: "Robert", 1895, "blue", "", ""
end</code></pre><p>For our research, we want to be able to answer questions such as the following:</p><ul><li><p>Who are the genetic grandparents of a specific person?</p></li><li><p>How frequent is each eye color?</p></li><li><p>Is one specific person an ancestor of another specific person?</p></li><li><p>How many generations do we have information for?</p></li><li><p>Does oneâ€™s eye color correlate with the ages of their genetic
parents when they were born?</p></li></ul><p>Letâ€™s start with the first question:</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>How would you compute a list of the known grandparents for a given
person? For purposes of this chapter, you may assume that each person
has a unique name (while this isnâ€™t realistic in practice, it will
simplify our computations for the time being; we will revisit it later
in the chapter).</p><p>(Hint: Make a task plan. Does it suggest any particular helper functions?)</p></blockquote></blockquote><p>Our task plan has two key steps: find the names of the genetic
parents of the named person, then find the names of the parents of
each of those people. Both steps share the need to compute the known
parents from a name, so we should create a helper function for that
(weâ€™ll call it <code data-lang="pyret" class="sourceCode">parents-of</code>). Since this sounds like a routine
table program, we can use it for a bit of review:</p><section class="SsectionLevel5" id="section 7.1.1.1"><h5 class="heading">7.1.1.1Â <a name="(part._compute-parents-table)"/>Computing Genetic Parents from an Ancestry Table<a href="#(part._compute-parents-table)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h5><p>How do we compute a list of someoneâ€™s genetic parents? Letâ€™s sketch a
task plan for that:</p><ul><li><p>filter the table to find the person</p></li><li><p>extract the name of the female parent</p></li><li><p>extract the name of the male parent</p></li><li><p>make a list of those names</p></li></ul><p>These are tasks we have seen before, so we can translate this
plan directly into code:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "Return list of names of known parents of given name"
  matches = filter-with(anc-table, lam(r): r["name"] == who end)
  if matches.length() &gt; 0:
    person-row = matches.row-n(0)
    [list:
      person-row["female-parent"],
      person-row["male-parent"]]
  else:
    empty
  end
where:
  parents-of(ancestors, "Anna")
    is [list: "Susan", "Charlie"]
  parents-of(ancestors, "Kathi") is empty
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Are you satisfied with this program? With the examples included in the
<code data-lang="pyret" class="sourceCode">where</code> block? Write down any critiques you have.</p></blockquote></blockquote><p>There are arguably some issues here. How many of these did you catch?</p><ul><li><p>The examples are weak: none of them consider people for
whom we are missing information on at least one parent.</p></li><li><p>The list of names returned in the case of an unknown parent
includes the empty string, which isnâ€™t actually a name. This could
cause problems if we use this list of names in a subsequent
computation (such as to compute the names of someoneâ€™s grandparents).</p></li><li><p>If empty strings are not part of the output list, then weâ€™d get
the same result from asking for the parents of <code data-lang="pyret" class="sourceCode">"Robert"</code> (who is
in the table) as for <code data-lang="pyret" class="sourceCode">"Kathi"</code> (who is not). These are
fundamentally different cases, which arguably demand different
outputs so we can tell them apart.</p></li></ul><p>To fix these problems, we need to remove the empty strings from the
produced list of parents and return something other than the
<code data-lang="pyret" class="sourceCode">empty</code> list when a name is not in the table. Since the output of
this function is a list of strings, itâ€™s hard to see what to return
that couldnâ€™t be confused for a valid list of names. Our solution for
now is to have Pyret throw an error (like the ones you get when Pyret
is not able to finish running your program). Hereâ€™s a solution that
handles both problems:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "Return list of names of known parents of given name"
  matches = filter-with(anc-table, lam(r): r["name"] == who end)
  if matches.length() &gt; 0:
    person-row = matches.row-n(0)
    names =
     [list: person-row["female-parent"],
       person-row["male-parent"]]
    L.filter(lam(n): not(n == "") end, names)
  else:
    raise("No such person " + who)
  end
where:
  parents-of(ancestors, "Anna") is [list: "Susan", "Charlie"]
  parents-of(ancestors, "John") is [list: "Robert"]
  parents-of(ancestors, "Robert") is empty
  parents-of(ancestors, "Kathi") raises "No such person"
end</code></pre><p>The <code data-lang="pyret" class="sourceCode">raise</code> construct tells Pyret to halt the program and produce
an error message. The error message does not have to match the
expected output type of the program. If you run this function with a
name that is not in the table, youâ€™ll see an error appear in the
interactions pane, with no result returned.</p><p>Within the <code data-lang="pyret" class="sourceCode">where</code> block, we see how to check whether an
expression will yield an error: instead of using <code data-lang="pyret" class="sourceCode">is</code> to check
the equality of values, we use <code data-lang="pyret" class="sourceCode">raises</code> to check whether the
provided string is a sub-string of the actual error produced by the
program.</p></section><section class="SsectionLevel5" id="section 7.1.1.2"><h5 class="heading">7.1.1.2Â <a name="(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)"/>Computing Grandparents from an Ancestry Table<a href="#(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h5><p>Once we have the <code data-lang="pyret" class="sourceCode">parents-of</code> function, we should be able to
compute the grandparents by computing parents of parents, as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun grandparents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "compute list of known grandparents in the table"
  # glue together lists of mother's parents and father's parents
  plist = parents-of(anc-table, who) # gives a list of two names
  parents-of(anc-table, plist.first) +
    parents-of(anc-table, plist.rest.first)
where:
  grandparents-of(ancestors, "Anna") is [list: "Ellen", "Bill"]
  grandparents-of(ancestors, "Laura") is [list:]
  grandparents-of(ancestors, "John") is [list: ]
  grandparents-of(ancestors, "Kathi") is [list:]
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Look back at our sample ancestry tree: for which people would this
correctly compute the list of grandparents?</p></blockquote></blockquote><p>This grandparents-of code works fine for someone who has both
parents in the table. For someone without two parents, however, the
<code data-lang="pyret" class="sourceCode">plist</code> will have fewer than two names, so the expression
<code data-lang="pyret" class="sourceCode">plist.rest.first</code> (if not <code data-lang="pyret" class="sourceCode">plist.first</code>) will yield an
error.</p><p>Hereâ€™s a version that checks the number of parents before computing
the set of grandparents:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun grandparents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "compute list of known grandparents in the table"
  # glue together lists of mother's parents and father's parents
  plist = parents-of(anc-table, who) # gives a list of two names
  if plist.length() == 2:
    parents-of(anc-table, plist.first) + parents-of(anc-table, plist.rest.first)
  else if plist.length() == 1:
    parents-of(anc-table, plist.first)
  else: empty
  end
where:
  grandparents-of(ancestors, "Anna") is [list: "Ellen", "Bill"]
  grandparents-of(ancestors, "Laura") is [list:]
  grandparents-of(ancestors, "John") is [list: ]
  grandparents-of(ancestors, "Kathi") raises "No such person"
end</code></pre><p>What if we now wanted to gather up all of someoneâ€™s ancestors? Since
we donâ€™t know how many generations there are, weâ€™d need to use
recursion. This approach would also be expensive, since weâ€™d end up
filtering over the table over and over, which checks every row of the
table in each use of <code data-lang="pyret" class="sourceCode">filter</code>.</p><p>Look back at the ancestry tree picture.  We donâ€™t do any complicated
filtering there â€“ we just follow the line in the picture immediately
from a person to their mother or father.  Can we get that idea in code
instead? Yes, through datatypes.</p></section><section class="SsectionLevel5" id="section 7.1.1.3"><h5 class="heading">7.1.1.3Â <a name="(part._ancestor-tree)"/>Creating a Datatype for Ancestor Trees<a href="#(part._ancestor-tree)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h5><p>For this approach, we want to create a datatype for Ancestor Trees
that has a variant (constructor) for setting up a person. Look
back at our picture â€“ what information makes up a person? Their
name, their mother, and their father (along with birthyear and
eyecolor, which arenâ€™t shown in the picture).  This suggests the following
datatype, which basically turns a row into a person value:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: ________,
      father :: ________
      )
end</code></pre><p>For example, annaâ€™s row might look like:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anna-row = person("Anna", 1997, "blue", ???, ???)</code></pre><p>What type do we put in the blanks?  A quick brainstorm yields
several ideas:
</p><ul><li><p><code data-lang="pyret" class="sourceCode">person</code></p></li><li><p><code data-lang="pyret" class="sourceCode">List&lt;person&gt;</code></p></li><li><p>some new datatype</p></li><li><p><code data-lang="pyret" class="sourceCode">AncTree</code></p></li><li><p><code data-lang="pyret" class="sourceCode">String</code></p></li></ul><p>Which should it be?</p><p>If we use a <code data-lang="pyret" class="sourceCode">String</code>, weâ€™re back to the table row, and we donâ€™t
end up with a way to easily get from one person to another. We should
therefore make this an <code data-lang="pyret" class="sourceCode">AncTree</code>.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: AncTree,
      father :: AncTree
      )
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write the <code data-lang="pyret" class="sourceCode">AncTree</code> starting from <code data-lang="pyret" class="sourceCode">Anna</code> using this definition.</p></blockquote></blockquote><p>Did you get stuck? What do we do when we run out of known people? To
handle that, we must add an option in the <code data-lang="pyret" class="sourceCode">AncTree</code> definition to
capture people for whom we donâ€™t know anything.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | noInfo
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: AncTree,
      father :: AncTree
      )
end</code></pre><p>Hereâ€™s Annaâ€™s tree written in this datatype:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anna-tree =
  person("Anna", 1997, "blue",
    person("Susan", 1971, "blue",
      person("Ellen", 1945, "brown",
        person("Laura", 1920, "blue", noInfo, noInfo),
        person("John", 1920, "green",
          noInfo,
          person("Robert", 1893, "brown", noInfo, noInfo))),
      person("Bill", 1946, "blue", noInfo, noInfo)),
    person("Charlie", 1972, "green", noInfo, noInfo))</code></pre><p>We could also have named each person data individually.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">robert-tree = person("Robert", 1893, "brown", noInfo, noInfo)
laura-tree = person("Laura", 1920, "blue", noInfo, noInfo)
john-tree = person("John", 1920, "green", noInfo, robert-tree)
ellen-tree = person("Ellen", 1945, "brown", laura-tree, john-tree)
bill-tree = person("Bill", 1946, "blue", noInfo, noInfo)
susan-tree = person("Susan", 1971, "blue", ellen-tree, bill-tree)
charlie-tree = person("Charlie", 1972, "green", noInfo, noInfo)
anna-tree2 = person("Anna", 1997, "blue", susan-tree, charlie-tree)</code></pre><p>The latter gives you pieces of the tree to use as other examples, but
loses the structure that is visible in the indentation of the first
version. You could get to pieces of the first version by digging into
the data, such as writing <code data-lang="pyret" class="sourceCode">anna-tree.mother.mother</code> to get to the
tree starting from "Ellen".</p><p>Hereâ€™s the <code data-lang="pyret" class="sourceCode">parents-of</code> function written against <code data-lang="pyret" class="sourceCode">AncTree</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of-tree(tr :: AncTree) -&gt; List&lt;String&gt;:
  cases (AncTree) tr:
    | noInfo =&gt; empty
    | person(n, y, e, m, f) =&gt; [list: m.name, f.name]
      # person bit more complicated if parent is missing
  end
end</code></pre></section>&#13;
<h5 class="heading">7.1.1.1Â <a name="(part._compute-parents-table)"/>Computing Genetic Parents from an Ancestry Table<a href="#(part._compute-parents-table)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h5><p>How do we compute a list of someoneâ€™s genetic parents? Letâ€™s sketch a
task plan for that:</p><ul><li><p>filter the table to find the person</p></li><li><p>extract the name of the female parent</p></li><li><p>extract the name of the male parent</p></li><li><p>make a list of those names</p></li></ul><p>These are tasks we have seen before, so we can translate this
plan directly into code:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "Return list of names of known parents of given name"
  matches = filter-with(anc-table, lam(r): r["name"] == who end)
  if matches.length() &gt; 0:
    person-row = matches.row-n(0)
    [list:
      person-row["female-parent"],
      person-row["male-parent"]]
  else:
    empty
  end
where:
  parents-of(ancestors, "Anna")
    is [list: "Susan", "Charlie"]
  parents-of(ancestors, "Kathi") is empty
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Are you satisfied with this program? With the examples included in the
<code data-lang="pyret" class="sourceCode">where</code> block? Write down any critiques you have.</p></blockquote></blockquote><p>There are arguably some issues here. How many of these did you catch?</p><ul><li><p>The examples are weak: none of them consider people for
whom we are missing information on at least one parent.</p></li><li><p>The list of names returned in the case of an unknown parent
includes the empty string, which isnâ€™t actually a name. This could
cause problems if we use this list of names in a subsequent
computation (such as to compute the names of someoneâ€™s grandparents).</p></li><li><p>If empty strings are not part of the output list, then weâ€™d get
the same result from asking for the parents of <code data-lang="pyret" class="sourceCode">"Robert"</code> (who is
in the table) as for <code data-lang="pyret" class="sourceCode">"Kathi"</code> (who is not). These are
fundamentally different cases, which arguably demand different
outputs so we can tell them apart.</p></li></ul><p>To fix these problems, we need to remove the empty strings from the
produced list of parents and return something other than the
<code data-lang="pyret" class="sourceCode">empty</code> list when a name is not in the table. Since the output of
this function is a list of strings, itâ€™s hard to see what to return
that couldnâ€™t be confused for a valid list of names. Our solution for
now is to have Pyret throw an error (like the ones you get when Pyret
is not able to finish running your program). Hereâ€™s a solution that
handles both problems:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "Return list of names of known parents of given name"
  matches = filter-with(anc-table, lam(r): r["name"] == who end)
  if matches.length() &gt; 0:
    person-row = matches.row-n(0)
    names =
     [list: person-row["female-parent"],
       person-row["male-parent"]]
    L.filter(lam(n): not(n == "") end, names)
  else:
    raise("No such person " + who)
  end
where:
  parents-of(ancestors, "Anna") is [list: "Susan", "Charlie"]
  parents-of(ancestors, "John") is [list: "Robert"]
  parents-of(ancestors, "Robert") is empty
  parents-of(ancestors, "Kathi") raises "No such person"
end</code></pre><p>The <code data-lang="pyret" class="sourceCode">raise</code> construct tells Pyret to halt the program and produce
an error message. The error message does not have to match the
expected output type of the program. If you run this function with a
name that is not in the table, youâ€™ll see an error appear in the
interactions pane, with no result returned.</p><p>Within the <code data-lang="pyret" class="sourceCode">where</code> block, we see how to check whether an
expression will yield an error: instead of using <code data-lang="pyret" class="sourceCode">is</code> to check
the equality of values, we use <code data-lang="pyret" class="sourceCode">raises</code> to check whether the
provided string is a sub-string of the actual error produced by the
program.</p>&#13;
<h5 class="heading">7.1.1.2Â <a name="(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)"/>Computing Grandparents from an Ancestry Table<a href="#(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h5><p>Once we have the <code data-lang="pyret" class="sourceCode">parents-of</code> function, we should be able to
compute the grandparents by computing parents of parents, as follows:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun grandparents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "compute list of known grandparents in the table"
  # glue together lists of mother's parents and father's parents
  plist = parents-of(anc-table, who) # gives a list of two names
  parents-of(anc-table, plist.first) +
    parents-of(anc-table, plist.rest.first)
where:
  grandparents-of(ancestors, "Anna") is [list: "Ellen", "Bill"]
  grandparents-of(ancestors, "Laura") is [list:]
  grandparents-of(ancestors, "John") is [list: ]
  grandparents-of(ancestors, "Kathi") is [list:]
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Look back at our sample ancestry tree: for which people would this
correctly compute the list of grandparents?</p></blockquote></blockquote><p>This grandparents-of code works fine for someone who has both
parents in the table. For someone without two parents, however, the
<code data-lang="pyret" class="sourceCode">plist</code> will have fewer than two names, so the expression
<code data-lang="pyret" class="sourceCode">plist.rest.first</code> (if not <code data-lang="pyret" class="sourceCode">plist.first</code>) will yield an
error.</p><p>Hereâ€™s a version that checks the number of parents before computing
the set of grandparents:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun grandparents-of(anc-table :: Table, who :: String) -&gt; List&lt;String&gt;:
  doc: "compute list of known grandparents in the table"
  # glue together lists of mother's parents and father's parents
  plist = parents-of(anc-table, who) # gives a list of two names
  if plist.length() == 2:
    parents-of(anc-table, plist.first) + parents-of(anc-table, plist.rest.first)
  else if plist.length() == 1:
    parents-of(anc-table, plist.first)
  else: empty
  end
where:
  grandparents-of(ancestors, "Anna") is [list: "Ellen", "Bill"]
  grandparents-of(ancestors, "Laura") is [list:]
  grandparents-of(ancestors, "John") is [list: ]
  grandparents-of(ancestors, "Kathi") raises "No such person"
end</code></pre><p>What if we now wanted to gather up all of someoneâ€™s ancestors? Since
we donâ€™t know how many generations there are, weâ€™d need to use
recursion. This approach would also be expensive, since weâ€™d end up
filtering over the table over and over, which checks every row of the
table in each use of <code data-lang="pyret" class="sourceCode">filter</code>.</p><p>Look back at the ancestry tree picture.  We donâ€™t do any complicated
filtering there â€“ we just follow the line in the picture immediately
from a person to their mother or father.  Can we get that idea in code
instead? Yes, through datatypes.</p>&#13;
<h5 class="heading">7.1.1.3Â <a name="(part._ancestor-tree)"/>Creating a Datatype for Ancestor Trees<a href="#(part._ancestor-tree)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h5><p>For this approach, we want to create a datatype for Ancestor Trees
that has a variant (constructor) for setting up a person. Look
back at our picture â€“ what information makes up a person? Their
name, their mother, and their father (along with birthyear and
eyecolor, which arenâ€™t shown in the picture).  This suggests the following
datatype, which basically turns a row into a person value:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: ________,
      father :: ________
      )
end</code></pre><p>For example, annaâ€™s row might look like:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anna-row = person("Anna", 1997, "blue", ???, ???)</code></pre><p>What type do we put in the blanks?  A quick brainstorm yields
several ideas:
</p><ul><li><p><code data-lang="pyret" class="sourceCode">person</code></p></li><li><p><code data-lang="pyret" class="sourceCode">List&lt;person&gt;</code></p></li><li><p>some new datatype</p></li><li><p><code data-lang="pyret" class="sourceCode">AncTree</code></p></li><li><p><code data-lang="pyret" class="sourceCode">String</code></p></li></ul><p>Which should it be?</p><p>If we use a <code data-lang="pyret" class="sourceCode">String</code>, weâ€™re back to the table row, and we donâ€™t
end up with a way to easily get from one person to another. We should
therefore make this an <code data-lang="pyret" class="sourceCode">AncTree</code>.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: AncTree,
      father :: AncTree
      )
end</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write the <code data-lang="pyret" class="sourceCode">AncTree</code> starting from <code data-lang="pyret" class="sourceCode">Anna</code> using this definition.</p></blockquote></blockquote><p>Did you get stuck? What do we do when we run out of known people? To
handle that, we must add an option in the <code data-lang="pyret" class="sourceCode">AncTree</code> definition to
capture people for whom we donâ€™t know anything.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data AncTree:
  | noInfo
  | person(
      name :: String,
      birthyear :: Number,
      eye :: String,
      mother :: AncTree,
      father :: AncTree
      )
end</code></pre><p>Hereâ€™s Annaâ€™s tree written in this datatype:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">anna-tree =
  person("Anna", 1997, "blue",
    person("Susan", 1971, "blue",
      person("Ellen", 1945, "brown",
        person("Laura", 1920, "blue", noInfo, noInfo),
        person("John", 1920, "green",
          noInfo,
          person("Robert", 1893, "brown", noInfo, noInfo))),
      person("Bill", 1946, "blue", noInfo, noInfo)),
    person("Charlie", 1972, "green", noInfo, noInfo))</code></pre><p>We could also have named each person data individually.</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">robert-tree = person("Robert", 1893, "brown", noInfo, noInfo)
laura-tree = person("Laura", 1920, "blue", noInfo, noInfo)
john-tree = person("John", 1920, "green", noInfo, robert-tree)
ellen-tree = person("Ellen", 1945, "brown", laura-tree, john-tree)
bill-tree = person("Bill", 1946, "blue", noInfo, noInfo)
susan-tree = person("Susan", 1971, "blue", ellen-tree, bill-tree)
charlie-tree = person("Charlie", 1972, "green", noInfo, noInfo)
anna-tree2 = person("Anna", 1997, "blue", susan-tree, charlie-tree)</code></pre><p>The latter gives you pieces of the tree to use as other examples, but
loses the structure that is visible in the indentation of the first
version. You could get to pieces of the first version by digging into
the data, such as writing <code data-lang="pyret" class="sourceCode">anna-tree.mother.mother</code> to get to the
tree starting from "Ellen".</p><p>Hereâ€™s the <code data-lang="pyret" class="sourceCode">parents-of</code> function written against <code data-lang="pyret" class="sourceCode">AncTree</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun parents-of-tree(tr :: AncTree) -&gt; List&lt;String&gt;:
  cases (AncTree) tr:
    | noInfo =&gt; empty
    | person(n, y, e, m, f) =&gt; [list: m.name, f.name]
      # person bit more complicated if parent is missing
  end
end</code></pre>&#13;
<h4 class="heading">7.1.2Â <a name="(part._.Programs_to_.Process_.Ancestor_.Trees)"/>Programs to Process Ancestor Trees<a href="#(part._.Programs_to_.Process_.Ancestor_.Trees)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h4><p>How would we write a function to determine whether anyone in the tree
had a particular name? To be clear, we are trying to fill in the
following code:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun in-tree(at :: AncTree, name :: String) -&gt; Boolean:
  doc: "determine whether name is in the tree"
  ...</code></pre><p>How do we get started?  Add some examples, remembering to check both
cases of the <code data-lang="pyret" class="sourceCode">AncTree</code> definition:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun in-tree(at :: AncTree, name :: String) -&gt; Boolean:
  doc: "determine whether name is in the tree"
  ...
where:
  in-tree(anna-tree, "Anna") is true
  in-tree(anna-tree, "Ellen") is true
  in-tree(ellen-tree, "Anna") is false
  in-tree(noInfo, "Ellen") is false
end</code></pre><p>What next? When we were working on lists, we talked about
the template, a skeleton of code that we knew we could write
based on the structure of the data. The template names the pieces of
each kind of data, and makes recursive calls on pieces that have the
same type.  Hereâ€™s the template over the <code data-lang="pyret" class="sourceCode">AncTree</code> filled in:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun in-tree(at :: AncTree, name :: String) -&gt; Boolean:
  doc: "determine whether name is in the tree"
  cases (AncTree) at:     # comes from AncTree being data with cases
    | noInfo =&gt; ...
    | person(n, y, e, m, f) =&gt; ... in-tree(m, name) ... in-tree(f, name)
  end
where:
  in-tree(anna-tree, "Anna") is true
  in-tree(anna-tree, "Ellen") is true
  in-tree(ellen-tree, "Anna") is false
  in-tree(noInfo, "Ellen") is false
end</code></pre><p>To finish the code, we need to think about how to fill in the
ellipses.</p><ul><li><p>When the tree is <code data-lang="pyret" class="sourceCode">noInfo</code>, it has no more people, so the answer
should be false (as worked out in the examples).</p></li><li><p>When the tree is a person, there are three possibilities: we
could be at a person with the name weâ€™re looking for, or the name
could be in the motherâ€™s tree, or the name could be in the fatherâ€™s
tree.</p><p>We know how to check whether the personâ€™s name matches the one
we are looking for. The recursive calls already ask about the name
being in the motherâ€™s tree or fatherâ€™s tree.  We just need to combine
those pieces into one Boolean answer. Since there are three
possibilities, we should combine them with <code data-lang="pyret" class="sourceCode">or</code></p></li></ul><p>Hereâ€™s the final code:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun in-tree(at :: AncTree, name :: String) -&gt; Boolean:
  doc: "determine whether name is in the tree"
  cases (AncTree) at:     # comes from AncTree being data with cases
    | noInfo =&gt; false
    | person(n, y, e, m, f) =&gt; (name == n) or in-tree(m, name) or in-tree(f, name)
      # n is the same as at.name
      # m is the same as at.mother
  end
where:
  in-tree(anna-tree, "Anna") is true
  in-tree(anna-tree, "Ellen") is true
  in-tree(ellen-tree, "Anna") is false
  in-tree(noInfo, "Ellen") is false
end</code></pre>&#13;
<h4 class="heading">7.1.3Â <a name="(part._.Summarizing_.How_to_.Approach_.Tree_.Problems)"/>Summarizing How to Approach Tree Problems<a href="#(part._.Summarizing_.How_to_.Approach_.Tree_.Problems)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h4><p>We design tree programs using the same design recipe that we covered
on lists:</p><blockquote class="Strategy"><p class="StrategyHeader">Strategy: Writing a Program Over Trees</p><blockquote class="StrategyBody"><ul><li><p>Write the datatype for your tree, including a base/leaf case</p></li><li><p>Write examples of your trees for use in testing</p></li><li><p>Write the function name, parameters, and types (the <code data-lang="pyret" class="sourceCode">fun</code>
line)</p></li><li><p>Write <code data-lang="pyret" class="sourceCode">where</code> checks for your code</p></li><li><p>Write the template, including the cases and recursive
calls. Hereâ€™s the template again for an ancestor tree, for an
arbitrary function called treeF:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun treeF(name :: String, t :: AncTree) -&gt; Boolean:
  cases (AncTree) anct:
    | unknown =&gt; ...
    | person(n, y, e, m, f) =&gt;
     ... treeF(name, m) ... treeF(name, f)
  end
end</code></pre></li><li><p>Fill in the template with details specific to the problem</p></li><li><p>Test your code using your examples</p></li></ul></blockquote></blockquote>&#13;
<h4 class="heading">7.1.4Â <a name="(part._.Study_.Questions)"/>Study Questions<a href="#(part._.Study_.Questions)" class="heading-anchor" title="Link to here">ðŸ”—</a> </h4><ul><li><p>Think of writing in-tree on a table (using filter-by) vs writing
it on a tree. How many times might each approach compare the name
being sought against a name in the table/tree?</p></li><li><p>Why do we need to use a recursive function to process the tree?</p></li><li><p>In what order will we check the names in the tree version?</p></li></ul><p>For practice, try problems such as</p><ul><li><p>How many blue-eyed people are in the tree?</p></li><li><p>How many people are in the tree?</p></li><li><p>How many generations are in the tree?</p></li><li><p>How many people have a given name in a tree?</p></li><li><p>How many people have names starting with "A"?</p></li><li><p>... and so on</p></li></ul>    
</body>
</html>