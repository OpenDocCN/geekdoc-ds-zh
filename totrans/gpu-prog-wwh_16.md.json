["```\n$ git  clone  https://github.com/ENCCS/gpu-programming.git\n$ cd  gpu-programming/content/examples/stencil/\n$ ls \n```", "```\n// (c) 2023 ENCCS, CSC and the contributors\n#include  \"heat.h\"\n\n// Update the temperature values using five-point stencil\n// Arguments:\n//   curr: current temperature values\n//   prev: temperature values from previous time step\n//   a: diffusivity\n//   dt: time step\nvoid  evolve(field  *curr,  field  *prev,  double  a,  double  dt)\n{\n  // Help the compiler avoid being confused by the structs\n  double  *currdata  =  curr->data.data();\n  double  *prevdata  =  prev->data.data();\n  int  nx  =  prev->nx;\n  int  ny  =  prev->ny;\n\n  // Determine the temperature field at next time step\n  // As we have fixed boundary conditions, the outermost gridpoints\n  // are not updated.\n  double  dx2  =  prev->dx  *  prev->dx;\n  double  dy2  =  prev->dy  *  prev->dy;\n\n  // Use OpenMP threads for parallel update of grid values\n #pragma omp parallel for  for  (int  i  =  1;  i  <  nx  +  1;  i++)  {\n  for  (int  j  =  1;  j  <  ny  +  1;  j++)  {\n  int  ind  =  i  *  (ny  +  2)  +  j;\n  int  ip  =  (i  +  1)  *  (ny  +  2)  +  j;\n  int  im  =  (i  -  1)  *  (ny  +  2)  +  j;\n  int  jp  =  i  *  (ny  +  2)  +  j  +  1;\n  int  jm  =  i  *  (ny  +  2)  +  j  -  1;\n  currdata[ind]  =  prevdata[ind]  +  a*dt*\n  ((prevdata[ip]  -  2.0*prevdata[ind]  +  prevdata[im])  /  dx2  +\n  (prevdata[jp]  -  2.0*prevdata[ind]  +  prevdata[jm])  /  dy2);\n  }\n  }\n} \n```", "```\n// Main routine for heat equation solver in 2D.\n// (c) 2023 ENCCS, CSC and the contributors\n#include  <cstdio>\n#include  <omp.h>\n\n#include  \"heat.h\"\n\ndouble  start_time  ()  {  return  omp_get_wtime();  }\ndouble  stop_time  ()  {  return  omp_get_wtime();  }\n\nint  main(int  argc,  char  **argv)\n{\n  // Set up the solver\n  int  nsteps;\n  field  current,  previous;\n  initialize(argc,  argv,  &current,  &previous,  &nsteps);\n\n  // Output the initial field and its temperature\n  field_write(&current,  0);\n  double  average_temp  =  field_average(&current);\n  printf(\"Average temperature, start: %f\\n\",  average_temp);\n\n  // Set diffusivity constant\n  double  a  =  0.5;\n  // Compute the largest stable time step\n  double  dx2  =  current.dx  *  current.dx;\n  double  dy2  =  current.dy  *  current.dy;\n  double  dt  =  dx2  *  dy2  /  (2.0  *  a  *  (dx2  +  dy2));\n  // Set output interval\n  int  output_interval  =  1500;\n\n  // Start timer\n  double  start_clock  =  start_time();\n  // Time evolution\n  for  (int  iter  =  1;  iter  <=  nsteps;  iter++)  {\n evolve(&current,  &previous,  a,  dt);  if  (iter  %  output_interval  ==  0)  {\n  field_write(&current,  iter);\n  }\n  // Swap current and previous fields for next iteration step\n  field_swap(&current,  &previous);\n  }\n  // Stop timer\n  double  stop_clock  =  stop_time();\n\n  // Output the final field and its temperature\n  average_temp  =  field_average(&previous);\n  printf(\"Average temperature at end: %f\\n\",  average_temp);\n  // Compare temperature for reference\n  if  (argc  ==  1)  {\n  printf(\"Control temperature at end: 59.281239\\n\");\n  }\n  field_write(&previous,  nsteps);\n\n  // Determine the computation time used for all the iterations\n  printf(\"Iterations took %.3f seconds.\\n\",  (stop_clock  -  start_clock));\n\n  return  0;\n} \n```", "```\n// Datatype for temperature field\nstruct  field  {\n  // nx and ny are the dimensions of the field. The array data\n  // contains also ghost layers, so it will have dimensions nx+2 x ny+2\n  int  nx;\n  int  ny;\n  // Size of the grid cells\n  double  dx;\n  double  dy;\n  // The temperature values in the 2D grid\n  std::vector<double>  data;\n};\n\n// CONSTANTS\n// Fixed grid spacing\nconst  double  DX  =  0.01;\nconst  double  DY  =  0.01;\n// Default temperatures\nconst  double  T_DISC  =  5.0;\nconst  double  T_AREA  =  65.0;\nconst  double  T_UPPER  =  85.0;\nconst  double  T_LOWER  =  5.0;\nconst  double  T_LEFT  =  20.0;\nconst  double  T_RIGHT  =  70.0;\n// Default problem size\nconst  int  ROWS  =  2000;\nconst  int  COLS  =  2000;\nconst  int  NSTEPS  =  500; \n```", "```\nsalloc -A project_465002387 -p small-g -N 1 -c 8 -n 1 --gpus-per-node=1 -t 1:00:00\n\nmodule load LUMI/24.03\nmodule load partition/G\nmodule load rocm/6.0.3\nmodule load PrgEnv-cray/8.5.0\n\ncd base/\nmake all \n```", "```\n$ srun  --pty  bash\n\n$ ./stencil\n$ ./stencil_off\n$ ./stencil_data\n\n$ exit \n```", "```\n$ ./stencil\nAverage temperature, start: 59.763305\nAverage temperature at end: 59.281239\nControl temperature at end: 59.281239\nIterations took 0.566 seconds.\n$ ./stencil_off\nAverage temperature, start: 59.763305\nAverage temperature at end: 59.281239\nControl temperature at end: 59.281239\nIterations took 3.792 seconds.\n$ ./stencil_data\nAverage temperature, start: 59.763305\nAverage temperature at end: 59.281239\nControl temperature at end: 59.281239\nIterations took 1.211 seconds.\n$ \n```", "```\n// (c) 2023 ENCCS, CSC and the contributors\n#include  \"heat.h\"\n\n// Update the temperature values using five-point stencil\n// Arguments:\n//   curr: current temperature values\n//   prev: temperature values from previous time step\n//   a: diffusivity\n//   dt: time step\nvoid  evolve(field  *curr,  field  *prev,  double  a,  double  dt)\n{\n  // Help the compiler avoid being confused by the structs\n  double  *currdata  =  curr->data.data();\n  double  *prevdata  =  prev->data.data();\n  int  nx  =  prev->nx;\n  int  ny  =  prev->ny;\n\n  // Determine the temperature field at next time step\n  // As we have fixed boundary conditions, the outermost gridpoints\n  // are not updated.\n  double  dx2  =  prev->dx  *  prev->dx;\n  double  dy2  =  prev->dy  *  prev->dy;\n\n  // Offload value update to GPU target (fallback to CPU is possible)\n #pragma omp target teams distribute parallel for \\ map(currdata[0:(nx+2)*(ny+2)],prevdata[0:(nx+2)*(ny+2)])  for  (int  i  =  1;  i  <  nx  +  1;  i++)  {\n  for  (int  j  =  1;  j  <  ny  +  1;  j++)  {\n  int  ind  =  i  *  (ny  +  2)  +  j;\n  int  ip  =  (i  +  1)  *  (ny  +  2)  +  j;\n  int  im  =  (i  -  1)  *  (ny  +  2)  +  j;\n  int  jp  =  i  *  (ny  +  2)  +  j  +  1;\n  int  jm  =  i  *  (ny  +  2)  +  j  -  1;\n  currdata[ind]  =  prevdata[ind]  +  a*dt*\n  ((prevdata[ip]  -  2.0*prevdata[ind]  +  prevdata[im])  /  dx2  +\n  (prevdata[jp]  -  2.0*prevdata[ind]  +  prevdata[jm])  /  dy2);\n  }\n  }\n} \n```", "```\n// (c) 2023 ENCCS, CSC and the contributors\n#include  \"heat.h\"\n#include  <sycl/sycl.hpp>\n\n// Update the temperature values using five-point stencil\n// Arguments:\n//   queue: SYCL queue\n//   curr: current temperature values\n//   prev: temperature values from previous time step\n//   a: diffusivity\n//   dt: time step\nvoid  evolve(sycl::queue  &Q,  field  *curr,  field  *prev,  double  a,  double  dt)  {\n  // Help the compiler avoid being confused by the structs\n  int  nx  =  prev->nx;\n  int  ny  =  prev->ny;\n  int  size  =  (nx  +  2)  *  (ny  +  2);\n\n  // Determine the temperature field at next time step\n  // As we have fixed boundary conditions, the outermost gridpoints\n  // are not updated.\n  double  dx2  =  prev->dx  *  prev->dx;\n  double  dy2  =  prev->dy  *  prev->dy;\n\n double  *currdata  =  sycl::malloc_device<double>(size,  Q); double  *prevdata  =  sycl::malloc_device<double>(size,  Q); Q.copy<double>(curr->data.data(),  currdata,  size); Q.copy<double>(prev->data.data(),  prevdata,  size); \n Q.parallel_for(sycl::range<2>(nx,  ny),  [=](sycl::id<2>  id)  {  auto  i  =  id[0]  +  1;\n  auto  j  =  id[1]  +  1;\n\n  int  ind  =  i  *  (ny  +  2)  +  j;\n  int  ip  =  (i  +  1)  *  (ny  +  2)  +  j;\n  int  im  =  (i  -  1)  *  (ny  +  2)  +  j;\n  int  jp  =  i  *  (ny  +  2)  +  j  +  1;\n  int  jm  =  i  *  (ny  +  2)  +  j  -  1;\n  currdata[ind]  =  prevdata[ind]  +  a*dt*\n  ((prevdata[ip]  -  2.0*prevdata[ind]  +  prevdata[im])  /  dx2  +\n  (prevdata[jp]  -  2.0*prevdata[ind]  +  prevdata[jm])  /  dy2);\n  });\n\n Q.copy<double>(currdata,  curr->data.data(),  size).wait(); sycl::free(currdata,  Q); sycl::free(prevdata,  Q); } \n```", "```\n# salloc  -A  project_465002387  -p  small-g  -N  1  -c  8  -n  1  --gpus-per-node=1  -t  1:00:00\n\nmodule load LUMI/24.03\nmodule load partition/G\nmodule load rocm/6.0.3\nmodule use  /appl/local/csc/modulefiles\nmodule load acpp/24.06.0 \n```", "```\n$ cd  ../sycl/\n(give the following lines some time, probably a couple of min)\n$ acpp  -O2  -o  stencil_naive  core-naive.cpp  io.cpp  main-naive.cpp  pngwriter.c  setup.cpp  utilities.cpp\n$ acpp  -O2  -o  stencil_data  core.cpp  io.cpp  main.cpp  pngwriter.c  setup.cpp  utilities.cpp\n\n$ srun  stencil_naive\n$ srun  stencil_data \n```", "```\n$ srun  stencil_naive\nAverage temperature, start: 59.763305\nAverage temperature at end: 59.281239\nControl temperature at end: 59.281239\nIterations took 2.086 seconds.\n$ srun  stencil_data\nAverage temperature, start: 59.763305\nAverage temperature at end: 59.281239\nControl temperature at end: 59.281239\nIterations took 0.052 seconds. \n```", "```\n// (c) 2023 ENCCS, CSC and the contributors\n#include  \"heat.h\"\n\n// Update the temperature values using five-point stencil\n// Arguments:\n//   curr: current temperature values\n//   prev: temperature values from previous time step\n//   a: diffusivity\n//   dt: time step\nvoid  evolve(field  *curr,  field  *prev,  double  a,  double  dt)\n{\n  // Help the compiler avoid being confused by the structs\n  double  *currdata  =  curr->data.data();\n  double  *prevdata  =  prev->data.data();\n  int  nx  =  prev->nx;\n  int  ny  =  prev->ny;\n\n  // Determine the temperature field at next time step\n  // As we have fixed boundary conditions, the outermost gridpoints\n  // are not updated.\n  double  dx2  =  prev->dx  *  prev->dx;\n  double  dy2  =  prev->dy  *  prev->dy;\n\n  // Offload value update to GPU target (fallback to CPU is possible)\n #pragma omp target teams distribute parallel for  for  (int  i  =  1;  i  <  nx  +  1;  i++)  {\n  for  (int  j  =  1;  j  <  ny  +  1;  j++)  {\n  int  ind  =  i  *  (ny  +  2)  +  j;\n  int  ip  =  (i  +  1)  *  (ny  +  2)  +  j;\n  int  im  =  (i  -  1)  *  (ny  +  2)  +  j;\n  int  jp  =  i  *  (ny  +  2)  +  j  +  1;\n  int  jm  =  i  *  (ny  +  2)  +  j  -  1;\n  currdata[ind]  =  prevdata[ind]  +  a*dt*\n  ((prevdata[ip]  -  2.0*prevdata[ind]  +  prevdata[im])  /  dx2  +\n  (prevdata[jp]  -  2.0*prevdata[ind]  +  prevdata[jm])  /  dy2);\n  }\n  }\n}\n\n// Start a data region and copy temperature fields to the device void  enter_data(field  *curr,  field  *prev) {\n double  *currdata  =  curr->data.data(); double  *prevdata  =  prev->data.data(); int  nx  =  prev->nx; int  ny  =  prev->ny;   // adding data mapping here #pragma omp target enter data \\ map(to: currdata[0:(nx+2)*(ny+2)], prevdata[0:(nx+2)*(ny+2)]) }   // End a data region and copy temperature fields back to the host void  exit_data(field  *curr,  field  *prev) {\n double  *currdata  =  curr->data.data(); double  *prevdata  =  prev->data.data(); int  nx  =  prev->nx; int  ny  =  prev->ny;   // adding data mapping here #pragma omp target exit data \\ map(from: currdata[0:(nx+2)*(ny+2)], prevdata[0:(nx+2)*(ny+2)]) }   // Copy a temperature field from the device to the host void  update_host(field  *heat) {\n double  *data  =  heat->data.data(); int  nx  =  heat->nx; int  ny  =  heat->ny;   // adding data mapping here #pragma omp target update from(data[0:(nx+2)*(ny+2)]) } \n```", "```\n// (c) 2023 ENCCS, CSC and the contributors\n#include  \"heat.h\"\n#include  <sycl/sycl.hpp>\n\n// Update the temperature values using five-point stencil\n// Arguments:\n//   queue: SYCL queue\n//   currdata: current temperature values (device pointer)\n//   prevdata: temperature values from previous time step (device pointer)\n//   prev: description of the grid parameters\n//   a: diffusivity\n//   dt: time step\nvoid  evolve(sycl::queue  &Q,  double*  currdata,  const  double*  prevdata,\n const  field  *prev,  double  a,  double  dt) {\n  int  nx  =  prev->nx;\n  int  ny  =  prev->ny;\n\n  // Determine the temperature field at next time step\n  // As we have fixed boundary conditions, the outermost gridpoints\n  // are not updated.\n  double  dx2  =  prev->dx  *  prev->dx;\n  double  dy2  =  prev->dy  *  prev->dy;\n\n Q.parallel_for(sycl::range<2>(nx,  ny),  [=](sycl::id<2>  id)  {  auto  i  =  id[0]  +  1;\n  auto  j  =  id[1]  +  1;\n\n  int  ind  =  i  *  (ny  +  2)  +  j;\n  int  ip  =  (i  +  1)  *  (ny  +  2)  +  j;\n  int  im  =  (i  -  1)  *  (ny  +  2)  +  j;\n  int  jp  =  i  *  (ny  +  2)  +  j  +  1;\n  int  jm  =  i  *  (ny  +  2)  +  j  -  1;\n  currdata[ind]  =  prevdata[ind]  +  a*dt*\n  ((prevdata[ip]  -  2.0*prevdata[ind]  +  prevdata[im])  /  dx2  +\n  (prevdata[jp]  -  2.0*prevdata[ind]  +  prevdata[jm])  /  dy2);\n  });\n}\n\nvoid  copy_to_buffer(sycl::queue  Q,  double*  buffer,  const  field*  f) {\n int  size  =  (f->nx  +  2)  *  (f->ny  +  2); Q.copy<double>(f->data.data(),  buffer,  size); }   void  copy_from_buffer(sycl::queue  Q,  const  double*  buffer,  field  *f) {\n int  size  =  (f->nx  +  2)  *  (f->ny  +  2); Q.copy<double>(buffer,  f->data.data(),  size).wait(); } \n```", "```\nfrom  numba  import jit\n\n# Update the temperature values using five-point stencil\n# Arguments:\n#   curr: current temperature field object\n#   prev: temperature field from previous time step\n#   a: diffusivity\n#   dt: time step\ndef  evolve(current, previous, a, dt):\n    dx2, dy2 = previous.dx**2, previous.dy**2\n    curr, prev = current.data, previous.data\n    # Run (possibly accelerated) update\n    _evolve(curr, prev, a, dt, dx2, dy2)\n\n@jit(nopython=True) def  _evolve(curr, prev, a, dt, dx2, dy2):\n    nx, ny = prev.shape # These are the FULL dims, rows+2 / cols+2\n    for i in range(1, nx-1):\n        for j in range(1, ny-1):\n            curr[i, j] = prev[i, j] + a * dt * ( \\\n              (prev[i+1, j] - 2*prev[i, j] + prev[i-1, j]) / dx2 + \\\n              (prev[i, j+1] - 2*prev[i, j] + prev[i, j-1]) / dy2 ) \n```", "```\n@jit(nopython=True) def  _generate(data, nx, ny):\n    # Radius of the source disc\n    radius = nx / 6.0\n    for i in range(nx+2):\n        for j in range(ny+2):\n            # Distance of point i, j from the origin\n            dx = i - nx / 2 + 1\n            dy = j - ny / 2 + 1\n            if (dx * dx + dy * dy < radius * radius):\n                data[i,j] = T_DISC\n            else:\n                data[i,j] = T_AREA\n\n    # Boundary conditions\n    for i in range(nx+2):\n        data[i,0] = T_LEFT\n        data[i, ny+1] = T_RIGHT\n\n    for j in range(ny+2):\n        data[0,j] = T_UPPER\n        data[nx+1, j] = T_LOWER \n```", "```\nimport  math\nfrom  numba  import cuda\n\n# Update the temperature values using five-point stencil\n# Arguments:\n#   curr: current temperature field object\n#   prev: temperature field from previous time step\n#   a: diffusivity\n#   dt: time step\ndef  evolve(current, previous, a, dt):\n    dx2, dy2 = previous.dx**2, previous.dy**2\n    curr, prev = current.dev, previous.dev\n    # Set thread and block sizes\n nx, ny = prev.shape # These are the FULL dims, rows+2 / cols+2 tx, ty = (16, 16)   # Arbitrary choice bx, by = math.ceil(nx / tx), math.ceil(ny / ty)    # Run numba (CUDA) kernel\n _evolve_kernel[(bx, by), (tx, ty)](curr, prev, a, dt, dx2, dy2) \n\n@cuda.jit()\ndef  _evolve_kernel(curr, prev, a, dt, dx2, dy2):\n    nx, ny = prev.shape # These are the FULL dims, rows+2 / cols+2\n    i, j = cuda.grid(2)\n    if ((i >= 1) and (i < nx-1) \n        and (j >= 1) and (j < ny-1)):\n        curr[i, j] = prev[i, j] + a * dt * ( \\\n            (prev[i+1, j] - 2*prev[i, j] + prev[i-1, j]) / dx2 + \\\n            (prev[i, j+1] - 2*prev[i, j] + prev[i, j-1]) / dy2 ) \n```", "```\n$ # skip the git clone step, if you have done that already\n$ git  clone  https://github.com/ENCCS/gpu-programming.git\n$ # allocate a GPU node using `salloc`\n$ # execute the `srun --pty singularity exec ...` command\nSingularity> cd /work/gpu-programming/content/examples/stencil/python-numba\nSingularity> . /.venv/bin/activate\nSingularity> python3 main.py \n```", "```\n$ git  clone  https://github.com/ENCCS/gpu-programming.git\n$ cd  gpu-programming/content/examples/stencil/python-numba\n$ # make sure you have active allocation\n$ srun  python3  main.py \n```", "```\n$ # interactive CPU node\n$ srun  --account=project_465002387  --partition=standard  --nodes=1  --cpus-per-task=32  --ntasks-per-node=1  --time=01:00:00  --pty  bash\n$ # load Julia env\n$ module  purge\n$ module  use  /appl/local/csc/modulefiles\n$ module  load  julia\n$ module  load  julia-amdgpu\n$ # in directory with Project.toml and source files, instantiate an environment to install packages\n$ julia  --project  -e  \"using Pkg ; Pkg.instantiate()\"\n$ # finally run\n$ julia  --project  main.jl \n```", "```\n$ srun  --account=project_465002387  --partition=standard-g  --nodes=1  --cpus-per-task=1  --ntasks-per-node=1  --gpus-per-node=1  --time=1:00:00  --pty  bash \n```", "```\n#using Plots\nusing  BenchmarkTools\n\ninclude(\"heat.jl\")\ninclude(\"core.jl\")\n\n\"\"\"\n visualize(curr::Field, filename=:none)\n\nCreate a heatmap of a temperature field. Optionally write png file. \n\"\"\"  \nfunction  visualize(curr::Field,  filename=:none)\n  background_color  =  :white\n  plot  =  heatmap(\n  curr.data,\n  colorbar_title  =  \"Temperature (C)\",\n  background_color  =  background_color\n  )\n\n  if  filename  !=  :none\n  savefig(filename)\n  else\n  display(plot)\n  end\nend\n\nncols,  nrows  =  2048,  2048\nnsteps  =  500\n\n# initialize current and previous states to the same state\ncurr,  prev  =  initialize(ncols,  nrows)\n\n# visualize initial field, requires Plots.jl\n#visualize(curr, \"initial.png\")\n\n# simulate temperature evolution for nsteps\nsimulate!(curr,  prev,  nsteps)\n\n# visualize final field, requires Plots.jl\n#visualize(curr, \"final.png\") \n```", "```\nusing  ProgressMeter\n\n\"\"\"\n evolve!(curr::Field, prev::Field, a, dt)\n\nCalculate a new temperature field curr based on the previous \nfield prev. a is the diffusion constant and dt is the largest \nstable time step. \n\"\"\"\nfunction  evolve!(curr::Field,  prev::Field,  a,  dt)\n  Threads.@threads  for  j  =  2:curr.ny+1\n  for  i  =  2:curr.nx+1\n  @inbounds  xderiv  =  (prev.data[i-1,  j]  -  2.0  *  prev.data[i,  j]  +  prev.data[i+1,  j])  /  curr.dx^2\n  @inbounds  yderiv  =  (prev.data[i,  j-1]  -  2.0  *  prev.data[i,  j]  +  prev.data[i,  j+1])  /  curr.dy^2\n  @inbounds  curr.data[i,  j]  =  prev.data[i,  j]  +  a  *  dt  *  (xderiv  +  yderiv)\n  end  \n  end\nend\n\n\"\"\"\n swap_fields!(curr::Field, prev::Field)\n\nSwap the data of two fields curr and prev. \n\"\"\"  \nfunction  swap_fields!(curr::Field,  prev::Field)\n  tmp  =  curr.data\n  curr.data  =  prev.data\n  prev.data  =  tmp\nend\n\n\"\"\" \n average_temperature(f::Field)\n\nCalculate average temperature of a temperature field. \n\"\"\"\naverage_temperature(f::Field)  =  sum(f.data[2:f.nx+1,  2:f.ny+1])  /  (f.nx  *  f.ny)\n\n\"\"\"\n simulate!(current, previous, nsteps)\n\nRun the heat equation solver on fields curr and prev for nsteps.\n\"\"\"\nfunction  simulate!(curr::Field,  prev::Field,  nsteps)\n\n  println(\"Initial average temperature: $(average_temperature(curr))\")\n\n  # Diffusion constant\n  a  =  0.5\n  # Largest stable time step\n  dt  =  curr.dx^2  *  curr.dy^2  /  (2.0  *  a  *  (curr.dx^2  +  curr.dy^2))\n\n  # display a nice progress bar\n  p  =  Progress(nsteps)\n\n  for  i  =  1:nsteps\n  # calculate new state based on previous state\n  evolve!(curr,  prev,  a,  dt)\n\n  # swap current and previous fields\n  swap_fields!(curr,  prev)\n\n  # increment the progress bar\n  next!(p)\n  end  \n\n  # print final average temperature\n  println(\"Final average temperature: $(average_temperature(curr))\")\nend \n```", "```\n# Fixed grid spacing\nconst  DX  =  0.01\nconst  DY  =  0.01\n# Default temperatures\nconst  T_DISC  =  5.0\nconst  T_AREA  =  65.0\nconst  T_UPPER  =  85.0\nconst  T_LOWER  =  5.0\nconst  T_LEFT  =  20.0\nconst  T_RIGHT  =  70.0\n# Default problem size\nconst  ROWS  =  2000\nconst  COLS  =  2000\nconst  NSTEPS  =  500\n\n\"\"\"\n Field(nx::Int64, ny::Int64, dx::Float64, dy::Float64, data::Matrix{Float64})\n\nTemperature field type. nx and ny are the dimensions of the field. \nThe array data contains also ghost layers, so it will have dimensions \n[nx+2, ny+2]\n\"\"\"\nmutable  struct Field{T<:AbstractArray}\n  nx::Int64\n  ny::Int64\n  # Size of the grid cells\n  dx::Float64\n  dy::Float64\n  # The temperature values in the 2D grid\n  data::T\nend\n\n# outer constructor with default cell sizes and initialized data\nField(nx::Int64,  ny::Int64,  data)  =  Field{typeof(data)}(nx,  ny,  0.01,  0.01,  data)\n\n# extend deepcopy to new type\nBase.deepcopy(f::Field)  =  Field(f.nx,  f.ny,  f.dx,  f.dy,  deepcopy(f.data))\n\n\"\"\"\n initialize(rows::Int, cols::Int, arraytype = Matrix)\n\nInitialize two temperature field with (nrows, ncols) number of \nrows and columns. If the arraytype is something else than Matrix,\ncreate data on the CPU first to avoid scalar indexing errors.\n\"\"\"\nfunction  initialize(nrows  =  1000,  ncols  =  1000,  arraytype  =  Matrix)\n  data  =  zeros(nrows+2,  ncols+2)\n\n  # generate a field with boundary conditions\n  if  arraytype  !=  Matrix\n  tmp  =  Field(nrows,  ncols,  data)\n  generate_field!(tmp)\n  gpudata  =  arraytype(tmp.data)\n  previous  =  Field(nrows,  ncols,  gpudata)\n  else\n  previous  =  Field(nrows,  ncols,  data)\n  generate_field!(previous)\n  end\n\n  current  =  Base.deepcopy(previous)\n\n  return  previous,  current\nend\n\n\"\"\"\n generate_field!(field0::Field)\n\nGenerate a temperature field.  Pattern is disc with a radius\nof nx / 6 in the center of the grid. Boundary conditions are \n(different) constant temperatures outside the grid.\n\"\"\"\nfunction  generate_field!(field::Field)\n  # Square of the disk radius\n  radius2  =  (field.nx  /  6.0)^2\n\n  for  j  =  1:field.ny+2\n  for  i  =  1:field.nx+2\n  ds2  =  (i  -  field.nx  /  2)^2  +  (j  -  field.ny  /  2)^2\n  if  ds2  <  radius2  \n  field.data[i,j]  =  T_DISC\n  else\n  field.data[i,j]  =  T_AREA\n  end\n  end  \n  end  \n\n  # Boundary conditions\n  field.data[:,1]  .=  T_LEFT\n  field.data[:,field.ny+2]  .=  T_RIGHT\n  field.data[1,:]  .=  T_UPPER\n  field.data[field.nx+2,:]  .=  T_LOWER\nend \n```", "```\n[deps]\nBenchmarkTools  =  \"6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf\"\n#Plots = \"91a5bcdd-55d7-5caf-9e0b-520d859cae80\"\nProgressMeter  =  \"92933f4c-e287-5a05-a399-4b506db050ca\" \n```", "```\n#using Plots\nusing  BenchmarkTools\nusing  AMDGPU\n\ninclude(\"heat.jl\")\ninclude(\"core_gpu.jl\")\n\n\"\"\"\n visualize(curr::Field, filename=:none)\n\nCreate a heatmap of a temperature field. Optionally write png file. \n\"\"\"  \nfunction  visualize(curr::Field,  filename=:none)\n  background_color  =  :white\n  plot  =  heatmap(\n  curr.data,\n  colorbar_title  =  \"Temperature (C)\",\n  background_color  =  background_color\n  )\n\n  if  filename  !=  :none\n  savefig(filename)\n  else\n  display(plot)\n  end\nend\n\nncols,  nrows  =  2048,  2048\nnsteps  =  500\n\n# initialize data on CPU\ncurr,  prev  =  initialize(ncols,  nrows,  ROCArray)\n# initialize data on CPU\n#curr, prev = initialize(ncols, nrows)\n\n# visualize initial field, requires Plots.jl\n#visualize(curr, \"initial.png\")\n\n# simulate temperature evolution for nsteps\n@btime  simulate!(curr,  prev,  nsteps)\n\n# visualize final field, requires Plots.jl\n#visualize(curr, \"final.png\") \n```", "```\nusing  ProgressMeter\n\n\"\"\"\n evolve!(curr::Field, prev::Field, a, dt)\n\nCalculate a new temperature field curr based on the previous \nfield prev. a is the diffusion constant and dt is the largest \nstable time step. \n\"\"\"\nfunction  evolve!(curr::Field,  prev::Field,  a,  dt)\n  Threads.@threads  for  j  =  2:curr.ny+1\n  for  i  =  2:curr.nx+1\n  @inbounds  xderiv  =  (prev.data[i-1,  j]  -  2.0  *  prev.data[i,  j]  +  prev.data[i+1,  j])  /  curr.dx^2\n  @inbounds  yderiv  =  (prev.data[i,  j-1]  -  2.0  *  prev.data[i,  j]  +  prev.data[i,  j+1])  /  curr.dy^2\n  @inbounds  curr.data[i,  j]  =  prev.data[i,  j]  +  a  *  dt  *  (xderiv  +  yderiv)\n  end  \n  end\nend\n\nfunction  evolve_cuda!(currdata,  prevdata,  dx2,  dy2,  nx,  ny,  a,  dt)\n  i  =  (blockIdx().x  -  1)  *  blockDim().x  +  threadIdx().x\n  j  =  (blockIdx().y  -  1)  *  blockDim().y  +  threadIdx().y\n  if  i  >  1  &&  j  >  1  &&  i  <  nx+2  &&  j  <  ny+2\n  @inbounds  xderiv  =  (prevdata[i-1,  j]  -  2.0  *  prevdata[i,  j]  +  prevdata[i+1,  j])  /  dx2\n  @inbounds  yderiv  =  (prevdata[i,  j-1]  -  2.0  *  prevdata[i,  j]  +  prevdata[i,  j+1])  /  dy2\n  @inbounds  currdata[i,  j]  =  prevdata[i,  j]  +  a  *  dt  *  (xderiv  +  yderiv)\n  end\n  return\nend\n\nfunction  evolve_rocm!(currdata,  prevdata,  dx2,  dy2,  nx,  ny,  a,  dt)\n  i  =  (workgroupIdx().x  -  1)  *  workgroupDim().x  +  workitemIdx().x\n  j  =  (workgroupIdx().y  -  1)  *  workgroupDim().y  +  workitemIdx().y\n  if  i  >  1  &&  j  >  1  &&  i  <  nx+2  &&  j  <  ny+2\n  @inbounds  xderiv  =  (prevdata[i-1,  j]  -  2.0  *  prevdata[i,  j]  +  prevdata[i+1,  j])  /  dx2\n  @inbounds  yderiv  =  (prevdata[i,  j-1]  -  2.0  *  prevdata[i,  j]  +  prevdata[i,  j+1])  /  dy2\n  @inbounds  currdata[i,  j]  =  prevdata[i,  j]  +  a  *  dt  *  (xderiv  +  yderiv)\n  end\n  return\nend\n\n\"\"\"\n swap_fields!(curr::Field, prev::Field)\n\nSwap the data of two fields curr and prev. \n\"\"\"  \nfunction  swap_fields!(curr::Field,  prev::Field)\n  tmp  =  curr.data\n  curr.data  =  prev.data\n  prev.data  =  tmp\nend\n\n\"\"\" \n average_temperature(f::Field)\n\nCalculate average temperature of a temperature field. \n\"\"\"\naverage_temperature(f::Field)  =  sum(f.data[2:f.nx+1,  2:f.ny+1])  /  (f.nx  *  f.ny)\n\n\"\"\"\n simulate!(current, previous, nsteps)\n\nRun the heat equation solver on fields curr and prev for nsteps.\n\"\"\"\nfunction  simulate!(curr::Field,  prev::Field,  nsteps)\n\n  println(\"Initial average temperature: $(average_temperature(curr))\")\n\n  # Diffusion constant\n  a  =  0.5\n  # Largest stable time step\n  dt  =  curr.dx^2  *  curr.dy^2  /  (2.0  *  a  *  (curr.dx^2  +  curr.dy^2))\n\n  # display a nice progress bar\n  p  =  Progress(nsteps)\n\n  for  i  =  1:nsteps\n  # calculate new state based on previous state\n  if  typeof(curr.data)  <:  ROCArray\n  nx,  ny  =  size(curr.data)  .-  2  \n  xthreads  =  ythreads  =  16\n  xblocks,  yblocks  =  cld(curr.nx,  xthreads),  cld(curr.ny,  ythreads)\n  @roc  groupsize=(xthreads,  ythreads)  gridsize  =  (xblocks,  yblocks)  evolve_rocm!(curr.data,  prev.data,  curr.dx^2,  curr.dy^2,  nx,  ny,  a,  dt)\n  else\n  evolve!(curr,  prev,  a,  dt)\n  end\n\n  # swap current and previous fields\n  swap_fields!(curr,  prev)\n\n  # increment the progress bar\n  next!(p)\n  end  \n\n  # print final average temperature\n  println(\"Final average temperature: $(average_temperature(curr))\")\nend \n```", "```\n$ git  clone  https://github.com/ENCCS/gpu-programming.git\n$ cd  gpu-programming/content/examples/stencil/\n$ ls \n```", "```\n// (c) 2023 ENCCS, CSC and the contributors\n#include  \"heat.h\"\n\n// Update the temperature values using five-point stencil\n// Arguments:\n//   curr: current temperature values\n//   prev: temperature values from previous time step\n//   a: diffusivity\n//   dt: time step\nvoid  evolve(field  *curr,  field  *prev,  double  a,  double  dt)\n{\n  // Help the compiler avoid being confused by the structs\n  double  *currdata  =  curr->data.data();\n  double  *prevdata  =  prev->data.data();\n  int  nx  =  prev->nx;\n  int  ny  =  prev->ny;\n\n  // Determine the temperature field at next time step\n  // As we have fixed boundary conditions, the outermost gridpoints\n  // are not updated.\n  double  dx2  =  prev->dx  *  prev->dx;\n  double  dy2  =  prev->dy  *  prev->dy;\n\n  // Use OpenMP threads for parallel update of grid values\n #pragma omp parallel for  for  (int  i  =  1;  i  <  nx  +  1;  i++)  {\n  for  (int  j  =  1;  j  <  ny  +  1;  j++)  {\n  int  ind  =  i  *  (ny  +  2)  +  j;\n  int  ip  =  (i  +  1)  *  (ny  +  2)  +  j;\n  int  im  =  (i  -  1)  *  (ny  +  2)  +  j;\n  int  jp  =  i  *  (ny  +  2)  +  j  +  1;\n  int  jm  =  i  *  (ny  +  2)  +  j  -  1;\n  currdata[ind]  =  prevdata[ind]  +  a*dt*\n  ((prevdata[ip]  -  2.0*prevdata[ind]  +  prevdata[im])  /  dx2  +\n  (prevdata[jp]  -  2.0*prevdata[ind]  +  prevdata[jm])  /  dy2);\n  }\n  }\n} \n```", "```\n// Main routine for heat equation solver in 2D.\n// (c) 2023 ENCCS, CSC and the contributors\n#include  <cstdio>\n#include  <omp.h>\n\n#include  \"heat.h\"\n\ndouble  start_time  ()  {  return  omp_get_wtime();  }\ndouble  stop_time  ()  {  return  omp_get_wtime();  }\n\nint  main(int  argc,  char  **argv)\n{\n  // Set up the solver\n  int  nsteps;\n  field  current,  previous;\n  initialize(argc,  argv,  &current,  &previous,  &nsteps);\n\n  // Output the initial field and its temperature\n  field_write(&current,  0);\n  double  average_temp  =  field_average(&current);\n  printf(\"Average temperature, start: %f\\n\",  average_temp);\n\n  // Set diffusivity constant\n  double  a  =  0.5;\n  // Compute the largest stable time step\n  double  dx2  =  current.dx  *  current.dx;\n  double  dy2  =  current.dy  *  current.dy;\n  double  dt  =  dx2  *  dy2  /  (2.0  *  a  *  (dx2  +  dy2));\n  // Set output interval\n  int  output_interval  =  1500;\n\n  // Start timer\n  double  start_clock  =  start_time();\n  // Time evolution\n  for  (int  iter  =  1;  iter  <=  nsteps;  iter++)  {\n evolve(&current,  &previous,  a,  dt);  if  (iter  %  output_interval  ==  0)  {\n  field_write(&current,  iter);\n  }\n  // Swap current and previous fields for next iteration step\n  field_swap(&current,  &previous);\n  }\n  // Stop timer\n  double  stop_clock  =  stop_time();\n\n  // Output the final field and its temperature\n  average_temp  =  field_average(&previous);\n  printf(\"Average temperature at end: %f\\n\",  average_temp);\n  // Compare temperature for reference\n  if  (argc  ==  1)  {\n  printf(\"Control temperature at end: 59.281239\\n\");\n  }\n  field_write(&previous,  nsteps);\n\n  // Determine the computation time used for all the iterations\n  printf(\"Iterations took %.3f seconds.\\n\",  (stop_clock  -  start_clock));\n\n  return  0;\n} \n```", "```\n// Datatype for temperature field\nstruct  field  {\n  // nx and ny are the dimensions of the field. The array data\n  // contains also ghost layers, so it will have dimensions nx+2 x ny+2\n  int  nx;\n  int  ny;\n  // Size of the grid cells\n  double  dx;\n  double  dy;\n  // The temperature values in the 2D grid\n  std::vector<double>  data;\n};\n\n// CONSTANTS\n// Fixed grid spacing\nconst  double  DX  =  0.01;\nconst  double  DY  =  0.01;\n// Default temperatures\nconst  double  T_DISC  =  5.0;\nconst  double  T_AREA  =  65.0;\nconst  double  T_UPPER  =  85.0;\nconst  double  T_LOWER  =  5.0;\nconst  double  T_LEFT  =  20.0;\nconst  double  T_RIGHT  =  70.0;\n// Default problem size\nconst  int  ROWS  =  2000;\nconst  int  COLS  =  2000;\nconst  int  NSTEPS  =  500; \n```", "```\nsalloc -A project_465002387 -p small-g -N 1 -c 8 -n 1 --gpus-per-node=1 -t 1:00:00\n\nmodule load LUMI/24.03\nmodule load partition/G\nmodule load rocm/6.0.3\nmodule load PrgEnv-cray/8.5.0\n\ncd base/\nmake all \n```", "```\n$ srun  --pty  bash\n\n$ ./stencil\n$ ./stencil_off\n$ ./stencil_data\n\n$ exit \n```", "```\n$ ./stencil\nAverage temperature, start: 59.763305\nAverage temperature at end: 59.281239\nControl temperature at end: 59.281239\nIterations took 0.566 seconds.\n$ ./stencil_off\nAverage temperature, start: 59.763305\nAverage temperature at end: 59.281239\nControl temperature at end: 59.281239\nIterations took 3.792 seconds.\n$ ./stencil_data\nAverage temperature, start: 59.763305\nAverage temperature at end: 59.281239\nControl temperature at end: 59.281239\nIterations took 1.211 seconds.\n$ \n```", "```\n// (c) 2023 ENCCS, CSC and the contributors\n#include  \"heat.h\"\n\n// Update the temperature values using five-point stencil\n// Arguments:\n//   curr: current temperature values\n//   prev: temperature values from previous time step\n//   a: diffusivity\n//   dt: time step\nvoid  evolve(field  *curr,  field  *prev,  double  a,  double  dt)\n{\n  // Help the compiler avoid being confused by the structs\n  double  *currdata  =  curr->data.data();\n  double  *prevdata  =  prev->data.data();\n  int  nx  =  prev->nx;\n  int  ny  =  prev->ny;\n\n  // Determine the temperature field at next time step\n  // As we have fixed boundary conditions, the outermost gridpoints\n  // are not updated.\n  double  dx2  =  prev->dx  *  prev->dx;\n  double  dy2  =  prev->dy  *  prev->dy;\n\n  // Offload value update to GPU target (fallback to CPU is possible)\n #pragma omp target teams distribute parallel for \\ map(currdata[0:(nx+2)*(ny+2)],prevdata[0:(nx+2)*(ny+2)])  for  (int  i  =  1;  i  <  nx  +  1;  i++)  {\n  for  (int  j  =  1;  j  <  ny  +  1;  j++)  {\n  int  ind  =  i  *  (ny  +  2)  +  j;\n  int  ip  =  (i  +  1)  *  (ny  +  2)  +  j;\n  int  im  =  (i  -  1)  *  (ny  +  2)  +  j;\n  int  jp  =  i  *  (ny  +  2)  +  j  +  1;\n  int  jm  =  i  *  (ny  +  2)  +  j  -  1;\n  currdata[ind]  =  prevdata[ind]  +  a*dt*\n  ((prevdata[ip]  -  2.0*prevdata[ind]  +  prevdata[im])  /  dx2  +\n  (prevdata[jp]  -  2.0*prevdata[ind]  +  prevdata[jm])  /  dy2);\n  }\n  }\n} \n```", "```\n// (c) 2023 ENCCS, CSC and the contributors\n#include  \"heat.h\"\n#include  <sycl/sycl.hpp>\n\n// Update the temperature values using five-point stencil\n// Arguments:\n//   queue: SYCL queue\n//   curr: current temperature values\n//   prev: temperature values from previous time step\n//   a: diffusivity\n//   dt: time step\nvoid  evolve(sycl::queue  &Q,  field  *curr,  field  *prev,  double  a,  double  dt)  {\n  // Help the compiler avoid being confused by the structs\n  int  nx  =  prev->nx;\n  int  ny  =  prev->ny;\n  int  size  =  (nx  +  2)  *  (ny  +  2);\n\n  // Determine the temperature field at next time step\n  // As we have fixed boundary conditions, the outermost gridpoints\n  // are not updated.\n  double  dx2  =  prev->dx  *  prev->dx;\n  double  dy2  =  prev->dy  *  prev->dy;\n\n double  *currdata  =  sycl::malloc_device<double>(size,  Q); double  *prevdata  =  sycl::malloc_device<double>(size,  Q); Q.copy<double>(curr->data.data(),  currdata,  size); Q.copy<double>(prev->data.data(),  prevdata,  size); \n Q.parallel_for(sycl::range<2>(nx,  ny),  [=](sycl::id<2>  id)  {  auto  i  =  id[0]  +  1;\n  auto  j  =  id[1]  +  1;\n\n  int  ind  =  i  *  (ny  +  2)  +  j;\n  int  ip  =  (i  +  1)  *  (ny  +  2)  +  j;\n  int  im  =  (i  -  1)  *  (ny  +  2)  +  j;\n  int  jp  =  i  *  (ny  +  2)  +  j  +  1;\n  int  jm  =  i  *  (ny  +  2)  +  j  -  1;\n  currdata[ind]  =  prevdata[ind]  +  a*dt*\n  ((prevdata[ip]  -  2.0*prevdata[ind]  +  prevdata[im])  /  dx2  +\n  (prevdata[jp]  -  2.0*prevdata[ind]  +  prevdata[jm])  /  dy2);\n  });\n\n Q.copy<double>(currdata,  curr->data.data(),  size).wait(); sycl::free(currdata,  Q); sycl::free(prevdata,  Q); } \n```", "```\n# salloc  -A  project_465002387  -p  small-g  -N  1  -c  8  -n  1  --gpus-per-node=1  -t  1:00:00\n\nmodule load LUMI/24.03\nmodule load partition/G\nmodule load rocm/6.0.3\nmodule use  /appl/local/csc/modulefiles\nmodule load acpp/24.06.0 \n```", "```\n$ cd  ../sycl/\n(give the following lines some time, probably a couple of min)\n$ acpp  -O2  -o  stencil_naive  core-naive.cpp  io.cpp  main-naive.cpp  pngwriter.c  setup.cpp  utilities.cpp\n$ acpp  -O2  -o  stencil_data  core.cpp  io.cpp  main.cpp  pngwriter.c  setup.cpp  utilities.cpp\n\n$ srun  stencil_naive\n$ srun  stencil_data \n```", "```\n$ srun  stencil_naive\nAverage temperature, start: 59.763305\nAverage temperature at end: 59.281239\nControl temperature at end: 59.281239\nIterations took 2.086 seconds.\n$ srun  stencil_data\nAverage temperature, start: 59.763305\nAverage temperature at end: 59.281239\nControl temperature at end: 59.281239\nIterations took 0.052 seconds. \n```", "```\n// (c) 2023 ENCCS, CSC and the contributors\n#include  \"heat.h\"\n\n// Update the temperature values using five-point stencil\n// Arguments:\n//   curr: current temperature values\n//   prev: temperature values from previous time step\n//   a: diffusivity\n//   dt: time step\nvoid  evolve(field  *curr,  field  *prev,  double  a,  double  dt)\n{\n  // Help the compiler avoid being confused by the structs\n  double  *currdata  =  curr->data.data();\n  double  *prevdata  =  prev->data.data();\n  int  nx  =  prev->nx;\n  int  ny  =  prev->ny;\n\n  // Determine the temperature field at next time step\n  // As we have fixed boundary conditions, the outermost gridpoints\n  // are not updated.\n  double  dx2  =  prev->dx  *  prev->dx;\n  double  dy2  =  prev->dy  *  prev->dy;\n\n  // Offload value update to GPU target (fallback to CPU is possible)\n #pragma omp target teams distribute parallel for  for  (int  i  =  1;  i  <  nx  +  1;  i++)  {\n  for  (int  j  =  1;  j  <  ny  +  1;  j++)  {\n  int  ind  =  i  *  (ny  +  2)  +  j;\n  int  ip  =  (i  +  1)  *  (ny  +  2)  +  j;\n  int  im  =  (i  -  1)  *  (ny  +  2)  +  j;\n  int  jp  =  i  *  (ny  +  2)  +  j  +  1;\n  int  jm  =  i  *  (ny  +  2)  +  j  -  1;\n  currdata[ind]  =  prevdata[ind]  +  a*dt*\n  ((prevdata[ip]  -  2.0*prevdata[ind]  +  prevdata[im])  /  dx2  +\n  (prevdata[jp]  -  2.0*prevdata[ind]  +  prevdata[jm])  /  dy2);\n  }\n  }\n}\n\n// Start a data region and copy temperature fields to the device void  enter_data(field  *curr,  field  *prev) {\n double  *currdata  =  curr->data.data(); double  *prevdata  =  prev->data.data(); int  nx  =  prev->nx; int  ny  =  prev->ny;   // adding data mapping here #pragma omp target enter data \\ map(to: currdata[0:(nx+2)*(ny+2)], prevdata[0:(nx+2)*(ny+2)]) }   // End a data region and copy temperature fields back to the host void  exit_data(field  *curr,  field  *prev) {\n double  *currdata  =  curr->data.data(); double  *prevdata  =  prev->data.data(); int  nx  =  prev->nx; int  ny  =  prev->ny;   // adding data mapping here #pragma omp target exit data \\ map(from: currdata[0:(nx+2)*(ny+2)], prevdata[0:(nx+2)*(ny+2)]) }   // Copy a temperature field from the device to the host void  update_host(field  *heat) {\n double  *data  =  heat->data.data(); int  nx  =  heat->nx; int  ny  =  heat->ny;   // adding data mapping here #pragma omp target update from(data[0:(nx+2)*(ny+2)]) } \n```", "```\n// (c) 2023 ENCCS, CSC and the contributors\n#include  \"heat.h\"\n#include  <sycl/sycl.hpp>\n\n// Update the temperature values using five-point stencil\n// Arguments:\n//   queue: SYCL queue\n//   currdata: current temperature values (device pointer)\n//   prevdata: temperature values from previous time step (device pointer)\n//   prev: description of the grid parameters\n//   a: diffusivity\n//   dt: time step\nvoid  evolve(sycl::queue  &Q,  double*  currdata,  const  double*  prevdata,\n const  field  *prev,  double  a,  double  dt) {\n  int  nx  =  prev->nx;\n  int  ny  =  prev->ny;\n\n  // Determine the temperature field at next time step\n  // As we have fixed boundary conditions, the outermost gridpoints\n  // are not updated.\n  double  dx2  =  prev->dx  *  prev->dx;\n  double  dy2  =  prev->dy  *  prev->dy;\n\n Q.parallel_for(sycl::range<2>(nx,  ny),  [=](sycl::id<2>  id)  {  auto  i  =  id[0]  +  1;\n  auto  j  =  id[1]  +  1;\n\n  int  ind  =  i  *  (ny  +  2)  +  j;\n  int  ip  =  (i  +  1)  *  (ny  +  2)  +  j;\n  int  im  =  (i  -  1)  *  (ny  +  2)  +  j;\n  int  jp  =  i  *  (ny  +  2)  +  j  +  1;\n  int  jm  =  i  *  (ny  +  2)  +  j  -  1;\n  currdata[ind]  =  prevdata[ind]  +  a*dt*\n  ((prevdata[ip]  -  2.0*prevdata[ind]  +  prevdata[im])  /  dx2  +\n  (prevdata[jp]  -  2.0*prevdata[ind]  +  prevdata[jm])  /  dy2);\n  });\n}\n\nvoid  copy_to_buffer(sycl::queue  Q,  double*  buffer,  const  field*  f) {\n int  size  =  (f->nx  +  2)  *  (f->ny  +  2); Q.copy<double>(f->data.data(),  buffer,  size); }   void  copy_from_buffer(sycl::queue  Q,  const  double*  buffer,  field  *f) {\n int  size  =  (f->nx  +  2)  *  (f->ny  +  2); Q.copy<double>(buffer,  f->data.data(),  size).wait(); } \n```", "```\nfrom  numba  import jit\n\n# Update the temperature values using five-point stencil\n# Arguments:\n#   curr: current temperature field object\n#   prev: temperature field from previous time step\n#   a: diffusivity\n#   dt: time step\ndef  evolve(current, previous, a, dt):\n    dx2, dy2 = previous.dx**2, previous.dy**2\n    curr, prev = current.data, previous.data\n    # Run (possibly accelerated) update\n    _evolve(curr, prev, a, dt, dx2, dy2)\n\n@jit(nopython=True) def  _evolve(curr, prev, a, dt, dx2, dy2):\n    nx, ny = prev.shape # These are the FULL dims, rows+2 / cols+2\n    for i in range(1, nx-1):\n        for j in range(1, ny-1):\n            curr[i, j] = prev[i, j] + a * dt * ( \\\n              (prev[i+1, j] - 2*prev[i, j] + prev[i-1, j]) / dx2 + \\\n              (prev[i, j+1] - 2*prev[i, j] + prev[i, j-1]) / dy2 ) \n```", "```\n@jit(nopython=True) def  _generate(data, nx, ny):\n    # Radius of the source disc\n    radius = nx / 6.0\n    for i in range(nx+2):\n        for j in range(ny+2):\n            # Distance of point i, j from the origin\n            dx = i - nx / 2 + 1\n            dy = j - ny / 2 + 1\n            if (dx * dx + dy * dy < radius * radius):\n                data[i,j] = T_DISC\n            else:\n                data[i,j] = T_AREA\n\n    # Boundary conditions\n    for i in range(nx+2):\n        data[i,0] = T_LEFT\n        data[i, ny+1] = T_RIGHT\n\n    for j in range(ny+2):\n        data[0,j] = T_UPPER\n        data[nx+1, j] = T_LOWER \n```", "```\nimport  math\nfrom  numba  import cuda\n\n# Update the temperature values using five-point stencil\n# Arguments:\n#   curr: current temperature field object\n#   prev: temperature field from previous time step\n#   a: diffusivity\n#   dt: time step\ndef  evolve(current, previous, a, dt):\n    dx2, dy2 = previous.dx**2, previous.dy**2\n    curr, prev = current.dev, previous.dev\n    # Set thread and block sizes\n nx, ny = prev.shape # These are the FULL dims, rows+2 / cols+2 tx, ty = (16, 16)   # Arbitrary choice bx, by = math.ceil(nx / tx), math.ceil(ny / ty)    # Run numba (CUDA) kernel\n _evolve_kernel[(bx, by), (tx, ty)](curr, prev, a, dt, dx2, dy2) \n\n@cuda.jit()\ndef  _evolve_kernel(curr, prev, a, dt, dx2, dy2):\n    nx, ny = prev.shape # These are the FULL dims, rows+2 / cols+2\n    i, j = cuda.grid(2)\n    if ((i >= 1) and (i < nx-1) \n        and (j >= 1) and (j < ny-1)):\n        curr[i, j] = prev[i, j] + a * dt * ( \\\n            (prev[i+1, j] - 2*prev[i, j] + prev[i-1, j]) / dx2 + \\\n            (prev[i, j+1] - 2*prev[i, j] + prev[i, j-1]) / dy2 ) \n```", "```\n$ # skip the git clone step, if you have done that already\n$ git  clone  https://github.com/ENCCS/gpu-programming.git\n$ # allocate a GPU node using `salloc`\n$ # execute the `srun --pty singularity exec ...` command\nSingularity> cd /work/gpu-programming/content/examples/stencil/python-numba\nSingularity> . /.venv/bin/activate\nSingularity> python3 main.py \n```", "```\n$ git  clone  https://github.com/ENCCS/gpu-programming.git\n$ cd  gpu-programming/content/examples/stencil/python-numba\n$ # make sure you have active allocation\n$ srun  python3  main.py \n```", "```\n$ # interactive CPU node\n$ srun  --account=project_465002387  --partition=standard  --nodes=1  --cpus-per-task=32  --ntasks-per-node=1  --time=01:00:00  --pty  bash\n$ # load Julia env\n$ module  purge\n$ module  use  /appl/local/csc/modulefiles\n$ module  load  julia\n$ module  load  julia-amdgpu\n$ # in directory with Project.toml and source files, instantiate an environment to install packages\n$ julia  --project  -e  \"using Pkg ; Pkg.instantiate()\"\n$ # finally run\n$ julia  --project  main.jl \n```", "```\n$ srun  --account=project_465002387  --partition=standard-g  --nodes=1  --cpus-per-task=1  --ntasks-per-node=1  --gpus-per-node=1  --time=1:00:00  --pty  bash \n```", "```\n#using Plots\nusing  BenchmarkTools\n\ninclude(\"heat.jl\")\ninclude(\"core.jl\")\n\n\"\"\"\n visualize(curr::Field, filename=:none)\n\nCreate a heatmap of a temperature field. Optionally write png file. \n\"\"\"  \nfunction  visualize(curr::Field,  filename=:none)\n  background_color  =  :white\n  plot  =  heatmap(\n  curr.data,\n  colorbar_title  =  \"Temperature (C)\",\n  background_color  =  background_color\n  )\n\n  if  filename  !=  :none\n  savefig(filename)\n  else\n  display(plot)\n  end\nend\n\nncols,  nrows  =  2048,  2048\nnsteps  =  500\n\n# initialize current and previous states to the same state\ncurr,  prev  =  initialize(ncols,  nrows)\n\n# visualize initial field, requires Plots.jl\n#visualize(curr, \"initial.png\")\n\n# simulate temperature evolution for nsteps\nsimulate!(curr,  prev,  nsteps)\n\n# visualize final field, requires Plots.jl\n#visualize(curr, \"final.png\") \n```", "```\nusing  ProgressMeter\n\n\"\"\"\n evolve!(curr::Field, prev::Field, a, dt)\n\nCalculate a new temperature field curr based on the previous \nfield prev. a is the diffusion constant and dt is the largest \nstable time step. \n\"\"\"\nfunction  evolve!(curr::Field,  prev::Field,  a,  dt)\n  Threads.@threads  for  j  =  2:curr.ny+1\n  for  i  =  2:curr.nx+1\n  @inbounds  xderiv  =  (prev.data[i-1,  j]  -  2.0  *  prev.data[i,  j]  +  prev.data[i+1,  j])  /  curr.dx^2\n  @inbounds  yderiv  =  (prev.data[i,  j-1]  -  2.0  *  prev.data[i,  j]  +  prev.data[i,  j+1])  /  curr.dy^2\n  @inbounds  curr.data[i,  j]  =  prev.data[i,  j]  +  a  *  dt  *  (xderiv  +  yderiv)\n  end  \n  end\nend\n\n\"\"\"\n swap_fields!(curr::Field, prev::Field)\n\nSwap the data of two fields curr and prev. \n\"\"\"  \nfunction  swap_fields!(curr::Field,  prev::Field)\n  tmp  =  curr.data\n  curr.data  =  prev.data\n  prev.data  =  tmp\nend\n\n\"\"\" \n average_temperature(f::Field)\n\nCalculate average temperature of a temperature field. \n\"\"\"\naverage_temperature(f::Field)  =  sum(f.data[2:f.nx+1,  2:f.ny+1])  /  (f.nx  *  f.ny)\n\n\"\"\"\n simulate!(current, previous, nsteps)\n\nRun the heat equation solver on fields curr and prev for nsteps.\n\"\"\"\nfunction  simulate!(curr::Field,  prev::Field,  nsteps)\n\n  println(\"Initial average temperature: $(average_temperature(curr))\")\n\n  # Diffusion constant\n  a  =  0.5\n  # Largest stable time step\n  dt  =  curr.dx^2  *  curr.dy^2  /  (2.0  *  a  *  (curr.dx^2  +  curr.dy^2))\n\n  # display a nice progress bar\n  p  =  Progress(nsteps)\n\n  for  i  =  1:nsteps\n  # calculate new state based on previous state\n  evolve!(curr,  prev,  a,  dt)\n\n  # swap current and previous fields\n  swap_fields!(curr,  prev)\n\n  # increment the progress bar\n  next!(p)\n  end  \n\n  # print final average temperature\n  println(\"Final average temperature: $(average_temperature(curr))\")\nend \n```", "```\n# Fixed grid spacing\nconst  DX  =  0.01\nconst  DY  =  0.01\n# Default temperatures\nconst  T_DISC  =  5.0\nconst  T_AREA  =  65.0\nconst  T_UPPER  =  85.0\nconst  T_LOWER  =  5.0\nconst  T_LEFT  =  20.0\nconst  T_RIGHT  =  70.0\n# Default problem size\nconst  ROWS  =  2000\nconst  COLS  =  2000\nconst  NSTEPS  =  500\n\n\"\"\"\n Field(nx::Int64, ny::Int64, dx::Float64, dy::Float64, data::Matrix{Float64})\n\nTemperature field type. nx and ny are the dimensions of the field. \nThe array data contains also ghost layers, so it will have dimensions \n[nx+2, ny+2]\n\"\"\"\nmutable  struct Field{T<:AbstractArray}\n  nx::Int64\n  ny::Int64\n  # Size of the grid cells\n  dx::Float64\n  dy::Float64\n  # The temperature values in the 2D grid\n  data::T\nend\n\n# outer constructor with default cell sizes and initialized data\nField(nx::Int64,  ny::Int64,  data)  =  Field{typeof(data)}(nx,  ny,  0.01,  0.01,  data)\n\n# extend deepcopy to new type\nBase.deepcopy(f::Field)  =  Field(f.nx,  f.ny,  f.dx,  f.dy,  deepcopy(f.data))\n\n\"\"\"\n initialize(rows::Int, cols::Int, arraytype = Matrix)\n\nInitialize two temperature field with (nrows, ncols) number of \nrows and columns. If the arraytype is something else than Matrix,\ncreate data on the CPU first to avoid scalar indexing errors.\n\"\"\"\nfunction  initialize(nrows  =  1000,  ncols  =  1000,  arraytype  =  Matrix)\n  data  =  zeros(nrows+2,  ncols+2)\n\n  # generate a field with boundary conditions\n  if  arraytype  !=  Matrix\n  tmp  =  Field(nrows,  ncols,  data)\n  generate_field!(tmp)\n  gpudata  =  arraytype(tmp.data)\n  previous  =  Field(nrows,  ncols,  gpudata)\n  else\n  previous  =  Field(nrows,  ncols,  data)\n  generate_field!(previous)\n  end\n\n  current  =  Base.deepcopy(previous)\n\n  return  previous,  current\nend\n\n\"\"\"\n generate_field!(field0::Field)\n\nGenerate a temperature field.  Pattern is disc with a radius\nof nx / 6 in the center of the grid. Boundary conditions are \n(different) constant temperatures outside the grid.\n\"\"\"\nfunction  generate_field!(field::Field)\n  # Square of the disk radius\n  radius2  =  (field.nx  /  6.0)^2\n\n  for  j  =  1:field.ny+2\n  for  i  =  1:field.nx+2\n  ds2  =  (i  -  field.nx  /  2)^2  +  (j  -  field.ny  /  2)^2\n  if  ds2  <  radius2  \n  field.data[i,j]  =  T_DISC\n  else\n  field.data[i,j]  =  T_AREA\n  end\n  end  \n  end  \n\n  # Boundary conditions\n  field.data[:,1]  .=  T_LEFT\n  field.data[:,field.ny+2]  .=  T_RIGHT\n  field.data[1,:]  .=  T_UPPER\n  field.data[field.nx+2,:]  .=  T_LOWER\nend \n```", "```\n[deps]\nBenchmarkTools  =  \"6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf\"\n#Plots = \"91a5bcdd-55d7-5caf-9e0b-520d859cae80\"\nProgressMeter  =  \"92933f4c-e287-5a05-a399-4b506db050ca\" \n```", "```\n#using Plots\nusing  BenchmarkTools\nusing  AMDGPU\n\ninclude(\"heat.jl\")\ninclude(\"core_gpu.jl\")\n\n\"\"\"\n visualize(curr::Field, filename=:none)\n\nCreate a heatmap of a temperature field. Optionally write png file. \n\"\"\"  \nfunction  visualize(curr::Field,  filename=:none)\n  background_color  =  :white\n  plot  =  heatmap(\n  curr.data,\n  colorbar_title  =  \"Temperature (C)\",\n  background_color  =  background_color\n  )\n\n  if  filename  !=  :none\n  savefig(filename)\n  else\n  display(plot)\n  end\nend\n\nncols,  nrows  =  2048,  2048\nnsteps  =  500\n\n# initialize data on CPU\ncurr,  prev  =  initialize(ncols,  nrows,  ROCArray)\n# initialize data on CPU\n#curr, prev = initialize(ncols, nrows)\n\n# visualize initial field, requires Plots.jl\n#visualize(curr, \"initial.png\")\n\n# simulate temperature evolution for nsteps\n@btime  simulate!(curr,  prev,  nsteps)\n\n# visualize final field, requires Plots.jl\n#visualize(curr, \"final.png\") \n```", "```\nusing  ProgressMeter\n\n\"\"\"\n evolve!(curr::Field, prev::Field, a, dt)\n\nCalculate a new temperature field curr based on the previous \nfield prev. a is the diffusion constant and dt is the largest \nstable time step. \n\"\"\"\nfunction  evolve!(curr::Field,  prev::Field,  a,  dt)\n  Threads.@threads  for  j  =  2:curr.ny+1\n  for  i  =  2:curr.nx+1\n  @inbounds  xderiv  =  (prev.data[i-1,  j]  -  2.0  *  prev.data[i,  j]  +  prev.data[i+1,  j])  /  curr.dx^2\n  @inbounds  yderiv  =  (prev.data[i,  j-1]  -  2.0  *  prev.data[i,  j]  +  prev.data[i,  j+1])  /  curr.dy^2\n  @inbounds  curr.data[i,  j]  =  prev.data[i,  j]  +  a  *  dt  *  (xderiv  +  yderiv)\n  end  \n  end\nend\n\nfunction  evolve_cuda!(currdata,  prevdata,  dx2,  dy2,  nx,  ny,  a,  dt)\n  i  =  (blockIdx().x  -  1)  *  blockDim().x  +  threadIdx().x\n  j  =  (blockIdx().y  -  1)  *  blockDim().y  +  threadIdx().y\n  if  i  >  1  &&  j  >  1  &&  i  <  nx+2  &&  j  <  ny+2\n  @inbounds  xderiv  =  (prevdata[i-1,  j]  -  2.0  *  prevdata[i,  j]  +  prevdata[i+1,  j])  /  dx2\n  @inbounds  yderiv  =  (prevdata[i,  j-1]  -  2.0  *  prevdata[i,  j]  +  prevdata[i,  j+1])  /  dy2\n  @inbounds  currdata[i,  j]  =  prevdata[i,  j]  +  a  *  dt  *  (xderiv  +  yderiv)\n  end\n  return\nend\n\nfunction  evolve_rocm!(currdata,  prevdata,  dx2,  dy2,  nx,  ny,  a,  dt)\n  i  =  (workgroupIdx().x  -  1)  *  workgroupDim().x  +  workitemIdx().x\n  j  =  (workgroupIdx().y  -  1)  *  workgroupDim().y  +  workitemIdx().y\n  if  i  >  1  &&  j  >  1  &&  i  <  nx+2  &&  j  <  ny+2\n  @inbounds  xderiv  =  (prevdata[i-1,  j]  -  2.0  *  prevdata[i,  j]  +  prevdata[i+1,  j])  /  dx2\n  @inbounds  yderiv  =  (prevdata[i,  j-1]  -  2.0  *  prevdata[i,  j]  +  prevdata[i,  j+1])  /  dy2\n  @inbounds  currdata[i,  j]  =  prevdata[i,  j]  +  a  *  dt  *  (xderiv  +  yderiv)\n  end\n  return\nend\n\n\"\"\"\n swap_fields!(curr::Field, prev::Field)\n\nSwap the data of two fields curr and prev. \n\"\"\"  \nfunction  swap_fields!(curr::Field,  prev::Field)\n  tmp  =  curr.data\n  curr.data  =  prev.data\n  prev.data  =  tmp\nend\n\n\"\"\" \n average_temperature(f::Field)\n\nCalculate average temperature of a temperature field. \n\"\"\"\naverage_temperature(f::Field)  =  sum(f.data[2:f.nx+1,  2:f.ny+1])  /  (f.nx  *  f.ny)\n\n\"\"\"\n simulate!(current, previous, nsteps)\n\nRun the heat equation solver on fields curr and prev for nsteps.\n\"\"\"\nfunction  simulate!(curr::Field,  prev::Field,  nsteps)\n\n  println(\"Initial average temperature: $(average_temperature(curr))\")\n\n  # Diffusion constant\n  a  =  0.5\n  # Largest stable time step\n  dt  =  curr.dx^2  *  curr.dy^2  /  (2.0  *  a  *  (curr.dx^2  +  curr.dy^2))\n\n  # display a nice progress bar\n  p  =  Progress(nsteps)\n\n  for  i  =  1:nsteps\n  # calculate new state based on previous state\n  if  typeof(curr.data)  <:  ROCArray\n  nx,  ny  =  size(curr.data)  .-  2  \n  xthreads  =  ythreads  =  16\n  xblocks,  yblocks  =  cld(curr.nx,  xthreads),  cld(curr.ny,  ythreads)\n  @roc  groupsize=(xthreads,  ythreads)  gridsize  =  (xblocks,  yblocks)  evolve_rocm!(curr.data,  prev.data,  curr.dx^2,  curr.dy^2,  nx,  ny,  a,  dt)\n  else\n  evolve!(curr,  prev,  a,  dt)\n  end\n\n  # swap current and previous fields\n  swap_fields!(curr,  prev)\n\n  # increment the progress bar\n  next!(p)\n  end  \n\n  # print final average temperature\n  println(\"Final average temperature: $(average_temperature(curr))\")\nend \n```", "```\n$ git  clone  https://github.com/ENCCS/gpu-programming.git\n$ cd  gpu-programming/content/examples/stencil/\n$ ls \n```", "```\n// (c) 2023 ENCCS, CSC and the contributors\n#include  \"heat.h\"\n\n// Update the temperature values using five-point stencil\n// Arguments:\n//   curr: current temperature values\n//   prev: temperature values from previous time step\n//   a: diffusivity\n//   dt: time step\nvoid  evolve(field  *curr,  field  *prev,  double  a,  double  dt)\n{\n  // Help the compiler avoid being confused by the structs\n  double  *currdata  =  curr->data.data();\n  double  *prevdata  =  prev->data.data();\n  int  nx  =  prev->nx;\n  int  ny  =  prev->ny;\n\n  // Determine the temperature field at next time step\n  // As we have fixed boundary conditions, the outermost gridpoints\n  // are not updated.\n  double  dx2  =  prev->dx  *  prev->dx;\n  double  dy2  =  prev->dy  *  prev->dy;\n\n  // Use OpenMP threads for parallel update of grid values\n #pragma omp parallel for  for  (int  i  =  1;  i  <  nx  +  1;  i++)  {\n  for  (int  j  =  1;  j  <  ny  +  1;  j++)  {\n  int  ind  =  i  *  (ny  +  2)  +  j;\n  int  ip  =  (i  +  1)  *  (ny  +  2)  +  j;\n  int  im  =  (i  -  1)  *  (ny  +  2)  +  j;\n  int  jp  =  i  *  (ny  +  2)  +  j  +  1;\n  int  jm  =  i  *  (ny  +  2)  +  j  -  1;\n  currdata[ind]  =  prevdata[ind]  +  a*dt*\n  ((prevdata[ip]  -  2.0*prevdata[ind]  +  prevdata[im])  /  dx2  +\n  (prevdata[jp]  -  2.0*prevdata[ind]  +  prevdata[jm])  /  dy2);\n  }\n  }\n} \n```", "```\n// Main routine for heat equation solver in 2D.\n// (c) 2023 ENCCS, CSC and the contributors\n#include  <cstdio>\n#include  <omp.h>\n\n#include  \"heat.h\"\n\ndouble  start_time  ()  {  return  omp_get_wtime();  }\ndouble  stop_time  ()  {  return  omp_get_wtime();  }\n\nint  main(int  argc,  char  **argv)\n{\n  // Set up the solver\n  int  nsteps;\n  field  current,  previous;\n  initialize(argc,  argv,  &current,  &previous,  &nsteps);\n\n  // Output the initial field and its temperature\n  field_write(&current,  0);\n  double  average_temp  =  field_average(&current);\n  printf(\"Average temperature, start: %f\\n\",  average_temp);\n\n  // Set diffusivity constant\n  double  a  =  0.5;\n  // Compute the largest stable time step\n  double  dx2  =  current.dx  *  current.dx;\n  double  dy2  =  current.dy  *  current.dy;\n  double  dt  =  dx2  *  dy2  /  (2.0  *  a  *  (dx2  +  dy2));\n  // Set output interval\n  int  output_interval  =  1500;\n\n  // Start timer\n  double  start_clock  =  start_time();\n  // Time evolution\n  for  (int  iter  =  1;  iter  <=  nsteps;  iter++)  {\n evolve(&current,  &previous,  a,  dt);  if  (iter  %  output_interval  ==  0)  {\n  field_write(&current,  iter);\n  }\n  // Swap current and previous fields for next iteration step\n  field_swap(&current,  &previous);\n  }\n  // Stop timer\n  double  stop_clock  =  stop_time();\n\n  // Output the final field and its temperature\n  average_temp  =  field_average(&previous);\n  printf(\"Average temperature at end: %f\\n\",  average_temp);\n  // Compare temperature for reference\n  if  (argc  ==  1)  {\n  printf(\"Control temperature at end: 59.281239\\n\");\n  }\n  field_write(&previous,  nsteps);\n\n  // Determine the computation time used for all the iterations\n  printf(\"Iterations took %.3f seconds.\\n\",  (stop_clock  -  start_clock));\n\n  return  0;\n} \n```", "```\n// Datatype for temperature field\nstruct  field  {\n  // nx and ny are the dimensions of the field. The array data\n  // contains also ghost layers, so it will have dimensions nx+2 x ny+2\n  int  nx;\n  int  ny;\n  // Size of the grid cells\n  double  dx;\n  double  dy;\n  // The temperature values in the 2D grid\n  std::vector<double>  data;\n};\n\n// CONSTANTS\n// Fixed grid spacing\nconst  double  DX  =  0.01;\nconst  double  DY  =  0.01;\n// Default temperatures\nconst  double  T_DISC  =  5.0;\nconst  double  T_AREA  =  65.0;\nconst  double  T_UPPER  =  85.0;\nconst  double  T_LOWER  =  5.0;\nconst  double  T_LEFT  =  20.0;\nconst  double  T_RIGHT  =  70.0;\n// Default problem size\nconst  int  ROWS  =  2000;\nconst  int  COLS  =  2000;\nconst  int  NSTEPS  =  500; \n```", "```\nsalloc -A project_465002387 -p small-g -N 1 -c 8 -n 1 --gpus-per-node=1 -t 1:00:00\n\nmodule load LUMI/24.03\nmodule load partition/G\nmodule load rocm/6.0.3\nmodule load PrgEnv-cray/8.5.0\n\ncd base/\nmake all \n```", "```\n$ srun  --pty  bash\n\n$ ./stencil\n$ ./stencil_off\n$ ./stencil_data\n\n$ exit \n```", "```\n$ ./stencil\nAverage temperature, start: 59.763305\nAverage temperature at end: 59.281239\nControl temperature at end: 59.281239\nIterations took 0.566 seconds.\n$ ./stencil_off\nAverage temperature, start: 59.763305\nAverage temperature at end: 59.281239\nControl temperature at end: 59.281239\nIterations took 3.792 seconds.\n$ ./stencil_data\nAverage temperature, start: 59.763305\nAverage temperature at end: 59.281239\nControl temperature at end: 59.281239\nIterations took 1.211 seconds.\n$ \n```", "```\n// (c) 2023 ENCCS, CSC and the contributors\n#include  \"heat.h\"\n\n// Update the temperature values using five-point stencil\n// Arguments:\n//   curr: current temperature values\n//   prev: temperature values from previous time step\n//   a: diffusivity\n//   dt: time step\nvoid  evolve(field  *curr,  field  *prev,  double  a,  double  dt)\n{\n  // Help the compiler avoid being confused by the structs\n  double  *currdata  =  curr->data.data();\n  double  *prevdata  =  prev->data.data();\n  int  nx  =  prev->nx;\n  int  ny  =  prev->ny;\n\n  // Determine the temperature field at next time step\n  // As we have fixed boundary conditions, the outermost gridpoints\n  // are not updated.\n  double  dx2  =  prev->dx  *  prev->dx;\n  double  dy2  =  prev->dy  *  prev->dy;\n\n  // Offload value update to GPU target (fallback to CPU is possible)\n #pragma omp target teams distribute parallel for \\ map(currdata[0:(nx+2)*(ny+2)],prevdata[0:(nx+2)*(ny+2)])  for  (int  i  =  1;  i  <  nx  +  1;  i++)  {\n  for  (int  j  =  1;  j  <  ny  +  1;  j++)  {\n  int  ind  =  i  *  (ny  +  2)  +  j;\n  int  ip  =  (i  +  1)  *  (ny  +  2)  +  j;\n  int  im  =  (i  -  1)  *  (ny  +  2)  +  j;\n  int  jp  =  i  *  (ny  +  2)  +  j  +  1;\n  int  jm  =  i  *  (ny  +  2)  +  j  -  1;\n  currdata[ind]  =  prevdata[ind]  +  a*dt*\n  ((prevdata[ip]  -  2.0*prevdata[ind]  +  prevdata[im])  /  dx2  +\n  (prevdata[jp]  -  2.0*prevdata[ind]  +  prevdata[jm])  /  dy2);\n  }\n  }\n} \n```", "```\n// (c) 2023 ENCCS, CSC and the contributors\n#include  \"heat.h\"\n#include  <sycl/sycl.hpp>\n\n// Update the temperature values using five-point stencil\n// Arguments:\n//   queue: SYCL queue\n//   curr: current temperature values\n//   prev: temperature values from previous time step\n//   a: diffusivity\n//   dt: time step\nvoid  evolve(sycl::queue  &Q,  field  *curr,  field  *prev,  double  a,  double  dt)  {\n  // Help the compiler avoid being confused by the structs\n  int  nx  =  prev->nx;\n  int  ny  =  prev->ny;\n  int  size  =  (nx  +  2)  *  (ny  +  2);\n\n  // Determine the temperature field at next time step\n  // As we have fixed boundary conditions, the outermost gridpoints\n  // are not updated.\n  double  dx2  =  prev->dx  *  prev->dx;\n  double  dy2  =  prev->dy  *  prev->dy;\n\n double  *currdata  =  sycl::malloc_device<double>(size,  Q); double  *prevdata  =  sycl::malloc_device<double>(size,  Q); Q.copy<double>(curr->data.data(),  currdata,  size); Q.copy<double>(prev->data.data(),  prevdata,  size); \n Q.parallel_for(sycl::range<2>(nx,  ny),  [=](sycl::id<2>  id)  {  auto  i  =  id[0]  +  1;\n  auto  j  =  id[1]  +  1;\n\n  int  ind  =  i  *  (ny  +  2)  +  j;\n  int  ip  =  (i  +  1)  *  (ny  +  2)  +  j;\n  int  im  =  (i  -  1)  *  (ny  +  2)  +  j;\n  int  jp  =  i  *  (ny  +  2)  +  j  +  1;\n  int  jm  =  i  *  (ny  +  2)  +  j  -  1;\n  currdata[ind]  =  prevdata[ind]  +  a*dt*\n  ((prevdata[ip]  -  2.0*prevdata[ind]  +  prevdata[im])  /  dx2  +\n  (prevdata[jp]  -  2.0*prevdata[ind]  +  prevdata[jm])  /  dy2);\n  });\n\n Q.copy<double>(currdata,  curr->data.data(),  size).wait(); sycl::free(currdata,  Q); sycl::free(prevdata,  Q); } \n```", "```\n# salloc  -A  project_465002387  -p  small-g  -N  1  -c  8  -n  1  --gpus-per-node=1  -t  1:00:00\n\nmodule load LUMI/24.03\nmodule load partition/G\nmodule load rocm/6.0.3\nmodule use  /appl/local/csc/modulefiles\nmodule load acpp/24.06.0 \n```", "```\n$ cd  ../sycl/\n(give the following lines some time, probably a couple of min)\n$ acpp  -O2  -o  stencil_naive  core-naive.cpp  io.cpp  main-naive.cpp  pngwriter.c  setup.cpp  utilities.cpp\n$ acpp  -O2  -o  stencil_data  core.cpp  io.cpp  main.cpp  pngwriter.c  setup.cpp  utilities.cpp\n\n$ srun  stencil_naive\n$ srun  stencil_data \n```", "```\n$ srun  stencil_naive\nAverage temperature, start: 59.763305\nAverage temperature at end: 59.281239\nControl temperature at end: 59.281239\nIterations took 2.086 seconds.\n$ srun  stencil_data\nAverage temperature, start: 59.763305\nAverage temperature at end: 59.281239\nControl temperature at end: 59.281239\nIterations took 0.052 seconds. \n```", "```\n// (c) 2023 ENCCS, CSC and the contributors\n#include  \"heat.h\"\n\n// Update the temperature values using five-point stencil\n// Arguments:\n//   curr: current temperature values\n//   prev: temperature values from previous time step\n//   a: diffusivity\n//   dt: time step\nvoid  evolve(field  *curr,  field  *prev,  double  a,  double  dt)\n{\n  // Help the compiler avoid being confused by the structs\n  double  *currdata  =  curr->data.data();\n  double  *prevdata  =  prev->data.data();\n  int  nx  =  prev->nx;\n  int  ny  =  prev->ny;\n\n  // Determine the temperature field at next time step\n  // As we have fixed boundary conditions, the outermost gridpoints\n  // are not updated.\n  double  dx2  =  prev->dx  *  prev->dx;\n  double  dy2  =  prev->dy  *  prev->dy;\n\n  // Offload value update to GPU target (fallback to CPU is possible)\n #pragma omp target teams distribute parallel for  for  (int  i  =  1;  i  <  nx  +  1;  i++)  {\n  for  (int  j  =  1;  j  <  ny  +  1;  j++)  {\n  int  ind  =  i  *  (ny  +  2)  +  j;\n  int  ip  =  (i  +  1)  *  (ny  +  2)  +  j;\n  int  im  =  (i  -  1)  *  (ny  +  2)  +  j;\n  int  jp  =  i  *  (ny  +  2)  +  j  +  1;\n  int  jm  =  i  *  (ny  +  2)  +  j  -  1;\n  currdata[ind]  =  prevdata[ind]  +  a*dt*\n  ((prevdata[ip]  -  2.0*prevdata[ind]  +  prevdata[im])  /  dx2  +\n  (prevdata[jp]  -  2.0*prevdata[ind]  +  prevdata[jm])  /  dy2);\n  }\n  }\n}\n\n// Start a data region and copy temperature fields to the device void  enter_data(field  *curr,  field  *prev) {\n double  *currdata  =  curr->data.data(); double  *prevdata  =  prev->data.data(); int  nx  =  prev->nx; int  ny  =  prev->ny;   // adding data mapping here #pragma omp target enter data \\ map(to: currdata[0:(nx+2)*(ny+2)], prevdata[0:(nx+2)*(ny+2)]) }   // End a data region and copy temperature fields back to the host void  exit_data(field  *curr,  field  *prev) {\n double  *currdata  =  curr->data.data(); double  *prevdata  =  prev->data.data(); int  nx  =  prev->nx; int  ny  =  prev->ny;   // adding data mapping here #pragma omp target exit data \\ map(from: currdata[0:(nx+2)*(ny+2)], prevdata[0:(nx+2)*(ny+2)]) }   // Copy a temperature field from the device to the host void  update_host(field  *heat) {\n double  *data  =  heat->data.data(); int  nx  =  heat->nx; int  ny  =  heat->ny;   // adding data mapping here #pragma omp target update from(data[0:(nx+2)*(ny+2)]) } \n```", "```\n// (c) 2023 ENCCS, CSC and the contributors\n#include  \"heat.h\"\n#include  <sycl/sycl.hpp>\n\n// Update the temperature values using five-point stencil\n// Arguments:\n//   queue: SYCL queue\n//   currdata: current temperature values (device pointer)\n//   prevdata: temperature values from previous time step (device pointer)\n//   prev: description of the grid parameters\n//   a: diffusivity\n//   dt: time step\nvoid  evolve(sycl::queue  &Q,  double*  currdata,  const  double*  prevdata,\n const  field  *prev,  double  a,  double  dt) {\n  int  nx  =  prev->nx;\n  int  ny  =  prev->ny;\n\n  // Determine the temperature field at next time step\n  // As we have fixed boundary conditions, the outermost gridpoints\n  // are not updated.\n  double  dx2  =  prev->dx  *  prev->dx;\n  double  dy2  =  prev->dy  *  prev->dy;\n\n Q.parallel_for(sycl::range<2>(nx,  ny),  [=](sycl::id<2>  id)  {  auto  i  =  id[0]  +  1;\n  auto  j  =  id[1]  +  1;\n\n  int  ind  =  i  *  (ny  +  2)  +  j;\n  int  ip  =  (i  +  1)  *  (ny  +  2)  +  j;\n  int  im  =  (i  -  1)  *  (ny  +  2)  +  j;\n  int  jp  =  i  *  (ny  +  2)  +  j  +  1;\n  int  jm  =  i  *  (ny  +  2)  +  j  -  1;\n  currdata[ind]  =  prevdata[ind]  +  a*dt*\n  ((prevdata[ip]  -  2.0*prevdata[ind]  +  prevdata[im])  /  dx2  +\n  (prevdata[jp]  -  2.0*prevdata[ind]  +  prevdata[jm])  /  dy2);\n  });\n}\n\nvoid  copy_to_buffer(sycl::queue  Q,  double*  buffer,  const  field*  f) {\n int  size  =  (f->nx  +  2)  *  (f->ny  +  2); Q.copy<double>(f->data.data(),  buffer,  size); }   void  copy_from_buffer(sycl::queue  Q,  const  double*  buffer,  field  *f) {\n int  size  =  (f->nx  +  2)  *  (f->ny  +  2); Q.copy<double>(buffer,  f->data.data(),  size).wait(); } \n```", "```\nfrom  numba  import jit\n\n# Update the temperature values using five-point stencil\n# Arguments:\n#   curr: current temperature field object\n#   prev: temperature field from previous time step\n#   a: diffusivity\n#   dt: time step\ndef  evolve(current, previous, a, dt):\n    dx2, dy2 = previous.dx**2, previous.dy**2\n    curr, prev = current.data, previous.data\n    # Run (possibly accelerated) update\n    _evolve(curr, prev, a, dt, dx2, dy2)\n\n@jit(nopython=True) def  _evolve(curr, prev, a, dt, dx2, dy2):\n    nx, ny = prev.shape # These are the FULL dims, rows+2 / cols+2\n    for i in range(1, nx-1):\n        for j in range(1, ny-1):\n            curr[i, j] = prev[i, j] + a * dt * ( \\\n              (prev[i+1, j] - 2*prev[i, j] + prev[i-1, j]) / dx2 + \\\n              (prev[i, j+1] - 2*prev[i, j] + prev[i, j-1]) / dy2 ) \n```", "```\n@jit(nopython=True) def  _generate(data, nx, ny):\n    # Radius of the source disc\n    radius = nx / 6.0\n    for i in range(nx+2):\n        for j in range(ny+2):\n            # Distance of point i, j from the origin\n            dx = i - nx / 2 + 1\n            dy = j - ny / 2 + 1\n            if (dx * dx + dy * dy < radius * radius):\n                data[i,j] = T_DISC\n            else:\n                data[i,j] = T_AREA\n\n    # Boundary conditions\n    for i in range(nx+2):\n        data[i,0] = T_LEFT\n        data[i, ny+1] = T_RIGHT\n\n    for j in range(ny+2):\n        data[0,j] = T_UPPER\n        data[nx+1, j] = T_LOWER \n```", "```\nimport  math\nfrom  numba  import cuda\n\n# Update the temperature values using five-point stencil\n# Arguments:\n#   curr: current temperature field object\n#   prev: temperature field from previous time step\n#   a: diffusivity\n#   dt: time step\ndef  evolve(current, previous, a, dt):\n    dx2, dy2 = previous.dx**2, previous.dy**2\n    curr, prev = current.dev, previous.dev\n    # Set thread and block sizes\n nx, ny = prev.shape # These are the FULL dims, rows+2 / cols+2 tx, ty = (16, 16)   # Arbitrary choice bx, by = math.ceil(nx / tx), math.ceil(ny / ty)    # Run numba (CUDA) kernel\n _evolve_kernel[(bx, by), (tx, ty)](curr, prev, a, dt, dx2, dy2) \n\n@cuda.jit()\ndef  _evolve_kernel(curr, prev, a, dt, dx2, dy2):\n    nx, ny = prev.shape # These are the FULL dims, rows+2 / cols+2\n    i, j = cuda.grid(2)\n    if ((i >= 1) and (i < nx-1) \n        and (j >= 1) and (j < ny-1)):\n        curr[i, j] = prev[i, j] + a * dt * ( \\\n            (prev[i+1, j] - 2*prev[i, j] + prev[i-1, j]) / dx2 + \\\n            (prev[i, j+1] - 2*prev[i, j] + prev[i, j-1]) / dy2 ) \n```", "```\n$ # skip the git clone step, if you have done that already\n$ git  clone  https://github.com/ENCCS/gpu-programming.git\n$ # allocate a GPU node using `salloc`\n$ # execute the `srun --pty singularity exec ...` command\nSingularity> cd /work/gpu-programming/content/examples/stencil/python-numba\nSingularity> . /.venv/bin/activate\nSingularity> python3 main.py \n```", "```\n$ git  clone  https://github.com/ENCCS/gpu-programming.git\n$ cd  gpu-programming/content/examples/stencil/python-numba\n$ # make sure you have active allocation\n$ srun  python3  main.py \n```", "```\n$ # interactive CPU node\n$ srun  --account=project_465002387  --partition=standard  --nodes=1  --cpus-per-task=32  --ntasks-per-node=1  --time=01:00:00  --pty  bash\n$ # load Julia env\n$ module  purge\n$ module  use  /appl/local/csc/modulefiles\n$ module  load  julia\n$ module  load  julia-amdgpu\n$ # in directory with Project.toml and source files, instantiate an environment to install packages\n$ julia  --project  -e  \"using Pkg ; Pkg.instantiate()\"\n$ # finally run\n$ julia  --project  main.jl \n```", "```\n$ srun  --account=project_465002387  --partition=standard-g  --nodes=1  --cpus-per-task=1  --ntasks-per-node=1  --gpus-per-node=1  --time=1:00:00  --pty  bash \n```", "```\n#using Plots\nusing  BenchmarkTools\n\ninclude(\"heat.jl\")\ninclude(\"core.jl\")\n\n\"\"\"\n visualize(curr::Field, filename=:none)\n\nCreate a heatmap of a temperature field. Optionally write png file. \n\"\"\"  \nfunction  visualize(curr::Field,  filename=:none)\n  background_color  =  :white\n  plot  =  heatmap(\n  curr.data,\n  colorbar_title  =  \"Temperature (C)\",\n  background_color  =  background_color\n  )\n\n  if  filename  !=  :none\n  savefig(filename)\n  else\n  display(plot)\n  end\nend\n\nncols,  nrows  =  2048,  2048\nnsteps  =  500\n\n# initialize current and previous states to the same state\ncurr,  prev  =  initialize(ncols,  nrows)\n\n# visualize initial field, requires Plots.jl\n#visualize(curr, \"initial.png\")\n\n# simulate temperature evolution for nsteps\nsimulate!(curr,  prev,  nsteps)\n\n# visualize final field, requires Plots.jl\n#visualize(curr, \"final.png\") \n```", "```\nusing  ProgressMeter\n\n\"\"\"\n evolve!(curr::Field, prev::Field, a, dt)\n\nCalculate a new temperature field curr based on the previous \nfield prev. a is the diffusion constant and dt is the largest \nstable time step. \n\"\"\"\nfunction  evolve!(curr::Field,  prev::Field,  a,  dt)\n  Threads.@threads  for  j  =  2:curr.ny+1\n  for  i  =  2:curr.nx+1\n  @inbounds  xderiv  =  (prev.data[i-1,  j]  -  2.0  *  prev.data[i,  j]  +  prev.data[i+1,  j])  /  curr.dx^2\n  @inbounds  yderiv  =  (prev.data[i,  j-1]  -  2.0  *  prev.data[i,  j]  +  prev.data[i,  j+1])  /  curr.dy^2\n  @inbounds  curr.data[i,  j]  =  prev.data[i,  j]  +  a  *  dt  *  (xderiv  +  yderiv)\n  end  \n  end\nend\n\n\"\"\"\n swap_fields!(curr::Field, prev::Field)\n\nSwap the data of two fields curr and prev. \n\"\"\"  \nfunction  swap_fields!(curr::Field,  prev::Field)\n  tmp  =  curr.data\n  curr.data  =  prev.data\n  prev.data  =  tmp\nend\n\n\"\"\" \n average_temperature(f::Field)\n\nCalculate average temperature of a temperature field. \n\"\"\"\naverage_temperature(f::Field)  =  sum(f.data[2:f.nx+1,  2:f.ny+1])  /  (f.nx  *  f.ny)\n\n\"\"\"\n simulate!(current, previous, nsteps)\n\nRun the heat equation solver on fields curr and prev for nsteps.\n\"\"\"\nfunction  simulate!(curr::Field,  prev::Field,  nsteps)\n\n  println(\"Initial average temperature: $(average_temperature(curr))\")\n\n  # Diffusion constant\n  a  =  0.5\n  # Largest stable time step\n  dt  =  curr.dx^2  *  curr.dy^2  /  (2.0  *  a  *  (curr.dx^2  +  curr.dy^2))\n\n  # display a nice progress bar\n  p  =  Progress(nsteps)\n\n  for  i  =  1:nsteps\n  # calculate new state based on previous state\n  evolve!(curr,  prev,  a,  dt)\n\n  # swap current and previous fields\n  swap_fields!(curr,  prev)\n\n  # increment the progress bar\n  next!(p)\n  end  \n\n  # print final average temperature\n  println(\"Final average temperature: $(average_temperature(curr))\")\nend \n```", "```\n# Fixed grid spacing\nconst  DX  =  0.01\nconst  DY  =  0.01\n# Default temperatures\nconst  T_DISC  =  5.0\nconst  T_AREA  =  65.0\nconst  T_UPPER  =  85.0\nconst  T_LOWER  =  5.0\nconst  T_LEFT  =  20.0\nconst  T_RIGHT  =  70.0\n# Default problem size\nconst  ROWS  =  2000\nconst  COLS  =  2000\nconst  NSTEPS  =  500\n\n\"\"\"\n Field(nx::Int64, ny::Int64, dx::Float64, dy::Float64, data::Matrix{Float64})\n\nTemperature field type. nx and ny are the dimensions of the field. \nThe array data contains also ghost layers, so it will have dimensions \n[nx+2, ny+2]\n\"\"\"\nmutable  struct Field{T<:AbstractArray}\n  nx::Int64\n  ny::Int64\n  # Size of the grid cells\n  dx::Float64\n  dy::Float64\n  # The temperature values in the 2D grid\n  data::T\nend\n\n# outer constructor with default cell sizes and initialized data\nField(nx::Int64,  ny::Int64,  data)  =  Field{typeof(data)}(nx,  ny,  0.01,  0.01,  data)\n\n# extend deepcopy to new type\nBase.deepcopy(f::Field)  =  Field(f.nx,  f.ny,  f.dx,  f.dy,  deepcopy(f.data))\n\n\"\"\"\n initialize(rows::Int, cols::Int, arraytype = Matrix)\n\nInitialize two temperature field with (nrows, ncols) number of \nrows and columns. If the arraytype is something else than Matrix,\ncreate data on the CPU first to avoid scalar indexing errors.\n\"\"\"\nfunction  initialize(nrows  =  1000,  ncols  =  1000,  arraytype  =  Matrix)\n  data  =  zeros(nrows+2,  ncols+2)\n\n  # generate a field with boundary conditions\n  if  arraytype  !=  Matrix\n  tmp  =  Field(nrows,  ncols,  data)\n  generate_field!(tmp)\n  gpudata  =  arraytype(tmp.data)\n  previous  =  Field(nrows,  ncols,  gpudata)\n  else\n  previous  =  Field(nrows,  ncols,  data)\n  generate_field!(previous)\n  end\n\n  current  =  Base.deepcopy(previous)\n\n  return  previous,  current\nend\n\n\"\"\"\n generate_field!(field0::Field)\n\nGenerate a temperature field.  Pattern is disc with a radius\nof nx / 6 in the center of the grid. Boundary conditions are \n(different) constant temperatures outside the grid.\n\"\"\"\nfunction  generate_field!(field::Field)\n  # Square of the disk radius\n  radius2  =  (field.nx  /  6.0)^2\n\n  for  j  =  1:field.ny+2\n  for  i  =  1:field.nx+2\n  ds2  =  (i  -  field.nx  /  2)^2  +  (j  -  field.ny  /  2)^2\n  if  ds2  <  radius2  \n  field.data[i,j]  =  T_DISC\n  else\n  field.data[i,j]  =  T_AREA\n  end\n  end  \n  end  \n\n  # Boundary conditions\n  field.data[:,1]  .=  T_LEFT\n  field.data[:,field.ny+2]  .=  T_RIGHT\n  field.data[1,:]  .=  T_UPPER\n  field.data[field.nx+2,:]  .=  T_LOWER\nend \n```", "```\n[deps]\nBenchmarkTools  =  \"6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf\"\n#Plots = \"91a5bcdd-55d7-5caf-9e0b-520d859cae80\"\nProgressMeter  =  \"92933f4c-e287-5a05-a399-4b506db050ca\" \n```", "```\n#using Plots\nusing  BenchmarkTools\nusing  AMDGPU\n\ninclude(\"heat.jl\")\ninclude(\"core_gpu.jl\")\n\n\"\"\"\n visualize(curr::Field, filename=:none)\n\nCreate a heatmap of a temperature field. Optionally write png file. \n\"\"\"  \nfunction  visualize(curr::Field,  filename=:none)\n  background_color  =  :white\n  plot  =  heatmap(\n  curr.data,\n  colorbar_title  =  \"Temperature (C)\",\n  background_color  =  background_color\n  )\n\n  if  filename  !=  :none\n  savefig(filename)\n  else\n  display(plot)\n  end\nend\n\nncols,  nrows  =  2048,  2048\nnsteps  =  500\n\n# initialize data on CPU\ncurr,  prev  =  initialize(ncols,  nrows,  ROCArray)\n# initialize data on CPU\n#curr, prev = initialize(ncols, nrows)\n\n# visualize initial field, requires Plots.jl\n#visualize(curr, \"initial.png\")\n\n# simulate temperature evolution for nsteps\n@btime  simulate!(curr,  prev,  nsteps)\n\n# visualize final field, requires Plots.jl\n#visualize(curr, \"final.png\") \n```", "```\nusing  ProgressMeter\n\n\"\"\"\n evolve!(curr::Field, prev::Field, a, dt)\n\nCalculate a new temperature field curr based on the previous \nfield prev. a is the diffusion constant and dt is the largest \nstable time step. \n\"\"\"\nfunction  evolve!(curr::Field,  prev::Field,  a,  dt)\n  Threads.@threads  for  j  =  2:curr.ny+1\n  for  i  =  2:curr.nx+1\n  @inbounds  xderiv  =  (prev.data[i-1,  j]  -  2.0  *  prev.data[i,  j]  +  prev.data[i+1,  j])  /  curr.dx^2\n  @inbounds  yderiv  =  (prev.data[i,  j-1]  -  2.0  *  prev.data[i,  j]  +  prev.data[i,  j+1])  /  curr.dy^2\n  @inbounds  curr.data[i,  j]  =  prev.data[i,  j]  +  a  *  dt  *  (xderiv  +  yderiv)\n  end  \n  end\nend\n\nfunction  evolve_cuda!(currdata,  prevdata,  dx2,  dy2,  nx,  ny,  a,  dt)\n  i  =  (blockIdx().x  -  1)  *  blockDim().x  +  threadIdx().x\n  j  =  (blockIdx().y  -  1)  *  blockDim().y  +  threadIdx().y\n  if  i  >  1  &&  j  >  1  &&  i  <  nx+2  &&  j  <  ny+2\n  @inbounds  xderiv  =  (prevdata[i-1,  j]  -  2.0  *  prevdata[i,  j]  +  prevdata[i+1,  j])  /  dx2\n  @inbounds  yderiv  =  (prevdata[i,  j-1]  -  2.0  *  prevdata[i,  j]  +  prevdata[i,  j+1])  /  dy2\n  @inbounds  currdata[i,  j]  =  prevdata[i,  j]  +  a  *  dt  *  (xderiv  +  yderiv)\n  end\n  return\nend\n\nfunction  evolve_rocm!(currdata,  prevdata,  dx2,  dy2,  nx,  ny,  a,  dt)\n  i  =  (workgroupIdx().x  -  1)  *  workgroupDim().x  +  workitemIdx().x\n  j  =  (workgroupIdx().y  -  1)  *  workgroupDim().y  +  workitemIdx().y\n  if  i  >  1  &&  j  >  1  &&  i  <  nx+2  &&  j  <  ny+2\n  @inbounds  xderiv  =  (prevdata[i-1,  j]  -  2.0  *  prevdata[i,  j]  +  prevdata[i+1,  j])  /  dx2\n  @inbounds  yderiv  =  (prevdata[i,  j-1]  -  2.0  *  prevdata[i,  j]  +  prevdata[i,  j+1])  /  dy2\n  @inbounds  currdata[i,  j]  =  prevdata[i,  j]  +  a  *  dt  *  (xderiv  +  yderiv)\n  end\n  return\nend\n\n\"\"\"\n swap_fields!(curr::Field, prev::Field)\n\nSwap the data of two fields curr and prev. \n\"\"\"  \nfunction  swap_fields!(curr::Field,  prev::Field)\n  tmp  =  curr.data\n  curr.data  =  prev.data\n  prev.data  =  tmp\nend\n\n\"\"\" \n average_temperature(f::Field)\n\nCalculate average temperature of a temperature field. \n\"\"\"\naverage_temperature(f::Field)  =  sum(f.data[2:f.nx+1,  2:f.ny+1])  /  (f.nx  *  f.ny)\n\n\"\"\"\n simulate!(current, previous, nsteps)\n\nRun the heat equation solver on fields curr and prev for nsteps.\n\"\"\"\nfunction  simulate!(curr::Field,  prev::Field,  nsteps)\n\n  println(\"Initial average temperature: $(average_temperature(curr))\")\n\n  # Diffusion constant\n  a  =  0.5\n  # Largest stable time step\n  dt  =  curr.dx^2  *  curr.dy^2  /  (2.0  *  a  *  (curr.dx^2  +  curr.dy^2))\n\n  # display a nice progress bar\n  p  =  Progress(nsteps)\n\n  for  i  =  1:nsteps\n  # calculate new state based on previous state\n  if  typeof(curr.data)  <:  ROCArray\n  nx,  ny  =  size(curr.data)  .-  2  \n  xthreads  =  ythreads  =  16\n  xblocks,  yblocks  =  cld(curr.nx,  xthreads),  cld(curr.ny,  ythreads)\n  @roc  groupsize=(xthreads,  ythreads)  gridsize  =  (xblocks,  yblocks)  evolve_rocm!(curr.data,  prev.data,  curr.dx^2,  curr.dy^2,  nx,  ny,  a,  dt)\n  else\n  evolve!(curr,  prev,  a,  dt)\n  end\n\n  # swap current and previous fields\n  swap_fields!(curr,  prev)\n\n  # increment the progress bar\n  next!(p)\n  end  \n\n  # print final average temperature\n  println(\"Final average temperature: $(average_temperature(curr))\")\nend \n```"]