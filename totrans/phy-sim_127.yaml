- en: Rigid Body Dynamics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://phys-sim-book.github.io/lec25.1-rigid_body_dynamics.html](https://phys-sim-book.github.io/lec25.1-rigid_body_dynamics.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  prefs: []
  type: TYPE_NORMAL
- en: Before jumping into ABD, let's review the traditional approach to simulate rigid
    body dynamics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by reviewing Newtonian mechanics — specifically, Newton’s second
    law for a particle at position x(t) with mass m:'
  prefs: []
  type: TYPE_NORMAL
- en: dtdx​mdtdv​​=v,=f.​
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, compute dtd(mx×v)​:'
  prefs: []
  type: TYPE_NORMAL
- en: dtd(mx×v)​​=mdtdx​×v+mx×dtdv​=mv×v+x×f=0+x×f=x×f.​
  prefs: []
  type: TYPE_NORMAL
- en: Here, mx×v is called the **angular momentum**, and x×f is the **torque**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a rigid body B, we can integrate over its volume:'
  prefs: []
  type: TYPE_NORMAL
- en: dtd​(∫B​ρx×vdx)=∫B​ρx×f(x)dx, where ρ=ρ(x) is the mass density of B at position
    x.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let c denote the center of mass (COM) of B. Then:'
  prefs: []
  type: TYPE_NORMAL
- en: dtd​(∫B​ρc×vdx)​=∫B​ρc×dtdv​dx=∫B​ρc×f(x)dx.​
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining both:'
  prefs: []
  type: TYPE_NORMAL
- en: dtd​(∫B​ρ(x−c)×vdx)=∫B​ρ(x−c)×f(x)dx.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since ∫B​ρ(x−c)×vc​dx=(∫B​ρ(x−c)dx)×vc​=0×vc​=0, we can further simplify:'
  prefs: []
  type: TYPE_NORMAL
- en: dtd​(∫B​ρ(x−c)×(v−vc​)dx)=∫B​ρ(x−c)×f(x)dx, where the right-hand side is the
    torque τ about the center of mass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Denoting the right-hand side as the torque τc​, compute the left-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: dtd​(∫B​ρ(x−c)×(v−vC​)dx)​=dtd​(∫B​ρ(x−c)×(ω×(x−c))dx)=dtd​(∫B​ρ(⟨x−c,x−c⟩ω−⟨x−c,ω⟩(x−c))dx)=IBc​ω.​
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the **inertia tensor** IBc​ is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: IBc​:=∫B​ρ(∥x−c∥22​I−(x−c)(x−c)T)dx.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since x depends on t, so does IBc​. Letting R(t) be the rotation matrix (the
    rotation of B from time 0 to t). It''s easy to verify that:'
  prefs: []
  type: TYPE_NORMAL
- en: IBc​(t)=R(t)IBc​(0)R(t)T.
  prefs: []
  type: TYPE_NORMAL
- en: 'Differentiating yields:'
  prefs: []
  type: TYPE_NORMAL
- en: τc​=ω×(Icω)+Icdtdω​.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the rigid body dynamics law becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: dtd​(mvc​)ω×(Icω)+Icdtdω​​=f,=τc​.​(25.1.1)
  prefs: []
  type: TYPE_NORMAL
- en: These equations resemble Newton's second law. The first describes how forces
    affect the linear momentum of the rigid body, while the second describes how torques
    influence its angular momentum.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a simple explicit integrator, we can simulate rigid body motion via:'
  prefs: []
  type: TYPE_NORMAL
- en: vn+1​xn+1​ωn+1​q^​n+1​qn+1​​=vn​+Δtmfn​​,=xn​+Δtvn​,=ωn​+Δt(Ic)−1(τc​−ω×(Icω)),=qn​+2Δt​ωqn​,=∣q^​n+1​∣q^​n+1​​.​(25.1.2)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, q is the unit quaternion representing the body’s rotation. Its update
    is based on a first-order approximation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'q​−q​=e2Δt​ωq−q=(cos2∥ω∥Δt​−1+∥ω∥ω​sin2∥ω∥Δt​)q=(Θ(Δt2)+2Δt​ω)q,​ which leads
    to: Δt→0lim​Δtq​−q​=21​wq,'
  prefs: []
  type: TYPE_NORMAL
- en: where w=(ωx​,ωy​,ωz​,0); q​ is the composition of the rotation represented by
    the rotation vector Δtω and the rotation represented by q.
  prefs: []
  type: TYPE_NORMAL
- en: '***Remark 25.1.1 (Rotation Vector to Quaternion).*** A rotation of angle θ
    around the axis defined by the unit vector u=(ux​,uy​,uz​)=ux​i+uy​j+uz​k can
    be represented by the quaternion q=e2θ​(ux​i+uy​j+uz​k)=cos2θ​+(ux​i+uy​j+uz​k)sin2θ​=cos2θ​+usin2θ​'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
