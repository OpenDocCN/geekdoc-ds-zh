- en: 7 Draw maps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 绘制地图
- en: 原文：[https://socviz.co/maps.html](https://socviz.co/maps.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://socviz.co/maps.html](https://socviz.co/maps.html)
- en: Choropleth maps show geographical regions colored, shaded, or graded according
    to some variable. They are visually striking, especially when the spatial units
    of the map are familiar entities, like the countries of the European Union, or
    states in the US. But maps like this can also sometimes be misleading. Although
    it is not a dedicated Geographical Information System (GIS), R can work with geographical
    data, and ggplot can make choropleth maps. But we’ll also consider some other
    ways of representing data like this.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 着色图（Choropleth maps）根据某些变量对地理区域进行着色、阴影或分级。它们视觉上引人注目，尤其是当地图的空间单元是熟悉的实体时，例如欧盟的国家或美国的州。但这样的地图有时也可能具有误导性。尽管它不是一个专门的地理信息系统（GIS），R
    可以与地理数据一起工作，ggplot 可以制作着色图。但我们也会考虑其他表示此类数据的方法。
- en: Figure [7.1](maps.html#fig:ch-07-maps1) shows a series of maps of the 2012 US
    general election results. Reading from the top left, From top left we see, first,
    a state-level, two-color map where the margin of victory can be high (a darker
    blue or red) or low (a lighter blue or red). The color scheme has no midpoint.
    Second, we see a two-color, county-level maps colored red or blue depending on
    the winner. Third is a county-level map where the color of red and blue counties
    is graded by the size of the vote share. Again, the color scale has no midpoint.
    Fourth is a county-level map with a continuous color gradient from blue to red,
    but that passes through a purple midpoint for areas where the balance of the vote
    is close to even. The map in the bottom left distorts the geographical boundaries
    by squeezing or inflating them to reflect the population of the county shown.
    Finally in the bottom right we see a cartogram, where states are drawn using square
    tiles, and the number of tiles each state gets is proportional to the number of
    electoral college votes it has (which in turn is proportional to that state’s
    population).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [7.1](maps.html#fig:ch-07-maps1) 展示了一系列 2012 年美国大选结果的地图。从左上角开始阅读，我们首先看到的是一个州级别的双色地图，胜利的差距可以是很大的（较深的蓝色或红色）或很小的（较浅的蓝色或红色）。颜色方案没有中间点。其次，我们看到的是根据获胜者着色为红色或蓝色的县级别地图。第三是县级别的地图，红色和蓝色县的着色根据选票份额的大小进行分级。同样，颜色刻度没有中间点。第四是县级别的地图，从蓝色到红色的连续颜色渐变，但通过紫色中间点穿过选票平衡接近均等的地区。左下角的地图通过挤压或膨胀地理边界来扭曲地理边界，以反映显示的县的人口。最后在右下角我们看到的是人口图，州使用方形瓷砖绘制，每个州获得的瓷砖数量与该州拥有的选举人票数成比例（这反过来又与该州的人口成比例）。
- en: '![2012 US election results maps of different kinds.](../Images/a26bf45fb34a8e5e4a89bd93eb7d673a.png)![2012
    US election results maps of different kinds.](../Images/b56c24f4318aedb73444ea9a158d08c0.png)![2012
    US election results maps of different kinds.](../Images/3067a46e627fe4a23f0de2f827c5b870.png)![2012
    US election results maps of different kinds.](../Images/7e57c406818fe4596df50a44d2bff04a.png)![2012
    US election results maps of different kinds.](../Images/46b0dbbd173026c3854d04f209ed4485.png)![2012
    US election results maps of different kinds.](../Images/1b3ad18732fdaff0ed0597ad5395eadc.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![2012 年美国不同类型的选举结果地图。](../Images/a26bf45fb34a8e5e4a89bd93eb7d673a.png)![2012
    年美国不同类型的选举结果地图。](../Images/b56c24f4318aedb73444ea9a158d08c0.png)![2012 年美国不同类型的选举结果地图。](../Images/3067a46e627fe4a23f0de2f827c5b870.png)![2012
    年美国不同类型的选举结果地图。](../Images/7e57c406818fe4596df50a44d2bff04a.png)![2012 年美国不同类型的选举结果地图。](../Images/46b0dbbd173026c3854d04f209ed4485.png)![2012
    年美国不同类型的选举结果地图。](../Images/1b3ad18732fdaff0ed0597ad5395eadc.png)'
- en: 'Figure 7.1: 2012 US election results maps of different kinds.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：2012 年美国不同类型的选举结果地图。
- en: Each of these maps shows data for the same event, but the impressions they convey
    are very different. Each faces two main problems. First, the underlying quantities
    of interest are only partly spatial. The number of electoral college votes won
    and the share of votes cast within a state or county are expressed in spatial
    terms, but ultimately it is the numbers of people within those regions that matter.
    Second, the regions themselves are of wildly differing sizes, and they differ
    in a way that is not well-correlated with the magnitudes of the underlying votes.
    The map makers also face choices that would arise in many other representations
    of the data. Do we want to just show who won each state in absolute terms (this
    is all that matters for the actual result, in the end) or do we want to indicate
    how close the race was? Do we want to display the results at some finer level
    of resolution than is relevant to the outcome, such as county rather than state
    counts? How can we convey that different data points can carry very different
    weights, because they represent vastly larger or smaller numbers of people? It
    is tricky enough to convey these choices honestly with different colors and shape
    sizes on a simple scatterplot. Often, a map is like a weird grid that you are
    forced to conform to even though you know it systematically misrepresents what
    you want to show.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些地图展示了同一事件的数据，但它们传达的印象却非常不同。每个地图都面临两个主要问题。首先，我们感兴趣的底层数量只有部分是空间性的。赢得的选举人票数和州或县内投出的选票份额是以空间术语表达的，但最终重要的是这些区域中的人数。其次，这些区域本身的大小差异很大，并且它们的大小与底层投票的规模之间没有很好的相关性。地图制作者还面临许多其他数据表示中会出现的选择。我们只想显示每个州谁赢得了绝对优势（这最终是实际结果中唯一重要的事情）吗？或者我们想表明比赛有多接近？我们想在比结果相关的更细的分辨率级别上显示结果，比如县而不是州计数吗？我们如何传达不同数据点可以携带非常不同的权重，因为它们代表的人数差异很大？用不同的颜色和形状大小在简单的散点图上诚实地传达这些选择已经足够棘手。通常，地图就像一个奇怪的网格，你被迫遵守它，即使你知道它系统地歪曲了你想要展示的内容。
- en: This is not always the case, of course. Sometimes our data really is purely
    spatial, and we can observe it at a fine enough level of detail that we can represent
    spatial distributions honestly and in a very compelling way. But the spatial features
    of much social science are collected through entities such as precincts, neighborhoods,
    metro areas, census tracts, counties, states, and nations. These may themselves
    be socially contingent. A great deal of cartographic work with social-scientific
    variables involves working both with and against that arbitrariness.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，情况并不总是如此。有时我们的数据确实是纯粹的空间数据，我们可以在足够细的细节水平上观察到它，从而以诚实和非常有说服力的方式表示空间分布。但许多社会科学的空间特征是通过诸如选区、邻里、大都市区、人口普查区、县、州和国家等实体收集的。这些本身可能就是社会相关的。大量使用社会科学变量的制图工作既涉及利用这种任意性，也涉及对抗这种任意性。
- en: 7.1 Map U.S. state-level data
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 绘制美国州级数据地图
- en: Let’s take a look at some data for the 2016 U.S. presidential election and see
    how we might plot it in R. The `election` dataset has various measures of the
    vote and vote shares by state. Here we pick some columns and sample a few rows
    at random.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看2016年美国总统选举的一些数据，并看看我们如何在R中绘制它。`election`数据集包含了各州投票和投票份额的各种度量。在这里，我们挑选了一些列并随机抽取了几行样本。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![2016 Election Results. Would a two-color choropleth map be more informative
    than this, or less?](../Images/41812dbdbd37c2e03ec02011347ccf84.png) Figure 7.2:
    2016 Election Results. Would a two-color choropleth map be more informative than
    this, or less?'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![2016选举结果。与这个相比，双色渐变图会更具有信息量吗，还是更少？](../Images/41812dbdbd37c2e03ec02011347ccf84.png)
    图7.2：2016选举结果。与这个相比，双色渐变图会更具有信息量吗，还是更少？'
- en: The FIPS code is a federal code that numbers states and territories of the US.
    It extends to the county level with an additional four digits, so every county
    in the US has a unique six-digit identifier, where the first two digits represent
    the state. This dataset also contains the census region of each state.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: FIPS代码是一个联邦代码，用于编号美国的州和领地。它扩展到县级，增加四位数字，因此美国每个县都有一个唯一的六位数字标识符，其中前两位数字代表州。此数据集还包含每个州的普查区域。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first thing you should remember about spatial data is that you don’t have
    to represent it spatially. We’ve been working with country-level data throughout,
    and have yet to make a map of it. Of course, spatial representations can be very
    useful, and sometimes absolutely necesssary. But we can start with a state-level
    dotplot, faceted by region. This plot brings together many aspects of plot construction
    that we have worked on so far, including subsetting data, reordering results by
    a second variable, and using a scale formatter. It also introduces some new options,
    like allowing free scales on an axis, and manually setting the color of an aesthetic.
    We break up the construction process into several steps by creating intermediate
    objects (`p0`, `p1`, `p2`) along the way. It makes the code a little more readable.
    Bear in mind also that, as always, you can try plotting each of these intermediate
    objects as well (just type their name at the console and hit return) to see what
    they look like. What happens if you remove the `scales="free_y"` argument to `facet_wrap()`?
    What happens if you delete the call to `scale_color_manual()`?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于空间数据，你应该记住的第一件事是，你不必以空间形式表示它。我们一直在处理国家层面的数据，但还没有制作出它的地图。当然，空间表示可以非常有用，有时甚至绝对必要。但我们可以从州级别的散点图开始，按区域进行分面。这个图汇集了我们迄今为止所做的一些绘图构建方面，包括数据子集、按第二个变量重新排序结果和使用刻度格式化器。它还引入了一些新选项，例如允许轴上有自由刻度，以及手动设置美学的颜色。我们通过在过程中创建中间对象（`p0`、`p1`、`p2`）将构建过程分解成几个步骤，这使得代码更易于阅读。记住，你始终可以尝试绘制这些中间对象（只需在控制台中输入它们的名称并按回车键）以查看它们的外观。如果你从`facet_wrap()`中移除`scales="free_y"`参数会发生什么？如果你删除了`scale_color_manual()`的调用会发生什么？
- en: As always, the first task in drawing a map is to get a data frame with the right
    information in it, and in the right order. First we load R’s `maps` package, which
    provides us with some pre-drawn map data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，绘制地图的第一步是获取包含正确信息且顺序正确的数据框。首先，我们加载R的`maps`包，它为我们提供了一些预先绘制的地图数据。
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This just a data frame. It has more than 15,000 rows because you need a lot
    of lines to draw a good-looking map. We can make a blank state map right away
    with this data, using `geom_polygon()`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个数据框。它有超过15,000行，因为绘制一张好看的地图需要很多线条。我们可以立即使用`geom_polygon()`函数用这些数据制作一个空白州地图。
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The map is plotted with latitude and longitude points, which are there as scale
    elements mapped to the x and y axes. A map is, after all, just a set of lines
    drawn in the right order on a grid.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该地图使用经纬度点绘制，这些点作为比例元素映射到x轴和y轴。毕竟，地图只是在一组网格上按正确顺序绘制的一系列线条。
- en: '![A first US map](../Images/50400274958d6a7511ccc1502da75fab.png) Figure 7.3:
    A first US map'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![第一张美国地图](../Images/50400274958d6a7511ccc1502da75fab.png) 图7.3：第一张美国地图'
- en: We can map the `fill` aesthetic to `region` and change the `color` mapping to
    a light gray and thin the lines to make the state borders a little nicer. We’ll
    also tell R not to plot a legend.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`fill`美学映射到`region`，并将`color`映射更改为浅灰色，同时将线条变细以使州边界看起来更美观。我们还会告诉R不要绘制图例。
- en: '![Coloring the states](../Images/12b837f02b22ed78c883832fbba6c494.png) Figure
    7.4: Coloring the states'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![着色各州](../Images/12b837f02b22ed78c883832fbba6c494.png) 图7.4：着色各州'
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, let’s deal with the projection. By default the map is plotted using the
    venerable Mercator projection. It doesn’t look that good. Assuming we are not
    planning on sailing across the Atlantic, the practical virtues of this projection
    are not much use to us, either. If you glance again at the maps in Figure [7.1](maps.html#fig:ch-07-maps1),
    you’ll notice they look nicer. This is because they are using an Albers projection.
    (Look, for example, at the way that the US-Canadian border is a little curved
    along the 49th parallel from Washington state to Minnesota, rather than not a
    straight line.) Techniques for map projection are a fascinating world of their
    own, but for now just remember we can transform the default projection used by
    `geom_polygon()`, via the `coord_map()` function. You’ll remember that we said
    that projection onto a coordinate system is a necessary part of the plotting process
    for any data. Normally it is left implicit. We have not usually had to specify
    a `coord_` function because most of the time we have drawn our plots on a simple
    Cartesian plane. Maps are more complex. Our locations and borders are defined
    on a more or less spherical object, which means must have a method for transforming
    or projecting our points and lines from a round to a flat surface. The many ways
    of doing this gives us a menu of cartographic options.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理投影问题。默认情况下，地图使用的是备受尊敬的墨卡托投影。它看起来并不好。如果我们不打算横渡大西洋，这个投影的实用优点对我们来说也没有多大用处。如果你再次浏览图[7.1](maps.html#fig:ch-07-maps1)中的地图，你会注意到它们看起来更漂亮。这是因为它们使用了Albers投影。（看看，例如，美国和加拿大边界是如何沿着华盛顿州到明尼苏达州的第49平行线略微弯曲，而不是一条直线。）地图投影的技术是一个迷人的领域，但到目前为止，只需记住我们可以通过`coord_map()`函数转换`geom_polygon()`默认使用的投影。你还记得我们说过，将投影到坐标系是任何数据绘图过程中的必要部分。通常情况下，它是隐含的。我们通常不需要指定`coord_`函数，因为我们大多数时候都是在简单的笛卡尔平面上绘制我们的图表。地图更复杂。我们的位置和边界定义在一个或多或少是球形的物体上，这意味着我们必须有一种方法将我们的点和线从圆形表面转换到平面。这样做的方式有很多，给我们提供了一系列的制图选项。
- en: The Albers projection requires two latitude parameters, `lat0` and `lat1`. We
    give them their conventional values for a US map here. (Try messing around with
    their values and see what happens when you redraw the map.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Albers投影需要两个纬度参数，`lat0`和`lat1`。在这里，我们为美国地图给出了它们的传统值。（尝试调整它们的值，看看当你重新绘制地图时会发生什么。）
- en: '![Improving the projection](../Images/7e82b98cf4878a25e166d767073cf3f4.png)
    Figure 7.5: Improving the projection'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![改进投影](../Images/7e82b98cf4878a25e166d767073cf3f4.png) 图7.5：改进投影'
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now we need to get our own data on to the map. Remember, underneath that map
    is just a big data frame specifying a large number of lines that need to be drawn.
    We have to merge our data with that data frame. Somewhat annoyingly, in the map
    data the state names (in a variable named `region`) are in lower case. We can
    create a variable in our own data frame to correspond to this, using the `tolower()`
    function to convert the `state` names. We then use `left_join` to merge but you
    could also use `merge(..., sort = FALSE)`. This merge step is important! You need
    to take care that the values of the key variables you are matching on really do
    exactly correspond to one another. If they do not, missing values (`NA` codes)
    will be introduced into your merge, and the lines on your map will not join up.
    This will result in a weirdly “sharded” appearance to your map when R tries to
    fill the polygons. Here, the `region` variable is the only column with the same
    name in both the data sets we are joining, and so the `left_join()` function uses
    it used by default. If the keys have different names in each data set you can
    specify that, if needed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将我们自己的数据放到地图上。记住，在那张地图下面只是一个大型的数据框，指定了需要绘制的大量线条。我们必须将我们的数据与该数据框合并。有些令人烦恼的是，在地图数据中，州名（在名为`region`的变量中）都是小写的。我们可以使用`tolower()`函数将`state`名称转换为小写，在我们的数据框中创建一个对应的变量。然后我们使用`left_join`进行合并，但你也可以使用`merge(...,
    sort = FALSE)`。这个合并步骤很重要！你需要确保你匹配的关键变量的值确实完全对应。如果不对应，你的合并中将会引入缺失值（`NA`代码），你的地图上的线条将不会连接起来。这将导致当R尝试填充多边形时，你的地图看起来会非常奇怪地“碎片化”。在这里，`region`变量是我们连接的两个数据集中唯一具有相同名称的列，因此`left_join()`函数默认使用它。如果每个数据集中的键名不同，你可以指定，如果需要的话。
- en: To reiterate, it is important to know your data and variables well enough to
    check that they have merged properly. Do not do it blindly. For example, if rows
    corresponding to Washington DC were named “washington dc” in the `region` variable
    of your `election` data frame, but “district of columbia” in the corresponding
    `region` variable of your map data, then merging on `region` would mean no rows
    in the `election` data frame would match “washington dc” in the map data, and
    the resulting merged variables for those rows would all be coded as missing. Maps
    that look broken when you draw them are usually caused by merge errors. But errors
    can also be subtle. For example, perhaps one of your state names inadvertently
    has a leading (or, worse, a trailing) space as a result of the data originally
    being imported from elsewhere and not fully cleaned. That would mean, for example,
    that `california` and `california␣` are different strings, and the match would
    fail. In ordinary use you might not easily see the extra space (designated here
    by `␣`). So, be careful.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一遍，了解你的数据和变量非常重要，以确保它们已经正确合并。不要盲目操作。例如，如果你的`election`数据框中的`region`变量中对应华盛顿特区的行被命名为“washington
    dc”，但在地图数据中相应的`region`变量中为“district of columbia”，那么基于`region`的合并意味着`election`数据框中的任何行都不会匹配地图数据中的“washington
    dc”，并且这些行的合并变量都将被编码为缺失。当你绘制地图时看起来破损的地图通常是由合并错误引起的。但错误也可能是微妙的。例如，可能由于数据最初是从其他地方导入且未完全清理，导致某个州名不小心有一个前导（或者更糟糕的是，一个尾随）空格。这意味着，例如，`california`和`california␣`是不同的字符串，匹配将失败。在普通使用中，你可能不容易看到额外的空格（在此处用`␣`表示）。因此，要小心。
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have now merged the data. Take a look at the object with `head(us_states_elec)`.
    Now that everything is in one big data frame, we can plot it in a map.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经合并了数据。用`head(us_states_elec)`查看对象。现在，由于所有内容都在一个大的数据框中，我们可以在地图上绘制它。
- en: '![Mapping the results](../Images/d0857ad451b1d786f96fdbb38d2809e8.png) Figure
    7.6: Mapping the results'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![映射结果](../Images/d0857ad451b1d786f96fdbb38d2809e8.png) 图7.6：映射结果'
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To complete the map, we will use our party colors for the fill, move the legend
    to the bottom, and add a title. Finally we will remove the grid lines and axis
    labels, which aren’t really needed, by defining a special theme for maps that
    removes most of the elements we don’t need. (We’ll learn more about themes in
    Chapter [8](refineplots.html#refineplots). You can also see the code for the map
    theme in the Appendix.)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成地图，我们将使用我们的党派颜色进行填充，将图例移动到底部，并添加一个标题。最后，我们将通过定义一个特殊的地图主题来移除大多数我们不需要的元素，从而删除网格线和轴标签，这些实际上并不需要。（我们将在第[8](refineplots.html#refineplots)章中了解更多关于主题的内容。你还可以在附录中查看地图主题的代码。）
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![Election 2016 by State](../Images/0101fe11ace19e521d5f1150cb4c441b.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![按州划分的2016年选举](../Images/0101fe11ace19e521d5f1150cb4c441b.png)'
- en: 'Figure 7.7: Election 2016 by State'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：按州划分的2016年选举
- en: With the map data frame in place, we can map other variables if we like. Let’s
    try a continuous measure, such as the percentage of the vote received by Donald
    Trump. To begin with, we just map the variable we want (`pct_trump`) to the `fill`
    aesthetic, and see what `geom_polygon()` does by default.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图数据框已经就绪的情况下，如果我们愿意，可以映射其他变量。让我们尝试一个连续度量，比如唐纳德·特朗普收到的选票百分比。首先，我们只需将我们想要的变量（`pct_trump`）映射到`fill`美学，看看`geom_polygon()`默认情况下会做什么。
- en: '![Two versions of Percent Trump by State](../Images/8189ee7190135dfd038997b7b9794b77.png)![Two
    versions of Percent Trump by State](../Images/9fd04466e47e74a20ef939fb88e33aee.png)
    Figure 7.8: Two versions of Percent Trump by State'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![按州划分的特朗普百分比的两个版本](../Images/8189ee7190135dfd038997b7b9794b77.png) ![按州划分的特朗普百分比的两个版本](../Images/9fd04466e47e74a20ef939fb88e33aee.png)
    图7.8：按州划分的特朗普百分比的两个版本'
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The default color used in the `p1` object is blue. Just for reasons of convention,
    that isn’t what is wanted here. In addition, the gradient runs in the wrong direction.
    In our case, the standard interpretation is that a higher vote share makes for
    a darker color. We fix both of these problems in the `p2` object by specifying
    the `scale` directly. We’ll use the values we created earlier in `party_colors`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`p1`对象中使用的默认颜色是蓝色。仅仅出于惯例，这并不是我们想要的。此外，渐变的方向也是错误的。在我们的情况下，标准的解释是更高的投票份额对应着更深的颜色。我们通过直接指定`scale`来修复`p2`对象中的这两个问题。我们将使用之前在`party_colors`中创建的值。'
- en: For election results, we might prefer a gradient that diverges from a midpoint.
    The `scale_gradient2()` function gives us a blue-red spectrum that passes through
    white by default. Alternatively, we can re-specify the mid-level color along with
    the high and low colors. We will make purple our midpoint, and use the `muted()`
    function from the `scales` library to tone down the color a little.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选举结果，我们可能更倾向于一个从中点发散的梯度。`scale_gradient2()` 函数为我们提供了一个默认通过白色的蓝-红光谱。或者，我们可以重新指定中点颜色以及高色和低色。我们将紫色作为中点，并使用
    `scales` 库中的 `muted()` 函数稍微降低一下颜色。
- en: '![Two views of Trump vs Clinton share: a white midpoint, and a Purple America
    version.](../Images/5a8f3b4c873f04e7a842cc0d670914c6.png)![Two views of Trump
    vs Clinton share: a white midpoint, and a Purple America version.](../Images/24ca50be3c0e06e458c318aa5d404727.png)
    Figure 7.9: Two views of Trump vs Clinton share: a white midpoint, and a Purple
    America version.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![特朗普对克林顿共享的两个视图：一个白色中点，和一个紫色美国版本。](../Images/5a8f3b4c873f04e7a842cc0d670914c6.png)![特朗普对克林顿共享的两个视图：一个白色中点，和一个紫色美国版本。](../Images/24ca50be3c0e06e458c318aa5d404727.png)
    图 7.9：特朗普对克林顿共享的两个视图：一个白色中点，和一个紫色美国版本。'
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you take a look at the gradient scale for this first “purple America” map,
    in Figure [7.9](maps.html#fig:ch-07-purple1st), you’ll see that it extends very
    high on the Blue side. This is because Washington DC is included in the data,
    and hence the scale. Even though it is barely visible on the map, DC has by far
    the highest points margin in favor of the Democrats of any unit of observation
    in the data. If we omit it, we’ll see that our scale shifts in a way that does
    not just affect the top of the blue end, but re-centers the whole gradient and
    makes the red side more vivid as a result. Figure [7.10](maps.html#fig:ch-07-purple2nd)
    shows the result.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看这张第一张“紫色美国”地图的渐变尺度，如图 [7.9](maps.html#fig:ch-07-purple1st) 所示，你会发现它在蓝色端非常高。这是因为华盛顿特区包含在数据中，因此也在尺度中。尽管它在地图上几乎看不见，但华盛顿特区在数据中任何观察单位中，对民主党支持率的优势都远远高于其他任何单位。如果我们省略它，我们会看到我们的尺度发生了变化，这不仅影响了蓝色端的顶部，而且使整个梯度重新居中，并使红色端更加鲜明。图
    [7.10](maps.html#fig:ch-07-purple2nd) 展示了结果。
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Figure 7.10: A Purple America version of Trump vs Clinton that excludes results
    from Washington, DC.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10：排除华盛顿特区结果的特朗普对克林顿的紫色美国版本。
- en: '![A Purple America version of Trump vs Clinton that excludes results from Washington,
    DC.](../Images/4f8d8961e73231bd264b9fa571a330f0.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![排除华盛顿特区结果的特朗普对克林顿的紫色美国版本](../Images/4f8d8961e73231bd264b9fa571a330f0.png)'
- en: This brings out the familiar choropleth problem of having geographical areas
    that only partially represent the variable we are mapping. In this case, we’re
    showing votes spatially, but what really matters is the number of people who voted.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这揭示了熟悉的渐变问题，即地理区域只部分代表我们正在映射的变量。在这种情况下，我们展示的是选票的空间分布，但真正重要的是投票的人数。
- en: 7.2 America’s ur-choropleths
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 美国的原始渐变图
- en: In the U.S. case, administrative areas vary widely in geographical area and
    they also vary widely in population size. The problem is evident at the state
    level, as we have seen, also arises even more at the county level. County-level
    US maps can be aesthetically pleasing, because of the added detail they bring
    to a national map. But they also make it easy to present a geographical distribution
    to insinuate an explanation. The results can be tricky to work with. When producing
    county maps, it is important to remember that the states of New Hampshire, Rhode
    Island, Massachussetts, and Connecticut are all smaller in area than any of the
    ten largest Western *counties*. Many of those counties have fewer than a hundred
    thousand people living in them. Some have fewer than ten thousand inhabitants.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国的情况下，行政区域的地理面积和人口规模差异很大。正如我们所见，这个问题在州一级很明显，在县一级更是如此。县一级的美国地图在美学上可能很吸引人，因为它们为全国地图增添了额外的细节。但它们也使得展示地理分布以暗示解释变得容易。结果可能很难处理。在制作县地图时，重要的是要记住，新罕布什尔州、罗德岛州、马萨诸塞州和康涅狄格州的面积都小于十个最大的西部**县**。其中许多县的人口少于十万人。有些县的人口甚至少于一万。
- en: The result is that most choropleth maps of the U.S. for whatever variable in
    effect show population density more than anything else. The other big variable,
    in the U.S. case, is Percent Black. Let’s see how to draw these two maps in R.
    The procedure is essentially the same as it was for the state-level map. We need
    two data frames, one containing the map data, and the other containing the fill
    variables we want plotted. Because there are more than three thousand counties
    in the United States, these two data frames will be rather larger than they were
    for the state-level maps.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，大多数美国按变量划分的分级色地图实际上更多地显示了人口密度。在美国的情况下，另一个重要变量是黑人百分比。让我们看看如何在 R 中绘制这两张地图。这个过程基本上与州级地图相同。我们需要两个数据框，一个包含地图数据，另一个包含我们想要绘制的填充变量。由于美国有超过三千个县，这两个数据框将比州级地图大得多。
- en: 'The datasets are included in the `socviz` library. The county map data frame
    has already been processed a little in order to transform it to an Albers projection,
    and also to relocate (and rescale) Alaska and Hawaii so that they fit into an
    area in the bottom left of the figure. This is better than throwing away two states
    from the data. The steps for this transformation and relocation are not shown
    here. If you want to see how it’s done, consult the Supplementary Material for
    details. Let’s take a look at our county map data first:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据集包含在 `socviz` 库中。县级地图数据框已经经过一些处理，以便将其转换为 Albers 投影，并且重新定位（并缩放）阿拉斯加和夏威夷，以便它们适合图的下左角区域。这比从数据中丢弃两个州要好。这个转换和重新定位的步骤在这里没有展示。如果你想了解如何完成，请参阅补充材料以获取详细信息。让我们先看看我们的县级地图数据：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It looks the same as our State map data frame, but it is much larger, running
    to almost 200,000 rows. The `id` field is the FIPS code for the county. Next,
    we have a data frame with county-level demographic, geographic, and election data:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来和我们的州地图数据框一样，但规模要大得多，几乎有 200,000 行。`id` 字段是县的 FIPS 代码。接下来，我们有一个包含县级人口、地理和选举数据的数据框：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This data frame includes information for entities besides counties, though not
    for all variables. If you look at the top of the object with `head()` you’ll notice
    that the first row of has an `id` of `0`. Zero is the FIPS code for the entire
    United States, and thus the data in this row are for the whole country. Similarly,
    the second row has an `id` of 01000, which corresponds to the State FIPS of 01,
    for the whole of Alabama. As we merge `county_data` in to `county_map`, these
    state rows will be dropped, along with the national row, as `county_map` only
    has county-level data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据框包含了除县以外实体的信息，但并非所有变量都有。如果你用 `head()` 函数查看对象顶部，你会注意到第一行的 `id` 为 `0`。零是整个美国的
    FIPS 代码，因此这一行的数据代表整个国家。同样，第二行的 `id` 为 01000，对应的是阿拉巴马州的州 FIPS 代码 01。当我们把 `county_data`
    合并到 `county_map` 中时，这些州行以及国家行都会被删除，因为 `county_map` 只包含县级数据。
- en: 'We merge the data frames using the shared FIPS `id` column:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用共享的 FIPS `id` 列合并数据框：
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With the data merged, we can map the population density per square mile.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 数据合并后，我们可以绘制每平方英里的人口密度图。
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Figure 7.11: US population density by county.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11：按县划分的美国人口密度。
- en: '![US population density by county.](../Images/5878e805ae980e18438416dbc167051d.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![按县划分的美国人口密度。](../Images/5878e805ae980e18438416dbc167051d.png)'
- en: If you try out the `p1` object you will see that ggplot produces a legible map,
    but by default it chooses an unordered categorical layout. This is because the
    `pop_dens` variable is not ordered. We could recode it so that R is aware of the
    ordering. Alternatively, we can manually supply the right sort of scale using
    the `scale_fill_brewer()` function, together with a nicer set of labels. We will
    learn more about this scale function in the next chapter. We also tweak how the
    legend is drawn using the `guides()` function to make sure each element of the
    key appears on the same row. Again, we will see this use of `guides()` in more
    detail in the next chapter. The use of `coord_equal()` makes sure that the relative
    scale of our map does not change even if we alter the overall dimensions of the
    plot.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用 `p1` 对象，你会看到 ggplot 生成了一个可读的地图，但默认情况下它选择了一个无序的分类布局。这是因为 `pop_dens` 变量没有排序。我们可以重新编码它，让
    R 知道排序。或者，我们可以使用 `scale_fill_brewer()` 函数手动提供正确的排序，同时提供一组更好的标签。我们将在下一章中学习更多关于这个缩放函数的内容。我们还使用
    `guides()` 函数调整图例的绘制方式，以确保关键元素出现在同一行上。我们将在下一章中更详细地看到 `guides()` 的这种用法。使用 `coord_equal()`
    确保即使我们改变整个图表的尺寸，地图的相对比例也不会改变。
- en: We can now do exactly the same thing for our map of percent Black population
    by county. Once again, we specify a palette for the `fill` mapping using `scale_fill_brewer()`,
    this time choosing a different range of hues for the map.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为按县划分的黑人人口百分比地图做完全相同的事情。再次，我们使用 `scale_fill_brewer()` 为 `fill` 映射指定调色板，这次选择地图的不同色调范围。
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Figure 7.12: Percent Black population by county.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12：按县划分的黑人人口百分比。
- en: '![Percent Black population by county.](../Images/b477ed9a2c1be43e478f72930491524a.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![按县划分的黑人人口百分比](../Images/b477ed9a2c1be43e478f72930491524a.png)'
- en: Figures [7.11](maps.html#fig:ch-07-urchoro1) and [7.12](maps.html#fig:ch-07-urchoro2)
    are America’s “ur-choropleths”. Between the two of them, population density and
    percent Black will do a lot to obliterate many a suggestively-patterned map of
    the United States. These two variables aren’t *explanations* of anything in isolation,
    but if it turns out that it is more useful to know one or both of them instead
    of the thing you’re plotting, you probably want to reconsider your theory.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [7.11](maps.html#fig:ch-07-urchoro1) 和 [7.12](maps.html#fig:ch-07-urchoro2)
    是美国的“原始 choropleths”。在这两个变量之间，人口密度和黑人百分比将对消除许多具有暗示性图案的美国地图产生很大影响。这两个变量在孤立的情况下并不是任何事物的*解释*，但如果发现知道其中一个或两个变量比你要绘制的图表更有用，你可能需要重新考虑你的理论。
- en: As an example of the problem in action, let’s draw two new county-level choropleths.
    The first is an effort to replicate a poorly-sourced but widely-circulated county
    map of firearm-related suicide rates in the United States. The `su_gun6` variable
    in `county_data` (and `county_full`) is a measure of the rate of all firearm-related
    suicides between 1999 and 2015\. The rates are binned into six categories. We
    have a `pop_dens6` variable that divides the population density into six categories,
    too.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作为问题实际作用的例子，让我们绘制两个新的县级 choropleths。第一个是试图复制一个来源不明但广泛传播的美国枪支相关自杀率县级地图。`county_data`（和
    `county_full`）中的 `su_gun6` 变量是衡量1999年至2015年间所有枪支相关自杀率的指标。这些比率被分为六个类别。我们还有一个 `pop_dens6`
    变量，它将人口密度也分为六个类别。
- en: We first draw a map with the `su_gun6` variable. We will match the color palettes
    between the maps, but for the population map we will flip our color scale around
    so that less populated areas are shown in a darker shade. We do this by using
    a function from the RColorBrewer library to manually create two palettes. The
    `rev()` function used here reverses the order of a vector.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `su_gun6` 变量绘制地图。我们将匹配地图之间的颜色调色板，但对于人口地图，我们将翻转颜色比例，以便人口较少的地区以较深的色调显示。我们通过使用
    RColorBrewer 库中的函数手动创建两个调色板来完成此操作。这里使用的 `rev()` 函数反转了向量的顺序。
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `brewer.pal()` function produces evenly-spaced color schemes to order from
    any one of several named palettes. The colors are specified in hexadecimal format.
    Again, we will learn more about color specifications and how to manipulate palettes
    for mapped variables in Chapter [8](refineplots.html#refineplots).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`brewer.pal()` 函数产生均匀间隔的颜色方案，可以从几个命名调色板中的任何一个进行排序。颜色以十六进制格式指定。再次强调，我们将在第 [8](refineplots.html#refineplots)
    章节中学习更多关于颜色规范以及如何操纵映射变量的调色板。'
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Having drawn the gun plot, we use almost exactly the same code to draw the reverse-coded
    population density map.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制完枪支图表后，我们使用几乎完全相同的代码绘制反向编码的人口密度地图。
- en: '[PRE28]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It’s clear that the two maps are not identical. However, the visual impact of
    the first has a lot in common with the second. The dark bands in the West (except
    for California) stand out, and fade as we move toward the center of the country.
    There are some strong similarities elsewhere on the map too, such as in the Northeast.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这两张地图并不完全相同。然而，第一张地图的视觉影响与第二张有很多共同之处。西部（除了加利福尼亚州）的深色带子突出，并向国家中心逐渐变淡。地图上其他地方也有一些强烈的相似之处，例如在东北部。
- en: The gun-related suicide measure is already expressed as a rate. It is the number
    of qualifying deaths in a county, divided by that county’s population. Normally,
    we standardize in this way to “control for” the fact that larger populations will
    tend to produce more gun-related suicides just because they have more people in
    them. However, this sort of standardization has its limits. In particular, when
    the event of interest is not very common, and there is very wide variation in
    the base size of the units, then the denominator (e.g., the population size) starts
    to be expressed more and more in the standardized measure.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 枪支相关自杀的指标已经表示为比率。这是在县内符合条件的死亡人数除以该县的人口数。通常，我们以这种方式进行标准化，以“控制”较大的人口数量会导致更多枪支相关自杀的事实。然而，这种标准化有其局限性。特别是，当感兴趣的事件不太常见，且单位的基本规模差异很大时，分母（例如，人口规模）开始越来越多地以标准化测量的形式表达。
- en: '![Gun-related suicides by county; Reverse-coded population density by county.
    Before tweeting this picture, please read the text for discussion of what is wrong
    with it.](../Images/2a742741590b78d74676dfecc884c5b2.png)![Gun-related suicides
    by county; Reverse-coded population density by county. Before tweeting this picture,
    please read the text for discussion of what is wrong with it.](../Images/1a4e08124d11e0309a71b43af45fc48e.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![按县分的枪支相关自杀；按县分反向编码的人口密度。在转发这张图片之前，请阅读关于其问题的讨论文本。](../Images/2a742741590b78d74676dfecc884c5b2.png)![按县分的枪支相关自杀；按县分反向编码的人口密度。在转发这张图片之前，请阅读关于其问题的讨论文本。](../Images/1a4e08124d11e0309a71b43af45fc48e.png)'
- en: 'Figure 7.13: Gun-related suicides by county; Reverse-coded population density
    by county. Before tweeting this picture, please read the text for discussion of
    what is wrong with it.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：按县分的枪支相关自杀；按县分反向编码的人口密度。在转发这张图片之前，请阅读关于其问题的讨论文本。
- en: Third, and more subtly, the data is subject to reporting constraints connected
    to population size. If there are fewer than ten events per year for a cause of
    death, the Centers for Disease Control (CDC) will not report them at the county
    level because it might be possible to identify particular deceased individuals.
    Assigning data like this to bins creates a threshold problem for choropleth maps.
    Look again Figure [7.13](maps.html#fig:ch-07-gunsu). The gun-related suicides
    panel seems to show a north-south band of counties with the lowest rate of suicides
    running from the Dakotas down through Nebraska, Kansas, and into West Texas. Oddly,
    this band borders counties in the West with the very highest rates, from New Mexico
    on up. But from the density map we can see that many counties in both these regions
    have very low population densities. Are they really that different in their gun-related
    suicide rates?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，而且更为微妙的是，数据受到与人口规模相关的报告限制。如果每年因某种原因死亡的事件少于十个，疾病控制中心（CDC）将不会在县一级报告这些事件，因为这可能有可能识别特定的死者。将此类数据分配到区间会为渐变图创建一个阈值问题。再次查看图[7.13](maps.html#fig:ch-07-gunsu)。枪支相关自杀部分似乎显示了一条从达科他州向南穿过内布拉斯加州、堪萨斯州直至西德克萨斯州的北南走向的县带，自杀率最低。奇怪的是，这条带子与西部自杀率极高的县相邻，从新墨西哥州一直向上。然而，从密度图上我们可以看到，这两个地区的许多县人口密度都很低。它们在枪支相关自杀率上真的有那么大的差异吗？
- en: Probably not. More likely, we are seeing an artifact arising from how the data
    is coded. For example, imagine a county with 100,000 inhabitants that experiences
    nine gun-related suicides in a year. The CDC will not report this number. Instead
    it will be coded as “suppressed”, accompanied by a note saying any standardized
    estimates or rates will also be unreliable. But if we are determined to make a
    map where all the counties are colored in, we might be tempted to put any suppressed
    results into the lowest bin. After all, we know that the number is somewhere between
    zero and ten. Why not just code it as zero?Do not do this. One standard alternative
    is to estimate the suppressed observations using a count model. An approach like
    this might naturally lead to more extensive, properly spatial modeling of the
    data. Meanwhile, a county with 100,000 inhabitants that experiences twelve gun-related
    suicides a year *will* be numerically reported. The CDC is a responsible organization,
    and so although it provides the absolute number of deaths for all counties above
    the threshold, the notes to the data file will still warn you that any rate calculated
    with this number will be unreliable. If we push ahead and do it anyway, then 12
    deaths in a small population might well put a sparsely-populated county in the
    highest category of suicide rate. Meanwhile, a low-population counties just under
    that threshold would be coded as being in the lowest (lightest) bin. But in reality
    they might not be so different, and in any case efforts to quantify that difference
    will be unreliable. If estimates for these counties cannot be obtained directly
    or estimated with a good model, then it is better to drop those cases as missing,
    even at the cost of your beautiful map, than have large areas of the country painted
    with a color derived from an unreliable number.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能不是。更有可能的是，我们正在看到的是数据编码方式产生的一个伪象。例如，想象一个有10万居民的县在一年中发生了九起枪支相关的自杀事件。CDC不会报告这个数字。相反，它会被编码为“压制”，并附上一条说明，指出任何标准化的估计或比率也将是不可靠的。但是，如果我们决心制作一个所有县都被着色的地图，我们可能会倾向于将任何被压制的调查结果放入最低的类别。毕竟，我们知道这个数字在零到十之间。为什么不直接将其编码为零呢？不要这样做。一个标准的替代方案是使用计数模型来估计被压制的观察值。这种方法可能会自然地导致对数据进行更广泛、更合适的空间建模。同时，一个有10万居民的县在一年中发生十二起枪支相关的自杀事件*将会*被数值报告。CDC是一个负责任的组织，因此尽管它为所有超过阈值的县提供了死亡绝对数，但数据文件中的注释仍会警告你，使用这个数字计算出的任何比率都将是不可靠的。如果我们坚持这样做，那么在小人口中12人死亡可能会将一个人口稀少的县归类为自杀率最高的类别。同时，低于该阈值的低人口县将被编码为最低（最轻）的类别。但在现实中，它们可能并没有那么不同，而且在任何情况下，试图量化这种差异的努力将是不可靠的。如果无法直接获得这些县的估计值或使用良好的模型进行估计，那么最好是将其作为缺失值删除，即使这会牺牲你那美丽的地图，也不应该用不可靠的数字来绘制大片国家的颜色。
- en: Small differences in reporting, combined with miscoding, will produce spatially
    misleading and substantively mistaken results. It might seem that focusing on
    the details of variable coding in this particular case is a little too much in
    the weeds for a general introduction. But it is exactly these details that can
    dramatically alter the appearance of any graph, but especially maps, in a way
    that can be hard to detect after the fact.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 报告中的小差异，加上错误编码，会产生在空间上误导性和实质上错误的结果。看起来，关注这个特定案例中变量编码的细节可能对于一般介绍来说有点过于繁琐。但正是这些细节会极大地改变任何图表，尤其是地图的外观，而这种改变在事后可能很难察觉。
- en: 7.3 Statebins
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 Statebins
- en: 'As an alternative to state-level choropleths, we can consider *statebins*,
    using a package developed by Bob Rudis. We will use it to look again at our state-level
    election results. Statebins is similar to ggplot but has a slightly different
    syntax from the one we’re used to. It needs several arguments including the basic
    data frame (the `state_data` argument), a vector of state names (`state_col`),
    and the value being shown (`value_col`). In addition, we can optionally tell it
    the color palette we want to use and the color of the text to label the state
    boxes. For a continuous variable we can use `statebins_continuous()`, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 作为州级渐变色的替代方案，我们可以考虑使用Bob Rudis开发的包来创建*州级分类箱*。我们将用它再次查看我们的州级选举结果。Statebins与ggplot类似，但其语法与我们习惯的不同。它需要几个参数，包括基本数据框（`state_data`参数）、州名向量（`state_col`）和要显示的值（`value_col`）。此外，我们可以选择性地告诉它我们想要的调色板和用于标注州框的文本颜色。对于连续变量，我们可以使用`statebins_continuous()`，如下所示：
- en: '![Statebins of the election results. We omit DC from the Clinton map to prevent
    the scale becoming unbalanced.](../Images/b0cc80f86d663953bb000c192b3c5ef0.png)![Statebins
    of the election results. We omit DC from the Clinton map to prevent the scale
    becoming unbalanced.](../Images/b3532df43e28c7c4536ec4e6831ed120.png) Figure 7.14:
    Statebins of the election results. We omit DC from the Clinton map to prevent
    the scale becoming unbalanced.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![选举结果的状态箱。为了防止比例失衡，我们从克林顿地图中省略了华盛顿特区](../Images/b0cc80f86d663953bb000c192b3c5ef0.png)![选举结果的状态箱。为了防止比例失衡，我们从克林顿地图中省略了华盛顿特区](../Images/b3532df43e28c7c4536ec4e6831ed120.png)
    图7.14：选举结果的状态箱。为了防止比例失衡，我们从克林顿地图中省略了华盛顿特区。'
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Sometimes we will want to present categorical data. If our variable is already
    cut into categories we can use `statebins_manual()` to represent it. Here add
    a new variable to the `election` data called `color`, just mirroring party names
    with two appropriate color names. We do this because we need to specify the colors
    we are using by way of a variable in the data frame, not as a proper mapping.
    We tell the `statebins_manual()` function that the colors are contained in column
    named `color`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可能想要展示分类数据。如果我们的变量已经被切割成类别，我们可以使用`statebins_manual()`来表示它。在这里，向`election`数据中添加一个名为`color`的新变量，用两个合适的颜色名称来反映党派名称。我们这样做是因为我们需要通过数据框中的变量来指定我们使用的颜色，而不是作为正确的映射。我们告诉`statebins_manual()`函数颜色包含在名为`color`的列中。
- en: Alternatively, we can have `statebins()` cut the data for us using the `breaks`
    argument, as in the second plot.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`statebins()`函数通过`breaks`参数帮我们切割数据，就像第二个图表中展示的那样。
- en: '![Manually specifying colors for statebins.](../Images/75d1261dd857cf92c3802f2eca4bdd7f.png)![Manually
    specifying colors for statebins.](../Images/5d771d400ed1ae057f1f2f1b733778c5.png)
    Figure 7.15: Manually specifying colors for statebins.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![手动指定状态箱的颜色](../Images/75d1261dd857cf92c3802f2eca4bdd7f.png)![手动指定状态箱的颜色](../Images/5d771d400ed1ae057f1f2f1b733778c5.png)
    图7.15：手动指定状态箱的颜色。'
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 7.4 Small-multiple maps
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 小倍数地图
- en: Sometimes we have geographical data with repeated observations over time. A
    common case is to have a country- or state-level measure observed over a period
    of years. In these cases, we might want to make a small multiple map to show changes
    over time. For example, the `opiates` data has state-level measures of the death
    rate from opiate-related causes (such as heroin or fentanyl overdoses) between
    1999 and 2014.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们会有带有时间重复观察的地理数据。一个常见的例子是在几年内对国家或州级指标进行观察。在这些情况下，我们可能想要制作一个小倍数地图来展示随时间的变化。例如，`opiates`数据包含了1999年至2014年间州级因阿片类药物（如海洛因或芬太尼过量）导致的死亡率指标。
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As before, we can take our `us_states` object, the one with the state-level
    map details, and merge it with our opiates dataset. As before, we convert the
    `State` variable in the `opiates` data to lower-case first, to make the match
    work properly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以将包含州级地图详细信息的`us_states`对象与我们的`opiates`数据集合并。同样，我们首先将`opiates`数据中的`State`变量转换为小写，以确保匹配正确。
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Because the `opiates` data includes the `Year` variable, we are now in a position
    to make a faceted small-multiple with one map for each year in the data. The following
    chunk of code is similar to the single state-level maps we have drawn so far.
    We specify the map data as usual, adding `geom_polygon()` and `coord_map()` to
    it, with the arguments those functions need. Instead of cutting our data into
    bins we will plot the continuous values for the adjusted death rate variable (`adjusted`)
    directly.If you want to experiment with cutting the data in to groups on the fly,
    take a look at the `cut_interval()` function. To help plot this variable effectively,
    we will use a new scale function from the `viridis` library. The viridis colors
    run in low-to-high sequences and do a very good job of combining perceptually
    uniform colors with easy-to-see, easily-contrasted hues along their scales. The
    `viridis` library provides continuous and discrete versions, both in several alternatives.
    Some balanced palettes can be a little washed out at their lower end, especially,
    but the viridis palettes avoid this. In this code, the `_c_` suffix in the `scale_fill_viridis_c()`
    function signals that it is the scale for continuous data. There is a `scale_fill_viridis_d()`
    equivalent for discrete data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`opiates`数据中包含了`Year`变量，我们现在可以制作一个分面小多倍图，每个年份对应一个地图。以下代码块与迄今为止我们绘制的单个州级地图类似。我们像往常一样指定地图数据，向其中添加`geom_polygon()`和`coord_map()`，并传入这些函数所需的参数。我们不会将数据切割成箱，而是直接绘制调整后的死亡率变量（`adjusted`）的连续值。如果你想在运行时动态地将数据切割成组，可以查看`cut_interval()`函数。为了有效地绘制这个变量，我们将使用来自`viridis`库的新比例函数。viridis颜色按从低到高的顺序排列，并在其比例上很好地结合了感知上均匀的颜色和易于看到、易于对比的色调。`viridis`库提供了连续和离散版本，都有几种选择。一些平衡的调色板在其低端可能会显得有点淡化，尤其是，但viridis调色板避免了这一点。在这段代码中，`scale_fill_viridis_c()`函数中的`_c_`后缀表示它是连续数据的比例。对于离散数据，有一个等效的`scale_fill_viridis_d()`。
- en: We facet the maps just like any other small-multiple with `facet_wrap()`. We
    use the `theme()` function to put the legend at the bottom and remove the default
    shaded background from the year labels. We will learn more about this use of the
    `theme()` function in Chapter [8](refineplots.html#refineplots). The final map
    is shown in Figure [7.16](maps.html#fig:ch-07-opiatemap).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`facet_wrap()`函数像其他任何小多倍图一样分面地图。我们使用`theme()`函数将图例放在底部，并从年份标签中移除默认的阴影背景。我们将在第[8](refineplots.html#refineplots)章中了解更多关于`theme()`函数的用法。最终的地图如图[7.16](maps.html#fig:ch-07-opiatemap)所示。
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![A small multiple map. States in grey reported too few deaths for a reliable
    population estimate in that year. States in white reported no data.](../Images/bf2bb1d1d0aaef98040ceb454e3a68f0.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![一个小多倍地图。当年死亡人数太少，无法进行可靠的估计时，用灰色表示的州。当年没有数据报告的州用白色表示。](../Images/bf2bb1d1d0aaef98040ceb454e3a68f0.png)'
- en: 'Figure 7.16: A small multiple map. States in grey reported too few deaths for
    a reliable population estimate in that year. States in white reported no data.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16：一个小多倍地图。当年死亡人数太少，无法进行可靠的估计时，用灰色表示的州。当年没有数据报告的州用白色表示。
- en: Is this a good way to visualize this data?Try revisiting your code for the ur-choropleths,
    but use continuous rather than binned measures, as well as the `viridis` palette.
    Instead of `pct_black` use the `black` variable. For the population density, divide
    `pop` by `land_area`. You will need to adjust the `scale_` functions. How do the
    maps compare to the binned versions? What happens to the population density map,
    and why? As we discussed above, choropleth maps of the U.S. tend to track first
    the size of the local population and secondarily the percent of the population
    that is African-American. The differences in the geographical size of states makes
    spotting changes more difficult again. And it is quite difficult to compare repeatedly
    across spatial regions. The repeated measures do mean that some comparison is
    possible, and the strong trends for this data make things a little easier to see.
    In this case, a casual viewer might think, for example, that the opiod crisis
    was worst in the desert southwest in comparison to many other parts of the country,
    although it also seems that something serious is happening in the Appalachians.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种好的数据可视化方法吗？尝试重新审视你的原始 choropleths 代码，但使用连续而不是分箱的度量，以及`viridis`调色板。用`black`变量代替`pct_black`。对于人口密度，将`pop`除以`land_area`。你需要调整`scale_`函数。地图与分箱版本相比如何？人口密度地图发生了什么变化，为什么？正如我们上面所讨论的，美国的
    choropleth 地图往往首先追踪当地人口规模，其次是非洲裔美国人口百分比。各州地理规模的差异使得发现变化变得更加困难。而且，在不同空间区域之间反复比较相当困难。重复的度量确实意味着可以进行一些比较，并且此数据的强烈趋势使得事情稍微容易一些看到。在这种情况下，一个偶然的观众可能会认为，例如，与该国的许多其他地区相比，阿巴拉契亚地区鸦片危机最严重，尽管似乎阿巴拉契亚地区也发生了严重的事情。
- en: 7.5 Is your data really spatial?
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 你的数据真的是空间性的吗？
- en: As we noted at the beginning of the Chapter, even if our data is collected via
    or grouped into spatial units, it is always worth asking whether a map is the
    best way to present it. Much county- state- and national data is not properly
    spatial, insofar as it is really about individuals (or some other unit of interest)
    rather than the geographical distribution of those units *per se*. Let’s take
    our state-level opiates data and redraw it as a time-series plot. We will keep
    the state-level focus (these are state-level rates, after all), but try to make
    the trends more directly visible.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头所提到的，即使我们的数据是通过或分组到空间单元收集的，询问是否地图是展示它的最佳方式总是值得的。许多县、州和国家数据实际上并不是真正空间性的，因为它们真正关注的是个人（或感兴趣的某些其他单位）而不是这些单位的地理分布本身。让我们以我们的州级鸦片数据为例，将其重新绘制成时间序列图。我们将保持州级焦点（毕竟，这些都是州级比率），但尝试使趋势更直接地可见。
- en: We could just plot the trends for every state, as we did at the very beginning
    with the `gapminder` data. But fifty states is too many lines to keep track of
    at once.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像最初用`gapminder`数据所做的那样，为每个州绘制趋势。但五十个州同时绘制太多的线条难以跟踪。
- en: '![All the states at once.](../Images/d208d7f0edc933a531d4f9d35093bddf.png)
    Figure 7.17: All the states at once.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![所有状态同时展示。](../Images/d208d7f0edc933a531d4f9d35093bddf.png) 图7.17：所有状态同时展示。'
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A more informative approach is to take advantage of the geographical structure
    of the data by using the census regions to group the States. Imagine a faceted
    plot showing state-level trends within each region of the country, perhaps with
    a trend line for each region. To do this, we will take advantage of ggplot’s ability
    to layer geoms one on top of another, using a different dataset in each case.
    We begin by taking the `opiates` data (removing Washington DC, as it is not a
    state), and plotting the adjusted death rate over time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更信息化的方法是利用数据的地理结构，通过使用人口普查区域来分组各州。想象一下一个分面图，展示国家每个区域内的州级趋势，也许每个区域都有一个趋势线。为此，我们将利用
    ggplot 的能力将 geoms 层层叠加，每个情况下使用不同的数据集。我们首先取`opiates`数据（移除华盛顿特区，因为它不是一个州），并绘制调整后的死亡率随时间的变化。
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `drop_na()` function deletes rows that have observations missing on the
    specified variables, in this case just `division_name`, because Washington DC
    is not part of any Census Division. We map the `group` aesthetic to `state` in
    `geom_line()`, which gives us a line plot for every state. We use the `color`
    argument in to set the lines to a light gray. Next, we add a smoother:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`drop_na()`函数删除了在指定变量上缺失观测值的行，在这种情况下，只是`division_name`，因为华盛顿特区不属于任何人口普查区。我们在`geom_line()`中将`group`美学映射到`state`，这为我们每个州提供了一个线形图。我们使用`color`参数将线条设置为浅灰色。接下来，我们添加一个平滑器：'
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For this geom we set the `group` aesthetic to `division_name`. (Division is
    a smaller Census classification than Region.) If we set it to `state` we would
    get fifty separate smoothers in addition to our fifty trend lines. Then, using
    what we learned in Chapter [4](groupfacettx.html#groupfacettx), we add a `geom_text_repel()`
    object that puts the label for each state at the end of the series. Because we
    are labeling lines rather than points, we only want the state label to appear
    at the end of the line. The trick is to subset the data so that only the points
    the last year observed are used (and thus labeled). We also must remember to remove
    Washington DC again here, as the new `data` argument supersedes the original one
    in `p0`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个几何图形，我们将`group`美学设置为`division_name`。（Division是比Region更小的普查分类。）如果我们将其设置为`state`，我们除了五十条趋势线外，还会得到五十个单独的平滑器。然后，利用我们在第[4](groupfacettx.html#groupfacettx)章中学到的知识，我们添加了一个`geom_text_repel()`对象，将每个州的标签放置在序列的末尾。因为我们是在标记线而不是点，所以我们只希望州标签出现在线的末尾。技巧是子集数据，以便只使用最后一年观察到的点（因此标记）。我们还必须记住再次删除华盛顿特区，因为新的`data`参数取代了`p0`中的原始参数。
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By default, `geom_text_repel` will at little line segments that indicate what
    the labels refer to. But that is not helpful here, as we are already dealing with
    the end point of a line. So we turn them off with the argument `segment.color
    = NA`. We also bump the labels off to the right of the lines a little, using the
    `nudge_x` argument, and use `coord_cartesian()` to set the axis limits so that
    there is enough room for them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`geom_text_repel`会在表示标签的短线段上。但在这里这并不有帮助，因为我们已经处理了线的终点。因此，我们使用`segment.color
    = NA`参数将其关闭。我们还使用`nudge_x`参数将标签稍微向线的右侧移动，并使用`coord_cartesian()`设置轴限制，以便有足够的空间。
- en: Finally, we facet the results by Census Division and add our labels. A useful
    adjustment is to reorder the panels by the average death rate. We put a minus
    in front of `adjusted` to that the divisions with the highest average rates appear
    in the chart first.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们按普查区划分结果，并添加我们的标签。一个有用的调整是按平均死亡率重新排序面板。我们在`adjusted`前放一个减号，以便具有最高平均率的分区首先出现在图表中。
- en: '[PRE39]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Our new plot brings out much of the overall story that is in the maps, but also
    shifts the emphasis a bit. It is easier to see more clearly what is happening
    in some parts of the country. In particular you can see the climbing numbers in
    New Hampshire, Rhode Island, Massachussetts, and Connecticut. You can more easily
    see the state-level differences in the West, for instance between Arizona, on
    the one hand, and New Mexico or Utah on the other. And as was also visible on
    the maps, the astonishingly rapid rise in West Virginia’s death rate is also evident.
    Finally, the time-series plots are better at conveying the diverging trajectories
    of various states within regions. There is a lot more variance at the end of the
    series than at the beginning, especially in the Northeast, Midwest, and South,
    and while this can be inferred from the maps it is easier to see in the trend
    plots.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新图表突出了地图中的大部分整体故事，但也稍微改变了重点。更容易清楚地看到国家某些地区正在发生的事情。特别是你可以看到新罕布什尔州、罗德岛、马萨诸塞州和康涅狄格州的数字在上升。你更容易看到西部各州在州一级的差异，例如亚利桑那州与另一方面的新墨西哥州或犹他州之间的差异。而且正如地图上所显示的，西弗吉尼亚州死亡率惊人地快速上升也是显而易见的。最后，时间序列图更好地传达了区域内各州的不同轨迹。在序列的末尾比开头有更多的方差，尤其是在东北部、中西部和南部，虽然这可以从地图中推断出来，但在趋势图中更容易看到。
- en: '![The opiate data as a faceted time-series.](../Images/419e9fabf3a7a4c4d47b584db781464b.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![阿片类药物数据作为一个分面时间序列。](../Images/419e9fabf3a7a4c4d47b584db781464b.png)'
- en: 'Figure 7.18: The opiate data as a faceted time-series.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18：阿片类药物数据作为一个分面时间序列。
- en: The unit of observation in this graph is still the state-year. The geographically-bound
    nature of the data never goes away. The lines we draw still represent states.
    Thus, the basic arbitrariness of the representation cannot be made to disappear.
    In some sense, an ideal dataset here would be collected at some much more fine-grained
    level of unit, time, and spatial specificity. Imagine individual-level data with
    arbitrarily precise information on personal characteristics, times, and location
    of death. In a case like that, we could then aggregate up to any categorical,
    spatial, or temporal units we liked. But data like that is extremely rare, often
    for very good reasons that range from practicality of collection to the privacy
    of individuals. In practice we need to take care not to commit a kind of fallacy
    of misplaced concreteness that mistakes the unit of observation for the thing
    of real substantive or theoretical interest. This is a problem for most kinds
    of social-scientific data. But their striking visual character makes maps perhaps
    more vulnerable to this problem than other kinds of visualization.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，观察的单位仍然是州-年。数据的地理属性永远不会消失。我们绘制的线条仍然代表各州。因此，表示的基本任意性无法消失。在某种程度上，一个理想的数据库应该是在更精细的单位、时间和空间特定性层面上收集的。想象一下具有关于个人特征、时间和死亡地点的任意精确信息的个体级数据。在这种情况下，我们可以将数据聚合到我们喜欢的任何分类、空间或时间单位。但这样的数据极为罕见，通常有很好的理由，从收集的实用性到个人的隐私。在实践中，我们需要注意不要犯一种将观察单位误认为是真正实质性或理论兴趣对象的错误具体化谬误。这是大多数社会科学数据的问题。但它们的显著视觉特征使得地图可能比其他类型的可视化更容易受到这个问题的影响。
- en: 7.6 Where to go next
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 接下来去哪里
- en: In this chapter, we learned how to begin work with state-level and county-level
    data organized by FIPS codes. But this barely scratches the surface of visualization
    where spatial features and distributions are the main focus. The analysis and
    visualization of spatial data is its own research area, with its own research
    disciplines in Geography and Cartography. Concepts and methods for representing
    spatial features are both well-developed and standardized. Until recently, most
    of this functionality was accessible only through dedicated Geographical Information
    Systems. Their mapping and spatial analysis features were not well connected.
    Or at least, they were not conveniently connected to software oriented to the
    analysis of tabular data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用FIPS代码组织州级和县级数据开始工作。但这对可视化领域来说只是触及了皮毛，因为空间特征和分布是可视化中的主要焦点。空间数据的分析和可视化是一个独立的研究领域，在地理学和制图学中拥有自己的研究学科。表示空间特征的概念和方法都得到了很好的发展和标准化。直到最近，大多数此类功能只能通过专门的地理信息系统访问。它们的制图和空间分析功能并未很好地连接。或者至少，它们并没有方便地连接到面向表格数据分析的软件。
- en: This is changing fast. Brundson & Comber (2015) provide an introduction to some
    of R’s mapping capabilities. Meanwhile, very recently these tools have become
    much more easily accessible via the tidyverse. Of particular interest to social
    scientists`r-spatial.github.io/sf/`. Also see news and updates at `r-spatial.org`.
    is Edzer Pebesma’s ongoing development of the `sf` package, which implements the
    standard Simple Features data model for spatial features in a tidyverse-friendly
    way. Relatedly, Kyle Walker and Bob Rudis’s `tigris` package`github.com/walkerke/tigris`
    allows for (sf-library combatible) access to the U.S. Census Bureau’s TIGER/Line
    shapefiles, which allow you to map data for many different geographical, administrative,
    and Census-related subdivisions of the United States, as well as things roads
    and water features. Finally, Kyle Walker’s `tidycensus` package`walkerke.github.io/tidycensus`
    (Walker, 2018) makes it much easier to tidily get both substantive and spatial
    feature data from the U.S. Census and the American Community Survey.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这正在迅速变化。Brundson和Comber（2015）介绍了R的一些制图功能。同时，最近这些工具通过tidyverse变得更加容易访问。对社会科学工作者来说，特别感兴趣的是`r-spatial.github.io/sf/`。还可以查看`r-spatial.org`上的新闻和更新。这是Edzer
    Pebesma对`sf`包的持续开发，该包以tidyverse友好的方式实现了空间特征的标准化简单特征数据模型。相关地，Kyle Walker和Bob Rudis的`tigris`包`github.com/walkerke/tigris`允许（sf库兼容）访问美国人口普查局的TIGER/Line形状文件，这些文件允许您绘制美国许多不同地理、行政和人口普查相关子区域的地图，以及道路和水域等特征。最后，Kyle
    Walker的`tidycensus`包`walkerke.github.io/tidycensus`（Walker，2018）使得从美国人口普查和美国社区调查中获取实质性数据和空间特征数据变得更加容易。
- en: 7.1 Map U.S. state-level data
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 绘制美国州级数据地图
- en: Let’s take a look at some data for the 2016 U.S. presidential election and see
    how we might plot it in R. The `election` dataset has various measures of the
    vote and vote shares by state. Here we pick some columns and sample a few rows
    at random.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看2016年美国总统选举的一些数据，并看看我们如何在R中绘制它。`election`数据集包含了按州划分的投票和投票份额的各种度量。这里我们挑选了一些列，并随机抽取了几行样本。
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![2016 Election Results. Would a two-color choropleth map be more informative
    than this, or less?](../Images/41812dbdbd37c2e03ec02011347ccf84.png) Figure 7.2:
    2016 Election Results. Would a two-color choropleth map be more informative than
    this, or less?'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![2016选举结果。这种双色渐变地图是否比这个更有信息量，或者更少？](../Images/41812dbdbd37c2e03ec02011347ccf84.png)
    图7.2：2016选举结果。这种双色渐变地图是否比这个更有信息量，或者更少？'
- en: The FIPS code is a federal code that numbers states and territories of the US.
    It extends to the county level with an additional four digits, so every county
    in the US has a unique six-digit identifier, where the first two digits represent
    the state. This dataset also contains the census region of each state.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: FIPS代码是一个联邦代码，用于编号美国的州和领地。它扩展到县级，增加四位数字，因此美国每个县都有一个唯一的六位数字标识符，其中前两位数字代表州。这个数据集还包含了每个州的普查区域。
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first thing you should remember about spatial data is that you don’t have
    to represent it spatially. We’ve been working with country-level data throughout,
    and have yet to make a map of it. Of course, spatial representations can be very
    useful, and sometimes absolutely necesssary. But we can start with a state-level
    dotplot, faceted by region. This plot brings together many aspects of plot construction
    that we have worked on so far, including subsetting data, reordering results by
    a second variable, and using a scale formatter. It also introduces some new options,
    like allowing free scales on an axis, and manually setting the color of an aesthetic.
    We break up the construction process into several steps by creating intermediate
    objects (`p0`, `p1`, `p2`) along the way. It makes the code a little more readable.
    Bear in mind also that, as always, you can try plotting each of these intermediate
    objects as well (just type their name at the console and hit return) to see what
    they look like. What happens if you remove the `scales="free_y"` argument to `facet_wrap()`?
    What happens if you delete the call to `scale_color_manual()`?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关于空间数据，你应该记住的第一件事是，你不必以空间形式表示它。我们一直在处理国家层面的数据，并且还没有制作出它的地图。当然，空间表示可以非常有用，有时甚至绝对必要。但我们可以从州级别的散点图开始，按区域进行分面。这个图汇集了我们迄今为止所做的一些绘图构建方面，包括数据子集、按第二个变量重新排序结果和使用刻度格式化器。它还引入了一些新选项，如允许轴上有自由刻度，以及手动设置美学的颜色。我们通过在过程中创建中间对象（`p0`、`p1`、`p2`）将构建过程分解成几个步骤。这使得代码更易于阅读。记住，你始终可以尝试绘制这些中间对象（只需在控制台中输入它们的名称并按回车键）以查看它们的外观。如果你从`facet_wrap()`中移除`scales="free_y"`参数会发生什么？如果你删除了`scale_color_manual()`的调用会发生什么？
- en: As always, the first task in drawing a map is to get a data frame with the right
    information in it, and in the right order. First we load R’s `maps` package, which
    provides us with some pre-drawn map data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，绘制地图的第一步是获取包含正确信息且顺序正确的数据框。首先，我们加载R的`maps`包，它为我们提供了一些预先绘制的地图数据。
- en: '[PRE43]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This just a data frame. It has more than 15,000 rows because you need a lot
    of lines to draw a good-looking map. We can make a blank state map right away
    with this data, using `geom_polygon()`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个数据框。因为它需要很多线条来绘制一个好看的地图，所以它有超过15,000行。我们可以使用`geom_polygon()`立即用这些数据制作一个空白州地图。
- en: '[PRE47]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The map is plotted with latitude and longitude points, which are there as scale
    elements mapped to the x and y axes. A map is, after all, just a set of lines
    drawn in the right order on a grid.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 地图使用经纬度点绘制，这些点作为映射到x轴和y轴的刻度元素。毕竟，地图只是在一组网格上按正确顺序绘制的一系列线条。
- en: '![A first US map](../Images/50400274958d6a7511ccc1502da75fab.png) Figure 7.3:
    A first US map'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![第一张美国地图](../Images/50400274958d6a7511ccc1502da75fab.png) 图7.3：第一张美国地图'
- en: We can map the `fill` aesthetic to `region` and change the `color` mapping to
    a light gray and thin the lines to make the state borders a little nicer. We’ll
    also tell R not to plot a legend.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`fill`美学映射到`region`，将`color`映射改为浅灰色，并将线条变细以使州边界看起来更美观。我们还将告诉R不要绘制图例。
- en: '![Coloring the states](../Images/12b837f02b22ed78c883832fbba6c494.png) Figure
    7.4: Coloring the states'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![给州上色](../Images/12b837f02b22ed78c883832fbba6c494.png) 图7.4：给州上色'
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Next, let’s deal with the projection. By default the map is plotted using the
    venerable Mercator projection. It doesn’t look that good. Assuming we are not
    planning on sailing across the Atlantic, the practical virtues of this projection
    are not much use to us, either. If you glance again at the maps in Figure [7.1](maps.html#fig:ch-07-maps1),
    you’ll notice they look nicer. This is because they are using an Albers projection.
    (Look, for example, at the way that the US-Canadian border is a little curved
    along the 49th parallel from Washington state to Minnesota, rather than not a
    straight line.) Techniques for map projection are a fascinating world of their
    own, but for now just remember we can transform the default projection used by
    `geom_polygon()`, via the `coord_map()` function. You’ll remember that we said
    that projection onto a coordinate system is a necessary part of the plotting process
    for any data. Normally it is left implicit. We have not usually had to specify
    a `coord_` function because most of the time we have drawn our plots on a simple
    Cartesian plane. Maps are more complex. Our locations and borders are defined
    on a more or less spherical object, which means must have a method for transforming
    or projecting our points and lines from a round to a flat surface. The many ways
    of doing this gives us a menu of cartographic options.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理投影问题。默认情况下，地图使用的是备受尊敬的墨卡托投影。它看起来并不好。如果你再次看图7.1中的地图（maps.html#fig:ch-07-maps1），你会注意到它们看起来更好。这是因为它们使用了Albers投影。（例如，看看美国-加拿大边界是如何沿着华盛顿州到明尼苏达州的第49平行线略微弯曲，而不是一条直线。）地图投影的技术是一个迷人的领域，但就现在而言，只需记住我们可以通过`coord_map()`函数转换`geom_polygon()`默认使用的投影。你还记得我们说过，将投影到坐标系是任何数据绘图过程中的必要部分。通常它是隐含的。我们通常不需要指定`coord_`函数，因为我们大多数时候都是在简单的笛卡尔平面上绘制我们的图表。地图更复杂。我们的位置和边界定义在一个或多或少是球形的物体上，这意味着我们必须有一种方法来转换或投影我们的点和线条，从圆形表面到平面表面。做这件事的许多方法给我们提供了一系列的制图选项。
- en: The Albers projection requires two latitude parameters, `lat0` and `lat1`. We
    give them their conventional values for a US map here. (Try messing around with
    their values and see what happens when you redraw the map.)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Albers投影需要两个纬度参数，`lat0`和`lat1`。在这里，我们为美国地图给出了它们的传统值。（试着调整它们的值，看看当你重新绘制地图时会发生什么。）
- en: '![Improving the projection](../Images/7e82b98cf4878a25e166d767073cf3f4.png)
    Figure 7.5: Improving the projection'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![改进投影](../Images/7e82b98cf4878a25e166d767073cf3f4.png) 图7.5：改进投影'
- en: '[PRE49]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now we need to get our own data on to the map. Remember, underneath that map
    is just a big data frame specifying a large number of lines that need to be drawn.
    We have to merge our data with that data frame. Somewhat annoyingly, in the map
    data the state names (in a variable named `region`) are in lower case. We can
    create a variable in our own data frame to correspond to this, using the `tolower()`
    function to convert the `state` names. We then use `left_join` to merge but you
    could also use `merge(..., sort = FALSE)`. This merge step is important! You need
    to take care that the values of the key variables you are matching on really do
    exactly correspond to one another. If they do not, missing values (`NA` codes)
    will be introduced into your merge, and the lines on your map will not join up.
    This will result in a weirdly “sharded” appearance to your map when R tries to
    fill the polygons. Here, the `region` variable is the only column with the same
    name in both the data sets we are joining, and so the `left_join()` function uses
    it used by default. If the keys have different names in each data set you can
    specify that, if needed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将我们自己的数据添加到地图上。记住，地图下面只是一个大型的数据框，它指定了需要绘制的大量线条。我们必须将我们的数据与这个数据框合并。有些令人烦恼的是，在地图数据中，州名（在名为`region`的变量中）都是小写的。我们可以在自己的数据框中创建一个变量来对应这个，使用`tolower()`函数将`state`名称转换为小写。然后我们使用`left_join`来合并，但你也可以使用`merge(...,
    sort = FALSE)`。这个合并步骤很重要！你需要确保你匹配的关键变量的值确实完全对应。如果它们不对应，你的合并中将会引入缺失值（`NA`代码），你的地图上的线条将无法连接。当R尝试填充多边形时，这会导致你的地图出现奇怪的分片外观。在这里，`region`变量是我们连接的两个数据集中唯一具有相同名称的列，因此`left_join()`函数默认使用它。如果每个数据集中的键有不同的名称，你可以指定，如果需要的话。
- en: To reiterate, it is important to know your data and variables well enough to
    check that they have merged properly. Do not do it blindly. For example, if rows
    corresponding to Washington DC were named “washington dc” in the `region` variable
    of your `election` data frame, but “district of columbia” in the corresponding
    `region` variable of your map data, then merging on `region` would mean no rows
    in the `election` data frame would match “washington dc” in the map data, and
    the resulting merged variables for those rows would all be coded as missing. Maps
    that look broken when you draw them are usually caused by merge errors. But errors
    can also be subtle. For example, perhaps one of your state names inadvertently
    has a leading (or, worse, a trailing) space as a result of the data originally
    being imported from elsewhere and not fully cleaned. That would mean, for example,
    that `california` and `california␣` are different strings, and the match would
    fail. In ordinary use you might not easily see the extra space (designated here
    by `␣`). So, be careful.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一遍，了解你的数据和变量非常重要，以确保它们已经正确合并。不要盲目操作。例如，如果你的`election`数据框中的`region`变量中对应华盛顿特区的行被命名为“washington
    dc”，但在相应的地图数据中的`region`变量中命名为“district of columbia”，那么基于`region`的合并意味着`election`数据框中的所有行都不会匹配地图数据中的“washington
    dc”，并且这些行的合并变量都将被编码为缺失值。当你绘制地图时看起来破损的地图通常是由合并错误引起的。但错误也可能是微妙的。例如，可能由于数据最初是从其他地方导入且未完全清理，导致某个州名不小心有一个前导（或更糟，尾随）空格。这意味着，例如，`california`和`california␣`是不同的字符串，匹配将失败。在普通使用中，你可能不容易看到额外的空格（在此处由`␣`表示）。因此，要小心。
- en: '[PRE50]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We have now merged the data. Take a look at the object with `head(us_states_elec)`.
    Now that everything is in one big data frame, we can plot it in a map.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经合并了数据。查看`head(us_states_elec)`对象。现在所有数据都在一个大的数据框中，我们可以在地图上绘制它。
- en: '![Mapping the results](../Images/d0857ad451b1d786f96fdbb38d2809e8.png) Figure
    7.6: Mapping the results'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![映射结果](../Images/d0857ad451b1d786f96fdbb38d2809e8.png) 图7.6：映射结果'
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To complete the map, we will use our party colors for the fill, move the legend
    to the bottom, and add a title. Finally we will remove the grid lines and axis
    labels, which aren’t really needed, by defining a special theme for maps that
    removes most of the elements we don’t need. (We’ll learn more about themes in
    Chapter [8](refineplots.html#refineplots). You can also see the code for the map
    theme in the Appendix.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成地图，我们将使用我们的党派颜色进行填充，将图例移动到底部，并添加一个标题。最后，我们将通过定义一个特殊的地图主题来删除我们不需要的大部分元素，从而移除网格线和轴标签，这些实际上并不需要。（我们将在第[8](refineplots.html#refineplots)章中了解更多关于主题的内容。你还可以在附录中查看地图主题的代码。）
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![Election 2016 by State](../Images/0101fe11ace19e521d5f1150cb4c441b.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![2016年各州选举图](../Images/0101fe11ace19e521d5f1150cb4c441b.png)'
- en: 'Figure 7.7: Election 2016 by State'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：2016年各州选举
- en: With the map data frame in place, we can map other variables if we like. Let’s
    try a continuous measure, such as the percentage of the vote received by Donald
    Trump. To begin with, we just map the variable we want (`pct_trump`) to the `fill`
    aesthetic, and see what `geom_polygon()` does by default.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图数据框就绪后，如果我们愿意，可以映射其他变量。让我们尝试一个连续的度量，比如唐纳德·特朗普获得的选票百分比。首先，我们只需将我们想要的变量（`pct_trump`）映射到`fill`美学，并看看`geom_polygon()`默认情况下会做什么。
- en: '![Two versions of Percent Trump by State](../Images/8189ee7190135dfd038997b7b9794b77.png)![Two
    versions of Percent Trump by State](../Images/9fd04466e47e74a20ef939fb88e33aee.png)
    Figure 7.8: Two versions of Percent Trump by State'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![各州特朗普得票百分比的两个版本](../Images/8189ee7190135dfd038997b7b9794b77.png)![各州特朗普得票百分比的两个版本](../Images/9fd04466e47e74a20ef939fb88e33aee.png)
    图7.8：各州特朗普得票百分比的两个版本'
- en: '[PRE53]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The default color used in the `p1` object is blue. Just for reasons of convention,
    that isn’t what is wanted here. In addition, the gradient runs in the wrong direction.
    In our case, the standard interpretation is that a higher vote share makes for
    a darker color. We fix both of these problems in the `p2` object by specifying
    the `scale` directly. We’ll use the values we created earlier in `party_colors`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`p1`对象中使用的默认颜色是蓝色。仅仅出于惯例，这并不是我们想要的。此外，渐变的方向也是错误的。在我们的情况下，标准的解释是更高的得票份额对应着更深的颜色。我们通过直接指定`scale`来修复`p2`对象中的这两个问题。我们将使用之前在`party_colors`中创建的值。
- en: For election results, we might prefer a gradient that diverges from a midpoint.
    The `scale_gradient2()` function gives us a blue-red spectrum that passes through
    white by default. Alternatively, we can re-specify the mid-level color along with
    the high and low colors. We will make purple our midpoint, and use the `muted()`
    function from the `scales` library to tone down the color a little.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选举结果，我们可能更喜欢从中点发散的渐变。`scale_gradient2()`函数为我们提供了一个默认通过白色的蓝-红光谱。或者，我们可以重新指定中点颜色以及高色和低色。我们将紫色作为中点，并使用`
    scales`库中的`muted()`函数稍微降低颜色饱和度。
- en: '![Two views of Trump vs Clinton share: a white midpoint, and a Purple America
    version.](../Images/5a8f3b4c873f04e7a842cc0d670914c6.png)![Two views of Trump
    vs Clinton share: a white midpoint, and a Purple America version.](../Images/24ca50be3c0e06e458c318aa5d404727.png)
    Figure 7.9: Two views of Trump vs Clinton share: a white midpoint, and a Purple
    America version.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![特朗普对克林顿共享的两个视图：白色中点和紫色美国版本。](../Images/5a8f3b4c873f04e7a842cc0d670914c6.png)![特朗普对克林顿共享的两个视图：白色中点和紫色美国版本。](../Images/24ca50be3c0e06e458c318aa5d404727.png)
    图7.9：特朗普对克林顿共享的两个视图：白色中点和紫色美国版本。'
- en: '[PRE54]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you take a look at the gradient scale for this first “purple America” map,
    in Figure [7.9](maps.html#fig:ch-07-purple1st), you’ll see that it extends very
    high on the Blue side. This is because Washington DC is included in the data,
    and hence the scale. Even though it is barely visible on the map, DC has by far
    the highest points margin in favor of the Democrats of any unit of observation
    in the data. If we omit it, we’ll see that our scale shifts in a way that does
    not just affect the top of the blue end, but re-centers the whole gradient and
    makes the red side more vivid as a result. Figure [7.10](maps.html#fig:ch-07-purple2nd)
    shows the result.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看这个第一个“紫色美国”地图的渐变尺度，如图[7.9](maps.html#fig:ch-07-purple1st)，你会发现它在蓝色一侧非常高。这是因为华盛顿特区包含在数据中，因此也包含在尺度中。尽管它在地图上几乎看不见，但华盛顿特区在数据中任何观察单位中，民主党获得的优势点数都远远高于其他单位。如果我们省略它，我们会看到我们的尺度发生了变化，这不仅影响了蓝色一端，而且使整个渐变重新居中，并使红色一侧更加鲜明。图[7.10](maps.html#fig:ch-07-purple2nd)显示了结果。
- en: '[PRE55]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Figure 7.10: A Purple America version of Trump vs Clinton that excludes results
    from Washington, DC.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：排除华盛顿特区结果的特朗普对克林顿的紫色美国版本。
- en: '![A Purple America version of Trump vs Clinton that excludes results from Washington,
    DC.](../Images/4f8d8961e73231bd264b9fa571a330f0.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![排除华盛顿特区结果的特朗普对克林顿的紫色美国版本](../Images/4f8d8961e73231bd264b9fa571a330f0.png)'
- en: This brings out the familiar choropleth problem of having geographical areas
    that only partially represent the variable we are mapping. In this case, we’re
    showing votes spatially, but what really matters is the number of people who voted.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这揭示了熟悉的分级统计图问题，即地理区域只能部分代表我们正在映射的变量。在这种情况下，我们展示的是空间上的选票，但真正重要的是投票的人数。
- en: 7.2 America’s ur-choropleths
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 美国的原始分级统计图
- en: In the U.S. case, administrative areas vary widely in geographical area and
    they also vary widely in population size. The problem is evident at the state
    level, as we have seen, also arises even more at the county level. County-level
    US maps can be aesthetically pleasing, because of the added detail they bring
    to a national map. But they also make it easy to present a geographical distribution
    to insinuate an explanation. The results can be tricky to work with. When producing
    county maps, it is important to remember that the states of New Hampshire, Rhode
    Island, Massachussetts, and Connecticut are all smaller in area than any of the
    ten largest Western *counties*. Many of those counties have fewer than a hundred
    thousand people living in them. Some have fewer than ten thousand inhabitants.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国的情况下，行政区域的地理面积和人口规模差异很大。正如我们所见，这个问题在州一级很明显，在县一级更是如此。县一级的美国地图在美学上可能很吸引人，因为它们为全国地图增添了额外的细节。但这也使得展示地理分布以暗示解释变得容易。结果可能很难处理。在制作县地图时，重要的是要记住，新罕布什尔州、罗德岛州、马萨诸塞州和康涅狄格州的面积都小于十个最大的西部**县**。其中许多县的人口少于十万人。有些县的人口甚至少于一万。
- en: The result is that most choropleth maps of the U.S. for whatever variable in
    effect show population density more than anything else. The other big variable,
    in the U.S. case, is Percent Black. Let’s see how to draw these two maps in R.
    The procedure is essentially the same as it was for the state-level map. We need
    two data frames, one containing the map data, and the other containing the fill
    variables we want plotted. Because there are more than three thousand counties
    in the United States, these two data frames will be rather larger than they were
    for the state-level maps.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，美国大多数按变量划分的分级色地图实际上更多地显示了人口密度。在美国的情况下，另一个重要变量是黑人百分比。让我们看看如何在 R 中绘制这两张地图。这个过程基本上和州级地图一样。我们需要两个数据框，一个包含地图数据，另一个包含我们想要绘制的填充变量。由于美国有超过三千个县，这两个数据框将比州级地图大得多。
- en: 'The datasets are included in the `socviz` library. The county map data frame
    has already been processed a little in order to transform it to an Albers projection,
    and also to relocate (and rescale) Alaska and Hawaii so that they fit into an
    area in the bottom left of the figure. This is better than throwing away two states
    from the data. The steps for this transformation and relocation are not shown
    here. If you want to see how it’s done, consult the Supplementary Material for
    details. Let’s take a look at our county map data first:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据集包含在 `socviz` 库中。县级地图数据框已经经过一些处理，以便将其转换为 Albers 投影，并且重新定位（并缩放）阿拉斯加和夏威夷，以便它们适合图的下左角区域。这比从数据中丢弃两个州要好。这个转换和重新定位的步骤在这里没有展示。如果你想了解如何完成，请参阅补充材料以获取详细信息。让我们先看看我们的县级地图数据：
- en: '[PRE56]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'It looks the same as our State map data frame, but it is much larger, running
    to almost 200,000 rows. The `id` field is the FIPS code for the county. Next,
    we have a data frame with county-level demographic, geographic, and election data:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来和我们的州地图数据框一样，但规模要大得多，几乎有 200,000 行。`id` 字段是县的 FIPS 代码。接下来，我们有一个包含县级人口、地理和选举数据的数据框：
- en: '[PRE58]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This data frame includes information for entities besides counties, though not
    for all variables. If you look at the top of the object with `head()` you’ll notice
    that the first row of has an `id` of `0`. Zero is the FIPS code for the entire
    United States, and thus the data in this row are for the whole country. Similarly,
    the second row has an `id` of 01000, which corresponds to the State FIPS of 01,
    for the whole of Alabama. As we merge `county_data` in to `county_map`, these
    state rows will be dropped, along with the national row, as `county_map` only
    has county-level data.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据框包含了除县以外实体的信息，尽管并非所有变量都有。如果你用 `head()` 函数查看对象顶部，你会注意到第一行的 `id` 为 `0`。零是整个美国的
    FIPS 代码，因此这一行的数据代表整个国家。同样，第二行的 `id` 为 01000，对应于阿拉巴马州的州 FIPS 代码 01。当我们把 `county_data`
    合并到 `county_map` 中时，这些州行以及国家行都会被删除，因为 `county_map` 只包含县级数据。
- en: 'We merge the data frames using the shared FIPS `id` column:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用共享的 FIPS `id` 列合并数据框：
- en: '[PRE60]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: With the data merged, we can map the population density per square mile.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 数据合并后，我们可以绘制每平方英里的人口密度图。
- en: '[PRE61]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Figure 7.11: US population density by county.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11：按县划分的美国人口密度。
- en: '![US population density by county.](../Images/5878e805ae980e18438416dbc167051d.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![按县划分的美国人口密度](../Images/5878e805ae980e18438416dbc167051d.png)'
- en: If you try out the `p1` object you will see that ggplot produces a legible map,
    but by default it chooses an unordered categorical layout. This is because the
    `pop_dens` variable is not ordered. We could recode it so that R is aware of the
    ordering. Alternatively, we can manually supply the right sort of scale using
    the `scale_fill_brewer()` function, together with a nicer set of labels. We will
    learn more about this scale function in the next chapter. We also tweak how the
    legend is drawn using the `guides()` function to make sure each element of the
    key appears on the same row. Again, we will see this use of `guides()` in more
    detail in the next chapter. The use of `coord_equal()` makes sure that the relative
    scale of our map does not change even if we alter the overall dimensions of the
    plot.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用`p1`对象，你会看到ggplot生成了一个可读的地图，但默认情况下，它选择了一个无序的分类布局。这是因为`pop_dens`变量没有排序。我们可以重新编码它，让R知道排序。或者，我们可以使用`scale_fill_brewer()`函数手动提供正确的排序类型，同时提供一组更好的标签。我们将在下一章中了解更多关于此缩放函数的内容。我们还使用`guides()`函数调整图例的绘制方式，以确保关键元素中的每个元素都出现在同一行。我们将在下一章中更详细地看到`guides()`的使用。`coord_equal()`的使用确保即使我们改变整个图表的总体尺寸，地图的相对比例也不会改变。
- en: We can now do exactly the same thing for our map of percent Black population
    by county. Once again, we specify a palette for the `fill` mapping using `scale_fill_brewer()`,
    this time choosing a different range of hues for the map.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为按县划分的黑人人口百分比地图做完全相同的事情。再次，我们使用`scale_fill_brewer()`指定`fill`映射的调色板，这次选择地图的不同色调范围。
- en: '[PRE62]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Figure 7.12: Percent Black population by county.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：按县划分的黑人人口百分比。
- en: '![Percent Black population by county.](../Images/b477ed9a2c1be43e478f72930491524a.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![按县划分的黑人人口百分比](../Images/b477ed9a2c1be43e478f72930491524a.png)'
- en: Figures [7.11](maps.html#fig:ch-07-urchoro1) and [7.12](maps.html#fig:ch-07-urchoro2)
    are America’s “ur-choropleths”. Between the two of them, population density and
    percent Black will do a lot to obliterate many a suggestively-patterned map of
    the United States. These two variables aren’t *explanations* of anything in isolation,
    but if it turns out that it is more useful to know one or both of them instead
    of the thing you’re plotting, you probably want to reconsider your theory.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图[7.11](maps.html#fig:ch-07-urchoro1)和[7.12](maps.html#fig:ch-07-urchoro2)是美国“原始”的
    choropleths。在这两个图表中，人口密度和黑人百分比将极大地抹去许多暗示性的美国地图模式。这两个变量在孤立的情况下并不是任何事物的*解释*，但如果知道其中一个或两个比你要绘制的对象更有用，你可能需要重新考虑你的理论。
- en: As an example of the problem in action, let’s draw two new county-level choropleths.
    The first is an effort to replicate a poorly-sourced but widely-circulated county
    map of firearm-related suicide rates in the United States. The `su_gun6` variable
    in `county_data` (and `county_full`) is a measure of the rate of all firearm-related
    suicides between 1999 and 2015\. The rates are binned into six categories. We
    have a `pop_dens6` variable that divides the population density into six categories,
    too.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 作为问题实际作用的例子，让我们绘制两个新的县级 choropleths。第一个是尝试复制一个来源不明但广泛传播的美国枪支相关自杀率县地图。`county_data`（和`county_full`）中的`su_gun6`变量是1999年至2015年间所有枪支相关自杀率的衡量标准。这些比率被分为六个类别。我们还有一个`pop_dens6`变量，它将人口密度也分为六个类别。
- en: We first draw a map with the `su_gun6` variable. We will match the color palettes
    between the maps, but for the population map we will flip our color scale around
    so that less populated areas are shown in a darker shade. We do this by using
    a function from the RColorBrewer library to manually create two palettes. The
    `rev()` function used here reverses the order of a vector.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`su_gun6`变量绘制地图。我们将匹配地图之间的颜色调色板，但对于人口地图，我们将颜色刻度翻转，以便以较深的色调显示人口较少的区域。我们通过使用RColorBrewer库中的函数手动创建两个调色板来实现这一点。这里使用的`rev()`函数反转了向量的顺序。
- en: '[PRE63]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `brewer.pal()` function produces evenly-spaced color schemes to order from
    any one of several named palettes. The colors are specified in hexadecimal format.
    Again, we will learn more about color specifications and how to manipulate palettes
    for mapped variables in Chapter [8](refineplots.html#refineplots).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`brewer.pal()`函数产生均匀间隔的颜色方案，可以从几个命名调色板中的任何一个进行排序。颜色以十六进制格式指定。同样，我们将在第[8](refineplots.html#refineplots)章中了解更多关于颜色规范和如何操纵映射变量的调色板。'
- en: '[PRE67]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Having drawn the gun plot, we use almost exactly the same code to draw the reverse-coded
    population density map.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制了枪支图表后，我们使用几乎完全相同的代码来绘制反向编码的人口密度地图。
- en: '[PRE68]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It’s clear that the two maps are not identical. However, the visual impact of
    the first has a lot in common with the second. The dark bands in the West (except
    for California) stand out, and fade as we move toward the center of the country.
    There are some strong similarities elsewhere on the map too, such as in the Northeast.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这两张地图并不完全相同。然而，第一张地图的视觉冲击力与第二张有很多共同之处。西部（除了加利福尼亚州）的深色带子突出，并向国家中心逐渐变淡。地图上其他地方也有一些强烈的相似之处，例如在东北部。
- en: The gun-related suicide measure is already expressed as a rate. It is the number
    of qualifying deaths in a county, divided by that county’s population. Normally,
    we standardize in this way to “control for” the fact that larger populations will
    tend to produce more gun-related suicides just because they have more people in
    them. However, this sort of standardization has its limits. In particular, when
    the event of interest is not very common, and there is very wide variation in
    the base size of the units, then the denominator (e.g., the population size) starts
    to be expressed more and more in the standardized measure.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与枪支相关的自杀指标已经表示为比率。它是县内合格死亡人数除以该县的人口数。通常，我们以这种方式进行标准化，以“控制”更大的人口将倾向于产生更多的枪支相关自杀的事实，仅仅是因为他们有更多的人。然而，这种标准化有其局限性。特别是，当感兴趣的事件不太常见，并且单位的基数大小差异很大时，分母（例如，人口规模）开始越来越多地在标准化指标中表达。
- en: '![Gun-related suicides by county; Reverse-coded population density by county.
    Before tweeting this picture, please read the text for discussion of what is wrong
    with it.](../Images/2a742741590b78d74676dfecc884c5b2.png)![Gun-related suicides
    by county; Reverse-coded population density by county. Before tweeting this picture,
    please read the text for discussion of what is wrong with it.](../Images/1a4e08124d11e0309a71b43af45fc48e.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![按县划分的与枪支相关的自杀；按县反向编码的人口密度。在转发这张图片之前，请阅读文本以讨论其存在的问题。](../Images/2a742741590b78d74676dfecc884c5b2.png)![按县划分的与枪支相关的自杀；按县反向编码的人口密度。在转发这张图片之前，请阅读文本以讨论其存在的问题。](../Images/1a4e08124d11e0309a71b43af45fc48e.png)'
- en: 'Figure 7.13: Gun-related suicides by county; Reverse-coded population density
    by county. Before tweeting this picture, please read the text for discussion of
    what is wrong with it.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：按县划分的与枪支相关的自杀；按县反向编码的人口密度。在转发这张图片之前，请阅读文本以讨论其存在的问题。
- en: Third, and more subtly, the data is subject to reporting constraints connected
    to population size. If there are fewer than ten events per year for a cause of
    death, the Centers for Disease Control (CDC) will not report them at the county
    level because it might be possible to identify particular deceased individuals.
    Assigning data like this to bins creates a threshold problem for choropleth maps.
    Look again Figure [7.13](maps.html#fig:ch-07-gunsu). The gun-related suicides
    panel seems to show a north-south band of counties with the lowest rate of suicides
    running from the Dakotas down through Nebraska, Kansas, and into West Texas. Oddly,
    this band borders counties in the West with the very highest rates, from New Mexico
    on up. But from the density map we can see that many counties in both these regions
    have very low population densities. Are they really that different in their gun-related
    suicide rates?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，更微妙的是，数据受到与人口规模相关的报告限制。如果每年因某种死因死亡的事件少于十个，疾病控制中心（CDC）将不会在县级层面报告这些事件，因为这可能有可能识别出特定的已故个人。将此类数据分配到分类中为等值线图创建了一个阈值问题。再次查看图[7.13](maps.html#fig:ch-07-gunsu)。与枪支相关的自杀部分似乎显示了一条从达科他州向南延伸至内布拉斯加州、堪萨斯州，并进入西德克萨斯州的北南向县自杀率最低带。奇怪的是，这条带子与西部自杀率极高的县相邻，从新墨西哥州一直向上。但从密度图我们可以看到，这两个地区的许多县人口密度都非常低。它们在枪支相关自杀率上真的有那么大的差异吗？
- en: Probably not. More likely, we are seeing an artifact arising from how the data
    is coded. For example, imagine a county with 100,000 inhabitants that experiences
    nine gun-related suicides in a year. The CDC will not report this number. Instead
    it will be coded as “suppressed”, accompanied by a note saying any standardized
    estimates or rates will also be unreliable. But if we are determined to make a
    map where all the counties are colored in, we might be tempted to put any suppressed
    results into the lowest bin. After all, we know that the number is somewhere between
    zero and ten. Why not just code it as zero?Do not do this. One standard alternative
    is to estimate the suppressed observations using a count model. An approach like
    this might naturally lead to more extensive, properly spatial modeling of the
    data. Meanwhile, a county with 100,000 inhabitants that experiences twelve gun-related
    suicides a year *will* be numerically reported. The CDC is a responsible organization,
    and so although it provides the absolute number of deaths for all counties above
    the threshold, the notes to the data file will still warn you that any rate calculated
    with this number will be unreliable. If we push ahead and do it anyway, then 12
    deaths in a small population might well put a sparsely-populated county in the
    highest category of suicide rate. Meanwhile, a low-population counties just under
    that threshold would be coded as being in the lowest (lightest) bin. But in reality
    they might not be so different, and in any case efforts to quantify that difference
    will be unreliable. If estimates for these counties cannot be obtained directly
    or estimated with a good model, then it is better to drop those cases as missing,
    even at the cost of your beautiful map, than have large areas of the country painted
    with a color derived from an unreliable number.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不是。更有可能的是，我们看到的只是一个由数据编码方式产生的伪影。例如，想象一个有10万居民的县在一年中发生了九起枪支相关的自杀事件。CDC不会报告这个数字。相反，它会被编码为“被抑制”，并附上说明，任何标准化的估计或比率也将是不可靠的。但如果我们决心制作一个所有县都被着色的地图，我们可能会倾向于将任何被抑制的结果放入最低区间。毕竟，我们知道这个数字在零到十之间。为什么不直接将其编码为零呢？不要这样做。一个标准的替代方案是使用计数模型来估计被抑制的观察值。这种方法可能会自然地导致对数据进行更广泛、更合适的空间建模。同时，一个有10万居民的县在一年中发生十二起枪支相关的自杀事件*将会*被数值报告。CDC是一个负责任的组织，因此尽管它为所有超过阈值的县提供了死亡绝对数，但数据文件中的注释仍会警告你，使用这个数字计算出的任何比率都将是不可靠的。如果我们坚持这样做，那么在小人口中12人死亡可能会将一个人口稀少的县归类为自杀率最高的类别。同时，低于该阈值的低人口县将被编码为位于最低（最轻）的区间。但在现实中，它们可能并没有那么不同，而且在任何情况下，试图量化这种差异的努力将是不可靠的。如果无法直接获得这些县的估计值或无法使用良好的模型进行估计，那么最好是将其作为缺失值删除，即使这会牺牲你美丽的地图，也不应该用不可靠的数字来绘制大片国家的颜色。
- en: Small differences in reporting, combined with miscoding, will produce spatially
    misleading and substantively mistaken results. It might seem that focusing on
    the details of variable coding in this particular case is a little too much in
    the weeds for a general introduction. But it is exactly these details that can
    dramatically alter the appearance of any graph, but especially maps, in a way
    that can be hard to detect after the fact.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 报告中的微小差异，加上错误编码，会产生在空间上误导性和实质上错误的结果。似乎关注这个特定案例中变量编码的细节对于一般介绍来说有点过于深入。但正是这些细节可以极大地改变任何图表的外观，尤其是地图，这种影响在事后可能很难察觉。
- en: 7.3 Statebins
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 状态区间
- en: 'As an alternative to state-level choropleths, we can consider *statebins*,
    using a package developed by Bob Rudis. We will use it to look again at our state-level
    election results. Statebins is similar to ggplot but has a slightly different
    syntax from the one we’re used to. It needs several arguments including the basic
    data frame (the `state_data` argument), a vector of state names (`state_col`),
    and the value being shown (`value_col`). In addition, we can optionally tell it
    the color palette we want to use and the color of the text to label the state
    boxes. For a continuous variable we can use `statebins_continuous()`, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 作为州级渐变色的替代方案，我们可以考虑使用Bob Rudis开发的包来使用*状态区间*。我们将用它再次查看我们的州级选举结果。状态区间类似于ggplot，但其语法与我们习惯的不同。它需要几个参数，包括基本数据框（`state_data`参数）、州名向量（`state_col`）和要显示的值（`value_col`）。此外，我们可以选择性地告诉它我们想要的调色板和用于标注州框的文本颜色。对于连续变量，我们可以使用`statebins_continuous()`，如下所示：
- en: '![Statebins of the election results. We omit DC from the Clinton map to prevent
    the scale becoming unbalanced.](../Images/b0cc80f86d663953bb000c192b3c5ef0.png)![Statebins
    of the election results. We omit DC from the Clinton map to prevent the scale
    becoming unbalanced.](../Images/b3532df43e28c7c4536ec4e6831ed120.png) Figure 7.14:
    Statebins of the election results. We omit DC from the Clinton map to prevent
    the scale becoming unbalanced.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![选举结果的状态箱。为了防止比例失衡，我们从克林顿地图中省略了哥伦比亚特区](../Images/b0cc80f86d663953bb000c192b3c5ef0.png)![选举结果的状态箱。为了防止比例失衡，我们从克林顿地图中省略了哥伦比亚特区](../Images/b3532df43e28c7c4536ec4e6831ed120.png)
    图7.14：选举结果的状态箱。为了防止比例失衡，我们从克林顿地图中省略了哥伦比亚特区。'
- en: '[PRE69]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Sometimes we will want to present categorical data. If our variable is already
    cut into categories we can use `statebins_manual()` to represent it. Here add
    a new variable to the `election` data called `color`, just mirroring party names
    with two appropriate color names. We do this because we need to specify the colors
    we are using by way of a variable in the data frame, not as a proper mapping.
    We tell the `statebins_manual()` function that the colors are contained in column
    named `color`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能需要展示分类数据。如果我们的变量已经被划分为类别，我们可以使用 `statebins_manual()` 函数来表示它。在这里，向 `election`
    数据集添加一个名为 `color` 的新变量，用两个合适的颜色名称来映射党派名称。我们这样做是因为我们需要通过数据框中的变量来指定我们使用的颜色，而不是作为正确的映射。我们告诉
    `statebins_manual()` 函数，颜色包含在名为 `color` 的列中。
- en: Alternatively, we can have `statebins()` cut the data for us using the `breaks`
    argument, as in the second plot.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `statebins()` 函数通过 `breaks` 参数来为我们切割数据，就像第二个图表中那样。
- en: '![Manually specifying colors for statebins.](../Images/75d1261dd857cf92c3802f2eca4bdd7f.png)![Manually
    specifying colors for statebins.](../Images/5d771d400ed1ae057f1f2f1b733778c5.png)
    Figure 7.15: Manually specifying colors for statebins.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![手动指定状态箱的颜色](../Images/75d1261dd857cf92c3802f2eca4bdd7f.png)![手动指定状态箱的颜色](../Images/5d771d400ed1ae057f1f2f1b733778c5.png)
    图7.15：手动指定状态箱的颜色。'
- en: '[PRE70]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 7.4 Small-multiple maps
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 小多地图
- en: Sometimes we have geographical data with repeated observations over time. A
    common case is to have a country- or state-level measure observed over a period
    of years. In these cases, we might want to make a small multiple map to show changes
    over time. For example, the `opiates` data has state-level measures of the death
    rate from opiate-related causes (such as heroin or fentanyl overdoses) between
    1999 and 2014.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们拥有随时间重复观察的地理数据。一个常见的情况是在几年内观察国家或州一级的指标。在这些情况下，我们可能想要制作一个小的多地图来展示随时间的变化。例如，`opiates`
    数据包含了1999年至2014年间州一级的阿片类药物相关死亡率的指标（如海洛因或芬太尼过量）。
- en: '[PRE71]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As before, we can take our `us_states` object, the one with the state-level
    map details, and merge it with our opiates dataset. As before, we convert the
    `State` variable in the `opiates` data to lower-case first, to make the match
    work properly.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以将我们的 `us_states` 对象，即包含州级地图详细信息的对象，与我们的 `opiates` 数据集合并。同样，我们将 `opiates`
    数据中的 `State` 变量转换为小写，以确保匹配正确。
- en: '[PRE73]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Because the `opiates` data includes the `Year` variable, we are now in a position
    to make a faceted small-multiple with one map for each year in the data. The following
    chunk of code is similar to the single state-level maps we have drawn so far.
    We specify the map data as usual, adding `geom_polygon()` and `coord_map()` to
    it, with the arguments those functions need. Instead of cutting our data into
    bins we will plot the continuous values for the adjusted death rate variable (`adjusted`)
    directly.If you want to experiment with cutting the data in to groups on the fly,
    take a look at the `cut_interval()` function. To help plot this variable effectively,
    we will use a new scale function from the `viridis` library. The viridis colors
    run in low-to-high sequences and do a very good job of combining perceptually
    uniform colors with easy-to-see, easily-contrasted hues along their scales. The
    `viridis` library provides continuous and discrete versions, both in several alternatives.
    Some balanced palettes can be a little washed out at their lower end, especially,
    but the viridis palettes avoid this. In this code, the `_c_` suffix in the `scale_fill_viridis_c()`
    function signals that it is the scale for continuous data. There is a `scale_fill_viridis_d()`
    equivalent for discrete data.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因为“鸦片”数据包括了“年份”变量，我们现在可以制作一个分面小型多图，每个年份对应一个地图。以下代码块与迄今为止绘制的单个州级地图类似。我们像往常一样指定地图数据，向其中添加`geom_polygon()`和`coord_map()`，并传入这些函数所需的参数。我们不会将数据切割成箱，而是直接绘制调整后的死亡率变量（`adjusted`）的连续值。如果你想在飞行中尝试将数据切割成组，请查看`cut_interval()`函数。为了有效地绘制这个变量，我们将使用来自`viridis`库的新比例函数。viridis颜色按低到高的顺序排列，并在其比例上很好地结合了感知上均匀的颜色和易于看到、易于对比的色调。`viridis`库提供了连续和离散版本，都有几种选择。一些平衡的调色板在其低端可能会显得有点淡化，尤其是，但viridis调色板避免了这一点。在这段代码中，`scale_fill_viridis_c()`函数中的`_c_`后缀表示它是连续数据的比例。对于离散数据，有一个等效的`scale_fill_viridis_d()`。
- en: We facet the maps just like any other small-multiple with `facet_wrap()`. We
    use the `theme()` function to put the legend at the bottom and remove the default
    shaded background from the year labels. We will learn more about this use of the
    `theme()` function in Chapter [8](refineplots.html#refineplots). The final map
    is shown in Figure [7.16](maps.html#fig:ch-07-opiatemap).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`facet_wrap()`函数像任何其他小型多图一样分面地图。我们使用`theme()`函数将图例放在底部，并从年份标签中移除默认的阴影背景。我们将在第[8](refineplots.html#refineplots)章中了解更多关于`theme()`函数的用法。最终的地图如图[7.16](maps.html#fig:ch-07-opiatemap)所示。
- en: '[PRE74]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '![A small multiple map. States in grey reported too few deaths for a reliable
    population estimate in that year. States in white reported no data.](../Images/bf2bb1d1d0aaef98040ceb454e3a68f0.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![一个小型多图。当年死亡人数过少，无法可靠估计人口数量的州用灰色表示。没有数据的州用白色表示。](../Images/bf2bb1d1d0aaef98040ceb454e3a68f0.png)'
- en: 'Figure 7.16: A small multiple map. States in grey reported too few deaths for
    a reliable population estimate in that year. States in white reported no data.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16：一个小型多图。当年死亡人数过少，无法可靠估计人口数量的州用灰色表示。没有数据的州用白色表示。
- en: Is this a good way to visualize this data?Try revisiting your code for the ur-choropleths,
    but use continuous rather than binned measures, as well as the `viridis` palette.
    Instead of `pct_black` use the `black` variable. For the population density, divide
    `pop` by `land_area`. You will need to adjust the `scale_` functions. How do the
    maps compare to the binned versions? What happens to the population density map,
    and why? As we discussed above, choropleth maps of the U.S. tend to track first
    the size of the local population and secondarily the percent of the population
    that is African-American. The differences in the geographical size of states makes
    spotting changes more difficult again. And it is quite difficult to compare repeatedly
    across spatial regions. The repeated measures do mean that some comparison is
    possible, and the strong trends for this data make things a little easier to see.
    In this case, a casual viewer might think, for example, that the opiod crisis
    was worst in the desert southwest in comparison to many other parts of the country,
    although it also seems that something serious is happening in the Appalachians.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种好的数据可视化方法吗？尝试重新审视您的原始代码，但对于 choropleths 使用连续而不是分箱的度量，以及使用 `viridis` 色彩表。用
    `black` 变量代替 `pct_black`。对于人口密度，将 `pop` 除以 `land_area`。您将需要调整 `scale_` 函数。地图与分箱版本相比如何？人口密度地图发生了什么变化，为什么？正如我们上面讨论的，美国的面状图往往首先追踪当地人口规模，其次是非洲裔美国人口百分比。各州地理规模的差异使得发现变化变得更加困难。而且，在不同空间区域之间反复比较相当困难。重复的度量确实意味着可以进行一些比较，并且这些数据的强烈趋势使得事情更容易观察。在这种情况下，一个普通的观察者可能会认为，例如，与该国的许多其他地区相比，阿巴拉契亚地区的阿片类药物危机最严重，尽管似乎阿巴拉契亚地区也发生了严重的事情。
- en: 7.5 Is your data really spatial?
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 您的数据真的是空间数据吗？
- en: As we noted at the beginning of the Chapter, even if our data is collected via
    or grouped into spatial units, it is always worth asking whether a map is the
    best way to present it. Much county- state- and national data is not properly
    spatial, insofar as it is really about individuals (or some other unit of interest)
    rather than the geographical distribution of those units *per se*. Let’s take
    our state-level opiates data and redraw it as a time-series plot. We will keep
    the state-level focus (these are state-level rates, after all), but try to make
    the trends more directly visible.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们在本章开头所提到的，即使我们的数据是通过或分组到空间单元收集的，询问是否地图是展示数据的最佳方式总是值得的。许多县、州和国家数据实际上并不是真正空间化的，因为它们真正关注的是个人（或感兴趣的某个单位）而不是这些单位的地理分布本身。让我们将我们的州级阿片类药物数据重新绘制成时间序列图。我们将保持州级焦点（毕竟，这些是州级比率），但尝试使趋势更加直接可见。
- en: We could just plot the trends for every state, as we did at the very beginning
    with the `gapminder` data. But fifty states is too many lines to keep track of
    at once.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像最初使用 `gapminder` 数据那样，为每个州绘制趋势图。但是，五十个州的线条太多，难以同时跟踪。
- en: '![All the states at once.](../Images/d208d7f0edc933a531d4f9d35093bddf.png)
    Figure 7.17: All the states at once.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![所有州同时展示。](../Images/d208d7f0edc933a531d4f9d35093bddf.png) 图 7.17：所有州同时展示。'
- en: '[PRE75]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: A more informative approach is to take advantage of the geographical structure
    of the data by using the census regions to group the States. Imagine a faceted
    plot showing state-level trends within each region of the country, perhaps with
    a trend line for each region. To do this, we will take advantage of ggplot’s ability
    to layer geoms one on top of another, using a different dataset in each case.
    We begin by taking the `opiates` data (removing Washington DC, as it is not a
    state), and plotting the adjusted death rate over time.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更信息化的方法是利用数据的地理结构，通过使用人口普查区来分组各州。想象一下，一个分面图显示了国家每个地区内的州级趋势，也许每个地区都有一个趋势线。为此，我们将利用
    ggplot 的能力，将 geom 在另一个 geom 之上分层，每个情况下使用不同的数据集。我们首先取 `opiates` 数据（移除华盛顿特区，因为它不是一个州），并绘制调整后的死亡率随时间的变化。
- en: '[PRE76]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `drop_na()` function deletes rows that have observations missing on the
    specified variables, in this case just `division_name`, because Washington DC
    is not part of any Census Division. We map the `group` aesthetic to `state` in
    `geom_line()`, which gives us a line plot for every state. We use the `color`
    argument in to set the lines to a light gray. Next, we add a smoother:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`drop_na()` 函数删除了在指定变量上缺失观测值的行，在本例中就是 `division_name`，因为华盛顿特区不属于任何人口普查区。我们在
    `geom_line()` 中将 `group` 视觉效果映射到 `state`，这为我们提供了每个州的折线图。我们使用 `color` 参数将线条设置为浅灰色。接下来，我们添加一个平滑器：'
- en: '[PRE77]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: For this geom we set the `group` aesthetic to `division_name`. (Division is
    a smaller Census classification than Region.) If we set it to `state` we would
    get fifty separate smoothers in addition to our fifty trend lines. Then, using
    what we learned in Chapter [4](groupfacettx.html#groupfacettx), we add a `geom_text_repel()`
    object that puts the label for each state at the end of the series. Because we
    are labeling lines rather than points, we only want the state label to appear
    at the end of the line. The trick is to subset the data so that only the points
    the last year observed are used (and thus labeled). We also must remember to remove
    Washington DC again here, as the new `data` argument supersedes the original one
    in `p0`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个几何图形，我们将`group`美学设置为`division_name`。（Division是比Region更小的普查分类。）如果我们将其设置为`state`，我们除了五十条趋势线外，还会得到五十个单独的平滑器。然后，利用我们在第[4](groupfacettx.html#groupfacettx)章中学到的知识，我们添加了一个`geom_text_repel()`对象，将每个州的标签放置在序列的末尾。因为我们是在标记线而不是点，所以我们只希望州标签出现在线的末尾。技巧是子集化数据，以便只使用最后一年观察到的点（因此标记）。我们还必须记住再次删除华盛顿特区，因为新的`data`参数取代了`p0`中的原始参数。
- en: '[PRE78]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: By default, `geom_text_repel` will at little line segments that indicate what
    the labels refer to. But that is not helpful here, as we are already dealing with
    the end point of a line. So we turn them off with the argument `segment.color
    = NA`. We also bump the labels off to the right of the lines a little, using the
    `nudge_x` argument, and use `coord_cartesian()` to set the axis limits so that
    there is enough room for them.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`geom_text_repel`会在小线段上添加标签，指示标签所指的内容。但在这里这并不 helpful，因为我们已经处理了线的终点。因此，我们通过`segment.color
    = NA`参数将其关闭。我们还使用`nudge_x`参数将标签稍微向线的右侧移动，并使用`coord_cartesian()`设置坐标轴限制，以便有足够的空间。
- en: Finally, we facet the results by Census Division and add our labels. A useful
    adjustment is to reorder the panels by the average death rate. We put a minus
    in front of `adjusted` to that the divisions with the highest average rates appear
    in the chart first.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们按普查区划分结果，并添加我们的标签。一个有用的调整是按平均死亡率重新排序面板。我们在`adjusted`前加一个减号，以便具有最高平均率的分区首先出现在图表中。
- en: '[PRE79]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Our new plot brings out much of the overall story that is in the maps, but also
    shifts the emphasis a bit. It is easier to see more clearly what is happening
    in some parts of the country. In particular you can see the climbing numbers in
    New Hampshire, Rhode Island, Massachussetts, and Connecticut. You can more easily
    see the state-level differences in the West, for instance between Arizona, on
    the one hand, and New Mexico or Utah on the other. And as was also visible on
    the maps, the astonishingly rapid rise in West Virginia’s death rate is also evident.
    Finally, the time-series plots are better at conveying the diverging trajectories
    of various states within regions. There is a lot more variance at the end of the
    series than at the beginning, especially in the Northeast, Midwest, and South,
    and while this can be inferred from the maps it is easier to see in the trend
    plots.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新图表突出了地图中大部分的整体故事，但也稍微改变了重点。更容易清楚地看到国家某些地区正在发生的事情。特别是你可以看到新罕布什尔州、罗德岛、马萨诸塞州和康涅狄格州的数字在上升。你更容易看到西部各州之间的州级差异，例如亚利桑那州与另一方面的新墨西哥州或犹他州之间的差异。而且正如地图上所显示的，西弗吉尼亚州死亡率惊人地快速上升也是显而易见的。最后，时间序列图更好地传达了区域内各州的不同轨迹。在序列的末尾比开头有更多的方差，尤其是在东北部、中西部和南部，虽然这可以从地图中推断出来，但在趋势图中更容易看到。
- en: '![The opiate data as a faceted time-series.](../Images/419e9fabf3a7a4c4d47b584db781464b.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![吗啡数据作为分面时间序列图](../Images/419e9fabf3a7a4c4d47b584db781464b.png)'
- en: 'Figure 7.18: The opiate data as a faceted time-series.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18：吗啡数据作为分面时间序列。
- en: The unit of observation in this graph is still the state-year. The geographically-bound
    nature of the data never goes away. The lines we draw still represent states.
    Thus, the basic arbitrariness of the representation cannot be made to disappear.
    In some sense, an ideal dataset here would be collected at some much more fine-grained
    level of unit, time, and spatial specificity. Imagine individual-level data with
    arbitrarily precise information on personal characteristics, times, and location
    of death. In a case like that, we could then aggregate up to any categorical,
    spatial, or temporal units we liked. But data like that is extremely rare, often
    for very good reasons that range from practicality of collection to the privacy
    of individuals. In practice we need to take care not to commit a kind of fallacy
    of misplaced concreteness that mistakes the unit of observation for the thing
    of real substantive or theoretical interest. This is a problem for most kinds
    of social-scientific data. But their striking visual character makes maps perhaps
    more vulnerable to this problem than other kinds of visualization.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，观察的单位仍然是州-年。数据的地理限制性质永远不会消失。我们绘制的线条仍然代表州。因此，表示的基本任意性无法消失。在某种意义上，一个理想的数据库应该是在更细粒度的单位、时间和空间特定性上收集的。想象一下具有关于个人特征、时间和死亡地点的任意精确信息的个体级数据。在这种情况下，我们可以将数据聚合到我们喜欢的任何分类、空间或时间单位。但是，这样的数据非常罕见，通常有很好的理由，从收集的实用性到个人的隐私。在实践中，我们需要注意不要犯一种将观察单位误认为是真正实质性或理论兴趣对象的错误具体化谬误。这是大多数社会科学数据的问题。但它们的引人注目的视觉特征使得地图可能比其他类型的可视化更容易出现这个问题。
- en: 7.6 Where to go next
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 接下来去哪里
- en: In this chapter, we learned how to begin work with state-level and county-level
    data organized by FIPS codes. But this barely scratches the surface of visualization
    where spatial features and distributions are the main focus. The analysis and
    visualization of spatial data is its own research area, with its own research
    disciplines in Geography and Cartography. Concepts and methods for representing
    spatial features are both well-developed and standardized. Until recently, most
    of this functionality was accessible only through dedicated Geographical Information
    Systems. Their mapping and spatial analysis features were not well connected.
    Or at least, they were not conveniently connected to software oriented to the
    analysis of tabular data.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何开始使用按FIPS代码组织的州级和县级数据。但这只是触及了可视化的表面，其中空间特征和分布是主要焦点。空间数据的分析和可视化是一个独立的研究领域，在地理学和制图学中拥有自己的研究学科。表示空间特征的概念和方法都得到了很好的发展和标准化。直到最近，大多数这种功能只能通过专门的地理信息系统访问。它们的映射和空间分析功能并没有很好地连接起来。或者至少，它们并没有方便地连接到面向表格数据分析的软件。
- en: This is changing fast. Brundson & Comber (2015) provide an introduction to some
    of R’s mapping capabilities. Meanwhile, very recently these tools have become
    much more easily accessible via the tidyverse. Of particular interest to social
    scientists`r-spatial.github.io/sf/`. Also see news and updates at `r-spatial.org`.
    is Edzer Pebesma’s ongoing development of the `sf` package, which implements the
    standard Simple Features data model for spatial features in a tidyverse-friendly
    way. Relatedly, Kyle Walker and Bob Rudis’s `tigris` package`github.com/walkerke/tigris`
    allows for (sf-library combatible) access to the U.S. Census Bureau’s TIGER/Line
    shapefiles, which allow you to map data for many different geographical, administrative,
    and Census-related subdivisions of the United States, as well as things roads
    and water features. Finally, Kyle Walker’s `tidycensus` package`walkerke.github.io/tidycensus`
    (Walker, 2018) makes it much easier to tidily get both substantive and spatial
    feature data from the U.S. Census and the American Community Survey.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化正在迅速发生。Brundson & Comber (2015) 为R的映射能力提供了一些介绍。同时，最近这些工具通过tidyverse变得更加容易访问。对社会科学工作者来说，特别感兴趣的是`r-spatial.github.io/sf/`。还可以在`r-spatial.org`查看新闻和更新。Edzer
    Pebesma正在持续开发`sf`包，它以tidyverse友好的方式实现了空间特征的标准化简单特征数据模型。相关地，Kyle Walker和Bob Rudis的`tigris`包`github.com/walkerke/tigris`允许（与sf库兼容）访问美国人口普查局的TIGER/Line形状文件，这些文件允许你为美国许多不同的地理、行政和人口普查相关的次级单位以及道路和水域特征绘制数据。最后，Kyle
    Walker的`tidycensus`包`walkerke.github.io/tidycensus`（Walker，2018）使得从美国人口普查和美国社区调查中获取实质性数据和空间特征数据变得更加容易。
