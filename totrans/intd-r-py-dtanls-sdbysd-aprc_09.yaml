- en: Chapter 6 Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 函数
- en: 原文：[https://randpythonbook.netlify.app/functions](https://randpythonbook.netlify.app/functions)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://randpythonbook.netlify.app/functions](https://randpythonbook.netlify.app/functions)
- en: This text has already covered how to *use* functions that come to us pre-made.
    At least we have discussed how to use them in a one-off way–just write the name
    of the function, write some parentheses after that name, and then plug in any
    requisite arguments by writing them in a comma-separated way between those two
    parentheses. This is how it works in both R and Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此文本已经介绍了如何*使用*预制的函数。至少我们已经讨论了如何一次性使用它们——只需写出函数名，在该名称后写一些括号，然后通过在两个括号之间以逗号分隔的方式写入任何必需的参数来插入。这在R和Python中都是这样工作的。
- en: In this section we take a look at how to *define* our own functions. This will
    not only help us to understand pre-made functions, but it will also be useful
    if we need some extra functionality that isn’t already provided to us.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何*定义*我们自己的函数。这不仅有助于我们理解预制的函数，而且如果我们需要一些尚未提供的额外功能，这也会很有用。
- en: Writing our own functions is also useful for “packaging up” computations. The
    utility of this will become apparent very soon. Consider the task of estimating
    a regression model. If you have a function that performs all of the required calculations,
    then
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 编写我们自己的函数也有助于“打包”计算。这种实用性很快就会变得明显。考虑估计回归模型的任务。如果你有一个执行所有必需计算的功能，那么
- en: you can estimate models without having to think about lower-level details or
    write any code yourself, and
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以估算模型，无需考虑底层细节或自己编写任何代码，并且
- en: you can re-use this function every time you fit any model on any data set for
    any project.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在任何项目中对任何数据集上的任何模型进行拟合时重复使用此函数。
- en: 6.1 Defining R Functions
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 定义R函数
- en: To create a function in R, we need another function called `function()`. We
    give the output of `function()` a name in the same way we give names to any other
    variable in R, by using the assignment operator `<-` . Here’s an example of a
    toy function called `addOne()`. Here `myInput` is a placeholder that refers to
    whatever the user of the function ends up plugging in.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要在R中创建一个函数，我们需要另一个名为 `function()` 的函数。我们以与在R中给任何其他变量命名相同的方式给 `function()` 的输出命名，即使用赋值运算符
    `<-` 。以下是一个名为 `addOne()` 的玩具函数的示例。在这里，`myInput` 是一个占位符，它指的是函数用户最终插入的任何内容。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Below the definition, the function is called with an input of `41`. When this
    happens, the following sequence of events occurs
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义下方，函数使用 `41` 作为输入被调用。当发生这种情况时，以下事件序列发生
- en: The value `41` is assigned to `myInput`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值 `41` 被分配给 `myInput`
- en: '`myOutput` is given the value `42`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`myOutput` 被赋予值 `42`'
- en: '`myOutput`, which is `42`, is returned from the function'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`myOutput`，其值为 `42`，将从函数返回'
- en: the temporary variables `myInput` and `myOutput` are destroyed.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时变量 `myInput` 和 `myOutput` 被销毁。
- en: We get the desired answer, and all the unnecessary intermediate variables are
    cleaned up and thrown away after they are no longer needed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到所需的答案，并且所有不必要的中间变量在不再需要后都会被清理并丢弃。
- en: If you are interested in writing a function, I recommend that you first write
    the logic outside of a function. This initial code will be easier to debug because
    your temporary variables will not be destroyed after the final result has been
    obtained. Once you are happy with the working code, you can copy and paste the
    logic into a function definition, and replace permanent variables with function
    inputs like `myInput` above.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对编写函数感兴趣，我建议你首先在函数外部编写逻辑。由于你的临时变量在最终结果获得后不会被销毁，因此初始代码将更容易调试。一旦你对工作代码满意，你就可以将逻辑复制并粘贴到函数定义中，并用函数输入（如上面的
    `myInput`）替换永久变量。
- en: 6.2 Defining Python Functions
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 定义Python函数
- en: To create a function in Python, we use the `def` statement (instead of the `function()`
    function in R). The desired name of the function comes next. After that, the formal
    parameters come, comma-separated inside parentheses, just like in R.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中创建一个函数，我们使用 `def` 语句（而不是R中的 `function()` 函数）。函数的期望名称接下来。然后是形式参数，以逗号分隔的方式放在括号内，就像在R中一样。
- en: Defining a function in Python is a little more concise. There is no assignment
    operator like there is in R, there are no curly braces, and `return` isn’t a function
    like it is in R, so there is no need to use parentheses after it. There is one
    syntactic addition, though–we need a colon (`:`) at the end of the first line
    of the definition.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中定义函数稍微简洁一些。与R不同，没有赋值运算符，没有花括号，`return`也不是像R中的函数那样，因此不需要在其后使用括号。尽管如此，有一个语法上的添加——在定义的第一行末尾需要有一个冒号（`:`）。
- en: Here is an example of a toy function called `add_one()`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个名为`add_one()`的玩具函数的例子。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Below the definition, the function is called with an input of `41`. When this
    happens, the following sequence of events occurs
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义下方，函数使用`41`作为输入被调用。当发生这种情况时，以下一系列事件发生
- en: The value `41` is assigned to `my_input`
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值`41`赋给`my_input`
- en: '`my_output` is given the value `42`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_output`被赋予值`42`'
- en: '`my_output`, which is `42`, is returned from the function'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_output`，其值为`42`，从函数中返回'
- en: the temporary variables `my_input` and `my_output` are destroyed.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时变量`my_input`和`my_output`被销毁。
- en: We get the desired answer, and all the unnecessary intermediate variables are
    cleaned up and thrown away after they are no longer needed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了期望的答案，并且所有不必要的中间变量在不再需要后都被清理并丢弃。
- en: 6.3 More Details On R’s User-Defined Functions
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 R的自定义函数的更多细节
- en: 'Technically, in R, functions are [defined as three things bundled together](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Function-objects):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术上，在R中，函数被[定义为三个捆绑在一起的东西](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Function-objects)：
- en: a **formal argument list** (also known as *formals*),
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**形式参数列表**（也称为*形式*），
- en: a **body**, and
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**主体**，和
- en: a **parent environment**.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**父环境**。
- en: The *formal argument list* is exactly what it sounds like. It is the list of
    arguments a function takes. You can access a function’s formal argument list using
    the `formals()` function. Note that it is not the *actual* arguments a user will
    plug in–that isn’t knowable at the time the function is created in the first place.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*形式参数列表*正如其名。它是函数接受的参数列表。你可以使用`formals()`函数访问函数的形式参数列表。请注意，它不是用户将插入的*实际*参数——在函数最初创建时这是不可知的。'
- en: Here is another function that takes a parameter called `whichNumber` that comes
    with a **default argument** of `1`. If the caller of the function does not specify
    what she wants to add to `myInput`, `addNumber()` will use `1` as the default.
    This default value shows up in the output of `formals(addNumber)`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是另一个接受一个名为`whichNumber`的参数的函数，该参数有一个**默认参数**为`1`。如果函数的调用者没有指定她想要添加到`myInput`的内容，`addNumber()`将使用`1`作为默认值。这个默认值出现在`formals(addNumber)`的输出中。
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function’s *body* is also exactly what it sounds like. It is the work that
    a function performs. You can access a function’s body using the the `body()` function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的*主体*正如其名。它是函数执行的工作。你可以使用`body()`函数访问函数的主体。
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Every function you create also has a *parent environment*[^(10)](#fn10). You
    can get/set this using the `environment()` function. Environments help a function
    know which variables it is allowed to use and how to use them. The parent environment
    of a function is where the function was *created*, and it contains variables outside
    of the body that the function can also use. The rules of which variables a function
    can use are called *scoping*. When you create functions in R, you are primarily
    using **lexical scoping**. This is discussed in more detail in section [6.5](/functions#function-scope-in-r).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的每个函数也都有一个*父环境*[^(10)](#fn10)。你可以使用`environment()`函数获取/设置它。环境帮助函数知道它可以使用哪些变量以及如何使用它们。函数的父环境是函数被*创建*的地方，它包含函数也可以使用的变量。函数可以使用哪些变量的规则称为*作用域*。当你使用R创建函数时，你主要使用**词法作用域**。这将在第6.5节（/functions#function-scope-in-r）中更详细地讨论。
- en: There is a lot more information about environments that isn’t provided in this
    text. For instance, a user-defined function also has [binding, execution, and
    calling environments associated with it](http://adv-r.had.co.nz/Environments.html#function-envs),
    and environments are used in creating package namespaces, which are important
    when two packages each have a function with the same name.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关于环境的信息还有很多，这里没有提供。例如，用户定义的函数也有[绑定、执行和调用环境与之相关](http://adv-r.had.co.nz/Environments.html#function-envs)，并且环境用于创建包命名空间，这在两个包各自有一个同名函数时非常重要。
- en: 6.4 More details on Python’s user-defined functions
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 Python用户定义函数的更多细节
- en: Roughly, Python functions have the same things R functions have. They have a
    **formal parameter list**, a body, and there are [namespaces](https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces)
    created that help organize which variables the function can access, as well as
    which pieces of code can call this new function. A namespace is just a “mapping
    from names to objects.”
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，Python函数与R函数有相同的东西。它们有**形式参数列表**、主体，并且创建了[命名空间](https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces)，这有助于组织函数可以访问的变量，以及哪些代码可以调用这个新函数。命名空间只是“从名称到对象的映射。”
- en: These three concepts are analogous to those in R. The names are just a bit different
    sometimes, and it isn’t organized in the same way. To access these bits of information,
    you need to access the *special attributes* of a function. User-defined functions
    in Python have a lot of pieces of information attached to them. If you’d like
    to see all of them, you can visit [this page of documentation](https://docs.python.org/3/reference/datamodel.html#objects-values-and-types).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个概念与R中的类似，名称有时略有不同，并且组织方式也不尽相同。要访问这些信息片段，您需要访问函数的*特殊属性*。Python中的用户定义函数附带了大量的信息。如果您想查看所有这些信息，可以访问[这个文档页面](https://docs.python.org/3/reference/datamodel.html#objects-values-and-types)。
- en: So, for instance, let’s try to find the *formal parameter list* of a user-defined
    function below. This is, again, the collection of inputs a function takes. Just
    like in R, this is not the *actual* arguments a user will plug in–that isn’t knowable
    at the time the function is created.[^(11)](#fn11) Here we have another function
    called `add_number()` that takes a parameter `which_number` that is accompanied
    by a default argument of `1`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们尝试找到用户定义函数的*形式参数列表*。这又是函数接受的输入集合。就像在R中一样，这并不是用户将插入的*实际*参数——在函数创建时这是不可知的。[^(11)](#fn11)
    这里我们还有一个名为`add_number()`的函数，它接受一个名为`which_number`的参数，该参数有一个默认参数`1`。
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `__code__` attribute has much more to offer. To see a list of names of all
    its contents, you can use `dir(add_number.__code__)`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`__code__`属性提供了更多功能。要查看其内容的所有名称列表，可以使用`dir(add_number.__code__)`。'
- en: Don’t worry if the notation `add_number.__code__` looks strange. The dot (`.`)
    operator will become more clear in the future chapter on *object-oriented programming*.
    For now, just think of `__code__` as being an object *belonging to* `add_number`.
    Objects that belong to other objects are called **attributes** in Python. The
    dot operator helps us access attributes *inside* other objects. It also helps
    us access objects belonging to modules that we `import` into our scripts.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`add_number.__code__`的表示法看起来很奇怪，请不要担心。点(`.`)操作符将在未来的面向对象编程章节中变得更加清晰。现在，只需将`__code__`视为属于`add_number`的对象。属于其他对象的对象在Python中被称为**属性**。点操作符帮助我们访问其他对象内部的属性。它还帮助我们访问我们`导入`到脚本中的模块所属的对象。
- en: 6.5 Function Scope in R
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 R中的函数作用域
- en: R uses **lexical scoping**. This means, in R,
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: R使用**词法作用域**。这意味着，在R中，
- en: functions can use *local* variables that are defined inside themselves,
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数可以使用在其内部定义的*局部*变量，
- en: functions can use *global* variables defined in the environment where the function
    itself was *defined* in, and
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数可以使用在函数自身被*定义*的环境中定义的*全局*变量，并且
- en: functions *cannot* necessarily use *global* variables defined in the environment
    where the function was *called* in, and
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数不一定可以使用在函数被*调用*的环境中定义的*全局*变量，并且
- en: functions will prefer *local* variables to *global* variables if there is a
    name clash.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在名称冲突，函数将优先使用*局部*变量。
- en: The first characteristic is obvious. The second and third are import to distinguish
    between. Consider the following code below. `sillyFunction()` can access `a` because
    `sillyFunction()` and `a` are defined in the same place.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个特征很明显。第二个和第三个特征很重要，需要区分。考虑以下代码。`sillyFunction()`可以访问`a`，因为`sillyFunction()`和`a`是在同一个地方定义的。
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On the other hand, the following example will not work because `a` and `anotherSillyFunc()`
    are not defined in the same place. Calling the function is not the same as defining
    a function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下示例将无法工作，因为`a`和`anotherSillyFunc()`不是在同一个地方定义的。调用函数与定义函数并不相同。
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, here is a demonstration of a function preferring one `a` over another.
    When `sillyFunction()` attempts to access `a`, it first looks in its own body,
    and so the innermost one gets used. On the other hand, `print(a)` shows `3`, the
    global variable.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一个函数优先选择一个`a`而不是另一个的演示。当`sillyFunction()`尝试访问`a`时，它首先在其自身体内查找，因此最内层的被使用。另一方面，`print(a)`显示的是全局变量`3`。
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The same concept applies if you create functions within functions. The inner
    function `innerFunc()` looks “inside-out” for variables, but only in the place
    it was defined.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在函数内部创建函数，同样的概念也适用。内部函数`innerFunc()`会“由内向外”寻找变量，但只在其定义的地方寻找。
- en: Below we call `outerFunc()`, which then calls `innerFunc()`. `innerFunc()` can
    refer to the variable `b`, because it lies in the same environment in which `innerFunc()`
    was created. Interestingly, `innerFunc()` can also refer to the variable `a`,
    because that variable was captured by `outerFunc()`, which provides access to
    `innerFunc()`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我们调用`outerFunc()`，然后它调用`innerFunc()`。`innerFunc()`可以引用变量`b`，因为它位于与`innerFunc()`创建时相同的环境中。有趣的是，`innerFunc()`也可以引用变量`a`，因为该变量被`outerFunc()`捕获，这为`innerFunc()`提供了访问权限。
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here’s another interesting example. If we ask `outerFunc()` to return the function
    `innerFunc()` (not the return object of `innerFunct()`…functions are objects,
    too!), then we might be surprised to see that `innerFunc()` can still successfully
    refer to `b`, even though it doesn’t exist inside the *calling environment.* But
    don’t be surprised! What matters is what was available when the function was *created*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的例子。如果我们要求`outerFunc()`返回函数`innerFunc()`（而不是`innerFunct()`的返回对象……函数也是对象！），我们可能会惊讶地看到`innerFunc()`仍然可以成功引用`b`，即使它不存在于**调用环境**中。但不要感到惊讶！重要的是函数**创建**时可用的情况。
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We use this property all the time when we create functions that return other
    functions. This is discussed in more detail in chapter [15](/an-introduction-to-functional-programming#an-introduction-to-functional-programming).
    In the above example, `outerFuncV2()`, the function that returned another function,
    is called a *function factory*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建返回其他函数的函数时经常使用这个特性。这将在第[15](/an-introduction-to-functional-programming#an-introduction-to-functional-programming)章中更详细地讨论。在上面的例子中，返回另一个函数的函数`outerFuncV2()`被称为**函数工厂**。
- en: Sometimes people will refer to R’s functions as **closures** to emphasize that
    they are capturing variables from the parent environment in which they were created,
    to emphasize the data that they are bundled with.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 人们有时会将R的函数称为**闭包**，以强调它们从创建它们的父环境中捕获变量，以强调它们捆绑的数据。
- en: 6.6 Function Scope in Python
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 Python中的函数作用域
- en: Python uses **lexical scoping** just like R. This means, in Python,
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用与R相同的**词法作用域**。这意味着，在Python中，
- en: functions can use *local* variables that are defined inside themselves,
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数可以使用定义在其内部的*局部*变量。
- en: functions have an order of preference for which variable to prefer in the case
    of a name clash, and
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数在名称冲突的情况下有一个优先级顺序来决定选择哪个变量，并且
- en: functions can sometimes use variables defined outside itself, but that ability
    depends on where the function and variable were *defined*, not where the function
    was *called*.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数有时可以使用自身外部定义的变量，但这种能力取决于函数和变量在哪里**定义**，而不是函数在哪里**调用**。
- en: 'Regarding characteristics (2) and (3), there is a famous acronym that describes
    the rules Python follows when finding and choosing variables: **LEGB**.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 关于特性（2）和（3），有一个著名的缩写词描述了Python在查找和选择变量时遵循的规则：**LEGB**。
- en: 'L: Local,'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'L: 局部，'
- en: 'E: Enclosing,'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'E: 封闭的，'
- en: 'G: Global, and'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'G: 全局，并且'
- en: 'B: Built-in.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'B: 内置的。'
- en: A Python function will search for a variable in these namespaces in this order.[^(12)](#fn12).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数将按照以下顺序在这些命名空间中搜索变量。[^(12)](#fn12)。
- en: “*Local*” refers to variables that are defined inside of the function’s block.
    The function below uses the local `a` over the global one.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: “*局部*”指的是在函数的代码块内部定义的变量。下面的函数使用局部变量`a`而不是全局变量。
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: “*Enclosing*” refers to variables that were defined in the enclosing namespace,
    but not the global namespace. These variables are sometimes called **free variables.**
    In the example below, there is no local `a` variable for `inner_func()`, but there
    is a global one, and one in the enclosing namespace. `inner_func()` chooses the
    one in the enclosing namespace. Moreover, `inner_func()` has its own copy of `a`
    to use, even after `a` was initially destroyed upon the completion of the call
    to `outer_func()`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: “*封装*”指的是在封装命名空间中定义的变量，而不是全局命名空间中的变量。这些变量有时被称为**自由变量**。在下面的例子中，`inner_func()`没有局部`a`变量，但有一个全局变量和一个封装命名空间中的变量。`inner_func()`选择了封装命名空间中的那个。此外，`inner_func()`还有一个自己的`a`副本来使用，即使`a`在`outer_func()`调用完成后最初被销毁。
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: “*Global*” scope contains variables defined in the module-level namespace. If
    the code in the below example was the entirety of your script, then `a` would
    be a global variable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: “*全局*”作用域包含在模块级命名空间中定义的变量。如果下面示例中的代码是整个脚本的全部，那么`a`将是一个全局变量。
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Just like in R, Python functions **cannot** necessarily find variables where
    the function was *called*. For example, here is some code that mimics the above
    R example. Both `a` and `b` are accessible from within `inner_func()`. That is
    due to LEGB.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在R中一样，Python函数**不一定**能找到函数被**调用**时的变量。例如，以下是一些模仿上述R示例的代码。`a`和`b`都可以在`inner_func()`内部访问。这是由于LEGB规则。
- en: 'However, if we start using `outer_func()` inside another function, *calling*
    it in another function, when it was *defined* somewhere else, well then it doesn’t
    have access to variables in the call site. You might be surprised at how the following
    code functions. Does this print the right string: `"this is the a I want to use
    now!"` No!'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们开始在另一个函数内部使用`outer_func()`，在另一个函数中**调用**它，而它是在别处**定义**的，那么它就无法访问调用点的变量。你可能会对以下代码的功能感到惊讶。这是否会打印出正确的字符串：“我现在想使用的a！”？不！
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you feel like you understand lexical scoping, great! You should be ready
    to take on chapter [15](/an-introduction-to-functional-programming#an-introduction-to-functional-programming),
    then. If not, keep playing around with examples. Without understanding the scoping
    rules R and Python share, writing your own functions will persistently feel more
    difficult than it really is.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得自己已经理解了词法作用域，那就太好了！那么你应该准备好去学习第[15](/an-introduction-to-functional-programming#an-introduction-to-functional-programming)章了。如果没有，那就继续玩转这些例子。如果不理解R和Python共享的作用域规则，编写你自己的函数将始终感觉比实际要困难得多。
- en: 6.7 Modifying a Function’s Arguments
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 修改函数的参数
- en: Can/should we modify a function’s argument? The flexibility to do this sounds
    empowering; however, not doing it is recommended because it makes programs easier
    to reason about.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否/应该修改函数的参数？这样做带来的灵活性听起来很有力量；然而，不这样做是推荐的，因为它使得程序更容易推理。
- en: 6.7.1 Passing By Value In R
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.1 R中的按值传递
- en: In R, it is *difficult* for a function to modify one of its argument.[^(13)](#fn13)
    Consider the following code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，函数修改其参数之一是**困难的**。[^(13)](#fn13)考虑以下代码。
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The function `f` has an argument called `arg`. When `f(a)` is performed, changes
    are made to a *copy* of `a`. When a function constructs a copy of all input variables
    inside its body, this is called **pass-by-value** semantics. This copy is a temporary
    intermediate value that only serves as a starting point for the function to produce
    a return value of `2`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`f`有一个名为`arg`的参数。当执行`f(a)`时，会修改`a`的一个**副本**。当函数在其体内构造所有输入变量的副本时，这被称为**按值传递**的语义。这个副本是一个临时中间值，它只为函数提供一个起点，以产生返回值`2`。
- en: '`arg` could have been called `a`, and the same behavior will take place. However,
    giving these two things different names is helpful to remind you and others that
    R copies its arguments.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`arg`原本可以被称为`a`，并且将发生相同的行为。然而，给这两者不同的名字有助于提醒你和他人R是复制其参数的。'
- en: It is still possible to modify `a`, but I don’t recommend doing this either.
    I will discuss this more in subsection [6.7](/functions#modifying-a-functions-arguments).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以修改`a`，但我也不推荐这样做。我将在子节[6.7](/functions#modifying-a-functions-arguments)中进一步讨论这个问题。
- en: 6.7.2 Passing By Assignment In Python
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.2 Python中的按赋值传递
- en: The story is more complicated in Python. Python functions have **pass-by-assignment**
    semantics. This is something that is very unique to Python. What this means is
    that your ability to modify the arguments of a function depends on
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，情况更为复杂。Python函数具有**按赋值传递**的语义。这是Python非常独特的地方。这意味着你修改函数参数的能力取决于
- en: what the type of the argument is, and
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 争论的类型是什么，以及
- en: what you’re trying to do to it.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你试图对其做什么。
- en: We will go throw some examples first, and then explain why this works the way
    it does. Here is some code that is analogous to the example above.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过一些例子，然后解释为什么它会以这种方式工作。这里有一些与上面例子相似的代码。
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, `a` is not modified. That is because `a` is an `int`. `int`s are
    **immutable** in Python, which means that their [value](https://docs.python.org/3/reference/datamodel.html#objects-values-and-types)
    cannot be changed after they are created, either inside or outside of the function’s
    scope. However, consider the case when `a` is a `list`, which is a **mutable**
    type. A mutable type is one that can have its value changed after its created.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`a` 没有被修改。这是因为 `a` 是一个 `int`。在 Python 中，`int` 是 **不可变** 的，这意味着一旦创建，其
    [值](https://docs.python.org/3/reference/datamodel.html#objects-values-and-types)
    就不能被更改，无论是在函数的作用域内还是外。然而，考虑 `a` 是一个 `list` 的情况，这是一个 **可变** 类型。可变类型是指在创建后可以更改其值的类型。
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case `a` *is* modified. Changing the value of the argument *inside*
    the function effects changes to that variable outside of the function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下 `a` *被修改了*。在函数内部更改参数的值会影响函数外部的那个变量。
- en: Ready to be confused? Here is a tricky third example. What happens if we take
    in a list, but try to do something else with it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 准备感到困惑了吗？这里有一个棘手的第三个例子。如果我们接受一个列表，但试图对它做其他的事情会发生什么。
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That time `a` did not permanently change in the global scope. Why does this
    happen? I thought `list`s were mutable!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 那次 `a` 在全局作用域中并没有永久改变。为什么会发生这种情况？我以为 `list` 是可变的！
- en: The reason behind all of this doesn’t even have anything to do with functions,
    per se. Rather, it has to do with how Python manages, [objects, values, and types](https://docs.python.org/3/reference/datamodel.html#objects-values-and-types).
    It also has to do with what happens during [assignment](https://docs.python.org/3/reference/executionmodel.html#naming-and-binding).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切背后的原因甚至与函数本身无关。相反，它与 Python 如何管理 [对象、值和类型](https://docs.python.org/3/reference/datamodel.html#objects-values-and-types)
    有关。它还与 [赋值](https://docs.python.org/3/reference/executionmodel.html#naming-and-binding)
    期间发生的事情有关。
- en: Let’s revisit the above code, but bring everything out of a function. Python
    is pass-by-assignment, so all we have to do is understand how assignment works.
    Starting with the immutable `int` example, we have the following.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视上面的代码，但将所有内容都从函数中提取出来。Python 是按赋值传递的，所以我们只需要理解赋值是如何工作的。从不可变的 `int` 示例开始，我们有以下内容。
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The [`id()`](https://docs.python.org/3/library/functions.html#id) function returns
    the **identity** of an object, which is kind of like its memory address. Identities
    of objects are unique and constant. If two variables, `a` and `b` say, have the
    same identity, `a is b` will evaluate to `True`. Otherwise, it will evaluate to
    `False`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`[`id()`](https://docs.python.org/3/library/functions.html#id) 函数返回对象的 **标识**，这有点像它的内存地址。对象的标识是唯一的且恒定的。如果两个变量，比如
    `a` 和 `b`，具有相同的标识，`a is b` 将评估为 `True`。否则，它将评估为 `False`。'
- en: In the first line, the *name* `a` is bound to the *object* `1`. In the second
    line, the name `arg` is bound to the *object* that is referred to by the *name*
    `a`. After the second line finishes, `arg` and `a` are two names for the same
    object (a fact that you can confirm by inserting `arg is a` immediately after
    this line).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，名称 `a` 被绑定到对象 `1`。在第二行，名称 `arg` 被绑定到由名称 `a` 所引用的对象。在第二行完成后，`arg` 和 `a`
    是同一对象的两个名称（你可以通过在此行后立即插入 `arg is a` 来确认这一事实）。
- en: In the third line, `arg` is bound to `2`. The variable `arg` can be changed,
    but only by re-binding it with a separate object. Re-binding `arg` does not change
    the value referred to by `a` because `a` still refers to `1`, an object separate
    from `2`. There is no reason to re-bind `a` because it wasn’t mentioned at all
    in the third line.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行，`arg` 被绑定到 `2`。变量 `arg` 可以被更改，但只能通过将其重新绑定到另一个对象。重新绑定 `arg` 不会更改 `a` 所引用的值，因为
    `a` 仍然引用 `1`，一个与 `2` 分离的对象。没有必要重新绑定 `a`，因为它在第三行根本就没有被提及。
- en: If we go back to the first function example, it’s basically the same idea. The
    only difference, however, is that `arg` is in its own scope. Let’s look at a simplified
    version of our second code chunk that uses a mutable list.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到第一个函数示例，基本上是同样的概念。然而，唯一的区别是 `arg` 在它自己的作用域中。让我们看看我们第二个代码块的一个简化版本，它使用了一个可变列表。
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, when we run `arg = a`, the name `arg` is bound to the same
    object that is bound to `a`. This much is the same. The only difference here,
    though, is that because lists are mutable, changing the first element of `arg`
    is done “in place”, and all variables can access the mutated object.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当我们运行 `arg = a` 时，名称 `arg` 绑定到与 `a` 绑定到同一个对象上。这一点是相同的。然而，这里唯一的区别是，由于列表是可变的，改变
    `arg` 的第一个元素是“就地”完成的，并且所有变量都可以访问被修改的对象。
- en: Why did the third example produce unexpected results? The difference is in the
    line `arg = [2]`. This rebinds the name `arg` to a different variable. `list`s
    are still mutable, but this has nothing to do with re-binding–re-binding a name
    works no matter what type of object you’re binding it to. In this case we are
    re-binding `arg` to a completely different list.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么第三个例子产生了意外的结果？区别在于这一行 `arg = [2]`。这会将名称 `arg` 绑定到不同的变量上。`list`s 仍然是可变的，但这与重新绑定无关——重新绑定名称无论绑定到什么类型的对象上都会生效。在这种情况下，我们正在将
    `arg` 重新绑定到一个完全不同的列表上。
- en: 6.8 Accessing and Modifying Captured Variables
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8 访问和修改捕获的变量
- en: In the last section, we were talking about variables that were passed in as
    function arguments. Here we are talking about variables that are **captured**.
    They are not passed in as variables, but they are still used inside a function.
    In general, even though it is possible to access and modify non-local captured
    variables in both languages, it is not a good idea.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了作为函数参数传递的变量。现在我们讨论的是**捕获**的变量。它们不是作为变量传递的，但它们仍然在函数内部使用。一般来说，尽管在两种语言中都可以访问和修改非局部捕获的变量，但这不是一个好主意。
- en: 6.8.1 Accessing Captured Variables in R
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.1 在 R 中访问捕获的变量
- en: As Hadley Wickham writes in [his book](https://adv-r.hadley.nz/functions#dynamic-lookup),
    “[l]exical scoping determines where, but not when to look for values.” R has **dynamic
    lookup**, meaning code inside a function will only try to access a referred-to
    variable when the function is *running*, not when it is defined.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如 Hadley Wickham 在他的书中[所写](https://adv-r.hadley.nz/functions#dynamic-lookup)，“词法作用域决定了在哪里查找值，但不是何时查找值。”
    R 有**动态查找**，这意味着函数内部的代码只有在函数**运行**时才会尝试访问引用的变量，而不是在定义时。
- en: Consider the R code below. The `dataReadyForModeling()` function is created
    in the global environment, and the global environment contains a Boolean variable
    called `dataAreClean`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下面的 R 代码。`dataReadyForModeling()` 函数是在全局环境中创建的，全局环境包含一个名为 `dataAreClean` 的布尔变量。
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now imagine sharing some code with a collaborator. Imagine, further, that your
    collaborator is the subject-matter expert, and knows little about R programming.
    Suppose that he changes `dataAreClean`, a global variable in the script, after
    he is done . Shouldn’t this induce a relatively trivial change to the overall
    program?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下与一个合作者共享一些代码。进一步想象，你的合作者是领域专家，对 R 编程了解不多。假设他在完成工作后更改了脚本中的全局变量 `dataAreClean`。这不应该导致对整体程序相对微小的改变吗？
- en: 'Let’s explore this hypothetical further. Consider what could happen if any
    of the following (very typical) conditions are true:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨这个假设。考虑以下（非常典型）的任何条件为真时可能发生的情况：
- en: you or your collaborators aren’t sure what `dataReadyForModeling()` will return
    because you don’t understand dynamic lookup, or
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你或你的合作者不确定 `dataReadyForModeling()` 会返回什么，因为你不理解动态查找，或者
- en: it’s difficult to visually keep track of all assignments to `dataAreClean` (e.g. your
    script is quite long or it changes often), or
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很难直观地跟踪所有对 `dataAreClean` 的赋值（例如，你的脚本相当长或者它经常变化），或者
- en: you are not running code sequentially (e.g. you are repeatedly testing chunks
    at a time instead of clearing out your memory and `source()`ing from scratch,
    over and over again).
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不是按顺序运行代码（例如，你一次又一次地测试代码块，而不是清除你的内存并从头开始 `source()`，一次又一次地）。
- en: In each of these situations, understanding of the program would be compromised.
    However, if you follow the above principle of never referring to non-local variables
    in function code, all members of the group could do their own work separately,
    minimizing the dependence on one another.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况中，对程序的理解将会受损。然而，如果你遵循上述原则，即函数代码中永远不要引用非局部变量，那么小组的每个成员都可以单独完成自己的工作，最小化相互之间的依赖。
- en: Another reason violating this could be troublesome is if you define a function
    that refers to a nonexistent variable. *Defining* the function will never throw
    an error because R will assume that variable is defined in the global environment.
    *Calling* the function might throw an error, unless you accidentally defined the
    variable, or if you forgot to delete a variable whose name you no longer want
    to use. Defining `myFunc()` with the code below will not throw an error, even
    if you think it should!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 违反这个规则可能造成麻烦的另一个原因是如果你定义了一个引用了不存在变量的函数。*定义*这个函数永远不会抛出错误，因为R会假设该变量定义在全局环境中。*调用*这个函数可能会抛出错误，除非你意外地定义了该变量，或者如果你忘记删除不再使用的变量。使用以下代码定义`myFunc()`不会抛出错误，即使你认为它应该会！
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 6.8.2 Accessing Captured Variables in Python
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.2 Python中访问捕获的变量
- en: It is the same exact situation in Python. Consider `everything_is_safe()`, a
    function that is analogous to `dataReadyForModeling()`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中也是同样的情况。考虑`everything_is_safe()`，一个与`dataReadyForModeling()`类似的功能。
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can also define `my_func()`, which is analogous to `myFunc()`. Defining this
    function doesn’t throw an error either.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义`my_func()`，它与`myFunc()`类似。定义这个函数也不会抛出错误。
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So stay away from referring to variables outside the body of your function!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以请远离在函数体外部引用变量！
- en: 6.8.3 Modifying Captured Variables In R
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.3 R中修改捕获的变量
- en: Now what if we want to be extra bad, and in addition to *accessing* global variables,
    we *modify* them, too?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要做得更过分一些，除了*访问*全局变量之外，还想*修改*它们呢？
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the program above, `makeATwo()` copies `a` into `arg`. It then assigns `2`
    to that copy. **Then it takes that `2` and writes it to the global `a` variable
    in the parent environment.** It does this using R’s super assignment operator
    `<<-`. Regardless of the inputs passed in to this function, it will always assign
    exactly `2` to `a`, no matter what.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的程序中，`makeATwo()`将`a`复制到`arg`中。然后它将`2`赋值给这个副本。**然后它将这个`2`写入父环境中的全局`a`变量。**它是通过使用R的超级赋值运算符`<<-`来做到这一点的。无论传递给这个函数的输入是什么，它都会将`2`精确地赋值给`a`，无论是什么。
- en: 'This is problematic because you are pre-occupying your mind with one function:
    `makeATwo()`. Whenever you write code that depends on `a` (or on things that depend
    on `a`, or on things that depended on things that depend on `a`, or …), you’ll
    have to repeatedly interrupt your train of thought to *try* and remember if what
    you’re doing is going to be okay with the current and future `makeATwo()` call
    sites.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有问题的，因为你正忙于关注一个函数：`makeATwo()`。每次你编写依赖于`a`（或依赖于`a`的东西，或依赖于依赖于`a`的东西，或……）的代码时，你将不得不反复打断你的思路来*尝试*记住你正在做的事情是否与当前的`makeATwo()`调用位置兼容。
- en: 6.8.4 Modifying Captured Variables In Python
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.4 Python中修改捕获的变量
- en: There is something in Python that is similar to R’s super assignment operator
    (`<<-`). It is the `global` keyword. This keyword will let you modify global variables
    from inside a function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有一个与R的超级赋值运算符（`<<-`）类似的东西。它是`global`关键字。这个关键字将允许你在函数内部修改全局变量。
- en: The upside to the `global` keyword is that it makes hunting for **side effects**
    relatively easy (A function’s side effects are changes it makes to non-local variables).
    Yes, this keyword should be used sparingly, even more sparingly than merely referring
    to global variables, but if you are ever debugging, and you want to hunt down
    places where variables are surprisingly being changed, you can hit `Ctrl-F` and
    search for the phrase “global.”
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`global`关键字的好处是它使得查找**副作用**相对容易（函数的副作用是指它对非局部变量所做的更改）。是的，这个关键字应该少用，甚至比仅仅引用全局变量还要少用，但如果你在调试时，想要追踪变量意外被更改的地方，你可以按`Ctrl-F`并搜索短语“global”。
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 6.9 Exercises
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9练习
- en: 6.9.1 R Questions
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.1 R问题
- en: Suppose you have a matrix \(\mathbf{X} \in \mathbb{R}^{n \times p}\) and a column
    vector \(\mathbf{y} \in \mathbb{R}^{n}\). To estimate the linear regression model
    \[\begin{equation} \mathbf{y} = \mathbf{X}\boldsymbol{\beta} + \epsilon, \end{equation}\]
    where \(\boldsymbol{\beta} \in \mathbb{R}^p\) is a column vector of errors, you
    can use calculus instead of numerical optimization. The formula for the least
    squares estimate of \(\boldsymbol{\beta}\) is \[\begin{equation} \hat{\boldsymbol{\beta}}
    = (\mathbf{X}^\intercal \mathbf{X})^{-1} \mathbf{X}^\intercal \mathbf{y}. \end{equation}\]
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个矩阵 \(\mathbf{X} \in \mathbb{R}^{n \times p}\) 和一个列向量 \(\mathbf{y} \in
    \mathbb{R}^{n}\)。为了估计线性回归模型 \[\begin{equation} \mathbf{y} = \mathbf{X}\boldsymbol{\beta}
    + \epsilon, \end{equation}\] 其中 \(\boldsymbol{\beta} \in \mathbb{R}^p\) 是一个误差的列向量，你可以使用微积分而不是数值优化。\(\boldsymbol{\beta}\)
    的最小二乘估计公式为 \[\begin{equation} \hat{\boldsymbol{\beta}} = (\mathbf{X}^\intercal
    \mathbf{X})^{-1} \mathbf{X}^\intercal \mathbf{y}. \end{equation}\]
- en: Once this \(p\)-dimensional vector is found, you can also obtain the *predicted
    (or fitted) values*
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到这个 \(p\)-维向量，你还可以获得 *预测（或拟合）值*
- en: \[\begin{equation} \hat{\mathbf{y}} := \mathbf{X}\hat{\boldsymbol{\beta}}, \end{equation}\]
    and the *residuals (or errors)*
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} \hat{\mathbf{y}} := \mathbf{X}\hat{\boldsymbol{\beta}}, \end{equation}\]
    以及 *残差（或误差）*
- en: \[\begin{equation} \mathbf{y} - \hat{\mathbf{y}} \end{equation}\]
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} \mathbf{y} - \hat{\mathbf{y}} \end{equation}\]
- en: 'Write a function called `getLinModEstimates()` that takes in two arguments
    in the following order:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为 `getLinModEstimates()` 的函数，该函数按以下顺序接受两个参数：
- en: the `vector` of response data \(\mathbf{y}\)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应数据 `vector` \(\mathbf{y}\)
- en: the `matrix` of predictors \(\mathbf{X}\).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测变量矩阵 \(\mathbf{X}\).
- en: 'Have it return a named `list` with three outputs inside:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让它返回一个包含三个输出的命名 `list`：
- en: the coefficient estimates as a `vector`,
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系数估计作为 `vector`，
- en: a `vector` of fitted values, and
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个拟合值 `vector`，以及
- en: a `vector` of residuals.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个残差 `vector`。
- en: The three elements of the returned list should have the names `coefficients`,
    `fitVals`, and `residuals`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 返回列表中的三个元素应具有名称 `coefficients`、`fitVals` 和 `residuals`。
- en: Write a function called `monteCarlo` that
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为 `monteCarlo` 的函数，
- en: takes as an input a function `sim(n)` that simulates `n` scalar variables,
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收一个名为 `sim(n)` 的函数作为输入，该函数模拟 `n` 个标量变量，
- en: takes as an input a function that evaluates \(f(x)\) on each random variable
    sample and that ideally takes in all of the random variables as a `vector`, and
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收一个函数作为输入，该函数在每个随机变量样本上评估 \(f(x)\)，并且理想情况下接受所有随机变量作为 `vector`，
- en: returns a function that takes one integer-valued argument (`num_sims`) and outputs
    a length one `vector`.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个函数，该函数接受一个整数值参数（`num_sims`）并输出一个长度为 `vector`。
- en: 'Assume `sim(n)` only has one argument: `n`, which is the number of simulations
    desired. `sim(n)`’s output should be a length `n` `vector`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `sim(n)` 只有一个参数：`n`，这是所需的模拟次数。`sim(n)` 的输出应是一个长度为 `n` 的 `vector`。
- en: 'The output of this returned function should be a Monte Carlo estimate of the
    expectation: \(\mathbb{E}[f(X)] \approx \frac{1}{n}\sum_{i=1}^n f(X^i)\).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此返回函数的输出应该是期望的蒙特卡洛估计：\(\mathbb{E}[f(X)] \approx \frac{1}{n}\sum_{i=1}^n f(X^i)\)。
- en: Write a function called `myDFT()` that computes the **Discrete Fourier Transform**
    of a `vector` and returns another `vector`. Feel free to check your work against
    `spec.pgram()`, `fft()`, or `astsa::mvspec()`, but do not include calls to those
    functions in your submission. Also, you should be aware that different functions
    transform and scale the answer differently, so be sure to read the documentation
    of any function you use to test against.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为 `myDFT()` 的函数，该函数计算 `vector` 的 **离散傅里叶变换** 并返回另一个 `vector`。您可以自由地检查您的结果与
    `spec.pgram()`、`fft()` 或 `astsa::mvspec()` 的结果，但不要在您的提交中包含对这些函数的调用。您还应该意识到，不同的函数以不同的方式转换和缩放答案，因此在使用任何函数进行测试之前，请务必阅读其文档。
- en: 'Given data \(x_1,x_2,\ldots,x_n\), \(i = \sqrt{-1}\), and the **Fourier/fundamental
    frequencies** \(\omega_j= j/n\) for \(j=0,1,\ldots,n-1\), we define the discrete
    Fourier transform (DFT) as:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 给定数据 \(x_1,x_2,\ldots,x_n\), \(i = \sqrt{-1}\), 以及 **傅里叶/基本频率** \(\omega_j=
    j/n\) 对于 \(j=0,1,\ldots,n-1\), 我们定义离散傅里叶变换（DFT）为：
- en: \[\begin{equation} \label{eq:DFT} d(\omega_j)= n^{-1/2} \sum_{t=1}^n x_t e^{-2
    \pi i \omega_j t} \end{equation}\]
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} \label{eq:DFT} d(\omega_j)= n^{-1/2} \sum_{t=1}^n x_t e^{-2
    \pi i \omega_j t} \end{equation}\]
- en: 6.9.2 Python Questions
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.2 Python 问题
- en: Estimating statistical models often involves some form of optimization, and
    often times, optimization is performed numerically. One of the most famous optimization
    algorithms is **Newton’s method**.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 估计统计模型通常涉及某种形式的优化，并且通常情况下，优化是数值执行的。最著名的优化算法之一是 **牛顿法**。
- en: 'Suppose you have a function \(f(x)\) that takes a scalar-valued input and returns
    a scalar as well. Also, suppose you have the function’s derivative \(f''(x)\),
    its second derivative \(f''''(x)\), and a starting point guess for what the minimizing
    input of \(f(x)\) is: \(x_0\).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个函数 \(f(x)\)，它接受一个标量值输入并返回一个标量。还假设你有函数的导数 \(f'(x)\)、二阶导数 \(f''(x)\)，以及
    \(f(x)\) 的最小化输入的起始点猜测：\(x_0\)。
- en: 'The algorithm repeatedly applies the following recursion:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 算法反复应用以下递归：
- en: \[\begin{equation} x_{n+1} = x_{n} - \frac{f'(x_n)}{f''(x_{n})}. \end{equation}\]
    Under appropriate regularity conditions for \(f\), after many iterations of the
    above recursion, when \(\tilde{n}\) is very large, \(x_{\tilde{n}}\) will be nearly
    the same as \(x_{\tilde{n}-1}\), and \(x_{\tilde{n}}\) is pretty close to \(\text{argmin}_x
    f(x)\). In other words, \(x_{\tilde{n}}\) is the minimizer of \(f\), and a root
    of \(f'\).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} x_{n+1} = x_{n} - \frac{f'(x_n)}{f''(x_{n})}. \end{equation}\]
    在 \(f\) 的适当正则性条件下，经过多次上述递归迭代后，当 \(\tilde{n}\) 非常大时，\(x_{\tilde{n}}\) 将几乎与 \(x_{\tilde{n}-1}\)
    相同，且 \(x_{\tilde{n}}\) 非常接近 \(\text{argmin}_x f(x)\)。换句话说，\(x_{\tilde{n}}\) 是
    \(f\) 的最小值，也是 \(f'\) 的根。
- en: Write a function called `f` that takes a `float` `x` and returns \((x-42)^2
    - 33\).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `f` 的函数，它接受一个 `float` 类型的 `x` 并返回 \((x-42)^2 - 33\)。
- en: Write a function called `f_prime` that takes a `float` and returns the derivative
    of the above.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `f_prime` 的函数，它接受一个 `float` 并返回上述函数的导数。
- en: Write a function called `f_dub_prime` that takes a `float` and returns an evaluation
    of the second derivative of \(f\).
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `f_dub_prime` 的函数，它接受一个 `float` 并返回 \(f\) 的二阶导数的评估。
- en: Theoretically, what is the minimizer of \(f\)? Assign your answer to the variable
    `best_x`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从理论上讲，\(f\) 的最小值是什么？将你的答案分配给变量 `best_x`。
- en: 'Write a function called `minimize()` that takes three arguments, and performs
    **ten iterations** of Newton’s algorithm, after which it returns \(x_{10}\). Don’t
    be afraid of copy/pasting ten or so lines of code. We haven’t learned loops yet,
    so that’s fine. The ordered arguments are:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `minimize()` 的函数，它接受三个参数，并在执行 **十次迭代** 的牛顿算法后返回 \(x_{10}\)。不要害怕复制粘贴大约十行代码。我们还没有学习循环，所以这没关系。有序参数如下：
- en: the function that evaluates the derivative of the function you’re interested
    in,
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估你感兴趣的函数导数的函数，
- en: the function that evaluates the second derivative of your objective function,
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估目标函数二阶导数的函数，
- en: an initial guess of the minimizer.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化器的初始猜测。
- en: Test your function by plugging in the above functions, and use a starting point
    of \(10\). Assign the output to a variable called `x_ten`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将上述函数插入测试，并使用起始点 \(10\) 来测试你的函数。将输出分配给名为 `x_ten` 的变量。
- en: Write a function called `smw_inverse(A,U,C,V)` that returns the inverse of a
    matrix using the **Sherman-Morrison-Woodbury formula** (Guttman [1946](#ref-woodbury)).
    Have it take the arguments \(A\), \(U\), \(C\), and \(V\) in that order and as
    Numpy `ndarray`s. Assume that `A` is a diagonal matrix.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为 `smw_inverse(A,U,C,V)` 的函数，该函数使用 **Sherman-Morrison-Woodbury 公式**（Guttman
    [1946](#ref-woodbury)）来求矩阵的逆。它按顺序接受参数 \(A\)、\(U\)、\(C\) 和 \(V\)，并且作为 Numpy `ndarray`s。假设
    `A` 是对角矩阵。
- en: \[\begin{equation} (A + UCV)^{-1} = A^{-1} - A^{-1}U(C^{-1} + VA^{-1}U)^{-1}V
    A^{-1} \end{equation}\] Despite being difficult to remember, this formula can
    be quite handy for speeding up matrix inversions when \(A\) and \(C\) are easier
    to invert (e.g. if \(A\) is diagonal and \(C\) is a scalar). The formula often
    shows up a lot in applications where you multiply matrices together (there are
    many such examples).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{equation} (A + UCV)^{-1} = A^{-1} - A^{-1}U(C^{-1} + VA^{-1}U)^{-1}V
    A^{-1} \end{equation}\] 尽管这个公式难以记忆，但当 \(A\) 和 \(C\) 更容易求逆时（例如，如果 \(A\) 是对角矩阵且
    \(C\) 是标量），它可以非常方便地加快矩阵求逆的速度。这个公式在矩阵相乘的应用中经常出现（有很多这样的例子）。
- en: To check your work, pick certain inputs, and make sure your formula corresponds
    with the naive, left-hand-side approach.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查你的工作，选择某些输入，并确保你的公式与直观的左侧方法相对应。
- en: References
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Guttman, Louis. 1946\. “Enlargement Methods for Computing the Inverse Matrix.”
    *The Annals of Mathematical Statistics* 17 (3): 336–43\. [https://doi.org/10.1214/aoms/1177730946](https://doi.org/10.1214/aoms/1177730946).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'Guttman, Louis. 1946\. “矩阵逆的计算扩展方法。” *《数学统计年刊》* 17 (3): 336–43\. [https://doi.org/10.1214/aoms/1177730946](https://doi.org/10.1214/aoms/1177730946).'
- en: '* * *'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Primitive functions are functions that contain no R code and are internally
    implemented in C. These are the only type of function in R that don’t have a parent
    environment.[↩](/functions#fnref10)
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始函数是不包含 R 代码的函数，它们在内部用 C 语言实现。这是 R 中唯一没有父环境的函数类型。[↩](/functions#fnref10)
- en: You might have noticed that Python uses two different words to prevent confusion.
    Unlike R, Python uses the word “parameter” (instead of “argument”) to refer to
    the inputs a function takes, and “arguments” to the specific values a user plugs
    in.[↩](/functions#fnref11)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能已经注意到，Python 使用两个不同的词来避免混淆。与 R 不同，Python 使用“参数”（而不是“参数”）一词来指代函数接受的输入，而“参数”则指用户插入的具体值。[↩](/functions#fnref11)
- en: Functions aren’t the only thing that get their own namespace. [Classes do, too](https://docs.python.org/3/tutorial/classes.html#a-first-look-at-classes).
    More information on classes is provided in Chapter [14](/an-introduction-to-object-oriented-programming#an-introduction-to-object-oriented-programming)[↩](/functions#fnref12)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数并不是唯一拥有自己的命名空间的事物。[类也是如此](https://docs.python.org/3/tutorial/classes.html#a-first-look-at-classes)。关于类的更多信息请参阅第
    [14](/an-introduction-to-object-oriented-programming#an-introduction-to-object-oriented-programming)
    章。[↩](/functions#fnref12)
- en: There are some exceptions to this, but it’s generally true.[↩](/functions#fnref13)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然有一些例外，但这通常是正确的。[↩](/functions#fnref13)
