- en: 17.1Â Introducing GraphsğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/intro-graphs.html](https://dcic-world.org/2025-08-27/intro-graphs.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Â Â Â Â [17.1.1Â Understanding Graphs](#%28part._.Understanding_.Graphs%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [17.1.2Â Representations](#%28part._.Representations%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [17.1.2.1Â Links by Name](#%28part._string-keys%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [17.1.2.2Â Links by Indices](#%28part._.Links_by_.Indices%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [17.1.2.3Â A List of Edges](#%28part._.A_.List_of_.Edges%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [17.1.2.4Â Abstracting Representations](#%28part._.Abstracting_.Representations%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [17.1.3Â Measuring Complexity for Graphs](#%28part._complexity-of-graphs%29)
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
- en: 'In [From Acyclicity to Cycles](Sharing_and_Equality.html#%28part._acyc-to-cyc%29)
    we introduced a special kind of sharing: when the data become cyclic, i.e., there
    exist values such that traversing other reachable values from them eventually
    gets you back to the value at which you began. Data that have this characteristic
    are called graphs.Technically, a cycle is not necessary to be a graph; a tree
    or a DAG is also regarded as a (degenerate) graph. In this section, however, we
    are interested in graphs that have the potential for cycles.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Lots of very important data are graphs. For instance, the people and connections
    in social media form a graph: the people are nodes or vertices and the connections
    (such as friendships) are links or edges. They form a graph because for many people,
    if you follow their friends and then the friends of their friends, you will eventually
    get back to the person you started with. (Most simply, this happens when two people
    are each othersâ€™ friends.) The Web, similarly is a graph: the nodes are pages
    and the edges are links between pages. The Internet is a graph: the nodes are
    machines and the edges are links between machines. A transportation network is
    a graph: e.g., cities are nodes and the edges are transportation links between
    them. And so on. Therefore, it is essential to understand graphs to represent
    and process a great deal of interesting real-world data.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Graphs are important and interesting for not only practical but also principled
    reasons. The property that a traversal can end up where it began means that traditional
    methods of processing will no longer work: if it blindly processes every node
    it visits, it could end up in an infinite loop. Therefore, we need better structural
    recipes for our programs. In addition, graphs have a very rich structure, which
    lends itself to several interesting computations over them. We will study both
    these aspects of graphs below.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 17.1.1Â Understanding Graphs[ğŸ”—](#(part._.Understanding_.Graphs) "Link to here")
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider again the binary trees we saw earlier [[Re-Examining Equality](Sharing_and_Equality.html#%28part._identical-eq%29)].
    Letâ€™s now try to distort the definition of a â€œtreeâ€ by creating ones with cycles,
    i.e., trees with nodes that point back to themselves (in the sense of `identical`).
    As we saw earlier [[From Acyclicity to Cycles](Sharing_and_Equality.html#%28part._acyc-to-cyc%29)],
    it is not completely straightforward to create such a structure, but what we saw
    earlier [[Streams From Functions](func-as-data.html#%28part._streams-from-funs%29)]
    can help us here, by letting us suspend the evaluation of the cyclic link. That
    is, we have to not only use `rec`, we must also use a function to delay evaluation.
    In turn, we have to update the annotations on the fields. Since these are not
    going to be â€œtreesâ€ any more, weâ€™ll use a name that is suggestive but not outright
    incorrect:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now letâ€™s try to construct some cyclic values. Here are a few examples:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now letâ€™s try to compute the size of a `BinT`. Hereâ€™s the obvious program:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: (Weâ€™ll see why we call it `sizeinf` in a moment.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens when we call `sizeinf(tr)`?
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It goes into an infinite loop: hence the `inf` in its name.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two very different meanings for â€œsizeâ€. One is, â€œHow many times can
    we traverse an edge?â€ The other is, â€œHow many distinct nodes were constructed
    as part of the data structure?â€ With trees, by definition, these two are the same.
    With a DAG the former exceeds the latter but only by a finite amount. With a general
    graph, the former can exceed the latter by an infinite amount. In the case of
    a datum like `tr`, we can in fact traverse edges an infinite number of times.
    But the total number of constructed nodes is only one! Letâ€™s write this as test
    cases in terms of a `size` function, to be defined:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Itâ€™s clear that we need to somehow remember what nodes we have visited previously:
    that is, we need a computation with â€œmemoryâ€. In principle this is easy: we just
    create an extra data structure that checks whether a node has already been counted.
    As long as we update this data structure correctly, we should be all set. Hereâ€™s
    an implementation.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The extra parameter, `seen`, is called an accumulator, because it â€œaccumulatesâ€
    the list of seen nodes.Note that this could just as well be a set; it doesnâ€™t
    have to be a list. The support function it needs checks whether a given node has
    already been seen:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How does this do? Well, `sizect(tr)` is indeed `1`, but `sizect(t1)` is `3`
    and `sizect(t2)` is `7`!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explain why these answers came out as they did.
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The fundamental problem is that weâ€™re not doing a very good job of remembering!
    Look at this pair of lines:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The nodes seen while traversing the left branch are effectively forgotten,
    because the only nodes we remember when traversing the right branch are those
    in `ns`: namely, the current node and those visited â€œhigher upâ€. As a result,
    any nodes that â€œcross sidesâ€ are counted twice.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The remedy for this, therefore, is to remember every node we visit. Then, when
    we have no more nodes to process, instead of returning only the size, we should
    return all the nodes visited until now. This ensures that nodes that have multiple
    paths to them are visited on only one path, not more than once. The logic for
    this is to return two values from each traversalâ€”<wbr>the size and all the visited
    nodesâ€”<wbr>and not just one.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Sure enough, this function satisfies the above tests.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 17.1.2Â Representations[ğŸ”—](#(part._.Representations) "Link to here")
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The representation weâ€™ve seen above for graphs is certainly a start towards
    creating cyclic data, but itâ€™s not very elegant. Itâ€™s both error-prone and inelegant
    to have to write `lam` everywhere, and remember to apply functions to `()` to
    obtain the actual values. Therefore, here we explore other representations of
    graphs that are more conventional and also much simpler to manipulate.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous ways to represent graphs, and the choice of representation
    depends on several factors:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the graph, and in particular, its density. We will discuss
    this further later [[Measuring Complexity for Graphs](#%28part._complexity-of-graphs%29)].
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The representation in which the data are provided by external sources. Sometimes
    it may be easier to simply adapt to their representation; in particular, in some
    cases there may not even be a choice.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The features provided by the programming language, which make some representations
    much harder to use than others.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In [[Several Variations on Sets](part_sets.html)], we explore the idea of having
    many different representations for one datatype. As we will see, this is very
    true of graphs as well. Therefore, it would be best if we could arrive at a common
    interface to process graphs, so that all later programs can be written in terms
    of this interface, without overly depending on the underlying representation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of representations, there are three main things we need:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: A way to construct graphs.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A way to identify (i.e., tell apart) nodes or vertices in a graph.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given a way to identify nodes, a way to get that nodeâ€™s neighbors in the graph.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any interface that satisfies these properties will suffice. For simplicity,
    we will focus on the second and third of these and not abstract over the process
    of constructing a graph.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Our running example will be a graph whose nodes are cities in the United States
    and edges are direct flight connections between them:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/149f40c8773898400ea9f6d76e084087.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 17.1.2.1Â Links by Name[ğŸ”—](#(part._string-keys) "Link to here")
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Hereâ€™s our first representation. We will assume that every node has a unique
    name (such a name, when used to look up information in a repository of data, is
    sometimes called a key). A node is then a key, some information about that node,
    and a list of keys that refer to other nodes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: (Here weâ€™re assuming our keys are strings.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Hereâ€™s a concrete instance of such a graph:The prefix `kn-` stands for â€œkeyed
    nodeâ€.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Given a key, hereâ€™s how we look up its neighbor:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Exercise
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convert the comment in the function into an invariant about the datum. Express
    this invariant as a refinement and add it to the declaration of graphs.
  id: totrans-64
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With this support, we can look up neighbors easily:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When it comes to testing, some tests are easy to write. Others, however, might
    require describing entire nodes, which can be unwieldy, so for the purpose of
    checking our implementation it suffices to examine just a part of the result:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 17.1.2.2Â Links by Indices[ğŸ”—](#(part._.Links_by_.Indices) "Link to here")
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In some languages, it is common to use numbers as names. This is especially
    useful when numbers can be used to get access to an element in a constant amount
    of time (in return for having a bound on the number of elements that can be accessed).
    Here, we use a listâ€”<wbr>which does not provide constant-time access to arbitrary
    elementsâ€”<wbr>to illustrate this concept. Most of this will look very similar
    to what we had before; weâ€™ll comment on a key difference at the end.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: First, the datatype:The prefix `ix-` stands for â€œindexedâ€.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our graph now looks like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'where weâ€™re assuming indices begin at `0`. To find a node:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can then find neighbors almost as before:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, our tests also look similar:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Something deeper is going on here. The keyed nodes have intrinsic keys: the
    key is part of the datum itself. Thus, given just a node, we can determine its
    key. In contrast, the indexed nodes represent extrinsic keys: the keys are determined
    outside the datum, and in particular by the position in some other data structure.
    Given a node and not the entire graph, we cannot know for what its key is. Even
    given the entire graph, we can only determine its key by using `identical`, which
    is a rather unsatisfactory approach to recovering fundamental information. This
    highlights a weakness of using extrinsically keyed representations of information.
    (In return, extrinsically keyed representations are easier to reassemble into
    new collections of data, because there is no danger of keys clashing: there are
    no intrinsic keys to clash.)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 17.1.2.3Â A List of Edges[ğŸ”—](#(part._.A_.List_of_.Edges) "Link to here")
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The representations we have seen until now have given priority to nodes, making
    edges simply a part of the information in a node. We could, instead, use a representation
    that makes edges primary, and nodes simply be the entities that lie at their ends:The
    prefix `le-` stands for â€œlist of edgesâ€.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, our flight network becomes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Observe that in this representation, nodes that are not connected to other nodes
    in the graph simply never show up! Youâ€™d therefore need an auxilliary data structure
    to keep track of all the nodes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the set of neighbors:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And to be sure:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: However, this representation makes it difficult to store complex information
    about a node without replicating it. Because nodes usually have rich information
    while the information about edges tends to be weaker, we often prefer node-centric
    representations. Of course, an alternative is to think of the node names as keys
    into some other data structure from which we can retrieve rich information about
    nodes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 17.1.2.4Â Abstracting Representations[ğŸ”—](#(part._.Abstracting_.Representations)
    "Link to here")
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We would like a general representation that lets us abstract over the specific
    implementations. We will assume that broadly we have available a notion of `Node`
    that has `content`, a notion of `Key`s (whether or not intrinsic), and a way to
    obtain the neighborsâ€”<wbr>a list of keysâ€”<wbr>given a key and a graph. This is
    sufficient for what follows. However, we still need to choose concrete keys to
    write examples and tests. For simplicity, weâ€™ll use string keys [[Links by Name](#%28part._string-keys%29)].
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 17.1.3Â Measuring Complexity for Graphs[ğŸ”—](#(part._complexity-of-graphs) "Link
    to here")
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we begin to define algorithms over graphs, we should consider how to
    measure the size of a graph. A graph has two components: its nodes and its edges.
    Some algorithms are going to focus on nodes (e.g., visiting each of them), while
    others will focus on edges, and some will care about both. So which do we use
    as the basis for counting operations: nodes or edges?'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'It would help if we can reduce these two measures to one. To see whether thatâ€™s
    possible, suppose a graph has \(k\) nodes. Then its number of edges has a wide
    range, with these two extremes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: No two nodes are connected. Then there are no edges at all.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every two nodes is connected. Then there are essentially as many edges as the
    number of pairs of nodes.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of nodes can thus be significantly less or even significantly more
    than the number of edges. Were this difference a matter of constants, we could
    have ignored it; but itâ€™s not. As a graph tends towards the former extreme, the
    ratio of nodes to edges approaches \(k\) (or even exceeds it, in the odd case
    where there are no edges, but this graph is not very interesting); as it tends
    towards the latter, it is the ratio of edges to nodes that approaches \(k^2\).
    In other words, neither measure subsumes the other by a constant independent of
    the graph.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when we want to speak of the complexity of algorithms over graphs,
    we have to consider the sizes of both the number of nodes and edges. In a connected
    graphA graph is connected if, from every node, we can traverse edges to get to
    every other node., however, there must be at least as many edges as nodes, which
    means the number of edges dominates the number of nodes. Since we are usually
    processing connected graphs, or connected parts of graphs one at a time, we can
    bound the number of nodes by the number of edges.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 17.1.1Â Understanding Graphs[ğŸ”—](#(part._.Understanding_.Graphs) "Link to here")
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider again the binary trees we saw earlier [[Re-Examining Equality](Sharing_and_Equality.html#%28part._identical-eq%29)].
    Letâ€™s now try to distort the definition of a â€œtreeâ€ by creating ones with cycles,
    i.e., trees with nodes that point back to themselves (in the sense of `identical`).
    As we saw earlier [[From Acyclicity to Cycles](Sharing_and_Equality.html#%28part._acyc-to-cyc%29)],
    it is not completely straightforward to create such a structure, but what we saw
    earlier [[Streams From Functions](func-as-data.html#%28part._streams-from-funs%29)]
    can help us here, by letting us suspend the evaluation of the cyclic link. That
    is, we have to not only use `rec`, we must also use a function to delay evaluation.
    In turn, we have to update the annotations on the fields. Since these are not
    going to be â€œtreesâ€ any more, weâ€™ll use a name that is suggestive but not outright
    incorrect:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now letâ€™s try to construct some cyclic values. Here are a few examples:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now letâ€™s try to compute the size of a `BinT`. Hereâ€™s the obvious program:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: (Weâ€™ll see why we call it `sizeinf` in a moment.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens when we call `sizeinf(tr)`?
  id: totrans-112
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It goes into an infinite loop: hence the `inf` in its name.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two very different meanings for â€œsizeâ€. One is, â€œHow many times can
    we traverse an edge?â€ The other is, â€œHow many distinct nodes were constructed
    as part of the data structure?â€ With trees, by definition, these two are the same.
    With a DAG the former exceeds the latter but only by a finite amount. With a general
    graph, the former can exceed the latter by an infinite amount. In the case of
    a datum like `tr`, we can in fact traverse edges an infinite number of times.
    But the total number of constructed nodes is only one! Letâ€™s write this as test
    cases in terms of a `size` function, to be defined:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Itâ€™s clear that we need to somehow remember what nodes we have visited previously:
    that is, we need a computation with â€œmemoryâ€. In principle this is easy: we just
    create an extra data structure that checks whether a node has already been counted.
    As long as we update this data structure correctly, we should be all set. Hereâ€™s
    an implementation.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The extra parameter, `seen`, is called an accumulator, because it â€œaccumulatesâ€
    the list of seen nodes.Note that this could just as well be a set; it doesnâ€™t
    have to be a list. The support function it needs checks whether a given node has
    already been seen:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How does this do? Well, `sizect(tr)` is indeed `1`, but `sizect(t1)` is `3`
    and `sizect(t2)` is `7`!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explain why these answers came out as they did.
  id: totrans-123
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The fundamental problem is that weâ€™re not doing a very good job of remembering!
    Look at this pair of lines:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The nodes seen while traversing the left branch are effectively forgotten,
    because the only nodes we remember when traversing the right branch are those
    in `ns`: namely, the current node and those visited â€œhigher upâ€. As a result,
    any nodes that â€œcross sidesâ€ are counted twice.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The remedy for this, therefore, is to remember every node we visit. Then, when
    we have no more nodes to process, instead of returning only the size, we should
    return all the nodes visited until now. This ensures that nodes that have multiple
    paths to them are visited on only one path, not more than once. The logic for
    this is to return two values from each traversalâ€”<wbr>the size and all the visited
    nodesâ€”<wbr>and not just one.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Sure enough, this function satisfies the above tests.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 17.1.2Â Representations[ğŸ”—](#(part._.Representations) "Link to here")
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The representation weâ€™ve seen above for graphs is certainly a start towards
    creating cyclic data, but itâ€™s not very elegant. Itâ€™s both error-prone and inelegant
    to have to write `lam` everywhere, and remember to apply functions to `()` to
    obtain the actual values. Therefore, here we explore other representations of
    graphs that are more conventional and also much simpler to manipulate.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous ways to represent graphs, and the choice of representation
    depends on several factors:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the graph, and in particular, its density. We will discuss
    this further later [[Measuring Complexity for Graphs](#%28part._complexity-of-graphs%29)].
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The representation in which the data are provided by external sources. Sometimes
    it may be easier to simply adapt to their representation; in particular, in some
    cases there may not even be a choice.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The features provided by the programming language, which make some representations
    much harder to use than others.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In [[Several Variations on Sets](part_sets.html)], we explore the idea of having
    many different representations for one datatype. As we will see, this is very
    true of graphs as well. Therefore, it would be best if we could arrive at a common
    interface to process graphs, so that all later programs can be written in terms
    of this interface, without overly depending on the underlying representation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of representations, there are three main things we need:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: A way to construct graphs.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A way to identify (i.e., tell apart) nodes or vertices in a graph.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given a way to identify nodes, a way to get that nodeâ€™s neighbors in the graph.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any interface that satisfies these properties will suffice. For simplicity,
    we will focus on the second and third of these and not abstract over the process
    of constructing a graph.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Our running example will be a graph whose nodes are cities in the United States
    and edges are direct flight connections between them:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/149f40c8773898400ea9f6d76e084087.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: 17.1.2.1Â Links by Name[ğŸ”—](#(part._string-keys) "Link to here")
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Hereâ€™s our first representation. We will assume that every node has a unique
    name (such a name, when used to look up information in a repository of data, is
    sometimes called a key). A node is then a key, some information about that node,
    and a list of keys that refer to other nodes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: (Here weâ€™re assuming our keys are strings.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Hereâ€™s a concrete instance of such a graph:The prefix `kn-` stands for â€œkeyed
    nodeâ€.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªæ­¤ç±»å›¾çš„å®ä¾‹ï¼šå‰ç¼€ `kn-` ä»£è¡¨â€œé”®èŠ‚ç‚¹â€ã€‚
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Given a key, hereâ€™s how we look up its neighbor:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªé”®ï¼Œè¿™æ˜¯æŸ¥æ‰¾å…¶é‚»å±…çš„æ–¹æ³•ï¼š
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Exercise
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convert the comment in the function into an invariant about the datum. Express
    this invariant as a refinement and add it to the declaration of graphs.
  id: totrans-154
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°†å‡½æ•°ä¸­çš„æ³¨é‡Šè½¬æ¢ä¸ºå…³äºæ•°æ®çš„ä¸å˜é‡ã€‚å°†è¿™ä¸ªä¸å˜é‡ä½œä¸ºç»†åŒ–å¹¶æ·»åŠ åˆ°å›¾çš„å£°æ˜ä¸­ã€‚
- en: 'With this support, we can look up neighbors easily:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰è¿™ä¸ªæ”¯æŒï¼Œæˆ‘ä»¬å¯ä»¥è½»æ¾åœ°æŸ¥æ‰¾é‚»å±…ï¼š
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When it comes to testing, some tests are easy to write. Others, however, might
    require describing entire nodes, which can be unwieldy, so for the purpose of
    checking our implementation it suffices to examine just a part of the result:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ¶‰åŠåˆ°æµ‹è¯•æ—¶ï¼Œæœ‰äº›æµ‹è¯•å¾ˆå®¹æ˜“ç¼–å†™ã€‚ç„¶è€Œï¼Œå…¶ä»–æµ‹è¯•å¯èƒ½éœ€è¦æè¿°æ•´ä¸ªèŠ‚ç‚¹ï¼Œè¿™å¯èƒ½å¾ˆéº»çƒ¦ï¼Œå› æ­¤ä¸ºäº†æ£€æŸ¥æˆ‘ä»¬çš„å®ç°ï¼Œåªéœ€æ£€æŸ¥ç»“æœçš„ä¸€éƒ¨åˆ†å°±è¶³å¤Ÿäº†ï¼š
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 17.1.2.2Â Links by Indices[ğŸ”—](#(part._.Links_by_.Indices) "Link to here")
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.1.2.2Â é€šè¿‡ç´¢å¼•çš„é“¾æ¥[ğŸ”—](#(part._.Links_by_.Indices) "é“¾æ¥è‡³æ­¤")
- en: In some languages, it is common to use numbers as names. This is especially
    useful when numbers can be used to get access to an element in a constant amount
    of time (in return for having a bound on the number of elements that can be accessed).
    Here, we use a listâ€”<wbr>which does not provide constant-time access to arbitrary
    elementsâ€”<wbr>to illustrate this concept. Most of this will look very similar
    to what we had before; weâ€™ll comment on a key difference at the end.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æŸäº›è¯­è¨€ä¸­ï¼Œä½¿ç”¨æ•°å­—ä½œä¸ºåç§°æ˜¯å¸¸è§çš„ã€‚å½“æ•°å­—å¯ä»¥ç”¨æ¥åœ¨å¸¸æ•°æ—¶é—´å†…è®¿é—®ä¸€ä¸ªå…ƒç´ æ—¶ï¼ˆä»¥é™åˆ¶å¯ä»¥è®¿é—®çš„å…ƒç´ æ•°é‡ä¸ºä»£ä»·ï¼‰ï¼Œè¿™ç‰¹åˆ«æœ‰ç”¨ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªåˆ—è¡¨â€”â€”<wbr>å®ƒä¸æä¾›å¯¹ä»»æ„å…ƒç´ çš„å¸¸æ•°æ—¶é—´è®¿é—®â€”â€”<wbr>æ¥å±•ç¤ºè¿™ä¸ªæ¦‚å¿µã€‚å¤§éƒ¨åˆ†å†…å®¹å°†ä¸æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„å†…å®¹éå¸¸ç›¸ä¼¼ï¼›æˆ‘ä»¬å°†åœ¨æœ€åè®¨è®ºä¸€ä¸ªå…³é”®å·®å¼‚ã€‚
- en: First, the datatype:The prefix `ix-` stands for â€œindexedâ€.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæ•°æ®ç±»å‹ï¼šå‰ç¼€ `ix-` ä»£è¡¨â€œç´¢å¼•â€ã€‚
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our graph now looks like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨çš„å›¾çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'where weâ€™re assuming indices begin at `0`. To find a node:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­æˆ‘ä»¬å‡è®¾ç´¢å¼•ä» `0` å¼€å§‹ã€‚è¦æ‰¾åˆ°ä¸€ä¸ªèŠ‚ç‚¹ï¼š
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can then find neighbors almost as before:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥åƒä»¥å‰ä¸€æ ·å‡ ä¹æ‰¾åˆ°é‚»å±…ï¼š
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, our tests also look similar:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬çš„æµ‹è¯•çœ‹èµ·æ¥ä¹Ÿå¾ˆç›¸ä¼¼ï¼š
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Something deeper is going on here. The keyed nodes have intrinsic keys: the
    key is part of the datum itself. Thus, given just a node, we can determine its
    key. In contrast, the indexed nodes represent extrinsic keys: the keys are determined
    outside the datum, and in particular by the position in some other data structure.
    Given a node and not the entire graph, we cannot know for what its key is. Even
    given the entire graph, we can only determine its key by using `identical`, which
    is a rather unsatisfactory approach to recovering fundamental information. This
    highlights a weakness of using extrinsically keyed representations of information.
    (In return, extrinsically keyed representations are easier to reassemble into
    new collections of data, because there is no danger of keys clashing: there are
    no intrinsic keys to clash.)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ­£åœ¨è¿›è¡Œä¸€äº›æ›´æ·±å…¥çš„äº‹æƒ…ã€‚é”®èŠ‚ç‚¹å…·æœ‰å†…åœ¨é”®ï¼šé”®æ˜¯æ•°æ®æœ¬èº«çš„ä¸€éƒ¨åˆ†ã€‚å› æ­¤ï¼Œç»™å®šä¸€ä¸ªèŠ‚ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šå…¶é”®ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œç´¢å¼•èŠ‚ç‚¹è¡¨ç¤ºå¤–éƒ¨çš„é”®ï¼šé”®æ˜¯åœ¨æ•°æ®å¤–éƒ¨ç¡®å®šçš„ï¼Œç‰¹åˆ«æ˜¯åœ¨æŸäº›å…¶ä»–æ•°æ®ç»“æ„çš„ä½ç½®ã€‚ç»™å®šä¸€ä¸ªèŠ‚ç‚¹è€Œä¸æ˜¯æ•´ä¸ªå›¾ï¼Œæˆ‘ä»¬æ— æ³•çŸ¥é“å…¶é”®æ˜¯ä»€ä¹ˆã€‚å³ä½¿ç»™å®šæ•´ä¸ªå›¾ï¼Œæˆ‘ä»¬ä¹Ÿåªèƒ½é€šè¿‡ä½¿ç”¨
    `identical` æ¥ç¡®å®šå…¶é”®ï¼Œè¿™æ˜¯ä¸€ä¸ªç›¸å½“ä¸ä»¤äººæ»¡æ„çš„æ–¹æ³•æ¥æ¢å¤åŸºæœ¬ä¿¡æ¯ã€‚è¿™çªå‡ºäº†ä½¿ç”¨ä¿¡æ¯çš„å¤–éƒ¨é”®è¡¨ç¤ºçš„å¼±ç‚¹ã€‚ï¼ˆä½œä¸ºå›æŠ¥ï¼Œå¤–éƒ¨é”®è¡¨ç¤ºæ›´å®¹æ˜“é‡æ–°ç»„è£…æˆæ–°çš„æ•°æ®é›†åˆï¼Œå› ä¸ºæ²¡æœ‰é”®å†²çªçš„å±é™©ï¼šæ²¡æœ‰å†…åœ¨é”®å¯ä»¥å†²çªã€‚ï¼‰
- en: 17.1.2.3Â A List of Edges[ğŸ”—](#(part._.A_.List_of_.Edges) "Link to here")
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.1.2.3Â è¾¹åˆ—è¡¨[ğŸ”—](#(part._.A_.List_of_.Edges) "é“¾æ¥è‡³æ­¤")
- en: The representations we have seen until now have given priority to nodes, making
    edges simply a part of the information in a node. We could, instead, use a representation
    that makes edges primary, and nodes simply be the entities that lie at their ends:The
    prefix `le-` stands for â€œlist of edgesâ€.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„è¡¨ç¤ºä¼˜å…ˆè€ƒè™‘äº†èŠ‚ç‚¹ï¼Œä½¿å¾—è¾¹åªæ˜¯èŠ‚ç‚¹ä¿¡æ¯çš„ä¸€éƒ¨åˆ†ã€‚ç›¸åï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªä½¿è¾¹æˆä¸ºä¸»è¦éƒ¨åˆ†çš„è¡¨ç¤ºï¼ŒèŠ‚ç‚¹åªæ˜¯ä½äºå…¶æœ«ç«¯çš„å®ä½“ï¼šå‰ç¼€ `le-`
    ä»£è¡¨â€œè¾¹åˆ—è¡¨â€ã€‚
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, our flight network becomes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬çš„èˆªç­ç½‘ç»œå˜æˆï¼š
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Observe that in this representation, nodes that are not connected to other nodes
    in the graph simply never show up! Youâ€™d therefore need an auxilliary data structure
    to keep track of all the nodes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿåˆ°åœ¨è¿™ä¸ªè¡¨ç¤ºä¸­ï¼Œæ²¡æœ‰è¿æ¥åˆ°å›¾ä¸­å…¶ä»–èŠ‚ç‚¹çš„èŠ‚ç‚¹æ ¹æœ¬ä¸ä¼šæ˜¾ç¤ºå‡ºæ¥ï¼å› æ­¤ï¼Œä½ éœ€è¦ä¸€ä¸ªè¾…åŠ©æ•°æ®ç»“æ„æ¥è·Ÿè¸ªæ‰€æœ‰èŠ‚ç‚¹ã€‚
- en: 'To obtain the set of neighbors:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: è¦è·å¾—é‚»å±…çš„é›†åˆï¼š
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And to be sure:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¶ä¸”ä¸ºäº†ç¡®ä¿ï¼š
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: However, this representation makes it difficult to store complex information
    about a node without replicating it. Because nodes usually have rich information
    while the information about edges tends to be weaker, we often prefer node-centric
    representations. Of course, an alternative is to think of the node names as keys
    into some other data structure from which we can retrieve rich information about
    nodes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 17.1.2.4Â Abstracting Representations[ğŸ”—](#(part._.Abstracting_.Representations)
    "Link to here")
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We would like a general representation that lets us abstract over the specific
    implementations. We will assume that broadly we have available a notion of `Node`
    that has `content`, a notion of `Key`s (whether or not intrinsic), and a way to
    obtain the neighborsâ€”<wbr>a list of keysâ€”<wbr>given a key and a graph. This is
    sufficient for what follows. However, we still need to choose concrete keys to
    write examples and tests. For simplicity, weâ€™ll use string keys [[Links by Name](#%28part._string-keys%29)].
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 17.1.2.1Â Links by Name[ğŸ”—](#(part._string-keys) "Link to here")
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Hereâ€™s our first representation. We will assume that every node has a unique
    name (such a name, when used to look up information in a repository of data, is
    sometimes called a key). A node is then a key, some information about that node,
    and a list of keys that refer to other nodes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: (Here weâ€™re assuming our keys are strings.)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Hereâ€™s a concrete instance of such a graph:The prefix `kn-` stands for â€œkeyed
    nodeâ€.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Given a key, hereâ€™s how we look up its neighbor:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Exercise
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convert the comment in the function into an invariant about the datum. Express
    this invariant as a refinement and add it to the declaration of graphs.
  id: totrans-195
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With this support, we can look up neighbors easily:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When it comes to testing, some tests are easy to write. Others, however, might
    require describing entire nodes, which can be unwieldy, so for the purpose of
    checking our implementation it suffices to examine just a part of the result:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 17.1.2.2Â Links by Indices[ğŸ”—](#(part._.Links_by_.Indices) "Link to here")
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In some languages, it is common to use numbers as names. This is especially
    useful when numbers can be used to get access to an element in a constant amount
    of time (in return for having a bound on the number of elements that can be accessed).
    Here, we use a listâ€”<wbr>which does not provide constant-time access to arbitrary
    elementsâ€”<wbr>to illustrate this concept. Most of this will look very similar
    to what we had before; weâ€™ll comment on a key difference at the end.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: First, the datatype:The prefix `ix-` stands for â€œindexedâ€.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Our graph now looks like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'where weâ€™re assuming indices begin at `0`. To find a node:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can then find neighbors almost as before:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, our tests also look similar:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Something deeper is going on here. The keyed nodes have intrinsic keys: the
    key is part of the datum itself. Thus, given just a node, we can determine its
    key. In contrast, the indexed nodes represent extrinsic keys: the keys are determined
    outside the datum, and in particular by the position in some other data structure.
    Given a node and not the entire graph, we cannot know for what its key is. Even
    given the entire graph, we can only determine its key by using `identical`, which
    is a rather unsatisfactory approach to recovering fundamental information. This
    highlights a weakness of using extrinsically keyed representations of information.
    (In return, extrinsically keyed representations are easier to reassemble into
    new collections of data, because there is no danger of keys clashing: there are
    no intrinsic keys to clash.)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ­£åœ¨è¿›è¡Œä¸€äº›æ›´æ·±å…¥çš„äº‹æƒ…ã€‚å¸¦é”®çš„èŠ‚ç‚¹å…·æœ‰å†…åœ¨é”®ï¼šé”®æ˜¯æ•°æ®æœ¬èº«çš„ä¸€éƒ¨åˆ†ã€‚å› æ­¤ï¼Œä»…ç»™å®šä¸€ä¸ªèŠ‚ç‚¹ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç¡®å®šå…¶é”®ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œç´¢å¼•èŠ‚ç‚¹ä»£è¡¨å¤–åœ¨é”®ï¼šé”®æ˜¯åœ¨æ•°æ®ä¹‹å¤–ç¡®å®šçš„ï¼Œç‰¹åˆ«æ˜¯åœ¨æŸäº›å…¶ä»–æ•°æ®ç»“æ„ä¸­çš„ä½ç½®ã€‚ç»™å®šä¸€ä¸ªèŠ‚ç‚¹è€Œä¸æ˜¯æ•´ä¸ªå›¾ï¼Œæˆ‘ä»¬æ— æ³•çŸ¥é“å…¶é”®çš„ç”¨é€”ã€‚å³ä½¿ç»™å®šæ•´ä¸ªå›¾ï¼Œæˆ‘ä»¬ä¹Ÿåªèƒ½é€šè¿‡ä½¿ç”¨`identical`æ¥ç¡®å®šå…¶é”®ï¼Œè¿™æ˜¯ä¸€ç§ç›¸å½“ä»¤äººä¸æ»¡æ„çš„æ–¹æ³•æ¥æ¢å¤åŸºæœ¬ä¿¡æ¯ã€‚è¿™çªå‡ºäº†ä½¿ç”¨å¤–åœ¨é”®è¡¨ç¤ºä¿¡æ¯çš„ä¸€ä¸ªå¼±ç‚¹ã€‚ï¼ˆä½œä¸ºå›æŠ¥ï¼Œå¤–åœ¨é”®è¡¨ç¤ºæ›´å®¹æ˜“é‡æ–°ç»„è£…æˆæ–°çš„æ•°æ®é›†åˆï¼Œå› ä¸ºæ²¡æœ‰é”®å†²çªçš„å±é™©ï¼šæ²¡æœ‰å†…åœ¨é”®å¯ä»¥å†²çªã€‚ï¼‰
- en: 17.1.2.3Â A List of Edges[ğŸ”—](#(part._.A_.List_of_.Edges) "Link to here")
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.1.2.3 è¾¹çš„åˆ—è¡¨[ğŸ”—](#(part._.A_.List_of_.Edges) "é“¾æ¥è‡³æ­¤")
- en: The representations we have seen until now have given priority to nodes, making
    edges simply a part of the information in a node. We could, instead, use a representation
    that makes edges primary, and nodes simply be the entities that lie at their ends:The
    prefix `le-` stands for â€œlist of edgesâ€.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åˆ°ç›®å‰ä¸ºæ­¢æ‰€çœ‹åˆ°çš„è¡¨ç¤ºä¼˜å…ˆè€ƒè™‘äº†èŠ‚ç‚¹ï¼Œä½¿å¾—è¾¹åªæ˜¯èŠ‚ç‚¹ä¿¡æ¯çš„ä¸€éƒ¨åˆ†ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸€ä¸ªä½¿è¾¹æˆä¸ºä¸»è¦çš„è¡¨ç¤ºï¼ŒèŠ‚ç‚¹åªæ˜¯ä½äºå…¶ç«¯ç‚¹çš„å®ä½“ï¼šå‰ç¼€`le-`ä»£è¡¨â€œè¾¹çš„åˆ—è¡¨â€ã€‚
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, our flight network becomes:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬çš„èˆªç­ç½‘ç»œå˜ä¸ºï¼š
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Observe that in this representation, nodes that are not connected to other nodes
    in the graph simply never show up! Youâ€™d therefore need an auxilliary data structure
    to keep track of all the nodes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨è¿™ä¸ªè¡¨ç¤ºä¸­ï¼Œä¸å›¾ä¸­å…¶ä»–èŠ‚ç‚¹ä¸ç›¸è¿çš„èŠ‚ç‚¹æ ¹æœ¬ä¸ä¼šå‡ºç°ï¼å› æ­¤ï¼Œä½ éœ€è¦ä¸€ä¸ªè¾…åŠ©æ•°æ®ç»“æ„æ¥è·Ÿè¸ªæ‰€æœ‰èŠ‚ç‚¹ã€‚
- en: 'To obtain the set of neighbors:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: è¦è·å¾—é‚»å±…é›†ï¼š
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And to be sure:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¶ä¸”ä¸ºäº†ç¡®ä¿ï¼š
- en: '[PRE57]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: However, this representation makes it difficult to store complex information
    about a node without replicating it. Because nodes usually have rich information
    while the information about edges tends to be weaker, we often prefer node-centric
    representations. Of course, an alternative is to think of the node names as keys
    into some other data structure from which we can retrieve rich information about
    nodes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¿™ç§è¡¨ç¤ºæ³•ä½¿å¾—åœ¨ä¸å¤åˆ¶çš„æƒ…å†µä¸‹å­˜å‚¨å…³äºèŠ‚ç‚¹çš„å¤æ‚ä¿¡æ¯å˜å¾—å›°éš¾ã€‚å› ä¸ºèŠ‚ç‚¹é€šå¸¸å…·æœ‰ä¸°å¯Œçš„ä¿¡æ¯ï¼Œè€Œè¾¹çš„ç›¸å…³ä¿¡æ¯å¾€å¾€è¾ƒå¼±ï¼Œæ‰€ä»¥æˆ‘ä»¬é€šå¸¸æ›´å–œæ¬¢ä»¥èŠ‚ç‚¹ä¸ºä¸­å¿ƒçš„è¡¨ç¤ºã€‚å½“ç„¶ï¼Œå¦ä¸€ç§æ–¹æ³•æ˜¯è®¤ä¸ºèŠ‚ç‚¹åç§°æ˜¯é€šå‘æŸäº›å…¶ä»–æ•°æ®ç»“æ„çš„é”®ï¼Œæˆ‘ä»¬å¯ä»¥ä»ä¸­æ£€ç´¢æœ‰å…³èŠ‚ç‚¹çš„ä¸°å¯Œä¿¡æ¯ã€‚
- en: 17.1.2.4Â Abstracting Representations[ğŸ”—](#(part._.Abstracting_.Representations)
    "Link to here")
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 17.1.2.4 æŠ½è±¡è¡¨ç¤º[ğŸ”—](#(part._.Abstracting_.Representations) "é“¾æ¥è‡³æ­¤")
- en: We would like a general representation that lets us abstract over the specific
    implementations. We will assume that broadly we have available a notion of `Node`
    that has `content`, a notion of `Key`s (whether or not intrinsic), and a way to
    obtain the neighborsâ€”<wbr>a list of keysâ€”<wbr>given a key and a graph. This is
    sufficient for what follows. However, we still need to choose concrete keys to
    write examples and tests. For simplicity, weâ€™ll use string keys [[Links by Name](#%28part._string-keys%29)].
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¸Œæœ›æœ‰ä¸€ä¸ªé€šç”¨çš„è¡¨ç¤ºï¼Œä½¿æˆ‘ä»¬èƒ½å¤ŸæŠ½è±¡å‡ºå…·ä½“çš„å®ç°ã€‚æˆ‘ä»¬å°†å‡è®¾æˆ‘ä»¬å¹¿æ³›åœ°æœ‰ä¸€ä¸ªå…·æœ‰`content`çš„`Node`æ¦‚å¿µï¼Œä¸€ä¸ª`Key`sï¼ˆæ˜¯å¦å†…åœ¨ï¼‰çš„æ¦‚å¿µï¼Œä»¥åŠç»™å®šä¸€ä¸ªé”®å’Œä¸€ä¸ªå›¾æ—¶è·å–é‚»å±…â€”â€”<wbr>é”®çš„åˆ—è¡¨â€”â€”<wbr>çš„æ–¹æ³•ã€‚è¿™å¯¹äºä»¥ä¸‹å†…å®¹æ˜¯è¶³å¤Ÿçš„ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ä»ç„¶éœ€è¦é€‰æ‹©å…·ä½“çš„é”®æ¥ç¼–å†™ç¤ºä¾‹å’Œæµ‹è¯•ã€‚ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨å­—ç¬¦ä¸²é”®
    [[é€šè¿‡åç§°é“¾æ¥](#%28part._string-keys%29)]ã€‚
- en: 17.1.3Â Measuring Complexity for Graphs[ğŸ”—](#(part._complexity-of-graphs) "Link
    to here")
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 17.1.3 ä¸ºå›¾æµ‹é‡å¤æ‚æ€§[ğŸ”—](#(part._complexity-of-graphs) "é“¾æ¥è‡³æ­¤")
- en: 'Before we begin to define algorithms over graphs, we should consider how to
    measure the size of a graph. A graph has two components: its nodes and its edges.
    Some algorithms are going to focus on nodes (e.g., visiting each of them), while
    others will focus on edges, and some will care about both. So which do we use
    as the basis for counting operations: nodes or edges?'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬å¼€å§‹å®šä¹‰å›¾ä¸Šçš„ç®—æ³•ä¹‹å‰ï¼Œæˆ‘ä»¬åº”è¯¥è€ƒè™‘å¦‚ä½•è¡¡é‡å›¾çš„å¤§å°ã€‚ä¸€ä¸ªå›¾æœ‰ä¸¤ä¸ªç»„æˆéƒ¨åˆ†ï¼šå®ƒçš„èŠ‚ç‚¹å’Œå®ƒçš„è¾¹ã€‚ä¸€äº›ç®—æ³•å°†ä¸“æ³¨äºèŠ‚ç‚¹ï¼ˆä¾‹å¦‚ï¼Œè®¿é—®æ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼‰ï¼Œè€Œå…¶ä»–ç®—æ³•å°†ä¸“æ³¨äºè¾¹ï¼Œè¿˜æœ‰ä¸€äº›å°†ä¸¤è€…éƒ½è€ƒè™‘åœ¨å†…ã€‚é‚£ä¹ˆï¼Œæˆ‘ä»¬ä»¥ä»€ä¹ˆä½œä¸ºè®¡æ•°æ“ä½œçš„åŸºç¡€ï¼šèŠ‚ç‚¹è¿˜æ˜¯è¾¹ï¼Ÿ
- en: 'It would help if we can reduce these two measures to one. To see whether thatâ€™s
    possible, suppose a graph has \(k\) nodes. Then its number of edges has a wide
    range, with these two extremes:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬å¯ä»¥å°†è¿™ä¸¤ä¸ªåº¦é‡ç®€åŒ–ä¸ºä¸€ä¸ªï¼Œé‚£å°±å¥½äº†ã€‚ä¸ºäº†çœ‹çœ‹è¿™æ˜¯å¦å¯èƒ½ï¼Œå‡è®¾ä¸€ä¸ªå›¾æœ‰ \(k\) ä¸ªèŠ‚ç‚¹ã€‚é‚£ä¹ˆå®ƒçš„è¾¹æ•°æœ‰ä¸€ä¸ªå¾ˆå¤§çš„èŒƒå›´ï¼Œè¿™ä¸¤ä¸ªæç«¯æ˜¯ï¼š
- en: No two nodes are connected. Then there are no edges at all.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ²¡æœ‰ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯è¿æ¥çš„ã€‚é‚£ä¹ˆæ ¹æœ¬å°±æ²¡æœ‰è¾¹ã€‚
- en: Every two nodes is connected. Then there are essentially as many edges as the
    number of pairs of nodes.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¯ä¸¤ä¸ªèŠ‚ç‚¹éƒ½ç›¸äº’è¿æ¥ã€‚é‚£ä¹ˆè¾¹çš„æ•°é‡å®é™…ä¸Šä¸èŠ‚ç‚¹å¯¹çš„æ•°é‡ç›¸åŒã€‚
- en: The number of nodes can thus be significantly less or even significantly more
    than the number of edges. Were this difference a matter of constants, we could
    have ignored it; but itâ€™s not. As a graph tends towards the former extreme, the
    ratio of nodes to edges approaches \(k\) (or even exceeds it, in the odd case
    where there are no edges, but this graph is not very interesting); as it tends
    towards the latter, it is the ratio of edges to nodes that approaches \(k^2\).
    In other words, neither measure subsumes the other by a constant independent of
    the graph.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼ŒèŠ‚ç‚¹çš„æ•°é‡å¯ä»¥æ˜¾è‘—å°‘äºç”šè‡³æ˜¾è‘—å¤šäºè¾¹çš„æ•°é‡ã€‚å¦‚æœè¿™ç§å·®å¼‚åªæ˜¯å¸¸æ•°çš„é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥å¿½ç•¥å®ƒï¼›ä½†äº‹å®å¹¶éå¦‚æ­¤ã€‚å½“å›¾è¶‹å‘äºå‰ä¸€ç§æç«¯æ—¶ï¼ŒèŠ‚ç‚¹ä¸è¾¹çš„æ¯”ç‡æ¥è¿‘
    \(k\)ï¼ˆç”šè‡³åœ¨æ²¡æœ‰è¾¹çš„å¥‡ç‰¹æƒ…å†µä¸‹ï¼Œè¾¹çš„æ•°é‡ç”šè‡³è¶…è¿‡ \(k\)ï¼Œä½†è¿™ç§å›¾å¹¶ä¸å¾ˆæœ‰è¶£ï¼‰ï¼›å½“å®ƒè¶‹å‘äºåä¸€ç§æç«¯æ—¶ï¼Œæ˜¯è¾¹ä¸èŠ‚ç‚¹çš„æ¯”ç‡æ¥è¿‘ \(k^2\)ã€‚æ¢å¥è¯è¯´ï¼Œè¿™ä¸¤ç§åº¦é‡éƒ½ä¸èƒ½é€šè¿‡ä¸€ä¸ªä¸å›¾æ— å…³çš„å¸¸æ•°æ¥åŒ…å«å¦ä¸€ç§åº¦é‡ã€‚
- en: Therefore, when we want to speak of the complexity of algorithms over graphs,
    we have to consider the sizes of both the number of nodes and edges. In a connected
    graphA graph is connected if, from every node, we can traverse edges to get to
    every other node., however, there must be at least as many edges as nodes, which
    means the number of edges dominates the number of nodes. Since we are usually
    processing connected graphs, or connected parts of graphs one at a time, we can
    bound the number of nodes by the number of edges.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œå½“æˆ‘ä»¬æƒ³è¦è®¨è®ºå›¾ä¸Šçš„ç®—æ³•å¤æ‚æ€§æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»è€ƒè™‘èŠ‚ç‚¹æ•°å’Œè¾¹æ•°çš„è§„æ¨¡ã€‚åœ¨ä¸€ä¸ªè¿é€šå›¾ä¸­ï¼ˆå¦‚æœä»æ¯ä¸ªèŠ‚ç‚¹å‡ºå‘ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è¾¹åˆ°è¾¾å›¾ä¸­çš„æ¯ä¸ªå…¶ä»–èŠ‚ç‚¹ï¼Œåˆ™ç§°è¯¥å›¾ä¸ºè¿é€šå›¾ï¼‰ï¼Œç„¶è€Œï¼Œè¾¹çš„æ•°é‡å¿…é¡»è‡³å°‘ä¸èŠ‚ç‚¹çš„æ•°é‡ä¸€æ ·å¤šï¼Œè¿™æ„å‘³ç€è¾¹çš„æ•°é‡å†³å®šäº†èŠ‚ç‚¹çš„æ•°é‡ã€‚ç”±äºæˆ‘ä»¬é€šå¸¸ä¸€æ¬¡å¤„ç†ä¸€ä¸ªè¿é€šå›¾æˆ–å›¾çš„è¿é€šéƒ¨åˆ†ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è¾¹çš„æ•°é‡æ¥é™åˆ¶èŠ‚ç‚¹çš„æ•°é‡ã€‚
