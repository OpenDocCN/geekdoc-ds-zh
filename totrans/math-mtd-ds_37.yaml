- en: '5.2\. Background: basic concepts in graph theory#'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://mmids-textbook.github.io/chap05_specgraph/02_graph/roch-mmids-specgraph-graph.html](https://mmids-textbook.github.io/chap05_specgraph/02_graph/roch-mmids-specgraph-graph.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this section, we cover the basics of graph theory. We also introduce the
    `NetworkX` package.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.1\. Undirected graphs[#](#undirected-graphs "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start with undirected graphs.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Undirected Graph)** \(\idx{graph}\xdi\) \(\idx{undirected
    graph}\xdi\) An undirected graph (or graph for short) is a pair \(G = (V,E)\)
    where \(V\) is the set of vertices (or nodes) and'
  prefs: []
  type: TYPE_NORMAL
- en: \[ E \subseteq \{\{u,v\}\,:\, u,v \in V,\ u \neq v\} \]
  prefs: []
  type: TYPE_NORMAL
- en: is the set of edges. \(\natural\)
  prefs: []
  type: TYPE_NORMAL
- en: Note that, unless otherwise stated, we typically do not allow self-loops, i.e.,
    edges that connect a vertex to itself.
  prefs: []
  type: TYPE_NORMAL
- en: '![Petersen graph (with help from Claude and ChatGPT)](../Images/bb1b1affc87320417edc1f5aca37b365.png)'
  prefs: []
  type: TYPE_IMG
- en: We occasionally write \(V(G)\) and \(E(G)\) for the vertices and edges of the
    graph \(G\). In our case, the set of vertices \(V\) is always finite.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Incidence and Adjacency)** A vertex \(v \in V\) is incident\(\idx{incident}\xdi\)
    with an edge \(e \in E\) if \(v \in e\). The incident vertices of an edge are
    called its endvertices. Two vertices \(u,v \in V\) are adjacent\(\idx{adjacent}\xdi\)
    (or neighbors), which we denote by \(u \sim v\), if \(\{u,v\} \in E\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Neighborhood and Degree)** The set of adjacent vertices of
    \(v\), denoted by \(N(v)\), is called the neighborhood\(\idx{neighborhood}\xdi\)
    of \(v\) and its size, i.e., \(\delta(v):=|N(v)|\), is the degree\(\idx{degree}\xdi\)
    of \(v\). A vertex \(v\) with \(\delta(v) = 0\) is called isolated\(\idx{isolated}\xdi\).
    A graph is called \(d\)-regular\(\idx{regular}\xdi\) if all its degrees are \(d\).
    \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: A well-known result, sometimes referred to as the [Handshaking Lemma](https://en.wikipedia.org/wiki/Handshaking_lemma)\(\idx{handshaking
    lemma}\xdi\), says that the sum of all degrees is twice the number of edges (prove
    it!).
  prefs: []
  type: TYPE_NORMAL
- en: '**EXAMPLE:** **(Petersen)** The Petersen graph is shown above. All its vertices
    have degree \(3\), that is, it is \(3\)-regular. In particular there is no isolated
    vertex. \(\lhd\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Path)** A path\(\idx{path}\xdi\) in \(G\) is a sequence of
    (not necessarily distinct) vertices \(x_0 \sim x_1 \sim \cdots \sim x_k\) with
    each consecutive pair being adjacent. The number of edges, \(k\), is called the
    length of the path. If the endvertices \(x_0\), \(x_k\) coincide, that is, \(x_0
    = x_k\), we call the path a cycle\(\idx{cycle}\xdi\). If the vertices are all
    distinct (except possibly for the endvertices), we say that the path (or cycle)
    is self-avoiding. The length of the shortest self-avoiding path connecting two
    distinct vertices \(u, v\) is called the graph distance\(\idx{graph distance}\xdi\)
    between \(u\) and \(v\), denoted by \(\rho(u,v)\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Connected)** We write \(u \leftrightarrow v\) if there is
    a path between \(u\) and \(v\). (By convention \(u \leftrightarrow u\).) A graph
    is connected if there is a path between any two of its vertices, that is, if \(u
    \leftrightarrow v\) for all \(u, v \in V\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**EXAMPLE:** **(Petersen, continued)** The Petersen graph is connected. \(\lhd\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**LEMMA** The relation \(\leftrightarrow\) is an [equivalence relation](https://en.wikipedia.org/wiki/Equivalence_relation),
    that is, \(u \leftrightarrow u\) for all \(u\) (reflexivity), \(u \leftrightarrow
    v\) if and only if \(v \leftrightarrow u\) (symmetry), and \(u \leftrightarrow
    v\) and \(v \leftrightarrow w\) implies \(u \leftrightarrow w\) (transitivity).
    \(\flat\)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Proof:* The first one is immediate from the definition. The second one is
    obtained by noting that we can reverse the path between \(u\) and \(v\) to construct
    a path between \(v\) and \(u\). The third one is obtained by noting that we can
    add a path between \(v\) and \(w\) to a path between \(u\) and \(v\) to construct
    a path between \(u\) and \(w\). \(\square\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Connected Components)** The [equivalence class](https://en.wikipedia.org/wiki/Equivalence_class)
    \(C[u] = \{v \in V\,:\, u \leftrightarrow v\}\), that is, the set of all vertices
    reachable from \(u\) through a path, is called a connected component\(\idx{connected
    component}\xdi\). A graph is connected if and only if it has only one connected
    component. \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: We show next that the (distinct) connected components form a partition of \(V\).
    It holds more generally for the equivalence classes of any equivalence relation.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEMMA** The following statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: a) \(u \leftrightarrow v\)
  prefs: []
  type: TYPE_NORMAL
- en: b) \(C[u] = C[v]\)
  prefs: []
  type: TYPE_NORMAL
- en: c) \(C[u] \cap C[v] \neq \emptyset\)
  prefs: []
  type: TYPE_NORMAL
- en: \(\flat\)
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence, either \(C[u] = C[v]\) or \(C[u] \cap C[v] = \emptyset\).
  prefs: []
  type: TYPE_NORMAL
- en: '*Proof:*'
  prefs: []
  type: TYPE_NORMAL
- en: 'a) \(\implies\) b): Let \(w \in C[u]\). So \(u \leftrightarrow w\). Symmetry
    and transitivity imply that \(v \leftrightarrow w\), which proves the claim.'
  prefs: []
  type: TYPE_NORMAL
- en: 'b) \(\implies\) c): Since \(u \in C[u]\) by reflexivity, we have \(\emptyset
    \neq C[u] = C[v] = C[u] \cap C[v]\).'
  prefs: []
  type: TYPE_NORMAL
- en: 'c) \(\implies\) a): Let \(w \in C[u] \cap C[v]\). Then \(u \leftrightarrow
    w\) and \(v \leftrightarrow w\). Symmetry and transitivity imply that \(u \leftrightarrow
    v\).'
  prefs: []
  type: TYPE_NORMAL
- en: \(\square\)
  prefs: []
  type: TYPE_NORMAL
- en: '![Connected components (with help from Claude; inspired by (Source))](../Images/2a49e5b611d0cb3744fbc9f044ea23ea.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Subgraphs and special graphs:* In network analysis, one is often interested
    in finding or counting interesting motifs or subgraphs within a much larger graph.
    We will not cover this important problem in network analysis much here, but see
    the *Exercises* section.'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Subgraph)** A subgraph\(\idx{subgraph}\xdi\) of \(G = (V,E)\)
    is a graph \(G'' = (V'',E'')\) with \(V'' \subseteq V\) and \(E'' \subseteq E\).
    Implicit in this definition is the fact that the edges in \(E''\) are incident
    only to \(V''\). The subgraph \(G''\) is said to be induced if'
  prefs: []
  type: TYPE_NORMAL
- en: \[ E' = \{\{x,y\}\,:\, x,y \in V',\ \{x,y\}\in E\}, \]
  prefs: []
  type: TYPE_NORMAL
- en: that is, if it contains exactly the edges of \(G\) between the vertices of \(V'\).
    In that case the notation \(G' := G[V']\) is used. \(\natural\)
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Spanning Subgraph)** A subgraph is said to be spanning\(\idx{spanning
    subgraph}\xdi\) if \(V'' = V\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Clique)** A subgraph containing all possible edges between
    its vertices is called a complete subgraph or clique\(\idx{clique}\xdi\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**EXAMPLE:** **(continued)** The Petersen graph contains no triangle (that
    is, complete subgraphs with \(3\) vertices), induced or not. \(\lhd\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Tree and forest)** A forest\(\idx{forest}\xdi\) is a graph
    with no self-avoiding cycle. A tree\(\idx{tree}\xdi\) is a connected forest. Vertices
    of degree \(1\) are called leaves. A spanning tree of \(G\) is a subgraph which
    is a tree and is also spanning. \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**NUMERICAL CORNER:** In Python, the [`NetworkX`](https://networkx.org) package
    provides many functionalities for defining, modifying and plotting graphs. For
    instance, many standard graphs can be defined conveniently. The [`networkx.petersen_graph`](https://networkx.org/documentation/stable/reference/generated/networkx.generators.small.petersen_graph.html)
    function defines the Petersen graph.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The graph can be plotted using the function [`networkx.draw_networkx`](https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx.html).
    Recall that in NumPy array indices start at \(0\). Consistently, NetworkX also
    names vertices starting at \(0\). Note, however, that this conflicts with our
    mathematical conventions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/b53a9db8d5538d64f42bd14671febcad7f9801f9c64feeb480cf242cab186e45.png](../Images/4434125a080ae08f69c60c5836805cf2.png)'
  prefs: []
  type: TYPE_IMG
- en: Other standard graphs can be generated with special functions, e.g. complete
    graphs using [`networkx.complete_graph`](https://networkx.org/documentation/stable/reference/generated/networkx.generators.classic.complete_graph.html#networkx.generators.classic.complete_graph).
    See [here](https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.classic)
    for a complete list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/a0ee95b038fed18e1bd3a19d39f2d8562dfdec2878e5499be0781d4ec4e98765.png](../Images/4951724a3717cf440027639708f0c5b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'See [here](https://networkx.org/documentation/stable/reference/functions.html)
    and [here](https://networkx.org/documentation/stable/reference/algorithms/index.html)
    for a list of functions to access various properties of a graph. Here are a few
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/4605ef8508b3a99c72677f416a1f6a860fe362bf231d2d54576c0e5561fa46bc.png](../Images/6f7735aad7868ed2feba3968e26cdcc4.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Another way of specifying a graph is to start with an empty graph with a given
    number of vertices and then add edges one by one. The following command creates
    a graph with \(4\) vertices and no edge (see [`networkx.empty_graph`](https://networkx.org/documentation/stable/reference/generated/networkx.generators.classic.empty_graph.html#networkx.generators.classic.empty_graph)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/a3dc8726731b499bf9695196650263cddae7d0f54b7777ab0f81cec8ffcd4605.png](../Images/9aaa661c7b224a4913156a9b27bf7d17.png)'
  prefs: []
  type: TYPE_IMG
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.2\. Directed graphs[#](#directed-graphs "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will also need directed graphs.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Directed Graph)** A directed graph\(\idx{directed graph}\xdi\)
    (or digraph for short) is a pair \(G = (V,E)\) where \(V\) is a set of vertices
    (or nodes) and'
  prefs: []
  type: TYPE_NORMAL
- en: \[ E \subseteq V^2 = \{(u,v)\,:\, u,v \in V\} \]
  prefs: []
  type: TYPE_NORMAL
- en: is a set of directed edges (or arcs). \(\natural\)
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in the directed case, we explicitly allow self-loops\(\idx{self-loop}\xdi\),
    i.e., edges of the form \((u,u)\) that connect a vertex to itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, unlike the undirected case, in a digraph the edges are ordered pairs
    – which is taken to mean that they have an orientation. If \(e = (i,j) \in E\)
    is an edge in a digraph \(G = (V,E)\), then \(i\) is called the source of \(e\)
    and \(j\) is the destination.
  prefs: []
  type: TYPE_NORMAL
- en: '![A directed graph (with help from Claude; inspired by (Source)](../Images/4bfde8866fba5b421fe07eb19bd03caa.png)'
  prefs: []
  type: TYPE_IMG
- en: The definitions discussed in the undirected case can be adapted to the directed
    case.
  prefs: []
  type: TYPE_NORMAL
- en: In the directed case, one distinguishes between the out-degree and the in-degree.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Out-degree and in-degree)** Let \(G = (V,E)\) be a digraph.
    The out-degree\(\idx{out-degree}\xdi\) of \(v \in V\), denoted by \(\delta^+(v)\),
    is the number of edges with source \(v\). The in-degree\(\idx{in-degree}\xdi\)
    of \(v\), denoted by \(\delta^-(v)\), is the number of edges with destination
    \(v\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: Paths and connectivity are also generalized naturally.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Directed Path)** A directed path\(\idx{directed path}\xdi\)
    is a sequence of vertices \(x_0, \ldots, x_k\) with \((x_{i-1},x_i) \in E\) for
    all \(i=1,\ldots,k\). We write \(u \to v\) if there is such a path with \(x_0
    = u\) and \(x_k = v\). If the endvertices \(x_0\), \(x_k\) coincide, that is,
    \(x_0 = x_k\), we call it a directed cycle\(\idx{directed cycle}\xdi\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Communication)** We say that \(u,v \in V\) communicate\(\idx{communicate}\xdi\),
    which we denote by \(u \leftrightarrow v\), if \(u \to v\) and \(v \to u\). The
    \(\leftrightarrow\) relation is again an equivalence relation. The equivalence
    classes of \(\leftrightarrow\) are called the strongly connected components of
    \(G\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Strongly Connected)** A digraph is strongly connected\(\idx{strongly
    connected}\xdi\) if any two of its vertices communicate, that is, if \(u \leftrightarrow
    v\) for all \(u, v \in V\). Or put differently, if there is only one strongly
    connected component\(\idx{strongly connected component}\xdi\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Directed Acyclic Graph)** A digraph is said to be a directed
    acyclic graph (DAG)\(\idx{directed acyclic graph}\xdi\) if it contains no directed
    cycle. \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**NUMERICAL CORNER:** The package `NetworkX` also supports digraphs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/76496f7965b537752105f87147188bd9a867acc87bfe4a3bb470fa702f7f8318.png](../Images/7e89c31acd337f7f5cf9d59692d3384e.png)'
  prefs: []
  type: TYPE_IMG
- en: Another way of specifying a digraph is to start with an empty graph with a given
    number of vertices and then add edges one by one (compare to the undirected case
    above).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/a6d3376c0f4544e54bd68776231c1245e7c427e45f332216b1264ff1c72601fb.png](../Images/f441f64d7ae78b107fc30916e169944b.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that edges in both directions are depicted here with a double-arrow. Also
    the self-loop is often awkwardly drawn. We can use [`networkx.draw_networkx_edges`](https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx_edges.html#networkx.drawing.nx_pylab.draw_networkx_edges)
    (together with [`networkx.draw_networkx_nodes`](https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx_nodes.html#networkx.drawing.nx_pylab.draw_networkx_nodes)
    and [`networkx.draw_networkx_labels`](https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx_labels.html#networkx.drawing.nx_pylab.draw_networkx_labels))
    to have more control over the drawing of the edges.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/967e543bbc3ca52cb02fc4d243fa5c68225aeebf075a3a99dc0292a20e89d648.png](../Images/453a50cc0a38fab0c952936c0df69d32.png)'
  prefs: []
  type: TYPE_IMG
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.3\. Matrix representations of graphs[#](#matrix-representations-of-graphs
    "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A convenient and useful way of specifying a graph is through a matrix representation.
    There are many such representations.
  prefs: []
  type: TYPE_NORMAL
- en: We start with the adjacency matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Adjacency Matrix)** Assume the (undirected) graph \(G = (V,E)\)
    has \(n = |V|\) vertices numbered \(1,\ldots,n\). The adjacency matrix\(\idx{adjacency
    matrix}\xdi\) \(A\) of \(G\) is the \(n\times n\) symmetric matrix defined as'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{align*} A_{xy} = \begin{cases} 1 & \text{if $\{x,y\} \in E$}\\ 0 &
    \text{o.w.} \end{cases} \end{align*}\]
  prefs: []
  type: TYPE_NORMAL
- en: \(\natural\)
  prefs: []
  type: TYPE_NORMAL
- en: '**EXAMPLE:** The adjancency matrix of the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with four edges (with help form Claude; inspired by (Source))](../Images/640c523edb11f10372db2c89d5d5d801.png)'
  prefs: []
  type: TYPE_IMG
- en: is
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split} A= \begin{pmatrix} 0 & 1 & 1 & 1\\ 1 & 0 & 0 & 0\\ 1 & 0 & 0
    & 1\\ 1 & 0 & 1 & 0 \end{pmatrix}. \end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is indeed symmetric. \(\lhd\)
  prefs: []
  type: TYPE_NORMAL
- en: Another useful matrix associated to a graph is its incidence matrix. For convenience,
    we assume again that the vertices of \(G = (V,E)\) are numbered \(1, \ldots, n\),
    where \(n\) is the number of vertices. We assume further that the edges are labeled
    \(e_1, \ldots, e_{m}\), where \(m\) is the number of edges.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Incidence Matrix)** The incidence matrix\(\idx{incidence
    matrix}\xdi\) of an undirected graph \(G = (V, E)\) is the \(n \times m\) matrix
    \(B\), where \(n = |V|\) and \(m =|E|\) are the numbers of vertices and edges
    respectively, such that \(B_{ij} = 1\) if the vertex \(i\) and edge \(e_j\) are
    incident and 0 otherwise. \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**EXAMPLE:** **(continued)** The incidence matrix of the graph from the previous
    example is given by'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split} B = \begin{pmatrix} 1 & 1 & 1 & 0\\ 1 & 0 & 0 & 0\\ 0 & 1 &
    0 & 1\\ 0 & 0 & 1 & 1 \end{pmatrix}. \end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: This matrix is not symmetric. In fact, in general, it is not even square. \(\lhd\)
  prefs: []
  type: TYPE_NORMAL
- en: '**NUMERICAL CORNER:** Using NetworkX, the adjacency matrix of a graph can be
    obtained with [`networkx.adjacency_matrix`](https://networkx.org/documentation/stable/reference/generated/networkx.linalg.graphmatrix.adjacency_matrix.html).
    By default, it returns a SciPy sparse matrix. Alternatively, one can get a regular
    array with [`toarray`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.toarray.html).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The incidence matrix is obtained with [`networkx.incidence_matrix`](https://networkx.org/documentation/stable/reference/generated/networkx.linalg.graphmatrix.incidence_matrix.html)
    – again as a sparse array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: In the digraph case, the definitions are adapted as follows. The adjacency matrix\(\idx{adjacency
    matrix}\xdi\) \(A\) of a digraph \(G = (V, E)\) is the matrix defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{align*} A_{xy} = \begin{cases} 1 & \text{if $(x,y) \in E$}\\ 0 & \text{o.w.}
    \end{cases} \end{align*}\]
  prefs: []
  type: TYPE_NORMAL
- en: The incidence matrix\(\idx{incidence matrix}\xdi\) of a digraph \(G\) with vertices
    \(1,\ldots,n\) and edges \(e_1, \ldots, e_m\) is the matrix \(B\) such that \(B_{ij}
    = -1\) if egde \(e_j\) leaves vertex \(i\), \(B_{ij} = 1\) if egde \(e_j\) enters
    vertex \(i\), and 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to undirected graphs, an orientation of an (undirected) graph \(G
    = (V, E)\) is a choice of direction for each of its edges, turning it into a digraph.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Oriented Incidence Matrix)** An oriented incidence matrix\(\idx{oriented
    incidence matrix}\xdi\) of an undirected graph \(G = (V, E)\) is the incidence
    matrix of an orientation of \(G\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '![An orientation of the Petersen graph (with help from ChatGPT and Claude)](../Images/f5685424aea999de21af27623ec5db76.png)'
  prefs: []
  type: TYPE_IMG
- en: '**NUMERICAL CORNER:** We revisit an earlier directed graph.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We compute the adjacency and incidence matrices. For the incidence matrix, one
    must specify `oriented=True` for the oriented version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Revisiting an ealier undirected graph, we note that `incidence_matrix()` can
    also produce an arbitrary oriented incidence matrix by using the `oriented=True`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.4\. Laplacian matrix[#](#laplacian-matrix "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A main matrix of interest for us will be the Laplacian matrix. It is a graph
    analogue of the [Laplace-Beltrami operator](https://en.wikipedia.org/wiki/Laplace%E2%80%93Beltrami_operator)
    in differential geometry. We will show in particular that it contains useful information
    about the connectedness of the graph and we will describe an application to graph
    partitioning in a later section. But first some theory.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that, given a graph \(G = (V, E)\), the quantity \(\delta(v)\) denotes
    the degree of \(v \in V\).
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Degree Matrix)** Let \(G = (V,E)\) be a graph with vertices
    \(V = \{1, \ldots, n\}\). The degree matrix\(\idx{degree matrix}\xdi\) is the
    diagonal matrix with the degrees on the diagonal, i.e., \(D = \mathrm{diag}(\delta(1),
    \ldots, \delta(n))\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: The key definition is the following.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Laplacian Matrix)** Let \(G = (V,E)\) be a graph with vertices
    \(V = \{1, \ldots, n\}\) adjacency matrix \(A \in \mathbb{R}^{n \times n}\) and
    degree matrix \(D = \mathrm{diag}(\delta(1), \ldots, \delta(n))\). The Laplacian
    matrix\(\idx{Laplacian matrix}\xdi\) associated to \(G\) is defined as \(L = D
    - A\). Its entries are'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split} l_{ij} = \begin{cases} \delta(i) & \text{if $i = j$}\\ -1 &
    \text{if $\{i,j\} \in E$}\\ 0 & \text{o.w.} \end{cases} \end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: \(\natural\)
  prefs: []
  type: TYPE_NORMAL
- en: Like the adjacency matrix, the Laplacian matrix is symmetric. Unlike the adjacency
    matrix, however, it is also positive semidefinite.
  prefs: []
  type: TYPE_NORMAL
- en: '**THEOREM** **(Properties of the Laplacian)** \(\idx{properties of the Laplacian
    theorem}\xdi\) For any graph \(G\), the Laplacian matrix is symmetric and positive
    semidefinite. \(\sharp\)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Proof:* Observe that the Laplacian matrix \(L\) of a graph \(G\) is indeed
    symmetric:'
  prefs: []
  type: TYPE_NORMAL
- en: \[ L^T = (D- A)^T = D^T - A^T = D - A \]
  prefs: []
  type: TYPE_NORMAL
- en: where we used that both \(D\) and \(A\) are themselves symmetric.
  prefs: []
  type: TYPE_NORMAL
- en: To prove the second claim, we need a lemma.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEMMA** **(Laplacian and Incidence)** \(\idx{Laplacian and incidence lemma}\xdi\)
    Let \(L\) be the Laplacian matrix of a graph \(G\). Let \(B\) be any oriented
    incidence matrix of \(G\). Then'
  prefs: []
  type: TYPE_NORMAL
- en: \[ L = B B^T. \]
  prefs: []
  type: TYPE_NORMAL
- en: \(\flat\)
  prefs: []
  type: TYPE_NORMAL
- en: '*Proof idea:* We just check the claim entry by entry.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Proof:* Enumerate the edges \(e_1,\ldots,e_m\). Let \(b_{ik}\) be entry \((i,k)\)
    of \(B\). For \(i \neq j\), entry \((i,j)\) of \(B B^T\)'
  prefs: []
  type: TYPE_NORMAL
- en: \[ (B B^T)_{ij} = \sum_{k=1}^m b_{ik} b_{jk}. \]
  prefs: []
  type: TYPE_NORMAL
- en: Note that \(b_{ik} b_{jk}\) is equal to (a) \(0\) if \(i\) or \(j\) (or both)
    are not incident with \(e_k\) or (b) \(-1\) if both \(i\) and \(j\) are incident
    with \(e_k\) (since one of \(i\) or \(j\) has a \(1\) in the column of \(B\) corresponding
    to \(e_k\) and the other one has a \(-1\)). So \((B B^T)_{ij} = -1\) when \(\{i,j\}
    \in E\) and is otherwise \(0\). So it coincides with the corresponding entry of
    the Laplacian matrix there.
  prefs: []
  type: TYPE_NORMAL
- en: For \(i = j\),
  prefs: []
  type: TYPE_NORMAL
- en: '\[ (B B^T)_{ii} = \sum_{k=1}^m b_{ik}^2 = \sum_{e = \{x, y\} \in E: i \in e}
    b_{xy}^2 = \sum_{e = \{x, y\} \in E: i \in e} 1 = \delta(i), \]'
  prefs: []
  type: TYPE_NORMAL
- en: where we used that \(b_{xy}^2 = 1\) because \(b_{xy} \in \{-1,1\}\) when \(\{x,y\}
    \in E\). Again it coincides with the corresponding entry of the Laplacian matrix.
    \(\square\)
  prefs: []
  type: TYPE_NORMAL
- en: We return to the proof of the theorem. By the previous lemma, for any \(\mathbf{x}
    \in \mathbb{R}^n\),
  prefs: []
  type: TYPE_NORMAL
- en: \[ \mathbf{x}^T L \mathbf{x} = \mathbf{x}^T B B^T \mathbf{x} = \|B^T \mathbf{x}\|^2
    \geq 0. \]
  prefs: []
  type: TYPE_NORMAL
- en: That proves positive semidefiniteness. \(\square\)
  prefs: []
  type: TYPE_NORMAL
- en: '***Self-assessment quiz*** *(with help from Claude, Gemini, and ChatGPT)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**1** Which of the following is NOT a valid definition of an undirected graph?'
  prefs: []
  type: TYPE_NORMAL
- en: a) A pair \(G = (V, E)\), where \(V\) is the set of vertices and \(E\) is a
    set of unordered pairs of vertices.
  prefs: []
  type: TYPE_NORMAL
- en: b) A collection of nodes connected by edges, where the edges have no direction.
  prefs: []
  type: TYPE_NORMAL
- en: c) A pair \(G = (V, E)\), where \(V\) is the set of vertices and \(E\) is a
    set of ordered pairs of vertices.
  prefs: []
  type: TYPE_NORMAL
- en: d) A mathematical structure used to model pairwise relations between objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**2** In a graph, what does the equivalence relation \(\leftrightarrow\) signify?'
  prefs: []
  type: TYPE_NORMAL
- en: a) Two vertices are in the same connected component.
  prefs: []
  type: TYPE_NORMAL
- en: b) Two vertices have the same degree.
  prefs: []
  type: TYPE_NORMAL
- en: c) Two vertices are adjacent.
  prefs: []
  type: TYPE_NORMAL
- en: d) Two vertices are part of a cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '**3** In a directed graph, what is the relationship between the in-degree and
    out-degree of a vertex?'
  prefs: []
  type: TYPE_NORMAL
- en: a) The in-degree is always greater than or equal to the out-degree.
  prefs: []
  type: TYPE_NORMAL
- en: b) The out-degree is always greater than or equal to the in-degree.
  prefs: []
  type: TYPE_NORMAL
- en: c) The in-degree and out-degree are always equal.
  prefs: []
  type: TYPE_NORMAL
- en: d) There is no fixed relationship between the in-degree and out-degree.
  prefs: []
  type: TYPE_NORMAL
- en: '**4** Which of the following is NOT a property of the Laplacian matrix of a
    graph?'
  prefs: []
  type: TYPE_NORMAL
- en: a) It is symmetric
  prefs: []
  type: TYPE_NORMAL
- en: b) It is positive semidefinite
  prefs: []
  type: TYPE_NORMAL
- en: c) It is always invertible
  prefs: []
  type: TYPE_NORMAL
- en: d) Its entries sum to zero in each row and column
  prefs: []
  type: TYPE_NORMAL
- en: '**5** Which matrix representation of a graph is typically symmetric?'
  prefs: []
  type: TYPE_NORMAL
- en: a) Adjacency matrix of an undirected graph.
  prefs: []
  type: TYPE_NORMAL
- en: b) Incidence matrix of an undirected graph.
  prefs: []
  type: TYPE_NORMAL
- en: c) Adjacency matrix of a directed graph.
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 1: c. Justification: The text defines an undirected graph as a pair
    \(G = (V, E)\), where \(E\) is a set of unordered pairs of vertices, not ordered
    pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 2: a. Justification: The text defines the relation \(\leftrightarrow\)
    as an equivalence relation that indicates two vertices are in the same connected
    component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 3: d. Justification: The in-degree and out-degree of a vertex in
    a directed graph depend on the number of edges entering and leaving the vertex,
    respectively, and there is no fixed relationship between them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 4: c. Justification: The text proves that the Laplacian matrix is
    symmetric and positive semidefinite, but does not claim that it is always invertible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 5: a. Justification: The text states that the adjacency matrix of
    an undirected graph is symmetric.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.1\. Undirected graphs[#](#undirected-graphs "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start with undirected graphs.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Undirected Graph)** \(\idx{graph}\xdi\) \(\idx{undirected
    graph}\xdi\) An undirected graph (or graph for short) is a pair \(G = (V,E)\)
    where \(V\) is the set of vertices (or nodes) and'
  prefs: []
  type: TYPE_NORMAL
- en: \[ E \subseteq \{\{u,v\}\,:\, u,v \in V,\ u \neq v\} \]
  prefs: []
  type: TYPE_NORMAL
- en: is the set of edges. \(\natural\)
  prefs: []
  type: TYPE_NORMAL
- en: Note that, unless otherwise stated, we typically do not allow self-loops, i.e.,
    edges that connect a vertex to itself.
  prefs: []
  type: TYPE_NORMAL
- en: '![Petersen graph (with help from Claude and ChatGPT)](../Images/bb1b1affc87320417edc1f5aca37b365.png)'
  prefs: []
  type: TYPE_IMG
- en: We occasionally write \(V(G)\) and \(E(G)\) for the vertices and edges of the
    graph \(G\). In our case, the set of vertices \(V\) is always finite.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Incidence and Adjacency)** A vertex \(v \in V\) is incident\(\idx{incident}\xdi\)
    with an edge \(e \in E\) if \(v \in e\). The incident vertices of an edge are
    called its endvertices. Two vertices \(u,v \in V\) are adjacent\(\idx{adjacent}\xdi\)
    (or neighbors), which we denote by \(u \sim v\), if \(\{u,v\} \in E\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Neighborhood and Degree)** The set of adjacent vertices of
    \(v\), denoted by \(N(v)\), is called the neighborhood\(\idx{neighborhood}\xdi\)
    of \(v\) and its size, i.e., \(\delta(v):=|N(v)|\), is the degree\(\idx{degree}\xdi\)
    of \(v\). A vertex \(v\) with \(\delta(v) = 0\) is called isolated\(\idx{isolated}\xdi\).
    A graph is called \(d\)-regular\(\idx{regular}\xdi\) if all its degrees are \(d\).
    \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: A well-known result, sometimes referred to as the [Handshaking Lemma](https://en.wikipedia.org/wiki/Handshaking_lemma)\(\idx{handshaking
    lemma}\xdi\), says that the sum of all degrees is twice the number of edges (prove
    it!).
  prefs: []
  type: TYPE_NORMAL
- en: '**EXAMPLE:** **(Petersen)** The Petersen graph is shown above. All its vertices
    have degree \(3\), that is, it is \(3\)-regular. In particular there is no isolated
    vertex. \(\lhd\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Path)** A path\(\idx{path}\xdi\) in \(G\) is a sequence of
    (not necessarily distinct) vertices \(x_0 \sim x_1 \sim \cdots \sim x_k\) with
    each consecutive pair being adjacent. The number of edges, \(k\), is called the
    length of the path. If the endvertices \(x_0\), \(x_k\) coincide, that is, \(x_0
    = x_k\), we call the path a cycle\(\idx{cycle}\xdi\). If the vertices are all
    distinct (except possibly for the endvertices), we say that the path (or cycle)
    is self-avoiding. The length of the shortest self-avoiding path connecting two
    distinct vertices \(u, v\) is called the graph distance\(\idx{graph distance}\xdi\)
    between \(u\) and \(v\), denoted by \(\rho(u,v)\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Connected)** We write \(u \leftrightarrow v\) if there is
    a path between \(u\) and \(v\). (By convention \(u \leftrightarrow u\).) A graph
    is connected if there is a path between any two of its vertices, that is, if \(u
    \leftrightarrow v\) for all \(u, v \in V\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**EXAMPLE:** **(Petersen, continued)** The Petersen graph is connected. \(\lhd\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**LEMMA** The relation \(\leftrightarrow\) is an [equivalence relation](https://en.wikipedia.org/wiki/Equivalence_relation),
    that is, \(u \leftrightarrow u\) for all \(u\) (reflexivity), \(u \leftrightarrow
    v\) if and only if \(v \leftrightarrow u\) (symmetry), and \(u \leftrightarrow
    v\) and \(v \leftrightarrow w\) implies \(u \leftrightarrow w\) (transitivity).
    \(\flat\)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Proof:* The first one is immediate from the definition. The second one is
    obtained by noting that we can reverse the path between \(u\) and \(v\) to construct
    a path between \(v\) and \(u\). The third one is obtained by noting that we can
    add a path between \(v\) and \(w\) to a path between \(u\) and \(v\) to construct
    a path between \(u\) and \(w\). \(\square\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Connected Components)** The [equivalence class](https://en.wikipedia.org/wiki/Equivalence_class)
    \(C[u] = \{v \in V\,:\, u \leftrightarrow v\}\), that is, the set of all vertices
    reachable from \(u\) through a path, is called a connected component\(\idx{connected
    component}\xdi\). A graph is connected if and only if it has only one connected
    component. \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: We show next that the (distinct) connected components form a partition of \(V\).
    It holds more generally for the equivalence classes of any equivalence relation.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEMMA** The following statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: a) \(u \leftrightarrow v\)
  prefs: []
  type: TYPE_NORMAL
- en: b) \(C[u] = C[v]\)
  prefs: []
  type: TYPE_NORMAL
- en: c) \(C[u] \cap C[v] \neq \emptyset\)
  prefs: []
  type: TYPE_NORMAL
- en: \(\flat\)
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence, either \(C[u] = C[v]\) or \(C[u] \cap C[v] = \emptyset\).
  prefs: []
  type: TYPE_NORMAL
- en: '*Proof:*'
  prefs: []
  type: TYPE_NORMAL
- en: 'a) \(\implies\) b): Let \(w \in C[u]\). So \(u \leftrightarrow w\). Symmetry
    and transitivity imply that \(v \leftrightarrow w\), which proves the claim.'
  prefs: []
  type: TYPE_NORMAL
- en: 'b) \(\implies\) c): Since \(u \in C[u]\) by reflexivity, we have \(\emptyset
    \neq C[u] = C[v] = C[u] \cap C[v]\).'
  prefs: []
  type: TYPE_NORMAL
- en: 'c) \(\implies\) a): Let \(w \in C[u] \cap C[v]\). Then \(u \leftrightarrow
    w\) and \(v \leftrightarrow w\). Symmetry and transitivity imply that \(u \leftrightarrow
    v\).'
  prefs: []
  type: TYPE_NORMAL
- en: \(\square\)
  prefs: []
  type: TYPE_NORMAL
- en: '![Connected components (with help from Claude; inspired by (Source))](../Images/2a49e5b611d0cb3744fbc9f044ea23ea.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Subgraphs and special graphs:* In network analysis, one is often interested
    in finding or counting interesting motifs or subgraphs within a much larger graph.
    We will not cover this important problem in network analysis much here, but see
    the *Exercises* section.'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Subgraph)** A subgraph\(\idx{subgraph}\xdi\) of \(G = (V,E)\)
    is a graph \(G'' = (V'',E'')\) with \(V'' \subseteq V\) and \(E'' \subseteq E\).
    Implicit in this definition is the fact that the edges in \(E''\) are incident
    only to \(V''\). The subgraph \(G''\) is said to be induced if'
  prefs: []
  type: TYPE_NORMAL
- en: \[ E' = \{\{x,y\}\,:\, x,y \in V',\ \{x,y\}\in E\}, \]
  prefs: []
  type: TYPE_NORMAL
- en: that is, if it contains exactly the edges of \(G\) between the vertices of \(V'\).
    In that case the notation \(G' := G[V']\) is used. \(\natural\)
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Spanning Subgraph)** A subgraph is said to be spanning\(\idx{spanning
    subgraph}\xdi\) if \(V'' = V\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Clique)** A subgraph containing all possible edges between
    its vertices is called a complete subgraph or clique\(\idx{clique}\xdi\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**EXAMPLE:** **(continued)** The Petersen graph contains no triangle (that
    is, complete subgraphs with \(3\) vertices), induced or not. \(\lhd\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Tree and forest)** A forest\(\idx{forest}\xdi\) is a graph
    with no self-avoiding cycle. A tree\(\idx{tree}\xdi\) is a connected forest. Vertices
    of degree \(1\) are called leaves. A spanning tree of \(G\) is a subgraph which
    is a tree and is also spanning. \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**NUMERICAL CORNER:** In Python, the [`NetworkX`](https://networkx.org) package
    provides many functionalities for defining, modifying and plotting graphs. For
    instance, many standard graphs can be defined conveniently. The [`networkx.petersen_graph`](https://networkx.org/documentation/stable/reference/generated/networkx.generators.small.petersen_graph.html)
    function defines the Petersen graph.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The graph can be plotted using the function [`networkx.draw_networkx`](https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx.html).
    Recall that in NumPy array indices start at \(0\). Consistently, NetworkX also
    names vertices starting at \(0\). Note, however, that this conflicts with our
    mathematical conventions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/b53a9db8d5538d64f42bd14671febcad7f9801f9c64feeb480cf242cab186e45.png](../Images/4434125a080ae08f69c60c5836805cf2.png)'
  prefs: []
  type: TYPE_IMG
- en: Other standard graphs can be generated with special functions, e.g. complete
    graphs using [`networkx.complete_graph`](https://networkx.org/documentation/stable/reference/generated/networkx.generators.classic.complete_graph.html#networkx.generators.classic.complete_graph).
    See [here](https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.classic)
    for a complete list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/a0ee95b038fed18e1bd3a19d39f2d8562dfdec2878e5499be0781d4ec4e98765.png](../Images/4951724a3717cf440027639708f0c5b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'See [here](https://networkx.org/documentation/stable/reference/functions.html)
    and [here](https://networkx.org/documentation/stable/reference/algorithms/index.html)
    for a list of functions to access various properties of a graph. Here are a few
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/4605ef8508b3a99c72677f416a1f6a860fe362bf231d2d54576c0e5561fa46bc.png](../Images/6f7735aad7868ed2feba3968e26cdcc4.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Another way of specifying a graph is to start with an empty graph with a given
    number of vertices and then add edges one by one. The following command creates
    a graph with \(4\) vertices and no edge (see [`networkx.empty_graph`](https://networkx.org/documentation/stable/reference/generated/networkx.generators.classic.empty_graph.html#networkx.generators.classic.empty_graph)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/a3dc8726731b499bf9695196650263cddae7d0f54b7777ab0f81cec8ffcd4605.png](../Images/9aaa661c7b224a4913156a9b27bf7d17.png)'
  prefs: []
  type: TYPE_IMG
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.2\. Directed graphs[#](#directed-graphs "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will also need directed graphs.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Directed Graph)** A directed graph\(\idx{directed graph}\xdi\)
    (or digraph for short) is a pair \(G = (V,E)\) where \(V\) is a set of vertices
    (or nodes) and'
  prefs: []
  type: TYPE_NORMAL
- en: \[ E \subseteq V^2 = \{(u,v)\,:\, u,v \in V\} \]
  prefs: []
  type: TYPE_NORMAL
- en: is a set of directed edges (or arcs). \(\natural\)
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in the directed case, we explicitly allow self-loops\(\idx{self-loop}\xdi\),
    i.e., edges of the form \((u,u)\) that connect a vertex to itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, unlike the undirected case, in a digraph the edges are ordered pairs
    – which is taken to mean that they have an orientation. If \(e = (i,j) \in E\)
    is an edge in a digraph \(G = (V,E)\), then \(i\) is called the source of \(e\)
    and \(j\) is the destination.
  prefs: []
  type: TYPE_NORMAL
- en: '![A directed graph (with help from Claude; inspired by (Source)](../Images/4bfde8866fba5b421fe07eb19bd03caa.png)'
  prefs: []
  type: TYPE_IMG
- en: The definitions discussed in the undirected case can be adapted to the directed
    case.
  prefs: []
  type: TYPE_NORMAL
- en: In the directed case, one distinguishes between the out-degree and the in-degree.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Out-degree and in-degree)** Let \(G = (V,E)\) be a digraph.
    The out-degree\(\idx{out-degree}\xdi\) of \(v \in V\), denoted by \(\delta^+(v)\),
    is the number of edges with source \(v\). The in-degree\(\idx{in-degree}\xdi\)
    of \(v\), denoted by \(\delta^-(v)\), is the number of edges with destination
    \(v\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: Paths and connectivity are also generalized naturally.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Directed Path)** A directed path\(\idx{directed path}\xdi\)
    is a sequence of vertices \(x_0, \ldots, x_k\) with \((x_{i-1},x_i) \in E\) for
    all \(i=1,\ldots,k\). We write \(u \to v\) if there is such a path with \(x_0
    = u\) and \(x_k = v\). If the endvertices \(x_0\), \(x_k\) coincide, that is,
    \(x_0 = x_k\), we call it a directed cycle\(\idx{directed cycle}\xdi\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Communication)** We say that \(u,v \in V\) communicate\(\idx{communicate}\xdi\),
    which we denote by \(u \leftrightarrow v\), if \(u \to v\) and \(v \to u\). The
    \(\leftrightarrow\) relation is again an equivalence relation. The equivalence
    classes of \(\leftrightarrow\) are called the strongly connected components of
    \(G\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Strongly Connected)** A digraph is strongly connected\(\idx{strongly
    connected}\xdi\) if any two of its vertices communicate, that is, if \(u \leftrightarrow
    v\) for all \(u, v \in V\). Or put differently, if there is only one strongly
    connected component\(\idx{strongly connected component}\xdi\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Directed Acyclic Graph)** A digraph is said to be a directed
    acyclic graph (DAG)\(\idx{directed acyclic graph}\xdi\) if it contains no directed
    cycle. \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**NUMERICAL CORNER:** The package `NetworkX` also supports digraphs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/76496f7965b537752105f87147188bd9a867acc87bfe4a3bb470fa702f7f8318.png](../Images/7e89c31acd337f7f5cf9d59692d3384e.png)'
  prefs: []
  type: TYPE_IMG
- en: Another way of specifying a digraph is to start with an empty graph with a given
    number of vertices and then add edges one by one (compare to the undirected case
    above).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/a6d3376c0f4544e54bd68776231c1245e7c427e45f332216b1264ff1c72601fb.png](../Images/f441f64d7ae78b107fc30916e169944b.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that edges in both directions are depicted here with a double-arrow. Also
    the self-loop is often awkwardly drawn. We can use [`networkx.draw_networkx_edges`](https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx_edges.html#networkx.drawing.nx_pylab.draw_networkx_edges)
    (together with [`networkx.draw_networkx_nodes`](https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx_nodes.html#networkx.drawing.nx_pylab.draw_networkx_nodes)
    and [`networkx.draw_networkx_labels`](https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_pylab.draw_networkx_labels.html#networkx.drawing.nx_pylab.draw_networkx_labels))
    to have more control over the drawing of the edges.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/967e543bbc3ca52cb02fc4d243fa5c68225aeebf075a3a99dc0292a20e89d648.png](../Images/453a50cc0a38fab0c952936c0df69d32.png)'
  prefs: []
  type: TYPE_IMG
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.3\. Matrix representations of graphs[#](#matrix-representations-of-graphs
    "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A convenient and useful way of specifying a graph is through a matrix representation.
    There are many such representations.
  prefs: []
  type: TYPE_NORMAL
- en: We start with the adjacency matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Adjacency Matrix)** Assume the (undirected) graph \(G = (V,E)\)
    has \(n = |V|\) vertices numbered \(1,\ldots,n\). The adjacency matrix\(\idx{adjacency
    matrix}\xdi\) \(A\) of \(G\) is the \(n\times n\) symmetric matrix defined as'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{align*} A_{xy} = \begin{cases} 1 & \text{if $\{x,y\} \in E$}\\ 0 &
    \text{o.w.} \end{cases} \end{align*}\]
  prefs: []
  type: TYPE_NORMAL
- en: \(\natural\)
  prefs: []
  type: TYPE_NORMAL
- en: '**EXAMPLE:** The adjancency matrix of the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with four edges (with help form Claude; inspired by (Source))](../Images/640c523edb11f10372db2c89d5d5d801.png)'
  prefs: []
  type: TYPE_IMG
- en: is
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split} A= \begin{pmatrix} 0 & 1 & 1 & 1\\ 1 & 0 & 0 & 0\\ 1 & 0 & 0
    & 1\\ 1 & 0 & 1 & 0 \end{pmatrix}. \end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is indeed symmetric. \(\lhd\)
  prefs: []
  type: TYPE_NORMAL
- en: Another useful matrix associated to a graph is its incidence matrix. For convenience,
    we assume again that the vertices of \(G = (V,E)\) are numbered \(1, \ldots, n\),
    where \(n\) is the number of vertices. We assume further that the edges are labeled
    \(e_1, \ldots, e_{m}\), where \(m\) is the number of edges.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Incidence Matrix)** The incidence matrix\(\idx{incidence
    matrix}\xdi\) of an undirected graph \(G = (V, E)\) is the \(n \times m\) matrix
    \(B\), where \(n = |V|\) and \(m =|E|\) are the numbers of vertices and edges
    respectively, such that \(B_{ij} = 1\) if the vertex \(i\) and edge \(e_j\) are
    incident and 0 otherwise. \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**EXAMPLE:** **(continued)** The incidence matrix of the graph from the previous
    example is given by'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split} B = \begin{pmatrix} 1 & 1 & 1 & 0\\ 1 & 0 & 0 & 0\\ 0 & 1 &
    0 & 1\\ 0 & 0 & 1 & 1 \end{pmatrix}. \end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: This matrix is not symmetric. In fact, in general, it is not even square. \(\lhd\)
  prefs: []
  type: TYPE_NORMAL
- en: '**NUMERICAL CORNER:** Using NetworkX, the adjacency matrix of a graph can be
    obtained with [`networkx.adjacency_matrix`](https://networkx.org/documentation/stable/reference/generated/networkx.linalg.graphmatrix.adjacency_matrix.html).
    By default, it returns a SciPy sparse matrix. Alternatively, one can get a regular
    array with [`toarray`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.toarray.html).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The incidence matrix is obtained with [`networkx.incidence_matrix`](https://networkx.org/documentation/stable/reference/generated/networkx.linalg.graphmatrix.incidence_matrix.html)
    – again as a sparse array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: In the digraph case, the definitions are adapted as follows. The adjacency matrix\(\idx{adjacency
    matrix}\xdi\) \(A\) of a digraph \(G = (V, E)\) is the matrix defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{align*} A_{xy} = \begin{cases} 1 & \text{if $(x,y) \in E$}\\ 0 & \text{o.w.}
    \end{cases} \end{align*}\]
  prefs: []
  type: TYPE_NORMAL
- en: The incidence matrix\(\idx{incidence matrix}\xdi\) of a digraph \(G\) with vertices
    \(1,\ldots,n\) and edges \(e_1, \ldots, e_m\) is the matrix \(B\) such that \(B_{ij}
    = -1\) if egde \(e_j\) leaves vertex \(i\), \(B_{ij} = 1\) if egde \(e_j\) enters
    vertex \(i\), and 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to undirected graphs, an orientation of an (undirected) graph \(G
    = (V, E)\) is a choice of direction for each of its edges, turning it into a digraph.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Oriented Incidence Matrix)** An oriented incidence matrix\(\idx{oriented
    incidence matrix}\xdi\) of an undirected graph \(G = (V, E)\) is the incidence
    matrix of an orientation of \(G\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: '![An orientation of the Petersen graph (with help from ChatGPT and Claude)](../Images/f5685424aea999de21af27623ec5db76.png)'
  prefs: []
  type: TYPE_IMG
- en: '**NUMERICAL CORNER:** We revisit an earlier directed graph.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We compute the adjacency and incidence matrices. For the incidence matrix, one
    must specify `oriented=True` for the oriented version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Revisiting an ealier undirected graph, we note that `incidence_matrix()` can
    also produce an arbitrary oriented incidence matrix by using the `oriented=True`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: \(\unlhd\)
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.4\. Laplacian matrix[#](#laplacian-matrix "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A main matrix of interest for us will be the Laplacian matrix. It is a graph
    analogue of the [Laplace-Beltrami operator](https://en.wikipedia.org/wiki/Laplace%E2%80%93Beltrami_operator)
    in differential geometry. We will show in particular that it contains useful information
    about the connectedness of the graph and we will describe an application to graph
    partitioning in a later section. But first some theory.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that, given a graph \(G = (V, E)\), the quantity \(\delta(v)\) denotes
    the degree of \(v \in V\).
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Degree Matrix)** Let \(G = (V,E)\) be a graph with vertices
    \(V = \{1, \ldots, n\}\). The degree matrix\(\idx{degree matrix}\xdi\) is the
    diagonal matrix with the degrees on the diagonal, i.e., \(D = \mathrm{diag}(\delta(1),
    \ldots, \delta(n))\). \(\natural\)'
  prefs: []
  type: TYPE_NORMAL
- en: The key definition is the following.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINITION** **(Laplacian Matrix)** Let \(G = (V,E)\) be a graph with vertices
    \(V = \{1, \ldots, n\}\) adjacency matrix \(A \in \mathbb{R}^{n \times n}\) and
    degree matrix \(D = \mathrm{diag}(\delta(1), \ldots, \delta(n))\). The Laplacian
    matrix\(\idx{Laplacian matrix}\xdi\) associated to \(G\) is defined as \(L = D
    - A\). Its entries are'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split} l_{ij} = \begin{cases} \delta(i) & \text{if $i = j$}\\ -1 &
    \text{if $\{i,j\} \in E$}\\ 0 & \text{o.w.} \end{cases} \end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: \(\natural\)
  prefs: []
  type: TYPE_NORMAL
- en: Like the adjacency matrix, the Laplacian matrix is symmetric. Unlike the adjacency
    matrix, however, it is also positive semidefinite.
  prefs: []
  type: TYPE_NORMAL
- en: '**THEOREM** **(Properties of the Laplacian)** \(\idx{properties of the Laplacian
    theorem}\xdi\) For any graph \(G\), the Laplacian matrix is symmetric and positive
    semidefinite. \(\sharp\)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Proof:* Observe that the Laplacian matrix \(L\) of a graph \(G\) is indeed
    symmetric:'
  prefs: []
  type: TYPE_NORMAL
- en: \[ L^T = (D- A)^T = D^T - A^T = D - A \]
  prefs: []
  type: TYPE_NORMAL
- en: where we used that both \(D\) and \(A\) are themselves symmetric.
  prefs: []
  type: TYPE_NORMAL
- en: To prove the second claim, we need a lemma.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEMMA** **(Laplacian and Incidence)** \(\idx{Laplacian and incidence lemma}\xdi\)
    Let \(L\) be the Laplacian matrix of a graph \(G\). Let \(B\) be any oriented
    incidence matrix of \(G\). Then'
  prefs: []
  type: TYPE_NORMAL
- en: \[ L = B B^T. \]
  prefs: []
  type: TYPE_NORMAL
- en: \(\flat\)
  prefs: []
  type: TYPE_NORMAL
- en: '*Proof idea:* We just check the claim entry by entry.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Proof:* Enumerate the edges \(e_1,\ldots,e_m\). Let \(b_{ik}\) be entry \((i,k)\)
    of \(B\). For \(i \neq j\), entry \((i,j)\) of \(B B^T\)'
  prefs: []
  type: TYPE_NORMAL
- en: \[ (B B^T)_{ij} = \sum_{k=1}^m b_{ik} b_{jk}. \]
  prefs: []
  type: TYPE_NORMAL
- en: Note that \(b_{ik} b_{jk}\) is equal to (a) \(0\) if \(i\) or \(j\) (or both)
    are not incident with \(e_k\) or (b) \(-1\) if both \(i\) and \(j\) are incident
    with \(e_k\) (since one of \(i\) or \(j\) has a \(1\) in the column of \(B\) corresponding
    to \(e_k\) and the other one has a \(-1\)). So \((B B^T)_{ij} = -1\) when \(\{i,j\}
    \in E\) and is otherwise \(0\). So it coincides with the corresponding entry of
    the Laplacian matrix there.
  prefs: []
  type: TYPE_NORMAL
- en: For \(i = j\),
  prefs: []
  type: TYPE_NORMAL
- en: '\[ (B B^T)_{ii} = \sum_{k=1}^m b_{ik}^2 = \sum_{e = \{x, y\} \in E: i \in e}
    b_{xy}^2 = \sum_{e = \{x, y\} \in E: i \in e} 1 = \delta(i), \]'
  prefs: []
  type: TYPE_NORMAL
- en: where we used that \(b_{xy}^2 = 1\) because \(b_{xy} \in \{-1,1\}\) when \(\{x,y\}
    \in E\). Again it coincides with the corresponding entry of the Laplacian matrix.
    \(\square\)
  prefs: []
  type: TYPE_NORMAL
- en: We return to the proof of the theorem. By the previous lemma, for any \(\mathbf{x}
    \in \mathbb{R}^n\),
  prefs: []
  type: TYPE_NORMAL
- en: \[ \mathbf{x}^T L \mathbf{x} = \mathbf{x}^T B B^T \mathbf{x} = \|B^T \mathbf{x}\|^2
    \geq 0. \]
  prefs: []
  type: TYPE_NORMAL
- en: That proves positive semidefiniteness. \(\square\)
  prefs: []
  type: TYPE_NORMAL
- en: '***Self-assessment quiz*** *(with help from Claude, Gemini, and ChatGPT)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**1** Which of the following is NOT a valid definition of an undirected graph?'
  prefs: []
  type: TYPE_NORMAL
- en: a) A pair \(G = (V, E)\), where \(V\) is the set of vertices and \(E\) is a
    set of unordered pairs of vertices.
  prefs: []
  type: TYPE_NORMAL
- en: b) A collection of nodes connected by edges, where the edges have no direction.
  prefs: []
  type: TYPE_NORMAL
- en: c) A pair \(G = (V, E)\), where \(V\) is the set of vertices and \(E\) is a
    set of ordered pairs of vertices.
  prefs: []
  type: TYPE_NORMAL
- en: d) A mathematical structure used to model pairwise relations between objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**2** In a graph, what does the equivalence relation \(\leftrightarrow\) signify?'
  prefs: []
  type: TYPE_NORMAL
- en: a) Two vertices are in the same connected component.
  prefs: []
  type: TYPE_NORMAL
- en: b) Two vertices have the same degree.
  prefs: []
  type: TYPE_NORMAL
- en: c) Two vertices are adjacent.
  prefs: []
  type: TYPE_NORMAL
- en: d) Two vertices are part of a cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '**3** In a directed graph, what is the relationship between the in-degree and
    out-degree of a vertex?'
  prefs: []
  type: TYPE_NORMAL
- en: a) The in-degree is always greater than or equal to the out-degree.
  prefs: []
  type: TYPE_NORMAL
- en: b) The out-degree is always greater than or equal to the in-degree.
  prefs: []
  type: TYPE_NORMAL
- en: c) The in-degree and out-degree are always equal.
  prefs: []
  type: TYPE_NORMAL
- en: d) There is no fixed relationship between the in-degree and out-degree.
  prefs: []
  type: TYPE_NORMAL
- en: '**4** Which of the following is NOT a property of the Laplacian matrix of a
    graph?'
  prefs: []
  type: TYPE_NORMAL
- en: a) It is symmetric
  prefs: []
  type: TYPE_NORMAL
- en: b) It is positive semidefinite
  prefs: []
  type: TYPE_NORMAL
- en: c) It is always invertible
  prefs: []
  type: TYPE_NORMAL
- en: d) Its entries sum to zero in each row and column
  prefs: []
  type: TYPE_NORMAL
- en: '**5** Which matrix representation of a graph is typically symmetric?'
  prefs: []
  type: TYPE_NORMAL
- en: a) Adjacency matrix of an undirected graph.
  prefs: []
  type: TYPE_NORMAL
- en: b) Incidence matrix of an undirected graph.
  prefs: []
  type: TYPE_NORMAL
- en: c) Adjacency matrix of a directed graph.
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 1: c. Justification: The text defines an undirected graph as a pair
    \(G = (V, E)\), where \(E\) is a set of unordered pairs of vertices, not ordered
    pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 2: a. Justification: The text defines the relation \(\leftrightarrow\)
    as an equivalence relation that indicates two vertices are in the same connected
    component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 3: d. Justification: The in-degree and out-degree of a vertex in
    a directed graph depend on the number of edges entering and leaving the vertex,
    respectively, and there is no fixed relationship between them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 4: c. Justification: The text proves that the Laplacian matrix is
    symmetric and positive semidefinite, but does not claim that it is always invertible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer for 5: a. Justification: The text states that the adjacency matrix of
    an undirected graph is symmetric.'
  prefs: []
  type: TYPE_NORMAL
