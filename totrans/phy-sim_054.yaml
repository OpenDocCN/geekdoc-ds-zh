- en: From Ground to Slope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://phys-sim-book.github.io/lec10.1-ground_to_slope.html](https://phys-sim-book.github.io/lec10.1-ground_to_slope.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation in the [Square Drop](lec8.3-square_drop.html) case study
    for horizontal grounds results in a simplified distance and distance gradient
    (Equation [(8.3.1)](lec8.3-square_drop.html#eq:lec8:dist_ground)) compared to
    that of a general half-space (Equation [(7.1.1)](lec7.1-signed_dists.html#eq:lec7:half_space_dist)):
    d(x)=nT(x−o),∇d(x)=n,and∇2d(x)=0.(10.1.1) This is all we need for implementing
    the slope. Defining a normal direction and a point lying on the slope'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 10.1.1 (Slope setup, simulator.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: and passing them to the time integrator and barrier energy, we can modify the
    barrier energy value, gradient, and Hessian computation for the slope as
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 10.1.2 (Slope contact barrier, BarrierEnergy.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then for the continuous collision detection, we similarly modify the implementation
    to compute the large feasible initial step size for line search using n and o:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 10.1.3 (Slope CCD, BarrierEnergy.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here the search direction of each node is projected onto the normal direction
    n to divide the current distance when computing the smallest step size that first
    brings the distance to 0.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, drawing the slope as a line from o−3n^ to o+3n^ where n^=[ny​,−nx​]
    pointing to the inclined direction,
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation 10.1.4 (Slope visualization, simulator.py).**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: we can now simulate an elastic square dropped on a slope without friction ([Figure
    10.1.1](#fig:lec10:slope_mu0)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6557a72582a004f1b656f30985f3157e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 10.1.1.** An elastic square dropped onto a frictionless slope, bouncing
    as it slides down.'
  prefs: []
  type: TYPE_NORMAL
