- en: Instruction Tables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令表
- en: 原文：[https://en.algorithmica.org/hpc/pipelining/tables/](https://en.algorithmica.org/hpc/pipelining/tables/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/pipelining/tables/](https://en.algorithmica.org/hpc/pipelining/tables/)
- en: Interleaving the stages of execution is a general idea in digital electronics,
    and it is applied not only in the main CPU pipeline, but also on the level of
    separate instructions and [memory](/hpc/cpu-cache/mlp). Most execution units have
    their own little pipelines and can take another instruction just one or two cycles
    after the previous one.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 执行阶段的交错是数字电子学中的一个通用概念，它不仅应用于主CPU流水线，还应用于单独的指令和[内存](/hpc/cpu-cache/mlp)层面。大多数执行单元都有自己的小型流水线，可以在前一个指令后的一个或两个周期内取另一个指令。
- en: 'In this context, it makes sense to use two different “[costs](/hpc/complexity)”
    for instructions:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，使用两种不同的“[成本](/hpc/complexity)”来衡量指令是有意义的：
- en: '*Latency*: how many cycles are needed to receive the results of an instruction.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*延迟*：需要多少周期才能收到指令的结果。'
- en: '*Throughput*: how many instructions can be, on average, executed per cycle.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*吞吐量*：平均每个周期可以执行多少条指令。'
- en: 'You can get latency and throughput numbers for a specific architecture from
    special documents called [instruction tables](https://www.agner.org/optimize/instruction_tables.pdf).
    Here are some sample values for my Zen 2 (all specified for 32-bit operands, if
    there is any difference):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从称为[指令表](https://www.agner.org/optimize/instruction_tables.pdf)的特殊文档中获取特定架构的延迟和吞吐量数值。以下是我Zen
    2的一些示例值（所有指定为32位操作数，如果有任何差异）：
- en: '| Instruction | Latency | RThroughput |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 延迟 | RThroughput |'
- en: '| --- | --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `jmp` | - | 2 |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `jmp` | - | 2 |'
- en: '| `mov r, r` | - | 1/4 |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `mov r, r` | - | 1/4 |'
- en: '| `mov r, m` | 4 | 1/2 |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `mov r, m` | 4 | 1/2 |'
- en: '| `mov m, r` | 3 | 1 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `mov m, r` | 3 | 1 |'
- en: '| `add` | 1 | 1/3 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `add` | 1 | 1/3 |'
- en: '| `cmp` | 1 | 1/4 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `cmp` | 1 | 1/4 |'
- en: '| `popcnt` | 1 | 1/4 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `popcnt` | 1 | 1/4 |'
- en: '| `mul` | 3 | 1 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `mul` | 3 | 1 |'
- en: '| `div` | 13-28 | 13-28 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `div` | 13-28 | 13-28 |'
- en: 'Some comments:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一些注释：
- en: Because our minds are so used to the cost model where “more” means “worse,”
    people mostly use *reciprocals* of throughput instead of throughput.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们的思维习惯于“更多”意味着“更差”的成本模型，因此人们主要使用吞吐量的倒数而不是吞吐量本身。
- en: If a certain instruction is especially frequent, its execution unit could be
    duplicated to increase its throughput — possibly to even more than one, but not
    higher than the [decode width](/hpc/architecture/layout).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果某个指令特别频繁，其执行单元可以被复制以增加其吞吐量——可能甚至超过一个，但不能超过[解码宽度](/hpc/architecture/layout)。
- en: Some instructions have a latency of 0\. This means that these instruction are
    used to control the scheduler and don’t reach the execution stage. They still
    have non-zero reciprocal throughput because the [CPU front-end](/hpc/architecture/layout)
    still needs to process them.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些指令的延迟为0。这意味着这些指令用于控制调度器，并不达到执行阶段。尽管如此，它们仍然具有非零的倒数吞吐量，因为[CPU前端](/hpc/architecture/layout)仍然需要处理它们。
- en: 'Most instructions are pipelined, and if they have the reciprocal throughput
    of $n$, this usually means that their execution unit can take another instruction
    after $n$ cycles (and if it is below 1, this means that there are multiple execution
    units, all capable of taking another instruction on the next cycle). One notable
    exception is [integer division](/hpc/arithmetic/division): it is either very poorly
    pipelined or not pipelined at all.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数指令都是流水线的，如果它们具有倒数吞吐量n，这通常意味着它们的执行单元可以在n个周期后（如果小于1，这意味着有多个执行单元，所有这些单元都能在下个周期取另一个指令）。一个值得注意的例外是[整数除法](/hpc/arithmetic/division)：它要么流水线非常差，要么根本不流水线。
- en: Some instructions have variable latency, depending on not only the size, but
    also the values of the operands. For memory operations (including fused ones like
    `add`), the latency is usually specified for the best case (an L1 cache hit).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些指令的延迟是可变的，不仅取决于操作数的大小，还取决于操作数的值。对于内存操作（包括像`add`这样的融合操作），延迟通常指定为最佳情况（L1缓存命中）。
- en: There are many more important little details, but this mental model will suffice
    for now.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多重要的细节，但这个心理模型现在就足够了。
- en: '[← Branchless Programming](https://en.algorithmica.org/hpc/pipelining/branchless/)[Throughput
    Computing →](https://en.algorithmica.org/hpc/pipelining/throughput/)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[无分支编程](https://en.algorithmica.org/hpc/pipelining/branchless/)[吞吐量计算 →](https://en.algorithmica.org/hpc/pipelining/throughput/)'
