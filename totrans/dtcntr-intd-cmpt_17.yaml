- en: 6.2¬†Collections of Structured Dataüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/Collections_of_Structured_Data.html](https://dcic-world.org/2025-08-27/Collections_of_Structured_Data.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[6.2.1¬†Lists as Collective Data](#%28part._.Lists_as_.Collective_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[6.2.2¬†Sets as Collective Data](#%28part._sets-as-collections%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[6.2.2.1¬†Picking Elements from Sets](#%28part._coll-sd-pick%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[6.2.2.2¬†Computing with Sets](#%28part._.Computing_with_.Sets%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[6.2.3¬†Combining Structured and Collective Data](#%28part._.Combining_.Structured_and_.Collective_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[6.2.4¬†Data Design Problem: Representing Quizzes](#%28part._.Data_.Design_.Problem__.Representing_.Quizzes%29)
    |'
  prefs: []
  type: TYPE_TB
- en: 'As we were looking at structured data [[Introduction to Structured Data](intro-struct-data.html)],
    we came across several situations where we have not one but many data: not one
    song but a playlist of them, not one animal but a zoo full of them, not one notification
    but several, not just one message (how we wish!) but many in our inbox, and so
    on. In general, then, we rarely have just a single structured datum: One notable
    exception: consider the configuration or preference information for a system.
    This might be stored in a file and updated through a user interface. Even though
    there is (usually) only one configuration at a time, it may have so many pieces
    that we won‚Äôt want to clutter our program with a large number of variables; instead,
    we might create a structure representing the configuration, and load just one
    instance of it. In effect, what would have been unconnected variables now become
    a set of linked fields. if we know we have only one, we might just have a few
    separate variables representing the pieces without going to the effort of creating
    and taking apart a structure. In general, therefore, we want to talk about collections
    of structured data. Here are more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The set of messages matching a tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of messages in a conversation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set of friends of a user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How are collective data different from structured data?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: In structured data, we have a fixed number of possibly different kinds of values.
    In collective data, we have a variable number of the same kind of value. For instance,
    we don‚Äôt say up front how many songs must be in a playlist or how many pages a
    user can have; but every one of them must be a song or a page. (A page may, of
    course, be conditionally defined, but ultimately everything in the collection
    is still a page.)
  prefs: []
  type: TYPE_NORMAL
- en: Observe that we‚Äôve mentioned both sets and lists above. The difference between
    a set and a list is that a set has no order, but a list has an order. This distinction
    is not vital now but we will return to it later [[Sets as Collective Data](#%28part._sets-as-collections%29)].
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, sets and lists are not the only kinds of collective data we can
    have. Here are some more:'
  prefs: []
  type: TYPE_NORMAL
- en: A family tree of people.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filesystem on your computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A seating chart at a party.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A social network of pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and so on. For the most part these are just as easy to program and manipulate
    as the earlier collective data once we have some experience, though some of them
    [[Re-Examining Equality](Sharing_and_Equality.html#%28part._identical-eq%29)]
    can involve more subtlety.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen tables [[Introduction to Tabular Data](intro-tabular-data.html)],
    which are a form of collective, structured data. Now we will look at a few more,
    and how to program them.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.1¬†Lists as Collective Data[üîó](#(part._.Lists_as_.Collective_.Data) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have already seen one example of a collection in some depth before: lists.
    A list is not limited to numbers or strings; it can contain any kind of value,
    including structured ones. For instance, using our examples from earlier [[Defining
    and Creating Structured Data](intro-struct-data.html#%28part._struct-data-eg%29)],
    we can make a list of songs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a three-element list where each element is a song:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Thus, what we have seen earlier about building functions over lists [[Processing
    Lists](processing-lists.html)] applies here too. To illustrate, suppose we wish
    to write the function `oldest-song-age`, which consumes a list of songs and produces
    the oldest song in the list. (There may be more than one song from the same year;
    the age‚Äî<wbr>by our measure‚Äî<wbr>of all those songs will be the same. If this
    happens, we just pick one of the songs from the list. Because of this, however,
    it would be more accurate to say ‚Äúan‚Äù rather than ‚Äúthe‚Äù oldest song.)
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs work through this with examples. To keep our examples easy to write, instead
    of writing out the full data for the songs, we‚Äôll refer to them just by their
    variable names. Clearly, the oldest song in our list is bound to `lvar`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What do we write in the last case? Recall that we saw this problem earlier
    [[`my-max`: Examples](processing-lists.html#%28part._my-max%29)]: there is no
    answer in the empty case. In fact, the computation here is remarkably similar
    to that of `my-max`, because it is essentially the same computation, just asking
    for the minimum year (which would make the song the oldest).'
  prefs: []
  type: TYPE_NORMAL
- en: From our examples, we can see a solution structure echoing that of `my-max`.
    For the empty list, we signal an error. Otherwise, we compute the oldest song
    in the rest of the list, and compare its year against that of the first. Whichever
    has the older year is the answer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is no guarantee there will be only oldest song, and this is
    reflected in the possibility that `osr.year` may equal `f.year`. However, our
    problem statement allowed us to pick just one such song, which is what we‚Äôve done.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify the solution above to `oldest-song-age`, which computes the age of the
    oldest song(s).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Haha, just kidding! You shouldn‚Äôt modify the previous solution at all! Instead,
    you should leave it alone‚Äî<wbr>it may come in handy for other purposes‚Äî<wbr>and
    instead build a new function to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 6.2.2¬†Sets as Collective Data[üîó](#(part._sets-as-collections) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we‚Äôve already seen, for some problems we don‚Äôt care about the order of inputs,
    nor about duplicates. Here are more examples where we don‚Äôt care about order or
    duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: Your Web browser records which Web pages you‚Äôve visited, and some Web sites
    use this information to color visited links differently than ones you haven‚Äôt
    seen. This color is typically independent of how many times you have visited the
    page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During an election, a poll agent might record that you have voted, but does
    not need to record how many times you have voted, and does not care about the
    order in which people vote.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For such problems a list is a bad fit relative to a set. Here we will see how
    Pyret‚Äôs built-in sets work. In [[Several Variations on Sets](part_sets.html)]
    we will see how we can build sets for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can define sets just as easily as we can lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Of course, due to the nature of the language‚Äôs syntax, we have to list the elements
    in some order. Does it matter?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How can we tell whether Pyret cares about the order?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here‚Äôs the simplest way to check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If we want to be especially cautious, we can write down all the other orderings
    of the elements as well, and see that Pyret doesn‚Äôt care.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many different orders are there?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Similarly for duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can again try several different kinds of duplication and confirm that sets
    ignore them.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2.1¬†Picking Elements from Sets[üîó](#(part._coll-sd-pick) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This lack of an ordering, however, poses a problem. With lists, it was meaningful
    to talk about the ‚Äúfirst‚Äù and corresponding ‚Äúrest‚Äù. By definition, with sets there
    is not ‚Äúfirst‚Äù element. In fact, Pyret does not even offer fields similar to `first`
    and `rest`. In its place is something a little more accurate but complex.
  prefs: []
  type: TYPE_NORMAL
- en: The `.pick` method returns a random element of a set. It produces a value of
    type `Pick` (which we get with `include pick`). When we pick an element, there
    are two possibilities. One is that the set is empty (analogous to a list being
    empty), which gives us a `pick-none` value. The other option is called `pick-some`,
    which gives us an actual member of the set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pick-some` variant of `Pick` has two fields, not one. To understand why
    takes a moment‚Äôs work. Let‚Äôs explore it by choosing an element of a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: (Notice that we aren‚Äôt using the `r` field in the `pick-some` case.)
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can you guess why we didn‚Äôt write examples for `an-elt`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run `an-elt(song-set)`. What element do you get?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run it again. Run it five more times.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you get the same element every time?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'No you don‚Äôt!Well, actually, it‚Äôs impossible to be certain you don‚Äôt. There
    is a very, very small likelihood you get the exact same element on every one of
    six runs. If it happens to you, keep running it more times! Pyret is designed
    to not always return the same element when picking from a set. This is on purpose:
    it‚Äôs to drive home the random nature of choosing from a set, and to prevent your
    program from accidentally depending on a particular order that Pyret might use.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given that `an-elt` does not return a predictable element, what (if any) tests
    can we write for it?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that though we can‚Äôt predict which element `an-elt` will produce, we
    do know it will produce an element of the set. Therefore, what we can write are
    tests that ensure the resulting element is a member of the set‚Äî<wbr>though in
    this case, that would not be particularly surprising.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2.2¬†Computing with Sets[üîó](#(part._.Computing_with_.Sets) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Once we have picked an element from a set, it‚Äôs often useful to obtain the
    set consisting of the remaining elements. We have already seen that choosing the
    first field of a `pick-some` is similar to taking the ‚Äúfirst‚Äù of a set. We therefore
    want a way to get the ‚Äúrest‚Äù of the set. However, we want the rest to what we
    obtain after excluding this particular ‚Äúfirst‚Äù. That‚Äôs what the second field of
    a `pick-some` is: what‚Äôs left of the set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this, we can write functions over sets that look roughly analogous to
    functions over lists. For instance, suppose we want to compute the size of a set.
    The function looks similar to `my-len` [[Some Example Exercises](processing-lists.html#%28part._my-len%29)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Though the process of deriving this is similar to that we used for `my-len`,
    the random nature of picking elements makes it harder to write examples that the
    actual function‚Äôs behavior will match.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.3¬†Combining Structured and Collective Data[üîó](#(part._.Combining_.Structured_and_.Collective_.Data)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As the above examples illustrate, a program‚Äôs data organization will often involve
    multiple kinds of compound data, often deeply intertwined. Let‚Äôs first think of
    these in pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Come up with examples that combine:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: structured and conditional data,
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: structured and collective data, and
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: conditional and collective data.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: You‚Äôve actually seen examples of each of these above. Identify them.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Finally, we might even have all three at once. For instance, a filesystem is
    usually a list (collective) of files and folders (conditional) where each file
    has several attributes (structured). Similarly, a social network has a set of
    pages (collective) where each page is for a person, organization, or other thing
    (conditional), and each page has several attributes (structured). Therefore, as
    you can see, combinations of these arise naturally in all kinds of applications
    that we deal with on a daily basis.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Take three of your favorite Web sites or apps. Identify the kinds of data they
    present. Classify these as structured, conditional, and collective. How do they
    combine these data?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '6.2.4¬†Data Design Problem: Representing Quizzes[üîó](#(part._.Data_.Design_.Problem__.Representing_.Quizzes)
    "Link to here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you can make collections of structured data, you can approach creating
    the data and programs for fairly sophisticated applications. Let‚Äôs try out a data-design
    problem, where we will focus just on creating the data definition, but not on
    writing the actual functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem Statement: You‚Äôve been hired to help create software for giving quizzes
    to students. The software will show the student a question, read in the student‚Äôs
    answer, compare the student‚Äôs answer to the expected answer (sort of like a Pyret
    example!), and produce the percentage of questions that the student got right.'
  prefs: []
  type: TYPE_NORMAL
- en: Your task is to create a data definition for capturing quizzes and expected
    answers. Don‚Äôt worry about representing the student responses.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose an initial data structure for quizzes. Start by identifying the pieces
    you might need and trying to write some sample questions.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We might imagine asking a quiz question like ‚Äúwhat is 3 + 4?‚Äú. We would expect
    the student to answer `7`. What would capture this? A piece of structured data
    with two fields like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: What‚Äôs a good type for the expected answer? This specific problem has a numeric
    answer, but other questions might have other types of answers. `Any` is therefore
    an appropriate type for the answer.
  prefs: []
  type: TYPE_NORMAL
- en: We would also need a list of `Question` to form an entire quiz.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, quiz software allows students to ask for hints.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Assume we wanted to have some (but not all) questions with hints, which would
    be text that a student could request for help with a problem. Modify the current
    data definition to capture quizzes in which some questions have hints and some
    do not.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A quiz should still be a list of questions, but the `Question` data definition
    needs another variant in order to handle questions with hints. The following would
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We could imagine extending this example to introduce dependencies between questions
    (such as one problem building on the skills of another), multiple choice questions,
    checkbox questions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Responsible Computing: Consider the Process Being Displaced'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Many companies have tried to improve education through software systems that
    automate tasks otherwise done by teachers. There are systems that show students
    a video, then give them quizzes (akin to what you just developed) to check what
    they have learned. A more extreme version interleaves videos and quizzes, thus
    teaching entire courses at scale, without the need for teacher intervention.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Massively-online courses (MOOCs) are a style of course that makes heavy use
    to computer automation, to enable reaching many more students without needing
    more teachers. Proponents of MOOCs and related educational technology tools have
    promised game-changing impacts of such tools, promising to extend quality education
    to students around the world who otherwise might lack access to quality teachers.
    Technology investors (and indeed some universities) dove in behind these technologies,
    hoping for an educational revolution at scale.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unfortunately, research and evaluation have shown that replacing education with
    automated systems, even ones with sophisticated features based on data analysis
    and predictions that identify skills that students haven‚Äôt quite mastered, doesn‚Äôt
    lead to the promised gains in learning. Why? It turns out that teaching is about
    more than choosing questions, gathering student work, and giving grades. Teachers
    provide encouragement, reassurance, and an understanding of an individual students‚Äô
    situation. Today‚Äôs computational systems don‚Äôt do this. The generally-accepted
    wisdom around these tools (backed by three prior decades of research) is that
    they are best used to complement direct instruction by a human teacher. In such
    a setting, some tools have resulted in solid performance gains on the parts of
    students.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The social-responsibility takeaway here is that you need to consider all the
    features of the system you might be trying to replace with a computational approach.
    Algorithmic quiz-taking tools have genuine value in some specific context, but
    they aren‚Äôt a replacement for all of teaching. A failure to understand the many
    aspects of teaching, and which ones do and do not make it effective for educating
    students, could have avoided a lot of inaccurate hype about the promise of algorithmic
    instruction.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 6.2.1¬†Lists as Collective Data[üîó](#(part._.Lists_as_.Collective_.Data) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have already seen one example of a collection in some depth before: lists.
    A list is not limited to numbers or strings; it can contain any kind of value,
    including structured ones. For instance, using our examples from earlier [[Defining
    and Creating Structured Data](intro-struct-data.html#%28part._struct-data-eg%29)],
    we can make a list of songs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a three-element list where each element is a song:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Thus, what we have seen earlier about building functions over lists [[Processing
    Lists](processing-lists.html)] applies here too. To illustrate, suppose we wish
    to write the function `oldest-song-age`, which consumes a list of songs and produces
    the oldest song in the list. (There may be more than one song from the same year;
    the age‚Äî<wbr>by our measure‚Äî<wbr>of all those songs will be the same. If this
    happens, we just pick one of the songs from the list. Because of this, however,
    it would be more accurate to say ‚Äúan‚Äù rather than ‚Äúthe‚Äù oldest song.)
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs work through this with examples. To keep our examples easy to write, instead
    of writing out the full data for the songs, we‚Äôll refer to them just by their
    variable names. Clearly, the oldest song in our list is bound to `lvar`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'What do we write in the last case? Recall that we saw this problem earlier
    [[`my-max`: Examples](processing-lists.html#%28part._my-max%29)]: there is no
    answer in the empty case. In fact, the computation here is remarkably similar
    to that of `my-max`, because it is essentially the same computation, just asking
    for the minimum year (which would make the song the oldest).'
  prefs: []
  type: TYPE_NORMAL
- en: From our examples, we can see a solution structure echoing that of `my-max`.
    For the empty list, we signal an error. Otherwise, we compute the oldest song
    in the rest of the list, and compare its year against that of the first. Whichever
    has the older year is the answer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is no guarantee there will be only oldest song, and this is
    reflected in the possibility that `osr.year` may equal `f.year`. However, our
    problem statement allowed us to pick just one such song, which is what we‚Äôve done.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify the solution above to `oldest-song-age`, which computes the age of the
    oldest song(s).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Haha, just kidding! You shouldn‚Äôt modify the previous solution at all! Instead,
    you should leave it alone‚Äî<wbr>it may come in handy for other purposes‚Äî<wbr>and
    instead build a new function to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 6.2.2¬†Sets as Collective Data[üîó](#(part._sets-as-collections) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we‚Äôve already seen, for some problems we don‚Äôt care about the order of inputs,
    nor about duplicates. Here are more examples where we don‚Äôt care about order or
    duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: Your Web browser records which Web pages you‚Äôve visited, and some Web sites
    use this information to color visited links differently than ones you haven‚Äôt
    seen. This color is typically independent of how many times you have visited the
    page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During an election, a poll agent might record that you have voted, but does
    not need to record how many times you have voted, and does not care about the
    order in which people vote.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For such problems a list is a bad fit relative to a set. Here we will see how
    Pyret‚Äôs built-in sets work. In [[Several Variations on Sets](part_sets.html)]
    we will see how we can build sets for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can define sets just as easily as we can lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Of course, due to the nature of the language‚Äôs syntax, we have to list the elements
    in some order. Does it matter?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How can we tell whether Pyret cares about the order?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here‚Äôs the simplest way to check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If we want to be especially cautious, we can write down all the other orderings
    of the elements as well, and see that Pyret doesn‚Äôt care.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many different orders are there?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Similarly for duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can again try several different kinds of duplication and confirm that sets
    ignore them.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2.1¬†Picking Elements from Sets[üîó](#(part._coll-sd-pick) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This lack of an ordering, however, poses a problem. With lists, it was meaningful
    to talk about the ‚Äúfirst‚Äù and corresponding ‚Äúrest‚Äù. By definition, with sets there
    is not ‚Äúfirst‚Äù element. In fact, Pyret does not even offer fields similar to `first`
    and `rest`. In its place is something a little more accurate but complex.
  prefs: []
  type: TYPE_NORMAL
- en: The `.pick` method returns a random element of a set. It produces a value of
    type `Pick` (which we get with `include pick`). When we pick an element, there
    are two possibilities. One is that the set is empty (analogous to a list being
    empty), which gives us a `pick-none` value. The other option is called `pick-some`,
    which gives us an actual member of the set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pick-some` variant of `Pick` has two fields, not one. To understand why
    takes a moment‚Äôs work. Let‚Äôs explore it by choosing an element of a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: (Notice that we aren‚Äôt using the `r` field in the `pick-some` case.)
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can you guess why we didn‚Äôt write examples for `an-elt`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run `an-elt(song-set)`. What element do you get?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run it again. Run it five more times.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you get the same element every time?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'No you don‚Äôt!Well, actually, it‚Äôs impossible to be certain you don‚Äôt. There
    is a very, very small likelihood you get the exact same element on every one of
    six runs. If it happens to you, keep running it more times! Pyret is designed
    to not always return the same element when picking from a set. This is on purpose:
    it‚Äôs to drive home the random nature of choosing from a set, and to prevent your
    program from accidentally depending on a particular order that Pyret might use.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given that `an-elt` does not return a predictable element, what (if any) tests
    can we write for it?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that though we can‚Äôt predict which element `an-elt` will produce, we
    do know it will produce an element of the set. Therefore, what we can write are
    tests that ensure the resulting element is a member of the set‚Äî<wbr>though in
    this case, that would not be particularly surprising.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2.2¬†Computing with Sets[üîó](#(part._.Computing_with_.Sets) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Once we have picked an element from a set, it‚Äôs often useful to obtain the
    set consisting of the remaining elements. We have already seen that choosing the
    first field of a `pick-some` is similar to taking the ‚Äúfirst‚Äù of a set. We therefore
    want a way to get the ‚Äúrest‚Äù of the set. However, we want the rest to what we
    obtain after excluding this particular ‚Äúfirst‚Äù. That‚Äôs what the second field of
    a `pick-some` is: what‚Äôs left of the set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this, we can write functions over sets that look roughly analogous to
    functions over lists. For instance, suppose we want to compute the size of a set.
    The function looks similar to `my-len` [[Some Example Exercises](processing-lists.html#%28part._my-len%29)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Though the process of deriving this is similar to that we used for `my-len`,
    the random nature of picking elements makes it harder to write examples that the
    actual function‚Äôs behavior will match.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2.1¬†Picking Elements from Sets[üîó](#(part._coll-sd-pick) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This lack of an ordering, however, poses a problem. With lists, it was meaningful
    to talk about the ‚Äúfirst‚Äù and corresponding ‚Äúrest‚Äù. By definition, with sets there
    is not ‚Äúfirst‚Äù element. In fact, Pyret does not even offer fields similar to `first`
    and `rest`. In its place is something a little more accurate but complex.
  prefs: []
  type: TYPE_NORMAL
- en: The `.pick` method returns a random element of a set. It produces a value of
    type `Pick` (which we get with `include pick`). When we pick an element, there
    are two possibilities. One is that the set is empty (analogous to a list being
    empty), which gives us a `pick-none` value. The other option is called `pick-some`,
    which gives us an actual member of the set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pick-some` variant of `Pick` has two fields, not one. To understand why
    takes a moment‚Äôs work. Let‚Äôs explore it by choosing an element of a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: (Notice that we aren‚Äôt using the `r` field in the `pick-some` case.)
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can you guess why we didn‚Äôt write examples for `an-elt`?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run `an-elt(song-set)`. What element do you get?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run it again. Run it five more times.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you get the same element every time?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'No you don‚Äôt!Well, actually, it‚Äôs impossible to be certain you don‚Äôt. There
    is a very, very small likelihood you get the exact same element on every one of
    six runs. If it happens to you, keep running it more times! Pyret is designed
    to not always return the same element when picking from a set. This is on purpose:
    it‚Äôs to drive home the random nature of choosing from a set, and to prevent your
    program from accidentally depending on a particular order that Pyret might use.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given that `an-elt` does not return a predictable element, what (if any) tests
    can we write for it?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that though we can‚Äôt predict which element `an-elt` will produce, we
    do know it will produce an element of the set. Therefore, what we can write are
    tests that ensure the resulting element is a member of the set‚Äî<wbr>though in
    this case, that would not be particularly surprising.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2.2¬†Computing with Sets[üîó](#(part._.Computing_with_.Sets) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Once we have picked an element from a set, it‚Äôs often useful to obtain the
    set consisting of the remaining elements. We have already seen that choosing the
    first field of a `pick-some` is similar to taking the ‚Äúfirst‚Äù of a set. We therefore
    want a way to get the ‚Äúrest‚Äù of the set. However, we want the rest to what we
    obtain after excluding this particular ‚Äúfirst‚Äù. That‚Äôs what the second field of
    a `pick-some` is: what‚Äôs left of the set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this, we can write functions over sets that look roughly analogous to
    functions over lists. For instance, suppose we want to compute the size of a set.
    The function looks similar to `my-len` [[Some Example Exercises](processing-lists.html#%28part._my-len%29)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Though the process of deriving this is similar to that we used for `my-len`,
    the random nature of picking elements makes it harder to write examples that the
    actual function‚Äôs behavior will match.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.3¬†Combining Structured and Collective Data[üîó](#(part._.Combining_.Structured_and_.Collective_.Data)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As the above examples illustrate, a program‚Äôs data organization will often involve
    multiple kinds of compound data, often deeply intertwined. Let‚Äôs first think of
    these in pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Come up with examples that combine:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: structured and conditional data,
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: structured and collective data, and
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: conditional and collective data.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: You‚Äôve actually seen examples of each of these above. Identify them.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Finally, we might even have all three at once. For instance, a filesystem is
    usually a list (collective) of files and folders (conditional) where each file
    has several attributes (structured). Similarly, a social network has a set of
    pages (collective) where each page is for a person, organization, or other thing
    (conditional), and each page has several attributes (structured). Therefore, as
    you can see, combinations of these arise naturally in all kinds of applications
    that we deal with on a daily basis.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Take three of your favorite Web sites or apps. Identify the kinds of data they
    present. Classify these as structured, conditional, and collective. How do they
    combine these data?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '6.2.4¬†Data Design Problem: Representing Quizzes[üîó](#(part._.Data_.Design_.Problem__.Representing_.Quizzes)
    "Link to here")'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you can make collections of structured data, you can approach creating
    the data and programs for fairly sophisticated applications. Let‚Äôs try out a data-design
    problem, where we will focus just on creating the data definition, but not on
    writing the actual functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem Statement: You‚Äôve been hired to help create software for giving quizzes
    to students. The software will show the student a question, read in the student‚Äôs
    answer, compare the student‚Äôs answer to the expected answer (sort of like a Pyret
    example!), and produce the percentage of questions that the student got right.'
  prefs: []
  type: TYPE_NORMAL
- en: Your task is to create a data definition for capturing quizzes and expected
    answers. Don‚Äôt worry about representing the student responses.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose an initial data structure for quizzes. Start by identifying the pieces
    you might need and trying to write some sample questions.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We might imagine asking a quiz question like ‚Äúwhat is 3 + 4?‚Äú. We would expect
    the student to answer `7`. What would capture this? A piece of structured data
    with two fields like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: What‚Äôs a good type for the expected answer? This specific problem has a numeric
    answer, but other questions might have other types of answers. `Any` is therefore
    an appropriate type for the answer.
  prefs: []
  type: TYPE_NORMAL
- en: We would also need a list of `Question` to form an entire quiz.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, quiz software allows students to ask for hints.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Assume we wanted to have some (but not all) questions with hints, which would
    be text that a student could request for help with a problem. Modify the current
    data definition to capture quizzes in which some questions have hints and some
    do not.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A quiz should still be a list of questions, but the `Question` data definition
    needs another variant in order to handle questions with hints. The following would
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We could imagine extending this example to introduce dependencies between questions
    (such as one problem building on the skills of another), multiple choice questions,
    checkbox questions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Responsible Computing: Consider the Process Being Displaced'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Many companies have tried to improve education through software systems that
    automate tasks otherwise done by teachers. There are systems that show students
    a video, then give them quizzes (akin to what you just developed) to check what
    they have learned. A more extreme version interleaves videos and quizzes, thus
    teaching entire courses at scale, without the need for teacher intervention.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Massively-online courses (MOOCs) are a style of course that makes heavy use
    to computer automation, to enable reaching many more students without needing
    more teachers. Proponents of MOOCs and related educational technology tools have
    promised game-changing impacts of such tools, promising to extend quality education
    to students around the world who otherwise might lack access to quality teachers.
    Technology investors (and indeed some universities) dove in behind these technologies,
    hoping for an educational revolution at scale.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unfortunately, research and evaluation have shown that replacing education with
    automated systems, even ones with sophisticated features based on data analysis
    and predictions that identify skills that students haven‚Äôt quite mastered, doesn‚Äôt
    lead to the promised gains in learning. Why? It turns out that teaching is about
    more than choosing questions, gathering student work, and giving grades. Teachers
    provide encouragement, reassurance, and an understanding of an individual students‚Äô
    situation. Today‚Äôs computational systems don‚Äôt do this. The generally-accepted
    wisdom around these tools (backed by three prior decades of research) is that
    they are best used to complement direct instruction by a human teacher. In such
    a setting, some tools have resulted in solid performance gains on the parts of
    students.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The social-responsibility takeaway here is that you need to consider all the
    features of the system you might be trying to replace with a computational approach.
    Algorithmic quiz-taking tools have genuine value in some specific context, but
    they aren‚Äôt a replacement for all of teaching. A failure to understand the many
    aspects of teaching, and which ones do and do not make it effective for educating
    students, could have avoided a lot of inaccurate hype about the promise of algorithmic
    instruction.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
