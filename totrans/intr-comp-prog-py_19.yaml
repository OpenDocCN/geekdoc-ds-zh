- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: MONTE CARLO SIMULATION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡罗模拟
- en: In Chapters 16 and 17, we looked at different ways of using randomness in computations.
    Many of the examples we presented fall into the class of computation known as
    **Monte Carlo simulation**. Monte Carlo simulation is a technique used to approximate
    the probability of an event by running the same simulation multiple times and
    averaging the results.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第16章和第17章中，我们探讨了在计算中使用随机性的不同方式。我们呈现的许多示例属于被称为**蒙特卡罗模拟**的计算类别。蒙特卡罗模拟是一种通过多次运行相同模拟并平均结果来近似事件概率的技术。
- en: 'Stanislaw Ulam and Nicholas Metropolis coined the term Monte Carlo simulation
    in 1949 in homage to the games of chance played in the casino in the Principality
    of Monaco. Ulam, who is best known for designing the hydrogen bomb with Edward
    Teller, described the invention of the method as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 斯坦尼斯瓦夫·乌拉姆和尼古拉斯·梅特罗波利斯于1949年创造了“蒙特卡罗模拟”这一术语，以向摩纳哥公国赌场中的机会游戏致敬。乌拉姆以与爱德华·泰勒共同设计氢弹而闻名，他这样描述该方法的发明：
- en: '*The first thoughts and attempts I made to practice [the Monte Carlo Method]
    were suggested by a question which occurred to me in 1946 as I was convalescing
    from an illness and playing solitaires. The question was what are the chances
    that a Canfield solitaire laid out with 52 cards will come out successfully? After
    spending a lot of time trying to estimate them by pure combinatorial calculations,
    I wondered whether a more practical method than “abstract thinking” might not
    be to lay it out say one hundred times and simply observe and count the number
    of successful plays. This was already possible to envisage with the beginning
    of the new era of fast computers,*[*^(124)*](#c18-fn-0001) *and I immediately
    thought of problems of neutron diffusion and other questions of mathematical physics,
    and more generally how to change processes described by certain differential equations
    into an equivalent form interpretable as a succession of random operations. Later
    … [in 1946, I] described the idea to John von Neumann, and we began to plan actual
    calculations.*[*^(125)*](#c18-fn-0002)'
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我对[蒙特卡罗方法]的首次思考和尝试，是在1946年我在康复期间玩接龙时想到的一个问题。这个问题是，一个用52张牌摆成的坎菲尔德接龙成功的机会是多少？在花了大量时间试图通过纯组合计算来估算它们之后，我想知道是否有比“抽象思维”更实际的方法，比如说摆一百次并简单观察和计算成功的次数。随着新一代快速计算机的出现，这已经是可以想象的了，*[*^(124)*](#c18-fn-0001)
    *我立即想到了中子扩散问题和其他数学物理问题，以及更一般地如何将由某些微分方程描述的过程转变为可解释为随机操作序列的等效形式。后来…… [在1946年，我]
    向约翰·冯·诺依曼描述了这个想法，我们开始规划实际计算。*[*^(125)*](#c18-fn-0002)'
- en: The technique was used during the Manhattan Project to predict what would happen
    during a nuclear fission reaction, but did not really take off until the 1950s,
    when computers became both more common and more powerful.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术在曼哈顿计划期间被用来预测核裂变反应会发生什么，但直到1950年代计算机变得更加普及和强大时，它才真正起飞。
- en: Ulam was not the first mathematician to think about using the tools of probability
    to understand a game of chance. The history of probability is intimately connected
    to the history of gambling. It is uncertainty that makes gambling possible. And
    the existence of gambling provoked the development of much of the mathematics
    needed to reason about uncertainty. Contributions to the foundations of probability
    theory by Cardano, Pascal, Fermat, Bernoulli, de Moivre, and Laplace were all
    motivated by a desire to better understand (and perhaps profit from) games of
    chance.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 乌拉姆并不是第一个想到使用概率工具来理解机会游戏的数学家。概率的历史与赌博的历史密切相关。正是这种不确定性使得赌博成为可能。而赌博的存在促使了许多必要的数学的发展，以便更好地推理不确定性。卡尔达诺、帕斯卡尔、费马、伯努利、德摩根和拉普拉斯对概率理论基础的贡献，都是出于希望更好地理解（并可能从中获利）机会游戏的愿望。
- en: 18.1 Pascal's Problem
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.1 帕斯卡尔问题
- en: 'Most of the early work on probability theory revolved around games using dice.[^(126)](#c18-fn-0003)
    Reputedly, Pascal''s interest in the field that came to be known as probability
    theory began when a friend asked him whether it would be profitable to bet that
    within 24 rolls of a pair of dice he would roll a double `6`. This was considered
    a hard problem in the mid-seventeenth century. Pascal and Fermat, two pretty smart
    guys, exchanged a number of letters about how to resolve the issue, but it now
    seems like an easy question to answer:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 早期概率理论的大部分研究围绕着使用骰子的游戏进行。传闻，帕斯卡对后来被称为概率理论的领域的兴趣开始于一个朋友问他，在24次掷骰中掷出双`6`是否会有利可图。这在十七世纪中期被视为一个棘手的问题。帕斯卡和费尔马这两位聪明人就如何解决这个问题交换了多封信件，但现在看来这是一个容易回答的问题：
- en: On the first roll the probability of rolling a `6` on each die is `1/6`, so
    the probability of rolling a `6` with both dice is `1/36`.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一次掷骰中，每个骰子掷出`6`的概率为`1/6`，因此两个骰子同时掷出`6`的概率为`1/36`。
- en: Therefore, the probability of not rolling a double `6` on the first roll is
    `1 ‑ 1/36 =` `35/36`.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，第一次掷骰不掷出双`6`的概率为`1 ‑ 1/36 =` `35/36`。
- en: Therefore, the probability of not rolling `6` on both die 24 consecutive times
    is `(35/36)`^(24), nearly `0.51`, and therefore the probability of rolling a double
    `6` is `1 - (35/36)`^(24), about `0.49`. In the long run, it would not be profitable
    to bet on rolling a double `6` within 24 rolls.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，连续24次掷骰不掷出`6`的概率为`(35/36)`^(24)，约为`0.51`，因此掷出双`6`的概率为`1 - (35/36)`^(24)，大约为`0.49`。从长远来看，押注在24次掷骰中掷出双`6`并不划算。
- en: Just to be safe, let's write a little program, [Figure 18-1](#c18-fig-0001),
    to simulate Pascal's friend's game and confirm that we get the same answer as
    Pascal. (All of the code in this chapter assumes that
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，我们写一个小程序，[图 18-1](#c18-fig-0001)，来模拟帕斯卡朋友的游戏，并确认我们得到的答案与帕斯卡相同。（本章中的所有代码都假设
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: occur at the start of the file in which the code occurs.) When run the first
    time, the call `check_pascal(1000000)` printed
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码出现的文件开始时出现。当第一次运行时，调用`check_pascal(1000000)`打印了结果。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is indeed quite close to `1 - (35/36)`^(24); typing `1-(35.0/36.0)**24`
    into the Python shell produces `0.49140387613090342`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实非常接近`1 - (35/36)`^(24)；在Python shell中输入`1-(35.0/36.0)**24`产生`0.49140387613090342`。
- en: '![c18-fig-0001.jpg](../images/c18-fig-0001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![c18-fig-0001.jpg](../images/c18-fig-0001.jpg)'
- en: '[Figure 18-1](#c18-fig-0001a) Checking Pascal''s analysis'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-1](#c18-fig-0001) 检查帕斯卡的分析'
- en: 18.2 Pass or Don't Pass?
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.2 过线或不过线？
- en: Not all questions about games of chance are so easily answered. In the game
    craps, the shooter (the person who rolls the dice) chooses between making a “pass
    line” or a “don't pass line” bet.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于机会游戏的问题并非都那么容易回答。在掷骰子游戏中，掷骰者（投掷骰子的人）在“过线”或“不过线”投注之间选择。
- en: 'Pass Line: Shooter wins if the first roll is a “natural” (`7` or `11`) and
    loses if it is “craps” (`2`, `3`, or `12`). If some other number is rolled, that
    number becomes the “point,” and the shooter keeps rolling. If the shooter rolls
    the point before rolling a `7`, the shooter wins. Otherwise the shooter loses.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过线：如果第一次掷骰结果是“自然数”（`7`或`11`），则掷骰者获胜；如果结果是“掷骰”（`2`、`3`或`12`），则掷骰者失败。如果掷出其他数字，该数字成为“点数”，掷骰者继续掷骰。如果掷骰者在掷出`7`之前掷出点数，掷骰者获胜；否则掷骰者失败。
- en: 'Don''t Pass Line: Shooter loses if the first roll is `7` or `11`, wins if it
    is `2` or `3`, and ties (a “push” in gambling jargon) if it is `12`. If some other
    number is rolled, that number becomes the point, and the shooter keeps rolling.
    If the shooter rolls a `7` before rolling the point, the shooter wins. Otherwise
    the shooter loses.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不过线：如果第一次掷骰结果是`7`或`11`，则掷骰者失败；如果结果是`2`或`3`，则掷骰者获胜；如果结果是`12`，则平局（在赌博术语中称为“平推”）。如果掷出其他数字，该数字成为点数，掷骰者继续掷骰。如果掷骰者在掷出点数之前掷出`7`，掷骰者获胜；否则掷骰者失败。
- en: Is one of these a better bet than the other? Is either a good bet? It is possible
    to analytically derive the answer to these questions, but it seems easier (at
    least to us) to write a program that simulates a craps game and see what happens.
    [Figure 18-2](#c18-fig-0002) contains the heart of such a simulation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者中哪个更划算？哪一个算是一个好赌注吗？可以通过分析得出这些问题的答案，但对我们来说，编写一个模拟掷骰游戏的程序并看看发生了什么似乎更简单。[图 18-2](#c18-fig-0002)包含了这种模拟的核心。
- en: '![c18-fig-0002.jpg](../images/c18-fig-0002.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![c18-fig-0002.jpg](../images/c18-fig-0002.jpg)'
- en: '[Figure 18-2](#c18-fig-0002a) `Craps_game` class'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-2](#c18-fig-0002) `Craps_game`类'
- en: The values of the instance variables of an instance of class `Craps_game` record
    the performance of the pass and don't pass lines since the start of the game.
    The observer methods `pass_results` and `dp_results` return these values. The
    method `play_hand` simulates one hand of a game. A “hand” starts when the shooter
    is “coming out,” the term used in craps for a roll before a point is established.
    A hand ends when the shooter has won or lost his or her initial bet. The bulk
    of the code in `play_hand` is merely an algorithmic description of the rules stated
    above. Notice that there is a loop in the `else` clause corresponding to what
    happens after a point is established. It is exited using a `break` statement when
    either a seven or the point is rolled.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Craps_game`类的实例变量记录自游戏开始以来通过线和不通过线的表现。观察方法`pass_results`和`dp_results`返回这些值。方法`play_hand`模拟一局游戏。一局的开始是当投掷者“出场”，这是在确定点数之前的投掷术语。一局在投掷者赢得或失去初始赌注时结束。`play_hand`中的大部分代码仅是上述规则的算法描述。请注意，`else`子句中有一个循环，对应于确定点数后发生的情况。当掷出七点或点数时，通过`break`语句退出循环。'
- en: '[Figure 18-3](#c18-fig-0003) contains a function that uses class `Craps_game`
    to simulate a series of craps games.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18-3](#c18-fig-0003)包含一个使用`Craps_game`类模拟一系列掷骰子游戏的函数。'
- en: '![c18-fig-0003.jpg](../images/c18-fig-0003.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![c18-fig-0003.jpg](../images/c18-fig-0003.jpg)'
- en: '[Figure 18-3](#c18-fig-0003a) Simulating a craps game'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18-3](#c18-fig-0003a) 模拟掷骰子游戏'
- en: 'The structure of `craps_sim` is typical of many simulation programs:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`craps_sim`的结构是许多模拟程序的典型：'
- en: 1\. It runs multiple games (think of each game as analogous to a trial in our
    earlier simulations) and accumulates the results. Each game includes multiple
    hands, so there is a nested loop.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 它运行多个游戏（可以把每个游戏看作是我们之前模拟中的一次试验）并累积结果。每个游戏包括多局，因此有一个嵌套循环。
- en: 2\. It then produces and stores statistics for each game.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 然后它生成并存储每个游戏的统计数据。
- en: 3\. Finally, it produces and outputs summary statistics. In this case, it prints
    the expected return on investment (ROI) for each kind of betting line and the
    standard deviation of that ROI.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 最后，它生成并输出汇总统计数据。在这种情况下，它打印每种投注线的预计投资回报率（ROI）和该ROI的标准差。
- en: '**Return on investment** is defined by the equation[^(127)](#c18-fn-0004)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**投资回报率**由以下方程定义[^(127)](#c18-fn-0004)'
- en: '![c18-fig-5001.jpg](../images/c18-fig-5001.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![c18-fig-5001.jpg](../images/c18-fig-5001.jpg)'
- en: Since the pass and don't pass lines pay even money (if you bet `$1` and win,
    you gain `$1`), the ROI is
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通过线和不通过线支付的是等额奖金（如果你投注`$1`并赢得，你获得`$1`），因此投资回报率为
- en: '![c18-fig-5002.jpg](../images/c18-fig-5002.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![c18-fig-5002.jpg](../images/c18-fig-5002.jpg)'
- en: For example, if you made `100` pass line bets and won half, your ROI would be
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你进行了`100`次通过线的投注并赢得了一半，那么你的ROI将是
- en: '![c18-fig-5003.jpg](../images/c18-fig-5003.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![c18-fig-5003.jpg](../images/c18-fig-5003.jpg)'
- en: If you bet the don't pass line 100 times and had 25 wins and 5 pushes, the ROI
    would be
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在不通过线上投注100次，并赢得25次和5次平局，那么ROI将是
- en: '![c18-fig-5004.jpg](../images/c18-fig-5004.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![c18-fig-5004.jpg](../images/c18-fig-5004.jpg)'
- en: Let's run our craps game simulation and see what happens when we try `craps_sim(20,
    10)`:[^(128)](#c18-fn-0005)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行掷骰子游戏模拟，看看尝试`craps_sim(20, 10)`时会发生什么：[^(128)](#c18-fn-0005)
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It looks as if it would be a good idea to avoid the pass line—where the expected
    return on investment is a `7%` loss. But the don't pass line looks like a pretty
    good bet. Or does it?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来避免通过线是个好主意——预计投资回报为`7%`的损失。但不通过线似乎是一个不错的赌注。或者说并非如此？
- en: Looking at the standard deviations, it seems that perhaps the don't pass line
    is not such a safe bet after all. Recall that under the assumption that the distribution
    is normal, the `95%` confidence interval is encompassed by `1.96` standard deviations
    on either side of the mean. For the don't pass line, the `95%` confidence interval
    is `[4.0–1.96`*`23.5372, 4.0+1.96`*`23.5372]`—roughly `[-43%, +51%]`. That certainly
    doesn't suggest that betting the don't pass line is a sure thing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从标准差来看，不通过线似乎并不是如此安全的赌注。回想一下，在假设分布是正态的情况下，`95%`的置信区间由均值两侧的`1.96`个标准差包围。对于不通过线，`95%`的置信区间是`[4.0–1.96`*`23.5372,
    4.0+1.96`*`23.5372]`——大约为`[-43%, +51%]`。这当然并不表明投注不通过线是万无一失的。
- en: Time to put the law of large numbers to work; `craps_sim(1000000, 10)` prints
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将大数法则付诸实践；`craps_sim(1000000, 10)` 输出
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can now be pretty safe in assuming that neither of these is a good bet.[^(129)](#c18-fn-0006)
    It looks as if the don't pass line might be slightly less bad, but we probably
    shouldn't count on that. If the `95%` confidence intervals for the pass and don't
    pass lines did not overlap, it would be safe to assume that the difference in
    the two means was statistically significant.[^(130)](#c18-fn-0007) However, they
    do overlap, so no conclusion can be safely drawn.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以相对安全地假设这两个选项都不是好的投注。[^(129)](#c18-fn-0006) 看起来不通过线可能稍微好一些，但我们可能不应该依赖于此。如果通过线和不通过线的`95%`置信区间没有重叠，假设两个均值之间的差异是统计显著的将是安全的。[^(130)](#c18-fn-0007)
    然而，它们确实重叠，所以不能安全得出结论。
- en: 'Suppose that instead of increasing the number of hands per game, we increased
    the number of games, e.g., by making the call `craps_sim(20, 1000000)`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不是增加每局的手数，而是增加游戏的局数，例如，通过调用`craps_sim(20, 1000000)`：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The standard deviations are high—indicating that the outcome of a single game
    of `20` hands is highly uncertain.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 标准差很高——这表明一局`20`手的结果高度不确定。
- en: One of the nice things about simulations is that they make it easy to perform
    “what if” experiments. For example, what if a player could sneak in a pair of
    cheater's dice that favored `5` over `2` (`5` and `2` are on the opposite sides
    of a die)? To test this out, all we have to do is replace the implementation of
    `roll_die` by something like
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟的一个好处是它们使得进行“如果”实验变得简单。例如，如果一名玩家能够悄悄地引入一对有利于`5`而非`2`的作弊骰子（`5`和`2`在骰子的对面）呢？要测试这个，只需将`roll_die`的实现替换为类似的内容。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This relatively small change in the die makes a dramatic difference in the odds.
    Running `craps_sim(1000000, 10)` yields
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 骰子上的这个相对较小的变化在赔率上产生了显著差异。运行`craps_sim(1000000, 10)`得出的结果是
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: No wonder casinos go to a lot of trouble to make sure that players don't introduce
    their own dice into the game!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 难怪赌场费尽心思确保玩家不在游戏中引入自己的骰子！
- en: '**Finger exercise**: A “big 6” bet pays even money if a 6 is rolled before
    a 7\. Assuming 30 $5 bets per hour, write a Monte Carlo simulation that estimates
    the cost per hour and the standard deviation of that cost of playing “big 6” bets.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习**：如果在掷出6之前掷出了7，"大6"的投注支付是平赔。假设每小时有30个$5的投注，编写一个蒙特卡罗模拟来估算玩“大6”投注的每小时成本和该成本的标准差。'
- en: 18.3 Using Table Lookup to Improve Performance
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.3 使用表查找来提高性能
- en: You might not want to try running `craps_sim(100000000, 10)` at home. It takes
    a long time to complete on most computers. That raises the question of whether
    there is a simple way to speed up the simulation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不想在家尝试运行`craps_sim(100000000, 10)`。在大多数计算机上完成这个任务需要很长时间。这引出了一个问题：是否有简单的方法来加快模拟速度。
- en: The complexity of the implementation of the function `craps_sim` is roughly
    *θ*`(``play_hand``)`*`hands_per_game`*`num_games`. The running time of `play_hand`
    depends upon the number of times the loop in it is executed. In principle, the
    loop could be executed an unbounded number of times since there is no bound on
    how long it could take to roll either a `7` or the point. In practice, of course,
    we have every reason to believe it will always terminate.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`craps_sim`的实现复杂度大约是*θ*`(``play_hand``)`*`hands_per_game`*`num_games`。`play_hand`的运行时间取决于循环执行的次数。从理论上讲，循环可以被执行无限次，因为掷出`7`或点数所需的时间没有上限。但实际上，我们有充分理由相信它总会终止。
- en: 'Notice, however, that the result of a call to `play_hand` does not depend on
    how many times the loop is executed, but only on which exit condition is reached.
    For each possible point, we can easily calculate the probability of rolling that
    point before rolling a `7`. For example, using a pair of dice we can roll a `4`
    in three different ways: `<1, 3>, <3, 1>,` and `<2, 2>`. We can roll a `7` in
    six different ways`: <1, 6>, <6, 1>, <2, 5>, <5, 2>, <3, 4>`, and `<4, 3>`. Therefore,
    exiting the loop by rolling a `7` is twice as likely as exiting the loop by rolling
    a `4`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不过请注意，`play_hand`的调用结果并不依赖于循环执行的次数，而只取决于达到的退出条件。对于每个可能的点，我们可以轻松计算在掷出`7`之前掷出该点的概率。例如，使用一对骰子我们可以用三种方式掷出`4`：`<1,
    3>, <3, 1>,` 和 `<2, 2>`。我们可以用六种方式掷出`7`：`<1, 6>, <6, 1>, <2, 5>, <5, 2>, <3, 4>`
    和 `<4, 3>`。因此，通过掷出`7`退出循环的可能性是通过掷出`4`的两倍。
- en: '[Figure 18-4](#c18-fig-0008) contains an implementation of `play_hand` that
    exploits this thinking. We first compute the probability of making the point before
    rolling a `7` for each possible value of the point and store those values in a
    dictionary. Suppose, for example, that the point is `8`. The shooter continues
    to roll until he either rolls the point or rolls craps. There are five ways of
    rolling an `8` `(<6,2>,` `<2,6>, <5,3>, <3,5>, and <4,4>)` and six ways of rolling
    a `7`. So, the value for the dictionary key `8` is the value of the expression
    `5/11`. Having this table allows us to replace the inner loop, which contained
    an unbounded number of rolls, with a test against one call to `random.random`.
    The asymptotic complexity of this version of `play_hand` is `O(1)`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-4](#c18-fig-0008)包含了一个利用这种思维的`play_hand`实现。我们首先计算在掷出`7`之前，针对每个可能的点值形成该点的概率，并将这些值存储在字典中。例如，假设点值为`8`。投掷者会继续掷骰，直到掷出该点或掷出“掷坏”。掷出`8`有五种方式`(<6,2>,
    <2,6>, <5,3>, <3,5>, <4,4>)`，而掷出`7`有六种方式。因此，字典键`8`的值为表达式`5/11`的值。拥有这个表允许我们将包含不受限制掷骰次数的内部循环替换为对一次`random.random`调用的测试。这个版本的`play_hand`的渐进复杂度为`O(1)`。'
- en: 'The idea of replacing computation by **table lookup** has broad applicability
    and is frequently used when speed is an issue. Table lookup is an example of the
    general idea of **trading time for space**. As we saw in Chapter 15, it is the
    key idea behind dynamic programming. We saw another example of this technique
    in our analysis of hashing: the larger the table, the fewer the collisions, and
    the faster the average lookup. In this case, the table is small, so the space
    cost is negligible.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 用**查表**替代计算的思想具有广泛的适用性，通常在速度成为问题时使用。查表是**以时间换空间**这一一般思想的一个例子。正如我们在第15章中看到的，这也是动态规划背后的关键思想。在我们对哈希分析中看到过这一技术的另一个例子：表越大，碰撞越少，平均查找速度越快。在这种情况下，表很小，所以空间成本微不足道。
- en: '![c18-fig-0004.jpg](../images/c18-fig-0004.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![c18-fig-0004.jpg](../images/c18-fig-0004.jpg)'
- en: '[Figure 18-4](#c18-fig-0008a) Using table lookup to improve performance'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-4](#c18-fig-0008a) 使用查表来提高性能'
- en: 18.4 Finding π
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.4 寻找π
- en: It is easy to see how Monte Carlo simulation is useful for tackling problems
    in which nondeterminism plays a role. Interestingly, however, Monte Carlo simulation
    (and randomized algorithms in general) can be used to solve problems that are
    not inherently stochastic, i.e., for which there is no uncertainty about outcomes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，蒙特卡罗模拟在解决非确定性问题时是有用的。有趣的是，蒙特卡罗模拟（以及随机算法一般）也可以用来解决那些本质上并不是随机的问题，即没有结果不确定性的问题。
- en: Consider *π*. For thousands of years, people have known that there is a constant
    (called *π* since the eighteenth century) such that the circumference of a circle
    is equal to `π` * `diameter` and the area of the circle equal to *π* * `radius`².
    What they did not know was the value of this constant.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑*π*。数千年来，人们一直知道有一个常数（自18世纪以来称为*π*），使得圆的周长等于`π` * `直径`，而圆的面积等于*π* * `半径`²。他们不知道的是这个常数的值。
- en: One of the earliest estimates, `4`*`(8/9)`² `= 3.16`, can found in the Egyptian
    *Rhind Papyrus*, circa 1650 BC. More than a thousand years later, the *Old Testament*
    (1 Kings 7.23) implied a different value for *π* when giving the specifications
    of one of King Solomon's construction projects,
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最早的估算之一，`4`*`(8/9)`² `= 3.16`，可以在公元前1650年的埃及*林德纸草书*中找到。千年之后，*旧约*（列王纪上 7.23）在给出所罗门王某个建筑项目的规格时暗示了一个不同的*π*值，
- en: '*And he made a molten sea, ten cubits from the one brim to the other: it was
    round all about, and his height was five cubits: and a line of 30 cubits did compass
    it round about.*'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*他造了一个铸造的海，从一边到另一边十肘：它周围是圆的，高五肘：周围有三十肘的线环绕着它。*'
- en: Solving for *π*, `10π = 30`, so *π* `= 3`. Perhaps the *Bible* is simply wrong,
    or perhaps the molten sea wasn't perfectly circular, or perhaps the circumference
    was measured from the outside of the wall and the diameter from the inside, or
    perhaps it's just poetic license. We leave it to the reader to decide.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 解决*π*，`10π = 30`，因此*π* `= 3`。也许*圣经*只是错了，或者铸造的海并不完美圆形，或者周长是从墙外测量的而直径是从内部测量的，或者这只是诗意的许可。我们留给读者自己决定。
- en: Archimedes of Syracuse (287-212 BCE) derived upper and lower bounds on the value
    of *π* by using a high-degree polygon to approximate a circular shape. Using a
    polygon with `96` sides, he concluded that `223/71 <` *π* `< 22/7`. Giving upper
    and lower bounds was a rather sophisticated approach for the time. If we take
    his best estimate as the average of his two bounds, we obtain `3.1418`, an error
    of about `0.0002`. Not bad! But about 700 years later, the Chinese mathematician
    Zu Chongzhi used a polygon with 24,576 sides to conclude that `3.1415962 <` *π*
    `< 3.1415927\.` About 800 years after that, the Dutch cartographer Adriaan Anthonisz
    (1527-1607) estimated it as `355/113`, roughly3.1415929203539825\. That estimate
    is good enough for most practical purposes, but it didn't keep mathematicians
    from working on the problem.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 阿基米德（公元前287-212年）通过使用高阶多边形来近似圆形，从而得出了*π*的上下界。使用96边的多边形，他得出结论`223/71 <` *π* `<
    22/7`。给出上下界在当时是一种相当复杂的方法。如果将他的两个界的平均值作为最佳估计，我们得到了`3.1418`，误差约为`0.0002`。不错！但大约700年后，中国数学家祖冲之使用一个有24,576个边的多边形得出结论`3.1415962
    <` *π* `< 3.1415927\`。大约800年后，荷兰制图师阿德里安·安东尼兹（1527-1607）估算为`355/113`，大约为3.1415929203539825。这一估算对大多数实际用途来说已经足够好，但并未阻止数学家继续研究这个问题。
- en: Long before computers were invented, the French mathematicians Buffon (1707-1788)
    and Laplace (1749-1827) proposed using a stochastic simulation to estimate the
    value of *π*.[^(131)](#c18-fn-0008) Think about inscribing a circle in a square
    with sides of length `2`, so that the radius, r, of the circle is of length `1`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机发明之前，法国数学家布丰（1707-1788）和拉普拉斯（1749-1827）提出使用随机模拟来估算*π*的值。[^(131)](#c18-fn-0008)
    想象一下在一条边长为`2`的正方形内画一个圆，使得圆的半径`r`为`1`。
- en: '![c18-fig-0005.jpg](../images/c18-fig-0005.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![c18-fig-0005.jpg](../images/c18-fig-0005.jpg)'
- en: Figure 18-5 Unit circle inscribed in a square
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-5 单位圆被画在正方形内
- en: By the definition of *π*, *area* = *πr*². Since `r` is `1`, *π* `= area`. But
    what's the area of the circle? Buffon suggested that he could estimate the area
    of a circle by a dropping a large number of needles (which he argued would follow
    a random path as they fell) in the vicinity of the square. The ratio of the number
    of needles with tips lying within the square to the number of needles with tips
    lying within the circle could then be used to estimate the area of the circle.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*π*的定义，*面积* = *πr*²。由于`r`为`1`，*π* `= 面积`。但圆的面积是多少呢？布丰建议通过在正方形附近抛投大量针来估算圆的面积（他认为针在下落时会随机移动）。落在正方形内的针尖数量与落在圆内的针尖数量的比率可以用来估算圆的面积。
- en: If the locations of the needles are truly random, we know that
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果针的位置是完全随机的，我们知道
- en: '![c18-fig-5005.jpg](../images/c18-fig-5005.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![c18-fig-5005.jpg](../images/c18-fig-5005.jpg)'
- en: and solving for the area of the circle,
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 并求解圆的面积，
- en: '![c18-fig-5006.jpg](../images/c18-fig-5006.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![c18-fig-5006.jpg](../images/c18-fig-5006.jpg)'
- en: Recall that the area of a `2` by `2` square is `4`, so,
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`2`乘以`2`的正方形面积是`4`，所以，
- en: '![c18-fig-5007.jpg](../images/c18-fig-5007.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![c18-fig-5007.jpg](../images/c18-fig-5007.jpg)'
- en: 'In general, to estimate the area of some region `R`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，要估算某个区域`R`的面积：
- en: 1\. Pick an enclosing region, `E`, such that the area of `E` is easy to calculate
    and `R` lies completely within `E`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 选择一个封闭区域`E`，使得`E`的面积容易计算，且`R`完全位于`E`内。
- en: 2\. Pick a set of random points that lie within `E`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 选择一组随机点，这些点位于`E`内。
- en: 3\. Let `F` be the fraction of the points that fall within `R`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 设`F`为落在`R`内的点的比例。
- en: 4\. Multiply the area of `E` by `F`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 将区域`E`的面积乘以`F`。
- en: If you try Buffon's experiment, you'll soon realize that the places where the
    needles land are not truly random. Moreover, even if you could drop them randomly,
    it would take a very large number of needles to get an approximation of `π` as
    good as even the *Bible*'s. Fortunately, computers can randomly drop simulated
    needles at a ferocious rate.[^(132)](#c18-fn-0009)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试布丰的实验，你会很快意识到针落下的位置并不是完全随机的。此外，即使你能随机投放它们，也需要大量的针才能得到与*Bible*相当的`π`近似值。幸运的是，计算机可以以惊人的速度随机投放模拟针。[^(132)](#c18-fn-0009)
- en: '[Figure 18-6](#c18-fig-0013) contains a program that estimates `π` using the
    Buffon-Laplace method. For simplicity, it considers only those needles that fall
    in the upper-right quadrant of the square.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18-6](#c18-fig-0013)包含一个使用布丰-拉普拉斯方法估算`π`的程序。为了简化，程序仅考虑落在正方形右上象限的针。'
- en: '![c18-fig-0006.jpg](../images/c18-fig-0006.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![c18-fig-0006.jpg](../images/c18-fig-0006.jpg)'
- en: '[Figure 18-6](#c18-fig-0013a) Estimating π'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-6](#c18-fig-0013a) 估计 π'
- en: The function `throw_needles` simulates dropping a needle by first using `random.random`
    to get a pair of positive Cartesian coordinates (`x` and `y` values) representing
    the position of the needle with respect to the center of the square. It then uses
    the Pythagorean theorem to compute the hypotenuse of the right triangle with base
    `x` and height `y`. This is the distance of the tip of the needle from the origin
    (the center of the square). Since the radius of the circle is `1`, we know that
    the needle lies within the circle if and only if the distance from the origin
    is no greater than `1`. We use this fact to count the number of needles in the
    circle.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `throw_needles` 通过首先使用 `random.random` 获取一对正的笛卡尔坐标（`x` 和 `y` 值），模拟扔掉一根针，这代表了针相对于正方形中心的位置。然后，它使用毕达哥拉斯定理计算以
    `x` 为底、`y` 为高的直角三角形的斜边。这是针尖离原点（正方形的中心）的距离。由于圆的半径为 `1`，我们知道，只有当从原点的距离不大于 `1` 时，针才会落在圆内。我们利用这一事实来计算落在圆内的针的数量。
- en: The function `get_est` uses `throw_needles` to find an estimate of *π* by first
    dropping `num_needles` needles, and then averaging the result over `num_trials`
    trials. It then returns the mean and standard deviation of the trials.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `get_est` 使用 `throw_needles` 通过首先扔掉 `num_needles` 根针，然后对 `num_trials` 次试验的结果取平均，来找出
    *π* 的估计值。它返回试验的均值和标准差。
- en: The function `est_pi` calls `get_est` with an ever-growing number of needles
    until the standard deviation returned by `get_est` is no larger than `precision/1.96\.`
    Under the assumption that the errors are normally distributed, this implies that
    `95%` of the values lie within `precision` of the mean.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `est_pi` 以不断增加的针的数量调用 `get_est`，直到 `get_est` 返回的标准差不大于 `precision/1.96`。在假设误差服从正态分布的前提下，这意味着
    `95%` 的值位于均值的 `precision` 范围内。
- en: When we ran `est_pi(0.01, 100)`, it printed
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `est_pi(0.01, 100)` 时，它打印了
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we would expect, the standard deviations decreased monotonically as we increased
    the number of samples. In the beginning the estimates of the value of `π` also
    improved steadily. Some were above the true value and some below, but each increase
    in `num_needles` led to an improved estimate. With `1000` samples per trial, the
    simulation's estimate was already better than those of the *Bible* and the *Rhind
    Papyrus*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，随着样本数量的增加，标准差单调减少。最开始时，`π` 的估计值也稳步提高。有些高于真实值，有些低于真实值，但每次增加 `num_needles`
    都会导致估计值的改善。在每次试验中使用 `1000` 个样本时，模拟的估计值已经优于*圣经*和*林德纸草书*。
- en: Curiously, the estimate got worse when the number of needles increased from
    `8,000` to `16,000`, since `3.14135` is farther from the true value of `π` than
    is `3.14143`. However, if we look at the ranges defined by one standard deviation
    around each of the means, both ranges contain the true value of *π*, and the range
    associated with the larger sample size is smaller. Even though the estimate generated
    with `16,000` samples happens to be farther from the actual value of *π*, we should
    have more confidence in its accuracy. This is an extremely important notion. It
    is not sufficient to produce a good answer. We have to have a valid reason to
    be confident that it is in fact a good answer. And when we drop a large enough
    number of needles, the small standard deviation gives us reason to be confident
    that we have a correct answer. Right?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，当针的数量从 `8,000` 增加到 `16,000` 时，估计值反而变差，因为 `3.14135` 离真实的 *π* 值比 `3.14143`
    更远。然而，如果我们查看每个均值周围一个标准差所定义的范围，这两个范围都包含真实的 *π* 值，且与较大样本量相关的范围更小。尽管使用 `16,000` 个样本生成的估计恰好离真实的
    *π* 值更远，但我们应该对其准确性更有信心。这是一个极其重要的概念。仅仅给出一个好答案是不够的。我们必须有合理的理由相信它实际上是一个好答案。当我们扔掉足够多的针时，小标准差给我们提供了信心，表明我们得到了正确的答案，对吧？
- en: Not exactly. Having a small standard deviation is a necessary condition for
    having confidence in the validity of the result. It is not a sufficient condition.
    The notion of a statistically valid conclusion should never be confused with the
    notion of a correct conclusion.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不完全是。拥有小的标准差是对结果有效性有信心的必要条件，但不是充分条件。统计有效结论的概念永远不应与正确结论的概念混淆。
- en: Each statistical analysis starts with a set of assumptions. The key assumption
    here is that our simulation is an accurate model of reality. Recall that the design
    of our Buffon-Laplace simulation started with a little algebra demonstrating how
    we could use the ratio of two areas to find the value of *π*. We then translated
    this idea into code that depended upon a little geometry and on the randomness
    of `random.random`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个统计分析都始于一组假设。这里的关键假设是我们的模拟是现实的准确模型。回想一下，我们的布丰-拉普拉斯模拟的设计是从一些代数开始的，这些代数展示了我们如何利用两个区域的比率来找到*π*的值。然后我们将这个想法转化为依赖于一些几何知识和`random.random`随机性的代码。
- en: Let's see what happens if we get any of this wrong. Suppose, for example, we
    replace the `4` in the last line of the function `throw_needles` by a `2`, and
    again run `est_pi(0.01, 100)`. This time it prints
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们在这些方面出错会发生什么。例如，假设我们将函数`throw_needles`最后一行中的`4`替换为`2`，然后再次运行`est_pi(0.01,
    100)`。这次它打印
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The standard deviation for a mere `32,000` needles suggests that we should
    have a fair amount of confidence in the estimate. But what does that really mean?
    It means that we can be reasonably confident that if we were to draw more samples
    from the same distribution, we would get a similar value. It says nothing about
    whether this value is close to the actual value of *π*. If you are going to remember
    only one thing about statistics, remember this: a statistically valid conclusion
    should not be confused with a correct conclusion!'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅`32,000`根针的标准差表明我们对这个估计应该有相当的信心。但这到底意味着什么呢？这意味着我们可以合理地相信，如果我们从同一分布中抽取更多样本，我们会得到一个类似的值。它并未说明这个值是否接近实际的*π*值。如果你要记住关于统计学的一件事，请记住这一点：统计上有效的结论不应与正确的结论混淆！
- en: Before believing the results of a simulation, we need to have confidence both
    that our conceptual model is correct and that we have correctly implemented that
    model. Whenever possible, you should attempt to validate results against reality.
    In this case, you could use some other means to compute an approximation to the
    area of a circle (e.g., physical measurement) and check that the computed value
    of *π* is at least in the right neighborhood.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在相信模拟结果之前，我们需要对我们的概念模型的正确性以及我们是否正确实现了该模型有信心。尽可能地，你应该尝试将结果与现实进行验证。在这种情况下，你可以使用其他方法计算圆的面积的近似值（例如，物理测量），并检查计算得到的*π*值至少是否在正确的范围内。
- en: 18.5 Some Closing Remarks about Simulation Models
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.5 关于模拟模型的一些结束语
- en: For most of the history of science, theorists used mathematical techniques to
    construct purely analytical models that could be used to predict the behavior
    of a system from a set of parameters and initial conditions. This led to the development
    of important mathematical tools ranging from calculus to probability theory. These
    tools helped scientists develop a reasonably accurate understanding of the macroscopic
    physical world.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在科学历史的大部分时间里，理论家们使用数学技术构建纯粹的解析模型，这些模型可以根据一组参数和初始条件预测系统的行为。这导致了重要数学工具的发展，从微积分到概率论。这些工具帮助科学家们对宏观物理世界形成了相对准确的理解。
- en: 'As the twentieth century progressed, the limitations of this approach became
    increasingly clear. Reasons for this include:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 随着二十世纪的进展，这种方法的局限性变得越来越明显。这些原因包括：
- en: An increased interest in the social sciences, e.g., economics, led to a desire
    to construct good models of systems that were not mathematically tractable.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对社会科学（例如经济学）的兴趣增加，促使人们希望构建那些在数学上无法处理的系统的良好模型。
- en: As the systems to be modeled grew increasingly complex, it seemed easier to
    successively refine a series of simulation models than to construct accurate analytic
    models.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着被建模的系统变得越来越复杂，似乎逐步完善一系列模拟模型比构建准确的解析模型要容易得多。
- en: It is often easier to extract useful intermediate results from a simulation
    than from an analytical model, e.g., to play “what if” games.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模拟中提取有用的中间结果往往比从解析模型中提取更容易，例如进行“如果……会怎样”的游戏。
- en: The availability of computers made it feasible to run large-scale simulations.
    Until the advent of the modern computer in the middle of the twentieth century
    the utility of simulation was limited by the time required to perform calculations
    by hand.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机的可用性使得运行大规模模拟成为可能。在二十世纪中叶现代计算机出现之前，模拟的实用性受限于手动计算所需的时间。
- en: Simulation models are **descriptive**, not **prescriptive**. They tell how a
    system works under given conditions; not how to arrange the conditions to make
    the system work best. A simulation does not optimize, it merely describes. That
    is not to say that simulation cannot be used as part of an optimization process.
    For example, simulation is often used as part of a search process in finding an
    optimal set of parameter settings.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真模型是**描述性的**，而不是**处方性的**。它们描述系统在给定条件下如何工作，而不是如何安排条件以使系统表现最佳。仿真并不优化，它只是描述。这并不是说仿真不能作为优化过程的一部分。例如，仿真通常作为寻找最佳参数设置的一部分搜索过程。
- en: 'Simulation models can be classified along three dimensions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真模型可以沿三个维度分类：
- en: Deterministic versus stochastic
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定性与随机性
- en: Static versus dynamic
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态与动态
- en: Discrete versus continuous
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离散与连续
- en: The behavior of a **deterministic simulation** is completely defined by the
    model. Rerunning a simulation will not change the outcome. Deterministic simulations
    are typically used when the system being modeled is itself deterministic but is
    too complex to analyze analytically, e.g., the performance of a processor chip.
    **Stochastic simulations** incorporate randomness in the model. Multiple runs
    of the same model may generate different values. This random element forces us
    to generate many outcomes to see the range of possibilities. The question of whether
    to generate `10` or `1000` or `100,000` outcomes is a statistical question, as
    discussed earlier.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**确定性仿真**的行为完全由模型定义。重新运行仿真不会改变结果。确定性仿真通常用于被建模系统本身也是确定性的情况，但分析过于复杂，例如，处理器芯片的性能。**随机仿真**在模型中引入了随机性。对同一模型的多次运行可能会生成不同的值。这种随机因素迫使我们生成多个结果，以查看可能性的范围。生成`10`、`1000`或`100,000`个结果的问题是一个统计问题，如前所述。'
- en: In a **static model**, time plays no essential role. The needle-dropping simulation
    used to estimate `π` in this chapter is an example of a static simulation. In
    a **dynamic model**, time, or some analog, plays an essential role. In the series
    of random walks simulated in Chapter 16, the number of steps taken was used as
    a surrogate for time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在**静态模型**中，时间没有本质作用。本章中用于估计`π`的针落仿真就是一个静态仿真的例子。在**动态模型**中，时间或某种类似物起着重要作用。在第16章中模拟的一系列随机行走中，所采取的步数被用作时间的替代。
- en: In a **discrete model**, the values of pertinent variables are enumerable, e.g.,
    they are integers. In a **continuous model**, the values of pertinent variables
    range over non-enumerable sets, e.g., the real numbers. Imagine analyzing the
    flow of traffic along a highway. We might choose to model each individual car,
    in which case we have a discrete model. Alternatively, we might choose to treat
    traffic as a flow, where changes in the flow can be described by differential
    equations. This leads to a continuous model. In this example, the discrete model
    more closely resembles the physical situation (nobody drives half a car, though
    some cars are half the size of others), but is more computationally complex than
    a continuous one. In practice, models often have both discrete and continuous
    components. For example, we might choose to model the flow of blood through the
    human body using a discrete model for blood (i.e., modeling individual corpuscles)
    and a continuous model for blood pressure.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在**离散模型**中，相关变量的值是可枚举的，例如，它们是整数。在**连续模型**中，相关变量的值范围在不可枚举的集合上，例如，实数。想象分析高速公路上的交通流。我们可能选择对每辆汽车进行建模，在这种情况下，我们有一个离散模型。或者，我们可能选择将交通视为一种流，其中流的变化可以用微分方程描述。这就导致了一个连续模型。在这个例子中，离散模型更接近物理情况（没有人开半辆车，尽管有些车的尺寸是其他车的一半），但计算复杂性大于连续模型。在实践中，模型往往同时具有离散和连续组件。例如，我们可能选择使用离散模型对血液流动进行建模（即，对单个血球建模），并使用连续模型对血压进行建模。
- en: 18.6 Terms Introduced in Chapter
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.6 本章引入的术语
- en: Monte Carlo simulation
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蒙特卡洛仿真
- en: return on investment (ROI)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投资回报率（ROI）
- en: table lookup
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表查找
- en: time/space tradeoff
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间/空间权衡
- en: descriptive model
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述模型
- en: prescriptive model
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处方模型
- en: deterministic simulation
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定性仿真
- en: stochastic simulation
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机仿真
- en: static model
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态模型
- en: dynamic model
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态模型
- en: discrete model
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离散模型
- en: continuous model
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续模型
