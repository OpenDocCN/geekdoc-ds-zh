- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: MONTE CARLO SIMULATION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡罗模拟
- en: In Chapters 16 and 17, we looked at different ways of using randomness in computations.
    Many of the examples we presented fall into the class of computation known as
    **Monte Carlo simulation**. Monte Carlo simulation is a technique used to approximate
    the probability of an event by running the same simulation multiple times and
    averaging the results.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第16章和第17章中，我们探讨了在计算中使用随机性的不同方式。我们呈现的许多示例属于被称为**蒙特卡罗模拟**的计算类别。蒙特卡罗模拟是一种通过多次运行相同模拟并平均结果来近似事件概率的技术。
- en: 'Stanislaw Ulam and Nicholas Metropolis coined the term Monte Carlo simulation
    in 1949 in homage to the games of chance played in the casino in the Principality
    of Monaco. Ulam, who is best known for designing the hydrogen bomb with Edward
    Teller, described the invention of the method as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 斯坦尼斯瓦夫·乌拉姆和尼古拉斯·梅特罗波利斯于1949年创造了“蒙特卡罗模拟”这一术语，以向摩纳哥公国赌场中的机会游戏致敬。乌拉姆以与爱德华·泰勒共同设计氢弹而闻名，他这样描述该方法的发明：
- en: '*The first thoughts and attempts I made to practice [the Monte Carlo Method]
    were suggested by a question which occurred to me in 1946 as I was convalescing
    from an illness and playing solitaires. The question was what are the chances
    that a Canfield solitaire laid out with 52 cards will come out successfully? After
    spending a lot of time trying to estimate them by pure combinatorial calculations,
    I wondered whether a more practical method than “abstract thinking” might not
    be to lay it out say one hundred times and simply observe and count the number
    of successful plays. This was already possible to envisage with the beginning
    of the new era of fast computers,*[*^(124)*](#c18-fn-0001) *and I immediately
    thought of problems of neutron diffusion and other questions of mathematical physics,
    and more generally how to change processes described by certain differential equations
    into an equivalent form interpretable as a succession of random operations. Later
    … [in 1946, I] described the idea to John von Neumann, and we began to plan actual
    calculations.*[*^(125)*](#c18-fn-0002)'
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我对[蒙特卡罗方法]的首次思考和尝试，是在1946年我在康复期间玩接龙时想到的一个问题。这个问题是，一个用52张牌摆成的坎菲尔德接龙成功的机会是多少？在花了大量时间试图通过纯组合计算来估算它们之后，我想知道是否有比“抽象思维”更实际的方法，比如说摆一百次并简单观察和计算成功的次数。随着新一代快速计算机的出现，这已经是可以想象的了，*[*^(124)*](#c18-fn-0001)
    *我立即想到了中子扩散问题和其他数学物理问题，以及更一般地如何将由某些微分方程描述的过程转变为可解释为随机操作序列的等效形式。后来…… [在1946年，我]
    向约翰·冯·诺依曼描述了这个想法，我们开始规划实际计算。*[*^(125)*](#c18-fn-0002)'
- en: The technique was used during the Manhattan Project to predict what would happen
    during a nuclear fission reaction, but did not really take off until the 1950s,
    when computers became both more common and more powerful.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术在曼哈顿计划期间被用来预测核裂变反应会发生什么，但直到1950年代计算机变得更加普及和强大时，它才真正起飞。
- en: Ulam was not the first mathematician to think about using the tools of probability
    to understand a game of chance. The history of probability is intimately connected
    to the history of gambling. It is uncertainty that makes gambling possible. And
    the existence of gambling provoked the development of much of the mathematics
    needed to reason about uncertainty. Contributions to the foundations of probability
    theory by Cardano, Pascal, Fermat, Bernoulli, de Moivre, and Laplace were all
    motivated by a desire to better understand (and perhaps profit from) games of
    chance.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 乌拉姆并不是第一个想到使用概率工具来理解机会游戏的数学家。概率的历史与赌博的历史密切相关。正是这种不确定性使得赌博成为可能。而赌博的存在促使了许多必要的数学的发展，以便更好地推理不确定性。卡尔达诺、帕斯卡尔、费马、伯努利、德摩根和拉普拉斯对概率理论基础的贡献，都是出于希望更好地理解（并可能从中获利）机会游戏的愿望。
- en: 18.1 Pascal's Problem
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.1 帕斯卡尔问题
- en: 'Most of the early work on probability theory revolved around games using dice.[^(126)](#c18-fn-0003)
    Reputedly, Pascal''s interest in the field that came to be known as probability
    theory began when a friend asked him whether it would be profitable to bet that
    within 24 rolls of a pair of dice he would roll a double `6`. This was considered
    a hard problem in the mid-seventeenth century. Pascal and Fermat, two pretty smart
    guys, exchanged a number of letters about how to resolve the issue, but it now
    seems like an easy question to answer:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: On the first roll the probability of rolling a `6` on each die is `1/6`, so
    the probability of rolling a `6` with both dice is `1/36`.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the probability of not rolling a double `6` on the first roll is
    `1 ‑ 1/36 =` `35/36`.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the probability of not rolling `6` on both die 24 consecutive times
    is `(35/36)`^(24), nearly `0.51`, and therefore the probability of rolling a double
    `6` is `1 - (35/36)`^(24), about `0.49`. In the long run, it would not be profitable
    to bet on rolling a double `6` within 24 rolls.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just to be safe, let's write a little program, [Figure 18-1](#c18-fig-0001),
    to simulate Pascal's friend's game and confirm that we get the same answer as
    Pascal. (All of the code in this chapter assumes that
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: occur at the start of the file in which the code occurs.) When run the first
    time, the call `check_pascal(1000000)` printed
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is indeed quite close to `1 - (35/36)`^(24); typing `1-(35.0/36.0)**24`
    into the Python shell produces `0.49140387613090342`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![c18-fig-0001.jpg](../images/c18-fig-0001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: '[Figure 18-1](#c18-fig-0001a) Checking Pascal''s analysis'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 18.2 Pass or Don't Pass?
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not all questions about games of chance are so easily answered. In the game
    craps, the shooter (the person who rolls the dice) chooses between making a “pass
    line” or a “don't pass line” bet.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass Line: Shooter wins if the first roll is a “natural” (`7` or `11`) and
    loses if it is “craps” (`2`, `3`, or `12`). If some other number is rolled, that
    number becomes the “point,” and the shooter keeps rolling. If the shooter rolls
    the point before rolling a `7`, the shooter wins. Otherwise the shooter loses.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Don''t Pass Line: Shooter loses if the first roll is `7` or `11`, wins if it
    is `2` or `3`, and ties (a “push” in gambling jargon) if it is `12`. If some other
    number is rolled, that number becomes the point, and the shooter keeps rolling.
    If the shooter rolls a `7` before rolling the point, the shooter wins. Otherwise
    the shooter loses.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is one of these a better bet than the other? Is either a good bet? It is possible
    to analytically derive the answer to these questions, but it seems easier (at
    least to us) to write a program that simulates a craps game and see what happens.
    [Figure 18-2](#c18-fig-0002) contains the heart of such a simulation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![c18-fig-0002.jpg](../images/c18-fig-0002.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: '[Figure 18-2](#c18-fig-0002a) `Craps_game` class'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The values of the instance variables of an instance of class `Craps_game` record
    the performance of the pass and don't pass lines since the start of the game.
    The observer methods `pass_results` and `dp_results` return these values. The
    method `play_hand` simulates one hand of a game. A “hand” starts when the shooter
    is “coming out,” the term used in craps for a roll before a point is established.
    A hand ends when the shooter has won or lost his or her initial bet. The bulk
    of the code in `play_hand` is merely an algorithmic description of the rules stated
    above. Notice that there is a loop in the `else` clause corresponding to what
    happens after a point is established. It is exited using a `break` statement when
    either a seven or the point is rolled.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-3](#c18-fig-0003) contains a function that uses class `Craps_game`
    to simulate a series of craps games.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![c18-fig-0003.jpg](../images/c18-fig-0003.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: '[Figure 18-3](#c18-fig-0003a) Simulating a craps game'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of `craps_sim` is typical of many simulation programs:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 1\. It runs multiple games (think of each game as analogous to a trial in our
    earlier simulations) and accumulates the results. Each game includes multiple
    hands, so there is a nested loop.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. It then produces and stores statistics for each game.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Finally, it produces and outputs summary statistics. In this case, it prints
    the expected return on investment (ROI) for each kind of betting line and the
    standard deviation of that ROI.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Return on investment** is defined by the equation[^(127)](#c18-fn-0004)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![c18-fig-5001.jpg](../images/c18-fig-5001.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: Since the pass and don't pass lines pay even money (if you bet `$1` and win,
    you gain `$1`), the ROI is
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![c18-fig-5002.jpg](../images/c18-fig-5002.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: For example, if you made `100` pass line bets and won half, your ROI would be
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![c18-fig-5003.jpg](../images/c18-fig-5003.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: If you bet the don't pass line 100 times and had 25 wins and 5 pushes, the ROI
    would be
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![c18-fig-5004.jpg](../images/c18-fig-5004.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: Let's run our craps game simulation and see what happens when we try `craps_sim(20,
    10)`:[^(128)](#c18-fn-0005)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It looks as if it would be a good idea to avoid the pass line—where the expected
    return on investment is a `7%` loss. But the don't pass line looks like a pretty
    good bet. Or does it?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the standard deviations, it seems that perhaps the don't pass line
    is not such a safe bet after all. Recall that under the assumption that the distribution
    is normal, the `95%` confidence interval is encompassed by `1.96` standard deviations
    on either side of the mean. For the don't pass line, the `95%` confidence interval
    is `[4.0–1.96`*`23.5372, 4.0+1.96`*`23.5372]`—roughly `[-43%, +51%]`. That certainly
    doesn't suggest that betting the don't pass line is a sure thing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Time to put the law of large numbers to work; `craps_sim(1000000, 10)` prints
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can now be pretty safe in assuming that neither of these is a good bet.[^(129)](#c18-fn-0006)
    It looks as if the don't pass line might be slightly less bad, but we probably
    shouldn't count on that. If the `95%` confidence intervals for the pass and don't
    pass lines did not overlap, it would be safe to assume that the difference in
    the two means was statistically significant.[^(130)](#c18-fn-0007) However, they
    do overlap, so no conclusion can be safely drawn.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that instead of increasing the number of hands per game, we increased
    the number of games, e.g., by making the call `craps_sim(20, 1000000)`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The standard deviations are high—indicating that the outcome of a single game
    of `20` hands is highly uncertain.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: One of the nice things about simulations is that they make it easy to perform
    “what if” experiments. For example, what if a player could sneak in a pair of
    cheater's dice that favored `5` over `2` (`5` and `2` are on the opposite sides
    of a die)? To test this out, all we have to do is replace the implementation of
    `roll_die` by something like
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This relatively small change in the die makes a dramatic difference in the odds.
    Running `craps_sim(1000000, 10)` yields
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: No wonder casinos go to a lot of trouble to make sure that players don't introduce
    their own dice into the game!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise**: A “big 6” bet pays even money if a 6 is rolled before
    a 7\. Assuming 30 $5 bets per hour, write a Monte Carlo simulation that estimates
    the cost per hour and the standard deviation of that cost of playing “big 6” bets.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 18.3 Using Table Lookup to Improve Performance
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might not want to try running `craps_sim(100000000, 10)` at home. It takes
    a long time to complete on most computers. That raises the question of whether
    there is a simple way to speed up the simulation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of the implementation of the function `craps_sim` is roughly
    *θ*`(``play_hand``)`*`hands_per_game`*`num_games`. The running time of `play_hand`
    depends upon the number of times the loop in it is executed. In principle, the
    loop could be executed an unbounded number of times since there is no bound on
    how long it could take to roll either a `7` or the point. In practice, of course,
    we have every reason to believe it will always terminate.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice, however, that the result of a call to `play_hand` does not depend on
    how many times the loop is executed, but only on which exit condition is reached.
    For each possible point, we can easily calculate the probability of rolling that
    point before rolling a `7`. For example, using a pair of dice we can roll a `4`
    in three different ways: `<1, 3>, <3, 1>,` and `<2, 2>`. We can roll a `7` in
    six different ways`: <1, 6>, <6, 1>, <2, 5>, <5, 2>, <3, 4>`, and `<4, 3>`. Therefore,
    exiting the loop by rolling a `7` is twice as likely as exiting the loop by rolling
    a `4`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-4](#c18-fig-0008) contains an implementation of `play_hand` that
    exploits this thinking. We first compute the probability of making the point before
    rolling a `7` for each possible value of the point and store those values in a
    dictionary. Suppose, for example, that the point is `8`. The shooter continues
    to roll until he either rolls the point or rolls craps. There are five ways of
    rolling an `8` `(<6,2>,` `<2,6>, <5,3>, <3,5>, and <4,4>)` and six ways of rolling
    a `7`. So, the value for the dictionary key `8` is the value of the expression
    `5/11`. Having this table allows us to replace the inner loop, which contained
    an unbounded number of rolls, with a test against one call to `random.random`.
    The asymptotic complexity of this version of `play_hand` is `O(1)`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of replacing computation by **table lookup** has broad applicability
    and is frequently used when speed is an issue. Table lookup is an example of the
    general idea of **trading time for space**. As we saw in Chapter 15, it is the
    key idea behind dynamic programming. We saw another example of this technique
    in our analysis of hashing: the larger the table, the fewer the collisions, and
    the faster the average lookup. In this case, the table is small, so the space
    cost is negligible.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![c18-fig-0004.jpg](../images/c18-fig-0004.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: '[Figure 18-4](#c18-fig-0008a) Using table lookup to improve performance'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 18.4 Finding π
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is easy to see how Monte Carlo simulation is useful for tackling problems
    in which nondeterminism plays a role. Interestingly, however, Monte Carlo simulation
    (and randomized algorithms in general) can be used to solve problems that are
    not inherently stochastic, i.e., for which there is no uncertainty about outcomes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Consider *π*. For thousands of years, people have known that there is a constant
    (called *π* since the eighteenth century) such that the circumference of a circle
    is equal to `π` * `diameter` and the area of the circle equal to *π* * `radius`².
    What they did not know was the value of this constant.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: One of the earliest estimates, `4`*`(8/9)`² `= 3.16`, can found in the Egyptian
    *Rhind Papyrus*, circa 1650 BC. More than a thousand years later, the *Old Testament*
    (1 Kings 7.23) implied a different value for *π* when giving the specifications
    of one of King Solomon's construction projects,
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '*And he made a molten sea, ten cubits from the one brim to the other: it was
    round all about, and his height was five cubits: and a line of 30 cubits did compass
    it round about.*'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Solving for *π*, `10π = 30`, so *π* `= 3`. Perhaps the *Bible* is simply wrong,
    or perhaps the molten sea wasn't perfectly circular, or perhaps the circumference
    was measured from the outside of the wall and the diameter from the inside, or
    perhaps it's just poetic license. We leave it to the reader to decide.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Archimedes of Syracuse (287-212 BCE) derived upper and lower bounds on the value
    of *π* by using a high-degree polygon to approximate a circular shape. Using a
    polygon with `96` sides, he concluded that `223/71 <` *π* `< 22/7`. Giving upper
    and lower bounds was a rather sophisticated approach for the time. If we take
    his best estimate as the average of his two bounds, we obtain `3.1418`, an error
    of about `0.0002`. Not bad! But about 700 years later, the Chinese mathematician
    Zu Chongzhi used a polygon with 24,576 sides to conclude that `3.1415962 <` *π*
    `< 3.1415927\.` About 800 years after that, the Dutch cartographer Adriaan Anthonisz
    (1527-1607) estimated it as `355/113`, roughly3.1415929203539825\. That estimate
    is good enough for most practical purposes, but it didn't keep mathematicians
    from working on the problem.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Long before computers were invented, the French mathematicians Buffon (1707-1788)
    and Laplace (1749-1827) proposed using a stochastic simulation to estimate the
    value of *π*.[^(131)](#c18-fn-0008) Think about inscribing a circle in a square
    with sides of length `2`, so that the radius, r, of the circle is of length `1`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![c18-fig-0005.jpg](../images/c18-fig-0005.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: Figure 18-5 Unit circle inscribed in a square
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: By the definition of *π*, *area* = *πr*². Since `r` is `1`, *π* `= area`. But
    what's the area of the circle? Buffon suggested that he could estimate the area
    of a circle by a dropping a large number of needles (which he argued would follow
    a random path as they fell) in the vicinity of the square. The ratio of the number
    of needles with tips lying within the square to the number of needles with tips
    lying within the circle could then be used to estimate the area of the circle.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: If the locations of the needles are truly random, we know that
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![c18-fig-5005.jpg](../images/c18-fig-5005.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: and solving for the area of the circle,
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![c18-fig-5006.jpg](../images/c18-fig-5006.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: Recall that the area of a `2` by `2` square is `4`, so,
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![c18-fig-5007.jpg](../images/c18-fig-5007.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'In general, to estimate the area of some region `R`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Pick an enclosing region, `E`, such that the area of `E` is easy to calculate
    and `R` lies completely within `E`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Pick a set of random points that lie within `E`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Let `F` be the fraction of the points that fall within `R`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. Multiply the area of `E` by `F`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you try Buffon's experiment, you'll soon realize that the places where the
    needles land are not truly random. Moreover, even if you could drop them randomly,
    it would take a very large number of needles to get an approximation of `π` as
    good as even the *Bible*'s. Fortunately, computers can randomly drop simulated
    needles at a ferocious rate.[^(132)](#c18-fn-0009)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-6](#c18-fig-0013) contains a program that estimates `π` using the
    Buffon-Laplace method. For simplicity, it considers only those needles that fall
    in the upper-right quadrant of the square.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![c18-fig-0006.jpg](../images/c18-fig-0006.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: '[Figure 18-6](#c18-fig-0013a) Estimating π'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-6](#c18-fig-0013a) 估计 π'
- en: The function `throw_needles` simulates dropping a needle by first using `random.random`
    to get a pair of positive Cartesian coordinates (`x` and `y` values) representing
    the position of the needle with respect to the center of the square. It then uses
    the Pythagorean theorem to compute the hypotenuse of the right triangle with base
    `x` and height `y`. This is the distance of the tip of the needle from the origin
    (the center of the square). Since the radius of the circle is `1`, we know that
    the needle lies within the circle if and only if the distance from the origin
    is no greater than `1`. We use this fact to count the number of needles in the
    circle.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `throw_needles` 通过首先使用 `random.random` 获取一对正的笛卡尔坐标（`x` 和 `y` 值），模拟扔掉一根针，这代表了针相对于正方形中心的位置。然后，它使用毕达哥拉斯定理计算以
    `x` 为底、`y` 为高的直角三角形的斜边。这是针尖离原点（正方形的中心）的距离。由于圆的半径为 `1`，我们知道，只有当从原点的距离不大于 `1` 时，针才会落在圆内。我们利用这一事实来计算落在圆内的针的数量。
- en: The function `get_est` uses `throw_needles` to find an estimate of *π* by first
    dropping `num_needles` needles, and then averaging the result over `num_trials`
    trials. It then returns the mean and standard deviation of the trials.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `get_est` 使用 `throw_needles` 通过首先扔掉 `num_needles` 根针，然后对 `num_trials` 次试验的结果取平均，来找出
    *π* 的估计值。它返回试验的均值和标准差。
- en: The function `est_pi` calls `get_est` with an ever-growing number of needles
    until the standard deviation returned by `get_est` is no larger than `precision/1.96\.`
    Under the assumption that the errors are normally distributed, this implies that
    `95%` of the values lie within `precision` of the mean.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `est_pi` 以不断增加的针的数量调用 `get_est`，直到 `get_est` 返回的标准差不大于 `precision/1.96`。在假设误差服从正态分布的前提下，这意味着
    `95%` 的值位于均值的 `precision` 范围内。
- en: When we ran `est_pi(0.01, 100)`, it printed
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `est_pi(0.01, 100)` 时，它打印了
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we would expect, the standard deviations decreased monotonically as we increased
    the number of samples. In the beginning the estimates of the value of `π` also
    improved steadily. Some were above the true value and some below, but each increase
    in `num_needles` led to an improved estimate. With `1000` samples per trial, the
    simulation's estimate was already better than those of the *Bible* and the *Rhind
    Papyrus*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，随着样本数量的增加，标准差单调减少。最开始时，`π` 的估计值也稳步提高。有些高于真实值，有些低于真实值，但每次增加 `num_needles`
    都会导致估计值的改善。在每次试验中使用 `1000` 个样本时，模拟的估计值已经优于*圣经*和*林德纸草书*。
- en: Curiously, the estimate got worse when the number of needles increased from
    `8,000` to `16,000`, since `3.14135` is farther from the true value of `π` than
    is `3.14143`. However, if we look at the ranges defined by one standard deviation
    around each of the means, both ranges contain the true value of *π*, and the range
    associated with the larger sample size is smaller. Even though the estimate generated
    with `16,000` samples happens to be farther from the actual value of *π*, we should
    have more confidence in its accuracy. This is an extremely important notion. It
    is not sufficient to produce a good answer. We have to have a valid reason to
    be confident that it is in fact a good answer. And when we drop a large enough
    number of needles, the small standard deviation gives us reason to be confident
    that we have a correct answer. Right?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，当针的数量从 `8,000` 增加到 `16,000` 时，估计值反而变差，因为 `3.14135` 离真实的 *π* 值比 `3.14143`
    更远。然而，如果我们查看每个均值周围一个标准差所定义的范围，这两个范围都包含真实的 *π* 值，且与较大样本量相关的范围更小。尽管使用 `16,000` 个样本生成的估计恰好离真实的
    *π* 值更远，但我们应该对其准确性更有信心。这是一个极其重要的概念。仅仅给出一个好答案是不够的。我们必须有合理的理由相信它实际上是一个好答案。当我们扔掉足够多的针时，小标准差给我们提供了信心，表明我们得到了正确的答案，对吧？
- en: Not exactly. Having a small standard deviation is a necessary condition for
    having confidence in the validity of the result. It is not a sufficient condition.
    The notion of a statistically valid conclusion should never be confused with the
    notion of a correct conclusion.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不完全是。拥有小的标准差是对结果有效性有信心的必要条件，但不是充分条件。统计有效结论的概念永远不应与正确结论的概念混淆。
- en: Each statistical analysis starts with a set of assumptions. The key assumption
    here is that our simulation is an accurate model of reality. Recall that the design
    of our Buffon-Laplace simulation started with a little algebra demonstrating how
    we could use the ratio of two areas to find the value of *π*. We then translated
    this idea into code that depended upon a little geometry and on the randomness
    of `random.random`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个统计分析都始于一组假设。这里的关键假设是我们的模拟是现实的准确模型。回想一下，我们的布丰-拉普拉斯模拟的设计是从一些代数开始的，这些代数展示了我们如何利用两个区域的比率来找到*π*的值。然后我们将这个想法转化为依赖于一些几何知识和`random.random`随机性的代码。
- en: Let's see what happens if we get any of this wrong. Suppose, for example, we
    replace the `4` in the last line of the function `throw_needles` by a `2`, and
    again run `est_pi(0.01, 100)`. This time it prints
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们在这些方面出错会发生什么。例如，假设我们将函数`throw_needles`最后一行中的`4`替换为`2`，然后再次运行`est_pi(0.01,
    100)`。这次它打印
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The standard deviation for a mere `32,000` needles suggests that we should
    have a fair amount of confidence in the estimate. But what does that really mean?
    It means that we can be reasonably confident that if we were to draw more samples
    from the same distribution, we would get a similar value. It says nothing about
    whether this value is close to the actual value of *π*. If you are going to remember
    only one thing about statistics, remember this: a statistically valid conclusion
    should not be confused with a correct conclusion!'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅`32,000`根针的标准差表明我们对这个估计应该有相当的信心。但这到底意味着什么呢？这意味着我们可以合理地相信，如果我们从同一分布中抽取更多样本，我们会得到一个类似的值。它并未说明这个值是否接近实际的*π*值。如果你要记住关于统计学的一件事，请记住这一点：统计上有效的结论不应与正确的结论混淆！
- en: Before believing the results of a simulation, we need to have confidence both
    that our conceptual model is correct and that we have correctly implemented that
    model. Whenever possible, you should attempt to validate results against reality.
    In this case, you could use some other means to compute an approximation to the
    area of a circle (e.g., physical measurement) and check that the computed value
    of *π* is at least in the right neighborhood.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在相信模拟结果之前，我们需要对我们的概念模型的正确性以及我们是否正确实现了该模型有信心。尽可能地，你应该尝试将结果与现实进行验证。在这种情况下，你可以使用其他方法计算圆的面积的近似值（例如，物理测量），并检查计算得到的*π*值至少是否在正确的范围内。
- en: 18.5 Some Closing Remarks about Simulation Models
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.5 关于模拟模型的一些结束语
- en: For most of the history of science, theorists used mathematical techniques to
    construct purely analytical models that could be used to predict the behavior
    of a system from a set of parameters and initial conditions. This led to the development
    of important mathematical tools ranging from calculus to probability theory. These
    tools helped scientists develop a reasonably accurate understanding of the macroscopic
    physical world.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在科学历史的大部分时间里，理论家们使用数学技术构建纯粹的解析模型，这些模型可以根据一组参数和初始条件预测系统的行为。这导致了重要数学工具的发展，从微积分到概率论。这些工具帮助科学家们对宏观物理世界形成了相对准确的理解。
- en: 'As the twentieth century progressed, the limitations of this approach became
    increasingly clear. Reasons for this include:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 随着二十世纪的进展，这种方法的局限性变得越来越明显。这些原因包括：
- en: An increased interest in the social sciences, e.g., economics, led to a desire
    to construct good models of systems that were not mathematically tractable.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对社会科学（例如经济学）的兴趣增加，促使人们希望构建那些在数学上无法处理的系统的良好模型。
- en: As the systems to be modeled grew increasingly complex, it seemed easier to
    successively refine a series of simulation models than to construct accurate analytic
    models.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着被建模的系统变得越来越复杂，似乎逐步完善一系列模拟模型比构建准确的解析模型要容易得多。
- en: It is often easier to extract useful intermediate results from a simulation
    than from an analytical model, e.g., to play “what if” games.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模拟中提取有用的中间结果往往比从解析模型中提取更容易，例如进行“如果……会怎样”的游戏。
- en: The availability of computers made it feasible to run large-scale simulations.
    Until the advent of the modern computer in the middle of the twentieth century
    the utility of simulation was limited by the time required to perform calculations
    by hand.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机的可用性使得运行大规模模拟成为可能。在二十世纪中叶现代计算机出现之前，模拟的实用性受限于手动计算所需的时间。
- en: Simulation models are **descriptive**, not **prescriptive**. They tell how a
    system works under given conditions; not how to arrange the conditions to make
    the system work best. A simulation does not optimize, it merely describes. That
    is not to say that simulation cannot be used as part of an optimization process.
    For example, simulation is often used as part of a search process in finding an
    optimal set of parameter settings.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真模型是**描述性的**，而不是**处方性的**。它们描述系统在给定条件下如何工作，而不是如何安排条件以使系统表现最佳。仿真并不优化，它只是描述。这并不是说仿真不能作为优化过程的一部分。例如，仿真通常作为寻找最佳参数设置的一部分搜索过程。
- en: 'Simulation models can be classified along three dimensions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真模型可以沿三个维度分类：
- en: Deterministic versus stochastic
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定性与随机性
- en: Static versus dynamic
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态与动态
- en: Discrete versus continuous
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离散与连续
- en: The behavior of a **deterministic simulation** is completely defined by the
    model. Rerunning a simulation will not change the outcome. Deterministic simulations
    are typically used when the system being modeled is itself deterministic but is
    too complex to analyze analytically, e.g., the performance of a processor chip.
    **Stochastic simulations** incorporate randomness in the model. Multiple runs
    of the same model may generate different values. This random element forces us
    to generate many outcomes to see the range of possibilities. The question of whether
    to generate `10` or `1000` or `100,000` outcomes is a statistical question, as
    discussed earlier.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**确定性仿真**的行为完全由模型定义。重新运行仿真不会改变结果。确定性仿真通常用于被建模系统本身也是确定性的情况，但分析过于复杂，例如，处理器芯片的性能。**随机仿真**在模型中引入了随机性。对同一模型的多次运行可能会生成不同的值。这种随机因素迫使我们生成多个结果，以查看可能性的范围。生成`10`、`1000`或`100,000`个结果的问题是一个统计问题，如前所述。'
- en: In a **static model**, time plays no essential role. The needle-dropping simulation
    used to estimate `π` in this chapter is an example of a static simulation. In
    a **dynamic model**, time, or some analog, plays an essential role. In the series
    of random walks simulated in Chapter 16, the number of steps taken was used as
    a surrogate for time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在**静态模型**中，时间没有本质作用。本章中用于估计`π`的针落仿真就是一个静态仿真的例子。在**动态模型**中，时间或某种类似物起着重要作用。在第16章中模拟的一系列随机行走中，所采取的步数被用作时间的替代。
- en: In a **discrete model**, the values of pertinent variables are enumerable, e.g.,
    they are integers. In a **continuous model**, the values of pertinent variables
    range over non-enumerable sets, e.g., the real numbers. Imagine analyzing the
    flow of traffic along a highway. We might choose to model each individual car,
    in which case we have a discrete model. Alternatively, we might choose to treat
    traffic as a flow, where changes in the flow can be described by differential
    equations. This leads to a continuous model. In this example, the discrete model
    more closely resembles the physical situation (nobody drives half a car, though
    some cars are half the size of others), but is more computationally complex than
    a continuous one. In practice, models often have both discrete and continuous
    components. For example, we might choose to model the flow of blood through the
    human body using a discrete model for blood (i.e., modeling individual corpuscles)
    and a continuous model for blood pressure.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在**离散模型**中，相关变量的值是可枚举的，例如，它们是整数。在**连续模型**中，相关变量的值范围在不可枚举的集合上，例如，实数。想象分析高速公路上的交通流。我们可能选择对每辆汽车进行建模，在这种情况下，我们有一个离散模型。或者，我们可能选择将交通视为一种流，其中流的变化可以用微分方程描述。这就导致了一个连续模型。在这个例子中，离散模型更接近物理情况（没有人开半辆车，尽管有些车的尺寸是其他车的一半），但计算复杂性大于连续模型。在实践中，模型往往同时具有离散和连续组件。例如，我们可能选择使用离散模型对血液流动进行建模（即，对单个血球建模），并使用连续模型对血压进行建模。
- en: 18.6 Terms Introduced in Chapter
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.6 本章引入的术语
- en: Monte Carlo simulation
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蒙特卡洛仿真
- en: return on investment (ROI)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投资回报率（ROI）
- en: table lookup
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表查找
- en: time/space tradeoff
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间/空间权衡
- en: descriptive model
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述模型
- en: prescriptive model
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处方模型
- en: deterministic simulation
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定性仿真
- en: stochastic simulation
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机仿真
- en: static model
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态模型
- en: dynamic model
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态模型
- en: discrete model
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离散模型
- en: continuous model
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续模型
