- en: Floating-Point Numbers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点数
- en: 原文：[https://en.algorithmica.org/hpc/arithmetic/float/](https://en.algorithmica.org/hpc/arithmetic/float/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/arithmetic/float/](https://en.algorithmica.org/hpc/arithmetic/float/)
- en: 'The users of floating-point arithmetic deserve one of these IQ bell curve memes
    — because this is how the relationship between it and most people typically proceeds:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点运算的用户应该得到一个这样的智商钟形曲线图——因为这就是它与大多数人通常的关系：
- en: Beginner programmers use it everywhere as if it was some magic unlimited-precision
    data type.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初级程序员到处使用它，就像它是某种魔法无限精度数据类型一样。
- en: Then they discover that `0.1 + 0.2 != 0.3` or some other quirk like that, freak
    out, start thinking that some random error term is added to every computation,
    and for many years avoid any real data types completely.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后他们发现 `0.1 + 0.2 != 0.3` 或者类似的其他怪异现象，感到恐慌，开始认为每次计算都会添加一些随机的误差项，并且多年来完全避免使用任何真实的数据类型。
- en: Then they finally man up, read the specification of how IEEE-754 floats work
    and start using them appropriately.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后他们最终鼓起勇气，阅读了 IEEE-754 浮点数的工作原理规范，并开始适当地使用它们。
- en: Unfortunately, too many people are still at stage 2, breeding various misconceptions
    about floating-point arithmetic — thinking that it is fundamentally imprecise
    and unstable, and slower than integer arithmetic.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，太多的人仍然处于第二阶段，产生了关于浮点运算的各种误解——认为它本质上是不精确和不稳定的，并且比整数运算慢。
- en: '![](../Images/fbc618b7fb6320b8680a6a63a76c34a3.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fbc618b7fb6320b8680a6a63a76c34a3.png)'
- en: But these are all just myths. Floating-point arithmetic is often *faster* than
    integer arithmetic because of specialized instructions, and real number representations
    are thoroughly standardized and follow simple and deterministic rules in terms
    of rounding, allowing you to manage computational errors reliably.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些都只是神话。由于专门的指令，浮点运算通常比整数运算要快，并且实数表示在舍入方面彻底标准化，遵循简单和确定的规则，允许你可靠地管理计算误差。
- en: In fact, it is so reliable that some high-level programming languages, most
    notably JavaScript, don’t have integers at all. In JavaScript, there is only one
    `number` type, which is internally stored as a 64-bit `double`, and due to the
    way floating-point arithmetic works, all integer numbers between $-2^{53}$ and
    $2^{53}$ and results of computations involving them can be stored exactly, so
    from a programmer’s perspective, there is little practical need for a separate
    integer type.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，它如此可靠，以至于一些高级编程语言，最著名的是 JavaScript，根本不提供整数类型。在 JavaScript 中，只有一个 `number`
    类型，它内部以 64 位 `double` 存储的，由于浮点运算的工作方式，所有介于 $-2^{53}$ 和 $2^{53}$ 之间的整数以及涉及它们的计算结果都可以精确存储，因此从程序员的视角来看，几乎没有实际需要单独的整数类型。
- en: One notable exception is when you need to perform bitwise operations with numbers,
    which *floating-point units* (the coprocessors responsible for operations on floating-point
    numbers) typically don’t support. In this case, they need to be converted to integers,
    which is so frequently used in JavaScript-enabled browsers that arm [added a special
    “FJCVTZS” instruction](https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/armv8-a-architecture-2016-additions)
    that stands for “Floating-point Javascript Convert to Signed fixed-point, rounding
    toward Zero” and does what it says it does — converts real to integer the exact
    same way as JavaScript — which is an interesting example of the software-hardware
    feedback loop in action.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显著的例外是当你需要使用数字进行位运算时，通常不支持这种操作的 *浮点单元*（负责浮点数运算的协处理器）通常不支持。在这种情况下，它们需要被转换为整数，这在
    JavaScript 兼容的浏览器中非常频繁地使用，以至于 arm [添加了一个特殊的“FJCVTZS”指令](https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/armv8-a-architecture-2016-additions)，代表“将浮点
    JavaScript 转换为有符号定点，舍入到零”，并且确实按照它所说的那样做——将实数精确转换为整数，就像 JavaScript 一样——这是软件-硬件反馈循环中一个有趣的例子。
- en: But unless you are a JavaScript developer who uses real types exclusively to
    emulate integer arithmetic, you probably need a more in-depth guide about floating-point
    arithmetic, so we are going to start with a broader subject.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但除非你是使用真实类型专门模拟整数运算的 JavaScript 开发者，否则你可能需要一个更深入的关于浮点运算的指南，因此我们将从更广泛的主题开始。
- en: '## [#](https://en.algorithmica.org/hpc/arithmetic/float/#real-number-representations)Real
    Number Representations'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '## [#](https://en.algorithmica.org/hpc/arithmetic/float/#real-number-representations)实数表示'
- en: If you need to deal with real (non-integer) numbers, you have several options
    with varying applicability. Before jumping straight to floating-point numbers,
    which is what most of this article is about, we want to discuss the available
    alternatives and the motivation behind them — after all, people who avoid floating-point
    arithmetic do have a point.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要处理实数（非整数）数字，你有几种选择，适用性各不相同。在直接跳到浮点数之前，这是本文的大部分内容，我们想要讨论可用的替代方案以及背后的动机——毕竟，避免浮点运算的人确实有他们的理由。
- en: '### [#](https://en.algorithmica.org/hpc/arithmetic/float/#symbolic-expressions)Symbolic
    Expressions'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/arithmetic/float/#symbolic-expressions)
    符号表达式'
- en: The first and the most cumbersome approach is to store not the resulting values
    themselves but the algebraic expressions that produce them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种也是最繁琐的方法是存储产生结果的代数表达式，而不是存储结果本身。
- en: 'Here is a simple example. In some applications, such as computational geometry,
    apart from adding, subtracting and multiplying numbers, you also need to divide
    without rounding, producing a rational number, which can be exactly represented
    with a ratio of two integers:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子。在某些应用中，例如计算几何，除了加、减和乘数字外，你还需要进行不四舍五入的除法，产生一个有理数，它可以由两个整数的比例精确表示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This ratio can be made irreducible, which would even make this representation
    unique:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个比例可以被约简，这将使这种表示变得独特：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is how *computer algebra* systems such as WolframAlpha and SageMath work:
    they operate solely on symbolic expressions and avoid evaluating anything as real
    values.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是像 WolframAlpha 和 SageMath 这样的 *计算机代数* 系统是如何工作的：它们仅操作符号表达式，并避免将任何内容作为实值评估。
- en: With this method, you get absolute precision, and it works well when you have
    a limited scope such as only supporting rational numbers. But this comes at a
    large computational cost because in general, you would need to somehow store the
    whole history of operations that led to the result and take it into account each
    time you perform a new operation — which quickly becomes unfeasible as the history
    grows.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你可以获得绝对精度，当你的范围有限，例如只支持有理数时，它效果很好。但是，这需要巨大的计算成本，因为通常你需要以某种方式存储导致结果的所有操作的历史，并在每次执行新操作时考虑这些历史——随着历史的增长，这很快就会变得不可行。
- en: '### [#](https://en.algorithmica.org/hpc/arithmetic/float/#fixed-point-numbers)Fixed-Point
    Numbers'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/arithmetic/float/#fixed-point-numbers)
    固定点数'
- en: Another approach is to stick to integers, but treat them as if they were multiplied
    by a fixed constant. This is essentially the same as changing units of measurement
    for more up-to-scale ones.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是坚持使用整数，但将它们视为乘以一个固定的常数。这本质上等同于改变更大规模测量单位的单位。
- en: 'Because some values can’t be represented exactly, this makes computations imprecise:
    you need to round the results to nearest representable value.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某些值无法精确表示，这使得计算不精确：你需要将结果四舍五入到最近的表示值。
- en: This approach is commonly used in financial software, where you *really* need
    a straightforward way to manage rounding errors so that the final numbers add
    up. For example, NASDAQ uses $\frac{1}{10000}$-th of a dollar as its base unit
    in its stock listings, meaning that you get the precision of exactly 4 digits
    after comma in all transactions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在金融软件中常用，在这些软件中，你需要一个简单的方法来管理舍入误差，以确保最终数字相加。例如，纳斯达克在其股票列表中使用美元的 $\frac{1}{10000}$
    作为其基本单位，这意味着在所有交易中，你都能获得小数点后精确到4位的精度。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Apart from introducing rounding errors, a bigger problem is that they become
    useless when the scaling constant is misplaced. If the numbers you are working
    with are too large, then the internal integer value will overflow, and if the
    numbers are too small, they will be just rounded down to zero. Interestingly,
    the former case once [became an issue](https://www.wsj.com/articles/berkshire-hathaways-stock-price-is-too-much-for-computers-11620168548)
    on NASDAQ when the Berkshire Hathaway stock price approached $\frac{2^{32} - 1}{10000}$
    = $429,496.7295 and could no longer fit in an unsigned 32-bit integer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了引入舍入误差外，更大的问题是，当缩放常数放置不当时，它们变得无用。如果你正在处理的数字太大，则内部整数值将溢出，如果数字太小，它们将被四舍五入到零。有趣的是，这种情况曾经
    [成为问题](https://www.wsj.com/articles/berkshire-hathaways-stock-price-is-too-much-for-computers-11620168548)
    在纳斯达克，当伯克希尔哈撒韦的股价接近 $\frac{2^{32} - 1}{10000}$ = $429,496.7295$ 时，它再也无法适应一个无符号32位整数。
- en: 'This problem makes fixed-point arithmetic fundamentally unsuitable for applications
    where you need to use both small and large numbers, for example, evaluating certain
    physics equations:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题使得定点算术在需要同时使用小数和大数的应用中基本不适用，例如，评估某些物理方程式：
- en: $$ E = m c^2 $$
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: $$ E = m c^2 $$
- en: In this particular one, $m$ is typically of the same order of magnitude as the
    mass of a proton ($1.67 \cdot 10^{-27}$ kg) and $c$ is the speed of light ($3
    \cdot 10^9$ m/s).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，$m$ 通常与质子的质量（$1.67 \cdot 10^{-27}$ kg）处于同一数量级，而 $c$ 是光速（$3 \cdot 10^9$
    m/s）。
- en: '### [#](https://en.algorithmica.org/hpc/arithmetic/float/#floating-point-numbers)Floating-Point
    Numbers'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/arithmetic/float/#floating-point-numbers)浮点数'
- en: In most numerical applications, we are mainly concerned with the relative error.
    We want the result of our computations to differ from the truth by no more than,
    say, $0.01\%$, and we don’t really care what that $0.01\%$ equates to in absolute
    units.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数数值应用中，我们主要关注相对误差。我们希望我们的计算结果与真实值相差不超过，比如说，$0.01\%$，我们并不真正关心这 $0.01\%$ 在绝对单位中等于多少。
- en: 'Floating-point numbers solve this by storing a certain number of the most significant
    digits and the order of magnitude of the number. More precisely, they are represented
    with an integer (called *significand* or *mantissa*) and scaled using an exponent
    of some fixed base — most commonly, 2 or 10\. For example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数通过存储一定数量的最高有效数字和数字的量级来解决这一问题。更精确地说，它们使用一个整数（称为*尾数*或*小数部分*）并通过某个固定基数的指数进行缩放——最常见的是
    2 或 10。例如：
- en: $$ 1.2345 = \underbrace{12345}_\text{mantissa} \times {\underbrace{10}_\text{base}\!\!\!\!}
    ^{\overbrace{-4}^\text{exponent}} $$
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: $$ 1.2345 = \underbrace{12345}_\text{小数部分} \times {\underbrace{10}_\text{基数}\!\!\!\!}
    ^{\overbrace{-4}^\text{指数}} $$
- en: Computers operate on fixed-length binary words, so when designing a floating-point
    format for hardware, you’d want a fixed-length binary format where some bits are
    dedicated for the mantissa (for more precision) and some for the exponent (for
    more range).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机在固定长度的二进制词上操作，因此当为硬件设计浮点数格式时，你希望有一个固定长度的二进制格式，其中一些位专门用于尾数（以获得更高的精度），一些位用于指数（以获得更大的范围）。
- en: 'This handmade float implementation hopefully conveys the idea:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个手工实现的浮点数示例希望传达这个想法：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This way we can represent numbers in the form $\pm \; m \times 2^e$ where both
    $m$ and $e$ are bounded *and possibly negative* integers — which would correspond
    to negative or small numbers respectively. The distribution of these numbers is
    very much non-uniform: there are roughly as many numbers in the $[0, 1)$ range
    as in the $[1, +\infty)$ range.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以用 $\pm \; m \times 2^e$ 的形式来表示数字，其中 $m$ 和 $e$ 都是有限的可能为负的整数——这分别对应于负数或小数。这些数字的分布非常不均匀：在
    $[0, 1)$ 范围内的数字数量与在 $[1, +\infty)$ 范围内的数字数量大致相同。
- en: Note that these representations are not unique for some numbers. For example,
    number $1$ can be represented as
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些表示对于某些数字不是唯一的。例如，数字 $1$ 可以表示为
- en: $$ 1 \times 2^0 = 2 \times 2^{-1} = 256 \times 2^{-8} $$
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: $$ 1 \times 2^0 = 2 \times 2^{-1} = 256 \times 2^{-8} $$
- en: and in 28 other ways that don’t overflow the mantissa.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以及在 28 种其他不会溢出尾数的方式中。
- en: 'This can be problematic for some applications, such as comparisons or hashing.
    To fix this, we can *normalize* these representations using a certain convention.
    In decimal, the [standard form](https://en.wikipedia.org/wiki/Scientific_notation)
    is to always put the comma after the first digit (`6.022e23`), and for binary,
    we can do the same:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这在某些应用中可能会出现问题，例如比较或散列。为了解决这个问题，我们可以使用某种约定来*规范化*这些表示。在十进制中，[标准形式](https://en.wikipedia.org/wiki/Scientific_notation)是将逗号放在第一个数字之后（`6.022e23`），对于二进制，我们可以做同样的事情：
- en: $$ 42 = 10101_2 = 1.0101_2 \times 2^5 $$ Notice that, following this rule, the
    first bit is always 1\. It is redundant to store it explicitly, so we will just
    pretend that it’s there and only store the other bits, which correspond to some
    rational number in the $[0, 1)$ range. The set of representable numbers is now
    roughly $$ \{ \pm \; (1 + m) \cdot 2^e \; | \; m = \frac{x}{2^{32}}, \; x \in
    [0, 2^{32}) \} $$
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: $$ 42 = 10101_2 = 1.0101_2 \times 2^5 $$ 注意，按照这个规则，第一个位总是 1。显式存储它是多余的，所以我们假装它在那里，只存储其他位，这些位对应于
    $[0, 1)$ 范围内的某个有理数。现在可以表示的数字集合大致为 $$ \{ \pm \; (1 + m) \cdot 2^e \; | \; m = \frac{x}{2^{32}},
    \; x \in [0, 2^{32}) \} $$
- en: 'Since $m$ is now a nonnegative value, we will now make it unsigned integer,
    and instead add a separate Boolean field for the sign of the number:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 $m$ 现在是一个非负值，我们将将其作为无符号整数处理，并添加一个单独的布尔字段来表示数字的符号：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let’s try to implement some arithmetic operation — for example, multiplication
    — using our handmade floats. Using the new formula, the result should be:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试实现一些算术运算——例如，乘法——使用我们手工制作的浮点数。使用新的公式，结果应该是：
- en: $$ \begin{aligned} c &= a \cdot b \\ &= (s_a \cdot (1 + m_a) \cdot 2^{e_a})
    \cdot (s_b \cdot (1 + m_b) \cdot 2^{e_b}) \\ &= s_a \cdot s_b \cdot (1 + m_a)
    \cdot (1 + m_b) \cdot 2^{e_a} \cdot 2^{e_b} \\ &= \underbrace{s_a \cdot s_b}_{s_c}
    \cdot (1 + \underbrace{m_a + m_b + m_a \cdot m_b}_{m_c}) \cdot 2^{\overbrace{e_a
    + e_b}^{e_c}} \end{aligned} $$
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: $$ \begin{aligned} c &= a \cdot b \\ &= (s_a \cdot (1 + m_a) \cdot 2^{e_a})
    \cdot (s_b \cdot (1 + m_b) \cdot 2^{e_b}) \\ &= s_a \cdot s_b \cdot (1 + m_a)
    \cdot (1 + m_b) \cdot 2^{e_a} \cdot 2^{e_b} \\ &= \underbrace{s_a \cdot s_b}_{s_c}
    \cdot (1 + \underbrace{m_a + m_b + m_a \cdot m_b}_{m_c}) \cdot 2^{\overbrace{e_a
    + e_b}^{e_c}} \end{aligned} $$
- en: 'The groupings now seem straightforward to calculate, but there are two nuances:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的分组看起来计算起来很简单，但有两大要点：
- en: 'The new mantissa is now in the $[0, 3)$ range. We need to check if it is larger
    than $1$ and normalize the representation, applying the following formula: $1
    + m = (1 + 1) + (m - 1) = (1 + \frac{m - 1}{2}) \cdot 2$.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的尾数现在在 $[0, 3)$ 范围内。我们需要检查它是否大于 $1$ 并规范化表示，应用以下公式：$1 + m = (1 + 1) + (m - 1)
    = (1 + \frac{m - 1}{2}) \cdot 2$。
- en: The resulting number can be (and very likely is) not representable exactly due
    to the lack of precision. We need twice as many bits to account for the $m_a \cdot
    m_b$ term, and the best we can do here is to round it to the nearest representable
    number.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果数字可能（并且很可能）不能精确表示，因为缺乏精度。我们需要两倍的位来考虑 $m_a \cdot m_b$ 项，我们在这里能做的最好的事情是将它四舍五入到最接近的可表示数字。
- en: Since we need some extra bits to properly handle the mantissa overflow issue,
    we will reserve one bit from $m$ thus limiting it to $[0,2^{31})$ range.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要一些额外的位来正确处理尾数溢出问题，我们将从 $m$ 中保留一个位，从而将其限制在 $[0,2^{31})$ 范围内。
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Many applications that require higher levels of precision use software floating-point
    arithmetic in a similar fashion. But of course, you don’t want to execute a sequence
    of 10 or so instructions that this code compiles to each time you want to multiply
    two real numbers, so on modern CPUs, floating-point arithmetic is implemented
    in hardware — usually as separate coprocessors due to its complexity.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 许多需要更高精度级别应用软件使用类似的软件浮点算术。但当然，你不想每次想要乘以两个实数时都执行10条或更多的指令，所以现代CPU上，浮点算术通常在硬件中实现——由于其复杂性，通常作为独立的协处理器。
- en: The *floating-point unit* of x86 (often referred to as x87) has separate registers
    and its own tiny instruction set that supports memory operations, basic arithmetic,
    trigonometry, and some common operations such as logarithm, exponent, and square
    root. To make these operations properly work together, some additional details
    of floating-point number representation need to be clarified — which we will do
    in [the next section](../ieee-754). [← ../Arithmetic](https://en.algorithmica.org/hpc/arithmetic/)[IEEE
    754 Floats →](https://en.algorithmica.org/hpc/arithmetic/ieee-754/)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: x86 的 *浮点单元*（通常称为 x87）有独立的寄存器和自己的小型指令集，支持内存操作、基本算术、三角函数以及一些常见操作，如对数、指数和平方根。为了使这些操作正确地协同工作，需要澄清浮点数表示的一些额外细节——我们将在
    [下一节](../ieee-754) 中进行说明。[← ../Arithmetic](https://en.algorithmica.org/hpc/arithmetic/)[IEEE
    754 浮点数 →](https://en.algorithmica.org/hpc/arithmetic/ieee-754/)
