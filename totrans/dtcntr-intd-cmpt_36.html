<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>12.1Â Mutating StructuresğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>12.1Â Mutating StructuresğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/mutating-structures.html">https://dcic-world.org/2025-08-27/mutating-structures.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._eg-bank-acc%29" class="toclink" data-pltdoc="x">12.1.1Â Example: Bank Accounts</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.Testing_.Functions_that_.Mutate_.Structures%29" class="toclink" data-pltdoc="x">12.1.2Â Testing Functions that Mutate Structures</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._mult-bank-acct%29" class="toclink" data-pltdoc="x">12.1.3Â Aliasing</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._structure-mut-dir%29" class="toclink" data-pltdoc="x">12.1.4Â Structure Mutation and the Directory</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._heap-intro%29" class="toclink" data-pltdoc="x">12.1.4.1Â Introducing the Heap</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._basic-data-heap%29" class="toclink" data-pltdoc="x">12.1.4.2Â Basic Data and the Heap</a></p></td></tr></table><p>We will now study a new kind of data and the programming style that
accompanies it. This will give us both great power and great
responsibility. We will develop this idea in both Pyret and Python,
both because the core concept arises in both (indeed in nearly all)
languages and
because their contrast is instructive.</p><section class="SsectionLevel4" id="section 12.1.1"><h4 class="heading">12.1.1Â <a name="(part._eg-bank-acc)"/>Example: Bank Accounts<a href="#(part._eg-bank-acc)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Imagine that we want to represent bank accounts, where each account
has a (unique) id number and a balance:</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">@dataclass
class Account:
    id: int
    balance: float</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Account:
    account(id :: Number,
    balance :: Number)
end</code></pre></td></tr></table><p>Letâ€™s now make an account:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500)</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500)</code></pre></td></tr></table><p>Now letâ€™s say we learn that the account has just
earned another 200. We could always reflect the resulting account as follows:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(acct1.id, acct1.balance + 200)</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">account(acct1.id, acct1.balance + 200)</code></pre></td></tr></table><p>However, this creates a new account; if we look at the current
<code data-lang="pyret" class="sourceCode">balance</code> of <code data-lang="pyret" class="sourceCode">acct1</code>, by writing <code data-lang="pyret" class="sourceCode">acct1.balance</code>, it is
still <code data-lang="pyret" class="sourceCode">500</code>. If this were our account, we would be quite sad!</p><p>Rather, we want to change the balance in the existing
account. This requires a programming feature that we have not
encountered until now: data that can be changed. Such data are called
mutable, and we explore them below. In contrast, until now we
have worked with immutable data: data that cannot be altered.</p><p>First, we have to declare that the data can be changed. In
Python, this is automatically true, always, so nothing changes. In
Pyret, however, fields cannot be changedâ€”<wbr/>they are
immutableâ€”<wbr/>by default. We have to explicitly say they can be
changed:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">@dataclass
class Account:
    id: int
    balance: float</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Account:
    account(id :: Number,
      ref balance :: Number)
end</code></pre></td></tr></table><p>This Pyret definition says that <code data-lang="pyret" class="sourceCode">id</code> cannot be changed,
while <code data-lang="pyret" class="sourceCode">balance</code> can. This ensures that no programmer can
accidentally change the bank account number. In Python, every
programmer has to make sure they donâ€™t accidentally change it.
(If we did want <code data-lang="pyret" class="sourceCode">id</code> to be mutable in Pyret, we would add a
<code data-lang="pyret" class="sourceCode">ref</code> in front of it, too.)</p><p>With this definition, making accounts looks the same (unsurprisingly
in Python, since nothing has changed):
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500)</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500)</code></pre></td></tr></table><p>When we view the account in Pyret, we see something
special:
</p><blockquote class="SCentered"><p><img src="../Images/f5f80ba55f5bfb86404617db2b19812e.png" alt="" width="193" height="84" data-original-src="https://dcic-world.org/2025-08-27/pyret-output-caution.png"/></p></blockquote><p>The yellow-and-black â€œcaution tapeâ€ indicator is a reminder that the
value can change, so what is shown on screen may not be the current
value.</p><p>Accessing an immutable field in Pyret remains the same:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1.id</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1.id</code></pre></td></tr></table><p>However, accessing a mutable field looks different in Pyret:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1.balance</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1!balance</code></pre></td></tr></table><p>The <code data-lang="pyret" class="sourceCode">!</code> is there to remind that what you are getting is the
current value of <code data-lang="pyret" class="sourceCode">balance</code>, and it may be different later.
Python does not offer a similar syntactic warning, but then again,
recall that every field is always mutable.</p><p>So now letâ€™s see how to change that account balance. For simplicity,
letâ€™s first see how to set the account balance to zero. We use slightly
different syntaxes for it in the two languages:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><p><code data-lang="text/x-python" class="sourceCode">acct1.balance = 0</code></p></td><td><p><code data-lang="pyret" class="sourceCode">acct1!{balance: 0}</code></p></td></tr></table><p>In Pyret, again, we use <code data-lang="pyret" class="sourceCode">!</code> in the syntax for
changing the field: read it as â€œchange the value
now!â€</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>You now know all the parts you need to figure out how to set
<code data-lang="pyret" class="sourceCode">balance</code> to be <code data-lang="pyret" class="sourceCode">200</code> more than its previous value.
Can you figure out how to write that?</p></blockquote></blockquote><p>Hereâ€™s how we combine the piecesâ€”<wbr/>accessing the value and then setting it:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><p><code data-lang="text/x-python" class="sourceCode">acct1.balance = acct1.balance + 200</code></p></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><p><code data-lang="pyret" class="sourceCode">acct1!{balance: acct1!balance + 200}</code></p></td></tr></table><p>While Pyretâ€™s syntax is a little more onerous for changing the value
of one field, it proves to be ligher-weight if we want to change
multiple fields. In Python weâ€™d have to write <code data-lang="pyret" class="sourceCode">acct1.</code> for
each of them, whereas in Pyret we need only the one <code data-lang="pyret" class="sourceCode">acct1!</code>. So
there is a trade-off between the two syntaxes.</p><p>We hadnâ€™t written any tests above. Suppose we had: already we might
notice something a bit odd. Say we had written
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def test_balance():
    assert acct1.balance == 500</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  acct1!balance is 500
end</code></pre></td></tr></table><p>This would pass before we performed the update, but fails after the
update is performed. In Python, tests are run when we call the testing
functions, which we typically do after loading the full file (either
by running them at the prompt or by putting our tests in a separate file).</p><p>In Pyret, tests are run as if they were written at the very bottom of
definitions. Therefore, even if the program looked like this in Pyret:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500)

check:
  acct1!balance is 500
end

acct1!{balance: acct1!balance + 200}</code></pre><p>the test fails. Alternatively, we can write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500)

check:
  acct1!balance is 700
end

acct1!{balance: acct1!balance + 200}</code></pre><p>and it passes, but not if we comment out the update.</p><p>In both languages, then, we see a new phenomenon: tests that are only
sometimes true. This phenomenon is called state. There is
a â€œstateâ€ (a collection of values for the defined names) in which
the balance is <code data-lang="pyret" class="sourceCode">500</code>, and another where it is <code data-lang="pyret" class="sourceCode">700</code>. This is
not merely limited to testing! Testing is just a reflection of what is
going on in the program as it runs. From now on, every programming
instruction will run in some state, and its actions will depend on the
other values in that state. If those values change, the same
instructionâ€”<wbr/>i.e., the same piece of program textâ€”<wbr/>may produce
different answers. This makes programming much harder, and we will
have to get used to the subtleties that come along with it.</p></section><section class="SsectionLevel4" id="section 12.1.2"><h4 class="heading">12.1.2Â <a name="(part._.Testing_.Functions_that_.Mutate_.Structures)"/>Testing Functions that Mutate Structures<a href="#(part._.Testing_.Functions_that_.Mutate_.Structures)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Our example of adding funds to an account corresponds to making a
deposit into a bank account. Letâ€™s turn our balance-updating
expression into a function (named <code data-lang="pyret" class="sourceCode">deposit</code>) that takes the
deposit amount as input. Then, weâ€™ll look at how to write tests for
that function. First, the function definition:</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def deposit(ac: Account, amt: float):
    '''add amt to the account's balance'''
    ac.balance = ac.balance + amt</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun deposit(ac :: Account, amt :: Number):
  doc: "add amt to the account's balance"
  ac!{balance: ac!balance + amt}
end</code></pre></td></tr></table><p>How do we test this?</p><p>In Python, this function does not return anything. In Pyret, the
update operation does return the value being updated, but in a larger
function we canâ€™t always assume that it will be the value
returned. Therefore, we have to set up our test to assume otherwise.</p><p>In general, tests for functions that contain mutation need to have
three to four parts:
</p><ol><li><p>Setup: set up the necessary values to provide the function.</p></li><li><p>Call: call the function.</p></li><li><p>Check: check that the function had the desired behavior.</p></li><li><p>Teardown: restore data to their expected state.</p></li></ol><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def test_deposit():
    # Setup
    a1 = Account(8200, 150)

    # Call
    deposit(a1, 100)

    # Check
    assert a1.balance == 250</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  # Setup
  a1 = account(8200, 150)

  # Call
  deposit(a1, 100)

  # Check
  a1!balance is 250
end</code></pre></td></tr></table><p>In this case we donâ€™t need to perform a Teardown step because we
created data purely for testing the function. But if, for instance, we
had run the test over a dataset whose values matter, we would need to
restore the changes.</p><p>Similarly, the Setup phase needs to make sure that all data have the
right values. Until now, once created, data did not change. But now,
data may have been changed by some other mutations, and this may cause
tests to fail. Therefore, the Setup phase requires not only creating
necessary data but also setting the values of previously-created data
to be what the test expects. (Again, note that in Python it is
difficult to know which fields might have been changed, whereas in
Pyret, we only have to reset the value of mutable fields.)</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write tests for the following function that adds interest to an account balance:</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def add_interest(ac: Account):
    '''increases the account value by 2 percent'''
    ac.balance = ac.balance * 1.02</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun add-interest(ac :: Account):
  doc: "increases the account value by 2 percent"
  ac!{balance: ac!balance * 1.02}
end</code></pre></td></tr></table></blockquote></blockquote></section><section class="SsectionLevel4" id="section 12.1.3"><h4 class="heading">12.1.3Â <a name="(part._mult-bank-acct)"/>Aliasing<a href="#(part._mult-bank-acct)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Now letâ€™s
suppose our bank allows accounts to be shared by multiple customers.
We should thus separate information about customers from that of
the account:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">@dataclass
class Customer:
    name: str
    acct: Account</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Customer:
    cust(name :: String,
      acct :: Account)
end</code></pre></td></tr></table><p>Specifically, suppose we have two accounts (<code data-lang="pyret" class="sourceCode">acct1</code> and
<code data-lang="pyret" class="sourceCode">acct2</code>), where <code data-lang="pyret" class="sourceCode">acct1</code> is owned jointly by Elena and Jorge:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500)
acct2 = Account(8405, 350)
elena = Customer("Elena", acct1)
jorge = Customer("Jorge", acct1)</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500)
acct2 = account(8405, 350)
elena = cust("Elena", acct1)
jorge = cust("Jorge", acct1)</code></pre></td></tr></table><p>Now letâ€™s say Elena earns an additional <code data-lang="pyret" class="sourceCode">150</code>. We want to update
the account to reflect this. How might we do it? First we have to
access the account itself: <code data-lang="pyret" class="sourceCode">elena.acct</code> (in both languages). Then
we would update it using the syntax above:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a = elena.acct
a.balance = a.balance + 150</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a = elena.acct
a!{balance: a!balance + 150}</code></pre></td></tr></table><p>Sure enough, Elenaâ€™s account will now have the value of <code data-lang="pyret" class="sourceCode">850</code>
(the original <code data-lang="pyret" class="sourceCode">500</code>, the bonus of <code data-lang="pyret" class="sourceCode">200</code>, and now the extra
<code data-lang="pyret" class="sourceCode">150</code>):
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert elena.acct.balance == 850</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  elena.acct!balance is 850
end</code></pre></td></tr></table><p>Observe that in Pyret we use <code data-lang="pyret" class="sourceCode">.</code> to get the account but <code data-lang="pyret" class="sourceCode">!</code>
to get the balance: a reminder that Elenaâ€™s account will never change
(the way we have defined the data structure), but that accountâ€™s
balance may and, indeed, does. Between the designs of Python and
Pyret, thereâ€™s a trade-off between convenience and precision.</p><p>The key question now is: what is Jorgeâ€™s balance? Put
differently, will this test pass or fail?
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert jorge.acct.balance == 850</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  jorge.acct!balance is 850
end</code></pre></td></tr></table><p>Or even more simply: what
is the value of this program?
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">jorge.acct.balance</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge.acct!balance</code></pre></td></tr></table><p>There are two very reasonable answers here:
</p><ol><li><p>Going by our prose, Jorgeâ€™s account should also have <code data-lang="pyret" class="sourceCode">850</code>,
because thatâ€™s what it means to â€œshareâ€ an account.</p></li><li><p>Going by the visible code, Jorgeâ€™s account should still have
<code data-lang="pyret" class="sourceCode">700</code>, because the update was made through <code data-lang="pyret" class="sourceCode">elena.acct</code>,
not <code data-lang="pyret" class="sourceCode">jorge.acct</code>.</p></li></ol><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Run the above code and see what you get.</p></blockquote></blockquote><p>What you find is that the above test passes: Jorgeâ€™s account also has
<code data-lang="pyret" class="sourceCode">850</code>. We say that <code data-lang="pyret" class="sourceCode">elena.acct</code> and <code data-lang="pyret" class="sourceCode">jorge.acct</code> are
aliases: they are two different â€œnamesâ€ for the exact same
datum.</p><p>This is not the first time we have had shared data. However, until
now, it hasnâ€™t mattered that the data were aliased. But now
that we have mutation, aliases matter: the balance in
<code data-lang="pyret" class="sourceCode">jorge.acct</code> has changed even though we never made an explicit
change using that name. It is as if <code data-lang="pyret" class="sourceCode">elena.acct</code> exhibited
spooky action at a distance.</p><p>Again, there is a linguistic difference here. Because all fields are
mutable in Python, you have to always be on the alert for
this. Because only <code data-lang="pyret" class="sourceCode">ref</code> fields are mutable in Pyret, you can be
sure that fields accessed through <code data-lang="pyret" class="sourceCode">.</code> will never change in value
over time or even if there are aliases, but those accessed through
<code data-lang="pyret" class="sourceCode">!</code> might change over time (and via aliases).</p></section><section class="SsectionLevel4" id="section 12.1.4"><h4 class="heading">12.1.4Â <a name="(part._structure-mut-dir)"/>Structure Mutation and the Directory<a href="#(part._structure-mut-dir)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Now that we have the ability to mutate the contents of data, we will need to show and then revise our
notion of directories. The directories are essentially the same
between Pyret and Python, with one exception: we have different naming
conventions in the two languages. For instance, we write
<code data-lang="text/x-python" class="sourceCode">Account(8404, 500)</code> in Python versus <code data-lang="pyret" class="sourceCode">account(8404, 500)</code>
in Pyret. It would be annoying to write every one of these twice, with
the only difference being the capitalization. Therefore, where the
only difference is the naming, we will ignore this difference
and show only one version (in this case, the Python version); you
should assume that the exact same thing is true for Pyret, other than
the capitalization.</p><p>As a reminder, here are our initial definitions once again:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500)
acct2 = Account(8405, 325)
elena = Customer("Elena", acct1)
jorge = Customer("Jorge", acct1)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Review the following proposal for the directory contents after running
the initial definitions. Is this what you expect to see?
</p><p>Directory</p><ul><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct2</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Elena", acct1)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Jorge", acct1)</code></pre></li></ul></blockquote></blockquote><p>Thereâ€™s a problem with this version, namely the use of <code data-lang="pyret" class="sourceCode">acct1</code> in
the values associated with <code data-lang="pyret" class="sourceCode">elena</code> and <code data-lang="pyret" class="sourceCode">jorge</code>. Remember,
the values in the directory canâ€™t refer to names in the directory:
both Pyret and Python replace names with their values when evaluating
expressions. Here is the corresponding version of the directory that
uses the value of <code data-lang="text/x-python" class="sourceCode">acct1</code>:
</p><p>Directory</p><ul><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct2</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8405, 325)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Elena", Account(8404, 500))</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Jorge", Account(8404, 500))</code></pre></li></ul><p>Observe that this is also what you would see if you were to evaluate
the corresponding variable names.</p><p>Now, letâ€™s add funds to Elenaâ€™s account:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena.acct.balance = elena.acct.balance + 150</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena.acct!{balance: elena.acct!balance + 150}</code></pre></td></tr></table><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Show how the directory changes if you run the above code.</p></blockquote></blockquote><p>If we follow the code precisely, we might expect the following
directory, in which only the balance in Elenaâ€™s version of the account
changes.</p><p>Directory</p><ul><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct2</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8405, 325)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Elena", Account(8404, 650))</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Jorge", Account(8404, 500))</code></pre></li></ul><p>We know from running the code, however, that the account is aliased,
so that the balances accessible from each of <code data-lang="pyret" class="sourceCode">acct</code>,
<code data-lang="pyret" class="sourceCode">elena.acct</code>, and <code data-lang="pyret" class="sourceCode">jorge.acct</code> all reflect the update. This
suggests that the actual directory should look something like</p><p>Directory</p><ul><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8404, 650)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct2</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8405, 325)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Elena", Account(8404, 650))</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Jorge", Account(8404, 650))</code></pre></li></ul><p>But this is also weird. The directory represents the information that
Pyret or Python maintain about your defined names and their
values. What in the directory indicates that those three balances should
change, but not the balance of <code data-lang="pyret" class="sourceCode">acct2</code>)? Put differently, what reflects the aliasing? Nothing!</p><p>The directory as we have used it up until now works fine for programs
without mutation. But once we have both mutation and aliasing, this
simple idea of mapping names to values breaks down because it
doesnâ€™t capture the aliases. We need a refined representation of the
connections between names and values that does capture aliasing.</p><section class="SsectionLevel5" id="section 12.1.4.1"><h5 class="heading">12.1.4.1Â <a name="(part._heap-intro)"/>Introducing the Heap<a href="#(part._heap-intro)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Our original presentation of the directory reflected the aliases that referred to a single
<code data-lang="pyret" class="sourceCode">Account</code> through repeated use of the name <code data-lang="pyret" class="sourceCode">acct1</code>. We only
lost that sharing when we replaced <code data-lang="pyret" class="sourceCode">acct1</code> with itâ€™s value while
setting up the data for Elena and Jorge. The rule that names canâ€™t
appear in the values is still important, especially in the presence of
mutation (weâ€™ll return to this later in <a href="mutating-variables.html#%28part._mutating-vars-memory%29" data-pltdoc="x">Mutating Variables in Memory</a>). But the idea
of having a single term that can be reused to reflect sharing is a
good one. Indeed, it reflects what happens inside your computer.</p><p>Every time you use a constructor to create data, your programming
environment stores it in the memory of your computer. Memory
consists of a (large) number of slots. Your newly-created datum goes
into one of these slots. Each slot is labeled with an
address. Just as a street address refers to a specific building,
a memory address refers to a specific slot where a datum is
stored. Memory slots are physical entities, not conceptual ones. A
computer with a 500GB hard drive has about 500 billion slots in which it can
store data. Not all of that memory is available to your programming
environment: your Web browser, applications, operating system, and so on all
get stored in the memory. Your programming environment does get a
portion of memory to use for storing its data. That portion is called
the heap.</p><p>When you write a statement like</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500)</code></pre><p>your programming environment puts the new <code data-lang="text/x-python" class="sourceCode">Account</code> into a
physical slot in the heap, then associates the address of that
slot with the variable name in the directory. The name in the
directory doesnâ€™t map to the value itself, but rather to the
address that holds the value. The address bridges
between the physical storage location and the conceptual name you want
to associate with the new datum. In other words, our directory really
looks like:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></p></li></ul><p>Our revised version has two separate areas: the directory (mapping
names to addresses) and the heap (showing the values stored
at the
addresses). We will use four-digit numbers for addresses, prefixed
with an @ symbol (reserving numbers with fewer digits for data
values). The specific number for the initial address (here 1001) is
arbitrary. Subsequent storage of structured data values will use the
addresses in order. Letâ€™s write out the directory and heap
contents for our initial definitions of accounts in this new format,
and see how it supports the aliasing that we intended.</p><p>First, we create both <code data-lang="pyret" class="sourceCode">acct1</code> and <code data-lang="pyret" class="sourceCode">acct2</code> in order as
follows. Note that the <code data-lang="pyret" class="sourceCode">Account</code> associated with name
<code data-lang="pyret" class="sourceCode">acct2</code> goes in address 1002.</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct2</code></pre><p>Â â†’Â 1002</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></p></li><li><p>1002:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></p></li></ul><p>When we run
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena = Customer("Elena", acct1)</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena = customer("Elena", acct1)</code></pre></td></tr></table><p>what happens? As before, we look up what the name <code data-lang="pyret" class="sourceCode">acct1</code> refers
to in the directory and substitute the result for the name in the
<code data-lang="pyret" class="sourceCode">Customer</code> data. Now,
<code data-lang="pyret" class="sourceCode">acct1</code> evaluates to an address, 1001. Therefore,
the <code data-lang="pyret" class="sourceCode">Customer</code> value in the heap contains an address:
</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre><p>Â â†’Â 1002</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></p></li><li><p>1002:Â <code data-lang="pyret" class="sourceCode">Customer("Elena", 1001)</code></p></li></ul><p>Similarly, when we run
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">jorge = Customer("Jorge", acct1)</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge = customer("Jorge", acct1)</code></pre></td></tr></table><p>the directory and heap look like this:
</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct2</code></pre><p>Â â†’Â 1002</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre><p>Â â†’Â 1003</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">jorge</code></pre><p>Â â†’Â 1004</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="text/x-python" class="sourceCode">Account(8404, 500)</code></p></li><li><p>1002:Â <code data-lang="text/x-python" class="sourceCode">Account(8405, 3250)</code></p></li><li><p>1003:Â <code data-lang="text/x-python" class="sourceCode">Customer("Elena", 1001)</code></p></li><li><p>1004:Â <code data-lang="text/x-python" class="sourceCode">Customer("Jorge", 1001)</code></p></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Fun fact in the Web version of the book: Did you try hovering over the addresses? Try it now!</p></blockquote></blockquote><p>With the heap articulated separately from the directory, we now see
the relationship between the <code data-lang="text/x-python" class="sourceCode">acct</code> fields
for the two customers and the name <code data-lang="pyret" class="sourceCode">acct1</code>: they refer to the same address, which in
turn means they refer to the same value. In contrast, the name
<code data-lang="pyret" class="sourceCode">acct2</code>, which was not aliased in the original code, refers to an
address that is not referenced anywhere else. This is the heart of
aliasing: thatâ€™s why changes made through one name also affect values
viewed through another.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write three distinct expressions each of which uses a different name in the
directory to return the balance in account <code data-lang="pyret" class="sourceCode">acct1</code>.</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Would the following statement work to update the balance in Elena and
Jorgeâ€™s shared account?
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena.acct.balance = jorge.acct.balance - 50</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena.acct!{balance: jorge.acct!balance - 50}</code></pre></td></tr></table><p>Does this seem like a good or bad way to do this computation? Why?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Extend the most recent directory and heap contents to reflect running
the following statement:
</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct3 = acct1</code></pre><p>Did you change the heap in the previous exercise? Should you have?</p></blockquote></blockquote><p>Three rules guide how the directory and heap are affected by running
programs:</p><ol><li><p>If the code construct a new piece of structured data, put the
new piece of structured data at the next address in the heap.</p></li><li><p>If the code associates a name with a piece of structured data,
the directory should map the name to the address of the datum in the
heap.</p></li><li><p>If the code modifies a field within structured data, modify the
data in the heap.</p></li></ol><p>In the example above, we did not alter the heap in any way; only the
directory should be modified to reflect that <code data-lang="text/x-python" class="sourceCode">acct3</code> and
<code data-lang="text/x-python" class="sourceCode">acct1</code> are now aliases.</p></section><section class="SsectionLevel5" id="section 12.1.4.2"><h5 class="heading">12.1.4.2Â <a name="(part._basic-data-heap)"/>Basic Data and the Heap<a href="#(part._basic-data-heap)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>The above rules donâ€™t indicate what happens when we have basic data,
such as numbers or strings, associated with names in the directory. Do
those values also get addresses in the heap?</p><p>They do not. As our example with shared accounts illustrated, we need
the heap so that updates to fields of shared data affect all aliases
(names that refer to) those data. Basic data donâ€™t have fields, so
there is no need to put them in the heap. Hereâ€™s a concrete example:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x = 4
prof = "Dr. Kumar"</code></pre><p>The corresponding directory and heap contents would be as follows:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">4</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">prof</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">"Dr. Kumar"</code></p></li></ul><p>Notice that this particular program puts nothing in the heap:
according to our rules above, only structured data only go into the
heap. Now assume our program also had a dataclass (Python) or datatype (Pyret)
for <code data-lang="text/x-python" class="sourceCode">Office</code>s, with a professorâ€™s name and room number. Hereâ€™s
another example showing a combination of basic and structured data:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x = 4
prof = "Dr. Kumar"
office1 = Office("Dr. Lakshmi", 311)
office2 = Office(prof, 310 + x)</code></pre><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">4</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">prof</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">"Dr. Kumar"</code></p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">office1</code></pre><p>Â â†’Â 1005</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">office2</code></pre><p>Â â†’Â 1006</p></li></ul><p>Heap</p><ul><li><p>1005:Â <code data-lang="text/x-python" class="sourceCode">Office("Dr. Lakshmi", 311)</code></p></li><li><p>1006:Â <code data-lang="text/x-python" class="sourceCode">Office("Dr. Kumar", 314)</code></p></li></ul><p>Though specific language implementations can vary, this shows that
it is sufficient to think of basic data as residing
in the directory, not the heap. The
whole point of structured data is that they have both their own
identity and multiple components. The heap gives access to both
concepts. Basic data canâ€™t be broken down (by definition). As such,
there is nothing lost by putting them only in the directory.</p><p>But what about strings? Weâ€™ve referred to them as basic data
until now, but donâ€™t they have â€œcomponentsâ€, namely the
characters that make up the string? Yes, that is technically
accurate. However, we are treating strings as basic data because we
arenâ€™t using operations that modify that sequence of characters. This is
a subtle point, one that usually comes up later in computer science.
This book
will leave strings in the directory, but if you are writing programs
that modify the internal characters, put them in the heap instead.</p></section></section>&#13;
<h4 class="heading">12.1.1Â <a name="(part._eg-bank-acc)"/>Example: Bank Accounts<a href="#(part._eg-bank-acc)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Imagine that we want to represent bank accounts, where each account
has a (unique) id number and a balance:</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">@dataclass
class Account:
    id: int
    balance: float</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Account:
    account(id :: Number,
    balance :: Number)
end</code></pre></td></tr></table><p>Letâ€™s now make an account:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500)</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500)</code></pre></td></tr></table><p>Now letâ€™s say we learn that the account has just
earned another 200. We could always reflect the resulting account as follows:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(acct1.id, acct1.balance + 200)</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">account(acct1.id, acct1.balance + 200)</code></pre></td></tr></table><p>However, this creates a new account; if we look at the current
<code data-lang="pyret" class="sourceCode">balance</code> of <code data-lang="pyret" class="sourceCode">acct1</code>, by writing <code data-lang="pyret" class="sourceCode">acct1.balance</code>, it is
still <code data-lang="pyret" class="sourceCode">500</code>. If this were our account, we would be quite sad!</p><p>Rather, we want to change the balance in the existing
account. This requires a programming feature that we have not
encountered until now: data that can be changed. Such data are called
mutable, and we explore them below. In contrast, until now we
have worked with immutable data: data that cannot be altered.</p><p>First, we have to declare that the data can be changed. In
Python, this is automatically true, always, so nothing changes. In
Pyret, however, fields cannot be changedâ€”<wbr/>they are
immutableâ€”<wbr/>by default. We have to explicitly say they can be
changed:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">@dataclass
class Account:
    id: int
    balance: float</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Account:
    account(id :: Number,
      ref balance :: Number)
end</code></pre></td></tr></table><p>This Pyret definition says that <code data-lang="pyret" class="sourceCode">id</code> cannot be changed,
while <code data-lang="pyret" class="sourceCode">balance</code> can. This ensures that no programmer can
accidentally change the bank account number. In Python, every
programmer has to make sure they donâ€™t accidentally change it.
(If we did want <code data-lang="pyret" class="sourceCode">id</code> to be mutable in Pyret, we would add a
<code data-lang="pyret" class="sourceCode">ref</code> in front of it, too.)</p><p>With this definition, making accounts looks the same (unsurprisingly
in Python, since nothing has changed):
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500)</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500)</code></pre></td></tr></table><p>When we view the account in Pyret, we see something
special:
</p><blockquote class="SCentered"><p><img src="../Images/f5f80ba55f5bfb86404617db2b19812e.png" alt="" width="193" height="84" data-original-src="https://dcic-world.org/2025-08-27/pyret-output-caution.png"/></p></blockquote><p>The yellow-and-black â€œcaution tapeâ€ indicator is a reminder that the
value can change, so what is shown on screen may not be the current
value.</p><p>Accessing an immutable field in Pyret remains the same:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1.id</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1.id</code></pre></td></tr></table><p>However, accessing a mutable field looks different in Pyret:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1.balance</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1!balance</code></pre></td></tr></table><p>The <code data-lang="pyret" class="sourceCode">!</code> is there to remind that what you are getting is the
current value of <code data-lang="pyret" class="sourceCode">balance</code>, and it may be different later.
Python does not offer a similar syntactic warning, but then again,
recall that every field is always mutable.</p><p>So now letâ€™s see how to change that account balance. For simplicity,
letâ€™s first see how to set the account balance to zero. We use slightly
different syntaxes for it in the two languages:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><p><code data-lang="text/x-python" class="sourceCode">acct1.balance = 0</code></p></td><td><p><code data-lang="pyret" class="sourceCode">acct1!{balance: 0}</code></p></td></tr></table><p>In Pyret, again, we use <code data-lang="pyret" class="sourceCode">!</code> in the syntax for
changing the field: read it as â€œchange the value
now!â€</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>You now know all the parts you need to figure out how to set
<code data-lang="pyret" class="sourceCode">balance</code> to be <code data-lang="pyret" class="sourceCode">200</code> more than its previous value.
Can you figure out how to write that?</p></blockquote></blockquote><p>Hereâ€™s how we combine the piecesâ€”<wbr/>accessing the value and then setting it:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><p><code data-lang="text/x-python" class="sourceCode">acct1.balance = acct1.balance + 200</code></p></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><p><code data-lang="pyret" class="sourceCode">acct1!{balance: acct1!balance + 200}</code></p></td></tr></table><p>While Pyretâ€™s syntax is a little more onerous for changing the value
of one field, it proves to be ligher-weight if we want to change
multiple fields. In Python weâ€™d have to write <code data-lang="pyret" class="sourceCode">acct1.</code> for
each of them, whereas in Pyret we need only the one <code data-lang="pyret" class="sourceCode">acct1!</code>. So
there is a trade-off between the two syntaxes.</p><p>We hadnâ€™t written any tests above. Suppose we had: already we might
notice something a bit odd. Say we had written
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def test_balance():
    assert acct1.balance == 500</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  acct1!balance is 500
end</code></pre></td></tr></table><p>This would pass before we performed the update, but fails after the
update is performed. In Python, tests are run when we call the testing
functions, which we typically do after loading the full file (either
by running them at the prompt or by putting our tests in a separate file).</p><p>In Pyret, tests are run as if they were written at the very bottom of
definitions. Therefore, even if the program looked like this in Pyret:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500)

check:
  acct1!balance is 500
end

acct1!{balance: acct1!balance + 200}</code></pre><p>the test fails. Alternatively, we can write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500)

check:
  acct1!balance is 700
end

acct1!{balance: acct1!balance + 200}</code></pre><p>and it passes, but not if we comment out the update.</p><p>In both languages, then, we see a new phenomenon: tests that are only
sometimes true. This phenomenon is called state. There is
a â€œstateâ€ (a collection of values for the defined names) in which
the balance is <code data-lang="pyret" class="sourceCode">500</code>, and another where it is <code data-lang="pyret" class="sourceCode">700</code>. This is
not merely limited to testing! Testing is just a reflection of what is
going on in the program as it runs. From now on, every programming
instruction will run in some state, and its actions will depend on the
other values in that state. If those values change, the same
instructionâ€”<wbr/>i.e., the same piece of program textâ€”<wbr/>may produce
different answers. This makes programming much harder, and we will
have to get used to the subtleties that come along with it.</p>&#13;
<h4 class="heading">12.1.2Â <a name="(part._.Testing_.Functions_that_.Mutate_.Structures)"/>Testing Functions that Mutate Structures<a href="#(part._.Testing_.Functions_that_.Mutate_.Structures)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Our example of adding funds to an account corresponds to making a
deposit into a bank account. Letâ€™s turn our balance-updating
expression into a function (named <code data-lang="pyret" class="sourceCode">deposit</code>) that takes the
deposit amount as input. Then, weâ€™ll look at how to write tests for
that function. First, the function definition:</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def deposit(ac: Account, amt: float):
    '''add amt to the account's balance'''
    ac.balance = ac.balance + amt</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun deposit(ac :: Account, amt :: Number):
  doc: "add amt to the account's balance"
  ac!{balance: ac!balance + amt}
end</code></pre></td></tr></table><p>How do we test this?</p><p>In Python, this function does not return anything. In Pyret, the
update operation does return the value being updated, but in a larger
function we canâ€™t always assume that it will be the value
returned. Therefore, we have to set up our test to assume otherwise.</p><p>In general, tests for functions that contain mutation need to have
three to four parts:
</p><ol><li><p>Setup: set up the necessary values to provide the function.</p></li><li><p>Call: call the function.</p></li><li><p>Check: check that the function had the desired behavior.</p></li><li><p>Teardown: restore data to their expected state.</p></li></ol><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def test_deposit():
    # Setup
    a1 = Account(8200, 150)

    # Call
    deposit(a1, 100)

    # Check
    assert a1.balance == 250</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  # Setup
  a1 = account(8200, 150)

  # Call
  deposit(a1, 100)

  # Check
  a1!balance is 250
end</code></pre></td></tr></table><p>In this case we donâ€™t need to perform a Teardown step because we
created data purely for testing the function. But if, for instance, we
had run the test over a dataset whose values matter, we would need to
restore the changes.</p><p>Similarly, the Setup phase needs to make sure that all data have the
right values. Until now, once created, data did not change. But now,
data may have been changed by some other mutations, and this may cause
tests to fail. Therefore, the Setup phase requires not only creating
necessary data but also setting the values of previously-created data
to be what the test expects. (Again, note that in Python it is
difficult to know which fields might have been changed, whereas in
Pyret, we only have to reset the value of mutable fields.)</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Write tests for the following function that adds interest to an account balance:</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">def add_interest(ac: Account):
    '''increases the account value by 2 percent'''
    ac.balance = ac.balance * 1.02</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun add-interest(ac :: Account):
  doc: "increases the account value by 2 percent"
  ac!{balance: ac!balance * 1.02}
end</code></pre></td></tr></table></blockquote></blockquote>&#13;
<h4 class="heading">12.1.3Â <a name="(part._mult-bank-acct)"/>Aliasing<a href="#(part._mult-bank-acct)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Now letâ€™s
suppose our bank allows accounts to be shared by multiple customers.
We should thus separate information about customers from that of
the account:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">@dataclass
class Customer:
    name: str
    acct: Account</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Customer:
    cust(name :: String,
      acct :: Account)
end</code></pre></td></tr></table><p>Specifically, suppose we have two accounts (<code data-lang="pyret" class="sourceCode">acct1</code> and
<code data-lang="pyret" class="sourceCode">acct2</code>), where <code data-lang="pyret" class="sourceCode">acct1</code> is owned jointly by Elena and Jorge:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500)
acct2 = Account(8405, 350)
elena = Customer("Elena", acct1)
jorge = Customer("Jorge", acct1)</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1 = account(8404, 500)
acct2 = account(8405, 350)
elena = cust("Elena", acct1)
jorge = cust("Jorge", acct1)</code></pre></td></tr></table><p>Now letâ€™s say Elena earns an additional <code data-lang="pyret" class="sourceCode">150</code>. We want to update
the account to reflect this. How might we do it? First we have to
access the account itself: <code data-lang="pyret" class="sourceCode">elena.acct</code> (in both languages). Then
we would update it using the syntax above:
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a = elena.acct
a.balance = a.balance + 150</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a = elena.acct
a!{balance: a!balance + 150}</code></pre></td></tr></table><p>Sure enough, Elenaâ€™s account will now have the value of <code data-lang="pyret" class="sourceCode">850</code>
(the original <code data-lang="pyret" class="sourceCode">500</code>, the bonus of <code data-lang="pyret" class="sourceCode">200</code>, and now the extra
<code data-lang="pyret" class="sourceCode">150</code>):
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert elena.acct.balance == 850</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  elena.acct!balance is 850
end</code></pre></td></tr></table><p>Observe that in Pyret we use <code data-lang="pyret" class="sourceCode">.</code> to get the account but <code data-lang="pyret" class="sourceCode">!</code>
to get the balance: a reminder that Elenaâ€™s account will never change
(the way we have defined the data structure), but that accountâ€™s
balance may and, indeed, does. Between the designs of Python and
Pyret, thereâ€™s a trade-off between convenience and precision.</p><p>The key question now is: what is Jorgeâ€™s balance? Put
differently, will this test pass or fail?
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">assert jorge.acct.balance == 850</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  jorge.acct!balance is 850
end</code></pre></td></tr></table><p>Or even more simply: what
is the value of this program?
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">jorge.acct.balance</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge.acct!balance</code></pre></td></tr></table><p>There are two very reasonable answers here:
</p><ol><li><p>Going by our prose, Jorgeâ€™s account should also have <code data-lang="pyret" class="sourceCode">850</code>,
because thatâ€™s what it means to â€œshareâ€ an account.</p></li><li><p>Going by the visible code, Jorgeâ€™s account should still have
<code data-lang="pyret" class="sourceCode">700</code>, because the update was made through <code data-lang="pyret" class="sourceCode">elena.acct</code>,
not <code data-lang="pyret" class="sourceCode">jorge.acct</code>.</p></li></ol><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Run the above code and see what you get.</p></blockquote></blockquote><p>What you find is that the above test passes: Jorgeâ€™s account also has
<code data-lang="pyret" class="sourceCode">850</code>. We say that <code data-lang="pyret" class="sourceCode">elena.acct</code> and <code data-lang="pyret" class="sourceCode">jorge.acct</code> are
aliases: they are two different â€œnamesâ€ for the exact same
datum.</p><p>This is not the first time we have had shared data. However, until
now, it hasnâ€™t mattered that the data were aliased. But now
that we have mutation, aliases matter: the balance in
<code data-lang="pyret" class="sourceCode">jorge.acct</code> has changed even though we never made an explicit
change using that name. It is as if <code data-lang="pyret" class="sourceCode">elena.acct</code> exhibited
spooky action at a distance.</p><p>Again, there is a linguistic difference here. Because all fields are
mutable in Python, you have to always be on the alert for
this. Because only <code data-lang="pyret" class="sourceCode">ref</code> fields are mutable in Pyret, you can be
sure that fields accessed through <code data-lang="pyret" class="sourceCode">.</code> will never change in value
over time or even if there are aliases, but those accessed through
<code data-lang="pyret" class="sourceCode">!</code> might change over time (and via aliases).</p>&#13;
<h4 class="heading">12.1.4Â <a name="(part._structure-mut-dir)"/>Structure Mutation and the Directory<a href="#(part._structure-mut-dir)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Now that we have the ability to mutate the contents of data, we will need to show and then revise our
notion of directories. The directories are essentially the same
between Pyret and Python, with one exception: we have different naming
conventions in the two languages. For instance, we write
<code data-lang="text/x-python" class="sourceCode">Account(8404, 500)</code> in Python versus <code data-lang="pyret" class="sourceCode">account(8404, 500)</code>
in Pyret. It would be annoying to write every one of these twice, with
the only difference being the capitalization. Therefore, where the
only difference is the naming, we will ignore this difference
and show only one version (in this case, the Python version); you
should assume that the exact same thing is true for Pyret, other than
the capitalization.</p><p>As a reminder, here are our initial definitions once again:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500)
acct2 = Account(8405, 325)
elena = Customer("Elena", acct1)
jorge = Customer("Jorge", acct1)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Review the following proposal for the directory contents after running
the initial definitions. Is this what you expect to see?
</p><p>Directory</p><ul><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct2</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Elena", acct1)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Jorge", acct1)</code></pre></li></ul></blockquote></blockquote><p>Thereâ€™s a problem with this version, namely the use of <code data-lang="pyret" class="sourceCode">acct1</code> in
the values associated with <code data-lang="pyret" class="sourceCode">elena</code> and <code data-lang="pyret" class="sourceCode">jorge</code>. Remember,
the values in the directory canâ€™t refer to names in the directory:
both Pyret and Python replace names with their values when evaluating
expressions. Here is the corresponding version of the directory that
uses the value of <code data-lang="text/x-python" class="sourceCode">acct1</code>:
</p><p>Directory</p><ul><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct2</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8405, 325)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Elena", Account(8404, 500))</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Jorge", Account(8404, 500))</code></pre></li></ul><p>Observe that this is also what you would see if you were to evaluate
the corresponding variable names.</p><p>Now, letâ€™s add funds to Elenaâ€™s account:
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena.acct.balance = elena.acct.balance + 150</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena.acct!{balance: elena.acct!balance + 150}</code></pre></td></tr></table><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Show how the directory changes if you run the above code.</p></blockquote></blockquote><p>If we follow the code precisely, we might expect the following
directory, in which only the balance in Elenaâ€™s version of the account
changes.</p><p>Directory</p><ul><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct2</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8405, 325)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Elena", Account(8404, 650))</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Jorge", Account(8404, 500))</code></pre></li></ul><p>We know from running the code, however, that the account is aliased,
so that the balances accessible from each of <code data-lang="pyret" class="sourceCode">acct</code>,
<code data-lang="pyret" class="sourceCode">elena.acct</code>, and <code data-lang="pyret" class="sourceCode">jorge.acct</code> all reflect the update. This
suggests that the actual directory should look something like</p><p>Directory</p><ul><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct1</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8404, 650)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">acct2</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Account(8405, 325)</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Elena", Account(8404, 650))</code></pre></li><li><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge</code></pre><p>Â â†’Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Customer("Jorge", Account(8404, 650))</code></pre></li></ul><p>But this is also weird. The directory represents the information that
Pyret or Python maintain about your defined names and their
values. What in the directory indicates that those three balances should
change, but not the balance of <code data-lang="pyret" class="sourceCode">acct2</code>)? Put differently, what reflects the aliasing? Nothing!</p><p>The directory as we have used it up until now works fine for programs
without mutation. But once we have both mutation and aliasing, this
simple idea of mapping names to values breaks down because it
doesnâ€™t capture the aliases. We need a refined representation of the
connections between names and values that does capture aliasing.</p><section class="SsectionLevel5" id="section 12.1.4.1"><h5 class="heading">12.1.4.1Â <a name="(part._heap-intro)"/>Introducing the Heap<a href="#(part._heap-intro)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Our original presentation of the directory reflected the aliases that referred to a single
<code data-lang="pyret" class="sourceCode">Account</code> through repeated use of the name <code data-lang="pyret" class="sourceCode">acct1</code>. We only
lost that sharing when we replaced <code data-lang="pyret" class="sourceCode">acct1</code> with itâ€™s value while
setting up the data for Elena and Jorge. The rule that names canâ€™t
appear in the values is still important, especially in the presence of
mutation (weâ€™ll return to this later in <a href="mutating-variables.html#%28part._mutating-vars-memory%29" data-pltdoc="x">Mutating Variables in Memory</a>). But the idea
of having a single term that can be reused to reflect sharing is a
good one. Indeed, it reflects what happens inside your computer.</p><p>Every time you use a constructor to create data, your programming
environment stores it in the memory of your computer. Memory
consists of a (large) number of slots. Your newly-created datum goes
into one of these slots. Each slot is labeled with an
address. Just as a street address refers to a specific building,
a memory address refers to a specific slot where a datum is
stored. Memory slots are physical entities, not conceptual ones. A
computer with a 500GB hard drive has about 500 billion slots in which it can
store data. Not all of that memory is available to your programming
environment: your Web browser, applications, operating system, and so on all
get stored in the memory. Your programming environment does get a
portion of memory to use for storing its data. That portion is called
the heap.</p><p>When you write a statement like</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500)</code></pre><p>your programming environment puts the new <code data-lang="text/x-python" class="sourceCode">Account</code> into a
physical slot in the heap, then associates the address of that
slot with the variable name in the directory. The name in the
directory doesnâ€™t map to the value itself, but rather to the
address that holds the value. The address bridges
between the physical storage location and the conceptual name you want
to associate with the new datum. In other words, our directory really
looks like:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></p></li></ul><p>Our revised version has two separate areas: the directory (mapping
names to addresses) and the heap (showing the values stored
at the
addresses). We will use four-digit numbers for addresses, prefixed
with an @ symbol (reserving numbers with fewer digits for data
values). The specific number for the initial address (here 1001) is
arbitrary. Subsequent storage of structured data values will use the
addresses in order. Letâ€™s write out the directory and heap
contents for our initial definitions of accounts in this new format,
and see how it supports the aliasing that we intended.</p><p>First, we create both <code data-lang="pyret" class="sourceCode">acct1</code> and <code data-lang="pyret" class="sourceCode">acct2</code> in order as
follows. Note that the <code data-lang="pyret" class="sourceCode">Account</code> associated with name
<code data-lang="pyret" class="sourceCode">acct2</code> goes in address 1002.</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct2</code></pre><p>Â â†’Â 1002</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></p></li><li><p>1002:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></p></li></ul><p>When we run
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena = Customer("Elena", acct1)</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena = customer("Elena", acct1)</code></pre></td></tr></table><p>what happens? As before, we look up what the name <code data-lang="pyret" class="sourceCode">acct1</code> refers
to in the directory and substitute the result for the name in the
<code data-lang="pyret" class="sourceCode">Customer</code> data. Now,
<code data-lang="pyret" class="sourceCode">acct1</code> evaluates to an address, 1001. Therefore,
the <code data-lang="pyret" class="sourceCode">Customer</code> value in the heap contains an address:
</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre><p>Â â†’Â 1002</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></p></li><li><p>1002:Â <code data-lang="pyret" class="sourceCode">Customer("Elena", 1001)</code></p></li></ul><p>Similarly, when we run
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">jorge = Customer("Jorge", acct1)</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge = customer("Jorge", acct1)</code></pre></td></tr></table><p>the directory and heap look like this:
</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct2</code></pre><p>Â â†’Â 1002</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre><p>Â â†’Â 1003</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">jorge</code></pre><p>Â â†’Â 1004</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="text/x-python" class="sourceCode">Account(8404, 500)</code></p></li><li><p>1002:Â <code data-lang="text/x-python" class="sourceCode">Account(8405, 3250)</code></p></li><li><p>1003:Â <code data-lang="text/x-python" class="sourceCode">Customer("Elena", 1001)</code></p></li><li><p>1004:Â <code data-lang="text/x-python" class="sourceCode">Customer("Jorge", 1001)</code></p></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Fun fact in the Web version of the book: Did you try hovering over the addresses? Try it now!</p></blockquote></blockquote><p>With the heap articulated separately from the directory, we now see
the relationship between the <code data-lang="text/x-python" class="sourceCode">acct</code> fields
for the two customers and the name <code data-lang="pyret" class="sourceCode">acct1</code>: they refer to the same address, which in
turn means they refer to the same value. In contrast, the name
<code data-lang="pyret" class="sourceCode">acct2</code>, which was not aliased in the original code, refers to an
address that is not referenced anywhere else. This is the heart of
aliasing: thatâ€™s why changes made through one name also affect values
viewed through another.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write three distinct expressions each of which uses a different name in the
directory to return the balance in account <code data-lang="pyret" class="sourceCode">acct1</code>.</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Would the following statement work to update the balance in Elena and
Jorgeâ€™s shared account?
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena.acct.balance = jorge.acct.balance - 50</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena.acct!{balance: jorge.acct!balance - 50}</code></pre></td></tr></table><p>Does this seem like a good or bad way to do this computation? Why?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Extend the most recent directory and heap contents to reflect running
the following statement:
</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct3 = acct1</code></pre><p>Did you change the heap in the previous exercise? Should you have?</p></blockquote></blockquote><p>Three rules guide how the directory and heap are affected by running
programs:</p><ol><li><p>If the code construct a new piece of structured data, put the
new piece of structured data at the next address in the heap.</p></li><li><p>If the code associates a name with a piece of structured data,
the directory should map the name to the address of the datum in the
heap.</p></li><li><p>If the code modifies a field within structured data, modify the
data in the heap.</p></li></ol><p>In the example above, we did not alter the heap in any way; only the
directory should be modified to reflect that <code data-lang="text/x-python" class="sourceCode">acct3</code> and
<code data-lang="text/x-python" class="sourceCode">acct1</code> are now aliases.</p></section><section class="SsectionLevel5" id="section 12.1.4.2"><h5 class="heading">12.1.4.2Â <a name="(part._basic-data-heap)"/>Basic Data and the Heap<a href="#(part._basic-data-heap)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>The above rules donâ€™t indicate what happens when we have basic data,
such as numbers or strings, associated with names in the directory. Do
those values also get addresses in the heap?</p><p>They do not. As our example with shared accounts illustrated, we need
the heap so that updates to fields of shared data affect all aliases
(names that refer to) those data. Basic data donâ€™t have fields, so
there is no need to put them in the heap. Hereâ€™s a concrete example:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x = 4
prof = "Dr. Kumar"</code></pre><p>The corresponding directory and heap contents would be as follows:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">4</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">prof</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">"Dr. Kumar"</code></p></li></ul><p>Notice that this particular program puts nothing in the heap:
according to our rules above, only structured data only go into the
heap. Now assume our program also had a dataclass (Python) or datatype (Pyret)
for <code data-lang="text/x-python" class="sourceCode">Office</code>s, with a professorâ€™s name and room number. Hereâ€™s
another example showing a combination of basic and structured data:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x = 4
prof = "Dr. Kumar"
office1 = Office("Dr. Lakshmi", 311)
office2 = Office(prof, 310 + x)</code></pre><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">4</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">prof</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">"Dr. Kumar"</code></p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">office1</code></pre><p>Â â†’Â 1005</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">office2</code></pre><p>Â â†’Â 1006</p></li></ul><p>Heap</p><ul><li><p>1005:Â <code data-lang="text/x-python" class="sourceCode">Office("Dr. Lakshmi", 311)</code></p></li><li><p>1006:Â <code data-lang="text/x-python" class="sourceCode">Office("Dr. Kumar", 314)</code></p></li></ul><p>Though specific language implementations can vary, this shows that
it is sufficient to think of basic data as residing
in the directory, not the heap. The
whole point of structured data is that they have both their own
identity and multiple components. The heap gives access to both
concepts. Basic data canâ€™t be broken down (by definition). As such,
there is nothing lost by putting them only in the directory.</p><p>But what about strings? Weâ€™ve referred to them as basic data
until now, but donâ€™t they have â€œcomponentsâ€, namely the
characters that make up the string? Yes, that is technically
accurate. However, we are treating strings as basic data because we
arenâ€™t using operations that modify that sequence of characters. This is
a subtle point, one that usually comes up later in computer science.
This book
will leave strings in the directory, but if you are writing programs
that modify the internal characters, put them in the heap instead.</p></section>&#13;
<h5 class="heading">12.1.4.1Â <a name="(part._heap-intro)"/>Introducing the Heap<a href="#(part._heap-intro)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Our original presentation of the directory reflected the aliases that referred to a single
<code data-lang="pyret" class="sourceCode">Account</code> through repeated use of the name <code data-lang="pyret" class="sourceCode">acct1</code>. We only
lost that sharing when we replaced <code data-lang="pyret" class="sourceCode">acct1</code> with itâ€™s value while
setting up the data for Elena and Jorge. The rule that names canâ€™t
appear in the values is still important, especially in the presence of
mutation (weâ€™ll return to this later in <a href="mutating-variables.html#%28part._mutating-vars-memory%29" data-pltdoc="x">Mutating Variables in Memory</a>). But the idea
of having a single term that can be reused to reflect sharing is a
good one. Indeed, it reflects what happens inside your computer.</p><p>Every time you use a constructor to create data, your programming
environment stores it in the memory of your computer. Memory
consists of a (large) number of slots. Your newly-created datum goes
into one of these slots. Each slot is labeled with an
address. Just as a street address refers to a specific building,
a memory address refers to a specific slot where a datum is
stored. Memory slots are physical entities, not conceptual ones. A
computer with a 500GB hard drive has about 500 billion slots in which it can
store data. Not all of that memory is available to your programming
environment: your Web browser, applications, operating system, and so on all
get stored in the memory. Your programming environment does get a
portion of memory to use for storing its data. That portion is called
the heap.</p><p>When you write a statement like</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1 = Account(8404, 500)</code></pre><p>your programming environment puts the new <code data-lang="text/x-python" class="sourceCode">Account</code> into a
physical slot in the heap, then associates the address of that
slot with the variable name in the directory. The name in the
directory doesnâ€™t map to the value itself, but rather to the
address that holds the value. The address bridges
between the physical storage location and the conceptual name you want
to associate with the new datum. In other words, our directory really
looks like:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></p></li></ul><p>Our revised version has two separate areas: the directory (mapping
names to addresses) and the heap (showing the values stored
at the
addresses). We will use four-digit numbers for addresses, prefixed
with an @ symbol (reserving numbers with fewer digits for data
values). The specific number for the initial address (here 1001) is
arbitrary. Subsequent storage of structured data values will use the
addresses in order. Letâ€™s write out the directory and heap
contents for our initial definitions of accounts in this new format,
and see how it supports the aliasing that we intended.</p><p>First, we create both <code data-lang="pyret" class="sourceCode">acct1</code> and <code data-lang="pyret" class="sourceCode">acct2</code> in order as
follows. Note that the <code data-lang="pyret" class="sourceCode">Account</code> associated with name
<code data-lang="pyret" class="sourceCode">acct2</code> goes in address 1002.</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct2</code></pre><p>Â â†’Â 1002</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></p></li><li><p>1002:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></p></li></ul><p>When we run
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena = Customer("Elena", acct1)</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena = customer("Elena", acct1)</code></pre></td></tr></table><p>what happens? As before, we look up what the name <code data-lang="pyret" class="sourceCode">acct1</code> refers
to in the directory and substitute the result for the name in the
<code data-lang="pyret" class="sourceCode">Customer</code> data. Now,
<code data-lang="pyret" class="sourceCode">acct1</code> evaluates to an address, 1001. Therefore,
the <code data-lang="pyret" class="sourceCode">Customer</code> value in the heap contains an address:
</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre><p>Â â†’Â 1002</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="pyret" class="sourceCode">Account(8404, 500)</code></p></li><li><p>1002:Â <code data-lang="pyret" class="sourceCode">Customer("Elena", 1001)</code></p></li></ul><p>Similarly, when we run
</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">jorge = Customer("Jorge", acct1)</code></pre></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">jorge = customer("Jorge", acct1)</code></pre></td></tr></table><p>the directory and heap look like this:
</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct1</code></pre><p>Â â†’Â 1001</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct2</code></pre><p>Â â†’Â 1002</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena</code></pre><p>Â â†’Â 1003</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">jorge</code></pre><p>Â â†’Â 1004</p></li></ul><p>Heap</p><ul><li><p>1001:Â <code data-lang="text/x-python" class="sourceCode">Account(8404, 500)</code></p></li><li><p>1002:Â <code data-lang="text/x-python" class="sourceCode">Account(8405, 3250)</code></p></li><li><p>1003:Â <code data-lang="text/x-python" class="sourceCode">Customer("Elena", 1001)</code></p></li><li><p>1004:Â <code data-lang="text/x-python" class="sourceCode">Customer("Jorge", 1001)</code></p></li></ul><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Fun fact in the Web version of the book: Did you try hovering over the addresses? Try it now!</p></blockquote></blockquote><p>With the heap articulated separately from the directory, we now see
the relationship between the <code data-lang="text/x-python" class="sourceCode">acct</code> fields
for the two customers and the name <code data-lang="pyret" class="sourceCode">acct1</code>: they refer to the same address, which in
turn means they refer to the same value. In contrast, the name
<code data-lang="pyret" class="sourceCode">acct2</code>, which was not aliased in the original code, refers to an
address that is not referenced anywhere else. This is the heart of
aliasing: thatâ€™s why changes made through one name also affect values
viewed through another.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Write three distinct expressions each of which uses a different name in the
directory to return the balance in account <code data-lang="pyret" class="sourceCode">acct1</code>.</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Would the following statement work to update the balance in Elena and
Jorgeâ€™s shared account?
</p><table cellspacing="0" cellpadding="0" class="TwoColumnAsRows"><tr><td><p>Python</p></td><td></td></tr><tr><td></td><td><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">elena.acct.balance = jorge.acct.balance - 50</code></pre></td></tr><tr><td><p>Pyret</p></td><td></td></tr><tr><td></td><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">elena.acct!{balance: jorge.acct!balance - 50}</code></pre></td></tr></table><p>Does this seem like a good or bad way to do this computation? Why?</p></blockquote></blockquote><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Extend the most recent directory and heap contents to reflect running
the following statement:
</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">acct3 = acct1</code></pre><p>Did you change the heap in the previous exercise? Should you have?</p></blockquote></blockquote><p>Three rules guide how the directory and heap are affected by running
programs:</p><ol><li><p>If the code construct a new piece of structured data, put the
new piece of structured data at the next address in the heap.</p></li><li><p>If the code associates a name with a piece of structured data,
the directory should map the name to the address of the datum in the
heap.</p></li><li><p>If the code modifies a field within structured data, modify the
data in the heap.</p></li></ol><p>In the example above, we did not alter the heap in any way; only the
directory should be modified to reflect that <code data-lang="text/x-python" class="sourceCode">acct3</code> and
<code data-lang="text/x-python" class="sourceCode">acct1</code> are now aliases.</p>&#13;
<h5 class="heading">12.1.4.2Â <a name="(part._basic-data-heap)"/>Basic Data and the Heap<a href="#(part._basic-data-heap)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>The above rules donâ€™t indicate what happens when we have basic data,
such as numbers or strings, associated with names in the directory. Do
those values also get addresses in the heap?</p><p>They do not. As our example with shared accounts illustrated, we need
the heap so that updates to fields of shared data affect all aliases
(names that refer to) those data. Basic data donâ€™t have fields, so
there is no need to put them in the heap. Hereâ€™s a concrete example:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x = 4
prof = "Dr. Kumar"</code></pre><p>The corresponding directory and heap contents would be as follows:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">4</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">prof</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">"Dr. Kumar"</code></p></li></ul><p>Notice that this particular program puts nothing in the heap:
according to our rules above, only structured data only go into the
heap. Now assume our program also had a dataclass (Python) or datatype (Pyret)
for <code data-lang="text/x-python" class="sourceCode">Office</code>s, with a professorâ€™s name and room number. Hereâ€™s
another example showing a combination of basic and structured data:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x = 4
prof = "Dr. Kumar"
office1 = Office("Dr. Lakshmi", 311)
office2 = Office(prof, 310 + x)</code></pre><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">x</code></pre><p>Â â†’Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">4</code></pre></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">prof</code></pre><p>Â â†’Â <code data-lang="text/x-python" class="sourceCode">"Dr. Kumar"</code></p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">office1</code></pre><p>Â â†’Â 1005</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">office2</code></pre><p>Â â†’Â 1006</p></li></ul><p>Heap</p><ul><li><p>1005:Â <code data-lang="text/x-python" class="sourceCode">Office("Dr. Lakshmi", 311)</code></p></li><li><p>1006:Â <code data-lang="text/x-python" class="sourceCode">Office("Dr. Kumar", 314)</code></p></li></ul><p>Though specific language implementations can vary, this shows that
it is sufficient to think of basic data as residing
in the directory, not the heap. The
whole point of structured data is that they have both their own
identity and multiple components. The heap gives access to both
concepts. Basic data canâ€™t be broken down (by definition). As such,
there is nothing lost by putting them only in the directory.</p><p>But what about strings? Weâ€™ve referred to them as basic data
until now, but donâ€™t they have â€œcomponentsâ€, namely the
characters that make up the string? Yes, that is technically
accurate. However, we are treating strings as basic data because we
arenâ€™t using operations that modify that sequence of characters. This is
a subtle point, one that usually comes up later in computer science.
This book
will leave strings in the directory, but if you are writing programs
that modify the internal characters, put them in the heap instead.</p>    
</body>
</html>