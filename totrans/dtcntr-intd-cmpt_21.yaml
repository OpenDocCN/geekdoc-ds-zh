- en: 8.1Â Functions as DatağŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.1 å‡½æ•°ä½œä¸ºæ•°æ®ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/func-as-data.html](https://dcic-world.org/2025-08-27/func-as-data.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/func-as-data.html](https://dcic-world.org/2025-08-27/func-as-data.html)
- en: '| Â Â Â Â [8.1.1Â A Little Calculus](#%28part._fd-calculus%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [8.1.1 ä¸€ç‚¹å¾®ç§¯åˆ†](#%28part._fd-calculus%29) |'
- en: '| Â Â Â Â [8.1.2Â A Helpful Shorthand for Anonymous Functions](#%28part._lam-shorthand%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [8.1.2 åŒ¿åå‡½æ•°çš„æœ‰ç”¨ç¼©å†™](#%28part._lam-shorthand%29) |'
- en: '| Â Â Â Â [8.1.3Â Streams From Functions](#%28part._streams-from-funs%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [8.1.3 æµç¨‹ä»å‡½æ•°ä¸­ç”Ÿæˆ](#%28part._streams-from-funs%29) |'
- en: '| Â Â Â Â [8.1.4Â Combining Forces: Streams of Derivatives](#%28part._d-dx-streams%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [8.1.4 ç»“åˆåŠ›é‡ï¼šå¯¼æ•°æµ](#%28part._d-dx-streams%29) |'
- en: Itâ€™s interesting to consider how expressive the little programming weâ€™ve learned
    so far can be. To illustrate this, weâ€™ll work through a few exercises of interesting
    concepts we can express using just functions as values. Weâ€™ll write two quite
    different things, then show how they converge nicely.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘åˆ°æˆ‘ä»¬è¿„ä»Šä¸ºæ­¢å­¦åˆ°çš„ç¼–ç¨‹çš„è¡¨è¿°èƒ½åŠ›æ˜¯å¾ˆæœ‰è¶£çš„ã€‚ä¸ºäº†è¯´æ˜è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å°†é€šè¿‡ä¸€äº›æœ‰è¶£çš„ç»ƒä¹ æ¥å±•ç¤ºæˆ‘ä»¬å¯ä»¥ä»…ä½¿ç”¨å‡½æ•°ä½œä¸ºå€¼æ¥è¡¨è¿°çš„æ¦‚å¿µã€‚æˆ‘ä»¬å°†å†™ä¸¤ä»¶ç›¸å½“ä¸åŒçš„äº‹æƒ…ï¼Œç„¶åå±•ç¤ºå®ƒä»¬å¦‚ä½•å¾ˆå¥½åœ°æ”¶æ•›ã€‚
- en: 8.1.1Â A Little Calculus[ğŸ”—](#(part._fd-calculus) "Link to here")
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1 ä¸€ç‚¹å¾®ç§¯åˆ†[ğŸ”—](#(part._fd-calculus) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'If youâ€™ve studied the differential calculus, youâ€™ve come across curious sytactic
    statements such as this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å·²ç»å­¦ä¹ è¿‡å¾®åˆ†å­¦ï¼Œä½ ä¸€å®šé‡åˆ°è¿‡è¿™æ ·çš„å¥‡æ€ªè¯­æ³•é™ˆè¿°ï¼š
- en: \begin{equation*}{\frac{d}{dx}} x^2 = 2x\end{equation*}
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}{\frac{d}{dx}} x^2 = 2x\end{equation*}
- en: 'Letâ€™s unpack what this means: the \(d/dx\), the \(x^2\), and the \(2x\).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è§£å¼€è¿™æ„å‘³ç€ä»€ä¹ˆï¼š\(d/dx\)ã€\(x^2\) å’Œ \(2x\)ã€‚
- en: 'First, letâ€™s take on the two expressions; weâ€™ll discuss one, and the discussion
    will cover the other as well. The correct response to â€œwhat does \(x^2\) mean?â€
    is, of course, an error: it doesnâ€™t mean anything, because \(x\) is an unbound
    identifier.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè®©æˆ‘ä»¬å¤„ç†è¿™ä¸¤ä¸ªè¡¨è¾¾å¼ï¼›æˆ‘ä»¬å°†è®¨è®ºä¸€ä¸ªï¼Œè®¨è®ºå°†æ¶µç›–å¦ä¸€ä¸ªã€‚å¯¹â€œ\(x^2\) çš„æ„æ€æ˜¯ä»€ä¹ˆï¼Ÿâ€çš„æ­£ç¡®å›ç­”å½“ç„¶æ˜¯é”™è¯¯ï¼šå®ƒæ²¡æœ‰ä»»ä½•æ„ä¹‰ï¼Œå› ä¸º \(x\)
    æ˜¯ä¸€ä¸ªæœªç»‘å®šçš„æ ‡è¯†ç¬¦ã€‚
- en: 'So what is it intended to mean? The intent, clearly, is to represent the function
    that squares its input, just as \(2x\) is meant to be the function that doubles
    its input. We have nicer ways of writing those:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œå®ƒçš„æ„å›¾æ˜¯ä»€ä¹ˆï¼Ÿæ˜¾ç„¶ï¼Œæ„å›¾æ˜¯è¡¨ç¤ºä¸€ä¸ªå¹³æ–¹å…¶è¾“å…¥çš„å‡½æ•°ï¼Œå°±åƒ \(2x\) æ„å‘³ç€æ˜¯å°†å…¶è¾“å…¥åŠ å€çš„é‚£ä¸ªå‡½æ•°ä¸€æ ·ã€‚æˆ‘ä»¬æœ‰æ›´ä¼˜é›…çš„æ–¹å¼æ¥å†™è¿™äº›ï¼š
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: and what weâ€™re really trying to say is that the \(d/dx\) (whatever that is)
    of `sq` is `dbl`.Weâ€™re assuming functions of arity one in the variable that is
    changing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çœŸæ­£è¯•å›¾è¯´çš„å…¶å®æ˜¯ `sq` çš„ `d/dx` æ˜¯ `dbl`ã€‚æˆ‘ä»¬å‡è®¾çš„æ˜¯ä¸€å…ƒå˜é‡ä¸­çš„å‡½æ•°ã€‚
- en: 'So now letâ€™s unpack \(d/dx\), starting with its type. As the above example
    illustrates, \(d/dx\) is really a function from functions to functions. That is,
    we can write its type as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œç°åœ¨è®©æˆ‘ä»¬è§£å¼€ `d/dx` çš„å«ä¹‰ï¼Œä»å…¶ç±»å‹å¼€å§‹ã€‚æ­£å¦‚ä¸Šè¿°ç¤ºä¾‹æ‰€ç¤ºï¼Œ`d/dx` å®é™…ä¸Šæ˜¯ä¸€ä¸ªä»å‡½æ•°åˆ°å‡½æ•°çš„å‡½æ•°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶ç±»å‹å†™æˆä»¥ä¸‹å½¢å¼ï¼š
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: (This type might explain why your calculus course never explained this operation
    this wayâ€”<wbr>though itâ€™s not clear that obscuring its true meaning is any better
    for your understanding.)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆè¿™ç§ç±»å‹å¯èƒ½è§£é‡Šäº†ä¸ºä»€ä¹ˆä½ çš„å¾®ç§¯åˆ†è¯¾ç¨‹ä»æœªä»¥è¿™ç§æ–¹å¼è§£é‡Šè¿™ä¸ªæ“ä½œâ€”â€”<wbr>å°½ç®¡ä¸æ¸…æ¥šæ©ç›–å…¶çœŸæ­£å«ä¹‰æ˜¯å¦å¯¹ä½ çš„ç†è§£æ›´æœ‰ç›Šã€‚ï¼‰
- en: Let us now implement `d-dx`. Weâ€™ll implement numerical differentiation, though
    in principle we could also implement symbolic differentiationâ€”<wbr>using rules
    you learned, e.g., given a polynomial, multiply by the exponent and reduce the
    exponent by oneâ€”<wbr>with a representation of expressions (a problem that will
    be covered in more detail in a future release).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç°åœ¨å®ç° `d/dx`ã€‚æˆ‘ä»¬å°†å®ç°æ•°å€¼å¾®åˆ†ï¼Œå°½ç®¡åŸåˆ™ä¸Šæˆ‘ä»¬ä¹Ÿå¯ä»¥å®ç°ç¬¦å·å¾®åˆ†â€”â€”<wbr>ä½¿ç”¨ä½ å­¦è¿‡çš„è§„åˆ™ï¼Œä¾‹å¦‚ï¼Œç»™å®šä¸€ä¸ªå¤šé¡¹å¼ï¼Œä¹˜ä»¥æŒ‡æ•°å¹¶å‡å°‘æŒ‡æ•°ä¸€ä¸ªâ€”â€”<wbr>ä½¿ç”¨è¡¨è¾¾å¼è¡¨ç¤ºï¼ˆè¿™ä¸ªé—®é¢˜å°†åœ¨æœªæ¥çš„ç‰ˆæœ¬ä¸­æ›´è¯¦ç»†åœ°ä»‹ç»ï¼‰ã€‚
- en: 'In general, numeric differentiation of a function at a point yields the value
    of the derivative at that point. We have a handy formula for it: the derivative
    of \(f\) at \(x\) is'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸ï¼Œå‡½æ•°åœ¨ä¸€ç‚¹çš„æ•°å€¼å¾®åˆ†ä¼šäº§ç”Ÿè¯¥ç‚¹çš„å¯¼æ•°å€¼ã€‚æˆ‘ä»¬æœ‰ä¸€ä¸ªæ–¹ä¾¿çš„å…¬å¼ï¼š\(f\) åœ¨ \(x\) å¤„çš„å¯¼æ•°æ˜¯
- en: \begin{equation*}\frac{f(x + \epsilon) - f(x)}{\epsilon}\end{equation*}
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}\frac{f(x + \epsilon) - f(x)}{\epsilon}\end{equation*}
- en: 'as \(\epsilon\) goes to zero in the limit. For now weâ€™ll give the infinitesimal
    a small but fixed value, and later [[Combining Forces: Streams of Derivatives](#%28part._d-dx-streams%29)]
    see how we can improve on this.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ \(\epsilon\) åœ¨æé™ä¸­è¶‹è¿‘äºé›¶æ—¶ã€‚ç°åœ¨æˆ‘ä»¬å°†ç»™æ— ç©·å°é‡ä¸€ä¸ªå°çš„ä½†å›ºå®šçš„å€¼ï¼Œç¨å [[ç»“åˆåŠ›é‡ï¼šå¯¼æ•°æµ](#%28part._d-dx-streams%29)]
    æˆ‘ä»¬å°†çœ‹çœ‹æˆ‘ä»¬å¦‚ä½•å¯ä»¥æ”¹è¿›è¿™ä¸€ç‚¹ã€‚
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can now translate the above formula into a function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨å¯ä»¥å°†ä¸Šè¿°å…¬å¼è½¬æ¢ä¸ºä¸€ä¸ªå‡½æ•°ï¼š
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And sure enough, we can check and make sure it works as expected:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œæˆ‘ä»¬å¯ä»¥æ£€æŸ¥å¹¶ç¡®ä¿å®ƒæŒ‰é¢„æœŸå·¥ä½œï¼š
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Confession: We chose the value of `epsilon` so that the default tolerance `is-roughly`
    works for this example.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: å€’éœ‰çš„æ˜¯ï¼Œæˆ‘ä»¬é€‰æ‹©äº†`epsilon`çš„å€¼ï¼Œä»¥ä¾¿é»˜è®¤çš„å®¹å·®`is-roughly`é€‚ç”¨äºè¿™ä¸ªä¾‹å­ã€‚
- en: 'However, there is something unsatisfying about this. The function weâ€™ve written
    clearly does not have the type we described earlier! What we wanted was an operation
    that takes just a function, and represents the platonic notion of differentiation;
    but weâ€™ve been forced, by the nature of numeric differentiation, to describe the
    derivative at a point. We might instead like to write something like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¿™è¿˜æœ‰ä¸€äº›ä»¤äººä¸æ»¡æ„çš„åœ°æ–¹ã€‚æˆ‘ä»¬ç¼–å†™çš„å‡½æ•°æ˜¾ç„¶ä¸å…·æœ‰æˆ‘ä»¬ä¹‹å‰æè¿°çš„ç±»å‹ï¼æˆ‘ä»¬æƒ³è¦çš„æ˜¯ä¸€ä¸ªåªæ¥å—å‡½æ•°çš„æ“ä½œï¼Œå¹¶ä»£è¡¨æŸæ‹‰å›¾å¼çš„å¾®åˆ†æ¦‚å¿µï¼›ä½†ç”±äºæ•°å€¼å¾®åˆ†çš„æ€§è´¨ï¼Œæˆ‘ä»¬è¢«è¿«æè¿°åœ¨æŸä¸ªç‚¹çš„å¯¼æ•°ã€‚æˆ‘ä»¬å¯èƒ½æ›´å–œæ¬¢å†™å¦‚ä¸‹ï¼š
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Do Now!
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬æ¥åšä¸€ä¸‹ç»ƒä¹ ï¼
- en: ''
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whatâ€™s the problem with the above definition?
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸Šé¢çš„å®šä¹‰æœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ
- en: 'If you didnâ€™t notice, Pyret will soon tell you: `x` isnâ€™t bound. Indeed, what
    is `x`? Itâ€™s the point at which weâ€™re trying to compute the numeric derivative.
    That is, `d-dx` needs to return not a number but a function (as the type indicates)
    that will consume this `x`:â€œLambdas are relegated to relative obscurity until
    Java makes them popular by not having them.â€â€”<wbr>James Iry, [A Brief, Incomplete,
    and Mostly Wrong History of Programming Languages](https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æ²¡æœ‰æ³¨æ„åˆ°ï¼ŒPyretå¾ˆå¿«å°±ä¼šå‘Šè¯‰ä½ ï¼š`x`æ²¡æœ‰ç»‘å®šã€‚å®é™…ä¸Šï¼Œ`x`æ˜¯ä»€ä¹ˆï¼Ÿå®ƒæ˜¯æˆ‘ä»¬è¯•å›¾è®¡ç®—æ•°å€¼å¯¼æ•°çš„ç‚¹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ`d-dx`éœ€è¦è¿”å›çš„ä¸æ˜¯æ•°å­—ï¼Œè€Œæ˜¯ä¸€ä¸ªå‡½æ•°ï¼ˆå¦‚ç±»å‹æ‰€ç¤ºï¼‰ï¼Œå®ƒå°†æ¶ˆè€—è¿™ä¸ª`x`ï¼šâ€œLambdas
    are relegated to relative obscurity until Java makes them popular by not having
    them.â€â€”<wbr>James Iry, [ã€Šç¼–ç¨‹è¯­è¨€ç®€å²ï¼šç®€çŸ­ã€ä¸å®Œæ•´ä¸”å¤§å¤šé”™è¯¯ã€‹](https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html)
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we want to be a little more explicit we can annotate the inner function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³æ›´æ˜ç¡®ä¸€äº›ï¼Œæˆ‘ä»¬å¯ä»¥æ³¨é‡Šå†…éƒ¨å‡½æ•°ï¼š
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is a special case of a concept useful in many programming contexts, which
    we explore in more detail elsewhere: [Staging](staging.html).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªåœ¨è®¸å¤šç¼–ç¨‹ç¯å¢ƒä¸­éƒ½å¾ˆæœ‰ç”¨çš„æ¦‚å¿µçš„ç‰¹æ®Šæƒ…å†µï¼Œæˆ‘ä»¬å°†åœ¨å…¶ä»–åœ°æ–¹æ›´è¯¦ç»†åœ°æ¢è®¨ï¼š[Staging](staging.html)ã€‚
- en: 'Sure enough, this definition now works. We can, for instance, test it as follows
    (note the use of `num-floor` to avoid numeric precision issues from making our
    tests appear to fail):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: æœç„¶ï¼Œè¿™ä¸ªå®šä¹‰ç°åœ¨æœ‰æ•ˆäº†ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·æµ‹è¯•å®ƒï¼ˆæ³¨æ„ä½¿ç”¨`num-floor`æ¥é¿å…æµ‹è¯•ä¸­å‡ºç°çš„æ•°å€¼ç²¾åº¦é—®é¢˜ï¼Œä½¿æµ‹è¯•çœ‹èµ·æ¥å¤±è´¥ï¼‰ï¼š
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can return to the original example that launched this investigation:
    what the sloppy and mysterious notation of math is really trying to say is,'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å›åˆ°å¯åŠ¨è¿™æ¬¡è°ƒæŸ¥çš„åŸå§‹ç¤ºä¾‹ï¼šæ•°å­¦ä¸­æ··ä¹±å’Œç¥ç§˜çš„ç¬¦å·çœŸæ­£è¯•å›¾è¡¨è¾¾çš„æ„æ€æ˜¯ï¼Œ
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: or, in the notation of [A Notation for Functions](predicting-growth.html#%28part._math-anon-functions%29),
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…ï¼Œåœ¨[A Notation for Functions](predicting-growth.html#%28part._math-anon-functions%29)çš„è®°æ³•ä¸­ï¼Œ
- en: \begin{equation*}{\frac{d}{dx}} [x \rightarrow x^2] = [x \rightarrow 2x]\end{equation*}
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}{\frac{d}{dx}} [x \rightarrow x^2] = [x \rightarrow 2x]\end{equation*}
- en: Pity math textbooks for not wanting to tell us the truth!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: æƒœå“‰ï¼Œæ•°å­¦æ•™ç§‘ä¹¦ä¸æ„¿å‘Šè¯‰æˆ‘ä»¬çœŸç›¸ï¼
- en: 8.1.2Â A Helpful Shorthand for Anonymous Functions[ğŸ”—](#(part._lam-shorthand)
    "Link to here")
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2 åŒ¿åå‡½æ•°çš„æœ‰ç”¨ç¼©å†™[ğŸ”—](#(part._lam-shorthand) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Pyret offers a shorter syntax for writing anonymous functions. Though, stylistically,
    we generally avoid it so that our programs donâ€™t become a jumble of special characters,
    sometimes itâ€™s particularly convenient, as we will see below. This syntax is
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretæä¾›äº†ç¼–å†™åŒ¿åå‡½æ•°çš„ç®€çŸ­è¯­æ³•ã€‚å°½ç®¡ä»é£æ ¼ä¸Šè®²ï¼Œæˆ‘ä»¬é€šå¸¸é¿å…ä½¿ç”¨å®ƒï¼Œä»¥å…æˆ‘ä»¬çš„ç¨‹åºå˜æˆç‰¹æ®Šå­—ç¬¦çš„æ··ä¹±ï¼Œä½†æœ‰æ—¶å®ƒç‰¹åˆ«æ–¹ä¾¿ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚è¿™ç§è¯­æ³•æ˜¯
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'where `a` is zero or more arguments and `b` is the body. For instance, we can
    write `lam(x): x * x end` as'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 'å…¶ä¸­`a`æ˜¯é›¶ä¸ªæˆ–å¤šä¸ªå‚æ•°ï¼Œ`b`æ˜¯ä¸»ä½“ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥å°†`lam(x): x * x end`å†™æˆ'
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: where we can see the benefit of brevity. In particular, note that there is no
    need for `end`, because the braces take the place of showing where the expression
    begins and ends. Similarly, we could have written `d-dx` as
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œçœ‹åˆ°ç®€æ´æ€§çš„å¥½å¤„ã€‚ç‰¹åˆ«æ˜¯ï¼Œè¯·æ³¨æ„æ²¡æœ‰å¿…è¦ä½¿ç”¨`end`ï¼Œå› ä¸ºèŠ±æ‹¬å·å·²ç»å–ä»£äº†è¡¨ç¤ºè¡¨è¾¾å¼å¼€å§‹å’Œç»“æŸçš„ä½ç½®ã€‚åŒæ ·ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å°†`d-dx`å†™æˆ
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: but many readers would say this makes the function harder to read, because the
    prominent `lam` makes clear that `d-dx` returns an (anonymous) function, whereas
    this syntax obscures it. Therefore, we will usually only use this shorthand syntax
    for â€œone-linersâ€.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è®¸å¤šè¯»è€…ä¼šè¯´è¿™ä½¿å‡½æ•°æ›´éš¾é˜…è¯»ï¼Œå› ä¸ºçªå‡ºçš„`lam`æ¸…æ¥šåœ°è¡¨æ˜`d-dx`è¿”å›ä¸€ä¸ªï¼ˆåŒ¿åï¼‰å‡½æ•°ï¼Œè€Œæ­¤è¯­æ³•åˆ™æ©ç›–äº†è¿™ä¸€ç‚¹ã€‚å› æ­¤ï¼Œæˆ‘ä»¬é€šå¸¸åªä¼šä½¿ç”¨è¿™ç§ç¼©å†™è¯­æ³•æ¥ç¼–å†™â€œä¸€è¡Œä»£ç â€ã€‚
- en: 8.1.3Â Streams From Functions[ğŸ”—](#(part._streams-from-funs) "Link to here")
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3 ä»å‡½æ•°ç”Ÿæˆæµ[ğŸ”—](#(part._streams-from-funs) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'People typically think of a function as serving one purpose: to parameterize
    an expression. While that is both true and the most common use of a function,
    it does not justify having a function of no arguments, because that clearly parameterizes
    over nothing at all. Yet functions of no argument also have a use, because functions
    actually serve two purposes: to parameterize, and to suspend evaluation of the
    body until the function is applied. In fact, these two uses are orthogonal, in
    that one can employ one feature without the other. Below, we will focus on delay
    without abstraction (the other shows up in other computer science settings).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: äººä»¬é€šå¸¸è®¤ä¸ºå‡½æ•°åªæœ‰ä¸€ä¸ªç”¨é€”ï¼šå‚æ•°åŒ–ä¸€ä¸ªè¡¨è¾¾å¼ã€‚è™½ç„¶è¿™æ˜¯çœŸçš„ï¼Œä¹Ÿæ˜¯å‡½æ•°æœ€å¸¸è§çš„ä½¿ç”¨æ–¹å¼ï¼Œä½†è¿™å¹¶ä¸èƒ½è¯æ˜æ²¡æœ‰å‚æ•°çš„å‡½æ•°æ˜¯åˆç†çš„ï¼Œå› ä¸ºé‚£æ˜¾ç„¶æ²¡æœ‰å¯¹ä»»ä½•ä¸œè¥¿è¿›è¡Œå‚æ•°åŒ–ã€‚ç„¶è€Œï¼Œæ²¡æœ‰å‚æ•°çš„å‡½æ•°ä¹Ÿæœ‰å…¶ç”¨é€”ï¼Œå› ä¸ºå‡½æ•°å®é™…ä¸Šæœ‰ä¸¤ä¸ªç”¨é€”ï¼šå‚æ•°åŒ–å’Œåœ¨å‡½æ•°è¢«åº”ç”¨ä¹‹å‰æŒ‚èµ·ä¸»ä½“çš„è¯„ä¼°ã€‚å®é™…ä¸Šï¼Œè¿™ä¸¤ä¸ªç”¨é€”æ˜¯æ­£äº¤çš„ï¼Œå› ä¸ºå¯ä»¥åœ¨ä¸ä½¿ç”¨å¦ä¸€ä¸ªåŠŸèƒ½çš„æƒ…å†µä¸‹ä½¿ç”¨å…¶ä¸­ä¸€ä¸ªåŠŸèƒ½ã€‚ä¸‹é¢ï¼Œæˆ‘ä»¬å°†å…³æ³¨å»¶è¿Ÿè€Œä¸æŠ½è±¡ï¼ˆå¦ä¸€ä¸ªåœ¨å…¶ä»–è®¡ç®—æœºç§‘å­¦åœºæ™¯ä¸­å‡ºç°ï¼‰ã€‚
- en: 'Letâ€™s consider the humble list. A list can be only finitely long. However,
    there are many lists (or sequences) in nature that have no natural upper bound:
    from mathematical objects (the sequence of natural numbers) to natural ones (the
    sequence of hits to a Web site). Rather than try to squeeze these unbounded lists
    into bounded ones, letâ€™s look at how we might represent and program over these
    unbounded lists.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹ç®€å•çš„åˆ—è¡¨ã€‚åˆ—è¡¨çš„é•¿åº¦åªèƒ½æ˜¯æœ‰é™çš„ã€‚ç„¶è€Œï¼Œè‡ªç„¶ç•Œä¸­æœ‰è®¸å¤šæ²¡æœ‰è‡ªç„¶ä¸Šé™çš„åˆ—è¡¨ï¼ˆæˆ–åºåˆ—ï¼‰ï¼šä»æ•°å­¦å¯¹è±¡ï¼ˆè‡ªç„¶æ•°çš„åºåˆ—ï¼‰åˆ°è‡ªç„¶ç°è±¡ï¼ˆç½‘ç«™è®¿é—®çš„åºåˆ—ï¼‰ã€‚ä¸å…¶è¯•å›¾å°†è¿™äº›æ— ç•Œåˆ—è¡¨å‹ç¼©æˆæœ‰ç•Œåˆ—è¡¨ï¼Œä¸å¦‚çœ‹çœ‹æˆ‘ä»¬å¦‚ä½•è¡¨ç¤ºå’Œç¼–ç¨‹è¿™äº›æ— ç•Œåˆ—è¡¨ã€‚
- en: 'First, letâ€™s write a program to compute the sequence of natural numbers:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè®©æˆ‘ä»¬ç¼–å†™ä¸€ä¸ªç¨‹åºæ¥è®¡ç®—è‡ªç„¶æ•°çš„åºåˆ—ï¼š
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Do Now!
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this program have a problem?
  id: totrans-60
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç¨‹åºæœ‰é—®é¢˜å—ï¼Ÿ
- en: 'While this represents our intent, it doesnâ€™t work: running itâ€”<wbr>e.g., `nats-from(0)`â€”<wbr>creates
    an infinite loop evaluating `nats-from` for every subsequent natural number. In
    other words, we want to write something very like the above, but that doesnâ€™t
    recur until we want it to, i.e., on demand. In other words, we want the rest of
    the list to be lazy.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶è¿™ä»£è¡¨äº†æˆ‘ä»¬çš„æ„å›¾ï¼Œä½†å®ƒä¸èµ·ä½œç”¨ï¼šè¿è¡Œå®ƒâ€”â€”ä¾‹å¦‚ï¼Œ`nats-from(0)`â€”â€”ä¼šåˆ›å»ºä¸€ä¸ªæ— é™å¾ªç¯ï¼Œä¸ºæ¯ä¸ªåç»­çš„è‡ªç„¶æ•°è¯„ä¼° `nats-from`ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬æƒ³è¦å†™ä¸€äº›éå¸¸ç±»ä¼¼ä¸Šé¢çš„ä¸œè¥¿ï¼Œä½†åªæœ‰åœ¨æˆ‘ä»¬éœ€è¦çš„æ—¶å€™æ‰ä¼šé€’å½’ï¼Œå³æŒ‰éœ€ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å¸Œæœ›åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æ˜¯æƒ°æ€§çš„ã€‚
- en: This is where our insight into functions comes in. A function, as we have just
    noted, delays evaluation of its body until it is applied. Therefore, a function
    would, in principle, defer the invocation of `nats-from(n + 1)` until itâ€™s needed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯æˆ‘ä»¬å¯¹å‡½æ•°çš„æ´å¯Ÿæ‰€åœ¨ã€‚æ­£å¦‚æˆ‘ä»¬åˆšæ‰æåˆ°çš„ï¼Œå‡½æ•°ä¼šå»¶è¿Ÿå…¶ä¸»ä½“çš„è¯„ä¼°ï¼Œç›´åˆ°å®ƒè¢«åº”ç”¨ã€‚å› æ­¤ï¼Œä»åŸåˆ™ä¸Šè®²ï¼Œå‡½æ•°ä¼šæ¨è¿Ÿè°ƒç”¨ `nats-from(n + 1)`
    ç›´åˆ°å®ƒè¢«éœ€è¦ã€‚
- en: 'Except, this creates a type problem: the second argument to `link` needs to
    be a list, and cannot be a function. Indeed, because it must be a list, and every
    value that has been constructed must be finite, every list is finite and eventually
    terminates in `empty`. Therefore, we need a new data structure to represent the
    links in these lazy lists (also known as streams):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†ï¼Œè¿™ä¼šåˆ›å»ºä¸€ä¸ªç±»å‹é—®é¢˜ï¼š`link` çš„ç¬¬äºŒä¸ªå‚æ•°éœ€è¦æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œè€Œä¸èƒ½æ˜¯ä¸€ä¸ªå‡½æ•°ã€‚ç¡®å®ï¼Œå› ä¸ºå®ƒå¿…é¡»æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œå¹¶ä¸”æ¯ä¸ªå·²ç»æ„é€ çš„å€¼éƒ½å¿…é¡»æ˜¯æœ‰é™çš„ï¼Œæ‰€ä»¥æ¯ä¸ªåˆ—è¡¨éƒ½æ˜¯æœ‰é™çš„ï¼Œæœ€ç»ˆä¼šåœ¨
    `empty` ä¸­ç»ˆæ­¢ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ–°çš„æ•°æ®ç»“æ„æ¥è¡¨ç¤ºè¿™äº›æƒ°æ€§åˆ—è¡¨ä¸­çš„é“¾æ¥ï¼ˆä¹Ÿç§°ä¸ºæµï¼‰ï¼š
- en: <stream-type-def> ::=
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <stream-type-def> ::=
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: where the annotation `( -> Stream<T>)` means a function from no arguments (hence
    the lack of anything before `->`), also known as a thunk. Note that the way we
    have defined streams they must be infinite, since we have provided no way to terminate
    them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ï¼Œæ³¨é‡Š `( -> Stream<T>)` è¡¨ç¤ºä¸€ä¸ªæ— å‚æ•°çš„å‡½æ•°ï¼ˆå› æ­¤ `->` å‰é¢æ²¡æœ‰å†…å®¹ï¼‰ï¼Œä¹Ÿç§°ä¸º thunkã€‚æ³¨æ„ï¼Œæˆ‘ä»¬å®šä¹‰æµçš„æ–¹å¼æ„å‘³ç€å®ƒä»¬å¿…é¡»æ˜¯æ— é™çš„ï¼Œå› ä¸ºæˆ‘ä»¬æ²¡æœ‰æä¾›ç»ˆæ­¢å®ƒä»¬çš„æ–¹æ³•ã€‚
- en: 'Letâ€™s construct the simplest example we can, a stream of constant values:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ„å»ºä¸€ä¸ªæœ€ç®€å•çš„ä¾‹å­ï¼Œä¸€ä¸ªå¸¸é‡å€¼çš„æµï¼š
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Pyret will actually complain about this definition. Note that the list equivalent
    of this also will not work:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret å®é™…ä¸Šä¼šå¯¹è¿™ä¸ªå®šä¹‰æå‡ºæŠ±æ€¨ã€‚æ³¨æ„ï¼Œè¿™ä¸ªåˆ—è¡¨çš„ç­‰ä»·ç‰©ä¹Ÿä¸ä¼šå·¥ä½œï¼š
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'because `ones` is not defined at the point of definition, so when Pyret evaluates
    `link(1, ones)`, it complains that `ones` is not defined. However, it is being
    overly conservative with our former definition: the use of `ones` is â€œunder a
    `lam`â€, and hence wonâ€™t be needed until after the definition of `ones` is done,
    at which point `ones` will be defined. We can indicate this to Pyret by using
    the keyword `rec`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸º `ones` åœ¨å®šä¹‰ç‚¹æ²¡æœ‰å®šä¹‰ï¼Œæ‰€ä»¥å½“ Pyret è¯„ä¼° `link(1, ones)` æ—¶ï¼Œå®ƒä¼šæŠ±æ€¨ `ones` æ²¡æœ‰å®šä¹‰ã€‚ç„¶è€Œï¼Œå®ƒå¯¹æˆ‘ä»¬çš„å‰ä¸€ä¸ªå®šä¹‰è¿‡äºä¿å®ˆï¼š`ones`
    çš„ä½¿ç”¨æ˜¯åœ¨ `lam` ä¸‹ï¼Œå› æ­¤åªæœ‰åœ¨ `ones` å®šä¹‰å®Œæˆåæ‰ä¼šéœ€è¦ï¼Œåˆ°é‚£æ—¶ `ones` å°†è¢«å®šä¹‰ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨å…³é”®å­— `rec` æ¥å‘ Pyret
    è¡¨æ˜è¿™ä¸€ç‚¹ï¼š
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that in Pyret, every `fun` implicitly has a `rec` beneath it, which is
    why we can create recursive functions with aplomb.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨ Pyret ä¸­ï¼Œæ¯ä¸ª `fun` éƒ½éšå¼åœ°æœ‰ä¸€ä¸ª `rec` åœ¨å…¶ä¸‹æ–¹ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬å¯ä»¥è½»æ¾åœ°åˆ›å»ºé€’å½’å‡½æ•°ã€‚
- en: Exercise
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Earlier we said that we canâ€™t write
  id: totrans-76
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¹‹å‰æˆ‘ä»¬è¯´è¿‡ï¼Œæˆ‘ä»¬æ— æ³•å†™å‡º
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-78
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if we tried to write
  id: totrans-80
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬å°è¯•å†™å‡º
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-82
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: instead? Does this work and, if so, what value is `ones` bound to? If it doesnâ€™t
    work, does it fail to work for the same reason as the definition without the `rec`?
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œè¿™æ ·åšè¡Œå¾—é€šå—ï¼Ÿå¦‚æœè¡Œå¾—é€šï¼Œ`ones` ç»‘å®šçš„å€¼æ˜¯ä»€ä¹ˆï¼Ÿå¦‚æœä¸è¡Œï¼Œå®ƒæ˜¯å¦å› ä¸ºä¸æ²¡æœ‰ `rec` çš„å®šä¹‰ç›¸åŒçš„åŸå› è€Œå¤±è´¥ï¼Ÿ
- en: 'Henceforth, we will use the shorthand [[A Helpful Shorthand for Anonymous Functions](#%28part._lam-shorthand%29)]
    instead. Therefore, we can rewrite the above definition as:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ä»æ­¤ä»¥åï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ç¼©å†™ [[åŒ¿åå‡½æ•°çš„æœ‰ç”¨ç¼©å†™](#(part._lam-shorthand))] æ¥ä»£æ›¿ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸Šè¿°å®šä¹‰é‡å†™ä¸ºï¼š
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice that `{(): â€¦}` defines an anonymous function of no arguments. You canâ€™t
    leave out the `()`! If you do, Pyret will get confused about what your program
    means.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ³¨æ„ï¼Œ`{(): â€¦}` å®šä¹‰äº†ä¸€ä¸ªæ— å‚æ•°çš„åŒ¿åå‡½æ•°ã€‚ä½ ä¸èƒ½çœç•¥ `()`ï¼å¦‚æœä½ è¿™æ ·åšï¼ŒPyret ä¼šå¯¹ä½ çš„ç¨‹åºçš„å«ä¹‰æ„Ÿåˆ°å›°æƒ‘ã€‚'
- en: 'Because functions are automatically recursive, when we write a function to
    create a stream, we donâ€™t need to use `rec`. Consider this example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºå‡½æ•°æ˜¯è‡ªåŠ¨é€’å½’çš„ï¼Œå½“æˆ‘ä»¬ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥åˆ›å»ºæµæ—¶ï¼Œæˆ‘ä»¬ä¸éœ€è¦ä½¿ç”¨ `rec`ã€‚è€ƒè™‘ä»¥ä¸‹ç¤ºä¾‹ï¼š
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'with which we can define the natural numbers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥å®šä¹‰è‡ªç„¶æ•°ï¼š
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the definition of `nats` is not recursive itselfâ€”<wbr>the recursion
    is inside `nats-from`â€”<wbr>so we donâ€™t need to use `rec` to define `nats`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ`nats` çš„å®šä¹‰æœ¬èº«ä¸æ˜¯é€’å½’çš„â€”â€”é€’å½’å‘ç”Ÿåœ¨ `nats-from` å†…éƒ¨â€”â€”å› æ­¤æˆ‘ä»¬ä¸éœ€è¦ä½¿ç”¨ `rec` æ¥å®šä¹‰ `nats`ã€‚
- en: Do Now!
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Earlier, we said that every list is finite and hence eventually terminates.
    How does this remark apply to streams, such as the definition of `ones` or `nats`
    above?
  id: totrans-95
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¹‹å‰ï¼Œæˆ‘ä»¬è¯´è¿‡æ¯ä¸ªåˆ—è¡¨éƒ½æ˜¯æœ‰é™çš„ï¼Œå› æ­¤æœ€ç»ˆä¼šç»ˆæ­¢ã€‚è¿™ä¸ªè¯„è®ºå¦‚ä½•é€‚ç”¨äºæµï¼Œä¾‹å¦‚ä¸Šé¢ `ones` æˆ– `nats` çš„å®šä¹‰ï¼Ÿ
- en: 'The description of `ones` is still a finite one; it simply represents the potential
    for an infinite number of values. Note that:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ones` çš„æè¿°ä»ç„¶æ˜¯ä¸€ä¸ªæœ‰é™çš„æè¿°ï¼›å®ƒä»…ä»…ä»£è¡¨äº†æ— é™å¤šä¸ªå€¼çš„å¯èƒ½æ€§ã€‚æ³¨æ„ï¼š'
- en: A similar reasoning doesnâ€™t apply to lists because the rest of the list has
    already been constructed; in contrast, placing a function there creates the potential
    for a potentially unbounded amount of computation to still be forthcoming.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ç±»ä¼¼çš„æ¨ç†ä¸é€‚ç”¨äºåˆ—è¡¨ï¼Œå› ä¸ºåˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†å·²ç»è¢«æ„é€ å¥½äº†ï¼›ç›¸æ¯”ä¹‹ä¸‹ï¼Œåœ¨é‚£é‡Œæ”¾ç½®ä¸€ä¸ªå‡½æ•°åˆ™å¯èƒ½äº§ç”Ÿå¤§é‡å°šæœªåˆ°æ¥çš„è®¡ç®—ã€‚
- en: That said, even with streams, in any given computation, we will create only
    a finite prefix of the stream. However, we donâ€™t have to prematurely decide how
    many; each client and use is welcome to extract less or more, as needed.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¯è™½å¦‚æ­¤ï¼Œå³ä½¿å¯¹äºæµï¼Œåœ¨ä»»ä½•ç»™å®šçš„è®¡ç®—ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿå°†åªåˆ›å»ºæµæœ‰é™çš„å‰ç¼€ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ä¸å¿…è¿‡æ—©åœ°å†³å®šæ•°é‡ï¼›æ¯ä¸ªå®¢æˆ·ç«¯å’Œä½¿ç”¨éƒ½å¯ä»¥æ ¹æ®éœ€è¦æå–æ›´å¤šæˆ–æ›´å°‘ã€‚
- en: 'Now weâ€™ve created multiple streams, but we still donâ€™t have an easy way to
    â€œseeâ€ one. First weâ€™ll define the traditional list-like selectors. Getting the
    first element works exactly as with lists:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»åˆ›å»ºäº†å¤šä¸ªæµï¼Œä½†æˆ‘ä»¬ä»ç„¶æ²¡æœ‰ä¸€ç§ç®€å•çš„æ–¹æ³•æ¥â€œçœ‹åˆ°â€ä¸€ä¸ªã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å°†å®šä¹‰ä¼ ç»Ÿçš„ç±»ä¼¼åˆ—è¡¨çš„é€‰æ‹©å™¨ã€‚è·å–ç¬¬ä¸€ä¸ªå…ƒç´ ä¸åˆ—è¡¨ä¸­çš„æ“ä½œå®Œå…¨ä¸€æ ·ï¼š
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In contrast, when trying to access the rest of the stream, all we get out of
    the data structure is a thunk. To access the actual rest, we need to force the
    thunk, which of course means applying it to no arguments:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸æ¯”ä¹‹ä¸‹ï¼Œå½“å°è¯•è®¿é—®æµçš„å…¶ä½™éƒ¨åˆ†æ—¶ï¼Œä»æ•°æ®ç»“æ„ä¸­æˆ‘ä»¬åªèƒ½å¾—åˆ°ä¸€ä¸ª thunkã€‚è¦è®¿é—®å®é™…çš„å…¶ä½™éƒ¨åˆ†ï¼Œæˆ‘ä»¬éœ€è¦å¼ºåˆ¶è¿™ä¸ª thunkï¼Œå½“ç„¶è¿™æ„å‘³ç€å°†å…¶åº”ç”¨äºæ— å‚æ•°ï¼š
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is useful for examining individual values of the stream. It is also useful
    to extract a finite prefix of it (of a given size) as a (regular) list, which
    would be especially handy for testing. Letâ€™s write that function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯¹äºæ£€æŸ¥æµçš„å•ä¸ªå€¼å¾ˆæœ‰ç”¨ã€‚æå–å®ƒæœ‰é™çš„å‰ç¼€ï¼ˆç»™å®šå¤§å°ï¼‰ä½œä¸ºä¸€ä¸ªï¼ˆå¸¸è§„ï¼‰åˆ—è¡¨ä¹Ÿå¾ˆæœ‰ç”¨ï¼Œè¿™å¯¹äºæµ‹è¯•ç‰¹åˆ«æœ‰ç”¨ã€‚è®©æˆ‘ä»¬ç¼–å†™è¿™ä¸ªå‡½æ•°ï¼š
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you pay close attention, youâ€™ll find that this body is not defined by cases
    over the structure of the (stream) inputâ€”<wbr>instead, itâ€™s defined by the cases
    of the definition of a natural number (zero or a successor). Weâ€™ll return to this
    below ([<lz-map2-def>](#%28elem._lz-map2-def%29)).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ä»”ç»†è§‚å¯Ÿï¼Œä½ ä¼šå‘ç°è¿™ä¸ªä½“ä¸æ˜¯é€šè¿‡ï¼ˆæµï¼‰è¾“å…¥çš„ç»“æ„æ¥å®šä¹‰çš„æ¡ˆä¾‹â€”â€”ç›¸åï¼Œå®ƒæ˜¯é€šè¿‡è‡ªç„¶æ•°å®šä¹‰çš„æ¡ˆä¾‹ï¼ˆé›¶æˆ–åç»§ï¼‰ã€‚æˆ‘ä»¬å°†åœ¨ä¸‹é¢å›åˆ°è¿™ä¸ªé—®é¢˜ ([<lz-map2-def>](#%28elem._lz-map2-def%29))ã€‚
- en: 'Now that we have this, we can use it for testing. Note that usually we use
    our data to test our functions; here, weâ€™re using this function to test our data:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†è¿™ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥è¿›è¡Œæµ‹è¯•ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬é€šå¸¸ä½¿ç”¨æˆ‘ä»¬çš„æ•°æ®æ¥æµ‹è¯•æˆ‘ä»¬çš„å‡½æ•°ï¼›è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªå‡½æ•°æ¥æµ‹è¯•æˆ‘ä»¬çš„æ•°æ®ï¼š
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The notation `(_ + 1)` defines a Pyret function of one argument that adds `1`
    to the given argument.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¦å·`(_ + 1)`å®šä¹‰äº†ä¸€ä¸ªæ¥å—ä¸€ä¸ªå‚æ•°å¹¶å°†`1`åŠ åˆ°ç»™å®šå‚æ•°ä¸Šçš„ Pyret å‡½æ•°ã€‚
- en: 'Letâ€™s define one more function: the equivalent of `map` over streams. For reasons
    that will soon become obvious, weâ€™ll define a version that takes two lists and
    applies the first argument to them pointwise:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å®šä¹‰å¦ä¸€ä¸ªå‡½æ•°ï¼šæµçš„`map`ç­‰ä»·å‡½æ•°ã€‚ç”±äºå¾ˆå¿«å°±ä¼šå˜å¾—æ˜æ˜¾çš„åŸå› ï¼Œæˆ‘ä»¬å°†å®šä¹‰ä¸€ä¸ªç‰ˆæœ¬ï¼Œå®ƒæ¥å—ä¸¤ä¸ªåˆ—è¡¨å¹¶å°†ç¬¬ä¸€ä¸ªå‚æ•°é€ç‚¹åº”ç”¨äºå®ƒä»¬ï¼š
- en: <lz-map2-def> ::=
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <lz-map2-def> ::=
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we can see our earlier remark about the structure of the function driven
    home especially clearly. Whereas a traditional `map` over lists would have two
    cases, here we have only one case because the data definition ([<stream-type-def>](#%28elem._stream-type-def%29))
    has only one case! What is the consequence of this? In a traditional `map`, one
    case looks like the above, but the other case corresponds to the `empty` input,
    for which it produces the same output. Here, because the stream never terminates,
    mapping over it doesnâ€™t either, and the structure of the function reflects this.This
    raises a much subtler problem: if the functionâ€™s body doesnâ€™t have base- and inductive-cases,
    how can we perform an inductive proof over it? The short answer is we canâ€™t: we
    must instead use [â˜› coinduction](glossary.html#%28elem._glossary-coinduction%29).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥ç‰¹åˆ«æ¸…æ¥šåœ°çœ‹åˆ°æˆ‘ä»¬ä¹‹å‰å…³äºå‡½æ•°ç»“æ„çš„è¯„è®ºã€‚è€Œä¼ ç»Ÿçš„åˆ—è¡¨`map`æœ‰ä¸¤ä¸ªæ¡ˆä¾‹ï¼Œè¿™é‡Œæˆ‘ä»¬åªæœ‰ä¸€ä¸ªæ¡ˆä¾‹ï¼Œå› ä¸ºæ•°æ®å®šä¹‰ ([<stream-type-def>](#%28elem._stream-type-def%29))åªæœ‰ä¸€ä¸ªæ¡ˆä¾‹ï¼è¿™æœ‰ä»€ä¹ˆåæœï¼Ÿåœ¨ä¼ ç»Ÿçš„`map`ä¸­ï¼Œä¸€ä¸ªæ¡ˆä¾‹çœ‹èµ·æ¥åƒä¸Šé¢é‚£æ ·ï¼Œä½†å¦ä¸€ä¸ªæ¡ˆä¾‹å¯¹åº”äº`empty`è¾“å…¥ï¼Œå®ƒäº§ç”Ÿç›¸åŒçš„è¾“å‡ºã€‚è¿™é‡Œï¼Œå› ä¸ºæµæ°¸è¿œä¸ä¼šç»ˆæ­¢ï¼Œæ‰€ä»¥æ˜ å°„ä¹Ÿä¸ä¼šç»ˆæ­¢ï¼Œå‡½æ•°çš„ç»“æ„åæ˜ äº†è¿™ä¸€ç‚¹ã€‚è¿™å¼•å‘äº†ä¸€ä¸ªæ›´å¾®å¦™çš„é—®é¢˜ï¼šå¦‚æœå‡½æ•°çš„ä¸»ä½“æ²¡æœ‰åŸºç¡€å’Œå½’çº³æ¡ˆä¾‹ï¼Œæˆ‘ä»¬å¦‚ä½•å¯¹å®ƒè¿›è¡Œå½’çº³è¯æ˜ï¼Ÿç®€çŸ­çš„ç­”æ¡ˆæ˜¯ï¼Œæˆ‘ä»¬ä¸èƒ½ï¼šæˆ‘ä»¬å¿…é¡»æ”¹ç”¨[â˜›å½’çº³å½’çº³](glossary.html#%28elem._glossary-coinduction%29)ã€‚
- en: 'Why did we define `lz-map2` instead of `lz-map`? Because it enables us to write
    the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæˆ‘ä»¬å®šä¹‰`lz-map2`è€Œä¸æ˜¯`lz-map`ï¼Ÿå› ä¸ºå®ƒä½¿æˆ‘ä»¬èƒ½å¤Ÿç¼–å†™ä»¥ä¸‹å†…å®¹ï¼š
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: from which, of course, we can extract as many Fibonacci numbers as we want!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ä»ä¸­ï¼Œå½“ç„¶ï¼Œæˆ‘ä»¬å¯ä»¥æå–æˆ‘ä»¬æƒ³è¦çš„ä»»ä½•æ–æ³¢é‚£å¥‘æ•°ï¼
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Exercise
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define the equivalent of `map` and `filter` for streams.
  id: totrans-119
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®šä¹‰æµçš„`map`å’Œ`filter`ç­‰ä»·å‡½æ•°ã€‚
- en: Streams and, more generally, infinite data structures that unfold on demand
    are extremely valuable in programming. Consider, for instance, the possible moves
    in a game. In some games, this can be infinite; even if it is finite, for interesting
    games the combinatorics mean that the tree is too large to feasibly store in memory.
    Therefore, the programmer of the computerâ€™s intelligence must unfold the game
    tree on demand. Programming it by using the encoding we have described above means
    the program describes the entire tree, lazily, and the tree unfolds automatically
    on demand, relieving the programmer of the burden of implementing such a strategy.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: æµå’Œæ›´ä¸€èˆ¬åœ°ï¼ŒæŒ‰éœ€å±•å¼€çš„æ— é™æ•°æ®ç»“æ„åœ¨ç¼–ç¨‹ä¸­éå¸¸æœ‰ä»·å€¼ã€‚è€ƒè™‘ï¼Œä¾‹å¦‚ï¼Œæ¸¸æˆä¸­å¯èƒ½é‡‡å–çš„ç§»åŠ¨ã€‚åœ¨æŸäº›æ¸¸æˆä¸­ï¼Œè¿™å¯èƒ½æ— é™ï¼›å³ä½¿å®ƒæ˜¯æœ‰é™çš„ï¼Œå¯¹äºæœ‰è¶£çš„æ¸¸æˆï¼Œç»„åˆæ•°å­¦æ„å‘³ç€æ ‘å¤ªå¤§ï¼Œæ— æ³•å®é™…å­˜å‚¨åœ¨å†…å­˜ä¸­ã€‚å› æ­¤ï¼Œè®¡ç®—æœºæ™ºèƒ½çš„ç¨‹åºå‘˜å¿…é¡»æŒ‰éœ€å±•å¼€æ¸¸æˆæ ‘ã€‚ä½¿ç”¨æˆ‘ä»¬ä¸Šé¢æè¿°çš„ç¼–ç æ¥ç¼–ç¨‹æ„å‘³ç€ç¨‹åºæ‡’æƒ°åœ°æè¿°æ•´ä¸ªæ ‘ï¼Œæ ‘æŒ‰éœ€è‡ªåŠ¨å±•å¼€ï¼Œå‡è½»äº†ç¨‹åºå‘˜å®ç°è¿™ç§ç­–ç•¥çš„è´Ÿæ‹…ã€‚
- en: In some languages, such as Haskell, lazy evaluation is built in by default.
    In such a language, there is no need to use thunks. However, lazy evaluation places
    other burdens on the language, which you can learn about in a programming-languages
    class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æŸäº›è¯­è¨€ä¸­ï¼Œä¾‹å¦‚ Haskellï¼Œé»˜è®¤æƒ…å†µä¸‹å°±å†…ç½®äº†æƒ°æ€§æ±‚å€¼ã€‚åœ¨è¿™æ ·çš„è¯­è¨€ä¸­ï¼Œä¸éœ€è¦ä½¿ç”¨ thunksã€‚ç„¶è€Œï¼Œæƒ°æ€§æ±‚å€¼ç»™è¯­è¨€å¸¦æ¥äº†å…¶ä»–è´Ÿæ‹…ï¼Œä½ å¯ä»¥åœ¨ç¼–ç¨‹è¯­è¨€è¯¾ç¨‹ä¸­äº†è§£è¿™äº›ã€‚
- en: '8.1.4Â Combining Forces: Streams of Derivatives[ğŸ”—](#(part._d-dx-streams) "Link
    to here")'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.4Â ç»„åˆåŠ›é‡ï¼šå¯¼æ•°æµ[ğŸ”—](#(part._d-dx-streams) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: When we defined `d-dx`, we set `epsilon` to an arbitrary, high value. We could
    instead think of `epsilon` as itself a stream that produces successively finer
    values; then, for instance, when the difference in the value of the derivative
    becomes small enough, we can decide we have a sufficient approximation to the
    derivative.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬å®šä¹‰`d-dx`æ—¶ï¼Œæˆ‘ä»¬å°†`epsilon`è®¾ç½®ä¸ºä¸€ä¸ªä»»æ„çš„é«˜å€¼ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥å°†`epsilon`æœ¬èº«çœ‹ä½œæ˜¯ä¸€ä¸ªäº§ç”Ÿè¶Šæ¥è¶Šç²¾ç»†å€¼çš„æµï¼›ç„¶åï¼Œä¾‹å¦‚ï¼Œå½“å¯¼æ•°å€¼çš„å·®å¼‚è¶³å¤Ÿå°çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥å†³å®šæˆ‘ä»¬å·²ç»å¾—åˆ°äº†å¯¼æ•°çš„è¶³å¤Ÿè¿‘ä¼¼ã€‚
- en: The first step is, therefore, to make `epsilon` some kind of parameter rather
    than a global constant. That leaves open what kind of parameter it should be (number
    or stream?) as well as when it should be supplied.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œç¬¬ä¸€æ­¥æ˜¯å°†`epsilon`å˜æˆæŸç§å‚æ•°ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå…¨å±€å¸¸æ•°ã€‚è¿™ç•™ä¸‹äº†å®ƒåº”è¯¥æ˜¯ä»€ä¹ˆç±»å‹çš„å‚æ•°ï¼ˆæ•°å­—æˆ–æµï¼Ÿï¼‰ä»¥åŠä½•æ—¶æä¾›çš„é—®é¢˜ã€‚
- en: 'It makes most sense to consume this parameter after we have decided what function
    we want to differentiate and at what value we want its derivative; after all,
    the stream of `epsilon` values may depend on both. Thus, we get:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬å†³å®šæˆ‘ä»¬æƒ³è¦å¾®åˆ†å“ªä¸ªå‡½æ•°ä»¥åŠæˆ‘ä»¬æƒ³è¦å…¶å¯¼æ•°çš„å€¼ä¹‹åï¼Œæ¶ˆè´¹è¿™ä¸ªå‚æ•°æœ€æœ‰æ„ä¹‰ï¼›æ¯•ç«Ÿï¼Œ`epsilon`å€¼çš„æµå¯èƒ½å–å†³äºè¿™ä¸¤ä¸ªã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¾—åˆ°ï¼š
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'with which we can return to our `square` example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡è¿™ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥å›åˆ°æˆ‘ä»¬çš„`square`ä¾‹å­ï¼š
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that at this point we have simply redefined `d-dx` without any reference
    to streams: we have merely made a constant into a parameter.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨è¿™ä¸ªç‚¹ä¸Šï¼Œæˆ‘ä»¬åªæ˜¯é‡æ–°å®šä¹‰äº†`d-dx`ï¼Œè€Œæ²¡æœ‰æåŠä»»ä½•å…³äºæµçš„å‚è€ƒï¼šæˆ‘ä»¬åªæ˜¯å°†ä¸€ä¸ªå¸¸æ•°å˜æˆäº†ä¸€ä¸ªå‚æ•°ã€‚
- en: 'Now letâ€™s define the stream of negative powers of ten:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬å®šä¹‰åçš„è´Ÿå¹‚çš„æµï¼š
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: so that
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For concreteness, letâ€™s pick an abscissa at which to compute the numeric derivative
    of `square`â€”<wbr>say `10`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å…·ä½“åŒ–ï¼Œè®©æˆ‘ä»¬é€‰æ‹©ä¸€ä¸ªæ¨ªåæ ‡æ¥è®¡ç®—`square`çš„æ•°å€¼å¯¼æ•°â€”â€”æ¯”å¦‚è¯´`10`ï¼š
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Recall, from the types, that this is now a function of type `(Number -> Number)`:
    given a value for `epsilon`, it computes the derivative using that value. We know,
    analytically, that the value of this derivative should be `20`. We can now (lazily)
    map `tenths` to provide increasingly better approximations for `epsilon` and see
    what happens:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹ï¼Œä»ç±»å‹æ¥çœ‹ï¼Œè¿™ç°åœ¨æ˜¯ä¸€ä¸ªç±»å‹ä¸º`(Number -> Number)`çš„å‡½æ•°ï¼šç»™å®šä¸€ä¸ª`epsilon`çš„å€¼ï¼Œå®ƒä½¿ç”¨è¿™ä¸ªå€¼æ¥è®¡ç®—å¯¼æ•°ã€‚æˆ‘ä»¬çŸ¥é“ï¼Œä»ç†è®ºä¸Šè®²ï¼Œè¿™ä¸ªå¯¼æ•°çš„å€¼åº”è¯¥æ˜¯`20`ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥ï¼ˆæ‡’æ•£åœ°ï¼‰å°†`tenths`æ˜ å°„åˆ°æä¾›å¯¹`epsilon`çš„è¶Šæ¥è¶Šå¥½çš„è¿‘ä¼¼ï¼Œå¹¶çœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆï¼š
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Sure enough, the values we obtain are `20.1`, `20.01`, `20.001`, and so on:
    progressively better numerical approximations to `20`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: æœç„¶ï¼Œæˆ‘ä»¬å¾—åˆ°çš„æ˜¯`20.1`ï¼Œ`20.01`ï¼Œ`20.001`ç­‰ç­‰ï¼šå¯¹`20`çš„è¶Šæ¥è¶Šå¥½çš„æ•°å€¼è¿‘ä¼¼ã€‚
- en: Exercise
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend the above program to take a tolerance, and draw as many values from the
    `epsilon` stream as necessary until the difference between successive approximations
    of the derivative fall within this tolerance.
  id: totrans-141
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°†ä¸Šè¿°ç¨‹åºæ‰©å±•ä»¥æ¥å—ä¸€ä¸ªå®¹å·®ï¼Œå¹¶ä»`epsilon`æµä¸­æŠ½å–å°½å¯èƒ½å¤šçš„å€¼ï¼Œç›´åˆ°å¯¼æ•°çš„è¿ç»­è¿‘ä¼¼ä¹‹é—´çš„å·®å¼‚è½åœ¨è¯¥å®¹å·®å†…ã€‚
- en: 8.1.1Â A Little Calculus[ğŸ”—](#(part._fd-calculus) "Link to here")
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1Â ä¸€ç‚¹å¾®ç§¯åˆ†[ğŸ”—](#(part._fd-calculus) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'If youâ€™ve studied the differential calculus, youâ€™ve come across curious sytactic
    statements such as this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ç ”ç©¶è¿‡å¾®åˆ†å­¦ï¼Œä½ å¯èƒ½ä¼šé‡åˆ°è¿™æ ·çš„å¥‡æ€ªè¯­æ³•é™ˆè¿°ï¼š
- en: \begin{equation*}{\frac{d}{dx}} x^2 = 2x\end{equation*}
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}{\frac{d}{dx}} x^2 = 2x\end{equation*}
- en: 'Letâ€™s unpack what this means: the \(d/dx\), the \(x^2\), and the \(2x\).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åˆ†æä¸€ä¸‹è¿™æ„å‘³ç€ä»€ä¹ˆï¼š\(d/dx\)ï¼Œ\(x^2\)ï¼Œå’Œ\(2x\)ã€‚
- en: 'First, letâ€™s take on the two expressions; weâ€™ll discuss one, and the discussion
    will cover the other as well. The correct response to â€œwhat does \(x^2\) mean?â€
    is, of course, an error: it doesnâ€™t mean anything, because \(x\) is an unbound
    identifier.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè®©æˆ‘ä»¬å¤„ç†è¿™ä¸¤ä¸ªè¡¨è¾¾å¼ï¼›æˆ‘ä»¬å°†è®¨è®ºä¸€ä¸ªï¼Œè®¨è®ºå°†æ¶µç›–å¦ä¸€ä¸ªã€‚å¯¹â€œ\(x^2\)æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿâ€çš„æ­£ç¡®å›ç­”å½“ç„¶æ˜¯é”™è¯¯ï¼šå®ƒæ²¡æœ‰ä»»ä½•æ„ä¹‰ï¼Œå› ä¸º\(x\)æ˜¯ä¸€ä¸ªæœªç»‘å®šçš„æ ‡è¯†ç¬¦ã€‚
- en: 'So what is it intended to mean? The intent, clearly, is to represent the function
    that squares its input, just as \(2x\) is meant to be the function that doubles
    its input. We have nicer ways of writing those:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£å®ƒçš„æ„å›¾æ˜¯ä»€ä¹ˆï¼Ÿå¾ˆæ˜æ˜¾ï¼Œæ„å›¾æ˜¯è¡¨ç¤ºä¸€ä¸ªå¹³æ–¹å…¶è¾“å…¥çš„å‡½æ•°ï¼Œå°±åƒ\(2x\)æ„å›¾æ˜¯è¡¨ç¤ºä¸€ä¸ªå°†å…¶è¾“å…¥ç¿»å€çš„å‡½æ•°ä¸€æ ·ã€‚æˆ‘ä»¬æœ‰æ›´ä¼˜é›…çš„æ–¹å¼æ¥å†™è¿™äº›ï¼š
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: and what weâ€™re really trying to say is that the \(d/dx\) (whatever that is)
    of `sq` is `dbl`.Weâ€™re assuming functions of arity one in the variable that is
    changing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çœŸæ­£è¯•å›¾è¯´çš„æ˜¯ï¼Œ`sq`çš„\(d/dx\)ï¼ˆæ— è®ºé‚£æ˜¯ä»€ä¹ˆï¼‰æ˜¯`dbl`ã€‚æˆ‘ä»¬å‡è®¾çš„æ˜¯ä¸€å…ƒå˜é‡ä¸­çš„å‡½æ•°ã€‚
- en: 'So now letâ€™s unpack \(d/dx\), starting with its type. As the above example
    illustrates, \(d/dx\) is really a function from functions to functions. That is,
    we can write its type as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œç°åœ¨è®©æˆ‘ä»¬åˆ†æ\(d/dx\)ï¼Œä»å®ƒçš„ç±»å‹å¼€å§‹ã€‚æ­£å¦‚ä¸Šé¢çš„ä¾‹å­æ‰€è¯´æ˜çš„ï¼Œ\(d/dx\)å®é™…ä¸Šæ˜¯ä»å‡½æ•°åˆ°å‡½æ•°çš„å‡½æ•°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶ç±»å‹å†™æˆä»¥ä¸‹å½¢å¼ï¼š
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: (This type might explain why your calculus course never explained this operation
    this wayâ€”<wbr>though itâ€™s not clear that obscuring its true meaning is any better
    for your understanding.)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆè¿™ç§ç±»å‹å¯èƒ½è§£é‡Šäº†ä¸ºä»€ä¹ˆä½ çš„å¾®ç§¯åˆ†è¯¾ç¨‹ä»æœªè¿™æ ·è§£é‡Šè¿™ä¸ªæ“ä½œâ€”â€”å°½ç®¡ä¸æ¸…æ¥šæ©ç›–å…¶çœŸæ­£å«ä¹‰æ˜¯å¦å¯¹ä½ çš„ç†è§£æ›´æœ‰ç›Šã€‚ï¼‰
- en: Let us now implement `d-dx`. Weâ€™ll implement numerical differentiation, though
    in principle we could also implement symbolic differentiationâ€”<wbr>using rules
    you learned, e.g., given a polynomial, multiply by the exponent and reduce the
    exponent by oneâ€”<wbr>with a representation of expressions (a problem that will
    be covered in more detail in a future release).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç°åœ¨å®ç° `d-dx`ã€‚æˆ‘ä»¬å°†å®ç°æ•°å€¼å¾®åˆ†ï¼Œå°½ç®¡åŸåˆ™ä¸Šæˆ‘ä»¬ä¹Ÿå¯ä»¥å®ç°ç¬¦å·å¾®åˆ†â€”â€”ä½¿ç”¨ä½ å­¦åˆ°çš„è§„åˆ™ï¼Œä¾‹å¦‚ï¼Œç»™å®šä¸€ä¸ªå¤šé¡¹å¼ï¼Œä¹˜ä»¥æŒ‡æ•°å¹¶å‡å»ä¸€ä¸ªæŒ‡æ•°â€”â€”ä½¿ç”¨è¡¨è¾¾å¼çš„è¡¨ç¤ºï¼ˆè¿™ä¸ªé—®é¢˜å°†åœ¨æœªæ¥çš„ç‰ˆæœ¬ä¸­æ›´è¯¦ç»†åœ°ä»‹ç»ï¼‰ã€‚
- en: 'In general, numeric differentiation of a function at a point yields the value
    of the derivative at that point. We have a handy formula for it: the derivative
    of \(f\) at \(x\) is'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸ï¼Œå‡½æ•°åœ¨ä¸€ç‚¹çš„æ•°å€¼å¾®åˆ†ç»™å‡ºè¯¥ç‚¹çš„å¯¼æ•°å€¼ã€‚æˆ‘ä»¬æœ‰ä¸€ä¸ªæ–¹ä¾¿çš„å…¬å¼ï¼š\(f\) åœ¨ \(x\) å¤„çš„å¯¼æ•°æ˜¯
- en: \begin{equation*}\frac{f(x + \epsilon) - f(x)}{\epsilon}\end{equation*}
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}\frac{f(x + \epsilon) - f(x)}{\epsilon}\end{equation*}
- en: 'as \(\epsilon\) goes to zero in the limit. For now weâ€™ll give the infinitesimal
    a small but fixed value, and later [[Combining Forces: Streams of Derivatives](#%28part._d-dx-streams%29)]
    see how we can improve on this.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'å½“ \(\epsilon\) è¶‹äºé›¶æ—¶ã€‚ç°åœ¨æˆ‘ä»¬å°†ç»™æ— ç©·å°ä¸€ä¸ªå°çš„ä½†å›ºå®šçš„å€¼ï¼Œç¨å [[Combining Forces: Streams of Derivatives](#%28part._d-dx-streams%29)]
    æˆ‘ä»¬å°†çœ‹çœ‹æˆ‘ä»¬å¦‚ä½•æ”¹è¿›è¿™ä¸€ç‚¹ã€‚'
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can now translate the above formula into a function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨å¯ä»¥å°†ä¸Šè¿°å…¬å¼è½¬æ¢æˆä¸€ä¸ªå‡½æ•°ï¼š
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And sure enough, we can check and make sure it works as expected:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ç¡®å®ï¼Œæˆ‘ä»¬å¯ä»¥æ£€æŸ¥å¹¶ç¡®ä¿å®ƒæŒ‰é¢„æœŸå·¥ä½œï¼š
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Confession: We chose the value of `epsilon` so that the default tolerance `is-roughly`
    works for this example.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ç™½è¯´ï¼šæˆ‘ä»¬é€‰æ‹©äº† `epsilon` çš„å€¼ï¼Œä»¥ä¾¿é»˜è®¤çš„å®¹å·® `is-roughly` å¯¹è¿™ä¸ªç¤ºä¾‹æœ‰æ•ˆã€‚
- en: 'However, there is something unsatisfying about this. The function weâ€™ve written
    clearly does not have the type we described earlier! What we wanted was an operation
    that takes just a function, and represents the platonic notion of differentiation;
    but weâ€™ve been forced, by the nature of numeric differentiation, to describe the
    derivative at a point. We might instead like to write something like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¿™æœ‰ç‚¹ä»¤äººä¸æ»¡æ„ã€‚æˆ‘ä»¬ç¼–å†™çš„å‡½æ•°æ˜¾ç„¶ä¸å…·æœ‰æˆ‘ä»¬ä¹‹å‰æè¿°çš„ç±»å‹ï¼æˆ‘ä»¬æƒ³è¦çš„æ˜¯ä¸€ä¸ªåªæ¥å—å‡½æ•°çš„æ“ä½œï¼Œå¹¶ä»£è¡¨æŸæ‹‰å›¾å¼çš„å¾®åˆ†æ¦‚å¿µï¼›ä½†ç”±äºæ•°å€¼å¾®åˆ†çš„æ€§è´¨ï¼Œæˆ‘ä»¬è¢«è¿«æè¿°åœ¨ä¸€ç‚¹çš„å¯¼æ•°ã€‚æˆ‘ä»¬å¯èƒ½æ›´å–œæ¬¢å†™è¿™æ ·ï¼š
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Do Now!
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whatâ€™s the problem with the above definition?
  id: totrans-167
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸Šé¢çš„å®šä¹‰æœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ
- en: 'If you didnâ€™t notice, Pyret will soon tell you: `x` isnâ€™t bound. Indeed, what
    is `x`? Itâ€™s the point at which weâ€™re trying to compute the numeric derivative.
    That is, `d-dx` needs to return not a number but a function (as the type indicates)
    that will consume this `x`:â€œLambdas are relegated to relative obscurity until
    Java makes them popular by not having them.â€â€”<wbr>James Iry, [A Brief, Incomplete,
    and Mostly Wrong History of Programming Languages](https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æ²¡æœ‰æ³¨æ„åˆ°ï¼ŒPyret å°†å¾ˆå¿«å‘Šè¯‰ä½ ï¼š`x` æ²¡æœ‰ç»‘å®šã€‚å®é™…ä¸Šï¼Œ`x` æ˜¯ä»€ä¹ˆï¼Ÿå®ƒæ˜¯æˆ‘ä»¬è¯•å›¾è®¡ç®—æ•°å€¼å¯¼æ•°çš„ç‚¹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ`d-dx` éœ€è¦è¿”å›ä¸€ä¸ªå‡½æ•°ï¼ˆæ­£å¦‚ç±»å‹æ‰€æŒ‡ç¤ºçš„ï¼‰ï¼Œå®ƒå°†æ¶ˆè€—è¿™ä¸ª
    `x`ï¼šâ€œLambdas are relegated to relative obscurity until Java makes them popular
    by not having them.â€â€”<wbr>James Iry, [A Brief, Incomplete, and Mostly Wrong History
    of Programming Languages](https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html)
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we want to be a little more explicit we can annotate the inner function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³æ›´æ˜ç¡®ä¸€äº›ï¼Œæˆ‘ä»¬å¯ä»¥æ³¨é‡Šå†…éƒ¨å‡½æ•°ï¼š
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is a special case of a concept useful in many programming contexts, which
    we explore in more detail elsewhere: [Staging](staging.html).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯è®¸å¤šç¼–ç¨‹ç¯å¢ƒä¸­ä¸€ä¸ªæœ‰ç”¨æ¦‚å¿µçš„ç‰¹æ®Šæƒ…å†µï¼Œæˆ‘ä»¬å°†åœ¨å…¶ä»–åœ°æ–¹æ›´è¯¦ç»†åœ°æ¢è®¨ï¼š[Staging](staging.html)ã€‚
- en: 'Sure enough, this definition now works. We can, for instance, test it as follows
    (note the use of `num-floor` to avoid numeric precision issues from making our
    tests appear to fail):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ç¡®å®ï¼Œè¿™ä¸ªå®šä¹‰ç°åœ¨å¯ä»¥å·¥ä½œäº†ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·æµ‹è¯•å®ƒï¼ˆæ³¨æ„ä½¿ç”¨ `num-floor` ä»¥é¿å…ç”±äºæµ‹è¯•å¤±è´¥è€Œå‡ºç°çš„æ•°å€¼ç²¾åº¦é—®é¢˜ï¼‰ï¼š
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we can return to the original example that launched this investigation:
    what the sloppy and mysterious notation of math is really trying to say is,'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å›åˆ°å¯åŠ¨è¿™æ¬¡è°ƒæŸ¥çš„åŸå§‹ç¤ºä¾‹ï¼šæ•°å­¦ä¸­æ··ä¹±ä¸”ç¥ç§˜çš„ç¬¦å·çœŸæ­£è¯•å›¾è¡¨è¾¾çš„æ„æ€æ˜¯ï¼Œ
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: or, in the notation of [A Notation for Functions](predicting-growth.html#%28part._math-anon-functions%29),
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…ï¼Œåœ¨[å‡½æ•°è¡¨ç¤ºæ³•](predicting-growth.html#%28part._math-anon-functions%29)çš„è¡¨ç¤ºæ³•ä¸­ï¼Œ
- en: \begin{equation*}{\frac{d}{dx}} [x \rightarrow x^2] = [x \rightarrow 2x]\end{equation*}
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}{\frac{d}{dx}} [x \rightarrow x^2] = [x \rightarrow 2x]\end{equation*}
- en: Pity math textbooks for not wanting to tell us the truth!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: æƒœå“‰æ•°å­¦æ•™ç§‘ä¹¦ä¸æ„¿å‘Šè¯‰æˆ‘ä»¬çœŸç›¸ï¼
- en: 8.1.2Â A Helpful Shorthand for Anonymous Functions[ğŸ”—](#(part._lam-shorthand)
    "Link to here")
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2Â åŒ¿åå‡½æ•°çš„æœ‰ç”¨ç®€å†™[ğŸ”—](#(part._lam-shorthand) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Pyret offers a shorter syntax for writing anonymous functions. Though, stylistically,
    we generally avoid it so that our programs donâ€™t become a jumble of special characters,
    sometimes itâ€™s particularly convenient, as we will see below. This syntax is
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret æä¾›äº†ä¸€ç§æ›´çŸ­çš„è¯­æ³•æ¥ç¼–å†™åŒ¿åå‡½æ•°ã€‚è™½ç„¶ä»é£æ ¼ä¸Šè®²ï¼Œæˆ‘ä»¬é€šå¸¸é¿å…ä½¿ç”¨å®ƒï¼Œä»¥å…æˆ‘ä»¬çš„ç¨‹åºå˜æˆç‰¹æ®Šå­—ç¬¦çš„æ··ä¹±ï¼Œä½†æœ‰æ—¶å®ƒç‰¹åˆ«æ–¹ä¾¿ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚æ­¤è¯­æ³•æ˜¯
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'where `a` is zero or more arguments and `b` is the body. For instance, we can
    write `lam(x): x * x end` as'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'å…¶ä¸­`a`æ˜¯é›¶ä¸ªæˆ–å¤šä¸ªå‚æ•°ï¼Œ`b`æ˜¯ä¸»ä½“ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥å°†`lam(x): x * x end`å†™æˆ'
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: where we can see the benefit of brevity. In particular, note that there is no
    need for `end`, because the braces take the place of showing where the expression
    begins and ends. Similarly, we could have written `d-dx` as
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ç®€æ´æ€§çš„å¥½å¤„ã€‚ç‰¹åˆ«æ˜¯ï¼Œè¯·æ³¨æ„æ²¡æœ‰å¿…è¦ä½¿ç”¨`end`ï¼Œå› ä¸ºèŠ±æ‹¬å·å–ä»£äº†æ˜¾ç¤ºè¡¨è¾¾å¼å¼€å§‹å’Œç»“æŸçš„ä½ç½®ã€‚åŒæ ·ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å°†`d-dx`å†™æˆ
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: but many readers would say this makes the function harder to read, because the
    prominent `lam` makes clear that `d-dx` returns an (anonymous) function, whereas
    this syntax obscures it. Therefore, we will usually only use this shorthand syntax
    for â€œone-linersâ€.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è®¸å¤šè¯»è€…ä¼šè¯´è¿™ä½¿å‡½æ•°æ›´éš¾é˜…è¯»ï¼Œå› ä¸ºçªå‡ºçš„`lam`æ¸…æ¥šåœ°è¡¨æ˜`d-dx`è¿”å›ä¸€ä¸ªï¼ˆåŒ¿åï¼‰å‡½æ•°ï¼Œè€Œæ­¤è¯­æ³•åˆ™æ©ç›–äº†è¿™ä¸€ç‚¹ã€‚å› æ­¤ï¼Œæˆ‘ä»¬é€šå¸¸åªä¼šä¸ºâ€œä¸€è¡Œä»£ç â€ä½¿ç”¨è¿™ç§ç®€å†™è¯­æ³•ã€‚
- en: 8.1.3Â Streams From Functions[ğŸ”—](#(part._streams-from-funs) "Link to here")
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3Â ä»å‡½æ•°ç”Ÿæˆæµ[ğŸ”—](#(part._streams-from-funs) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'People typically think of a function as serving one purpose: to parameterize
    an expression. While that is both true and the most common use of a function,
    it does not justify having a function of no arguments, because that clearly parameterizes
    over nothing at all. Yet functions of no argument also have a use, because functions
    actually serve two purposes: to parameterize, and to suspend evaluation of the
    body until the function is applied. In fact, these two uses are orthogonal, in
    that one can employ one feature without the other. Below, we will focus on delay
    without abstraction (the other shows up in other computer science settings).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: äººä»¬é€šå¸¸è®¤ä¸ºå‡½æ•°åªæœ‰ä¸€ä¸ªç”¨é€”ï¼šå‚æ•°åŒ–ä¸€ä¸ªè¡¨è¾¾å¼ã€‚è™½ç„¶è¿™æ˜¯çœŸçš„ï¼Œä¹Ÿæ˜¯å‡½æ•°æœ€å¸¸è§çš„ä½¿ç”¨æ–¹å¼ï¼Œä½†è¿™å¹¶ä¸èƒ½è¯æ˜éœ€è¦ä¸€ä¸ªæ— å‚æ•°çš„å‡½æ•°ï¼Œå› ä¸ºé‚£æ˜¾ç„¶ä»€ä¹ˆéƒ½æ²¡æœ‰å‚æ•°åŒ–ã€‚ç„¶è€Œï¼Œæ— å‚æ•°çš„å‡½æ•°ä¹Ÿæœ‰å…¶ç”¨é€”ï¼Œå› ä¸ºå‡½æ•°å®é™…ä¸Šæœ‰ä¸¤ä¸ªç”¨é€”ï¼šå‚æ•°åŒ–å’Œå»¶è¿Ÿä¸»ä½“ç›´åˆ°å‡½æ•°è¢«åº”ç”¨æ—¶çš„è¯„ä¼°ã€‚å®é™…ä¸Šï¼Œè¿™ä¸¤ä¸ªç”¨é€”æ˜¯æ­£äº¤çš„ï¼Œå› ä¸ºå¯ä»¥åœ¨ä¸ä½¿ç”¨å¦ä¸€ä¸ªçš„æƒ…å†µä¸‹ä½¿ç”¨ä¸€ä¸ªç‰¹æ€§ã€‚ä¸‹é¢ï¼Œæˆ‘ä»¬å°†å…³æ³¨å»¶è¿Ÿè€Œä¸æŠ½è±¡ï¼ˆå¦ä¸€ä¸ªåœ¨å…¶ä»–è®¡ç®—æœºç§‘å­¦è®¾ç½®ä¸­å‡ºç°ï¼‰ã€‚
- en: 'Letâ€™s consider the humble list. A list can be only finitely long. However,
    there are many lists (or sequences) in nature that have no natural upper bound:
    from mathematical objects (the sequence of natural numbers) to natural ones (the
    sequence of hits to a Web site). Rather than try to squeeze these unbounded lists
    into bounded ones, letâ€™s look at how we might represent and program over these
    unbounded lists.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹ç®€å•çš„åˆ—è¡¨ã€‚åˆ—è¡¨å¯ä»¥æ˜¯æœ‰é™çš„ã€‚ç„¶è€Œï¼Œè‡ªç„¶ç•Œä¸­æœ‰è®¸å¤šæ²¡æœ‰è‡ªç„¶ä¸Šé™çš„åˆ—è¡¨ï¼ˆæˆ–åºåˆ—ï¼‰ï¼šä»æ•°å­¦å¯¹è±¡ï¼ˆè‡ªç„¶æ•°çš„åºåˆ—ï¼‰åˆ°è‡ªç„¶ç°è±¡ï¼ˆç½‘ç«™è®¿é—®çš„åºåˆ—ï¼‰ã€‚è€Œä¸æ˜¯è¯•å›¾å°†è¿™äº›æ— ç•Œçš„åˆ—è¡¨å‹ç¼©æˆæœ‰ç•Œçš„åˆ—è¡¨ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬å¦‚ä½•è¡¨ç¤ºå’Œç¼–ç¨‹è¿™äº›æ— ç•Œåˆ—è¡¨ã€‚
- en: 'First, letâ€™s write a program to compute the sequence of natural numbers:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè®©æˆ‘ä»¬ç¼–å†™ä¸€ä¸ªç¨‹åºæ¥è®¡ç®—è‡ªç„¶æ•°çš„åºåˆ—ï¼š
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Do Now!
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this program have a problem?
  id: totrans-195
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç¨‹åºæœ‰é—®é¢˜å—ï¼Ÿ
- en: 'While this represents our intent, it doesnâ€™t work: running itâ€”<wbr>e.g., `nats-from(0)`â€”<wbr>creates
    an infinite loop evaluating `nats-from` for every subsequent natural number. In
    other words, we want to write something very like the above, but that doesnâ€™t
    recur until we want it to, i.e., on demand. In other words, we want the rest of
    the list to be lazy.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶è¿™ä»£è¡¨äº†æˆ‘ä»¬çš„æ„å›¾ï¼Œä½†å®ƒä¸èµ·ä½œç”¨ï¼šè¿è¡Œå®ƒâ€”â€”ä¾‹å¦‚ï¼Œ`nats-from(0)`â€”â€”ä¼šåˆ›å»ºä¸€ä¸ªæ— é™å¾ªç¯ï¼Œå¯¹æ¯ä¸ªåç»­çš„è‡ªç„¶æ•°è¯„ä¼°`nats-from`ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å¸Œæœ›ç¼–å†™ç±»ä¼¼äºä¸Šé¢çš„å†…å®¹ï¼Œä½†åªæœ‰åœ¨éœ€è¦æ—¶æ‰é‡å¤ï¼Œå³æŒ‰éœ€ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å¸Œæœ›åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æ˜¯æƒ°æ€§çš„ã€‚
- en: This is where our insight into functions comes in. A function, as we have just
    noted, delays evaluation of its body until it is applied. Therefore, a function
    would, in principle, defer the invocation of `nats-from(n + 1)` until itâ€™s needed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯æˆ‘ä»¬å¯¹å‡½æ•°çš„æ´å¯ŸåŠ›æ‰€åœ¨ã€‚æ­£å¦‚æˆ‘ä»¬åˆšæ‰æåˆ°çš„ï¼Œå‡½æ•°ä¼šå»¶è¿Ÿå…¶ä¸»ä½“çš„è¯„ä¼°ï¼Œç›´åˆ°å®ƒè¢«åº”ç”¨ã€‚å› æ­¤ï¼ŒåŸåˆ™ä¸Šï¼Œå‡½æ•°å°†æ¨è¿Ÿ`nats-from(n + 1)`çš„è°ƒç”¨ï¼Œç›´åˆ°éœ€è¦æ—¶ã€‚
- en: 'Except, this creates a type problem: the second argument to `link` needs to
    be a list, and cannot be a function. Indeed, because it must be a list, and every
    value that has been constructed must be finite, every list is finite and eventually
    terminates in `empty`. Therefore, we need a new data structure to represent the
    links in these lazy lists (also known as streams):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†ï¼Œè¿™ä¼šåˆ›å»ºä¸€ä¸ªç±»å‹é—®é¢˜ï¼š`link` çš„ç¬¬äºŒä¸ªå‚æ•°éœ€è¦æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œè€Œä¸èƒ½æ˜¯ä¸€ä¸ªå‡½æ•°ã€‚ç¡®å®ï¼Œå› ä¸ºå®ƒå¿…é¡»æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œå¹¶ä¸”æ¯ä¸ªå·²æ„å»ºçš„å€¼éƒ½å¿…é¡»æ˜¯æœ‰é™çš„ï¼Œæ‰€ä»¥æ¯ä¸ªåˆ—è¡¨éƒ½æ˜¯æœ‰é™çš„ï¼Œæœ€ç»ˆä¼šåœ¨
    `empty` ä¸­ç»ˆæ­¢ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ–°çš„æ•°æ®ç»“æ„æ¥è¡¨ç¤ºè¿™äº›æ‡’åˆ—è¡¨ï¼ˆä¹Ÿç§°ä¸ºæµï¼‰ä¸­çš„é“¾æ¥ï¼š
- en: <stream-type-def> ::=
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stream-type-def> ::='
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: where the annotation `( -> Stream<T>)` means a function from no arguments (hence
    the lack of anything before `->`), also known as a thunk. Note that the way we
    have defined streams they must be infinite, since we have provided no way to terminate
    them.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­æ³¨é‡Š `( -> Stream<T>)` è¡¨ç¤ºä¸€ä¸ªæ— å‚æ•°çš„å‡½æ•°ï¼ˆå› æ­¤ `->` å‰é¢æ²¡æœ‰å…¶ä»–å†…å®¹ï¼‰ï¼Œä¹Ÿç§°ä¸º thunkã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬å®šä¹‰çš„æµå¿…é¡»æ˜¯æ— é™çš„ï¼Œå› ä¸ºæˆ‘ä»¬æ²¡æœ‰æä¾›ç»ˆæ­¢å®ƒä»¬çš„æ–¹æ³•ã€‚
- en: 'Letâ€™s construct the simplest example we can, a stream of constant values:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ„å»ºæœ€ç®€å•çš„ä¾‹å­ï¼Œä¸€ä¸ªå¸¸é‡å€¼çš„æµï¼š
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Pyret will actually complain about this definition. Note that the list equivalent
    of this also will not work:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret å®é™…ä¸Šä¼šå¯¹æ­¤å®šä¹‰æå‡ºæŠ±æ€¨ã€‚è¯·æ³¨æ„ï¼Œæ­¤åˆ—è¡¨ç­‰ä»·ç‰©ä¹Ÿä¸ä¼šå·¥ä½œï¼š
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'because `ones` is not defined at the point of definition, so when Pyret evaluates
    `link(1, ones)`, it complains that `ones` is not defined. However, it is being
    overly conservative with our former definition: the use of `ones` is â€œunder a
    `lam`â€, and hence wonâ€™t be needed until after the definition of `ones` is done,
    at which point `ones` will be defined. We can indicate this to Pyret by using
    the keyword `rec`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸º `ones` åœ¨å®šä¹‰ç‚¹æ²¡æœ‰å®šä¹‰ï¼Œæ‰€ä»¥å½“ Pyret è®¡ç®— `link(1, ones)` æ—¶ï¼Œå®ƒä¼šæŠ±æ€¨ `ones` æ²¡æœ‰å®šä¹‰ã€‚ç„¶è€Œï¼Œå®ƒå¯¹æˆ‘ä»¬çš„å‰ä¸€ä¸ªå®šä¹‰è¿‡äºä¿å®ˆï¼š`ones`
    çš„ä½¿ç”¨æ˜¯åœ¨ `lam` ä¸‹ï¼Œå› æ­¤åªæœ‰åœ¨ `ones` å®šä¹‰å®Œæˆåæ‰ä¼šéœ€è¦ï¼Œåˆ°é‚£æ—¶ `ones` å°†è¢«å®šä¹‰ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨å…³é”®å­— `rec` æ¥å‘ Pyret
    è¡¨æ˜è¿™ä¸€ç‚¹ï¼š
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that in Pyret, every `fun` implicitly has a `rec` beneath it, which is
    why we can create recursive functions with aplomb.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨ Pyret ä¸­ï¼Œæ¯ä¸ª `fun` éƒ½éšå¼åœ°æœ‰ä¸€ä¸ª `rec`ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬å¯ä»¥è½»æ¾åœ°åˆ›å»ºé€’å½’å‡½æ•°ã€‚
- en: Exercise
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Earlier we said that we canâ€™t write
  id: totrans-211
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¹‹å‰æˆ‘ä»¬è¯´è¿‡ï¼Œæˆ‘ä»¬ä¸èƒ½ç¼–å†™
- en: ''
  id: totrans-212
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-213
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ''
  id: totrans-214
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if we tried to write
  id: totrans-215
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬å°è¯•ç¼–å†™
- en: ''
  id: totrans-216
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-217
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ''
  id: totrans-218
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: instead? Does this work and, if so, what value is `ones` bound to? If it doesnâ€™t
    work, does it fail to work for the same reason as the definition without the `rec`?
  id: totrans-219
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™æ ·åšå¯ä»¥å—ï¼Ÿå¦‚æœå¯ä»¥ï¼Œ`ones` ç»‘å®šçš„æ˜¯ä»€ä¹ˆå€¼ï¼Ÿå¦‚æœä¸è¡Œï¼Œå®ƒæ˜¯å¦å› ä¸ºä¸æ²¡æœ‰ `rec` çš„å®šä¹‰ç›¸åŒçš„åŸå› è€Œå¤±è´¥ï¼Ÿ
- en: 'Henceforth, we will use the shorthand [[A Helpful Shorthand for Anonymous Functions](#%28part._lam-shorthand%29)]
    instead. Therefore, we can rewrite the above definition as:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ä»æ­¤ä»¥åï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ç¼©å†™ [[åŒ¿åå‡½æ•°çš„æœ‰ç”¨ç¼©å†™](#(part._lam-shorthand))]ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸Šé¢çš„å®šä¹‰é‡å†™ä¸ºï¼š
- en: '[PRE56]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Notice that `{(): â€¦}` defines an anonymous function of no arguments. You canâ€™t
    leave out the `()`! If you do, Pyret will get confused about what your program
    means.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ³¨æ„ `{(): â€¦}` å®šä¹‰äº†ä¸€ä¸ªæ— å‚æ•°çš„åŒ¿åå‡½æ•°ã€‚ä½ ä¸èƒ½çœç•¥ `()`ï¼å¦‚æœä½ çœç•¥äº†ï¼ŒPyret ä¼šå¯¹ä½ çš„ç¨‹åºçš„å«ä¹‰æ„Ÿåˆ°å›°æƒ‘ã€‚'
- en: 'Because functions are automatically recursive, when we write a function to
    create a stream, we donâ€™t need to use `rec`. Consider this example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºå‡½æ•°æ˜¯è‡ªåŠ¨é€’å½’çš„ï¼Œå½“æˆ‘ä»¬ç¼–å†™ä¸€ä¸ªåˆ›å»ºæµçš„å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬ä¸éœ€è¦ä½¿ç”¨ `rec`ã€‚è€ƒè™‘ä»¥ä¸‹ç¤ºä¾‹ï¼š
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'with which we can define the natural numbers:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥å®šä¹‰è‡ªç„¶æ•°ï¼š
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that the definition of `nats` is not recursive itselfâ€”<wbr>the recursion
    is inside `nats-from`â€”<wbr>so we donâ€™t need to use `rec` to define `nats`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ`nats` çš„å®šä¹‰æœ¬èº«ä¸æ˜¯é€’å½’çš„â€”â€”é€’å½’å‘ç”Ÿåœ¨ `nats-from` å†…éƒ¨â€”â€”å› æ­¤æˆ‘ä»¬ä¸éœ€è¦ä½¿ç”¨ `rec` æ¥å®šä¹‰ `nats`ã€‚
- en: Do Now!
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Earlier, we said that every list is finite and hence eventually terminates.
    How does this remark apply to streams, such as the definition of `ones` or `nats`
    above?
  id: totrans-230
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¹‹å‰ï¼Œæˆ‘ä»¬è¯´è¿‡æ¯ä¸ªåˆ—è¡¨éƒ½æ˜¯æœ‰é™çš„ï¼Œå› æ­¤æœ€ç»ˆä¼šç»ˆæ­¢ã€‚è¿™ä¸ªè¯„è®ºå¦‚ä½•é€‚ç”¨äºæµï¼Œä¾‹å¦‚ä¸Šé¢ `ones` æˆ– `nats` çš„å®šä¹‰ï¼Ÿ
- en: 'The description of `ones` is still a finite one; it simply represents the potential
    for an infinite number of values. Note that:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`ones` çš„æè¿°ä»ç„¶æ˜¯ä¸€ä¸ªæœ‰é™çš„æè¿°ï¼›å®ƒåªæ˜¯ä»£è¡¨æ— é™å¤šä¸ªå€¼çš„æ½œåŠ›ã€‚è¯·æ³¨æ„ï¼š'
- en: A similar reasoning doesnâ€™t apply to lists because the rest of the list has
    already been constructed; in contrast, placing a function there creates the potential
    for a potentially unbounded amount of computation to still be forthcoming.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ç±»ä¼¼çš„æ¨ç†ä¸é€‚ç”¨äºåˆ—è¡¨ï¼Œå› ä¸ºåˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†å·²ç»æ„å»ºå®Œæˆï¼›ç›¸æ¯”ä¹‹ä¸‹ï¼Œåœ¨é‚£é‡Œæ”¾ç½®ä¸€ä¸ªå‡½æ•°ä¼šåˆ›å»ºå¤§é‡æ½œåœ¨æœªå®Œæˆçš„è®¡ç®—ã€‚
- en: That said, even with streams, in any given computation, we will create only
    a finite prefix of the stream. However, we donâ€™t have to prematurely decide how
    many; each client and use is welcome to extract less or more, as needed.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¯è™½å¦‚æ­¤ï¼Œå³ä½¿åœ¨ä½¿ç”¨æµçš„æƒ…å†µä¸‹ï¼Œåœ¨ä»»ä½•ç»™å®šçš„è®¡ç®—ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿå°†åªåˆ›å»ºæµçš„ä¸€ä¸ªæœ‰é™å‰ç¼€ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ä¸å¿…æå‰å†³å®šæ•°é‡ï¼›æ¯ä¸ªå®¢æˆ·ç«¯å’Œä½¿ç”¨è€…éƒ½å¯ä»¥æ ¹æ®éœ€è¦æå–æ›´å¤šæˆ–æ›´å°‘ã€‚
- en: 'Now weâ€™ve created multiple streams, but we still donâ€™t have an easy way to
    â€œseeâ€ one. First weâ€™ll define the traditional list-like selectors. Getting the
    first element works exactly as with lists:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»åˆ›å»ºäº†å¤šä¸ªæµï¼Œä½†æˆ‘ä»¬ä»ç„¶æ²¡æœ‰ä¸€ç§ç®€å•çš„æ–¹æ³•æ¥â€œçœ‹åˆ°â€ä¸€ä¸ªã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å°†å®šä¹‰ä¼ ç»Ÿçš„ç±»ä¼¼åˆ—è¡¨çš„é€‰æ‹©å™¨ã€‚è·å–ç¬¬ä¸€ä¸ªå…ƒç´ ä¸åˆ—è¡¨ä¸­çš„æ“ä½œå®Œå…¨ä¸€æ ·ï¼š
- en: '[PRE59]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In contrast, when trying to access the rest of the stream, all we get out of
    the data structure is a thunk. To access the actual rest, we need to force the
    thunk, which of course means applying it to no arguments:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åï¼Œå½“å°è¯•è®¿é—®æµçš„å…¶ä½™éƒ¨åˆ†æ—¶ï¼Œæˆ‘ä»¬ä»æ•°æ®ç»“æ„ä¸­å¾—åˆ°çš„åªæ˜¯ä¸€ä¸ªthunkã€‚è¦è®¿é—®å®é™…çš„å…¶ä½™éƒ¨åˆ†ï¼Œæˆ‘ä»¬éœ€è¦å¼ºåˆ¶thunkï¼Œè¿™å½“ç„¶æ„å‘³ç€å°†å…¶åº”ç”¨äºæ— å‚æ•°ï¼š
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is useful for examining individual values of the stream. It is also useful
    to extract a finite prefix of it (of a given size) as a (regular) list, which
    would be especially handy for testing. Letâ€™s write that function:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯¹äºæ£€æŸ¥æµçš„å•ä¸ªå€¼å¾ˆæœ‰ç”¨ã€‚å®ƒè¿˜å…è®¸æˆ‘ä»¬æå–å®ƒï¼ˆç»™å®šå¤§å°ï¼‰çš„ä¸€ä¸ªæœ‰é™å‰ç¼€ä½œä¸ºï¼ˆå¸¸è§„ï¼‰åˆ—è¡¨ï¼Œè¿™å¯¹äºæµ‹è¯•ç‰¹åˆ«æœ‰ç”¨ã€‚è®©æˆ‘ä»¬ç¼–å†™è¿™ä¸ªå‡½æ•°ï¼š
- en: '[PRE61]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If you pay close attention, youâ€™ll find that this body is not defined by cases
    over the structure of the (stream) inputâ€”<wbr>instead, itâ€™s defined by the cases
    of the definition of a natural number (zero or a successor). Weâ€™ll return to this
    below ([<lz-map2-def>](#%28elem._lz-map2-def%29)).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ä»”ç»†è§‚å¯Ÿï¼Œä½ ä¼šå‘ç°è¿™ä¸ªä¸»ä½“ä¸æ˜¯é€šè¿‡åœ¨ï¼ˆæµï¼‰è¾“å…¥çš„ç»“æ„ä¸Šå®šä¹‰æƒ…å†µæ¥å®šä¹‰çš„â€”â€”ç›¸åï¼Œå®ƒæ˜¯é€šè¿‡è‡ªç„¶æ•°ï¼ˆé›¶æˆ–åç»§ï¼‰çš„å®šä¹‰çš„æƒ…å†µæ¥å®šä¹‰çš„ã€‚æˆ‘ä»¬å°†åœ¨ä¸‹é¢å›åˆ°è¿™ä¸ªé—®é¢˜
    ([<lz-map2-def>](#%28elem._lz-map2-def%29))ã€‚
- en: 'Now that we have this, we can use it for testing. Note that usually we use
    our data to test our functions; here, weâ€™re using this function to test our data:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†è¿™ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥è¿›è¡Œæµ‹è¯•ã€‚è¯·æ³¨æ„ï¼Œé€šå¸¸æˆ‘ä»¬ä½¿ç”¨æˆ‘ä»¬çš„æ•°æ®æ¥æµ‹è¯•æˆ‘ä»¬çš„å‡½æ•°ï¼›è¿™é‡Œï¼Œæˆ‘ä»¬æ­£åœ¨ä½¿ç”¨è¿™ä¸ªå‡½æ•°æ¥æµ‹è¯•æˆ‘ä»¬çš„æ•°æ®ï¼š
- en: '[PRE62]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The notation `(_ + 1)` defines a Pyret function of one argument that adds `1`
    to the given argument.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¦å·`(_ + 1)`å®šä¹‰äº†ä¸€ä¸ªæ¥å—ä¸€ä¸ªå‚æ•°çš„Pyretå‡½æ•°ï¼Œè¯¥å‡½æ•°å°†ç»™å®šçš„å‚æ•°åŠ `1`ã€‚
- en: 'Letâ€™s define one more function: the equivalent of `map` over streams. For reasons
    that will soon become obvious, weâ€™ll define a version that takes two lists and
    applies the first argument to them pointwise:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å®šä¹‰å¦ä¸€ä¸ªå‡½æ•°ï¼šæµçš„`map`çš„ç­‰æ•ˆå‡½æ•°ã€‚ç”±äºå¾ˆå¿«å°±ä¼šå˜å¾—æ˜æ˜¾çš„åŸå› ï¼Œæˆ‘ä»¬å°†å®šä¹‰ä¸€ä¸ªæ¥å—ä¸¤ä¸ªåˆ—è¡¨å¹¶å°†ç¬¬ä¸€ä¸ªå‚æ•°é€ç‚¹åº”ç”¨äºå®ƒä»¬çš„ç‰ˆæœ¬ï¼š
- en: <lz-map2-def> ::=
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <lz-map2-def> ::=
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now we can see our earlier remark about the structure of the function driven
    home especially clearly. Whereas a traditional `map` over lists would have two
    cases, here we have only one case because the data definition ([<stream-type-def>](#%28elem._stream-type-def%29))
    has only one case! What is the consequence of this? In a traditional `map`, one
    case looks like the above, but the other case corresponds to the `empty` input,
    for which it produces the same output. Here, because the stream never terminates,
    mapping over it doesnâ€™t either, and the structure of the function reflects this.This
    raises a much subtler problem: if the functionâ€™s body doesnâ€™t have base- and inductive-cases,
    how can we perform an inductive proof over it? The short answer is we canâ€™t: we
    must instead use [â˜› coinduction](glossary.html#%28elem._glossary-coinduction%29).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥ç‰¹åˆ«æ¸…æ¥šåœ°çœ‹åˆ°æˆ‘ä»¬ä¹‹å‰å…³äºå‡½æ•°ç»“æ„çš„è¯„è®ºã€‚è€Œä¼ ç»Ÿçš„åˆ—è¡¨`map`æœ‰ä¸¤ä¸ªæƒ…å†µï¼Œè¿™é‡Œæˆ‘ä»¬åªæœ‰ä¸€ä¸ªæƒ…å†µï¼Œå› ä¸ºæ•°æ®å®šä¹‰ ([<stream-type-def>](#%28elem._stream-type-def%29))åªæœ‰ä¸€ä¸ªæƒ…å†µï¼è¿™æœ‰ä»€ä¹ˆåæœï¼Ÿåœ¨ä¼ ç»Ÿçš„`map`ä¸­ï¼Œä¸€ä¸ªæƒ…å†µçœ‹èµ·æ¥åƒä¸Šé¢é‚£æ ·ï¼Œä½†å¦ä¸€ä¸ªæƒ…å†µå¯¹åº”äº`empty`è¾“å…¥ï¼Œå®ƒäº§ç”Ÿç›¸åŒçš„è¾“å‡ºã€‚è¿™é‡Œï¼Œå› ä¸ºæµæ°¸è¿œä¸ä¼šç»ˆæ­¢ï¼Œæ‰€ä»¥æ˜ å°„å®ƒä¹Ÿä¸ä¼šç»ˆæ­¢ï¼Œå‡½æ•°çš„ç»“æ„åæ˜ äº†è¿™ä¸€ç‚¹ã€‚è¿™å¼•å‘äº†ä¸€ä¸ªæ›´å¾®å¦™çš„é—®é¢˜ï¼šå¦‚æœå‡½æ•°çš„ä¸»ä½“æ²¡æœ‰åŸºç¡€å’Œå½’çº³æƒ…å†µï¼Œæˆ‘ä»¬å¦‚ä½•å¯¹å®ƒè¿›è¡Œå½’çº³è¯æ˜ï¼Ÿç®€çŸ­çš„ç­”æ¡ˆæ˜¯ï¼Œæˆ‘ä»¬ä¸èƒ½ï¼šæˆ‘ä»¬å¿…é¡»æ”¹ç”¨[â˜›å½’çº³å½’çº³](glossary.html#%28elem._glossary-coinduction%29)ã€‚
- en: 'Why did we define `lz-map2` instead of `lz-map`? Because it enables us to write
    the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæˆ‘ä»¬å®šä¹‰äº†`lz-map2`è€Œä¸æ˜¯`lz-map`ï¼Ÿå› ä¸ºå®ƒä½¿æˆ‘ä»¬èƒ½å¤Ÿç¼–å†™ä»¥ä¸‹å†…å®¹ï¼š
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: from which, of course, we can extract as many Fibonacci numbers as we want!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ä»ä¸­ï¼Œå½“ç„¶ï¼Œæˆ‘ä»¬å¯ä»¥æå–æˆ‘ä»¬æƒ³è¦çš„ä»»æ„å¤šçš„æ–æ³¢é‚£å¥‘æ•°ï¼
- en: '[PRE65]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Exercise
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define the equivalent of `map` and `filter` for streams.
  id: totrans-254
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®šä¹‰æµçš„`map`å’Œ`filter`çš„ç­‰æ•ˆå‡½æ•°ã€‚
- en: Streams and, more generally, infinite data structures that unfold on demand
    are extremely valuable in programming. Consider, for instance, the possible moves
    in a game. In some games, this can be infinite; even if it is finite, for interesting
    games the combinatorics mean that the tree is too large to feasibly store in memory.
    Therefore, the programmer of the computerâ€™s intelligence must unfold the game
    tree on demand. Programming it by using the encoding we have described above means
    the program describes the entire tree, lazily, and the tree unfolds automatically
    on demand, relieving the programmer of the burden of implementing such a strategy.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: æµå’Œæ›´ä¸€èˆ¬åœ°ï¼ŒæŒ‰éœ€å±•å¼€çš„æ— é™æ•°æ®ç»“æ„åœ¨ç¼–ç¨‹ä¸­éå¸¸æœ‰ä»·å€¼ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘æ¸¸æˆä¸­çš„å¯èƒ½ç§»åŠ¨ã€‚åœ¨æŸäº›æ¸¸æˆä¸­ï¼Œè¿™å¯èƒ½æ— é™ï¼›å³ä½¿å®ƒæ˜¯æœ‰é™çš„ï¼Œå¯¹äºæœ‰è¶£çš„æ¸¸æˆï¼Œç»„åˆæ„å‘³ç€æ ‘å¤ªå¤§ï¼Œæ— æ³•å®é™…å­˜å‚¨åœ¨å†…å­˜ä¸­ã€‚å› æ­¤ï¼Œè®¡ç®—æœºæ™ºèƒ½çš„ç¨‹åºå‘˜å¿…é¡»æŒ‰éœ€å±•å¼€æ¸¸æˆæ ‘ã€‚é€šè¿‡ä½¿ç”¨æˆ‘ä»¬ä¸Šé¢æè¿°çš„ç¼–ç æ¥ç¼–ç¨‹æ„å‘³ç€ç¨‹åºæè¿°äº†æ•´ä¸ªæ ‘ï¼Œæƒ°æ€§åœ°ï¼Œæ ‘æŒ‰éœ€è‡ªåŠ¨å±•å¼€ï¼Œå‡è½»äº†ç¨‹åºå‘˜å®ç°è¿™ç§ç­–ç•¥çš„è´Ÿæ‹…ã€‚
- en: In some languages, such as Haskell, lazy evaluation is built in by default.
    In such a language, there is no need to use thunks. However, lazy evaluation places
    other burdens on the language, which you can learn about in a programming-languages
    class.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æŸäº›è¯­è¨€ä¸­ï¼Œä¾‹å¦‚ Haskellï¼Œæƒ°æ€§æ±‚å€¼æ˜¯é»˜è®¤å†…ç½®çš„ã€‚åœ¨è¿™ç§è¯­è¨€ä¸­ï¼Œä¸éœ€è¦ä½¿ç”¨ thunksã€‚ç„¶è€Œï¼Œæƒ°æ€§æ±‚å€¼ç»™è¯­è¨€å¸¦æ¥äº†å…¶ä»–è´Ÿæ‹…ï¼Œä½ å¯ä»¥åœ¨ç¼–ç¨‹è¯­è¨€è¯¾ç¨‹ä¸­äº†è§£è¿™äº›ã€‚
- en: '8.1.4Â Combining Forces: Streams of Derivatives[ğŸ”—](#(part._d-dx-streams) "Link
    to here")'
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.4Â ç»„åˆåŠ›é‡ï¼šå¯¼æ•°æµ[ğŸ”—](#(part._d-dx-streams) "é“¾æ¥è‡³æ­¤")
- en: When we defined `d-dx`, we set `epsilon` to an arbitrary, high value. We could
    instead think of `epsilon` as itself a stream that produces successively finer
    values; then, for instance, when the difference in the value of the derivative
    becomes small enough, we can decide we have a sufficient approximation to the
    derivative.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬å®šä¹‰ `d-dx` æ—¶ï¼Œæˆ‘ä»¬å°† `epsilon` è®¾ç½®ä¸ºä¸€ä¸ªä»»æ„çš„é«˜å€¼ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥å°† `epsilon` è§†ä¸ºä¸€ä¸ªäº§ç”Ÿè¶Šæ¥è¶Šç²¾ç»†å€¼çš„æµï¼›ç„¶åï¼Œä¾‹å¦‚ï¼Œå½“å¯¼æ•°å€¼çš„å·®å¼‚å˜å¾—è¶³å¤Ÿå°ï¼Œæˆ‘ä»¬å¯ä»¥å†³å®šæˆ‘ä»¬å·²ç»å¾—åˆ°äº†å¯¼æ•°çš„è¶³å¤Ÿé€¼è¿‘ã€‚
- en: The first step is, therefore, to make `epsilon` some kind of parameter rather
    than a global constant. That leaves open what kind of parameter it should be (number
    or stream?) as well as when it should be supplied.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œç¬¬ä¸€æ­¥æ˜¯å°† `epsilon` å˜æˆä¸€ä¸ªå‚æ•°ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå…¨å±€å¸¸æ•°ã€‚è¿™ç•™ä¸‹äº†å®ƒåº”è¯¥æ˜¯ä»€ä¹ˆç±»å‹çš„å‚æ•°ï¼ˆæ•°å­—æˆ–æµï¼Ÿï¼‰ä»¥åŠä½•æ—¶æä¾›çš„é—®é¢˜ã€‚
- en: 'It makes most sense to consume this parameter after we have decided what function
    we want to differentiate and at what value we want its derivative; after all,
    the stream of `epsilon` values may depend on both. Thus, we get:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬å†³å®šè¦å¾®åˆ†å“ªä¸ªå‡½æ•°ä»¥åŠå…¶å¯¼æ•°åœ¨ä»€ä¹ˆå€¼æ—¶ï¼Œæ¶ˆè´¹è¿™ä¸ªå‚æ•°æœ€æœ‰æ„ä¹‰ï¼›æ¯•ç«Ÿï¼Œ`epsilon` çš„æµå¯èƒ½å–å†³äºè¿™ä¸¤ä¸ªå› ç´ ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¾—åˆ°ï¼š
- en: '[PRE66]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'with which we can return to our `square` example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡è¿™ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥å›åˆ°æˆ‘ä»¬çš„ `square` ä¾‹å­ï¼š
- en: '[PRE67]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Note that at this point we have simply redefined `d-dx` without any reference
    to streams: we have merely made a constant into a parameter.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨è¿™ä¸ªæ—¶å€™ï¼Œæˆ‘ä»¬åªæ˜¯é‡æ–°å®šä¹‰äº† `d-dx`ï¼Œè€Œæ²¡æœ‰æåŠæµï¼šæˆ‘ä»¬åªæ˜¯å°†ä¸€ä¸ªå¸¸æ•°å˜æˆäº†ä¸€ä¸ªå‚æ•°ã€‚
- en: 'Now letâ€™s define the stream of negative powers of ten:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬å®šä¹‰è´Ÿåçš„å¹‚çš„æµï¼š
- en: '[PRE68]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: so that
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¾¿
- en: '[PRE69]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'For concreteness, letâ€™s pick an abscissa at which to compute the numeric derivative
    of `square`â€”<wbr>say `10`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å…·ä½“åŒ–ï¼Œè®©æˆ‘ä»¬é€‰æ‹©ä¸€ä¸ªæ¨ªåæ ‡æ¥è®¡ç®— `square` çš„æ•°å€¼å¯¼æ•°â€”â€”æ¯”å¦‚è¯´ `10`ï¼š
- en: '[PRE70]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Recall, from the types, that this is now a function of type `(Number -> Number)`:
    given a value for `epsilon`, it computes the derivative using that value. We know,
    analytically, that the value of this derivative should be `20`. We can now (lazily)
    map `tenths` to provide increasingly better approximations for `epsilon` and see
    what happens:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ä»ç±»å‹ä¸­å›æƒ³èµ·æ¥ï¼Œç°åœ¨è¿™æ˜¯ä¸€ä¸ª `(Number -> Number)` ç±»å‹çš„å‡½æ•°ï¼šç»™å®šä¸€ä¸ª `epsilon` çš„å€¼ï¼Œå®ƒä½¿ç”¨è¯¥å€¼æ¥è®¡ç®—å¯¼æ•°ã€‚æˆ‘ä»¬çŸ¥é“ï¼Œä»è§£æçš„è§’åº¦æ¥çœ‹ï¼Œè¿™ä¸ªå¯¼æ•°çš„å€¼åº”è¯¥æ˜¯
    `20`ã€‚ç°åœ¨ï¼ˆæƒ°æ€§åœ°ï¼‰æˆ‘ä»¬å¯ä»¥å°† `tenths` æ˜ å°„åˆ°æä¾›è¶Šæ¥è¶Šå¥½çš„ `epsilon` è¿‘ä¼¼å€¼ï¼Œå¹¶çœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆï¼š
- en: '[PRE71]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Sure enough, the values we obtain are `20.1`, `20.01`, `20.001`, and so on:
    progressively better numerical approximations to `20`.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: æœç„¶ï¼Œæˆ‘ä»¬å¾—åˆ°çš„ä»·å€¼æ˜¯ `20.1`ï¼Œ`20.01`ï¼Œ`20.001`ï¼Œç­‰ç­‰ï¼šå¯¹ `20` çš„è¶Šæ¥è¶Šå¥½çš„æ•°å€¼é€¼è¿‘ã€‚
- en: Exercise
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend the above program to take a tolerance, and draw as many values from the
    `epsilon` stream as necessary until the difference between successive approximations
    of the derivative fall within this tolerance.
  id: totrans-276
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°†ä¸Šè¿°ç¨‹åºæ‰©å±•ä»¥æ¥å—ä¸€ä¸ªå®¹å·®ï¼Œå¹¶ä» `epsilon` æµä¸­æå–å°½å¯èƒ½å¤šçš„å€¼ï¼Œç›´åˆ°å¯¼æ•°çš„è¿ç»­é€¼è¿‘ä¹‹é—´çš„å·®å¼‚è½åœ¨è¯¥å®¹å·®å†…ã€‚
