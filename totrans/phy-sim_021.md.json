["```py\nimport numpy as np\nimport os\n\ndef generate(side_length, n_seg):\n    # sample nodes uniformly on a square\n    x = np.array([[0.0, 0.0]] * ((n_seg + 1) ** 2))\n    step = side_length / n_seg\n    for i in range(0, n_seg + 1):\n        for j in range(0, n_seg + 1):\n            x[i * (n_seg + 1) + j] = [-side_length / 2 + i * step, -side_length / 2 + j * step]\n\n    # connect the nodes with edges\n    e = []\n    # horizontal edges\n    for i in range(0, n_seg):\n        for j in range(0, n_seg + 1):\n            e.append([i * (n_seg + 1) + j, (i + 1) * (n_seg + 1) + j])\n    # vertical edges\n    for i in range(0, n_seg + 1):\n        for j in range(0, n_seg):\n            e.append([i * (n_seg + 1) + j, i * (n_seg + 1) + j + 1])\n    # diagonals\n    for i in range(0, n_seg):\n        for j in range(0, n_seg):\n            e.append([i * (n_seg + 1) + j, (i + 1) * (n_seg + 1) + j + 1])\n            e.append([(i + 1) * (n_seg + 1) + j, i * (n_seg + 1) + j + 1])\n\n    return [x, e] \n```"]