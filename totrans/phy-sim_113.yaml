- en: Precomputing Normal and Tangent Information
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预计算法向和切向信息
- en: 原文：[https://phys-sim-book.github.io/lec22.2-precompute.html](https://phys-sim-book.github.io/lec22.2-precompute.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://phys-sim-book.github.io/lec22.2-precompute.html](https://phys-sim-book.github.io/lec22.2-precompute.html)
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
- en: To make the temporally discretized friction force integrable, we must explicitly
    discretize certain normal and tangent information. This information only needs
    to be calculated once at the beginning of each time step, as it will remain constant
    during each optimization.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使时间离散化的摩擦力可积，我们必须显式地离散化某些法向和切向信息。这些信息只需要在每个时间步长的开始计算一次，因为它们将在每次优化过程中保持不变。
- en: 'First, we need to calculate λn for each point-edge pair using xn. Recall that
    we used squared distances as input for the barrier functions, so λn should be
    calculated using the chain rule as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用 xn 计算每个点-边缘对的 λn。回想一下，我们使用了平方距离作为势函数的输入，因此 λn 应该使用链式法则如下计算：
- en: λa^,en​​=21​Aa^​(−∂dPE∂b(dsqPE​(xa^n​,e),d^2)​)=21​Aa^​(−∂dsqPE​∂b(dsqPE​(xa^n​,e),d^2)​∂dPE∂dsqPE​​)=21​Aa^​(−∂dsqPE​∂b(dsqPE​(xa^n​,e),d^2)​)2dPE.​
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: λa^n,en=21Aa^(-∂dPE∂b(dsqPE(xa^n,e),d^2))=21Aa^(-∂dsqPE∂b(dsqPE(xa^n,e),d^2)∂dPE∂dsqPE))=21Aa^(-∂dsqPE∂b(dsqPE(xa^n,e),d^2))2dPE.​
- en: According to the scaled barrier function taking squared distance as input (Equation
    [(21.3.1)](lec21.3-barrier_and_derivatives.html#eq:lec21:scaled_barrier_func)),
    we can derive
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以平方距离作为输入的缩放势函数（方程 [(21.3.1)](lec21.3-barrier_and_derivatives.html#eq:lec21:scaled_barrier_func))，我们可以推导出
- en: ∂dsq​∂b(dsq​,d^2)​={8κ​d^(d^21​lnd^2dsq​​+dsq​1​(d^2dsq​​−1))0​if d<d^;if d≥d^.​
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ∂dsq∂b(dsq,d^2)={8κd^(d^21lnd^2dsq+dsq1(d^2dsq−1))0if d<d^;if d≥d^.​
- en: '***Remark 22.2.1.*** The set of point-edge pairs for friction in our semi-implicit
    friction setting is fixed in each time step and is different from the set of normal
    contact pairs. The set for friction only contains those pairs with dPE(xa^n​,e)<d^,
    and this does not change with the optimization variable xn+1 in the current time
    step.'
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***备注 22.2.1.*** 在我们的半隐式摩擦设置中，点-边缘对的集合在每个时间步长中是固定的，并且与法向接触对的集合不同。摩擦的集合只包含那些
    dPE(xa^n,e)<d^ 的对，并且这不会随着当前时间步长中的优化变量 xn+1 而改变。'
- en: Now for the tangent information, the key is to keep the normal and the barycentric
    coordinate of the closest point on the edge constant. For the k-th point-edge
    pair, if we denote the node indices for the point and edge as p, e0​, and e1​,
    then we can write the relative sliding velocity as
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于切向信息，关键在于保持边缘上最近点的法向和重心坐标不变。对于第 k 个点-边缘对，如果我们用 p、e0 和 e1 表示点和边缘的节点索引，那么我们可以写出相对滑动速度为
- en: vk​=(I−nnT)(vp​−((1−r)ve0​​+rve1​​)),
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: vk=(I−nnT)(vp−((1−r)ve0+rve1)),
- en: where r=argminc​∥xp​−((1−c)xe0​​+cxe1​​)∥ is the barycentric coordinate and
    n=(xp​−((1−r)xe0​​+rxe1​​))/∥xp​−((1−r)xe0​​+rxe1​​)∥ is the normal of the edge.
    Here we see that r and n are both dependent on x, so directly integrating vk​
    is nontrivial. By calculating n and r using xn, we obtain the semi-implicit relative
    sliding velocity
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 r=argminc∥xp−((1−c)xe0+cxe1)∥ 是重心坐标，n=(xp−((1−r)xe0+rxe1))/∥xp−((1−r)xe0+rxe1)∥
    是边缘的法向。在这里我们可以看到，r 和 n 都依赖于 x，所以直接积分 vk 是非平凡的。通过使用 xn 计算 n 和 r，我们得到半隐式相对滑动速度
- en: vˉk​=(I−nn(nn)T)(vp​−((1−rn)ve0​​+rnve1​​)),
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: vˉk=(I−nn(nn)T)(vp−((1−rn)ve0+rnve1)),
- en: and now only the velocities are dependent on xn+1, which makes both integration
    and differentiation straightforward. If we denote v^k​=vp​−((1−rn)ve0​​+rnve1​​),
    we obtain
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只有速度依赖于 xn+1，这使得积分和微分都变得简单。如果我们表示 v^k=vp−((1−rn)ve0+rnve1)，我们得到
- en: ∂v^k​∂vˉk​​=(I−nn(nn)T)and∂[xpT​,xe0​T​,xe1​T​]T∂v^k​​=h^1​[I​(rn−1)I​−rnI​].
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ∂v^k∂vˉk=(I−nn(nn)T)和∂[xpT,xe0T,xe1T]T∂v^k=h^1[I(I(rn−1)I−rnI)].
- en: '[Code](#code)'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码](#code)'
- en: Next, let's look at the code. [Implementation 22.2.1](#imp:lec22:contact_point_and_normal)
    calculates the barycentric coordinate of the closest point and the normal given
    point-edge nodal positions. The idea is to orthogonally project xp​ onto the edge.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看代码。[实现 22.2.1](#imp:lec22:contact_point_and_normal) 计算了给定点-边缘节点位置的最接近点的重心坐标和法向。思路是将
    xp 垂直投影到边缘上。
- en: '**Implementation 22.2.1 (Calculating contact point and normal, PointEdgeDistance.py).**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现 22.2.1（计算接触点和法向，PointEdgeDistance.py）。**'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, [Implementation 22.2.2](#imp:lec22:fric_precomp) traverses all non-incident
    point-edge pairs with a distance smaller than d^, calculates λ, and calls the
    above function to calculate n and r.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，[实现 22.2.2](#imp:lec22:fric_precomp) 遍历所有距离小于 d^ 的非碰撞点-边缘对，计算 λ，并调用上述函数计算
    n 和 r。
- en: As in [Frictional Contact](./lec9-friction.html), these lines of code are executed
    at the beginning of each time step in `time_integrator.py`, and the information
    for each friction pair is stored and passed to the energy, gradient, and Hessian
    computation functions that we will discuss next.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[摩擦接触](./lec9-friction.html)中所述，这些代码行在`time_integrator.py`的每个时间步开始时执行，并且每个摩擦对的信息被存储并传递给我们将要讨论的能量、梯度和Hessian计算函数。
- en: '**Implementation 22.2.2 (Semi-implicit friction precomputation, BarrierEnergy.py).**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现 22.2.2（半隐式摩擦预计算，BarrierEnergy.py）**。'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
