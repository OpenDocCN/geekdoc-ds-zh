<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>17.4Â Shortest (or Lightest) PathsðŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>17.4Â Shortest (or Lightest) PathsðŸ”—</h1>
<blockquote>åŽŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/lightest-paths.html">https://dcic-world.org/2025-08-27/lightest-paths.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td/></tr></table><p>Imagine planning a trip: itâ€™s natural that you might want to get to
your destination in the least time, or for the least money, or some
other criterion that involves <span class="emph">minimizing the sum of edge
weights</span>. This is known as computing the shortest path.</p><p>We should immediately clarify an unfortunate terminological
confusion. What we really want to compute is the <span style="font-style: italic">lightest</span>
pathâ€”<wbr/>the one of least weight. Unfortunately, computer science
terminology has settled on the terminology we use here; just be sure
to not take it literally.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Construct a graph and select a pair of nodes in it such that the
shortest path from one to the other is not the lightest one, and vice
versa.</p></blockquote></blockquote><p>We have already seen [<a href="basic-graph-trav.html#%28part._dfs-bfs%29" data-pltdoc="x">Depth- and Breadth-First Traversals</a>] that breadth-first search
constructs shortest paths in unweighted graphs. These correspond to
lightest paths when there are no weights (or, equivalently, all
weights are identical and positive). Now we have to generalize this to
the case where the edges have weights.</p><p/><div class="SIntrapara">We will proceed inductively, gradually defining a function seemingly
of this type
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">w :: Key -&gt; Number</code></pre></div></div></div><div class="SIntrapara">that reflects the weight of the lightest path from the source node to
that one. But letâ€™s think about this annotation: since weâ€™re building
this up node-by-node, initially most nodes have no weight to report;
and even at the end, a node that is unreachable from the source will
have no weight for a lightest (or indeed, any) path. Rather than make
up a number that pretends to reflect this situation, we will instead
use an option type:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">w :: Key -&gt; Option&lt;Number&gt;</code></pre></div></div></div><div class="SIntrapara">When there is <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">some</code></span> value it will be the weight; otherwise the
weight will be <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">none</code></span>.</div><p>Now letâ€™s think about this inductively. What do we know initially?
Well, certainly that the source node is at a distance of zero from
itself (that must be the lightest path, because we canâ€™t get any
lighter). This gives us a (trivial) set of nodes for which we already
know the lightest weight. Our goal is to grow this set of
nodesâ€”<wbr/>modestly, by one, on each iterationâ€”<wbr/>until we either find the
destination, or we have no more nodes to add (in which case our
desination is not reachable from the source).</p><p>Inductively, at each step we have the set of all nodes for which we
know the lightest path (initially this is just the source node, but it
does mean this set is never empty, which will matter in what we say
next). Now consider <span class="emph">all</span> the edges adjacent to this set of nodes
that lead to nodes for which we donâ€™t already know the lightest
path. Choose a node, \(q\), that minimizes the total weight of the
path to it. We claim that this will in fact be the lightest path to
that node.</p><p>If this claim is true, then we are done. Thatâ€™s because we would now add
\(q\) to the set of nodes whose lightest weights we now know, and
repeat the process of finding lightest outgoing edges from there. This
process has thus added one more node. At some point we will find that
there are no edges that lead outside the known set, at which point we
can terminate.</p><p>It stands to reason that terminating at this point is safe: it
corresponds to having computed the reachable set. The only thing left
is to demonstrate that this <span style="font-style: italic">greedy</span> algorithm yields a
<span class="emph">lightest</span> path to each node.</p><p>We will prove this by contradiction. Suppose we have the path
\(s \rightarrow d\)
from source \(s\) to node \(d\), as found by the algorithm above, but
assume also that we have a different path that is actually lighter.
At every node, when we added a node along the \(s \rightarrow d\)
path, the algorithm would have added a lighter path if it existed. The
fact that it did not falsifies our claim that a <span class="emph">lighter</span> path
exists (there could be a different path of the <span class="emph">same</span> weight;
this would be permitted by the algorithm, but it also doesnâ€™t
contradict our claim). Therefore the algorithm does indeed find the
lightest path.</p><p>What remains is to determine a data structure that enables this
algorithm. At every node, we want to know the least weight from the
set of nodes for which we know the least weight to all their
neighbors. We could achieve this by sorting, but this is overkill: we
donâ€™t actually need a total ordering on all these weights, only the
lightest one. A <span style="font-style: italic">heap</span> <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">see Wikipedia</a> gives us this.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>What if we allowed edges of weight zero? What would change in the
above algorithm?</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>What if we allowed edges of negative weight? What would change in the
above algorithm?<span class="refelem"><span class="refcolumn"><span class="refcontent">After youâ€™ve thought about this for a while,
take a look at
<a href="https://www.quantamagazine.org/finally-a-fast-algorithm-for-shortest-paths-on-negative-graphs-20230118/">this article</a>.</span></span></span></p></blockquote></blockquote><p>For your reference, this algorithm is known as
<span class="emph">Dijkstraâ€™s Algorithm</span>.</p>    
</body>
</html>