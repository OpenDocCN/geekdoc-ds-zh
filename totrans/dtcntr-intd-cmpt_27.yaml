- en: 9.2¬†Dictionariesüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/dictionaries.html](https://dcic-world.org/2025-08-27/dictionaries.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[9.2.1¬†Creating and Using a Dictionary](#%28part._.Creating_and_.Using_a_.Dictionary%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[9.2.2¬†Searching Through the Values in a Dictionary](#%28part._.Searching_.Through_the_.Values_in_a_.Dictionary%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[9.2.3¬†Dictionaries with More Complex Values](#%28part._.Dictionaries_with_.More_.Complex_.Values%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[9.2.4¬†Dictionaries versus Dataclasses](#%28part._.Dictionaries_versus_.Dataclasses%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[Summary](#%28part._.Summary%29) |'
  prefs: []
  type: TYPE_TB
- en: So far, we have seen several ways to process sequential data such as lists.
    In each of Pyret and Python, we can use `filter` and `map` to perform certain
    operations that yield lists. In Pyret, we used recursion to aggregate list data
    into a single value. In Python, we used for-loops for this task. While we could
    use recursion or for-loops for `filter` and `map` tasks as well, using these named
    operators makes it easier for someone else to quickly read your code and understand
    what kind of operation it is performing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This observation raises a question though: are there other common code patterns
    that get written with recursion or for-loops that would benefit from specialized
    handling?'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, imagine that we had a dataclass for airline flights. Each flight
    has its origin and destination cities, the flight code (including the airline
    name and flight number), and the number of seats on the flight. Imagine also that
    we have functions to look up the destination and seating capacity of individual
    flights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Look at the similarity between `destination1` and `capacity1`. How might we
    share the common code between these two functions?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Both `destination1` and `capacity1` traverse the list of flights looking for
    the one with the given flight-code, then extract a piece of information from that
    flight. The for-loop isn‚Äôt doing anything other than looking for the desired flight
    data. This suggests that a `find_flight` helper could be useful here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Searching for a single element from a list based on a specific piece of information
    is common in many programs. This is so common, in fact, that languages provide
    special data structures and operations just to help with this task. In Python,
    this data structure is called a dictionary (hashmap, hashtable, and associative
    arrays are names for similar data structures in other languages, though there
    are key nuances that distinguish all these variations).
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.1¬†Creating and Using a Dictionary[üîó](#(part._.Creating_and_.Using_a_.Dictionary)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A dictionary maps unique values (called keys) to corresponding pieces of data
    for each key (called values). Here is our flight example written instead as a
    dictionary instead of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The general form of a dictionary is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Dictionaries are designed to enable easy lookup of values give a key. To get
    the
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'associated with key `''CSA-145''`, we can write simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the number of seats on flight `''CSA-145''`, we can simply write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, the dictionary data structure removes the need to traverse
    a list to find the `Flight` with a specific key. The dictionary lookup operation
    does that work for us. Actually, dictionaries are even more nuanced: depending
    on how they are designed, dictionaries can retrieve the value for a key without
    traversing all the values (or even any other value). In general, you can assume
    that dictionary-based lookup is significantly faster than a list-based one. How
    this works is a more advanced topic; some of this content is explained in [SECREF].'
  prefs: []
  type: TYPE_NORMAL
- en: 'One limitation of dictionaries is that they allow only one value per key. Let‚Äôs
    consider a different example, this time one that uses rooms in a building as keys
    and occupants as values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'What if someone new moves into office 412? In Python, we can the value for
    that key as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, any use of `office_dict[412]` will evaluate to `'Zeynep'` instead of `'Marisol'`.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.2¬†Searching Through the Values in a Dictionary[üîó](#(part._.Searching_.Through_the_.Values_in_a_.Dictionary)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What if we wanted to find all of the flights with more than 100 seats? For this,
    we have to search through all of the key-value pairs and check their balances.
    This again sounds like we need a for-loop. What does that look like on a dictionary
    though?
  prefs: []
  type: TYPE_NORMAL
- en: 'Turns out, it looks much like writing a for loop on a list (at least in Python).
    Here‚Äôs a program that creates a list of the flights with more than 100 seats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, the for-loop iterates over the keys. Within the loop, we use each key
    to retrieve its corresponding `Flight`, perform the balance check on the `Flight`,
    then put the `Flight` in our running list if it meets our criterion.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Create a dictionary that maps names of classrooms or meeting rooms to the numbers
    of seats that they have. Write expressions to:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Look up how many seats are in a specific room
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Change the capacity of a specific room to have 10 more seats than it did initially
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Find all rooms that can seat at least 50 students
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: 9.2.3¬†Dictionaries with More Complex Values[üîó](#(part._.Dictionaries_with_.More_.Complex_.Values)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A track-and-field tournament needs to manage the names of the players on the
    individual teams that will be competing. For example, ‚ÄúTeam Red‚Äù has ‚ÄúShaoming‚Äù
    and ‚ÄúLijin‚Äù, ‚ÄúTeam Green‚Äù contains ‚ÄúObi‚Äù and ‚ÄùChinara‚Äù, and ‚ÄúTeam Blue‚Äù has ‚ÄúMateo‚Äù
    and ‚ÄúSophia‚Äù. Come up with a way to organize the data that will allow the organizers
    to easily access the names of the players on each team, keeping in mind that there
    could be many more teams than just the three listed here.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This feels like a dictionary situation, in that we have a meaningful key (the
    team name) with which we want to access values (the names of the players). However,
    we have already said that dictionaries allow only one value per key. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would be in the dictionary after running this code? If you aren‚Äôt sure,
    try it out!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'How do we store multiple player names under the same key? The insight here
    is that the collection of players, not an individual player, is what we want to
    associate with the team name. We should therefore store a list of players under
    each key, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The values in a dictionary aren‚Äôt limited to being basic values. They can be
    arbitrarily complex, including lists, tables, or even other dictionaries (and
    more!). There is still only one value per key, which is the requirement of a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.4¬†Dictionaries versus Dataclasses[üîó](#(part._.Dictionaries_versus_.Dataclasses)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Previously, we learned about dataclasses as a way to create compound data in
    Python. Here again is the `ToDoItem` dataclass that we introduced earlier, as
    well as an example datum for that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'One could view the field names in the dataclass as akin to keys in a dictionary.
    If we did so, we could also capture the `milk` datum via a dictionary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a dictionary to capture the compound datum
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a to-do list named `myTD_D` that contains a list of dictionaries, rather
    than a list of dataclasses.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Putting these two approaches side-by-side, here‚Äôs the contrast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you see as the benefits and drawbacks of each of dataclasses and dictionaries
    to represent compound data?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dataclasses have a fixed number of fields, while directories allow arbitrary
    numbers of keys. Dataclass fields can be annotated with types (which most languages
    will check when you make new data); dictionaries can use fixed types for each
    of keys and values, though this gets restrictive when using dictionaries to capture
    dataclasses with fields of different types. Dataclasses give you a function name
    for creating new data, whereas with dictionaries you‚Äôd have to create such a function
    on your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, dataclasses come with more linguistic support for error checking:
    you can‚Äôt supply data for the wrong number of fields or field values of the wrong
    type. Dictionaries are more flexible: you can support optional fields more easily,
    including adding new fields/keys as a program runs. Each of these makes more sense
    in some programming situations.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function `ToDoItem_D` that takes a description, due date, and list of
    tags and returns a dictionary with keys for each field of a to-do item.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summary[üîó](#(part._.Summary) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Python programmers tend to make substantial use of dictionaries. In this chapter,
    we‚Äôve seen dictionaries used in two different settings:'
  prefs: []
  type: TYPE_NORMAL
- en: one in which the keys uniquely identify different entities or individuals among
    a larger set; the values represent some consistent type of information about each
    individual. The dictionary overall captures information about a large population
    of individuals, each with their own key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: one in which the keys name fields of compound data; the values associated with
    each field can have different types from the values for other fields. This setting
    corresponds to the use of dataclasses, in which a dictionary captures information
    about one individual; some other structure (such as a list or another dictionary)
    would be needed to hold the dictionaries for each individual.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a general rule, it is better to use dataclasses for the second setting when
    you have a fixed set of fields. The use of dictionaries for dataclasses is somewhat
    associated with programming practices in the Python community (less so in other
    languages). The first setting, however, is a common use of dictionaries in nearly
    all languages, especially since dictionaries are usually built to provide fast
    access to the data associated with a specific key.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.1¬†Creating and Using a Dictionary[üîó](#(part._.Creating_and_.Using_a_.Dictionary)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A dictionary maps unique values (called keys) to corresponding pieces of data
    for each key (called values). Here is our flight example written instead as a
    dictionary instead of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The general form of a dictionary is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Dictionaries are designed to enable easy lookup of values give a key. To get
    the
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'associated with key `''CSA-145''`, we can write simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the number of seats on flight `''CSA-145''`, we can simply write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, the dictionary data structure removes the need to traverse
    a list to find the `Flight` with a specific key. The dictionary lookup operation
    does that work for us. Actually, dictionaries are even more nuanced: depending
    on how they are designed, dictionaries can retrieve the value for a key without
    traversing all the values (or even any other value). In general, you can assume
    that dictionary-based lookup is significantly faster than a list-based one. How
    this works is a more advanced topic; some of this content is explained in [SECREF].'
  prefs: []
  type: TYPE_NORMAL
- en: 'One limitation of dictionaries is that they allow only one value per key. Let‚Äôs
    consider a different example, this time one that uses rooms in a building as keys
    and occupants as values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'What if someone new moves into office 412? In Python, we can the value for
    that key as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, any use of `office_dict[412]` will evaluate to `'Zeynep'` instead of `'Marisol'`.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.2¬†Searching Through the Values in a Dictionary[üîó](#(part._.Searching_.Through_the_.Values_in_a_.Dictionary)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What if we wanted to find all of the flights with more than 100 seats? For this,
    we have to search through all of the key-value pairs and check their balances.
    This again sounds like we need a for-loop. What does that look like on a dictionary
    though?
  prefs: []
  type: TYPE_NORMAL
- en: 'Turns out, it looks much like writing a for loop on a list (at least in Python).
    Here‚Äôs a program that creates a list of the flights with more than 100 seats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, the for-loop iterates over the keys. Within the loop, we use each key
    to retrieve its corresponding `Flight`, perform the balance check on the `Flight`,
    then put the `Flight` in our running list if it meets our criterion.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Create a dictionary that maps names of classrooms or meeting rooms to the numbers
    of seats that they have. Write expressions to:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Look up how many seats are in a specific room
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Change the capacity of a specific room to have 10 more seats than it did initially
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Find all rooms that can seat at least 50 students
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: 9.2.3¬†Dictionaries with More Complex Values[üîó](#(part._.Dictionaries_with_.More_.Complex_.Values)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A track-and-field tournament needs to manage the names of the players on the
    individual teams that will be competing. For example, ‚ÄúTeam Red‚Äù has ‚ÄúShaoming‚Äù
    and ‚ÄúLijin‚Äù, ‚ÄúTeam Green‚Äù contains ‚ÄúObi‚Äù and ‚ÄùChinara‚Äù, and ‚ÄúTeam Blue‚Äù has ‚ÄúMateo‚Äù
    and ‚ÄúSophia‚Äù. Come up with a way to organize the data that will allow the organizers
    to easily access the names of the players on each team, keeping in mind that there
    could be many more teams than just the three listed here.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This feels like a dictionary situation, in that we have a meaningful key (the
    team name) with which we want to access values (the names of the players). However,
    we have already said that dictionaries allow only one value per key. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would be in the dictionary after running this code? If you aren‚Äôt sure,
    try it out!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'How do we store multiple player names under the same key? The insight here
    is that the collection of players, not an individual player, is what we want to
    associate with the team name. We should therefore store a list of players under
    each key, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The values in a dictionary aren‚Äôt limited to being basic values. They can be
    arbitrarily complex, including lists, tables, or even other dictionaries (and
    more!). There is still only one value per key, which is the requirement of a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.4¬†Dictionaries versus Dataclasses[üîó](#(part._.Dictionaries_versus_.Dataclasses)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Previously, we learned about dataclasses as a way to create compound data in
    Python. Here again is the `ToDoItem` dataclass that we introduced earlier, as
    well as an example datum for that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'One could view the field names in the dataclass as akin to keys in a dictionary.
    If we did so, we could also capture the `milk` datum via a dictionary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a dictionary to capture the compound datum
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a to-do list named `myTD_D` that contains a list of dictionaries, rather
    than a list of dataclasses.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Putting these two approaches side-by-side, here‚Äôs the contrast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you see as the benefits and drawbacks of each of dataclasses and dictionaries
    to represent compound data?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dataclasses have a fixed number of fields, while directories allow arbitrary
    numbers of keys. Dataclass fields can be annotated with types (which most languages
    will check when you make new data); dictionaries can use fixed types for each
    of keys and values, though this gets restrictive when using dictionaries to capture
    dataclasses with fields of different types. Dataclasses give you a function name
    for creating new data, whereas with dictionaries you‚Äôd have to create such a function
    on your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, dataclasses come with more linguistic support for error checking:
    you can‚Äôt supply data for the wrong number of fields or field values of the wrong
    type. Dictionaries are more flexible: you can support optional fields more easily,
    including adding new fields/keys as a program runs. Each of these makes more sense
    in some programming situations.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function `ToDoItem_D` that takes a description, due date, and list of
    tags and returns a dictionary with keys for each field of a to-do item.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summary[üîó](#(part._.Summary) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Python programmers tend to make substantial use of dictionaries. In this chapter,
    we‚Äôve seen dictionaries used in two different settings:'
  prefs: []
  type: TYPE_NORMAL
- en: one in which the keys uniquely identify different entities or individuals among
    a larger set; the values represent some consistent type of information about each
    individual. The dictionary overall captures information about a large population
    of individuals, each with their own key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: one in which the keys name fields of compound data; the values associated with
    each field can have different types from the values for other fields. This setting
    corresponds to the use of dataclasses, in which a dictionary captures information
    about one individual; some other structure (such as a list or another dictionary)
    would be needed to hold the dictionaries for each individual.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a general rule, it is better to use dataclasses for the second setting when
    you have a fixed set of fields. The use of dictionaries for dataclasses is somewhat
    associated with programming practices in the Python community (less so in other
    languages). The first setting, however, is a common use of dictionaries in nearly
    all languages, especially since dictionaries are usually built to provide fast
    access to the data associated with a specific key.
  prefs: []
  type: TYPE_NORMAL
- en: Summary[üîó](#(part._.Summary) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Python programmers tend to make substantial use of dictionaries. In this chapter,
    we‚Äôve seen dictionaries used in two different settings:'
  prefs: []
  type: TYPE_NORMAL
- en: one in which the keys uniquely identify different entities or individuals among
    a larger set; the values represent some consistent type of information about each
    individual. The dictionary overall captures information about a large population
    of individuals, each with their own key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: one in which the keys name fields of compound data; the values associated with
    each field can have different types from the values for other fields. This setting
    corresponds to the use of dataclasses, in which a dictionary captures information
    about one individual; some other structure (such as a list or another dictionary)
    would be needed to hold the dictionaries for each individual.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a general rule, it is better to use dataclasses for the second setting when
    you have a fixed set of fields. The use of dictionaries for dataclasses is somewhat
    associated with programming practices in the Python community (less so in other
    languages). The first setting, however, is a common use of dictionaries in nearly
    all languages, especially since dictionaries are usually built to provide fast
    access to the data associated with a specific key.
  prefs: []
  type: TYPE_NORMAL
