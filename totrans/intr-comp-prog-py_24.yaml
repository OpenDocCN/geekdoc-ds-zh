- en: '23'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EXPLORING DATA WITH PANDAS
  prefs: []
  type: TYPE_NORMAL
- en: Most of the second half of this book is focused on building various kinds of
    computational models that can be used to extract useful information from data.
    In the chapters following this one, we will take a quick look at simple ways to
    use machine learning to build models from data.
  prefs: []
  type: TYPE_NORMAL
- en: Before doing so, however, we will look at a popular library that can be used
    to quickly get acquainted with a dataset before diving into more detailed analysis.
    **Pandas**[^(173)](#c23-fn-0001) is built on top of numpy. Pandas provides mechanisms
    to facilitate
  prefs: []
  type: TYPE_NORMAL
- en: Organizing data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating simple statistics about data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing the data in formats that faciltates future analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 23.1 DataFrames and CSV Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything in Pandas is built around the type **DataFrame**. A DataFrame is
    a mutable two-dimensional tabular data structure with labeled axes (rows and columns).
    One way to think about it is as a spreadsheet on steroids.
  prefs: []
  type: TYPE_NORMAL
- en: While DataFrames can be built from scratch using Python code, a more common
    way to create a DataFrame is by reading in a **CSV file**. As we saw in Chapter
    19, each line of a CSV file consists of one or more values, separated by commas.[^(174)](#c23-fn-0002)
    CSV files are typically used to store tabular numbers in plain text. In such cases,
    it is common for lines to have the same number of fields. Because they are plain
    text, they are often used to move data from one application to another. For example,
    most spreadsheet programs allow users to write the contents of spreadsheet into
    a CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 23-1](#c23-fig-0001) shows a DataFrame containing information about
    the late rounds of the 2019 FIFA Women''s World Cup. Each column represents something
    called a **series**. An **index** is associated with each row. By default, the
    indices are consecutive numbers, but they needn''t be. A **name** is associated
    with each column. As we will see, these names play a role similar to that of keys
    in dictionaries.'
  prefs: []
  type: TYPE_NORMAL
- en: '![c23-fig-0001.jpg](../images/c23-fig-0001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 23-1](#c23-fig-0001a) A sample Pandas DataFrame bound to the variable
    wwc'
  prefs: []
  type: TYPE_NORMAL
- en: The DataFrame pictured in [Figure 23-1](#c23-fig-0001) was produced using the
    code below and the CSV file depicted in [Figure 23-2](#c23-fig-0002).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![c23-fig-0002.jpg](../images/c23-fig-0002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 23-2](#c23-fig-0002a) An example CSV file'
  prefs: []
  type: TYPE_NORMAL
- en: After importing Pandas, the code uses the Pandas’ function `read_csv` to read
    the CSV file, and then prints it in the tabular form shown in [Figure 23-1](#c23-fig-0001).
    If the DataFrame has a large number of rows or columns, `print` will replace columns
    and/or rows in the center of the DataFrame with ellipses. This can be avoided
    by first converting the DataFrame to a string using the DataFrame method `to_string`.
  prefs: []
  type: TYPE_NORMAL
- en: Together, a row index and a column label indicate a data cell (as in a spreadsheet).
    We discuss how to access individual cells and groups of cells in Section 23.3\.
    Typically, but not always, the cells in a column are all of the same type. In
    the DataFrame in [Figure 23-1](#c23-fig-0001), each of the cells in the `Round`,
    `Winner`, and `Loser` columns is of type `str`. The cells in the `W` `Goals` and
    `L` `Goals` columns are of type `numpy.int64`. You won't have a problem if you
    think of them as Python ints.
  prefs: []
  type: TYPE_NORMAL
- en: We can directly access the three components of a DataFrame using the attributes
    `index`, `columns`, and `values`.
  prefs: []
  type: TYPE_NORMAL
- en: "The `index` attribute is of type `RangeIndex`. For example, the value of `wwc.index`\
    \ is `\uFEFFRangeIndex(start=0, stop=8, step=1)`. Therefore, the code"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: will print the integers 0-7 in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: "The `columns` attribute is of type `Index`. For example, the value `wwc.columns`\
    \ is \uFEFF`Index(['Round', 'Winner', 'W Goals', 'Loser', 'L Goals'], dtype='object')`,\
    \ and the code"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: "The `values` attribute is of type `numpy.ndarray`. In Chapter 13 we introduced\
    \ the type `numpy.array`. It turns out that `array` is a special case of `ndarray`.\
    \ Whereas arrays are one-dimensional (like other sequence types), ndarrays can\
    \ be multidimensional. The number of dimensions and items in an ndarray is called\
    \ its **shape** and is represented by a tuple of non-negative integers that specify\
    \ the size of each dimension. The value of \uFEFF`wwc.values` is the two-dimensional\
    \ ndarray"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since it has eight rows and five columns, its shape is `(8, 5)`.
  prefs: []
  type: TYPE_NORMAL
- en: 23.2 Creating Series and DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In practice, Pandas’ DataFrames are typically created by loading a dataset that
    has been stored as either an SQL database, a CSV file, or in a format associated
    with a spreadsheet application. However, it is sometimes useful to construct series
    and DataFrames using Python code.
  prefs: []
  type: TYPE_NORMAL
- en: "The expression `\uFEFFpd.DataFrame()` produces an empty DataFrame, and the\
    \ statement `print(pd.DataFrame())` produces the output"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A simple way to create a non-empty DataFrame is to pass in a list. For example,
    the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: "Notice that Pandas has automatically generated a label, albeit not a particularly\
    \ descriptive one, for the DataFrame's only column. To get a more descriptive\
    \ label, we can pass in a dictionary rather than a list. For example, the code\
    \ \uFEFF`print(pd.DataFrame({'Round': rounds}))` prints"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To directly create a DataFrame with multiple columns, we need only pass in a
    dictionary with multiple entries, each consisting of a column label as a key and
    a list as the value associated with each key. Each of these lists must be of the
    same length. For example, the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once a DataFrame has been created, it is easy to add columns. For example, the
    statement `df['W Goals'] = [2, 1, 0, 0]` mutates `df` so that its value becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: "Just as the values associated with a key in dictionary can be replaced, the\
    \ values associated with a column can be replaced. For example, after executing\
    \ the statement \uFEFF `\uFEFFdf['W Goals'] = [2, 1, 2, 2]`, the value of `df`\
    \ becomes"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: "It is also easy to drop columns from a DataFrame. The function call `\uFEFF\
    print(df.drop('Winner', axis = 'columns'))` prints"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: "and leaves `df` unchanged. If we had not included `axis = 'columns'` (or equivalently\
    \ `axis = 1`) in the call to `drop`, the axis would have defaulted to `'rows'`\
    \ (equivalent to `axis = 0`), which would have led to generating the exception\
    \ \uFEFF`KeyError: \"['Winner'] not found in axis.\"`"
  prefs: []
  type: TYPE_NORMAL
- en: "If a DataFrame is large, using `drop` in this way is inefficient, since it\
    \ requires copying the DataFrame. The copy can be avoided by setting the `inplace`\
    \ keyword argument to `drop` to `True`. The call \uFEFF`df.drop('Winner', axis\
    \ = 'columns', inplace = True)` mutates `df` and returns `None`."
  prefs: []
  type: TYPE_NORMAL
- en: Rows can be added to the beginning or end of a DataFrame using the `DataFrame`
    constructor to create a new DataFrame, and then using the `concat` function to
    combine the new DataFrame with an existing DataFrame. For example, the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: sets `df` to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Had the keyword argument `sort` been set to `True`, `concat` would have also
    changed the order of the columns based upon the lexographic ordering of their
    labels. That is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: swaps the position of the last two columns and returns the DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If no value for `sort` is provided, it defaults to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the indices of each of the concatenated DataFrames are unchanged.
    Consequently, there are multiple rows with the same index. The indices can be
    reset using the `reset_index` method. For example, the expression `df.reset_index(drop
    = True)` evaluates to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If `reset_index` is invoked with `drop = False`, a new column containing the
    old indices is added to the DataFrame. The column is labeled `index`.
  prefs: []
  type: TYPE_NORMAL
- en: "You might be wondering why Pandas even allows duplicate indices. The reason\
    \ is that it is often helpful to use a semantically meaningful index to label\
    \ rows. For example, `\uFEFFdf.set_index('Round')` evaluates to"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 23.3 Selecting Columns and Rows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: "As is the case for other composite types in Python, square brackets are the\
    \ primary mechanism for selecting parts of a DataFrame. To select a single column\
    \ of a DataFrame, we simply place the label of the column in between square brackets.\
    \ For example, \uFEFF `wwc['Winner']` evaluates to"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: "The type of this object is `**Series**`, i.e., it is not a DataFrame. A Series\
    \ is a one-dimensional sequence of values, each of which is labeled by an index.\
    \ To select a single item from a Series, we place an index within square brackets\
    \ following the series. So, \uFEFF`wwc['Winner'][3]` evaluates to the string `Sweden`."
  prefs: []
  type: TYPE_NORMAL
- en: We can iterate over a series using a `for` loop. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: "prints \uFEFF`England,USA,Netherlands,Sweden,USA,Netherlands,Sweden,USA`."
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** Write a function that returns the sum of the goals scored
    by winners.'
  prefs: []
  type: TYPE_NORMAL
- en: "Square brackets can also be used to select multiple columns from a DataFrame.\
    \ This is done by placing a list of column labels within the square brackets.\
    \ This produces a DataFrame rather than series. For example, \uFEFF`wwc[['Winner',\
    \ 'Loser']]` produces the DataFrame"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: "The column labels in the list within the selection square brackets don't have\
    \ to be in the same order as the labels appear in the original DataFrame. This\
    \ makes it convenient to use selection to reorganize the DataFrame. For example,\
    \ \uFEFF\uFEFF`\uFEFFwwc[['Round','Winner','Loser','W Goals','L Goals']]` returns\
    \ the DataFrame"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that attempting to select a row by putting its index inside of square brackets
    will not work. It will generate a `KeyError` exception. Curiously, however, we
    can select rows using slicing. So, while `wwc[1]` causes an exception, `wwc[1:2]`
    produces a DataFrame with a single row,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We discuss other ways of selecting rows in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 23.3.1 Selection Using loc and iloc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `**loc**` method can be used to select rows, columns, or combinations of
    rows and columns from a DataFrame. Importantly, all selection is done using labels.
    This is worth emphasizing, since some of the labels (e.g., the indices) can look
    suspiciously like numbers.
  prefs: []
  type: TYPE_NORMAL
- en: If `df` is a DataFrame, the expression `df.loc[label]` returns a series corresponding
    to the row associated with `label` in `df`. For example, `wwc.loc[3]` returns
    the Series
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the column labels of `wwc` are the index labels for the Series,
    and the values associated with those labels are the values for the corresponding
    columns in the row labeled `3` in `wwc`.
  prefs: []
  type: TYPE_NORMAL
- en: "To select multiple rows, we need only put a list of labels (rather than a single\
    \ label) inside the square brackets following `.loc`. When this is done, the value\
    \ of the expression is a DataFrame rather than a Series. For example, the expression\
    \ `\uFEFFwwc.loc[[1,3,5]]` produces"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the index associated with each row of the new DataFrame is the index
    of that row in the old DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: "Slicing provides another way to select multiple rows. The general form is `df.loc[first:last:step]`.\
    \ If `first` is not supplied, it defaults to the first index in the DataFrame.\
    \ If `last` is not supplied, it defaults to the last index in the DataFrame.If\
    \ `step` is not supplied, it defaults to `1`. The expression `\uFEFFwwc.loc[3:7:2]`\
    \ produces the DataFrame"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: "As a Python programmer, you might be surprised that that the row labeled `7`\
    \ is included. For other Python data containers (such as lists), the last value\
    \ is excluded when slicing, but not for DataFrames.[^(175)](#c23-fn-0003) The\
    \ expression \uFEFF`wwc.loc[6:]` produces the DataFrame"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: "And the expression \uFEFF`wwc.loc[:2]` produces"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Finger exercise:** Write an expression that selects all even numbered rows
    in `wwc`.'
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, `loc` can be used to simultaneously select a combination
    of rows and columns. This is done with an expression of the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The row and column selectors can be written using any of the mechanisms already
    discussed, i.e., a single label, a list of labels, or a slicing expression. For
    example, `wwc.loc[0:2, 'Round':'L Goals':2]` produces
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**Finger exercise:** Write an expression that generates the DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Thus far, you wouldn't have gone wrong if you thought of the index labels as
    integers. Let's see how selection works when 1) the labels are not number-like,
    and 2) more than one row has the same label. Let `wwc_by_round` be the DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: "What do you think the expression \uFEFF`wwc_by_round.loc['Semis']` evaluates\
    \ to? It selects all rows with the label `Semis` to return"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: "Similarly, \uFEFF`wwc_by_round.loc[['Semis', \uFEFF'Championship']]` selects\
    \ all rows with a label of either `Semis` or \uFEFF`Championship`:"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Slicing also work with non-numeric indices. The expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: produces a DataFrame by selecting the first row labeled by `Quarters` and then
    selecting every other row until it has passed a row labeled `Semis` to generate
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: "Now, suppose we want to select the second and third of the rows labeled `Quarters`.\
    \ We can't simply write \uFEFF`wwc_by_round.loc['Quarters']` because that will\
    \ select all four rows labeled `Quarters`. Enter the `iloc` method."
  prefs: []
  type: TYPE_NORMAL
- en: "The `**iloc**` method is like `loc`, except rather than working with labels,\
    \ it works with integers (hence the `i` in `iloc`). The first row of a DataFrame\
    \ is `iloc 0`, the second at `iloc 1`, etc. So, to select the second and third\
    \ of the rows labeled `Quarters`, we write \uFEFF`wwc_by_round.iloc[[1,2]]`."
  prefs: []
  type: TYPE_NORMAL
- en: 23.3.2 Selection by Group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is often convenient to split a DataFrame into subsets and apply some aggregation
    or transformation separately to each subset. The `groupby` method makes it easy
    to do this sort of thing.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose, for example, we want to know the total number of goals scored by the
    winning and losing teams in each round. The code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: "binds `group_by_round` to an object of type \uFEFF`DataFrameGroupBy`. We can\
    \ then apply the aggregator `sum` to that object to generate a DataFrame. The\
    \ code"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: "The code \uFEFF`print(wwc.groupby('Winner').mean())` prints"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: From this we can easily see that England averaged three goals in the games it
    won, while shutting out its opponents.
  prefs: []
  type: TYPE_NORMAL
- en: "The code \uFEFF`print(wwc.groupby(['Loser', 'Round']).mean())` prints"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: From this we can easily see that England averaged one goal in the games it lost,
    while giving up two.
  prefs: []
  type: TYPE_NORMAL
- en: 23.3.3 Selection by Content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose we want to select all of the rows for games won by Sweden from the DataFrame
    in [Figure 23-1](#c23-fig-0001). Since this DataFrame is a small one, we could
    look at each row and find the indices of the rows corresponding to those games.
    Of course, that approach doesn't scale to large DataFrames. Fortunately, it is
    easy to select rows based on their contents using something called **Boolean indexing**.
  prefs: []
  type: TYPE_NORMAL
- en: "The basic idea is to write a logical expression referring to the values contained\
    \ in the DataFrame. That expression is then evaluated on each row of the DataFrame,\
    \ and the rows for which it evaluates to `True` are selected. The expression \uFEFF\
    `wwc.loc[wwc['Winner'] == ‘Sweden']` evaluates to the DataFrame"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving all of the games involving Sweden is only a little more complicated.
    The logical operators `**&**` (corresponding to and), `**|**` (corresponding to
    or), and `**–**` (corresponding to not) can be used to form expressions. The expression
    `wwc.loc[(wwc['Winner'] == ‘Sweden') | (wwc['Loser'] == ‘Sweden')]` returns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Beware, the parentheses around the two subterms of the logical expression are
    necessary because in Pandas `|` has higher precedence than `==`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** Write an expression that returns a DataFrame containing
    games in which the USA but not France played.'
  prefs: []
  type: TYPE_NORMAL
- en: If we expect to do many queries selecting games in which a country participated,
    it might be convenient to define the function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: "Since `get_country` returns a DataFrame, it is easy to extract the games between\
    \ pairs of teams by composing two calls of `get_country`. For example, evaluating\
    \ \uFEFF`get_country(get_country(wwc, ‘Sweden'),'Germany')` extracts the one game\
    \ (teams play each other at most once during a knockout round) between these two\
    \ teams."
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to generalize `get_country` so that it accepts a list of countries
    as an argument and returns all games in which any of the countries in the list
    played. We can do this using the `isin` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `isin` method filters a DataFrame by selecting only those rows with a specified
    value (or element of a specified collection of values) in a specified column.
    The expression `df['Winner'].isin(countries)` in the implementation of `get_games`
    selects those rows in `df` in which the column `Winner` contains an element in
    the list `countries`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** Print a DataFrame containing only the games in which Sweden
    played either Germany or Netherlands.'
  prefs: []
  type: TYPE_NORMAL
- en: 23.4 Manipulating the Data in a DataFrame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've now looked at some simple ways to create and select parts of DataFrames.
    One of the things that makes DataFrames worth creating is the ease of extracting
    aggregate information from them. Let's start by looking at some ways we might
    extract aggregate information from the DataFrame `wwc`, pictured in [Figure 23-1](#c23-fig-0001).
  prefs: []
  type: TYPE_NORMAL
- en: "The columns of a DataFrame can be operated on in ways that are analogous to\
    \ the ways we operate on numpy arrays. For example, analogous to the way the expression\
    \ \uFEFF`2*np.array([1,2,3])` evaluates to the array `\uFEFF[2 4 6]`, the expression\
    \ \uFEFF`2*wwc['W Goals']` evaluates to the series"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The expression `wwc['W Goals'].sum()` sums the values in the `W Goals` column
    to produce the value `16`. Similarly, the expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: computes the total number of goals scored by Sweden, 6, and the expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: computes the mean goal differential of the games in the DataFrame, `1.5`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** Write an expression that computes the total number of
    goals scored in all of the rounds.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise**: Write an expression that computes the total number of
    goals scored by the losing teams in the quarter finals.'
  prefs: []
  type: TYPE_NORMAL
- en: "Suppose we want to add a column containing the goal differential for all of\
    \ the games and add a row summarizing the totals for all the columns containing\
    \ numbers. Adding the column is simple. We merely execute \uFEFF`wwc['G Diff']\
    \ = wwc['W Goals'] - wwc['L Goals']`. Adding the row is more involved. We first\
    \ create a dictionary with the contents of the desired row, and then use that\
    \ dictionary to create a new DataFrame containing only the new row. We then use\
    \ the `concat` function to concatenate `wwc` and the new DataFrame."
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This code produces the DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when we tried to sum the values in columns that did not contain
    numbers, Pandas did not generate an exception. Instead it supplied the special
    value `NaN` (Not a Number).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to providing simple arithmetic operations like sum and mean, Pandas
    provides methods for computing a variety of useful statistical functions. Among
    the most useful of these is `corr`, which is used to compute the **correlation**
    between two series.
  prefs: []
  type: TYPE_NORMAL
- en: A correlation is a number between -1 and 1 that provides information about the
    relationship between two numeric values. A positive correlation indicates that
    as the value of one variable increases, so does the value of the other. A negative
    correlation indicates that as the value of one variable increases, the value of
    the other variable decreases. A correlation of zero indicates that there is no
    relation between the values of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: The most commonly used measure of correction is Pearson correlation. Pearson
    correlation measures the strength and direction of the linear relationship between
    two variables. In addition to Pearson correlation, Pandas supports two other measures
    of correlation, Spearman and Kendall. There are important differences among the
    three measures (e.g., Spearman is less sensitive to outliers than Pearson, but
    is useful only for discovering monotonic relationships), but a discussion of when
    to use which is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: To print the Pearson pairwise correlations of `W Goals`, `L Goals`, and `G Diff`
    for all of the games (and exclude the row with the totals), we need only execute
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: which produces
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The values along the diagonal are all 1, because each series is perfectly positively
    correlated with itself. Unsurprisingly, the goal differentials are strongly positively
    correlated with the number of goals scored by the winning team, and strongly negatively
    correlated with the number of goals scored by the loser. The weaker negative correlation
    between the goals scored by the winners and losers also makes sense for professional
    soccer.[^(176)](#c23-fn-0004)
  prefs: []
  type: TYPE_NORMAL
- en: 23.5 An Extended Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section we will look at two datasets, one containing historical temperature
    data for 21 U.S. cities and the other historical data about the global use of
    fossil fuels.
  prefs: []
  type: TYPE_NORMAL
- en: 23.5.1 Temperature Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines of code set default options that limit the number of rows
    and columns shown when printing DataFrames. These options play a role similar
    to that played by the `rcParams` we used for setting various default values for
    plotting. The function `reset_option` can be used to set an option back to the
    system default value.
  prefs: []
  type: TYPE_NORMAL
- en: This DataFrame is organized in a way that makes it easy to see what the weather
    was like in different cities on specific dates. For example, the query
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: tells us that on August 12, 1979, the temperature in New York was 15C and in
    Tampa 25.55C.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** Write an expression that evaluates to `True` if Phoenix
    was warmer than Tampa on October 31, 2000, and `False` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** Write code to extract the date on which the temperature
    in Phoenix was 41.4C.[^(177)](#c23-fn-0005)'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, looking at data from 21 cities for 20,088 dates doesn't give
    us much direct insight into larger questions related to temperature trends. Let's
    start by adding columns that provide summary information about the temperatures
    each day. The code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Was the mean temperature of those 21 cities on July 4, 2000, really much higher
    than the temperature on the surface of the sun? Probably not. It seems more likely
    that there is a bug in our code. The problem is that our DataFrame encodes dates
    as numbers, and these numbers are used to compute the mean of each row. Conceptually,
    it might make more sense to think of the date as an index for a series of temperatures.
    So, let's change the DataFrame to make the dates indices. The code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: prints the more plausible
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Notice, by the way, that since `Date` is no longer a column label, we had to
    use a different print statement. Why did we use slicing to select a single row?
    Because we wanted to create a DataFrame rather than a series.
  prefs: []
  type: TYPE_NORMAL
- en: We are now in a position to start producing some plots showing various trends.
    For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: "produces a plot that shows the seasonality of temperatures in the United States.\
    \ Notice that before plotting the mean temperatures we cast the series into a\
    \ list. Had we plotted the series directly, it would have used the indices of\
    \ the series (integers representing dates) for the x-axis. This would have produced\
    \ a rather odd-looking plot, since the points on the x-axis would have been strangely\
    \ spaced. For example, the distance between December 30, 1961 and December 31,\
    \ 1961 would have been 1, but the distance between December 31, 1961 and January\
    \ 1, 1962 would have been 8870 (\uFEFF19620,101 – 19611231)."
  prefs: []
  type: TYPE_NORMAL
- en: '![c23-fig-5001.jpg](../images/c23-fig-5001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see the seasonal pattern more clearly, by zooming in on a few years and
    producing a plot using the call `plt.plot(list(temperatures['Mean T'])[0:3*365])`.
  prefs: []
  type: TYPE_NORMAL
- en: '![c23-fig-5002.jpg](../images/c23-fig-5002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Over the last decades, a consensus that the Earth is warming has emerged. Let's
    see whether this data is consistent with that consensus. Since we are investigating
    a hypothesis about a long-term trend, we should probably not be looking at daily
    or seasonal variations in temperature. Instead, let's look at annual data.
  prefs: []
  type: TYPE_NORMAL
- en: As a first step, let's use the data in `temperatures` to build a new DataFrame
    in which the rows represent years rather than days. Code that does this is contained
    in [Figure 23-3](#c23-fig-0005) and [Figure 23-4](#c23-fig-0006). Most of the
    work is done in the function `get_dict`, [Figure 23-3](#c23-fig-0005), which returns
    a dictionary mapping a year to a dictionary giving the values for that year associated
    with different labels. The implementation of `get_dict` iterates over the rows
    in `temperatures` using `iterrows`. That method returns an iterator that for each
    row returns a pair containing the index label and the contents of the row as a
    series. Elements of the yielded series can be selected using column labels.[^(178)](#c23-fn-0006)
  prefs: []
  type: TYPE_NORMAL
- en: '![c23-fig-0003.jpg](../images/c23-fig-0003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 23-3](#c23-fig-0005a) Building a dictionary mapping years to temperature
    data'
  prefs: []
  type: TYPE_NORMAL
- en: If `test` were the DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: "the call \uFEFF`get_dict(test, ['Max', 'Min'])` would return the dictionary"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '![c23-fig-0004.jpg](../images/c23-fig-0004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 23-4](#c23-fig-0006a) Building a DataFrame organized around years'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code following the invocation of get_dict in [Figure 23-4](#c23-fig-0006)
    builds a list containing each year appearing in `temperatures,` and additional
    lists containing the minimum, maximum, and mean temperatures for those years.
    Finally it uses those lists to build the DataFrame `yearly_temps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the data in a convenient format, let's generate some plots
    to visualize how the temperatures change over time. The code in [Figure 23-5](#c23-fig-0007)
    produced the plots in [Figure 23-6](#c23-fig-0008).
  prefs: []
  type: TYPE_NORMAL
- en: '![c23-fig-0005.jpg](../images/c23-fig-0005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 23-5](#c23-fig-0007a) Produce plots relating year to temperature measurements'
  prefs: []
  type: TYPE_NORMAL
- en: '![c23-fig-0006.jpg](../images/c23-fig-0006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 23-6](#c23-fig-0008a) Mean and minimum annual temperatures'
  prefs: []
  type: TYPE_NORMAL
- en: The plot on the left in [Figure 23-6](#c23-fig-0008) shows an undeniable trend;[^(179)](#c23-fn-0007)
    the mean temperatures in these 21 cities has risen over time. The plot on the
    right is less clear. The extreme annual fluctuations make it hard to see a trend.
    A more revealing plot can be produced by plotting a **moving average** of the
    temperatures.
  prefs: []
  type: TYPE_NORMAL
- en: "The Pandas method `rolling` is used to perform an operation on multiple consecutive\
    \ values of a series. Evaluating the expression `\uFEFFyearly_temps['Min T'].rolling(7).mean()`\
    \ produces a series in which the first 6 values are `NaN`, and for each i greater\
    \ than 6, the ith value in the series is the mean of `yearly_temps['Min'][i-6:i+1].`\
    \ Plotting that series against the year produces the plot in [Figure 23-7](#c23-fig-0009),\
    \ which does suggest a trend."
  prefs: []
  type: TYPE_NORMAL
- en: '![c23-fig-0007.jpg](../images/c23-fig-0007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 23-7](#c23-fig-0009a) Rolling average minimum temperatures'
  prefs: []
  type: TYPE_NORMAL
- en: While visualizing the relationship between two series can be informative, it
    is often useful to look at those relationships more quantitatively. Let's start
    by looking at the correlations between years and the seven-year rolling averages
    of the minimum, maximum, and mean temperatures. Before computing the correlations,
    we first update the series in `yearly_temps` to contain rolling averages and then
    convert the year values from strings to integers. The code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: All of the summary temperature values are positively correlated with the year,
    with the mean temperatures the most strongly correlated. That raises the question
    of how much of the variance in the rolling average of the mean temperatures is
    explained by the year. The following code prints the coefficient of determination
    (Section 20.2.1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: "Since some of the values in the `Mean` series are `NaN`, we first use the function\
    \ `np.isfinite` to get the indices of the non-`NaN` values in `\uFEFFyearly_temps['Mean']`.\
    \ We then build a linear model and finally use the `r_squared` function (see Figure\
    \ 20-13) to compare the results predicted by the model to the actual temperatures.\
    \ The linear model relating years to the seven-year rolling average mean temperature\
    \ explains nearly 94% of the variance."
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise:** Find the coefficient of determination (r²) for the mean
    annual temperature rather than for the rolling average and for a ten-year rolling
    average.'
  prefs: []
  type: TYPE_NORMAL
- en: If you happen to live in the U.S. or plan to travel to the U.S., you might be
    more interested in looking at the data by city rather than year. Let's start by
    producing a new DataFrame that provides summary data for each city. In deference
    to our American readers, we convert all temperatures to Fahrenheit by applying
    a conversion function to all values in `city_temps`. The penultimate line adds
    a column showing how extreme the temperature variation is. Executing this code
    produces the DataFrame in [Figure 23-8](#c23-fig-0010).[^(180)](#c23-fn-0008)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '![c23-fig-0008.jpg](../images/c23-fig-0008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 23-8](#c23-fig-0010a) Average temperatures for select cities'
  prefs: []
  type: TYPE_NORMAL
- en: To visualize differences among cities, we generated the plot in [Figure 23-9](#c23-fig-0011)
    using the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: "Notice that we used the sort order \uFEFF`Max - Min` for all three series.\
    \ The use of `ascending = False` reverses the default sorting order."
  prefs: []
  type: TYPE_NORMAL
- en: '![c23-fig-0009.jpg](../images/c23-fig-0009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 23-9](#c23-fig-0011a) Variation in temperature extremes'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at this plot we can see, among other things, that
  prefs: []
  type: TYPE_NORMAL
- en: Across cities, the minimum temperature differs much more than the maximum temperature.
    Because of this, Max – Min (the sort order) is strongly positively correlated
    with the minimum temperature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It never gets very hot in San Francisco or Seattle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The temperature in San Juan is close to constant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The temperature in Chicago is not close to constant. It gets both quite hot
    and frighteningly cold in the windy city.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It gets uncomfortably hot in both Phoenix and Las Vegas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: San Francisco and Albuquerque have about the same mean temperature, but radically
    different minima and maxima.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 23.5.2 Fossil Fuel Consumption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: "The file \uFEFFglobal-fossil-fuel-consumption.csv contains data about the yearly\
    \ consumption of fossil fuels on Earth from 1965 and 2015\\. The code"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: prints
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's replace the columns showing the consumption of each kind of fuel
    by two columns, one showing the sum of the three, and the other the five-year
    rolling average of the sum.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We can plot this data using
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: to get the plot in [Figure 23-10](#c23-fig-0012).
  prefs: []
  type: TYPE_NORMAL
- en: '![c23-fig-0010.jpg](../images/c23-fig-0010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 23-10](#c23-fig-0012a) Global consumption of fossil fuels'
  prefs: []
  type: TYPE_NORMAL
- en: While there are a few small dips in consumption (e.g., around the 2008 financial
    crisis), the upward trend is unmistakable.
  prefs: []
  type: TYPE_NORMAL
- en: The scientific community has reached consensus that there is an association
    between this rise in fuel consumption and the rise in the average temperature
    on the planet. Let's see how it relates to the temperatures in the 21 U.S. cities
    we looked at in Section 23.5.1.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that `yearly_temps` was bound to the DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Wouldn't it be nice if there were an easy way to combine `yearly_temps` and
    `emissions`? Pandas’ `merge` function does just that. The code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: prints the DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The DataFrame contains the union of the columns appearing in `yearly_temps`
    and `emissions` but includes only rows built from the rows in `yearly_temps` and
    `emissions` that contain the same value in the `Year` column.
  prefs: []
  type: TYPE_NORMAL
- en: "Now that we have the emissions and temperature information in the same DataFrame,\
    \ it is easy to look at how things are correlated with each other. The code  `\uFEFF\
    print(merged_df.corr().round(2).to_string())` prints"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We see that global fuel consumption in previous years is indeed highly correlated
    with both the mean and maximum temperature in these U.S. cities. Does this imply
    that increased fuel consumption is causing the rise in temperature? It does not.
    Notice that both are highly correlated with year. Perhaps some lurking variable
    is also correlated with year and is the causal factor. What we can say from a
    statistical perspective, is that the data does not contradict the widely accepted
    scientific hypothesis that the increased use of fossil fuels generates greenhouse
    gasses that have caused temperatures to rise.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our brief look at Pandas. We have only scratched the surface
    of what it offers. We will use it later in the book and introduce a few more features.
    If you want to learn more, there are many online resources and some excellent
    inexpensive books. The website `[https://www.dataschool.io/best-python-pandas-resources/](https://www.dataschool.io/best-python-pandas-resources/)`
    lists some of these.
  prefs: []
  type: TYPE_NORMAL
- en: 23.6 Terms Introduced in Chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DataFrame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSV file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: shape (of ndarray)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: correlation of series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: moving (rolling) average
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
