- en: 12.2Â Understanding EqualityğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.2Â ç†è§£ç›¸ç­‰ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/unified-equality.html](https://dcic-world.org/2025-08-27/unified-equality.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/unified-equality.html](https://dcic-world.org/2025-08-27/unified-equality.html)
- en: '| Â Â Â Â [12.2.1Â Equality of Data](#%28part._equality-of-data%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [12.2.1 æ•°æ®çš„ç›¸ç­‰](#%28part._equality-of-data%29)|'
- en: '| Â Â Â Â [12.2.2Â Different Equality Operations](#%28part._equality-operations%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [12.2.2Â ä¸åŒçš„ç›¸ç­‰æ“ä½œ](#%28part._equality-operations%29)|'
- en: '| Â Â Â Â Â Â [12.2.2.1Â Equality in Python](#%28part._.Equality_in_.Python%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [12.2.2.1 Pythonä¸­çš„ç›¸ç­‰](#%28part._.Equality_in_.Python%29)|'
- en: '| Â Â Â Â Â Â [12.2.2.2Â Equality in Pyret](#%28part._.Equality_in_.Pyret%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [12.2.2.2 Pyretä¸­çš„ç›¸ç­‰](#%28part._.Equality_in_.Pyret%29)|'
- en: 12.2.1Â Equality of Data[ğŸ”—](#(part._equality-of-data) "Link to here")
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.1Â æ•°æ®çš„ç›¸ç­‰[ğŸ”—](#(part._equality-of-data) "é“¾æ¥è‡³æ­¤")
- en: Now that we have the ability to mutate data, itâ€™s worth asking what it means
    for two pieces of data to be equal. Weâ€™ll motivate this through a concrete example.
    Following the naming convention of [Structure Mutation and the Directory](mutating-structures.html#%28part._structure-mut-dir%29),
    we will write every name only once, using the upper-case name from Python, but
    everything we write will equally be true for Pyret.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†ä¿®æ”¹æ•°æ®çš„èƒ½åŠ›ï¼Œå€¼å¾—æ€è€ƒä¸¤ä¸ªæ•°æ®ç›¸ç­‰æ„å‘³ç€ä»€ä¹ˆã€‚æˆ‘ä»¬å°†é€šè¿‡ä¸€ä¸ªå…·ä½“çš„ä¾‹å­æ¥é˜è¿°è¿™ä¸€ç‚¹ã€‚éµå¾ª[ç»“æ„ä¿®æ”¹å’Œç›®å½•](mutating-structures.html#%28part._structure-mut-dir%29)çš„å‘½åè§„èŒƒï¼Œæˆ‘ä»¬å°†åªå†™æ¯ä¸ªåç§°ä¸€æ¬¡ï¼Œä½¿ç”¨Pythonçš„å¤§å†™åç§°ï¼Œä½†æˆ‘ä»¬æ‰€å†™çš„ä¸€åˆ‡å¯¹Pyretä¹ŸåŒæ ·é€‚ç”¨ã€‚
- en: 'First, consider these three statements:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè€ƒè™‘ä»¥ä¸‹ä¸‰ä¸ªé™ˆè¿°ï¼š
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Do Now!
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the above `Account`s do you consider â€œequalâ€?
  id: totrans-12
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ è®¤ä¸ºå“ªä¸ªä»¥ä¸Šçš„`Account`æ˜¯â€œç›¸ç­‰çš„â€ï¼Ÿ
- en: The third `Account` has a different balance than the first two, so it canâ€™t
    be considered equal to either of the first two. The first two have the same contents,
    so arguably they can be considered equal.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸‰ä¸ª`Account`çš„ä½™é¢ä¸å‰ä¸¤ä¸ªä¸åŒï¼Œå› æ­¤ä¸èƒ½è®¤ä¸ºå®ƒä¸å‰ä¸¤ä¸ªç›¸ç­‰ã€‚å‰ä¸¤ä¸ªå…·æœ‰ç›¸åŒçš„å†…å®¹ï¼Œæ‰€ä»¥å¯ä»¥è¯´å®ƒä»¬å¯ä»¥è¢«è®¤ä¸ºæ˜¯ç›¸ç­‰çš„ã€‚
- en: 'Now, letâ€™s consider the directory and heap that would result from running these
    three statements:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬è€ƒè™‘è¿è¡Œè¿™ä¸‰ä¸ªè¯­å¥åäº§ç”Ÿçš„ç›®å½•å’Œå †ï¼š
- en: Directory
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE1]'
- en: â†’Â 1120
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1120
- en: '[PRE2]'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE2]'
- en: â†’Â 1121
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1121
- en: '[PRE3]'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE3]'
- en: â†’Â 1122
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1122
- en: Heap
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1120:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1120:'
- en: '[PRE4]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '1121:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1121:'
- en: '[PRE5]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '1122:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1122:'
- en: '[PRE6]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'From the perspective of the heap, each account ends up at its own address.
    Those different addresses are a way in which the two values are not the same:
    they have the same contents, but not the same address. Is that relevant? To explore
    this, letâ€™s associate another name (`a4`) with the same address as `a2`, then
    change the balance in `a2`. For now we will show just the Python version:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ä»å †çš„è§’åº¦æ¥çœ‹ï¼Œæ¯ä¸ªè´¦æˆ·æœ€ç»ˆéƒ½ä¼šåˆ°è¾¾è‡ªå·±çš„åœ°å€ã€‚è¿™äº›ä¸åŒçš„åœ°å€æ˜¯ä¸¤ä¸ªå€¼ä¸åŒçš„æ–¹å¼ï¼šå®ƒä»¬æœ‰ç›¸åŒçš„å†…å®¹ï¼Œä½†æ²¡æœ‰ç›¸åŒçš„åœ°å€ã€‚è¿™æœ‰ä»€ä¹ˆç›¸å…³å—ï¼Ÿä¸ºäº†æ¢ç´¢è¿™ä¸€ç‚¹ï¼Œè®©æˆ‘ä»¬å°†å¦ä¸€ä¸ªåç§°ï¼ˆ`a4`ï¼‰ä¸`a2`ç›¸åŒçš„åœ°å€å…³è”èµ·æ¥ï¼Œç„¶åæ›´æ”¹`a2`çš„ä½™é¢ã€‚ç°åœ¨æˆ‘ä»¬åªå±•ç¤ºPythonç‰ˆæœ¬ï¼š
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What does memory look like before and after checkpoint 1? Before the checkpoint:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: æ£€æŸ¥ç‚¹1ä¹‹å‰å’Œä¹‹åå†…å­˜çœ‹èµ·æ¥åƒä»€ä¹ˆï¼Ÿåœ¨æ£€æŸ¥ç‚¹ä¹‹å‰ï¼š
- en: Directory
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE8]'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE8]'
- en: â†’Â 1130
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1130
- en: '[PRE9]'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE9]'
- en: â†’Â 1131
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1131
- en: '[PRE10]'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE10]'
- en: â†’Â 1132
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1132
- en: '[PRE11]'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE11]'
- en: â†’Â 1131
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1131
- en: Heap
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1130:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1130:'
- en: '[PRE12]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '1131:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1131:'
- en: '[PRE13]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '1132:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1132:'
- en: '[PRE14]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`a1` and `a2` refer to two different `Account`s with the same contents. After
    checkpoint 1, those contents are different because we modified the contents of
    the balance field in `a2`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`a1`å’Œ`a2`æŒ‡çš„æ˜¯ä¸¤ä¸ªå…·æœ‰ç›¸åŒå†…å®¹çš„`Account`ã€‚åœ¨æ£€æŸ¥ç‚¹1ä¹‹åï¼Œè¿™äº›å†…å®¹å°±ä¸åŒäº†ï¼Œå› ä¸ºæˆ‘ä»¬ä¿®æ”¹äº†`a2`ä¸­ä½™é¢å­—æ®µçš„å«é‡ï¼š'
- en: Directory
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE15]'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE15]'
- en: â†’Â 1130
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1130
- en: '[PRE16]'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE16]'
- en: â†’Â 1131
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1131
- en: '[PRE17]'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE17]'
- en: â†’Â 1132
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1132
- en: '[PRE18]'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE18]'
- en: â†’Â 1131
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1131
- en: Heap
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1130:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1130:'
- en: '[PRE19]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '1131:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1131:'
- en: '[PRE20]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '1132:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1132:'
- en: '[PRE21]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In contrast, `a2` and `a4` are aliases for the same `Account`. Therefore, their
    values change in lockstep: asking to display the value of either one would now
    show an account with a balance of `800`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸æ¯”ä¹‹ä¸‹ï¼Œ`a2`å’Œ`a4`æ˜¯åŒä¸€`Account`çš„åˆ«åã€‚å› æ­¤ï¼Œå®ƒä»¬çš„å€¼ä¼šåŒæ­¥å˜åŒ–ï¼šç°åœ¨è¦æ±‚æ˜¾ç¤ºä»»ä½•ä¸€ä¸ªçš„å€¼éƒ½ä¼šæ˜¾ç¤ºä¸€ä¸ªä½™é¢ä¸º`800`çš„è´¦æˆ·ã€‚
- en: Do Now!
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think now? Are the first two accounts equal?
  id: totrans-68
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ ç°åœ¨æ€ä¹ˆæƒ³ï¼Ÿå‰ä¸¤ä¸ªè´¦æˆ·ç›¸ç­‰å—ï¼Ÿ
- en: 12.2.2Â Different Equality Operations[ğŸ”—](#(part._equality-operations) "Link to
    here")
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.2Â ä¸åŒçš„ç›¸ç­‰æ“ä½œ[ğŸ”—](#(part._equality-operations) "é“¾æ¥è‡³æ­¤")
- en: 'This sequence of examples points out that we seem to be raising two possible
    notions of equality:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸€ç³»åˆ—çš„ä¾‹å­æŒ‡å‡ºï¼Œæˆ‘ä»¬ä¼¼ä¹æå‡ºäº†ä¸¤ç§å¯èƒ½çš„ç›¸ç­‰æ¦‚å¿µï¼š
- en: Whether two values have the same contents. This is formally called structural
    equality; you can think of it as a â€œprint equalityâ€, namely, when displayed, do
    the two values look the same.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä¸¤ä¸ªå€¼æ˜¯å¦æœ‰ç›¸åŒçš„å†…å®¹ã€‚è¿™æ­£å¼ç§°ä¸ºç»“æ„ç›¸ç­‰ï¼›ä½ å¯ä»¥å°†å…¶è§†ä¸ºâ€œæ‰“å°ç›¸ç­‰â€ï¼Œå³å½“æ˜¾ç¤ºæ—¶ï¼Œä¸¤ä¸ªå€¼çœ‹èµ·æ¥æ˜¯å¦ç›¸åŒã€‚
- en: Whether two values live at the same address, i.e., there is actually only one
    value in memory. This is formally called reference equality. Usually, we would
    refer to the two values by different names (so there is the possibility that they
    are different), and reference equality checks whether the names are aliases. Observe
    that a given value always prints the same way, so any two names that have reference
    equality also have structural equality, but not vice versa.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä¸¤ä¸ªå€¼æ˜¯å¦ä½äºåŒä¸€åœ°å€ï¼Œå³å†…å­˜ä¸­å®é™…ä¸Šåªæœ‰ä¸€ä¸ªå€¼ã€‚è¿™æ­£å¼ç§°ä¸ºå¼•ç”¨ç­‰ä»·æ€§ã€‚é€šå¸¸ï¼Œæˆ‘ä»¬ä¼šç”¨ä¸åŒçš„åç§°æ¥å¼•ç”¨è¿™ä¸¤ä¸ªå€¼ï¼ˆå› æ­¤å®ƒä»¬å¯èƒ½æ˜¯ä¸åŒçš„ï¼‰ï¼Œå¼•ç”¨ç­‰ä»·æ€§æ£€æŸ¥è¿™äº›åç§°æ˜¯å¦æ˜¯åˆ«åã€‚è§‚å¯Ÿåˆ°ä¸€ä¸ªç»™å®šçš„å€¼æ€»æ˜¯ä»¥ç›¸åŒçš„æ–¹å¼æ‰“å°ï¼Œå› æ­¤å…·æœ‰å¼•ç”¨ç­‰ä»·æ€§çš„ä»»ä½•ä¸¤ä¸ªåç§°ä¹Ÿå…·æœ‰ç»“æ„ç­‰ä»·æ€§ï¼Œä½†åä¹‹åˆ™ä¸ç„¶ã€‚
- en: Which notion of equality is â€œcorrectâ€? It turns out that they are valuable in
    different contexts. For this reason, programming languages generally provide multiple
    equality operations, letting the programmer indicate which kind of equality they
    mean in their context.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: å“ªç§ç­‰ä»·æ¦‚å¿µæ˜¯â€œæ­£ç¡®â€çš„ï¼Ÿå®é™…ä¸Šï¼Œå®ƒä»¬åœ¨ä¸åŒçš„ä¸Šä¸‹æ–‡ä¸­éƒ½å¾ˆæœ‰ä»·å€¼ã€‚å› æ­¤ï¼Œç¼–ç¨‹è¯­è¨€é€šå¸¸æä¾›å¤šç§ç­‰ä»·æ“ä½œï¼Œè®©ç¨‹åºå‘˜èƒ½å¤Ÿè¡¨æ˜ä»–ä»¬åœ¨ä¸Šä¸‹æ–‡ä¸­æŒ‡çš„æ˜¯å“ªç§ç­‰ä»·ã€‚
- en: Unfortunately, the names of equality operations, and their exact meaning, vary
    across languages. Therefore, we will examine each of Pyret and Python separately.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œç­‰ä»·æ“ä½œçš„åç§°åŠå…¶ç¡®åˆ‡å«ä¹‰åœ¨ä¸åŒçš„è¯­è¨€ä¸­å„ä¸ç›¸åŒã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†åˆ†åˆ«æ£€æŸ¥ Pyret å’Œ Pythonã€‚
- en: 12.2.2.1Â Equality in Python[ğŸ”—](#(part._.Equality_in_.Python) "Link to here")
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 12.2.2.1 Pyret ä¸­çš„ç­‰ä»·æ€§[ğŸ”—](#(part._.Equality_in_.Python) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'The `==` operator that you learned in Pyret and we carried into Python checks
    for structural equality, independent of addresses:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Pyret å’Œ Python ä¸­ä½ å­¦åˆ°çš„ `==` æ“ä½œç¬¦æ£€æŸ¥ç»“æ„ç­‰ä»·æ€§ï¼Œä¸åœ°å€æ— å…³ï¼š
- en: '|'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE22]'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '&#124;'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE24]'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '&#124;'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'However, note that this will no longer be true at checkpoint 2:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œåœ¨æ£€æŸ¥ç‚¹ 2 æ—¶è¿™ä¸å†æˆç«‹ï¼š
- en: '|'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE26]'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '&#124;'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE28]'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '&#124;'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'If we instead want to check for aliasing, we instead use an operation called
    `is` (not to be confused with Pyretâ€™s `is`, which is used for writing tests):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³æ£€æŸ¥åˆ«åï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªåä¸º `is` çš„æ“ä½œï¼ˆä¸è¦ä¸ Pyret çš„ `is` æ··æ·†ï¼Œåè€…ç”¨äºç¼–å†™æµ‹è¯•ï¼‰ï¼š
- en: '|'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE30]'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '&#124;'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE32]'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '&#124;'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: This explains why `a2 == a4` was true both before and after the mutation, but
    `a1 == a2` was no longer true after it. The latter seems to violate a very basic
    meaning of â€œequalityâ€; the problem here is caused by the introduction of mutation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è§£é‡Šäº†ä¸ºä»€ä¹ˆ `a2 == a4` åœ¨å˜å¼‚å‰åéƒ½ä¸ºçœŸï¼Œä½† `a1 == a2` åœ¨å˜å¼‚åä¸å†ä¸ºçœŸã€‚åè€…ä¼¼ä¹è¿åäº†â€œç­‰ä»·â€çš„åŸºæœ¬å«ä¹‰ï¼›è¿™é‡Œçš„é—®é¢˜æ˜¯ç”±äºå¼•å…¥äº†å˜å¼‚ã€‚
- en: As we go forward, youâ€™ll get more practice with when to use each kind of equality.
    The `==` operator is more accepting, so it is usually the right default. If you
    actually need to know whether two expressions evaluate to the same address, you
    should instead use `is`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: éšç€æˆ‘ä»¬ç»§ç»­å‰è¿›ï¼Œä½ å°†æ›´å¤šåœ°ç»ƒä¹ ä½•æ—¶ä½¿ç”¨æ¯ç§ç±»å‹çš„ç­‰ä»·æ€§ã€‚`==` æ“ä½œç¬¦æ›´å®½å®¹ï¼Œå› æ­¤é€šå¸¸æ˜¯æ­£ç¡®çš„é»˜è®¤é€‰é¡¹ã€‚å¦‚æœä½ å®é™…ä¸Šéœ€è¦çŸ¥é“ä¸¤ä¸ªè¡¨è¾¾å¼æ˜¯å¦è¯„ä¼°ä¸ºåŒä¸€åœ°å€ï¼Œä½ åº”è¯¥ä½¿ç”¨
    `is`ã€‚
- en: 12.2.2.2Â Equality in Pyret[ğŸ”—](#(part._.Equality_in_.Pyret) "Link to here")
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 12.2.2.2 Pyret ä¸­çš„ç­‰ä»·æ€§[ğŸ”—](#(part._.Equality_in_.Pyret) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Equality in Pyret is somewhat more detailed, because the language wants you
    to think harder about what is happening in your programs.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret ä¸­çš„ç­‰ä»·æ€§æœ‰äº›æ›´è¯¦ç»†ï¼Œå› ä¸ºè¯¥è¯­è¨€å¸Œæœ›ä½ åœ¨ç¨‹åºä¸­æ›´æ·±å…¥åœ°æ€è€ƒæ­£åœ¨å‘ç”Ÿçš„äº‹æƒ…ã€‚
- en: 'Recall that we are using the datatype in [Example: Bank Accounts](mutating-structures.html#%28part._eg-bank-acc%29)
    and have written the following definitions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹ï¼Œæˆ‘ä»¬æ­£åœ¨ä½¿ç”¨ [ç¤ºä¾‹ï¼šé“¶è¡Œè´¦æˆ·](mutating-structures.html#%28part._eg-bank-acc%29) ä¸­çš„æ•°æ®ç±»å‹ï¼Œå¹¶ç¼–å†™äº†ä»¥ä¸‹å®šä¹‰ï¼š
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In Python, we saw that `a1 == a2` before the mutation. However, in Pyret, this
    produces `false`! Why?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Python ä¸­ï¼Œæˆ‘ä»¬åœ¨å˜å¼‚ä¹‹å‰çœ‹åˆ°äº† `a1 == a2`ã€‚ç„¶è€Œï¼Œåœ¨ Pyret ä¸­ï¼Œè¿™ä¼šäº§ç”Ÿ `false`ï¼ä¸ºä»€ä¹ˆï¼Ÿ
- en: 'The reason is because structural equality is actually complicated; there are
    two different questions we could be asking:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: åŸå› æ˜¯ç»“æ„ç­‰ä»·æ€§å®é™…ä¸Šå¾ˆå¤æ‚ï¼›æˆ‘ä»¬å¯ä»¥é—®ä¸¤ä¸ªä¸åŒçš„é—®é¢˜ï¼š
- en: Are these two values structurally equal right now?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªå€¼ç°åœ¨åœ¨ç»“æ„ä¸Šç›¸ç­‰å—ï¼Ÿ
- en: Will these two values be structurally equal always?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªå€¼åœ¨ç»“æ„ä¸Šæ€»æ˜¯ç›¸ç­‰å—ï¼Ÿ
- en: Pyret makes a distinction between these two.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret åœ¨è¿™ä¸¤ä¸ªä¹‹é—´åšå‡ºäº†åŒºåˆ†ã€‚
- en: 'By default, Pyret tends towards safer programming practices. Therefore, the
    standard (structural) equality predicate, `==`, will only return `true` if the
    two values will always be equal. Thus:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: é»˜è®¤æƒ…å†µä¸‹ï¼ŒPyret å€¾å‘äºæ›´å®‰å…¨çš„ç¼–ç¨‹å®è·µã€‚å› æ­¤ï¼Œæ ‡å‡†çš„ï¼ˆç»“æ„ï¼‰ç­‰ä»·è°“è¯ `==` åªæœ‰åœ¨è¿™ä¸¤ä¸ªå€¼å§‹ç»ˆç›¸ç­‰æ—¶æ‰ä¼šè¿”å› `true`ã€‚å› æ­¤ï¼š
- en: '|'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE35]'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '&#124;'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Because the two values are actually aliases, no matter how one changes, the
    â€œotherâ€ will always change in the same way. Therefore, they will always â€œprint
    the sameâ€. We can confirm that they are aliases by using Pyretâ€™s reference equality
    operator, `<=>`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '&#124;'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '&#124;'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, that guarantee does not apply to `a1` and `a2`; and indeed, at
    checkpoint 2, we see that they are no longer equal. Hence
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '&#124;'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '|'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a time when `a1` and `a2` do print the same, namely before
    checkpoint 1\. Therefore, Pyret provides another equality operator that checks
    whether values are equal at the moment, `=~`. If we ask this before checkpoint
    1, we get:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '&#124;'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we ask the same question at checkpoint 2, we get:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '&#124;'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'These operators and their funny symbols may be hard to remember, but Pyret
    also gives them useful (if longer) names, and they can be used as ordinary functions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbol |  | Function |  | Type |  | Meaning |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| `==` |  | `equal-always` |  | Structural |  | If it returns `true`, they
    will always be equal, irrespective of any future mutations. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| `=~` |  | `equal-now` |  | Structural |  | If it returns `true` they are
    currently equal, but that may change after future mutations. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| `<=>` |  | `identical` |  | Reference |  | Returns `true` if the two arguments
    are aliases, `false` otherwise. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: 'Thus, before checkpoint 1:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '&#124;'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '&#124;'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '|'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '&#124;'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '|'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '&#124;'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '|'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '&#124;'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '|'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '&#124;'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '|'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'After checkpoint 2, we no longer need to check any of the `equal-always` or
    `identical` relationships again, because by definition they cannot change. But
    we should check `equal-now` again. Sure enough:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '&#124;'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '|'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '&#124;'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '|'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in Pyret, the `==` operator is the same as `equal-always`. When data
    contain mutable fields, this will always produce `false`, because even if the
    values are structurally equal now, itâ€™s possible that a future mutation will change
    that. This is to remind you to be careful in the presence of mutation. In situations
    where we really care only about equality at that instant, we can use `=~`, i.e.,
    `equal-now`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The examples above might suggest that only aliased values are `equal-always`.
    This is not true! If our data are immutable (which is the default in the language),
    then if two values are structurally equal now, they must remain structurally equal
    forever. For such data, `equal-always` will return `true` even when they are not
    aliases. This is a reminder that we get stronger guarantees about immutable data.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that upto this point we have used `equal-always`â€”<wbr>in
    the form of both `==` and Pyretâ€™s `is` in testingâ€”<wbr>without really bothering
    to understand very much about how it works, and yet have always gotten predictable
    answers. This suggests that there is something natural about working with immutable
    data. In contrast, with mutable data, something has to give. Pyret made a conscious
    design choice to reflect this in the distinction between `equal-always` and `equal-now`.
    Python made a different choice, which results in â€œequalityâ€ having a perhaps surprising
    meaning. (Python has no notion of `equal-always`, only `equal-now` or `=~`, which
    is written as `==`, and `identical` or `<=>`, which is written as `is`.)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¸€ç›´ä½¿ç”¨`equal-always`â€”<wbr>åœ¨æµ‹è¯•ä¸­æ—¢ä½¿ç”¨`==`ä¹Ÿä½¿ç”¨Pyretçš„`is`â€”<wbr>è€Œæ²¡æœ‰çœŸæ­£å»ç†è§£å®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œä½†æˆ‘ä»¬æ€»æ˜¯å¾—åˆ°äº†å¯é¢„æµ‹çš„ç­”æ¡ˆã€‚è¿™è¡¨æ˜ä¸ä¸å¯å˜æ•°æ®ä¸€èµ·å·¥ä½œæœ‰ä¸€äº›è‡ªç„¶ä¹‹å¤„ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œåœ¨ä½¿ç”¨å¯å˜æ•°æ®æ—¶ï¼Œå¿…é¡»æœ‰æ‰€å¦¥åã€‚Pyretæœ‰æ„è¯†åœ°åšå‡ºäº†è®¾è®¡é€‰æ‹©ï¼Œé€šè¿‡`equal-always`å’Œ`equal-now`ä¹‹é—´çš„åŒºåˆ«æ¥åæ˜ è¿™ä¸€ç‚¹ã€‚Pythonåšå‡ºäº†ä¸åŒçš„é€‰æ‹©ï¼Œè¿™å¯¼è‡´â€œç›¸ç­‰â€å…·æœ‰å¯èƒ½ä»¤äººæƒŠè®¶çš„å«ä¹‰ã€‚ï¼ˆPythonæ²¡æœ‰`equal-always`çš„æ¦‚å¿µï¼Œåªæœ‰`equal-now`æˆ–`=~`ï¼Œå®ƒå†™æˆ`==`ï¼Œä»¥åŠ`identical`æˆ–`<=>`ï¼Œå®ƒå†™æˆ`is`ã€‚ï¼‰
- en: 12.2.1Â Equality of Data[ğŸ”—](#(part._equality-of-data) "Link to here")
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.1 æ•°æ®çš„ç›¸ç­‰æ€§[ğŸ”—](#(part._equality-of-data) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Now that we have the ability to mutate data, itâ€™s worth asking what it means
    for two pieces of data to be equal. Weâ€™ll motivate this through a concrete example.
    Following the naming convention of [Structure Mutation and the Directory](mutating-structures.html#%28part._structure-mut-dir%29),
    we will write every name only once, using the upper-case name from Python, but
    everything we write will equally be true for Pyret.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†ä¿®æ”¹æ•°æ®çš„èƒ½åŠ›ï¼Œå€¼å¾—æ¢è®¨ä¸¤ä¸ªæ•°æ®ç‰‡æ®µç›¸ç­‰æ„å‘³ç€ä»€ä¹ˆã€‚æˆ‘ä»¬å°†é€šè¿‡ä¸€ä¸ªå…·ä½“çš„ä¾‹å­æ¥é˜è¿°è¿™ä¸€ç‚¹ã€‚éµå¾ª[ç»“æ„ä¿®æ”¹å’Œç›®å½•](mutating-structures.html#%28part._structure-mut-dir%29)çš„å‘½åæƒ¯ä¾‹ï¼Œæˆ‘ä»¬å°†åªå†™æ¯ä¸ªåç§°ä¸€æ¬¡ï¼Œä½¿ç”¨Pythonçš„å¤§å†™åç§°ï¼Œä½†æˆ‘ä»¬æ‰€å†™çš„ä¸€åˆ‡å¯¹PyretåŒæ ·é€‚ç”¨ã€‚
- en: 'First, consider these three statements:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè€ƒè™‘ä»¥ä¸‹ä¸‰ä¸ªè¯­å¥ï¼š
- en: '[PRE63]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Do Now!
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the above `Account`s do you consider â€œequalâ€?
  id: totrans-271
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ è®¤ä¸ºä¸Šè¿°å“ªä¸ª`Account`æ˜¯â€œç›¸ç­‰â€çš„ï¼Ÿ
- en: The third `Account` has a different balance than the first two, so it canâ€™t
    be considered equal to either of the first two. The first two have the same contents,
    so arguably they can be considered equal.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸‰ä¸ª`Account`çš„ä½™é¢ä¸å‰ä¸¤ä¸ªä¸åŒï¼Œå› æ­¤ä¸èƒ½è®¤ä¸ºå®ƒä¸å‰ä¸¤ä¸ªç›¸ç­‰ã€‚å‰ä¸¤ä¸ªå†…å®¹ç›¸åŒï¼Œæ‰€ä»¥å¯ä»¥è¯´å®ƒä»¬å¯ä»¥è¢«è®¤ä¸ºæ˜¯ç›¸ç­‰çš„ã€‚
- en: 'Now, letâ€™s consider the directory and heap that would result from running these
    three statements:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬è€ƒè™‘è¿è¡Œè¿™ä¸‰ä¸ªè¯­å¥åäº§ç”Ÿçš„ç›®å½•å’Œå †ï¼š
- en: Directory
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE64]'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE64]'
- en: â†’Â 1120
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1120
- en: '[PRE65]'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE65]'
- en: â†’Â 1121
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1121
- en: '[PRE66]'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE66]'
- en: â†’Â 1122
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1122
- en: Heap
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1120:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1120:'
- en: '[PRE67]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '1121:'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1121:'
- en: '[PRE68]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '1122:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1122:'
- en: '[PRE69]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'From the perspective of the heap, each account ends up at its own address.
    Those different addresses are a way in which the two values are not the same:
    they have the same contents, but not the same address. Is that relevant? To explore
    this, letâ€™s associate another name (`a4`) with the same address as `a2`, then
    change the balance in `a2`. For now we will show just the Python version:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ä»å †çš„è§’åº¦æ¥çœ‹ï¼Œæ¯ä¸ªè´¦æˆ·æœ€ç»ˆéƒ½ä¼šåˆ°è¾¾è‡ªå·±çš„åœ°å€ã€‚è¿™äº›ä¸åŒçš„åœ°å€æ˜¯ä¸¤ä¸ªå€¼ä¸ç›¸åŒçš„ä¸€ç§æ–¹å¼ï¼šå®ƒä»¬æœ‰ç›¸åŒçš„å†…å®¹ï¼Œä½†æ²¡æœ‰ç›¸åŒçš„åœ°å€ã€‚è¿™æœ‰ä»€ä¹ˆç›¸å…³å—ï¼Ÿä¸ºäº†æ¢ç´¢è¿™ä¸€ç‚¹ï¼Œè®©æˆ‘ä»¬å°†å¦ä¸€ä¸ªåç§°ï¼ˆ`a4`ï¼‰ä¸`a2`ç›¸åŒçš„åœ°å€å…³è”èµ·æ¥ï¼Œç„¶åä¿®æ”¹`a2`ä¸­çš„ä½™é¢ã€‚ç°åœ¨æˆ‘ä»¬åªå±•ç¤ºPythonç‰ˆæœ¬ï¼š
- en: '[PRE70]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'What does memory look like before and after checkpoint 1? Before the checkpoint:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ£€æŸ¥ç‚¹1ä¹‹å‰å’Œä¹‹åçš„è®°å¿†æ˜¯ä»€ä¹ˆæ ·çš„ï¼Ÿåœ¨æ£€æŸ¥ç‚¹ä¹‹å‰ï¼š
- en: Directory
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE71]'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE71]'
- en: â†’Â 1130
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1130
- en: '[PRE72]'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE72]'
- en: â†’Â 1131
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1131
- en: '[PRE73]'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE73]'
- en: â†’Â 1132
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1132
- en: '[PRE74]'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE74]'
- en: â†’Â 1131
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1131
- en: Heap
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1130:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1130:'
- en: '[PRE75]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '1131:'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1131:'
- en: '[PRE76]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '1132:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1132:'
- en: '[PRE77]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`a1` and `a2` refer to two different `Account`s with the same contents. After
    checkpoint 1, those contents are different because we modified the contents of
    the balance field in `a2`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`a1`å’Œ`a2`æŒ‡çš„æ˜¯ä¸¤ä¸ªå†…å®¹ç›¸åŒçš„ä¸åŒ`Account`ã€‚åœ¨æ£€æŸ¥ç‚¹1ä¹‹åï¼Œè¿™äº›å†…å®¹å˜å¾—ä¸åŒï¼Œå› ä¸ºæˆ‘ä»¬ä¿®æ”¹äº†`a2`ä¸­ä½™é¢å­—æ®µçš„å€¼ï¼š'
- en: Directory
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE78]'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE78]'
- en: â†’Â 1130
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1130
- en: '[PRE79]'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE79]'
- en: â†’Â 1131
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1131
- en: '[PRE80]'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE80]'
- en: â†’Â 1132
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1132
- en: '[PRE81]'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE81]'
- en: â†’Â 1131
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1131
- en: Heap
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: '1130:'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1130:'
- en: '[PRE82]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '1131:'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1131:'
- en: '[PRE83]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '1132:'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1132:'
- en: '[PRE84]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In contrast, `a2` and `a4` are aliases for the same `Account`. Therefore, their
    values change in lockstep: asking to display the value of either one would now
    show an account with a balance of `800`.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸æ¯”ä¹‹ä¸‹ï¼Œ`a2`å’Œ`a4`æ˜¯åŒä¸€`Account`çš„åˆ«åã€‚å› æ­¤ï¼Œå®ƒä»¬çš„å€¼ä¼šåŒæ­¥å˜åŒ–ï¼šç°åœ¨è¦æ±‚æ˜¾ç¤ºä»»ä¸€è´¦æˆ·çš„å€¼å°†æ˜¾ç¤ºä¸€ä¸ªä½™é¢ä¸º`800`çš„è´¦æˆ·ã€‚
- en: Do Now!
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think now? Are the first two accounts equal?
  id: totrans-327
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ ç°åœ¨æ€ä¹ˆæƒ³ï¼Ÿå‰ä¸¤ä¸ªè´¦æˆ·ç›¸ç­‰å—ï¼Ÿ
- en: 12.2.2Â Different Equality Operations[ğŸ”—](#(part._equality-operations) "Link to
    here")
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.2 ä¸åŒçš„ç›¸ç­‰æ€§æ“ä½œ[ğŸ”—](#(part._equality-operations) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'This sequence of examples points out that we seem to be raising two possible
    notions of equality:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸€ç³»åˆ—çš„ä¾‹å­æŒ‡å‡ºï¼Œæˆ‘ä»¬ä¼¼ä¹æå‡ºäº†ä¸¤ç§å¯èƒ½çš„ç›¸ç­‰æ€§æ¦‚å¿µï¼š
- en: Whether two values have the same contents. This is formally called structural
    equality; you can think of it as a â€œprint equalityâ€, namely, when displayed, do
    the two values look the same.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä¸¤ä¸ªå€¼æ˜¯å¦å…·æœ‰ç›¸åŒçš„å†…å®¹ã€‚è¿™æ­£å¼ç§°ä¸ºç»“æ„ç­‰ä»·æ€§ï¼›ä½ å¯ä»¥å°†å…¶è§†ä¸ºâ€œæ‰“å°ç­‰ä»·æ€§â€ï¼Œå³å½“æ˜¾ç¤ºæ—¶ï¼Œè¿™ä¸¤ä¸ªå€¼çœ‹èµ·æ¥æ˜¯å¦ç›¸åŒã€‚
- en: Whether two values live at the same address, i.e., there is actually only one
    value in memory. This is formally called reference equality. Usually, we would
    refer to the two values by different names (so there is the possibility that they
    are different), and reference equality checks whether the names are aliases. Observe
    that a given value always prints the same way, so any two names that have reference
    equality also have structural equality, but not vice versa.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä¸¤ä¸ªå€¼æ˜¯å¦ä½äºåŒä¸€åœ°å€ï¼Œå³å†…å­˜ä¸­å®é™…ä¸Šåªæœ‰ä¸€ä¸ªå€¼ã€‚è¿™æ­£å¼ç§°ä¸ºå¼•ç”¨ç­‰ä»·æ€§ã€‚é€šå¸¸ï¼Œæˆ‘ä»¬ä¼šç”¨ä¸åŒçš„åç§°æ¥å¼•ç”¨è¿™ä¸¤ä¸ªå€¼ï¼ˆå› æ­¤å®ƒä»¬å¯èƒ½æ˜¯ä¸åŒçš„ï¼‰ï¼Œå¼•ç”¨ç­‰ä»·æ€§æ£€æŸ¥è¿™äº›åç§°æ˜¯å¦æ˜¯åˆ«åã€‚è§‚å¯Ÿåˆ°ä¸€ä¸ªç»™å®šçš„å€¼æ€»æ˜¯ä»¥ç›¸åŒçš„æ–¹å¼æ‰“å°ï¼Œæ‰€ä»¥ä»»ä½•å…·æœ‰å¼•ç”¨ç­‰ä»·æ€§çš„ä¸¤ä¸ªåç§°ä¹Ÿå…·æœ‰ç»“æ„ç­‰ä»·æ€§ï¼Œä½†åä¹‹åˆ™ä¸ç„¶ã€‚
- en: Which notion of equality is â€œcorrectâ€? It turns out that they are valuable in
    different contexts. For this reason, programming languages generally provide multiple
    equality operations, letting the programmer indicate which kind of equality they
    mean in their context.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: å“ªç§ç­‰ä»·æ€§çš„æ¦‚å¿µæ˜¯â€œæ­£ç¡®çš„â€ï¼Ÿå®é™…ä¸Šï¼Œå®ƒä»¬åœ¨ä¸åŒçš„ä¸Šä¸‹æ–‡ä¸­éƒ½å¾ˆæœ‰ä»·å€¼ã€‚å› æ­¤ï¼Œç¼–ç¨‹è¯­è¨€é€šå¸¸æä¾›å¤šä¸ªç­‰ä»·æ€§æ“ä½œï¼Œè®©ç¨‹åºå‘˜èƒ½å¤Ÿè¡¨æ˜ä»–ä»¬åœ¨ä¸Šä¸‹æ–‡ä¸­æŒ‡çš„æ˜¯å“ªç§ç­‰ä»·æ€§ã€‚
- en: Unfortunately, the names of equality operations, and their exact meaning, vary
    across languages. Therefore, we will examine each of Pyret and Python separately.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œç­‰ä»·æ€§æ“ä½œçš„åç§°åŠå…¶ç¡®åˆ‡å«ä¹‰åœ¨ä¸åŒçš„è¯­è¨€ä¸­å„ä¸ç›¸åŒã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†åˆ†åˆ«æ£€æŸ¥Pyretå’ŒPythonã€‚
- en: 12.2.2.1Â Equality in Python[ğŸ”—](#(part._.Equality_in_.Python) "Link to here")
  id: totrans-334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 12.2.2.1Â Pythonä¸­çš„ç­‰ä»·æ€§[ğŸ”—](#(part._.Equality_in_.Python) "é“¾æ¥è‡³æ­¤")
- en: 'The `==` operator that you learned in Pyret and we carried into Python checks
    for structural equality, independent of addresses:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ åœ¨Pyretå’ŒPythonä¸­å­¦åˆ°çš„`==`è¿ç®—ç¬¦æ£€æŸ¥ç»“æ„ç­‰ä»·æ€§ï¼Œä¸åœ°å€æ— å…³ï¼š
- en: '|'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE85]'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '&#124;'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE86]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '|'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE87]'
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '&#124;'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE88]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '|'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'However, note that this will no longer be true at checkpoint 2:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œåœ¨æ£€æŸ¥ç‚¹2æ—¶è¿™å°†ä¸å†æˆç«‹ï¼š
- en: '|'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE89]'
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '&#124;'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE90]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '|'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE91]'
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '&#124;'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE92]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '|'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'If we instead want to check for aliasing, we instead use an operation called
    `is` (not to be confused with Pyretâ€™s `is`, which is used for writing tests):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³æ£€æŸ¥åˆ«åï¼Œæˆ‘ä»¬åˆ™ä½¿ç”¨ä¸€ä¸ªç§°ä¸º`is`çš„æ“ä½œï¼ˆä¸è¦ä¸Pyretçš„`is`æ··æ·†ï¼Œå®ƒç”¨äºç¼–å†™æµ‹è¯•ï¼‰ï¼š
- en: '|'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE93]'
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '&#124;'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE94]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '|'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE95]'
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '&#124;'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE96]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '|'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: This explains why `a2 == a4` was true both before and after the mutation, but
    `a1 == a2` was no longer true after it. The latter seems to violate a very basic
    meaning of â€œequalityâ€; the problem here is caused by the introduction of mutation.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è§£é‡Šäº†ä¸ºä»€ä¹ˆåœ¨å˜å¼‚å‰å`a2 == a4`éƒ½æ˜¯çœŸçš„ï¼Œä½†å˜å¼‚å`a1 == a2`ä¸å†æˆç«‹ã€‚åè€…ä¼¼ä¹è¿åäº†â€œç­‰ä»·æ€§â€çš„éå¸¸åŸºæœ¬çš„æ„ä¹‰ï¼›è¿™é‡Œçš„é—®é¢˜æ˜¯å¼•å…¥å˜å¼‚æ‰€å¯¼è‡´çš„ã€‚
- en: As we go forward, youâ€™ll get more practice with when to use each kind of equality.
    The `==` operator is more accepting, so it is usually the right default. If you
    actually need to know whether two expressions evaluate to the same address, you
    should instead use `is`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: éšç€æˆ‘ä»¬ç»§ç»­å‰è¿›ï¼Œä½ å°†è·å¾—æ›´å¤šç»ƒä¹ ä½•æ—¶ä½¿ç”¨æ¯ç§ç­‰ä»·æ€§çš„ç»éªŒã€‚`==`è¿ç®—ç¬¦æ›´å®½å®¹ï¼Œå› æ­¤é€šå¸¸æ˜¯æ­£ç¡®çš„é»˜è®¤é€‰é¡¹ã€‚å¦‚æœä½ å®é™…ä¸Šéœ€è¦çŸ¥é“ä¸¤ä¸ªè¡¨è¾¾å¼æ˜¯å¦è¯„ä¼°ä¸ºç›¸åŒçš„åœ°å€ï¼Œä½ åº”è¯¥ä½¿ç”¨`is`ã€‚
- en: 12.2.2.2Â Equality in Pyret[ğŸ”—](#(part._.Equality_in_.Pyret) "Link to here")
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 12.2.2.2Â Pyretä¸­çš„ç­‰ä»·æ€§[ğŸ”—](#(part._.Equality_in_.Pyret) "é“¾æ¥è‡³æ­¤")
- en: Equality in Pyret is somewhat more detailed, because the language wants you
    to think harder about what is happening in your programs.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretä¸­çš„ç­‰ä»·æ€§ç›¸å¯¹æ›´è¯¦ç»†ï¼Œå› ä¸ºè¯¥è¯­è¨€å¸Œæœ›ä½ åœ¨ç¨‹åºä¸­æ›´æ·±å…¥åœ°æ€è€ƒæ­£åœ¨å‘ç”Ÿçš„äº‹æƒ…ã€‚
- en: 'Recall that we are using the datatype in [Example: Bank Accounts](mutating-structures.html#%28part._eg-bank-acc%29)
    and have written the following definitions:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹ï¼Œæˆ‘ä»¬åœ¨[ç¤ºä¾‹ï¼šé“¶è¡Œè´¦æˆ·](mutating-structures.html#%28part._eg-bank-acc%29)ä¸­ä½¿ç”¨æ•°æ®ç±»å‹ï¼Œå¹¶ç¼–å†™äº†ä»¥ä¸‹å®šä¹‰ï¼š
- en: '[PRE97]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In Python, we saw that `a1 == a2` before the mutation. However, in Pyret, this
    produces `false`! Why?
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pythonä¸­ï¼Œæˆ‘ä»¬åœ¨å˜å¼‚å‰çœ‹åˆ°äº†`a1 == a2`ã€‚ç„¶è€Œï¼Œåœ¨Pyretä¸­ï¼Œè¿™ä¼šäº§ç”Ÿ`false`ï¼ä¸ºä»€ä¹ˆï¼Ÿ
- en: 'The reason is because structural equality is actually complicated; there are
    two different questions we could be asking:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: åŸå› åœ¨äºç»“æ„ç­‰ä»·æ€§å®é™…ä¸Šå¾ˆå¤æ‚ï¼›æˆ‘ä»¬å¯èƒ½æå‡ºä¸¤ä¸ªä¸åŒçš„é—®é¢˜ï¼š
- en: Are these two values structurally equal right now?
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªå€¼ç°åœ¨åœ¨ç»“æ„ä¸Šç­‰ä»·å—ï¼Ÿ
- en: Will these two values be structurally equal always?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªå€¼æ˜¯å¦å§‹ç»ˆåœ¨ç»“æ„ä¸Šç­‰ä»·ï¼Ÿ
- en: Pyret makes a distinction between these two.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretåœ¨è¿™ä¸¤ç‚¹ä¸Šåšå‡ºäº†åŒºåˆ†ã€‚
- en: 'By default, Pyret tends towards safer programming practices. Therefore, the
    standard (structural) equality predicate, `==`, will only return `true` if the
    two values will always be equal. Thus:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: é»˜è®¤æƒ…å†µä¸‹ï¼ŒPyretå€¾å‘äºæ›´å®‰å…¨çš„ç¼–ç¨‹å®è·µã€‚å› æ­¤ï¼Œæ ‡å‡†çš„ï¼ˆç»“æ„ï¼‰ç­‰ä»·è°“è¯`==`åªæœ‰åœ¨ä¸¤ä¸ªå€¼å°†å§‹ç»ˆç›¸ç­‰çš„æƒ…å†µä¸‹æ‰ä¼šè¿”å›`true`ã€‚å› æ­¤ï¼š
- en: '|'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE98]'
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '&#124;'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE99]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '|'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Because the two values are actually aliases, no matter how one changes, the
    â€œotherâ€ will always change in the same way. Therefore, they will always â€œprint
    the sameâ€. We can confirm that they are aliases by using Pyretâ€™s reference equality
    operator, `<=>`:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºè¿™ä¸¤ä¸ªå€¼å®é™…ä¸Šæ˜¯åˆ«åï¼Œæ— è®ºå…¶ä¸­ä¸€ä¸ªå¦‚ä½•å˜åŒ–ï¼Œå¦ä¸€ä¸ªä¹Ÿä¼šä»¥ç›¸åŒçš„æ–¹å¼å˜åŒ–ã€‚å› æ­¤ï¼Œå®ƒä»¬å°†å§‹ç»ˆâ€œæ‰“å°å‡ºç›¸åŒçš„å€¼â€ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨Pyretçš„å¼•ç”¨ç­‰ä»·è¿ç®—ç¬¦`<=>`æ¥ç¡®è®¤å®ƒä»¬æ˜¯åˆ«åï¼š
- en: '|'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE100]'
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '&#124;'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE101]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '|'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE102]'
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '&#124;'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE103]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '|'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: In contrast, that guarantee does not apply to `a1` and `a2`; and indeed, at
    checkpoint 2, we see that they are no longer equal. Hence
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸æ¯”ä¹‹ä¸‹ï¼Œè¿™ä¸ªä¿è¯å¹¶ä¸é€‚ç”¨äº`a1`å’Œ`a2`ï¼›å®é™…ä¸Šï¼Œåœ¨æ£€æŸ¥ç‚¹2æ—¶ï¼Œæˆ‘ä»¬çœ‹åˆ°å®ƒä»¬ä¸å†ç›¸ç­‰ã€‚å› æ­¤
- en: '|'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE104]'
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '&#124;'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE105]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '|'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'However, there is a time when `a1` and `a2` do print the same, namely before
    checkpoint 1\. Therefore, Pyret provides another equality operator that checks
    whether values are equal at the moment, `=~`. If we ask this before checkpoint
    1, we get:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œå­˜åœ¨ä¸€ä¸ªæ—¶åˆ»`a1`å’Œ`a2`ç¡®å®ä¼šæ‰“å°å‡ºç›¸åŒçš„å€¼ï¼Œé‚£å°±æ˜¯åœ¨æ£€æŸ¥ç‚¹1ä¹‹å‰ã€‚å› æ­¤ï¼ŒPyretæä¾›äº†ä¸€ä¸ªé¢å¤–çš„ç­‰ä»·è¿ç®—ç¬¦ï¼Œç”¨äºæ£€æŸ¥å€¼åœ¨å½“å‰æ—¶åˆ»æ˜¯å¦ç›¸ç­‰ï¼Œå³`=~`ã€‚å¦‚æœæˆ‘ä»¬åœ¨è¿™ä¸ªæ£€æŸ¥ç‚¹ä¹‹å‰è¿›è¡Œè¯¢é—®ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ï¼š
- en: '|'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE106]'
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '&#124;'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE107]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '|'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'But if we ask the same question at checkpoint 2, we get:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†å¦‚æœæˆ‘ä»¬åœ¨è¿™ä¸ªæ£€æŸ¥ç‚¹2æ—¶æå‡ºç›¸åŒçš„é—®é¢˜ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ï¼š
- en: '|'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE108]'
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '&#124;'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE109]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '|'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'These operators and their funny symbols may be hard to remember, but Pyret
    also gives them useful (if longer) names, and they can be used as ordinary functions:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›è¿ç®—ç¬¦åŠå…¶æœ‰è¶£çš„ç¬¦å·å¯èƒ½éš¾ä»¥è®°ä½ï¼Œä½†Pyretä¹Ÿç»™äº†å®ƒä»¬æœ‰ç”¨çš„ï¼ˆå¦‚æœæ›´é•¿ï¼‰åç§°ï¼Œå¹¶ä¸”å®ƒä»¬å¯ä»¥ç”¨ä½œæ™®é€šå‡½æ•°ï¼š
- en: '| Symbol |  | Function |  | Type |  | Meaning |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| ç¬¦å· |  | å‡½æ•° |  | ç±»å‹ |  | å«ä¹‰ |'
- en: '| `==` |  | `equal-always` |  | Structural |  | If it returns `true`, they
    will always be equal, irrespective of any future mutations. |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| `==` |  | `equal-always` |  | ç»“æ„ |  | å¦‚æœå®ƒè¿”å›`true`ï¼Œå®ƒä»¬å°†å§‹ç»ˆç›¸ç­‰ï¼Œæ— è®ºæœªæ¥çš„å˜å¼‚å¦‚ä½•ã€‚|'
- en: '| `=~` |  | `equal-now` |  | Structural |  | If it returns `true` they are
    currently equal, but that may change after future mutations. |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| `=~` |  | `equal-now` |  | ç»“æ„ |  | å¦‚æœå®ƒè¿”å›`true`ï¼Œå®ƒä»¬ç›®å‰æ˜¯ç›¸ç­‰çš„ï¼Œä½†ä¹‹åå¯èƒ½ä¼šå› ä¸ºæœªæ¥çš„å˜å¼‚è€Œæ”¹å˜ã€‚|'
- en: '| `<=>` |  | `identical` |  | Reference |  | Returns `true` if the two arguments
    are aliases, `false` otherwise. |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| `<=>` |  | `identical` |  | å¼•ç”¨ |  | å¦‚æœä¸¤ä¸ªå‚æ•°æ˜¯åˆ«åï¼Œåˆ™è¿”å›`true`ï¼Œå¦åˆ™è¿”å›`false`ã€‚|'
- en: 'Thus, before checkpoint 1:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œåœ¨æ£€æŸ¥ç‚¹1ä¹‹å‰ï¼š
- en: '|'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE110]'
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '&#124;'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE111]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '|'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE112]'
  id: totrans-466
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '&#124;'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE113]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '|'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE114]'
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '&#124;'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE115]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '|'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE116]'
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '&#124;'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE117]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '|'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE118]'
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '&#124;'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE119]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '|'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE120]'
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '&#124;'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE121]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '|'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'After checkpoint 2, we no longer need to check any of the `equal-always` or
    `identical` relationships again, because by definition they cannot change. But
    we should check `equal-now` again. Sure enough:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ£€æŸ¥ç‚¹2ä¹‹åï¼Œæˆ‘ä»¬ä¸å†éœ€è¦å†æ¬¡æ£€æŸ¥ä»»ä½•`equal-always`æˆ–`identical`å…³ç³»ï¼Œå› ä¸ºæ ¹æ®å®šä¹‰ï¼Œå®ƒä»¬ä¸èƒ½æ”¹å˜ã€‚ä½†æˆ‘ä»¬åº”è¯¥å†æ¬¡æ£€æŸ¥`equal-now`ã€‚æœç„¶ï¼š
- en: '|'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE122]'
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '&#124;'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE123]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '|'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE124]'
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '&#124;'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE125]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '|'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Therefore, in Pyret, the `==` operator is the same as `equal-always`. When data
    contain mutable fields, this will always produce `false`, because even if the
    values are structurally equal now, itâ€™s possible that a future mutation will change
    that. This is to remind you to be careful in the presence of mutation. In situations
    where we really care only about equality at that instant, we can use `=~`, i.e.,
    `equal-now`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œåœ¨Pyretä¸­ï¼Œ`==`è¿ç®—ç¬¦ä¸`equal-always`ç›¸åŒã€‚å½“æ•°æ®åŒ…å«å¯å˜å­—æ®µæ—¶ï¼Œè¿™æ€»æ˜¯ä¼šç”Ÿæˆ`false`ï¼Œå› ä¸ºå³ä½¿å€¼ç°åœ¨åœ¨ç»“æ„ä¸Šç›¸ç­‰ï¼Œæœªæ¥çš„å˜å¼‚ä¹Ÿå¯èƒ½æ”¹å˜è¿™ä¸€ç‚¹ã€‚è¿™æ˜¯æé†’ä½ åœ¨å­˜åœ¨å˜å¼‚çš„æƒ…å†µä¸‹è¦å°å¿ƒã€‚åœ¨çœŸæ­£åªå…³å¿ƒé‚£ä¸€åˆ»çš„ç­‰ä»·æ€§çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨`=~`ï¼Œå³`equal-now`ã€‚
- en: The examples above might suggest that only aliased values are `equal-always`.
    This is not true! If our data are immutable (which is the default in the language),
    then if two values are structurally equal now, they must remain structurally equal
    forever. For such data, `equal-always` will return `true` even when they are not
    aliases. This is a reminder that we get stronger guarantees about immutable data.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°ç¤ºä¾‹å¯èƒ½ä¼šè®©äººè¯¯ä»¥ä¸ºåªæœ‰åˆ«åå€¼æ‰æ˜¯`equal-always`ã€‚è¿™å¹¶ä¸æ­£ç¡®ï¼å¦‚æœæˆ‘ä»¬çš„æ•°æ®æ˜¯ä¸å¯å˜çš„ï¼ˆåœ¨è¯­è¨€ä¸­è¿™æ˜¯é»˜è®¤è®¾ç½®ï¼‰ï¼Œé‚£ä¹ˆå¦‚æœä¸¤ä¸ªå€¼ç°åœ¨åœ¨ç»“æ„ä¸Šç›¸ç­‰ï¼Œå®ƒä»¬å¿…é¡»æ°¸è¿œåœ¨ç»“æ„ä¸Šç›¸ç­‰ã€‚å¯¹äºæ­¤ç±»æ•°æ®ï¼Œå³ä½¿å®ƒä»¬ä¸æ˜¯åˆ«åï¼Œ`equal-always`ä¹Ÿä¼šè¿”å›`true`ã€‚è¿™æ˜¯æé†’æˆ‘ä»¬å…³äºä¸å¯å˜æ•°æ®å¯ä»¥å¾—åˆ°æ›´å¼ºçš„ä¿è¯ã€‚
- en: It is worth noting that upto this point we have used `equal-always`â€”<wbr>in
    the form of both `==` and Pyretâ€™s `is` in testingâ€”<wbr>without really bothering
    to understand very much about how it works, and yet have always gotten predictable
    answers. This suggests that there is something natural about working with immutable
    data. In contrast, with mutable data, something has to give. Pyret made a conscious
    design choice to reflect this in the distinction between `equal-always` and `equal-now`.
    Python made a different choice, which results in â€œequalityâ€ having a perhaps surprising
    meaning. (Python has no notion of `equal-always`, only `equal-now` or `=~`, which
    is written as `==`, and `identical` or `<=>`, which is written as `is`.)
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¸€ç›´åœ¨ä½¿ç”¨ `equal-always`â€”â€”ä»¥ `==` å’Œ Pyret çš„ `is`ï¼ˆåœ¨æµ‹è¯•ä¸­ä½¿ç”¨ï¼‰çš„å½¢å¼â€”â€”è€Œæ²¡æœ‰çœŸæ­£å»ç†è§£å®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œä½†æˆ‘ä»¬æ€»æ˜¯å¾—åˆ°äº†å¯é¢„æµ‹çš„ç­”æ¡ˆã€‚è¿™è¡¨æ˜ä¸ä¸å¯å˜æ•°æ®ä¸€èµ·å·¥ä½œæœ‰ä¸€äº›è‡ªç„¶ä¹‹å¤„ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œä¸å¯å˜æ•°æ®ä¸€èµ·ï¼Œå¿…é¡»åšå‡ºä¸€äº›å¦¥åã€‚Pyret
    æœ‰æ„è¯†åœ°åšå‡ºäº†è®¾è®¡é€‰æ‹©ï¼Œåœ¨ `equal-always` å’Œ `equal-now` ä¹‹é—´åšå‡ºåŒºåˆ†ã€‚Python åšäº†ä¸åŒçš„é€‰æ‹©ï¼Œè¿™å¯¼è‡´â€œç­‰ä»·æ€§â€å…·æœ‰å¯èƒ½ä»¤äººæƒŠè®¶çš„å«ä¹‰ã€‚ï¼ˆPython
    æ²¡æœ‰å…³äº `equal-always` çš„æ¦‚å¿µï¼Œåªæœ‰ `equal-now` æˆ– `=~`ï¼ˆå†™ä½œ `==`ï¼‰å’Œ `identical` æˆ– `<=>`ï¼ˆå†™ä½œ
    `is`ï¼‰ã€‚ï¼‰
- en: 12.2.2.1Â Equality in Python[ğŸ”—](#(part._.Equality_in_.Python) "Link to here")
  id: totrans-524
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 12.2.2.1 Python ä¸­çš„ç­‰ä»·æ€§[ğŸ”—](#(part._.Equality_in_.Python) "é“¾æ¥è‡³æ­¤")
- en: 'The `==` operator that you learned in Pyret and we carried into Python checks
    for structural equality, independent of addresses:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ åœ¨ Pyret ä¸­å­¦åˆ°çš„ `==` æ“ä½œç¬¦ä»¥åŠæˆ‘ä»¬å¸¦å…¥ Python çš„æ“ä½œç¬¦æ£€æŸ¥ç»“æ„ç­‰ä»·æ€§ï¼Œè€Œä¸è€ƒè™‘åœ°å€ï¼š
- en: '|'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE126]'
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '&#124;'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE127]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '|'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE128]'
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '&#124;'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE129]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '|'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'However, note that this will no longer be true at checkpoint 2:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œè¿™å°†åœ¨æ£€æŸ¥ç‚¹ 2 æ—¶ä¸å†æˆç«‹ï¼š
- en: '|'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE130]'
  id: totrans-545
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '&#124;'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE131]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '|'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE132]'
  id: totrans-553
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '&#124;'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE133]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '|'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'If we instead want to check for aliasing, we instead use an operation called
    `is` (not to be confused with Pyretâ€™s `is`, which is used for writing tests):'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³è¦æ£€æŸ¥åˆ«åï¼ˆaliasingï¼‰ï¼Œåˆ™å¯ä»¥ä½¿ç”¨ä¸€ä¸ªåä¸º `is` çš„æ“ä½œï¼ˆä¸è¦ä¸ Pyret çš„ `is` æ··æ·†ï¼Œåè€…ç”¨äºç¼–å†™æµ‹è¯•ï¼‰ï¼š
- en: '|'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE134]'
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '&#124;'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE135]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '|'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE136]'
  id: totrans-570
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '&#124;'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE137]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '|'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: This explains why `a2 == a4` was true both before and after the mutation, but
    `a1 == a2` was no longer true after it. The latter seems to violate a very basic
    meaning of â€œequalityâ€; the problem here is caused by the introduction of mutation.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è§£é‡Šäº†ä¸ºä»€ä¹ˆåœ¨å˜å¼‚å‰å `a2 == a4` éƒ½æ˜¯æ­£ç¡®çš„ï¼Œä½† `a1 == a2` åœ¨å˜å¼‚åä¸å†æ­£ç¡®ã€‚åè€…ä¼¼ä¹è¿åäº†â€œç­‰ä»·æ€§â€çš„åŸºæœ¬å«ä¹‰ï¼›è¿™é‡Œçš„é—®é¢˜æ˜¯ç”±å˜å¼‚çš„å¼•å…¥é€ æˆçš„ã€‚
- en: As we go forward, youâ€™ll get more practice with when to use each kind of equality.
    The `==` operator is more accepting, so it is usually the right default. If you
    actually need to know whether two expressions evaluate to the same address, you
    should instead use `is`.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: éšç€æˆ‘ä»¬ç»§ç»­å‰è¿›ï¼Œä½ å°†æ›´å¤šåœ°ç»ƒä¹ ä½•æ—¶ä½¿ç”¨æ¯ç§ç±»å‹çš„ç­‰ä»·æ€§ã€‚`==` æ“ä½œç¬¦æ›´å®½å®¹ï¼Œå› æ­¤é€šå¸¸æ˜¯æ­£ç¡®çš„é»˜è®¤é€‰é¡¹ã€‚å¦‚æœä½ å®é™…ä¸Šéœ€è¦çŸ¥é“ä¸¤ä¸ªè¡¨è¾¾å¼æ˜¯å¦è¯„ä¼°ä¸ºç›¸åŒçš„åœ°å€ï¼Œä½ åº”è¯¥ä½¿ç”¨
    `is`ã€‚
- en: 12.2.2.2Â Equality in Pyret[ğŸ”—](#(part._.Equality_in_.Pyret) "Link to here")
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 12.2.2.2 Pyret ä¸­çš„ç­‰ä»·æ€§[ğŸ”—](#(part._.Equality_in_.Pyret) "é“¾æ¥è‡³æ­¤")
- en: Equality in Pyret is somewhat more detailed, because the language wants you
    to think harder about what is happening in your programs.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret ä¸­çš„ç­‰ä»·æ€§ï¼ˆEqualityï¼‰ç›¸å¯¹æ›´è¯¦ç»†ï¼Œå› ä¸ºè¿™ç§è¯­è¨€å¸Œæœ›ä½ åœ¨ç¨‹åºä¸­æ›´æ·±å…¥åœ°æ€è€ƒæ­£åœ¨å‘ç”Ÿçš„äº‹æƒ…ã€‚
- en: 'Recall that we are using the datatype in [Example: Bank Accounts](mutating-structures.html#%28part._eg-bank-acc%29)
    and have written the following definitions:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹ï¼Œæˆ‘ä»¬æ­£åœ¨ä½¿ç”¨ [ç¤ºä¾‹ï¼šé“¶è¡Œè´¦æˆ·](mutating-structures.html#%28part._eg-bank-acc%29) ä¸­çš„æ•°æ®ç±»å‹ï¼Œå¹¶ç¼–å†™äº†ä»¥ä¸‹å®šä¹‰ï¼š
- en: '[PRE138]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: In Python, we saw that `a1 == a2` before the mutation. However, in Pyret, this
    produces `false`! Why?
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Python ä¸­ï¼Œæˆ‘ä»¬åœ¨å˜å¼‚ä¹‹å‰çœ‹åˆ°äº† `a1 == a2`ã€‚ç„¶è€Œï¼Œåœ¨ Pyret ä¸­ï¼Œè¿™ä¼šäº§ç”Ÿ `false`ï¼ä¸ºä»€ä¹ˆï¼Ÿ
- en: 'The reason is because structural equality is actually complicated; there are
    two different questions we could be asking:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: åŸå› åœ¨äºç»“æ„ç­‰ä»·æ€§å®é™…ä¸Šå¾ˆå¤æ‚ï¼›æˆ‘ä»¬å¯èƒ½æå‡ºäº†ä¸¤ä¸ªä¸åŒçš„é—®é¢˜ï¼š
- en: Are these two values structurally equal right now?
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¿™äº›ä¸¤ä¸ªå€¼åœ¨å½“å‰æ˜¯å¦åœ¨ç»“æ„ä¸Šç›¸ç­‰ï¼Ÿ
- en: Will these two values be structurally equal always?
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªå€¼åœ¨ç»“æ„ä¸Šæ˜¯å¦æ€»æ˜¯ç›¸ç­‰ï¼Ÿ
- en: Pyret makes a distinction between these two.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret åœ¨è¿™ä¸¤ä¸ªæ–¹é¢åšå‡ºäº†åŒºåˆ†ã€‚
- en: 'By default, Pyret tends towards safer programming practices. Therefore, the
    standard (structural) equality predicate, `==`, will only return `true` if the
    two values will always be equal. Thus:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: é»˜è®¤æƒ…å†µä¸‹ï¼ŒPyret å€¾å‘äºæ›´å®‰å…¨çš„ç¼–ç¨‹å®è·µã€‚å› æ­¤ï¼Œæ ‡å‡†çš„ï¼ˆç»“æ„æ€§çš„ï¼‰ç­‰ä»·æ€§è°“è¯ `==` åªæœ‰åœ¨ä¸¤ä¸ªå€¼å§‹ç»ˆç›¸ç­‰æ—¶æ‰ä¼šè¿”å› `true`ã€‚å› æ­¤ï¼š
- en: '|'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE139]'
  id: totrans-590
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '&#124;'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE140]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '|'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Because the two values are actually aliases, no matter how one changes, the
    â€œotherâ€ will always change in the same way. Therefore, they will always â€œprint
    the sameâ€. We can confirm that they are aliases by using Pyretâ€™s reference equality
    operator, `<=>`:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºè¿™ä¸¤ä¸ªå€¼å®é™…ä¸Šæ˜¯åˆ«åï¼Œæ— è®ºæ€æ ·å˜åŒ–ï¼Œå¦ä¸€ä¸ªå€¼æ€»ä¼šä»¥ç›¸åŒçš„æ–¹å¼å˜åŒ–ã€‚å› æ­¤ï¼Œå®ƒä»¬å°†å§‹ç»ˆâ€œæ‰“å°å‡ºç›¸åŒçš„â€ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨ Pyret çš„å¼•ç”¨ç›¸ç­‰æ“ä½œç¬¦
    `<=>` æ¥ç¡®è®¤å®ƒä»¬æ˜¯åˆ«åï¼š
- en: '|'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE141]'
  id: totrans-599
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '&#124;'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE142]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '|'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE143]'
  id: totrans-607
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '&#124;'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE144]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '|'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: In contrast, that guarantee does not apply to `a1` and `a2`; and indeed, at
    checkpoint 2, we see that they are no longer equal. Hence
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸æ­¤ç›¸åï¼Œè¿™ä¸ªä¿è¯ä¸é€‚ç”¨äº `a1` å’Œ `a2`ï¼›å®é™…ä¸Šï¼Œåœ¨æ£€æŸ¥ç‚¹ 2 æ—¶ï¼Œæˆ‘ä»¬çœ‹åˆ°å®ƒä»¬ä¸å†ç›¸ç­‰ã€‚å› æ­¤
- en: '|'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE145]'
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '&#124;'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE146]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '|'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'However, there is a time when `a1` and `a2` do print the same, namely before
    checkpoint 1\. Therefore, Pyret provides another equality operator that checks
    whether values are equal at the moment, `=~`. If we ask this before checkpoint
    1, we get:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œå½“ `a1` å’Œ `a2` æ‰“å°å‡ºç›¸åŒçš„å†…å®¹æ—¶ï¼Œæœ‰ä¸€ä¸ªæ—¶åˆ»ï¼Œå³åœ¨æ£€æŸ¥ç‚¹ 1 ä¹‹å‰ã€‚å› æ­¤ï¼ŒPyret æä¾›äº†å¦ä¸€ä¸ªç›¸ç­‰æ“ä½œç¬¦ï¼Œç”¨äºæ£€æŸ¥å€¼åœ¨é‚£ä¸€åˆ»æ˜¯å¦ç›¸ç­‰ï¼Œå³
    `=~`ã€‚å¦‚æœæˆ‘ä»¬åœ¨æ­¤ä¹‹å‰æå‡ºè¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ï¼š
- en: '|'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE147]'
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '&#124;'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE148]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '|'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'But if we ask the same question at checkpoint 2, we get:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†å¦‚æœæˆ‘ä»¬æ£€æŸ¥ç‚¹ 2 æ—¶æå‡ºç›¸åŒçš„é—®é¢˜ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ï¼š
- en: '|'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE149]'
  id: totrans-634
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '&#124;'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE150]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '|'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'These operators and their funny symbols may be hard to remember, but Pyret
    also gives them useful (if longer) names, and they can be used as ordinary functions:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ“ä½œç¬¦åŠå…¶æœ‰è¶£çš„ç¬¦å·å¯èƒ½éš¾ä»¥è®°ä½ï¼Œä½† Pyret ä¹Ÿæä¾›äº†å®ƒä»¬æœ‰ç”¨çš„ï¼ˆå¦‚æœæ›´é•¿ï¼‰åç§°ï¼Œå¹¶ä¸”å®ƒä»¬å¯ä»¥ç”¨ä½œæ™®é€šå‡½æ•°ï¼š
- en: '| Symbol |  | Function |  | Type |  | Meaning |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
  zh: '| ç¬¦å· |  | å‡½æ•° |  | ç±»å‹ |  | å«ä¹‰ |'
- en: '| `==` |  | `equal-always` |  | Structural |  | If it returns `true`, they
    will always be equal, irrespective of any future mutations. |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
  zh: '| `==` |  | `equal-always` |  | ç»“æ„æ€§ |  | å¦‚æœè¿”å› `true`ï¼Œå®ƒä»¬å°†å§‹ç»ˆç›¸ç­‰ï¼Œæ— è®ºæœªæ¥çš„ä»»ä½•å˜å¼‚ã€‚ |'
- en: '| `=~` |  | `equal-now` |  | Structural |  | If it returns `true` they are
    currently equal, but that may change after future mutations. |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '| `=~` |  | `equal-now` |  | ç»“æ„æ€§ |  | å¦‚æœè¿”å› `true`ï¼Œå®ƒä»¬ç›®å‰ç›¸ç­‰ï¼Œä½†æœªæ¥çš„å˜å¼‚å¯èƒ½ä¼šæ”¹å˜è¿™ä¸€ç‚¹ã€‚ |'
- en: '| `<=>` |  | `identical` |  | Reference |  | Returns `true` if the two arguments
    are aliases, `false` otherwise. |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| `<=>` |  | `identical` |  | å¼•ç”¨ |  | å¦‚æœä¸¤ä¸ªå‚æ•°æ˜¯åˆ«åï¼Œåˆ™è¿”å› `true`ï¼Œå¦åˆ™è¿”å› `false`ã€‚ |'
- en: 'Thus, before checkpoint 1:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œåœ¨æ£€æŸ¥ç‚¹ 1 ä¹‹å‰ï¼š
- en: '|'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE151]'
  id: totrans-648
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '&#124;'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE152]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '|'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE153]'
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '&#124;'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE154]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '|'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE155]'
  id: totrans-664
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '&#124;'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE156]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '|'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE157]'
  id: totrans-672
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '&#124;'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE158]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '|'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE159]'
  id: totrans-680
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '&#124;'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE160]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '|'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE161]'
  id: totrans-688
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '&#124;'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE162]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '|'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'After checkpoint 2, we no longer need to check any of the `equal-always` or
    `identical` relationships again, because by definition they cannot change. But
    we should check `equal-now` again. Sure enough:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ£€æŸ¥ç‚¹ 2 ä¹‹åï¼Œæˆ‘ä»¬ä¸å†éœ€è¦å†æ¬¡æ£€æŸ¥ä»»ä½• `equal-always` æˆ– `identical` å…³ç³»ï¼Œå› ä¸ºæ ¹æ®å®šä¹‰ï¼Œå®ƒä»¬ä¸èƒ½æ”¹å˜ã€‚ä½†æˆ‘ä»¬åº”è¯¥å†æ¬¡æ£€æŸ¥
    `equal-now`ã€‚æœç„¶ï¼š
- en: '|'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE163]'
  id: totrans-697
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '&#124;'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE164]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '|'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '[PRE165]'
  id: totrans-705
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '&#124;'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124;'
- en: '|'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE166]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '|'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Therefore, in Pyret, the `==` operator is the same as `equal-always`. When data
    contain mutable fields, this will always produce `false`, because even if the
    values are structurally equal now, itâ€™s possible that a future mutation will change
    that. This is to remind you to be careful in the presence of mutation. In situations
    where we really care only about equality at that instant, we can use `=~`, i.e.,
    `equal-now`.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œåœ¨ Pyret ä¸­ï¼Œ`==` æ“ä½œç¬¦ä¸ `equal-always` ç›¸åŒã€‚å½“æ•°æ®åŒ…å«å¯å˜å­—æ®µæ—¶ï¼Œè¿™æ€»ä¼šäº§ç”Ÿ `false`ï¼Œå› ä¸ºå³ä½¿ç°åœ¨åœ¨ç»“æ„ä¸Šç›¸ç­‰ï¼Œæœªæ¥çš„å˜å¼‚ä¹Ÿå¯èƒ½æ”¹å˜è¿™ä¸€ç‚¹ã€‚è¿™æ˜¯ä¸ºäº†æé†’ä½ åœ¨å­˜åœ¨å˜å¼‚çš„æƒ…å†µä¸‹è¦å°å¿ƒã€‚åœ¨çœŸæ­£åªå…³å¿ƒé‚£ä¸€åˆ»ç›¸ç­‰æ€§çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨
    `=~`ï¼Œå³ `equal-now`ã€‚
- en: The examples above might suggest that only aliased values are `equal-always`.
    This is not true! If our data are immutable (which is the default in the language),
    then if two values are structurally equal now, they must remain structurally equal
    forever. For such data, `equal-always` will return `true` even when they are not
    aliases. This is a reminder that we get stronger guarantees about immutable data.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°ç¤ºä¾‹å¯èƒ½è¡¨æ˜åªæœ‰åˆ«åå€¼æ˜¯ `equal-always`ã€‚è¿™å¹¶ä¸æ­£ç¡®ï¼å¦‚æœæˆ‘ä»¬çš„æ•°æ®æ˜¯ä¸å¯å˜çš„ï¼ˆè¿™æ˜¯è¯­è¨€ä¸­çš„é»˜è®¤è®¾ç½®ï¼‰ï¼Œé‚£ä¹ˆå¦‚æœä¸¤ä¸ªå€¼ç°åœ¨åœ¨ç»“æ„ä¸Šç›¸ç­‰ï¼Œå®ƒä»¬å¿…é¡»æ°¸è¿œåœ¨ç»“æ„ä¸Šç›¸ç­‰ã€‚å¯¹äºæ­¤ç±»æ•°æ®ï¼Œå³ä½¿å®ƒä»¬ä¸æ˜¯åˆ«åï¼Œ`equal-always`
    ä¹Ÿä¼šè¿”å› `true`ã€‚è¿™æ˜¯ä¸€ä¸ªæé†’ï¼Œæˆ‘ä»¬å…³äºä¸å¯å˜æ•°æ®å¯ä»¥å¾—åˆ°æ›´å¼ºçš„ä¿è¯ã€‚
- en: It is worth noting that upto this point we have used `equal-always`â€”<wbr>in
    the form of both `==` and Pyretâ€™s `is` in testingâ€”<wbr>without really bothering
    to understand very much about how it works, and yet have always gotten predictable
    answers. This suggests that there is something natural about working with immutable
    data. In contrast, with mutable data, something has to give. Pyret made a conscious
    design choice to reflect this in the distinction between `equal-always` and `equal-now`.
    Python made a different choice, which results in â€œequalityâ€ having a perhaps surprising
    meaning. (Python has no notion of `equal-always`, only `equal-now` or `=~`, which
    is written as `==`, and `identical` or `<=>`, which is written as `is`.)
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åœ¨æµ‹è¯•ä¸­ä¸€ç›´ä½¿ç”¨`equal-always`â€”â€”<wbr>æ— è®ºæ˜¯ä½¿ç”¨`==`è¿˜æ˜¯Pyretçš„`is`â€”â€”<wbr>å¹¶æ²¡æœ‰çœŸæ­£å»æ·±å…¥äº†è§£å®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œç„¶è€Œæˆ‘ä»¬æ€»æ˜¯å¾—åˆ°äº†å¯é¢„æµ‹çš„ç­”æ¡ˆã€‚è¿™è¡¨æ˜ï¼Œåœ¨å¤„ç†ä¸å¯å˜æ•°æ®æ—¶ï¼Œå­˜åœ¨æŸç§è‡ªç„¶æ€§ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œåœ¨å¤„ç†å¯å˜æ•°æ®æ—¶ï¼Œå¿…é¡»æœ‰æ‰€å¦¥åã€‚Pyretæœ‰æ„è¯†åœ°åšå‡ºäº†è®¾è®¡é€‰æ‹©ï¼Œé€šè¿‡åœ¨`equal-always`å’Œ`equal-now`ä¹‹é—´çš„åŒºåˆ«æ¥åæ˜ è¿™ä¸€ç‚¹ã€‚Pythonåšå‡ºäº†ä¸åŒçš„é€‰æ‹©ï¼Œè¿™å¯¼è‡´â€œç›¸ç­‰â€å…·æœ‰å¯èƒ½ä»¤äººæƒŠè®¶çš„å«ä¹‰ã€‚ï¼ˆPythonæ²¡æœ‰`equal-always`çš„æ¦‚å¿µï¼Œåªæœ‰`equal-now`æˆ–`=~`ï¼Œå®ƒè¢«å†™ä½œ`==`ï¼Œä»¥åŠ`identical`æˆ–`<=>`ï¼Œå®ƒè¢«å†™ä½œ`is`ã€‚ï¼‰
