- en: 12.2¬†Understanding Equalityüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/unified-equality.html](https://dcic-world.org/2025-08-27/unified-equality.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[12.2.1¬†Equality of Data](#%28part._equality-of-data%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[12.2.2¬†Different Equality Operations](#%28part._equality-operations%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[12.2.2.1¬†Equality in Python](#%28part._.Equality_in_.Python%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[12.2.2.2¬†Equality in Pyret](#%28part._.Equality_in_.Pyret%29) |'
  prefs: []
  type: TYPE_TB
- en: 12.2.1¬†Equality of Data[üîó](#(part._equality-of-data) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have the ability to mutate data, it‚Äôs worth asking what it means
    for two pieces of data to be equal. We‚Äôll motivate this through a concrete example.
    Following the naming convention of [Structure Mutation and the Directory](mutating-structures.html#%28part._structure-mut-dir%29),
    we will write every name only once, using the upper-case name from Python, but
    everything we write will equally be true for Pyret.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, consider these three statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the above `Account`s do you consider ‚Äúequal‚Äù?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The third `Account` has a different balance than the first two, so it can‚Äôt
    be considered equal to either of the first two. The first two have the same contents,
    so arguably they can be considered equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let‚Äôs consider the directory and heap that would result from running these
    three statements:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1120:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1121:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1122:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From the perspective of the heap, each account ends up at its own address.
    Those different addresses are a way in which the two values are not the same:
    they have the same contents, but not the same address. Is that relevant? To explore
    this, let‚Äôs associate another name (`a4`) with the same address as `a2`, then
    change the balance in `a2`. For now we will show just the Python version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'What does memory look like before and after checkpoint 1? Before the checkpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1130:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1131:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1132:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`a1` and `a2` refer to two different `Account`s with the same contents. After
    checkpoint 1, those contents are different because we modified the contents of
    the balance field in `a2`:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1130:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1131:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1132:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In contrast, `a2` and `a4` are aliases for the same `Account`. Therefore, their
    values change in lockstep: asking to display the value of either one would now
    show an account with a balance of `800`.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think now? Are the first two accounts equal?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 12.2.2¬†Different Equality Operations[üîó](#(part._equality-operations) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This sequence of examples points out that we seem to be raising two possible
    notions of equality:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether two values have the same contents. This is formally called structural
    equality; you can think of it as a ‚Äúprint equality‚Äù, namely, when displayed, do
    the two values look the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whether two values live at the same address, i.e., there is actually only one
    value in memory. This is formally called reference equality. Usually, we would
    refer to the two values by different names (so there is the possibility that they
    are different), and reference equality checks whether the names are aliases. Observe
    that a given value always prints the same way, so any two names that have reference
    equality also have structural equality, but not vice versa.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which notion of equality is ‚Äúcorrect‚Äù? It turns out that they are valuable in
    different contexts. For this reason, programming languages generally provide multiple
    equality operations, letting the programmer indicate which kind of equality they
    mean in their context.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the names of equality operations, and their exact meaning, vary
    across languages. Therefore, we will examine each of Pyret and Python separately.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.2.1¬†Equality in Python[üîó](#(part._.Equality_in_.Python) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `==` operator that you learned in Pyret and we carried into Python checks
    for structural equality, independent of addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, note that this will no longer be true at checkpoint 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we instead want to check for aliasing, we instead use an operation called
    `is` (not to be confused with Pyret‚Äôs `is`, which is used for writing tests):'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This explains why `a2 == a4` was true both before and after the mutation, but
    `a1 == a2` was no longer true after it. The latter seems to violate a very basic
    meaning of ‚Äúequality‚Äù; the problem here is caused by the introduction of mutation.
  prefs: []
  type: TYPE_NORMAL
- en: As we go forward, you‚Äôll get more practice with when to use each kind of equality.
    The `==` operator is more accepting, so it is usually the right default. If you
    actually need to know whether two expressions evaluate to the same address, you
    should instead use `is`.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.2.2¬†Equality in Pyret[üîó](#(part._.Equality_in_.Pyret) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Equality in Pyret is somewhat more detailed, because the language wants you
    to think harder about what is happening in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that we are using the datatype in [Example: Bank Accounts](mutating-structures.html#%28part._eg-bank-acc%29)
    and have written the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In Python, we saw that `a1 == a2` before the mutation. However, in Pyret, this
    produces `false`! Why?
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is because structural equality is actually complicated; there are
    two different questions we could be asking:'
  prefs: []
  type: TYPE_NORMAL
- en: Are these two values structurally equal right now?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Will these two values be structurally equal always?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pyret makes a distinction between these two.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Pyret tends towards safer programming practices. Therefore, the
    standard (structural) equality predicate, `==`, will only return `true` if the
    two values will always be equal. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the two values are actually aliases, no matter how one changes, the
    ‚Äúother‚Äù will always change in the same way. Therefore, they will always ‚Äúprint
    the same‚Äù. We can confirm that they are aliases by using Pyret‚Äôs reference equality
    operator, `<=>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, that guarantee does not apply to `a1` and `a2`; and indeed, at
    checkpoint 2, we see that they are no longer equal. Hence
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a time when `a1` and `a2` do print the same, namely before
    checkpoint 1\. Therefore, Pyret provides another equality operator that checks
    whether values are equal at the moment, `=~`. If we ask this before checkpoint
    1, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we ask the same question at checkpoint 2, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'These operators and their funny symbols may be hard to remember, but Pyret
    also gives them useful (if longer) names, and they can be used as ordinary functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbol |  | Function |  | Type |  | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| `==` |  | `equal-always` |  | Structural |  | If it returns `true`, they
    will always be equal, irrespective of any future mutations. |'
  prefs: []
  type: TYPE_TB
- en: '| `=~` |  | `equal-now` |  | Structural |  | If it returns `true` they are
    currently equal, but that may change after future mutations. |'
  prefs: []
  type: TYPE_TB
- en: '| `<=>` |  | `identical` |  | Reference |  | Returns `true` if the two arguments
    are aliases, `false` otherwise. |'
  prefs: []
  type: TYPE_TB
- en: 'Thus, before checkpoint 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'After checkpoint 2, we no longer need to check any of the `equal-always` or
    `identical` relationships again, because by definition they cannot change. But
    we should check `equal-now` again. Sure enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in Pyret, the `==` operator is the same as `equal-always`. When data
    contain mutable fields, this will always produce `false`, because even if the
    values are structurally equal now, it‚Äôs possible that a future mutation will change
    that. This is to remind you to be careful in the presence of mutation. In situations
    where we really care only about equality at that instant, we can use `=~`, i.e.,
    `equal-now`.
  prefs: []
  type: TYPE_NORMAL
- en: The examples above might suggest that only aliased values are `equal-always`.
    This is not true! If our data are immutable (which is the default in the language),
    then if two values are structurally equal now, they must remain structurally equal
    forever. For such data, `equal-always` will return `true` even when they are not
    aliases. This is a reminder that we get stronger guarantees about immutable data.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that upto this point we have used `equal-always`‚Äî<wbr>in
    the form of both `==` and Pyret‚Äôs `is` in testing‚Äî<wbr>without really bothering
    to understand very much about how it works, and yet have always gotten predictable
    answers. This suggests that there is something natural about working with immutable
    data. In contrast, with mutable data, something has to give. Pyret made a conscious
    design choice to reflect this in the distinction between `equal-always` and `equal-now`.
    Python made a different choice, which results in ‚Äúequality‚Äù having a perhaps surprising
    meaning. (Python has no notion of `equal-always`, only `equal-now` or `=~`, which
    is written as `==`, and `identical` or `<=>`, which is written as `is`.)
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.1¬†Equality of Data[üîó](#(part._equality-of-data) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have the ability to mutate data, it‚Äôs worth asking what it means
    for two pieces of data to be equal. We‚Äôll motivate this through a concrete example.
    Following the naming convention of [Structure Mutation and the Directory](mutating-structures.html#%28part._structure-mut-dir%29),
    we will write every name only once, using the upper-case name from Python, but
    everything we write will equally be true for Pyret.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, consider these three statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the above `Account`s do you consider ‚Äúequal‚Äù?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The third `Account` has a different balance than the first two, so it can‚Äôt
    be considered equal to either of the first two. The first two have the same contents,
    so arguably they can be considered equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let‚Äôs consider the directory and heap that would result from running these
    three statements:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1120:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1121:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1122:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From the perspective of the heap, each account ends up at its own address.
    Those different addresses are a way in which the two values are not the same:
    they have the same contents, but not the same address. Is that relevant? To explore
    this, let‚Äôs associate another name (`a4`) with the same address as `a2`, then
    change the balance in `a2`. For now we will show just the Python version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'What does memory look like before and after checkpoint 1? Before the checkpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1130:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1131:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1132:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`a1` and `a2` refer to two different `Account`s with the same contents. After
    checkpoint 1, those contents are different because we modified the contents of
    the balance field in `a2`:'
  prefs: []
  type: TYPE_NORMAL
- en: Directory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: ‚Üí¬†1131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: '1130:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1131:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '1132:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In contrast, `a2` and `a4` are aliases for the same `Account`. Therefore, their
    values change in lockstep: asking to display the value of either one would now
    show an account with a balance of `800`.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think now? Are the first two accounts equal?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 12.2.2¬†Different Equality Operations[üîó](#(part._equality-operations) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This sequence of examples points out that we seem to be raising two possible
    notions of equality:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether two values have the same contents. This is formally called structural
    equality; you can think of it as a ‚Äúprint equality‚Äù, namely, when displayed, do
    the two values look the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whether two values live at the same address, i.e., there is actually only one
    value in memory. This is formally called reference equality. Usually, we would
    refer to the two values by different names (so there is the possibility that they
    are different), and reference equality checks whether the names are aliases. Observe
    that a given value always prints the same way, so any two names that have reference
    equality also have structural equality, but not vice versa.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which notion of equality is ‚Äúcorrect‚Äù? It turns out that they are valuable in
    different contexts. For this reason, programming languages generally provide multiple
    equality operations, letting the programmer indicate which kind of equality they
    mean in their context.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the names of equality operations, and their exact meaning, vary
    across languages. Therefore, we will examine each of Pyret and Python separately.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.2.1¬†Equality in Python[üîó](#(part._.Equality_in_.Python) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `==` operator that you learned in Pyret and we carried into Python checks
    for structural equality, independent of addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, note that this will no longer be true at checkpoint 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we instead want to check for aliasing, we instead use an operation called
    `is` (not to be confused with Pyret‚Äôs `is`, which is used for writing tests):'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This explains why `a2 == a4` was true both before and after the mutation, but
    `a1 == a2` was no longer true after it. The latter seems to violate a very basic
    meaning of ‚Äúequality‚Äù; the problem here is caused by the introduction of mutation.
  prefs: []
  type: TYPE_NORMAL
- en: As we go forward, you‚Äôll get more practice with when to use each kind of equality.
    The `==` operator is more accepting, so it is usually the right default. If you
    actually need to know whether two expressions evaluate to the same address, you
    should instead use `is`.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.2.2¬†Equality in Pyret[üîó](#(part._.Equality_in_.Pyret) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Equality in Pyret is somewhat more detailed, because the language wants you
    to think harder about what is happening in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that we are using the datatype in [Example: Bank Accounts](mutating-structures.html#%28part._eg-bank-acc%29)
    and have written the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: In Python, we saw that `a1 == a2` before the mutation. However, in Pyret, this
    produces `false`! Why?
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is because structural equality is actually complicated; there are
    two different questions we could be asking:'
  prefs: []
  type: TYPE_NORMAL
- en: Are these two values structurally equal right now?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Will these two values be structurally equal always?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pyret makes a distinction between these two.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Pyret tends towards safer programming practices. Therefore, the
    standard (structural) equality predicate, `==`, will only return `true` if the
    two values will always be equal. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the two values are actually aliases, no matter how one changes, the
    ‚Äúother‚Äù will always change in the same way. Therefore, they will always ‚Äúprint
    the same‚Äù. We can confirm that they are aliases by using Pyret‚Äôs reference equality
    operator, `<=>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, that guarantee does not apply to `a1` and `a2`; and indeed, at
    checkpoint 2, we see that they are no longer equal. Hence
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a time when `a1` and `a2` do print the same, namely before
    checkpoint 1\. Therefore, Pyret provides another equality operator that checks
    whether values are equal at the moment, `=~`. If we ask this before checkpoint
    1, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we ask the same question at checkpoint 2, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'These operators and their funny symbols may be hard to remember, but Pyret
    also gives them useful (if longer) names, and they can be used as ordinary functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbol |  | Function |  | Type |  | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| `==` |  | `equal-always` |  | Structural |  | If it returns `true`, they
    will always be equal, irrespective of any future mutations. |'
  prefs: []
  type: TYPE_TB
- en: '| `=~` |  | `equal-now` |  | Structural |  | If it returns `true` they are
    currently equal, but that may change after future mutations. |'
  prefs: []
  type: TYPE_TB
- en: '| `<=>` |  | `identical` |  | Reference |  | Returns `true` if the two arguments
    are aliases, `false` otherwise. |'
  prefs: []
  type: TYPE_TB
- en: 'Thus, before checkpoint 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'After checkpoint 2, we no longer need to check any of the `equal-always` or
    `identical` relationships again, because by definition they cannot change. But
    we should check `equal-now` again. Sure enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in Pyret, the `==` operator is the same as `equal-always`. When data
    contain mutable fields, this will always produce `false`, because even if the
    values are structurally equal now, it‚Äôs possible that a future mutation will change
    that. This is to remind you to be careful in the presence of mutation. In situations
    where we really care only about equality at that instant, we can use `=~`, i.e.,
    `equal-now`.
  prefs: []
  type: TYPE_NORMAL
- en: The examples above might suggest that only aliased values are `equal-always`.
    This is not true! If our data are immutable (which is the default in the language),
    then if two values are structurally equal now, they must remain structurally equal
    forever. For such data, `equal-always` will return `true` even when they are not
    aliases. This is a reminder that we get stronger guarantees about immutable data.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that upto this point we have used `equal-always`‚Äî<wbr>in
    the form of both `==` and Pyret‚Äôs `is` in testing‚Äî<wbr>without really bothering
    to understand very much about how it works, and yet have always gotten predictable
    answers. This suggests that there is something natural about working with immutable
    data. In contrast, with mutable data, something has to give. Pyret made a conscious
    design choice to reflect this in the distinction between `equal-always` and `equal-now`.
    Python made a different choice, which results in ‚Äúequality‚Äù having a perhaps surprising
    meaning. (Python has no notion of `equal-always`, only `equal-now` or `=~`, which
    is written as `==`, and `identical` or `<=>`, which is written as `is`.)
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.2.1¬†Equality in Python[üîó](#(part._.Equality_in_.Python) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `==` operator that you learned in Pyret and we carried into Python checks
    for structural equality, independent of addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, note that this will no longer be true at checkpoint 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we instead want to check for aliasing, we instead use an operation called
    `is` (not to be confused with Pyret‚Äôs `is`, which is used for writing tests):'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This explains why `a2 == a4` was true both before and after the mutation, but
    `a1 == a2` was no longer true after it. The latter seems to violate a very basic
    meaning of ‚Äúequality‚Äù; the problem here is caused by the introduction of mutation.
  prefs: []
  type: TYPE_NORMAL
- en: As we go forward, you‚Äôll get more practice with when to use each kind of equality.
    The `==` operator is more accepting, so it is usually the right default. If you
    actually need to know whether two expressions evaluate to the same address, you
    should instead use `is`.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.2.2¬†Equality in Pyret[üîó](#(part._.Equality_in_.Pyret) "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Equality in Pyret is somewhat more detailed, because the language wants you
    to think harder about what is happening in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that we are using the datatype in [Example: Bank Accounts](mutating-structures.html#%28part._eg-bank-acc%29)
    and have written the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: In Python, we saw that `a1 == a2` before the mutation. However, in Pyret, this
    produces `false`! Why?
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is because structural equality is actually complicated; there are
    two different questions we could be asking:'
  prefs: []
  type: TYPE_NORMAL
- en: Are these two values structurally equal right now?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Will these two values be structurally equal always?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pyret makes a distinction between these two.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Pyret tends towards safer programming practices. Therefore, the
    standard (structural) equality predicate, `==`, will only return `true` if the
    two values will always be equal. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the two values are actually aliases, no matter how one changes, the
    ‚Äúother‚Äù will always change in the same way. Therefore, they will always ‚Äúprint
    the same‚Äù. We can confirm that they are aliases by using Pyret‚Äôs reference equality
    operator, `<=>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, that guarantee does not apply to `a1` and `a2`; and indeed, at
    checkpoint 2, we see that they are no longer equal. Hence
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a time when `a1` and `a2` do print the same, namely before
    checkpoint 1\. Therefore, Pyret provides another equality operator that checks
    whether values are equal at the moment, `=~`. If we ask this before checkpoint
    1, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we ask the same question at checkpoint 2, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'These operators and their funny symbols may be hard to remember, but Pyret
    also gives them useful (if longer) names, and they can be used as ordinary functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbol |  | Function |  | Type |  | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| `==` |  | `equal-always` |  | Structural |  | If it returns `true`, they
    will always be equal, irrespective of any future mutations. |'
  prefs: []
  type: TYPE_TB
- en: '| `=~` |  | `equal-now` |  | Structural |  | If it returns `true` they are
    currently equal, but that may change after future mutations. |'
  prefs: []
  type: TYPE_TB
- en: '| `<=>` |  | `identical` |  | Reference |  | Returns `true` if the two arguments
    are aliases, `false` otherwise. |'
  prefs: []
  type: TYPE_TB
- en: 'Thus, before checkpoint 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'After checkpoint 2, we no longer need to check any of the `equal-always` or
    `identical` relationships again, because by definition they cannot change. But
    we should check `equal-now` again. Sure enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '&#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in Pyret, the `==` operator is the same as `equal-always`. When data
    contain mutable fields, this will always produce `false`, because even if the
    values are structurally equal now, it‚Äôs possible that a future mutation will change
    that. This is to remind you to be careful in the presence of mutation. In situations
    where we really care only about equality at that instant, we can use `=~`, i.e.,
    `equal-now`.
  prefs: []
  type: TYPE_NORMAL
- en: The examples above might suggest that only aliased values are `equal-always`.
    This is not true! If our data are immutable (which is the default in the language),
    then if two values are structurally equal now, they must remain structurally equal
    forever. For such data, `equal-always` will return `true` even when they are not
    aliases. This is a reminder that we get stronger guarantees about immutable data.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that upto this point we have used `equal-always`‚Äî<wbr>in
    the form of both `==` and Pyret‚Äôs `is` in testing‚Äî<wbr>without really bothering
    to understand very much about how it works, and yet have always gotten predictable
    answers. This suggests that there is something natural about working with immutable
    data. In contrast, with mutable data, something has to give. Pyret made a conscious
    design choice to reflect this in the distinction between `equal-always` and `equal-now`.
    Python made a different choice, which results in ‚Äúequality‚Äù having a perhaps surprising
    meaning. (Python has no notion of `equal-always`, only `equal-now` or `=~`, which
    is written as `==`, and `identical` or `<=>`, which is written as `is`.)
  prefs: []
  type: TYPE_NORMAL
