<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>12.2Â Understanding EqualityğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>12.2Â Understanding EqualityğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/unified-equality.html">https://dcic-world.org/2025-08-27/unified-equality.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._equality-of-data%29" class="toclink" data-pltdoc="x">12.2.1<span class="hspace">Â </span>Equality of Data</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._equality-operations%29" class="toclink" data-pltdoc="x">12.2.2<span class="hspace">Â </span>Different Equality Operations</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Equality_in_.Python%29" class="toclink" data-pltdoc="x">12.2.2.1<span class="hspace">Â </span>Equality in Python</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â Â Â </span><a href="#%28part._.Equality_in_.Pyret%29" class="toclink" data-pltdoc="x">12.2.2.2<span class="hspace">Â </span>Equality in Pyret</a></p></td></tr></table><section class="SsectionLevel4" id="section 12.2.1"><h4 class="heading">12.2.1<span class="stt">Â </span><a name="(part._equality-of-data)"/>Equality of Data<span class="button-group"><a href="#(part._equality-of-data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Now that we have the ability to mutate data, itâ€™s worth asking what it
means for two pieces of data to be equal. Weâ€™ll motivate this through
a concrete example. Following the naming convention of
<a href="mutating-structures.html#%28part._structure-mut-dir%29" data-pltdoc="x">Structure Mutation and the Directory</a>, we will write every name only once, using the
upper-case name from Python, but everything we write will equally be
true for Pyret.</p><p>First, consider these three statements:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1 = Account(8603, 500)
a2 = Account(8603, 500)
a3 = Account(8603, 250)</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Which of the above <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account</code></span>s do you consider â€œequalâ€?</p></blockquote></blockquote><p>The third <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account</code></span> has a different balance than the first two,
so it canâ€™t be considered equal to either of the first two. The first
two have the same contents, so arguably they can be considered equal.</p><p>Now, letâ€™s consider the directory and heap that would result from
running these three statements:</p><div class="HeapExpr"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1120</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1121</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a3</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1122</span></div></li></ul></div><div class="HeapPart"><p>Heap</p><ul><li><p/><div class="SIntrapara"><span class="heapref source">1120</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><span class="heapref source">1121</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><span class="heapref source">1122</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 250)</code></pre></div></div></div></li></ul></div><p/><div class="clear"/></div><p>From the perspective of the heap, each account ends up at its own
address. Those different addresses are a way in which the two values
are not the same: they have the same contents, but not the same
address. Is that relevant? To explore this, letâ€™s associate another
name (<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a4</code></span>) with the same address as <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></span>, then change
the balance in <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></span>.
For now we will show just the Python version:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1 = Account(8603, 500)
a2 = Account(8603, 500)
a3 = Account(8603, 250)
a4 = a2
# checkpoint 1
a2.balance = 800
# checkpoint 2</code></pre></div></div><p/><div class="SIntrapara">What does memory look like before and after checkpoint 1? Before the
checkpoint:
</div><div class="SIntrapara"><div class="HeapExpr"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1130</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1131</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a3</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1132</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a4</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1131</span></div></li></ul></div><div class="HeapPart"><p>Heap</p><ul><li><p/><div class="SIntrapara"><span class="heapref source">1130</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><span class="heapref source">1131</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><span class="heapref source">1132</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 250)</code></pre></div></div></div></li></ul></div><p/><div class="clear"/></div></div><div class="SIntrapara"><span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1</code></span> and <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></span> refer to two different
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account</code></span>s with the same contents. After checkpoint 1, those
contents are different because we modified the contents of the balance
field in <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></span>:
</div><div class="SIntrapara"><div class="HeapExpr"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1130</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1131</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a3</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1132</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a4</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1131</span></div></li></ul></div><div class="HeapPart"><p>Heap</p><ul><li><p/><div class="SIntrapara"><span class="heapref source">1130</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><span class="heapref source">1131</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 800)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><span class="heapref source">1132</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 250)</code></pre></div></div></div></li></ul></div><p/><div class="clear"/></div></div><div class="SIntrapara">In contrast, <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></span> and <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a4</code></span> are aliases for the
same <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account</code></span>. Therefore, their values change in lockstep:
asking to display the value of either one would now show an account
with a balance of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">800</code></span>.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you think now? Are the first two accounts equal?</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 12.2.2"><h4 class="heading">12.2.2<span class="stt">Â </span><a name="(part._equality-operations)"/>Different Equality Operations<span class="button-group"><a href="#(part._equality-operations)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>This sequence of examples points out that we seem to be raising two
possible notions of equality:</p><ol><li><p>Whether two values have the same contents. This is formally called
<span class="emph">structural equality</span>; you can think of it as a â€œprint
equalityâ€, namely, when displayed, do the two values look the same.</p></li><li><p>Whether two values live at the same address, i.e., there is
actually only one value in memory. This is formally called
<span style="font-style: italic">reference equality</span>. Usually, we would refer to the two values by
different names (so there is the <span class="emph">possibility</span> that they are
different), and reference equality checks whether the names are
aliases. Observe that a given value always prints the same way, so
any two names that have reference equality also have structural
equality, but not vice versa.</p></li></ol><p>Which notion of equality is â€œcorrectâ€? It turns out that they are
valuable in different contexts. For this reason, programming languages
generally provide multiple equality operations, letting the programmer
indicate which kind of equality they mean in their context.</p><p>Unfortunately, the names of equality operations, and their exact
meaning, vary across languages. Therefore, we will examine each of
Pyret and Python separately.</p><section class="SsectionLevel5" id="section 12.2.2.1"><h5 class="heading">12.2.2.1<span class="stt">Â </span><a name="(part._.Equality_in_.Python)"/>Equality in Python<span class="button-group"><a href="#(part._.Equality_in_.Python)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>The <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">==</code></span> operator that you learned in Pyret and we carried into
Python checks for structural equality, independent of addresses:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></div></div></td></tr></table></div><p>However, note that this will no longer be true at checkpoint
2:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">False</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></div></div></td></tr></table></div><p>If we instead want to check for aliasing, we instead use an operation
called <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">is</code></span> (not to be confused with Pyretâ€™s <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span>, which
is used for writing tests):</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 is a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">False</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 is a4</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></div></div></td></tr></table></div><p>This explains why <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2 == a4</code></span> was true both before and
after the mutation, but <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1 == a2</code></span> was no longer true
after it. The latter seems to violate a very basic meaning of
â€œequalityâ€; the problem here is caused by the introduction of
mutation.</p><p>As we go forward, youâ€™ll get more practice with when to use each kind
of equality. The <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">==</code></span> operator is more accepting, so it is
usually the right default. If you actually need to know whether two
expressions evaluate to the same address, you should instead use <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">is</code></span>.</p></section><section class="SsectionLevel5" id="section 12.2.2.2"><h5 class="heading">12.2.2.2<span class="stt">Â </span><a name="(part._.Equality_in_.Pyret)"/>Equality in Pyret<span class="button-group"><a href="#(part._.Equality_in_.Pyret)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Equality in Pyret is somewhat more detailed, because the language
wants you to think harder about what is happening in your programs.</p><p/><div class="SIntrapara">Recall that we are using the datatype in <a href="mutating-structures.html#%28part._eg-bank-acc%29" data-pltdoc="x">Example: Bank Accounts</a> and
have written the following definitions:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 = account(8603, 500)
a2 = account(8603, 500)
a3 = account(8603, 250)
a4 = a2
# checkpoint 1
a2!{balance: 800}
# checkpoint 2
</code></pre></div></div></div><p>In Python, we saw that <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1 == a2</code></span> before the
mutation. However, in Pyret, this produces <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>! Why?</p><p/><div class="SIntrapara">The reason is because structural equality is actually complicated;
there are two different questions we could be asking:
</div><div class="SIntrapara"><ol><li><p>Are these two values structurally equal <span class="emph">right now</span>?</p></li><li><p>Will these two values be structurally equal <span class="emph">always</span>?</p></li></ol></div><div class="SIntrapara">Pyret makes a distinction between these two.</div><p>By default, Pyret tends towards safer programming
practices. Therefore, the standard (structural) equality predicate,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span>, will only return <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> if the two values will
<span class="emph">always</span> be equal. Thus:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table><p>Because the two values are actually aliases, no matter how one
changes, the â€œotherâ€ will always change in the same way. Therefore,
they will always â€œprint the sameâ€. We can confirm that they are
aliases by using Pyretâ€™s reference equality operator, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;=&gt;</code></span>:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 &lt;=&gt; a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 &lt;=&gt; a4</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><p>In contrast, that guarantee does not apply to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2</code></span>; and indeed, at checkpoint 2, we see that they are no
longer equal. Hence</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table><p>However, there is a time when <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2</code></span> do print
the same, namely before checkpoint 1. Therefore, Pyret provides
another equality operator that checks whether values are equal
<span class="emph">at the moment</span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=~</code></span>. If we ask this before checkpoint 1,
we get:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 =~ a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table><p>But if we ask the same question at checkpoint 2, we get:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 =~ a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table><p/><div class="SIntrapara">These operators and their funny symbols may be hard to remember, but
Pyret also gives them useful (if longer) <span class="emph">names</span>, and they can be
used as ordinary functions:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span style="font-weight: bold">Symbol</span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span style="font-weight: bold">Function</span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span style="font-weight: bold">Type</span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span style="font-weight: bold">Meaning</span></p></td></tr><tr><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>Structural</p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>If it returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>, they will always be equal,
irrespective of any future mutations.</p></td></tr><tr><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=~</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>Structural</p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>If it returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> they are currently equal,
but that may change after future mutations.</p></td></tr><tr><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;=&gt;</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>Reference</p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>Returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> if the two arguments are aliases,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span> otherwise.</p></td></tr></table></div><div class="SIntrapara">Thus, before checkpoint 1:</div><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a1, a2)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a2, a4)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always(a1, a2)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always(a2, a4)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical(a1, a2)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical(a2, a4)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><p>After checkpoint 2, we no longer need to check any of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> relationships again, because
by definition they cannot change. But we should check <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>
again. Sure enough:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a1, a2)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a2, a4)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><p>Therefore, in Pyret, the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span> operator is the same as
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>. When data contain mutable fields, this will
always produce <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>, because even if the values are
structurally equal now, itâ€™s <span class="emph">possible</span> that a future
mutation will change that. This is to remind you to be careful in the
presence of mutation. In situations where we really care only about
equality at that instant, we can use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=~</code></span>, i.e., <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>.</p><p>The examples above might suggest that only aliased values are
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>. This is not true! If our data are immutable
(which is the default in the language), then if two values are
structurally equal now, they must remain structurally equal
forever. For such data, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> will return <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>
even when they are not aliases. This is a reminder that we get
stronger guarantees about immutable data.</p><p>It is worth noting that upto this point we have used
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>â€”<wbr/>in the form of both <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span> and Pyretâ€™s
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> in testingâ€”<wbr/>without really bothering to understand very
much about how it works, and yet have always gotten predictable
answers. This suggests that there is something natural about working
with immutable data. In contrast, with mutable data, something has to
give. Pyret made a conscious design choice to reflect this in the
distinction between <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>. Python
made a different choice, which results in â€œequalityâ€ having a
perhaps surprising meaning. (Python has no notion of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>, only <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=~</code></span>, which is
written as <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">==</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;=&gt;</code></span>, which is
written as <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">is</code></span>.)</p></section></section>&#13;
<h4 class="heading">12.2.1<span class="stt">Â </span><a name="(part._equality-of-data)"/>Equality of Data<span class="button-group"><a href="#(part._equality-of-data)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Now that we have the ability to mutate data, itâ€™s worth asking what it
means for two pieces of data to be equal. Weâ€™ll motivate this through
a concrete example. Following the naming convention of
<a href="mutating-structures.html#%28part._structure-mut-dir%29" data-pltdoc="x">Structure Mutation and the Directory</a>, we will write every name only once, using the
upper-case name from Python, but everything we write will equally be
true for Pyret.</p><p>First, consider these three statements:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1 = Account(8603, 500)
a2 = Account(8603, 500)
a3 = Account(8603, 250)</code></pre></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Which of the above <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account</code></span>s do you consider â€œequalâ€?</p></blockquote></blockquote><p>The third <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account</code></span> has a different balance than the first two,
so it canâ€™t be considered equal to either of the first two. The first
two have the same contents, so arguably they can be considered equal.</p><p>Now, letâ€™s consider the directory and heap that would result from
running these three statements:</p><div class="HeapExpr"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1120</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1121</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a3</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1122</span></div></li></ul></div><div class="HeapPart"><p>Heap</p><ul><li><p/><div class="SIntrapara"><span class="heapref source">1120</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><span class="heapref source">1121</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><span class="heapref source">1122</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 250)</code></pre></div></div></div></li></ul></div><p/><div class="clear"/></div><p>From the perspective of the heap, each account ends up at its own
address. Those different addresses are a way in which the two values
are not the same: they have the same contents, but not the same
address. Is that relevant? To explore this, letâ€™s associate another
name (<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a4</code></span>) with the same address as <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></span>, then change
the balance in <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></span>.
For now we will show just the Python version:</p><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1 = Account(8603, 500)
a2 = Account(8603, 500)
a3 = Account(8603, 250)
a4 = a2
# checkpoint 1
a2.balance = 800
# checkpoint 2</code></pre></div></div><p/><div class="SIntrapara">What does memory look like before and after checkpoint 1? Before the
checkpoint:
</div><div class="SIntrapara"><div class="HeapExpr"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1130</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1131</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a3</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1132</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a4</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1131</span></div></li></ul></div><div class="HeapPart"><p>Heap</p><ul><li><p/><div class="SIntrapara"><span class="heapref source">1130</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><span class="heapref source">1131</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><span class="heapref source">1132</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 250)</code></pre></div></div></div></li></ul></div><p/><div class="clear"/></div></div><div class="SIntrapara"><span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1</code></span> and <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></span> refer to two different
<span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account</code></span>s with the same contents. After checkpoint 1, those
contents are different because we modified the contents of the balance
field in <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></span>:
</div><div class="SIntrapara"><div class="HeapExpr"><div class="EnvPart"><p>Directory</p><ul><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1130</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1131</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a3</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1132</span></div></li><li><p/><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a4</code></pre></div></div></div><div class="SIntrapara"><span class="hspace">Â </span>â†’<span class="hspace">Â </span><span class="heapref sink">1131</span></div></li></ul></div><div class="HeapPart"><p>Heap</p><ul><li><p/><div class="SIntrapara"><span class="heapref source">1130</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><span class="heapref source">1131</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 800)</code></pre></div></div></div></li><li><p/><div class="SIntrapara"><span class="heapref source">1132</span>:<span class="hspace">Â </span></div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Python" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 250)</code></pre></div></div></div></li></ul></div><p/><div class="clear"/></div></div><div class="SIntrapara">In contrast, <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></span> and <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a4</code></span> are aliases for the
same <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account</code></span>. Therefore, their values change in lockstep:
asking to display the value of either one would now show an account
with a balance of <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">800</code></span>.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you think now? Are the first two accounts equal?</p></blockquote></blockquote>&#13;
<h4 class="heading">12.2.2<span class="stt">Â </span><a name="(part._equality-operations)"/>Different Equality Operations<span class="button-group"><a href="#(part._equality-operations)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>This sequence of examples points out that we seem to be raising two
possible notions of equality:</p><ol><li><p>Whether two values have the same contents. This is formally called
<span class="emph">structural equality</span>; you can think of it as a â€œprint
equalityâ€, namely, when displayed, do the two values look the same.</p></li><li><p>Whether two values live at the same address, i.e., there is
actually only one value in memory. This is formally called
<span style="font-style: italic">reference equality</span>. Usually, we would refer to the two values by
different names (so there is the <span class="emph">possibility</span> that they are
different), and reference equality checks whether the names are
aliases. Observe that a given value always prints the same way, so
any two names that have reference equality also have structural
equality, but not vice versa.</p></li></ol><p>Which notion of equality is â€œcorrectâ€? It turns out that they are
valuable in different contexts. For this reason, programming languages
generally provide multiple equality operations, letting the programmer
indicate which kind of equality they mean in their context.</p><p>Unfortunately, the names of equality operations, and their exact
meaning, vary across languages. Therefore, we will examine each of
Pyret and Python separately.</p><section class="SsectionLevel5" id="section 12.2.2.1"><h5 class="heading">12.2.2.1<span class="stt">Â </span><a name="(part._.Equality_in_.Python)"/>Equality in Python<span class="button-group"><a href="#(part._.Equality_in_.Python)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>The <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">==</code></span> operator that you learned in Pyret and we carried into
Python checks for structural equality, independent of addresses:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></div></div></td></tr></table></div><p>However, note that this will no longer be true at checkpoint
2:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">False</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></div></div></td></tr></table></div><p>If we instead want to check for aliasing, we instead use an operation
called <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">is</code></span> (not to be confused with Pyretâ€™s <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span>, which
is used for writing tests):</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 is a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">False</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 is a4</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></div></div></td></tr></table></div><p>This explains why <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2 == a4</code></span> was true both before and
after the mutation, but <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1 == a2</code></span> was no longer true
after it. The latter seems to violate a very basic meaning of
â€œequalityâ€; the problem here is caused by the introduction of
mutation.</p><p>As we go forward, youâ€™ll get more practice with when to use each kind
of equality. The <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">==</code></span> operator is more accepting, so it is
usually the right default. If you actually need to know whether two
expressions evaluate to the same address, you should instead use <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">is</code></span>.</p></section><section class="SsectionLevel5" id="section 12.2.2.2"><h5 class="heading">12.2.2.2<span class="stt">Â </span><a name="(part._.Equality_in_.Pyret)"/>Equality in Pyret<span class="button-group"><a href="#(part._.Equality_in_.Pyret)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Equality in Pyret is somewhat more detailed, because the language
wants you to think harder about what is happening in your programs.</p><p/><div class="SIntrapara">Recall that we are using the datatype in <a href="mutating-structures.html#%28part._eg-bank-acc%29" data-pltdoc="x">Example: Bank Accounts</a> and
have written the following definitions:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 = account(8603, 500)
a2 = account(8603, 500)
a3 = account(8603, 250)
a4 = a2
# checkpoint 1
a2!{balance: 800}
# checkpoint 2
</code></pre></div></div></div><p>In Python, we saw that <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1 == a2</code></span> before the
mutation. However, in Pyret, this produces <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>! Why?</p><p/><div class="SIntrapara">The reason is because structural equality is actually complicated;
there are two different questions we could be asking:
</div><div class="SIntrapara"><ol><li><p>Are these two values structurally equal <span class="emph">right now</span>?</p></li><li><p>Will these two values be structurally equal <span class="emph">always</span>?</p></li></ol></div><div class="SIntrapara">Pyret makes a distinction between these two.</div><p>By default, Pyret tends towards safer programming
practices. Therefore, the standard (structural) equality predicate,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span>, will only return <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> if the two values will
<span class="emph">always</span> be equal. Thus:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table><p>Because the two values are actually aliases, no matter how one
changes, the â€œotherâ€ will always change in the same way. Therefore,
they will always â€œprint the sameâ€. We can confirm that they are
aliases by using Pyretâ€™s reference equality operator, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;=&gt;</code></span>:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 &lt;=&gt; a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 &lt;=&gt; a4</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><p>In contrast, that guarantee does not apply to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2</code></span>; and indeed, at checkpoint 2, we see that they are no
longer equal. Hence</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table><p>However, there is a time when <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2</code></span> do print
the same, namely before checkpoint 1. Therefore, Pyret provides
another equality operator that checks whether values are equal
<span class="emph">at the moment</span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=~</code></span>. If we ask this before checkpoint 1,
we get:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 =~ a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table><p>But if we ask the same question at checkpoint 2, we get:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 =~ a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table><p/><div class="SIntrapara">These operators and their funny symbols may be hard to remember, but
Pyret also gives them useful (if longer) <span class="emph">names</span>, and they can be
used as ordinary functions:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span style="font-weight: bold">Symbol</span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span style="font-weight: bold">Function</span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span style="font-weight: bold">Type</span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span style="font-weight: bold">Meaning</span></p></td></tr><tr><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>Structural</p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>If it returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>, they will always be equal,
irrespective of any future mutations.</p></td></tr><tr><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=~</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>Structural</p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>If it returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> they are currently equal,
but that may change after future mutations.</p></td></tr><tr><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;=&gt;</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>Reference</p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>Returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> if the two arguments are aliases,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span> otherwise.</p></td></tr></table></div><div class="SIntrapara">Thus, before checkpoint 1:</div><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a1, a2)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a2, a4)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always(a1, a2)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always(a2, a4)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical(a1, a2)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical(a2, a4)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><p>After checkpoint 2, we no longer need to check any of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> relationships again, because
by definition they cannot change. But we should check <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>
again. Sure enough:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a1, a2)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a2, a4)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><p>Therefore, in Pyret, the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span> operator is the same as
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>. When data contain mutable fields, this will
always produce <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>, because even if the values are
structurally equal now, itâ€™s <span class="emph">possible</span> that a future
mutation will change that. This is to remind you to be careful in the
presence of mutation. In situations where we really care only about
equality at that instant, we can use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=~</code></span>, i.e., <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>.</p><p>The examples above might suggest that only aliased values are
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>. This is not true! If our data are immutable
(which is the default in the language), then if two values are
structurally equal now, they must remain structurally equal
forever. For such data, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> will return <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>
even when they are not aliases. This is a reminder that we get
stronger guarantees about immutable data.</p><p>It is worth noting that upto this point we have used
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>â€”<wbr/>in the form of both <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span> and Pyretâ€™s
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> in testingâ€”<wbr/>without really bothering to understand very
much about how it works, and yet have always gotten predictable
answers. This suggests that there is something natural about working
with immutable data. In contrast, with mutable data, something has to
give. Pyret made a conscious design choice to reflect this in the
distinction between <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>. Python
made a different choice, which results in â€œequalityâ€ having a
perhaps surprising meaning. (Python has no notion of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>, only <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=~</code></span>, which is
written as <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">==</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;=&gt;</code></span>, which is
written as <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">is</code></span>.)</p></section>&#13;
<h5 class="heading">12.2.2.1<span class="stt">Â </span><a name="(part._.Equality_in_.Python)"/>Equality in Python<span class="button-group"><a href="#(part._.Equality_in_.Python)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>The <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">==</code></span> operator that you learned in Pyret and we carried into
Python checks for structural equality, independent of addresses:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></div></div></td></tr></table></div><p>However, note that this will no longer be true at checkpoint
2:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">False</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></div></div></td></tr></table></div><p>If we instead want to check for aliasing, we instead use an operation
called <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">is</code></span> (not to be confused with Pyretâ€™s <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span>, which
is used for writing tests):</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 is a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">False</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 is a4</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></div></div></td></tr></table></div><p>This explains why <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2 == a4</code></span> was true both before and
after the mutation, but <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1 == a2</code></span> was no longer true
after it. The latter seems to violate a very basic meaning of
â€œequalityâ€; the problem here is caused by the introduction of
mutation.</p><p>As we go forward, youâ€™ll get more practice with when to use each kind
of equality. The <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">==</code></span> operator is more accepting, so it is
usually the right default. If you actually need to know whether two
expressions evaluate to the same address, you should instead use <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">is</code></span>.</p>&#13;
<h5 class="heading">12.2.2.2<span class="stt">Â </span><a name="(part._.Equality_in_.Pyret)"/>Equality in Pyret<span class="button-group"><a href="#(part._.Equality_in_.Pyret)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Equality in Pyret is somewhat more detailed, because the language
wants you to think harder about what is happening in your programs.</p><p/><div class="SIntrapara">Recall that we are using the datatype in <a href="mutating-structures.html#%28part._eg-bank-acc%29" data-pltdoc="x">Example: Bank Accounts</a> and
have written the following definitions:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 = account(8603, 500)
a2 = account(8603, 500)
a3 = account(8603, 250)
a4 = a2
# checkpoint 1
a2!{balance: 800}
# checkpoint 2
</code></pre></div></div></div><p>In Python, we saw that <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1 == a2</code></span> before the
mutation. However, in Pyret, this produces <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>! Why?</p><p/><div class="SIntrapara">The reason is because structural equality is actually complicated;
there are two different questions we could be asking:
</div><div class="SIntrapara"><ol><li><p>Are these two values structurally equal <span class="emph">right now</span>?</p></li><li><p>Will these two values be structurally equal <span class="emph">always</span>?</p></li></ol></div><div class="SIntrapara">Pyret makes a distinction between these two.</div><p>By default, Pyret tends towards safer programming
practices. Therefore, the standard (structural) equality predicate,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span>, will only return <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> if the two values will
<span class="emph">always</span> be equal. Thus:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table><p>Because the two values are actually aliases, no matter how one
changes, the â€œotherâ€ will always change in the same way. Therefore,
they will always â€œprint the sameâ€. We can confirm that they are
aliases by using Pyretâ€™s reference equality operator, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;=&gt;</code></span>:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 &lt;=&gt; a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 &lt;=&gt; a4</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><p>In contrast, that guarantee does not apply to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2</code></span>; and indeed, at checkpoint 2, we see that they are no
longer equal. Hence</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table><p>However, there is a time when <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2</code></span> do print
the same, namely before checkpoint 1. Therefore, Pyret provides
another equality operator that checks whether values are equal
<span class="emph">at the moment</span>, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=~</code></span>. If we ask this before checkpoint 1,
we get:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 =~ a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table><p>But if we ask the same question at checkpoint 2, we get:</p><p/><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 =~ a2</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table><p/><div class="SIntrapara">These operators and their funny symbols may be hard to remember, but
Pyret also gives them useful (if longer) <span class="emph">names</span>, and they can be
used as ordinary functions:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span style="font-weight: bold">Symbol</span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span style="font-weight: bold">Function</span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span style="font-weight: bold">Type</span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span style="font-weight: bold">Meaning</span></p></td></tr><tr><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>Structural</p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>If it returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>, they will always be equal,
irrespective of any future mutations.</p></td></tr><tr><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=~</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>Structural</p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>If it returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> they are currently equal,
but that may change after future mutations.</p></td></tr><tr><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;=&gt;</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p><span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span></p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>Reference</p></td><td><p><span class="hspace">Â Â Â Â </span></p></td><td><p>Returns <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> if the two arguments are aliases,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span> otherwise.</p></td></tr></table></div><div class="SIntrapara">Thus, before checkpoint 1:</div><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a1, a2)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a2, a4)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always(a1, a2)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always(a2, a4)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical(a1, a2)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical(a2, a4)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><p>After checkpoint 2, we no longer need to check any of the
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> relationships again, because
by definition they cannot change. But we should check <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>
again. Sure enough:</p><p/><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a1, a2)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></div></div></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a2, a4)</code></pre></div></div></blockquote></td></tr></table></td></tr><tr><td><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></div></div></td></tr></table></div><p>Therefore, in Pyret, the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span> operator is the same as
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>. When data contain mutable fields, this will
always produce <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>, because even if the values are
structurally equal now, itâ€™s <span class="emph">possible</span> that a future
mutation will change that. This is to remind you to be careful in the
presence of mutation. In situations where we really care only about
equality at that instant, we can use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=~</code></span>, i.e., <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>.</p><p>The examples above might suggest that only aliased values are
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>. This is not true! If our data are immutable
(which is the default in the language), then if two values are
structurally equal now, they must remain structurally equal
forever. For such data, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> will return <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>
even when they are not aliases. This is a reminder that we get
stronger guarantees about immutable data.</p><p>It is worth noting that upto this point we have used
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>â€”<wbr/>in the form of both <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">==</code></span> and Pyretâ€™s
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> in testingâ€”<wbr/>without really bothering to understand very
much about how it works, and yet have always gotten predictable
answers. This suggests that there is something natural about working
with immutable data. In contrast, with mutable data, something has to
give. Pyret made a conscious design choice to reflect this in the
distinction between <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span>. Python
made a different choice, which results in â€œequalityâ€ having a
perhaps surprising meaning. (Python has no notion of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always</code></span>, only <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">=~</code></span>, which is
written as <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">==</code></span>, and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical</code></span> or <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">&lt;=&gt;</code></span>, which is
written as <span title="Python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">is</code></span>.)</p>    
</body>
</html>