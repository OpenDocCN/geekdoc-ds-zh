<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>12.2Â Understanding EqualityğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>12.2Â Understanding EqualityğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/unified-equality.html">https://dcic-world.org/2025-08-27/unified-equality.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._equality-of-data%29" class="toclink" data-pltdoc="x">12.2.1Â Equality of Data</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._equality-operations%29" class="toclink" data-pltdoc="x">12.2.2Â Different Equality Operations</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Equality_in_.Python%29" class="toclink" data-pltdoc="x">12.2.2.1Â Equality in Python</a></p></td></tr><tr><td><p>Â Â Â Â Â Â <a href="#%28part._.Equality_in_.Pyret%29" class="toclink" data-pltdoc="x">12.2.2.2Â Equality in Pyret</a></p></td></tr></table><section class="SsectionLevel4" id="section 12.2.1"><h4 class="heading">12.2.1Â <a name="(part._equality-of-data)"/>Equality of Data<a href="#(part._equality-of-data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Now that we have the ability to mutate data, itâ€™s worth asking what it
means for two pieces of data to be equal. Weâ€™ll motivate this through
a concrete example. Following the naming convention of
<a href="mutating-structures.html#%28part._structure-mut-dir%29" data-pltdoc="x">Structure Mutation and the Directory</a>, we will write every name only once, using the
upper-case name from Python, but everything we write will equally be
true for Pyret.</p><p>First, consider these three statements:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1 = Account(8603, 500)
a2 = Account(8603, 500)
a3 = Account(8603, 250)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Which of the above <code data-lang="text/x-python" class="sourceCode">Account</code>s do you consider â€œequalâ€?</p></blockquote></blockquote><p>The third <code data-lang="text/x-python" class="sourceCode">Account</code> has a different balance than the first two,
so it canâ€™t be considered equal to either of the first two. The first
two have the same contents, so arguably they can be considered equal.</p><p>Now, letâ€™s consider the directory and heap that would result from
running these three statements:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1</code></pre><p>Â â†’Â 1120</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></pre><p>Â â†’Â 1121</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a3</code></pre><p>Â â†’Â 1122</p></li></ul><p>Heap</p><ul><li><p>1120:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></li><li><p>1121:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></li><li><p>1122:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 250)</code></pre></li></ul><p>From the perspective of the heap, each account ends up at its own
address. Those different addresses are a way in which the two values
are not the same: they have the same contents, but not the same
address. Is that relevant? To explore this, letâ€™s associate another
name (<code data-lang="text/x-python" class="sourceCode">a4</code>) with the same address as <code data-lang="text/x-python" class="sourceCode">a2</code>, then change
the balance in <code data-lang="text/x-python" class="sourceCode">a2</code>.
For now we will show just the Python version:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1 = Account(8603, 500)
a2 = Account(8603, 500)
a3 = Account(8603, 250)
a4 = a2
# checkpoint 1
a2.balance = 800
# checkpoint 2</code></pre><p>What does memory look like before and after checkpoint 1? Before the
checkpoint:
</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1</code></pre><p>Â â†’Â 1130</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></pre><p>Â â†’Â 1131</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a3</code></pre><p>Â â†’Â 1132</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a4</code></pre><p>Â â†’Â 1131</p></li></ul><p>Heap</p><ul><li><p>1130:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></li><li><p>1131:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></li><li><p>1132:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 250)</code></pre></li></ul><code data-lang="text/x-python" class="sourceCode">a1</code> and <code data-lang="text/x-python" class="sourceCode">a2</code> refer to two different
<code data-lang="text/x-python" class="sourceCode">Account</code>s with the same contents. After checkpoint 1, those
contents are different because we modified the contents of the balance
field in <code data-lang="text/x-python" class="sourceCode">a2</code>:
<p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1</code></pre><p>Â â†’Â 1130</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></pre><p>Â â†’Â 1131</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a3</code></pre><p>Â â†’Â 1132</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a4</code></pre><p>Â â†’Â 1131</p></li></ul><p>Heap</p><ul><li><p>1130:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></li><li><p>1131:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 800)</code></pre></li><li><p>1132:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 250)</code></pre></li></ul><p>In contrast, <code data-lang="text/x-python" class="sourceCode">a2</code> and <code data-lang="text/x-python" class="sourceCode">a4</code> are aliases for the
same <code data-lang="text/x-python" class="sourceCode">Account</code>. Therefore, their values change in lockstep:
asking to display the value of either one would now show an account
with a balance of <code data-lang="text/x-python" class="sourceCode">800</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you think now? Are the first two accounts equal?</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 12.2.2"><h4 class="heading">12.2.2Â <a name="(part._equality-operations)"/>Different Equality Operations<a href="#(part._equality-operations)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>This sequence of examples points out that we seem to be raising two
possible notions of equality:</p><ol><li><p>Whether two values have the same contents. This is formally called
structural equality; you can think of it as a â€œprint
equalityâ€, namely, when displayed, do the two values look the same.</p></li><li><p>Whether two values live at the same address, i.e., there is
actually only one value in memory. This is formally called
reference equality. Usually, we would refer to the two values by
different names (so there is the possibility that they are
different), and reference equality checks whether the names are
aliases. Observe that a given value always prints the same way, so
any two names that have reference equality also have structural
equality, but not vice versa.</p></li></ol><p>Which notion of equality is â€œcorrectâ€? It turns out that they are
valuable in different contexts. For this reason, programming languages
generally provide multiple equality operations, letting the programmer
indicate which kind of equality they mean in their context.</p><p>Unfortunately, the names of equality operations, and their exact
meaning, vary across languages. Therefore, we will examine each of
Pyret and Python separately.</p><section class="SsectionLevel5" id="section 12.2.2.1"><h5 class="heading">12.2.2.1Â <a name="(part._.Equality_in_.Python)"/>Equality in Python<a href="#(part._.Equality_in_.Python)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>The <code data-lang="text/x-python" class="sourceCode">==</code> operator that you learned in Pyret and we carried into
Python checks for structural equality, independent of addresses:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></td></tr></table><p>However, note that this will no longer be true at checkpoint
2:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">False</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></td></tr></table><p>If we instead want to check for aliasing, we instead use an operation
called <code data-lang="text/x-python" class="sourceCode">is</code> (not to be confused with Pyretâ€™s <code data-lang="pyret" class="sourceCode">is</code>, which
is used for writing tests):</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 is a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">False</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 is a4</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></td></tr></table><p>This explains why <code data-lang="text/x-python" class="sourceCode">a2 == a4</code> was true both before and
after the mutation, but <code data-lang="text/x-python" class="sourceCode">a1 == a2</code> was no longer true
after it. The latter seems to violate a very basic meaning of
â€œequalityâ€; the problem here is caused by the introduction of
mutation.</p><p>As we go forward, youâ€™ll get more practice with when to use each kind
of equality. The <code data-lang="text/x-python" class="sourceCode">==</code> operator is more accepting, so it is
usually the right default. If you actually need to know whether two
expressions evaluate to the same address, you should instead use <code data-lang="text/x-python" class="sourceCode">is</code>.</p></section><section class="SsectionLevel5" id="section 12.2.2.2"><h5 class="heading">12.2.2.2Â <a name="(part._.Equality_in_.Pyret)"/>Equality in Pyret<a href="#(part._.Equality_in_.Pyret)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Equality in Pyret is somewhat more detailed, because the language
wants you to think harder about what is happening in your programs.</p><p>Recall that we are using the datatype in <a href="mutating-structures.html#%28part._eg-bank-acc%29" data-pltdoc="x">Example: Bank Accounts</a> and
have written the following definitions:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 = account(8603, 500)
a2 = account(8603, 500)
a3 = account(8603, 250)
a4 = a2
# checkpoint 1
a2!{balance: 800}
# checkpoint 2
</code></pre><p>In Python, we saw that <code data-lang="text/x-python" class="sourceCode">a1 == a2</code> before the
mutation. However, in Pyret, this produces <code data-lang="pyret" class="sourceCode">false</code>! Why?</p><p>The reason is because structural equality is actually complicated;
there are two different questions we could be asking:
</p><ol><li><p>Are these two values structurally equal right now?</p></li><li><p>Will these two values be structurally equal always?</p></li></ol><p>Pyret makes a distinction between these two.</p><p>By default, Pyret tends towards safer programming
practices. Therefore, the standard (structural) equality predicate,
<code data-lang="pyret" class="sourceCode">==</code>, will only return <code data-lang="pyret" class="sourceCode">true</code> if the two values will
always be equal. Thus:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>Because the two values are actually aliases, no matter how one
changes, the â€œotherâ€ will always change in the same way. Therefore,
they will always â€œprint the sameâ€. We can confirm that they are
aliases by using Pyretâ€™s reference equality operator, <code data-lang="pyret" class="sourceCode">&lt;=&gt;</code>:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 &lt;=&gt; a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 &lt;=&gt; a4</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>In contrast, that guarantee does not apply to <code data-lang="pyret" class="sourceCode">a1</code> and
<code data-lang="pyret" class="sourceCode">a2</code>; and indeed, at checkpoint 2, we see that they are no
longer equal. Hence</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>However, there is a time when <code data-lang="pyret" class="sourceCode">a1</code> and <code data-lang="pyret" class="sourceCode">a2</code> do print
the same, namely before checkpoint 1. Therefore, Pyret provides
another equality operator that checks whether values are equal
at the moment, <code data-lang="pyret" class="sourceCode">=~</code>. If we ask this before checkpoint 1,
we get:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 =~ a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>But if we ask the same question at checkpoint 2, we get:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 =~ a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>These operators and their funny symbols may be hard to remember, but
Pyret also gives them useful (if longer) names, and they can be
used as ordinary functions:
</p><table cellspacing="0" cellpadding="0"><tr><td><p>Symbol</p></td><td><p>Â Â Â Â </p></td><td><p>Function</p></td><td><p>Â Â Â Â </p></td><td><p>Type</p></td><td><p>Â Â Â Â </p></td><td><p>Meaning</p></td></tr><tr><td><p><code data-lang="pyret" class="sourceCode">==</code></p></td><td><p>Â Â Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">equal-always</code></p></td><td><p>Â Â Â Â </p></td><td><p>Structural</p></td><td><p>Â Â Â Â </p></td><td><p>If it returns <code data-lang="pyret" class="sourceCode">true</code>, they will always be equal,
irrespective of any future mutations.</p></td></tr><tr><td><p><code data-lang="pyret" class="sourceCode">=~</code></p></td><td><p>Â Â Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">equal-now</code></p></td><td><p>Â Â Â Â </p></td><td><p>Structural</p></td><td><p>Â Â Â Â </p></td><td><p>If it returns <code data-lang="pyret" class="sourceCode">true</code> they are currently equal,
but that may change after future mutations.</p></td></tr><tr><td><p><code data-lang="pyret" class="sourceCode">&lt;=&gt;</code></p></td><td><p>Â Â Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">identical</code></p></td><td><p>Â Â Â Â </p></td><td><p>Reference</p></td><td><p>Â Â Â Â </p></td><td><p>Returns <code data-lang="pyret" class="sourceCode">true</code> if the two arguments are aliases,
<code data-lang="pyret" class="sourceCode">false</code> otherwise.</p></td></tr></table><p>Thus, before checkpoint 1:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a1, a2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a2, a4)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always(a1, a2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always(a2, a4)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical(a1, a2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical(a2, a4)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>After checkpoint 2, we no longer need to check any of the
<code data-lang="pyret" class="sourceCode">equal-always</code> or <code data-lang="pyret" class="sourceCode">identical</code> relationships again, because
by definition they cannot change. But we should check <code data-lang="pyret" class="sourceCode">equal-now</code>
again. Sure enough:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a1, a2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a2, a4)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>Therefore, in Pyret, the <code data-lang="pyret" class="sourceCode">==</code> operator is the same as
<code data-lang="pyret" class="sourceCode">equal-always</code>. When data contain mutable fields, this will
always produce <code data-lang="pyret" class="sourceCode">false</code>, because even if the values are
structurally equal now, itâ€™s possible that a future
mutation will change that. This is to remind you to be careful in the
presence of mutation. In situations where we really care only about
equality at that instant, we can use <code data-lang="pyret" class="sourceCode">=~</code>, i.e., <code data-lang="pyret" class="sourceCode">equal-now</code>.</p><p>The examples above might suggest that only aliased values are
<code data-lang="pyret" class="sourceCode">equal-always</code>. This is not true! If our data are immutable
(which is the default in the language), then if two values are
structurally equal now, they must remain structurally equal
forever. For such data, <code data-lang="pyret" class="sourceCode">equal-always</code> will return <code data-lang="pyret" class="sourceCode">true</code>
even when they are not aliases. This is a reminder that we get
stronger guarantees about immutable data.</p><p>It is worth noting that upto this point we have used
<code data-lang="pyret" class="sourceCode">equal-always</code>â€”<wbr/>in the form of both <code data-lang="pyret" class="sourceCode">==</code> and Pyretâ€™s
<code data-lang="pyret" class="sourceCode">is</code> in testingâ€”<wbr/>without really bothering to understand very
much about how it works, and yet have always gotten predictable
answers. This suggests that there is something natural about working
with immutable data. In contrast, with mutable data, something has to
give. Pyret made a conscious design choice to reflect this in the
distinction between <code data-lang="pyret" class="sourceCode">equal-always</code> and <code data-lang="pyret" class="sourceCode">equal-now</code>. Python
made a different choice, which results in â€œequalityâ€ having a
perhaps surprising meaning. (Python has no notion of
<code data-lang="pyret" class="sourceCode">equal-always</code>, only <code data-lang="pyret" class="sourceCode">equal-now</code> or <code data-lang="pyret" class="sourceCode">=~</code>, which is
written as <code data-lang="text/x-python" class="sourceCode">==</code>, and <code data-lang="pyret" class="sourceCode">identical</code> or <code data-lang="pyret" class="sourceCode">&lt;=&gt;</code>, which is
written as <code data-lang="text/x-python" class="sourceCode">is</code>.)</p></section></section>&#13;
<h4 class="heading">12.2.1Â <a name="(part._equality-of-data)"/>Equality of Data<a href="#(part._equality-of-data)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Now that we have the ability to mutate data, itâ€™s worth asking what it
means for two pieces of data to be equal. Weâ€™ll motivate this through
a concrete example. Following the naming convention of
<a href="mutating-structures.html#%28part._structure-mut-dir%29" data-pltdoc="x">Structure Mutation and the Directory</a>, we will write every name only once, using the
upper-case name from Python, but everything we write will equally be
true for Pyret.</p><p>First, consider these three statements:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1 = Account(8603, 500)
a2 = Account(8603, 500)
a3 = Account(8603, 250)</code></pre><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Which of the above <code data-lang="text/x-python" class="sourceCode">Account</code>s do you consider â€œequalâ€?</p></blockquote></blockquote><p>The third <code data-lang="text/x-python" class="sourceCode">Account</code> has a different balance than the first two,
so it canâ€™t be considered equal to either of the first two. The first
two have the same contents, so arguably they can be considered equal.</p><p>Now, letâ€™s consider the directory and heap that would result from
running these three statements:</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1</code></pre><p>Â â†’Â 1120</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></pre><p>Â â†’Â 1121</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a3</code></pre><p>Â â†’Â 1122</p></li></ul><p>Heap</p><ul><li><p>1120:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></li><li><p>1121:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></li><li><p>1122:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 250)</code></pre></li></ul><p>From the perspective of the heap, each account ends up at its own
address. Those different addresses are a way in which the two values
are not the same: they have the same contents, but not the same
address. Is that relevant? To explore this, letâ€™s associate another
name (<code data-lang="text/x-python" class="sourceCode">a4</code>) with the same address as <code data-lang="text/x-python" class="sourceCode">a2</code>, then change
the balance in <code data-lang="text/x-python" class="sourceCode">a2</code>.
For now we will show just the Python version:</p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1 = Account(8603, 500)
a2 = Account(8603, 500)
a3 = Account(8603, 250)
a4 = a2
# checkpoint 1
a2.balance = 800
# checkpoint 2</code></pre><p>What does memory look like before and after checkpoint 1? Before the
checkpoint:
</p><p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1</code></pre><p>Â â†’Â 1130</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></pre><p>Â â†’Â 1131</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a3</code></pre><p>Â â†’Â 1132</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a4</code></pre><p>Â â†’Â 1131</p></li></ul><p>Heap</p><ul><li><p>1130:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></li><li><p>1131:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></li><li><p>1132:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 250)</code></pre></li></ul><code data-lang="text/x-python" class="sourceCode">a1</code> and <code data-lang="text/x-python" class="sourceCode">a2</code> refer to two different
<code data-lang="text/x-python" class="sourceCode">Account</code>s with the same contents. After checkpoint 1, those
contents are different because we modified the contents of the balance
field in <code data-lang="text/x-python" class="sourceCode">a2</code>:
<p>Directory</p><ul><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a1</code></pre><p>Â â†’Â 1130</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a2</code></pre><p>Â â†’Â 1131</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a3</code></pre><p>Â â†’Â 1132</p></li><li><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">a4</code></pre><p>Â â†’Â 1131</p></li></ul><p>Heap</p><ul><li><p>1130:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 500)</code></pre></li><li><p>1131:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 800)</code></pre></li><li><p>1132:Â </p><pre data-lang="text/x-python" class="sourceCode"><code data-lang="text/x-python" class="sourceCode">Account(8603, 250)</code></pre></li></ul><p>In contrast, <code data-lang="text/x-python" class="sourceCode">a2</code> and <code data-lang="text/x-python" class="sourceCode">a4</code> are aliases for the
same <code data-lang="text/x-python" class="sourceCode">Account</code>. Therefore, their values change in lockstep:
asking to display the value of either one would now show an account
with a balance of <code data-lang="text/x-python" class="sourceCode">800</code>.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What do you think now? Are the first two accounts equal?</p></blockquote></blockquote>&#13;
<h4 class="heading">12.2.2Â <a name="(part._equality-operations)"/>Different Equality Operations<a href="#(part._equality-operations)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>This sequence of examples points out that we seem to be raising two
possible notions of equality:</p><ol><li><p>Whether two values have the same contents. This is formally called
structural equality; you can think of it as a â€œprint
equalityâ€, namely, when displayed, do the two values look the same.</p></li><li><p>Whether two values live at the same address, i.e., there is
actually only one value in memory. This is formally called
reference equality. Usually, we would refer to the two values by
different names (so there is the possibility that they are
different), and reference equality checks whether the names are
aliases. Observe that a given value always prints the same way, so
any two names that have reference equality also have structural
equality, but not vice versa.</p></li></ol><p>Which notion of equality is â€œcorrectâ€? It turns out that they are
valuable in different contexts. For this reason, programming languages
generally provide multiple equality operations, letting the programmer
indicate which kind of equality they mean in their context.</p><p>Unfortunately, the names of equality operations, and their exact
meaning, vary across languages. Therefore, we will examine each of
Pyret and Python separately.</p><section class="SsectionLevel5" id="section 12.2.2.1"><h5 class="heading">12.2.2.1Â <a name="(part._.Equality_in_.Python)"/>Equality in Python<a href="#(part._.Equality_in_.Python)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>The <code data-lang="text/x-python" class="sourceCode">==</code> operator that you learned in Pyret and we carried into
Python checks for structural equality, independent of addresses:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></td></tr></table><p>However, note that this will no longer be true at checkpoint
2:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">False</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></td></tr></table><p>If we instead want to check for aliasing, we instead use an operation
called <code data-lang="text/x-python" class="sourceCode">is</code> (not to be confused with Pyretâ€™s <code data-lang="pyret" class="sourceCode">is</code>, which
is used for writing tests):</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 is a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">False</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 is a4</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></td></tr></table><p>This explains why <code data-lang="text/x-python" class="sourceCode">a2 == a4</code> was true both before and
after the mutation, but <code data-lang="text/x-python" class="sourceCode">a1 == a2</code> was no longer true
after it. The latter seems to violate a very basic meaning of
â€œequalityâ€; the problem here is caused by the introduction of
mutation.</p><p>As we go forward, youâ€™ll get more practice with when to use each kind
of equality. The <code data-lang="text/x-python" class="sourceCode">==</code> operator is more accepting, so it is
usually the right default. If you actually need to know whether two
expressions evaluate to the same address, you should instead use <code data-lang="text/x-python" class="sourceCode">is</code>.</p></section><section class="SsectionLevel5" id="section 12.2.2.2"><h5 class="heading">12.2.2.2Â <a name="(part._.Equality_in_.Pyret)"/>Equality in Pyret<a href="#(part._.Equality_in_.Pyret)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Equality in Pyret is somewhat more detailed, because the language
wants you to think harder about what is happening in your programs.</p><p>Recall that we are using the datatype in <a href="mutating-structures.html#%28part._eg-bank-acc%29" data-pltdoc="x">Example: Bank Accounts</a> and
have written the following definitions:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 = account(8603, 500)
a2 = account(8603, 500)
a3 = account(8603, 250)
a4 = a2
# checkpoint 1
a2!{balance: 800}
# checkpoint 2
</code></pre><p>In Python, we saw that <code data-lang="text/x-python" class="sourceCode">a1 == a2</code> before the
mutation. However, in Pyret, this produces <code data-lang="pyret" class="sourceCode">false</code>! Why?</p><p>The reason is because structural equality is actually complicated;
there are two different questions we could be asking:
</p><ol><li><p>Are these two values structurally equal right now?</p></li><li><p>Will these two values be structurally equal always?</p></li></ol><p>Pyret makes a distinction between these two.</p><p>By default, Pyret tends towards safer programming
practices. Therefore, the standard (structural) equality predicate,
<code data-lang="pyret" class="sourceCode">==</code>, will only return <code data-lang="pyret" class="sourceCode">true</code> if the two values will
always be equal. Thus:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>Because the two values are actually aliases, no matter how one
changes, the â€œotherâ€ will always change in the same way. Therefore,
they will always â€œprint the sameâ€. We can confirm that they are
aliases by using Pyretâ€™s reference equality operator, <code data-lang="pyret" class="sourceCode">&lt;=&gt;</code>:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 &lt;=&gt; a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 &lt;=&gt; a4</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>In contrast, that guarantee does not apply to <code data-lang="pyret" class="sourceCode">a1</code> and
<code data-lang="pyret" class="sourceCode">a2</code>; and indeed, at checkpoint 2, we see that they are no
longer equal. Hence</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>However, there is a time when <code data-lang="pyret" class="sourceCode">a1</code> and <code data-lang="pyret" class="sourceCode">a2</code> do print
the same, namely before checkpoint 1. Therefore, Pyret provides
another equality operator that checks whether values are equal
at the moment, <code data-lang="pyret" class="sourceCode">=~</code>. If we ask this before checkpoint 1,
we get:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 =~ a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>But if we ask the same question at checkpoint 2, we get:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 =~ a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>These operators and their funny symbols may be hard to remember, but
Pyret also gives them useful (if longer) names, and they can be
used as ordinary functions:
</p><table cellspacing="0" cellpadding="0"><tr><td><p>Symbol</p></td><td><p>Â Â Â Â </p></td><td><p>Function</p></td><td><p>Â Â Â Â </p></td><td><p>Type</p></td><td><p>Â Â Â Â </p></td><td><p>Meaning</p></td></tr><tr><td><p><code data-lang="pyret" class="sourceCode">==</code></p></td><td><p>Â Â Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">equal-always</code></p></td><td><p>Â Â Â Â </p></td><td><p>Structural</p></td><td><p>Â Â Â Â </p></td><td><p>If it returns <code data-lang="pyret" class="sourceCode">true</code>, they will always be equal,
irrespective of any future mutations.</p></td></tr><tr><td><p><code data-lang="pyret" class="sourceCode">=~</code></p></td><td><p>Â Â Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">equal-now</code></p></td><td><p>Â Â Â Â </p></td><td><p>Structural</p></td><td><p>Â Â Â Â </p></td><td><p>If it returns <code data-lang="pyret" class="sourceCode">true</code> they are currently equal,
but that may change after future mutations.</p></td></tr><tr><td><p><code data-lang="pyret" class="sourceCode">&lt;=&gt;</code></p></td><td><p>Â Â Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">identical</code></p></td><td><p>Â Â Â Â </p></td><td><p>Reference</p></td><td><p>Â Â Â Â </p></td><td><p>Returns <code data-lang="pyret" class="sourceCode">true</code> if the two arguments are aliases,
<code data-lang="pyret" class="sourceCode">false</code> otherwise.</p></td></tr></table><p>Thus, before checkpoint 1:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a1, a2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a2, a4)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always(a1, a2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always(a2, a4)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical(a1, a2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical(a2, a4)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>After checkpoint 2, we no longer need to check any of the
<code data-lang="pyret" class="sourceCode">equal-always</code> or <code data-lang="pyret" class="sourceCode">identical</code> relationships again, because
by definition they cannot change. But we should check <code data-lang="pyret" class="sourceCode">equal-now</code>
again. Sure enough:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a1, a2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a2, a4)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>Therefore, in Pyret, the <code data-lang="pyret" class="sourceCode">==</code> operator is the same as
<code data-lang="pyret" class="sourceCode">equal-always</code>. When data contain mutable fields, this will
always produce <code data-lang="pyret" class="sourceCode">false</code>, because even if the values are
structurally equal now, itâ€™s possible that a future
mutation will change that. This is to remind you to be careful in the
presence of mutation. In situations where we really care only about
equality at that instant, we can use <code data-lang="pyret" class="sourceCode">=~</code>, i.e., <code data-lang="pyret" class="sourceCode">equal-now</code>.</p><p>The examples above might suggest that only aliased values are
<code data-lang="pyret" class="sourceCode">equal-always</code>. This is not true! If our data are immutable
(which is the default in the language), then if two values are
structurally equal now, they must remain structurally equal
forever. For such data, <code data-lang="pyret" class="sourceCode">equal-always</code> will return <code data-lang="pyret" class="sourceCode">true</code>
even when they are not aliases. This is a reminder that we get
stronger guarantees about immutable data.</p><p>It is worth noting that upto this point we have used
<code data-lang="pyret" class="sourceCode">equal-always</code>â€”<wbr/>in the form of both <code data-lang="pyret" class="sourceCode">==</code> and Pyretâ€™s
<code data-lang="pyret" class="sourceCode">is</code> in testingâ€”<wbr/>without really bothering to understand very
much about how it works, and yet have always gotten predictable
answers. This suggests that there is something natural about working
with immutable data. In contrast, with mutable data, something has to
give. Pyret made a conscious design choice to reflect this in the
distinction between <code data-lang="pyret" class="sourceCode">equal-always</code> and <code data-lang="pyret" class="sourceCode">equal-now</code>. Python
made a different choice, which results in â€œequalityâ€ having a
perhaps surprising meaning. (Python has no notion of
<code data-lang="pyret" class="sourceCode">equal-always</code>, only <code data-lang="pyret" class="sourceCode">equal-now</code> or <code data-lang="pyret" class="sourceCode">=~</code>, which is
written as <code data-lang="text/x-python" class="sourceCode">==</code>, and <code data-lang="pyret" class="sourceCode">identical</code> or <code data-lang="pyret" class="sourceCode">&lt;=&gt;</code>, which is
written as <code data-lang="text/x-python" class="sourceCode">is</code>.)</p></section>&#13;
<h5 class="heading">12.2.2.1Â <a name="(part._.Equality_in_.Python)"/>Equality in Python<a href="#(part._.Equality_in_.Python)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>The <code data-lang="text/x-python" class="sourceCode">==</code> operator that you learned in Pyret and we carried into
Python checks for structural equality, independent of addresses:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></td></tr></table><p>However, note that this will no longer be true at checkpoint
2:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">False</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></td></tr></table><p>If we instead want to check for aliasing, we instead use an operation
called <code data-lang="text/x-python" class="sourceCode">is</code> (not to be confused with Pyretâ€™s <code data-lang="pyret" class="sourceCode">is</code>, which
is used for writing tests):</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 is a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">False</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 is a4</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">True</code></pre></td></tr></table><p>This explains why <code data-lang="text/x-python" class="sourceCode">a2 == a4</code> was true both before and
after the mutation, but <code data-lang="text/x-python" class="sourceCode">a1 == a2</code> was no longer true
after it. The latter seems to violate a very basic meaning of
â€œequalityâ€; the problem here is caused by the introduction of
mutation.</p><p>As we go forward, youâ€™ll get more practice with when to use each kind
of equality. The <code data-lang="text/x-python" class="sourceCode">==</code> operator is more accepting, so it is
usually the right default. If you actually need to know whether two
expressions evaluate to the same address, you should instead use <code data-lang="text/x-python" class="sourceCode">is</code>.</p>&#13;
<h5 class="heading">12.2.2.2Â <a name="(part._.Equality_in_.Pyret)"/>Equality in Pyret<a href="#(part._.Equality_in_.Pyret)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h5><p>Equality in Pyret is somewhat more detailed, because the language
wants you to think harder about what is happening in your programs.</p><p>Recall that we are using the datatype in <a href="mutating-structures.html#%28part._eg-bank-acc%29" data-pltdoc="x">Example: Bank Accounts</a> and
have written the following definitions:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 = account(8603, 500)
a2 = account(8603, 500)
a3 = account(8603, 250)
a4 = a2
# checkpoint 1
a2!{balance: 800}
# checkpoint 2
</code></pre><p>In Python, we saw that <code data-lang="text/x-python" class="sourceCode">a1 == a2</code> before the
mutation. However, in Pyret, this produces <code data-lang="pyret" class="sourceCode">false</code>! Why?</p><p>The reason is because structural equality is actually complicated;
there are two different questions we could be asking:
</p><ol><li><p>Are these two values structurally equal right now?</p></li><li><p>Will these two values be structurally equal always?</p></li></ol><p>Pyret makes a distinction between these two.</p><p>By default, Pyret tends towards safer programming
practices. Therefore, the standard (structural) equality predicate,
<code data-lang="pyret" class="sourceCode">==</code>, will only return <code data-lang="pyret" class="sourceCode">true</code> if the two values will
always be equal. Thus:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 == a4</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>Because the two values are actually aliases, no matter how one
changes, the â€œotherâ€ will always change in the same way. Therefore,
they will always â€œprint the sameâ€. We can confirm that they are
aliases by using Pyretâ€™s reference equality operator, <code data-lang="pyret" class="sourceCode">&lt;=&gt;</code>:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 &lt;=&gt; a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a2 &lt;=&gt; a4</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>In contrast, that guarantee does not apply to <code data-lang="pyret" class="sourceCode">a1</code> and
<code data-lang="pyret" class="sourceCode">a2</code>; and indeed, at checkpoint 2, we see that they are no
longer equal. Hence</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 == a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>However, there is a time when <code data-lang="pyret" class="sourceCode">a1</code> and <code data-lang="pyret" class="sourceCode">a2</code> do print
the same, namely before checkpoint 1. Therefore, Pyret provides
another equality operator that checks whether values are equal
at the moment, <code data-lang="pyret" class="sourceCode">=~</code>. If we ask this before checkpoint 1,
we get:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 =~ a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>But if we ask the same question at checkpoint 2, we get:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a1 =~ a2</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><p>These operators and their funny symbols may be hard to remember, but
Pyret also gives them useful (if longer) names, and they can be
used as ordinary functions:
</p><table cellspacing="0" cellpadding="0"><tr><td><p>Symbol</p></td><td><p>Â Â Â Â </p></td><td><p>Function</p></td><td><p>Â Â Â Â </p></td><td><p>Type</p></td><td><p>Â Â Â Â </p></td><td><p>Meaning</p></td></tr><tr><td><p><code data-lang="pyret" class="sourceCode">==</code></p></td><td><p>Â Â Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">equal-always</code></p></td><td><p>Â Â Â Â </p></td><td><p>Structural</p></td><td><p>Â Â Â Â </p></td><td><p>If it returns <code data-lang="pyret" class="sourceCode">true</code>, they will always be equal,
irrespective of any future mutations.</p></td></tr><tr><td><p><code data-lang="pyret" class="sourceCode">=~</code></p></td><td><p>Â Â Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">equal-now</code></p></td><td><p>Â Â Â Â </p></td><td><p>Structural</p></td><td><p>Â Â Â Â </p></td><td><p>If it returns <code data-lang="pyret" class="sourceCode">true</code> they are currently equal,
but that may change after future mutations.</p></td></tr><tr><td><p><code data-lang="pyret" class="sourceCode">&lt;=&gt;</code></p></td><td><p>Â Â Â Â </p></td><td><p><code data-lang="pyret" class="sourceCode">identical</code></p></td><td><p>Â Â Â Â </p></td><td><p>Reference</p></td><td><p>Â Â Â Â </p></td><td><p>Returns <code data-lang="pyret" class="sourceCode">true</code> if the two arguments are aliases,
<code data-lang="pyret" class="sourceCode">false</code> otherwise.</p></td></tr></table><p>Thus, before checkpoint 1:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a1, a2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a2, a4)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always(a1, a2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-always(a2, a4)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical(a1, a2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">identical(a2, a4)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>After checkpoint 2, we no longer need to check any of the
<code data-lang="pyret" class="sourceCode">equal-always</code> or <code data-lang="pyret" class="sourceCode">identical</code> relationships again, because
by definition they cannot change. But we should check <code data-lang="pyret" class="sourceCode">equal-now</code>
again. Sure enough:</p><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a1, a2)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></pre></td></tr></table><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><table cellspacing="0" cellpadding="0" class="PyretReplInteraction"><tr><td><blockquote class="PyretRepl"><p class="PyretReplPrompt"/><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">equal-now(a2, a4)</code></pre></blockquote></td></tr></table></td></tr><tr><td><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></pre></td></tr></table><p>Therefore, in Pyret, the <code data-lang="pyret" class="sourceCode">==</code> operator is the same as
<code data-lang="pyret" class="sourceCode">equal-always</code>. When data contain mutable fields, this will
always produce <code data-lang="pyret" class="sourceCode">false</code>, because even if the values are
structurally equal now, itâ€™s possible that a future
mutation will change that. This is to remind you to be careful in the
presence of mutation. In situations where we really care only about
equality at that instant, we can use <code data-lang="pyret" class="sourceCode">=~</code>, i.e., <code data-lang="pyret" class="sourceCode">equal-now</code>.</p><p>The examples above might suggest that only aliased values are
<code data-lang="pyret" class="sourceCode">equal-always</code>. This is not true! If our data are immutable
(which is the default in the language), then if two values are
structurally equal now, they must remain structurally equal
forever. For such data, <code data-lang="pyret" class="sourceCode">equal-always</code> will return <code data-lang="pyret" class="sourceCode">true</code>
even when they are not aliases. This is a reminder that we get
stronger guarantees about immutable data.</p><p>It is worth noting that upto this point we have used
<code data-lang="pyret" class="sourceCode">equal-always</code>â€”<wbr/>in the form of both <code data-lang="pyret" class="sourceCode">==</code> and Pyretâ€™s
<code data-lang="pyret" class="sourceCode">is</code> in testingâ€”<wbr/>without really bothering to understand very
much about how it works, and yet have always gotten predictable
answers. This suggests that there is something natural about working
with immutable data. In contrast, with mutable data, something has to
give. Pyret made a conscious design choice to reflect this in the
distinction between <code data-lang="pyret" class="sourceCode">equal-always</code> and <code data-lang="pyret" class="sourceCode">equal-now</code>. Python
made a different choice, which results in â€œequalityâ€ having a
perhaps surprising meaning. (Python has no notion of
<code data-lang="pyret" class="sourceCode">equal-always</code>, only <code data-lang="pyret" class="sourceCode">equal-now</code> or <code data-lang="pyret" class="sourceCode">=~</code>, which is
written as <code data-lang="text/x-python" class="sourceCode">==</code>, and <code data-lang="pyret" class="sourceCode">identical</code> or <code data-lang="pyret" class="sourceCode">&lt;=&gt;</code>, which is
written as <code data-lang="text/x-python" class="sourceCode">is</code>.)</p>    
</body>
</html>