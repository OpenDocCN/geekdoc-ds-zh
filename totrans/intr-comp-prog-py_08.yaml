- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MODULES AND FILES
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have operated under the assumptions that 1) our entire program is
    stored in one file, 2) our programs do not depend upon previously written code
    (other than the code implementing Python), and 3) our programs do not access previously
    gathered data nor do they store their results in a way that allows them to be
    accessed after the program is finished running.
  prefs: []
  type: TYPE_NORMAL
- en: The first assumption is perfectly reasonable as long as programs are small.
    As programs get larger, however, it is typically more convenient to store different
    parts of them in different files. Imagine, for example, that multiple people are
    working on the same program. It would be a nightmare if they were all trying to
    update the same file. In Section 7.1, we discuss a mechanism, Python modules,
    that allow us to easily construct a program from code in multiple files.
  prefs: []
  type: TYPE_NORMAL
- en: The second and third assumptions are reasonable for exercises designed to help
    people learn to program, but rarely reasonable when writing programs designed
    to accomplish something useful. In Section 7.2, we show how to take advantage
    of library modules that are part of the standard Python distribution. We use a
    couple of these modules in this chapter, and many others later in the book. Section
    7.3 provides a brief introduction to reading from and writing data to files.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1  Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **module** is a `.py` file containing Python definitions and statements. We
    could create, for example, a file `circle.py` containing the code in [Figure 7-1](#c7-fig-0001).
  prefs: []
  type: TYPE_NORMAL
- en: '![c7-fig-0001.jpg](../images/c7-fig-0001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 7-1](#c7-fig-0001a) Some code related to circles and spheres'
  prefs: []
  type: TYPE_NORMAL
- en: A program gets access to a module through an **import statement**. So, for example,
    the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: will print
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Modules are typically stored in individual files. Each module has its own private
    symbol table. Consequently, within `circle.py` we access objects (e.g., `pi` and
    `area`) in the usual way. Executing `import M` creates a binding for module `M`
    in the scope in which the `import` appears. Therefore, in the importing context
    we use dot notation to indicate that we are referring to a name defined in the
    imported module.[^(46)](#c7-fn-0001) For example, outside of `circle.py`, the
    references `pi` and `circle.pi` can (and in this case do) refer to different objects.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, the use of dot notation may seem cumbersome. On the other hand,
    when one imports a module one often has no idea what local names might have been
    used in the implementation of that module. The use of dot notation to **fully**
    **qualify** names avoids the possibility of getting burned by an accidental name
    clash. For example, executing the assignment `pi = 3` outside of the `circle`
    module does not change the value of `pi` used within the `circle` module.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, a module can contain executable statements as well as function
    definitions. Typically, these statements are used to initialize the module. For
    this reason, the statements in a module are executed only the first time a module
    is imported into a program. Moreover, a module is imported only once per interpreter
    session. If you start a console, import a module, and then change the contents
    of that module, the interpreter will still be using the original version of the
    module. This can lead to puzzling behavior when debugging. When in doubt, start
    a new shell.
  prefs: []
  type: TYPE_NORMAL
- en: A variant of the `import` statement that allows the importing program to omit
    the module name when accessing names defined inside the imported module. Executing
    the statement `from M import *` creates bindings in the current scope to all objects
    defined within `M`, but not to `M` itself. For example, the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: will first print `3.14159`, and then produce the error message
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Many Python programmers frown upon using this kind of “wild card” `import.`
    They believe that it makes code more difficult to read because it is no longer
    obvious where a name (for example `pi` in the above code) is defined.
  prefs: []
  type: TYPE_NORMAL
- en: A commonly used variant of the import statement is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This instructs the interpreter to import the module named *module_name*, but
    rename it to *new_name*. This is useful if *module_name* is already being used
    for something else in the importing program. The most common reason programmers
    use this form is to provide an abbreviation for a long name.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 Using Predefined Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lots of useful module packages come as part of the **standard Python library**;
    we will use a number of them later in this book. Moreover, most Python distributions
    come with packages beyond those in the standard library. The Anaconda distribution
    for Python 3.8 comes with over 600 packages! We will use a few of these later
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduce two standard packages, `math` and `calendar`,
    and give a few simple examples of their use. By the way, these packages, like
    all of the standard modules, use Python mechanisms that we have not yet covered
    (e.g., exceptions, which are covered in Chapter 9).
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we presented various ways to approximate logarithms. But
    we did not show you the easiest way. The easiest way is to simply import the module
    `math`. For example, to print the log of x base 2, all you need to write is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In addition to containing approximately 50 useful mathematical functions, the
    `math` module contains several useful floating-point constants, e.g., `math.pi`
    and `math.inf` (positive infinity).
  prefs: []
  type: TYPE_NORMAL
- en: The standard library modules designed to support mathematical programming represent
    a minority of the modules in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine, for example, that you wanted to print a textual representation of the
    days of the week of March 1949, something akin to the picture on the right. You
    could go online and find what the calendar looked like that month and year. Then,
    with sufficient patience and lots of trial and error, you might manage to write
    a print statement that would get the job done. Alternatively, you could simply
    write
  prefs: []
  type: TYPE_NORMAL
- en: '![c7-fig-5001.jpg](../images/c7-fig-5001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Or, if you preferred to see the calendar in French, Polish, and Danish, you
    could write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: which would produce
  prefs: []
  type: TYPE_NORMAL
- en: '![c7-fig-5002.jpg](../images/c7-fig-5002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Suppose you wanted to know on what day of the week Christmas will fall in 2033\.
    The line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: will answer the question. The invocation of `cal.weekday` will return an integer
    representing the day of the week,[^(47)](#c7-fn-0002) which is then used to index
    into `cal.day_name`—a list of the days of the week in English.
  prefs: []
  type: TYPE_NORMAL
- en: "Now, suppose you wanted to know on what day American Thanksgiving fell in 2011\\\
    . The day of the week is easy, because American Thanksgiving is always on the\
    \ fourth Thursday of November.[^(48)](#c7-fn-0003) Finding the actual date is\
    \ slightly more complex. First, we use `cal.monthcalendar` to get a list representing\
    \ the weeks of the month. Each element of the list contains seven integers, representing\
    \ the day of the month. If the day does not occur in that month, the first element\
    \ of the list for the week will be `0`. For example, if a month with 31 days starts\
    \ on a Tuesday, the first element of the list will be the list `\uFEFF[0, 1, 2,\
    \ 3, 4, 5, 6]` and the last element of the list will be `\uFEFF[30, 31, 0, 0,\
    \ 0, 0, 0`]."
  prefs: []
  type: TYPE_NORMAL
- en: We use the list returned by `calendar.monthcalendar` to check to see if there
    is a Thursday in the first week. If so, the fourth Thursday is in the fourth week
    of the month (which is at index 3); otherwise it is in the fifth week.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Finger exercise:** Write a function that meets the specification'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Finger exercise:** Since 1958, Canadian Thanksgiving has occurred on the
    second Monday in October. Write a function that takes a year (>1957) as a parameter,
    and returns the number of days between Canadian Thanksgiving and Christmas.'
  prefs: []
  type: TYPE_NORMAL
- en: By convention, Python programmers usually
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Import one module per line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Place all imports at the start of a program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Import standard modules first, followed by third-party modules (e.g., the
    modules provided through Anaconda), and finally application-specific modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Occasionally, placing all imports at the start of a program leads to a problem.
    An import statement is an executable line of code, and the Python interpreter
    executes it when it is encountered. Some modules contain code that gets executed
    when the module is imported. Typically, this code initializes some objects used
    by the module. Since some of this code might access shared resources (e.g., the
    file system on your computer), where in a program the import is executed might
    matter. The good news is that this is unlikely to be a problem for the modules
    you are likely to use.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every computer system uses **files** to save things from one computation to
    the next. Python provides many facilities for creating and accessing files. Here
    we illustrate some of the basic ones.
  prefs: []
  type: TYPE_NORMAL
- en: Each operating system (e.g., Windows and macOS) comes with its own file system
    for creating and accessing files. Python achieves operating-system independence
    by accessing files through something called a **file handle**. The code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: instructs the operating system to create a file with the name `kids` and return
    a file handle for that file. The argument `'w'` to `open` indicates that the file
    is to be opened for **writing**. The following code **opens** a file, uses the
    `**write**` method to write two lines. (In a Python string, the escape character
    “`\`” is used to indicate that the next character should be treated in a special
    way. In this example, the string `'\n'` indicates a **newline character**.) Finally,
    the code **closes** the file. Remember to close a file when the program is finished
    using it. Otherwise there is a risk that some or all of the writes may not be
    saved.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can ensure that you don't forget to close a file by opening it using a `**with**`
    statement. Code of the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: opens a file, binds a local name to it that can be used in the *code_block*,
    and then closes the file when *code_block* is exited.
  prefs: []
  type: TYPE_NORMAL
- en: The following code opens a file for **reading** (using the argument `'r'`),
    and prints its contents. Since Python treats a file as a sequence of lines, we
    can use a `for` statement to iterate over the file's contents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we type the names David and Andrea, this will print
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The extra line between David and Andrea is there because print starts a new
    line each time it encounters the `'\n'` at the end of each line in the file. We
    could have avoided printing the extra line by writing `print(line[:-1])`.
  prefs: []
  type: TYPE_NORMAL
- en: The code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: "will print the single line \uFEFF`MichaelMark`."
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have overwritten the previous contents of the file `kids`. If
    we don't want to do that, we can open the file for **appending** (instead of writing)
    by using the argument `'a'`. For example, if we now run the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: "it will print the line \uFEFF`MichaelMarkDavidAndrea`."
  prefs: []
  type: TYPE_NORMAL
- en: '**Finger exercise**: Write a program that first stores the first ten numbers
    in the Fibonnaci sequence to a file named `fib_file`. Each number should be on
    a separate line in the file. The program should then read the numbers from the
    file and print them.'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the common operations on files are summarized in [Figure 7-2](#c7-fig-0004).
  prefs: []
  type: TYPE_NORMAL
- en: '![c7-fig-0002.jpg](../images/c7-fig-0002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 7-2](#c7-fig-0004a) Common functions for accessing files'
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Terms Introduced in Chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: import statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fully qualified names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: standard Python library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: file handle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: writing to and reading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: from files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: newline character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: opening and closing files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: with statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: appending to files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
