<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>21Â Detecting CyclesğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>21Â Detecting CyclesğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/cycle-detection.html">https://dcic-world.org/2025-08-27/cycle-detection.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.A_.Running_.Example%29" class="toclink" data-pltdoc="x">21.1<span class="hspace">Â </span>A Running Example</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Types%29" class="toclink" data-pltdoc="x">21.2<span class="hspace">Â </span>Types</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.A_.First_.Checker%29" class="toclink" data-pltdoc="x">21.3<span class="hspace">Â </span>A First Checker</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._cyc-det-comp%29" class="toclink" data-pltdoc="x">21.4<span class="hspace">Â </span>Complexity</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.A_.Fabulous_.Improvement%29" class="toclink" data-pltdoc="x">21.5<span class="hspace">Â </span>A Fabulous Improvement</a></p></td></tr><tr><td><p><span class="hspace">Â Â Â Â </span><a href="#%28part._.Testing%29" class="toclink" data-pltdoc="x">21.6<span class="hspace">Â </span>Testing</a></p></td></tr></table><section class="SsectionLevel3" id="section 21.1"><h3 class="heading">21.1<span class="stt">Â </span><a name="(part._.A_.Running_.Example)"/>A Running Example<span class="button-group"><a href="#(part._.A_.Running_.Example)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">As you may have noticed, Pyret will check for and print cycles. For instance,
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import lists as L

data Pair: p(hd, ref tl) end

p0 = p(0, 0)
p1 = p(1, 1)

p2 = p(2, 3)
p3 = p(3, 4)
p2!{tl: p3}
p3!{tl: p2}

p4 = p(4, p3)
p5 = p(5, p4)

p6 = p(6, "dummy")
p6!{tl: p6}</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Sketch out the above pairs to make sure you see all the cycles.</p></blockquote></blockquote><p>So we have two that participate in no cyclic behavior (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p0</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p1</code></span>), two (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p2</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p3</code></span> that are mutually-cyclic, one
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p6</code></span>) that is a self-cycle, and two (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p4</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p5</code></span>)
that <span class="emph">lead to</span> a cycle.</p></section><section class="SsectionLevel3" id="section 21.2"><h3 class="heading">21.2<span class="stt">Â </span><a name="(part._.Types)"/>Types<span class="button-group"><a href="#(part._.Types)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">As an aside, imagine we try to type-check this program. We have to
provide a type for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tl</code></span>, but itâ€™s not clear what this can be:
sometimes itâ€™s a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>, and other times itâ€™s a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Pair</code></span>. However, we might observe that if our <span class="emph">goal</span> is to
create cyclic data, then we want <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tl</code></span> to refer to a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Pair</code></span>
or to nothing at all. That suggests that a useful type is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Pair: p(hd :: Number, ref tl :: Option&lt;Pair&gt;) end</code></pre></div></div></div><div class="SIntrapara">so that we can write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p0 = p(0, none)
p1 = p(1, none)

p2 = p(2, none)
p3 = p(3, none)
p2!{tl: some(p3)}
p3!{tl: some(p2)}
p4 = p(4, some(p3))
p5 = p(5, some(p4))

p6 = p(6, none)
p6!{tl: some(p6)}</code></pre></div></div></div><div class="SIntrapara">This works, but we have to deal with the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Option</code></span>
everywhere. Since our goal is to focus on cycles, and this would
become unwieldy, we ignore the typed version from now on.</div></section><section class="SsectionLevel3" id="section 21.3"><h3 class="heading">21.3<span class="stt">Â </span><a name="(part._.A_.First_.Checker)"/>A First Checker<span class="button-group"><a href="#(part._.A_.First_.Checker)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Okay, back to the untyped version.</p><p/><div class="SIntrapara">So letâ€™s try to figure out whether, given a Pair, it leads to a cycle. What should the type be?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cc :: Pair -&gt; Boolean</code></pre></div></div></div><div class="SIntrapara">where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cc</code></span> stands for â€œcheck cycleâ€.</div><p>Critically, itâ€™s important that this be a total function: i.e., it always terminates.</p><p/><div class="SIntrapara">So letâ€™s write the most obvious solution:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun cc(e):
  fun loop(cur, hist):
    if is-p(cur):
      if L.member-identical(hist, cur):
        true
      else:
        loop(cur!tl, link(cur, hist))
      end
    else:
      false
    end
  end
  loop(e, empty)
end</code></pre></div></div></div><div class="SIntrapara">First of all, does this even terminate? It could take a while to visit
all the nodes, but a cycle demands that somewhere, we revisit a node
we saw before. Since we track that, we canâ€™t not terminate. Therefore,
termination is guaranteed, and the function is total. Indeed, all
these tests pass:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  cc(p0) is false
  cc(p1) is false
  cc(p2) is true
  cc(p3) is true
  cc(p4) is true
  cc(p5) is true
  cc(p6) is true
end</code></pre></div></div></div><p/><div class="SIntrapara">As another aside, observe that we could have written these tests instead like
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  p0 violates cc
  p2 satisfies cc
end</code></pre></div></div></div><div class="SIntrapara">which would be more concise, but that would also be misleading: it
would suggest that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cc</code></span> is a desirable property, so <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p2</code></span> is
a â€œgoodâ€ instance and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p0</code></span> is a â€œbadâ€ one. However, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cc</code></span>
is not a judgment of qualityâ€”<wbr/>its two responses have equal
weightâ€”<wbr/>so this would be confusing to a later reader.</div></section><section class="SsectionLevel3" id="section 21.4"><h3 class="heading">21.4<span class="stt">Â </span><a name="(part._cyc-det-comp)"/>Complexity<span class="button-group"><a href="#(part._cyc-det-comp)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Now that we have determined that it terminates, we can ask for its
time and space complexity. First we have to decide what we are even
computing the complexity over. If the sequence is finite, then the
size is clearly the size of the sequence. But if itâ€™s infinite, we
donâ€™t want to traverse the â€œwhole thingâ€: rather, we mean its finite
part (excluding any repetition). So the meaningful measure in either
case is the number of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p</code></span> nodes, i.e., the finite size. It may
just be that some of these lead back to themselves, so that a naÃ¯ve
traversal will go on forever.</p><p>Okay, so we visit each node once. We keep track of all the nodes just
in case we double back over, either until we run out of nodes or we
repeat one. Therefore, the space complexity is linear in the length of
the sum of the prefix (from the starting node) and the cycle. The time
complexity is that but also, at each point, we have to check
membership, so itâ€™s quadratic in the length of that prefix +
cycle. So: linear space, quadratic time, in the size of the prefix +
cycle.</p><p>Now, some degree of linear behavior is unavoidable: we clearly have to
keep going until we run out or hit a cycle, so for detecting the cycle
having something be linear in the size of the prefix (get it out of
the way) + length of the cycle (find the cycle) seems essential. But
can we improve on this complexity? It seems unlikely: by definition,
how can we check for a cycle if we donâ€™t remember everything weâ€™ve
seen?</p><p>Our first hunch might be, â€œMaybe thereâ€™s another space-time
tradeoff!â€ But itâ€™s not so clear here. Our space is linear and time
quadratic, so we may think we can flip those around. But the time
canâ€™t be less than the space! If, for instance, we had linear time and
quadratic space, that wouldnâ€™t make sense, because weâ€™d need at least
quadratic time just to fill the space. So thatâ€™s not going to work so
well.</p><p>Instead, the best way to improve seems to have a better lookup data
structure. Weâ€™d still take linear spaceâ€”<wbr/>as we said, linear was
unavoidable (and we canâ€™t just be linear in the size of the cycle,
because the whole point is we donâ€™t even know we have a cycle, much
less which parts are prefix and which parts cycle)â€”<wbr/>and the time
complexity would hopefully reduce from quadratic to
linear-times-something-sublinear.</p></section><section class="SsectionLevel3" id="section 21.5"><h3 class="heading">21.5<span class="stt">Â </span><a name="(part._.A_.Fabulous_.Improvement)"/>A Fabulous Improvement<span class="button-group"><a href="#(part._.A_.Fabulous_.Improvement)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>It turns out we can do a lot better! Itâ€™s called the tortoise-and-hare
algorithm.</p><p>We start off with two references into the sequence, one called the
tortoise and the other the hare.</p><p>At each step, the tortoise tries to advance by one node. If it cannot,
weâ€™ve run out of sequence, and weâ€™re done. The hare, being a hare and
not a tortoise, tries to advance by two nodes. Again, if it cannot,
weâ€™ve run out of sequence, and weâ€™re done. Otherwise both advance, and
check if theyâ€™re at the same place. If they are, because they started
out being at distinct nodes, weâ€™ve found a cycle! If they are not,
then we iterate.</p><p>Why does this even work? In the finite case itâ€™s clear, because the
hare will run out of next nodes. We only have to think about the
infinite case. There, in general, we have this kind of situation:</p><p><img src="../Images/31742a6ba02914cbc2bca965912ea982.png" alt="" data-original-src="https://dcic-world.org/2025-08-27/cycle-rho.png"/></p><p>There is some prefix of nodes, followed by a cycle. Now, we donâ€™t know
how long the prefix is, so we donâ€™t know how far ahead of the tortoise
the hare is. Nevertheless, there is some first point at which the
tortoise enters the cycle. (There must be, because the tortoise always
makes progress, and the prefix can only be finite.) From this point
on, we know that on each step, the relative speed of the two animals
is 1. That means the hare â€œgainsâ€ 1 on the tortoise every step. We
can see that eventually, the hare must catch up with the
tortoiseâ€”<wbr/>or, alternatively, that the tortoise catches up with the
hare!</p><p>Now letâ€™s analyze this. The tortoise will get caught by the time it
has completed one loop of the cycle. Because the tortoise moves one
step at a time, the total time is the length of the prefix + length of
the loop. In terms of space, however, we no longer need any history at
all; we only need the current positions of the tortoise and
hare. Therefore, our time complexity is linear, but the space
complexity is now significantly smaller: down to <span class="emph">constant</span>!</p><p/><div class="SIntrapara">Here is the code:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun th(e):
  fun loop(tt, hr):
    if tt &lt;=&gt; hr:
      true
    else:
      if is-p(tt) and is-p(hr):
        new-tt = tt!tl
        int-hr = hr!tl
        if is-p(int-hr):
          new-hr = int-hr!tl
          loop(new-tt, new-hr)
        else:
          false
        end
      else:
        false
      end
    end
  end
  loop(e, e!tl)
end</code></pre></div></div></div></section><section class="SsectionLevel3" id="section 21.6"><h3 class="heading">21.6<span class="stt">Â </span><a name="(part._.Testing)"/>Testing<span class="button-group"><a href="#(part._.Testing)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">While it might be tempting to write tests like
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  cc(p0) is false
  cc(p2) is true
end</code></pre></div></div></div><div class="SIntrapara">(i.e., the same as before, but with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cc</code></span> replaced by <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ph</code></span>), we should instead write them as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  cc(p0) is th(p0)
  cc(p1) is th(p1)
  cc(p2) is th(p2)
  cc(p3) is th(p3)
  cc(p4) is th(p4)
  cc(p5) is th(p5)
  cc(p6) is th(p6)
end</code></pre></div></div></div><p>This confers two advantages. First, if we change the example, we donâ€™t
have to update two tests, only one. But the much more important reason
is that we intend for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pr</code></span> to be <span class="emph">an optimized version of</span>
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cc</code></span>. That is, we expect the two to produce the same result. We
can think of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cc</code></span> as our clear, reference implementation. That
is, this is another instance of <span style="font-style: italic">model-based testing</span>.</p><p>As an aside, this algorithm is not exactly what Pyret does, because we
need to check for arbitrary graph-ness, not just cycles. Itâ€™s also
complicated due to user-defined functions, etc.</p></section>&#13;
<h3 class="heading">21.1<span class="stt">Â </span><a name="(part._.A_.Running_.Example)"/>A Running Example<span class="button-group"><a href="#(part._.A_.Running_.Example)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">As you may have noticed, Pyret will check for and print cycles. For instance,
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">import lists as L

data Pair: p(hd, ref tl) end

p0 = p(0, 0)
p1 = p(1, 1)

p2 = p(2, 3)
p3 = p(3, 4)
p2!{tl: p3}
p3!{tl: p2}

p4 = p(4, p3)
p5 = p(5, p4)

p6 = p(6, "dummy")
p6!{tl: p6}</code></pre></div></div></div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Sketch out the above pairs to make sure you see all the cycles.</p></blockquote></blockquote><p>So we have two that participate in no cyclic behavior (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p0</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p1</code></span>), two (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p2</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p3</code></span> that are mutually-cyclic, one
(<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p6</code></span>) that is a self-cycle, and two (<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p4</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p5</code></span>)
that <span class="emph">lead to</span> a cycle.</p>&#13;
<h3 class="heading">21.2<span class="stt">Â </span><a name="(part._.Types)"/>Types<span class="button-group"><a href="#(part._.Types)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">As an aside, imagine we try to type-check this program. We have to
provide a type for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tl</code></span>, but itâ€™s not clear what this can be:
sometimes itâ€™s a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Number</code></span>, and other times itâ€™s a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Pair</code></span>. However, we might observe that if our <span class="emph">goal</span> is to
create cyclic data, then we want <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">tl</code></span> to refer to a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Pair</code></span>
or to nothing at all. That suggests that a useful type is:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Pair: p(hd :: Number, ref tl :: Option&lt;Pair&gt;) end</code></pre></div></div></div><div class="SIntrapara">so that we can write
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p0 = p(0, none)
p1 = p(1, none)

p2 = p(2, none)
p3 = p(3, none)
p2!{tl: some(p3)}
p3!{tl: some(p2)}
p4 = p(4, some(p3))
p5 = p(5, some(p4))

p6 = p(6, none)
p6!{tl: some(p6)}</code></pre></div></div></div><div class="SIntrapara">This works, but we have to deal with the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Option</code></span>
everywhere. Since our goal is to focus on cycles, and this would
become unwieldy, we ignore the typed version from now on.</div>&#13;
<h3 class="heading">21.3<span class="stt">Â </span><a name="(part._.A_.First_.Checker)"/>A First Checker<span class="button-group"><a href="#(part._.A_.First_.Checker)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Okay, back to the untyped version.</p><p/><div class="SIntrapara">So letâ€™s try to figure out whether, given a Pair, it leads to a cycle. What should the type be?
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cc :: Pair -&gt; Boolean</code></pre></div></div></div><div class="SIntrapara">where <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cc</code></span> stands for â€œcheck cycleâ€.</div><p>Critically, itâ€™s important that this be a total function: i.e., it always terminates.</p><p/><div class="SIntrapara">So letâ€™s write the most obvious solution:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun cc(e):
  fun loop(cur, hist):
    if is-p(cur):
      if L.member-identical(hist, cur):
        true
      else:
        loop(cur!tl, link(cur, hist))
      end
    else:
      false
    end
  end
  loop(e, empty)
end</code></pre></div></div></div><div class="SIntrapara">First of all, does this even terminate? It could take a while to visit
all the nodes, but a cycle demands that somewhere, we revisit a node
we saw before. Since we track that, we canâ€™t not terminate. Therefore,
termination is guaranteed, and the function is total. Indeed, all
these tests pass:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  cc(p0) is false
  cc(p1) is false
  cc(p2) is true
  cc(p3) is true
  cc(p4) is true
  cc(p5) is true
  cc(p6) is true
end</code></pre></div></div></div><p/><div class="SIntrapara">As another aside, observe that we could have written these tests instead like
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  p0 violates cc
  p2 satisfies cc
end</code></pre></div></div></div><div class="SIntrapara">which would be more concise, but that would also be misleading: it
would suggest that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cc</code></span> is a desirable property, so <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p2</code></span> is
a â€œgoodâ€ instance and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p0</code></span> is a â€œbadâ€ one. However, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cc</code></span>
is not a judgment of qualityâ€”<wbr/>its two responses have equal
weightâ€”<wbr/>so this would be confusing to a later reader.</div>&#13;
<h3 class="heading">21.4<span class="stt">Â </span><a name="(part._cyc-det-comp)"/>Complexity<span class="button-group"><a href="#(part._cyc-det-comp)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Now that we have determined that it terminates, we can ask for its
time and space complexity. First we have to decide what we are even
computing the complexity over. If the sequence is finite, then the
size is clearly the size of the sequence. But if itâ€™s infinite, we
donâ€™t want to traverse the â€œwhole thingâ€: rather, we mean its finite
part (excluding any repetition). So the meaningful measure in either
case is the number of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">p</code></span> nodes, i.e., the finite size. It may
just be that some of these lead back to themselves, so that a naÃ¯ve
traversal will go on forever.</p><p>Okay, so we visit each node once. We keep track of all the nodes just
in case we double back over, either until we run out of nodes or we
repeat one. Therefore, the space complexity is linear in the length of
the sum of the prefix (from the starting node) and the cycle. The time
complexity is that but also, at each point, we have to check
membership, so itâ€™s quadratic in the length of that prefix +
cycle. So: linear space, quadratic time, in the size of the prefix +
cycle.</p><p>Now, some degree of linear behavior is unavoidable: we clearly have to
keep going until we run out or hit a cycle, so for detecting the cycle
having something be linear in the size of the prefix (get it out of
the way) + length of the cycle (find the cycle) seems essential. But
can we improve on this complexity? It seems unlikely: by definition,
how can we check for a cycle if we donâ€™t remember everything weâ€™ve
seen?</p><p>Our first hunch might be, â€œMaybe thereâ€™s another space-time
tradeoff!â€ But itâ€™s not so clear here. Our space is linear and time
quadratic, so we may think we can flip those around. But the time
canâ€™t be less than the space! If, for instance, we had linear time and
quadratic space, that wouldnâ€™t make sense, because weâ€™d need at least
quadratic time just to fill the space. So thatâ€™s not going to work so
well.</p><p>Instead, the best way to improve seems to have a better lookup data
structure. Weâ€™d still take linear spaceâ€”<wbr/>as we said, linear was
unavoidable (and we canâ€™t just be linear in the size of the cycle,
because the whole point is we donâ€™t even know we have a cycle, much
less which parts are prefix and which parts cycle)â€”<wbr/>and the time
complexity would hopefully reduce from quadratic to
linear-times-something-sublinear.</p>&#13;
<h3 class="heading">21.5<span class="stt">Â </span><a name="(part._.A_.Fabulous_.Improvement)"/>A Fabulous Improvement<span class="button-group"><a href="#(part._.A_.Fabulous_.Improvement)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>It turns out we can do a lot better! Itâ€™s called the tortoise-and-hare
algorithm.</p><p>We start off with two references into the sequence, one called the
tortoise and the other the hare.</p><p>At each step, the tortoise tries to advance by one node. If it cannot,
weâ€™ve run out of sequence, and weâ€™re done. The hare, being a hare and
not a tortoise, tries to advance by two nodes. Again, if it cannot,
weâ€™ve run out of sequence, and weâ€™re done. Otherwise both advance, and
check if theyâ€™re at the same place. If they are, because they started
out being at distinct nodes, weâ€™ve found a cycle! If they are not,
then we iterate.</p><p>Why does this even work? In the finite case itâ€™s clear, because the
hare will run out of next nodes. We only have to think about the
infinite case. There, in general, we have this kind of situation:</p><p><img src="../Images/31742a6ba02914cbc2bca965912ea982.png" alt="" data-original-src="https://dcic-world.org/2025-08-27/cycle-rho.png"/></p><p>There is some prefix of nodes, followed by a cycle. Now, we donâ€™t know
how long the prefix is, so we donâ€™t know how far ahead of the tortoise
the hare is. Nevertheless, there is some first point at which the
tortoise enters the cycle. (There must be, because the tortoise always
makes progress, and the prefix can only be finite.) From this point
on, we know that on each step, the relative speed of the two animals
is 1. That means the hare â€œgainsâ€ 1 on the tortoise every step. We
can see that eventually, the hare must catch up with the
tortoiseâ€”<wbr/>or, alternatively, that the tortoise catches up with the
hare!</p><p>Now letâ€™s analyze this. The tortoise will get caught by the time it
has completed one loop of the cycle. Because the tortoise moves one
step at a time, the total time is the length of the prefix + length of
the loop. In terms of space, however, we no longer need any history at
all; we only need the current positions of the tortoise and
hare. Therefore, our time complexity is linear, but the space
complexity is now significantly smaller: down to <span class="emph">constant</span>!</p><p/><div class="SIntrapara">Here is the code:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun th(e):
  fun loop(tt, hr):
    if tt &lt;=&gt; hr:
      true
    else:
      if is-p(tt) and is-p(hr):
        new-tt = tt!tl
        int-hr = hr!tl
        if is-p(int-hr):
          new-hr = int-hr!tl
          loop(new-tt, new-hr)
        else:
          false
        end
      else:
        false
      end
    end
  end
  loop(e, e!tl)
end</code></pre></div></div></div>&#13;
<h3 class="heading">21.6<span class="stt">Â </span><a name="(part._.Testing)"/>Testing<span class="button-group"><a href="#(part._.Testing)" class="heading-anchor" title="Link to here">ğŸ”—</a><span style="visibility: hidden"> </span></span></h3><p/><div class="SIntrapara">While it might be tempting to write tests like
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  cc(p0) is false
  cc(p2) is true
end</code></pre></div></div></div><div class="SIntrapara">(i.e., the same as before, but with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cc</code></span> replaced by <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">ph</code></span>), we should instead write them as follows:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  cc(p0) is th(p0)
  cc(p1) is th(p1)
  cc(p2) is th(p2)
  cc(p3) is th(p3)
  cc(p4) is th(p4)
  cc(p5) is th(p5)
  cc(p6) is th(p6)
end</code></pre></div></div></div><p>This confers two advantages. First, if we change the example, we donâ€™t
have to update two tests, only one. But the much more important reason
is that we intend for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">pr</code></span> to be <span class="emph">an optimized version of</span>
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cc</code></span>. That is, we expect the two to produce the same result. We
can think of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">cc</code></span> as our clear, reference implementation. That
is, this is another instance of <span style="font-style: italic">model-based testing</span>.</p><p>As an aside, this algorithm is not exactly what Pyret does, because we
need to check for arbitrary graph-ness, not just cycles. Itâ€™s also
complicated due to user-defined functions, etc.</p>    
</body>
</html>