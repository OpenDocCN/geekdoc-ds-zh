<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>6 Work with models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>6 Work with models</h1>
<blockquote>原文：<a href="https://socviz.co/modeling.html">https://socviz.co/modeling.html</a></blockquote>

<p>Data visualization is about more than generating figures that display
the raw numbers from a table of data. Right from the beginning, it
involves summarizing or transforming parts of the data, and then plotting the
results. Statistical models are a central part of that process. In this Chapter, we will begin by looking briefly at how ggplot can use various modeling techniques directly within geoms. Then we will see how to use the <code>broom</code> and <code>margins</code> libraries to tidily extract and plot estimates from models that we fit ourselves.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb170-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gapminder,</a>
<a class="sourceLine" id="cb170-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">log</span>(gdpPercap), <span class="dt">y =</span> lifeExp))</a>
<a class="sourceLine" id="cb170-3" data-line-number="3"/>
<a class="sourceLine" id="cb170-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">alpha=</span><span class="fl">0.1</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb170-5" data-line-number="5"><span class="st">    </span><span class="kw">geom_smooth</span>(<span class="dt">color =</span> <span class="st">"tomato"</span>, <span class="dt">fill=</span><span class="st">"tomato"</span>, <span class="dt">method =</span> MASS<span class="op">::</span>rlm) <span class="op">+</span></a>
<a class="sourceLine" id="cb170-6" data-line-number="6"><span class="st">    </span><span class="kw">geom_smooth</span>(<span class="dt">color =</span> <span class="st">"steelblue"</span>, <span class="dt">fill=</span><span class="st">"steelblue"</span>, <span class="dt">method =</span> <span class="st">"lm"</span>)</a>
<a class="sourceLine" id="cb170-7" data-line-number="7"/>
<a class="sourceLine" id="cb170-8" data-line-number="8">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">alpha=</span><span class="fl">0.1</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb170-9" data-line-number="9"><span class="st">    </span><span class="kw">geom_smooth</span>(<span class="dt">color =</span> <span class="st">"tomato"</span>, <span class="dt">method =</span> <span class="st">"lm"</span>, <span class="dt">size =</span> <span class="fl">1.2</span>, </a>
<a class="sourceLine" id="cb170-10" data-line-number="10">                <span class="dt">formula =</span> y <span class="op">~</span><span class="st"> </span>splines<span class="op">::</span><span class="kw">bs</span>(x, <span class="dv">3</span>), <span class="dt">se =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb170-11" data-line-number="11"/>
<a class="sourceLine" id="cb170-12" data-line-number="12">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">alpha=</span><span class="fl">0.1</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb170-13" data-line-number="13"><span class="st">    </span><span class="kw">geom_quantile</span>(<span class="dt">color =</span> <span class="st">"tomato"</span>, <span class="dt">size =</span> <span class="fl">1.2</span>, <span class="dt">method =</span> <span class="st">"rqss"</span>,</a>
<a class="sourceLine" id="cb170-14" data-line-number="14">                  <span class="dt">lambda =</span> <span class="dv">1</span>, <span class="dt">quantiles =</span> <span class="kw">c</span>(<span class="fl">0.20</span>, <span class="fl">0.5</span>, <span class="fl">0.85</span>))</a></code></pre>
<p>Histograms, density plots, boxplots, and other geoms compute either
single numbers or new variables before plotting them. As we saw in
Section <a href="groupfacettx.html#statfunctions">4.4</a>, these calculations are done by <code>stat_</code>
functions, each of which works hand-in-hand with its default <code>geom_</code>
function, and <em>vice versa</em>. Moreover, from the smoothing lines we drew
from almost the very first plots we made, we have seen that <code>stat_</code>
functions can do a fair amount of calculation and even model
estimation on the fly. The <code>geom_smooth()</code> function can take a range of <code>method</code>
arguments to fit LOESS, OLS, and robust regression lines, amongst others.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-modeltypes"/>
<img src="../Images/5e0f8a786d35d2776bd2ade9bc6896c2.png" alt="From top to bottom: an OLS vs robust regression comparison; a polynomial fit; and quantile regression." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-modeltypes-1.png"/><img src="../Images/57342b13ec034d19a24d373e9943a57d.png" alt="From top to bottom: an OLS vs robust regression comparison; a polynomial fit; and quantile regression." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-modeltypes-2.png"/><img src="../Images/2ebf7a3136803c7e67df9ae98d103b65.png" alt="From top to bottom: an OLS vs robust regression comparison; a polynomial fit; and quantile regression." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-modeltypes-3.png"/>
<!--
<p class="caption marginnote">-->Figure 6.1: From top to bottom: an OLS vs robust regression comparison; a polynomial fit; and quantile regression.<!--</p>-->
<!--</div>--></span>
</p>
<p>Both the <code>geom_smooth()</code> and <code>geom_quantile()</code> functions can also be
instructed to use different formulas to produce their fits. In the top
panel of Figure <a href="modeling.html#fig:ch-06-modeltypes">6.1</a>, we access the <code>MASS</code> library’s
<code>rlm</code> function to fit a robust regression line. In the second panel,
the <code>bs</code> function is invoked directly from the <code>splines</code> library in
the same way, to fit a polynominal curve to the data. This is the same
approach to directly accessing functions without loading a whole
library that we have already used several times when using functions
from the <code>scales</code> library. The <code>geom_quantile()</code> function, meanwhile,
is like a specialized version of <code>geom_smooth()</code> that can fit quantile
regression lines using a variety of methods. The <code>quantiles</code> argument
takes a vector specifying the quantiles at which to fit the lines.</p>
<div id="show-several-fits-at-once-with-a-legend" class="section level2">
<h2><span class="header-section-number">6.1</span> Show several fits at once, with a legend</h2>
<p>As we just saw in the first panel of Figure <a href="modeling.html#fig:ch-06-modeltypes">6.1</a>,
where we plotted both an OLS and a robust regression line, we can look
at several fits at once on the same plot by layering on new smoothers
with <code>geom_smooth()</code>. As long as we set the <code>color</code> and <code>fill</code>
aesthetics to different values for each fit, we can easily distinguish
them visually. However, ggplot will not draw a legend that guides us
about which fit is which. This is because the smoothers are not
logically connected to one another. They exist as separate layers.
What if we are comparing several different fits and want a legend
describing them?</p>
<p>As it turns out, <code>geom_smooth()</code> can do this via the slightly unusual
route of mapping the <code>color</code> and <code>fill</code> aesthetics to a string
describing the model we are fitting, and then using
<code>scale_color_manual()</code> and <code>scale_fill_manual()</code> to create the legend.
First we use <code>brewer.pal()</code> from the RColorBrewer library to extract
three qualitatively different colors from a larger palette. The colors
are represented as hex values. As before use the <code>::</code> convention to
use the function without loading the whole library:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb171-1" data-line-number="1">model_colors &lt;-<span class="st"> </span>RColorBrewer<span class="op">::</span><span class="kw">brewer.pal</span>(<span class="dv">3</span>, <span class="st">"Set1"</span>)</a>
<a class="sourceLine" id="cb171-2" data-line-number="2">model_colors</a></code></pre>
<pre><code>## [1] "#E41A1C" "#377EB8" "#4DAF4A"</code></pre>
<p>Then we create a plot with three different smoothers, mapping the
color and fill <em>within the <code>aes()</code> function</em> as the name of the
smoother:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb173-1" data-line-number="1">p0 &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gapminder,</a>
<a class="sourceLine" id="cb173-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">log</span>(gdpPercap), <span class="dt">y =</span> lifeExp))</a>
<a class="sourceLine" id="cb173-3" data-line-number="3"/>
<a class="sourceLine" id="cb173-4" data-line-number="4">p1 &lt;-<span class="st"> </span>p0 <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">alpha =</span> <span class="fl">0.2</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb173-5" data-line-number="5"><span class="st">    </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> <span class="st">"lm"</span>, <span class="kw">aes</span>(<span class="dt">color =</span> <span class="st">"OLS"</span>, <span class="dt">fill =</span> <span class="st">"OLS"</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb173-6" data-line-number="6"><span class="st">    </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> <span class="st">"lm"</span>, <span class="dt">formula =</span> y <span class="op">~</span><span class="st"> </span>splines<span class="op">::</span><span class="kw">bs</span>(x, <span class="dt">df =</span> <span class="dv">3</span>),</a>
<a class="sourceLine" id="cb173-7" data-line-number="7">                <span class="kw">aes</span>(<span class="dt">color =</span> <span class="st">"Cubic Spline"</span>, <span class="dt">fill =</span> <span class="st">"Cubic Spline"</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb173-8" data-line-number="8"><span class="st">    </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> <span class="st">"loess"</span>,</a>
<a class="sourceLine" id="cb173-9" data-line-number="9">                <span class="kw">aes</span>(<span class="dt">color =</span> <span class="st">"LOESS"</span>, <span class="dt">fill =</span> <span class="st">"LOESS"</span>))</a>
<a class="sourceLine" id="cb173-10" data-line-number="10"/>
<a class="sourceLine" id="cb173-11" data-line-number="11"/>
<a class="sourceLine" id="cb173-12" data-line-number="12">p1 <span class="op">+</span><span class="st"> </span><span class="kw">scale_color_manual</span>(<span class="dt">name =</span> <span class="st">"Models"</span>, <span class="dt">values =</span> model_colors) <span class="op">+</span></a>
<a class="sourceLine" id="cb173-13" data-line-number="13"><span class="st">    </span><span class="kw">scale_fill_manual</span>(<span class="dt">name =</span> <span class="st">"Models"</span>, <span class="dt">values =</span> model_colors) <span class="op">+</span></a>
<a class="sourceLine" id="cb173-14" data-line-number="14"><span class="st">    </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
<div class="figure"><span id="fig:ch-06-multimods1"/>
<p class="caption marginnote shownote">
Figure 6.2: Fitting smoothers with a legend.
</p>
<img src="../Images/5a99296ca57928e76a48f13a3687d518.png" alt="Fitting smoothers with a legend." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-multimods1-1.png"/>
</div>
<p>In a way we have cheated a little here to make the plot work. Until
now, we have always mapped aesthetics to the names of variables, not
to strings like “OLS” or “Cubic Splines”. In Chapter <a href="makeplot.html#makeplot">3</a>, when we
discussed mapping versus setting aesthetics, we saw what happened when
we tried to change the color of the points in a scatterplot by setting
them to “purple” inside the <code>aes()</code> function. The result was that the
points turned red instead, as ggplot in effect created a new variable
and labeled it with the word “purple”. We learned there that the
<code>aes()</code> function was for mapping variables to aesthetics.</p>
<p>Here we take advantage of that behavior, creating a new single-value
variable for the name of each of our models. Ggplot will properly construct the relevant guide if we call <code>scale_color_manual()</code> and <code>scale_fill_manual()</code>.<label for="tufte-mn-66" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-66" class="margin-toggle"/><span class="marginnote shownote">Remember that we have to call two scale functions because we have two mappings.</span> The result is a single plot containing not just our three smoothers, but also an appropriate legend to guide the reader.</p>
<p>These model-fitting features make ggplot very useful for exploratory
work, and make it straightforward to generate and compare model-based
trends and other summaries as part of the process of descriptive data
visualization. The various <code>stat_</code> functions are a flexible way to add
summary estimates of various kinds to plots. But we will also want
more than this, including presenting results from models we fit
ourselves.</p>
</div>
<div id="look-inside-model-objects" class="section level2">
<h2><span class="header-section-number">6.2</span> Look inside model objects</h2>
<p>Covering the details of fitting statistical models in R is beyond the
scope of this book. For a comprehensive, modern introduction to that
topic you should work your way through <span class="citation">(Gelman &amp; Hill, 2018)</span>.
<span class="citation">(Harrell, 2016)</span> is also very good on the many practical
connections between modeling and graphing data. Similarly,
<span class="citation">(Gelman, 2004)</span> provides a detailed discussion of
the use of graphics as a tool in model-checking and validation. Here
we will discuss some ways to take the models that you fit and extract
information that is easy to work with in ggplot. Our goal, as always,
is to get from however the object is stored to a tidy table of numbers
that we can plot. Most classes of statistical model in R will contain
the information we need, or will have a special set of functions, or
methods, designed to extract it.</p>
<p>We can start by learning a little more about how the output of models
is stored in R. Remember, we are always working with objects, and
objects have an internal structure consisting of named pieces.
Sometimes these are single numbers, sometimes vectors, and sometimes
lists of things like vectors, matrices, or formulas.</p>
<p>We have been working extensively with tibbles and data frames. These
store tables of data with named columns, perhaps consisting of
different classes of variable, such as integers, characters, dates, or
factors. Model objects are a little more complicated again.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb174-1" data-line-number="1">gapminder</a></code></pre>
<pre><code>## # A tibble: 1,704 x 6
##    country     continent  year lifeExp      pop gdpPercap
##    &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;
##  1 Afghanistan Asia       1952    28.8  8425333       779
##  2 Afghanistan Asia       1957    30.3  9240934       821
##  3 Afghanistan Asia       1962    32.0 10267083       853
##  4 Afghanistan Asia       1967    34.0 11537966       836
##  5 Afghanistan Asia       1972    36.1 13079460       740
##  6 Afghanistan Asia       1977    38.4 14880372       786
##  7 Afghanistan Asia       1982    39.9 12881816       978
##  8 Afghanistan Asia       1987    40.8 13867957       852
##  9 Afghanistan Asia       1992    41.7 16317921       649
## 10 Afghanistan Asia       1997    41.8 22227415       635
## # ... with 1,694 more rows</code></pre>
<p>Remember, we can use the <code>str()</code> function to learn more about the
internal structure of any object. For example, we can get some
information on what class (or classes) of object <code>gapminder</code> is, how
large it is, and what components it has. The output from
<code>str(gapminder)</code> is somewhat dense:</p>
<pre><code>## Classes 'tbl_df', 'tbl' and 'data.frame':    1704 obs. of  6 variables:
## $ country : Factor w/ 142 levels "Afghanistan",..: 1 1 ...
## $ continent: Factor w/ 5 levels "Africa","Americas",..: 3 3
##    ...
## $ year : int 1952 1957 ...
## $ lifeExp : num 28.8 ...
## $ pop : int 8425333 9240934 ...
## $ gdpPercap: num 779 ...</code></pre>
<p>There is a lot of information here about the object as a whole and
each variable in it. In the same way, statistical models in R have an
internal structure. But because models are more complex entities than
data tables, their structure is correspondingly more complicated.
There are more pieces of information, and more kinds of information,
that we might want to use. All of this information is generally stored
in or is computable from parts of a model object.</p>
<p>We can create a linear model, an ordinary OLS regression, using the
<code>gapminder</code> data. This dataset has a country-year structure that makes
an OLS specification like this the wrong one to use. But never mind
that for now. We use the <code>lm()</code> function to run the model, and store
it in an object called <code>out</code>:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb177-1" data-line-number="1">out &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="dt">formula =</span> lifeExp <span class="op">~</span><span class="st"> </span>gdpPercap <span class="op">+</span><span class="st"> </span>pop <span class="op">+</span><span class="st"> </span>continent,</a>
<a class="sourceLine" id="cb177-2" data-line-number="2">          <span class="dt">data =</span> gapminder)</a></code></pre>
<p>The first argument is the formula for the model. <code>lifeExp</code> is the
dependent variable and the tilde <code>~</code> operator is used to designate the
left- and right-hand sides of a model (including in cases, as we saw
with <code>facet_wrap()</code> where the model just has a right-hand side.)</p>
<p>Let’s look at the results by asking R to print a summary of the model.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb178-1" data-line-number="1"><span class="kw">summary</span>(out)</a></code></pre>
<pre><code>## 
## Call:
## lm(formula = lifeExp ~ gdpPercap + pop + continent, data = gapminder)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
## -49.16  -4.49   0.30   5.11  25.17 
## 
## Coefficients:
##                   Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)       4.78e+01   3.40e-01  140.82   &lt;2e-16 ***
## gdpPercap         4.50e-04   2.35e-05   19.16   &lt;2e-16 ***
## pop               6.57e-09   1.98e-09    3.33    9e-04 ***
## continentAmericas 1.35e+01   6.00e-01   22.46   &lt;2e-16 ***
## continentAsia     8.19e+00   5.71e-01   14.34   &lt;2e-16 ***
## continentEurope   1.75e+01   6.25e-01   27.97   &lt;2e-16 ***
## continentOceania  1.81e+01   1.78e+00   10.15   &lt;2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 8.37 on 1697 degrees of freedom
## Multiple R-squared:  0.582,  Adjusted R-squared:  0.581 
## F-statistic:  394 on 6 and 1697 DF,  p-value: &lt;2e-16</code></pre>
<p>When we use the <code>summary()</code> function on <code>out</code>, we are not getting a
simple feed of what’s in the model object. Instead, like any function,
<code>summary()</code> takes its input, performs some actions, and produces
output. In this case, what is printed to the console is partly
information that is stored inside the model object, and partly
information that the <code>summary()</code> function has calculated and formated
for display on the screen. Behind the scenes, <code>summary()</code> gets help
from other functions. Objects of different classes have default
<em>methods</em> associated with them, so that when the generic <code>summary()</code>
function is applied to a linear model object, the function knows to
pass the work on to a more specialized function that does a bunch of
calculations and formatting appropriate to a linear model object. We
use the same generic <code>summary()</code> function on data frames, as in
<code>summary(gapminder)</code>, but in that case a different default method is
applied.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-lm-object-schematic"/>
<img src="../Images/f5f123f28f8a54c1faa7cd02545df638.png" alt="Schematic view of a linear model object." width="65%" data-original-src="https://socviz.co/assets/ch-06-lm-object-schematic.png"/>
<!--
<p class="caption marginnote">-->Figure 6.3: Schematic view of a linear model object.<!--</p>-->
<!--</div>--></span>
</p>
<p>The output from <code>summary()</code> gives a precis of the model, but we can’t
really do any further analysis with it directly. For example, what if
we want to plot something from the model? The information necessary to
make plots is inside the <code>out</code> object, but it is not obvious how to
use it.</p>
<p>If we take a look at the structure of the model object with <code>str(out)</code>
we will find that there is a <em>lot</em> of information in there. Like most
complex objects in R, <code>out</code> is organized as a list of components or
elements. Several of these elements are themselves lists. Figure
<a href="modeling.html#fig:ch-06-lm-object-schematic">6.3</a> gives you a schematic view of the
contents of a linear model object. In this list of items, elements are
single values, some are data frames, and some are additional lists of
simpler items. Again, remember our earlier discussion where we said
objects could be thought of as being organized like a filing system:
cabinets contain drawers, and drawer may contain which may contain
pages of information, whole documents, or groups of folders with more
documents inside. As an alternative analogy, and sticking with the
image of a list, you can think of a master to-do list for a project,
where the top-level headings lead to contain additional lists of tasks
of different kinds.</p>
<p>The <code>out</code> object created by <code>lm</code> contains several different named
elements. Some, like the residual degrees of freedom in the model, are
just a single number.<label for="tufte-mn-67" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-67" class="margin-toggle"/><span class="marginnote shownote">Try <code>out$df.residual</code>
at the console.</span> Others are much larger entities, such as the data
frame used to fit the model, which is retained by default. <label for="tufte-mn-68" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-68" class="margin-toggle"/><span class="marginnote shownote">Try <code>out$model</code>, but be prepared for a lot of stuff to be printed at the console.</span> Other elements have been computed by R and then stored, such as the coefficients of the model and other quantities. You can try <code>out$coefficients</code>, <code>out$residuals</code>, and <code>out$fitted.values</code>, for instance. Others are lists themselves
(like <code>qr</code>). So you can see that the <code>summary()</code> function is selecting and printing only a small amount of core information, in comparison to what is stored in the model object.</p>
<p>Just like the tables of data we saw earlier in Section
<a href="appendix.html#tidydata">A.1.3</a>, the output of <code>summary()</code> is presented in a way that
is <em>compact</em> and <em>efficient</em> in terms of getting information across,
but also <em>untidy</em> when considered from the point of view of further
manipulation. There is a table of coefficients, but the variable names
are in the rows. The column names are awkward, and some information
(e.g. at the bottom of the output) has been calculated and printed
out, but is not stored in the model object.</p>
</div>
<div id="get-model-based-graphics-right" class="section level2">
<h2><span class="header-section-number">6.3</span> Get model-based graphics right</h2>
<p>Figures based on statistical models face all the ordinary challenges
of effective data visualization, and then some. This is because model
results usually carry a considerable extra burden of interpretation
and necessary background knowledge. The more complex the model, the
trickier it becomes to convey this information effectively, and the
easier it becomes to lead one’s audience or oneself into error. Within
the social sciences, our ability to clearly and honestly present
model-based graphics has greatly improved over the past ten or fifteen
years. Over the same period, it has become clearer that some kinds of
models are quite tricky to understand, even ones that had previously
been seen as straightforward elements of the modeling toolkit
<span class="citation">(Ai &amp; Norton, 2003; Brambor, Clark, &amp; Golder, 2006)</span>.</p>
<p>Plotting model estimates is closely connected to properly estimating
models in the first place. This means there is no substitute for
learning the statistics. You should not use graphical methods as a
substitute for understanding the model used to produce them. While
this book cannot teach you that material, we can make a few general
points about what good model-based graphics look like, and work
through some examples of how ggplot and some additional libraries can
make it easier to get good results.</p>
<div id="present-your-findings-in-substantive-terms" class="section level3">
<h3><span class="header-section-number">6.3.1</span> Present your findings in substantive terms</h3>
<p>Useful model-based plots show results in ways that are substantively
meaningful and directly interpretable with respect to the questions
the analysis is trying to answer. This means showing results in a
context where other variables in the analysis are held at sensible
values, such as their means or medians. With continuous variables, it
can often be useful to generate predicted values that cover some
substantively meaningful move across the distribution, such as from
the 25th to the 75th percentile, rather than a single-unit increment
in the variable of interest. For unordered categorical variables,
predicted values might be presented with respect to the modal category
in the data, or for a particular category of theoretical interest.
Presenting substantively interpretable findings often also means using
(and sometimes converting to) a scale that readers can easily
understand. If your model reports results in log-odds, for example,
converting the estimates to predicted probabilities will make it
easier to interpret. All of this advice is quite general. Each of
these points applies equally well to the presentation of summary
results in a table rather than a graph. There is nothing distinctively
graphical about putting the focus on the substantive meaning of your
findings.</p>
</div>
<div id="show-your-degree-of-confidence" class="section level3">
<h3><span class="header-section-number">6.3.2</span> Show your degree of confidence</h3>
<p>Much the same applies to presenting the degree of uncertainty or
confidence you have in your results. Model estimates come with various
measures of precision, confidence, credence, or significance.
Presenting and interpreting these measures is notoriously prone to
misinterpretation, or over-interpretation, as researchers and
audiences both demand more from things like confidence intervals and
p-values than these statistics can deliver. At a minimum, having
decided on an appropriate measure of model fit or the right assessment
of confidence, you should show their range when you present your
results. A family of related ggplot geoms allow you to show a range or
interval defined by position on the x-axis and then a <code>ymin</code> and
<code>ymax</code> range on the y-axis. These geoms include <code>geom_pointrange()</code>
and <code>geom_errorbar()</code>, which we will see in action shortly. A related
geom, <code>geom_ribbon()</code> uses the same arguments to draw filled areas,
and is useful for plotting ranges of y-axis values along some
continuously varying x-axis.</p>
</div>
<div id="show-your-data-when-you-can" class="section level3">
<h3><span class="header-section-number">6.3.3</span> Show your data when you can</h3>
<p>Plotting the results from a multivariate model generally means one of
two things. First, we can show what is in effect a table of
coefficients with associated measures of confidence, perhaps
organizing the coefficients into meaningful groups, or by the size of
the predicted association, or both. Second, we can show the predicted
values of some variables (rather than just a model’s coefficients)
across some range of interest. The latter approach lets us show the
original data points if we wish. The way ggplot builds graphics layer
by layer allows us to easily combine model estimates (e.g. a
regression line and an associated range) and the underlying data. In
effect these are manually-constructed versions of the
automatically-generated plots that we have been producing with
<code>geom_smooth()</code> since the beginning of this book.</p>
</div>
</div>
<div id="generate-predictions-to-graph" class="section level2">
<h2><span class="header-section-number">6.4</span> Generate predictions to graph</h2>
<p>Having fitted a model, then, we might want to get a picture of the
estimates it produces over the range of some particular variable,
holding other covariates constant at some sensible values. The
<code>predict()</code> function is a generic way of using model objects to
produce this kind of prediction. In R, “generic” functions take their
inputs and pass them along to more specific functions behind the
scenes, ones that are suited to working with the particular kind of
model object we have. The details of getting predicted values from a
OLS model, for instance, will be somewhat different from getting
predictions out of a logistic regression. But in each case we can use
the same <code>predict()</code> function, taking care to check the documentation
to see what form the results are returned in for the kind of model we
are working with. Many of the most commonly-used functions in R are
generic in this way. The <code>summary()</code> function, for example, works on
objects of many different classes, from vectors to data frames and
statistical models, producing appropriate output in each case by way
of a class-specific function in the background.</p>
<p>For <code>predict()</code> to calculate the new values for us, it needs some new
data to fit the model to. We will generate a new data frame whose
columns have the same names as the variables in the model’s original
data, but where the rows have new values. A very useful function
called <code>expand.grid()</code> will help us do this. We will give it a list of
variables, specifying the range of values we want each variable to
take. Then <code>expand.grid()</code> will generate the will multiply out the<label for="tufte-mn-69" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-69" class="margin-toggle"/><span class="marginnote shownote">The function calculates the cartesian product of the variables given to it.</span>
full range of values for all combinations of the values we give it,
thus creating a new data frame with the new data we need.</p>
<p>In the following bit of code, we use <code>min()</code> and <code>max()</code> to get the
minimum and maximum values for per capita GDP, and then create a
vector with one hundred evenly-spaced elements between the minimum and
the maximum. We hold population constant at its median, and we let
continent take all of its five available values.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb180-1" data-line-number="1">min_gdp &lt;-<span class="st"> </span><span class="kw">min</span>(gapminder<span class="op">$</span>gdpPercap)</a>
<a class="sourceLine" id="cb180-2" data-line-number="2">max_gdp &lt;-<span class="st"> </span><span class="kw">max</span>(gapminder<span class="op">$</span>gdpPercap)</a>
<a class="sourceLine" id="cb180-3" data-line-number="3">med_pop &lt;-<span class="st"> </span><span class="kw">median</span>(gapminder<span class="op">$</span>pop)</a>
<a class="sourceLine" id="cb180-4" data-line-number="4"/>
<a class="sourceLine" id="cb180-5" data-line-number="5">pred_df &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">gdpPercap =</span> (<span class="kw">seq</span>(<span class="dt">from =</span> min_gdp,</a>
<a class="sourceLine" id="cb180-6" data-line-number="6">                                        <span class="dt">to =</span> max_gdp,</a>
<a class="sourceLine" id="cb180-7" data-line-number="7">                                        <span class="dt">length.out =</span> <span class="dv">100</span>)),</a>
<a class="sourceLine" id="cb180-8" data-line-number="8">                       <span class="dt">pop =</span> med_pop,</a>
<a class="sourceLine" id="cb180-9" data-line-number="9">                       <span class="dt">continent =</span> <span class="kw">c</span>(<span class="st">"Africa"</span>, <span class="st">"Americas"</span>,</a>
<a class="sourceLine" id="cb180-10" data-line-number="10">                                     <span class="st">"Asia"</span>, <span class="st">"Europe"</span>, <span class="st">"Oceania"</span>))</a>
<a class="sourceLine" id="cb180-11" data-line-number="11"/>
<a class="sourceLine" id="cb180-12" data-line-number="12"><span class="kw">dim</span>(pred_df)</a></code></pre>
<pre><code>## [1] 500   3</code></pre>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb182-1" data-line-number="1"><span class="kw">head</span>(pred_df)</a></code></pre>
<pre><code>##   gdpPercap     pop continent
## 1   241.166 7023596    Africa
## 2  1385.428 7023596    Africa
## 3  2529.690 7023596    Africa
## 4  3673.953 7023596    Africa
## 5  4818.215 7023596    Africa
## 6  5962.477 7023596    Africa</code></pre>
<p>Now we can use <code>predict()</code>. If we give the function our new data and model, without any further argument, it will calculate the fitted values for every row in the data frame. If we specify <code>interval = 'predict'</code> as an argument, it will calculate 95% prediction intervals in addition to the point estimate.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb184-1" data-line-number="1">pred_out &lt;-<span class="st"> </span><span class="kw">predict</span>(<span class="dt">object =</span> out,</a>
<a class="sourceLine" id="cb184-2" data-line-number="2">                    <span class="dt">newdata =</span> pred_df,</a>
<a class="sourceLine" id="cb184-3" data-line-number="3">                    <span class="dt">interval =</span> <span class="st">"predict"</span>)</a>
<a class="sourceLine" id="cb184-4" data-line-number="4"><span class="kw">head</span>(pred_out)</a></code></pre>
<pre><code>##       fit     lwr     upr
## 1 47.9686 31.5477 64.3895
## 2 48.4830 32.0623 64.9037
## 3 48.9973 32.5767 65.4180
## 4 49.5117 33.0909 65.9325
## 5 50.0260 33.6050 66.4471
## 6 50.5404 34.1189 66.9619</code></pre>
<p>Because we know that, by construction, the cases in <code>pred_df</code> and <code>pred_out</code> correspond row for row,
we can bind the two data frames together by column. This method of joining or merging tables is <em>definitely not</em> recommended when you are
dealing with data.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb186-1" data-line-number="1">pred_df &lt;-<span class="st"> </span><span class="kw">cbind</span>(pred_df, pred_out)</a>
<a class="sourceLine" id="cb186-2" data-line-number="2"><span class="kw">head</span>(pred_df)</a></code></pre>
<pre><code>##   gdpPercap     pop continent  fit  lwr  upr
## 1       241 7023596    Africa 48.0 31.5 64.4
## 2      1385 7023596    Africa 48.5 32.1 64.9
## 3      2530 7023596    Africa 49.0 32.6 65.4
## 4      3674 7023596    Africa 49.5 33.1 65.9
## 5      4818 7023596    Africa 50.0 33.6 66.4
## 6      5962 7023596    Africa 50.5 34.1 67.0</code></pre>
<p>The end result is a tidy data frame, containing the predicted values
from the model for the range of values we specified. Now we can plot
the results. Because we produced a full range of predicted values, we
can decide whether or not to use all of them. Here we further subset
the predictions to just those for Europe and Africa.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb188-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> <span class="kw">subset</span>(pred_df, continent <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="st">"Europe"</span>, <span class="st">"Africa"</span>)),</a>
<a class="sourceLine" id="cb188-2" data-line-number="2">            <span class="kw">aes</span>(<span class="dt">x =</span> gdpPercap,</a>
<a class="sourceLine" id="cb188-3" data-line-number="3">                <span class="dt">y =</span> fit, <span class="dt">ymin =</span> lwr, <span class="dt">ymax =</span> upr,</a>
<a class="sourceLine" id="cb188-4" data-line-number="4">                <span class="dt">color =</span> continent,</a>
<a class="sourceLine" id="cb188-5" data-line-number="5">                <span class="dt">fill =</span> continent,</a>
<a class="sourceLine" id="cb188-6" data-line-number="6">                <span class="dt">group =</span> continent))</a>
<a class="sourceLine" id="cb188-7" data-line-number="7"/>
<a class="sourceLine" id="cb188-8" data-line-number="8">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">data =</span> <span class="kw">subset</span>(gapminder,</a>
<a class="sourceLine" id="cb188-9" data-line-number="9">                             continent <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="st">"Europe"</span>, <span class="st">"Africa"</span>)),</a>
<a class="sourceLine" id="cb188-10" data-line-number="10">               <span class="kw">aes</span>(<span class="dt">x =</span> gdpPercap, <span class="dt">y =</span> lifeExp,</a>
<a class="sourceLine" id="cb188-11" data-line-number="11">                   <span class="dt">color =</span> continent),</a>
<a class="sourceLine" id="cb188-12" data-line-number="12">               <span class="dt">alpha =</span> <span class="fl">0.5</span>,</a>
<a class="sourceLine" id="cb188-13" data-line-number="13">               <span class="dt">inherit.aes =</span> <span class="ot">FALSE</span>) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb188-14" data-line-number="14"><span class="st">    </span><span class="kw">geom_line</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb188-15" data-line-number="15"><span class="st">    </span><span class="kw">geom_ribbon</span>(<span class="dt">alpha =</span> <span class="fl">0.2</span>, <span class="dt">color =</span> <span class="ot">FALSE</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb188-16" data-line-number="16"><span class="st">    </span><span class="kw">scale_x_log10</span>(<span class="dt">labels =</span> scales<span class="op">::</span>dollar)</a></code></pre>
<div class="figure"><span id="fig:ch-06-ols-predictions"/>
<p class="caption marginnote shownote">
Figure 6.4: OLS Predictions.
</p>
<img src="../Images/0f85fa49f1edb0321e841e4bdd2d20cc.png" alt="OLS Predictions." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-ols-predictions-1.png"/>
</div>
<p>We use a new geom here to draw the area covered by the prediction
intervals: <code>geom_ribbon()</code>. It takes an <code>x</code> argument like a line, but
a <code>ymin</code> and <code>ymax</code> argument as specified in the <code>ggplot()</code> aesthetic
mapping. This defines the lower and upper limits of the prediction
interval.</p>
<p>In practice, you may not use <code>predict()</code> directly all that often.
Instead, you might write code using additional libraries that
encapsulate the process of producing predictions and plots from
models. These are especially useful when your model is a little more
complex and the interpretation of coefficients becomes trickier. This
happens, for instance, when you have a binary outcome variable and
need to convert the results of a logistic regression into predicted
probabilities, or when you have interaction terms amongst your
predictions. We will discuss some of these helper libraries in the next
few sections. However, bear in mind that <code>predict()</code> and its ability
to work safely with different classes of model underpins many of those
libraries. So it’s useful to see it in action first hand in order to
understand what it is doing.</p>
</div>
<div id="tidy-model-objects-with-broom" class="section level2">
<h2><span class="header-section-number">6.5</span> Tidy model objects with broom</h2>
<p>The <code>predict</code> method is very useful, but there are a lot of other
things we might want to do with our model output. We will use David
Robinson’s <code>broom</code> package to help us out. It is a library of
functions that help us get from the model results that R generates
to numbers that we can plot. It will take model objects and turn
pieces of them into data frames that you can use easily with ggplot.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb189-1" data-line-number="1"><span class="kw">library</span>(broom)</a></code></pre>
<p>Broom takes ggplot’s approach to tidy data and extends it to the model
objects that R produces. Its methods can tidily extract three kinds of
information. First, we can see <em>component-level</em> information about
aspects of the model itself, such as coefficients and t-statistics.
Second, we can obtain <em>observation-level</em> information about the
model’s connection to the underlying data. This includes the fitted
values and residuals for each observation in the data. And finally we
can get <em>model-level</em> information that summarizes the fit as a whole,
such as an F-statistic, the model deviance, or the r-squared. There is
a <code>broom</code> function for each of these tasks.</p>
<div id="get-component-level-statistics-with-tidy" class="section level3">
<h3><span class="header-section-number">6.5.1</span> Get component-level statistics with tidy()</h3>
<p>The <code>tidy()</code> function takes a model object and returns a data frame of
component-level information. We can work with this to make plots in a
familiar way, and much more easily than fishing inside the model
object to extract the various terms. Here is an example, using
the default results as just returned. For a more convenient display of
the results, we will pipe the object we create with <code>tidy()</code> through a
function that rounds the numeric columns of the data frame to two
decimal places. This doesn’t change anything about the object itself,
of course.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb190-1" data-line-number="1">out_comp &lt;-<span class="st"> </span><span class="kw">tidy</span>(out)</a>
<a class="sourceLine" id="cb190-2" data-line-number="2">out_comp <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round_df</span>()</a></code></pre>
<pre><code>##                term estimate std.error statistic p.value
## 1       (Intercept)    47.81      0.34    140.82       0
## 2         gdpPercap     0.00      0.00     19.16       0
## 3               pop     0.00      0.00      3.33       0
## 4 continentAmericas    13.48      0.60     22.46       0
## 5     continentAsia     8.19      0.57     14.34       0
## 6   continentEurope    17.47      0.62     27.97       0
## 7  continentOceania    18.08      1.78     10.15       0</code></pre>
<p>We are now able to treat this data frame just like all the other data
that we have seen so far.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-ols-tidy"/>
<img src="../Images/86cb8182688f582ab5bf93d7c02069cb.png" alt="Basic plot of OLS estimates." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-ols-tidy-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.5: Basic plot of OLS estimates.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb192-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(out_comp, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> term,</a>
<a class="sourceLine" id="cb192-2" data-line-number="2">                                    <span class="dt">y =</span> estimate))</a>
<a class="sourceLine" id="cb192-3" data-line-number="3"/>
<a class="sourceLine" id="cb192-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>() </a></code></pre>
<p>We can extend and clean up this plot in a variety of ways. For
example, we can tell <code>tidy()</code> to calculate confidence intervals for
the estimates, using R’s <code>confint()</code> function.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb193-1" data-line-number="1">out_conf &lt;-<span class="st"> </span><span class="kw">tidy</span>(out, <span class="dt">conf.int =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb193-2" data-line-number="2">out_conf <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round_df</span>()</a></code></pre>
<pre><code>##                term estimate std.error statistic p.value conf.low conf.high
## 1       (Intercept)    47.81      0.34    140.82       0    47.15     48.48
## 2         gdpPercap     0.00      0.00     19.16       0     0.00      0.00
## 3               pop     0.00      0.00      3.33       0     0.00      0.00
## 4 continentAmericas    13.48      0.60     22.46       0    12.30     14.65
## 5     continentAsia     8.19      0.57     14.34       0     7.07      9.31
## 6   continentEurope    17.47      0.62     27.97       0    16.25     18.70
## 7  continentOceania    18.08      1.78     10.15       0    14.59     21.58</code></pre>
<p>The convenience “not in” operator <code>%nin%</code> is available via the
<code>socviz</code> library. It does the opposite of <code>%in%</code> and selects only the
items in a first vector of characters that are not in the second.
We’ll use it to drop the intercept term from the table. We also want
to something about the labels. When fitting a model with categorical
variables, R will create coefficient names based on the variable name
and the category name, like <code>continentAmericas</code>. Normally we like to
clean these up before plotting. Most commonly, we just want to strip
away the variable name at the beginning of the coefficient label. For
this we can use <code>prefix_strip()</code>, a convenience function in the
<code>socviz</code> library. We tell it which prefixes to drop, using it to
create a new column variable in <code>out_conf</code> that corresponds to the
<code>terms</code> column, but that has nicer labels.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb195-1" data-line-number="1">out_conf &lt;-<span class="st"> </span><span class="kw">subset</span>(out_conf, term <span class="op">%nin%</span><span class="st"> "(Intercept)"</span>)</a>
<a class="sourceLine" id="cb195-2" data-line-number="2">out_conf<span class="op">$</span>nicelabs &lt;-<span class="st"> </span><span class="kw">prefix_strip</span>(out_conf<span class="op">$</span>term, <span class="st">"continent"</span>)</a></code></pre>
<p>Now we can use <code>geom_pointrange()</code> to make a figure that displays some
information about our confidence in the variable estimates, as opposed
to just the coefficients. As with the boxplots earlier, we use
<code>reorder()</code> to sort the names of the model’s terms by the <code>estimate</code>
variable, thus arranging our plot of effects from largest to smallest
in magnitude.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-ols-tidy-conf-2"/>
<img src="../Images/388eb72c4d668c76c8c461f3b459c1de.png" alt="A nicer plot of OLS estimates and confidence intervals." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-ols-tidy-conf-2-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.6: A nicer plot of OLS estimates and confidence intervals.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb196-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(out_conf, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(nicelabs, estimate),</a>
<a class="sourceLine" id="cb196-2" data-line-number="2">                                    <span class="dt">y =</span> estimate, <span class="dt">ymin =</span> conf.low, <span class="dt">ymax =</span> conf.high))</a>
<a class="sourceLine" id="cb196-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_pointrange</span>() <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>() <span class="op">+</span><span class="st"> </span><span class="kw">labs</span>(<span class="dt">x=</span><span class="st">""</span>, <span class="dt">y=</span><span class="st">"OLS Estimate"</span>)</a></code></pre>
<p>Dotplots of this kind can be very compact. The vertical axis can often be compressed quite a bit, with no loss in comprehension. In fact, they are often easier to read with much less room between the rows than given by a default square shape.</p>
</div>
<div id="get-observation-level-statistics-with-augment" class="section level3">
<h3><span class="header-section-number">6.5.2</span> Get observation-level statistics with augment()</h3>
<p>The values returned by <code>augment()</code> are all statistics calculated at
the level of the original observations. As such, they can be added on
to the data frame that the model is based on. Working from a
call to <code>augment()</code> will return a data frame with all the original
observations used in the estimation of the model, together with
columns like the following:</p>
<ul>
<li><code>.fitted</code> — The fitted values of the model.</li>
<li><code>.se.fit</code> — The standard errors of the fitted values.</li>
<li><code>.resid</code> — The residuals.</li>
<li><code>.hat</code> — The diagonal of the hat matrix.</li>
<li><code>.sigma</code> — An estimate of residual standard deviation when the corresponding observation is dropped from the model.</li>
<li><code>.cooksd</code> — Cook’s distance, a common regression diagnostic; and</li>
<li><code>.std.resid</code> — The standardized residuals.</li>
</ul>
<p>Each of these variables is named with a leading dot, for example
<code>.hat</code> rather than <code>hat</code>, and so on. This is to guard against
accidentally confusing it with (or accidentally overwriting) an
existing variable in your data with this name. The columns of
values return will differ slightly depending on the class of model
being fitted.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb197-1" data-line-number="1">out_aug &lt;-<span class="st"> </span><span class="kw">augment</span>(out)</a>
<a class="sourceLine" id="cb197-2" data-line-number="2"><span class="kw">head</span>(out_aug) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round_df</span>()</a></code></pre>
<pre><code>##   lifeExp gdpPercap      pop continent .fitted .se.fit .resid .hat .sigma .cooksd .std.resid
## 1    28.8       779  8425333      Asia    56.4    0.47  -27.6    0   8.34    0.01      -3.31
## 2    30.3       821  9240934      Asia    56.4    0.47  -26.1    0   8.34    0.00      -3.13
## 3    32.0       853 10267083      Asia    56.5    0.47  -24.5    0   8.35    0.00      -2.93
## 4    34.0       836 11537966      Asia    56.5    0.47  -22.4    0   8.35    0.00      -2.69
## 5    36.1       740 13079460      Asia    56.4    0.47  -20.3    0   8.35    0.00      -2.44
## 6    38.4       786 14880372      Asia    56.5    0.47  -18.0    0   8.36    0.00      -2.16</code></pre>
<p>By default, <code>augment()</code> will extract the available data from the model
object. This will usually include the variables used in the model
itself, but not any additional ones contained in the original data frame.
Sometimes it is useful to have these. We can add them by specifying the
<code>data</code> argument:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb199-1" data-line-number="1">out_aug &lt;-<span class="st"> </span><span class="kw">augment</span>(out, <span class="dt">data =</span> gapminder)</a>
<a class="sourceLine" id="cb199-2" data-line-number="2"><span class="kw">head</span>(out_aug) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round_df</span>()</a></code></pre>
<pre><code>##       country continent year lifeExp      pop gdpPercap .fitted .se.fit .resid .hat .sigma .cooksd
## 1 Afghanistan      Asia 1952    28.8  8425333       779    56.4    0.47  -27.6    0   8.34    0.01
## 2 Afghanistan      Asia 1957    30.3  9240934       821    56.4    0.47  -26.1    0   8.34    0.00
## 3 Afghanistan      Asia 1962    32.0 10267083       853    56.5    0.47  -24.5    0   8.35    0.00
## 4 Afghanistan      Asia 1967    34.0 11537966       836    56.5    0.47  -22.4    0   8.35    0.00
## 5 Afghanistan      Asia 1972    36.1 13079460       740    56.4    0.47  -20.3    0   8.35    0.00
## 6 Afghanistan      Asia 1977    38.4 14880372       786    56.5    0.47  -18.0    0   8.36    0.00
##   .std.resid
## 1      -3.31
## 2      -3.13
## 3      -2.93
## 4      -2.69
## 5      -2.44
## 6      -2.16</code></pre>
<p>If some rows containing missing data were dropped to fit the model,
then these will not be carried over to the augmented data frame.</p>
<p>The new columns created by <code>augment()</code> can be used to create some
standard regression plots. For example, we can plot the residuals versus the fitted values. Figure <a href="modeling.html#fig:ch-06-augresid">6.7</a> suggests,
unsurprisingly, that our country-year data has rather more structure
than is captured by our OLS model.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-augresid"/>
<img src="../Images/43cf2a062d66ee897fa121dbf99503c9.png" alt="Residuals vs Fitted Values." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-augresid-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.7: Residuals vs Fitted Values.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb201-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> out_aug,</a>
<a class="sourceLine" id="cb201-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> .fitted, <span class="dt">y =</span> .resid))</a>
<a class="sourceLine" id="cb201-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>()</a></code></pre>
</div>
<div id="get-model-level-statistics-with-glance" class="section level3">
<h3><span class="header-section-number">6.5.3</span> Get model-level statistics with glance()</h3>
<p>This function organizes the information typically presented at the
bottom of a model’s <code>summary()</code> output. By itself, it usually just
returns a table with a single row in it. But as we shall see in a
moment, the real power of <code>broom</code>’s approach is the way that it can
scale up to cases where we are grouping or subsampling our data.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb202-1" data-line-number="1"><span class="kw">glance</span>(out) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round_df</span>()</a></code></pre>
<pre><code>##   r.squared adj.r.squared sigma statistic p.value df
## 1      0.58          0.58  8.37    393.91       0  7
##     logLik     AIC     BIC deviance df.residual
## 1 -6033.83 12083.6 12127.2   118754        1697</code></pre>
<p>Broom is able to tidy (and augment, and glance at) a wide range of
model types. Not all functions are available for all classes of
model. Consult broom’s documentation for more details on what
is available. For example, here is a plot created from the tidied
output of an event-history analysis. First we generate a Cox
proportional hazards model of some survival data.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb204-1" data-line-number="1"><span class="kw">library</span>(survival)</a>
<a class="sourceLine" id="cb204-2" data-line-number="2"/>
<a class="sourceLine" id="cb204-3" data-line-number="3">out_cph &lt;-<span class="st"> </span><span class="kw">coxph</span>(<span class="kw">Surv</span>(time, status) <span class="op">~</span><span class="st"> </span>age <span class="op">+</span><span class="st"> </span>sex, <span class="dt">data =</span> lung)</a>
<a class="sourceLine" id="cb204-4" data-line-number="4">out_surv &lt;-<span class="st"> </span><span class="kw">survfit</span>(out_cph)</a></code></pre>
<p>The details of the fit are not important here, but in the first step
the <code>Surv()</code> function creates the response or outcome variable for the
proportional hazards model that is then fitted by the <code>coxph()</code>
function. Then the <code>survfit()</code> function creates the survival curve
from the model, much like we used <code>predict()</code> to generate predicted
values earlier. Try <code>summary(out_cph)</code> to see the model, and
<code>summary(out_surv)</code> to see the table of predicted values that will
form the basis for our plot. Next we tidy <code>out_surv</code> to get a data
frame, and plot it.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-survival"/>
<img src="../Images/1e961d36cc805682f5590795a7c245a4.png" alt="A Kaplan-Meier plot." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-survival-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.8: A Kaplan-Meier plot.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb205-1" data-line-number="1">out_tidy &lt;-<span class="st"> </span><span class="kw">tidy</span>(out_surv)</a>
<a class="sourceLine" id="cb205-2" data-line-number="2"/>
<a class="sourceLine" id="cb205-3" data-line-number="3">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> out_tidy, <span class="dt">mapping =</span> <span class="kw">aes</span>(time, estimate))</a>
<a class="sourceLine" id="cb205-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb205-5" data-line-number="5"><span class="st">    </span><span class="kw">geom_ribbon</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">ymin =</span> conf.low, <span class="dt">ymax =</span> conf.high), <span class="dt">alpha =</span> <span class="fl">.2</span>)</a></code></pre>
</div>
</div>
<div id="grouped-analysis-and-list-columns" class="section level2">
<h2><span class="header-section-number">6.6</span> Grouped analysis and list columns</h2>
<p>Broom makes it possible to quickly fit models to different subsets of
your data and get consistent and usable tables of results out the
other end. For example, let’s say we wanted to look at the gapminder
data by examining the relationship between life expectancy and GDP by
<em>continent</em>, for each year in the data.</p>
<p>The <code>gapminder</code> data is at bottom organized by country-years. That is
the unit of observation in the rows. If we wanted, we could take
a slice of the data manually, such as “all countries observed in Asia,
in 1962” or “all in Africa, 2002”. Here is “Europe, 1977”:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb206-1" data-line-number="1">eu77 &lt;-<span class="st"> </span>gapminder <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(continent <span class="op">==</span><span class="st"> "Europe"</span>, year <span class="op">==</span><span class="st"> </span><span class="dv">1977</span>)</a></code></pre>
<p>We could then see what the relationship between life expectancy and
GDP looked like for that continent-year group:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb207-1" data-line-number="1">fit &lt;-<span class="st"> </span><span class="kw">lm</span>(lifeExp <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(gdpPercap), <span class="dt">data =</span> eu77)</a>
<a class="sourceLine" id="cb207-2" data-line-number="2"><span class="kw">summary</span>(fit)</a></code></pre>
<pre><code>## 
## Call:
## lm(formula = lifeExp ~ log(gdpPercap), data = eu77)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
## -7.496 -1.031  0.093  1.176  3.712 
## 
## Coefficients:
##                Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)      29.489      7.161    4.12  0.00031 ***
## log(gdpPercap)    4.488      0.756    5.94  2.2e-06 ***
## ---
## Signif. codes:  
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 2.11 on 28 degrees of freedom
## Multiple R-squared:  0.557,  Adjusted R-squared:  0.541 
## F-statistic: 35.2 on 1 and 28 DF,  p-value: 2.17e-06</code></pre>
<p>With <code>dplyr</code> and <code>broom</code> we can do this for every continent-year slice
of the data in a compact and tidy way. We start with our table of
data, and then (<code>%&gt;%</code>) group the countries by <code>continent</code> and <code>year</code>
using the <code>group_by()</code> function. We introduced this grouping operation
in Chapter <a href="groupfacettx.html#groupfacettx">4</a>. Our data is reorganized first by
continent, and within continent by year. Here we will take one further
step and <em>nest</em> the data that make up each group:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb209-1" data-line-number="1">out_le &lt;-<span class="st"> </span>gapminder <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb209-2" data-line-number="2"><span class="st">    </span><span class="kw">group_by</span>(continent, year) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb209-3" data-line-number="3"><span class="st">    </span><span class="kw">nest</span>()</a>
<a class="sourceLine" id="cb209-4" data-line-number="4"/>
<a class="sourceLine" id="cb209-5" data-line-number="5">out_le</a></code></pre>
<pre><code>## # A tibble: 60 x 3
##    continent  year data             
##    &lt;fct&gt;     &lt;int&gt; &lt;list&gt;           
##  1 Asia       1952 &lt;tibble [33 × 4]&gt;
##  2 Asia       1957 &lt;tibble [33 × 4]&gt;
##  3 Asia       1962 &lt;tibble [33 × 4]&gt;
##  4 Asia       1967 &lt;tibble [33 × 4]&gt;
##  5 Asia       1972 &lt;tibble [33 × 4]&gt;
##  6 Asia       1977 &lt;tibble [33 × 4]&gt;
##  7 Asia       1982 &lt;tibble [33 × 4]&gt;
##  8 Asia       1987 &lt;tibble [33 × 4]&gt;
##  9 Asia       1992 &lt;tibble [33 × 4]&gt;
## 10 Asia       1997 &lt;tibble [33 × 4]&gt;
## # ... with 50 more rows</code></pre>
<p>Think of what <code>nest()</code> does as a more intensive version what
<code>group_by()</code> does. The resulting object is has the tabular form we
expect (it is a tibble) but it looks a little unusual. The first two
columns are the familiar <code>continent</code> and <code>year</code>. But we now also have
a new column, <code>data</code>, that contains a small table of data
corresponding to each continent-year group. This is a <em>list column</em>,
something we have not seen before. It turns out to be very useful for
bundling together complex objects (structured, in this case, as a list
of tibbles, each being a 33x4 table of data) within the rows of our
data (which remains tabular). Our “Europe 1977” fit is in there. We
can look at it, if we like, by filtering the data and then <em>unnesting</em>
the list column.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb211-1" data-line-number="1">out_le <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(continent <span class="op">==</span><span class="st"> "Europe"</span> <span class="op">&amp;</span><span class="st"> </span>year <span class="op">==</span><span class="st"> </span><span class="dv">1977</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">unnest</span>()</a></code></pre>
<pre><code>## # A tibble: 30 x 6
##    continent  year country         lifeExp    pop gdpPercap
##    &lt;fct&gt;     &lt;int&gt; &lt;fct&gt;             &lt;dbl&gt;  &lt;int&gt;     &lt;dbl&gt;
##  1 Europe     1977 Albania            68.9 2.51e⁶      3533
##  2 Europe     1977 Austria            72.2 7.57e⁶     19749
##  3 Europe     1977 Belgium            72.8 9.82e⁶     19118
##  4 Europe     1977 Bosnia and Her…    69.9 4.09e⁶      3528
##  5 Europe     1977 Bulgaria           70.8 8.80e⁶      7612
##  6 Europe     1977 Croatia            70.6 4.32e⁶     11305
##  7 Europe     1977 Czech Republic     70.7 1.02e⁷     14800
##  8 Europe     1977 Denmark            74.7 5.09e⁶     20423
##  9 Europe     1977 Finland            72.5 4.74e⁶     15605
## 10 Europe     1977 France             73.8 5.32e⁷     18293
## # ... with 20 more rows</code></pre>
<p>List columns are useful because we can act on them in a compact and
tidy way. In particular, we can pass functions along to each row of
the list column and make something happen. For example, a moment ago
we ran a regression of life expectancy and logged GDP for European
countries in 1977. We can do that for every continent-year combination
in the data. We first create a convenience function called <code>fit_ols()</code>
that takes a single argument, <code>df</code> (for data frame) and that fits the
linear model we are interested in. Then<label for="tufte-mn-70" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-70" class="margin-toggle"/><span class="marginnote shownote">The map action is an important idea in functional programming. If you have written code in other, more imperative languages you can think of it as a compact alternative to writing for … next loops. You can of course write loops like this in R. Computationally they are often not any less efficient than their functional alternatives. But mapping functions to arrays is more easily integrated into a sequence of data transformations.</span> we <em>map</em> that function to each
of our list column rows in turn. Recall from Chapter <a href="groupfacettx.html#groupfacettx">4</a>
that <code>mutate</code> creates new variables or columns on the fly within a
pipeline.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb213-1" data-line-number="1">fit_ols &lt;-<span class="st"> </span><span class="cf">function</span>(df) {</a>
<a class="sourceLine" id="cb213-2" data-line-number="2">    <span class="kw">lm</span>(lifeExp <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(gdpPercap), <span class="dt">data =</span> df)</a>
<a class="sourceLine" id="cb213-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb213-4" data-line-number="4"/>
<a class="sourceLine" id="cb213-5" data-line-number="5">out_le &lt;-<span class="st"> </span>gapminder <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb213-6" data-line-number="6"><span class="st">    </span><span class="kw">group_by</span>(continent, year) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb213-7" data-line-number="7"><span class="st">    </span><span class="kw">nest</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb213-8" data-line-number="8"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">model =</span> <span class="kw">map</span>(data, fit_ols)) </a>
<a class="sourceLine" id="cb213-9" data-line-number="9"/>
<a class="sourceLine" id="cb213-10" data-line-number="10">out_le</a></code></pre>
<pre><code>## # A tibble: 60 x 4
##    continent  year data              model   
##    &lt;fct&gt;     &lt;int&gt; &lt;list&gt;            &lt;list&gt;  
##  1 Asia       1952 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
##  2 Asia       1957 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
##  3 Asia       1962 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
##  4 Asia       1967 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
##  5 Asia       1972 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
##  6 Asia       1977 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
##  7 Asia       1982 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
##  8 Asia       1987 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
##  9 Asia       1992 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
## 10 Asia       1997 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
## # ... with 50 more rows</code></pre>
<p>Before starting the pipeline we create a new function: It
is a convenience function whose only job is to estimate a particular
OLS model on some data. Like almost everything in R, functions are a
kind of object. To make a new one, we use the slightly special
<code>function()</code> function. (Nerds love that sort of thing.) There is a
little more detail on creating functions in the Appendix. To see what <code>fit_ols()</code> looks like once it is created, type <code>fit_ols</code> without parentheses at the Console. To see what it does, try <code>fit_ols(df = gapminder)</code>, or <code>summary(fit_ols(gapminder))</code>.</p>
<p>Now we have two list columns: <code>data</code>, and <code>model</code>. The latter was
created by mapping the <code>fit_ols()</code> function to each row of <code>data</code>.
Inside each element of <code>model</code> is a linear model for that
continent-year. So we now have sixty OLS fits, one for every
continent-year grouping. Having the models inside the list column is
not much use to us in and of itself. But we can extract the
information we want while keeping things in a tidy tabular form. For clarity
we will run the pipeline from the beginning again, this time adding a few
new steps.</p>
<p>First we extract summary statistics from each model by
mapping the <code>tidy()</code> function from broom to the model list column.
Then we unnest the result, dropping the other columns in the process.
Finally, we filter out all the Intercept terms, and also drop all
observations from Oceania. In the case of the Intercepts we do this
just out of convenience. Oceania we drop just because there are so few
observations. We put the results in an object called <code>out_tidy</code>.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb215-1" data-line-number="1">fit_ols &lt;-<span class="st"> </span><span class="cf">function</span>(df) {</a>
<a class="sourceLine" id="cb215-2" data-line-number="2">    <span class="kw">lm</span>(lifeExp <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(gdpPercap), <span class="dt">data =</span> df)</a>
<a class="sourceLine" id="cb215-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb215-4" data-line-number="4"/>
<a class="sourceLine" id="cb215-5" data-line-number="5">out_tidy &lt;-<span class="st"> </span>gapminder <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb215-6" data-line-number="6"><span class="st">    </span><span class="kw">group_by</span>(continent, year) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb215-7" data-line-number="7"><span class="st">    </span><span class="kw">nest</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb215-8" data-line-number="8"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">model =</span> <span class="kw">map</span>(data, fit_ols),</a>
<a class="sourceLine" id="cb215-9" data-line-number="9">           <span class="dt">tidied =</span> <span class="kw">map</span>(model, tidy)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb215-10" data-line-number="10"><span class="st">    </span><span class="kw">unnest</span>(tidied, <span class="dt">.drop =</span> <span class="ot">TRUE</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb215-11" data-line-number="11"><span class="st">    </span><span class="kw">filter</span>(term <span class="op">%nin%</span><span class="st"> "(Intercept)"</span> <span class="op">&amp;</span></a>
<a class="sourceLine" id="cb215-12" data-line-number="12"><span class="st">           </span>continent <span class="op">%nin%</span><span class="st"> "Oceania"</span>)</a>
<a class="sourceLine" id="cb215-13" data-line-number="13"/>
<a class="sourceLine" id="cb215-14" data-line-number="14">out_tidy <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">sample_n</span>(<span class="dv">5</span>)</a></code></pre>
<pre><code>## # A tibble: 5 x 7
##   continent  year term           estimate std.error statistic      p.value
##   &lt;fct&gt;     &lt;int&gt; &lt;chr&gt;             &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;
## 1 Europe     1987 log(gdpPercap)     4.14     0.752      5.51 0.00000693  
## 2 Asia       1972 log(gdpPercap)     4.44     1.01       4.41 0.000116    
## 3 Europe     1972 log(gdpPercap)     4.51     0.757      5.95 0.00000208  
## 4 Americas   1952 log(gdpPercap)    10.4      2.72       3.84 0.000827    
## 5 Asia       1987 log(gdpPercap)     5.17     0.727      7.12 0.0000000531</code></pre>
<p>We now have tidy regression output with an estimate of the association
between log GDP per capita and life expectancy for each year, within
continents. We can plot these estimates in a way that takes advantage
of their groupiness.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb217-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> out_tidy,</a>
<a class="sourceLine" id="cb217-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year, <span class="dt">y =</span> estimate,</a>
<a class="sourceLine" id="cb217-3" data-line-number="3">                          <span class="dt">ymin =</span> estimate <span class="op">-</span><span class="st"> </span><span class="dv">2</span><span class="op">*</span>std.error,</a>
<a class="sourceLine" id="cb217-4" data-line-number="4">                          <span class="dt">ymax =</span> estimate <span class="op">+</span><span class="st"> </span><span class="dv">2</span><span class="op">*</span>std.error,</a>
<a class="sourceLine" id="cb217-5" data-line-number="5">                          <span class="dt">group =</span> continent, <span class="dt">color =</span> continent))</a>
<a class="sourceLine" id="cb217-6" data-line-number="6"/>
<a class="sourceLine" id="cb217-7" data-line-number="7">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_pointrange</span>(<span class="dt">position =</span> <span class="kw">position_dodge</span>(<span class="dt">width =</span> <span class="dv">1</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb217-8" data-line-number="8"><span class="st">    </span><span class="kw">scale_x_continuous</span>(<span class="dt">breaks =</span> <span class="kw">unique</span>(gapminder<span class="op">$</span>year)) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb217-9" data-line-number="9"><span class="st">    </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb217-10" data-line-number="10"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">"Year"</span>, <span class="dt">y =</span> <span class="st">"Estimate"</span>, <span class="dt">color =</span> <span class="st">"Continent"</span>)</a></code></pre>
<div class="figure fullwidth"><span id="fig:ch-06-dodgeplot"/>
<img src="../Images/23ad9adc4c5e240c3e5b24eb5be2ec2f.png" alt="Yearly estimates of the association between GDP and Life Expectancy, pooled by continent." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-dodgeplot-1.png"/>
<p class="caption marginnote shownote">
Figure 6.9: Yearly estimates of the association between GDP and Life Expectancy, pooled by continent.
</p>
</div>
<p>The call to <code>position_dodge()</code> within <code>geom_pointrange()</code> allows the
point ranges for each continent to be near each other within years,
instead of being plotted right on top of one another. We could have
faceted the results by continent, but doing it this way lets us see
differences in the yearly estimates much more easily. This technique is very
useful not just for cases like this, but also when you want to compare
the coefficients given by different kinds of statistical model. This
sometimes happens when we’re interested in seeing how, say, OLS
performs against some other model specification.</p>
</div>
<div id="plot-marginal-effects" class="section level2">
<h2><span class="header-section-number">6.7</span> Plot marginal effects</h2>
<p>Our earlier discussion of <code>predict()</code> was about obtaining estimates of
the average effect of some coefficient, net of the other terms in the
model. Over the past decade, estimating and plotting <em>partial</em> or
<em>marginal effects</em> from a model has become an increasingly common way
of presenting accurate and interpretively useful predictions. Interest
in marginal effects plots was stimulated by the realization that the
interpretation of terms in logistic regression models, in particular,
was trickier than it seemed—especially when there were interaction
terms in the model <span class="citation">(Ai &amp; Norton, 2003)</span>. Thomas Leeper’s
<code>margins</code> package can make these plots for us.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb218-1" data-line-number="1"><span class="kw">library</span>(margins)</a></code></pre>
<p>To see it in action, we’ll take another look at the General Social
Survey data in <code>gss_sm</code>, this time focusing on the binary variable,
<code>obama</code>.<label for="tufte-mn-71" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-71" class="margin-toggle"/><span class="marginnote shownote">As is common with retrospective questions on elections, rather more people claim to have voted for Obama than is consistent with the vote share he received in the election.</span> It is coded <code>1</code> if the respondent said they voted for Barack
Obama in the 2012 presidential election, and <code>0</code> otherwise. In this case, mostly for convenience here, the zero code includes all other answers
to the question, including those who said they voted for Mitt Romney,
those who said they did not vote, those who refused to answer, and
those who said they didn’t know who they voted for. We will fit a
logistic regression on <code>obama</code>, with <code>age</code>, <code>polviews</code>, <code>race</code>, and
<code>sex</code> as the predictors. The <code>age</code> variable is the respondent’s age in
years. The <code>sex</code> variable is coded as “Male” or “Female” with “Male”
as the reference category. The <code>race</code> variable is coded as “White”,
“Black”, or “Other” with “White” as the reference category. The
<code>polviews</code> measure is a self-reported scale of the respondent’s
political orientation from “Extremely Conservative” through “Extremely
Liberal”, with “Moderate” in the middle. We take <code>polviews</code> and create
a new variable, <code>polviews_m</code>, using the <code>relevel()</code> function to recode
“Moderate” to be the reference category. We fit the model with the
<code>glm()</code> function, and specify an interaction between <code>race</code> and <code>sex</code>.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb219-1" data-line-number="1">gss_sm<span class="op">$</span>polviews_m &lt;-<span class="st"> </span><span class="kw">relevel</span>(gss_sm<span class="op">$</span>polviews, <span class="dt">ref =</span> <span class="st">"Moderate"</span>)</a>
<a class="sourceLine" id="cb219-2" data-line-number="2"/>
<a class="sourceLine" id="cb219-3" data-line-number="3">out_bo &lt;-<span class="st"> </span><span class="kw">glm</span>(obama <span class="op">~</span><span class="st"> </span>polviews_m <span class="op">+</span><span class="st"> </span>sex<span class="op">*</span>race,</a>
<a class="sourceLine" id="cb219-4" data-line-number="4">              <span class="dt">family =</span> <span class="st">"binomial"</span>, <span class="dt">data =</span> gss_sm)</a>
<a class="sourceLine" id="cb219-5" data-line-number="5"><span class="kw">summary</span>(out_bo)</a></code></pre>
<pre><code>## 
## Call:
## glm(formula = obama ~ polviews_m + sex * race, family = "binomial", 
##     data = gss_sm)
## 
## Deviance Residuals: 
##    Min      1Q  Median      3Q     Max  
## -2.905  -0.554   0.177   0.542   2.244  
## 
## Coefficients:
##                                  Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept)                       0.29649    0.13409    2.21   0.0270 *  
## polviews_mExtremely Liberal       2.37295    0.52504    4.52  6.2e-06 ***
## polviews_mLiberal                 2.60003    0.35667    7.29  3.1e-13 ***
## polviews_mSlightly Liberal        1.29317    0.24843    5.21  1.9e-07 ***
## polviews_mSlightly Conservative  -1.35528    0.18129   -7.48  7.7e-14 ***
## polviews_mConservative           -2.34746    0.20038  -11.71  &lt; 2e-16 ***
## polviews_mExtremely Conservative -2.72738    0.38721   -7.04  1.9e-12 ***
## sexFemale                         0.25487    0.14537    1.75   0.0796 .  
## raceBlack                         3.84953    0.50132    7.68  1.6e-14 ***
## raceOther                        -0.00214    0.43576    0.00   0.9961    
## sexFemale:raceBlack              -0.19751    0.66007   -0.30   0.7648    
## sexFemale:raceOther               1.57483    0.58766    2.68   0.0074 ** 
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 2247.9  on 1697  degrees of freedom
## Residual deviance: 1345.9  on 1686  degrees of freedom
##   (1169 observations deleted due to missingness)
## AIC: 1370
## 
## Number of Fisher Scoring iterations: 6</code></pre>
<p>The summary reports the coefficients and other information. We can now
graph the data in any one of several ways. Using <code>margins()</code> we
calculate the marginal effects for each variable:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb221-1" data-line-number="1">bo_m &lt;-<span class="st"> </span><span class="kw">margins</span>(out_bo)</a>
<a class="sourceLine" id="cb221-2" data-line-number="2"><span class="kw">summary</span>(bo_m)</a></code></pre>
<pre><code>##                            factor     AME     SE        z      p   lower   upper
##            polviews_mConservative -0.4119 0.0283 -14.5394 0.0000 -0.4674 -0.3564
##  polviews_mExtremely Conservative -0.4538 0.0420 -10.7971 0.0000 -0.5361 -0.3714
##       polviews_mExtremely Liberal  0.2681 0.0295   9.0996 0.0000  0.2103  0.3258
##                 polviews_mLiberal  0.2768 0.0229  12.0736 0.0000  0.2319  0.3218
##   polviews_mSlightly Conservative -0.2658 0.0330  -8.0596 0.0000 -0.3304 -0.2011
##        polviews_mSlightly Liberal  0.1933 0.0303   6.3896 0.0000  0.1340  0.2526
##                         raceBlack  0.4032 0.0173  23.3568 0.0000  0.3694  0.4371
##                         raceOther  0.1247 0.0386   3.2297 0.0012  0.0490  0.2005
##                         sexFemale  0.0443 0.0177   2.5073 0.0122  0.0097  0.0789</code></pre>
<p>The <code>margins</code> library comes with several plot methods of its own. If
you wish, at this point you can just try <code>plot(bo_m)</code> to see a plot of
the average marginal effects, produced with the general look of a
Stata graphic. Other plot methods in the <code>margins</code> library include
<code>cplot()</code>, which visualizes marginal effects conditional on a second
variable, and <code>image()</code>, which shows predictions or marginal effects
as a filled heatmap or contour plot.</p>
<p>Alternatively, we can take results from <code>margins()</code> and plot them
ourselves. To clean up the summary a little a little, we convert it to
a tibble, then use <code>prefix_strip()</code> and <code>prefix_replace()</code> to tidy
the labels. We want to strip the <code>polviews_m</code> and <code>sex</code> prefixes, and
(to avoid ambiguity about “Other”), adjust the <code>race</code> prefix.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb223-1" data-line-number="1">bo_gg &lt;-<span class="st"> </span><span class="kw">as_tibble</span>(<span class="kw">summary</span>(bo_m))</a>
<a class="sourceLine" id="cb223-2" data-line-number="2">prefixes &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"polviews_m"</span>, <span class="st">"sex"</span>)</a>
<a class="sourceLine" id="cb223-3" data-line-number="3">bo_gg<span class="op">$</span>factor &lt;-<span class="st"> </span><span class="kw">prefix_strip</span>(bo_gg<span class="op">$</span>factor, prefixes)</a>
<a class="sourceLine" id="cb223-4" data-line-number="4">bo_gg<span class="op">$</span>factor &lt;-<span class="st"> </span><span class="kw">prefix_replace</span>(bo_gg<span class="op">$</span>factor, <span class="st">"race"</span>, <span class="st">"Race: "</span>)</a>
<a class="sourceLine" id="cb223-5" data-line-number="5"/>
<a class="sourceLine" id="cb223-6" data-line-number="6">bo_gg <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(factor, AME, lower, upper) </a></code></pre>
<pre><code>## # A tibble: 9 x 4
##   factor                     AME    lower   upper
## * &lt;chr&gt;                    &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;
## 1 Conservative           -0.412  -0.467   -0.356 
## 2 Extremely Conservative -0.454  -0.536   -0.371 
## 3 Extremely Liberal       0.268   0.210    0.326 
## 4 Liberal                 0.277   0.232    0.322 
## 5 Slightly Conservative  -0.266  -0.330   -0.201 
## 6 Slightly Liberal        0.193   0.134    0.253 
## 7 Race: Black             0.403   0.369    0.437 
## 8 Race: Other             0.125   0.0490   0.200 
## 9 Female                  0.0443  0.00967  0.0789</code></pre>
<p>Now we have a table that we can plot as we have learned:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb225-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> bo_gg, <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(factor, AME),</a>
<a class="sourceLine" id="cb225-2" data-line-number="2">                              <span class="dt">y =</span> AME, <span class="dt">ymin =</span> lower, <span class="dt">ymax =</span> upper))</a>
<a class="sourceLine" id="cb225-3" data-line-number="3"/>
<a class="sourceLine" id="cb225-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="dv">0</span>, <span class="dt">color =</span> <span class="st">"gray80"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb225-5" data-line-number="5"><span class="st">    </span><span class="kw">geom_pointrange</span>() <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb225-6" data-line-number="6"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">"Average Marginal Effect"</span>) </a></code></pre>
<div class="figure"><span id="fig:ch-06-ameplot"/>
<p class="caption marginnote shownote">
Figure 6.10: Average marginal effects plot.
</p>
<img src="../Images/2dd558be4bdff7c74737e947984bbc4f.png" alt="Average marginal effects plot." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-ameplot-1.png"/>
</div>
<p>If we are just interested in getting conditional effects for a particular
variable, then conveniently we can ask the plot methods in the
margins library to do the work calculating effects for us but without
drawing their plot. Instead, they can return the results in a format we
can easily use in ggplot, and with less need for clean up, for the
clean-up. For example, with <code>cplot()</code>:</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-condeffplot"/>
<img src="../Images/8ac0e7da6d09561016fd87ab560c2c2a.png" alt="Conditional effects plot." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-condeffplot-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.11: Conditional effects plot.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb226-1" data-line-number="1">pv_cp &lt;-<span class="st"> </span><span class="kw">cplot</span>(out_bo, <span class="dt">x =</span> <span class="st">"sex"</span>, <span class="dt">draw =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb226-2" data-line-number="2"/>
<a class="sourceLine" id="cb226-3" data-line-number="3">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> pv_cp, <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(xvals, yvals),</a>
<a class="sourceLine" id="cb226-4" data-line-number="4">                              <span class="dt">y =</span> yvals, <span class="dt">ymin =</span> lower, <span class="dt">ymax =</span> upper))</a>
<a class="sourceLine" id="cb226-5" data-line-number="5"/>
<a class="sourceLine" id="cb226-6" data-line-number="6">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="dv">0</span>, <span class="dt">color =</span> <span class="st">"gray80"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb226-7" data-line-number="7"><span class="st">    </span><span class="kw">geom_pointrange</span>() <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb226-8" data-line-number="8"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">"Conditional Effect"</span>) </a></code></pre>
<p>The margins package is under active development. It can do much more
than described here. The vignettes that come with the package provide
more extensive discussion and numerous examples.</p>
</div>
<div id="plots-from-complex-surveys" class="section level2">
<h2><span class="header-section-number">6.8</span> Plots from complex surveys</h2>
<p>Social scientists often work with data collected using a complex survey design. Survey instruments may be stratified by region or some other characteristic, contain replicate weights to make them comparable to a reference population, have a clustered structure, and so on. In Chapter <a href="groupfacettx.html#groupfacettx">4</a> we learned how calculate and then plot frequency tables of categorical variables, using some data from the General Social Survey (GSS). However, if we want accurate estimates of US households from the GSS, we will need to take the survey’s design into account, and use the survey weights provided in the dataset. Thomas Lumley’s <code>survey</code> library provides a comprehensive set of tools for addressing these issues. The tools and the theory behind them are discussed in detail in <span class="citation">Lumley (2010)</span>, and an overview of the package is provided in <span class="citation">Lumley (2004)</span>. While the functions in the <code>survey</code> package are straightforward to use and return results in a generally tidy form, the package predates the tidyverse and its conventions by several years. This means we cannot use <code>survey</code> functions directly with <code>dplyr</code>. However, Greg Freedman Ellis has written a helper package, <code>srvyr</code>, that solves this problem for us, and lets us use the <code>survey</code> library’s functions within a data analysis pipeline in a familiar way.</p>
<p>For example, the <code>gss_lon</code> data contains a small subset of measures from every wave of the GSS since its inception in 1972. It also contains several variables that describe the design of the survey and provide replicate weights for observations in various years. These technical details are described in the GSS documentation. Similar information is typically provided by other complex surveys. Here we will use this design information to calculate weighted estimates of the distribution of educational attainment by race, for selected survey years from 1976 to 2016.</p>
<p>To begin, we load the <code>survey</code> and <code>srvyr</code> libraries.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb227-1" data-line-number="1"><span class="kw">library</span>(survey)</a>
<a class="sourceLine" id="cb227-2" data-line-number="2"><span class="kw">library</span>(srvyr)</a></code></pre>
<p>Next, we take our <code>gss_lon</code> dataset and use the <code>survey</code> tools to create a new object that contains the data, as before, but with some additional information about the survey’s design:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb228-1" data-line-number="1"><span class="kw">options</span>(<span class="dt">survey.lonely.psu =</span> <span class="st">"adjust"</span>)</a>
<a class="sourceLine" id="cb228-2" data-line-number="2"><span class="kw">options</span>(<span class="dt">na.action=</span><span class="st">"na.pass"</span>)</a>
<a class="sourceLine" id="cb228-3" data-line-number="3"/>
<a class="sourceLine" id="cb228-4" data-line-number="4">gss_wt &lt;-<span class="st"> </span><span class="kw">subset</span>(gss_lon, year <span class="op">&gt;</span><span class="st"> </span><span class="dv">1974</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb228-5" data-line-number="5"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">stratvar =</span> <span class="kw">interaction</span>(year, vstrat)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb228-6" data-line-number="6"><span class="st">    </span><span class="kw">as_survey_design</span>(<span class="dt">ids =</span> vpsu,</a>
<a class="sourceLine" id="cb228-7" data-line-number="7">                     <span class="dt">strata =</span> stratvar,</a>
<a class="sourceLine" id="cb228-8" data-line-number="8">                     <span class="dt">weights =</span> wtssall,</a>
<a class="sourceLine" id="cb228-9" data-line-number="9">                     <span class="dt">nest =</span> <span class="ot">TRUE</span>)</a></code></pre>
<p>The two <code>options</code> set at the beginning provide some information to the <code>survey</code> library about how to behave. You should consult <span class="citation">Lumley (2010)</span> and the <code>survey</code> package documentation for details. The subsequent operations create <code>gss_wt</code>, an object with one additional column (<code>stratvar</code>), describing the yearly sampling strata. We use the <code>interaction()</code> function to do this. It multiplies the <code>vstrat</code> variable by the <code>year</code> variable to get a vector of stratum information for each year.<label for="tufte-mn-72" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-72" class="margin-toggle"/><span class="marginnote shownote">We have to do this because of the way the GSS codes its stratum information.</span> In the next step, we use the <code>as_survey_design()</code> function to add the key pieces of information about the survey design. It adds information about the sampling identifiers (<code>ids</code>), the strata (<code>strata</code>), and the replicate weights (<code>weights</code>). With those in place we can take advantage of a large number of specialized functions in the <code>survey</code> library that allow us to calculate properly weighted survey means or estimate models with the correct sampling specification. For example, we can easily calculate the distribution of education by race for a series of years from 1976 to 2016. We use <code>survey_mean()</code> to do this:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb229-1" data-line-number="1">out_grp &lt;-<span class="st"> </span>gss_wt <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb229-2" data-line-number="2"><span class="st">    </span><span class="kw">filter</span>(year <span class="op">%in%</span><span class="st"> </span><span class="kw">seq</span>(<span class="dv">1976</span>, <span class="dv">2016</span>, <span class="dt">by =</span> <span class="dv">4</span>)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb229-3" data-line-number="3"><span class="st">    </span><span class="kw">group_by</span>(year, race, degree) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb229-4" data-line-number="4"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">prop =</span> <span class="kw">survey_mean</span>(<span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</a>
<a class="sourceLine" id="cb229-5" data-line-number="5"/>
<a class="sourceLine" id="cb229-6" data-line-number="6">out_grp</a></code></pre>
<pre><code>## # A tibble: 150 x 5
##     year race  degree           prop prop_se
##    &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt;           &lt;dbl&gt;   &lt;dbl&gt;
##  1  1976 White Lt High School 0.328  0.0160 
##  2  1976 White High School    0.518  0.0162 
##  3  1976 White Junior College 0.0129 0.00298
##  4  1976 White Bachelor       0.101  0.00960
##  5  1976 White Graduate       0.0393 0.00644
##  6  1976 Black Lt High School 0.562  0.0611 
##  7  1976 Black High School    0.337  0.0476 
##  8  1976 Black Junior College 0.0426 0.0193 
##  9  1976 Black Bachelor       0.0581 0.0239 
## 10  1976 Black Graduate       0      0      
## # ... with 140 more rows</code></pre>
<p>The results returned in <code>out_grp</code> include standard errors. We can also ask <code>survey_mean()</code> to calculate confidence intervals for us, if we wish.</p>
<p>Grouping with <code>group_by()</code> lets us calculate counts or means for the innermost variable, grouped by the next variable “up” or “out”, in this case, <code>degree</code> by <code>race</code>, such that the proportions for <code>degree</code> will sum to one for each group in <code>race</code>, and this will be done separately for each value of <code>year</code>. If we want the <em>marginal</em> frequencies, such that the values for all combinations of <code>race</code> and <code>degree</code> sum to one within each year, we first have to interact the variables we are cross-classifying. Then we group by the new interacted variable and do the calculation as before:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb231-1" data-line-number="1">out_mrg &lt;-<span class="st"> </span>gss_wt <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb231-2" data-line-number="2"><span class="st">    </span><span class="kw">filter</span>(year <span class="op">%in%</span><span class="st"> </span><span class="kw">seq</span>(<span class="dv">1976</span>, <span class="dv">2016</span>, <span class="dt">by =</span> <span class="dv">4</span>)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb231-3" data-line-number="3"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">racedeg =</span> <span class="kw">interaction</span>(race, degree)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb231-4" data-line-number="4"><span class="st">    </span><span class="kw">group_by</span>(year, racedeg) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb231-5" data-line-number="5"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">prop =</span> <span class="kw">survey_mean</span>(<span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</a>
<a class="sourceLine" id="cb231-6" data-line-number="6"/>
<a class="sourceLine" id="cb231-7" data-line-number="7">out_mrg</a></code></pre>
<pre><code>## # A tibble: 150 x 4
##     year racedeg                 prop prop_se
##    &lt;dbl&gt; &lt;fct&gt;                  &lt;dbl&gt;   &lt;dbl&gt;
##  1  1976 White.Lt High School 0.298   0.0146 
##  2  1976 Black.Lt High School 0.0471  0.00840
##  3  1976 Other.Lt High School 0.00195 0.00138
##  4  1976 White.High School    0.471   0.0160 
##  5  1976 Black.High School    0.0283  0.00594
##  6  1976 Other.High School    0.00325 0.00166
##  7  1976 White.Junior College 0.0117  0.00268
##  8  1976 Black.Junior College 0.00357 0.00162
##  9  1976 Other.Junior College 0       0      
## 10  1976 White.Bachelor       0.0919  0.00888
## # ... with 140 more rows</code></pre>
<p>This gives us the numbers that we want and returns them in a tidy data frame. The <code>interaction()</code> function produces variable labels that are a compound of the two variables we interacted, with each combination of categories separated by a period, (such as <code>White.Graduate</code>. However, perhaps we would like to see these categories as two separate columns, one for race and one for education, as before. Because the variable labels are organized in a predictable way, we can use one of the convenient functions in the tidyverse’s <code>tidyr</code> library to separate the single variable into two columns while correctly preserving the row values. Appropriately, this function is called <code>separate()</code>.<label for="tufte-mn-73" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-73" class="margin-toggle"/><span class="marginnote shownote">The two backslashes before the period in the call to <code>separate</code> are necessary for R to interpret it literally as a period. By default in search and replace operations like this, the search terms are regular expressions. The period acts as a special character, a kind of wildcard, meaning ‘any character at all’. To make the regular expression engine treat it literally, we add one backslash before it. The backslash is an ‘escape’ character. It means ‘The next character is going to be treated differently from usual’. However, because the backslash is a special character as well, we need to add a second backslash to make sure the parser sees it properly.</span></p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb233-1" data-line-number="1">out_mrg &lt;-<span class="st"> </span>gss_wt <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb233-2" data-line-number="2"><span class="st">    </span><span class="kw">filter</span>(year <span class="op">%in%</span><span class="st"> </span><span class="kw">seq</span>(<span class="dv">1976</span>, <span class="dv">2016</span>, <span class="dt">by =</span> <span class="dv">4</span>)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb233-3" data-line-number="3"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">racedeg =</span> <span class="kw">interaction</span>(race, degree)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb233-4" data-line-number="4"><span class="st">    </span><span class="kw">group_by</span>(year, racedeg) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb233-5" data-line-number="5"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">prop =</span> <span class="kw">survey_mean</span>(<span class="dt">na.rm =</span> <span class="ot">TRUE</span>)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb233-6" data-line-number="6"><span class="st">    </span><span class="kw">separate</span>(racedeg, <span class="dt">sep =</span> <span class="st">"</span><span class="ch">\\</span><span class="st">."</span>, <span class="dt">into =</span> <span class="kw">c</span>(<span class="st">"race"</span>, <span class="st">"degree"</span>))</a>
<a class="sourceLine" id="cb233-7" data-line-number="7"/>
<a class="sourceLine" id="cb233-8" data-line-number="8">out_mrg</a></code></pre>
<pre><code>## # A tibble: 150 x 5
##     year race  degree            prop prop_se
##    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;            &lt;dbl&gt;   &lt;dbl&gt;
##  1  1976 White Lt High School 0.298   0.0146 
##  2  1976 Black Lt High School 0.0471  0.00840
##  3  1976 Other Lt High School 0.00195 0.00138
##  4  1976 White High School    0.471   0.0160 
##  5  1976 Black High School    0.0283  0.00594
##  6  1976 Other High School    0.00325 0.00166
##  7  1976 White Junior College 0.0117  0.00268
##  8  1976 Black Junior College 0.00357 0.00162
##  9  1976 Other Junior College 0       0      
## 10  1976 White Bachelor       0.0919  0.00888
## # ... with 140 more rows</code></pre>
<p>The call to <code>separate()</code> says to take the <code>racedeg</code> column, split each value when it sees a period, and reorganize the results into two columns, <code>race</code> and <code>degree</code>. This gives us a tidy table much like <code>out_grp</code>, but for the marginal frequencies.</p>
<p>Reasonable people can disagree over how best to plot a small multiple of a frequency table while faceting by year, especially when there is some measure of uncertainty attached. A barplot is the obvious approach for a single case, but when there are many years it can become difficult to compare bars across panels. This is especially the case when standard errors or confidence intervals are used in conjunction with bars.<label for="tufte-mn-74" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-74" class="margin-toggle"/><span class="marginnote shownote">Sometimes it may be preferable to show that the underlying variable is categorical, as a bar chart makes clear, and not continuous, as a line graph suggests. Here the trade-off is in favor of the line graphs as the bars are very hard to compare across facets.</span> This is sometimes called a “dynamite plot”, not because it looks amazing but because the t-shaped error bars on the tops of the columns make them look like cartoon dynamite plungers. An alternative is to use a line graph to join up the time observations, faceting on educational categories instead of year. Figure <a href="modeling.html#fig:ch-06-svyyears">6.12</a> shows the results for our GSS data in dynamite-plot form, where the error bars are defined as twice the standard error in either direction around the point estimate.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb235-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> <span class="kw">subset</span>(out_grp, race <span class="op">%nin%</span><span class="st"> "Other"</span>),</a>
<a class="sourceLine" id="cb235-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> degree, <span class="dt">y =</span> prop,</a>
<a class="sourceLine" id="cb235-3" data-line-number="3">                          <span class="dt">ymin =</span> prop <span class="op">-</span><span class="st"> </span><span class="dv">2</span><span class="op">*</span>prop_se,</a>
<a class="sourceLine" id="cb235-4" data-line-number="4">                          <span class="dt">ymax =</span> prop <span class="op">+</span><span class="st"> </span><span class="dv">2</span><span class="op">*</span>prop_se,</a>
<a class="sourceLine" id="cb235-5" data-line-number="5">                          <span class="dt">fill =</span> race,</a>
<a class="sourceLine" id="cb235-6" data-line-number="6">                          <span class="dt">color =</span> race,</a>
<a class="sourceLine" id="cb235-7" data-line-number="7">                          <span class="dt">group =</span> race))</a>
<a class="sourceLine" id="cb235-8" data-line-number="8"/>
<a class="sourceLine" id="cb235-9" data-line-number="9">dodge &lt;-<span class="st"> </span><span class="kw">position_dodge</span>(<span class="dt">width=</span><span class="fl">0.9</span>)</a>
<a class="sourceLine" id="cb235-10" data-line-number="10"/>
<a class="sourceLine" id="cb235-11" data-line-number="11">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_col</span>(<span class="dt">position =</span> dodge, <span class="dt">alpha =</span> <span class="fl">0.2</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb235-12" data-line-number="12"><span class="st">    </span><span class="kw">geom_errorbar</span>(<span class="dt">position =</span> dodge, <span class="dt">width =</span> <span class="fl">0.2</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb235-13" data-line-number="13"><span class="st">    </span><span class="kw">scale_x_discrete</span>(<span class="dt">labels =</span> scales<span class="op">::</span><span class="kw">wrap_format</span>(<span class="dv">10</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb235-14" data-line-number="14"><span class="st">    </span><span class="kw">scale_y_continuous</span>(<span class="dt">labels =</span> scales<span class="op">::</span>percent) <span class="op">+</span></a>
<a class="sourceLine" id="cb235-15" data-line-number="15"><span class="st">    </span><span class="kw">scale_color_brewer</span>(<span class="dt">type =</span> <span class="st">"qual"</span>, <span class="dt">palette =</span> <span class="st">"Dark2"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb235-16" data-line-number="16"><span class="st">    </span><span class="kw">scale_fill_brewer</span>(<span class="dt">type =</span> <span class="st">"qual"</span>, <span class="dt">palette =</span> <span class="st">"Dark2"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb235-17" data-line-number="17"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">"Educational Attainment by Race"</span>,</a>
<a class="sourceLine" id="cb235-18" data-line-number="18">         <span class="dt">subtitle =</span> <span class="st">"GSS 1976-2016"</span>,</a>
<a class="sourceLine" id="cb235-19" data-line-number="19">         <span class="dt">fill =</span> <span class="st">"Race"</span>,</a>
<a class="sourceLine" id="cb235-20" data-line-number="20">         <span class="dt">color =</span> <span class="st">"Race"</span>,</a>
<a class="sourceLine" id="cb235-21" data-line-number="21">         <span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">"Percent"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb235-22" data-line-number="22"><span class="st">    </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>year, <span class="dt">ncol =</span> <span class="dv">2</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb235-23" data-line-number="23"><span class="st">    </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
<div class="figure"><span id="fig:ch-06-svyyears"/>
<p class="caption marginnote shownote">
Figure 6.12: Weighted estimates of educational attainment for Whites and Blacks, GSS selected years 1976-2016. Faceting barplots is often a bad idea, and the more facets there are the worse an idea it is. With a small-multiple plot the viewer wants to compare across panels (in this case, over time), but this is difficult to do when the data inside the panels are categorical comparisons shown as bars (in this case, education level by group).
</p>
<img src="../Images/1fe47b8275a8fdedb0c705fdb59bee6a.png" alt="Weighted estimates of educational attainment for Whites and Blacks, GSS selected years 1976-2016. Faceting barplots is often a bad idea, and the more facets there are the worse an idea it is. With a small-multiple plot the viewer wants to compare across panels (in this case, over time), but this is difficult to do when the data inside the panels are categorical comparisons shown as bars (in this case, education level by group)." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-svyyears-1.png"/>
</div>
<p>This plot has a few cosmetic details and adjustments that we will learn more about in Chapter <a href="refineplots.html#refineplots">8</a>. As before, I encourage you to peel back the plot from the bottom, one instruction at a time, to see what changes. One useful adjustment to notice is the new call to the <code>scales</code> library to adjust the labels on the x-axis. The adjustment on the y-axis is familiar, <code>scales::percent</code> to convert the proportion to a percentage. On the x-axis, the issue is that several of the labels are rather long. If we do not adjust them they will print over one another. The <code>scales::wrap_format()</code> function will break long labels into lines. It takes a single numerical argument (here <code>10</code>) that is the maxmimum length a string can be before it is wrapped onto a new line.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-svyyears2"/>
<img src="../Images/c4e4a7dbf051feeb43ed1d4a236124ed.png" alt="Faceting by education instead." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-svyyears2-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.13: Faceting by education instead.<!--</p>-->
<!--</div>--></span>
</p>
<p>A graph like this is true to the categorical nature of the data, while showing the breakdown of groups within each year. But you should experiment with some alternatives. For example, we might decide that it is better to facet by degree category instead, and put the year on the x-axis within each panel. If we do that, then we can use <code>geom_line()</code> to show a time trend, which is more natural, and <code>geom_ribbon()</code> to show the error range. This is perhaps a better way to show the data, especially as it brings out the time trends within each degree category, and allows us to see the similarities and differences by racial classification at the same time.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb236-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> <span class="kw">subset</span>(out_grp, race <span class="op">%nin%</span><span class="st"> "Other"</span>),</a>
<a class="sourceLine" id="cb236-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year, <span class="dt">y =</span> prop, <span class="dt">ymin =</span> prop <span class="op">-</span><span class="st"> </span><span class="dv">2</span><span class="op">*</span>prop_se,</a>
<a class="sourceLine" id="cb236-3" data-line-number="3">                          <span class="dt">ymax =</span> prop <span class="op">+</span><span class="st"> </span><span class="dv">2</span><span class="op">*</span>prop_se, <span class="dt">fill =</span> race, <span class="dt">color =</span> race,</a>
<a class="sourceLine" id="cb236-4" data-line-number="4">                          <span class="dt">group =</span> race))</a>
<a class="sourceLine" id="cb236-5" data-line-number="5"/>
<a class="sourceLine" id="cb236-6" data-line-number="6">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_ribbon</span>(<span class="dt">alpha =</span> <span class="fl">0.3</span>, <span class="kw">aes</span>(<span class="dt">color =</span> <span class="ot">NULL</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb236-7" data-line-number="7"><span class="st">    </span><span class="kw">geom_line</span>() <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb236-8" data-line-number="8"><span class="st">    </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>degree, <span class="dt">ncol =</span> <span class="dv">1</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb236-9" data-line-number="9"><span class="st">    </span><span class="kw">scale_y_continuous</span>(<span class="dt">labels =</span> scales<span class="op">::</span>percent) <span class="op">+</span></a>
<a class="sourceLine" id="cb236-10" data-line-number="10"><span class="st">    </span><span class="kw">scale_color_brewer</span>(<span class="dt">type =</span> <span class="st">"qual"</span>, <span class="dt">palette =</span> <span class="st">"Dark2"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb236-11" data-line-number="11"><span class="st">    </span><span class="kw">scale_fill_brewer</span>(<span class="dt">type =</span> <span class="st">"qual"</span>, <span class="dt">palette =</span> <span class="st">"Dark2"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb236-12" data-line-number="12"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">"Educational Attainment</span><span class="ch">\n</span><span class="st">by Race"</span>,</a>
<a class="sourceLine" id="cb236-13" data-line-number="13">         <span class="dt">subtitle =</span> <span class="st">"GSS 1976-2016"</span>, <span class="dt">fill =</span> <span class="st">"Race"</span>,</a>
<a class="sourceLine" id="cb236-14" data-line-number="14">         <span class="dt">color =</span> <span class="st">"Race"</span>, <span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">"Percent"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb236-15" data-line-number="15"><span class="st">    </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
</div>
<div id="where-to-go-next-5" class="section level2">
<h2><span class="header-section-number">6.9</span> Where to go next</h2>
<p>In general, when you estimate models and want to plot the results, the difficult step is not the plotting but rather calculating and extracting the right numbers. Generating predicted values and measures of confidence or uncertainty from models requires that you understand the model you are fitting, and the function you use to fit it, especially when it involves interactions, cross-level effects, or transformations of the predictor or response scales. The details can vary substantially from model type to model type, and also with the goals of any particular analysis. It is unwise to approach them mechanically. That said, several tools exist to help you work with model objects and produce a default set of plots from them.</p>
<div id="default-plots-for-models" class="section level3">
<h3><span class="header-section-number">6.9.1</span> Default plots for models</h3>
<p>Just as model objects in R usually have a default <code>summary()</code> method,
printing out an overview tailored to the type of model it is, they
will usually have a default <code>plot()</code> method, too. Figures produced by
<code>plot()</code> are typically not generated via ggplot, but it is usually
worth exploring them. They typically make use of either R’s base
graphics or the <code>lattice</code> library <span class="citation">(Sarkar, 2008)</span>. These are two plotting systems that
we do not cover in this book. Default plot methods are easy to
examine. Let’s take a look again at our simple OLS model.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb237-1" data-line-number="1">out &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="dt">formula =</span> lifeExp <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(gdpPercap) <span class="op">+</span><span class="st"> </span>pop <span class="op">+</span><span class="st"> </span>continent, <span class="dt">data =</span> gapminder)</a></code></pre>
<p>To look at some of R’s default plots for this model, use the <code>plot()</code>
function.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb238-1" data-line-number="1"><span class="co"># Plot not shown</span></a>
<a class="sourceLine" id="cb238-2" data-line-number="2"><span class="kw">plot</span>(out, <span class="dt">which =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>), <span class="dt">ask=</span><span class="ot">FALSE</span>)</a></code></pre>
<p>The <code>which()</code> statement here selects the first two of four default
plots for this kind of model. If you want to easily reproduce base R’s
default model graphics using ggplot, the <code>ggfortify</code> library is worth
examining. It is in some ways similar to <code>broom</code>, in that it tidies
the output of model objects, but it focuses on producing a standard plot
(or group of plots) for a wide variety of model types. It does this by
defining a function called <code>autoplot()</code>. The idea is to be able to use
<code>autoplot()</code> with the output of many different kinds of model.</p>
<p>A second option worth looking at is the <code>coefplot</code> library. It
provides a quick way to produce good-quality plots of point estimates
and confidence intervals. It has the advantage of managing the
estimation of interaction effects and other occasionally tricky
calculations.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-coefplot"/>
<img src="../Images/33f6d7587e738968b391596c468ee85a.png" alt="A plot from coefplot." width="480" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-coefplot-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.14: A plot from coefplot.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb239-1" data-line-number="1"><span class="kw">library</span>(coefplot)</a>
<a class="sourceLine" id="cb239-2" data-line-number="2">out &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="dt">formula =</span> lifeExp <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(gdpPercap) <span class="op">+</span><span class="st"> </span><span class="kw">log</span>(pop) <span class="op">+</span><span class="st"> </span>continent, <span class="dt">data =</span> gapminder)</a>
<a class="sourceLine" id="cb239-3" data-line-number="3"/>
<a class="sourceLine" id="cb239-4" data-line-number="4"><span class="kw">coefplot</span>(out, <span class="dt">sort =</span> <span class="st">"magnitude"</span>, <span class="dt">intercept =</span> <span class="ot">FALSE</span>)</a></code></pre>
</div>
<div id="tools-in-development" class="section level3">
<h3><span class="header-section-number">6.9.2</span> Tools in development</h3>
<p>Tidyverse tools for modeling and model exploration are being actively developed. The <code>broom</code> and <code>margins</code> libraries continue to get more and more useful. There are also other projects worth paying attention to. The <code>infer</code> package<label for="tufte-mn-75" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-75" class="margin-toggle"/><span class="marginnote shownote"><code>infer.netlify.com</code></span> is in its early stages but can already do useful things in a pipeline-friendly way. You can install it from CRAN with <code>install.packages("infer")</code>.</p>
</div>
<div id="extensions-to-ggplot" class="section level3">
<h3><span class="header-section-number">6.9.3</span> Extensions to ggplot</h3>
<p>The GGally package provides a suite of functions designed to make producing standard but somewhat complex plots a little easier. For instance, it can produce generalized pairs plots, a useful way of quickly examining possible relationships between several different variables at once. This sort of plot is like the visual version of a correlation matrix. It shows a bivariate plot for all pairs of variables in the data. This is relatively straightforward when all the variables are continuous measures. Things get more complex when, as is often the case in the social sciences, some or all variables are categorical or otherwise limited in the range of values they can take. A generalized pairs plot can handle these cases. For example, Figure <a href="#fig:ch-06-ggallyplot"><strong>??</strong></a> shows a generalized pairs plot for five variables from the <code>organdata</code> dataset.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb240-1" data-line-number="1"><span class="kw">library</span>(GGally)</a>
<a class="sourceLine" id="cb240-2" data-line-number="2"/>
<a class="sourceLine" id="cb240-3" data-line-number="3">organdata_sm &lt;-<span class="st"> </span>organdata <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb240-4" data-line-number="4"><span class="st">    </span><span class="kw">select</span>(donors, pop_dens, pubhealth,</a>
<a class="sourceLine" id="cb240-5" data-line-number="5">           roads, consent_law)</a>
<a class="sourceLine" id="cb240-6" data-line-number="6"/>
<a class="sourceLine" id="cb240-7" data-line-number="7"><span class="kw">ggpairs</span>(<span class="dt">data =</span> organdata_sm,</a>
<a class="sourceLine" id="cb240-8" data-line-number="8">        <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">color =</span> consent_law),</a>
<a class="sourceLine" id="cb240-9" data-line-number="9">        <span class="dt">upper =</span> <span class="kw">list</span>(<span class="dt">continuous =</span> <span class="kw">wrap</span>(<span class="st">"density"</span>), <span class="dt">combo =</span> <span class="st">"box_no_facet"</span>),</a>
<a class="sourceLine" id="cb240-10" data-line-number="10">        <span class="dt">lower =</span> <span class="kw">list</span>(<span class="dt">continuous =</span> <span class="kw">wrap</span>(<span class="st">"points"</span>), <span class="dt">combo =</span> <span class="kw">wrap</span>(<span class="st">"dot_no_facet"</span>)))</a></code></pre>
<p>Multi-panel plots like this are intrinsically very rich in information. When combined with several within-panel types of representation, or any more than a modest number of variables, they can become quite complex. They should be used less for the presentation of finished work, although it is possible. More often they are a useful tool for the working researcher to quickly investigate aspects of a data set. The goal is not to pithily summarize a single point one already knows, but to open things up for further exploration.</p>

</div>
</div>
&#13;

<h2><span class="header-section-number">6.1</span> Show several fits at once, with a legend</h2>
<p>As we just saw in the first panel of Figure <a href="modeling.html#fig:ch-06-modeltypes">6.1</a>,
where we plotted both an OLS and a robust regression line, we can look
at several fits at once on the same plot by layering on new smoothers
with <code>geom_smooth()</code>. As long as we set the <code>color</code> and <code>fill</code>
aesthetics to different values for each fit, we can easily distinguish
them visually. However, ggplot will not draw a legend that guides us
about which fit is which. This is because the smoothers are not
logically connected to one another. They exist as separate layers.
What if we are comparing several different fits and want a legend
describing them?</p>
<p>As it turns out, <code>geom_smooth()</code> can do this via the slightly unusual
route of mapping the <code>color</code> and <code>fill</code> aesthetics to a string
describing the model we are fitting, and then using
<code>scale_color_manual()</code> and <code>scale_fill_manual()</code> to create the legend.
First we use <code>brewer.pal()</code> from the RColorBrewer library to extract
three qualitatively different colors from a larger palette. The colors
are represented as hex values. As before use the <code>::</code> convention to
use the function without loading the whole library:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb171-1" data-line-number="1">model_colors &lt;-<span class="st"> </span>RColorBrewer<span class="op">::</span><span class="kw">brewer.pal</span>(<span class="dv">3</span>, <span class="st">"Set1"</span>)</a>
<a class="sourceLine" id="cb171-2" data-line-number="2">model_colors</a></code></pre>
<pre><code>## [1] "#E41A1C" "#377EB8" "#4DAF4A"</code></pre>
<p>Then we create a plot with three different smoothers, mapping the
color and fill <em>within the <code>aes()</code> function</em> as the name of the
smoother:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb173-1" data-line-number="1">p0 &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gapminder,</a>
<a class="sourceLine" id="cb173-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">log</span>(gdpPercap), <span class="dt">y =</span> lifeExp))</a>
<a class="sourceLine" id="cb173-3" data-line-number="3"/>
<a class="sourceLine" id="cb173-4" data-line-number="4">p1 &lt;-<span class="st"> </span>p0 <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">alpha =</span> <span class="fl">0.2</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb173-5" data-line-number="5"><span class="st">    </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> <span class="st">"lm"</span>, <span class="kw">aes</span>(<span class="dt">color =</span> <span class="st">"OLS"</span>, <span class="dt">fill =</span> <span class="st">"OLS"</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb173-6" data-line-number="6"><span class="st">    </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> <span class="st">"lm"</span>, <span class="dt">formula =</span> y <span class="op">~</span><span class="st"> </span>splines<span class="op">::</span><span class="kw">bs</span>(x, <span class="dt">df =</span> <span class="dv">3</span>),</a>
<a class="sourceLine" id="cb173-7" data-line-number="7">                <span class="kw">aes</span>(<span class="dt">color =</span> <span class="st">"Cubic Spline"</span>, <span class="dt">fill =</span> <span class="st">"Cubic Spline"</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb173-8" data-line-number="8"><span class="st">    </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> <span class="st">"loess"</span>,</a>
<a class="sourceLine" id="cb173-9" data-line-number="9">                <span class="kw">aes</span>(<span class="dt">color =</span> <span class="st">"LOESS"</span>, <span class="dt">fill =</span> <span class="st">"LOESS"</span>))</a>
<a class="sourceLine" id="cb173-10" data-line-number="10"/>
<a class="sourceLine" id="cb173-11" data-line-number="11"/>
<a class="sourceLine" id="cb173-12" data-line-number="12">p1 <span class="op">+</span><span class="st"> </span><span class="kw">scale_color_manual</span>(<span class="dt">name =</span> <span class="st">"Models"</span>, <span class="dt">values =</span> model_colors) <span class="op">+</span></a>
<a class="sourceLine" id="cb173-13" data-line-number="13"><span class="st">    </span><span class="kw">scale_fill_manual</span>(<span class="dt">name =</span> <span class="st">"Models"</span>, <span class="dt">values =</span> model_colors) <span class="op">+</span></a>
<a class="sourceLine" id="cb173-14" data-line-number="14"><span class="st">    </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
<div class="figure"><span id="fig:ch-06-multimods1"/>
<p class="caption marginnote shownote">
Figure 6.2: Fitting smoothers with a legend.
</p>
<img src="../Images/5a99296ca57928e76a48f13a3687d518.png" alt="Fitting smoothers with a legend." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-multimods1-1.png"/>
</div>
<p>In a way we have cheated a little here to make the plot work. Until
now, we have always mapped aesthetics to the names of variables, not
to strings like “OLS” or “Cubic Splines”. In Chapter <a href="makeplot.html#makeplot">3</a>, when we
discussed mapping versus setting aesthetics, we saw what happened when
we tried to change the color of the points in a scatterplot by setting
them to “purple” inside the <code>aes()</code> function. The result was that the
points turned red instead, as ggplot in effect created a new variable
and labeled it with the word “purple”. We learned there that the
<code>aes()</code> function was for mapping variables to aesthetics.</p>
<p>Here we take advantage of that behavior, creating a new single-value
variable for the name of each of our models. Ggplot will properly construct the relevant guide if we call <code>scale_color_manual()</code> and <code>scale_fill_manual()</code>.<label for="tufte-mn-66" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-66" class="margin-toggle"/><span class="marginnote shownote">Remember that we have to call two scale functions because we have two mappings.</span> The result is a single plot containing not just our three smoothers, but also an appropriate legend to guide the reader.</p>
<p>These model-fitting features make ggplot very useful for exploratory
work, and make it straightforward to generate and compare model-based
trends and other summaries as part of the process of descriptive data
visualization. The various <code>stat_</code> functions are a flexible way to add
summary estimates of various kinds to plots. But we will also want
more than this, including presenting results from models we fit
ourselves.</p>
&#13;

<h2><span class="header-section-number">6.2</span> Look inside model objects</h2>
<p>Covering the details of fitting statistical models in R is beyond the
scope of this book. For a comprehensive, modern introduction to that
topic you should work your way through <span class="citation">(Gelman &amp; Hill, 2018)</span>.
<span class="citation">(Harrell, 2016)</span> is also very good on the many practical
connections between modeling and graphing data. Similarly,
<span class="citation">(Gelman, 2004)</span> provides a detailed discussion of
the use of graphics as a tool in model-checking and validation. Here
we will discuss some ways to take the models that you fit and extract
information that is easy to work with in ggplot. Our goal, as always,
is to get from however the object is stored to a tidy table of numbers
that we can plot. Most classes of statistical model in R will contain
the information we need, or will have a special set of functions, or
methods, designed to extract it.</p>
<p>We can start by learning a little more about how the output of models
is stored in R. Remember, we are always working with objects, and
objects have an internal structure consisting of named pieces.
Sometimes these are single numbers, sometimes vectors, and sometimes
lists of things like vectors, matrices, or formulas.</p>
<p>We have been working extensively with tibbles and data frames. These
store tables of data with named columns, perhaps consisting of
different classes of variable, such as integers, characters, dates, or
factors. Model objects are a little more complicated again.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb174-1" data-line-number="1">gapminder</a></code></pre>
<pre><code>## # A tibble: 1,704 x 6
##    country     continent  year lifeExp      pop gdpPercap
##    &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;
##  1 Afghanistan Asia       1952    28.8  8425333       779
##  2 Afghanistan Asia       1957    30.3  9240934       821
##  3 Afghanistan Asia       1962    32.0 10267083       853
##  4 Afghanistan Asia       1967    34.0 11537966       836
##  5 Afghanistan Asia       1972    36.1 13079460       740
##  6 Afghanistan Asia       1977    38.4 14880372       786
##  7 Afghanistan Asia       1982    39.9 12881816       978
##  8 Afghanistan Asia       1987    40.8 13867957       852
##  9 Afghanistan Asia       1992    41.7 16317921       649
## 10 Afghanistan Asia       1997    41.8 22227415       635
## # ... with 1,694 more rows</code></pre>
<p>Remember, we can use the <code>str()</code> function to learn more about the
internal structure of any object. For example, we can get some
information on what class (or classes) of object <code>gapminder</code> is, how
large it is, and what components it has. The output from
<code>str(gapminder)</code> is somewhat dense:</p>
<pre><code>## Classes 'tbl_df', 'tbl' and 'data.frame':    1704 obs. of  6 variables:
## $ country : Factor w/ 142 levels "Afghanistan",..: 1 1 ...
## $ continent: Factor w/ 5 levels "Africa","Americas",..: 3 3
##    ...
## $ year : int 1952 1957 ...
## $ lifeExp : num 28.8 ...
## $ pop : int 8425333 9240934 ...
## $ gdpPercap: num 779 ...</code></pre>
<p>There is a lot of information here about the object as a whole and
each variable in it. In the same way, statistical models in R have an
internal structure. But because models are more complex entities than
data tables, their structure is correspondingly more complicated.
There are more pieces of information, and more kinds of information,
that we might want to use. All of this information is generally stored
in or is computable from parts of a model object.</p>
<p>We can create a linear model, an ordinary OLS regression, using the
<code>gapminder</code> data. This dataset has a country-year structure that makes
an OLS specification like this the wrong one to use. But never mind
that for now. We use the <code>lm()</code> function to run the model, and store
it in an object called <code>out</code>:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb177-1" data-line-number="1">out &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="dt">formula =</span> lifeExp <span class="op">~</span><span class="st"> </span>gdpPercap <span class="op">+</span><span class="st"> </span>pop <span class="op">+</span><span class="st"> </span>continent,</a>
<a class="sourceLine" id="cb177-2" data-line-number="2">          <span class="dt">data =</span> gapminder)</a></code></pre>
<p>The first argument is the formula for the model. <code>lifeExp</code> is the
dependent variable and the tilde <code>~</code> operator is used to designate the
left- and right-hand sides of a model (including in cases, as we saw
with <code>facet_wrap()</code> where the model just has a right-hand side.)</p>
<p>Let’s look at the results by asking R to print a summary of the model.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb178-1" data-line-number="1"><span class="kw">summary</span>(out)</a></code></pre>
<pre><code>## 
## Call:
## lm(formula = lifeExp ~ gdpPercap + pop + continent, data = gapminder)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
## -49.16  -4.49   0.30   5.11  25.17 
## 
## Coefficients:
##                   Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)       4.78e+01   3.40e-01  140.82   &lt;2e-16 ***
## gdpPercap         4.50e-04   2.35e-05   19.16   &lt;2e-16 ***
## pop               6.57e-09   1.98e-09    3.33    9e-04 ***
## continentAmericas 1.35e+01   6.00e-01   22.46   &lt;2e-16 ***
## continentAsia     8.19e+00   5.71e-01   14.34   &lt;2e-16 ***
## continentEurope   1.75e+01   6.25e-01   27.97   &lt;2e-16 ***
## continentOceania  1.81e+01   1.78e+00   10.15   &lt;2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 8.37 on 1697 degrees of freedom
## Multiple R-squared:  0.582,  Adjusted R-squared:  0.581 
## F-statistic:  394 on 6 and 1697 DF,  p-value: &lt;2e-16</code></pre>
<p>When we use the <code>summary()</code> function on <code>out</code>, we are not getting a
simple feed of what’s in the model object. Instead, like any function,
<code>summary()</code> takes its input, performs some actions, and produces
output. In this case, what is printed to the console is partly
information that is stored inside the model object, and partly
information that the <code>summary()</code> function has calculated and formated
for display on the screen. Behind the scenes, <code>summary()</code> gets help
from other functions. Objects of different classes have default
<em>methods</em> associated with them, so that when the generic <code>summary()</code>
function is applied to a linear model object, the function knows to
pass the work on to a more specialized function that does a bunch of
calculations and formatting appropriate to a linear model object. We
use the same generic <code>summary()</code> function on data frames, as in
<code>summary(gapminder)</code>, but in that case a different default method is
applied.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-lm-object-schematic"/>
<img src="../Images/f5f123f28f8a54c1faa7cd02545df638.png" alt="Schematic view of a linear model object." width="65%" data-original-src="https://socviz.co/assets/ch-06-lm-object-schematic.png"/>
<!--
<p class="caption marginnote">-->Figure 6.3: Schematic view of a linear model object.<!--</p>-->
<!--</div>--></span>
</p>
<p>The output from <code>summary()</code> gives a precis of the model, but we can’t
really do any further analysis with it directly. For example, what if
we want to plot something from the model? The information necessary to
make plots is inside the <code>out</code> object, but it is not obvious how to
use it.</p>
<p>If we take a look at the structure of the model object with <code>str(out)</code>
we will find that there is a <em>lot</em> of information in there. Like most
complex objects in R, <code>out</code> is organized as a list of components or
elements. Several of these elements are themselves lists. Figure
<a href="modeling.html#fig:ch-06-lm-object-schematic">6.3</a> gives you a schematic view of the
contents of a linear model object. In this list of items, elements are
single values, some are data frames, and some are additional lists of
simpler items. Again, remember our earlier discussion where we said
objects could be thought of as being organized like a filing system:
cabinets contain drawers, and drawer may contain which may contain
pages of information, whole documents, or groups of folders with more
documents inside. As an alternative analogy, and sticking with the
image of a list, you can think of a master to-do list for a project,
where the top-level headings lead to contain additional lists of tasks
of different kinds.</p>
<p>The <code>out</code> object created by <code>lm</code> contains several different named
elements. Some, like the residual degrees of freedom in the model, are
just a single number.<label for="tufte-mn-67" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-67" class="margin-toggle"/><span class="marginnote shownote">Try <code>out$df.residual</code>
at the console.</span> Others are much larger entities, such as the data
frame used to fit the model, which is retained by default. <label for="tufte-mn-68" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-68" class="margin-toggle"/><span class="marginnote shownote">Try <code>out$model</code>, but be prepared for a lot of stuff to be printed at the console.</span> Other elements have been computed by R and then stored, such as the coefficients of the model and other quantities. You can try <code>out$coefficients</code>, <code>out$residuals</code>, and <code>out$fitted.values</code>, for instance. Others are lists themselves
(like <code>qr</code>). So you can see that the <code>summary()</code> function is selecting and printing only a small amount of core information, in comparison to what is stored in the model object.</p>
<p>Just like the tables of data we saw earlier in Section
<a href="appendix.html#tidydata">A.1.3</a>, the output of <code>summary()</code> is presented in a way that
is <em>compact</em> and <em>efficient</em> in terms of getting information across,
but also <em>untidy</em> when considered from the point of view of further
manipulation. There is a table of coefficients, but the variable names
are in the rows. The column names are awkward, and some information
(e.g. at the bottom of the output) has been calculated and printed
out, but is not stored in the model object.</p>
&#13;

<h2><span class="header-section-number">6.3</span> Get model-based graphics right</h2>
<p>Figures based on statistical models face all the ordinary challenges
of effective data visualization, and then some. This is because model
results usually carry a considerable extra burden of interpretation
and necessary background knowledge. The more complex the model, the
trickier it becomes to convey this information effectively, and the
easier it becomes to lead one’s audience or oneself into error. Within
the social sciences, our ability to clearly and honestly present
model-based graphics has greatly improved over the past ten or fifteen
years. Over the same period, it has become clearer that some kinds of
models are quite tricky to understand, even ones that had previously
been seen as straightforward elements of the modeling toolkit
<span class="citation">(Ai &amp; Norton, 2003; Brambor, Clark, &amp; Golder, 2006)</span>.</p>
<p>Plotting model estimates is closely connected to properly estimating
models in the first place. This means there is no substitute for
learning the statistics. You should not use graphical methods as a
substitute for understanding the model used to produce them. While
this book cannot teach you that material, we can make a few general
points about what good model-based graphics look like, and work
through some examples of how ggplot and some additional libraries can
make it easier to get good results.</p>
<div id="present-your-findings-in-substantive-terms" class="section level3">
<h3><span class="header-section-number">6.3.1</span> Present your findings in substantive terms</h3>
<p>Useful model-based plots show results in ways that are substantively
meaningful and directly interpretable with respect to the questions
the analysis is trying to answer. This means showing results in a
context where other variables in the analysis are held at sensible
values, such as their means or medians. With continuous variables, it
can often be useful to generate predicted values that cover some
substantively meaningful move across the distribution, such as from
the 25th to the 75th percentile, rather than a single-unit increment
in the variable of interest. For unordered categorical variables,
predicted values might be presented with respect to the modal category
in the data, or for a particular category of theoretical interest.
Presenting substantively interpretable findings often also means using
(and sometimes converting to) a scale that readers can easily
understand. If your model reports results in log-odds, for example,
converting the estimates to predicted probabilities will make it
easier to interpret. All of this advice is quite general. Each of
these points applies equally well to the presentation of summary
results in a table rather than a graph. There is nothing distinctively
graphical about putting the focus on the substantive meaning of your
findings.</p>
</div>
<div id="show-your-degree-of-confidence" class="section level3">
<h3><span class="header-section-number">6.3.2</span> Show your degree of confidence</h3>
<p>Much the same applies to presenting the degree of uncertainty or
confidence you have in your results. Model estimates come with various
measures of precision, confidence, credence, or significance.
Presenting and interpreting these measures is notoriously prone to
misinterpretation, or over-interpretation, as researchers and
audiences both demand more from things like confidence intervals and
p-values than these statistics can deliver. At a minimum, having
decided on an appropriate measure of model fit or the right assessment
of confidence, you should show their range when you present your
results. A family of related ggplot geoms allow you to show a range or
interval defined by position on the x-axis and then a <code>ymin</code> and
<code>ymax</code> range on the y-axis. These geoms include <code>geom_pointrange()</code>
and <code>geom_errorbar()</code>, which we will see in action shortly. A related
geom, <code>geom_ribbon()</code> uses the same arguments to draw filled areas,
and is useful for plotting ranges of y-axis values along some
continuously varying x-axis.</p>
</div>
<div id="show-your-data-when-you-can" class="section level3">
<h3><span class="header-section-number">6.3.3</span> Show your data when you can</h3>
<p>Plotting the results from a multivariate model generally means one of
two things. First, we can show what is in effect a table of
coefficients with associated measures of confidence, perhaps
organizing the coefficients into meaningful groups, or by the size of
the predicted association, or both. Second, we can show the predicted
values of some variables (rather than just a model’s coefficients)
across some range of interest. The latter approach lets us show the
original data points if we wish. The way ggplot builds graphics layer
by layer allows us to easily combine model estimates (e.g. a
regression line and an associated range) and the underlying data. In
effect these are manually-constructed versions of the
automatically-generated plots that we have been producing with
<code>geom_smooth()</code> since the beginning of this book.</p>
</div>
&#13;

<h3><span class="header-section-number">6.3.1</span> Present your findings in substantive terms</h3>
<p>Useful model-based plots show results in ways that are substantively
meaningful and directly interpretable with respect to the questions
the analysis is trying to answer. This means showing results in a
context where other variables in the analysis are held at sensible
values, such as their means or medians. With continuous variables, it
can often be useful to generate predicted values that cover some
substantively meaningful move across the distribution, such as from
the 25th to the 75th percentile, rather than a single-unit increment
in the variable of interest. For unordered categorical variables,
predicted values might be presented with respect to the modal category
in the data, or for a particular category of theoretical interest.
Presenting substantively interpretable findings often also means using
(and sometimes converting to) a scale that readers can easily
understand. If your model reports results in log-odds, for example,
converting the estimates to predicted probabilities will make it
easier to interpret. All of this advice is quite general. Each of
these points applies equally well to the presentation of summary
results in a table rather than a graph. There is nothing distinctively
graphical about putting the focus on the substantive meaning of your
findings.</p>
&#13;

<h3><span class="header-section-number">6.3.2</span> Show your degree of confidence</h3>
<p>Much the same applies to presenting the degree of uncertainty or
confidence you have in your results. Model estimates come with various
measures of precision, confidence, credence, or significance.
Presenting and interpreting these measures is notoriously prone to
misinterpretation, or over-interpretation, as researchers and
audiences both demand more from things like confidence intervals and
p-values than these statistics can deliver. At a minimum, having
decided on an appropriate measure of model fit or the right assessment
of confidence, you should show their range when you present your
results. A family of related ggplot geoms allow you to show a range or
interval defined by position on the x-axis and then a <code>ymin</code> and
<code>ymax</code> range on the y-axis. These geoms include <code>geom_pointrange()</code>
and <code>geom_errorbar()</code>, which we will see in action shortly. A related
geom, <code>geom_ribbon()</code> uses the same arguments to draw filled areas,
and is useful for plotting ranges of y-axis values along some
continuously varying x-axis.</p>
&#13;

<h3><span class="header-section-number">6.3.3</span> Show your data when you can</h3>
<p>Plotting the results from a multivariate model generally means one of
two things. First, we can show what is in effect a table of
coefficients with associated measures of confidence, perhaps
organizing the coefficients into meaningful groups, or by the size of
the predicted association, or both. Second, we can show the predicted
values of some variables (rather than just a model’s coefficients)
across some range of interest. The latter approach lets us show the
original data points if we wish. The way ggplot builds graphics layer
by layer allows us to easily combine model estimates (e.g. a
regression line and an associated range) and the underlying data. In
effect these are manually-constructed versions of the
automatically-generated plots that we have been producing with
<code>geom_smooth()</code> since the beginning of this book.</p>
&#13;

<h2><span class="header-section-number">6.4</span> Generate predictions to graph</h2>
<p>Having fitted a model, then, we might want to get a picture of the
estimates it produces over the range of some particular variable,
holding other covariates constant at some sensible values. The
<code>predict()</code> function is a generic way of using model objects to
produce this kind of prediction. In R, “generic” functions take their
inputs and pass them along to more specific functions behind the
scenes, ones that are suited to working with the particular kind of
model object we have. The details of getting predicted values from a
OLS model, for instance, will be somewhat different from getting
predictions out of a logistic regression. But in each case we can use
the same <code>predict()</code> function, taking care to check the documentation
to see what form the results are returned in for the kind of model we
are working with. Many of the most commonly-used functions in R are
generic in this way. The <code>summary()</code> function, for example, works on
objects of many different classes, from vectors to data frames and
statistical models, producing appropriate output in each case by way
of a class-specific function in the background.</p>
<p>For <code>predict()</code> to calculate the new values for us, it needs some new
data to fit the model to. We will generate a new data frame whose
columns have the same names as the variables in the model’s original
data, but where the rows have new values. A very useful function
called <code>expand.grid()</code> will help us do this. We will give it a list of
variables, specifying the range of values we want each variable to
take. Then <code>expand.grid()</code> will generate the will multiply out the<label for="tufte-mn-69" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-69" class="margin-toggle"/><span class="marginnote shownote">The function calculates the cartesian product of the variables given to it.</span>
full range of values for all combinations of the values we give it,
thus creating a new data frame with the new data we need.</p>
<p>In the following bit of code, we use <code>min()</code> and <code>max()</code> to get the
minimum and maximum values for per capita GDP, and then create a
vector with one hundred evenly-spaced elements between the minimum and
the maximum. We hold population constant at its median, and we let
continent take all of its five available values.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb180-1" data-line-number="1">min_gdp &lt;-<span class="st"> </span><span class="kw">min</span>(gapminder<span class="op">$</span>gdpPercap)</a>
<a class="sourceLine" id="cb180-2" data-line-number="2">max_gdp &lt;-<span class="st"> </span><span class="kw">max</span>(gapminder<span class="op">$</span>gdpPercap)</a>
<a class="sourceLine" id="cb180-3" data-line-number="3">med_pop &lt;-<span class="st"> </span><span class="kw">median</span>(gapminder<span class="op">$</span>pop)</a>
<a class="sourceLine" id="cb180-4" data-line-number="4"/>
<a class="sourceLine" id="cb180-5" data-line-number="5">pred_df &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">gdpPercap =</span> (<span class="kw">seq</span>(<span class="dt">from =</span> min_gdp,</a>
<a class="sourceLine" id="cb180-6" data-line-number="6">                                        <span class="dt">to =</span> max_gdp,</a>
<a class="sourceLine" id="cb180-7" data-line-number="7">                                        <span class="dt">length.out =</span> <span class="dv">100</span>)),</a>
<a class="sourceLine" id="cb180-8" data-line-number="8">                       <span class="dt">pop =</span> med_pop,</a>
<a class="sourceLine" id="cb180-9" data-line-number="9">                       <span class="dt">continent =</span> <span class="kw">c</span>(<span class="st">"Africa"</span>, <span class="st">"Americas"</span>,</a>
<a class="sourceLine" id="cb180-10" data-line-number="10">                                     <span class="st">"Asia"</span>, <span class="st">"Europe"</span>, <span class="st">"Oceania"</span>))</a>
<a class="sourceLine" id="cb180-11" data-line-number="11"/>
<a class="sourceLine" id="cb180-12" data-line-number="12"><span class="kw">dim</span>(pred_df)</a></code></pre>
<pre><code>## [1] 500   3</code></pre>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb182-1" data-line-number="1"><span class="kw">head</span>(pred_df)</a></code></pre>
<pre><code>##   gdpPercap     pop continent
## 1   241.166 7023596    Africa
## 2  1385.428 7023596    Africa
## 3  2529.690 7023596    Africa
## 4  3673.953 7023596    Africa
## 5  4818.215 7023596    Africa
## 6  5962.477 7023596    Africa</code></pre>
<p>Now we can use <code>predict()</code>. If we give the function our new data and model, without any further argument, it will calculate the fitted values for every row in the data frame. If we specify <code>interval = 'predict'</code> as an argument, it will calculate 95% prediction intervals in addition to the point estimate.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb184-1" data-line-number="1">pred_out &lt;-<span class="st"> </span><span class="kw">predict</span>(<span class="dt">object =</span> out,</a>
<a class="sourceLine" id="cb184-2" data-line-number="2">                    <span class="dt">newdata =</span> pred_df,</a>
<a class="sourceLine" id="cb184-3" data-line-number="3">                    <span class="dt">interval =</span> <span class="st">"predict"</span>)</a>
<a class="sourceLine" id="cb184-4" data-line-number="4"><span class="kw">head</span>(pred_out)</a></code></pre>
<pre><code>##       fit     lwr     upr
## 1 47.9686 31.5477 64.3895
## 2 48.4830 32.0623 64.9037
## 3 48.9973 32.5767 65.4180
## 4 49.5117 33.0909 65.9325
## 5 50.0260 33.6050 66.4471
## 6 50.5404 34.1189 66.9619</code></pre>
<p>Because we know that, by construction, the cases in <code>pred_df</code> and <code>pred_out</code> correspond row for row,
we can bind the two data frames together by column. This method of joining or merging tables is <em>definitely not</em> recommended when you are
dealing with data.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb186-1" data-line-number="1">pred_df &lt;-<span class="st"> </span><span class="kw">cbind</span>(pred_df, pred_out)</a>
<a class="sourceLine" id="cb186-2" data-line-number="2"><span class="kw">head</span>(pred_df)</a></code></pre>
<pre><code>##   gdpPercap     pop continent  fit  lwr  upr
## 1       241 7023596    Africa 48.0 31.5 64.4
## 2      1385 7023596    Africa 48.5 32.1 64.9
## 3      2530 7023596    Africa 49.0 32.6 65.4
## 4      3674 7023596    Africa 49.5 33.1 65.9
## 5      4818 7023596    Africa 50.0 33.6 66.4
## 6      5962 7023596    Africa 50.5 34.1 67.0</code></pre>
<p>The end result is a tidy data frame, containing the predicted values
from the model for the range of values we specified. Now we can plot
the results. Because we produced a full range of predicted values, we
can decide whether or not to use all of them. Here we further subset
the predictions to just those for Europe and Africa.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb188-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> <span class="kw">subset</span>(pred_df, continent <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="st">"Europe"</span>, <span class="st">"Africa"</span>)),</a>
<a class="sourceLine" id="cb188-2" data-line-number="2">            <span class="kw">aes</span>(<span class="dt">x =</span> gdpPercap,</a>
<a class="sourceLine" id="cb188-3" data-line-number="3">                <span class="dt">y =</span> fit, <span class="dt">ymin =</span> lwr, <span class="dt">ymax =</span> upr,</a>
<a class="sourceLine" id="cb188-4" data-line-number="4">                <span class="dt">color =</span> continent,</a>
<a class="sourceLine" id="cb188-5" data-line-number="5">                <span class="dt">fill =</span> continent,</a>
<a class="sourceLine" id="cb188-6" data-line-number="6">                <span class="dt">group =</span> continent))</a>
<a class="sourceLine" id="cb188-7" data-line-number="7"/>
<a class="sourceLine" id="cb188-8" data-line-number="8">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">data =</span> <span class="kw">subset</span>(gapminder,</a>
<a class="sourceLine" id="cb188-9" data-line-number="9">                             continent <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="st">"Europe"</span>, <span class="st">"Africa"</span>)),</a>
<a class="sourceLine" id="cb188-10" data-line-number="10">               <span class="kw">aes</span>(<span class="dt">x =</span> gdpPercap, <span class="dt">y =</span> lifeExp,</a>
<a class="sourceLine" id="cb188-11" data-line-number="11">                   <span class="dt">color =</span> continent),</a>
<a class="sourceLine" id="cb188-12" data-line-number="12">               <span class="dt">alpha =</span> <span class="fl">0.5</span>,</a>
<a class="sourceLine" id="cb188-13" data-line-number="13">               <span class="dt">inherit.aes =</span> <span class="ot">FALSE</span>) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb188-14" data-line-number="14"><span class="st">    </span><span class="kw">geom_line</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb188-15" data-line-number="15"><span class="st">    </span><span class="kw">geom_ribbon</span>(<span class="dt">alpha =</span> <span class="fl">0.2</span>, <span class="dt">color =</span> <span class="ot">FALSE</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb188-16" data-line-number="16"><span class="st">    </span><span class="kw">scale_x_log10</span>(<span class="dt">labels =</span> scales<span class="op">::</span>dollar)</a></code></pre>
<div class="figure"><span id="fig:ch-06-ols-predictions"/>
<p class="caption marginnote shownote">
Figure 6.4: OLS Predictions.
</p>
<img src="../Images/0f85fa49f1edb0321e841e4bdd2d20cc.png" alt="OLS Predictions." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-ols-predictions-1.png"/>
</div>
<p>We use a new geom here to draw the area covered by the prediction
intervals: <code>geom_ribbon()</code>. It takes an <code>x</code> argument like a line, but
a <code>ymin</code> and <code>ymax</code> argument as specified in the <code>ggplot()</code> aesthetic
mapping. This defines the lower and upper limits of the prediction
interval.</p>
<p>In practice, you may not use <code>predict()</code> directly all that often.
Instead, you might write code using additional libraries that
encapsulate the process of producing predictions and plots from
models. These are especially useful when your model is a little more
complex and the interpretation of coefficients becomes trickier. This
happens, for instance, when you have a binary outcome variable and
need to convert the results of a logistic regression into predicted
probabilities, or when you have interaction terms amongst your
predictions. We will discuss some of these helper libraries in the next
few sections. However, bear in mind that <code>predict()</code> and its ability
to work safely with different classes of model underpins many of those
libraries. So it’s useful to see it in action first hand in order to
understand what it is doing.</p>
&#13;

<h2><span class="header-section-number">6.5</span> Tidy model objects with broom</h2>
<p>The <code>predict</code> method is very useful, but there are a lot of other
things we might want to do with our model output. We will use David
Robinson’s <code>broom</code> package to help us out. It is a library of
functions that help us get from the model results that R generates
to numbers that we can plot. It will take model objects and turn
pieces of them into data frames that you can use easily with ggplot.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb189-1" data-line-number="1"><span class="kw">library</span>(broom)</a></code></pre>
<p>Broom takes ggplot’s approach to tidy data and extends it to the model
objects that R produces. Its methods can tidily extract three kinds of
information. First, we can see <em>component-level</em> information about
aspects of the model itself, such as coefficients and t-statistics.
Second, we can obtain <em>observation-level</em> information about the
model’s connection to the underlying data. This includes the fitted
values and residuals for each observation in the data. And finally we
can get <em>model-level</em> information that summarizes the fit as a whole,
such as an F-statistic, the model deviance, or the r-squared. There is
a <code>broom</code> function for each of these tasks.</p>
<div id="get-component-level-statistics-with-tidy" class="section level3">
<h3><span class="header-section-number">6.5.1</span> Get component-level statistics with tidy()</h3>
<p>The <code>tidy()</code> function takes a model object and returns a data frame of
component-level information. We can work with this to make plots in a
familiar way, and much more easily than fishing inside the model
object to extract the various terms. Here is an example, using
the default results as just returned. For a more convenient display of
the results, we will pipe the object we create with <code>tidy()</code> through a
function that rounds the numeric columns of the data frame to two
decimal places. This doesn’t change anything about the object itself,
of course.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb190-1" data-line-number="1">out_comp &lt;-<span class="st"> </span><span class="kw">tidy</span>(out)</a>
<a class="sourceLine" id="cb190-2" data-line-number="2">out_comp <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round_df</span>()</a></code></pre>
<pre><code>##                term estimate std.error statistic p.value
## 1       (Intercept)    47.81      0.34    140.82       0
## 2         gdpPercap     0.00      0.00     19.16       0
## 3               pop     0.00      0.00      3.33       0
## 4 continentAmericas    13.48      0.60     22.46       0
## 5     continentAsia     8.19      0.57     14.34       0
## 6   continentEurope    17.47      0.62     27.97       0
## 7  continentOceania    18.08      1.78     10.15       0</code></pre>
<p>We are now able to treat this data frame just like all the other data
that we have seen so far.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-ols-tidy"/>
<img src="../Images/86cb8182688f582ab5bf93d7c02069cb.png" alt="Basic plot of OLS estimates." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-ols-tidy-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.5: Basic plot of OLS estimates.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb192-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(out_comp, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> term,</a>
<a class="sourceLine" id="cb192-2" data-line-number="2">                                    <span class="dt">y =</span> estimate))</a>
<a class="sourceLine" id="cb192-3" data-line-number="3"/>
<a class="sourceLine" id="cb192-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>() </a></code></pre>
<p>We can extend and clean up this plot in a variety of ways. For
example, we can tell <code>tidy()</code> to calculate confidence intervals for
the estimates, using R’s <code>confint()</code> function.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb193-1" data-line-number="1">out_conf &lt;-<span class="st"> </span><span class="kw">tidy</span>(out, <span class="dt">conf.int =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb193-2" data-line-number="2">out_conf <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round_df</span>()</a></code></pre>
<pre><code>##                term estimate std.error statistic p.value conf.low conf.high
## 1       (Intercept)    47.81      0.34    140.82       0    47.15     48.48
## 2         gdpPercap     0.00      0.00     19.16       0     0.00      0.00
## 3               pop     0.00      0.00      3.33       0     0.00      0.00
## 4 continentAmericas    13.48      0.60     22.46       0    12.30     14.65
## 5     continentAsia     8.19      0.57     14.34       0     7.07      9.31
## 6   continentEurope    17.47      0.62     27.97       0    16.25     18.70
## 7  continentOceania    18.08      1.78     10.15       0    14.59     21.58</code></pre>
<p>The convenience “not in” operator <code>%nin%</code> is available via the
<code>socviz</code> library. It does the opposite of <code>%in%</code> and selects only the
items in a first vector of characters that are not in the second.
We’ll use it to drop the intercept term from the table. We also want
to something about the labels. When fitting a model with categorical
variables, R will create coefficient names based on the variable name
and the category name, like <code>continentAmericas</code>. Normally we like to
clean these up before plotting. Most commonly, we just want to strip
away the variable name at the beginning of the coefficient label. For
this we can use <code>prefix_strip()</code>, a convenience function in the
<code>socviz</code> library. We tell it which prefixes to drop, using it to
create a new column variable in <code>out_conf</code> that corresponds to the
<code>terms</code> column, but that has nicer labels.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb195-1" data-line-number="1">out_conf &lt;-<span class="st"> </span><span class="kw">subset</span>(out_conf, term <span class="op">%nin%</span><span class="st"> "(Intercept)"</span>)</a>
<a class="sourceLine" id="cb195-2" data-line-number="2">out_conf<span class="op">$</span>nicelabs &lt;-<span class="st"> </span><span class="kw">prefix_strip</span>(out_conf<span class="op">$</span>term, <span class="st">"continent"</span>)</a></code></pre>
<p>Now we can use <code>geom_pointrange()</code> to make a figure that displays some
information about our confidence in the variable estimates, as opposed
to just the coefficients. As with the boxplots earlier, we use
<code>reorder()</code> to sort the names of the model’s terms by the <code>estimate</code>
variable, thus arranging our plot of effects from largest to smallest
in magnitude.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-ols-tidy-conf-2"/>
<img src="../Images/388eb72c4d668c76c8c461f3b459c1de.png" alt="A nicer plot of OLS estimates and confidence intervals." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-ols-tidy-conf-2-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.6: A nicer plot of OLS estimates and confidence intervals.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb196-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(out_conf, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(nicelabs, estimate),</a>
<a class="sourceLine" id="cb196-2" data-line-number="2">                                    <span class="dt">y =</span> estimate, <span class="dt">ymin =</span> conf.low, <span class="dt">ymax =</span> conf.high))</a>
<a class="sourceLine" id="cb196-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_pointrange</span>() <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>() <span class="op">+</span><span class="st"> </span><span class="kw">labs</span>(<span class="dt">x=</span><span class="st">""</span>, <span class="dt">y=</span><span class="st">"OLS Estimate"</span>)</a></code></pre>
<p>Dotplots of this kind can be very compact. The vertical axis can often be compressed quite a bit, with no loss in comprehension. In fact, they are often easier to read with much less room between the rows than given by a default square shape.</p>
</div>
<div id="get-observation-level-statistics-with-augment" class="section level3">
<h3><span class="header-section-number">6.5.2</span> Get observation-level statistics with augment()</h3>
<p>The values returned by <code>augment()</code> are all statistics calculated at
the level of the original observations. As such, they can be added on
to the data frame that the model is based on. Working from a
call to <code>augment()</code> will return a data frame with all the original
observations used in the estimation of the model, together with
columns like the following:</p>
<ul>
<li><code>.fitted</code> — The fitted values of the model.</li>
<li><code>.se.fit</code> — The standard errors of the fitted values.</li>
<li><code>.resid</code> — The residuals.</li>
<li><code>.hat</code> — The diagonal of the hat matrix.</li>
<li><code>.sigma</code> — An estimate of residual standard deviation when the corresponding observation is dropped from the model.</li>
<li><code>.cooksd</code> — Cook’s distance, a common regression diagnostic; and</li>
<li><code>.std.resid</code> — The standardized residuals.</li>
</ul>
<p>Each of these variables is named with a leading dot, for example
<code>.hat</code> rather than <code>hat</code>, and so on. This is to guard against
accidentally confusing it with (or accidentally overwriting) an
existing variable in your data with this name. The columns of
values return will differ slightly depending on the class of model
being fitted.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb197-1" data-line-number="1">out_aug &lt;-<span class="st"> </span><span class="kw">augment</span>(out)</a>
<a class="sourceLine" id="cb197-2" data-line-number="2"><span class="kw">head</span>(out_aug) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round_df</span>()</a></code></pre>
<pre><code>##   lifeExp gdpPercap      pop continent .fitted .se.fit .resid .hat .sigma .cooksd .std.resid
## 1    28.8       779  8425333      Asia    56.4    0.47  -27.6    0   8.34    0.01      -3.31
## 2    30.3       821  9240934      Asia    56.4    0.47  -26.1    0   8.34    0.00      -3.13
## 3    32.0       853 10267083      Asia    56.5    0.47  -24.5    0   8.35    0.00      -2.93
## 4    34.0       836 11537966      Asia    56.5    0.47  -22.4    0   8.35    0.00      -2.69
## 5    36.1       740 13079460      Asia    56.4    0.47  -20.3    0   8.35    0.00      -2.44
## 6    38.4       786 14880372      Asia    56.5    0.47  -18.0    0   8.36    0.00      -2.16</code></pre>
<p>By default, <code>augment()</code> will extract the available data from the model
object. This will usually include the variables used in the model
itself, but not any additional ones contained in the original data frame.
Sometimes it is useful to have these. We can add them by specifying the
<code>data</code> argument:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb199-1" data-line-number="1">out_aug &lt;-<span class="st"> </span><span class="kw">augment</span>(out, <span class="dt">data =</span> gapminder)</a>
<a class="sourceLine" id="cb199-2" data-line-number="2"><span class="kw">head</span>(out_aug) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round_df</span>()</a></code></pre>
<pre><code>##       country continent year lifeExp      pop gdpPercap .fitted .se.fit .resid .hat .sigma .cooksd
## 1 Afghanistan      Asia 1952    28.8  8425333       779    56.4    0.47  -27.6    0   8.34    0.01
## 2 Afghanistan      Asia 1957    30.3  9240934       821    56.4    0.47  -26.1    0   8.34    0.00
## 3 Afghanistan      Asia 1962    32.0 10267083       853    56.5    0.47  -24.5    0   8.35    0.00
## 4 Afghanistan      Asia 1967    34.0 11537966       836    56.5    0.47  -22.4    0   8.35    0.00
## 5 Afghanistan      Asia 1972    36.1 13079460       740    56.4    0.47  -20.3    0   8.35    0.00
## 6 Afghanistan      Asia 1977    38.4 14880372       786    56.5    0.47  -18.0    0   8.36    0.00
##   .std.resid
## 1      -3.31
## 2      -3.13
## 3      -2.93
## 4      -2.69
## 5      -2.44
## 6      -2.16</code></pre>
<p>If some rows containing missing data were dropped to fit the model,
then these will not be carried over to the augmented data frame.</p>
<p>The new columns created by <code>augment()</code> can be used to create some
standard regression plots. For example, we can plot the residuals versus the fitted values. Figure <a href="modeling.html#fig:ch-06-augresid">6.7</a> suggests,
unsurprisingly, that our country-year data has rather more structure
than is captured by our OLS model.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-augresid"/>
<img src="../Images/43cf2a062d66ee897fa121dbf99503c9.png" alt="Residuals vs Fitted Values." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-augresid-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.7: Residuals vs Fitted Values.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb201-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> out_aug,</a>
<a class="sourceLine" id="cb201-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> .fitted, <span class="dt">y =</span> .resid))</a>
<a class="sourceLine" id="cb201-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>()</a></code></pre>
</div>
<div id="get-model-level-statistics-with-glance" class="section level3">
<h3><span class="header-section-number">6.5.3</span> Get model-level statistics with glance()</h3>
<p>This function organizes the information typically presented at the
bottom of a model’s <code>summary()</code> output. By itself, it usually just
returns a table with a single row in it. But as we shall see in a
moment, the real power of <code>broom</code>’s approach is the way that it can
scale up to cases where we are grouping or subsampling our data.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb202-1" data-line-number="1"><span class="kw">glance</span>(out) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round_df</span>()</a></code></pre>
<pre><code>##   r.squared adj.r.squared sigma statistic p.value df
## 1      0.58          0.58  8.37    393.91       0  7
##     logLik     AIC     BIC deviance df.residual
## 1 -6033.83 12083.6 12127.2   118754        1697</code></pre>
<p>Broom is able to tidy (and augment, and glance at) a wide range of
model types. Not all functions are available for all classes of
model. Consult broom’s documentation for more details on what
is available. For example, here is a plot created from the tidied
output of an event-history analysis. First we generate a Cox
proportional hazards model of some survival data.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb204-1" data-line-number="1"><span class="kw">library</span>(survival)</a>
<a class="sourceLine" id="cb204-2" data-line-number="2"/>
<a class="sourceLine" id="cb204-3" data-line-number="3">out_cph &lt;-<span class="st"> </span><span class="kw">coxph</span>(<span class="kw">Surv</span>(time, status) <span class="op">~</span><span class="st"> </span>age <span class="op">+</span><span class="st"> </span>sex, <span class="dt">data =</span> lung)</a>
<a class="sourceLine" id="cb204-4" data-line-number="4">out_surv &lt;-<span class="st"> </span><span class="kw">survfit</span>(out_cph)</a></code></pre>
<p>The details of the fit are not important here, but in the first step
the <code>Surv()</code> function creates the response or outcome variable for the
proportional hazards model that is then fitted by the <code>coxph()</code>
function. Then the <code>survfit()</code> function creates the survival curve
from the model, much like we used <code>predict()</code> to generate predicted
values earlier. Try <code>summary(out_cph)</code> to see the model, and
<code>summary(out_surv)</code> to see the table of predicted values that will
form the basis for our plot. Next we tidy <code>out_surv</code> to get a data
frame, and plot it.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-survival"/>
<img src="../Images/1e961d36cc805682f5590795a7c245a4.png" alt="A Kaplan-Meier plot." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-survival-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.8: A Kaplan-Meier plot.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb205-1" data-line-number="1">out_tidy &lt;-<span class="st"> </span><span class="kw">tidy</span>(out_surv)</a>
<a class="sourceLine" id="cb205-2" data-line-number="2"/>
<a class="sourceLine" id="cb205-3" data-line-number="3">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> out_tidy, <span class="dt">mapping =</span> <span class="kw">aes</span>(time, estimate))</a>
<a class="sourceLine" id="cb205-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb205-5" data-line-number="5"><span class="st">    </span><span class="kw">geom_ribbon</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">ymin =</span> conf.low, <span class="dt">ymax =</span> conf.high), <span class="dt">alpha =</span> <span class="fl">.2</span>)</a></code></pre>
</div>
&#13;

<h3><span class="header-section-number">6.5.1</span> Get component-level statistics with tidy()</h3>
<p>The <code>tidy()</code> function takes a model object and returns a data frame of
component-level information. We can work with this to make plots in a
familiar way, and much more easily than fishing inside the model
object to extract the various terms. Here is an example, using
the default results as just returned. For a more convenient display of
the results, we will pipe the object we create with <code>tidy()</code> through a
function that rounds the numeric columns of the data frame to two
decimal places. This doesn’t change anything about the object itself,
of course.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb190-1" data-line-number="1">out_comp &lt;-<span class="st"> </span><span class="kw">tidy</span>(out)</a>
<a class="sourceLine" id="cb190-2" data-line-number="2">out_comp <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round_df</span>()</a></code></pre>
<pre><code>##                term estimate std.error statistic p.value
## 1       (Intercept)    47.81      0.34    140.82       0
## 2         gdpPercap     0.00      0.00     19.16       0
## 3               pop     0.00      0.00      3.33       0
## 4 continentAmericas    13.48      0.60     22.46       0
## 5     continentAsia     8.19      0.57     14.34       0
## 6   continentEurope    17.47      0.62     27.97       0
## 7  continentOceania    18.08      1.78     10.15       0</code></pre>
<p>We are now able to treat this data frame just like all the other data
that we have seen so far.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-ols-tidy"/>
<img src="../Images/86cb8182688f582ab5bf93d7c02069cb.png" alt="Basic plot of OLS estimates." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-ols-tidy-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.5: Basic plot of OLS estimates.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb192-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(out_comp, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> term,</a>
<a class="sourceLine" id="cb192-2" data-line-number="2">                                    <span class="dt">y =</span> estimate))</a>
<a class="sourceLine" id="cb192-3" data-line-number="3"/>
<a class="sourceLine" id="cb192-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>() </a></code></pre>
<p>We can extend and clean up this plot in a variety of ways. For
example, we can tell <code>tidy()</code> to calculate confidence intervals for
the estimates, using R’s <code>confint()</code> function.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb193-1" data-line-number="1">out_conf &lt;-<span class="st"> </span><span class="kw">tidy</span>(out, <span class="dt">conf.int =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb193-2" data-line-number="2">out_conf <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round_df</span>()</a></code></pre>
<pre><code>##                term estimate std.error statistic p.value conf.low conf.high
## 1       (Intercept)    47.81      0.34    140.82       0    47.15     48.48
## 2         gdpPercap     0.00      0.00     19.16       0     0.00      0.00
## 3               pop     0.00      0.00      3.33       0     0.00      0.00
## 4 continentAmericas    13.48      0.60     22.46       0    12.30     14.65
## 5     continentAsia     8.19      0.57     14.34       0     7.07      9.31
## 6   continentEurope    17.47      0.62     27.97       0    16.25     18.70
## 7  continentOceania    18.08      1.78     10.15       0    14.59     21.58</code></pre>
<p>The convenience “not in” operator <code>%nin%</code> is available via the
<code>socviz</code> library. It does the opposite of <code>%in%</code> and selects only the
items in a first vector of characters that are not in the second.
We’ll use it to drop the intercept term from the table. We also want
to something about the labels. When fitting a model with categorical
variables, R will create coefficient names based on the variable name
and the category name, like <code>continentAmericas</code>. Normally we like to
clean these up before plotting. Most commonly, we just want to strip
away the variable name at the beginning of the coefficient label. For
this we can use <code>prefix_strip()</code>, a convenience function in the
<code>socviz</code> library. We tell it which prefixes to drop, using it to
create a new column variable in <code>out_conf</code> that corresponds to the
<code>terms</code> column, but that has nicer labels.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb195-1" data-line-number="1">out_conf &lt;-<span class="st"> </span><span class="kw">subset</span>(out_conf, term <span class="op">%nin%</span><span class="st"> "(Intercept)"</span>)</a>
<a class="sourceLine" id="cb195-2" data-line-number="2">out_conf<span class="op">$</span>nicelabs &lt;-<span class="st"> </span><span class="kw">prefix_strip</span>(out_conf<span class="op">$</span>term, <span class="st">"continent"</span>)</a></code></pre>
<p>Now we can use <code>geom_pointrange()</code> to make a figure that displays some
information about our confidence in the variable estimates, as opposed
to just the coefficients. As with the boxplots earlier, we use
<code>reorder()</code> to sort the names of the model’s terms by the <code>estimate</code>
variable, thus arranging our plot of effects from largest to smallest
in magnitude.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-ols-tidy-conf-2"/>
<img src="../Images/388eb72c4d668c76c8c461f3b459c1de.png" alt="A nicer plot of OLS estimates and confidence intervals." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-ols-tidy-conf-2-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.6: A nicer plot of OLS estimates and confidence intervals.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb196-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(out_conf, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(nicelabs, estimate),</a>
<a class="sourceLine" id="cb196-2" data-line-number="2">                                    <span class="dt">y =</span> estimate, <span class="dt">ymin =</span> conf.low, <span class="dt">ymax =</span> conf.high))</a>
<a class="sourceLine" id="cb196-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_pointrange</span>() <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>() <span class="op">+</span><span class="st"> </span><span class="kw">labs</span>(<span class="dt">x=</span><span class="st">""</span>, <span class="dt">y=</span><span class="st">"OLS Estimate"</span>)</a></code></pre>
<p>Dotplots of this kind can be very compact. The vertical axis can often be compressed quite a bit, with no loss in comprehension. In fact, they are often easier to read with much less room between the rows than given by a default square shape.</p>
&#13;

<h3><span class="header-section-number">6.5.2</span> Get observation-level statistics with augment()</h3>
<p>The values returned by <code>augment()</code> are all statistics calculated at
the level of the original observations. As such, they can be added on
to the data frame that the model is based on. Working from a
call to <code>augment()</code> will return a data frame with all the original
observations used in the estimation of the model, together with
columns like the following:</p>
<ul>
<li><code>.fitted</code> — The fitted values of the model.</li>
<li><code>.se.fit</code> — The standard errors of the fitted values.</li>
<li><code>.resid</code> — The residuals.</li>
<li><code>.hat</code> — The diagonal of the hat matrix.</li>
<li><code>.sigma</code> — An estimate of residual standard deviation when the corresponding observation is dropped from the model.</li>
<li><code>.cooksd</code> — Cook’s distance, a common regression diagnostic; and</li>
<li><code>.std.resid</code> — The standardized residuals.</li>
</ul>
<p>Each of these variables is named with a leading dot, for example
<code>.hat</code> rather than <code>hat</code>, and so on. This is to guard against
accidentally confusing it with (or accidentally overwriting) an
existing variable in your data with this name. The columns of
values return will differ slightly depending on the class of model
being fitted.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb197-1" data-line-number="1">out_aug &lt;-<span class="st"> </span><span class="kw">augment</span>(out)</a>
<a class="sourceLine" id="cb197-2" data-line-number="2"><span class="kw">head</span>(out_aug) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round_df</span>()</a></code></pre>
<pre><code>##   lifeExp gdpPercap      pop continent .fitted .se.fit .resid .hat .sigma .cooksd .std.resid
## 1    28.8       779  8425333      Asia    56.4    0.47  -27.6    0   8.34    0.01      -3.31
## 2    30.3       821  9240934      Asia    56.4    0.47  -26.1    0   8.34    0.00      -3.13
## 3    32.0       853 10267083      Asia    56.5    0.47  -24.5    0   8.35    0.00      -2.93
## 4    34.0       836 11537966      Asia    56.5    0.47  -22.4    0   8.35    0.00      -2.69
## 5    36.1       740 13079460      Asia    56.4    0.47  -20.3    0   8.35    0.00      -2.44
## 6    38.4       786 14880372      Asia    56.5    0.47  -18.0    0   8.36    0.00      -2.16</code></pre>
<p>By default, <code>augment()</code> will extract the available data from the model
object. This will usually include the variables used in the model
itself, but not any additional ones contained in the original data frame.
Sometimes it is useful to have these. We can add them by specifying the
<code>data</code> argument:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb199-1" data-line-number="1">out_aug &lt;-<span class="st"> </span><span class="kw">augment</span>(out, <span class="dt">data =</span> gapminder)</a>
<a class="sourceLine" id="cb199-2" data-line-number="2"><span class="kw">head</span>(out_aug) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round_df</span>()</a></code></pre>
<pre><code>##       country continent year lifeExp      pop gdpPercap .fitted .se.fit .resid .hat .sigma .cooksd
## 1 Afghanistan      Asia 1952    28.8  8425333       779    56.4    0.47  -27.6    0   8.34    0.01
## 2 Afghanistan      Asia 1957    30.3  9240934       821    56.4    0.47  -26.1    0   8.34    0.00
## 3 Afghanistan      Asia 1962    32.0 10267083       853    56.5    0.47  -24.5    0   8.35    0.00
## 4 Afghanistan      Asia 1967    34.0 11537966       836    56.5    0.47  -22.4    0   8.35    0.00
## 5 Afghanistan      Asia 1972    36.1 13079460       740    56.4    0.47  -20.3    0   8.35    0.00
## 6 Afghanistan      Asia 1977    38.4 14880372       786    56.5    0.47  -18.0    0   8.36    0.00
##   .std.resid
## 1      -3.31
## 2      -3.13
## 3      -2.93
## 4      -2.69
## 5      -2.44
## 6      -2.16</code></pre>
<p>If some rows containing missing data were dropped to fit the model,
then these will not be carried over to the augmented data frame.</p>
<p>The new columns created by <code>augment()</code> can be used to create some
standard regression plots. For example, we can plot the residuals versus the fitted values. Figure <a href="modeling.html#fig:ch-06-augresid">6.7</a> suggests,
unsurprisingly, that our country-year data has rather more structure
than is captured by our OLS model.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-augresid"/>
<img src="../Images/43cf2a062d66ee897fa121dbf99503c9.png" alt="Residuals vs Fitted Values." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-augresid-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.7: Residuals vs Fitted Values.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb201-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> out_aug,</a>
<a class="sourceLine" id="cb201-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> .fitted, <span class="dt">y =</span> .resid))</a>
<a class="sourceLine" id="cb201-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>()</a></code></pre>
&#13;

<h3><span class="header-section-number">6.5.3</span> Get model-level statistics with glance()</h3>
<p>This function organizes the information typically presented at the
bottom of a model’s <code>summary()</code> output. By itself, it usually just
returns a table with a single row in it. But as we shall see in a
moment, the real power of <code>broom</code>’s approach is the way that it can
scale up to cases where we are grouping or subsampling our data.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb202-1" data-line-number="1"><span class="kw">glance</span>(out) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round_df</span>()</a></code></pre>
<pre><code>##   r.squared adj.r.squared sigma statistic p.value df
## 1      0.58          0.58  8.37    393.91       0  7
##     logLik     AIC     BIC deviance df.residual
## 1 -6033.83 12083.6 12127.2   118754        1697</code></pre>
<p>Broom is able to tidy (and augment, and glance at) a wide range of
model types. Not all functions are available for all classes of
model. Consult broom’s documentation for more details on what
is available. For example, here is a plot created from the tidied
output of an event-history analysis. First we generate a Cox
proportional hazards model of some survival data.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb204-1" data-line-number="1"><span class="kw">library</span>(survival)</a>
<a class="sourceLine" id="cb204-2" data-line-number="2"/>
<a class="sourceLine" id="cb204-3" data-line-number="3">out_cph &lt;-<span class="st"> </span><span class="kw">coxph</span>(<span class="kw">Surv</span>(time, status) <span class="op">~</span><span class="st"> </span>age <span class="op">+</span><span class="st"> </span>sex, <span class="dt">data =</span> lung)</a>
<a class="sourceLine" id="cb204-4" data-line-number="4">out_surv &lt;-<span class="st"> </span><span class="kw">survfit</span>(out_cph)</a></code></pre>
<p>The details of the fit are not important here, but in the first step
the <code>Surv()</code> function creates the response or outcome variable for the
proportional hazards model that is then fitted by the <code>coxph()</code>
function. Then the <code>survfit()</code> function creates the survival curve
from the model, much like we used <code>predict()</code> to generate predicted
values earlier. Try <code>summary(out_cph)</code> to see the model, and
<code>summary(out_surv)</code> to see the table of predicted values that will
form the basis for our plot. Next we tidy <code>out_surv</code> to get a data
frame, and plot it.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-survival"/>
<img src="../Images/1e961d36cc805682f5590795a7c245a4.png" alt="A Kaplan-Meier plot." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-survival-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.8: A Kaplan-Meier plot.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb205-1" data-line-number="1">out_tidy &lt;-<span class="st"> </span><span class="kw">tidy</span>(out_surv)</a>
<a class="sourceLine" id="cb205-2" data-line-number="2"/>
<a class="sourceLine" id="cb205-3" data-line-number="3">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> out_tidy, <span class="dt">mapping =</span> <span class="kw">aes</span>(time, estimate))</a>
<a class="sourceLine" id="cb205-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb205-5" data-line-number="5"><span class="st">    </span><span class="kw">geom_ribbon</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">ymin =</span> conf.low, <span class="dt">ymax =</span> conf.high), <span class="dt">alpha =</span> <span class="fl">.2</span>)</a></code></pre>
&#13;

<h2><span class="header-section-number">6.6</span> Grouped analysis and list columns</h2>
<p>Broom makes it possible to quickly fit models to different subsets of
your data and get consistent and usable tables of results out the
other end. For example, let’s say we wanted to look at the gapminder
data by examining the relationship between life expectancy and GDP by
<em>continent</em>, for each year in the data.</p>
<p>The <code>gapminder</code> data is at bottom organized by country-years. That is
the unit of observation in the rows. If we wanted, we could take
a slice of the data manually, such as “all countries observed in Asia,
in 1962” or “all in Africa, 2002”. Here is “Europe, 1977”:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb206-1" data-line-number="1">eu77 &lt;-<span class="st"> </span>gapminder <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(continent <span class="op">==</span><span class="st"> "Europe"</span>, year <span class="op">==</span><span class="st"> </span><span class="dv">1977</span>)</a></code></pre>
<p>We could then see what the relationship between life expectancy and
GDP looked like for that continent-year group:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb207-1" data-line-number="1">fit &lt;-<span class="st"> </span><span class="kw">lm</span>(lifeExp <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(gdpPercap), <span class="dt">data =</span> eu77)</a>
<a class="sourceLine" id="cb207-2" data-line-number="2"><span class="kw">summary</span>(fit)</a></code></pre>
<pre><code>## 
## Call:
## lm(formula = lifeExp ~ log(gdpPercap), data = eu77)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
## -7.496 -1.031  0.093  1.176  3.712 
## 
## Coefficients:
##                Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)      29.489      7.161    4.12  0.00031 ***
## log(gdpPercap)    4.488      0.756    5.94  2.2e-06 ***
## ---
## Signif. codes:  
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 2.11 on 28 degrees of freedom
## Multiple R-squared:  0.557,  Adjusted R-squared:  0.541 
## F-statistic: 35.2 on 1 and 28 DF,  p-value: 2.17e-06</code></pre>
<p>With <code>dplyr</code> and <code>broom</code> we can do this for every continent-year slice
of the data in a compact and tidy way. We start with our table of
data, and then (<code>%&gt;%</code>) group the countries by <code>continent</code> and <code>year</code>
using the <code>group_by()</code> function. We introduced this grouping operation
in Chapter <a href="groupfacettx.html#groupfacettx">4</a>. Our data is reorganized first by
continent, and within continent by year. Here we will take one further
step and <em>nest</em> the data that make up each group:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb209-1" data-line-number="1">out_le &lt;-<span class="st"> </span>gapminder <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb209-2" data-line-number="2"><span class="st">    </span><span class="kw">group_by</span>(continent, year) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb209-3" data-line-number="3"><span class="st">    </span><span class="kw">nest</span>()</a>
<a class="sourceLine" id="cb209-4" data-line-number="4"/>
<a class="sourceLine" id="cb209-5" data-line-number="5">out_le</a></code></pre>
<pre><code>## # A tibble: 60 x 3
##    continent  year data             
##    &lt;fct&gt;     &lt;int&gt; &lt;list&gt;           
##  1 Asia       1952 &lt;tibble [33 × 4]&gt;
##  2 Asia       1957 &lt;tibble [33 × 4]&gt;
##  3 Asia       1962 &lt;tibble [33 × 4]&gt;
##  4 Asia       1967 &lt;tibble [33 × 4]&gt;
##  5 Asia       1972 &lt;tibble [33 × 4]&gt;
##  6 Asia       1977 &lt;tibble [33 × 4]&gt;
##  7 Asia       1982 &lt;tibble [33 × 4]&gt;
##  8 Asia       1987 &lt;tibble [33 × 4]&gt;
##  9 Asia       1992 &lt;tibble [33 × 4]&gt;
## 10 Asia       1997 &lt;tibble [33 × 4]&gt;
## # ... with 50 more rows</code></pre>
<p>Think of what <code>nest()</code> does as a more intensive version what
<code>group_by()</code> does. The resulting object is has the tabular form we
expect (it is a tibble) but it looks a little unusual. The first two
columns are the familiar <code>continent</code> and <code>year</code>. But we now also have
a new column, <code>data</code>, that contains a small table of data
corresponding to each continent-year group. This is a <em>list column</em>,
something we have not seen before. It turns out to be very useful for
bundling together complex objects (structured, in this case, as a list
of tibbles, each being a 33x4 table of data) within the rows of our
data (which remains tabular). Our “Europe 1977” fit is in there. We
can look at it, if we like, by filtering the data and then <em>unnesting</em>
the list column.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb211-1" data-line-number="1">out_le <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(continent <span class="op">==</span><span class="st"> "Europe"</span> <span class="op">&amp;</span><span class="st"> </span>year <span class="op">==</span><span class="st"> </span><span class="dv">1977</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">unnest</span>()</a></code></pre>
<pre><code>## # A tibble: 30 x 6
##    continent  year country         lifeExp    pop gdpPercap
##    &lt;fct&gt;     &lt;int&gt; &lt;fct&gt;             &lt;dbl&gt;  &lt;int&gt;     &lt;dbl&gt;
##  1 Europe     1977 Albania            68.9 2.51e⁶      3533
##  2 Europe     1977 Austria            72.2 7.57e⁶     19749
##  3 Europe     1977 Belgium            72.8 9.82e⁶     19118
##  4 Europe     1977 Bosnia and Her…    69.9 4.09e⁶      3528
##  5 Europe     1977 Bulgaria           70.8 8.80e⁶      7612
##  6 Europe     1977 Croatia            70.6 4.32e⁶     11305
##  7 Europe     1977 Czech Republic     70.7 1.02e⁷     14800
##  8 Europe     1977 Denmark            74.7 5.09e⁶     20423
##  9 Europe     1977 Finland            72.5 4.74e⁶     15605
## 10 Europe     1977 France             73.8 5.32e⁷     18293
## # ... with 20 more rows</code></pre>
<p>List columns are useful because we can act on them in a compact and
tidy way. In particular, we can pass functions along to each row of
the list column and make something happen. For example, a moment ago
we ran a regression of life expectancy and logged GDP for European
countries in 1977. We can do that for every continent-year combination
in the data. We first create a convenience function called <code>fit_ols()</code>
that takes a single argument, <code>df</code> (for data frame) and that fits the
linear model we are interested in. Then<label for="tufte-mn-70" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-70" class="margin-toggle"/><span class="marginnote shownote">The map action is an important idea in functional programming. If you have written code in other, more imperative languages you can think of it as a compact alternative to writing for … next loops. You can of course write loops like this in R. Computationally they are often not any less efficient than their functional alternatives. But mapping functions to arrays is more easily integrated into a sequence of data transformations.</span> we <em>map</em> that function to each
of our list column rows in turn. Recall from Chapter <a href="groupfacettx.html#groupfacettx">4</a>
that <code>mutate</code> creates new variables or columns on the fly within a
pipeline.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb213-1" data-line-number="1">fit_ols &lt;-<span class="st"> </span><span class="cf">function</span>(df) {</a>
<a class="sourceLine" id="cb213-2" data-line-number="2">    <span class="kw">lm</span>(lifeExp <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(gdpPercap), <span class="dt">data =</span> df)</a>
<a class="sourceLine" id="cb213-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb213-4" data-line-number="4"/>
<a class="sourceLine" id="cb213-5" data-line-number="5">out_le &lt;-<span class="st"> </span>gapminder <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb213-6" data-line-number="6"><span class="st">    </span><span class="kw">group_by</span>(continent, year) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb213-7" data-line-number="7"><span class="st">    </span><span class="kw">nest</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb213-8" data-line-number="8"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">model =</span> <span class="kw">map</span>(data, fit_ols)) </a>
<a class="sourceLine" id="cb213-9" data-line-number="9"/>
<a class="sourceLine" id="cb213-10" data-line-number="10">out_le</a></code></pre>
<pre><code>## # A tibble: 60 x 4
##    continent  year data              model   
##    &lt;fct&gt;     &lt;int&gt; &lt;list&gt;            &lt;list&gt;  
##  1 Asia       1952 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
##  2 Asia       1957 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
##  3 Asia       1962 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
##  4 Asia       1967 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
##  5 Asia       1972 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
##  6 Asia       1977 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
##  7 Asia       1982 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
##  8 Asia       1987 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
##  9 Asia       1992 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
## 10 Asia       1997 &lt;tibble [33 × 4]&gt; &lt;S3: lm&gt;
## # ... with 50 more rows</code></pre>
<p>Before starting the pipeline we create a new function: It
is a convenience function whose only job is to estimate a particular
OLS model on some data. Like almost everything in R, functions are a
kind of object. To make a new one, we use the slightly special
<code>function()</code> function. (Nerds love that sort of thing.) There is a
little more detail on creating functions in the Appendix. To see what <code>fit_ols()</code> looks like once it is created, type <code>fit_ols</code> without parentheses at the Console. To see what it does, try <code>fit_ols(df = gapminder)</code>, or <code>summary(fit_ols(gapminder))</code>.</p>
<p>Now we have two list columns: <code>data</code>, and <code>model</code>. The latter was
created by mapping the <code>fit_ols()</code> function to each row of <code>data</code>.
Inside each element of <code>model</code> is a linear model for that
continent-year. So we now have sixty OLS fits, one for every
continent-year grouping. Having the models inside the list column is
not much use to us in and of itself. But we can extract the
information we want while keeping things in a tidy tabular form. For clarity
we will run the pipeline from the beginning again, this time adding a few
new steps.</p>
<p>First we extract summary statistics from each model by
mapping the <code>tidy()</code> function from broom to the model list column.
Then we unnest the result, dropping the other columns in the process.
Finally, we filter out all the Intercept terms, and also drop all
observations from Oceania. In the case of the Intercepts we do this
just out of convenience. Oceania we drop just because there are so few
observations. We put the results in an object called <code>out_tidy</code>.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb215-1" data-line-number="1">fit_ols &lt;-<span class="st"> </span><span class="cf">function</span>(df) {</a>
<a class="sourceLine" id="cb215-2" data-line-number="2">    <span class="kw">lm</span>(lifeExp <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(gdpPercap), <span class="dt">data =</span> df)</a>
<a class="sourceLine" id="cb215-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb215-4" data-line-number="4"/>
<a class="sourceLine" id="cb215-5" data-line-number="5">out_tidy &lt;-<span class="st"> </span>gapminder <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb215-6" data-line-number="6"><span class="st">    </span><span class="kw">group_by</span>(continent, year) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb215-7" data-line-number="7"><span class="st">    </span><span class="kw">nest</span>() <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb215-8" data-line-number="8"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">model =</span> <span class="kw">map</span>(data, fit_ols),</a>
<a class="sourceLine" id="cb215-9" data-line-number="9">           <span class="dt">tidied =</span> <span class="kw">map</span>(model, tidy)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb215-10" data-line-number="10"><span class="st">    </span><span class="kw">unnest</span>(tidied, <span class="dt">.drop =</span> <span class="ot">TRUE</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb215-11" data-line-number="11"><span class="st">    </span><span class="kw">filter</span>(term <span class="op">%nin%</span><span class="st"> "(Intercept)"</span> <span class="op">&amp;</span></a>
<a class="sourceLine" id="cb215-12" data-line-number="12"><span class="st">           </span>continent <span class="op">%nin%</span><span class="st"> "Oceania"</span>)</a>
<a class="sourceLine" id="cb215-13" data-line-number="13"/>
<a class="sourceLine" id="cb215-14" data-line-number="14">out_tidy <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">sample_n</span>(<span class="dv">5</span>)</a></code></pre>
<pre><code>## # A tibble: 5 x 7
##   continent  year term           estimate std.error statistic      p.value
##   &lt;fct&gt;     &lt;int&gt; &lt;chr&gt;             &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;
## 1 Europe     1987 log(gdpPercap)     4.14     0.752      5.51 0.00000693  
## 2 Asia       1972 log(gdpPercap)     4.44     1.01       4.41 0.000116    
## 3 Europe     1972 log(gdpPercap)     4.51     0.757      5.95 0.00000208  
## 4 Americas   1952 log(gdpPercap)    10.4      2.72       3.84 0.000827    
## 5 Asia       1987 log(gdpPercap)     5.17     0.727      7.12 0.0000000531</code></pre>
<p>We now have tidy regression output with an estimate of the association
between log GDP per capita and life expectancy for each year, within
continents. We can plot these estimates in a way that takes advantage
of their groupiness.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb217-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> out_tidy,</a>
<a class="sourceLine" id="cb217-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year, <span class="dt">y =</span> estimate,</a>
<a class="sourceLine" id="cb217-3" data-line-number="3">                          <span class="dt">ymin =</span> estimate <span class="op">-</span><span class="st"> </span><span class="dv">2</span><span class="op">*</span>std.error,</a>
<a class="sourceLine" id="cb217-4" data-line-number="4">                          <span class="dt">ymax =</span> estimate <span class="op">+</span><span class="st"> </span><span class="dv">2</span><span class="op">*</span>std.error,</a>
<a class="sourceLine" id="cb217-5" data-line-number="5">                          <span class="dt">group =</span> continent, <span class="dt">color =</span> continent))</a>
<a class="sourceLine" id="cb217-6" data-line-number="6"/>
<a class="sourceLine" id="cb217-7" data-line-number="7">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_pointrange</span>(<span class="dt">position =</span> <span class="kw">position_dodge</span>(<span class="dt">width =</span> <span class="dv">1</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb217-8" data-line-number="8"><span class="st">    </span><span class="kw">scale_x_continuous</span>(<span class="dt">breaks =</span> <span class="kw">unique</span>(gapminder<span class="op">$</span>year)) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb217-9" data-line-number="9"><span class="st">    </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb217-10" data-line-number="10"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">"Year"</span>, <span class="dt">y =</span> <span class="st">"Estimate"</span>, <span class="dt">color =</span> <span class="st">"Continent"</span>)</a></code></pre>
<div class="figure fullwidth"><span id="fig:ch-06-dodgeplot"/>
<img src="../Images/23ad9adc4c5e240c3e5b24eb5be2ec2f.png" alt="Yearly estimates of the association between GDP and Life Expectancy, pooled by continent." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-dodgeplot-1.png"/>
<p class="caption marginnote shownote">
Figure 6.9: Yearly estimates of the association between GDP and Life Expectancy, pooled by continent.
</p>
</div>
<p>The call to <code>position_dodge()</code> within <code>geom_pointrange()</code> allows the
point ranges for each continent to be near each other within years,
instead of being plotted right on top of one another. We could have
faceted the results by continent, but doing it this way lets us see
differences in the yearly estimates much more easily. This technique is very
useful not just for cases like this, but also when you want to compare
the coefficients given by different kinds of statistical model. This
sometimes happens when we’re interested in seeing how, say, OLS
performs against some other model specification.</p>
&#13;

<h2><span class="header-section-number">6.7</span> Plot marginal effects</h2>
<p>Our earlier discussion of <code>predict()</code> was about obtaining estimates of
the average effect of some coefficient, net of the other terms in the
model. Over the past decade, estimating and plotting <em>partial</em> or
<em>marginal effects</em> from a model has become an increasingly common way
of presenting accurate and interpretively useful predictions. Interest
in marginal effects plots was stimulated by the realization that the
interpretation of terms in logistic regression models, in particular,
was trickier than it seemed—especially when there were interaction
terms in the model <span class="citation">(Ai &amp; Norton, 2003)</span>. Thomas Leeper’s
<code>margins</code> package can make these plots for us.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb218-1" data-line-number="1"><span class="kw">library</span>(margins)</a></code></pre>
<p>To see it in action, we’ll take another look at the General Social
Survey data in <code>gss_sm</code>, this time focusing on the binary variable,
<code>obama</code>.<label for="tufte-mn-71" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-71" class="margin-toggle"/><span class="marginnote shownote">As is common with retrospective questions on elections, rather more people claim to have voted for Obama than is consistent with the vote share he received in the election.</span> It is coded <code>1</code> if the respondent said they voted for Barack
Obama in the 2012 presidential election, and <code>0</code> otherwise. In this case, mostly for convenience here, the zero code includes all other answers
to the question, including those who said they voted for Mitt Romney,
those who said they did not vote, those who refused to answer, and
those who said they didn’t know who they voted for. We will fit a
logistic regression on <code>obama</code>, with <code>age</code>, <code>polviews</code>, <code>race</code>, and
<code>sex</code> as the predictors. The <code>age</code> variable is the respondent’s age in
years. The <code>sex</code> variable is coded as “Male” or “Female” with “Male”
as the reference category. The <code>race</code> variable is coded as “White”,
“Black”, or “Other” with “White” as the reference category. The
<code>polviews</code> measure is a self-reported scale of the respondent’s
political orientation from “Extremely Conservative” through “Extremely
Liberal”, with “Moderate” in the middle. We take <code>polviews</code> and create
a new variable, <code>polviews_m</code>, using the <code>relevel()</code> function to recode
“Moderate” to be the reference category. We fit the model with the
<code>glm()</code> function, and specify an interaction between <code>race</code> and <code>sex</code>.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb219-1" data-line-number="1">gss_sm<span class="op">$</span>polviews_m &lt;-<span class="st"> </span><span class="kw">relevel</span>(gss_sm<span class="op">$</span>polviews, <span class="dt">ref =</span> <span class="st">"Moderate"</span>)</a>
<a class="sourceLine" id="cb219-2" data-line-number="2"/>
<a class="sourceLine" id="cb219-3" data-line-number="3">out_bo &lt;-<span class="st"> </span><span class="kw">glm</span>(obama <span class="op">~</span><span class="st"> </span>polviews_m <span class="op">+</span><span class="st"> </span>sex<span class="op">*</span>race,</a>
<a class="sourceLine" id="cb219-4" data-line-number="4">              <span class="dt">family =</span> <span class="st">"binomial"</span>, <span class="dt">data =</span> gss_sm)</a>
<a class="sourceLine" id="cb219-5" data-line-number="5"><span class="kw">summary</span>(out_bo)</a></code></pre>
<pre><code>## 
## Call:
## glm(formula = obama ~ polviews_m + sex * race, family = "binomial", 
##     data = gss_sm)
## 
## Deviance Residuals: 
##    Min      1Q  Median      3Q     Max  
## -2.905  -0.554   0.177   0.542   2.244  
## 
## Coefficients:
##                                  Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept)                       0.29649    0.13409    2.21   0.0270 *  
## polviews_mExtremely Liberal       2.37295    0.52504    4.52  6.2e-06 ***
## polviews_mLiberal                 2.60003    0.35667    7.29  3.1e-13 ***
## polviews_mSlightly Liberal        1.29317    0.24843    5.21  1.9e-07 ***
## polviews_mSlightly Conservative  -1.35528    0.18129   -7.48  7.7e-14 ***
## polviews_mConservative           -2.34746    0.20038  -11.71  &lt; 2e-16 ***
## polviews_mExtremely Conservative -2.72738    0.38721   -7.04  1.9e-12 ***
## sexFemale                         0.25487    0.14537    1.75   0.0796 .  
## raceBlack                         3.84953    0.50132    7.68  1.6e-14 ***
## raceOther                        -0.00214    0.43576    0.00   0.9961    
## sexFemale:raceBlack              -0.19751    0.66007   -0.30   0.7648    
## sexFemale:raceOther               1.57483    0.58766    2.68   0.0074 ** 
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 2247.9  on 1697  degrees of freedom
## Residual deviance: 1345.9  on 1686  degrees of freedom
##   (1169 observations deleted due to missingness)
## AIC: 1370
## 
## Number of Fisher Scoring iterations: 6</code></pre>
<p>The summary reports the coefficients and other information. We can now
graph the data in any one of several ways. Using <code>margins()</code> we
calculate the marginal effects for each variable:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb221-1" data-line-number="1">bo_m &lt;-<span class="st"> </span><span class="kw">margins</span>(out_bo)</a>
<a class="sourceLine" id="cb221-2" data-line-number="2"><span class="kw">summary</span>(bo_m)</a></code></pre>
<pre><code>##                            factor     AME     SE        z      p   lower   upper
##            polviews_mConservative -0.4119 0.0283 -14.5394 0.0000 -0.4674 -0.3564
##  polviews_mExtremely Conservative -0.4538 0.0420 -10.7971 0.0000 -0.5361 -0.3714
##       polviews_mExtremely Liberal  0.2681 0.0295   9.0996 0.0000  0.2103  0.3258
##                 polviews_mLiberal  0.2768 0.0229  12.0736 0.0000  0.2319  0.3218
##   polviews_mSlightly Conservative -0.2658 0.0330  -8.0596 0.0000 -0.3304 -0.2011
##        polviews_mSlightly Liberal  0.1933 0.0303   6.3896 0.0000  0.1340  0.2526
##                         raceBlack  0.4032 0.0173  23.3568 0.0000  0.3694  0.4371
##                         raceOther  0.1247 0.0386   3.2297 0.0012  0.0490  0.2005
##                         sexFemale  0.0443 0.0177   2.5073 0.0122  0.0097  0.0789</code></pre>
<p>The <code>margins</code> library comes with several plot methods of its own. If
you wish, at this point you can just try <code>plot(bo_m)</code> to see a plot of
the average marginal effects, produced with the general look of a
Stata graphic. Other plot methods in the <code>margins</code> library include
<code>cplot()</code>, which visualizes marginal effects conditional on a second
variable, and <code>image()</code>, which shows predictions or marginal effects
as a filled heatmap or contour plot.</p>
<p>Alternatively, we can take results from <code>margins()</code> and plot them
ourselves. To clean up the summary a little a little, we convert it to
a tibble, then use <code>prefix_strip()</code> and <code>prefix_replace()</code> to tidy
the labels. We want to strip the <code>polviews_m</code> and <code>sex</code> prefixes, and
(to avoid ambiguity about “Other”), adjust the <code>race</code> prefix.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb223-1" data-line-number="1">bo_gg &lt;-<span class="st"> </span><span class="kw">as_tibble</span>(<span class="kw">summary</span>(bo_m))</a>
<a class="sourceLine" id="cb223-2" data-line-number="2">prefixes &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"polviews_m"</span>, <span class="st">"sex"</span>)</a>
<a class="sourceLine" id="cb223-3" data-line-number="3">bo_gg<span class="op">$</span>factor &lt;-<span class="st"> </span><span class="kw">prefix_strip</span>(bo_gg<span class="op">$</span>factor, prefixes)</a>
<a class="sourceLine" id="cb223-4" data-line-number="4">bo_gg<span class="op">$</span>factor &lt;-<span class="st"> </span><span class="kw">prefix_replace</span>(bo_gg<span class="op">$</span>factor, <span class="st">"race"</span>, <span class="st">"Race: "</span>)</a>
<a class="sourceLine" id="cb223-5" data-line-number="5"/>
<a class="sourceLine" id="cb223-6" data-line-number="6">bo_gg <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(factor, AME, lower, upper) </a></code></pre>
<pre><code>## # A tibble: 9 x 4
##   factor                     AME    lower   upper
## * &lt;chr&gt;                    &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;
## 1 Conservative           -0.412  -0.467   -0.356 
## 2 Extremely Conservative -0.454  -0.536   -0.371 
## 3 Extremely Liberal       0.268   0.210    0.326 
## 4 Liberal                 0.277   0.232    0.322 
## 5 Slightly Conservative  -0.266  -0.330   -0.201 
## 6 Slightly Liberal        0.193   0.134    0.253 
## 7 Race: Black             0.403   0.369    0.437 
## 8 Race: Other             0.125   0.0490   0.200 
## 9 Female                  0.0443  0.00967  0.0789</code></pre>
<p>Now we have a table that we can plot as we have learned:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb225-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> bo_gg, <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(factor, AME),</a>
<a class="sourceLine" id="cb225-2" data-line-number="2">                              <span class="dt">y =</span> AME, <span class="dt">ymin =</span> lower, <span class="dt">ymax =</span> upper))</a>
<a class="sourceLine" id="cb225-3" data-line-number="3"/>
<a class="sourceLine" id="cb225-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="dv">0</span>, <span class="dt">color =</span> <span class="st">"gray80"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb225-5" data-line-number="5"><span class="st">    </span><span class="kw">geom_pointrange</span>() <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb225-6" data-line-number="6"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">"Average Marginal Effect"</span>) </a></code></pre>
<div class="figure"><span id="fig:ch-06-ameplot"/>
<p class="caption marginnote shownote">
Figure 6.10: Average marginal effects plot.
</p>
<img src="../Images/2dd558be4bdff7c74737e947984bbc4f.png" alt="Average marginal effects plot." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-ameplot-1.png"/>
</div>
<p>If we are just interested in getting conditional effects for a particular
variable, then conveniently we can ask the plot methods in the
margins library to do the work calculating effects for us but without
drawing their plot. Instead, they can return the results in a format we
can easily use in ggplot, and with less need for clean up, for the
clean-up. For example, with <code>cplot()</code>:</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-condeffplot"/>
<img src="../Images/8ac0e7da6d09561016fd87ab560c2c2a.png" alt="Conditional effects plot." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-condeffplot-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.11: Conditional effects plot.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb226-1" data-line-number="1">pv_cp &lt;-<span class="st"> </span><span class="kw">cplot</span>(out_bo, <span class="dt">x =</span> <span class="st">"sex"</span>, <span class="dt">draw =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb226-2" data-line-number="2"/>
<a class="sourceLine" id="cb226-3" data-line-number="3">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> pv_cp, <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(xvals, yvals),</a>
<a class="sourceLine" id="cb226-4" data-line-number="4">                              <span class="dt">y =</span> yvals, <span class="dt">ymin =</span> lower, <span class="dt">ymax =</span> upper))</a>
<a class="sourceLine" id="cb226-5" data-line-number="5"/>
<a class="sourceLine" id="cb226-6" data-line-number="6">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="dv">0</span>, <span class="dt">color =</span> <span class="st">"gray80"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb226-7" data-line-number="7"><span class="st">    </span><span class="kw">geom_pointrange</span>() <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb226-8" data-line-number="8"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">"Conditional Effect"</span>) </a></code></pre>
<p>The margins package is under active development. It can do much more
than described here. The vignettes that come with the package provide
more extensive discussion and numerous examples.</p>
&#13;

<h2><span class="header-section-number">6.8</span> Plots from complex surveys</h2>
<p>Social scientists often work with data collected using a complex survey design. Survey instruments may be stratified by region or some other characteristic, contain replicate weights to make them comparable to a reference population, have a clustered structure, and so on. In Chapter <a href="groupfacettx.html#groupfacettx">4</a> we learned how calculate and then plot frequency tables of categorical variables, using some data from the General Social Survey (GSS). However, if we want accurate estimates of US households from the GSS, we will need to take the survey’s design into account, and use the survey weights provided in the dataset. Thomas Lumley’s <code>survey</code> library provides a comprehensive set of tools for addressing these issues. The tools and the theory behind them are discussed in detail in <span class="citation">Lumley (2010)</span>, and an overview of the package is provided in <span class="citation">Lumley (2004)</span>. While the functions in the <code>survey</code> package are straightforward to use and return results in a generally tidy form, the package predates the tidyverse and its conventions by several years. This means we cannot use <code>survey</code> functions directly with <code>dplyr</code>. However, Greg Freedman Ellis has written a helper package, <code>srvyr</code>, that solves this problem for us, and lets us use the <code>survey</code> library’s functions within a data analysis pipeline in a familiar way.</p>
<p>For example, the <code>gss_lon</code> data contains a small subset of measures from every wave of the GSS since its inception in 1972. It also contains several variables that describe the design of the survey and provide replicate weights for observations in various years. These technical details are described in the GSS documentation. Similar information is typically provided by other complex surveys. Here we will use this design information to calculate weighted estimates of the distribution of educational attainment by race, for selected survey years from 1976 to 2016.</p>
<p>To begin, we load the <code>survey</code> and <code>srvyr</code> libraries.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb227-1" data-line-number="1"><span class="kw">library</span>(survey)</a>
<a class="sourceLine" id="cb227-2" data-line-number="2"><span class="kw">library</span>(srvyr)</a></code></pre>
<p>Next, we take our <code>gss_lon</code> dataset and use the <code>survey</code> tools to create a new object that contains the data, as before, but with some additional information about the survey’s design:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb228-1" data-line-number="1"><span class="kw">options</span>(<span class="dt">survey.lonely.psu =</span> <span class="st">"adjust"</span>)</a>
<a class="sourceLine" id="cb228-2" data-line-number="2"><span class="kw">options</span>(<span class="dt">na.action=</span><span class="st">"na.pass"</span>)</a>
<a class="sourceLine" id="cb228-3" data-line-number="3"/>
<a class="sourceLine" id="cb228-4" data-line-number="4">gss_wt &lt;-<span class="st"> </span><span class="kw">subset</span>(gss_lon, year <span class="op">&gt;</span><span class="st"> </span><span class="dv">1974</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb228-5" data-line-number="5"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">stratvar =</span> <span class="kw">interaction</span>(year, vstrat)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb228-6" data-line-number="6"><span class="st">    </span><span class="kw">as_survey_design</span>(<span class="dt">ids =</span> vpsu,</a>
<a class="sourceLine" id="cb228-7" data-line-number="7">                     <span class="dt">strata =</span> stratvar,</a>
<a class="sourceLine" id="cb228-8" data-line-number="8">                     <span class="dt">weights =</span> wtssall,</a>
<a class="sourceLine" id="cb228-9" data-line-number="9">                     <span class="dt">nest =</span> <span class="ot">TRUE</span>)</a></code></pre>
<p>The two <code>options</code> set at the beginning provide some information to the <code>survey</code> library about how to behave. You should consult <span class="citation">Lumley (2010)</span> and the <code>survey</code> package documentation for details. The subsequent operations create <code>gss_wt</code>, an object with one additional column (<code>stratvar</code>), describing the yearly sampling strata. We use the <code>interaction()</code> function to do this. It multiplies the <code>vstrat</code> variable by the <code>year</code> variable to get a vector of stratum information for each year.<label for="tufte-mn-72" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-72" class="margin-toggle"/><span class="marginnote shownote">We have to do this because of the way the GSS codes its stratum information.</span> In the next step, we use the <code>as_survey_design()</code> function to add the key pieces of information about the survey design. It adds information about the sampling identifiers (<code>ids</code>), the strata (<code>strata</code>), and the replicate weights (<code>weights</code>). With those in place we can take advantage of a large number of specialized functions in the <code>survey</code> library that allow us to calculate properly weighted survey means or estimate models with the correct sampling specification. For example, we can easily calculate the distribution of education by race for a series of years from 1976 to 2016. We use <code>survey_mean()</code> to do this:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb229-1" data-line-number="1">out_grp &lt;-<span class="st"> </span>gss_wt <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb229-2" data-line-number="2"><span class="st">    </span><span class="kw">filter</span>(year <span class="op">%in%</span><span class="st"> </span><span class="kw">seq</span>(<span class="dv">1976</span>, <span class="dv">2016</span>, <span class="dt">by =</span> <span class="dv">4</span>)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb229-3" data-line-number="3"><span class="st">    </span><span class="kw">group_by</span>(year, race, degree) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb229-4" data-line-number="4"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">prop =</span> <span class="kw">survey_mean</span>(<span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</a>
<a class="sourceLine" id="cb229-5" data-line-number="5"/>
<a class="sourceLine" id="cb229-6" data-line-number="6">out_grp</a></code></pre>
<pre><code>## # A tibble: 150 x 5
##     year race  degree           prop prop_se
##    &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt;           &lt;dbl&gt;   &lt;dbl&gt;
##  1  1976 White Lt High School 0.328  0.0160 
##  2  1976 White High School    0.518  0.0162 
##  3  1976 White Junior College 0.0129 0.00298
##  4  1976 White Bachelor       0.101  0.00960
##  5  1976 White Graduate       0.0393 0.00644
##  6  1976 Black Lt High School 0.562  0.0611 
##  7  1976 Black High School    0.337  0.0476 
##  8  1976 Black Junior College 0.0426 0.0193 
##  9  1976 Black Bachelor       0.0581 0.0239 
## 10  1976 Black Graduate       0      0      
## # ... with 140 more rows</code></pre>
<p>The results returned in <code>out_grp</code> include standard errors. We can also ask <code>survey_mean()</code> to calculate confidence intervals for us, if we wish.</p>
<p>Grouping with <code>group_by()</code> lets us calculate counts or means for the innermost variable, grouped by the next variable “up” or “out”, in this case, <code>degree</code> by <code>race</code>, such that the proportions for <code>degree</code> will sum to one for each group in <code>race</code>, and this will be done separately for each value of <code>year</code>. If we want the <em>marginal</em> frequencies, such that the values for all combinations of <code>race</code> and <code>degree</code> sum to one within each year, we first have to interact the variables we are cross-classifying. Then we group by the new interacted variable and do the calculation as before:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb231-1" data-line-number="1">out_mrg &lt;-<span class="st"> </span>gss_wt <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb231-2" data-line-number="2"><span class="st">    </span><span class="kw">filter</span>(year <span class="op">%in%</span><span class="st"> </span><span class="kw">seq</span>(<span class="dv">1976</span>, <span class="dv">2016</span>, <span class="dt">by =</span> <span class="dv">4</span>)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb231-3" data-line-number="3"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">racedeg =</span> <span class="kw">interaction</span>(race, degree)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb231-4" data-line-number="4"><span class="st">    </span><span class="kw">group_by</span>(year, racedeg) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb231-5" data-line-number="5"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">prop =</span> <span class="kw">survey_mean</span>(<span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</a>
<a class="sourceLine" id="cb231-6" data-line-number="6"/>
<a class="sourceLine" id="cb231-7" data-line-number="7">out_mrg</a></code></pre>
<pre><code>## # A tibble: 150 x 4
##     year racedeg                 prop prop_se
##    &lt;dbl&gt; &lt;fct&gt;                  &lt;dbl&gt;   &lt;dbl&gt;
##  1  1976 White.Lt High School 0.298   0.0146 
##  2  1976 Black.Lt High School 0.0471  0.00840
##  3  1976 Other.Lt High School 0.00195 0.00138
##  4  1976 White.High School    0.471   0.0160 
##  5  1976 Black.High School    0.0283  0.00594
##  6  1976 Other.High School    0.00325 0.00166
##  7  1976 White.Junior College 0.0117  0.00268
##  8  1976 Black.Junior College 0.00357 0.00162
##  9  1976 Other.Junior College 0       0      
## 10  1976 White.Bachelor       0.0919  0.00888
## # ... with 140 more rows</code></pre>
<p>This gives us the numbers that we want and returns them in a tidy data frame. The <code>interaction()</code> function produces variable labels that are a compound of the two variables we interacted, with each combination of categories separated by a period, (such as <code>White.Graduate</code>. However, perhaps we would like to see these categories as two separate columns, one for race and one for education, as before. Because the variable labels are organized in a predictable way, we can use one of the convenient functions in the tidyverse’s <code>tidyr</code> library to separate the single variable into two columns while correctly preserving the row values. Appropriately, this function is called <code>separate()</code>.<label for="tufte-mn-73" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-73" class="margin-toggle"/><span class="marginnote shownote">The two backslashes before the period in the call to <code>separate</code> are necessary for R to interpret it literally as a period. By default in search and replace operations like this, the search terms are regular expressions. The period acts as a special character, a kind of wildcard, meaning ‘any character at all’. To make the regular expression engine treat it literally, we add one backslash before it. The backslash is an ‘escape’ character. It means ‘The next character is going to be treated differently from usual’. However, because the backslash is a special character as well, we need to add a second backslash to make sure the parser sees it properly.</span></p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb233-1" data-line-number="1">out_mrg &lt;-<span class="st"> </span>gss_wt <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb233-2" data-line-number="2"><span class="st">    </span><span class="kw">filter</span>(year <span class="op">%in%</span><span class="st"> </span><span class="kw">seq</span>(<span class="dv">1976</span>, <span class="dv">2016</span>, <span class="dt">by =</span> <span class="dv">4</span>)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb233-3" data-line-number="3"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">racedeg =</span> <span class="kw">interaction</span>(race, degree)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb233-4" data-line-number="4"><span class="st">    </span><span class="kw">group_by</span>(year, racedeg) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb233-5" data-line-number="5"><span class="st">    </span><span class="kw">summarize</span>(<span class="dt">prop =</span> <span class="kw">survey_mean</span>(<span class="dt">na.rm =</span> <span class="ot">TRUE</span>)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb233-6" data-line-number="6"><span class="st">    </span><span class="kw">separate</span>(racedeg, <span class="dt">sep =</span> <span class="st">"</span><span class="ch">\\</span><span class="st">."</span>, <span class="dt">into =</span> <span class="kw">c</span>(<span class="st">"race"</span>, <span class="st">"degree"</span>))</a>
<a class="sourceLine" id="cb233-7" data-line-number="7"/>
<a class="sourceLine" id="cb233-8" data-line-number="8">out_mrg</a></code></pre>
<pre><code>## # A tibble: 150 x 5
##     year race  degree            prop prop_se
##    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;            &lt;dbl&gt;   &lt;dbl&gt;
##  1  1976 White Lt High School 0.298   0.0146 
##  2  1976 Black Lt High School 0.0471  0.00840
##  3  1976 Other Lt High School 0.00195 0.00138
##  4  1976 White High School    0.471   0.0160 
##  5  1976 Black High School    0.0283  0.00594
##  6  1976 Other High School    0.00325 0.00166
##  7  1976 White Junior College 0.0117  0.00268
##  8  1976 Black Junior College 0.00357 0.00162
##  9  1976 Other Junior College 0       0      
## 10  1976 White Bachelor       0.0919  0.00888
## # ... with 140 more rows</code></pre>
<p>The call to <code>separate()</code> says to take the <code>racedeg</code> column, split each value when it sees a period, and reorganize the results into two columns, <code>race</code> and <code>degree</code>. This gives us a tidy table much like <code>out_grp</code>, but for the marginal frequencies.</p>
<p>Reasonable people can disagree over how best to plot a small multiple of a frequency table while faceting by year, especially when there is some measure of uncertainty attached. A barplot is the obvious approach for a single case, but when there are many years it can become difficult to compare bars across panels. This is especially the case when standard errors or confidence intervals are used in conjunction with bars.<label for="tufte-mn-74" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-74" class="margin-toggle"/><span class="marginnote shownote">Sometimes it may be preferable to show that the underlying variable is categorical, as a bar chart makes clear, and not continuous, as a line graph suggests. Here the trade-off is in favor of the line graphs as the bars are very hard to compare across facets.</span> This is sometimes called a “dynamite plot”, not because it looks amazing but because the t-shaped error bars on the tops of the columns make them look like cartoon dynamite plungers. An alternative is to use a line graph to join up the time observations, faceting on educational categories instead of year. Figure <a href="modeling.html#fig:ch-06-svyyears">6.12</a> shows the results for our GSS data in dynamite-plot form, where the error bars are defined as twice the standard error in either direction around the point estimate.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb235-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> <span class="kw">subset</span>(out_grp, race <span class="op">%nin%</span><span class="st"> "Other"</span>),</a>
<a class="sourceLine" id="cb235-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> degree, <span class="dt">y =</span> prop,</a>
<a class="sourceLine" id="cb235-3" data-line-number="3">                          <span class="dt">ymin =</span> prop <span class="op">-</span><span class="st"> </span><span class="dv">2</span><span class="op">*</span>prop_se,</a>
<a class="sourceLine" id="cb235-4" data-line-number="4">                          <span class="dt">ymax =</span> prop <span class="op">+</span><span class="st"> </span><span class="dv">2</span><span class="op">*</span>prop_se,</a>
<a class="sourceLine" id="cb235-5" data-line-number="5">                          <span class="dt">fill =</span> race,</a>
<a class="sourceLine" id="cb235-6" data-line-number="6">                          <span class="dt">color =</span> race,</a>
<a class="sourceLine" id="cb235-7" data-line-number="7">                          <span class="dt">group =</span> race))</a>
<a class="sourceLine" id="cb235-8" data-line-number="8"/>
<a class="sourceLine" id="cb235-9" data-line-number="9">dodge &lt;-<span class="st"> </span><span class="kw">position_dodge</span>(<span class="dt">width=</span><span class="fl">0.9</span>)</a>
<a class="sourceLine" id="cb235-10" data-line-number="10"/>
<a class="sourceLine" id="cb235-11" data-line-number="11">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_col</span>(<span class="dt">position =</span> dodge, <span class="dt">alpha =</span> <span class="fl">0.2</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb235-12" data-line-number="12"><span class="st">    </span><span class="kw">geom_errorbar</span>(<span class="dt">position =</span> dodge, <span class="dt">width =</span> <span class="fl">0.2</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb235-13" data-line-number="13"><span class="st">    </span><span class="kw">scale_x_discrete</span>(<span class="dt">labels =</span> scales<span class="op">::</span><span class="kw">wrap_format</span>(<span class="dv">10</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb235-14" data-line-number="14"><span class="st">    </span><span class="kw">scale_y_continuous</span>(<span class="dt">labels =</span> scales<span class="op">::</span>percent) <span class="op">+</span></a>
<a class="sourceLine" id="cb235-15" data-line-number="15"><span class="st">    </span><span class="kw">scale_color_brewer</span>(<span class="dt">type =</span> <span class="st">"qual"</span>, <span class="dt">palette =</span> <span class="st">"Dark2"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb235-16" data-line-number="16"><span class="st">    </span><span class="kw">scale_fill_brewer</span>(<span class="dt">type =</span> <span class="st">"qual"</span>, <span class="dt">palette =</span> <span class="st">"Dark2"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb235-17" data-line-number="17"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">"Educational Attainment by Race"</span>,</a>
<a class="sourceLine" id="cb235-18" data-line-number="18">         <span class="dt">subtitle =</span> <span class="st">"GSS 1976-2016"</span>,</a>
<a class="sourceLine" id="cb235-19" data-line-number="19">         <span class="dt">fill =</span> <span class="st">"Race"</span>,</a>
<a class="sourceLine" id="cb235-20" data-line-number="20">         <span class="dt">color =</span> <span class="st">"Race"</span>,</a>
<a class="sourceLine" id="cb235-21" data-line-number="21">         <span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">"Percent"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb235-22" data-line-number="22"><span class="st">    </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>year, <span class="dt">ncol =</span> <span class="dv">2</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb235-23" data-line-number="23"><span class="st">    </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
<div class="figure"><span id="fig:ch-06-svyyears"/>
<p class="caption marginnote shownote">
Figure 6.12: Weighted estimates of educational attainment for Whites and Blacks, GSS selected years 1976-2016. Faceting barplots is often a bad idea, and the more facets there are the worse an idea it is. With a small-multiple plot the viewer wants to compare across panels (in this case, over time), but this is difficult to do when the data inside the panels are categorical comparisons shown as bars (in this case, education level by group).
</p>
<img src="../Images/1fe47b8275a8fdedb0c705fdb59bee6a.png" alt="Weighted estimates of educational attainment for Whites and Blacks, GSS selected years 1976-2016. Faceting barplots is often a bad idea, and the more facets there are the worse an idea it is. With a small-multiple plot the viewer wants to compare across panels (in this case, over time), but this is difficult to do when the data inside the panels are categorical comparisons shown as bars (in this case, education level by group)." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-svyyears-1.png"/>
</div>
<p>This plot has a few cosmetic details and adjustments that we will learn more about in Chapter <a href="refineplots.html#refineplots">8</a>. As before, I encourage you to peel back the plot from the bottom, one instruction at a time, to see what changes. One useful adjustment to notice is the new call to the <code>scales</code> library to adjust the labels on the x-axis. The adjustment on the y-axis is familiar, <code>scales::percent</code> to convert the proportion to a percentage. On the x-axis, the issue is that several of the labels are rather long. If we do not adjust them they will print over one another. The <code>scales::wrap_format()</code> function will break long labels into lines. It takes a single numerical argument (here <code>10</code>) that is the maxmimum length a string can be before it is wrapped onto a new line.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-svyyears2"/>
<img src="../Images/c4e4a7dbf051feeb43ed1d4a236124ed.png" alt="Faceting by education instead." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-svyyears2-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.13: Faceting by education instead.<!--</p>-->
<!--</div>--></span>
</p>
<p>A graph like this is true to the categorical nature of the data, while showing the breakdown of groups within each year. But you should experiment with some alternatives. For example, we might decide that it is better to facet by degree category instead, and put the year on the x-axis within each panel. If we do that, then we can use <code>geom_line()</code> to show a time trend, which is more natural, and <code>geom_ribbon()</code> to show the error range. This is perhaps a better way to show the data, especially as it brings out the time trends within each degree category, and allows us to see the similarities and differences by racial classification at the same time.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb236-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> <span class="kw">subset</span>(out_grp, race <span class="op">%nin%</span><span class="st"> "Other"</span>),</a>
<a class="sourceLine" id="cb236-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year, <span class="dt">y =</span> prop, <span class="dt">ymin =</span> prop <span class="op">-</span><span class="st"> </span><span class="dv">2</span><span class="op">*</span>prop_se,</a>
<a class="sourceLine" id="cb236-3" data-line-number="3">                          <span class="dt">ymax =</span> prop <span class="op">+</span><span class="st"> </span><span class="dv">2</span><span class="op">*</span>prop_se, <span class="dt">fill =</span> race, <span class="dt">color =</span> race,</a>
<a class="sourceLine" id="cb236-4" data-line-number="4">                          <span class="dt">group =</span> race))</a>
<a class="sourceLine" id="cb236-5" data-line-number="5"/>
<a class="sourceLine" id="cb236-6" data-line-number="6">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_ribbon</span>(<span class="dt">alpha =</span> <span class="fl">0.3</span>, <span class="kw">aes</span>(<span class="dt">color =</span> <span class="ot">NULL</span>)) <span class="op">+</span></a>
<a class="sourceLine" id="cb236-7" data-line-number="7"><span class="st">    </span><span class="kw">geom_line</span>() <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb236-8" data-line-number="8"><span class="st">    </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>degree, <span class="dt">ncol =</span> <span class="dv">1</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb236-9" data-line-number="9"><span class="st">    </span><span class="kw">scale_y_continuous</span>(<span class="dt">labels =</span> scales<span class="op">::</span>percent) <span class="op">+</span></a>
<a class="sourceLine" id="cb236-10" data-line-number="10"><span class="st">    </span><span class="kw">scale_color_brewer</span>(<span class="dt">type =</span> <span class="st">"qual"</span>, <span class="dt">palette =</span> <span class="st">"Dark2"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb236-11" data-line-number="11"><span class="st">    </span><span class="kw">scale_fill_brewer</span>(<span class="dt">type =</span> <span class="st">"qual"</span>, <span class="dt">palette =</span> <span class="st">"Dark2"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb236-12" data-line-number="12"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">"Educational Attainment</span><span class="ch">\n</span><span class="st">by Race"</span>,</a>
<a class="sourceLine" id="cb236-13" data-line-number="13">         <span class="dt">subtitle =</span> <span class="st">"GSS 1976-2016"</span>, <span class="dt">fill =</span> <span class="st">"Race"</span>,</a>
<a class="sourceLine" id="cb236-14" data-line-number="14">         <span class="dt">color =</span> <span class="st">"Race"</span>, <span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">"Percent"</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb236-15" data-line-number="15"><span class="st">    </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
&#13;

<h2><span class="header-section-number">6.9</span> Where to go next</h2>
<p>In general, when you estimate models and want to plot the results, the difficult step is not the plotting but rather calculating and extracting the right numbers. Generating predicted values and measures of confidence or uncertainty from models requires that you understand the model you are fitting, and the function you use to fit it, especially when it involves interactions, cross-level effects, or transformations of the predictor or response scales. The details can vary substantially from model type to model type, and also with the goals of any particular analysis. It is unwise to approach them mechanically. That said, several tools exist to help you work with model objects and produce a default set of plots from them.</p>
<div id="default-plots-for-models" class="section level3">
<h3><span class="header-section-number">6.9.1</span> Default plots for models</h3>
<p>Just as model objects in R usually have a default <code>summary()</code> method,
printing out an overview tailored to the type of model it is, they
will usually have a default <code>plot()</code> method, too. Figures produced by
<code>plot()</code> are typically not generated via ggplot, but it is usually
worth exploring them. They typically make use of either R’s base
graphics or the <code>lattice</code> library <span class="citation">(Sarkar, 2008)</span>. These are two plotting systems that
we do not cover in this book. Default plot methods are easy to
examine. Let’s take a look again at our simple OLS model.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb237-1" data-line-number="1">out &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="dt">formula =</span> lifeExp <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(gdpPercap) <span class="op">+</span><span class="st"> </span>pop <span class="op">+</span><span class="st"> </span>continent, <span class="dt">data =</span> gapminder)</a></code></pre>
<p>To look at some of R’s default plots for this model, use the <code>plot()</code>
function.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb238-1" data-line-number="1"><span class="co"># Plot not shown</span></a>
<a class="sourceLine" id="cb238-2" data-line-number="2"><span class="kw">plot</span>(out, <span class="dt">which =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>), <span class="dt">ask=</span><span class="ot">FALSE</span>)</a></code></pre>
<p>The <code>which()</code> statement here selects the first two of four default
plots for this kind of model. If you want to easily reproduce base R’s
default model graphics using ggplot, the <code>ggfortify</code> library is worth
examining. It is in some ways similar to <code>broom</code>, in that it tidies
the output of model objects, but it focuses on producing a standard plot
(or group of plots) for a wide variety of model types. It does this by
defining a function called <code>autoplot()</code>. The idea is to be able to use
<code>autoplot()</code> with the output of many different kinds of model.</p>
<p>A second option worth looking at is the <code>coefplot</code> library. It
provides a quick way to produce good-quality plots of point estimates
and confidence intervals. It has the advantage of managing the
estimation of interaction effects and other occasionally tricky
calculations.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-coefplot"/>
<img src="../Images/33f6d7587e738968b391596c468ee85a.png" alt="A plot from coefplot." width="480" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-coefplot-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.14: A plot from coefplot.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb239-1" data-line-number="1"><span class="kw">library</span>(coefplot)</a>
<a class="sourceLine" id="cb239-2" data-line-number="2">out &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="dt">formula =</span> lifeExp <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(gdpPercap) <span class="op">+</span><span class="st"> </span><span class="kw">log</span>(pop) <span class="op">+</span><span class="st"> </span>continent, <span class="dt">data =</span> gapminder)</a>
<a class="sourceLine" id="cb239-3" data-line-number="3"/>
<a class="sourceLine" id="cb239-4" data-line-number="4"><span class="kw">coefplot</span>(out, <span class="dt">sort =</span> <span class="st">"magnitude"</span>, <span class="dt">intercept =</span> <span class="ot">FALSE</span>)</a></code></pre>
</div>
<div id="tools-in-development" class="section level3">
<h3><span class="header-section-number">6.9.2</span> Tools in development</h3>
<p>Tidyverse tools for modeling and model exploration are being actively developed. The <code>broom</code> and <code>margins</code> libraries continue to get more and more useful. There are also other projects worth paying attention to. The <code>infer</code> package<label for="tufte-mn-75" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-75" class="margin-toggle"/><span class="marginnote shownote"><code>infer.netlify.com</code></span> is in its early stages but can already do useful things in a pipeline-friendly way. You can install it from CRAN with <code>install.packages("infer")</code>.</p>
</div>
<div id="extensions-to-ggplot" class="section level3">
<h3><span class="header-section-number">6.9.3</span> Extensions to ggplot</h3>
<p>The GGally package provides a suite of functions designed to make producing standard but somewhat complex plots a little easier. For instance, it can produce generalized pairs plots, a useful way of quickly examining possible relationships between several different variables at once. This sort of plot is like the visual version of a correlation matrix. It shows a bivariate plot for all pairs of variables in the data. This is relatively straightforward when all the variables are continuous measures. Things get more complex when, as is often the case in the social sciences, some or all variables are categorical or otherwise limited in the range of values they can take. A generalized pairs plot can handle these cases. For example, Figure <a href="#fig:ch-06-ggallyplot"><strong>??</strong></a> shows a generalized pairs plot for five variables from the <code>organdata</code> dataset.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb240-1" data-line-number="1"><span class="kw">library</span>(GGally)</a>
<a class="sourceLine" id="cb240-2" data-line-number="2"/>
<a class="sourceLine" id="cb240-3" data-line-number="3">organdata_sm &lt;-<span class="st"> </span>organdata <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb240-4" data-line-number="4"><span class="st">    </span><span class="kw">select</span>(donors, pop_dens, pubhealth,</a>
<a class="sourceLine" id="cb240-5" data-line-number="5">           roads, consent_law)</a>
<a class="sourceLine" id="cb240-6" data-line-number="6"/>
<a class="sourceLine" id="cb240-7" data-line-number="7"><span class="kw">ggpairs</span>(<span class="dt">data =</span> organdata_sm,</a>
<a class="sourceLine" id="cb240-8" data-line-number="8">        <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">color =</span> consent_law),</a>
<a class="sourceLine" id="cb240-9" data-line-number="9">        <span class="dt">upper =</span> <span class="kw">list</span>(<span class="dt">continuous =</span> <span class="kw">wrap</span>(<span class="st">"density"</span>), <span class="dt">combo =</span> <span class="st">"box_no_facet"</span>),</a>
<a class="sourceLine" id="cb240-10" data-line-number="10">        <span class="dt">lower =</span> <span class="kw">list</span>(<span class="dt">continuous =</span> <span class="kw">wrap</span>(<span class="st">"points"</span>), <span class="dt">combo =</span> <span class="kw">wrap</span>(<span class="st">"dot_no_facet"</span>)))</a></code></pre>
<p>Multi-panel plots like this are intrinsically very rich in information. When combined with several within-panel types of representation, or any more than a modest number of variables, they can become quite complex. They should be used less for the presentation of finished work, although it is possible. More often they are a useful tool for the working researcher to quickly investigate aspects of a data set. The goal is not to pithily summarize a single point one already knows, but to open things up for further exploration.</p>

</div>
&#13;

<h3><span class="header-section-number">6.9.1</span> Default plots for models</h3>
<p>Just as model objects in R usually have a default <code>summary()</code> method,
printing out an overview tailored to the type of model it is, they
will usually have a default <code>plot()</code> method, too. Figures produced by
<code>plot()</code> are typically not generated via ggplot, but it is usually
worth exploring them. They typically make use of either R’s base
graphics or the <code>lattice</code> library <span class="citation">(Sarkar, 2008)</span>. These are two plotting systems that
we do not cover in this book. Default plot methods are easy to
examine. Let’s take a look again at our simple OLS model.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb237-1" data-line-number="1">out &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="dt">formula =</span> lifeExp <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(gdpPercap) <span class="op">+</span><span class="st"> </span>pop <span class="op">+</span><span class="st"> </span>continent, <span class="dt">data =</span> gapminder)</a></code></pre>
<p>To look at some of R’s default plots for this model, use the <code>plot()</code>
function.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb238-1" data-line-number="1"><span class="co"># Plot not shown</span></a>
<a class="sourceLine" id="cb238-2" data-line-number="2"><span class="kw">plot</span>(out, <span class="dt">which =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>), <span class="dt">ask=</span><span class="ot">FALSE</span>)</a></code></pre>
<p>The <code>which()</code> statement here selects the first two of four default
plots for this kind of model. If you want to easily reproduce base R’s
default model graphics using ggplot, the <code>ggfortify</code> library is worth
examining. It is in some ways similar to <code>broom</code>, in that it tidies
the output of model objects, but it focuses on producing a standard plot
(or group of plots) for a wide variety of model types. It does this by
defining a function called <code>autoplot()</code>. The idea is to be able to use
<code>autoplot()</code> with the output of many different kinds of model.</p>
<p>A second option worth looking at is the <code>coefplot</code> library. It
provides a quick way to produce good-quality plots of point estimates
and confidence intervals. It has the advantage of managing the
estimation of interaction effects and other occasionally tricky
calculations.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-06-coefplot"/>
<img src="../Images/33f6d7587e738968b391596c468ee85a.png" alt="A plot from coefplot." width="480" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-06-coefplot-1.png"/>
<!--
<p class="caption marginnote">-->Figure 6.14: A plot from coefplot.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb239-1" data-line-number="1"><span class="kw">library</span>(coefplot)</a>
<a class="sourceLine" id="cb239-2" data-line-number="2">out &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="dt">formula =</span> lifeExp <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(gdpPercap) <span class="op">+</span><span class="st"> </span><span class="kw">log</span>(pop) <span class="op">+</span><span class="st"> </span>continent, <span class="dt">data =</span> gapminder)</a>
<a class="sourceLine" id="cb239-3" data-line-number="3"/>
<a class="sourceLine" id="cb239-4" data-line-number="4"><span class="kw">coefplot</span>(out, <span class="dt">sort =</span> <span class="st">"magnitude"</span>, <span class="dt">intercept =</span> <span class="ot">FALSE</span>)</a></code></pre>
&#13;

<h3><span class="header-section-number">6.9.2</span> Tools in development</h3>
<p>Tidyverse tools for modeling and model exploration are being actively developed. The <code>broom</code> and <code>margins</code> libraries continue to get more and more useful. There are also other projects worth paying attention to. The <code>infer</code> package<label for="tufte-mn-75" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-75" class="margin-toggle"/><span class="marginnote shownote"><code>infer.netlify.com</code></span> is in its early stages but can already do useful things in a pipeline-friendly way. You can install it from CRAN with <code>install.packages("infer")</code>.</p>
&#13;

<h3><span class="header-section-number">6.9.3</span> Extensions to ggplot</h3>
<p>The GGally package provides a suite of functions designed to make producing standard but somewhat complex plots a little easier. For instance, it can produce generalized pairs plots, a useful way of quickly examining possible relationships between several different variables at once. This sort of plot is like the visual version of a correlation matrix. It shows a bivariate plot for all pairs of variables in the data. This is relatively straightforward when all the variables are continuous measures. Things get more complex when, as is often the case in the social sciences, some or all variables are categorical or otherwise limited in the range of values they can take. A generalized pairs plot can handle these cases. For example, Figure <a href="#fig:ch-06-ggallyplot"><strong>??</strong></a> shows a generalized pairs plot for five variables from the <code>organdata</code> dataset.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb240-1" data-line-number="1"><span class="kw">library</span>(GGally)</a>
<a class="sourceLine" id="cb240-2" data-line-number="2"/>
<a class="sourceLine" id="cb240-3" data-line-number="3">organdata_sm &lt;-<span class="st"> </span>organdata <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb240-4" data-line-number="4"><span class="st">    </span><span class="kw">select</span>(donors, pop_dens, pubhealth,</a>
<a class="sourceLine" id="cb240-5" data-line-number="5">           roads, consent_law)</a>
<a class="sourceLine" id="cb240-6" data-line-number="6"/>
<a class="sourceLine" id="cb240-7" data-line-number="7"><span class="kw">ggpairs</span>(<span class="dt">data =</span> organdata_sm,</a>
<a class="sourceLine" id="cb240-8" data-line-number="8">        <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">color =</span> consent_law),</a>
<a class="sourceLine" id="cb240-9" data-line-number="9">        <span class="dt">upper =</span> <span class="kw">list</span>(<span class="dt">continuous =</span> <span class="kw">wrap</span>(<span class="st">"density"</span>), <span class="dt">combo =</span> <span class="st">"box_no_facet"</span>),</a>
<a class="sourceLine" id="cb240-10" data-line-number="10">        <span class="dt">lower =</span> <span class="kw">list</span>(<span class="dt">continuous =</span> <span class="kw">wrap</span>(<span class="st">"points"</span>), <span class="dt">combo =</span> <span class="kw">wrap</span>(<span class="st">"dot_no_facet"</span>)))</a></code></pre>
<p>Multi-panel plots like this are intrinsically very rich in information. When combined with several within-panel types of representation, or any more than a modest number of variables, they can become quite complex. They should be used less for the presentation of finished work, although it is possible. More often they are a useful tool for the working researcher to quickly investigate aspects of a data set. The goal is not to pithily summarize a single point one already knows, but to open things up for further exploration.</p>

    
</body>
</html>