- en: 19Â State and EqualityğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19 çŠ¶æ€ä¸ç­‰ä»·[ğŸ”—](#(part._state-and-equality) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/state-in-pyret.html](https://dcic-world.org/2025-08-27/state-in-pyret.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/state-in-pyret.html](https://dcic-world.org/2025-08-27/state-in-pyret.html)
- en: '| Â Â Â Â [19.1Â Boxes: A Canonical Mutable Structure](#%28part._boxes%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   [19.1 ç›’å­ï¼šä¸€ä¸ªè§„èŒƒçš„å¯å˜ç»“æ„](#%28part._boxes%29) |'
- en: '| Â Â Â Â [19.2Â Mutation and Types](#%28part._.Mutation_and_.Types%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|   [19.2 å˜å¼‚ä¸ç±»å‹](#%28part._.Mutation_and_.Types%29) |'
- en: '| Â Â Â Â [19.3Â Mutation and Equality](#%28part._.Mutation_and_.Equality%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|   [19.3 å˜å¼‚ä¸ç­‰ä»·](#%28part._.Mutation_and_.Equality%29) |'
- en: '| Â Â Â Â [19.4Â Another Equality Predicate](#%28part._.Another_.Equality_.Predicate%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|   [19.4 å¦ä¸€ä¸ªç­‰ä»·è°“è¯](#%28part._.Another_.Equality_.Predicate%29) |'
- en: '| Â Â Â Â [19.5Â A Hierarchy of Equality](#%28part._equality-hierarchy%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|   [19.5 ç­‰çº§ä½“ç³»](#%28part._equality-hierarchy%29) |'
- en: '| Â Â Â Â [19.6Â Space and Time Complexity](#%28part._.Space_and_.Time_.Complexity%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|   [19.6 ç©ºé—´å’Œæ—¶é—´å¤æ‚åº¦](#%28part._.Space_and_.Time_.Complexity%29) |'
- en: '| Â Â Â Â [19.7Â What it Means to be Identical](#%28part._sem-identical%29) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|   [19.7 ç›¸åŒæ„å‘³ç€ä»€ä¹ˆ](#%28part._sem-identical%29) |'
- en: '| Â Â Â Â [19.8Â Comparing Functions](#%28part._comp-func%29) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|   [19.8 æ¯”è¾ƒå‡½æ•°](#%28part._comp-func%29) |'
- en: 'In [Mutating Structures](mutating-structures.html), we introduced the notion
    of mutable data. We also saw the impact it has on testing. Underlying testing
    is some notion of equality: when we write a test in Pyret using `is`, we are implicitly
    making a statement about equality between the two sides. Here we will examine
    equality in the presence of state in more detail.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ [å˜å¼‚ç»“æ„](mutating-structures.html) ä¸­ï¼Œæˆ‘ä»¬å¼•å…¥äº†å¯å˜æ•°æ®çš„æ¦‚å¿µã€‚æˆ‘ä»¬è¿˜çœ‹åˆ°äº†å®ƒå¯¹æµ‹è¯•çš„å½±å“ã€‚æµ‹è¯•çš„åŸºç¡€æ˜¯æŸç§ç­‰ä»·æ€§çš„æ¦‚å¿µï¼šå½“æˆ‘ä»¬ä½¿ç”¨
    `is` åœ¨ Pyret ä¸­ç¼–å†™æµ‹è¯•æ—¶ï¼Œæˆ‘ä»¬éšå¼åœ°åšå‡ºäº†å…³äºä¸¤è¾¹çš„ç­‰ä»·æ€§å£°æ˜ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†æ›´è¯¦ç»†åœ°ç ”ç©¶å­˜åœ¨çŠ¶æ€æ—¶çš„ç­‰ä»·æ€§ã€‚
- en: '19.1Â Boxes: A Canonical Mutable Structure[ğŸ”—](#(part._boxes) "Link to here")'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1 ç›’å­ï¼šä¸€ä¸ªè§„èŒƒçš„å¯å˜ç»“æ„[ğŸ”—](#(part._boxes) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'In [Mutating Structures](mutating-structures.html) we saw a motivating example
    using bank accounts. To focus our study of equality, it can be convenient to have
    an even simpler mutable data structure, called a box (which you will find in other
    programming languages as well). A box has only one fieldâ€”<wbr>the value being
    boxedâ€”<wbr>and supports just three operations:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ [å˜å¼‚ç»“æ„](mutating-structures.html) ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†ä¸€ä¸ªä½¿ç”¨é“¶è¡Œè´¦æˆ·çš„æ¿€åŠ±ç¤ºä¾‹ã€‚ä¸ºäº†é›†ä¸­ç ”ç©¶ç­‰ä»·æ€§ï¼Œæœ‰ä¸€ä¸ªæ›´ç®€å•çš„å¯å˜æ•°æ®ç»“æ„å¯èƒ½å¾ˆæ–¹ä¾¿ï¼Œç§°ä¸ºç›’å­ï¼ˆä½ ä¹Ÿä¼šåœ¨å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­æ‰¾åˆ°å®ƒï¼‰ã€‚ç›’å­åªæœ‰ä¸€ä¸ªå­—æ®µâ€”â€”è¢«å°è£…çš„å€¼â€”â€”å¹¶ä¸”æ”¯æŒä»…ä¸‰ä¸ªæ“ä½œï¼š
- en: box consumes a value and creates a mutable box containing that value.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: box æ¶ˆè€—ä¸€ä¸ªå€¼å¹¶åˆ›å»ºä¸€ä¸ªåŒ…å«è¯¥å€¼çš„å¯å˜ç›’å­ã€‚
- en: unbox-now consumes a box and returns the value contained in the box.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: unbox-now æ¶ˆè€—ä¸€ä¸ªç›’å­å¹¶è¿”å›ç›’å­ä¸­çš„å€¼ã€‚
- en: set-box-now consumes a box, a new value, and changes the box to contain the
    value. All subsequent unbox-nows of that box will now return the new valueâ€”<wbr>unless
    it is mutated again.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: set-box-now æ¶ˆè€—ä¸€ä¸ªç›’å­ã€ä¸€ä¸ªæ–°å€¼ï¼Œå¹¶å°†ç›’å­æ›´æ”¹ä¸ºåŒ…å«è¯¥å€¼ã€‚è¯¥ç›’å­çš„æ‰€æœ‰åç»­ unbox-now æ“ä½œç°åœ¨å°†è¿”å›æ–°å€¼â€”â€”é™¤éå®ƒå†æ¬¡è¢«å˜å¼‚ã€‚
- en: 'Here are the corresponding definitions in Pyret:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯ Pyret ä¸­ç›¸åº”çš„å®šä¹‰ï¼š
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Observe that we use `b!v` to extract the current value, and use the naming convention
    of `-now` to make clear these are stateful operations, so the value now may not
    be the same as the value later.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°æˆ‘ä»¬ä½¿ç”¨ `b!v` æ¥æå–å½“å‰å€¼ï¼Œå¹¶ä½¿ç”¨ `-now` çš„å‘½åçº¦å®šæ¥æ˜ç¡®è¿™äº›æ˜¯çŠ¶æ€æ“ä½œï¼Œå› æ­¤ç°åœ¨çš„å€¼å¯èƒ½ä¸ç­‰äºä»¥åçš„å€¼ã€‚
- en: 19.2Â Mutation and Types[ğŸ”—](#(part._.Mutation_and_.Types) "Link to here")
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.2 å˜å¼‚ä¸ç±»å‹[ğŸ”—](#(part._.Mutation_and_.Types) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: In terms of types, whenever we replace the value in a box, we want it to be
    type-consistent with what was previously there. Otherwise it would be very difficult
    to program against a box, because the type of its content would keep changing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç±»å‹æ–¹é¢ï¼Œæ— è®ºä½•æ—¶æˆ‘ä»¬åœ¨ç›’å­ä¸­æ›¿æ¢å€¼ï¼Œæˆ‘ä»¬éƒ½å¸Œæœ›å®ƒä¸ä¹‹å‰çš„å†…å®¹ä¿æŒç±»å‹ä¸€è‡´ã€‚å¦åˆ™ï¼Œé’ˆå¯¹ç›’å­ç¼–ç¨‹å°†ä¼šéå¸¸å›°éš¾ï¼Œå› ä¸ºå…¶å†…å®¹çš„ç±»å‹ä¼šä¸æ–­å˜åŒ–ã€‚
- en: 'These definitions obey the following tests:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›å®šä¹‰éµå¾ªä»¥ä¸‹æµ‹è¯•ï¼š
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, we cannot write `set-box-now(n1, "hi")`, because that would violate
    the type of `n1`, which is `Box<Number>`. We could make this explicit by writing
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œæˆ‘ä»¬ä¸èƒ½å†™ `set-box-now(n1, "hi")`ï¼Œå› ä¸ºè¿™ä¼šè¿å `n1` çš„ç±»å‹ï¼Œå®ƒæ˜¯ `Box<Number>`ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼ä½¿å…¶æ˜ç¡®ï¼š
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'if we wanted to be explicit. However, note that `n1` being a box of numbers
    does not preclude us from having a box of strings:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³æ˜ç¡®çš„è¯ã€‚ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œ`n1` æ˜¯ä¸€ä¸ªæ•°å­—çš„ç›’å­å¹¶ä¸æ„å‘³ç€æˆ‘ä»¬ä¸èƒ½æœ‰ä¸€ä¸ªå­—ç¬¦ä¸²çš„ç›’å­ï¼š
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: or indeed a box of any other type. We just need its type to remain consistent,
    whatever that type is.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…ç¡®å®æ˜¯ä¸€ä¸ªä»»ä½•å…¶ä»–ç±»å‹çš„ç›’å­ã€‚æˆ‘ä»¬åªéœ€è¦å…¶ç±»å‹ä¿æŒä¸€è‡´ï¼Œæ— è®ºè¿™ä¸ªç±»å‹æ˜¯ä»€ä¹ˆã€‚
- en: 'This is a general rule we want to follow with mutable data: the new value must
    be the same type as the old value. This gives programs a consistent interface
    to program against. For instance, above, we know that we can always perform numeric
    operations against the value extracted from `n1`â€”<wbr>there is no danger that
    it will suddenly produce a string. This discipline can either be enforced by a
    system of annotations, or has to be manually maintained by the programmer.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æˆ‘ä»¬å¸Œæœ›éµå¾ªçš„å¯å˜æ•°æ®çš„é€šç”¨è§„åˆ™ï¼šæ–°å€¼å¿…é¡»ä¸æ—§å€¼ç›¸åŒç±»å‹ã€‚è¿™ä¸ºç¨‹åºæä¾›äº†ä¸€ä¸ªä¸€è‡´çš„æ¥å£ã€‚ä¾‹å¦‚ï¼Œä¸Šé¢ï¼Œæˆ‘ä»¬çŸ¥é“æˆ‘ä»¬å¯ä»¥å§‹ç»ˆå¯¹ä»`n1`æå–çš„å€¼æ‰§è¡Œæ•°å€¼æ“ä½œâ€”â€”<wbr>æ²¡æœ‰çªç„¶äº§ç”Ÿå­—ç¬¦ä¸²çš„å±é™©ã€‚è¿™ç§çºªå¾‹å¯ä»¥é€šè¿‡æ³¨é‡Šç³»ç»Ÿå¼ºåˆ¶æ‰§è¡Œï¼Œæˆ–è€…å¿…é¡»ç”±ç¨‹åºå‘˜æ‰‹åŠ¨ç»´æŠ¤ã€‚
- en: 19.3Â Mutation and Equality[ğŸ”—](#(part._.Mutation_and_.Equality) "Link to here")
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3Â å˜å¼‚å’Œç­‰æ€§[ğŸ”—](#(part._.Mutation_and_.Equality) "é“¾æ¥è‡³æ­¤")
- en: Weâ€™ve already seen [[Re-Examining Equality](Sharing_and_Equality.html#%28part._identical-eq%29)]
    that equality is subtle. Itâ€™s about to become much subtler with the introduction
    of mutation!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»çœ‹åˆ° [[é‡æ–°å®¡è§†ç­‰æ€§](Sharing_and_Equality.html#%28part._identical-eq%29)]ï¼Œç­‰æ€§æ˜¯å¾®å¦™çš„ã€‚éšç€å˜å¼‚çš„å¼•å…¥ï¼Œå®ƒå°†å˜å¾—æ›´åŠ å¾®å¦™ï¼
- en: 'As a running example, weâ€™ll work with:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºè¿è¡Œç¤ºä¾‹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ï¼š
- en: <three-boxes> ::=
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <three-boxes> ::=
- en: '| Â Â b1 = box(7) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â b1 = box(7) |'
- en: '| Â Â b2 = box(7) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â b2 = box(7) |'
- en: '| Â Â b3 = b1 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â b3 = b1 |'
- en: 'Observe that `b1` and `b3` are referring to the same box, while `b2` is referring
    to a different one. We can see this from a memory diagram:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„`b1`å’Œ`b3`æ­£åœ¨å¼•ç”¨åŒä¸€ä¸ªç›’å­ï¼Œè€Œ`b2`æ­£åœ¨å¼•ç”¨å¦ä¸€ä¸ªç›’å­ã€‚æˆ‘ä»¬å¯ä»¥ä»å†…å­˜å›¾ä¸­çœ‹åˆ°è¿™ä¸€ç‚¹ï¼š
- en: Directory
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE4]'
- en: â†’Â 1001
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1001
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE5]'
- en: â†’Â 1002
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1002
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE6]'
- en: â†’Â 1001
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1001
- en: Heap
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: 1001:Â `box(7)`
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1001:Â `box(7)`
- en: 1002:Â `box(7)`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1002:Â `box(7)`
- en: 'We can confirm this using the following tests:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æµ‹è¯•æ¥ç¡®è®¤è¿™ä¸€ç‚¹ï¼š
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In other words, `b1` and `b3` are aliases for the same box, but neither is an
    alias to the box referred to by `b2`. Since `identical` is transitive, it follows
    from the first two tests that the third test must also pass (and thankfully, Pyret
    confirms this for us!).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: æ¢å¥è¯è¯´ï¼Œ`b1`å’Œ`b3`æ˜¯åŒä¸€ç›’å­çš„åˆ«åï¼Œä½†å®ƒä»¬éƒ½ä¸æ˜¯`b2`æ‰€å¼•ç”¨çš„ç›’å­çš„åˆ«åã€‚ç”±äº`identical`æ˜¯ä¼ é€’çš„ï¼Œä»å‰ä¸¤ä¸ªæµ‹è¯•å¯ä»¥æ¨æ–­å‡ºç¬¬ä¸‰ä¸ªæµ‹è¯•ä¹Ÿå¿…é¡»é€šè¿‡ï¼ˆå¹¸è¿çš„æ˜¯ï¼ŒPyretä¸ºæˆ‘ä»¬ç¡®è®¤äº†è¿™ä¸€ç‚¹ï¼ï¼‰ã€‚
- en: Now, you might wonder why we have used `identical` and not `equal-always` [[Notations
    for Equality](Sharing_and_Equality.html#%28part._equal-always%29)], i.e., plain
    old `is`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œä½ å¯èƒ½æƒ³çŸ¥é“ä¸ºä»€ä¹ˆæˆ‘ä»¬ä½¿ç”¨äº†`identical`è€Œä¸æ˜¯`equal-always` [[ç­‰æ€§è¡¨ç¤ºæ³•](Sharing_and_Equality.html#%28part._equal-always%29)]ï¼Œå³æ™®é€šçš„`is`ã€‚
- en: Do Now!
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Letâ€™s try that:'
  id: totrans-53
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è¯•è¯•çœ‹ï¼š
- en: ''
  id: totrans-54
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you see?
  id: totrans-57
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ çœ‹åˆ°äº†ä»€ä¹ˆï¼Ÿ
- en: 'Itâ€™s unsurprising that the first test, `b1 is b3`, passes. However, the second,
    `b1 is b2`, fails! And the name suggests why: the two are not guaranteed to always
    be equal. That is, suppose we were to modify the box referred to by `b1`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªæµ‹è¯•`b1 is b3`é€šè¿‡å¹¶ä¸ä»¤äººæƒŠè®¶ã€‚ç„¶è€Œï¼Œç¬¬äºŒä¸ªæµ‹è¯•`b1 is b2`å¤±è´¥äº†ï¼å¹¶ä¸”åç§°æš—ç¤ºäº†åŸå› ï¼šè¿™ä¸¤ä¸ªä¸æ˜¯æ€»æ˜¯ç›¸ç­‰çš„ä¿è¯ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæˆ‘ä»¬ä¿®æ”¹ç”±`b1`å¼•ç”¨çš„ç›’å­ï¼š
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Sure enough, the values in the boxes are not the same, but because `b1` and
    `b3` are aliases, their values change in lock-step (more accurately, there is
    only one valueâ€”<wbr>the box at 1001):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: æœç„¶ï¼Œç›’å­ä¸­çš„å€¼å¹¶ä¸ç›¸åŒï¼Œä½†ç”±äº`b1`å’Œ`b3`æ˜¯åˆ«åï¼Œå®ƒä»¬çš„å€¼ä¼šåŒæ­¥å˜åŒ–ï¼ˆæ›´å‡†ç¡®åœ°è¯´ï¼Œåªæœ‰ä¸€ä¸ªå€¼â€”â€”<wbr>ä½äº1001çš„ç›’å­ï¼‰ï¼š
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 19.4Â Another Equality Predicate[ğŸ”—](#(part._.Another_.Equality_.Predicate) "Link
    to here")
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4Â å¦ä¸€ä¸ªç›¸ç­‰è°“è¯[ğŸ”—](#(part._.Another_.Equality_.Predicate) "é“¾æ¥è‡³æ­¤")
- en: 'Suppose we return to the state where we have defined the three boxes [[<three-boxes>](#%28elem._three-boxes%29)]
    but not mutated `b1`. That is, when printed, all three boxes have the same value,
    `box(7)`. We have seen that `b1` and `b3` are both `equal-always` and `identical`
    to each other. However, we have also seen that `b1` and `b2` are neither of those.
    This is somewhat frustrating, because there is clearly some sense in which they
    are â€œequalâ€: at the moment, they contain the same value, even if later on one
    of them might not.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬å›åˆ°æˆ‘ä»¬å®šä¹‰äº†ä¸‰ä¸ªç›’å­ [[<three-boxes>](#%28elem._three-boxes%29)] ä½†æ²¡æœ‰ä¿®æ”¹`b1`çš„çŠ¶æ€ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“æ‰“å°æ—¶ï¼Œæ‰€æœ‰ä¸‰ä¸ªç›’å­éƒ½æœ‰ç›¸åŒçš„å€¼ï¼Œ`box(7)`ã€‚æˆ‘ä»¬å·²ç»çœ‹åˆ°`b1`å’Œ`b3`éƒ½æ˜¯å½¼æ­¤çš„`equal-always`å’Œ`identical`ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ä¹Ÿçœ‹åˆ°`b1`å’Œ`b2`éƒ½ä¸æ˜¯ã€‚è¿™æœ‰ç‚¹ä»¤äººæ²®ä¸§ï¼Œå› ä¸ºæ˜¾ç„¶åœ¨æŸäº›æ–¹é¢å®ƒä»¬æ˜¯â€œç›¸ç­‰â€çš„ï¼šåœ¨å½“å‰æ—¶åˆ»ï¼Œå®ƒä»¬åŒ…å«ç›¸åŒçš„å€¼ï¼Œå³ä½¿åæ¥å…¶ä¸­ä¸€ä¸ªå¯èƒ½ä¸æ˜¯ã€‚
- en: 'Therefore, Pyret offers a third equality predicate that is designed for just
    these situations: it is (as you might guess) called `equal-now`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼ŒPyretæä¾›äº†ä¸€ä¸ªç¬¬ä¸‰ç§ç­‰æ€§è°“è¯ï¼Œä¸“ä¸ºè¿™äº›æƒ…å†µè®¾è®¡ï¼šæ­£å¦‚ä½ å¯èƒ½çŒœåˆ°çš„ï¼Œå®ƒè¢«ç§°ä¸º`equal-now`ï¼š
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `-now` in the name reminds us that these values are equal at the moment,
    but may not be equal later. Sure enough, if we add
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: åç§°ä¸­çš„`-now`æé†’æˆ‘ä»¬ï¼Œè¿™äº›å€¼åœ¨å½“å‰æ—¶åˆ»æ˜¯ç›¸ç­‰çš„ï¼Œä½†ä»¥åå¯èƒ½ä¸å†ç›¸ç­‰ã€‚æœç„¶ï¼Œå¦‚æœæˆ‘ä»¬æ·»åŠ 
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'back into the program, the above `equal-now` tests fail: now, they are no longer
    equal!'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: å°†å€¼æ”¾å›ç¨‹åºä¸­ï¼Œä¸Šè¿°çš„`equal-now`æµ‹è¯•å¤±è´¥äº†ï¼šç°åœ¨ï¼Œå®ƒä»¬ä¸å†ç›¸ç­‰äº†ï¼
- en: 'Recall that the other two equality predicates have an binary operator notation:
    `==` for `equal-always` and `<=>` for `identical`. Similarly, `equal-now` has
    the binary operator `=~`. You should view that as `=` with hand-waving `~`: itâ€™s
    equal for now, but donâ€™t expect it to remain so. That is, we can rewrite the above
    tests as:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹ï¼Œå…¶ä»–ä¸¤ä¸ªç­‰ä»·è°“è¯æœ‰ä¸€ä¸ªäºŒè¿›åˆ¶è¿ç®—ç¬¦è¡¨ç¤ºæ³•ï¼š`==` è¡¨ç¤º `equal-always`ï¼Œ`<=>` è¡¨ç¤º `identical`ã€‚åŒæ ·ï¼Œ`equal-now`
    æœ‰äºŒè¿›åˆ¶è¿ç®—ç¬¦ `=~`ã€‚ä½ åº”è¯¥æŠŠå®ƒçœ‹ä½œæ˜¯ `=` åŠ ä¸Šä¸€ä¸ªæŒ¥æ‰‹çš„ `~`ï¼šå®ƒç°åœ¨ç›¸ç­‰ï¼Œä½†ä¸è¦æœŸæœ›å®ƒä¿æŒè¿™æ ·ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸Šè¿°æµ‹è¯•é‡å†™ä¸ºï¼š
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Whether they pass, of course, depends on the state of the program: whether
    `b1`, `b2`, or `b3` has had its content modified.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œå®ƒä»¬æ˜¯å¦é€šè¿‡å–å†³äºç¨‹åºçš„çŠ¶æ€ï¼š`b1`ã€`b2` æˆ– `b3` çš„å†…å®¹æ˜¯å¦å·²è¢«ä¿®æ”¹ã€‚
- en: 19.5Â A Hierarchy of Equality[ğŸ”—](#(part._equality-hierarchy) "Link to here")
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.5 ç­‰ä»·æ€§å±‚æ¬¡[ğŸ”—](#(part._equality-hierarchy) "é“¾æ¥è‡³æ­¤")
- en: As you might guess, the equality operators have a hierarchy of implication.
    That is, if one operator is true of two expressions, the other necessarily is,
    but not vice versa.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½ æ‰€çŒœï¼Œç­‰ä»·è¿ç®—ç¬¦æœ‰ä¸€ä¸ªè•´æ¶µå±‚æ¬¡ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœä¸€ä¸ªè¿ç®—ç¬¦å¯¹ä¸¤ä¸ªè¡¨è¾¾å¼ä¸ºçœŸï¼Œé‚£ä¹ˆå¦ä¸€ä¸ªå¿…ç„¶ä¸ºçœŸï¼Œä½†åä¹‹åˆ™ä¸ç„¶ã€‚
- en: Do Now!
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can you work out this hierarchy of implication?
  id: totrans-76
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ èƒ½æ‰¾å‡ºè¿™ä¸ªè•´æ¶µå±‚æ¬¡å—ï¼Ÿ
- en: Observe that if two expressions are `identical`, then they are aliases, i.e.,
    they are referring to one and the same value. Therefore, the values produced by
    those expressions must be `equal-always`. If they are always equal, then clearly
    at any given moment, they must also be `equal-now`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¦‚æœä¸¤ä¸ªè¡¨è¾¾å¼æ˜¯ `identical`ï¼Œé‚£ä¹ˆå®ƒä»¬æ˜¯åˆ«åï¼Œå³å®ƒä»¬æŒ‡çš„æ˜¯åŒä¸€ä¸ªå€¼ã€‚å› æ­¤ï¼Œè¿™äº›è¡¨è¾¾å¼äº§ç”Ÿçš„å€¼å¿…é¡»æ˜¯ `equal-always`ã€‚å¦‚æœå®ƒä»¬å§‹ç»ˆç›¸ç­‰ï¼Œé‚£ä¹ˆæ˜¾ç„¶åœ¨ä»»ä½•ç»™å®šæ—¶åˆ»ï¼Œå®ƒä»¬ä¹Ÿå¿…é¡»æ˜¯
    `equal-now`ã€‚
- en: Even if two expressions are not `identical`, they may be `equal-always`. This
    would never be true of mutable data (because there is the possibility of a future
    mutation), but it can be true of immutable data that have the same structure and
    contents. In that case, if they are always equal, then again they must be `equal-now`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: å³ä½¿ä¸¤ä¸ªè¡¨è¾¾å¼ä¸æ˜¯ `identical`ï¼Œå®ƒä»¬ä¹Ÿå¯èƒ½æ˜¯ `equal-always`ã€‚è¿™å¯¹äºå¯å˜æ•°æ®æ¥è¯´æ°¸è¿œä¸ä¼šæ˜¯çœŸçš„ï¼ˆå› ä¸ºå­˜åœ¨æœªæ¥çªå˜çš„å¯èƒ½æ€§ï¼‰ï¼Œä½†å¯¹äºå…·æœ‰ç›¸åŒç»“æ„å’Œå†…å®¹çš„ä¸å˜æ•°æ®æ¥è¯´å¯ä»¥æ˜¯çœŸçš„ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¦‚æœå®ƒä»¬å§‹ç»ˆç›¸ç­‰ï¼Œé‚£ä¹ˆå®ƒä»¬ä¹Ÿå¿…é¡»æ˜¯
    `equal-now`ã€‚
- en: However, the converses are not true.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œé€†å‘½é¢˜å¹¶ä¸æˆç«‹ã€‚
- en: 'If two data are `equal-now`, they may not be `equal-always`: if they are mutable,
    a future mutation may change the equality, as we have seen above. Similarly, two
    data may be `equal-always` but not be `identical`, because they reside at different
    heap addresses and are therefore truly different data.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä¸¤ä¸ªæ•°æ®æ˜¯ `equal-now`ï¼Œå®ƒä»¬å¯èƒ½ä¸æ˜¯ `equal-always`ï¼šå¦‚æœå®ƒä»¬æ˜¯å¯å˜çš„ï¼Œæœªæ¥çš„çªå˜å¯èƒ½ä¼šæ”¹å˜ç­‰ä»·æ€§ï¼Œå°±åƒæˆ‘ä»¬ä¸Šé¢çœ‹åˆ°çš„ã€‚åŒæ ·ï¼Œä¸¤ä¸ªæ•°æ®å¯èƒ½
    `equal-always` ä½†ä¸æ˜¯ `identical`ï¼Œå› ä¸ºå®ƒä»¬ä½äºä¸åŒçš„å †åœ°å€ï¼Œå› æ­¤æ˜¯çœŸæ­£ä¸åŒçš„æ•°æ®ã€‚
- en: 'In most languages, it is common to have two equality operators, corresponding
    to `identical` (known as reference equality) and `equal-now` (known as structural
    equality). Pyret is rare in having a third operator, `equal-always`. For most
    programs, this is in fact the most useful equality operator: it is not overly
    bothered with details of aliasing, which can be difficult to predict; at the same
    time it makes decisions that stand the test of time, thereby forming a useful
    basis for various optimizations (which may not even be conscious of their temporal
    assumptions). This is why `is` in testing uses `equal-always` by default, and
    forces users to explicitly pick a different primitive if they want it.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¤§å¤šæ•°è¯­è¨€ä¸­ï¼Œé€šå¸¸æœ‰ä¸¤ä¸ªç­‰ä»·è¿ç®—ç¬¦ï¼Œå¯¹åº”äº`identical`ï¼ˆç§°ä¸ºå¼•ç”¨ç­‰ä»·ï¼‰å’Œ`equal-now`ï¼ˆç§°ä¸ºç»“æ„ç­‰ä»·ï¼‰ã€‚Pyret æ˜¯å°‘æ•°æœ‰å‡ ä¸ªç¬¬ä¸‰ä¸ªè¿ç®—ç¬¦çš„è¯­è¨€ä¹‹ä¸€ï¼Œå³
    `equal-always`ã€‚å¯¹äºå¤§å¤šæ•°ç¨‹åºæ¥è¯´ï¼Œè¿™å®é™…ä¸Šæ˜¯æœ€æœ‰ç”¨çš„ç­‰ä»·è¿ç®—ç¬¦ï¼šå®ƒä¸å¤ªå…³å¿ƒåˆ«åç»†èŠ‚ï¼Œè¿™äº›ç»†èŠ‚å¯èƒ½éš¾ä»¥é¢„æµ‹ï¼›åŒæ—¶ï¼Œå®ƒåšå‡ºçš„å†³ç­–ç»å¾—èµ·æ—¶é—´çš„è€ƒéªŒï¼Œä»è€Œä¸ºå„ç§ä¼˜åŒ–ï¼ˆå¯èƒ½ç”šè‡³æ²¡æœ‰æ„è¯†åˆ°å®ƒä»¬çš„æ—¶æ€å‡è®¾ï¼‰æä¾›äº†ä¸€ä¸ªæœ‰ç”¨çš„åŸºç¡€ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåœ¨æµ‹è¯•ä¸­
    `is` é»˜è®¤ä½¿ç”¨ `equal-always`ï¼Œå¹¶å¼ºåˆ¶ç”¨æˆ·æ˜ç¡®é€‰æ‹©ä¸åŒçš„åŸå§‹è¿ç®—ç¬¦ï¼Œå¦‚æœä»–ä»¬æƒ³è¦çš„è¯ã€‚
- en: 19.6Â Space and Time Complexity[ğŸ”—](#(part._.Space_and_.Time_.Complexity) "Link
    to here")
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.6 ç©ºé—´å’Œæ—¶é—´å¤æ‚åº¦[ğŸ”—](#(part._.Space_and_.Time_.Complexity) "é“¾æ¥è‡³æ­¤")
- en: '`identical` always takes constant time. Indeed, some programs use `identical`
    precisely because they want constant-time equality, carefully structuring their
    program so that values that should be considered equal are aliases to the same
    value. Of course, maintaining this programming discipline is tricky.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`identical` æ€»æ˜¯èŠ±è´¹å¸¸æ•°æ—¶é—´ã€‚ç¡®å®ï¼Œä¸€äº›ç¨‹åºä½¿ç”¨ `identical` æ­£æ˜¯å› ä¸ºå®ƒä»¬æƒ³è¦å¸¸æ•°æ—¶é—´çš„ç­‰ä»·æ€§ï¼Œä»”ç»†åœ°æ„å»ºç¨‹åºï¼Œä½¿å¾—åº”è¯¥è¢«è§†ä¸ºç­‰ä»·çš„ä»·å€¼æ˜¯åŒä¸€å€¼çš„åˆ«åã€‚å½“ç„¶ï¼Œä¿æŒè¿™ç§ç¼–ç¨‹çºªå¾‹æ˜¯æ£˜æ‰‹çš„ã€‚'
- en: '`equal-always` and `equal-now` both must traverse at least the immutable part
    of data. Therefore, they take time proportional to the smaller datum (because
    if the two data are of different size, they must not be equal anyway, so there
    is no need to visit the extra data). The difference is that `equal-always` reduces
    to `identical` at references, thereby performing less computation than `equal-now`
    would.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`equal-always`å’Œ`equal-now`éƒ½å¿…é¡»è‡³å°‘éå†æ•°æ®çš„ä¸å˜éƒ¨åˆ†ã€‚å› æ­¤ï¼Œå®ƒä»¬çš„æ—¶é—´ä¸è¾ƒå°çš„æ•°æ®é‡æˆæ¯”ä¾‹ï¼ˆå› ä¸ºå¦‚æœä¸¤ä¸ªæ•°æ®çš„å¤§å°ä¸åŒï¼Œå®ƒä»¬è‚¯å®šä¸ç›¸ç­‰ï¼Œæ‰€ä»¥æ²¡æœ‰å¿…è¦è®¿é—®é¢å¤–çš„æ•°æ®ï¼‰ã€‚åŒºåˆ«åœ¨äº`equal-always`åœ¨å¼•ç”¨æ—¶ç®€åŒ–ä¸º`identical`ï¼Œå› æ­¤æ¯”`equal-now`æ‰§è¡Œçš„è®¡ç®—æ›´å°‘ã€‚'
- en: 19.7Â What it Means to be Identical[ğŸ”—](#(part._sem-identical) "Link to here")
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.7 æˆä¸ºç›¸åŒæ„å‘³ç€ä»€ä¹ˆ[ğŸ”—](#(part._sem-identical) "é“¾æ¥è‡³æ­¤")
- en: 'Return for a moment to the state where we have just defined the three boxes
    [[<three-boxes>](#%28elem._three-boxes%29)]. We could have written the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹æˆ‘ä»¬åˆšåˆšå®šä¹‰çš„ä¸‰ä¸ªæ¡†çš„çŠ¶æ€[[<three-boxes>](#%28elem._three-boxes%29)]ã€‚æˆ‘ä»¬å¯ä»¥å†™å‡ºä»¥ä¸‹å†…å®¹ï¼š
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we can compare the contents of the various boxes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥æ¯”è¾ƒå„ä¸ªæ¡†çš„å†…å®¹ï¼š
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And at the end of performing comparisons, we can restore them:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ‰§è¡Œæ¯”è¾ƒä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥æ¢å¤å®ƒä»¬ï¼š
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Observe that `b1-id-b2` would be `false` but `b1-id-b3` would be `true`. And
    notice that this would always be true when the two expressions are identical,
    but not otherwise.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ`b1-id-b2`ä¼šæ˜¯`false`ï¼Œä½†`b1-id-b3`ä¼šæ˜¯`true`ã€‚å¹¶ä¸”è¯·æ³¨æ„ï¼Œå½“ä¸¤ä¸ªè¡¨è¾¾å¼ç›¸åŒçš„æ—¶å€™ï¼Œè¿™å§‹ç»ˆæ˜¯æ­£ç¡®çš„ï¼Œå¦åˆ™åˆ™ä¸æ˜¯ã€‚
- en: Thus, at the end there has been no change, but by making the change we can check
    which values are and arenâ€™t aliases of others. In other words, thisrepresents
    the essence of `identical`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæœ€ç»ˆæ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œä½†é€šè¿‡è¿›è¡Œè¿™ç§æ”¹å˜ï¼Œæˆ‘ä»¬å¯ä»¥æ£€æŸ¥å“ªäº›å€¼æ˜¯å…¶ä»–å€¼çš„åˆ«åï¼Œå“ªäº›åˆ™ä¸æ˜¯ã€‚æ¢å¥è¯è¯´ï¼Œè¿™ä»£è¡¨äº†`identical`çš„æœ¬è´¨ã€‚
- en: 'In practice, `identical` does not behave this way: it would be too disruptive.
    It is also not the most efficient implementation possible, when Pyret can simply
    check the memory addresses being the same. Nevertheless, it does demonstrate the
    basic idea behind `identical`: two values are `identical` precisely when, when
    you make changes to one, you see the changes manifest on the â€œotherâ€ (i.e., there
    is really only one value, but with potentially multiple names for it).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šï¼Œ`identical`å¹¶ä¸ä»¥è¿™ç§æ–¹å¼è¡¨ç°ï¼šè¿™ä¼šå¤ªå…·ç ´åæ€§ã€‚å½“Pyretå¯ä»¥ç®€å•åœ°æ£€æŸ¥å†…å­˜åœ°å€æ˜¯å¦ç›¸åŒæ—¶ï¼Œå®ƒä¹Ÿä¸æ˜¯æœ€æœ‰æ•ˆçš„å®ç°æ–¹å¼ã€‚å°½ç®¡å¦‚æ­¤ï¼Œå®ƒç¡®å®å±•ç¤ºäº†`identical`èƒŒåçš„åŸºæœ¬æ€æƒ³ï¼šä¸¤ä¸ªå€¼æ˜¯`identical`çš„ï¼Œå½“ä¸”ä»…å½“ä½ å¯¹ä¸€ä¸ªå€¼è¿›è¡Œæ›´æ”¹æ—¶ï¼Œä½ ä¼šåœ¨â€œå¦ä¸€ä¸ªâ€å€¼ä¸Šçœ‹åˆ°è¿™äº›æ›´æ”¹ï¼ˆå³å®é™…ä¸Šåªæœ‰ä¸€ä¸ªå€¼ï¼Œä½†å¯èƒ½æœ‰å¤šä¸ªåç§°ï¼‰ã€‚
- en: 19.8Â Comparing Functions[ğŸ”—](#(part._comp-func) "Link to here")
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.8 æ¯”è¾ƒå‡½æ•°[ğŸ”—](#(part._comp-func) "é“¾æ¥è‡³æ­¤")
- en: We havenâ€™t actually provided the full truth about equality because we havenâ€™t
    discussed functions. Defining equality for functionsâ€”<wbr>especially extensional
    equality, namely whether two functions have the same graph, i.e., for each input
    produce the same outputâ€”<wbr>is complicated (a euphemism for impossible) due to
    the Halting Problem.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å®é™…ä¸Šå¹¶æ²¡æœ‰æä¾›å…³äºç­‰ä»·çš„å…¨éƒ¨çœŸç›¸ï¼Œå› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰è®¨è®ºå‡½æ•°ã€‚å®šä¹‰å‡½æ•°çš„ç­‰ä»·æ€§â€”â€”ç‰¹åˆ«æ˜¯å¤–å»¶ç­‰ä»·æ€§ï¼Œå³ä¸¤ä¸ªå‡½æ•°æ˜¯å¦æœ‰ç›¸åŒçš„å›¾ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºæ¯ä¸ªè¾“å…¥äº§ç”Ÿç›¸åŒçš„è¾“å‡ºâ€”â€”ç”±äºåœæœºé—®é¢˜ï¼Œè¿™æ˜¯å¤æ‚ï¼ˆä¸€ç§å§”å©‰çš„è¯´æ³•ï¼Œå³ä¸å¯èƒ½ï¼‰çš„ã€‚
- en: 'Because of this, most languages have tended to use approximations for function
    equality, most commonly reference equality. This is, however, a very weak approximation:
    even if the exact same function text in the same environment is allocated as two
    different closures, these would not be reference-equal. At least when this is
    done as part of the definition of `identical`, it makes sense; if other operators
    do this, however, they are actively lying, which is something the equality operators
    do not usually do.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºè¿™ä¸ªåŸå› ï¼Œå¤§å¤šæ•°è¯­è¨€éƒ½å€¾å‘äºä½¿ç”¨å‡½æ•°ç›¸ç­‰çš„è¿‘ä¼¼å€¼ï¼Œæœ€å¸¸è§çš„æ˜¯å¼•ç”¨ç›¸ç­‰ã€‚ç„¶è€Œï¼Œè¿™å´æ˜¯ä¸€ä¸ªéå¸¸å¼±çš„è¿‘ä¼¼ï¼šå³ä½¿ç›¸åŒçš„å‡½æ•°æ–‡æœ¬åœ¨ç›¸åŒçš„ç¯å¢ƒä¸­åˆ†é…ä¸ºä¸¤ä¸ªä¸åŒçš„é—­åŒ…ï¼Œå®ƒä»¬ä¹Ÿä¸ä¼šæ˜¯å¼•ç”¨ç›¸ç­‰çš„ã€‚è‡³å°‘å½“è¿™æ˜¯`identical`å®šä¹‰çš„ä¸€éƒ¨åˆ†æ—¶ï¼Œè¿™æ ·åšæ˜¯æœ‰æ„ä¹‰çš„ï¼›ç„¶è€Œï¼Œå¦‚æœå…¶ä»–æ“ä½œç¬¦è¿™æ ·åšï¼Œå®ƒä»¬å°±æ˜¯åœ¨æ’’è°ï¼Œè€Œè¿™é€šå¸¸ä¸æ˜¯ç­‰ä»·æ“ä½œç¬¦çš„è¡Œä¸ºã€‚
- en: 'There is one other approach we can take: simply disallow function comparison.
    This is what Pyret does: all three equality operators above will result in an
    error if you try to compare two functions. (You can compare against just one function,
    however, and you will get the answer `false`.) This ensures that the languageâ€™s
    comparison operators are never trusted falsely.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥é‡‡å–å¦ä¸€ç§æ–¹æ³•ï¼šç®€å•åœ°ç¦æ­¢å‡½æ•°æ¯”è¾ƒã€‚è¿™æ­£æ˜¯Pyretæ‰€åšçš„äº‹æƒ…ï¼šå¦‚æœä½ å°è¯•æ¯”è¾ƒä¸¤ä¸ªå‡½æ•°ï¼Œä¸Šè¿°æ‰€æœ‰ä¸‰ä¸ªç­‰ä»·æ“ä½œç¬¦éƒ½ä¼šå¯¼è‡´é”™è¯¯ã€‚ï¼ˆç„¶è€Œï¼Œä½ å¯ä»¥ä¸ä¸€ä¸ªå‡½æ•°è¿›è¡Œæ¯”è¾ƒï¼Œä½ å°†å¾—åˆ°`false`çš„ç­”æ¡ˆã€‚ï¼‰è¿™ç¡®ä¿äº†è¯­è¨€çš„æ¯”è¾ƒæ“ä½œç¬¦æ°¸è¿œä¸ä¼šè¢«é”™è¯¯åœ°ä¿¡ä»»ã€‚
- en: Pyret did have the choice of allowing reference equality for functions inside
    `identical` and erroring only in the other two cases. Had it done so, however,
    it would have violated the chain of implication above [[A Hierarchy of Equality](#%28part._equality-hierarchy%29)].
    The present design is arguably more elegant. Programmers who do want to use reference
    equality on functions can simply embed the functions inside a mutable structure
    like boxes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretç¡®å®å¯ä»¥é€‰æ‹©å…è®¸åœ¨`identical`å†…éƒ¨ä½¿ç”¨å¼•ç”¨ç›¸ç­‰æ€§ï¼Œå¹¶åœ¨å…¶ä»–ä¸¤ç§æƒ…å†µä¸‹æŠ¥é”™ã€‚ç„¶è€Œï¼Œå¦‚æœå®ƒè¿™æ ·åšï¼Œå°±ä¼šè¿åä¸Šè¿°çš„æ¨ç†é“¾ [[ç­‰ä»·æ€§å±‚æ¬¡](#(part._equality-hierarchy%29)]).
    å½“å‰çš„è®¾è®¡å¯ä»¥è¯´æ˜¯æ›´åŠ ä¼˜é›…ã€‚æƒ³è¦åœ¨å‡½æ•°ä¸Šä½¿ç”¨å¼•ç”¨ç›¸ç­‰çš„ç¨‹åºå‘˜å¯ä»¥ç®€å•åœ°åœ¨ä¸€ä¸ªå¯å˜ç»“æ„ï¼ˆå¦‚æ¡†ï¼‰å†…éƒ¨åµŒå…¥å‡½æ•°ã€‚
- en: 'There is one problem with erroring when comparing two functions: a completely
    generic procedure that compares two arbitrary values may error if both of the
    values given are functions. Because this can cause unpredictable program failure,
    Pyret offers a three-valued version of each of the above three operators (`identical3`,
    `equal-always3` and `equal-now3`), all of which return `EqualityResult` values
    that correspond to truth, falsity, and ignorance (returned in the case when both
    arguments are functions). Programmers can use this in place of the Boolean-valued
    comparison operators if they are uncertain about the types of the parameters.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯”è¾ƒä¸¤ä¸ªå‡½æ•°æ—¶å‡ºé”™æœ‰ä¸€ä¸ªé—®é¢˜ï¼šä¸€ä¸ªå®Œå…¨é€šç”¨çš„æ¯”è¾ƒä¸¤ä¸ªä»»æ„å€¼çš„ç¨‹åºå¯èƒ½ä¼šåœ¨ç»™å®šçš„ä¸¤ä¸ªå€¼éƒ½æ˜¯å‡½æ•°æ—¶å‡ºé”™ã€‚å› ä¸ºè¿™å¯èƒ½å¯¼è‡´ä¸å¯é¢„æµ‹çš„ç¨‹åºå¤±è´¥ï¼ŒPyretä¸ºä¸Šè¿°ä¸‰ä¸ªè¿ç®—ç¬¦ï¼ˆ`identical3`ã€`equal-always3`å’Œ`equal-now3`ï¼‰æä¾›äº†ä¸‰å€¼ç‰ˆæœ¬ï¼Œæ‰€æœ‰è¿™äº›è¿ç®—ç¬¦éƒ½è¿”å›å¯¹åº”äºçœŸã€å‡å’ŒæœªçŸ¥ï¼ˆå½“ä¸¤ä¸ªå‚æ•°éƒ½æ˜¯å‡½æ•°æ—¶è¿”å›ï¼‰çš„`EqualityResult`å€¼ã€‚å¦‚æœç¨‹åºå‘˜ä¸ç¡®å®šå‚æ•°çš„ç±»å‹ï¼Œä»–ä»¬å¯ä»¥ä½¿ç”¨è¿™äº›è¿ç®—ç¬¦æ¥ä»£æ›¿å¸ƒå°”å€¼æ¯”è¾ƒè¿ç®—ç¬¦ã€‚
- en: '19.1Â Boxes: A Canonical Mutable Structure[ğŸ”—](#(part._boxes) "Link to here")'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1Â æ¡†ï¼šä¸€ä¸ªè§„èŒƒçš„å¯å˜ç»“æ„[ğŸ”—](#(part._boxes) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'In [Mutating Structures](mutating-structures.html) we saw a motivating example
    using bank accounts. To focus our study of equality, it can be convenient to have
    an even simpler mutable data structure, called a box (which you will find in other
    programming languages as well). A box has only one fieldâ€”<wbr>the value being
    boxedâ€”<wbr>and supports just three operations:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[ä¿®æ”¹ç»“æ„](mutating-structures.html)ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†ä¸€ä¸ªä½¿ç”¨é“¶è¡Œè´¦æˆ·çš„åŠ¨æœºç¤ºä¾‹ã€‚ä¸ºäº†é›†ä¸­ç ”ç©¶ç­‰ä»·æ€§ï¼Œæœ‰ä¸€ä¸ªæ›´ç®€å•çš„å¯å˜æ•°æ®ç»“æ„å¯èƒ½å¾ˆæœ‰ç”¨ï¼Œç§°ä¸ºæ¡†ï¼ˆä½ å°†åœ¨å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­æ‰¾åˆ°å®ƒï¼‰ã€‚æ¡†åªæœ‰ä¸€ä¸ªå­—æ®µâ€”â€”<wbr>è¢«è£…ç®±çš„å€¼â€”â€”<wbr>å¹¶æ”¯æŒä»¥ä¸‹ä¸‰ä¸ªæ“ä½œï¼š
- en: box consumes a value and creates a mutable box containing that value.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`box`æ¶ˆè€—ä¸€ä¸ªå€¼å¹¶åˆ›å»ºä¸€ä¸ªåŒ…å«è¯¥å€¼çš„å¯å˜æ¡†ã€‚'
- en: unbox-now consumes a box and returns the value contained in the box.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unbox-now`æ¶ˆè€—ä¸€ä¸ªæ¡†å¹¶è¿”å›æ¡†ä¸­åŒ…å«çš„å€¼ã€‚'
- en: set-box-now consumes a box, a new value, and changes the box to contain the
    value. All subsequent unbox-nows of that box will now return the new valueâ€”<wbr>unless
    it is mutated again.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`set-box-now`æ¶ˆè€—ä¸€ä¸ªæ¡†ã€ä¸€ä¸ªæ–°å€¼ï¼Œå¹¶å°†æ¡†æ›´æ”¹ä¸ºåŒ…å«è¯¥å€¼ã€‚æ­¤åå¯¹è¯¥æ¡†çš„æ‰€æœ‰`unbox-now`æ“ä½œç°åœ¨å°†è¿”å›æ–°å€¼â€”â€”<wbr>é™¤éå®ƒå†æ¬¡è¢«ä¿®æ”¹ã€‚'
- en: 'Here are the corresponding definitions in Pyret:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯Pyretä¸­çš„ç›¸åº”å®šä¹‰ï¼š
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Observe that we use `b!v` to extract the current value, and use the naming convention
    of `-now` to make clear these are stateful operations, so the value now may not
    be the same as the value later.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„æˆ‘ä»¬ä½¿ç”¨`b!v`æ¥æå–å½“å‰å€¼ï¼Œå¹¶ä½¿ç”¨`-now`çš„å‘½åçº¦å®šæ¥æ¸…æ¥šåœ°è¡¨æ˜è¿™äº›æ˜¯çŠ¶æ€æ“ä½œï¼Œå› æ­¤ç°åœ¨çš„å€¼å¯èƒ½ä¸ç­‰äºä»¥åçš„å€¼ã€‚
- en: 19.2Â Mutation and Types[ğŸ”—](#(part._.Mutation_and_.Types) "Link to here")
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.2Â ä¿®æ”¹å’Œç±»å‹[ğŸ”—](#(part._.Mutation_and_.Types) "é“¾æ¥åˆ°æ­¤å¤„")
- en: In terms of types, whenever we replace the value in a box, we want it to be
    type-consistent with what was previously there. Otherwise it would be very difficult
    to program against a box, because the type of its content would keep changing.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç±»å‹æ–¹é¢ï¼Œæ¯æ¬¡æˆ‘ä»¬åœ¨ä¸€ä¸ªæ¡†ä¸­æ›¿æ¢å€¼æ—¶ï¼Œæˆ‘ä»¬éƒ½å¸Œæœ›å®ƒä¸å‰ä¸€ä¸ªå€¼ä¿æŒç±»å‹ä¸€è‡´ã€‚å¦åˆ™ï¼Œé’ˆå¯¹ä¸€ä¸ªæ¡†è¿›è¡Œç¼–ç¨‹å°†ä¼šéå¸¸å›°éš¾ï¼Œå› ä¸ºå…¶å†…å®¹çš„ç±»å‹ä¼šä¸æ–­å˜åŒ–ã€‚
- en: 'These definitions obey the following tests:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›å®šä¹‰éµå¾ªä»¥ä¸‹æµ‹è¯•ï¼š
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, we cannot write `set-box-now(n1, "hi")`, because that would violate
    the type of `n1`, which is `Box<Number>`. We could make this explicit by writing
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œæˆ‘ä»¬ä¸èƒ½ç¼–å†™`set-box-now(n1, "hi")`ï¼Œå› ä¸ºè¿™ä¼šè¿å`n1`çš„ç±»å‹ï¼Œå…¶ç±»å‹ä¸º`Box<Number>`ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼ä½¿å…¶æ›´æ˜ç¡®ï¼š
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'if we wanted to be explicit. However, note that `n1` being a box of numbers
    does not preclude us from having a box of strings:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³è¦æ˜ç¡®çš„è¯ã€‚ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œ`n1`æ˜¯ä¸€ä¸ªæ•°å­—çš„æ¡†å¹¶ä¸é˜»æ­¢æˆ‘ä»¬æœ‰ä¸€ä¸ªå­—ç¬¦ä¸²çš„æ¡†ï¼š
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: or indeed a box of any other type. We just need its type to remain consistent,
    whatever that type is.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…ç¡®å®æ˜¯ä¸€ä¸ªä»»ä½•å…¶ä»–ç±»å‹çš„æ¡†ã€‚æˆ‘ä»¬åªéœ€è¦å…¶ç±»å‹ä¿æŒä¸€è‡´ï¼Œæ— è®ºè¯¥ç±»å‹æ˜¯ä»€ä¹ˆã€‚
- en: 'This is a general rule we want to follow with mutable data: the new value must
    be the same type as the old value. This gives programs a consistent interface
    to program against. For instance, above, we know that we can always perform numeric
    operations against the value extracted from `n1`â€”<wbr>there is no danger that
    it will suddenly produce a string. This discipline can either be enforced by a
    system of annotations, or has to be manually maintained by the programmer.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æˆ‘ä»¬å¸Œæœ›éµå¾ªçš„å¯å˜æ•°æ®çš„ä¸€èˆ¬è§„åˆ™ï¼šæ–°å€¼å¿…é¡»ä¸æ—§å€¼ç›¸åŒç±»å‹ã€‚è¿™ä¸ºç¨‹åºæä¾›äº†ä¸€ä¸ªä¸€è‡´çš„æ¥å£æ¥ç¼–ç¨‹ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸Šé¢ï¼Œæˆ‘ä»¬çŸ¥é“æˆ‘ä»¬å¯ä»¥å§‹ç»ˆå¯¹ä» `n1` æå–çš„å€¼æ‰§è¡Œæ•°å€¼æ“ä½œâ€”â€”æ²¡æœ‰å±é™©å®ƒä¼šçªç„¶äº§ç”Ÿä¸€ä¸ªå­—ç¬¦ä¸²ã€‚è¿™ç§çºªå¾‹å¯ä»¥é€šè¿‡æ³¨é‡Šç³»ç»Ÿå¼ºåˆ¶æ‰§è¡Œï¼Œæˆ–è€…å¿…é¡»ç”±ç¨‹åºå‘˜æ‰‹åŠ¨ç»´æŠ¤ã€‚
- en: 19.3Â Mutation and Equality[ğŸ”—](#(part._.Mutation_and_.Equality) "Link to here")
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3 çªå˜å’Œç›¸ç­‰æ€§[ğŸ”—](#(part._.Mutation_and_.Equality) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Weâ€™ve already seen [[Re-Examining Equality](Sharing_and_Equality.html#%28part._identical-eq%29)]
    that equality is subtle. Itâ€™s about to become much subtler with the introduction
    of mutation!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»çœ‹åˆ° [[é‡æ–°å®¡è§†ç›¸ç­‰æ€§](Sharing_and_Equality.html#%28part._identical-eq%29)]ï¼Œç›¸ç­‰æ€§æ˜¯å¾®å¦™çš„ã€‚éšç€çªå˜ï¼ˆmutationï¼‰çš„å¼•å…¥ï¼Œå®ƒå°†å˜å¾—æ›´åŠ å¾®å¦™ï¼
- en: 'As a running example, weâ€™ll work with:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºè¿è¡Œç¤ºä¾‹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ï¼š
- en: <three-boxes> ::=
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <three-boxes> ::=
- en: '| Â Â b1 = box(7) |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â b1 = box(7) |'
- en: '| Â Â b2 = box(7) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â b2 = box(7) |'
- en: '| Â Â b3 = b1 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â b3 = b1 |'
- en: 'Observe that `b1` and `b3` are referring to the same box, while `b2` is referring
    to a different one. We can see this from a memory diagram:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ° `b1` å’Œ `b3` æŒ‡çš„æ˜¯åŒä¸€ä¸ªç›’å­ï¼Œè€Œ `b2` æŒ‡çš„æ˜¯å¦ä¸€ä¸ªç›’å­ã€‚æˆ‘ä»¬å¯ä»¥ä»å†…å­˜å›¾ä¸­çœ‹å‡ºè¿™ä¸€ç‚¹ï¼š
- en: Directory
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å½•
- en: '[PRE21]'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE21]'
- en: â†’Â 1001
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1001
- en: '[PRE22]'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE22]'
- en: â†’Â 1002
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1002
- en: '[PRE23]'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE23]'
- en: â†’Â 1001
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â†’Â 1001
- en: Heap
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: å †
- en: 1001:Â `box(7)`
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1001:Â `box(7)`
- en: 1002:Â `box(7)`
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1002:Â `box(7)`
- en: 'We can confirm this using the following tests:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æµ‹è¯•æ¥ç¡®è®¤è¿™ä¸€ç‚¹ï¼š
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In other words, `b1` and `b3` are aliases for the same box, but neither is an
    alias to the box referred to by `b2`. Since `identical` is transitive, it follows
    from the first two tests that the third test must also pass (and thankfully, Pyret
    confirms this for us!).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: æ¢å¥è¯è¯´ï¼Œ`b1` å’Œ `b3` æ˜¯åŒä¸€ç›’å­çš„åˆ«åï¼Œä½†å®ƒä»¬éƒ½ä¸æ˜¯ `b2` æ‰€æŒ‡çš„ç›’å­çš„åˆ«åã€‚ç”±äº `identical` æ˜¯ä¼ é€’çš„ï¼Œä»å‰ä¸¤ä¸ªæµ‹è¯•å¯ä»¥æ¨æ–­å‡ºç¬¬ä¸‰ä¸ªæµ‹è¯•ä¹Ÿå¿…é¡»é€šè¿‡ï¼ˆå¹¸è¿çš„æ˜¯ï¼ŒPyret
    ä¸ºæˆ‘ä»¬ç¡®è®¤äº†è¿™ä¸€ç‚¹ï¼ï¼‰
- en: Now, you might wonder why we have used `identical` and not `equal-always` [[Notations
    for Equality](Sharing_and_Equality.html#%28part._equal-always%29)], i.e., plain
    old `is`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œä½ å¯èƒ½ä¼šæƒ³çŸ¥é“ä¸ºä»€ä¹ˆæˆ‘ä»¬ä½¿ç”¨äº† `identical` è€Œä¸æ˜¯ `equal-always` [[ç›¸ç­‰æ€§çš„è¡¨ç¤ºæ³•](Sharing_and_Equality.html#%28part._equal-always%29)]ï¼Œå³æ™®é€šçš„
    `is`ã€‚
- en: Do Now!
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Letâ€™s try that:'
  id: totrans-143
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è¯•è¯•è¿™ä¸ªï¼š
- en: ''
  id: totrans-144
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-145
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you see?
  id: totrans-147
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ çœ‹åˆ°äº†ä»€ä¹ˆï¼Ÿ
- en: 'Itâ€™s unsurprising that the first test, `b1 is b3`, passes. However, the second,
    `b1 is b2`, fails! And the name suggests why: the two are not guaranteed to always
    be equal. That is, suppose we were to modify the box referred to by `b1`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªæµ‹è¯•ï¼Œ`b1 is b3` é€šè¿‡ï¼Œè¿™å¹¶ä¸ä»¤äººæƒŠè®¶ã€‚ç„¶è€Œï¼Œç¬¬äºŒä¸ªæµ‹è¯•ï¼Œ`b1 is b2` å¤±è´¥äº†ï¼è€Œä¸”åå­—æš—ç¤ºäº†åŸå› ï¼šè¿™ä¸¤ä¸ªå¹¶ä¸ä¿è¯æ€»æ˜¯ç›¸ç­‰ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæˆ‘ä»¬ä¿®æ”¹
    `b1` æ‰€æŒ‡çš„ç›’å­ï¼š
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Sure enough, the values in the boxes are not the same, but because `b1` and
    `b3` are aliases, their values change in lock-step (more accurately, there is
    only one valueâ€”<wbr>the box at 1001):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: æœç„¶ï¼Œç›’å­ä¸­çš„å€¼å¹¶ä¸ç›¸åŒï¼Œä½†ç”±äº `b1` å’Œ `b3` æ˜¯åˆ«åï¼Œå®ƒä»¬çš„å€¼ä¼šåŒæ­¥å˜åŒ–ï¼ˆæ›´å‡†ç¡®åœ°è¯´ï¼Œåªæœ‰ä¸€ä¸ªå€¼â€”â€”<wbr>1001 å¤„çš„ç›’å­ï¼‰ï¼š
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 19.4Â Another Equality Predicate[ğŸ”—](#(part._.Another_.Equality_.Predicate) "Link
    to here")
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4 å¦ä¸€ä¸ªç›¸ç­‰è°“è¯[ğŸ”—](#(part._.Another_.Equality_.Predicate) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Suppose we return to the state where we have defined the three boxes [[<three-boxes>](#%28elem._three-boxes%29)]
    but not mutated `b1`. That is, when printed, all three boxes have the same value,
    `box(7)`. We have seen that `b1` and `b3` are both `equal-always` and `identical`
    to each other. However, we have also seen that `b1` and `b2` are neither of those.
    This is somewhat frustrating, because there is clearly some sense in which they
    are â€œequalâ€: at the moment, they contain the same value, even if later on one
    of them might not.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬å›åˆ°æˆ‘ä»¬å®šä¹‰äº†ä¸‰ä¸ªç›’å­ [[<three-boxes>](#%28elem._three-boxes%29)] ä½†æ²¡æœ‰çªå˜ `b1` çš„çŠ¶æ€ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“æ‰“å°æ—¶ï¼Œæ‰€æœ‰ä¸‰ä¸ªç›’å­éƒ½æœ‰ç›¸åŒçš„å€¼ï¼Œ`box(7)`ã€‚æˆ‘ä»¬å·²ç»çœ‹åˆ°
    `b1` å’Œ `b3` éƒ½æ˜¯å½¼æ­¤çš„ `equal-always` å’Œ `identical`ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ä¹Ÿå·²ç»çœ‹åˆ° `b1` å’Œ `b2` éƒ½ä¸æ˜¯è¿™äº›ã€‚è¿™æœ‰ç‚¹ä»¤äººæ²®ä¸§ï¼Œå› ä¸ºæ˜¾ç„¶åœ¨æŸäº›æ–¹é¢å®ƒä»¬æ˜¯â€œç›¸ç­‰â€çš„ï¼šåœ¨ç›®å‰ï¼Œå®ƒä»¬åŒ…å«ç›¸åŒçš„å€¼ï¼Œå³ä½¿åæ¥å…¶ä¸­ä¸€ä¸ªå¯èƒ½ä¸æ˜¯ã€‚
- en: 'Therefore, Pyret offers a third equality predicate that is designed for just
    these situations: it is (as you might guess) called `equal-now`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼ŒPyret æä¾›äº†ç¬¬ä¸‰ä¸ªç›¸ç­‰è°“è¯ï¼Œä¸“ä¸ºè¿™äº›æƒ…å†µè®¾è®¡ï¼šæ­£å¦‚ä½ å¯èƒ½çŒœåˆ°çš„ï¼Œå®ƒè¢«ç§°ä¸º `equal-now`ï¼š
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `-now` in the name reminds us that these values are equal at the moment,
    but may not be equal later. Sure enough, if we add
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`-now` åœ¨åç§°ä¸­æé†’æˆ‘ä»¬ï¼Œè¿™äº›å€¼åœ¨ç›®å‰æ˜¯ç›¸ç­‰çš„ï¼Œä½†ä»¥åå¯èƒ½ä¸å†ç›¸ç­‰ã€‚æœä¸å…¶ç„¶ï¼Œå¦‚æœæˆ‘ä»¬æ·»åŠ '
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'back into the program, the above `equal-now` tests fail: now, they are no longer
    equal!'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: å°†ä¸Šè¿° `equal-now` æµ‹è¯•æ”¾å›ç¨‹åºä¸­ï¼Œç°åœ¨å®ƒä»¬å¤±è´¥äº†ï¼šç°åœ¨å®ƒä»¬ä¸å†ç›¸ç­‰äº†ï¼
- en: 'Recall that the other two equality predicates have an binary operator notation:
    `==` for `equal-always` and `<=>` for `identical`. Similarly, `equal-now` has
    the binary operator `=~`. You should view that as `=` with hand-waving `~`: itâ€™s
    equal for now, but donâ€™t expect it to remain so. That is, we can rewrite the above
    tests as:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹ï¼Œå…¶ä»–ä¸¤ä¸ªç­‰ä»·è°“è¯æœ‰ä¸€ä¸ªäºŒå…ƒè¿ç®—ç¬¦è¡¨ç¤ºæ³•ï¼š`==`è¡¨ç¤ºâ€œå§‹ç»ˆç›¸ç­‰â€å’Œ`<=>`è¡¨ç¤ºâ€œç›¸åŒâ€ã€‚åŒæ ·ï¼Œâ€œå½“å‰ç›¸ç­‰â€æœ‰äºŒå…ƒè¿ç®—ç¬¦`=~`ã€‚ä½ åº”è¯¥å°†å…¶è§†ä¸ºå¸¦æœ‰æŒ¥æ‰‹`~`çš„`=`ï¼šå®ƒç°åœ¨ç›¸ç­‰ï¼Œä½†ä¸è¦æœŸæœ›å®ƒä¿æŒå¦‚æ­¤ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸Šè¿°æµ‹è¯•é‡å†™ä¸ºï¼š
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Whether they pass, of course, depends on the state of the program: whether
    `b1`, `b2`, or `b3` has had its content modified.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œå®ƒä»¬æ˜¯å¦é€šè¿‡ï¼Œå–å†³äºç¨‹åºçš„çŠ¶æ€ï¼š`b1`ã€`b2`æˆ–`b3`çš„å†…å®¹æ˜¯å¦å·²è¢«ä¿®æ”¹ã€‚
- en: 19.5Â A Hierarchy of Equality[ğŸ”—](#(part._equality-hierarchy) "Link to here")
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.5 ç­‰ä»·æ€§å±‚æ¬¡[ğŸ”—](#(part._equality-hierarchy) "é“¾æ¥è‡³æ­¤")
- en: As you might guess, the equality operators have a hierarchy of implication.
    That is, if one operator is true of two expressions, the other necessarily is,
    but not vice versa.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½ æ‰€çŒœï¼Œç­‰ä»·è¿ç®—ç¬¦æœ‰ä¸€ä¸ªéšå«çš„å±‚æ¬¡ç»“æ„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœä¸€ä¸ªè¿ç®—ç¬¦å¯¹ä¸¤ä¸ªè¡¨è¾¾å¼æˆç«‹ï¼Œé‚£ä¹ˆå¦ä¸€ä¸ªè¿ç®—ç¬¦å¿…ç„¶æˆç«‹ï¼Œä½†åä¹‹åˆ™ä¸ç„¶ã€‚
- en: Do Now!
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can you work out this hierarchy of implication?
  id: totrans-166
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ èƒ½æ‰¾å‡ºè¿™ä¸ªéšå«çš„å±‚æ¬¡ç»“æ„å—ï¼Ÿ
- en: Observe that if two expressions are `identical`, then they are aliases, i.e.,
    they are referring to one and the same value. Therefore, the values produced by
    those expressions must be `equal-always`. If they are always equal, then clearly
    at any given moment, they must also be `equal-now`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¦‚æœä¸¤ä¸ªè¡¨è¾¾å¼æ˜¯â€œç›¸åŒâ€ï¼Œé‚£ä¹ˆå®ƒä»¬æ˜¯åˆ«åï¼Œå³å®ƒä»¬æŒ‡å‘åŒä¸€ä¸ªå€¼ã€‚å› æ­¤ï¼Œè¿™äº›è¡¨è¾¾å¼äº§ç”Ÿçš„å€¼å¿…é¡»æ˜¯â€œå§‹ç»ˆç›¸ç­‰â€ã€‚å¦‚æœå®ƒä»¬å§‹ç»ˆç›¸ç­‰ï¼Œé‚£ä¹ˆæ˜¾ç„¶åœ¨ä»»ä½•ç»™å®šæ—¶åˆ»ï¼Œå®ƒä»¬ä¹Ÿå¿…é¡»æ˜¯â€œå½“å‰ç›¸ç­‰â€ã€‚
- en: Even if two expressions are not `identical`, they may be `equal-always`. This
    would never be true of mutable data (because there is the possibility of a future
    mutation), but it can be true of immutable data that have the same structure and
    contents. In that case, if they are always equal, then again they must be `equal-now`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: å³ä½¿ä¸¤ä¸ªè¡¨è¾¾å¼ä¸æ˜¯â€œç›¸åŒâ€ï¼Œå®ƒä»¬ä¹Ÿå¯èƒ½æ˜¯â€œå§‹ç»ˆç›¸ç­‰â€ã€‚è¿™åœ¨å¯å˜æ•°æ®ä¸­æ°¸è¿œä¸ä¼šæˆç«‹ï¼ˆå› ä¸ºå­˜åœ¨æœªæ¥å˜å¼‚çš„å¯èƒ½æ€§ï¼‰ï¼Œä½†å®ƒå¯ä»¥æˆç«‹åœ¨å…·æœ‰ç›¸åŒç»“æ„å’Œå†…å®¹çš„ä¸å¯å˜æ•°æ®ä¸­ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¦‚æœå®ƒä»¬å§‹ç»ˆç›¸ç­‰ï¼Œé‚£ä¹ˆå®ƒä»¬å†æ¬¡å¿…é¡»æ˜¯â€œå½“å‰ç›¸ç­‰â€ã€‚
- en: However, the converses are not true.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œé€†å‘½é¢˜å¹¶ä¸æˆç«‹ã€‚
- en: 'If two data are `equal-now`, they may not be `equal-always`: if they are mutable,
    a future mutation may change the equality, as we have seen above. Similarly, two
    data may be `equal-always` but not be `identical`, because they reside at different
    heap addresses and are therefore truly different data.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä¸¤ä¸ªæ•°æ®æ˜¯â€œå½“å‰ç›¸ç­‰â€ï¼Œå®ƒä»¬å¯èƒ½ä¸æ˜¯â€œå§‹ç»ˆç›¸ç­‰â€ï¼šå¦‚æœå®ƒä»¬æ˜¯å¯å˜çš„ï¼Œæœªæ¥çš„å˜å¼‚å¯èƒ½ä¼šæ”¹å˜ç­‰ä»·æ€§ï¼Œå°±åƒæˆ‘ä»¬ä¸Šé¢çœ‹åˆ°çš„ã€‚åŒæ ·ï¼Œä¸¤ä¸ªæ•°æ®å¯èƒ½â€œå§‹ç»ˆç›¸ç­‰â€ï¼Œä½†ä¸æ˜¯â€œç›¸åŒâ€ï¼Œå› ä¸ºå®ƒä»¬ä½äºä¸åŒçš„å †åœ°å€ï¼Œå› æ­¤ç¡®å®æ˜¯ä¸åŒçš„æ•°æ®ã€‚
- en: 'In most languages, it is common to have two equality operators, corresponding
    to `identical` (known as reference equality) and `equal-now` (known as structural
    equality). Pyret is rare in having a third operator, `equal-always`. For most
    programs, this is in fact the most useful equality operator: it is not overly
    bothered with details of aliasing, which can be difficult to predict; at the same
    time it makes decisions that stand the test of time, thereby forming a useful
    basis for various optimizations (which may not even be conscious of their temporal
    assumptions). This is why `is` in testing uses `equal-always` by default, and
    forces users to explicitly pick a different primitive if they want it.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¤§å¤šæ•°è¯­è¨€ä¸­ï¼Œé€šå¸¸æœ‰ä¸¤ä¸ªç­‰ä»·è¿ç®—ç¬¦ï¼Œå¯¹åº”äº`identical`ï¼ˆç§°ä¸ºå¼•ç”¨ç­‰ä»·ï¼‰å’Œ`equal-now`ï¼ˆç§°ä¸ºç»“æ„ç­‰ä»·ï¼‰ã€‚Pyretæ˜¯ç½•è§çš„ï¼Œå®ƒæœ‰ä¸€ä¸ªç¬¬ä¸‰ä¸ªè¿ç®—ç¬¦ï¼Œ`equal-always`ã€‚å¯¹äºå¤§å¤šæ•°ç¨‹åºæ¥è¯´ï¼Œè¿™å®é™…ä¸Šæ˜¯æœ€æœ‰ç”¨çš„ç­‰ä»·è¿ç®—ç¬¦ï¼šå®ƒä¸å¤ªå…³å¿ƒåˆ«åç»†èŠ‚ï¼Œè¿™äº›ç»†èŠ‚éš¾ä»¥é¢„æµ‹ï¼›åŒæ—¶ï¼Œå®ƒåšå‡ºçš„å†³ç­–ç»å¾—èµ·æ—¶é—´çš„è€ƒéªŒï¼Œä»è€Œä¸ºå„ç§ä¼˜åŒ–æä¾›äº†ä¸€ä¸ªæœ‰ç”¨çš„åŸºç¡€ï¼ˆè¿™äº›ä¼˜åŒ–ç”šè‡³å¯èƒ½æ²¡æœ‰æ„è¯†åˆ°å®ƒä»¬çš„æ—¶æ€å‡è®¾ï¼‰ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåœ¨æµ‹è¯•ä¸­ä½¿ç”¨`is`é»˜è®¤ä½¿ç”¨`equal-always`ï¼Œå¹¶å¼ºåˆ¶ç”¨æˆ·æ˜ç¡®é€‰æ‹©ä¸åŒçš„åŸå§‹è¿ç®—ç¬¦ï¼Œå¦‚æœä»–ä»¬æƒ³è¦çš„è¯ã€‚
- en: 19.6Â Space and Time Complexity[ğŸ”—](#(part._.Space_and_.Time_.Complexity) "Link
    to here")
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.6 ç©ºé—´å’Œæ—¶é—´å¤æ‚åº¦[ğŸ”—](#(part._.Space_and_.Time_.Complexity) "é“¾æ¥è‡³æ­¤")
- en: '`identical` always takes constant time. Indeed, some programs use `identical`
    precisely because they want constant-time equality, carefully structuring their
    program so that values that should be considered equal are aliases to the same
    value. Of course, maintaining this programming discipline is tricky.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`identical`æ€»æ˜¯éœ€è¦å¸¸æ•°æ—¶é—´ã€‚äº‹å®ä¸Šï¼Œä¸€äº›ç¨‹åºä½¿ç”¨`identical`æ­£æ˜¯å› ä¸ºå®ƒä»¬æƒ³è¦å¸¸æ•°æ—¶é—´çš„ç­‰ä»·æ€§ï¼Œä»”ç»†åœ°æ„å»ºå®ƒä»¬çš„ç¨‹åºï¼Œä½¿å¾—åº”è¯¥è¢«è§†ä¸ºç›¸ç­‰çš„å€¼æ˜¯åŒä¸€å€¼çš„åˆ«åã€‚å½“ç„¶ï¼Œä¿æŒè¿™ç§ç¼–ç¨‹çºªå¾‹æ˜¯æ£˜æ‰‹çš„ã€‚'
- en: '`equal-always` and `equal-now` both must traverse at least the immutable part
    of data. Therefore, they take time proportional to the smaller datum (because
    if the two data are of different size, they must not be equal anyway, so there
    is no need to visit the extra data). The difference is that `equal-always` reduces
    to `identical` at references, thereby performing less computation than `equal-now`
    would.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`equal-always` å’Œ `equal-now` éƒ½å¿…é¡»è‡³å°‘éå†æ•°æ®çš„ä¸å˜éƒ¨åˆ†ã€‚å› æ­¤ï¼Œå®ƒä»¬æ‰€éœ€çš„æ—¶é—´ä¸è¾ƒå°çš„æ•°æ®é‡æˆæ¯”ä¾‹ï¼ˆå› ä¸ºå¦‚æœä¸¤ä¸ªæ•°æ®çš„å¤§å°ä¸åŒï¼Œå®ƒä»¬è‚¯å®šä¸ç›¸ç­‰ï¼Œæ‰€ä»¥æ²¡æœ‰å¿…è¦è®¿é—®é¢å¤–çš„æ•°æ®ï¼‰ã€‚åŒºåˆ«åœ¨äº
    `equal-always` åœ¨å¼•ç”¨æ—¶ä¼šå‡å°‘åˆ° `identical`ï¼Œå› æ­¤æ¯” `equal-now` æ‰§è¡Œçš„è®¡ç®—æ›´å°‘ã€‚'
- en: 19.7Â What it Means to be Identical[ğŸ”—](#(part._sem-identical) "Link to here")
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.7 ä»€ä¹ˆæ„å‘³ç€ç›¸åŒ[ğŸ”—](#(part._sem-identical) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Return for a moment to the state where we have just defined the three boxes
    [[<three-boxes>](#%28elem._three-boxes%29)]. We could have written the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹æˆ‘ä»¬åˆšåˆšå®šä¹‰çš„ä¸‰ä¸ªç›’å­ [[<three-boxes>](#%28elem._three-boxes%29)] çš„çŠ¶æ€ã€‚æˆ‘ä»¬å¯ä»¥å†™å‡ºä»¥ä¸‹å†…å®¹ï¼š
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we can compare the contents of the various boxes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥æ¯”è¾ƒå„ä¸ªç›’å­çš„å†…å®¹ï¼š
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And at the end of performing comparisons, we can restore them:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ‰§è¡Œæ¯”è¾ƒä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥æ¢å¤å®ƒä»¬ï¼š
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Observe that `b1-id-b2` would be `false` but `b1-id-b3` would be `true`. And
    notice that this would always be true when the two expressions are identical,
    but not otherwise.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ° `b1-id-b2` ä¼šæ˜¯ `false`ï¼Œä½† `b1-id-b3` ä¼šæ˜¯ `true`ã€‚å¹¶ä¸”è¯·æ³¨æ„ï¼Œå½“ä¸¤ä¸ªè¡¨è¾¾å¼ç›¸åŒçš„æ—¶å€™ï¼Œè¿™å§‹ç»ˆæ˜¯æ­£ç¡®çš„ï¼Œä½†å¦‚æœä¸ç›¸åŒåˆ™ä¸ç„¶ã€‚
- en: Thus, at the end there has been no change, but by making the change we can check
    which values are and arenâ€™t aliases of others. In other words, thisrepresents
    the essence of `identical`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæœ€ç»ˆæ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œä½†é€šè¿‡è¿›è¡Œæ›´æ”¹ï¼Œæˆ‘ä»¬å¯ä»¥æ£€æŸ¥å“ªäº›å€¼æ˜¯å…¶ä»–å€¼çš„åˆ«åï¼Œå“ªäº›ä¸æ˜¯ã€‚æ¢å¥è¯è¯´ï¼Œè¿™ä»£è¡¨äº† `identical` çš„æœ¬è´¨ã€‚
- en: 'In practice, `identical` does not behave this way: it would be too disruptive.
    It is also not the most efficient implementation possible, when Pyret can simply
    check the memory addresses being the same. Nevertheless, it does demonstrate the
    basic idea behind `identical`: two values are `identical` precisely when, when
    you make changes to one, you see the changes manifest on the â€œotherâ€ (i.e., there
    is really only one value, but with potentially multiple names for it).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®è·µä¸­ï¼Œ`identical` å¹¶ä¸è¿™æ ·è¡¨ç°ï¼šè¿™ä¼šå¤ªå…·ç ´åæ€§ã€‚å®ƒä¹Ÿä¸æ˜¯å¯èƒ½çš„æœ€æœ‰æ•ˆå®ç°ï¼Œå› ä¸º Pyret å¯ä»¥ç®€å•åœ°æ£€æŸ¥å†…å­˜åœ°å€æ˜¯å¦ç›¸åŒã€‚å°½ç®¡å¦‚æ­¤ï¼Œå®ƒç¡®å®å±•ç¤ºäº†
    `identical` èƒŒåçš„åŸºæœ¬æ€æƒ³ï¼šä¸¤ä¸ªå€¼åœ¨ä¸”ä»…åœ¨å½“ä½ å¯¹ä¸€ä¸ªå€¼è¿›è¡Œæ›´æ”¹æ—¶ï¼Œä½ ä¼šåœ¨â€œå¦ä¸€ä¸ªâ€å€¼ä¸Šçœ‹åˆ°è¿™äº›æ›´æ”¹ï¼ˆå³ï¼Œå®é™…ä¸Šåªæœ‰ä¸€ä¸ªå€¼ï¼Œä½†å¯èƒ½æœ‰å¤šä¸ªåç§°ï¼‰ã€‚
- en: 19.8Â Comparing Functions[ğŸ”—](#(part._comp-func) "Link to here")
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.8 æ¯”è¾ƒå‡½æ•°[ğŸ”—](#(part._comp-func) "é“¾æ¥åˆ°æ­¤å¤„")
- en: We havenâ€™t actually provided the full truth about equality because we havenâ€™t
    discussed functions. Defining equality for functionsâ€”<wbr>especially extensional
    equality, namely whether two functions have the same graph, i.e., for each input
    produce the same outputâ€”<wbr>is complicated (a euphemism for impossible) due to
    the Halting Problem.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å®é™…ä¸Šå¹¶æ²¡æœ‰æä¾›å…³äºç­‰ä»·çš„å®Œæ•´çœŸç›¸ï¼Œå› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰è®¨è®ºå‡½æ•°ã€‚å®šä¹‰å‡½æ•°çš„ç­‰ä»·â€”â€”ç‰¹åˆ«æ˜¯å¤–å»¶ç­‰ä»·ï¼Œå³ä¸¤ä¸ªå‡½æ•°æ˜¯å¦æœ‰ç›¸åŒçš„å›¾ï¼Œå³å¯¹äºæ¯ä¸ªè¾“å…¥äº§ç”Ÿç›¸åŒçš„è¾“å‡ºâ€”â€”ç”±äºåœæœºé—®é¢˜è€Œå˜å¾—å¤æ‚ï¼ˆè¿™æ˜¯ä¸€ä¸ªå§”å©‰çš„è¯´æ³•ï¼Œå³ä¸å¯èƒ½ï¼‰ã€‚
- en: 'Because of this, most languages have tended to use approximations for function
    equality, most commonly reference equality. This is, however, a very weak approximation:
    even if the exact same function text in the same environment is allocated as two
    different closures, these would not be reference-equal. At least when this is
    done as part of the definition of `identical`, it makes sense; if other operators
    do this, however, they are actively lying, which is something the equality operators
    do not usually do.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºè¿™ä¸ªåŸå› ï¼Œå¤§å¤šæ•°è¯­è¨€å€¾å‘äºä½¿ç”¨å‡½æ•°ç­‰ä»·çš„è¿‘ä¼¼å€¼ï¼Œæœ€å¸¸è§çš„æ˜¯å¼•ç”¨ç­‰ä»·ã€‚ç„¶è€Œï¼Œè¿™å´æ˜¯ä¸€ä¸ªéå¸¸å¼±çš„è¿‘ä¼¼ï¼šå³ä½¿åœ¨ç›¸åŒçš„ç¯å¢ƒä¸­ï¼Œç›¸åŒçš„å‡½æ•°æ–‡æœ¬è¢«åˆ†é…ä¸ºä¸¤ä¸ªä¸åŒçš„é—­åŒ…ï¼Œè¿™äº›é—­åŒ…ä¹Ÿä¸ä¼šæ˜¯å¼•ç”¨ç­‰ä»·çš„ã€‚è‡³å°‘å½“è¿™ä½œä¸º
    `identical` å®šä¹‰çš„ä¸€éƒ¨åˆ†è¿›è¡Œæ—¶ï¼Œè¿™æ˜¯æœ‰æ„ä¹‰çš„ï¼›ç„¶è€Œï¼Œå¦‚æœå…¶ä»–æ“ä½œç¬¦è¿™æ ·åšï¼Œå®ƒä»¬å°±æ˜¯åœ¨æ’’è°ï¼Œè€Œè¿™é€šå¸¸ä¸æ˜¯ç­‰ä»·æ“ä½œç¬¦çš„è¡Œä¸ºã€‚
- en: 'There is one other approach we can take: simply disallow function comparison.
    This is what Pyret does: all three equality operators above will result in an
    error if you try to compare two functions. (You can compare against just one function,
    however, and you will get the answer `false`.) This ensures that the languageâ€™s
    comparison operators are never trusted falsely.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥é‡‡å–å¦ä¸€ç§æ–¹æ³•ï¼šç®€å•åœ°ç¦æ­¢å‡½æ•°æ¯”è¾ƒã€‚è¿™å°±æ˜¯ Pyret æ‰€åšçš„ï¼šå¦‚æœä½ å°è¯•æ¯”è¾ƒä¸¤ä¸ªå‡½æ•°ï¼Œä¸Šè¿°æ‰€æœ‰ä¸‰ä¸ªç­‰ä»·æ“ä½œç¬¦éƒ½ä¼šå¯¼è‡´é”™è¯¯ã€‚ï¼ˆç„¶è€Œï¼Œä½ å¯ä»¥ä¸ä¸€ä¸ªå‡½æ•°è¿›è¡Œæ¯”è¾ƒï¼Œä½ å°†å¾—åˆ°
    `false` çš„ç­”æ¡ˆã€‚ï¼‰è¿™ç¡®ä¿äº†è¯­è¨€çš„æ¯”è¾ƒæ“ä½œç¬¦æ°¸è¿œä¸ä¼šè¢«é”™è¯¯åœ°ä¿¡ä»»ã€‚
- en: Pyret did have the choice of allowing reference equality for functions inside
    `identical` and erroring only in the other two cases. Had it done so, however,
    it would have violated the chain of implication above [[A Hierarchy of Equality](#%28part._equality-hierarchy%29)].
    The present design is arguably more elegant. Programmers who do want to use reference
    equality on functions can simply embed the functions inside a mutable structure
    like boxes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretç¡®å®å¯ä»¥é€‰æ‹©åœ¨`identical`å†…éƒ¨å…è®¸å¼•ç”¨ç›¸ç­‰æ€§ï¼Œå¹¶åœ¨å…¶ä»–ä¸¤ç§æƒ…å†µä¸‹æŠ¥é”™ã€‚ç„¶è€Œï¼Œå¦‚æœå®ƒè¿™æ ·åšï¼Œå°±ä¼šè¿åä¸Šè¿°çš„æ¨ç†é“¾ [[ç­‰ä»·æ€§å±‚æ¬¡](#(part._equality-hierarchy))].
    å½“å‰çš„è®¾è®¡å¯ä»¥è¯´æ˜¯æ›´åŠ ä¼˜é›…ã€‚é‚£äº›ç¡®å®æƒ³è¦åœ¨å‡½æ•°ä¸Šä½¿ç”¨å¼•ç”¨ç›¸ç­‰çš„ç¨‹åºå‘˜å¯ä»¥ç®€å•åœ°å°†å‡½æ•°åµŒå…¥åˆ°ä¸€ä¸ªå¯å˜ç»“æ„ï¼Œæ¯”å¦‚ç›’å­ä¸­ã€‚
- en: 'There is one problem with erroring when comparing two functions: a completely
    generic procedure that compares two arbitrary values may error if both of the
    values given are functions. Because this can cause unpredictable program failure,
    Pyret offers a three-valued version of each of the above three operators (`identical3`,
    `equal-always3` and `equal-now3`), all of which return `EqualityResult` values
    that correspond to truth, falsity, and ignorance (returned in the case when both
    arguments are functions). Programmers can use this in place of the Boolean-valued
    comparison operators if they are uncertain about the types of the parameters.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ¯”è¾ƒä¸¤ä¸ªå‡½æ•°æ—¶æœ‰ä¸€ä¸ªé—®é¢˜ï¼šä¸€ä¸ªå®Œå…¨é€šç”¨çš„æ¯”è¾ƒä¸¤ä¸ªä»»æ„å€¼çš„ç¨‹åºå¯èƒ½ä¼šæŠ¥é”™ï¼Œå¦‚æœç»™å®šçš„ä¸¤ä¸ªå€¼éƒ½æ˜¯å‡½æ•°çš„è¯ã€‚å› ä¸ºè¿™ç§æƒ…å†µå¯èƒ½ä¼šå¼•èµ·ä¸å¯é¢„æµ‹çš„ç¨‹åºå¤±è´¥ï¼ŒPyretä¸ºä¸Šè¿°ä¸‰ä¸ªæ“ä½œç¬¦ä¸­çš„æ¯ä¸€ä¸ªéƒ½æä¾›äº†ä¸€ä¸ªä¸‰å€¼ç‰ˆæœ¬ï¼ˆ`identical3`ã€`equal-always3`å’Œ`equal-now3`ï¼‰ï¼Œæ‰€æœ‰è¿™äº›æ“ä½œç¬¦éƒ½è¿”å›å¯¹åº”äºçœŸå€¼ã€å‡å€¼å’ŒæœªçŸ¥ï¼ˆå½“ä¸¤ä¸ªå‚æ•°éƒ½æ˜¯å‡½æ•°æ—¶è¿”å›ï¼‰çš„`EqualityResult`å€¼ã€‚å¦‚æœç¨‹åºå‘˜ä¸ç¡®å®šå‚æ•°çš„ç±»å‹ï¼Œä»–ä»¬å¯ä»¥ä½¿ç”¨è¿™äº›æ“ä½œç¬¦æ¥ä»£æ›¿å¸ƒå°”å€¼æ¯”è¾ƒæ“ä½œç¬¦ã€‚
