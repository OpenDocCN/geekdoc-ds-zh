- en: 17.4Â Shortest (or Lightest) PathsðŸ”—
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŽŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/lightest-paths.html](https://dcic-world.org/2025-08-27/lightest-paths.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'Imagine planning a trip: itâ€™s natural that you might want to get to your destination
    in the least time, or for the least money, or some other criterion that involves
    minimizing the sum of edge weights. This is known as computing the shortest path.'
  prefs: []
  type: TYPE_NORMAL
- en: We should immediately clarify an unfortunate terminological confusion. What
    we really want to compute is the lightest pathâ€”<wbr>the one of least weight. Unfortunately,
    computer science terminology has settled on the terminology we use here; just
    be sure to not take it literally.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Construct a graph and select a pair of nodes in it such that the shortest path
    from one to the other is not the lightest one, and vice versa.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: We have already seen [[Depth- and Breadth-First Traversals](basic-graph-trav.html#%28part._dfs-bfs%29)]
    that breadth-first search constructs shortest paths in unweighted graphs. These
    correspond to lightest paths when there are no weights (or, equivalently, all
    weights are identical and positive). Now we have to generalize this to the case
    where the edges have weights.
  prefs: []
  type: TYPE_NORMAL
- en: We will proceed inductively, gradually defining a function seemingly of this
    type
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'that reflects the weight of the lightest path from the source node to that
    one. But letâ€™s think about this annotation: since weâ€™re building this up node-by-node,
    initially most nodes have no weight to report; and even at the end, a node that
    is unreachable from the source will have no weight for a lightest (or indeed,
    any) path. Rather than make up a number that pretends to reflect this situation,
    we will instead use an option type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When there is `some` value it will be the weight; otherwise the weight will
    be `none`.
  prefs: []
  type: TYPE_NORMAL
- en: Now letâ€™s think about this inductively. What do we know initially? Well, certainly
    that the source node is at a distance of zero from itself (that must be the lightest
    path, because we canâ€™t get any lighter). This gives us a (trivial) set of nodes
    for which we already know the lightest weight. Our goal is to grow this set of
    nodesâ€”<wbr>modestly, by one, on each iterationâ€”<wbr>until we either find the destination,
    or we have no more nodes to add (in which case our desination is not reachable
    from the source).
  prefs: []
  type: TYPE_NORMAL
- en: Inductively, at each step we have the set of all nodes for which we know the
    lightest path (initially this is just the source node, but it does mean this set
    is never empty, which will matter in what we say next). Now consider all the edges
    adjacent to this set of nodes that lead to nodes for which we donâ€™t already know
    the lightest path. Choose a node, \(q\), that minimizes the total weight of the
    path to it. We claim that this will in fact be the lightest path to that node.
  prefs: []
  type: TYPE_NORMAL
- en: If this claim is true, then we are done. Thatâ€™s because we would now add \(q\)
    to the set of nodes whose lightest weights we now know, and repeat the process
    of finding lightest outgoing edges from there. This process has thus added one
    more node. At some point we will find that there are no edges that lead outside
    the known set, at which point we can terminate.
  prefs: []
  type: TYPE_NORMAL
- en: 'It stands to reason that terminating at this point is safe: it corresponds
    to having computed the reachable set. The only thing left is to demonstrate that
    this greedy algorithm yields a lightest path to each node.'
  prefs: []
  type: TYPE_NORMAL
- en: We will prove this by contradiction. Suppose we have the path \(s \rightarrow
    d\) from source \(s\) to node \(d\), as found by the algorithm above, but assume
    also that we have a different path that is actually lighter. At every node, when
    we added a node along the \(s \rightarrow d\) path, the algorithm would have added
    a lighter path if it existed. The fact that it did not falsifies our claim that
    a lighter path exists (there could be a different path of the same weight; this
    would be permitted by the algorithm, but it also doesnâ€™t contradict our claim).
    Therefore the algorithm does indeed find the lightest path.
  prefs: []
  type: TYPE_NORMAL
- en: 'What remains is to determine a data structure that enables this algorithm.
    At every node, we want to know the least weight from the set of nodes for which
    we know the least weight to all their neighbors. We could achieve this by sorting,
    but this is overkill: we donâ€™t actually need a total ordering on all these weights,
    only the lightest one. A heap [see Wikipedia](https://en.wikipedia.org/wiki/Heap_(data_structure))
    gives us this.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if we allowed edges of weight zero? What would change in the above algorithm?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if we allowed edges of negative weight? What would change in the above
    algorithm?After youâ€™ve thought about this for a while, take a look at [this article](https://www.quantamagazine.org/finally-a-fast-algorithm-for-shortest-paths-on-negative-graphs-20230118/).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: For your reference, this algorithm is known as Dijkstraâ€™s Algorithm.
  prefs: []
  type: TYPE_NORMAL
