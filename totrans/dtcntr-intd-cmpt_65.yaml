- en: 20¬†Recursion and Cycles from Mutationüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/rec-from-mut.html](https://dcic-world.org/2025-08-27/rec-from-mut.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Earlier [[From Acyclicity to Cycles](Sharing_and_Equality.html#%28part._acyc-to-cyc%29)],
    we saw the difficulty of constructing cyclic data, and saw how we could address
    this problem using state [[Cyclic Data](unified-cyclic-data.html)]. Let us now
    return to the earlier example of creating a cyclic list of alternating colors.
    We had tried to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: which, as we noted, does not pass muster because `web-colors` is not bound on
    the right of the `=`. (Why not? Because otherwise, if we try to substitute `web-colors`
    on the right, we would end up in an infinite regress.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Something about this should make you a little suspicious: we have been able
    to write recursive functions all the time, without difficulty. Why are they different?
    For two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The first reason is the fact that we‚Äôre defining a function. A function‚Äôs body
    is not evaluated right away‚Äî<wbr>only when we apply it‚Äî<wbr>so the language can
    wait for the body to finish being defined. (We‚Äôll see what this might mean in
    a moment.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second reason isn‚Äôt actually a reason: function definitions actually are
    special. But we are about to expose what‚Äôs so special about them‚Äî<wbr>it‚Äôs the
    use of a box! [[Boxes: A Canonical Mutable Structure](state-in-pyret.html#%28part._boxes%29)]‚Äî<wbr>so
    that any definition can avail of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returning to our example above, recall that we can‚Äôt make up our list using
    `link`s, because we want the list to never terminate. Therefore, let us first
    define a new datatype to hold an cyclic list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You should think of this as analogous to a list, where `hd` is the first element
    and `tl` is the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Observe that we have carefully avoided writing type definitions for the fields;
    we will instead try to figure them out as we go along. Also, however, this definition
    as written cannot work.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see why not?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let‚Äôs decompose the intended infinite list into two pieces: lists that begin
    with white and ones that begin with grey. What follows white? A grey list. What
    follows grey? A white list. It is clear we can‚Äôt write down these two definitions
    because one of them must precede the other, but each one depends on the other.
    (This is the same problem as trying to write a single definition above.)'
  prefs: []
  type: TYPE_NORMAL
- en: 20.1¬†Partial Definitions[üîó](#(part._.Partial_.Definitions) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What we need to instead do is to partially define each list, and then complete
    the definition using the other one. However, that is impossible using the above
    definition, because we cannot change anything once it is constructed. Instead,
    therefore, we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that this datatype lacks a base case, which should remind you of definitions
    we saw in [Streams From Functions](func-as-data.html#%28part._streams-from-funs%29).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this, we can define:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these definitions is quite useless by itself, but they each represent
    what we want, and they have a mutable field for the rest, currently holding a
    dummy value. Therefore, it‚Äôs clear what we must do next: update the mutable field.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we have ordained that our colors must alternate beginning with white,
    this rounds up our definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we ask Pyret to inspect the value of `web-colors`, we notice that it employs
    an algorithm to prevent traversing infinite objects. You can learn more about
    how that works separately [[Detecting Cycles](cycle-detection.html)].
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a helper function, `take`, a variation of which we saw for streams
    [[Streams From Functions](func-as-data.html#%28part._streams-from-funs%29)], to
    inspect a finite prefix of an infinite list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 20.2¬†Recursive Functions[üîó](#(part._rec-for-recursive) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Based on this, we can now understand recursive functions. Consider a very simple
    example, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We might like to think this is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: but if you enter this, Pyret will complain that `sum` is not bound. We must
    instead write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: What do you think `rec` does? It binds `sum` to a box initially containing a
    dummy value; it then defines the function in an environment where the name is
    bound, unboxing the use of the name; and finally, it replaces the box‚Äôs content
    with the defined function, following the same pattern we saw earlier for `web-colors`.
  prefs: []
  type: TYPE_NORMAL
- en: 20.3¬†Premature Evaluation[üîó](#(part._premature-eval) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Observe that the above description reveals that there is a time between the
    creation of the name and the assignment of a value to it. Can this intermediate
    state be observed? It sure can!
  prefs: []
  type: TYPE_NORMAL
- en: 'There are generally three solutions to this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the value is sufficiently obscure so that it can never be used in
    a meaningful context. This means values like 0 are especially bad, and indeed
    most common datatypes should be shunned. Indeed, there is no value already in
    use that can be used here that might not be confusing in some context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The language might create a new type of value just for use here. For instance,
    imagine this definition of `CList`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`undef` appears to be a ‚Äúbase case‚Äù, thus making `CList` very similar to `List`.
    In truth, however, the `undef` is present only until the first mutation happens,
    after which it will never again be present: the intent is that `r` only contain
    a reference to other `clink`s.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `undef` value can now be used by the language to check for premature uses
    of a cyclic list. However, while this is technically feasible, it imposes a run-time
    penalty. Therefore, this check is usually only performed by languages focused
    on teaching; professional programmers are assumed to be able to manage the consequences
    of such premature use by themselves.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Allow the recursion constructor to be used only in the case of binding functions,
    and then make sure that the right-hand side of the binding is syntactically a
    function. This solution precludes some reasonable programs, but is certainly safe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 20.4¬†Cyclic Lists Versus Streams[üîó](#(part._.Cyclic_.Lists_.Versus_.Streams)
    "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The color list example above is, as we have noted, very reminiscent of stream
    examples. What is the relationship between the two ways of defining infinite data?
  prefs: []
  type: TYPE_NORMAL
- en: 'Cyclic lists have on their side simplicity. The pattern of definition used
    above can actually be encapsulated into a language construct, so programmers do
    not need to wrestle with mutable fields (as above) or thunks (as streams demand).
    This simplicity, however, comes at a price: cyclic lists can only represent strictly
    repeating data, i.e., you cannot define `nats` or `fibs` as cyclic lists. In contrast,
    the function abstraction in a stream makes it generative: each invocation can
    create a truly novel datum (such as the next natural or Fibonacci number). Therefore,
    it is straightforward to implement cyclic lists as streams, but not vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: 20.1¬†Partial Definitions[üîó](#(part._.Partial_.Definitions) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What we need to instead do is to partially define each list, and then complete
    the definition using the other one. However, that is impossible using the above
    definition, because we cannot change anything once it is constructed. Instead,
    therefore, we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that this datatype lacks a base case, which should remind you of definitions
    we saw in [Streams From Functions](func-as-data.html#%28part._streams-from-funs%29).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this, we can define:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these definitions is quite useless by itself, but they each represent
    what we want, and they have a mutable field for the rest, currently holding a
    dummy value. Therefore, it‚Äôs clear what we must do next: update the mutable field.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we have ordained that our colors must alternate beginning with white,
    this rounds up our definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If we ask Pyret to inspect the value of `web-colors`, we notice that it employs
    an algorithm to prevent traversing infinite objects. You can learn more about
    how that works separately [[Detecting Cycles](cycle-detection.html)].
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a helper function, `take`, a variation of which we saw for streams
    [[Streams From Functions](func-as-data.html#%28part._streams-from-funs%29)], to
    inspect a finite prefix of an infinite list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 20.2¬†Recursive Functions[üîó](#(part._rec-for-recursive) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Based on this, we can now understand recursive functions. Consider a very simple
    example, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We might like to think this is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: but if you enter this, Pyret will complain that `sum` is not bound. We must
    instead write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: What do you think `rec` does? It binds `sum` to a box initially containing a
    dummy value; it then defines the function in an environment where the name is
    bound, unboxing the use of the name; and finally, it replaces the box‚Äôs content
    with the defined function, following the same pattern we saw earlier for `web-colors`.
  prefs: []
  type: TYPE_NORMAL
- en: 20.3¬†Premature Evaluation[üîó](#(part._premature-eval) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Observe that the above description reveals that there is a time between the
    creation of the name and the assignment of a value to it. Can this intermediate
    state be observed? It sure can!
  prefs: []
  type: TYPE_NORMAL
- en: 'There are generally three solutions to this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the value is sufficiently obscure so that it can never be used in
    a meaningful context. This means values like 0 are especially bad, and indeed
    most common datatypes should be shunned. Indeed, there is no value already in
    use that can be used here that might not be confusing in some context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The language might create a new type of value just for use here. For instance,
    imagine this definition of `CList`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`undef` appears to be a ‚Äúbase case‚Äù, thus making `CList` very similar to `List`.
    In truth, however, the `undef` is present only until the first mutation happens,
    after which it will never again be present: the intent is that `r` only contain
    a reference to other `clink`s.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `undef` value can now be used by the language to check for premature uses
    of a cyclic list. However, while this is technically feasible, it imposes a run-time
    penalty. Therefore, this check is usually only performed by languages focused
    on teaching; professional programmers are assumed to be able to manage the consequences
    of such premature use by themselves.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Allow the recursion constructor to be used only in the case of binding functions,
    and then make sure that the right-hand side of the binding is syntactically a
    function. This solution precludes some reasonable programs, but is certainly safe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 20.4¬†Cyclic Lists Versus Streams[üîó](#(part._.Cyclic_.Lists_.Versus_.Streams)
    "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The color list example above is, as we have noted, very reminiscent of stream
    examples. What is the relationship between the two ways of defining infinite data?
  prefs: []
  type: TYPE_NORMAL
- en: 'Cyclic lists have on their side simplicity. The pattern of definition used
    above can actually be encapsulated into a language construct, so programmers do
    not need to wrestle with mutable fields (as above) or thunks (as streams demand).
    This simplicity, however, comes at a price: cyclic lists can only represent strictly
    repeating data, i.e., you cannot define `nats` or `fibs` as cyclic lists. In contrast,
    the function abstraction in a stream makes it generative: each invocation can
    create a truly novel datum (such as the next natural or Fibonacci number). Therefore,
    it is straightforward to implement cyclic lists as streams, but not vice versa.'
  prefs: []
  type: TYPE_NORMAL
