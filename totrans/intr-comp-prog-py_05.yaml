- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: FUNCTIONS, SCOPING, AND ABSTRACTION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数、作用域和抽象
- en: So far, we have introduced numbers, assignments, input/output, comparisons,
    and looping constructs. How powerful is this subset of Python? In a theoretical
    sense, it is as powerful as you will ever need, i.e., it is Turing complete. This
    means that if a problem can be solved using computation, it can be solved using
    only those linguistic mechanisms you have already seen.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了数字、赋值、输入/输出、比较和循环结构。这个 Python 子集有多强大？从理论上讲，它强大到你所需的一切，即它是图灵完备的。这意味着，如果一个问题可以通过计算解决，那么它可以仅仅使用你已经看到的语言机制来解决。
- en: But just because something can be done, doesn't mean it should be done! While
    any computation can, in principle, be implemented using only these mechanisms,
    doing so is wildly impractical. In the last chapter, we looked at an algorithm
    for finding an approximation to the square root of a positive number, see [Figure
    4-1](#c4-fig-0001).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但仅仅因为某件事可以做，并不意味着应该去做！虽然原则上任何计算都可以仅使用这些机制来实现，但这样做非常不实际。在上一章中，我们查看了一个寻找正数平方根近似值的算法，见[图
    4-1](#c4-fig-0001)。
- en: '![c4-fig-0001.jpg](../images/c4-fig-0001.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0001.jpg](../images/c4-fig-0001.jpg)'
- en: '[Figure 4-1](#c4-fig-0001a) Using bisection search to approximate square root
    of x'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-1](#c4-fig-0001) 使用二分查找法近似计算 x 的平方根'
- en: This is a reasonable piece of code, but it lacks general utility. It works only
    for the values assigned to the variables `x` and `epsilon`. This means that if
    we want to reuse it, we need to copy the code, possibly edit the variable names,
    and paste it where we want it. We cannot easily use this computation inside of
    some other, more complex, computation. Furthermore, if we want to compute cube
    roots rather than square roots, we have to edit the code. If we want a program
    that computes both square and cube roots (or for that matter computes square roots
    in two different places), the program would contain multiple chunks of almost
    identical code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个合理的代码片段，但缺乏通用性。它仅适用于分配给变量`x`和`epsilon`的值。这意味着如果我们想重用它，就需要复制代码，可能还要编辑变量名，然后粘贴到我们想要的位置。我们不能轻松地在其他更复杂的计算中使用这个计算。此外，如果我们想计算立方根而不是平方根，我们就得编辑代码。如果我们想要一个能够计算平方根和立方根的程序（或者说在两个不同地方计算平方根），程序中将包含多块几乎相同的代码。
- en: '[Figure 4-2](#c4-fig-0002) adapts the code in [Figure 4-1](#c4-fig-0001) to
    print the sum of the square root of `x1` and the cube root of `x2`. The code works,
    but it''s not pretty.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-2](#c4-fig-0002) 将[图 4-1](#c4-fig-0001)中的代码改编为打印`x1`的平方根和`x2`的立方根的和。代码可以运行，但看起来不太美观。'
- en: '![c4-fig-0002.jpg](../images/c4-fig-0002.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0002.jpg](../images/c4-fig-0002.jpg)'
- en: '[Figure 4-2](#c4-fig-0002a) Summing a square root and a cube root'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-2](#c4-fig-0002) 平方根和立方根的和'
- en: The more code a program contains, the more chance something can go wrong, and
    the harder the code is to maintain. Imagine, for example, that there were an error
    in the initial implementation of bisection search, and that the error came to
    light when testing the program. It would be all too easy to fix the implementation
    in one place and not notice similar code elsewhere that needed repair.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 程序包含的代码越多，出错的机会就越大，代码的维护也越困难。例如，想象一下，如果二分查找法的初始实现存在错误，并且在测试程序时发现了这个错误，那么很容易在一个地方修复实现，而忽视了其他需要修复的类似代码。
- en: Fortunately, Python provides several linguistic features that make it relatively
    easy to generalize and reuse code. The most important is the function.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python 提供了几种语言特性，使得泛化和重用代码相对容易。最重要的是函数。
- en: 4.1 Functions and Scoping
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 函数与作用域
- en: We've already used a number of built-in functions, e.g., `max` and `abs` in
    [Figure 4-1](#c4-fig-0001). The ability for programmers to define and then use
    their own functions, as if they were built-in, is a qualitative leap forward in
    convenience.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了多个内置函数，例如在[图 4-1](#c4-fig-0001)中使用的`max`和`abs`。程序员能够定义并像内置函数一样使用自己的函数，这在便利性上是一个质的飞跃。
- en: 4.1.1 Function Definitions
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 函数定义
- en: In Python each **function definition** is of the form[^(25)](#c4-fn-0001)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，每个**函数定义**的形式是[^(25)](#c4-fn-0001)
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For example, we could define the function `max_val`[^(26)](#c4-fn-0002) by the
    code
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过代码定义函数`max_val`[^(26)](#c4-fn-0002)
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`def` is a reserved word that tells Python a function is about to be defined.
    The function name (`max_val` in this example) is simply a name that is used to
    refer to the function. The PEP 8 convention is that function names should be in
    all lowercase with words separated by underscores to improve readability.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`def`是一个保留字，告诉Python即将定义一个函数。函数名（在此示例中为`max_val`）只是一个用于引用函数的名称。PEP 8规范要求函数名应全小写，单词用下划线分隔，以提高可读性。'
- en: The sequence of names within the parentheses following the function name (`x`,`y`
    in this example) are the **formal parameters** of the function. When the function
    is used, the formal parameters are bound (as in an assignment statement) to the
    **actual parameters** (often referred to as **arguments**) of the **function invocation**
    (also referred to as a **function call**). For example, the invocation
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名后括号中的名称序列（在此示例中为`x`,`y`）是函数的**形式参数**。当使用函数时，形式参数被绑定（如同赋值语句）到**实际参数**（通常称为**实参**）的**函数调用**（也称为**函数调用**）。例如，该调用
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: binds `x` to `3` and `y` to `4`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将`x`绑定到`3`，`y`绑定到`4`。
- en: The function body is any piece of Python code.[^(27)](#c4-fn-0003) There is,
    however, a special statement, `**return**`, that can be used only within the body
    of a function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体是任何Python代码的片段。[^(27)](#c4-fn-0003) 然而，有一个特殊语句`**return**`，只能在函数体内使用。
- en: A function call is an expression, and like all expressions, it has a value.
    That value is returned by the invoked function. For example, the value of the
    expression `max_val(3,4)*max_val(3,2)` is `12`, because the first invocation of
    `max_val` returns the `int` `4` and the second returns the `int` `3`. Note that
    execution of a `return` statement terminates an invocation of the function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用是一个表达式，像所有表达式一样，它有一个值。该值由被调用的函数返回。例如，表达式`max_val(3,4)*max_val(3,2)`的值是`12`，因为第一次调用`max_val`返回`int`
    `4`，第二次返回`int` `3`。请注意，执行`return`语句会终止函数的调用。
- en: To recapitulate, when a function is called
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 概括地说，当调用函数时
- en: 1\. The expressions that make up the actual parameters are evaluated, and the
    formal parameters of the function are bound to the resulting values. For example,
    the invocation `max_val(3+4, z)` will bind the formal parameter `x` to `7` and
    the formal parameter `y` to whatever value the variable `z` has when the invocation
    is executed.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 组成实际参数的表达式被求值，函数的形式参数被绑定到结果值。例如，调用`max_val(3+4, z)`将把形式参数`x`绑定到`7`，将形式参数`y`绑定到调用执行时变量`z`的值。
- en: 2\. The **point of execution** (the next instruction to be executed) moves from
    the point of invocation to the first statement in the body of the function.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. **执行点**（下一条要执行的指令）从调用点移动到函数体中的第一条语句。
- en: 3\. The code in the body of the function is executed until either a `return`
    statement is encountered, in which case the value of the expression following
    the `return` becomes the value of the function invocation, or there are no more
    statements to execute, in which case the function returns the value `None`. (If
    no expression follows the `return`, the value of the invocation is `None`.)[^(28)](#c4-fn-0004)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 函数体中的代码会执行，直到遇到`return`语句，在这种情况下，`return`后面表达式的值成为函数调用的值；如果没有更多语句可执行，函数将返回值`None`。（如果`return`后没有表达式，调用的值为`None`。）[^(28)](#c4-fn-0004)
- en: 4\. The value of the invocation is the returned value.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 调用的值是返回的值。
- en: 5\. The point of execution is transferred back to the code immediately following
    the invocation.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5\. 执行点被转移回紧接在调用后面的代码。
- en: Parameters allow programmers to write code that accesses not specific objects,
    but instead whatever objects the caller of the function chooses to use as actual
    parameters. This is called **lambda abstraction**.[^(29)](#c4-fn-0005)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 参数使程序员能够编写访问特定对象的代码，而是访问调用函数时选择用作实际参数的对象。这被称为**lambda抽象**。[^(29)](#c4-fn-0005)
- en: '[Figure 4-3](#c4-fig-0003) contains a function that has three formal parameters
    and returns a value, call it `result`, such that `abs(result**power – x) >= epsilon`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-3](#c4-fig-0003)包含一个有三个形式参数并返回一个值的函数，称其为`result`，使得`abs(result**power
    – x) >= epsilon`。'
- en: '![c4-fig-0003.jpg](../images/c4-fig-0003.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0003.jpg](../images/c4-fig-0003.jpg)'
- en: '[Figure 4-3](#c4-fig-0003a) A function for finding roots'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-3](#c4-fig-0003a) 一个寻找根的函数'
- en: '[Figure 4-4](#c4-fig-0004) contains code that can be used to test whether `find_root`
    works as intended. The testing function `test_find_root` is about the same length
    as `find_root` itself. To inexperienced programmers, writing **test functions**
    often seems to be a waste of effort. Experienced programmers know, however, that
    an investment in writing testing code often pays big dividends. It certainly beats
    sitting at a keyboard and typing test cases into the shell over and over during
    **debugging** (the process of finding out why a program does not work, and then
    fixing it). Notice that because we are invoking `test_find_root` with three tuples
    (i.e., sequences of values) of length three, one call checks 27 combinations of
    parameters. Finally, because `test_find_root` checks whether `find_root` is returning
    an appropriate answer and reports the result, it saves the programmer from the
    tedious and error-prone task of visually inspecting each output and checking it
    for correctness. We return to the subject of testing in Chapter 8.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-4](#c4-fig-0004) 包含可用于测试 `find_root` 是否按预期工作的代码。测试函数 `test_find_root`
    的长度与 `find_root` 本身大致相同。对于缺乏经验的程序员来说，编写 **测试函数** 通常看起来是一种浪费精力。然而，经验丰富的程序员知道，编写测试代码的投资往往会带来丰厚的回报。这绝对胜过在键盘前反复输入测试用例到
    shell 中进行 **调试**（找出程序为何不工作并修复的过程）。请注意，由于我们使用三个长度为三的元组调用 `test_find_root`，一次调用检查
    27 种参数组合。最后，因为 `test_find_root` 检查 `find_root` 是否返回合适的答案并报告结果，它使程序员免于逐个检查每个输出并验证其正确性的乏味且容易出错的任务。我们将在第
    8 章回到测试的主题。'
- en: '**Finger exercise:** Use the `find_root` function in [Figure 4-3](#c4-fig-0003)
    to print the sum of approximations to the square root of 25, the cube root of
    -8, and the fourth root of 16\. Use 0.001 as epsilon.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：** 使用 [图 4-3](#c4-fig-0003) 中的 `find_root` 函数打印 25 的平方根、-8 的立方根和 16
    的四次根的近似值之和。使用 0.001 作为 epsilon。'
- en: '**Finger exercise:** Write a function `is_in` that accepts two strings as arguments
    and returns True if either string occurs anywhere in the other, and False otherwise.
    Hint: you might want to use the built-in `str` operator `in`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：** 编写一个函数 `is_in`，接受两个字符串作为参数，如果其中一个字符串在另一个字符串中出现，则返回 True，否则返回 False。提示：你可能想使用内置的
    `str` 操作符 `in`。'
- en: '**Finger exercise:** Write a function to test `is_in.`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：** 编写一个函数来测试 `is_in`。'
- en: '![c4-fig-0004.jpg](../images/c4-fig-0004.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0004.jpg](../images/c4-fig-0004.jpg)'
- en: '[Figure 4-4](#c4-fig-0004a) Code to test `find_root`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-4](#c4-fig-0004) 测试 `find_root` 的代码'
- en: 4.1.2 Keyword Arguments and Default Values
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 关键字参数和默认值
- en: In Python, there are two ways that formal parameters get bound to actual parameters.
    The most common method, which is the one we have used so far, is called **positional**—the
    first formal parameter is bound to the first actual parameter, the second formal
    to the second actual, etc. Python also supports **keyword arguments**, in which
    formals are bound to actuals using the name of the formal parameter. Consider
    the function definition
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，正式参数绑定到实际参数有两种方式。最常见的方法是 **位置参数**——第一个正式参数绑定到第一个实际参数，第二个正式参数绑定到第二个实际参数，依此类推。Python
    还支持 **关键字参数**，其中正式参数通过其名称绑定到实际参数。考虑以下函数定义
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The function `print_name` assumes that `first_name` and `last_name` are strings
    and that `reverse` is a Boolean. If `reverse == True`, it prints `last_name,`
    `first_name`; otherwise it prints `first_name last_name`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `print_name` 假设 `first_name` 和 `last_name` 是字符串，`reverse` 是布尔值。如果 `reverse
    == True`，它打印 `last_name,` `first_name`；否则，它打印 `first_name last_name`。
- en: 'Each of the following is an equivalent invocation of `print_name`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下每个都是 `print_name` 的等效调用：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Though the keyword arguments can appear in any order in the list of actual parameters,
    it is not legal to follow a keyword argument with a non-keyword argument. Therefore,
    an error message would be produced by
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管关键字参数可以在实际参数列表中以任何顺序出现，但在关键字参数后跟非关键字参数是非法的。因此，会产生错误消息
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Keyword arguments are commonly used in conjunction with **default parameter
    values**. We can, for example, write
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数通常与 **默认参数值** 一起使用。例如，我们可以写
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Default values allow programmers to call a function with fewer than the specified
    number of arguments. For example,
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值允许程序员用少于指定数量的参数调用函数。例如，
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: will print
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将打印
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The last two invocations of `print_name` are semantically equivalent. The last
    one has the advantage of providing some documentation for the perhaps mysterious
    argument `True`. More generally, using keyword arguments reduces the risk of unintentionally
    binding an actual parameter to the wrong formal parameter. The line of code
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两次调用 `print_name` 在语义上是等价的。最后一次调用的优势在于为可能神秘的参数 `True` 提供了一些文档。更一般地说，使用关键字参数降低了将实际参数错误绑定到形式参数的风险。这行代码
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: leaves no ambiguity about the intent of the programmer who wrote it. This is
    useful because calling a function with the right arguments in the wrong order
    is a common blunder.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不会对编写它的程序员的意图产生歧义。这是有用的，因为以错误的顺序调用函数并传递正确的参数是一种常见错误。
- en: The value associated with a default parameter is computed at function definition
    time. This can lead to surprising program behavior, as we discuss in Section 5.3.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数关联的值是在函数定义时计算的。这可能导致程序行为出人意料，正如我们在第 5.3 节中讨论的那样。
- en: '**Finger exercise:** Write a function `mult` that accepts either one or two
    ints as arguments. If called with two arguments, the function prints the product
    of the two arguments. If called with one argument, it prints that argument.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**手指练习：** 编写一个函数 `mult`，接受一个或两个整数作为参数。如果调用时传入两个参数，函数将打印两个参数的乘积；如果调用时传入一个参数，则打印该参数。'
- en: 4.1.3 Variable Number of Arguments
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 可变数量的参数
- en: Python has a number of built-in functions that operate on a variable number
    of arguments. For example,
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有许多内置函数可以处理可变数量的参数。例如，
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: are both legal (and evaluate to what you think they do). Python makes it easy
    for programmers to define their own functions that accept a variable number of
    arguments. The **unpacking operator** `*` allows a function to accept a variable
    number of positional arguments. For example,
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都是合法的（并且评估的结果符合你的预期）。Python 使程序员可以轻松定义接受可变数量参数的函数。**拆包运算符** `*` 允许函数接受可变数量的位置参数。例如，
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: "prints \uFEFF`1.5 -1.0`. Note that the name following the `*` in the argument\
    \ list need not be `args`. It can be any name. For `mean`, it might have been\
    \ more descriptive to write \uFEFF`def mean(*numbers)`."
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 `1.5 -1.0`。请注意，参数列表中跟在 `*` 后面的名称不必是 `args`，可以是任何名称。对于 `mean`，更具描述性的写法可能是
    `def mean(*numbers)`。
- en: 4.1.4 Scoping
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4 作用域
- en: 'Let''s look at another small example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看另一个小例子：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When run, this code prints
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，这段代码打印
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What is going on here? At the call of `f`, the formal parameter `x` is locally
    bound to the value of the actual parameter `x` in the context of the function
    body of `f`. Though the actual and formal parameters have the same name, they
    are not the same variable. Each function defines a new **name space**, also called
    a **scope**. The formal parameter `x` and the **local variable** `y` that are
    used in `f` exist only within the scope of the definition of `f`. The assignment
    statement `x = x + y` within the function body binds the local name `x` to the
    object `4`. The assignments in `f` have no effect on the bindings of the names
    `x` and `y` that exist outside the scope of `f`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？在调用 `f` 时，形式参数 `x` 在 `f` 的函数体上下文中被局部绑定到实际参数 `x` 的值。尽管实际参数和形式参数同名，但它们不是同一个变量。每个函数定义了一个新的**名称空间**，也称为**作用域**。在
    `f` 中使用的形式参数 `x` 和**局部变量** `y` 仅在 `f` 的定义范围内存在。函数体内的赋值语句 `x = x + y` 将局部名称 `x`
    绑定到对象 `4`。在 `f` 中的赋值对 `f` 作用域外存在的名称 `x` 和 `y` 的绑定没有影响。
- en: 'Here''s one way to think about this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一种思考方式：
- en: 1\. At the top level, i.e., the level of the shell, a **symbol table** keeps
    track of all names defined at that level and their current bindings.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 在顶层，即 shell 的级别，**符号表** 跟踪在该级别定义的所有名称及其当前绑定。
- en: 2\. When a function is called, a new symbol table (often called a **stack frame**)
    is created. This table keeps track of all names defined within the function (including
    the formal parameters) and their current bindings. If a function is called from
    within the function body, yet another stack frame is created.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 当函数被调用时，会创建一个新的符号表（通常称为**栈帧**）。这个表跟踪在函数内定义的所有名称（包括形式参数）及其当前绑定。如果在函数体内再次调用该函数，则会创建另一个栈帧。
- en: 3\. When the function completes, its stack frame goes away.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 当函数完成时，其栈帧会消失。
- en: In Python, you can always determine the scope of a name by looking at the program
    text. This is called **static** or **lexical scoping**. [Figure 4-5](#c4-fig-0005)
    contains an example illustrating Python's scope rules. The history of the stack
    frames associated with the code is depicted in [Figure 4-6](#c4-fig-0006).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你可以通过查看程序文本来确定名称的作用域。这被称为**静态**或**词法作用域**。[图4-5](#c4-fig-0005)包含一个示例，说明了Python的作用域规则。与代码相关的栈帧历史在[图4-6](#c4-fig-0006)中描绘。
- en: '![c4-fig-0005.jpg](../images/c4-fig-0005.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0005.jpg](../images/c4-fig-0005.jpg)'
- en: '[Figure 4-5](#c4-fig-0005a) Nested scopes'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-5](#c4-fig-0005a) 嵌套作用域'
- en: The first column in [Figure 4-6](#c4-fig-0006) contains the set of names known
    outside the body of the function `f`, i.e., the variables `x` and `z`, and the
    function name `f`. The first assignment statement binds `x` to `3`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-6](#c4-fig-0006)中的第一列包含函数`f`体外已知的名称集合，即变量`x`和`z`以及函数名称`f`。第一个赋值语句将`x`绑定到`3`。'
- en: '![c4-fig-0006.jpg](../images/c4-fig-0006.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0006.jpg](../images/c4-fig-0006.jpg)'
- en: '[Figure 4-6](#c4-fig-0006a) Stack frames'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-6](#c4-fig-0006a) 栈帧'
- en: The assignment statement `z = f(x)` first evaluates the expression `f(x)` by
    invoking the function `f` with the value to which `x` is bound. When `f` is entered,
    a stack frame is created, as shown in column 2\. The names in the stack frame
    are `x` (the formal parameter `x`, not the `x` in the calling context), `g`, and
    `h`. The variables `g` and `h` are bound to objects of type `function`. The properties
    of these functions are given by the function definitions within `f`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值语句`z = f(x)`首先通过调用函数`f`并传入`x`绑定的值来计算表达式`f(x)`。当进入`f`时，创建了一个栈帧，如第2列所示。栈帧中的名称有`x`（形式参数`x`，而不是调用上下文中的`x`）、`g`和`h`。变量`g`和`h`绑定到类型为`function`的对象。这些函数的属性由`f`内部的函数定义给出。
- en: When `h` is invoked from within `f`, yet another stack frame is created, as
    shown in column 3\. This frame contains only the local variable `z`. Why does
    it not also contain `x`? A name is added to the scope associated with a function
    only if that name is a formal parameter of the function or a variable bound to
    an object within the body of the function. In the body of `h`, `x` occurs only
    on the right-hand side of an assignment statement. The appearance of a name (`x`
    in this case) that is not bound to an object anywhere in the function body (the
    body of `h` in this case) causes the interpreter to search the stack frame associated
    with the scope within which the function is defined (the stack frame associated
    with `f`). If the name is found (which it is in this case), the value to which
    it is bound (`4`) is used. If it is not found there, an error message is produced.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当从`f`内部调用`h`时，又创建了一个栈帧，如第3列所示。此帧仅包含局部变量`z`。为什么它不包含`x`呢？只有当名称是函数的形式参数或绑定到函数体内对象的变量时，才会将名称添加到与函数关联的作用域中。在`h`的主体内，`x`仅出现在赋值语句的右侧。一个名称（在这种情况下是`x`）出现在函数体（在这种情况下是`h`）中但未绑定到任何对象，导致解释器搜索与函数定义相关的作用域的栈帧（与`f`相关的栈帧）。如果找到了名称（在这种情况下找到了），则使用其绑定的值（`4`）。如果没有找到，则会产生错误信息。
- en: When `h` returns, the stack frame associated with the invocation of `h` goes
    away (it is **popped** off the top of the stack), as depicted in column 4\. Note
    that we never remove frames from the middle of the stack, but only the most recently
    added frame. Because of this “last in first out” (**LIFO**) behavior, we refer
    to it as a **stack**. (Imagine cooking a stack of pancakes. When the first one
    comes off the griddle, the chef places it on a serving plate. As each successive
    pancake comes off the griddle, it is stacked on top of the pancakes already on
    the serving plate. When it comes time to eat the pancakes, the first pancake served
    will be the one on top of the stack, the last one added—leaving the penultimate
    pancake added to the stack as the new top pancake, and the next one to be served.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当`h`返回时，与`h`调用相关的栈帧消失（它从栈顶**弹出**），如第4列所示。请注意，我们从不移除栈中间的帧，而只移除最新添加的帧。由于这种“后进先出”（**LIFO**）的行为，我们称其为**栈**。（想象一下煎一叠煎饼。当第一个煎饼从平底锅上取下时，厨师将其放在一个餐盘上。随着每个后续煎饼从平底锅上取下，它被叠放在已经在餐盘上的煎饼上。当要吃煎饼时，首先上桌的煎饼是叠在最上面的，即最后一个放入的煎饼——这使得倒数第二个放入的煎饼成为新的顶部煎饼，接下来要上桌的煎饼。）
- en: '![c4-fig-5001.jpg](../images/c4-fig-5001.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-5001.jpg](../images/c4-fig-5001.jpg)'
- en: Returning to our Python example, `g` is now invoked, and a stack frame containing
    `g`'s local variable `x` is added (column 5). When `g` returns, that frame is
    popped (column 6). When `f` returns, the stack frame containing the names associated
    with `f` is popped, getting us back to the original stack frame (column `7`).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的Python示例，`g`现在被调用，并添加一个包含`g`的局部变量`x`的栈帧（列5）。当`g`返回时，该帧被弹出（列6）。当`f`返回时，包含与`f`相关名称的栈帧被弹出，使我们回到原始栈帧（列`7`）。
- en: Notice that when `f` returns, even though the variable `g` no longer exists,
    the object of type `function` to which that name was once bound still exists.
    This is because functions are objects, and can be returned just like any other
    kind of object. So, `z` can be bound to the value returned by `f`, and the function
    call `z()` can be used to invoke the function that was bound to the name `g` within
    `f`—even though the name `g` is not known outside the context of `f`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当`f`返回时，尽管变量`g`不再存在，曾经与该名称绑定的`function`类型的对象仍然存在。这是因为函数是对象，可以像其他任何类型的对象一样被返回。因此，`z`可以绑定到`f`返回的值，函数调用`z()`可以用来调用在`f`中与名称`g`绑定的函数——即使名称`g`在`f`的外部上下文中是未知的。
- en: So, what does the code in [Figure 4-5](#c4-fig-0005) print? It prints
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，[图4-5](#c4-fig-0005)中的代码打印了什么？它打印了
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The order in which references to a name occur is not germane. If an object is
    bound to a name anywhere in the function body (even if it occurs in an expression
    before it appears as the left-hand side of an assignment), it is treated as local
    to that function.[^(30)](#c4-fn-0006) Consider the code
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对名称的引用顺序并不重要。如果在函数体内的任何地方将一个对象绑定到一个名称（即使它出现在赋值的左侧之前的表达式中），它被视为该函数的局部。[^(30)](#c4-fn-0006)
    请考虑以下代码
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It prints `3` when `f` is invoked, but the error message
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`f`时，它打印`3`，但错误信息
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: is printed when the print statement in `g` is encountered. This happens because
    the assignment statement following the `print` statement causes `x` to be local
    to `g`. And because `x` is local to `g`, it has no value when the `print` statement
    is executed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到`g`中的打印语句时会打印出来。这是因为`print`语句后面的赋值语句使得`x`变成了`g`的局部变量。而且因为`x`是`g`的局部变量，所以在执行`print`语句时没有值。
- en: Confused yet? It takes most people a bit of time to get their head around scope
    rules. Don't let this bother you. For now, charge ahead and start using functions.
    Most of the time, you will only want to use variables that are local to a function,
    and the subtleties of scoping will be irrelevant. In fact, if your program depends
    upon some subtle scoping rule, you might consider rewriting to avoid doing so.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还感到困惑吗？大多数人需要一点时间来理解作用域规则。不要让这困扰你。现在，继续前进，开始使用函数。大多数时候，你只想使用局部于函数的变量，而作用域的细微差别将无关紧要。事实上，如果你的程序依赖于一些微妙的作用域规则，你可能会考虑重写以避免这样做。
- en: 4.2 Specifications
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 规范
- en: 'A **specification** of a function defines a contract between the implementer
    of a function and those who will be writing programs that use the function. We
    refer to the users of a function as its **clients**. This contract can be thought
    of as containing two parts:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**规范**定义了函数的实现者与将编写使用该函数的程序的人之间的契约。我们将函数的用户称为其**客户**。这个契约可以被视为包含两个部分：
- en: '**Assumptions**: These describe conditions that must be met by clients of the
    function. Typically, they describe constraints on the actual parameters. Almost
    always, they specify the acceptable set of types for each parameter, and not infrequently
    some constraints on the value of one or more parameters. For example, the specification
    of `find_root` might require that `power` be a positive integer.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**假设**：这些描述了函数的客户必须满足的条件。通常，它们描述了对实际参数的约束。几乎总是，它们指定了每个参数的可接受类型集，并且不时对一个或多个参数的值施加一些约束。例如，`find_root`的规范可能要求`power`为正整数。'
- en: '**Guarantees**: These describe conditions that must be met by the function,
    provided it has been called in a way that satisfies the assumptions. For example,
    the specification of `find_root` might guarantee that it returns `None` if asked
    to find a root that doesn''t exist (e.g., the square root of a negative number).'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保证**：这些描述了在满足假设的情况下，函数必须满足的条件。例如，`find_root`的规范可能保证，如果被要求找到不存在的根（例如，负数的平方根），它将返回`None`。'
- en: Functions are a way of creating computational elements that we can think of
    as primitives. They provide decomposition and abstraction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一种创建计算元素的方法，我们可以将其视为原始元素。它们提供了分解和抽象。
- en: '**Decomposition** creates structure. It allows us to break a program into parts
    that are reasonably self-contained and that may be reused in different settings.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**分解**创造结构。它允许我们将程序分解为合理自-contained的部分，并可以在不同环境中重复使用。'
- en: '**Abstraction** hides detail. It allows us to use a piece of code as if it
    were a black box—that is, something whose interior details we cannot see, don''t
    need to see, and shouldn''t even want to see.[^(31)](#c4-fn-0007) The essence
    of abstraction is preserving information that is relevant in a given context,
    and forgetting information that is irrelevant in that context. The key to using
    abstraction effectively in programming is finding a notion of relevance that is
    appropriate for both the builder of an abstraction and the potential clients of
    the abstraction. That is the true art of programming.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象**隐藏了细节。它允许我们像使用一个黑箱一样使用一段代码——即，我们看不到、也不需要看、甚至不应该想要看其内部细节。[^(31)](#c4-fn-0007)
    抽象的本质是在特定上下文中保留相关信息，并遗忘该上下文中不相关的信息。在编程中有效使用抽象的关键是找到一个适合抽象构建者和潜在抽象客户端的相关性概念。这就是编程的真正艺术。'
- en: Abstraction is all about forgetting. There are lots of ways to model this, for
    example, the auditory apparatus of most teenagers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象就是关于遗忘的。有很多方法可以对其建模，例如，大多数青少年的听觉系统。
- en: 'Teenager says: *May I borrow the car tonight?*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 青少年说：*我今晚可以借车吗？*
- en: 'Parent says: *Yes, but be back before midnight, and make sure that the gas
    tank is full.*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 父母说：*是的，但要在午夜之前回来，并确保油箱是满的。*
- en: 'Teenager hears: *Yes.*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 青少年听到：*是的*。
- en: The teenager has ignored all of those pesky details that he or she considers
    irrelevant. Abstraction is a many-to-one process. Had the parent said “Yes, but
    be back before 2:00 a.m., and make sure that the car is clean,” it would also
    have been abstracted to Yes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 青少年忽略了所有他或她认为无关紧要的琐碎细节。抽象是一个多对一的过程。如果父母说“是的，但要在凌晨2点之前回来，并确保车子干净”，这也会被抽象为“是的”。
- en: By way of analogy, imagine that you were asked to produce an introductory computer
    science course containing 25 lectures. One way to do this would be to recruit
    25 professors and ask each of them to prepare a one-hour lecture on their favorite
    topic. Though you might get 25 wonderful hours, the whole thing is likely to feel
    like a dramatization of Pirandello's *Six Characters in Search of an Author* (or
    that political science course you took with 15 guest lecturers). If each professor
    worked in isolation, they would have no idea how to relate the material in their
    lecture to the material covered in other lectures.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类比，想象一下你被要求制作一个包含25节课的计算机科学入门课程。一种方法是招募25位教授，让每位教授准备一个小时的讲座，讲述他们最喜欢的话题。尽管你可能会得到25个精彩的小时，但整个课程可能会让人感觉像是皮兰德罗的*寻找作者的六个角色*（或你参加的那门有15位客座讲师的政治科学课程）。如果每位教授独立工作，他们就无法将自己讲座中的材料与其他讲座中的材料联系起来。
- en: Somehow, you need to let everyone know what everyone else is doing, without
    generating so much work that nobody is willing to participate. This is where abstraction
    comes in. You could write 25 specifications, each saying what material the students
    should learn in each lecture, but not giving any detail about how that material
    should be taught. What you got might not be pedagogically wonderful, but at least
    it might make sense.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不知怎么的，你需要让每个人知道其他人正在做什么，而不产生太多的工作让没人愿意参与。这就是抽象的作用。你可以写25个规格，每个规格说明学生在每节课上应该学习什么材料，但不提供关于如何教授这些材料的任何细节。你得到的可能在教育上并不完美，但至少可能是有意义的。
- en: This is the way organizations use teams of programmers to get things done. Given
    a specification of a module, a programmer can work on implementing that module
    without worrying about what the other programmers on the team are doing. Moreover,
    the other programmers can use the specification to start writing code that uses
    the module without worrying about how the module will be implemented.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是组织使用程序员团队完成任务的方式。给定一个模块的规格，程序员可以在实现该模块时无需担心团队中其他程序员在做什么。此外，其他程序员可以利用该规格开始编写使用该模块的代码，而不必担心模块将如何实现。
- en: '[Figure 4-7](#c4-fig-0008) adds a specification to the implementation of `find_root`
    in [Figure 4-3](#c4-fig-0003).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-7](#c4-fig-0008) 为 [图 4-3](#c4-fig-0003) 中的 `find_root` 实现添加了一个规范。'
- en: '![c4-fig-0007.jpg](../images/c4-fig-0007.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0007.jpg](../images/c4-fig-0007.jpg)'
- en: '[Figure 4-7](#c4-fig-0008a) A function definition with a specification'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-7](#c4-fig-0008a) 带有规范的函数定义。'
- en: The text between the triple quotation marks is called a **docstring** in Python.
    By convention, Python programmers use docstrings to provide specifications of
    functions. These docstrings can be accessed using the built-in function `**help**`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 三重引号之间的文本在 Python 中称为 **docstring**。按照惯例，Python 程序员使用 docstring 提供函数的规范。这些 docstring
    可以使用内置函数 `**help**` 进行访问。
- en: One of the nice things about Python IDEs is that they provide an interactive
    tool for asking about the built-in objects. If you want to know what a specific
    function does, you need only type `help(*object*)` into the console window. For
    example, `help(abs)` produces the text
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Python IDEs 的一个优点是它们提供了一个交互式工具，用于查询内置对象。如果你想知道某个特定函数的功能，只需在控制台窗口中输入 `help(*object*)`。例如，输入
    `help(abs)` 会产生以下文本。
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This tells us that `abs` is a function that maps a single argument to its absolute
    value. (The `/` in the argument list means that the argument must be positional.)
    If you enter `help()`, an interactive help session is started, and the interpreter
    will present the prompt `help>` in the console window. An advantage of the interactive
    mode is that you can get help on Python constructs that are not objects. E.g.,
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们 `abs` 是一个将单个参数映射到其绝对值的函数。（参数列表中的 `/` 意味着该参数必须是位置参数。）如果你输入 `help()`，会启动一个交互式帮助会话，解释器会在控制台窗口中显示提示符
    `help>`。交互模式的一个优点是，你可以获得有关不是对象的 Python 构造的帮助。例如，
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Interactive help can be exited by entering `quit`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过输入 `quit` 退出交互帮助。
- en: If the code in [Figure 4-4](#c4-fig-0004) had been loaded into an IDE, typing
    `help(find_root)` in the shell would display
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 [图 4-4](#c4-fig-0004) 中的代码已加载到 IDE 中，在 shell 中输入 `help(find_root)` 将显示
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The specification of `find_root` is an abstraction of all the possible implementations
    that meet the specification. Clients of `find_root` can assume that the implementation
    meets the specification, but they should assume nothing more. For example, clients
    can assume that the call `find_root(4, 2, 0.01)` returns some value whose square
    is between `3.99` and `4.01`. The value returned could be positive or negative,
    and even though `4` is a perfect square, the value returned might not be `2` or
    `-2`. Crucially, if the assumptions of the specification are not satisfied, nothing
    can be assumed about the effect of calling the function. For example, the call
    `find_root(8, 3, 0)` could return `2`. But it could also crash, run forever, or
    return some number nowhere near the cube root of 8.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_root` 的规范是所有可能满足该规范的实现的抽象。`find_root` 的客户端可以假设实现符合规范，但不应假设其他内容。例如，客户端可以假设调用
    `find_root(4, 2, 0.01)` 返回的某个值的平方在 `3.99` 和 `4.01` 之间。返回的值可以是正数或负数，即使 `4` 是一个完全平方，返回的值也可能不是
    `2` 或 `-2`。关键是，如果未满足规范的假设，则无法对调用函数的效果做出任何假设。例如，调用 `find_root(8, 3, 0)` 可能返回 `2`，但也可能崩溃、无限运行，或者返回与
    8 的立方根相去甚远的某个数字。'
- en: '**Finger exercise:** Using the algorithm of Figure 3-6, write a function that
    satisfies the specification'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**指尖练习：** 使用图 3-6 的算法，编写一个满足规范的函数。'
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 4.3 Using Functions to Modularize Code
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 使用函数模块化代码。
- en: So far, all of the functions we have implemented have been small. They fit nicely
    on a single page. As we implement more complicated functionality, it is convenient
    to split functions into multiple functions, each of which does one simple thing.
    To illustrate this idea we, somewhat superfluously, split `find_root` into three
    separate functions, as shown in [Figure 4-8](#c4-fig-0009). Each of the functions
    has its own specification and each makes sense as a stand-alone entity. The function
    `find_root_bounds` finds an interval in which the root must lie, `bisection_solve`
    uses bisection search to search this interval for an approximation to the root,
    and `find_root` simply calls the other two and returns the root.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实现的所有函数都很小，适合单页展示。随着我们实现更复杂的功能，将函数拆分为多个执行单一简单任务的函数是很方便的。为了说明这个想法，我们稍微多余地将
    `find_root` 拆分为三个独立的函数，如 [图 4-8](#c4-fig-0009) 所示。每个函数都有自己的规范，并且每个函数作为独立实体是有意义的。函数
    `find_root_bounds` 查找根必须位于的区间，`bisection_solve` 使用二分搜索在此区间中寻找根的近似值，而 `find_root`
    则简单地调用其他两个函数并返回根。
- en: Is this version of `find_root` easier to understand than the original monolithic
    implementation? Probably not. A good rule of thumb is that if a function fits
    comfortably on a single page, it probably doesn't need to be subdivided to be
    easily understood.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的 `find_root` 比原始单体实现更容易理解吗？可能不是。一个好的经验法则是，如果一个函数可以舒适地放在单页上，它可能不需要被细分以便于理解。
- en: '![c4-fig-0008.jpg](../images/c4-fig-0008.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0008.jpg](../images/c4-fig-0008.jpg)'
- en: '[Figure 4-8](#c4-fig-0009a) Splitting find_root into multiple functions'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-8](#c4-fig-0009a) 将 find_root 拆分为多个函数'
- en: 4.4 Functions as Objects
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 函数作为对象
- en: In Python, functions are **first-class objects**. That means they can be treated
    like objects of any other type, e.g., `int` or `list`. They have types, e.g.,
    the expression `type(abs)` has the value `<type 'built-in_function_or_method'>`;
    they can appear in expressions, e.g., as the right-hand side of an assignment
    statement or as an argument to a function; they can be returned by functions;
    etc.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，函数是 **一等对象**。这意味着它们可以像其他类型的对象一样被处理，例如 `int` 或 `list`。它们有类型，例如，表达式
    `type(abs)` 的值为 `<type 'built-in_function_or_method'>`；它们可以出现在表达式中，例如，作为赋值语句的右侧或作为函数的参数；它们可以由函数返回；等等。
- en: Using functions as arguments allows a style of coding called **higher-order
    programming**. It allows us to write functions that are more generally useful.
    For example, the function `bisection_solve` in [Figure 4-8](#c4-fig-0009) can
    be rewritten so that it can be applied to tasks other than root finding, as shown
    in [Figure 4-9](#c4-fig-0010).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数作为参数允许一种称为 **高阶编程** 的编码风格。它使我们能够编写更具通用性的函数。例如，[图 4-8](#c4-fig-0009) 中的 `bisection_solve`
    函数可以重写，以便应用于根以外的任务，如 [图 4-9](#c4-fig-0010) 所示。
- en: '![c4-fig-0009.jpg](../images/c4-fig-0009.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0009.jpg](../images/c4-fig-0009.jpg)'
- en: '[Figure 4-9](#c4-fig-0010a) Generalizing `bisection_solve`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-9](#c4-fig-0010a) 概括 `bisection_solve`'
- en: We start by replacing the integer parameter `power` by a function, `eval_ans`,
    that maps floats to floats. We then replace every instance of the expression `ans**power`
    by the function call `eval_ans(ans)`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始将整数参数 `power` 替换为一个函数 `eval_ans`，该函数将浮点数映射到浮点数。然后，我们将表达式 `ans**power` 的每个实例替换为函数调用
    `eval_ans(ans)`。
- en: If we wanted to use the new `bisection_solve` to print an approximation to the
    square root of 99, we could run the code
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用新的 `bisection_solve` 打印出99的平方根近似值，我们可以运行代码
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Going to the trouble of defining a function to do something as simple as squaring
    a number seems a bit silly. Fortuitously, Python supports the creation of anonymous
    functions (i.e., functions that are not bound to a name), using the reserved word
    `lambda`. The general form of a **lambda expression** is
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单地定义一个函数来计算平方，似乎有些多余。幸运的是，Python 支持使用保留字 `lambda` 创建匿名函数（即不绑定名称的函数）。**lambda
    表达式**的一般形式是
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For example, the lambda expression `lambda x, y: x*y` returns a function that
    returns the product of its two arguments. Lambda expressions are frequently used
    as arguments to higher-order functions. For example, we could replace the above
    call to `bisection_solve` with'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，lambda 表达式 `lambda x, y: x*y` 返回一个返回其两个参数乘积的函数。lambda 表达式常作为高阶函数的参数使用。比如，我们可以用'
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Finger exercise:** Write a lambda expression that has two numeric parameters.
    If the second argument equals zero, it should return `None`. Otherwise it should
    return the value of dividing the first argument by the second argument. Hint:
    use a conditional expression.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习：** 编写一个具有两个数值参数的 lambda 表达式。如果第二个参数为零，它应该返回 `None`。否则，它应该返回第一个参数除以第二个参数的值。提示：使用条件表达式。'
- en: Since functions are first-class objects, they can be created and returned within
    functions. For example, given the function definition
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数是一等对象，它们可以在函数内创建和返回。例如，给定函数定义
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: the code
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: will print an approximation to the n^(th) root of 99, where n is a number entered
    by a user.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将打印99的 n^(th) 根的近似值，其中 n 是用户输入的数字。
- en: The way we have generalized `bisection_solve` means that it can now be used
    not only to search for approximations to roots, but to search for approximations
    to any monotonic[^(32)](#c4-fn-0008) function that maps floats to floats. For
    example, the code in [Figure 4-10](#c4-fig-0011) uses `bisection_solve` to find
    approximations to logarithms.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`bisection_solve`的概括意味着它现在不仅可以用来搜索根的逼近值，还可以搜索任何将浮点数映射到浮点数的单调[^(32)](#c4-fn-0008)函数的逼近值。例如，[图
    4-10](#c4-fig-0011)中的代码使用`bisection_solve`找到对数的逼近值。
- en: '![c4-fig-0010.jpg](../images/c4-fig-0010.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![c4-fig-0010.jpg](../images/c4-fig-0010.jpg)'
- en: '[Figure 4-10](#c4-fig-0011a) Using `bisection_solve` to approximate logs'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-10](#c4-fig-0011a) 使用`bisection_solve`来逼近对数'
- en: Notice that the implementation of `log` includes the definition of a local function,
    `find_log_bounds`. This function could have been defined outside of `log`, but
    since we don't expect to use it in any other context, it seemed better not to.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`log`的实现包含了一个局部函数`find_log_bounds`的定义。这个函数本可以在`log`之外定义，但由于我们不期望在其他上下文中使用它，因此不这样做似乎更好。
- en: 4.5 Methods, Oversimplified
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 方法，简单化
- en: Methods are function-like objects. They can be called with parameters, they
    can return values, and they can have side effects. They do differ from functions
    in some important ways, which we will discuss in Chapter 10.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是类似函数的对象。它们可以带参数调用，可以返回值，并且可以具有副作用。它们在一些重要方面与函数有所不同，我们将在第10章中讨论。
- en: "For now, think of methods as providing a peculiar syntax for a function call.\
    \ Instead of putting the first argument inside parentheses following the function\
    \ name, we use **dot notation** to place that argument before the function name.\
    \ We introduce methods here because many useful operations on built-in types are\
    \ methods, and therefore invoked using dot notation. For example, if `s` is a\
    \ string, the `find` method can be used to find the index of the first occurrence\
    \ of a substring in `s`. So, if `s` were \uFEFF`'abcbc'`, the invocation `\uFEFF\
    s.find('bc')` would return `1`. Attempting to treat `find` as a function, e.g.,\
    \ invoking `find(s,'bc')`, produces the error message `\uFEFFNameError: name 'find'\
    \ is not defined`."
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '目前，可以将方法视为为函数调用提供一种特殊语法。我们使用**点表示法**将第一个参数放在函数名称之前，而不是将其放在括号内。我们在这里引入方法，因为许多内置类型上的有用操作都是方法，因此通过点表示法调用。例如，如果`s`是一个字符串，可以使用`find`方法找到子字符串在`s`中第一次出现的索引。因此，如果`s`是`''abcbc''`，调用`s.find(''bc'')`将返回`1`。尝试将`find`视为函数，例如调用`find(s,''bc'')`，会产生错误信息`NameError:
    name ''find'' is not defined`。'
- en: '**Finger exercise:** What does `s.find(sub)` return if `sub` does not occur
    in `s`?'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**指尖练习：** 如果`sub`在`s`中不存在，`s.find(sub)`会返回什么？'
- en: '**Finger exercise:** Use `find` to implement a function satisfying the specification'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**指尖练习：** 使用`find`实现一个满足规范的函数'
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 4.6 Terms Introduced in Chapter
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 在章节中引入的术语
- en: function definition
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数定义
- en: formal parameter
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形式参数
- en: actual parameter
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际参数
- en: argument
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数
- en: function invocation (function call)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用
- en: return statement
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回语句
- en: point of execution
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行点
- en: lambda abstraction
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda 抽象
- en: test function
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试函数
- en: debugging
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: positional argument
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置参数
- en: keyword argument
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字参数
- en: default parameter value
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认参数值
- en: unpacking operator (*)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解包运算符 (*)
- en: name space
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称空间
- en: scope
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围
- en: local variable
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量
- en: symbol table
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号表
- en: stack frame
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈帧
- en: static (lexical) scoping
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态（词法）作用域
- en: stack (LIFO)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈（后进先出）
- en: specification
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范
- en: client
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端
- en: assumption
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设
- en: guarantee
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保证
- en: decomposition
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解
- en: abstraction
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象
- en: docstring
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档字符串
- en: help function
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助函数
- en: first-class object
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一等对象
- en: higher-order programming
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶编程
- en: lambda expression
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda 表达式
- en: method
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: dot notation
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点表示法
