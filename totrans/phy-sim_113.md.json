["```py\n# compute normal and the parameterization of the closest point on the edge\ndef tangent(p, e0, e1):\n    e = e1 - e0\n    ratio = np.dot(e, p - e0) / np.dot(e, e)\n    if ratio < 0:    # point(p)-point(e0) expression\n        n = p - e0\n    elif ratio > 1:  # point(p)-point(e1) expression\n        n = p - e1\n    else:            # point(p)-line(e0e1) expression\n        n = p - ((1 - ratio) * e0 + ratio * e1)\n    return [n / np.linalg.norm(n), ratio] \n```", "```py\n # self-contact\n    mu_lambda_self = []\n    dhat_sqr = dhat * dhat\n    for xI in bp:\n        for eI in be:\n            if xI != eI[0] and xI != eI[1]: # do not consider a point and its incident edge\n                d_sqr = PE.val(x[xI], x[eI[0]], x[eI[1]])\n                if d_sqr < dhat_sqr:\n                    s = d_sqr / dhat_sqr\n                    # since d_sqr is used, need to divide by 8 not 2 here for consistency to linear elasticity\n                    # also, lambda = -\\partial b / \\partial d = -(\\partial b / \\partial d^2) * (\\partial d^2 / \\partial d)\n                    mu_lam = mu * -0.5 * contact_area[xI] * dhat * (kappa / 8 * (math.log(s) / dhat_sqr + (s - 1) / d_sqr)) * 2 * math.sqrt(d_sqr)\n                    [n, r] = PE.tangent(x[xI], x[eI[0]], x[eI[1]]) # normal and closest point parameterization on the edge\n                    mu_lambda_self.append([xI, eI[0], eI[1], mu_lam, n, r]) \n```"]