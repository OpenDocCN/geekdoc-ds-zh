<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>16.1Â Sharing and EqualityğŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>16.1Â Sharing and EqualityğŸ”—</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/Sharing_and_Equality.html">https://dcic-world.org/2025-08-27/Sharing_and_Equality.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>Â Â Â Â <a href="#%28part._identical-eq%29" class="toclink" data-pltdoc="x">16.1.1Â Re-Examining Equality</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.The_.Cost_of_.Evaluating_.References%29" class="toclink" data-pltdoc="x">16.1.2Â The Cost of Evaluating References</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._equal-always%29" class="toclink" data-pltdoc="x">16.1.3Â Notations for Equality</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.On_the_.Internet__.Nobody_.Knows_.You_re_a_.D.A.G%29" class="toclink" data-pltdoc="x">16.1.4Â On the Internet, Nobody Knows Youâ€™re a DAG</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._.It_s_.Always_.Been_a_.D.A.G%29" class="toclink" data-pltdoc="x">16.1.5Â Itâ€™s Always Been a DAG</a></p></td></tr><tr><td><p>Â Â Â Â <a href="#%28part._acyc-to-cyc%29" class="toclink" data-pltdoc="x">16.1.6Â From Acyclicity to Cycles</a></p></td></tr></table><section class="SsectionLevel4" id="section 16.1.1"><h4 class="heading">16.1.1Â <a name="(part._identical-eq)"/>Re-Examining Equality<a href="#(part._identical-eq)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Consider the following data definition and example values:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data BT:
  | leaf
  | node(v, l :: BT, r :: BT)
end

a-tree =
  node(5,
    node(4, leaf, leaf),
    node(4, leaf, leaf))

b-tree =
  block:
    four-node = node(4, leaf, leaf)
    node(5,
      four-node,
      four-node)
  end</code></pre><p>In particular, it might seem that the way weâ€™ve written <code data-lang="pyret" class="sourceCode">b-tree</code>
is morally equivalent to how weâ€™ve written <code data-lang="pyret" class="sourceCode">a-tree</code>, but weâ€™ve
created a helpful binding to avoid code duplication.</p><p>Because both <code data-lang="pyret" class="sourceCode">a-tree</code> and <code data-lang="pyret" class="sourceCode">b-tree</code> are bound to trees with
<code data-lang="pyret" class="sourceCode">5</code> at the root and a left and right child each containing
<code data-lang="pyret" class="sourceCode">4</code>, we can indeed reasonably consider these trees
equivalent. Sure enough:
</p><a name="(elem._equal-tests)"/>&lt;equal-tests&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  a-tree   is b-tree
  a-tree.l is a-tree.l
  a-tree.l is a-tree.r
  b-tree.l is b-tree.r
end</code></pre><p>However, there is another sense in which these trees are not
equivalent. concretely, <code data-lang="pyret" class="sourceCode">a-tree</code> constructs a distinct node for
each child, while <code data-lang="pyret" class="sourceCode">b-tree</code> uses the same node for both
children.  Surely this difference should show up somehow, but we
have not yet seen a way to write a program that will tell these
apart.</p><p>By default, the <code data-lang="pyret" class="sourceCode">is</code> operator uses the same equality test as
Pyretâ€™s <code data-lang="pyret" class="sourceCode">==</code>. There are, however, other equality tests in
Pyret. In particular, the way we can tell apart these data is by using
Pyretâ€™s <code data-lang="pyret" class="sourceCode">identical</code> function, which implements
reference equality.  This checks not only whether two
values are structurally equivalent but whether they are
the result of the very same act of value construction.
With this, we can now write additional tests:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  identical(a-tree, b-tree)     is false
  identical(a-tree.l, a-tree.l) is true
  identical(a-tree.l, a-tree.r) is false
  identical(b-tree.l, b-tree.r) is true
end</code></pre><p>Letâ€™s step back for a moment and consider the behavior that gives us this
result.  We can visualize the different values by putting each distinct value
in a separate location alongside the running program.  We can draw the
first step as creating a <code data-lang="pyret" class="sourceCode">node</code> with value <code data-lang="pyret" class="sourceCode">4</code>:</p><pre class="HeapCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a-tree =
  node(5,
    1001,
    node(4, leaf, leaf))

b-tree =
  block:
    four-node = node(4, leaf, leaf)
    node(5,
      four-node,
      four-node)
  end</code></pre></pre><p>Heap</p><ul><li><p>1001:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li></ul><p>The next step creates another node with value <code data-lang="pyret" class="sourceCode">4</code>, distinct from the
first:</p><pre class="HeapCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a-tree =
  node(5, 1001, 1002)

b-tree =
  block:
    four-node = node(4, leaf, leaf)
    node(5,
      four-node,
      four-node)
  end</code></pre></pre><p>Heap</p><ul><li><p>1001:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1002:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li></ul><p>Then the <code data-lang="pyret" class="sourceCode">node</code> for <code data-lang="pyret" class="sourceCode">a-tree</code> is created:</p><pre class="HeapCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a-tree = 1003

b-tree =
  block:
    four-node = node(4, leaf, leaf)
    node(5,
      four-node,
      four-node)
  end</code></pre></pre><p>Heap</p><ul><li><p>1001:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1002:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1003:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1001, 1002)</code></pre></li></ul><p>When evaluating the <code data-lang="pyret" class="sourceCode">block</code> for <code data-lang="pyret" class="sourceCode">b-tree</code>, first a single node is
created for the <code data-lang="pyret" class="sourceCode">four-node</code> binding:</p><pre class="HeapCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a-tree = 1003

b-tree =
  block:
    four-node = 1004
    node(5,
      four-node,
      four-node)
  end</code></pre></pre><p>Heap</p><ul><li><p>1001:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1002:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1003:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1001, 1002)</code></pre></li><li><p>1004:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li></ul><p>These location values can be substituted just like any other, so they get
substituted for <code data-lang="pyret" class="sourceCode">four-node</code> to continue evaluation of the
block.We skipped substituting <code data-lang="pyret" class="sourceCode">a-tree</code> for the moment, that
will come up later.</p><pre class="HeapCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a-tree = 1003

b-tree =
  block:
    node(5, 1004, 1004)
  end</code></pre></pre><p>Heap</p><ul><li><p>1001:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1002:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1003:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1001, 1002)</code></pre></li><li><p>1004:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li></ul><p>Finally, the node for <code data-lang="pyret" class="sourceCode">b-tree</code> is created:</p><pre class="HeapCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a-tree = 1003

b-tree = 1005</code></pre></pre><p>Heap</p><ul><li><p>1001:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1002:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1003:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1001, 1002)</code></pre></li><li><p>1004:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1005:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1004, 1004)</code></pre></li></ul><p>This visualization can help us explain the test we wrote using <code data-lang="pyret" class="sourceCode">identical</code>.
Letâ€™s consider the test with the appropriate location references substituted
for <code data-lang="pyret" class="sourceCode">a-tree</code> and <code data-lang="pyret" class="sourceCode">b-tree</code>:</p><pre class="HeapCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  identical(1003, 1005)
    is false
  identical(1003.l, 1003.l)
    is true
  identical(1003.l, 1003.r)
    is false
  identical(1005.l, 1005.r)
    is true
end</code></pre></pre><p>Heap</p><ul><li><p>1001:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1002:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1003:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1001, 1002)</code></pre></li><li><p>1004:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1005:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1004, 1004)</code></pre></li></ul><pre class="HeapCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  identical(1003, 1005)
    is false
  identical(1001, 1001)
    is true
  identical(1001, 1004)
    is false
  identical(1004, 1004)
    is true
end</code></pre></pre><p>Heap</p><ul><li><p>1001:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1002:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1003:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1001, 1002)</code></pre></li><li><p>1004:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1005:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1004, 1004)</code></pre></li></ul><p>There is actually another way to write these tests in Pyret: the
<code data-lang="pyret" class="sourceCode">is</code> operator can also be parameterized by a different equality
predicate than the default <code data-lang="pyret" class="sourceCode">==</code>. Thus, the above block can
equivalently be written as:We can use <code data-lang="pyret" class="sourceCode">is-not</code>
to check for expected failure of equality.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  a-tree   is-not%(identical) b-tree
  a-tree.l is%(identical)     a-tree.l
  a-tree.l is-not%(identical) a-tree.r
  b-tree.l is%(identical)     b-tree.r
end</code></pre><p>We will use this style of equality testing from now on.</p><p>Observe how these are the same values that were compared earlier
(<a href="#%28elem._equal-tests%29" data-pltdoc="x">&lt;equal-tests&gt;</a>), but the results are now different: some
values that were true earlier are now false. In particular,
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  a-tree   is                 b-tree
  a-tree   is-not%(identical) b-tree
  a-tree.l is                 a-tree.r
  a-tree.l is-not%(identical) a-tree.r
end</code></pre><p>Later we will return both to
what <code data-lang="pyret" class="sourceCode">identical</code> really means
[<a href="unified-equality.html" data-pltdoc="x">Understanding Equality</a>]
(Pyret has a full range of equality operations suitable for different situations).</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>There are many more equality tests we can and should perform
even with the basic data above to make sure we really understand
equality and, relatedly, storage of data in memory. What other
tests should we conduct? Predict what results they should produce
before running them!</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 16.1.2"><h4 class="heading">16.1.2Â <a name="(part._.The_.Cost_of_.Evaluating_.References)"/>The Cost of Evaluating References<a href="#(part._.The_.Cost_of_.Evaluating_.References)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>From a complexity viewpoint, itâ€™s important for us to understand how
these references work. As we have hinted, <code data-lang="pyret" class="sourceCode">four-node</code> is computed
only once, and each use of it refers to the same value: if, instead,
it was evaluated each time we referred to <code data-lang="pyret" class="sourceCode">four-node</code>, there
would be no real difference between <code data-lang="pyret" class="sourceCode">a-tree</code> and <code data-lang="pyret" class="sourceCode">b-tree</code>,
and the above tests would not distinguish between them.</p><p>This is especially relevant when understanding the cost of function
evaluation. Weâ€™ll construct two simple examples that illustrate
this. Weâ€™ll begin with a contrived data structure:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L = range(0, 100)</code></pre><p>Suppose we now define
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L1 = link(1, L)
L2 = link(-1, L)</code></pre><p>Constructing a list clearly takes time at least proportional to the
length; therefore, we expect the time to compute <code data-lang="pyret" class="sourceCode">L</code> to be
considerably more than that for a single <code data-lang="pyret" class="sourceCode">link</code>
operation. Therefore, the question is how long it takes to compute
<code data-lang="pyret" class="sourceCode">L1</code> and <code data-lang="pyret" class="sourceCode">L2</code> after <code data-lang="pyret" class="sourceCode">L</code> has been computed: constant
time, or time proportional to the length of <code data-lang="pyret" class="sourceCode">L</code>?</p><p>The answer, for Pyret, and for most other contemporary languages
(including Java, C#, OCaml, Racket, etc.), is that these additional
computations take constant time. That is, the value bound to
<code data-lang="pyret" class="sourceCode">L</code> is computed once and bound to <code data-lang="pyret" class="sourceCode">L</code>; subsequent
expressions refer to this value (hence â€œreferenceâ€)
rather than reconstructing it, as reference equality shows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  L1.rest is%(identical) L
  L2.rest is%(identical) L
  L1.rest is%(identical) L2.rest
end</code></pre><p>Similarly, we can define a function, pass <code data-lang="pyret" class="sourceCode">L</code> to it, and see
whether the resulting argument is <code data-lang="pyret" class="sourceCode">identical</code> to the original:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun check-for-no-copy(another-l):
  identical(another-l, L)
end

check:
  check-for-no-copy(L) is true
end</code></pre><p>or, equivalently,
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  L satisfies check-for-no-copy
end</code></pre><p>Therefore, neither built-in operations (like <code data-lang="pyret" class="sourceCode">.rest</code>) nor
user-defined ones (like <code data-lang="pyret" class="sourceCode">check-for-no-copy</code>) make copies of their
arguments.Strictly speaking, of course, we cannot
conclude that no copy was made. Pyret could have made a copy,
discarded it, and still passed a reference to the original. Given how
perverse this would be, we can assumeâ€”<wbr/>and take the languageâ€™s
creatorsâ€™ word for itâ€”<wbr/>that this doesnâ€™t actually happen. By creating
extremely large lists, we can also use timing information to observe
that the time of constructing the list grows proportional to the
length of the list while the time of passing it as a parameter remains
constant. The important thing to observe here is that, instead of
simply relying on authority, we have used operations in the
language itself to understand how the language behaves.</p></section><section class="SsectionLevel4" id="section 16.1.3"><h4 class="heading">16.1.3Â <a name="(part._equal-always)"/>Notations for Equality<a href="#(part._equal-always)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Until now we have used <code data-lang="pyret" class="sourceCode">==</code> for equality. Now we have learned that itâ€™s
only one of multiple equality operators, and that there is another one called
<code data-lang="pyret" class="sourceCode">identical</code>. However, these two have somewhat subtly different syntactic
properties. <code data-lang="pyret" class="sourceCode">identical</code> is a name for a function, which can
therefore be used to refer to it like any other function (e.g., when we need to
mention it in a <code data-lang="pyret" class="sourceCode">is-not</code> clause). In contrast, <code data-lang="pyret" class="sourceCode">==</code> is a binary
operator, which can only be used in the middle of expressions.</p><p>This should naturally make us wonder about the other two possibilities: a
binary expression version of <code data-lang="pyret" class="sourceCode">identical</code> and a function name equivalent of
<code data-lang="pyret" class="sourceCode">==</code>. They do, in fact, exist! The operation performed by <code data-lang="pyret" class="sourceCode">==</code> is
called <code data-lang="pyret" class="sourceCode">equal-always</code>. Therefore, we can write the first block of tests
equivalently, but more explicitly, as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  a-tree   is%(equal-always) b-tree
  a-tree.l is%(equal-always) a-tree.l
  a-tree.l is%(equal-always) a-tree.r
  b-tree.l is%(equal-always) b-tree.r
end</code></pre><p>Conversely, the binary operator notation for <code data-lang="pyret" class="sourceCode">identical</code> is <code data-lang="pyret" class="sourceCode">&lt;=&gt;</code>.
Thus, we can equivalently write <code data-lang="pyret" class="sourceCode">check-for-no-copy</code> as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun check-for-no-copy(another-l):
  another-l &lt;=&gt; L
end</code></pre></section><section class="SsectionLevel4" id="section 16.1.4"><h4 class="heading">16.1.4Â <a name="(part._.On_the_.Internet__.Nobody_.Knows_.You_re_a_.D.A.G)"/>On the Internet, Nobody Knows Youâ€™re a DAG<a href="#(part._.On_the_.Internet__.Nobody_.Knows_.You_re_a_.D.A.G)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Despite the name weâ€™ve given it, <code data-lang="pyret" class="sourceCode">b-tree</code> is not actually a
tree. In a tree, by definition, there are no shared nodes,
whereas in <code data-lang="pyret" class="sourceCode">b-tree</code> the node named by <code data-lang="pyret" class="sourceCode">four-node</code> is shared
by two parts of the tree. Despite this, traversing <code data-lang="pyret" class="sourceCode">b-tree</code> will
still terminate, because there are no cyclic references in it:
if you start from any node and visit its â€œchildrenâ€, you cannot end
up back at that node.  There is a special name for a value with such a
shape: directed acyclic graph (DAG).</p><p>Many important data structures are actually a DAG underneath. For
instance, consider Web sites. It is common to think of a site as a
tree of pages: the top-level refers to several sections, each of which
refers to sub-sections, and so on. However, sometimes an entry needs
to be cataloged under multiple sections. For instance, an academic
department might organize pages by people, teaching, and research. In
the first of these pages it lists the people who work there; in the
second, the list of courses; and in the third, the list of research
groups. In turn, the courses might have references to the people
teaching them, and the research groups are populated by these same
people. Since we want only one page per person (for both maintenance
and search indexing purposes), all these personnel links refer back to
the same page for people.</p><p>Letâ€™s construct a simple form of this. First a datatype to represent a
siteâ€™s content:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Content:
  | page(s :: String)
  | section(title :: String, sub :: List&lt;Content&gt;)
end</code></pre><p>Letâ€™s now define a few people:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">people-pages :: Content =
  section("People",
    [list: page("Church"),
      page("Dijkstra"),
      page("Hopper") ])</code></pre><p>and a way to extract a particular personâ€™s page:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun get-person(n): get(people-pages.sub, n) end</code></pre><p>Now we can define theory and systems sections:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">theory-pages :: Content =
  section("Theory",
    [list: get-person(0), get-person(1)])
systems-pages :: Content =
  section("Systems",
    [list: get-person(1), get-person(2)])</code></pre><p>which are integrated into a site as a whole:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">site :: Content =
  section("Computing Sciences",
    [list: theory-pages, systems-pages])</code></pre><p>Now we can confirm that each of these luminaries needs to keep only
one Web page current; for instance:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  theory  = get(site.sub, 0)
  systems = get(site.sub, 1)
  theory-dijkstra  = get(theory.sub, 1)
  systems-dijkstra = get(systems.sub, 0)
  theory-dijkstra is             systems-dijkstra
  theory-dijkstra is%(identical) systems-dijkstra
end</code></pre></section><section class="SsectionLevel4" id="section 16.1.5"><h4 class="heading">16.1.5Â <a name="(part._.It_s_.Always_.Been_a_.D.A.G)"/>Itâ€™s Always Been a DAG<a href="#(part._.It_s_.Always_.Been_a_.D.A.G)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>What we may not realize is that weâ€™ve actually been creating a DAG for longer
than we think. To see this, consider <code data-lang="pyret" class="sourceCode">a-tree</code>, which very clearly seems to
be a tree. But look more closely not at the <code data-lang="pyret" class="sourceCode">node</code>s but rather at the
<code data-lang="pyret" class="sourceCode">leaf</code>(s). How many actual <code data-lang="pyret" class="sourceCode">leaf</code>s do we create?</p><p>One hint is that we donâ€™t seem to call a function when creating a <code data-lang="pyret" class="sourceCode">leaf</code>:
the data definition does not list any fields, and when constructing a
<code data-lang="pyret" class="sourceCode">BT</code> value, we simply write <code data-lang="pyret" class="sourceCode">leaf</code>, not (say)
<code data-lang="pyret" class="sourceCode">leaf()</code>. Still, it would be nice to know what is happening behind the
scenes. To check, we can simply ask Pyret:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  leaf is%(identical) leaf
end</code></pre><p>Itâ€™s important that we not write <code data-lang="pyret" class="sourceCode">leaf &lt;=&gt; leaf</code> here, because
that is just an expression whose result is ignored. We have to write <code data-lang="pyret" class="sourceCode">is</code>
to register this as a test whose result is checked and reported.
and this check passes. That is, when we write a variant without any
fields, Pyret automatically creates a singleton: it makes just one
instance and uses that instance everywhere. This leads to a more efficient
memory representation, because there is no reason to have lots of distinct
<code data-lang="pyret" class="sourceCode">leaf</code>s each taking up their own memory. However, a subtle consequence of
that is that we have been creating a DAG all along.</p><p>If we really wanted each <code data-lang="pyret" class="sourceCode">leaf</code> to be distinct, itâ€™s easy: we can write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data BTDistinct:
  | leaf()
  | node(v, l :: BTDistinct, r :: BTDistinct)
end</code></pre><p>Then we would need to use the <code data-lang="pyret" class="sourceCode">leaf</code> function everywhere:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c-tree :: BTDistinct =
  node(5,
    node(4, leaf(), leaf()),
    node(4, leaf(), leaf()))</code></pre><p>And sure enough:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  leaf() is-not%(identical) leaf()
end</code></pre></section><section class="SsectionLevel4" id="section 16.1.6"><h4 class="heading">16.1.6Â <a name="(part._acyc-to-cyc)"/>From Acyclicity to Cycles<a href="#(part._acyc-to-cyc)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Hereâ€™s another example that arises on the Web. Suppose we are
constructing a table of output in a Web page. We would like the rows
of the table to alternate between white and grey. If the table had
only two rows, we could map the row-generating function over a list of
these two colors. Since we do not know how many rows it will have,
however, we would like the list to be as long as necessary. In effect,
we would like to write:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web-colors = link("white", link("grey", web-colors))</code></pre><p>to obtain an indefinitely long list, so that we could eventually write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map2(color-table-row, table-row-content, web-colors)</code></pre><p>which applies a <code data-lang="pyret" class="sourceCode">color-table-row</code> function to two arguments: the
current row from <code data-lang="pyret" class="sourceCode">table-row-content</code>, and the current color from
<code data-lang="pyret" class="sourceCode">web-colors</code>, proceeding in lockstep over the two lists.</p><p>Unfortunately, there are many things wrong with this attempted
definition.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Do you see what they are?</p></blockquote></blockquote><p>Here are some problems in turn:
</p><ul><li><p>This will not even parse. The identifier <code data-lang="pyret" class="sourceCode">web-colors</code> is
not bound on the right of the <code data-lang="pyret" class="sourceCode">=</code>.</p></li><li><p>Earlier, we saw a solution to such a problem: use <code data-lang="pyret" class="sourceCode">rec</code>
[<a href="func-as-data.html#%28part._streams-from-funs%29" data-pltdoc="x">Streams From Functions</a>]. What happens if we write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec web-colors = link("white", link("grey", web-colors))</code></pre><p>instead?
</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why does <code data-lang="pyret" class="sourceCode">rec</code> work in the definition of <code data-lang="pyret" class="sourceCode">ones</code> but not above?</p></blockquote></blockquote></li><li><p>Assuming we have fixed the above problem, one of two things will
happen. It depends on what the initial value of <code data-lang="pyret" class="sourceCode">web-colors</code>
is. Because it is a dummy value, we do not get an arbitrarily long
list of colors but rather a list of two colors followed by the dummy
value. Indeed, this program will not even type-check.</p><p>Suppose, however, that <code data-lang="pyret" class="sourceCode">web-colors</code> were written instead as a
function definition to delay its creation:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun web-colors(): link("white", link("grey", web-colors())) end</code></pre><p>On its own this just defines a function. If, however, we use
itâ€”<wbr/><code data-lang="pyret" class="sourceCode">web-colors()</code>â€”<wbr/>it goes into an infinite loop constructing
<code data-lang="pyret" class="sourceCode">link</code>s.</p></li><li><p>Even if all that were to work, <code data-lang="pyret" class="sourceCode">map2</code> would either (a) not
terminate because its second argument is indefinitely long, or (b)
report an error because the two arguments arenâ€™t the same length.</p></li></ul><p>All these problems are symptoms of a bigger issue. What we are trying
to do here is not merely create a shared datum (like a DAG) but
something much richer: a cyclic datum, i.e., one that refers
back to itself:</p><blockquote class="SCentered"><p><img style="vertical-align: -1px; margin: -3px -3px -3px -3px;" src="../Images/e8661971bf1b4ec52d4a6cfb124b63a2.png" alt="image" width="108" height="108" data-original-src="https://dcic-world.org/2025-08-27/pict_4.png"/></p></blockquote><p>When you get to cycles, even defining the datum becomes difficult
because its definition depends on itself so it (seemingly) needs to
already be defined in the process of being defined. We will return to
cyclic data later in <a href="unified-cyclic-data.html" data-pltdoc="x">Cyclic Data</a>, and to this
specific example in <a href="rec-from-mut.html" data-pltdoc="x">Recursion and Cycles from Mutation</a>.</p></section>&#13;
<h4 class="heading">16.1.1Â <a name="(part._identical-eq)"/>Re-Examining Equality<a href="#(part._identical-eq)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Consider the following data definition and example values:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data BT:
  | leaf
  | node(v, l :: BT, r :: BT)
end

a-tree =
  node(5,
    node(4, leaf, leaf),
    node(4, leaf, leaf))

b-tree =
  block:
    four-node = node(4, leaf, leaf)
    node(5,
      four-node,
      four-node)
  end</code></pre><p>In particular, it might seem that the way weâ€™ve written <code data-lang="pyret" class="sourceCode">b-tree</code>
is morally equivalent to how weâ€™ve written <code data-lang="pyret" class="sourceCode">a-tree</code>, but weâ€™ve
created a helpful binding to avoid code duplication.</p><p>Because both <code data-lang="pyret" class="sourceCode">a-tree</code> and <code data-lang="pyret" class="sourceCode">b-tree</code> are bound to trees with
<code data-lang="pyret" class="sourceCode">5</code> at the root and a left and right child each containing
<code data-lang="pyret" class="sourceCode">4</code>, we can indeed reasonably consider these trees
equivalent. Sure enough:
</p><a name="(elem._equal-tests)"/>&lt;equal-tests&gt; ::=<pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  a-tree   is b-tree
  a-tree.l is a-tree.l
  a-tree.l is a-tree.r
  b-tree.l is b-tree.r
end</code></pre><p>However, there is another sense in which these trees are not
equivalent. concretely, <code data-lang="pyret" class="sourceCode">a-tree</code> constructs a distinct node for
each child, while <code data-lang="pyret" class="sourceCode">b-tree</code> uses the same node for both
children.  Surely this difference should show up somehow, but we
have not yet seen a way to write a program that will tell these
apart.</p><p>By default, the <code data-lang="pyret" class="sourceCode">is</code> operator uses the same equality test as
Pyretâ€™s <code data-lang="pyret" class="sourceCode">==</code>. There are, however, other equality tests in
Pyret. In particular, the way we can tell apart these data is by using
Pyretâ€™s <code data-lang="pyret" class="sourceCode">identical</code> function, which implements
reference equality.  This checks not only whether two
values are structurally equivalent but whether they are
the result of the very same act of value construction.
With this, we can now write additional tests:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  identical(a-tree, b-tree)     is false
  identical(a-tree.l, a-tree.l) is true
  identical(a-tree.l, a-tree.r) is false
  identical(b-tree.l, b-tree.r) is true
end</code></pre><p>Letâ€™s step back for a moment and consider the behavior that gives us this
result.  We can visualize the different values by putting each distinct value
in a separate location alongside the running program.  We can draw the
first step as creating a <code data-lang="pyret" class="sourceCode">node</code> with value <code data-lang="pyret" class="sourceCode">4</code>:</p><pre class="HeapCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a-tree =
  node(5,
    1001,
    node(4, leaf, leaf))

b-tree =
  block:
    four-node = node(4, leaf, leaf)
    node(5,
      four-node,
      four-node)
  end</code></pre></pre><p>Heap</p><ul><li><p>1001:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li></ul><p>The next step creates another node with value <code data-lang="pyret" class="sourceCode">4</code>, distinct from the
first:</p><pre class="HeapCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a-tree =
  node(5, 1001, 1002)

b-tree =
  block:
    four-node = node(4, leaf, leaf)
    node(5,
      four-node,
      four-node)
  end</code></pre></pre><p>Heap</p><ul><li><p>1001:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1002:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li></ul><p>Then the <code data-lang="pyret" class="sourceCode">node</code> for <code data-lang="pyret" class="sourceCode">a-tree</code> is created:</p><pre class="HeapCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a-tree = 1003

b-tree =
  block:
    four-node = node(4, leaf, leaf)
    node(5,
      four-node,
      four-node)
  end</code></pre></pre><p>Heap</p><ul><li><p>1001:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1002:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1003:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1001, 1002)</code></pre></li></ul><p>When evaluating the <code data-lang="pyret" class="sourceCode">block</code> for <code data-lang="pyret" class="sourceCode">b-tree</code>, first a single node is
created for the <code data-lang="pyret" class="sourceCode">four-node</code> binding:</p><pre class="HeapCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a-tree = 1003

b-tree =
  block:
    four-node = 1004
    node(5,
      four-node,
      four-node)
  end</code></pre></pre><p>Heap</p><ul><li><p>1001:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1002:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1003:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1001, 1002)</code></pre></li><li><p>1004:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li></ul><p>These location values can be substituted just like any other, so they get
substituted for <code data-lang="pyret" class="sourceCode">four-node</code> to continue evaluation of the
block.We skipped substituting <code data-lang="pyret" class="sourceCode">a-tree</code> for the moment, that
will come up later.</p><pre class="HeapCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a-tree = 1003

b-tree =
  block:
    node(5, 1004, 1004)
  end</code></pre></pre><p>Heap</p><ul><li><p>1001:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1002:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1003:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1001, 1002)</code></pre></li><li><p>1004:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li></ul><p>Finally, the node for <code data-lang="pyret" class="sourceCode">b-tree</code> is created:</p><pre class="HeapCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">a-tree = 1003

b-tree = 1005</code></pre></pre><p>Heap</p><ul><li><p>1001:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1002:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1003:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1001, 1002)</code></pre></li><li><p>1004:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1005:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1004, 1004)</code></pre></li></ul><p>This visualization can help us explain the test we wrote using <code data-lang="pyret" class="sourceCode">identical</code>.
Letâ€™s consider the test with the appropriate location references substituted
for <code data-lang="pyret" class="sourceCode">a-tree</code> and <code data-lang="pyret" class="sourceCode">b-tree</code>:</p><pre class="HeapCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  identical(1003, 1005)
    is false
  identical(1003.l, 1003.l)
    is true
  identical(1003.l, 1003.r)
    is false
  identical(1005.l, 1005.r)
    is true
end</code></pre></pre><p>Heap</p><ul><li><p>1001:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1002:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1003:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1001, 1002)</code></pre></li><li><p>1004:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1005:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1004, 1004)</code></pre></li></ul><pre class="HeapCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  identical(1003, 1005)
    is false
  identical(1001, 1001)
    is true
  identical(1001, 1004)
    is false
  identical(1004, 1004)
    is true
end</code></pre></pre><p>Heap</p><ul><li><p>1001:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1002:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1003:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1001, 1002)</code></pre></li><li><p>1004:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(4, leaf, leaf)</code></pre></li><li><p>1005:Â </p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">node(5, 1004, 1004)</code></pre></li></ul><p>There is actually another way to write these tests in Pyret: the
<code data-lang="pyret" class="sourceCode">is</code> operator can also be parameterized by a different equality
predicate than the default <code data-lang="pyret" class="sourceCode">==</code>. Thus, the above block can
equivalently be written as:We can use <code data-lang="pyret" class="sourceCode">is-not</code>
to check for expected failure of equality.
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  a-tree   is-not%(identical) b-tree
  a-tree.l is%(identical)     a-tree.l
  a-tree.l is-not%(identical) a-tree.r
  b-tree.l is%(identical)     b-tree.r
end</code></pre><p>We will use this style of equality testing from now on.</p><p>Observe how these are the same values that were compared earlier
(<a href="#%28elem._equal-tests%29" data-pltdoc="x">&lt;equal-tests&gt;</a>), but the results are now different: some
values that were true earlier are now false. In particular,
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  a-tree   is                 b-tree
  a-tree   is-not%(identical) b-tree
  a-tree.l is                 a-tree.r
  a-tree.l is-not%(identical) a-tree.r
end</code></pre><p>Later we will return both to
what <code data-lang="pyret" class="sourceCode">identical</code> really means
[<a href="unified-equality.html" data-pltdoc="x">Understanding Equality</a>]
(Pyret has a full range of equality operations suitable for different situations).</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>There are many more equality tests we can and should perform
even with the basic data above to make sure we really understand
equality and, relatedly, storage of data in memory. What other
tests should we conduct? Predict what results they should produce
before running them!</p></blockquote></blockquote>&#13;
<h4 class="heading">16.1.2Â <a name="(part._.The_.Cost_of_.Evaluating_.References)"/>The Cost of Evaluating References<a href="#(part._.The_.Cost_of_.Evaluating_.References)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>From a complexity viewpoint, itâ€™s important for us to understand how
these references work. As we have hinted, <code data-lang="pyret" class="sourceCode">four-node</code> is computed
only once, and each use of it refers to the same value: if, instead,
it was evaluated each time we referred to <code data-lang="pyret" class="sourceCode">four-node</code>, there
would be no real difference between <code data-lang="pyret" class="sourceCode">a-tree</code> and <code data-lang="pyret" class="sourceCode">b-tree</code>,
and the above tests would not distinguish between them.</p><p>This is especially relevant when understanding the cost of function
evaluation. Weâ€™ll construct two simple examples that illustrate
this. Weâ€™ll begin with a contrived data structure:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L = range(0, 100)</code></pre><p>Suppose we now define
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">L1 = link(1, L)
L2 = link(-1, L)</code></pre><p>Constructing a list clearly takes time at least proportional to the
length; therefore, we expect the time to compute <code data-lang="pyret" class="sourceCode">L</code> to be
considerably more than that for a single <code data-lang="pyret" class="sourceCode">link</code>
operation. Therefore, the question is how long it takes to compute
<code data-lang="pyret" class="sourceCode">L1</code> and <code data-lang="pyret" class="sourceCode">L2</code> after <code data-lang="pyret" class="sourceCode">L</code> has been computed: constant
time, or time proportional to the length of <code data-lang="pyret" class="sourceCode">L</code>?</p><p>The answer, for Pyret, and for most other contemporary languages
(including Java, C#, OCaml, Racket, etc.), is that these additional
computations take constant time. That is, the value bound to
<code data-lang="pyret" class="sourceCode">L</code> is computed once and bound to <code data-lang="pyret" class="sourceCode">L</code>; subsequent
expressions refer to this value (hence â€œreferenceâ€)
rather than reconstructing it, as reference equality shows:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  L1.rest is%(identical) L
  L2.rest is%(identical) L
  L1.rest is%(identical) L2.rest
end</code></pre><p>Similarly, we can define a function, pass <code data-lang="pyret" class="sourceCode">L</code> to it, and see
whether the resulting argument is <code data-lang="pyret" class="sourceCode">identical</code> to the original:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun check-for-no-copy(another-l):
  identical(another-l, L)
end

check:
  check-for-no-copy(L) is true
end</code></pre><p>or, equivalently,
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  L satisfies check-for-no-copy
end</code></pre><p>Therefore, neither built-in operations (like <code data-lang="pyret" class="sourceCode">.rest</code>) nor
user-defined ones (like <code data-lang="pyret" class="sourceCode">check-for-no-copy</code>) make copies of their
arguments.Strictly speaking, of course, we cannot
conclude that no copy was made. Pyret could have made a copy,
discarded it, and still passed a reference to the original. Given how
perverse this would be, we can assumeâ€”<wbr/>and take the languageâ€™s
creatorsâ€™ word for itâ€”<wbr/>that this doesnâ€™t actually happen. By creating
extremely large lists, we can also use timing information to observe
that the time of constructing the list grows proportional to the
length of the list while the time of passing it as a parameter remains
constant. The important thing to observe here is that, instead of
simply relying on authority, we have used operations in the
language itself to understand how the language behaves.</p>&#13;
<h4 class="heading">16.1.3Â <a name="(part._equal-always)"/>Notations for Equality<a href="#(part._equal-always)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Until now we have used <code data-lang="pyret" class="sourceCode">==</code> for equality. Now we have learned that itâ€™s
only one of multiple equality operators, and that there is another one called
<code data-lang="pyret" class="sourceCode">identical</code>. However, these two have somewhat subtly different syntactic
properties. <code data-lang="pyret" class="sourceCode">identical</code> is a name for a function, which can
therefore be used to refer to it like any other function (e.g., when we need to
mention it in a <code data-lang="pyret" class="sourceCode">is-not</code> clause). In contrast, <code data-lang="pyret" class="sourceCode">==</code> is a binary
operator, which can only be used in the middle of expressions.</p><p>This should naturally make us wonder about the other two possibilities: a
binary expression version of <code data-lang="pyret" class="sourceCode">identical</code> and a function name equivalent of
<code data-lang="pyret" class="sourceCode">==</code>. They do, in fact, exist! The operation performed by <code data-lang="pyret" class="sourceCode">==</code> is
called <code data-lang="pyret" class="sourceCode">equal-always</code>. Therefore, we can write the first block of tests
equivalently, but more explicitly, as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  a-tree   is%(equal-always) b-tree
  a-tree.l is%(equal-always) a-tree.l
  a-tree.l is%(equal-always) a-tree.r
  b-tree.l is%(equal-always) b-tree.r
end</code></pre><p>Conversely, the binary operator notation for <code data-lang="pyret" class="sourceCode">identical</code> is <code data-lang="pyret" class="sourceCode">&lt;=&gt;</code>.
Thus, we can equivalently write <code data-lang="pyret" class="sourceCode">check-for-no-copy</code> as
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun check-for-no-copy(another-l):
  another-l &lt;=&gt; L
end</code></pre>&#13;
<h4 class="heading">16.1.4Â <a name="(part._.On_the_.Internet__.Nobody_.Knows_.You_re_a_.D.A.G)"/>On the Internet, Nobody Knows Youâ€™re a DAG<a href="#(part._.On_the_.Internet__.Nobody_.Knows_.You_re_a_.D.A.G)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Despite the name weâ€™ve given it, <code data-lang="pyret" class="sourceCode">b-tree</code> is not actually a
tree. In a tree, by definition, there are no shared nodes,
whereas in <code data-lang="pyret" class="sourceCode">b-tree</code> the node named by <code data-lang="pyret" class="sourceCode">four-node</code> is shared
by two parts of the tree. Despite this, traversing <code data-lang="pyret" class="sourceCode">b-tree</code> will
still terminate, because there are no cyclic references in it:
if you start from any node and visit its â€œchildrenâ€, you cannot end
up back at that node.  There is a special name for a value with such a
shape: directed acyclic graph (DAG).</p><p>Many important data structures are actually a DAG underneath. For
instance, consider Web sites. It is common to think of a site as a
tree of pages: the top-level refers to several sections, each of which
refers to sub-sections, and so on. However, sometimes an entry needs
to be cataloged under multiple sections. For instance, an academic
department might organize pages by people, teaching, and research. In
the first of these pages it lists the people who work there; in the
second, the list of courses; and in the third, the list of research
groups. In turn, the courses might have references to the people
teaching them, and the research groups are populated by these same
people. Since we want only one page per person (for both maintenance
and search indexing purposes), all these personnel links refer back to
the same page for people.</p><p>Letâ€™s construct a simple form of this. First a datatype to represent a
siteâ€™s content:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data Content:
  | page(s :: String)
  | section(title :: String, sub :: List&lt;Content&gt;)
end</code></pre><p>Letâ€™s now define a few people:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">people-pages :: Content =
  section("People",
    [list: page("Church"),
      page("Dijkstra"),
      page("Hopper") ])</code></pre><p>and a way to extract a particular personâ€™s page:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun get-person(n): get(people-pages.sub, n) end</code></pre><p>Now we can define theory and systems sections:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">theory-pages :: Content =
  section("Theory",
    [list: get-person(0), get-person(1)])
systems-pages :: Content =
  section("Systems",
    [list: get-person(1), get-person(2)])</code></pre><p>which are integrated into a site as a whole:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">site :: Content =
  section("Computing Sciences",
    [list: theory-pages, systems-pages])</code></pre><p>Now we can confirm that each of these luminaries needs to keep only
one Web page current; for instance:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  theory  = get(site.sub, 0)
  systems = get(site.sub, 1)
  theory-dijkstra  = get(theory.sub, 1)
  systems-dijkstra = get(systems.sub, 0)
  theory-dijkstra is             systems-dijkstra
  theory-dijkstra is%(identical) systems-dijkstra
end</code></pre>&#13;
<h4 class="heading">16.1.5Â <a name="(part._.It_s_.Always_.Been_a_.D.A.G)"/>Itâ€™s Always Been a DAG<a href="#(part._.It_s_.Always_.Been_a_.D.A.G)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>What we may not realize is that weâ€™ve actually been creating a DAG for longer
than we think. To see this, consider <code data-lang="pyret" class="sourceCode">a-tree</code>, which very clearly seems to
be a tree. But look more closely not at the <code data-lang="pyret" class="sourceCode">node</code>s but rather at the
<code data-lang="pyret" class="sourceCode">leaf</code>(s). How many actual <code data-lang="pyret" class="sourceCode">leaf</code>s do we create?</p><p>One hint is that we donâ€™t seem to call a function when creating a <code data-lang="pyret" class="sourceCode">leaf</code>:
the data definition does not list any fields, and when constructing a
<code data-lang="pyret" class="sourceCode">BT</code> value, we simply write <code data-lang="pyret" class="sourceCode">leaf</code>, not (say)
<code data-lang="pyret" class="sourceCode">leaf()</code>. Still, it would be nice to know what is happening behind the
scenes. To check, we can simply ask Pyret:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  leaf is%(identical) leaf
end</code></pre><p>Itâ€™s important that we not write <code data-lang="pyret" class="sourceCode">leaf &lt;=&gt; leaf</code> here, because
that is just an expression whose result is ignored. We have to write <code data-lang="pyret" class="sourceCode">is</code>
to register this as a test whose result is checked and reported.
and this check passes. That is, when we write a variant without any
fields, Pyret automatically creates a singleton: it makes just one
instance and uses that instance everywhere. This leads to a more efficient
memory representation, because there is no reason to have lots of distinct
<code data-lang="pyret" class="sourceCode">leaf</code>s each taking up their own memory. However, a subtle consequence of
that is that we have been creating a DAG all along.</p><p>If we really wanted each <code data-lang="pyret" class="sourceCode">leaf</code> to be distinct, itâ€™s easy: we can write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">data BTDistinct:
  | leaf()
  | node(v, l :: BTDistinct, r :: BTDistinct)
end</code></pre><p>Then we would need to use the <code data-lang="pyret" class="sourceCode">leaf</code> function everywhere:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">c-tree :: BTDistinct =
  node(5,
    node(4, leaf(), leaf()),
    node(4, leaf(), leaf()))</code></pre><p>And sure enough:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  leaf() is-not%(identical) leaf()
end</code></pre>&#13;
<h4 class="heading">16.1.6Â <a name="(part._acyc-to-cyc)"/>From Acyclicity to Cycles<a href="#(part._acyc-to-cyc)" class="heading-anchor" title="Link to here">ğŸ”—</a> </h4><p>Hereâ€™s another example that arises on the Web. Suppose we are
constructing a table of output in a Web page. We would like the rows
of the table to alternate between white and grey. If the table had
only two rows, we could map the row-generating function over a list of
these two colors. Since we do not know how many rows it will have,
however, we would like the list to be as long as necessary. In effect,
we would like to write:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">web-colors = link("white", link("grey", web-colors))</code></pre><p>to obtain an indefinitely long list, so that we could eventually write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">map2(color-table-row, table-row-content, web-colors)</code></pre><p>which applies a <code data-lang="pyret" class="sourceCode">color-table-row</code> function to two arguments: the
current row from <code data-lang="pyret" class="sourceCode">table-row-content</code>, and the current color from
<code data-lang="pyret" class="sourceCode">web-colors</code>, proceeding in lockstep over the two lists.</p><p>Unfortunately, there are many things wrong with this attempted
definition.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Do you see what they are?</p></blockquote></blockquote><p>Here are some problems in turn:
</p><ul><li><p>This will not even parse. The identifier <code data-lang="pyret" class="sourceCode">web-colors</code> is
not bound on the right of the <code data-lang="pyret" class="sourceCode">=</code>.</p></li><li><p>Earlier, we saw a solution to such a problem: use <code data-lang="pyret" class="sourceCode">rec</code>
[<a href="func-as-data.html#%28part._streams-from-funs%29" data-pltdoc="x">Streams From Functions</a>]. What happens if we write
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">rec web-colors = link("white", link("grey", web-colors))</code></pre><p>instead?
</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Why does <code data-lang="pyret" class="sourceCode">rec</code> work in the definition of <code data-lang="pyret" class="sourceCode">ones</code> but not above?</p></blockquote></blockquote></li><li><p>Assuming we have fixed the above problem, one of two things will
happen. It depends on what the initial value of <code data-lang="pyret" class="sourceCode">web-colors</code>
is. Because it is a dummy value, we do not get an arbitrarily long
list of colors but rather a list of two colors followed by the dummy
value. Indeed, this program will not even type-check.</p><p>Suppose, however, that <code data-lang="pyret" class="sourceCode">web-colors</code> were written instead as a
function definition to delay its creation:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun web-colors(): link("white", link("grey", web-colors())) end</code></pre><p>On its own this just defines a function. If, however, we use
itâ€”<wbr/><code data-lang="pyret" class="sourceCode">web-colors()</code>â€”<wbr/>it goes into an infinite loop constructing
<code data-lang="pyret" class="sourceCode">link</code>s.</p></li><li><p>Even if all that were to work, <code data-lang="pyret" class="sourceCode">map2</code> would either (a) not
terminate because its second argument is indefinitely long, or (b)
report an error because the two arguments arenâ€™t the same length.</p></li></ul><p>All these problems are symptoms of a bigger issue. What we are trying
to do here is not merely create a shared datum (like a DAG) but
something much richer: a cyclic datum, i.e., one that refers
back to itself:</p><blockquote class="SCentered"><p><img style="vertical-align: -1px; margin: -3px -3px -3px -3px;" src="../Images/e8661971bf1b4ec52d4a6cfb124b63a2.png" alt="image" width="108" height="108" data-original-src="https://dcic-world.org/2025-08-27/pict_4.png"/></p></blockquote><p>When you get to cycles, even defining the datum becomes difficult
because its definition depends on itself so it (seemingly) needs to
already be defined in the process of being defined. We will return to
cyclic data later in <a href="unified-cyclic-data.html" data-pltdoc="x">Cyclic Data</a>, and to this
specific example in <a href="rec-from-mut.html" data-pltdoc="x">Recursion and Cycles from Mutation</a>.</p>    
</body>
</html>