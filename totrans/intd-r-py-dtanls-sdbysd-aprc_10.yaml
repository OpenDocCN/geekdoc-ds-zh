- en: Chapter 7 Categorical Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 分类数据
- en: 原文：[https://randpythonbook.netlify.app/categorical-data](https://randpythonbook.netlify.app/categorical-data)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://randpythonbook.netlify.app/categorical-data](https://randpythonbook.netlify.app/categorical-data)
- en: While statisticians may describe data as being either categorical or numerical,
    this classification is different than classifying data by its *type* in a program.
    So, strictly speaking, if you have categorical data, you are not obligated to
    use any particular type to represent it in your script.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然统计学家可能将数据描述为分类或数值，但这种分类与按其在程序中的*类型*对数据进行分类不同。所以，严格来说，如果你有分类数据，你并不一定有义务在你的脚本中使用任何特定的类型来表示它。
- en: However, there are types that are specifically designed to be used with categorical
    data, and so they are especially advantageous to use if you end up with the opportunity.
    We describe a few of them here in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些类型是专门设计用来与分类数据一起使用的，因此如果你有机会，使用它们特别有利。我们将在本章中描述其中的一些。
- en: 7.1 `factor`s in R
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 R中的`factor`函数
- en: Categorical data in R is often stored in a [`factor`](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Factors)
    variable. `factor`s are more special than `vector`s of integers because
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，分类数据通常存储在`factor`变量中。`factor`比整数的`vector`更特殊，因为
- en: they have a `levels` attribute, which is comprised of all the possible values
    that each response could be;
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有一个`levels`属性，它由每个响应可能的所有可能值组成；
- en: they may or may not be *ordered*, which will also control how they are used
    in mathematical functions;
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能是有序的，也可能不是，这也会控制它们在数学函数中的使用方式；
- en: they might have a `contrasts` attribute, which will control how they are used
    in statistical modeling functions.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能有一个`contrasts`属性，这将控制它们在统计建模函数中的使用方式。
- en: Here is a first example. Say we asked three people what their favorite season
    was. The data might look something like this.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个第一个例子。假设我们问三个人他们最喜欢的季节是什么。数据可能看起来像这样。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`factor`s always have levels, which is the collection of all possible unique
    values each observation can take.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`factor`总是有级别，这是每个观测值可以采取的所有可能唯一值的集合。'
- en: You should be careful if you are not specifying them directly. What happens
    when you use the default option and replace the second assignment in the above
    code with `responses <- factor(c("autumn", "summer", "summer"))`? The documentation
    of `factor()` will tell you that, by default, `factor()` will just take the unique
    values found in the data. In this case, nobody prefers winter or spring, and so
    neither will show up in `levels(responses)`. This may or may not be what you want.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有直接指定它们，你应该小心。当你使用默认选项并将上述代码中的第二个赋值替换为`responses <- factor(c("autumn", "summer",
    "summer"))`时会发生什么？`factor()`函数的文档会告诉你，默认情况下，`factor()`将只取数据中找到的唯一值。在这种情况下，没有人更喜欢冬天或春天，因此它们都不会出现在`levels(responses)`中。这可能是你想要的，也可能不是。
- en: '`factor`s can be ordered or unordered. Ordered `factor`s are for *ordinal*
    data. Ordinal data is a particular type of categorical data that recognizes the
    categories have a natural order (e.g. low/ medium/high and not red/green/blue).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`factor`可以是有序的，也可以是无序的。有序的`factor`用于*有序*数据。有序数据是一种特殊的分类数据，它承认类别具有自然顺序（例如，低/中/高，而不是红/绿/蓝）。'
- en: As another example, say we asked ten people how much they liked statistical
    computing, and they could only respond “love it”, “it’s okay” or “hate it”. The
    data might look something like this.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，假设我们问十个人他们有多喜欢统计计算，他们只能回答“爱它”、“还可以”或“讨厌它”。数据可能看起来像这样。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When creating ordered factors with `factor()`, be mindful that the `levels=`
    argument is assumed to be ordered when you plug it into `factor()`. In the above
    example, if you specified `levels = c("love it", "it's okay", "hate it")`, then
    the factor would assume `love it < it's okay < hate it`, which may or may not
    be what you want.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`factor()`创建有序因子时，请注意，当你将其插入`factor()`时，`levels=`参数被认为是有序的。在上面的例子中，如果你指定了`levels
    = c("love it", "it's okay", "hate it")`，那么因子将假设`love it < it's okay < hate it`，这可能是你想要的，也可能不是。
- en: Last, `factor`s may or may not have a `contrast` attribute. You can get or set
    this with the `contrasts()` function. This will influence some of the functions
    you use on your data that estimate statistical models.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`factor`可能有一个`contrast`属性。你可以使用`contrasts()`函数获取或设置这个属性。这将影响你使用的数据估计统计模型的一些函数。
- en: I will not discuss specifics of contrasts in this text, but the overall motivation
    is important. In short, the primary reason for using `factor`s is that they are
    designed to allow control over *how* you model categorical data. To be more specific,
    changing attributes of a `factor` could control the paremeterization of a model
    you’re estimating. If you’re using a particular function for modeling with categorical
    data, you need to know how it treats factors. On the other hand, if you’re writing
    a function that performs modeling of categorical data, you should know how to
    treat factors.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会讨论本文中对比的具体细节，但整体动机很重要。简而言之，使用`factor`s的主要原因是它们被设计成可以控制如何对分类数据进行建模。更具体地说，改变`factor`的属性可以控制你正在估计的模型的参数化。如果你正在使用特定函数进行分类数据的建模，你需要知道它如何处理`factors`。另一方面，如果你正在编写一个执行分类数据建模的函数，你应该知道如何处理`factors`。
- en: Here are two examples that you might come across in your studies.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的学习中可能会遇到以下两个例子。
- en: Consider using `factor`s as inputs to a function that performs linear regression.
    With linear regression models, if you have categorical inputs, there are many
    choices for how to write down a model. In each model, the collection of parameters
    will mean different things. In R, you might pick the model by creating the `factor`
    in a specific way.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑使用`factor`s作为执行线性回归的函数的输入。在线性回归模型中，如果你有分类输入，有许多选择来写下模型。在每个模型中，参数集合将意味着不同的事情。在R中，你可能会通过以特定方式创建`factor`来选择模型。
- en: Suppose you are interested in estimating a classification model. In this case,
    the *dependent* variable is categorical, not the independent variable. With these
    types of models, choosing whether or not your `factor` is ordered is critical.
    These options would estimate completely different models, so choose wisely!
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你对估计分类模型感兴趣。在这种情况下，*因变量*是分类的，而不是自变量。在这些类型的模型中，选择你的`factor`是否有序是至关重要的。这些选项将估计完全不同的模型，所以请明智地选择！
- en: The mathematical details of these examples is outside of the scope of this text.
    If you have not learned about dummy variables in a regression course, or if you
    have not considered the difference between multinomial logistic regression and
    ordinal logistic regression, or if you have but you’re just a little rusty, that
    is totally fine. I only mention these as examples for how the `factor` type can
    trigger special behavior.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子的数学细节超出了本文的范围。如果你在回归课程中没有学习过虚拟变量，或者如果你没有考虑过多项逻辑回归和有序逻辑回归之间的区别，或者你考虑过但只是有点生疏，那完全没问题。我只是提到这些作为`factor`类型可以触发特殊行为的例子。
- en: 'In addition to creating one with `factor()`, there are two other common ways
    that you can end up with `factors`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`factor()`创建一个之外，还有两种常见的结束方式可以得到`factors`：
- en: creating factors from numerical data, and
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数值数据创建`factors`，以及
- en: when reading in an external data file, one of the columns is coerced to a `factor`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当读取外部数据文件时，某一列被强制转换为`factor`。
- en: Here is an example of (1). We can take non-categorical data, and `cut()` it
    into something categorical.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个（1）的例子。我们可以将非分类数据`cut()`成分类数据。
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finally, be mindful of how different functions read in external data sets. When
    reading in an external file, if a particular function comes across a column that
    has characters in it, it will need to decide whether to store that column as a
    character vector, or as a `factor`. For example, `read.csv()` and `read.table()`
    have a `stringsAsFactors=` argument that you should be mindful of.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意不同函数读取外部数据集的方式。当读取外部文件时，如果某个函数遇到包含字符的列，它将需要决定是否将该列存储为字符向量，还是作为`factor`。例如，`read.csv()`和`read.table()`有一个`stringsAsFactors=`参数，你应该注意这一点。
- en: 7.2 Two Options for Categorical Data in Pandas
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 Pandas中分类数据的两种选项
- en: Pandas provides two options for storing categorical data. They are both very
    similar to R’s `factor`s. You may use either
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas提供了两种存储分类数据的方法。它们都与R的`factor`s非常相似。你可以使用其中任何一个
- en: a Pandas `Series` with a special `dtype`, or
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个具有特殊`dtype`的Pandas `Series`，或者
- en: a Pandas `Categorical` container.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Pandas `Categorical`容器。
- en: Pandas’ `Series` were discussed earlier in sections [3.2](/r-vectors-versus-numpy-arrays-and-pandas-series#overview-of-python)
    and [3.4](/r-vectors-versus-numpy-arrays-and-pandas-series#vectorization-in-python).
    These were containers that forced every element to share the same `dtype`. Here,
    we specify `dtype="category"` in `pd.Series()`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas的`Series`在[3.2](/r-vectors-versus-numpy-arrays-and-pandas-series#overview-of-python)和[3.4](/r-vectors-versus-numpy-arrays-and-pandas-series#vectorization-in-python)节中已经讨论过。这些是强制每个元素共享相同`dtype`的容器。在这里，我们在`pd.Series()`中指定`dtype="category"`。
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The second option is to use Pandas’ `Categorical` containers. They are quite
    similar, so the choice is subtle. Like `Series` containers, they also force all
    of their elements to share the same shared `dtype`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是使用Pandas的`Categorical`容器。它们非常相似，所以选择是微妙的。就像`Series`容器一样，它们也强制所有元素共享相同的`dtype`。
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You might have noticed that, with the `Categorical` container, methods and data
    members were not accessed through the `.cat` accessor. It is also more similar
    to R’s `factor`s because you can specify more arguments in the constructor.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在使用`Categorical`容器时，方法和数据成员不是通过`.cat`访问器访问的。它也与R的`factor`类似，因为你可以指定更多的参数在构造函数中。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In Pandas, just like in R, you need to be very careful about what the `categories`
    (c.f `levels`) are. If you are using ordinal data, they need to be specified in
    the correct order. If you are using small data sets, be cognizant of whether all
    the categories show up in the data–otherwise they will not be correctly inferred.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pandas中，就像在R中一样，你需要非常小心地处理`categories`（即`levels`）。如果你使用有序数据，它们需要按照正确的顺序指定。如果你使用小数据集，要注意是否所有类别都出现在数据中——否则它们将不会被正确推断。
- en: With Pandas’ `Series` it’s more difficult to specify a nondefault `dtype`. One
    option is to change them after the object has been created.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pandas的`Series`中，指定非默认的`dtype`更困难。一个选项是在对象创建后更改它们。
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Another option is to create the `dtype` before you create the `Series`, and
    pass it into `pd.Series()`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是在创建`Series`之前创建`dtype`，并将其传递给`pd.Series()`。
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Just like in R, you can convert numerical data into categorical. The function
    even has the same name as in R: [`pd.cut()`](https://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html#series-creation).
    Depending on the type of the input, [it will return either a `Series` or a `Categorical`](https://pandas.pydata.org/docs/reference/api/pandas.cut.html).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在R中一样，你可以将数值数据转换为分类数据。该函数甚至与R中的名称相同：`pd.cut()`([https://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html#series-creation](https://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html#series-creation))。根据输入类型，它将返回一个`Series`或`Categorical`([https://pandas.pydata.org/docs/reference/api/pandas.cut.html](https://pandas.pydata.org/docs/reference/api/pandas.cut.html))。
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, when reading in data from an external source, choose carefully whether
    you want character data to be stored as a string type, or as a categorical type.
    Here we use [`pd.read_csv()`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html)
    to read in Fisher’s Iris data set (Fisher [1988](#ref-misc_iris_53)) hosted by
    (Dua and Graff [2017](#ref-uci_data)). More information on Pandas’ `DataFrames`
    can be found in the next chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当从外部源读取数据时，仔细选择是否要将字符数据存储为字符串类型，还是分类类型。在这里，我们使用`pd.read_csv()`([https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html))读取Fisher的Iris数据集（Fisher
    [1988](#ref-misc_iris_53))，由(Dua和Graff [2017](#ref-uci_data))提供。有关Pandas的`DataFrames`的更多信息，请参阅下一章。
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 7.3 Exercises
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 练习
- en: 7.3.1 R Questions
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 R问题
- en: Read in this chess data set (“Chess (King-Rook vs. King-Pawn)” [1989](#ref-misc_chess)),
    hosted by (Dua and Graff [2017](#ref-uci_data)), with the following code. You
    will probably have to change your working directory, but if you do, make sure
    to comment out that code before you submit your script to me.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码读取这个棋盘数据集（“Chess (King-Rook vs. King-Pawn)” [1989](#ref-misc_chess))，由(Dua和Graff
    [2017](#ref-uci_data))提供。你可能需要更改工作目录，但如果你这样做，确保在将脚本提交给我之前注释掉那段代码。
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Are all of the columns `factor`s? Assign `TRUE` or `FALSE` to `allFactors`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有列都是`factor`类型吗？将`TRUE`或`FALSE`赋值给`allFactors`。
- en: 'Should any of these `factor`s be ordered? Assign `TRUE` or `FALSE` to `ideallyOrdered`.
    Hint: read the data set description from [https://archive.ics.uci.edu/ml/datasets/Chess+%28King-Rook+vs.+King-Pawn%29](https://archive.ics.uci.edu/ml/datasets/Chess+%28King-Rook+vs.+King-Pawn%29).'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些`factor`中的任何一个应该是有序的吗？将`TRUE`或`FALSE`赋值给`ideallyOrdered`。提示：从[https://archive.ics.uci.edu/ml/datasets/Chess+%28King-Rook+vs.+King-Pawn%29](https://archive.ics.uci.edu/ml/datasets/Chess+%28King-Rook+vs.+King-Pawn%29)读取数据集描述。
- en: Are any of these factors currently ordered? Assign `TRUE` or `FALSE` to `currentlyOrdered`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些因素目前是否有序？将`TRUE`或`FALSE`赋值给`currentlyOrdered`。
- en: What percent (between \(0\) and \(100\)) of the time is the first column equal
    to `'f'`? Assign your answer to `percentF`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一列等于 `'f'` 的百分比是多少（介于 \(0\) 和 \(100\)% 之间）？将你的答案分配给 `percentF`。
- en: Suppose you have the following `vector`. Please make sure to include this code
    in your script.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个以下 `vector`。请确保将此代码包含在你的脚本中。
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: create a `factor` from `normSamps`. Map each element to `"within 1 sd"` or `"outside
    1 sd"` depending on whether the element is within \(1\) theoretical standard deviation
    of \(0\) or not. Call the `factor` `withinOrNot`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `normSamps` 中创建一个 `factor`。将每个元素映射到 `"within 1 sd"` 或 `"outside 1 sd"`，具体取决于元素是否在
    \(0\) 的 \(1\) 理论标准差内。将 `factor` 命名为 `withinOrNot`。
- en: 7.3.2 Python Questions
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 Python 问题
- en: 'Consider the following simulated letter grade data for two students:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个学生的模拟成绩数据：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Convert the two Numpy arrays to one of the Pandas types for categorical data
    that the textbook discussed. Call these two variables `s1` and `s2`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这两个 Numpy 数组转换为教科书讨论的 Pandas 类型的分类数据。将这两个变量命名为 `s1` 和 `s2`。
- en: These data are categorical. Are they ordinal? Make sure to adjust `s1` and `s2`
    accordingly.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些数据是分类数据。它们是有序的吗？确保相应地调整 `s1` 和 `s2`。
- en: Calculate the two student GPAs. Assign the floating point numbers to variables
    named `s1_gpa` and `s2_gpa`. Use `grade_values` to convert each letter grade to
    a number, and then average all the numbers for each student together using equal
    weights.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算两个学生的 GPA。将浮点数分配给名为 `s1_gpa` 和 `s2_gpa` 的变量。使用 `grade_values` 将每个字母成绩转换为数字，然后使用等权重将每个学生的所有数字平均在一起。
- en: 'Is each category equally-spaced? If yes, then these are said to be *interval
    data*. Does your answer to this question affect the legitimacy of averaging together
    any ordinal data? Assign a `str` response to the variable `ave_ord_data_response`.
    Hint: consider (any) two different data sets that happen to produce the same GPA.
    Is the equality of these two GPAs misleading?'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个类别是否等距分布？如果是，那么这些数据被称为 *等距数据*。你对这个问题的回答是否会影响将任何有序数据平均起来的合法性？将你的回答分配给变量 `ave_ord_data_response`。提示：考虑（任何）两个不同的数据集，它们恰好产生了相同的
    GPA。这两个 GPA 的相等性是否具有误导性？
- en: Compute the mode grade for each student. Assign your answers as `str`s to the
    variables `s1_mode` and `s2_mode`. If there are more than one modes, then assign
    the one that comes first alphabetically.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每个学生的平均成绩。将你的答案作为 `str` 分配给变量 `s1_mode` 和 `s2_mode`。如果有多个平均成绩，则分配字母顺序中第一个的平均成绩。
- en: Suppose you are creating a *classifier* whose job it is to predict labels. Consider
    the following `DataFrame` of predicted labels next to their corresponding actual
    labels. Please make sure to include this code in your script.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在创建一个 *分类器*，其任务是预测标签。考虑以下预测标签与相应实际标签的 `DataFrame`。请确保将此代码包含在你的脚本中。
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Assign the prediction accuracy, as a percent (between \(0\) and \(100\)), to
    the variable `perc_acc`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将预测准确率（介于 \(0\) 和 \(100\)% 之间）分配给变量 `perc_acc`。
- en: Create a *confusion matrix* to better assess *which* labels your classifier
    has a difficult time with. This should be a \(3 \times 3\) Numpy `ndarray` of
    percentages. The row will correspond to the predicted label, the column will correspond
    to the actual label, and number in location \((0,2)\), say, will be the percent
    of observations where your model predicted label `1` and the actual was a label
    `3`. Call the variable `confusion`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 *混淆矩阵* 以更好地评估分类器在哪些标签上难以处理。这应该是一个 \(3 \times 3\) 的 Numpy `ndarray` 百分比。行将对应于预测标签，列将对应于实际标签，而位置
    \((0,2)\) 中的数字，例如，将是模型预测标签 `1` 而实际标签为 `3` 的观察值的百分比。将变量命名为 `confusion`。
- en: References
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: “Chess (King-Rook vs. King-Pawn).” 1989\. UCI Machine Learning Repository.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: “象棋（王后-车对王-兵）。” 1989\. UCI 机器学习库。
- en: Dua, Dheeru, and Casey Graff. 2017\. “UCI Machine Learning Repository.” University
    of California, Irvine, School of Information; Computer Sciences. [http://archive.ics.uci.edu/ml](http://archive.ics.uci.edu/ml).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Dua, Dheeru 和 Casey Graff. 2017\. “UCI 机器学习库。”加州大学欧文分校，信息与计算机科学学院。[http://archive.ics.uci.edu/ml](http://archive.ics.uci.edu/ml)。
- en: Fisher, Test, R.A. & Creator. 1988\. “Iris.” UCI Machine Learning Repository.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Fisher, Test, R.A. & Creator. 1988\. “Iris.” UCI 机器学习库。
