["```py\nimport numpy as np\nimport utils\n\nepsv = 1e-3\n\ndef f0(vbarnorm, epsv, hhat):\n    if vbarnorm >= epsv:\n        return vbarnorm * hhat\n    else:\n        vbarnormhhat = vbarnorm * hhat\n        epsvhhat = epsv * hhat\n        return vbarnormhhat * vbarnormhhat * (-vbarnormhhat / 3.0 + epsvhhat) / (epsvhhat * epsvhhat) + epsvhhat / 3.0\n\ndef f1_div_vbarnorm(vbarnorm, epsv):\n    if vbarnorm >= epsv:\n        return 1.0 / vbarnorm\n    else:\n        return (-vbarnorm + 2.0 * epsv) / (epsv * epsv)\n\ndef f_hess_term(vbarnorm, epsv):\n    if vbarnorm >= epsv:\n        return -1.0 / (vbarnorm * vbarnorm)\n    else:\n        return -1.0 / (epsv * epsv) \n```", "```py\ndef val(v, mu_lambda, hhat, n):\n    sum = 0.0\n    T = np.identity(2) - np.outer(n, n) # tangent of slope is constant\n    for i in range(0, len(v)):\n        if mu_lambda[i] > 0:\n            vbar = np.transpose(T).dot(v[i])\n            sum += mu_lambda[i] * f0(np.linalg.norm(vbar), epsv, hhat)\n    return sum\n\ndef grad(v, mu_lambda, hhat, n):\n    g = np.array([[0.0, 0.0]] * len(v))\n    T = np.identity(2) - np.outer(n, n) # tangent of slope is constant\n    for i in range(0, len(v)):\n        if mu_lambda[i] > 0:\n            vbar = np.transpose(T).dot(v[i])\n            g[i] = mu_lambda[i] * f1_div_vbarnorm(np.linalg.norm(vbar), epsv) * T.dot(vbar)\n    return g\n\ndef hess(v, mu_lambda, hhat, n):\n    IJV = [[0] * 0, [0] * 0, np.array([0.0] * 0)]\n    T = np.identity(2) - np.outer(n, n) # tangent of slope is constant\n    for i in range(0, len(v)):\n        if mu_lambda[i] > 0:\n            vbar = np.transpose(T).dot(v[i])\n            vbarnorm = np.linalg.norm(vbar)\n            inner_term = f1_div_vbarnorm(vbarnorm, epsv) * np.identity(2)\n            if vbarnorm != 0:\n                inner_term += f_hess_term(vbarnorm, epsv) / vbarnorm * np.outer(vbar, vbar)\n            local_hess = mu_lambda[i] * T.dot(utils.make_PSD(inner_term)).dot(np.transpose(T)) / hhat\n            for c in range(0, 2):\n                for r in range(0, 2):\n                    IJV[0].append(i * 2 + r)\n                    IJV[1].append(i * 2 + c)\n                    IJV[2] = np.append(IJV[2], local_hess[r, c])\n    return IJV \n```", "```py\ndef step_forward(x, e, v, m, l2, k, n, o, contact_area, mu, is_DBC, h, tol):\n    x_tilde = x + v * h     # implicit Euler predictive position\n    x_n = copy.deepcopy(x)\n    mu_lambda = BarrierEnergy.compute_mu_lambda(x, n, o, contact_area, mu)  # compute mu * lambda for each node using x^n\n\n    # Newton loop \n```", "```py\ndef compute_mu_lambda(x, n, o, contact_area, mu):\n    mu_lambda = np.array([0.0] * len(x))\n    for i in range(0, len(x)):\n        d = n.dot(x[i] - o)\n        if d < dhat:\n            s = d / dhat\n            mu_lambda[i] = mu * -contact_area[i] * dhat * (kappa / 2 * (math.log(s) / dhat + (s - 1) / d))\n    return mu_lambda \n```", "```py\nmu = 0.11        # friction coefficient of the slope \n```"]