["```py\n# Mass-Spring Solids Simulation\n\nimport numpy as np  # numpy for linear algebra\nimport pygame       # pygame for visualization\npygame.init()\n\nimport square_mesh   # square mesh\nimport time_integrator\n\n# simulation setup\nside_len = 1\nrho = 1000  # density of square\nk = 1e5     # spring stiffness\ninitial_stretch = 1.4\nn_seg = 4   # num of segments per side of the square\nh = 0.004   # time step size in s\n\n# initialize simulation\n[x, e] = square_mesh.generate(side_len, n_seg)  # node positions and edge node indices\nv = np.array([[0.0, 0.0]] * len(x))             # velocity\nm = [rho * side_len * side_len / ((n_seg + 1) * (n_seg + 1))] * len(x)  # calculate node mass evenly\n# rest length squared\nl2 = []\nfor i in range(0, len(e)):\n    diff = x[e[i][0]] - x[e[i][1]]\n    l2.append(diff.dot(diff))\nk = [k] * len(e)    # spring stiffness\n# apply initial stretch horizontally\nfor i in range(0, len(x)):\n    x[i][0] *= initial_stretch\n\n# simulation with visualization\nresolution = np.array([900, 900])\noffset = resolution / 2\nscale = 200\ndef screen_projection(x):\n    return [offset[0] + scale * x[0], resolution[1] - (offset[1] + scale * x[1])]\n\ntime_step = 0\nsquare_mesh.write_to_file(time_step, x, n_seg)\nscreen = pygame.display.set_mode(resolution)\nrunning = True\nwhile running:\n    # run until the user asks to quit\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    print('### Time step', time_step, '###')\n\n    # fill the background and draw the square\n    screen.fill((255, 255, 255))\n    for eI in e:\n        pygame.draw.aaline(screen, (0, 0, 255), screen_projection(x[eI[0]]), screen_projection(x[eI[1]]))\n    for xI in x:\n        pygame.draw.circle(screen, (0, 0, 255), screen_projection(xI), 0.1 * side_len / n_seg * scale)\n\n    pygame.display.flip()   # flip the display\n\n    # step forward simulation and wait for screen refresh\n    [x, v] = time_integrator.step_forward(x, e, v, m, l2, k, h, 1e-2)\n    time_step += 1\n    pygame.time.wait(int(h * 1000))\n    square_mesh.write_to_file(time_step, x, n_seg)\n\npygame.quit() \n```", "```py\ndef write_to_file(frameNum, x, n_seg):\n    # Check if 'output' directory exists; if not, create it\n    if not os.path.exists('output'):\n        os.makedirs('output')\n\n    # create obj file\n    filename = f\"output/{frameNum}.obj\"\n    with open(filename, 'w') as f:\n        # write vertex coordinates\n        for row in x:\n            f.write(f\"v {float(row[0]):.6f} {float(row[1]):.6f} 0.0\\n\") \n        # write vertex indices for each triangle\n        for i in range(0, n_seg):\n            for j in range(0, n_seg):\n                #NOTE: each cell is exported as 2 triangles for rendering\n                f.write(f\"f {i * (n_seg+1) + j + 1} {(i+1) * (n_seg+1) + j + 1} {(i+1) * (n_seg+1) + j+1 + 1}\\n\")\n                f.write(f\"f {i * (n_seg+1) + j + 1} {(i+1) * (n_seg+1) + j+1 + 1} {i * (n_seg+1) + j+1 + 1}\\n\") \n```", "```py\npython3 simulator.py \n```"]