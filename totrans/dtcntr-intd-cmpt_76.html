<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>29Â Pyret vs. PythonðŸ”—</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>29Â Pyret vs. PythonðŸ”—</h1>
<blockquote>åŽŸæ–‡ï¼š<a href="https://dcic-world.org/2025-08-27/pyret-vs-python.html">https://dcic-world.org/2025-08-27/pyret-vs-python.html</a></blockquote><p>For the curious, we offer a few examples here to justify our frustration with
Python for early programming.</p><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><p>Python exposes machine arithmetic by default. Thus, by default,
<code data-lang="text/x-python" class="sourceCode">0.1 + 0.2</code> is not the same as <code data-lang="text/x-python" class="sourceCode">0.3</code>. (We hope youâ€™re
not surprised to hear this.) Why this is the case is a
fascinating subject of study, but we consistently find it a distraction for first-time programmers writing programs with arithmetic.
And if we handwave the details of floating point aside, are we
taking our claims of program reliability seriously?</p></td><td><p>Pyret implements exact arithmetic, including rationals, by default. In
Pyret, <code data-lang="pyret" class="sourceCode">0.1 + 0.2</code> really is equal to <code data-lang="pyret" class="sourceCode">0.3</code>. Where a computation must
return an inexact number, Pyret does it explicitly: a key requirement in
a curriculum built on reliability.</p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><p>Understanding the difference between creating a variable and updating its value is a key
learning outcome, along with understanding variablesâ€™ scopes. Python explicitly
conflates declaration with update, and <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/pmmwplck-python-full-monty/">has a tangled history with scope</a>.</p></td><td><p>Pyret is statically scoped, and goes to great lengthsâ€”<wbr/>e.g., in the
design of a query language for tablesâ€”<wbr/>to maintain it. There is no ambiguity in
Pyretâ€™s syntax for working with variables.</p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><p>Python has a weakly-defined, optional mechanism of annotations that was
added late in the languageâ€™s design,
<a href="https://twitter.com/joepolitz/status/1357751800795832321?s=20">which
conflates values and types</a>.</p></td><td><p>Drawing on lessons learned from
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/ffkwf-mrspidey/">our</a>
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/gsk-flow-typing-theory/">several</a>
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/pqk-progressive-types/">prior</a>
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/pgk-sem-type-fc-member-name/">research</a>
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/lpgk-tejas-type-sys-js/">projects</a>
on adding types to languages after-the-fact,
Pyret was designed with typability from the start, with several
subtle design choices to enable this. Pyret also has support (currently
dynamic) for refinement-type annotations.</p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><p>Pythonâ€™s annotation mechanism has no notion of refinements.</p></td><td><p>To prepare students for modern programming languages with rich type systems, Pyretâ€™s
annotation syntax supports refinements. However, these are checked dynamically, so that
students do not need to satisfy the vagaries of any particular proof assistant.</p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><p>Python has weak built-in support for testing. While it has extensive
professional libraries to test software, these impose a non-trivial burden on
learners, as a result of which most introductory curricula do not use them.</p></td><td><p>First, a curriculum that proclaims reliability must put testing at its
heart. Second, our pedagogy places heavy emphasis on the use of examples, and
in particular the building-up of abstractions from concrete instances. For both
these reasons, Pyret has extensive support in the language itselfâ€”<wbr/>not
through optional, external librariesâ€”<wbr/>for writing examples and tests, and
provides direct language support for many of the interesting and tricky issues
that arise when doing so.</p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><p>Modern testing goes well beyond unit-tests. Furthermore,
property-based testing is a very useful
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/wnk-use-rel-prob-pbt/">gateway</a>
to thinking about formal properties. In Python, this is only available through libraries.</p></td><td><p>Pyret has convenient language featuresâ€”<wbr/>such as the use of
<code data-lang="pyret" class="sourceCode">satisfies</code> rather than <code data-lang="pyret" class="sourceCode">is</code> in testsâ€”<wbr/>to expose students
to these ideas in lightweight ways.</p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><p>State is ubiquitous in libraries.</p></td><td><p>State is an important but also complicated part of
programming. Pyret nudges students to program without state while
still permitting the full range of stateful programming. This comes
with safeguards both linguistic (e.g., variables are immutable unless
declared otherwise) and in output (e.g., mutable fields are displayed
to alert the student that the value may change or may even have
already changed).</p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><p>Equality comparison is simplistic and in line with most other
professional languages.</p></td><td><p>Equality is in fact subtle, and useful as a pedagogic
device. Therefore, Pyret has a carefully-designed family of equality
operators that are not only of practical value but also have pedagogic
use.</p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><p>Images are not values in the language. You can write a program to produce
an image, but you canâ€™t just view it in your programming environment.</p></td><td><p>Images are values. Pyret can print an image just like it can a string or
a number (and why not?). Images are fun values, but they arenâ€™t
frivolous: they are especially useful for demystifying and explaining important
but abstract issues like function composition.</p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><p>The language doesnâ€™t have a built-in notion of reactive programs.</p></td><td><p>Reactivity is a core concept in the language, and the subject of both
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/plpk-reactor-design/">design</a>
and
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/bnpkg-stopify/">implementation</a>
research.</p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><p>Pythonâ€™s error messages are not added with novices as a primary audience.</p></td><td><p>Novices make many errors. They can be especially intimidated by
error reports, and can feel discouraged about causing errors. Thus,
Pyretâ€™s error messages are the result of nearly a
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/mfk-measur-effect-error-msg-novice-sigcse/">decade</a>
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/mfk-mind-lang-novice-inter-error-msg/">of</a>
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/wk-error-msg-classifier/">research</a>.
In fact, some educators have created pedagogic techniques that explicitly rely
on the nature and presentation of information in Pyretâ€™s errors.</p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><p>Python has begun to suffer from complexity creep that we believe serves professionals at the expense of novices.
For example, the result of map in Python is actually a special
generator value. This can lead to outcomes requiring extra explanation, like map(str, [1, 2, 3]) producing &lt;map object at 0x1045f4940&gt;.
Type hints (discussed above) are another example.</p></td><td><p>Since Pyretâ€™s target audience is novice programmers programming in the
style of this book, our primary goal when adding any feature is to preserve the
early experience and avoid surprises.</p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><p>Data definitions are central to computer science, but Python over-relies
on built-in data structures (especially dictionaries) and makes user-defined
ones unwieldy to create.</p></td><td><p>Pyret borrows from the rich tradition of languages like Standard ML,
OCaml, and Haskell to provide algebraic datatypes, whose absence often forces
programmers to engage in unwieldy (and inefficient) encoding tricks.</p></td></tr></table><table cellspacing="0" cellpadding="0" class="TwoColumn"><tr><td><p>Python</p></td><td><p>Pyret</p></td></tr><tr><td><p>Python has several more rough corners that can lead to unexpected and
undesirable outcomes. For instance, <code data-lang="text/x-python" class="sourceCode">=</code> sometimes introduces new
variables and sometimes rebinds them. A function where a student forgot to
return a value doesnâ€™t result in an error but silently returns
<code data-lang="text/x-python" class="sourceCode">None</code>. Python has a complicated
<a href="https://papl.cs.brown.edu/2020/growing-lang.html#%28part._design-space-cond%29">table</a>
that describes which values are true and which are false. And so on.</p></td><td><p>Pyret is designed from the ground-up to avoid all these problems.</p></td></tr></table>    
</body>
</html>