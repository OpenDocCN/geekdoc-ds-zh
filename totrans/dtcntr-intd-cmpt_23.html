<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>8.3¬†Examples, Testing, and Program Checkingüîó</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>8.3¬†Examples, Testing, and Program Checkingüîó</h1>
<blockquote>ÂéüÊñáÔºö<a href="https://dcic-world.org/2025-08-27/testing.html">https://dcic-world.org/2025-08-27/testing.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">¬†¬†¬†¬†</span><a href="#%28part._from-examples-to-tests%29" class="toclink" data-pltdoc="x">8.3.1<span class="hspace">¬†</span>From Examples to Tests</a></p></td></tr><tr><td><p><span class="hspace">¬†¬†¬†¬†</span><a href="#%28part._s~3arefined%29" class="toclink" data-pltdoc="x">8.3.2<span class="hspace">¬†</span>More Refined Comparisons</a></p></td></tr><tr><td><p><span class="hspace">¬†¬†¬†¬†</span><a href="#%28part._.When_.Tests_.Fail%29" class="toclink" data-pltdoc="x">8.3.3<span class="hspace">¬†</span>When Tests Fail</a></p></td></tr><tr><td><p><span class="hspace">¬†¬†¬†¬†</span><a href="#%28part._test-oracle%29" class="toclink" data-pltdoc="x">8.3.4<span class="hspace">¬†</span>Oracles for Testing</a></p></td></tr></table><p/><div class="SIntrapara">Back in <a href="From_Repeated_Expressions_to_Functions.html#%28part._writing-examples%29" data-pltdoc="x">Documenting Functions with Examples</a>, we began to develop your habit of
writing concrete examples of functions. In <a href="processing-tables.html#%28part._task-plans%29" data-pltdoc="x">Task Plans</a>, we
showed you how to develop examples of intermediate values to help you
plan the code for you to write. As these examples show, there are many
ways to write down examples. We could write them on a board, on paper,
or even as comments in a computer document. These are all reasonable
and indeed, often, the best way to begin working on a
problem. However, if we can write our examples <span class="emph">in a precise form
that a computer can understand</span>, we achieve two things:
</div><div class="SIntrapara"><ul><li><p>When we‚Äôre done writing our purported solution, we can have the
computer check whether we got it right.</p></li><li><p>In the process of writing down our expectation, we often find it
hard to express with the precision that a computer expects. Sometimes
this is because we‚Äôre still formulating the details and haven‚Äôt yet
pinned them down, but at other times it‚Äôs because <span class="emph">we don‚Äôt yet
understand the problem</span>. In such situations, the force of precision
actually does us good, because it helps us understand the weakness of
our understanding.</p></li></ul></div><section class="SsectionLevel4" id="section 8.3.1"><h4 class="heading">8.3.1<span class="stt">¬†</span><a name="(part._from-examples-to-tests)"/>From Examples to Tests<span class="button-group"><a href="#(part._from-examples-to-tests)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span></h4><p>Until now, we have written examples in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where:</code></span> blocks for two
purposes: to help us figure out what a function needs to do, and to
provide guidance to someone reading our code as to what behavior they can
expect when using our function. For the smaller programs that we have
written until now, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span>-based examples have been
sufficient. As our programs get more complicated, however, a small set
of related illustrative examples won‚Äôt suffice. We need to think about being
much more thorough in the sets of inputs that we consider.</p><p>Consider for example a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">count-uses</code></span> that counts how many
times a specific string appears in a list (this could be used to tally
votes, to compute the frequency of using a discount code, and so
on). What input scenarios might we need to check before using our
function to run an actual election or a business?</p><ul><li><p>The result for a string that is in the list once</p></li><li><p>The result for a string that is in the list multiple times</p></li><li><p>The result for a string that is at the end of a longer list (to make
sure we are checking all of the elements)</p></li><li><p>The result for a string that isn‚Äôt in the list</p></li><li><p>The result for a string that is in the list but with different capitalization</p></li><li><p>The result for a string that is a typo-away from a word in the list</p></li></ul><p>Notice that here we are considering many more situations, including
fairly nuanced ones that affect how robust our code would be under
realistic situations. Once we start considering situations like these,
we are shifting from <span class="emph">examples to illustrate our code</span> to
<span class="emph">tests to thoroughly test our code</span>.</p><p>In Pyret, we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> blocks inside function definitions for
examples. We use a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check</code></span> block outside the function definition
for tests. For example:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun count-uses(of-string :: String, in-list :: List&lt;String&gt;) -&gt; Number:
  ...
where:
  count-uses("pepper", [list:]) is 0
  count-uses("pepper", [list: "onion"]) is 0
  count-uses("pepper", [list: "pepper", "onion"]) is 1
  count-uses("pepper", [list: "pepper", "pepper", "onion"]) is 2
end

check:
  count-uses("ppper", [list: "pepper"]) is 0
  count-uses("ONION", [list: "pepper", "onion"]) is 1
  count-uses("tomato",
    [list: "pepper", "onion", "onion", "pepper", "tomato",
      "tomato", "onion", "tomato"])
    is 3
  ...
end</code></pre></div></div><p>As a guiding rule, we put illustrative cases that would help someone
else reading our code into the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> block, while we put the
nitty-gritty checks that our code handles the wider range of usage
scenarios (including error cases) into the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check</code></span>. Sometimes,
the line between these two isn‚Äôt clear: for example, one could easily
argue that the second test (the function handles different
capitalization) belongs in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> instead. The third test about
using a really long list would remain in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check</code></span>, however, as
longer inputs are generally not instructive to a reader of your code.</p><p>Putting tests in a block that lives outside the function has another
advantage at the level of professional programming: it allows your
tests to live in a separate file from your code. This has two key
benefits. First, it makes it easier for someone to read the essential parts
of your code (if they are building on your work). Second, it makes it
easier to control when tests are run. When your <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check</code></span> blocks
are in the same file as your code, all the tests will be checked when
you run your code. When they are in a different file, an organization
can choose when to run the tests. During development, tests are run
frequently to make sure no errors have been introduced. Once code is
tested and ready to be deployed or used, tests are not run along with
the program (unless there has been a modification or someone has
discovered an error with the code). This is standard practice in software projects.</p><p>It is also worth noting that the collection of tests grows throughout
the development process, moreso than do the collection of examples. As
you are developing code, <span class="emph">every time you find a bug in your code,
add a test for it in your <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check</code></span> block so you don‚Äôt accidentally
introduce that same error again later</span>. Whereas we develop
examples up front as we figure out what we want our program to do, we
augment our tests as we discover what our program actually does (and
perhaps should <span class="emph">not</span> do). In practice, developers write an
initial set of checks on the scenarios they thought of before and
while writing the code, then expand those tests as they try out more
scenarios and gain users who report scenarios where the code does not
work.</p><p>Nearly all programming languages come with some constructs or packages
in which you can write tests in separate files. Pyret is unique in
supporting the distinction between examples and tests (both for
learning and for readability of code by others). Many programming
tools that support professionals expect you to put all tests in
separate folders and files (offering no support for examples). In this
book, we emphasize the difference between these two uses of
input-output pairs in programming because we find them extremely
useful both professionally and pedagogically.</p></section><section class="SsectionLevel4" id="section 8.3.2"><h4 class="heading">8.3.2<span class="stt">¬†</span><a name="(part._s~3arefined)"/>More Refined Comparisons<span class="button-group"><a href="#(part._s~3arefined)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span></h4><p>Sometimes, a direct comparison via <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> isn‚Äôt enough for
testing. We have already seen this in the case of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raises</code></span>
tests (<a href="trees.html#%28part._compute-parents-table%29" data-pltdoc="x">Computing Genetic Parents from an Ancestry Table</a>). As another example, when doing
some computations, especially involving math with approximations, the
exact match of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> isn‚Äôt feasible. For example, consider these tests for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distance-to-origin</code></span>:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  distance-to-origin(point(1, 1)) is ???
end</code></pre></div></div><p>What can we check here?  Typing this into the REPL, we can find that the answer
prints as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1.4142135623730951</code></span>.  That‚Äôs an approximation of the real
answer, which Pyret cannot represent exactly.  But it‚Äôs hard to know that this
precise answer, to this decimal place, and no more, is the one we should expect
up front, and thinking through the answers is supposed to be the first thing we
do!</p><p>Since we know we‚Äôre getting an approximation, we can really only check that the
answer is <span class="emph">roughly</span> correct, not exactly correct.  If we can check that
the answer to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distance-to-origin(point(1, 1))</code></span> is around, say,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1.41</code></span>, and can do the same for some similar cases, that‚Äôs probably good
enough for many applications, and for our purposes here.  If we were
calculating orbital dynamics, we might demand higher precision, but note that
we‚Äôd still need to pick a cutoff!  Testing for inexact results is a necessary
task.</p><p>Let‚Äôs first define what we mean by ‚Äúaround‚Äù with one of the most precise ways
we can, a function:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun around(actual :: Number, expected :: Number) -&gt; Boolean:
  doc: "Return whether actual is within 0.01 of expected"
  num-abs(actual - expected) &lt; 0.01
where:
  around(5, 5.01) is true
  around(5.01, 5) is true
  around(5.02, 5) is false
  around(num-sqrt(2), 1.41) is true
end</code></pre></div></div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> form now helps us out.  There is special syntax for supplying a
user-defined function to use to compare the two values, instead of just
checking if they are equal:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  5 is%(around) 5.01
  num-sqrt(2) is%(around) 1.41
  distance-to-origin(point(1, 1)) is%(around) 1.41
end</code></pre></div></div><p>Adding <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">%(something)</code></span> after <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> changes the behavior of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span>.  Normally, it would compare the left and right values for equality.
If something is provided with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">%</code></span>, however, it instead passes the left
and right values to the provided function (in this example <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">around</code></span>).  If
the provided function produces <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>, the test passes, if it produces
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>, the test fails.  This gives us the control we need to test
functions with predictable approximate results.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Extend the definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distance-to-origin</code></span> to include
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">polar</code></span> points.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p><span class="refelem"><span class="refcolumn"><span class="refcontent">This might save you a Google search:
<a href="http://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates">polar
conversions</a>.</span></span></span>
Use the design recipe to write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x-component</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">y-component</code></span>, which return the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">y</code></span> Cartesian parts
of the point (which you would need, for example, if you were plotting them on a graph).
Read about <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-sin</code></span> and other functions you‚Äôll need at
<a href="http://www.pyret.org/docs/latest/numbers.html">the Pyret number
documentation</a>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p> Write a data definition called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Pay</code></span> for pay types that includes
both hourly employees, whose pay type includes an hourly rate, and salaried
employees, whose pay type includes a total salary for the year.  Use the design
recipe to write a function called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">expected-weekly-wages</code></span> that takes a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Pay</code></span>, and returns the expected weekly salary: the expected weekly salary
for an hourly employee assumes they work 40 hours, and the expected weekly
salary for a salaried employee is 1/52 of their salary.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 8.3.3"><h4 class="heading">8.3.3<span class="stt">¬†</span><a name="(part._.When_.Tests_.Fail)"/>When Tests Fail<span class="button-group"><a href="#(part._.When_.Tests_.Fail)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span></h4><p>Suppose we‚Äôve written the function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt</code></span>, which computes the
square root of a given number. We‚Äôve written some tests for this
function. We run the program, and find that a test fails. There are
two obvious reasons why this can happen.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What are the two obvious reasons?</p></blockquote></blockquote><p/><div class="SIntrapara">The two reasons are, of course, the two ‚Äúsides‚Äù of the test: the
problem could be with the values we‚Äôve written or with the function
we‚Äôve written. For instance, if we‚Äôve written
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt(4) is 1.75</code></pre></div></div></div><div class="SIntrapara">then the fault clearly lies with the values (because \(1.75^2\) is
clearly not \(4\)). On the other hand, if it fails the test
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt(4) is 2</code></pre></div></div></div><div class="SIntrapara">then the odds are that we‚Äôve made an error in the definition of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt</code></span> instead, and that‚Äôs what we need to fix.</div><p>Note that there is no way for the computer to tell what went
wrong. When it reports a test failure, all it‚Äôs saying is that there
is an <span style="font-style: italic">inconsistency</span> between the program and the tests. The
computer is not passing judgment on which one is ‚Äúcorrect‚Äù, because
it can‚Äôt do that. That is a matter for human
judgment.<span class="refelem"><span class="refcolumn"><span class="refcontent">For this reason, we‚Äôve been doing research on
<a href="http://cs.brown.edu/~sk/Publications/Papers/Published/pkf-ifpr-tests-tf-prog/">peer review of tests</a>, so students can help one another review their
tests before they begin writing programs.</span></span></span></p><p/><div class="SIntrapara">Actually...not so fast. There‚Äôs one more possibility we didn‚Äôt
consider: the third, not-so-obvious reason why a test might
fail. Return to this test:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt(4) is 2</code></pre></div></div></div><div class="SIntrapara">Clearly the inputs and outputs are correct, but it could be that the
definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt</code></span> is <span class="emph">also</span> correct, and yet the test
fails.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Do you see why?</p></blockquote></blockquote><p>Depending on how we‚Äôve programmed <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt</code></span>, it might return the
root <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-2</code></span> instead of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>. Now <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-2</code></span> is a perfectly good
answer, too. That is, neither the function nor the particular set of
test values we specified is inherently wrong; it‚Äôs just that the
function happens to be a <span style="font-style: italic">relation</span>, i.e., it maps one input to
multiple outputs (that is, \(\sqrt{4} = \pm 2\)). The question now is
how to write the test properly.</p></section><section class="SsectionLevel4" id="section 8.3.4"><h4 class="heading">8.3.4<span class="stt">¬†</span><a name="(part._test-oracle)"/>Oracles for Testing<span class="button-group"><a href="#(part._test-oracle)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">In other words, sometimes what we want to express is not a concrete
input-output pair, but rather check that the output has the right
<span class="emph">relationship</span> to the input. Concretely, what might this be in
the case of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt</code></span>? We hinted at this earlier when we said that
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1.75</code></span> clearly can‚Äôt be right, because squaring it does not yield
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">4</code></span>. That gives us the general insight: that a number is a valid
root (note the use of ‚Äúa‚Äù instead of ‚Äúthe‚Äù) if squaring it yields
the original number. That is, we might write a function like this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun is-sqrt(n):
  n-root = sqrt(n)
  n == (n-root * n-root)
end</code></pre></div></div></div><div class="SIntrapara">and then our test looks like
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  is-sqrt(4) is true
end</code></pre></div></div></div><div class="SIntrapara">Unfortunately, this has an awkward failure case. If <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt</code></span> does
not produce a number that is in fact a root, we aren‚Äôt told what the
actual value is; instead, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-sqrt</code></span> returns false, and the test
failure just says that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span> (what <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-sqrt</code></span> returns) is
not <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> (what the test expects)‚Äî<wbr/>which is both absolutely
true and utterly useless.</div><p/><div class="SIntrapara">Fortunately, Pyret has a better way of expressing the same
check. Instead of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span>, we can write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">satisfies</code></span>, and then
the value on the left must <span style="font-style: italic">satisfy</span> the <span style="font-style: italic">predicate</span> on the
right. Concretely, this looks like:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun check-sqrt(n):
  lam(n-root):
    n == (n-root * n-root)
  end
end</code></pre></div></div></div><div class="SIntrapara">which lets us write:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  sqrt(4) satisfies check-sqrt(4)
end</code></pre></div></div></div><div class="SIntrapara">Now, if there‚Äôs a failure, we learn of the actual value produced by
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt(4)</code></span> that failed to satisfy the predicate.</div></section>&#13;
<h4 class="heading">8.3.1<span class="stt">¬†</span><a name="(part._from-examples-to-tests)"/>From Examples to Tests<span class="button-group"><a href="#(part._from-examples-to-tests)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span></h4><p>Until now, we have written examples in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where:</code></span> blocks for two
purposes: to help us figure out what a function needs to do, and to
provide guidance to someone reading our code as to what behavior they can
expect when using our function. For the smaller programs that we have
written until now, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span>-based examples have been
sufficient. As our programs get more complicated, however, a small set
of related illustrative examples won‚Äôt suffice. We need to think about being
much more thorough in the sets of inputs that we consider.</p><p>Consider for example a function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">count-uses</code></span> that counts how many
times a specific string appears in a list (this could be used to tally
votes, to compute the frequency of using a discount code, and so
on). What input scenarios might we need to check before using our
function to run an actual election or a business?</p><ul><li><p>The result for a string that is in the list once</p></li><li><p>The result for a string that is in the list multiple times</p></li><li><p>The result for a string that is at the end of a longer list (to make
sure we are checking all of the elements)</p></li><li><p>The result for a string that isn‚Äôt in the list</p></li><li><p>The result for a string that is in the list but with different capitalization</p></li><li><p>The result for a string that is a typo-away from a word in the list</p></li></ul><p>Notice that here we are considering many more situations, including
fairly nuanced ones that affect how robust our code would be under
realistic situations. Once we start considering situations like these,
we are shifting from <span class="emph">examples to illustrate our code</span> to
<span class="emph">tests to thoroughly test our code</span>.</p><p>In Pyret, we use <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> blocks inside function definitions for
examples. We use a <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check</code></span> block outside the function definition
for tests. For example:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun count-uses(of-string :: String, in-list :: List&lt;String&gt;) -&gt; Number:
  ...
where:
  count-uses("pepper", [list:]) is 0
  count-uses("pepper", [list: "onion"]) is 0
  count-uses("pepper", [list: "pepper", "onion"]) is 1
  count-uses("pepper", [list: "pepper", "pepper", "onion"]) is 2
end

check:
  count-uses("ppper", [list: "pepper"]) is 0
  count-uses("ONION", [list: "pepper", "onion"]) is 1
  count-uses("tomato",
    [list: "pepper", "onion", "onion", "pepper", "tomato",
      "tomato", "onion", "tomato"])
    is 3
  ...
end</code></pre></div></div><p>As a guiding rule, we put illustrative cases that would help someone
else reading our code into the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> block, while we put the
nitty-gritty checks that our code handles the wider range of usage
scenarios (including error cases) into the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check</code></span>. Sometimes,
the line between these two isn‚Äôt clear: for example, one could easily
argue that the second test (the function handles different
capitalization) belongs in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">where</code></span> instead. The third test about
using a really long list would remain in <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check</code></span>, however, as
longer inputs are generally not instructive to a reader of your code.</p><p>Putting tests in a block that lives outside the function has another
advantage at the level of professional programming: it allows your
tests to live in a separate file from your code. This has two key
benefits. First, it makes it easier for someone to read the essential parts
of your code (if they are building on your work). Second, it makes it
easier to control when tests are run. When your <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check</code></span> blocks
are in the same file as your code, all the tests will be checked when
you run your code. When they are in a different file, an organization
can choose when to run the tests. During development, tests are run
frequently to make sure no errors have been introduced. Once code is
tested and ready to be deployed or used, tests are not run along with
the program (unless there has been a modification or someone has
discovered an error with the code). This is standard practice in software projects.</p><p>It is also worth noting that the collection of tests grows throughout
the development process, moreso than do the collection of examples. As
you are developing code, <span class="emph">every time you find a bug in your code,
add a test for it in your <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check</code></span> block so you don‚Äôt accidentally
introduce that same error again later</span>. Whereas we develop
examples up front as we figure out what we want our program to do, we
augment our tests as we discover what our program actually does (and
perhaps should <span class="emph">not</span> do). In practice, developers write an
initial set of checks on the scenarios they thought of before and
while writing the code, then expand those tests as they try out more
scenarios and gain users who report scenarios where the code does not
work.</p><p>Nearly all programming languages come with some constructs or packages
in which you can write tests in separate files. Pyret is unique in
supporting the distinction between examples and tests (both for
learning and for readability of code by others). Many programming
tools that support professionals expect you to put all tests in
separate folders and files (offering no support for examples). In this
book, we emphasize the difference between these two uses of
input-output pairs in programming because we find them extremely
useful both professionally and pedagogically.</p>&#13;
<h4 class="heading">8.3.2<span class="stt">¬†</span><a name="(part._s~3arefined)"/>More Refined Comparisons<span class="button-group"><a href="#(part._s~3arefined)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span></h4><p>Sometimes, a direct comparison via <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> isn‚Äôt enough for
testing. We have already seen this in the case of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">raises</code></span>
tests (<a href="trees.html#%28part._compute-parents-table%29" data-pltdoc="x">Computing Genetic Parents from an Ancestry Table</a>). As another example, when doing
some computations, especially involving math with approximations, the
exact match of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> isn‚Äôt feasible. For example, consider these tests for <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distance-to-origin</code></span>:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  distance-to-origin(point(1, 1)) is ???
end</code></pre></div></div><p>What can we check here?  Typing this into the REPL, we can find that the answer
prints as <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1.4142135623730951</code></span>.  That‚Äôs an approximation of the real
answer, which Pyret cannot represent exactly.  But it‚Äôs hard to know that this
precise answer, to this decimal place, and no more, is the one we should expect
up front, and thinking through the answers is supposed to be the first thing we
do!</p><p>Since we know we‚Äôre getting an approximation, we can really only check that the
answer is <span class="emph">roughly</span> correct, not exactly correct.  If we can check that
the answer to <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distance-to-origin(point(1, 1))</code></span> is around, say,
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1.41</code></span>, and can do the same for some similar cases, that‚Äôs probably good
enough for many applications, and for our purposes here.  If we were
calculating orbital dynamics, we might demand higher precision, but note that
we‚Äôd still need to pick a cutoff!  Testing for inexact results is a necessary
task.</p><p>Let‚Äôs first define what we mean by ‚Äúaround‚Äù with one of the most precise ways
we can, a function:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun around(actual :: Number, expected :: Number) -&gt; Boolean:
  doc: "Return whether actual is within 0.01 of expected"
  num-abs(actual - expected) &lt; 0.01
where:
  around(5, 5.01) is true
  around(5.01, 5) is true
  around(5.02, 5) is false
  around(num-sqrt(2), 1.41) is true
end</code></pre></div></div><p>The <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> form now helps us out.  There is special syntax for supplying a
user-defined function to use to compare the two values, instead of just
checking if they are equal:</p><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  5 is%(around) 5.01
  num-sqrt(2) is%(around) 1.41
  distance-to-origin(point(1, 1)) is%(around) 1.41
end</code></pre></div></div><p>Adding <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">%(something)</code></span> after <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span> changes the behavior of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span>.  Normally, it would compare the left and right values for equality.
If something is provided with <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">%</code></span>, however, it instead passes the left
and right values to the provided function (in this example <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">around</code></span>).  If
the provided function produces <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span>, the test passes, if it produces
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span>, the test fails.  This gives us the control we need to test
functions with predictable approximate results.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Extend the definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">distance-to-origin</code></span> to include
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">polar</code></span> points.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p><span class="refelem"><span class="refcolumn"><span class="refcontent">This might save you a Google search:
<a href="http://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates">polar
conversions</a>.</span></span></span>
Use the design recipe to write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x-component</code></span> and
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">y-component</code></span>, which return the <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">x</code></span> and <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">y</code></span> Cartesian parts
of the point (which you would need, for example, if you were plotting them on a graph).
Read about <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">num-sin</code></span> and other functions you‚Äôll need at
<a href="http://www.pyret.org/docs/latest/numbers.html">the Pyret number
documentation</a>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p> Write a data definition called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Pay</code></span> for pay types that includes
both hourly employees, whose pay type includes an hourly rate, and salaried
employees, whose pay type includes a total salary for the year.  Use the design
recipe to write a function called <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">expected-weekly-wages</code></span> that takes a
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">Pay</code></span>, and returns the expected weekly salary: the expected weekly salary
for an hourly employee assumes they work 40 hours, and the expected weekly
salary for a salaried employee is 1/52 of their salary.</p></blockquote></blockquote>&#13;
<h4 class="heading">8.3.3<span class="stt">¬†</span><a name="(part._.When_.Tests_.Fail)"/>When Tests Fail<span class="button-group"><a href="#(part._.When_.Tests_.Fail)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span></h4><p>Suppose we‚Äôve written the function <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt</code></span>, which computes the
square root of a given number. We‚Äôve written some tests for this
function. We run the program, and find that a test fails. There are
two obvious reasons why this can happen.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What are the two obvious reasons?</p></blockquote></blockquote><p/><div class="SIntrapara">The two reasons are, of course, the two ‚Äúsides‚Äù of the test: the
problem could be with the values we‚Äôve written or with the function
we‚Äôve written. For instance, if we‚Äôve written
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt(4) is 1.75</code></pre></div></div></div><div class="SIntrapara">then the fault clearly lies with the values (because \(1.75^2\) is
clearly not \(4\)). On the other hand, if it fails the test
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt(4) is 2</code></pre></div></div></div><div class="SIntrapara">then the odds are that we‚Äôve made an error in the definition of
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt</code></span> instead, and that‚Äôs what we need to fix.</div><p>Note that there is no way for the computer to tell what went
wrong. When it reports a test failure, all it‚Äôs saying is that there
is an <span style="font-style: italic">inconsistency</span> between the program and the tests. The
computer is not passing judgment on which one is ‚Äúcorrect‚Äù, because
it can‚Äôt do that. That is a matter for human
judgment.<span class="refelem"><span class="refcolumn"><span class="refcontent">For this reason, we‚Äôve been doing research on
<a href="http://cs.brown.edu/~sk/Publications/Papers/Published/pkf-ifpr-tests-tf-prog/">peer review of tests</a>, so students can help one another review their
tests before they begin writing programs.</span></span></span></p><p/><div class="SIntrapara">Actually...not so fast. There‚Äôs one more possibility we didn‚Äôt
consider: the third, not-so-obvious reason why a test might
fail. Return to this test:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt(4) is 2</code></pre></div></div></div><div class="SIntrapara">Clearly the inputs and outputs are correct, but it could be that the
definition of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt</code></span> is <span class="emph">also</span> correct, and yet the test
fails.</div><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Do you see why?</p></blockquote></blockquote><p>Depending on how we‚Äôve programmed <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt</code></span>, it might return the
root <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-2</code></span> instead of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">2</code></span>. Now <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">-2</code></span> is a perfectly good
answer, too. That is, neither the function nor the particular set of
test values we specified is inherently wrong; it‚Äôs just that the
function happens to be a <span style="font-style: italic">relation</span>, i.e., it maps one input to
multiple outputs (that is, \(\sqrt{4} = \pm 2\)). The question now is
how to write the test properly.</p>&#13;
<h4 class="heading">8.3.4<span class="stt">¬†</span><a name="(part._test-oracle)"/>Oracles for Testing<span class="button-group"><a href="#(part._test-oracle)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span></h4><p/><div class="SIntrapara">In other words, sometimes what we want to express is not a concrete
input-output pair, but rather check that the output has the right
<span class="emph">relationship</span> to the input. Concretely, what might this be in
the case of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt</code></span>? We hinted at this earlier when we said that
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">1.75</code></span> clearly can‚Äôt be right, because squaring it does not yield
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">4</code></span>. That gives us the general insight: that a number is a valid
root (note the use of ‚Äúa‚Äù instead of ‚Äúthe‚Äù) if squaring it yields
the original number. That is, we might write a function like this:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun is-sqrt(n):
  n-root = sqrt(n)
  n == (n-root * n-root)
end</code></pre></div></div></div><div class="SIntrapara">and then our test looks like
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  is-sqrt(4) is true
end</code></pre></div></div></div><div class="SIntrapara">Unfortunately, this has an awkward failure case. If <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt</code></span> does
not produce a number that is in fact a root, we aren‚Äôt told what the
actual value is; instead, <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-sqrt</code></span> returns false, and the test
failure just says that <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">false</code></span> (what <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is-sqrt</code></span> returns) is
not <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">true</code></span> (what the test expects)‚Äî<wbr/>which is both absolutely
true and utterly useless.</div><p/><div class="SIntrapara">Fortunately, Pyret has a better way of expressing the same
check. Instead of <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">is</code></span>, we can write <span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">satisfies</code></span>, and then
the value on the left must <span style="font-style: italic">satisfy</span> the <span style="font-style: italic">predicate</span> on the
right. Concretely, this looks like:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun check-sqrt(n):
  lam(n-root):
    n == (n-root * n-root)
  end
end</code></pre></div></div></div><div class="SIntrapara">which lets us write:
</div><div class="SIntrapara"><p/><div class="sourceCodeWrapper"><span data-label="Pyret" class="sourceLangLabel"/><div class="sourceCode"><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  sqrt(4) satisfies check-sqrt(4)
end</code></pre></div></div></div><div class="SIntrapara">Now, if there‚Äôs a failure, we learn of the actual value produced by
<span title="Pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt(4)</code></span> that failed to satisfy the predicate.</div>    
</body>
</html>