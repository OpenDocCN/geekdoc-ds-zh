<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>8.3¬†Examples, Testing, and Program Checkingüîó</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>8.3¬†Examples, Testing, and Program Checkingüîó</h1>
<blockquote>ÂéüÊñáÔºö<a href="https://dcic-world.org/2025-08-27/testing.html">https://dcic-world.org/2025-08-27/testing.html</a></blockquote><table cellspacing="0" cellpadding="0"><tr><td><p>¬†¬†¬†¬†<a href="#%28part._from-examples-to-tests%29" class="toclink" data-pltdoc="x">8.3.1¬†From Examples to Tests</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._s~3arefined%29" class="toclink" data-pltdoc="x">8.3.2¬†More Refined Comparisons</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._.When_.Tests_.Fail%29" class="toclink" data-pltdoc="x">8.3.3¬†When Tests Fail</a></p></td></tr><tr><td><p>¬†¬†¬†¬†<a href="#%28part._test-oracle%29" class="toclink" data-pltdoc="x">8.3.4¬†Oracles for Testing</a></p></td></tr></table><p>Back in <a href="From_Repeated_Expressions_to_Functions.html#%28part._writing-examples%29" data-pltdoc="x">Documenting Functions with Examples</a>, we began to develop your habit of
writing concrete examples of functions. In <a href="processing-tables.html#%28part._task-plans%29" data-pltdoc="x">Task Plans</a>, we
showed you how to develop examples of intermediate values to help you
plan the code for you to write. As these examples show, there are many
ways to write down examples. We could write them on a board, on paper,
or even as comments in a computer document. These are all reasonable
and indeed, often, the best way to begin working on a
problem. However, if we can write our examples in a precise form
that a computer can understand, we achieve two things:
</p><ul><li><p>When we‚Äôre done writing our purported solution, we can have the
computer check whether we got it right.</p></li><li><p>In the process of writing down our expectation, we often find it
hard to express with the precision that a computer expects. Sometimes
this is because we‚Äôre still formulating the details and haven‚Äôt yet
pinned them down, but at other times it‚Äôs because we don‚Äôt yet
understand the problem. In such situations, the force of precision
actually does us good, because it helps us understand the weakness of
our understanding.</p></li></ul><section class="SsectionLevel4" id="section 8.3.1"><h4 class="heading">8.3.1¬†<a name="(part._from-examples-to-tests)"/>From Examples to Tests<a href="#(part._from-examples-to-tests)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Until now, we have written examples in <code data-lang="pyret" class="sourceCode">where:</code> blocks for two
purposes: to help us figure out what a function needs to do, and to
provide guidance to someone reading our code as to what behavior they can
expect when using our function. For the smaller programs that we have
written until now, <code data-lang="pyret" class="sourceCode">where</code>-based examples have been
sufficient. As our programs get more complicated, however, a small set
of related illustrative examples won‚Äôt suffice. We need to think about being
much more thorough in the sets of inputs that we consider.</p><p>Consider for example a function <code data-lang="pyret" class="sourceCode">count-uses</code> that counts how many
times a specific string appears in a list (this could be used to tally
votes, to compute the frequency of using a discount code, and so
on). What input scenarios might we need to check before using our
function to run an actual election or a business?</p><ul><li><p>The result for a string that is in the list once</p></li><li><p>The result for a string that is in the list multiple times</p></li><li><p>The result for a string that is at the end of a longer list (to make
sure we are checking all of the elements)</p></li><li><p>The result for a string that isn‚Äôt in the list</p></li><li><p>The result for a string that is in the list but with different capitalization</p></li><li><p>The result for a string that is a typo-away from a word in the list</p></li></ul><p>Notice that here we are considering many more situations, including
fairly nuanced ones that affect how robust our code would be under
realistic situations. Once we start considering situations like these,
we are shifting from examples to illustrate our code to
tests to thoroughly test our code.</p><p>In Pyret, we use <code data-lang="pyret" class="sourceCode">where</code> blocks inside function definitions for
examples. We use a <code data-lang="pyret" class="sourceCode">check</code> block outside the function definition
for tests. For example:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun count-uses(of-string :: String, in-list :: List&lt;String&gt;) -&gt; Number:
  ...
where:
  count-uses("pepper", [list:]) is 0
  count-uses("pepper", [list: "onion"]) is 0
  count-uses("pepper", [list: "pepper", "onion"]) is 1
  count-uses("pepper", [list: "pepper", "pepper", "onion"]) is 2
end

check:
  count-uses("ppper", [list: "pepper"]) is 0
  count-uses("ONION", [list: "pepper", "onion"]) is 1
  count-uses("tomato",
    [list: "pepper", "onion", "onion", "pepper", "tomato",
      "tomato", "onion", "tomato"])
    is 3
  ...
end</code></pre><p>As a guiding rule, we put illustrative cases that would help someone
else reading our code into the <code data-lang="pyret" class="sourceCode">where</code> block, while we put the
nitty-gritty checks that our code handles the wider range of usage
scenarios (including error cases) into the <code data-lang="pyret" class="sourceCode">check</code>. Sometimes,
the line between these two isn‚Äôt clear: for example, one could easily
argue that the second test (the function handles different
capitalization) belongs in <code data-lang="pyret" class="sourceCode">where</code> instead. The third test about
using a really long list would remain in <code data-lang="pyret" class="sourceCode">check</code>, however, as
longer inputs are generally not instructive to a reader of your code.</p><p>Putting tests in a block that lives outside the function has another
advantage at the level of professional programming: it allows your
tests to live in a separate file from your code. This has two key
benefits. First, it makes it easier for someone to read the essential parts
of your code (if they are building on your work). Second, it makes it
easier to control when tests are run. When your <code data-lang="pyret" class="sourceCode">check</code> blocks
are in the same file as your code, all the tests will be checked when
you run your code. When they are in a different file, an organization
can choose when to run the tests. During development, tests are run
frequently to make sure no errors have been introduced. Once code is
tested and ready to be deployed or used, tests are not run along with
the program (unless there has been a modification or someone has
discovered an error with the code). This is standard practice in software projects.</p><p>It is also worth noting that the collection of tests grows throughout
the development process, moreso than do the collection of examples. As
you are developing code, every time you find a bug in your code,
add a test for it in your <code data-lang="pyret" class="sourceCode">check</code> block so you don‚Äôt accidentally
introduce that same error again later. Whereas we develop
examples up front as we figure out what we want our program to do, we
augment our tests as we discover what our program actually does (and
perhaps should not do). In practice, developers write an
initial set of checks on the scenarios they thought of before and
while writing the code, then expand those tests as they try out more
scenarios and gain users who report scenarios where the code does not
work.</p><p>Nearly all programming languages come with some constructs or packages
in which you can write tests in separate files. Pyret is unique in
supporting the distinction between examples and tests (both for
learning and for readability of code by others). Many programming
tools that support professionals expect you to put all tests in
separate folders and files (offering no support for examples). In this
book, we emphasize the difference between these two uses of
input-output pairs in programming because we find them extremely
useful both professionally and pedagogically.</p></section><section class="SsectionLevel4" id="section 8.3.2"><h4 class="heading">8.3.2¬†<a name="(part._s~3arefined)"/>More Refined Comparisons<a href="#(part._s~3arefined)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Sometimes, a direct comparison via <code data-lang="pyret" class="sourceCode">is</code> isn‚Äôt enough for
testing. We have already seen this in the case of <code data-lang="pyret" class="sourceCode">raises</code>
tests (<a href="trees.html#%28part._compute-parents-table%29" data-pltdoc="x">Computing Genetic Parents from an Ancestry Table</a>). As another example, when doing
some computations, especially involving math with approximations, the
exact match of <code data-lang="pyret" class="sourceCode">is</code> isn‚Äôt feasible. For example, consider these tests for <code data-lang="pyret" class="sourceCode">distance-to-origin</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  distance-to-origin(point(1, 1)) is ???
end</code></pre><p>What can we check here?  Typing this into the REPL, we can find that the answer
prints as <code data-lang="pyret" class="sourceCode">1.4142135623730951</code>.  That‚Äôs an approximation of the real
answer, which Pyret cannot represent exactly.  But it‚Äôs hard to know that this
precise answer, to this decimal place, and no more, is the one we should expect
up front, and thinking through the answers is supposed to be the first thing we
do!</p><p>Since we know we‚Äôre getting an approximation, we can really only check that the
answer is roughly correct, not exactly correct.  If we can check that
the answer to <code data-lang="pyret" class="sourceCode">distance-to-origin(point(1, 1))</code> is around, say,
<code data-lang="pyret" class="sourceCode">1.41</code>, and can do the same for some similar cases, that‚Äôs probably good
enough for many applications, and for our purposes here.  If we were
calculating orbital dynamics, we might demand higher precision, but note that
we‚Äôd still need to pick a cutoff!  Testing for inexact results is a necessary
task.</p><p>Let‚Äôs first define what we mean by ‚Äúaround‚Äù with one of the most precise ways
we can, a function:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun around(actual :: Number, expected :: Number) -&gt; Boolean:
  doc: "Return whether actual is within 0.01 of expected"
  num-abs(actual - expected) &lt; 0.01
where:
  around(5, 5.01) is true
  around(5.01, 5) is true
  around(5.02, 5) is false
  around(num-sqrt(2), 1.41) is true
end</code></pre><p>The <code data-lang="pyret" class="sourceCode">is</code> form now helps us out.  There is special syntax for supplying a
user-defined function to use to compare the two values, instead of just
checking if they are equal:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  5 is%(around) 5.01
  num-sqrt(2) is%(around) 1.41
  distance-to-origin(point(1, 1)) is%(around) 1.41
end</code></pre><p>Adding <code data-lang="pyret" class="sourceCode">%(something)</code> after <code data-lang="pyret" class="sourceCode">is</code> changes the behavior of
<code data-lang="pyret" class="sourceCode">is</code>.  Normally, it would compare the left and right values for equality.
If something is provided with <code data-lang="pyret" class="sourceCode">%</code>, however, it instead passes the left
and right values to the provided function (in this example <code data-lang="pyret" class="sourceCode">around</code>).  If
the provided function produces <code data-lang="pyret" class="sourceCode">true</code>, the test passes, if it produces
<code data-lang="pyret" class="sourceCode">false</code>, the test fails.  This gives us the control we need to test
functions with predictable approximate results.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Extend the definition of <code data-lang="pyret" class="sourceCode">distance-to-origin</code> to include
<code data-lang="pyret" class="sourceCode">polar</code> points.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>This might save you a Google search:
<a href="http://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates">polar
conversions</a>.
Use the design recipe to write <code data-lang="pyret" class="sourceCode">x-component</code> and
<code data-lang="pyret" class="sourceCode">y-component</code>, which return the <code data-lang="pyret" class="sourceCode">x</code> and <code data-lang="pyret" class="sourceCode">y</code> Cartesian parts
of the point (which you would need, for example, if you were plotting them on a graph).
Read about <code data-lang="pyret" class="sourceCode">num-sin</code> and other functions you‚Äôll need at
<a href="http://www.pyret.org/docs/latest/numbers.html">the Pyret number
documentation</a>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p> Write a data definition called <code data-lang="pyret" class="sourceCode">Pay</code> for pay types that includes
both hourly employees, whose pay type includes an hourly rate, and salaried
employees, whose pay type includes a total salary for the year.  Use the design
recipe to write a function called <code data-lang="pyret" class="sourceCode">expected-weekly-wages</code> that takes a
<code data-lang="pyret" class="sourceCode">Pay</code>, and returns the expected weekly salary: the expected weekly salary
for an hourly employee assumes they work 40 hours, and the expected weekly
salary for a salaried employee is 1/52 of their salary.</p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 8.3.3"><h4 class="heading">8.3.3¬†<a name="(part._.When_.Tests_.Fail)"/>When Tests Fail<a href="#(part._.When_.Tests_.Fail)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Suppose we‚Äôve written the function <code data-lang="pyret" class="sourceCode">sqrt</code>, which computes the
square root of a given number. We‚Äôve written some tests for this
function. We run the program, and find that a test fails. There are
two obvious reasons why this can happen.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What are the two obvious reasons?</p></blockquote></blockquote><p>The two reasons are, of course, the two ‚Äúsides‚Äù of the test: the
problem could be with the values we‚Äôve written or with the function
we‚Äôve written. For instance, if we‚Äôve written
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt(4) is 1.75</code></pre><p>then the fault clearly lies with the values (because \(1.75^2\) is
clearly not \(4\)). On the other hand, if it fails the test
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt(4) is 2</code></pre><p>then the odds are that we‚Äôve made an error in the definition of
<code data-lang="pyret" class="sourceCode">sqrt</code> instead, and that‚Äôs what we need to fix.</p><p>Note that there is no way for the computer to tell what went
wrong. When it reports a test failure, all it‚Äôs saying is that there
is an inconsistency between the program and the tests. The
computer is not passing judgment on which one is ‚Äúcorrect‚Äù, because
it can‚Äôt do that. That is a matter for human
judgment.For this reason, we‚Äôve been doing research on
<a href="http://cs.brown.edu/~sk/Publications/Papers/Published/pkf-ifpr-tests-tf-prog/">peer review of tests</a>, so students can help one another review their
tests before they begin writing programs.</p><p>Actually...not so fast. There‚Äôs one more possibility we didn‚Äôt
consider: the third, not-so-obvious reason why a test might
fail. Return to this test:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt(4) is 2</code></pre><p>Clearly the inputs and outputs are correct, but it could be that the
definition of <code data-lang="pyret" class="sourceCode">sqrt</code> is also correct, and yet the test
fails.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Do you see why?</p></blockquote></blockquote><p>Depending on how we‚Äôve programmed <code data-lang="pyret" class="sourceCode">sqrt</code>, it might return the
root <code data-lang="pyret" class="sourceCode">-2</code> instead of <code data-lang="pyret" class="sourceCode">2</code>. Now <code data-lang="pyret" class="sourceCode">-2</code> is a perfectly good
answer, too. That is, neither the function nor the particular set of
test values we specified is inherently wrong; it‚Äôs just that the
function happens to be a relation, i.e., it maps one input to
multiple outputs (that is, \(\sqrt{4} = \pm 2\)). The question now is
how to write the test properly.</p></section><section class="SsectionLevel4" id="section 8.3.4"><h4 class="heading">8.3.4¬†<a name="(part._test-oracle)"/>Oracles for Testing<a href="#(part._test-oracle)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>In other words, sometimes what we want to express is not a concrete
input-output pair, but rather check that the output has the right
relationship to the input. Concretely, what might this be in
the case of <code data-lang="pyret" class="sourceCode">sqrt</code>? We hinted at this earlier when we said that
<code data-lang="pyret" class="sourceCode">1.75</code> clearly can‚Äôt be right, because squaring it does not yield
<code data-lang="pyret" class="sourceCode">4</code>. That gives us the general insight: that a number is a valid
root (note the use of ‚Äúa‚Äù instead of ‚Äúthe‚Äù) if squaring it yields
the original number. That is, we might write a function like this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun is-sqrt(n):
  n-root = sqrt(n)
  n == (n-root * n-root)
end</code></pre><p>and then our test looks like
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  is-sqrt(4) is true
end</code></pre><p>Unfortunately, this has an awkward failure case. If <code data-lang="pyret" class="sourceCode">sqrt</code> does
not produce a number that is in fact a root, we aren‚Äôt told what the
actual value is; instead, <code data-lang="pyret" class="sourceCode">is-sqrt</code> returns false, and the test
failure just says that <code data-lang="pyret" class="sourceCode">false</code> (what <code data-lang="pyret" class="sourceCode">is-sqrt</code> returns) is
not <code data-lang="pyret" class="sourceCode">true</code> (what the test expects)‚Äî<wbr/>which is both absolutely
true and utterly useless.</p><p>Fortunately, Pyret has a better way of expressing the same
check. Instead of <code data-lang="pyret" class="sourceCode">is</code>, we can write <code data-lang="pyret" class="sourceCode">satisfies</code>, and then
the value on the left must satisfy the predicate on the
right. Concretely, this looks like:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun check-sqrt(n):
  lam(n-root):
    n == (n-root * n-root)
  end
end</code></pre><p>which lets us write:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  sqrt(4) satisfies check-sqrt(4)
end</code></pre><p>Now, if there‚Äôs a failure, we learn of the actual value produced by
<code data-lang="pyret" class="sourceCode">sqrt(4)</code> that failed to satisfy the predicate.</p></section>&#13;
<h4 class="heading">8.3.1¬†<a name="(part._from-examples-to-tests)"/>From Examples to Tests<a href="#(part._from-examples-to-tests)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Until now, we have written examples in <code data-lang="pyret" class="sourceCode">where:</code> blocks for two
purposes: to help us figure out what a function needs to do, and to
provide guidance to someone reading our code as to what behavior they can
expect when using our function. For the smaller programs that we have
written until now, <code data-lang="pyret" class="sourceCode">where</code>-based examples have been
sufficient. As our programs get more complicated, however, a small set
of related illustrative examples won‚Äôt suffice. We need to think about being
much more thorough in the sets of inputs that we consider.</p><p>Consider for example a function <code data-lang="pyret" class="sourceCode">count-uses</code> that counts how many
times a specific string appears in a list (this could be used to tally
votes, to compute the frequency of using a discount code, and so
on). What input scenarios might we need to check before using our
function to run an actual election or a business?</p><ul><li><p>The result for a string that is in the list once</p></li><li><p>The result for a string that is in the list multiple times</p></li><li><p>The result for a string that is at the end of a longer list (to make
sure we are checking all of the elements)</p></li><li><p>The result for a string that isn‚Äôt in the list</p></li><li><p>The result for a string that is in the list but with different capitalization</p></li><li><p>The result for a string that is a typo-away from a word in the list</p></li></ul><p>Notice that here we are considering many more situations, including
fairly nuanced ones that affect how robust our code would be under
realistic situations. Once we start considering situations like these,
we are shifting from examples to illustrate our code to
tests to thoroughly test our code.</p><p>In Pyret, we use <code data-lang="pyret" class="sourceCode">where</code> blocks inside function definitions for
examples. We use a <code data-lang="pyret" class="sourceCode">check</code> block outside the function definition
for tests. For example:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun count-uses(of-string :: String, in-list :: List&lt;String&gt;) -&gt; Number:
  ...
where:
  count-uses("pepper", [list:]) is 0
  count-uses("pepper", [list: "onion"]) is 0
  count-uses("pepper", [list: "pepper", "onion"]) is 1
  count-uses("pepper", [list: "pepper", "pepper", "onion"]) is 2
end

check:
  count-uses("ppper", [list: "pepper"]) is 0
  count-uses("ONION", [list: "pepper", "onion"]) is 1
  count-uses("tomato",
    [list: "pepper", "onion", "onion", "pepper", "tomato",
      "tomato", "onion", "tomato"])
    is 3
  ...
end</code></pre><p>As a guiding rule, we put illustrative cases that would help someone
else reading our code into the <code data-lang="pyret" class="sourceCode">where</code> block, while we put the
nitty-gritty checks that our code handles the wider range of usage
scenarios (including error cases) into the <code data-lang="pyret" class="sourceCode">check</code>. Sometimes,
the line between these two isn‚Äôt clear: for example, one could easily
argue that the second test (the function handles different
capitalization) belongs in <code data-lang="pyret" class="sourceCode">where</code> instead. The third test about
using a really long list would remain in <code data-lang="pyret" class="sourceCode">check</code>, however, as
longer inputs are generally not instructive to a reader of your code.</p><p>Putting tests in a block that lives outside the function has another
advantage at the level of professional programming: it allows your
tests to live in a separate file from your code. This has two key
benefits. First, it makes it easier for someone to read the essential parts
of your code (if they are building on your work). Second, it makes it
easier to control when tests are run. When your <code data-lang="pyret" class="sourceCode">check</code> blocks
are in the same file as your code, all the tests will be checked when
you run your code. When they are in a different file, an organization
can choose when to run the tests. During development, tests are run
frequently to make sure no errors have been introduced. Once code is
tested and ready to be deployed or used, tests are not run along with
the program (unless there has been a modification or someone has
discovered an error with the code). This is standard practice in software projects.</p><p>It is also worth noting that the collection of tests grows throughout
the development process, moreso than do the collection of examples. As
you are developing code, every time you find a bug in your code,
add a test for it in your <code data-lang="pyret" class="sourceCode">check</code> block so you don‚Äôt accidentally
introduce that same error again later. Whereas we develop
examples up front as we figure out what we want our program to do, we
augment our tests as we discover what our program actually does (and
perhaps should not do). In practice, developers write an
initial set of checks on the scenarios they thought of before and
while writing the code, then expand those tests as they try out more
scenarios and gain users who report scenarios where the code does not
work.</p><p>Nearly all programming languages come with some constructs or packages
in which you can write tests in separate files. Pyret is unique in
supporting the distinction between examples and tests (both for
learning and for readability of code by others). Many programming
tools that support professionals expect you to put all tests in
separate folders and files (offering no support for examples). In this
book, we emphasize the difference between these two uses of
input-output pairs in programming because we find them extremely
useful both professionally and pedagogically.</p>&#13;
<h4 class="heading">8.3.2¬†<a name="(part._s~3arefined)"/>More Refined Comparisons<a href="#(part._s~3arefined)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Sometimes, a direct comparison via <code data-lang="pyret" class="sourceCode">is</code> isn‚Äôt enough for
testing. We have already seen this in the case of <code data-lang="pyret" class="sourceCode">raises</code>
tests (<a href="trees.html#%28part._compute-parents-table%29" data-pltdoc="x">Computing Genetic Parents from an Ancestry Table</a>). As another example, when doing
some computations, especially involving math with approximations, the
exact match of <code data-lang="pyret" class="sourceCode">is</code> isn‚Äôt feasible. For example, consider these tests for <code data-lang="pyret" class="sourceCode">distance-to-origin</code>:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  distance-to-origin(point(1, 1)) is ???
end</code></pre><p>What can we check here?  Typing this into the REPL, we can find that the answer
prints as <code data-lang="pyret" class="sourceCode">1.4142135623730951</code>.  That‚Äôs an approximation of the real
answer, which Pyret cannot represent exactly.  But it‚Äôs hard to know that this
precise answer, to this decimal place, and no more, is the one we should expect
up front, and thinking through the answers is supposed to be the first thing we
do!</p><p>Since we know we‚Äôre getting an approximation, we can really only check that the
answer is roughly correct, not exactly correct.  If we can check that
the answer to <code data-lang="pyret" class="sourceCode">distance-to-origin(point(1, 1))</code> is around, say,
<code data-lang="pyret" class="sourceCode">1.41</code>, and can do the same for some similar cases, that‚Äôs probably good
enough for many applications, and for our purposes here.  If we were
calculating orbital dynamics, we might demand higher precision, but note that
we‚Äôd still need to pick a cutoff!  Testing for inexact results is a necessary
task.</p><p>Let‚Äôs first define what we mean by ‚Äúaround‚Äù with one of the most precise ways
we can, a function:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun around(actual :: Number, expected :: Number) -&gt; Boolean:
  doc: "Return whether actual is within 0.01 of expected"
  num-abs(actual - expected) &lt; 0.01
where:
  around(5, 5.01) is true
  around(5.01, 5) is true
  around(5.02, 5) is false
  around(num-sqrt(2), 1.41) is true
end</code></pre><p>The <code data-lang="pyret" class="sourceCode">is</code> form now helps us out.  There is special syntax for supplying a
user-defined function to use to compare the two values, instead of just
checking if they are equal:</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  5 is%(around) 5.01
  num-sqrt(2) is%(around) 1.41
  distance-to-origin(point(1, 1)) is%(around) 1.41
end</code></pre><p>Adding <code data-lang="pyret" class="sourceCode">%(something)</code> after <code data-lang="pyret" class="sourceCode">is</code> changes the behavior of
<code data-lang="pyret" class="sourceCode">is</code>.  Normally, it would compare the left and right values for equality.
If something is provided with <code data-lang="pyret" class="sourceCode">%</code>, however, it instead passes the left
and right values to the provided function (in this example <code data-lang="pyret" class="sourceCode">around</code>).  If
the provided function produces <code data-lang="pyret" class="sourceCode">true</code>, the test passes, if it produces
<code data-lang="pyret" class="sourceCode">false</code>, the test fails.  This gives us the control we need to test
functions with predictable approximate results.</p><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>Extend the definition of <code data-lang="pyret" class="sourceCode">distance-to-origin</code> to include
<code data-lang="pyret" class="sourceCode">polar</code> points.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p>This might save you a Google search:
<a href="http://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates">polar
conversions</a>.
Use the design recipe to write <code data-lang="pyret" class="sourceCode">x-component</code> and
<code data-lang="pyret" class="sourceCode">y-component</code>, which return the <code data-lang="pyret" class="sourceCode">x</code> and <code data-lang="pyret" class="sourceCode">y</code> Cartesian parts
of the point (which you would need, for example, if you were plotting them on a graph).
Read about <code data-lang="pyret" class="sourceCode">num-sin</code> and other functions you‚Äôll need at
<a href="http://www.pyret.org/docs/latest/numbers.html">the Pyret number
documentation</a>.</p></blockquote></blockquote><blockquote class="Exercise"><p class="ExerciseHeader">Exercise</p><blockquote class="ExerciseBody"><p> Write a data definition called <code data-lang="pyret" class="sourceCode">Pay</code> for pay types that includes
both hourly employees, whose pay type includes an hourly rate, and salaried
employees, whose pay type includes a total salary for the year.  Use the design
recipe to write a function called <code data-lang="pyret" class="sourceCode">expected-weekly-wages</code> that takes a
<code data-lang="pyret" class="sourceCode">Pay</code>, and returns the expected weekly salary: the expected weekly salary
for an hourly employee assumes they work 40 hours, and the expected weekly
salary for a salaried employee is 1/52 of their salary.</p></blockquote></blockquote>&#13;
<h4 class="heading">8.3.3¬†<a name="(part._.When_.Tests_.Fail)"/>When Tests Fail<a href="#(part._.When_.Tests_.Fail)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>Suppose we‚Äôve written the function <code data-lang="pyret" class="sourceCode">sqrt</code>, which computes the
square root of a given number. We‚Äôve written some tests for this
function. We run the program, and find that a test fails. There are
two obvious reasons why this can happen.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>What are the two obvious reasons?</p></blockquote></blockquote><p>The two reasons are, of course, the two ‚Äúsides‚Äù of the test: the
problem could be with the values we‚Äôve written or with the function
we‚Äôve written. For instance, if we‚Äôve written
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt(4) is 1.75</code></pre><p>then the fault clearly lies with the values (because \(1.75^2\) is
clearly not \(4\)). On the other hand, if it fails the test
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt(4) is 2</code></pre><p>then the odds are that we‚Äôve made an error in the definition of
<code data-lang="pyret" class="sourceCode">sqrt</code> instead, and that‚Äôs what we need to fix.</p><p>Note that there is no way for the computer to tell what went
wrong. When it reports a test failure, all it‚Äôs saying is that there
is an inconsistency between the program and the tests. The
computer is not passing judgment on which one is ‚Äúcorrect‚Äù, because
it can‚Äôt do that. That is a matter for human
judgment.For this reason, we‚Äôve been doing research on
<a href="http://cs.brown.edu/~sk/Publications/Papers/Published/pkf-ifpr-tests-tf-prog/">peer review of tests</a>, so students can help one another review their
tests before they begin writing programs.</p><p>Actually...not so fast. There‚Äôs one more possibility we didn‚Äôt
consider: the third, not-so-obvious reason why a test might
fail. Return to this test:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">sqrt(4) is 2</code></pre><p>Clearly the inputs and outputs are correct, but it could be that the
definition of <code data-lang="pyret" class="sourceCode">sqrt</code> is also correct, and yet the test
fails.</p><blockquote class="Incercise"><p class="IncerciseHeader">Do Now!</p><blockquote class="IncerciseBody"><p>Do you see why?</p></blockquote></blockquote><p>Depending on how we‚Äôve programmed <code data-lang="pyret" class="sourceCode">sqrt</code>, it might return the
root <code data-lang="pyret" class="sourceCode">-2</code> instead of <code data-lang="pyret" class="sourceCode">2</code>. Now <code data-lang="pyret" class="sourceCode">-2</code> is a perfectly good
answer, too. That is, neither the function nor the particular set of
test values we specified is inherently wrong; it‚Äôs just that the
function happens to be a relation, i.e., it maps one input to
multiple outputs (that is, \(\sqrt{4} = \pm 2\)). The question now is
how to write the test properly.</p>&#13;
<h4 class="heading">8.3.4¬†<a name="(part._test-oracle)"/>Oracles for Testing<a href="#(part._test-oracle)" class="heading-anchor" title="Link to here">üîó</a> </h4><p>In other words, sometimes what we want to express is not a concrete
input-output pair, but rather check that the output has the right
relationship to the input. Concretely, what might this be in
the case of <code data-lang="pyret" class="sourceCode">sqrt</code>? We hinted at this earlier when we said that
<code data-lang="pyret" class="sourceCode">1.75</code> clearly can‚Äôt be right, because squaring it does not yield
<code data-lang="pyret" class="sourceCode">4</code>. That gives us the general insight: that a number is a valid
root (note the use of ‚Äúa‚Äù instead of ‚Äúthe‚Äù) if squaring it yields
the original number. That is, we might write a function like this:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun is-sqrt(n):
  n-root = sqrt(n)
  n == (n-root * n-root)
end</code></pre><p>and then our test looks like
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  is-sqrt(4) is true
end</code></pre><p>Unfortunately, this has an awkward failure case. If <code data-lang="pyret" class="sourceCode">sqrt</code> does
not produce a number that is in fact a root, we aren‚Äôt told what the
actual value is; instead, <code data-lang="pyret" class="sourceCode">is-sqrt</code> returns false, and the test
failure just says that <code data-lang="pyret" class="sourceCode">false</code> (what <code data-lang="pyret" class="sourceCode">is-sqrt</code> returns) is
not <code data-lang="pyret" class="sourceCode">true</code> (what the test expects)‚Äî<wbr/>which is both absolutely
true and utterly useless.</p><p>Fortunately, Pyret has a better way of expressing the same
check. Instead of <code data-lang="pyret" class="sourceCode">is</code>, we can write <code data-lang="pyret" class="sourceCode">satisfies</code>, and then
the value on the left must satisfy the predicate on the
right. Concretely, this looks like:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">fun check-sqrt(n):
  lam(n-root):
    n == (n-root * n-root)
  end
end</code></pre><p>which lets us write:
</p><pre data-lang="pyret" class="sourceCode"><code data-lang="pyret" class="sourceCode">check:
  sqrt(4) satisfies check-sqrt(4)
end</code></pre><p>Now, if there‚Äôs a failure, we learn of the actual value produced by
<code data-lang="pyret" class="sourceCode">sqrt(4)</code> that failed to satisfy the predicate.</p>    
</body>
</html>