["```py\nimport numpy as np\n\ngravity = [0.0, -9.81]\n\ndef val(x, m):\n    sum = 0.0\n    for i in range(0, len(x)):\n        sum += -m[i] * x[i].dot(gravity)\n    return sum\n\ndef grad(x, m):\n    g = np.array([gravity] * len(x))\n    for i in range(0, len(x)):\n        g[i] *= -m[i]\n    return g\n\n# Hessian is 0 \n```", "```py\ndef IP_val(x, e, x_tilde, m, l2, k, h):\n    return InertiaEnergy.val(x, x_tilde, m) + h * h * (MassSpringEnergy.val(x, e, l2, k) + GravityEnergy.val(x, m))     # implicit Euler\n\ndef IP_grad(x, e, x_tilde, m, l2, k, h):\n    return InertiaEnergy.grad(x, x_tilde, m) + h * h * (MassSpringEnergy.grad(x, e, l2, k) + GravityEnergy.grad(x, m))   # implicit Euler \n```", "```py\ndef search_dir(x, e, x_tilde, m, l2, k, is_DBC, h):\n    projected_hess = IP_hess(x, e, x_tilde, m, l2, k, h)\n    reshaped_grad = IP_grad(x, e, x_tilde, m, l2, k, h).reshape(len(x) * 2, 1)\n    # eliminate DOF by modifying gradient and Hessian for DBC:\n    for i, j in zip(*projected_hess.nonzero()):\n        if is_DBC[int(i / 2)] | is_DBC[int(j / 2)]: \n            projected_hess[i, j] = (i == j)\n    for i in range(0, len(x)):\n        if is_DBC[i]:\n            reshaped_grad[i * 2] = reshaped_grad[i * 2 + 1] = 0.0\n    return spsolve(projected_hess, -reshaped_grad).reshape(len(x), 2) \n```", "```py\nDBC = [n_seg, (n_seg + 1) * (n_seg + 1) - 1]  # fix the left and right top nodes\n\n# ...\n\n# identify whether a node is Dirichlet\nis_DBC = [False] * len(x)\nfor i in DBC:\n    is_DBC[i] = True \n```"]