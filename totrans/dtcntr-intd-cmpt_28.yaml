- en: 9.3Â ArraysðŸ”—
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŽŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/arrays.html](https://dcic-world.org/2025-08-27/arrays.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Â Â Â Â [9.3.1Â Two Memory Layouts for Ordered Items](#%28part._.Two_.Memory_.Layouts_for_.Ordered_.Items%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [9.3.2Â Iterating Partly through an Ordered Datum](#%28part._.Iterating_.Partly_through_an_.Ordered_.Datum%29)
    |'
  prefs: []
  type: TYPE_TB
- en: 'We ended the last chapter with a question about how fast one can access a specific
    element of a list. Specifically, if you have a list called finishers of Runners
    (our example from last time) and you write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How long does it take to locate the Runner in 10th place (remember, indices
    start at 0)?
  prefs: []
  type: TYPE_NORMAL
- en: It depends on how the list is laid out in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.1Â Two Memory Layouts for Ordered Items[ðŸ”—](#(part._.Two_.Memory_.Layouts_for_.Ordered_.Items)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we say "list", we usually mean simply: a collection of items with order.
    How might a collection of ordered items be arranged in memory? Here are two examples,
    using a list of course names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first version, the elements are laid out in consecutive memory locations
    (this is rougly how weâ€™ve shown lists up to now):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Prog DirectoryÂ Â Â Â Â Â Â Â Â Â Â Memory |'
  prefs: []
  type: TYPE_TB
- en: '| -------------------------------------------------------------------- |'
  prefs: []
  type: TYPE_TB
- en: '| courses --> loc 1001Â Â Â Â Â Â loc 1001 --> [loc 1002, loc1003, loc 1004] |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1002 --> "CS111" |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1003 --> "ENGN90" |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1004 --> "VISA100" |'
  prefs: []
  type: TYPE_TB
- en: In the second version, each element is captured as a datatype containing the
    element and the next list location. When we were in Pyret, this datatype was called
    `link`.
  prefs: []
  type: TYPE_NORMAL
- en: '| Prog DirectoryÂ Â Â Â Â Â Â Â Â Â Â Memory |'
  prefs: []
  type: TYPE_TB
- en: '| -------------------------------------------------------------------- |'
  prefs: []
  type: TYPE_TB
- en: '| courses --> loc 1001Â Â Â Â Â Â loc 1001 --> link("CS111", loc 1002) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1002 --> link("ENGN90", loc 1003) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1003 --> link("VISA100", loc 1004) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1004 --> empty |'
  prefs: []
  type: TYPE_TB
- en: What are the tradeoffs between the two versions? In the first, we can access
    items by index in constant time, as we could for hashtables, but changing the
    contents (adding or deleting) requires moving things around in memory. In the
    second, the size of the collection can grow or shrink arbitrarily, but it takes
    time proportional to the index to look up a specific value. Each organization
    has its place in some programs.
  prefs: []
  type: TYPE_NORMAL
- en: In data structures terms, the first organization is called an array. The second
    is called a linked list. Pyret implements linked lists, with arrays being a separate
    data type (with a different notation from lists). Python implements lists as arrays.
    When you approach a new programming language, you need to look up whether its
    lists are linked lists or arrays if you care about the run-time performance of
    the underlying operations.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to our Runners discussion from the last chapter, we can simply use
    Python lists (arrays) rather than a hashtable, and be able to access the names
    of Runners who finished in particular positions. But letâ€™s instead ask a different
    question.
  prefs: []
  type: TYPE_NORMAL
- en: 'How would we report the top finishers in each age category? In particular,
    we want to write a function such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Think about how you would write this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s our solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, rather than return only when we get to the end of the list, we want to
    return once we have five runners in the list. So we set up an additional variable
    (`in_range`) to help us track progress of the computation. Once we have gotten
    to 5 runners, we return the list. If we never get to 5 runners, we print a warning
    to the user then return the results that we do have.
  prefs: []
  type: TYPE_NORMAL
- en: Couldnâ€™t we have just looked at the length of the list, rather than maintain
    the `in_range` variable? Yes, we could have, though this version sets up a contrast
    to our next example.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.2Â Iterating Partly through an Ordered Datum[ðŸ”—](#(part._.Iterating_.Partly_through_an_.Ordered_.Datum)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What if instead we just wanted to print out the top 5 finishers, rather than
    gather a list? While in general it is usually better to separate computing and
    displaying data, in practice we do sometimes merge them, or do other operations
    (like write some data to file) which wonâ€™t return anything. How do we modify the
    code to print the names rather than build up a list of the runners?
  prefs: []
  type: TYPE_NORMAL
- en: The challenge here is how to stop the computation. When we are building up a
    list, we stop a computation using return. But if our code isnâ€™t returning, or
    otherwise needs to stop a loop before it reaches the end of the data, what do
    we do?
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a command called `break`, which says to terminate the loop and continue
    the rest of the computation. Here, the break is in place of the inner return statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If Python reaches the `break` statement, it terminates the for loop and goes
    to the next statement, which is the print at the end of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.1Â Two Memory Layouts for Ordered Items[ðŸ”—](#(part._.Two_.Memory_.Layouts_for_.Ordered_.Items)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we say "list", we usually mean simply: a collection of items with order.
    How might a collection of ordered items be arranged in memory? Here are two examples,
    using a list of course names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first version, the elements are laid out in consecutive memory locations
    (this is rougly how weâ€™ve shown lists up to now):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Prog DirectoryÂ Â Â Â Â Â Â Â Â Â Â Memory |'
  prefs: []
  type: TYPE_TB
- en: '| -------------------------------------------------------------------- |'
  prefs: []
  type: TYPE_TB
- en: '| courses --> loc 1001Â Â Â Â Â Â loc 1001 --> [loc 1002, loc1003, loc 1004] |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1002 --> "CS111" |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1003 --> "ENGN90" |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1004 --> "VISA100" |'
  prefs: []
  type: TYPE_TB
- en: In the second version, each element is captured as a datatype containing the
    element and the next list location. When we were in Pyret, this datatype was called
    `link`.
  prefs: []
  type: TYPE_NORMAL
- en: '| Prog DirectoryÂ Â Â Â Â Â Â Â Â Â Â Memory |'
  prefs: []
  type: TYPE_TB
- en: '| -------------------------------------------------------------------- |'
  prefs: []
  type: TYPE_TB
- en: '| courses --> loc 1001Â Â Â Â Â Â loc 1001 --> link("CS111", loc 1002) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1002 --> link("ENGN90", loc 1003) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1003 --> link("VISA100", loc 1004) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1004 --> empty |'
  prefs: []
  type: TYPE_TB
- en: What are the tradeoffs between the two versions? In the first, we can access
    items by index in constant time, as we could for hashtables, but changing the
    contents (adding or deleting) requires moving things around in memory. In the
    second, the size of the collection can grow or shrink arbitrarily, but it takes
    time proportional to the index to look up a specific value. Each organization
    has its place in some programs.
  prefs: []
  type: TYPE_NORMAL
- en: In data structures terms, the first organization is called an array. The second
    is called a linked list. Pyret implements linked lists, with arrays being a separate
    data type (with a different notation from lists). Python implements lists as arrays.
    When you approach a new programming language, you need to look up whether its
    lists are linked lists or arrays if you care about the run-time performance of
    the underlying operations.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to our Runners discussion from the last chapter, we can simply use
    Python lists (arrays) rather than a hashtable, and be able to access the names
    of Runners who finished in particular positions. But letâ€™s instead ask a different
    question.
  prefs: []
  type: TYPE_NORMAL
- en: 'How would we report the top finishers in each age category? In particular,
    we want to write a function such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Think about how you would write this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s our solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, rather than return only when we get to the end of the list, we want to
    return once we have five runners in the list. So we set up an additional variable
    (`in_range`) to help us track progress of the computation. Once we have gotten
    to 5 runners, we return the list. If we never get to 5 runners, we print a warning
    to the user then return the results that we do have.
  prefs: []
  type: TYPE_NORMAL
- en: Couldnâ€™t we have just looked at the length of the list, rather than maintain
    the `in_range` variable? Yes, we could have, though this version sets up a contrast
    to our next example.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.2Â Iterating Partly through an Ordered Datum[ðŸ”—](#(part._.Iterating_.Partly_through_an_.Ordered_.Datum)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What if instead we just wanted to print out the top 5 finishers, rather than
    gather a list? While in general it is usually better to separate computing and
    displaying data, in practice we do sometimes merge them, or do other operations
    (like write some data to file) which wonâ€™t return anything. How do we modify the
    code to print the names rather than build up a list of the runners?
  prefs: []
  type: TYPE_NORMAL
- en: The challenge here is how to stop the computation. When we are building up a
    list, we stop a computation using return. But if our code isnâ€™t returning, or
    otherwise needs to stop a loop before it reaches the end of the data, what do
    we do?
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a command called `break`, which says to terminate the loop and continue
    the rest of the computation. Here, the break is in place of the inner return statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If Python reaches the `break` statement, it terminates the for loop and goes
    to the next statement, which is the print at the end of the function.
  prefs: []
  type: TYPE_NORMAL
