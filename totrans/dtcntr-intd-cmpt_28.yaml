- en: 9.3Â ArraysğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/arrays.html](https://dcic-world.org/2025-08-27/arrays.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Â Â Â Â [9.3.1Â Two Memory Layouts for Ordered Items](#%28part._.Two_.Memory_.Layouts_for_.Ordered_.Items%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [9.3.2Â Iterating Partly through an Ordered Datum](#%28part._.Iterating_.Partly_through_an_.Ordered_.Datum%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
- en: 'We ended the last chapter with a question about how fast one can access a specific
    element of a list. Specifically, if you have a list called finishers of Runners
    (our example from last time) and you write:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How long does it take to locate the Runner in 10th place (remember, indices
    start at 0)?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: It depends on how the list is laid out in memory.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.1Â Two Memory Layouts for Ordered Items[ğŸ”—](#(part._.Two_.Memory_.Layouts_for_.Ordered_.Items)
    "Link to here")
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we say "list", we usually mean simply: a collection of items with order.
    How might a collection of ordered items be arranged in memory? Here are two examples,
    using a list of course names:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the first version, the elements are laid out in consecutive memory locations
    (this is rougly how weâ€™ve shown lists up to now):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '| Prog DirectoryÂ Â Â Â Â Â Â Â Â Â Â Memory |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
- en: '| -------------------------------------------------------------------- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: '| courses --> loc 1001Â Â Â Â Â Â loc 1001 --> [loc 1002, loc1003, loc 1004] |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1002 --> "CS111" |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1003 --> "ENGN90" |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1004 --> "VISA100" |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: In the second version, each element is captured as a datatype containing the
    element and the next list location. When we were in Pyret, this datatype was called
    `link`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '| Prog DirectoryÂ Â Â Â Â Â Â Â Â Â Â Memory |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| -------------------------------------------------------------------- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| courses --> loc 1001Â Â Â Â Â Â loc 1001 --> link("CS111", loc 1002) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1002 --> link("ENGN90", loc 1003) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1003 --> link("VISA100", loc 1004) |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1004 --> empty |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: What are the tradeoffs between the two versions? In the first, we can access
    items by index in constant time, as we could for hashtables, but changing the
    contents (adding or deleting) requires moving things around in memory. In the
    second, the size of the collection can grow or shrink arbitrarily, but it takes
    time proportional to the index to look up a specific value. Each organization
    has its place in some programs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: In data structures terms, the first organization is called an array. The second
    is called a linked list. Pyret implements linked lists, with arrays being a separate
    data type (with a different notation from lists). Python implements lists as arrays.
    When you approach a new programming language, you need to look up whether its
    lists are linked lists or arrays if you care about the run-time performance of
    the underlying operations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Going back to our Runners discussion from the last chapter, we can simply use
    Python lists (arrays) rather than a hashtable, and be able to access the names
    of Runners who finished in particular positions. But letâ€™s instead ask a different
    question.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'How would we report the top finishers in each age category? In particular,
    we want to write a function such as the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Think about how you would write this code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s our solution:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, rather than return only when we get to the end of the list, we want to
    return once we have five runners in the list. So we set up an additional variable
    (`in_range`) to help us track progress of the computation. Once we have gotten
    to 5 runners, we return the list. If we never get to 5 runners, we print a warning
    to the user then return the results that we do have.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Couldnâ€™t we have just looked at the length of the list, rather than maintain
    the `in_range` variable? Yes, we could have, though this version sets up a contrast
    to our next example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.2Â Iterating Partly through an Ordered Datum[ğŸ”—](#(part._.Iterating_.Partly_through_an_.Ordered_.Datum)
    "Link to here")
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What if instead we just wanted to print out the top 5 finishers, rather than
    gather a list? While in general it is usually better to separate computing and
    displaying data, in practice we do sometimes merge them, or do other operations
    (like write some data to file) which wonâ€™t return anything. How do we modify the
    code to print the names rather than build up a list of the runners?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The challenge here is how to stop the computation. When we are building up a
    list, we stop a computation using return. But if our code isnâ€™t returning, or
    otherwise needs to stop a loop before it reaches the end of the data, what do
    we do?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a command called `break`, which says to terminate the loop and continue
    the rest of the computation. Here, the break is in place of the inner return statement:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If Python reaches the `break` statement, it terminates the for loop and goes
    to the next statement, which is the print at the end of the function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.1Â Two Memory Layouts for Ordered Items[ğŸ”—](#(part._.Two_.Memory_.Layouts_for_.Ordered_.Items)
    "Link to here")
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we say "list", we usually mean simply: a collection of items with order.
    How might a collection of ordered items be arranged in memory? Here are two examples,
    using a list of course names:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the first version, the elements are laid out in consecutive memory locations
    (this is rougly how weâ€™ve shown lists up to now):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '| Prog DirectoryÂ Â Â Â Â Â Â Â Â Â Â Memory |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| -------------------------------------------------------------------- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| courses --> loc 1001Â Â Â Â Â Â loc 1001 --> [loc 1002, loc1003, loc 1004] |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1002 --> "CS111" |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1003 --> "ENGN90" |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1004 --> "VISA100" |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: In the second version, each element is captured as a datatype containing the
    element and the next list location. When we were in Pyret, this datatype was called
    `link`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '| Prog DirectoryÂ Â Â Â Â Â Â Â Â Â Â Memory |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| ç¨‹åºç›®å½•Â Â Â Â Â Â Â Â Â Â Â å†…å­˜ |'
- en: '| -------------------------------------------------------------------- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| -------------------------------------------------------------------- |'
- en: '| courses --> loc 1001Â Â Â Â Â Â loc 1001 --> link("CS111", loc 1002) |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| courses --> loc 1001Â Â Â Â Â loc 1001 --> é“¾æ¥("CS111", loc 1002) |'
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1002 --> link("ENGN90", loc 1003) |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1002 --> é“¾æ¥("ENGN90", loc 1003) |'
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1003 --> link("VISA100", loc 1004) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1003 --> é“¾æ¥("VISA100", loc 1004) |'
- en: '| Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1004 --> empty |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â loc 1004 --> ç©ºå€¼ |'
- en: What are the tradeoffs between the two versions? In the first, we can access
    items by index in constant time, as we could for hashtables, but changing the
    contents (adding or deleting) requires moving things around in memory. In the
    second, the size of the collection can grow or shrink arbitrarily, but it takes
    time proportional to the index to look up a specific value. Each organization
    has its place in some programs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸¤ç§ç‰ˆæœ¬ä¹‹é—´çš„æƒè¡¡æ˜¯ä»€ä¹ˆï¼Ÿåœ¨ç¬¬ä¸€ç§ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥å¸¸æ•°æ—¶é—´é€šè¿‡ç´¢å¼•è®¿é—®é¡¹ç›®ï¼Œå°±åƒæ•£åˆ—è¡¨ä¸€æ ·ï¼Œä½†æ›´æ”¹å†…å®¹ï¼ˆæ·»åŠ æˆ–åˆ é™¤ï¼‰éœ€è¦ç§»åŠ¨å†…å­˜ä¸­çš„å†…å®¹ã€‚åœ¨ç¬¬äºŒç§ä¸­ï¼Œé›†åˆçš„å¤§å°å¯ä»¥ä»»æ„å¢é•¿æˆ–ç¼©å°ï¼Œä½†æŸ¥æ‰¾ç‰¹å®šå€¼éœ€è¦ä¸ç´¢å¼•æˆæ¯”ä¾‹çš„æ—¶é—´ã€‚æ¯ä¸ªç»„ç»‡åœ¨å…¶æŸäº›ç¨‹åºä¸­éƒ½æœ‰å…¶ä½ç½®ã€‚
- en: In data structures terms, the first organization is called an array. The second
    is called a linked list. Pyret implements linked lists, with arrays being a separate
    data type (with a different notation from lists). Python implements lists as arrays.
    When you approach a new programming language, you need to look up whether its
    lists are linked lists or arrays if you care about the run-time performance of
    the underlying operations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ•°æ®ç»“æ„æœ¯è¯­ä¸­ï¼Œç¬¬ä¸€ç§ç»„ç»‡ç§°ä¸ºæ•°ç»„ã€‚ç¬¬äºŒç§ç§°ä¸ºé“¾è¡¨ã€‚Pyretå®ç°äº†é“¾è¡¨ï¼Œè€Œæ•°ç»„æ˜¯ä¸€ä¸ªä¸åŒçš„æ•°æ®ç±»å‹ï¼ˆä¸åˆ—è¡¨æœ‰ä¸åŒçš„è¡¨ç¤ºæ³•ï¼‰ã€‚Pythonå®ç°åˆ—è¡¨ä¸ºæ•°ç»„ã€‚å½“ä½ æ¥è§¦ä¸€ç§æ–°çš„ç¼–ç¨‹è¯­è¨€æ—¶ï¼Œå¦‚æœä½ å…³å¿ƒåº•å±‚æ“ä½œçš„è¿è¡Œæ—¶æ€§èƒ½ï¼Œä½ éœ€è¦æŸ¥æ‰¾å…¶åˆ—è¡¨æ˜¯é“¾è¡¨è¿˜æ˜¯æ•°ç»„ã€‚
- en: Going back to our Runners discussion from the last chapter, we can simply use
    Python lists (arrays) rather than a hashtable, and be able to access the names
    of Runners who finished in particular positions. But letâ€™s instead ask a different
    question.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: å›åˆ°ä¸Šä¸€ç« ä¸­æˆ‘ä»¬å…³äºè·‘è€…çš„è®¨è®ºï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°ä½¿ç”¨Pythonåˆ—è¡¨ï¼ˆæ•°ç»„ï¼‰è€Œä¸æ˜¯æ•£åˆ—è¡¨ï¼Œå¹¶ä¸”èƒ½å¤Ÿè®¿é—®åœ¨ç‰¹å®šä½ç½®å®Œæˆæ¯”èµ›çš„è·‘è€…çš„åå­—ã€‚ä½†è®©æˆ‘ä»¬æå‡ºä¸€ä¸ªä¸åŒçš„é—®é¢˜ã€‚
- en: 'How would we report the top finishers in each age category? In particular,
    we want to write a function such as the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•æŠ¥å‘Šæ¯ä¸ªå¹´é¾„ç»„çš„é¡¶å°–å®Œæˆè€…ï¼Ÿç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬æƒ³è¦ç¼–å†™ä¸€ä¸ªå¦‚ä¸‹æ‰€ç¤ºçš„å‡½æ•°ï¼š
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Think about how you would write this code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: æ€è€ƒä¸€ä¸‹ä½ ä¼šå¦‚ä½•ç¼–å†™è¿™æ®µä»£ç ã€‚
- en: 'Hereâ€™s our solution:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æˆ‘ä»¬çš„è§£å†³æ–¹æ¡ˆï¼š
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, rather than return only when we get to the end of the list, we want to
    return once we have five runners in the list. So we set up an additional variable
    (`in_range`) to help us track progress of the computation. Once we have gotten
    to 5 runners, we return the list. If we never get to 5 runners, we print a warning
    to the user then return the results that we do have.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä¸æƒ³åªåœ¨åˆ°è¾¾åˆ—è¡¨æœ«å°¾æ—¶æ‰è¿”å›ï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨åˆ—è¡¨ä¸­æœ‰äº”ä¸ªè·‘è€…æ—¶è¿”å›ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è®¾ç½®äº†ä¸€ä¸ªé¢å¤–çš„å˜é‡ï¼ˆ`in_range`ï¼‰æ¥å¸®åŠ©æˆ‘ä»¬è·Ÿè¸ªè®¡ç®—çš„è¿›åº¦ã€‚ä¸€æ—¦æˆ‘ä»¬æœ‰äº†5ä¸ªè·‘è€…ï¼Œæˆ‘ä»¬å°±è¿”å›åˆ—è¡¨ã€‚å¦‚æœæˆ‘ä»¬ä»æœªè¾¾åˆ°5ä¸ªè·‘è€…ï¼Œæˆ‘ä»¬å‘ç”¨æˆ·æ‰“å°ä¸€ä¸ªè­¦å‘Šç„¶åè¿”å›æˆ‘ä»¬å·²æœ‰çš„ç»“æœã€‚
- en: Couldnâ€™t we have just looked at the length of the list, rather than maintain
    the `in_range` variable? Yes, we could have, though this version sets up a contrast
    to our next example.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸èƒ½åªæŸ¥çœ‹åˆ—è¡¨çš„é•¿åº¦ï¼Œè€Œä¸æ˜¯ç»´æŠ¤`in_range`å˜é‡å—ï¼Ÿæ˜¯çš„ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·åšï¼Œå°½ç®¡è¿™ä¸ªç‰ˆæœ¬ä¸æˆ‘ä»¬çš„ä¸‹ä¸€ä¸ªä¾‹å­å½¢æˆå¯¹æ¯”ã€‚
- en: 9.3.2Â Iterating Partly through an Ordered Datum[ğŸ”—](#(part._.Iterating_.Partly_through_an_.Ordered_.Datum)
    "Link to here")
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2Â éƒ¨åˆ†éå†æœ‰åºæ•°æ®[ğŸ”—](#(part._.Iterating_.Partly_through_an_.Ordered_.Datum) "é“¾æ¥åˆ°æ­¤å¤„")
- en: What if instead we just wanted to print out the top 5 finishers, rather than
    gather a list? While in general it is usually better to separate computing and
    displaying data, in practice we do sometimes merge them, or do other operations
    (like write some data to file) which wonâ€™t return anything. How do we modify the
    code to print the names rather than build up a list of the runners?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬åªæƒ³æ‰“å°å‡ºå‰5åå®Œæˆè€…ï¼Œè€Œä¸æ˜¯æ”¶é›†ä¸€ä¸ªåˆ—è¡¨ï¼Œä¼šæ€æ ·ï¼Ÿè™½ç„¶é€šå¸¸å°†è®¡ç®—å’Œæ˜¾ç¤ºæ•°æ®åˆ†å¼€æ˜¯æ›´å¥½çš„åšæ³•ï¼Œä½†åœ¨å®è·µä¸­ï¼Œæˆ‘ä»¬æœ‰æ—¶ä¼šåˆå¹¶å®ƒä»¬ï¼Œæˆ–è€…æ‰§è¡Œå…¶ä»–æ“ä½œï¼ˆå¦‚å°†ä¸€äº›æ•°æ®å†™å…¥æ–‡ä»¶ï¼‰è¿™äº›æ“ä½œä¸ä¼šè¿”å›ä»»ä½•å†…å®¹ã€‚æˆ‘ä»¬å¦‚ä½•ä¿®æ”¹ä»£ç æ¥æ‰“å°åå­—è€Œä¸æ˜¯æ„å»ºè·‘è€…åˆ—è¡¨ï¼Ÿ
- en: The challenge here is how to stop the computation. When we are building up a
    list, we stop a computation using return. But if our code isnâ€™t returning, or
    otherwise needs to stop a loop before it reaches the end of the data, what do
    we do?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„æŒ‘æˆ˜æ˜¯å¦‚ä½•åœæ­¢è®¡ç®—ã€‚å½“æˆ‘ä»¬æ„å»ºä¸€ä¸ªåˆ—è¡¨æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨returnæ¥åœæ­¢è®¡ç®—ã€‚ä½†å¦‚æœæˆ‘ä»¬ä»£ç æ²¡æœ‰è¿”å›ï¼Œæˆ–è€…éœ€è¦åœ¨åˆ°è¾¾æ•°æ®æœ«å°¾ä¹‹å‰åœæ­¢å¾ªç¯ï¼Œæˆ‘ä»¬è¯¥æ€ä¹ˆåŠï¼Ÿ
- en: 'We use a command called `break`, which says to terminate the loop and continue
    the rest of the computation. Here, the break is in place of the inner return statement:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªåä¸º `break` çš„å‘½ä»¤ï¼Œè¯¥å‘½ä»¤æŒ‡ç¤ºç»ˆæ­¢å¾ªç¯å¹¶ç»§ç»­å‰©ä½™çš„è®¡ç®—ã€‚åœ¨è¿™é‡Œï¼Œ`break` ä»£æ›¿äº†å†…éƒ¨çš„è¿”å›è¯­å¥ï¼š
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If Python reaches the `break` statement, it terminates the for loop and goes
    to the next statement, which is the print at the end of the function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœ Python é‡åˆ° `break` è¯­å¥ï¼Œå®ƒå°†ç»ˆæ­¢ for å¾ªç¯å¹¶è·³è½¬åˆ°ä¸‹ä¸€ä¸ªè¯­å¥ï¼Œå³å‡½æ•°æœ«å°¾çš„æ‰“å°è¯­å¥ã€‚
