["```cpp\n@lru_cache def f(n, w):  # check if we have no items to choose if n == 0: return 0  # check if we can't pick the last item (note zero-based indexing) if c[n - 1] > w: return f(n - 1, w)  # otherwise, we can either pick the last item or not return max(f(n - 1, w), c[n - 1] + f(n - 1, w - c[n - 1])) \n```", "```cpp\nint f[N + 1][W + 1] = {0}; // this zero-fills the array  for (int n = 1; n <= N; n++)  for (int w = 0; w <= W; w++) f[n][w] = c[n - 1] > w ? f[n - 1][w] : max(f[n - 1][k], c[n - 1] + f[n - 1][w - c[n - 1]]); \n```", "```cpp\nbool f[W + 1] = {0}; f[0] = 1; for (int n = 0; n < N; n++)  for (int x = W - c[n]; x >= 0; x--) f[x + c[n]] |= f[x]; \n```", "```cpp\nstd::bitset<W + 1> b; b[0] = 1; for (int n = 0; n < N; n++)  b |= b << c[n]; \n```", "```cpp\nint rmq(int l, int r) { // half-interval [l; r)  int t = __lg(r - l); return min(mn[t][l], mn[t][r - (1 << t)]); } \n```", "```cpp\nint mn[logn][maxn];   memcpy(mn[0], a, sizeof a);   for (int l = 0; l < logn - 1; l++)  for (int i = 0; i + (2 << l) <= n; i++) mn[l + 1][i] = min(mn[l][i], mn[l][i + (1 << l)]); \n```", "```cpp\nint left_child[maxn], right_child[maxn], key[maxn], size[maxn]; \n```", "```cpp\nstruct Node {  int left_child, right_child, key, size; };   Node t[maxn]; \n```"]