- en: Stages of Compilation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译阶段
- en: 原文：[https://en.algorithmica.org/hpc/compilation/stages/](https://en.algorithmica.org/hpc/compilation/stages/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://en.algorithmica.org/hpc/compilation/stages/](https://en.algorithmica.org/hpc/compilation/stages/)
- en: 'Before jumping straight to compiler optimizations, which is what most of this
    chapter is about, let’s briefly recap the “big picture” first. Skipping the boring
    parts, there are 4 stages of turning C programs into executables:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在直接跳到编译器优化之前，这是本章的大部分内容，让我们首先简要回顾一下“大局”。跳过无聊的部分，将C程序转换为可执行文件有4个阶段：
- en: '**Preprocessing** expands macros, pulls included source from header files,
    and strips off comments from source code: `gcc -E source.c` (outputs preprocessed
    source to stdout)'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预处理**扩展宏，从头文件中提取包含的源代码，并从源代码中删除注释：`gcc -E source.c`（将预处理的源代码输出到stdout）'
- en: '**Compiling** parses the source, checks for syntax errors, converts it into
    an intermediate representation, performs optimizations, and finally translates
    it into assembly language: `gcc -S file.c` (emits an `.s` file)'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译**解析源代码，检查语法错误，将其转换为中间表示，执行优化，最后将其翻译成汇编语言：`gcc -S file.c`（生成一个`.s`文件）'
- en: '**Assembly** turns assembly language into machine code, except that any external
    function calls like `printf` are substituted with placeholders: `gcc -c file.c`
    (emits an `.o` file, called *object file*)'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**汇编**将汇编语言转换为机器代码，除了任何外部函数调用（如`printf`）都被占位符替换：`gcc -c file.c`（生成一个`.o`文件，称为*目标文件*）'
- en: '**Linking** finally resolves the function calls by plugging in their actual
    addresses, and produces an executable binary: `gcc -o binary file.c`'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**链接**最终通过插入它们的实际地址来解决函数调用，并生成一个可执行的二进制文件：`gcc -o binary file.c`'
- en: There are possibilities to improve program performance in each of these stages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些每个阶段中都有提高程序性能的可能性。
- en: '### [#](https://en.algorithmica.org/hpc/compilation/stages/#interprocedural-optimization)Interprocedural
    Optimization'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/compilation/stages/#interprocedural-optimization)过程间优化'
- en: We have the last [stage](../stages), linking, because it is is both easier and
    faster to compile programs on a file-by-file basis and then link those files together
    — this way you can do this in parallel and also cache intermediate results.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有最后一个[阶段](../stages)，链接，因为按文件逐个编译程序然后链接这些文件既容易又快，这样你可以并行执行，还可以缓存中间结果。
- en: 'It also gives the ability to distribute code as *libraries*, which can be either
    *static* or *shared*:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了将代码作为*库*分发的功能，这些库可以是*静态*的或*共享*的：
- en: '*Static* libraries are simply collections of precompiled object files that
    are merged with other sources by the compiler to produce a single executable,
    just as it normally would.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*静态*库只是预编译的目标文件的集合，编译器将它们与其他源代码合并以生成单个可执行文件，就像它通常所做的那样。'
- en: '*Dynamic* or *shared* libraries are precompiled executables that have additional
    meta-information about where their callables are, references to which are resolved
    during runtime. As the name suggests, this allows *sharing* the compiled binaries
    between multiple programs.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态*或*共享*库是预编译的可执行文件，它们包含有关其可调用位置的其他元信息，这些引用在运行时被解析。正如其名所示，这允许*共享*多个程序之间的编译二进制文件。'
- en: The main advantage of using static libraries is that you can perform various
    *interprocedural optimizations* that require more context than just the signatures
    of library functions, such as [function inlining](/hpc/architecture/functions)
    or dead code elimination. To force the linker to look for and only accept static
    libraries, you can pass the `-static` option.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态库的主要优点是你可以执行需要更多上下文（而不仅仅是库函数签名）的各种*过程间优化*，例如[函数内联](/hpc/architecture/functions)或删除死代码。要强制链接器查找并仅接受静态库，你可以传递`-static`选项。
- en: This process is called *link-time optimization (LTO)*, and it is possible because
    modern compilers also store some form of *intermediate representation* in object
    files, which allows them to perform certain lightweight optimizations on the program
    as a whole. This also allows using different compiled languages in the same program,
    which can even be optimized across language barriers if their compilers use the
    same intermediate representation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程被称为*链接时优化（LTO）*，这是可能的，因为现代编译器也会在目标文件中存储某种形式的*中间表示*，这使得它们可以对整个程序执行某些轻量级优化。这也允许在同一个程序中使用不同的编译语言，如果它们的编译器使用相同的中间表示，甚至可以在语言障碍之间进行优化。
- en: LTO is a relatively recent feature (it appeared in GCC only around 2014), and
    it is still far from perfect. In C and C++, the way to make sure no performance
    is lost due to separate compilation is to create a *header-only library*. As the
    name suggests, they are just header files that contain full definitions of all
    functions, and so by simply including them, the compiler gets access to all optimizations
    possible. Although you do have to recompile the library code from scratch each
    time, this approach retains full control and makes sure that no performance is
    lost.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: LTO 是一个相对较新的特性（它在 GCC 中大约出现在 2014 年），并且它还远未完善。在 C 和 C++ 中，确保由于单独编译而不会丢失性能的方法是创建一个
    *仅包含头文件的库*。正如其名所示，它们只是包含所有函数完整定义的头文件，因此通过简单地包含它们，编译器就可以访问所有可能的优化。尽管您确实需要每次从头开始重新编译库代码，但这种方法保留了完全的控制权，并确保不会丢失任何性能。
- en: '### [#](https://en.algorithmica.org/hpc/compilation/stages/#inspecting-the-output)Inspecting
    the Output'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '### [#](https://en.algorithmica.org/hpc/compilation/stages/#inspecting-the-output)检查输出'
- en: Examining output from each of these stages can yield useful insights into what’s
    happening in your program.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 检查每个阶段的输出可以为您提供关于程序中发生情况的宝贵见解。
- en: You can get assembly from the source by passing the `-S` flag to the compiler,
    which will then generate a human-readable `*.s` file. If you pass `-fverbose-asm`,
    this file will also contain compiler comments about source code line numbers and
    some info about variables being used. If it is just a little snippet and you are
    feeling lazy, you can use [Compiler Explorer](https://godbolt.org/), which is
    a very handy online tool that converts source code to assembly, highlights logical
    asm blocks by color, includes a small x86 instruction set reference, and also
    has a large selection of other compilers, targets, and languages.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过向编译器传递 `-S` 标志来从源代码获取汇编代码，编译器随后将生成一个人类可读的 `*.s` 文件。如果您传递 `-fverbose-asm`，此文件还将包含有关源代码行号和正在使用的变量的编译器注释。如果您只是想查看一小段代码并且感到懒惰，可以使用
    [Compiler Explorer](https://godbolt.org/)，这是一个非常实用的在线工具，可以将源代码转换为汇编代码，通过颜色突出显示逻辑汇编块，包含一个小的
    x86 指令集参考，并且还提供了大量其他编译器、目标平台和语言的选项。
- en: Apart from the assembly, the other most helpful level of abstraction is the
    intermediate representation on which compilers perform optimizations. The IR defines
    the flow of computation itself and is much less dependent on architecture features
    like the number of registers or a particular instruction set. It is often useful
    to inspect these to get insight into how the compiler *sees* your program, but
    this is a bit out of the scope of this book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了汇编代码之外，另一个非常有用的抽象级别是编译器执行的优化所基于的中间表示。IR 定义了计算流程本身，并且对架构特性（如寄存器数量或特定的指令集）的依赖性要小得多。检查这些内容通常有助于了解编译器是如何“看到”您的程序的，但这超出了本书的范围。
- en: We will mainly use [GCC](https://gcc.gnu.org/) in this chapter, but also try
    to duplicate examples for [Clang](https://clang.llvm.org/) when necessary. The
    two compilers are largely compatible with each other, for the most part only differing
    in some optimization flags and minor syntax details. [← ../Compilation](https://en.algorithmica.org/hpc/compilation/)[Flags
    and Targets →](https://en.algorithmica.org/hpc/compilation/flags/)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中主要使用 [GCC](https://gcc.gnu.org/)，但在必要时也会尝试复制 [Clang](https://clang.llvm.org/)
    的示例。这两个编译器在很大程度上是兼容的，大部分差异仅在于一些优化标志和微小的语法细节。[← ../Compilation](https://en.algorithmica.org/hpc/compilation/)[标志和目标
    →](https://en.algorithmica.org/hpc/compilation/flags/)
