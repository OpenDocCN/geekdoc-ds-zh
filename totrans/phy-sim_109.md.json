["```py\n # self-contact\n    for xI in bp:\n        for eI in be:\n            if xI != eI[0] and xI != eI[1]: # do not consider a point and its incident edge\n                if CCD.bbox_overlap(x[xI], x[eI[0]], x[eI[1]], p[xI], p[eI[0]], p[eI[1]], alpha):\n                    toc = CCD.narrow_phase_CCD(x[xI], x[eI[0]], x[eI[1]], p[xI], p[eI[0]], p[eI[1]], alpha)\n                    if alpha > toc:\n                        alpha = toc \n```", "```py\nfrom copy import deepcopy\nimport numpy as np\nimport math\n\nimport distance.PointEdgeDistance as PE\n\n# check whether the bounding box of the trajectory of the point and the edge overlap\ndef bbox_overlap(p, e0, e1, dp, de0, de1, toc_upperbound):\n    max_p = np.maximum(p, p + toc_upperbound * dp) # point trajectory bbox top-right\n    min_p = np.minimum(p, p + toc_upperbound * dp) # point trajectory bbox bottom-left\n    max_e = np.maximum(np.maximum(e0, e0 + toc_upperbound * de0), np.maximum(e1, e1 + toc_upperbound * de1)) # edge trajectory bbox top-right\n    min_e = np.minimum(np.minimum(e0, e0 + toc_upperbound * de0), np.minimum(e1, e1 + toc_upperbound * de1)) # edge trajectory bbox bottom-left\n    if np.any(np.greater(min_p, max_e)) or np.any(np.greater(min_e, max_p)):\n        return False\n    else:\n        return True \n```", "```py\n# compute the first \"time\" of contact, or toc,\n# return the computed toc only if it is smaller than the previously computed toc_upperbound\ndef narrow_phase_CCD(_p, _e0, _e1, _dp, _de0, _de1, toc_upperbound):\n    p = deepcopy(_p)\n    e0 = deepcopy(_e0)\n    e1 = deepcopy(_e1)\n    dp = deepcopy(_dp)\n    de0 = deepcopy(_de0)\n    de1 = deepcopy(_de1)\n\n    # use relative displacement for faster convergence\n    mov = (dp + de0 + de1) / 3 \n    de0 -= mov\n    de1 -= mov\n    dp -= mov\n    maxDispMag = np.linalg.norm(dp) + math.sqrt(max(np.dot(de0, de0), np.dot(de1, de1)))\n    if maxDispMag == 0:\n        return toc_upperbound\n\n    eta = 0.1 # calculate the toc that first brings the distance to 0.1x the current distance\n    dist2_cur = PE.val(p, e0, e1)\n    dist_cur = math.sqrt(dist2_cur)\n    gap = eta * dist_cur\n    # iteratively move the point and edge towards each other and\n    # grow the toc estimate without numerical errors\n    toc = 0\n    while True:\n        tocLowerBound = (1 - eta) * dist_cur / maxDispMag\n\n        p += tocLowerBound * dp\n        e0 += tocLowerBound * de0\n        e1 += tocLowerBound * de1\n        dist2_cur = PE.val(p, e0, e1)\n        dist_cur = math.sqrt(dist2_cur)\n        if toc != 0 and dist_cur < gap:\n            break\n\n        toc += tocLowerBound\n        if toc > toc_upperbound:\n            return toc_upperbound\n\n    return toc \n```"]