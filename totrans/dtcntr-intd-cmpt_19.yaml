- en: 7.1Â TreesğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.1 æ ‘ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/trees.html](https://dcic-world.org/2025-08-27/trees.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/trees.html](https://dcic-world.org/2025-08-27/trees.html)
- en: '| Â Â Â Â [7.1.1Â Data Design Problem â€“ Ancestry Data](#%28part._ancestor-trees%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [7.1.1 æ•°æ®è®¾è®¡é—®é¢˜ â€“ å®¶è°±æ•°æ®](#%28part._ancestor-trees%29) |'
- en: '| Â Â Â Â Â Â [7.1.1.1Â Computing Genetic Parents from an Ancestry Table](#%28part._compute-parents-table%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â [7.1.1.1 ä»å®¶è°±è¡¨ä¸­è®¡ç®—é—ä¼ çˆ¶æ¯](#%28part._compute-parents-table%29) |'
- en: '| Â Â Â Â Â Â [7.1.1.2Â Computing Grandparents from an Ancestry Table](#%28part._.Computing_.Grandparents_from_an_.Ancestry_.Table%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â [7.1.1.2 ä»å®¶è°±è¡¨ä¸­è®¡ç®—ç¥–çˆ¶æ¯](#%28part._.Computing_.Grandparents_from_an_.Ancestry_.Table%29)
    |'
- en: '| Â Â Â Â Â Â [7.1.1.3Â Creating a Datatype for Ancestor Trees](#%28part._ancestor-tree%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â Â Â [7.1.1.3 ä¸ºå®¶è°±æ ‘åˆ›å»ºæ•°æ®ç±»å‹](#%28part._ancestor-tree%29) |'
- en: '| Â Â Â Â [7.1.2Â Programs to Process Ancestor Trees](#%28part._.Programs_to_.Process_.Ancestor_.Trees%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [7.1.2 å¤„ç†å®¶è°±æ ‘çš„ç¨‹åº](#%28part._.Programs_to_.Process_.Ancestor_.Trees%29) |'
- en: '| Â Â Â Â [7.1.3Â Summarizing How to Approach Tree Problems](#%28part._.Summarizing_.How_to_.Approach_.Tree_.Problems%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [7.1.3 æ€»ç»“å¦‚ä½•å¤„ç†æ ‘é—®é¢˜](#%28part._.Summarizing_.How_to_.Approach_.Tree_.Problems%29)
    |'
- en: '| Â Â Â Â [7.1.4Â Study Questions](#%28part._.Study_.Questions%29) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|Â Â Â [7.1.4 ç ”ç©¶é—®é¢˜](#%28part._.Study_.Questions%29) |'
- en: 7.1.1Â Data Design Problem â€“ Ancestry Data[ğŸ”—](#(part._ancestor-trees) "Link to
    here")
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1 æ•°æ®è®¾è®¡é—®é¢˜ â€“ å®¶è°±æ•°æ®[ğŸ”—](#(part._ancestor-trees) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Imagine that we wanted to manage ancestry information for purposes of a medical
    research study. Specifically, we want to record peopleâ€™s birthyear, eye colors,
    and genetic parents. Hereâ€™s a sample table of such data, with one row for each
    person:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœæˆ‘ä»¬æƒ³ç®¡ç†ç”¨äºåŒ»å­¦ç ”ç©¶ç›®çš„çš„å®¶è°±ä¿¡æ¯ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬æƒ³è®°å½•äººä»¬çš„å‡ºç”Ÿå¹´ä»½ã€çœ¼ç›é¢œè‰²å’Œé—ä¼ çˆ¶æ¯ã€‚ä»¥ä¸‹æ˜¯è¿™æ ·æ•°æ®çš„æ ·æœ¬è¡¨ï¼Œæ¯è¡Œä»£è¡¨ä¸€ä¸ªäººï¼š
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For our research, we want to be able to answer questions such as the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æˆ‘ä»¬çš„ç ”ç©¶ï¼Œæˆ‘ä»¬å¸Œæœ›èƒ½å¤Ÿå›ç­”ä»¥ä¸‹é—®é¢˜ï¼š
- en: Who are the genetic grandparents of a specific person?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æŸä¸ªç‰¹å®šäººçš„é—ä¼ ç¥–çˆ¶æ¯æ˜¯è°ï¼Ÿ
- en: How frequent is each eye color?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¯ç§çœ¼ç›é¢œè‰²çš„é¢‘ç‡æ˜¯å¤šå°‘ï¼Ÿ
- en: Is one specific person an ancestor of another specific person?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªç‰¹å®šçš„äººæ˜¯å¦æ˜¯å¦ä¸€ä¸ªç‰¹å®šäººçš„ç¥–å…ˆï¼Ÿ
- en: How many generations do we have information for?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ‰å¤šå°‘ä»£çš„ä¿¡æ¯ï¼Ÿ
- en: Does oneâ€™s eye color correlate with the ages of their genetic parents when they
    were born?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªäººå‡ºç”Ÿæ—¶ï¼Œä»–ä»¬çš„çœ¼ç›é¢œè‰²ä¸ä»–ä»¬çš„é—ä¼ çˆ¶æ¯é‚£æ—¶çš„å¹´é¾„ç›¸å…³å—ï¼Ÿ
- en: 'Letâ€™s start with the first question:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»ç¬¬ä¸€ä¸ªé—®é¢˜å¼€å§‹ï¼š
- en: Do Now!
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you compute a list of the known grandparents for a given person? For
    purposes of this chapter, you may assume that each person has a unique name (while
    this isnâ€™t realistic in practice, it will simplify our computations for the time
    being; we will revisit it later in the chapter).
  id: totrans-21
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ ä¼šå¦‚ä½•è®¡ç®—ç»™å®šäººçš„å·²çŸ¥ç¥–çˆ¶æ¯çš„åˆ—è¡¨ï¼Ÿä¸ºäº†æœ¬ç« çš„ç›®çš„ï¼Œä½ å¯ä»¥å‡è®¾æ¯ä¸ªäººéƒ½æœ‰ä¸€ä¸ªç‹¬ç‰¹çš„åå­—ï¼ˆè™½ç„¶è¿™åœ¨å®è·µä¸­å¹¶ä¸ç°å®ï¼Œä½†ä¸ºäº†ç®€åŒ–æˆ‘ä»¬çš„è®¡ç®—ï¼Œæˆ‘ä»¬æš‚æ—¶è¿™æ ·åšï¼›æˆ‘ä»¬å°†åœ¨æœ¬ç« çš„åé¢é‡æ–°è®¨è®ºè¿™ä¸ªé—®é¢˜ï¼‰ã€‚
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '(Hint: Make a task plan. Does it suggest any particular helper functions?)'
  id: totrans-23
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ï¼ˆæç¤ºï¼šåˆ¶å®šä¸€ä¸ªä»»åŠ¡è®¡åˆ’ã€‚å®ƒæ˜¯å¦å»ºè®®ä»»ä½•ç‰¹å®šçš„è¾…åŠ©å‡½æ•°ï¼Ÿï¼‰
- en: 'Our task plan has two key steps: find the names of the genetic parents of the
    named person, then find the names of the parents of each of those people. Both
    steps share the need to compute the known parents from a name, so we should create
    a helper function for that (weâ€™ll call it `parents-of`). Since this sounds like
    a routine table program, we can use it for a bit of review:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ä»»åŠ¡è®¡åˆ’åŒ…å«ä¸¤ä¸ªå…³é”®æ­¥éª¤ï¼šæ‰¾åˆ°æŒ‡å®šäººçš„é—ä¼ çˆ¶æ¯çš„å§“åï¼Œç„¶åæ‰¾åˆ°è¿™äº›äººçš„çˆ¶æ¯çš„å§“åã€‚è¿™ä¸¤ä¸ªæ­¥éª¤éƒ½éœ€è¦ä»å§“åè®¡ç®—å·²çŸ¥çš„çˆ¶æ¯ï¼Œå› æ­¤æˆ‘ä»¬åº”è¯¥ä¸ºè¿™ä¸ªç›®çš„åˆ›å»ºä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼ˆæˆ‘ä»¬å°†ç§°ä¹‹ä¸º`parents-of`ï¼‰ã€‚ç”±äºè¿™å¬èµ·æ¥åƒæ˜¯ä¸€ä¸ªå¸¸è§„çš„è¡¨æ ¼ç¨‹åºï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥å¤ä¹ ä¸€ä¸‹ï¼š
- en: 7.1.1.1Â Computing Genetic Parents from an Ancestry Table[ğŸ”—](#(part._compute-parents-table)
    "Link to here")
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.1 ä»å®¶è°±è¡¨ä¸­è®¡ç®—é—ä¼ çˆ¶æ¯[ğŸ”—](#(part._compute-parents-table) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'How do we compute a list of someoneâ€™s genetic parents? Letâ€™s sketch a task
    plan for that:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•è®¡ç®—æŸäººçš„é—ä¼ çˆ¶æ¯åˆ—è¡¨ï¼Ÿè®©æˆ‘ä»¬ä¸ºè¿™ä¸ªä»»åŠ¡è‰æ‹Ÿä¸€ä¸ªè®¡åˆ’ï¼š
- en: filter the table to find the person
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿‡æ»¤è¡¨æ ¼ä»¥æ‰¾åˆ°è¯¥äºº
- en: extract the name of the female parent
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æå–å¥³æ€§çˆ¶æ¯çš„å§“å
- en: extract the name of the male parent
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æå–ç”·æ€§çˆ¶æ¯çš„å§“å
- en: make a list of those names
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ—å‡ºé‚£äº›å§“å
- en: 'These are tasks we have seen before, so we can translate this plan directly
    into code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ˜¯æˆ‘ä»¬ä¹‹å‰è§è¿‡çš„ä»»åŠ¡ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç›´æ¥å°†è¿™ä¸ªè®¡åˆ’è½¬æ¢ä¸ºä»£ç ï¼š
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Do Now!
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Are you satisfied with this program? With the examples included in the `where`
    block? Write down any critiques you have.
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ å¯¹è¿™ä¸ªç¨‹åºæ»¡æ„å—ï¼ŸåŒ…æ‹¬åœ¨`where`å—ä¸­çš„ç¤ºä¾‹ï¼Ÿå†™ä¸‹ä½ æ‰€æœ‰çš„æ‰¹è¯„æ„è§ã€‚
- en: There are arguably some issues here. How many of these did you catch?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œå¯èƒ½æœ‰ä¸€äº›é—®é¢˜ã€‚ä½ å‘ç°äº†å¤šå°‘ï¼Ÿ
- en: 'The examples are weak: none of them consider people for whom we are missing
    information on at least one parent.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¾‹å­å¾ˆå¼±ï¼šå®ƒä»¬éƒ½æ²¡æœ‰è€ƒè™‘è‡³å°‘æœ‰ä¸€ä½çˆ¶æ¯ä¿¡æ¯ç¼ºå¤±çš„äººã€‚
- en: The list of names returned in the case of an unknown parent includes the empty
    string, which isnâ€™t actually a name. This could cause problems if we use this
    list of names in a subsequent computation (such as to compute the names of someoneâ€™s
    grandparents).
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨æœªçŸ¥çˆ¶æ¯çš„æƒ…å†µä¸‹è¿”å›çš„å§“ååˆ—è¡¨ä¸­åŒ…æ‹¬ç©ºå­—ç¬¦ä¸²ï¼Œè¿™å®é™…ä¸Šå¹¶ä¸æ˜¯ä¸€ä¸ªåå­—ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªå§“ååˆ—è¡¨è¿›è¡Œåç»­è®¡ç®—ï¼ˆä¾‹å¦‚è®¡ç®—æŸäººçš„ç¥–çˆ¶æ¯çš„åå­—ï¼‰ï¼Œè¿™å¯èƒ½ä¼šå¼•èµ·é—®é¢˜ã€‚
- en: If empty strings are not part of the output list, then weâ€™d get the same result
    from asking for the parents of `"Robert"` (who is in the table) as for `"Kathi"`
    (who is not). These are fundamentally different cases, which arguably demand different
    outputs so we can tell them apart.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœç©ºå­—ç¬¦ä¸²ä¸æ˜¯è¾“å‡ºåˆ—è¡¨çš„ä¸€éƒ¨åˆ†ï¼Œé‚£ä¹ˆä»è¯·æ±‚`"Robert"`ï¼ˆä»–åœ¨è¡¨ä¸­ï¼‰çš„çˆ¶æ¯å’Œè¯·æ±‚`"Kathi"`ï¼ˆä¸åœ¨è¡¨ä¸­ï¼‰çš„çˆ¶æ¯å°†å¾—åˆ°ç›¸åŒçš„ç»“æœã€‚è¿™äº›æ˜¯æ ¹æœ¬ä¸åŒçš„æ¡ˆä¾‹ï¼Œå¯ä»¥è¯´éœ€è¦ä¸åŒçš„è¾“å‡ºä»¥ä¾¿æˆ‘ä»¬å¯ä»¥åŒºåˆ†å®ƒä»¬ã€‚
- en: 'To fix these problems, we need to remove the empty strings from the produced
    list of parents and return something other than the `empty` list when a name is
    not in the table. Since the output of this function is a list of strings, itâ€™s
    hard to see what to return that couldnâ€™t be confused for a valid list of names.
    Our solution for now is to have Pyret throw an error (like the ones you get when
    Pyret is not able to finish running your program). Hereâ€™s a solution that handles
    both problems:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ä¿®å¤è¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦ä»äº§ç”Ÿçš„çˆ¶æ¯åˆ—è¡¨ä¸­åˆ é™¤ç©ºå­—ç¬¦ä¸²ï¼Œå¹¶åœ¨åå­—ä¸åœ¨è¡¨ä¸­æ—¶è¿”å›é™¤`empty`åˆ—è¡¨ä¹‹å¤–çš„å†…å®¹ã€‚ç”±äºè¿™ä¸ªå‡½æ•°çš„è¾“å‡ºæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œå¾ˆéš¾çœ‹å‡ºå¯ä»¥è¿”å›ä»€ä¹ˆä¸ä¼šä¸æœ‰æ•ˆçš„åå­—åˆ—è¡¨æ··æ·†ã€‚æˆ‘ä»¬ç›®å‰çš„è§£å†³æ–¹æ¡ˆæ˜¯è®©PyretæŠ›å‡ºä¸€ä¸ªé”™è¯¯ï¼ˆå°±åƒä½ åœ¨Pyretæ— æ³•å®Œæˆè¿è¡Œä½ çš„ç¨‹åºæ—¶å¾—åˆ°çš„é‚£æ ·ï¼‰ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªå¤„ç†è¿™ä¸¤ä¸ªé—®é¢˜çš„è§£å†³æ–¹æ¡ˆï¼š
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `raise` construct tells Pyret to halt the program and produce an error message.
    The error message does not have to match the expected output type of the program.
    If you run this function with a name that is not in the table, youâ€™ll see an error
    appear in the interactions pane, with no result returned.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`raise`æ„é€ å‡½æ•°å‘Šè¯‰Pyretåœæ­¢ç¨‹åºå¹¶äº§ç”Ÿä¸€ä¸ªé”™è¯¯ä¿¡æ¯ã€‚é”™è¯¯ä¿¡æ¯ä¸å¿…ä¸ç¨‹åºé¢„æœŸçš„è¾“å‡ºç±»å‹ç›¸åŒ¹é…ã€‚å¦‚æœä½ ç”¨ä¸åœ¨è¡¨ä¸­çš„åå­—è¿è¡Œè¿™ä¸ªå‡½æ•°ï¼Œä½ å°†åœ¨äº¤äº’é¢æ¿ä¸­çœ‹åˆ°ä¸€ä¸ªé”™è¯¯å‡ºç°ï¼Œå¹¶ä¸”æ²¡æœ‰è¿”å›ç»“æœã€‚'
- en: 'Within the `where` block, we see how to check whether an expression will yield
    an error: instead of using `is` to check the equality of values, we use `raises`
    to check whether the provided string is a sub-string of the actual error produced
    by the program.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨`where`å—ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°å¦‚ä½•æ£€æŸ¥ä¸€ä¸ªè¡¨è¾¾å¼æ˜¯å¦ä¼šäº§ç”Ÿé”™è¯¯ï¼šæˆ‘ä»¬ä¸æ˜¯ä½¿ç”¨`is`æ¥æ£€æŸ¥å€¼çš„ç›¸ç­‰æ€§ï¼Œè€Œæ˜¯ä½¿ç”¨`raises`æ¥æ£€æŸ¥æä¾›çš„å­—ç¬¦ä¸²æ˜¯å¦æ˜¯ç¨‹åºå®é™…äº§ç”Ÿçš„é”™è¯¯çš„ä¸€ä¸ªå­å­—ç¬¦ä¸²ã€‚
- en: 7.1.1.2Â Computing Grandparents from an Ancestry Table[ğŸ”—](#(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)
    "Link to here")
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.2Â ä»å®¶è°±è¡¨ä¸­è®¡ç®—ç¥–çˆ¶æ¯[ğŸ”—](#(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)
    "é“¾æ¥è‡³æ­¤")
- en: 'Once we have the `parents-of` function, we should be able to compute the grandparents
    by computing parents of parents, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬æœ‰äº†`parents-of`å‡½æ•°ï¼Œæˆ‘ä»¬åº”è¯¥èƒ½å¤Ÿé€šè¿‡è®¡ç®—çˆ¶æ¯çš„çˆ¶æ¯æ¥è®¡ç®—ç¥–çˆ¶æ¯ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Do Now!
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Look back at our sample ancestry tree: for which people would this correctly
    compute the list of grandparents?'
  id: totrans-49
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å›é¡¾æˆ‘ä»¬çš„æ ·æœ¬å®¶è°±æ ‘ï¼šå¯¹äºå“ªäº›äººï¼Œè¿™ä¸ªè®¡ç®—å°†æ­£ç¡®åœ°è®¡ç®—å‡ºç¥–çˆ¶æ¯çš„åˆ—è¡¨ï¼Ÿ
- en: This grandparents-of code works fine for someone who has both parents in the
    table. For someone without two parents, however, the `plist` will have fewer than
    two names, so the expression `plist.rest.first` (if not `plist.first`) will yield
    an error.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: å½“è¡¨ä¸­åŒæ—¶æœ‰ä¸¤ä½çˆ¶æ¯æ—¶ï¼Œè¿™æ®µè®¡ç®—ç¥–çˆ¶æ¯çš„ä»£ç è¿è¡Œè‰¯å¥½ã€‚ç„¶è€Œï¼Œå¯¹äºæ²¡æœ‰ä¸¤ä½çˆ¶æ¯çš„äººæ¥è¯´ï¼Œ`plist`å°†åŒ…å«å°‘äºä¸¤ä¸ªåå­—ï¼Œå› æ­¤`plist.rest.first`ï¼ˆå¦‚æœä¸æ˜¯`plist.first`ï¼‰çš„è¡¨è¾¾å¼å°†äº§ç”Ÿé”™è¯¯ã€‚
- en: 'Hereâ€™s a version that checks the number of parents before computing the set
    of grandparents:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯ä¸€ä¸ªåœ¨è®¡ç®—ç¥–çˆ¶æ¯é›†åˆä¹‹å‰æ£€æŸ¥çˆ¶æ¯æ•°é‡çš„ç‰ˆæœ¬ï¼š
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What if we now wanted to gather up all of someoneâ€™s ancestors? Since we donâ€™t
    know how many generations there are, weâ€™d need to use recursion. This approach
    would also be expensive, since weâ€™d end up filtering over the table over and over,
    which checks every row of the table in each use of `filter`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ç°åœ¨æƒ³è¦æ”¶é›†æŸäººçš„æ‰€æœ‰ç¥–å…ˆå‘¢ï¼Ÿç”±äºæˆ‘ä»¬ä¸çŸ¥é“æœ‰å¤šå°‘ä»£ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨é€’å½’ã€‚è¿™ç§æ–¹æ³•ä¹Ÿä¼šå¾ˆæ˜‚è´µï¼Œå› ä¸ºæˆ‘ä»¬æœ€ç»ˆä¼šåœ¨æ¯æ¬¡ä½¿ç”¨`filter`æ—¶å¤šæ¬¡è¿‡æ»¤è¡¨ï¼Œè¿™ä¼šæ£€æŸ¥è¡¨çš„æ¯ä¸€è¡Œã€‚
- en: Look back at the ancestry tree picture. We donâ€™t do any complicated filtering
    there â€“ we just follow the line in the picture immediately from a person to their
    mother or father. Can we get that idea in code instead? Yes, through datatypes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: å›é¡¾ä¸€ä¸‹å®¶è°±æ ‘å›¾ç‰‡ã€‚åœ¨é‚£é‡Œæˆ‘ä»¬æ²¡æœ‰è¿›è¡Œä»»ä½•å¤æ‚çš„è¿‡æ»¤â€”â€”æˆ‘ä»¬åªæ˜¯ä»ä¸€ä¸ªäººç›´æ¥è·Ÿéšåˆ°ä»–ä»¬çš„æ¯äº²æˆ–çˆ¶äº²ã€‚æˆ‘ä»¬èƒ½å¦åœ¨ä»£ç ä¸­å®ç°è¿™ä¸ªæƒ³æ³•ï¼Ÿæ˜¯çš„ï¼Œé€šè¿‡æ•°æ®ç±»å‹ã€‚
- en: 7.1.1.3Â Creating a Datatype for Ancestor Trees[ğŸ”—](#(part._ancestor-tree) "Link
    to here")
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.3Â ä¸ºç¥–å…ˆæ ‘åˆ›å»ºæ•°æ®ç±»å‹[ğŸ”—](#(part._ancestor-tree) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'For this approach, we want to create a datatype for Ancestor Trees that has
    a variant (constructor) for setting up a person. Look back at our picture â€“ what
    information makes up a person? Their name, their mother, and their father (along
    with birthyear and eyecolor, which arenâ€™t shown in the picture). This suggests
    the following datatype, which basically turns a row into a person value:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºè¿™ç§æ–¹æ³•ï¼Œæˆ‘ä»¬å¸Œæœ›ä¸ºç¥–å…ˆæ ‘åˆ›å»ºä¸€ä¸ªå…·æœ‰è®¾ç½®ä¸ªäººå˜ä½“ï¼ˆæ„é€ å‡½æ•°ï¼‰çš„æ•°æ®ç±»å‹ã€‚å›é¡¾æˆ‘ä»¬çš„å›¾ç‰‡â€”â€”ä»€ä¹ˆä¿¡æ¯æ„æˆäº†ä¸€ä¸ªäººï¼Ÿä»–ä»¬çš„åå­—ã€ä»–ä»¬çš„æ¯äº²å’Œä»–ä»¬çš„çˆ¶äº²ï¼ˆä»¥åŠå‡ºç”Ÿå¹´ä»½å’Œçœ¼ç›é¢œè‰²ï¼Œè¿™äº›åœ¨å›¾ç‰‡ä¸­æ²¡æœ‰æ˜¾ç¤ºï¼‰ã€‚è¿™è¡¨æ˜ä»¥ä¸‹æ•°æ®ç±»å‹ï¼Œå®ƒåŸºæœ¬ä¸Šå°†ä¸€è¡Œè½¬æ¢ä¸ºä¸ªäººå€¼ï¼š
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For example, annaâ€™s row might look like:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œannaçš„è¡Œå¯èƒ½çœ‹èµ·æ¥åƒï¼š
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'What type do we put in the blanks? A quick brainstorm yields several ideas:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åº”è¯¥å¡«ä»€ä¹ˆç±»å‹ï¼Ÿå¿«é€Ÿå¤´è„‘é£æš´äº§ç”Ÿäº†å‡ ä¸ªæƒ³æ³•ï¼š
- en: '`person`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`person`'
- en: '`List<person>`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<person>`'
- en: some new datatype
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€äº›æ–°çš„æ•°æ®ç±»å‹
- en: '`AncTree`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AncTree`'
- en: '`String`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`'
- en: Which should it be?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒåº”è¯¥æ˜¯å“ªä¸€ä¸ªï¼Ÿ
- en: If we use a `String`, weâ€™re back to the table row, and we donâ€™t end up with
    a way to easily get from one person to another. We should therefore make this
    an `AncTree`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ä½¿ç”¨`String`ï¼Œæˆ‘ä»¬å°±å›åˆ°äº†è¡¨æ ¼è¡Œï¼Œå¹¶ä¸”æˆ‘ä»¬æ— æ³•è½»æ¾åœ°ä»ä¸€ä¸ªäººè½¬åˆ°å¦ä¸€ä¸ªäººã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥å°†å…¶å‘½åä¸º`AncTree`ã€‚
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Do Now!
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the `AncTree` starting from `Anna` using this definition.
  id: totrans-71
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸ªå®šä¹‰ä»â€œAnnaâ€å¼€å§‹ç¼–å†™`AncTree`ã€‚
- en: Did you get stuck? What do we do when we run out of known people? To handle
    that, we must add an option in the `AncTree` definition to capture people for
    whom we donâ€™t know anything.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¡ä½äº†å—ï¼Ÿå½“æˆ‘ä»¬ç”¨å®Œå·²çŸ¥çš„äººæ—¶ï¼Œæˆ‘ä»¬è¯¥æ€ä¹ˆåŠï¼Ÿä¸ºäº†å¤„ç†è¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬å¿…é¡»åœ¨`AncTree`å®šä¹‰ä¸­æ·»åŠ ä¸€ä¸ªé€‰é¡¹æ¥æ•è·æˆ‘ä»¬ä¸çŸ¥é“ä»»ä½•ä¿¡æ¯çš„äººã€‚
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Hereâ€™s Annaâ€™s tree written in this datatype:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯ä½¿ç”¨è¿™ç§æ•°æ®ç±»å‹ç¼–å†™çš„Annaçš„æ ‘ï¼š
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We could also have named each person data individually.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹Ÿå¯ä»¥ä¸ºæ¯ä¸ªäººçš„æ•°æ®å•ç‹¬å‘½åã€‚
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The latter gives you pieces of the tree to use as other examples, but loses
    the structure that is visible in the indentation of the first version. You could
    get to pieces of the first version by digging into the data, such as writing `anna-tree.mother.mother`
    to get to the tree starting from "Ellen".
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: åè€…ä¸ºä½ æä¾›äº†å¯ä»¥ç”¨äºå…¶ä»–ç¤ºä¾‹çš„æ ‘çš„ç‰‡æ®µï¼Œä½†å¤±å»äº†ç¬¬ä¸€ä¸ªç‰ˆæœ¬ä¸­å¯è§çš„ç»“æ„ã€‚ä½ å¯ä»¥é€šè¿‡æŒ–æ˜æ•°æ®æ¥è·å¾—ç¬¬ä¸€ä¸ªç‰ˆæœ¬çš„ç‰‡æ®µï¼Œä¾‹å¦‚ç¼–å†™`anna-tree.mother.mother`æ¥è·å–ä»â€œEllenâ€å¼€å§‹çš„æ ‘ã€‚
- en: 'Hereâ€™s the `parents-of` function written against `AncTree`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯é’ˆå¯¹`AncTree`ç¼–å†™çš„`parents-of`å‡½æ•°ï¼š
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 7.1.2Â Programs to Process Ancestor Trees[ğŸ”—](#(part._.Programs_to_.Process_.Ancestor_.Trees)
    "Link to here")
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2Â å¤„ç†ç¥–å…ˆæ ‘çš„ç¨‹åº[ğŸ”—](#(part._.Programs_to_.Process_.Ancestor_.Trees) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'How would we write a function to determine whether anyone in the tree had a
    particular name? To be clear, we are trying to fill in the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥ç¡®å®šæ ‘ä¸­æ˜¯å¦æœ‰äººæœ‰ç‰¹å®šçš„åå­—ï¼Ÿä¸ºäº†æ¸…æ¥šèµ·è§ï¼Œæˆ‘ä»¬æ­£åœ¨å°è¯•å¡«å†™ä»¥ä¸‹ä»£ç ï¼š
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'How do we get started? Add some examples, remembering to check both cases of
    the `AncTree` definition:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•å¼€å§‹ï¼Ÿæ·»åŠ ä¸€äº›ç¤ºä¾‹ï¼Œè®°å¾—æ£€æŸ¥`AncTree`å®šä¹‰çš„ä¸¤ç§æƒ…å†µï¼š
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'What next? When we were working on lists, we talked about the template, a skeleton
    of code that we knew we could write based on the structure of the data. The template
    names the pieces of each kind of data, and makes recursive calls on pieces that
    have the same type. Hereâ€™s the template over the `AncTree` filled in:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥æ˜¯ä»€ä¹ˆï¼Ÿå½“æˆ‘ä»¬å¤„ç†åˆ—è¡¨æ—¶ï¼Œæˆ‘ä»¬è®¨è®ºäº†æ¨¡æ¿ï¼Œè¿™æ˜¯æˆ‘ä»¬æ ¹æ®æ•°æ®ç»“æ„çŸ¥é“æˆ‘ä»¬å¯ä»¥ç¼–å†™çš„ä»£ç æ¡†æ¶ã€‚æ¨¡æ¿å‘½åäº†æ¯ç§æ•°æ®ç±»å‹çš„å„ä¸ªéƒ¨åˆ†ï¼Œå¹¶å¯¹å…·æœ‰ç›¸åŒç±»å‹çš„éƒ¨åˆ†è¿›è¡Œé€’å½’è°ƒç”¨ã€‚ä¸‹é¢æ˜¯å¡«å……åœ¨`AncTree`ä¸Šçš„æ¨¡æ¿ï¼š
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To finish the code, we need to think about how to fill in the ellipses.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: å®Œæˆä»£ç ï¼Œæˆ‘ä»¬éœ€è¦æ€è€ƒå¦‚ä½•å¡«å……çœç•¥å·ã€‚
- en: When the tree is `noInfo`, it has no more people, so the answer should be false
    (as worked out in the examples).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“æ ‘æ˜¯`noInfo`æ—¶ï¼Œå®ƒæ²¡æœ‰æ›´å¤šçš„äººï¼Œæ‰€ä»¥ç­”æ¡ˆåº”è¯¥æ˜¯falseï¼ˆå¦‚ç¤ºä¾‹ä¸­æ‰€ç¤ºï¼‰ã€‚
- en: 'When the tree is a person, there are three possibilities: we could be at a
    person with the name weâ€™re looking for, or the name could be in the motherâ€™s tree,
    or the name could be in the fatherâ€™s tree.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“æ ‘æ˜¯ä¸€ä¸ªäººæ—¶ï¼Œæœ‰ä¸‰ç§å¯èƒ½æ€§ï¼šæˆ‘ä»¬å¯èƒ½åœ¨ä¸€ä¸ªå…·æœ‰æˆ‘ä»¬æ­£åœ¨å¯»æ‰¾çš„åå­—çš„äººé‚£é‡Œï¼Œæˆ–è€…åå­—å¯èƒ½åœ¨æ¯äº²çš„æ ‘ä¸­ï¼Œæˆ–è€…åå­—å¯èƒ½åœ¨çˆ¶äº²çš„æ ‘ä¸­ã€‚
- en: We know how to check whether the personâ€™s name matches the one we are looking
    for. The recursive calls already ask about the name being in the motherâ€™s tree
    or fatherâ€™s tree. We just need to combine those pieces into one Boolean answer.
    Since there are three possibilities, we should combine them with `or`
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çŸ¥é“å¦‚ä½•æ£€æŸ¥ä¸€ä¸ªäººçš„åå­—æ˜¯å¦ä¸æˆ‘ä»¬æ­£åœ¨å¯»æ‰¾çš„åå­—åŒ¹é…ã€‚é€’å½’è°ƒç”¨å·²ç»è¯¢é—®äº†åå­—æ˜¯å¦åœ¨æ¯äº²çš„æ ‘æˆ–çˆ¶äº²çš„æ ‘ä¸­ã€‚æˆ‘ä»¬åªéœ€è¦å°†è¿™äº›éƒ¨åˆ†ç»„åˆæˆä¸€ä¸ªå¸ƒå°”ç­”æ¡ˆã€‚ç”±äºæœ‰ä¸‰ç§å¯èƒ½æ€§ï¼Œæˆ‘ä»¬åº”è¯¥ä½¿ç”¨`or`æ¥ç»„åˆå®ƒä»¬ã€‚
- en: 'Hereâ€™s the final code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯æœ€ç»ˆçš„ä»£ç ï¼š
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 7.1.3Â Summarizing How to Approach Tree Problems[ğŸ”—](#(part._.Summarizing_.How_to_.Approach_.Tree_.Problems)
    "Link to here")
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.3Â æ€»ç»“å¦‚ä½•å¤„ç†æ ‘é—®é¢˜[ğŸ”—](#(part._.Summarizing_.How_to_.Approach_.Tree_.Problems) "é“¾æ¥è‡³æ­¤")
- en: 'We design tree programs using the same design recipe that we covered on lists:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä½¿ç”¨ä¸æˆ‘ä»¬åœ¨åˆ—è¡¨ä¸Šè¦†ç›–çš„è®¾è®¡é…æ–¹è®¾è®¡æ ‘ç¨‹åºï¼š
- en: 'Strategy: Writing a Program Over Trees'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç­–ç•¥ï¼šåœ¨æ ‘ä¸Šç¼–å†™ç¨‹åº
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the datatype for your tree, including a base/leaf case
  id: totrans-98
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸ºä½ çš„æ ‘ç¼–å†™æ•°æ®ç±»å‹ï¼ŒåŒ…æ‹¬åŸºæœ¬/å¶èŠ‚ç‚¹æƒ…å†µ
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Write examples of your trees for use in testing
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸ºæµ‹è¯•ç¼–å†™ä½ çš„æ ‘ç¤ºä¾‹
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Write the function name, parameters, and types (the `fun` line)
  id: totrans-104
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¼–å†™å‡½æ•°åã€å‚æ•°å’Œç±»å‹ï¼ˆ`fun`è¡Œï¼‰
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-106
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Write `where` checks for your code
  id: totrans-107
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¼–å†™`where`æ£€æŸ¥ä½ çš„ä»£ç 
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-109
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the template, including the cases and recursive calls. Hereâ€™s the template
    again for an ancestor tree, for an arbitrary function called treeF:'
  id: totrans-110
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¼–å†™æ¨¡æ¿ï¼ŒåŒ…æ‹¬æƒ…å†µå’Œé€’å½’è°ƒç”¨ã€‚ä»¥ä¸‹æ˜¯ç¥–å…ˆæ ‘çš„æ¨¡æ¿ï¼Œå¯¹äºä»»æ„å‡½æ•°ç§°ä¸ºtreeFï¼š
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-112
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-114
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ''
  id: totrans-115
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Fill in the template with details specific to the problem
  id: totrans-117
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç”¨å…·ä½“é—®é¢˜çš„ç»†èŠ‚å¡«å†™æ¨¡æ¿
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Test your code using your examples
  id: totrans-120
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ä½ çš„ç¤ºä¾‹æµ‹è¯•ä½ çš„ä»£ç 
- en: 7.1.4Â Study Questions[ğŸ”—](#(part._.Study_.Questions) "Link to here")
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.4Â å­¦ä¹ é—®é¢˜[ğŸ”—](#(part._.Study_.Questions) "é“¾æ¥è‡³æ­¤")
- en: Think of writing in-tree on a table (using filter-by) vs writing it on a tree.
    How many times might each approach compare the name being sought against a name
    in the table/tree?
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æƒ³è±¡åœ¨è¡¨æ ¼ï¼ˆä½¿ç”¨æŒ‰è¿‡æ»¤ï¼‰ä¸Šå’Œåœ¨æ ‘ä¸Šç¼–å†™ã€‚æ¯ç§æ–¹æ³•å¯èƒ½éœ€è¦å¤šå°‘æ¬¡å°†æ‰€éœ€åç§°ä¸è¡¨æ ¼/æ ‘ä¸­çš„åç§°è¿›è¡Œæ¯”è¾ƒï¼Ÿ
- en: Why do we need to use a recursive function to process the tree?
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦ä½¿ç”¨é€’å½’å‡½æ•°æ¥å¤„ç†æ ‘ï¼Ÿ
- en: In what order will we check the names in the tree version?
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†æŒ‰ä»€ä¹ˆé¡ºåºæ£€æŸ¥æ ‘ç‰ˆæœ¬ä¸­çš„åç§°ï¼Ÿ
- en: For practice, try problems such as
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç»ƒä¹ ï¼Œå°è¯•ä»¥ä¸‹é—®é¢˜
- en: How many blue-eyed people are in the tree?
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ ‘ä¸­æœ‰å¤šå°‘è“çœ¼ç›çš„äººï¼Ÿ
- en: How many people are in the tree?
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ ‘ä¸­æœ‰å¤šå°‘äººï¼Ÿ
- en: How many generations are in the tree?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ ‘ä¸­æœ‰å¤šå°‘ä»£ï¼Ÿ
- en: How many people have a given name in a tree?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨æ ‘ä¸­æœ‰å¤šå°‘äººæœ‰ä¸€ä¸ªç‰¹å®šçš„åå­—ï¼Ÿ
- en: How many people have names starting with "A"?
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ‰å¤šå°‘äººçš„åå­—ä»¥"A"å¼€å¤´ï¼Ÿ
- en: '... and so on'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '...ç­‰ç­‰'
- en: 7.1.1Â Data Design Problem â€“ Ancestry Data[ğŸ”—](#(part._ancestor-trees) "Link to
    here")
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1Â æ•°æ®è®¾è®¡é—®é¢˜ â€“ å®¶è°±æ•°æ®[ğŸ”—](#(part._ancestor-trees) "é“¾æ¥è‡³æ­¤")
- en: 'Imagine that we wanted to manage ancestry information for purposes of a medical
    research study. Specifically, we want to record peopleâ€™s birthyear, eye colors,
    and genetic parents. Hereâ€™s a sample table of such data, with one row for each
    person:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœæˆ‘ä»¬æƒ³ä¸ºäº†åŒ»å­¦ç ”ç©¶çš„ç›®çš„ç®¡ç†å®¶è°±ä¿¡æ¯ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬æƒ³è®°å½•äººä»¬çš„å‡ºç”Ÿå¹´ä»½ã€çœ¼ç›é¢œè‰²å’Œé—ä¼ çˆ¶æ¯ã€‚ä»¥ä¸‹æ˜¯è¿™æ ·æ•°æ®çš„æ ·æœ¬è¡¨ï¼Œæ¯äººä¸€è¡Œï¼š
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For our research, we want to be able to answer questions such as the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æˆ‘ä»¬çš„ç ”ç©¶ï¼Œæˆ‘ä»¬å¸Œæœ›èƒ½å¤Ÿå›ç­”ä»¥ä¸‹é—®é¢˜ï¼š
- en: Who are the genetic grandparents of a specific person?
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç‰¹å®šäººå‘˜çš„é—ä¼ ç¥–çˆ¶æ¯æ˜¯è°ï¼Ÿ
- en: How frequent is each eye color?
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¯ç§çœ¼ç›é¢œè‰²çš„é¢‘ç‡æ˜¯å¤šå°‘ï¼Ÿ
- en: Is one specific person an ancestor of another specific person?
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ˜¯å¦æœ‰ç‰¹å®šçš„äººæ˜¯å¦ä¸€ä¸ªç‰¹å®šäººçš„ç¥–å…ˆï¼Ÿ
- en: How many generations do we have information for?
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ‰å¤šå°‘ä»£çš„ä¿¡æ¯ï¼Ÿ
- en: Does oneâ€™s eye color correlate with the ages of their genetic parents when they
    were born?
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªäººå‡ºç”Ÿæ—¶ï¼Œä»–ä»¬çš„çœ¼ç›é¢œè‰²æ˜¯å¦ä¸é—ä¼ çˆ¶æ¯çš„å¹´é¾„ç›¸å…³ï¼Ÿ
- en: 'Letâ€™s start with the first question:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»ç¬¬ä¸€ä¸ªé—®é¢˜å¼€å§‹ï¼š
- en: Do Now!
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹å³è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you compute a list of the known grandparents for a given person? For
    purposes of this chapter, you may assume that each person has a unique name (while
    this isnâ€™t realistic in practice, it will simplify our computations for the time
    being; we will revisit it later in the chapter).
  id: totrans-144
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ ä¼šå¦‚ä½•è®¡ç®—ç»™å®šäººå‘˜çš„å·²çŸ¥ç¥–çˆ¶æ¯åˆ—è¡¨ï¼Ÿåœ¨æœ¬ç« ä¸­ï¼Œä½ å¯ä»¥å‡è®¾æ¯ä¸ªäººéƒ½æœ‰ä¸€ä¸ªç‹¬ç‰¹çš„åå­—ï¼ˆè™½ç„¶è¿™åœ¨å®è·µä¸­å¹¶ä¸ç°å®ï¼Œä½†è¿™å°†ç®€åŒ–æˆ‘ä»¬ç›®å‰çš„è®¡ç®—ï¼›æˆ‘ä»¬å°†åœ¨æœ¬ç« ç¨åé‡æ–°è®¨è®ºè¿™ä¸ªé—®é¢˜ï¼‰ã€‚
- en: ''
  id: totrans-145
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '(Hint: Make a task plan. Does it suggest any particular helper functions?)'
  id: totrans-146
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ï¼ˆæç¤ºï¼šåˆ¶å®šä»»åŠ¡è®¡åˆ’ã€‚å®ƒæ˜¯å¦å»ºè®®ä»»ä½•ç‰¹å®šçš„è¾…åŠ©å‡½æ•°ï¼Ÿï¼‰
- en: 'Our task plan has two key steps: find the names of the genetic parents of the
    named person, then find the names of the parents of each of those people. Both
    steps share the need to compute the known parents from a name, so we should create
    a helper function for that (weâ€™ll call it `parents-of`). Since this sounds like
    a routine table program, we can use it for a bit of review:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ä»»åŠ¡è®¡åˆ’æœ‰ä¸¤ä¸ªå…³é”®æ­¥éª¤ï¼šæ‰¾åˆ°æŒ‡å®šäººå‘˜çš„é—ä¼ çˆ¶æ¯çš„å§“åï¼Œç„¶åæ‰¾åˆ°è¿™äº›äººå‘˜çš„çˆ¶æ¯çš„å§“åã€‚è¿™ä¸¤ä¸ªæ­¥éª¤éƒ½éœ€è¦ä»å§“åè®¡ç®—å·²çŸ¥çˆ¶æ¯ï¼Œå› æ­¤æˆ‘ä»¬åº”è¯¥ä¸ºè¿™ä¸ªåˆ›å»ºä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼ˆæˆ‘ä»¬å°†å®ƒç§°ä¸º`parents-of`ï¼‰ã€‚ç”±äºè¿™å¬èµ·æ¥åƒæ˜¯ä¸€ä¸ªå¸¸è§„çš„è¡¨æ ¼ç¨‹åºï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥å¤ä¹ ä¸€ä¸‹ï¼š
- en: 7.1.1.1Â Computing Genetic Parents from an Ancestry Table[ğŸ”—](#(part._compute-parents-table)
    "Link to here")
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.1Â ä»å®¶è°±è¡¨ä¸­è®¡ç®—é—ä¼ çˆ¶æ¯[ğŸ”—](#(part._compute-parents-table) "é“¾æ¥è‡³æ­¤")
- en: 'How do we compute a list of someoneâ€™s genetic parents? Letâ€™s sketch a task
    plan for that:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•è®¡ç®—æŸäººçš„é—ä¼ çˆ¶æ¯åˆ—è¡¨ï¼Ÿè®©æˆ‘ä»¬ä¸ºè¿™ä¸ªä»»åŠ¡è‰æ‹Ÿä¸€ä¸ªè®¡åˆ’ï¼š
- en: filter the table to find the person
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿‡æ»¤è¡¨æ ¼ä»¥æ‰¾åˆ°è¿™ä¸ªäºº
- en: extract the name of the female parent
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æå–å¥³æ€§çˆ¶æ¯çš„å§“å
- en: extract the name of the male parent
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æå–ç”·æ€§çˆ¶æ¯çš„å§“å
- en: make a list of those names
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ—å‡ºè¿™äº›åå­—
- en: 'These are tasks we have seen before, so we can translate this plan directly
    into code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ˜¯æˆ‘ä»¬ä¹‹å‰è§è¿‡çš„ä»»åŠ¡ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥å°†è¿™ä¸ªè®¡åˆ’è½¬æ¢ä¸ºä»£ç ï¼š
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Do Now!
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Are you satisfied with this program? With the examples included in the `where`
    block? Write down any critiques you have.
  id: totrans-158
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ å¯¹è¿™ä¸ªç¨‹åºæ»¡æ„å—ï¼ŸåŒ…æ‹¬åœ¨`where`å—ä¸­çš„ç¤ºä¾‹ï¼Ÿå†™ä¸‹ä½ æ‰€æœ‰çš„æ‰¹è¯„æ„è§ã€‚
- en: There are arguably some issues here. How many of these did you catch?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œå¯èƒ½æœ‰ä¸€äº›é—®é¢˜ã€‚ä½ å‘ç°äº†å¤šå°‘ï¼Ÿ
- en: 'The examples are weak: none of them consider people for whom we are missing
    information on at least one parent.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¤ºä¾‹å¾ˆå¼±ï¼šå®ƒä»¬éƒ½æ²¡æœ‰è€ƒè™‘è‡³å°‘ä¸€ä¸ªçˆ¶æ¯ä¿¡æ¯ç¼ºå¤±çš„äººã€‚
- en: The list of names returned in the case of an unknown parent includes the empty
    string, which isnâ€™t actually a name. This could cause problems if we use this
    list of names in a subsequent computation (such as to compute the names of someoneâ€™s
    grandparents).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨æœªçŸ¥çˆ¶æ¯çš„æƒ…å†µä¸‹è¿”å›çš„å§“ååˆ—è¡¨ä¸­åŒ…æ‹¬ç©ºå­—ç¬¦ä¸²ï¼Œè¿™å®é™…ä¸Šå¹¶ä¸æ˜¯ä¸€ä¸ªåå­—ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªå§“ååˆ—è¡¨è¿›è¡Œåç»­è®¡ç®—ï¼ˆä¾‹å¦‚è®¡ç®—æŸäººçš„ç¥–çˆ¶æ¯å§“åï¼‰ï¼Œè¿™å¯èƒ½ä¼šå¼•èµ·é—®é¢˜ã€‚
- en: If empty strings are not part of the output list, then weâ€™d get the same result
    from asking for the parents of `"Robert"` (who is in the table) as for `"Kathi"`
    (who is not). These are fundamentally different cases, which arguably demand different
    outputs so we can tell them apart.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœç©ºå­—ç¬¦ä¸²ä¸æ˜¯è¾“å‡ºåˆ—è¡¨çš„ä¸€éƒ¨åˆ†ï¼Œé‚£ä¹ˆæˆ‘ä»¬è¯¢é—®`"Robert"`ï¼ˆä»–åœ¨è¡¨ä¸­ï¼‰çš„çˆ¶æ¯å’Œè¯¢é—®`"Kathi"`ï¼ˆä»–ä¸åœ¨è¡¨ä¸­ï¼‰çš„çˆ¶æ¯å°†å¾—åˆ°ç›¸åŒçš„ç»“æœã€‚è¿™äº›æ˜¯æ ¹æœ¬ä¸åŒçš„æ¡ˆä¾‹ï¼Œå¯ä»¥è¯´éœ€è¦ä¸åŒçš„è¾“å‡ºä»¥ä¾¿æˆ‘ä»¬å¯ä»¥åŒºåˆ†å®ƒä»¬ã€‚
- en: 'To fix these problems, we need to remove the empty strings from the produced
    list of parents and return something other than the `empty` list when a name is
    not in the table. Since the output of this function is a list of strings, itâ€™s
    hard to see what to return that couldnâ€™t be confused for a valid list of names.
    Our solution for now is to have Pyret throw an error (like the ones you get when
    Pyret is not able to finish running your program). Hereâ€™s a solution that handles
    both problems:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ä¿®å¤è¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦ä»äº§ç”Ÿçš„çˆ¶æ¯åˆ—è¡¨ä¸­åˆ é™¤ç©ºå­—ç¬¦ä¸²ï¼Œå¹¶åœ¨å§“åä¸åœ¨è¡¨ä¸­æ—¶è¿”å›é™¤`empty`åˆ—è¡¨ä¹‹å¤–çš„å†…å®¹ã€‚ç”±äºè¿™ä¸ªå‡½æ•°çš„è¾“å‡ºæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œå¾ˆéš¾çœ‹å‡ºå¯ä»¥è¿”å›ä»€ä¹ˆä¸ä¼šä¸æœ‰æ•ˆçš„å§“ååˆ—è¡¨æ··æ·†ã€‚æˆ‘ä»¬ç°åœ¨çš„è§£å†³æ–¹æ¡ˆæ˜¯è®©PyretæŠ›å‡ºä¸€ä¸ªé”™è¯¯ï¼ˆå°±åƒä½ åœ¨Pyretæ— æ³•å®Œæˆè¿è¡Œä½ çš„ç¨‹åºæ—¶å¾—åˆ°çš„é‚£æ ·ï¼‰ã€‚è¿™æ˜¯ä¸€ä¸ªå¤„ç†è¿™ä¸¤ä¸ªé—®é¢˜çš„è§£å†³æ–¹æ¡ˆï¼š
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `raise` construct tells Pyret to halt the program and produce an error message.
    The error message does not have to match the expected output type of the program.
    If you run this function with a name that is not in the table, youâ€™ll see an error
    appear in the interactions pane, with no result returned.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`raise`æ„é€ å‡½æ•°å‘Šè¯‰Pyretåœæ­¢ç¨‹åºå¹¶äº§ç”Ÿä¸€ä¸ªé”™è¯¯ä¿¡æ¯ã€‚é”™è¯¯ä¿¡æ¯ä¸å¿…ä¸ç¨‹åºé¢„æœŸçš„è¾“å‡ºç±»å‹ç›¸åŒ¹é…ã€‚å¦‚æœä½ ç”¨ä¸åœ¨è¡¨æ ¼ä¸­çš„åå­—è¿è¡Œè¿™ä¸ªå‡½æ•°ï¼Œä½ ä¼šåœ¨äº¤äº’é¢æ¿ä¸­çœ‹åˆ°ä¸€ä¸ªé”™è¯¯å‡ºç°ï¼Œå¹¶ä¸”æ²¡æœ‰è¿”å›ç»“æœã€‚'
- en: 'Within the `where` block, we see how to check whether an expression will yield
    an error: instead of using `is` to check the equality of values, we use `raises`
    to check whether the provided string is a sub-string of the actual error produced
    by the program.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨`where`å—ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°å¦‚ä½•æ£€æŸ¥è¡¨è¾¾å¼æ˜¯å¦ä¼šäº§ç”Ÿé”™è¯¯ï¼šæˆ‘ä»¬ä¸æ˜¯ä½¿ç”¨`is`æ¥æ£€æŸ¥å€¼çš„ç›¸ç­‰æ€§ï¼Œè€Œæ˜¯ä½¿ç”¨`raises`æ¥æ£€æŸ¥æä¾›çš„å­—ç¬¦ä¸²æ˜¯å¦æ˜¯ç¨‹åºå®é™…äº§ç”Ÿçš„é”™è¯¯çš„ä¸€ä¸ªå­å­—ç¬¦ä¸²ã€‚
- en: 7.1.1.2Â Computing Grandparents from an Ancestry Table[ğŸ”—](#(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)
    "Link to here")
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.2Â ä»å®¶è°±è¡¨ä¸­è®¡ç®—ç¥–çˆ¶æ¯[ğŸ”—](#(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)
    "é“¾æ¥è‡³æ­¤")
- en: 'Once we have the `parents-of` function, we should be able to compute the grandparents
    by computing parents of parents, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬æœ‰äº†`parents-of`å‡½æ•°ï¼Œæˆ‘ä»¬åº”è¯¥èƒ½å¤Ÿé€šè¿‡è®¡ç®—çˆ¶æ¯çš„çˆ¶æ¯æ¥è®¡ç®—ç¥–çˆ¶æ¯ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Do Now!
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Look back at our sample ancestry tree: for which people would this correctly
    compute the list of grandparents?'
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å›é¡¾æˆ‘ä»¬çš„æ ·æœ¬å®¶è°±æ ‘ï¼šå¯¹äºå“ªäº›äººï¼Œè¿™ä¸ªè®¡ç®—å¯ä»¥æ­£ç¡®åœ°è®¡ç®—å‡ºç¥–çˆ¶æ¯åˆ—è¡¨ï¼Ÿ
- en: This grandparents-of code works fine for someone who has both parents in the
    table. For someone without two parents, however, the `plist` will have fewer than
    two names, so the expression `plist.rest.first` (if not `plist.first`) will yield
    an error.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µè®¡ç®—ç¥–çˆ¶æ¯çš„ä»£ç å¯¹äºè¡¨æ ¼ä¸­åŒæ—¶æœ‰åŒäº²çš„äººæ¥è¯´æ˜¯æœ‰æ•ˆçš„ã€‚ç„¶è€Œï¼Œå¯¹äºæ²¡æœ‰åŒäº²çš„äººæ¥è¯´ï¼Œ`plist`å°†å°‘äºä¸¤ä¸ªåå­—ï¼Œæ‰€ä»¥è¡¨è¾¾å¼`plist.rest.first`ï¼ˆå¦‚æœä¸æ˜¯`plist.first`ï¼‰å°†äº§ç”Ÿé”™è¯¯ã€‚
- en: 'Hereâ€™s a version that checks the number of parents before computing the set
    of grandparents:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªåœ¨è®¡ç®—ç¥–çˆ¶æ¯é›†åˆä¹‹å‰æ£€æŸ¥çˆ¶æ¯æ•°é‡çš„ç‰ˆæœ¬ï¼š
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What if we now wanted to gather up all of someoneâ€™s ancestors? Since we donâ€™t
    know how many generations there are, weâ€™d need to use recursion. This approach
    would also be expensive, since weâ€™d end up filtering over the table over and over,
    which checks every row of the table in each use of `filter`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ç°åœ¨æƒ³æ”¶é›†æŸäººçš„æ‰€æœ‰ç¥–å…ˆå‘¢ï¼Ÿç”±äºæˆ‘ä»¬ä¸çŸ¥é“æœ‰å¤šå°‘ä»£ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨é€’å½’ã€‚è¿™ç§æ–¹æ³•ä¹Ÿä¼šå¾ˆæ˜‚è´µï¼Œå› ä¸ºæˆ‘ä»¬æœ€ç»ˆä¼šå¤šæ¬¡è¿‡æ»¤è¡¨ï¼Œæ¯æ¬¡ä½¿ç”¨`filter`éƒ½ä¼šæ£€æŸ¥è¡¨ä¸­çš„æ¯ä¸€è¡Œã€‚
- en: Look back at the ancestry tree picture. We donâ€™t do any complicated filtering
    there â€“ we just follow the line in the picture immediately from a person to their
    mother or father. Can we get that idea in code instead? Yes, through datatypes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: å›é¡¾ç¥–å…ˆæ ‘å›¾ç‰‡ã€‚æˆ‘ä»¬é‚£é‡Œæ²¡æœ‰åšä»»ä½•å¤æ‚çš„è¿‡æ»¤â€”â€”æˆ‘ä»¬åªæ˜¯ä»ä¸€ä¸ªäººç›´æ¥è·Ÿéšå›¾ç‰‡ä¸­çš„çº¿æ¡åˆ°ä»–ä»¬çš„æ¯äº²æˆ–çˆ¶äº²ã€‚æˆ‘ä»¬èƒ½å¦åœ¨ä»£ç ä¸­å®ç°è¿™ä¸ªæƒ³æ³•ï¼Ÿæ˜¯çš„ï¼Œé€šè¿‡æ•°æ®ç±»å‹ã€‚
- en: 7.1.1.3Â Creating a Datatype for Ancestor Trees[ğŸ”—](#(part._ancestor-tree) "Link
    to here")
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.3Â åˆ›å»ºç¥–å…ˆæ ‘çš„æ•°æ®ç±»å‹[ğŸ”—](#(part._ancestor-tree) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'For this approach, we want to create a datatype for Ancestor Trees that has
    a variant (constructor) for setting up a person. Look back at our picture â€“ what
    information makes up a person? Their name, their mother, and their father (along
    with birthyear and eyecolor, which arenâ€™t shown in the picture). This suggests
    the following datatype, which basically turns a row into a person value:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºè¿™ç§æ–¹æ³•ï¼Œæˆ‘ä»¬å¸Œæœ›ä¸ºç¥–å…ˆæ ‘åˆ›å»ºä¸€ä¸ªæ•°æ®ç±»å‹ï¼Œå®ƒæœ‰ä¸€ä¸ªç”¨äºè®¾ç½®ä¸ªäººçš„å˜ä½“ï¼ˆæ„é€ å‡½æ•°ï¼‰ã€‚å›é¡¾æˆ‘ä»¬çš„å›¾ç‰‡â€”â€”ä»€ä¹ˆä¿¡æ¯æ„æˆäº†ä¸€ä¸ªäººï¼Ÿä»–ä»¬çš„åå­—ã€ä»–ä»¬çš„æ¯äº²å’Œä»–ä»¬çš„çˆ¶äº²ï¼ˆä»¥åŠå‡ºç”Ÿå¹´ä»½å’Œçœ¼ç›é¢œè‰²ï¼Œè¿™äº›åœ¨å›¾ç‰‡ä¸­æ²¡æœ‰æ˜¾ç¤ºï¼‰ã€‚è¿™è¡¨æ˜ä»¥ä¸‹æ•°æ®ç±»å‹ï¼Œå®ƒåŸºæœ¬ä¸Šå°†ä¸€è¡Œè½¬æ¢æˆä¸ªäººå€¼ï¼š
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For example, annaâ€™s row might look like:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œå®‰å¨œçš„è¡Œå¯èƒ½çœ‹èµ·æ¥åƒï¼š
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What type do we put in the blanks? A quick brainstorm yields several ideas:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åº”è¯¥æŠŠä»€ä¹ˆç±»å‹å¡«å…¥ç©ºç™½å¤„ï¼Ÿå¿«é€Ÿå¤´è„‘é£æš´äº§ç”Ÿäº†å‡ ä¸ªæƒ³æ³•ï¼š
- en: '`person`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`person`'
- en: '`List<person>`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<person>`'
- en: some new datatype
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€äº›æ–°çš„æ•°æ®ç±»å‹
- en: '`AncTree`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AncTree`'
- en: '`String`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`'
- en: Which should it be?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒåº”è¯¥æ˜¯è¿™æ ·çš„ï¼Ÿ
- en: If we use a `String`, weâ€™re back to the table row, and we donâ€™t end up with
    a way to easily get from one person to another. We should therefore make this
    an `AncTree`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ª`String`ï¼Œæˆ‘ä»¬å°±ä¼šå›åˆ°è¡¨æ ¼è¡Œï¼Œå¹¶ä¸”æ— æ³•è½»æ¾åœ°ä»ä¸€ä¸ªäººè·³è½¬åˆ°å¦ä¸€ä¸ªäººã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥å°†å…¶åšæˆä¸€ä¸ª`AncTree`ã€‚
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Do Now!
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the `AncTree` starting from `Anna` using this definition.
  id: totrans-194
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸ªå®šä¹‰ä»â€œAnnaâ€å¼€å§‹ç¼–å†™`AncTree`ã€‚
- en: Did you get stuck? What do we do when we run out of known people? To handle
    that, we must add an option in the `AncTree` definition to capture people for
    whom we donâ€™t know anything.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¡ä½äº†å—ï¼Ÿå½“æˆ‘ä»¬ç”¨å®Œå·²çŸ¥çš„äººæ—¶ï¼Œæˆ‘ä»¬è¯¥æ€ä¹ˆåŠï¼Ÿä¸ºäº†å¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨`AncTree`å®šä¹‰ä¸­æ·»åŠ ä¸€ä¸ªé€‰é¡¹æ¥æ•æ‰æˆ‘ä»¬ä¸€æ— æ‰€çŸ¥çš„äººã€‚
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Hereâ€™s Annaâ€™s tree written in this datatype:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ç”¨è¿™ç§æ•°æ®ç±»å‹ç¼–å†™çš„å®‰å¨œçš„æ ‘ï¼š
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We could also have named each person data individually.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹Ÿå¯ä»¥ä¸ºæ¯ä¸ªä¸ªäººæ•°æ®å•ç‹¬å‘½åã€‚
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The latter gives you pieces of the tree to use as other examples, but loses
    the structure that is visible in the indentation of the first version. You could
    get to pieces of the first version by digging into the data, such as writing `anna-tree.mother.mother`
    to get to the tree starting from "Ellen".
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: åè€…æä¾›äº†æ ‘çš„éƒ¨åˆ†ä»¥ç”¨ä½œå…¶ä»–ç¤ºä¾‹ï¼Œä½†å¤±å»äº†ç¬¬ä¸€ç‰ˆä¸­å¯è§çš„ç»“æ„ã€‚ä½ å¯ä»¥é€šè¿‡æ·±å…¥æ•°æ®æ¥è·å¾—ç¬¬ä¸€ç‰ˆçš„éƒ¨åˆ†ï¼Œä¾‹å¦‚ï¼Œé€šè¿‡ç¼–å†™`anna-tree.mother.mother`æ¥ä»â€œEllenâ€å¼€å§‹è·å–æ ‘ã€‚
- en: 'Hereâ€™s the `parents-of` function written against `AncTree`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯é’ˆå¯¹`AncTree`ç¼–å†™çš„`parents-of`å‡½æ•°ï¼š
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 7.1.1.1Â Computing Genetic Parents from an Ancestry Table[ğŸ”—](#(part._compute-parents-table)
    "Link to here")
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.1Â ä»å®¶è°±è¡¨ä¸­è®¡ç®—é—ä¼ çˆ¶æ¯[ğŸ”—](#(part._compute-parents-table) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'How do we compute a list of someoneâ€™s genetic parents? Letâ€™s sketch a task
    plan for that:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•è®¡ç®—æŸäººçš„é—ä¼ çˆ¶æ¯åˆ—è¡¨ï¼Ÿè®©æˆ‘ä»¬ä¸ºè¿™ä¸ªä»»åŠ¡è‰æ‹Ÿä¸€ä¸ªè®¡åˆ’ï¼š
- en: filter the table to find the person
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿‡æ»¤è¡¨ä»¥æ‰¾åˆ°ä¸ªäºº
- en: extract the name of the female parent
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æå–å¥³æ€§çˆ¶æ¯çš„å§“å
- en: extract the name of the male parent
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æå–ç”·æ€§çˆ¶æ¯çš„å§“å
- en: make a list of those names
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ¶ä½œè¿™äº›åå­—çš„åˆ—è¡¨
- en: 'These are tasks we have seen before, so we can translate this plan directly
    into code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ˜¯æˆ‘ä»¬ä¹‹å‰è§è¿‡çš„ä»»åŠ¡ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç›´æ¥å°†æ­¤è®¡åˆ’è½¬æ¢ä¸ºä»£ç ï¼š
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Do Now!
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Are you satisfied with this program? With the examples included in the `where`
    block? Write down any critiques you have.
  id: totrans-214
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ å¯¹è¿™ä¸ªç¨‹åºæ»¡æ„å—ï¼ŸåŒ…æ‹¬åœ¨`where`å—ä¸­çš„ç¤ºä¾‹å—ï¼Ÿå†™ä¸‹ä½ æ‰€æœ‰çš„æ‰¹è¯„ã€‚
- en: There are arguably some issues here. How many of these did you catch?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œå¯èƒ½æœ‰ä¸€äº›é—®é¢˜ã€‚ä½ æŠ“ä½äº†å¤šå°‘ï¼Ÿ
- en: 'The examples are weak: none of them consider people for whom we are missing
    information on at least one parent.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¾‹å­ä¸å¤Ÿå¼ºå¤§ï¼šå®ƒä»¬ä¸­æ²¡æœ‰ä¸€ä¸ªè€ƒè™‘è‡³å°‘ç¼ºå¤±ä¸€ä¸ªçˆ¶æ¯ä¿¡æ¯çš„ä¸ªäººã€‚
- en: The list of names returned in the case of an unknown parent includes the empty
    string, which isnâ€™t actually a name. This could cause problems if we use this
    list of names in a subsequent computation (such as to compute the names of someoneâ€™s
    grandparents).
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨æœªçŸ¥çˆ¶æ¯çš„æƒ…å†µä¸‹è¿”å›çš„å§“ååˆ—è¡¨ä¸­åŒ…å«ç©ºå­—ç¬¦ä¸²ï¼Œè¿™å®é™…ä¸Šå¹¶ä¸æ˜¯ä¸€ä¸ªå§“åã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªå§“ååˆ—è¡¨è¿›è¡Œåç»­è®¡ç®—ï¼ˆä¾‹å¦‚è®¡ç®—æŸäººçš„ç¥–çˆ¶æ¯å§“åï¼‰ï¼Œè¿™å¯èƒ½ä¼šå¼•èµ·é—®é¢˜ã€‚
- en: If empty strings are not part of the output list, then weâ€™d get the same result
    from asking for the parents of `"Robert"` (who is in the table) as for `"Kathi"`
    (who is not). These are fundamentally different cases, which arguably demand different
    outputs so we can tell them apart.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœç©ºå­—ç¬¦ä¸²ä¸æ˜¯è¾“å‡ºåˆ—è¡¨çš„ä¸€éƒ¨åˆ†ï¼Œé‚£ä¹ˆä»è¯·æ±‚ `"Robert"`ï¼ˆä»–åœ¨è¡¨ä¸­ï¼‰çš„çˆ¶æ¯å’Œè¯·æ±‚ `"Kathi"`ï¼ˆå¥¹ä¸åœ¨è¡¨ä¸­ï¼‰çš„çˆ¶æ¯å°†å¾—åˆ°ç›¸åŒçš„ç»“æœã€‚è¿™äº›æ˜¯æ ¹æœ¬ä¸åŒçš„æ¡ˆä¾‹ï¼Œå¯ä»¥è¯´éœ€è¦ä¸åŒçš„è¾“å‡ºä»¥ä¾¿æˆ‘ä»¬å¯ä»¥åŒºåˆ†å®ƒä»¬ã€‚
- en: 'To fix these problems, we need to remove the empty strings from the produced
    list of parents and return something other than the `empty` list when a name is
    not in the table. Since the output of this function is a list of strings, itâ€™s
    hard to see what to return that couldnâ€™t be confused for a valid list of names.
    Our solution for now is to have Pyret throw an error (like the ones you get when
    Pyret is not able to finish running your program). Hereâ€™s a solution that handles
    both problems:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†è§£å†³è¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦ä»ç”Ÿæˆçš„çˆ¶æ¯åˆ—è¡¨ä¸­ç§»é™¤ç©ºå­—ç¬¦ä¸²ï¼Œå¹¶åœ¨å§“åä¸åœ¨è¡¨ä¸­æ—¶è¿”å›é™¤ç©ºåˆ—è¡¨ä¹‹å¤–çš„å†…å®¹ã€‚ç”±äºæ­¤å‡½æ•°çš„è¾“å‡ºæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œå¾ˆéš¾çœ‹å‡ºè¿”å›çš„å†…å®¹ä¸ä¼šä¸æœ‰æ•ˆçš„å§“ååˆ—è¡¨æ··æ·†ã€‚æˆ‘ä»¬ç›®å‰çš„è§£å†³æ–¹æ¡ˆæ˜¯è®©PyretæŠ›å‡ºé”™è¯¯ï¼ˆå°±åƒPyretæ— æ³•å®Œæˆè¿è¡Œä½ çš„ç¨‹åºæ—¶å¾—åˆ°çš„é”™è¯¯ä¸€æ ·ï¼‰ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªè§£å†³è¿™ä¸¤ä¸ªé—®é¢˜çš„è§£å†³æ–¹æ¡ˆï¼š
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `raise` construct tells Pyret to halt the program and produce an error message.
    The error message does not have to match the expected output type of the program.
    If you run this function with a name that is not in the table, youâ€™ll see an error
    appear in the interactions pane, with no result returned.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`raise` æ„é€ å‡½æ•°å‘Šè¯‰Pyretåœæ­¢ç¨‹åºå¹¶ç”Ÿæˆä¸€ä¸ªé”™è¯¯æ¶ˆæ¯ã€‚é”™è¯¯æ¶ˆæ¯ä¸éœ€è¦ä¸ç¨‹åºçš„é¢„æœŸè¾“å‡ºç±»å‹åŒ¹é…ã€‚å¦‚æœä½ ç”¨ä¸åœ¨è¡¨ä¸­çš„å§“åè¿è¡Œæ­¤å‡½æ•°ï¼Œä½ å°†åœ¨äº¤äº’å¼é¢æ¿ä¸­çœ‹åˆ°ä¸€ä¸ªé”™è¯¯å‡ºç°ï¼Œå¹¶ä¸”æ²¡æœ‰è¿”å›ç»“æœã€‚'
- en: 'Within the `where` block, we see how to check whether an expression will yield
    an error: instead of using `is` to check the equality of values, we use `raises`
    to check whether the provided string is a sub-string of the actual error produced
    by the program.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ `where` å—ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°å¦‚ä½•æ£€æŸ¥è¡¨è¾¾å¼æ˜¯å¦ä¼šç”Ÿæˆé”™è¯¯ï¼šæˆ‘ä»¬ä¸æ˜¯ä½¿ç”¨ `is` æ¥æ£€æŸ¥å€¼çš„ç›¸ç­‰æ€§ï¼Œè€Œæ˜¯ä½¿ç”¨ `raises` æ¥æ£€æŸ¥æä¾›çš„å­—ç¬¦ä¸²æ˜¯å¦æ˜¯ç¨‹åºå®é™…äº§ç”Ÿçš„é”™è¯¯æ¶ˆæ¯çš„å­å­—ç¬¦ä¸²ã€‚
- en: 7.1.1.2Â Computing Grandparents from an Ancestry Table[ğŸ”—](#(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)
    "Link to here")
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.2 ä»å®¶è°±è¡¨ä¸­è®¡ç®—ç¥–çˆ¶æ¯[ğŸ”—](#(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Once we have the `parents-of` function, we should be able to compute the grandparents
    by computing parents of parents, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬æœ‰äº† `parents-of` å‡½æ•°ï¼Œæˆ‘ä»¬å°±åº”è¯¥èƒ½å¤Ÿé€šè¿‡è®¡ç®—çˆ¶æ¯çš„çˆ¶æ¯æ¥è®¡ç®—ç¥–çˆ¶æ¯ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Do Now!
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Look back at our sample ancestry tree: for which people would this correctly
    compute the list of grandparents?'
  id: totrans-228
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å›é¡¾æˆ‘ä»¬çš„ç¤ºä¾‹å®¶è°±æ ‘ï¼šå¯¹äºå“ªäº›äººï¼Œè¿™å°†æ­£ç¡®è®¡ç®—å‡ºç¥–çˆ¶æ¯çš„åˆ—è¡¨ï¼Ÿ
- en: This grandparents-of code works fine for someone who has both parents in the
    table. For someone without two parents, however, the `plist` will have fewer than
    two names, so the expression `plist.rest.first` (if not `plist.first`) will yield
    an error.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µå…³äºç¥–çˆ¶æ¯çš„ä»£ç å¯¹äºåœ¨è¡¨ä¸­éƒ½æœ‰çˆ¶æ¯çš„ä¸ªäººæ¥è¯´æ˜¯æœ‰æ•ˆçš„ã€‚ç„¶è€Œï¼Œå¯¹äºæ²¡æœ‰ä¸¤ä¸ªçˆ¶æ¯çš„ä¸ªäººï¼Œ`plist` å°†åŒ…å«å°‘äºä¸¤ä¸ªå§“åï¼Œå› æ­¤è¡¨è¾¾å¼ `plist.rest.first`ï¼ˆå¦‚æœä¸æ˜¯
    `plist.first`ï¼‰å°†äº§ç”Ÿé”™è¯¯ã€‚
- en: 'Hereâ€™s a version that checks the number of parents before computing the set
    of grandparents:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªåœ¨è®¡ç®—ç¥–çˆ¶æ¯çš„é›†åˆä¹‹å‰æ£€æŸ¥çˆ¶æ¯æ•°é‡çš„ç‰ˆæœ¬ï¼š
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What if we now wanted to gather up all of someoneâ€™s ancestors? Since we donâ€™t
    know how many generations there are, weâ€™d need to use recursion. This approach
    would also be expensive, since weâ€™d end up filtering over the table over and over,
    which checks every row of the table in each use of `filter`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ç°åœ¨æƒ³æ”¶é›†æŸäººçš„æ‰€æœ‰ç¥–å…ˆå‘¢ï¼Ÿç”±äºæˆ‘ä»¬ä¸çŸ¥é“æœ‰å¤šå°‘ä»£ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨é€’å½’ã€‚è¿™ç§æ–¹æ³•ä¹Ÿä¼šå¾ˆæ˜‚è´µï¼Œå› ä¸ºæˆ‘ä»¬æœ€ç»ˆä¼šå¤šæ¬¡è¿‡æ»¤è¡¨ï¼Œæ¯æ¬¡ä½¿ç”¨ `filter`
    éƒ½ä¼šæ£€æŸ¥è¡¨çš„æ¯ä¸€è¡Œã€‚
- en: Look back at the ancestry tree picture. We donâ€™t do any complicated filtering
    there â€“ we just follow the line in the picture immediately from a person to their
    mother or father. Can we get that idea in code instead? Yes, through datatypes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: å›é¡¾å®¶è°±æ ‘å›¾ç‰‡ã€‚æˆ‘ä»¬é‚£é‡Œæ²¡æœ‰è¿›è¡Œä»»ä½•å¤æ‚çš„è¿‡æ»¤â€”â€”æˆ‘ä»¬åªæ˜¯ä»ä¸€ä¸ªäººç›´æ¥è·Ÿéšåˆ°ä»–ä»¬çš„æ¯äº²æˆ–çˆ¶äº²ã€‚æˆ‘ä»¬èƒ½å¦åœ¨ä»£ç ä¸­å®ç°è¿™ä¸ªæƒ³æ³•ï¼Ÿæ˜¯çš„ï¼Œé€šè¿‡æ•°æ®ç±»å‹ã€‚
- en: 7.1.1.3Â Creating a Datatype for Ancestor Trees[ğŸ”—](#(part._ancestor-tree) "Link
    to here")
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.1.1.3 åˆ›å»ºç¥–å…ˆæ ‘çš„æ•°æ®ç±»å‹[ğŸ”—](#(part._ancestor-tree) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'For this approach, we want to create a datatype for Ancestor Trees that has
    a variant (constructor) for setting up a person. Look back at our picture â€“ what
    information makes up a person? Their name, their mother, and their father (along
    with birthyear and eyecolor, which arenâ€™t shown in the picture). This suggests
    the following datatype, which basically turns a row into a person value:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºè¿™ç§æ–¹æ³•ï¼Œæˆ‘ä»¬å¸Œæœ›ä¸ºç¥–å…ˆæ ‘åˆ›å»ºä¸€ä¸ªæ•°æ®ç±»å‹ï¼Œå®ƒæœ‰ä¸€ä¸ªç”¨äºè®¾ç½®ä¸ªäººçš„å˜ä½“ï¼ˆæ„é€ å‡½æ•°ï¼‰ã€‚å›é¡¾æˆ‘ä»¬çš„å›¾ç‰‡â€”â€”ä»€ä¹ˆä¿¡æ¯æ„æˆäº†ä¸€ä¸ªäººï¼Ÿä»–ä»¬çš„åå­—ã€ä»–ä»¬çš„æ¯äº²å’Œä»–ä»¬çš„çˆ¶äº²ï¼ˆä»¥åŠå‡ºç”Ÿå¹´ä»½å’Œçœ¼ç›é¢œè‰²ï¼Œè¿™äº›åœ¨å›¾ç‰‡ä¸­æ²¡æœ‰æ˜¾ç¤ºï¼‰ã€‚è¿™å»ºè®®ä»¥ä¸‹æ•°æ®ç±»å‹ï¼Œå®ƒåŸºæœ¬ä¸Šå°†ä¸€è¡Œè½¬æ¢ä¸ºä¸ªäººå€¼ï¼š
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For example, annaâ€™s row might look like:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œannaçš„è¡Œå¯èƒ½çœ‹èµ·æ¥åƒè¿™æ ·ï¼š
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What type do we put in the blanks? A quick brainstorm yields several ideas:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åº”è¯¥å¡«å…¥ä»€ä¹ˆç±»å‹ï¼Ÿå¿«é€Ÿå¤´è„‘é£æš´äº§ç”Ÿäº†å‡ ä¸ªæƒ³æ³•ï¼š
- en: '`person`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`person`'
- en: '`List<person>`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<person>`'
- en: some new datatype
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€äº›æ–°çš„æ•°æ®ç±»å‹
- en: '`AncTree`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AncTree`'
- en: '`String`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`'
- en: Which should it be?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: åº”è¯¥é€‰æ‹©å“ªä¸€ä¸ªï¼Ÿ
- en: If we use a `String`, weâ€™re back to the table row, and we donâ€™t end up with
    a way to easily get from one person to another. We should therefore make this
    an `AncTree`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ä½¿ç”¨`String`ï¼Œæˆ‘ä»¬å°±å›åˆ°äº†è¡¨è¡Œï¼Œå¹¶ä¸”æ— æ³•è½»æ¾åœ°ä»ä¸€ä¸ªäººè½¬åˆ°å¦ä¸€ä¸ªäººã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥å°†å…¶ä½œä¸º`AncTree`ã€‚
- en: '[PRE35]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Do Now!
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨åšä»€ä¹ˆï¼Ÿ
- en: ''
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the `AncTree` starting from `Anna` using this definition.
  id: totrans-250
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸ªå®šä¹‰ä»`Anna`å¼€å§‹ç¼–å†™`AncTree`ã€‚
- en: Did you get stuck? What do we do when we run out of known people? To handle
    that, we must add an option in the `AncTree` definition to capture people for
    whom we donâ€™t know anything.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¡ä½äº†å—ï¼Ÿå½“æˆ‘ä»¬ç”¨å°½å·²çŸ¥çš„äººæ—¶ï¼Œæˆ‘ä»¬è¯¥æ€ä¹ˆåŠï¼Ÿä¸ºäº†å¤„ç†è¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬å¿…é¡»åœ¨`AncTree`å®šä¹‰ä¸­æ·»åŠ ä¸€ä¸ªé€‰é¡¹æ¥æ•è·æˆ‘ä»¬ä¸€æ— æ‰€çŸ¥çš„äººã€‚
- en: '[PRE36]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Hereâ€™s Annaâ€™s tree written in this datatype:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯ä½¿ç”¨è¿™ç§æ•°æ®ç±»å‹ç¼–å†™çš„Annaçš„æ ‘ï¼š
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We could also have named each person data individually.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹Ÿå¯ä»¥ä¸ºæ¯ä¸ªäººæ•°æ®å•ç‹¬å‘½åã€‚
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The latter gives you pieces of the tree to use as other examples, but loses
    the structure that is visible in the indentation of the first version. You could
    get to pieces of the first version by digging into the data, such as writing `anna-tree.mother.mother`
    to get to the tree starting from "Ellen".
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: åè€…æä¾›äº†å¯ä»¥ç”¨äºå…¶ä»–ç¤ºä¾‹çš„æ ‘çš„ç‰‡æ®µï¼Œä½†å¤±å»äº†ç¬¬ä¸€ä¸ªç‰ˆæœ¬ä¸­å¯è§çš„ç¼©è¿›ç»“æ„ã€‚ä½ å¯ä»¥é€šè¿‡æ·±å…¥æ•°æ®æ¥è·å¾—ç¬¬ä¸€ä¸ªç‰ˆæœ¬çš„ç‰‡æ®µï¼Œä¾‹å¦‚ï¼Œé€šè¿‡ç¼–å†™`anna-tree.mother.mother`æ¥ä»"Ellen"å¼€å§‹è·å–æ ‘ã€‚
- en: 'Hereâ€™s the `parents-of` function written against `AncTree`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯é’ˆå¯¹`AncTree`ç¼–å†™çš„`parents-of`å‡½æ•°ï¼š
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 7.1.2Â Programs to Process Ancestor Trees[ğŸ”—](#(part._.Programs_to_.Process_.Ancestor_.Trees)
    "Link to here")
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2Â å¤„ç†ç¥–å…ˆæ ‘çš„ç¨‹åº[ğŸ”—](#(part._.Programs_to_.Process_.Ancestor_.Trees) "é“¾æ¥è‡³æ­¤")
- en: 'How would we write a function to determine whether anyone in the tree had a
    particular name? To be clear, we are trying to fill in the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥ç¡®å®šæ ‘ä¸­æ˜¯å¦æœ‰äººæœ‰ç‰¹å®šçš„åå­—ï¼Ÿä¸ºäº†æ¸…æ¥šèµ·è§ï¼Œæˆ‘ä»¬æ­£åœ¨å°è¯•å¡«å†™ä»¥ä¸‹ä»£ç ï¼š
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'How do we get started? Add some examples, remembering to check both cases of
    the `AncTree` definition:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•å¼€å§‹ï¼Ÿæ·»åŠ ä¸€äº›ç¤ºä¾‹ï¼Œè®°å¾—æ£€æŸ¥`AncTree`å®šä¹‰çš„ä¸¤ç§æƒ…å†µï¼š
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'What next? When we were working on lists, we talked about the template, a skeleton
    of code that we knew we could write based on the structure of the data. The template
    names the pieces of each kind of data, and makes recursive calls on pieces that
    have the same type. Hereâ€™s the template over the `AncTree` filled in:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥æ˜¯ä»€ä¹ˆï¼Ÿå½“æˆ‘ä»¬å¤„ç†åˆ—è¡¨æ—¶ï¼Œæˆ‘ä»¬è°ˆè®ºäº†æ¨¡æ¿ï¼Œè¿™æ˜¯æˆ‘ä»¬æ ¹æ®æ•°æ®ç»“æ„çŸ¥é“æˆ‘ä»¬å¯ä»¥ç¼–å†™çš„ä»£ç çš„éª¨æ¶ã€‚æ¨¡æ¿å‘½åäº†æ¯ç§æ•°æ®ç±»å‹çš„å„ä¸ªéƒ¨åˆ†ï¼Œå¹¶åœ¨å…·æœ‰ç›¸åŒç±»å‹çš„éƒ¨åˆ†ä¸Šæ‰§è¡Œé€’å½’è°ƒç”¨ã€‚è¿™é‡Œæ˜¯å¡«å……äº†`AncTree`çš„æ¨¡æ¿ï¼š
- en: '[PRE42]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To finish the code, we need to think about how to fill in the ellipses.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å®Œæˆä»£ç ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘å¦‚ä½•å¡«å……çœç•¥å·ã€‚
- en: When the tree is `noInfo`, it has no more people, so the answer should be false
    (as worked out in the examples).
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“æ ‘æ˜¯`noInfo`æ—¶ï¼Œå®ƒæ²¡æœ‰æ›´å¤šçš„äººï¼Œæ‰€ä»¥ç­”æ¡ˆåº”è¯¥æ˜¯falseï¼ˆå¦‚ç¤ºä¾‹ä¸­æ‰€ç¤ºï¼‰ã€‚
- en: 'When the tree is a person, there are three possibilities: we could be at a
    person with the name weâ€™re looking for, or the name could be in the motherâ€™s tree,
    or the name could be in the fatherâ€™s tree.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“æ ‘ä»£è¡¨ä¸€ä¸ªäººæ—¶ï¼Œæœ‰ä¸‰ç§å¯èƒ½æ€§ï¼šæˆ‘ä»¬å¯èƒ½æ‰¾åˆ°äº†æˆ‘ä»¬è¦æ‰¾çš„åå­—å¯¹åº”çš„äººï¼Œæˆ–è€…åå­—å¯èƒ½åœ¨æ¯äº²çš„æ ‘ä¸­ï¼Œæˆ–è€…åå­—å¯èƒ½åœ¨çˆ¶äº²çš„æ ‘ä¸­ã€‚
- en: We know how to check whether the personâ€™s name matches the one we are looking
    for. The recursive calls already ask about the name being in the motherâ€™s tree
    or fatherâ€™s tree. We just need to combine those pieces into one Boolean answer.
    Since there are three possibilities, we should combine them with `or`
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çŸ¥é“å¦‚ä½•æ£€æŸ¥äººçš„åå­—æ˜¯å¦ä¸æˆ‘ä»¬å¯»æ‰¾çš„åå­—åŒ¹é…ã€‚é€’å½’è°ƒç”¨å·²ç»è¯¢é—®äº†åå­—æ˜¯å¦åœ¨æ¯äº²çš„æ ‘æˆ–çˆ¶äº²çš„æ ‘ä¸­ã€‚æˆ‘ä»¬åªéœ€è¦å°†è¿™äº›éƒ¨åˆ†ç»„åˆæˆä¸€ä¸ªå¸ƒå°”ç­”æ¡ˆã€‚ç”±äºæœ‰ä¸‰ç§å¯èƒ½æ€§ï¼Œæˆ‘ä»¬åº”è¯¥ç”¨`or`ç»„åˆå®ƒä»¬ã€‚
- en: 'Hereâ€™s the final code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯æœ€ç»ˆçš„ä»£ç ï¼š
- en: '[PRE43]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 7.1.3Â Summarizing How to Approach Tree Problems[ğŸ”—](#(part._.Summarizing_.How_to_.Approach_.Tree_.Problems)
    "Link to here")
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.3Â æ€»ç»“å¦‚ä½•å¤„ç†æ ‘é—®é¢˜[ğŸ”—](#(part._.Summarizing_.How_to_.Approach_.Tree_.Problems) "é“¾æ¥è‡³æ­¤")
- en: 'We design tree programs using the same design recipe that we covered on lists:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä½¿ç”¨åœ¨åˆ—è¡¨ä¸­ä»‹ç»è¿‡çš„ç›¸åŒè®¾è®¡æ–¹æ³•æ¥è®¾è®¡æ ‘ç¨‹åºï¼š
- en: 'Strategy: Writing a Program Over Trees'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç­–ç•¥ï¼šåœ¨æ ‘ä¸Šç¼–å†™ç¨‹åº
- en: ''
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the datatype for your tree, including a base/leaf case
  id: totrans-277
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸ºä½ çš„æ ‘ç¼–å†™æ•°æ®ç±»å‹ï¼ŒåŒ…æ‹¬åŸºæœ¬/å¶èŠ‚ç‚¹æƒ…å†µ
- en: ''
  id: totrans-278
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-279
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Write examples of your trees for use in testing
  id: totrans-280
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¼–å†™ä½ çš„æ ‘ç¤ºä¾‹ï¼Œç”¨äºæµ‹è¯•
- en: ''
  id: totrans-281
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-282
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Write the function name, parameters, and types (the `fun` line)
  id: totrans-283
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å†™å‡ºå‡½æ•°åã€å‚æ•°å’Œç±»å‹ï¼ˆ`fun`è¡Œï¼‰
- en: ''
  id: totrans-284
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-285
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Write `where` checks for your code
  id: totrans-286
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸ºä½ çš„ä»£ç ç¼–å†™`where`æ£€æŸ¥
- en: ''
  id: totrans-287
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-288
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the template, including the cases and recursive calls. Hereâ€™s the template
    again for an ancestor tree, for an arbitrary function called treeF:'
  id: totrans-289
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¼–å†™æ¨¡æ¿ï¼ŒåŒ…æ‹¬æƒ…å†µå’Œé€’å½’è°ƒç”¨ã€‚ä»¥ä¸‹æ˜¯ç¥–å…ˆæ ‘æ¨¡æ¿çš„å†æ¬¡å‘ˆç°ï¼Œç”¨äºä¸€ä¸ªä»»æ„å‡½æ•°ç§°ä¸ºtreeFï¼š
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-291
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-293
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ''
  id: totrans-294
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-295
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Fill in the template with details specific to the problem
  id: totrans-296
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¯¦ç»†ä¿¡æ¯å¡«å†™æ¨¡æ¿ä»¥é’ˆå¯¹é—®é¢˜
- en: ''
  id: totrans-297
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-298
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Test your code using your examples
  id: totrans-299
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ä½ çš„ç¤ºä¾‹æµ‹è¯•ä½ çš„ä»£ç 
- en: 7.1.4Â Study Questions[ğŸ”—](#(part._.Study_.Questions) "Link to here")
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.4 ç ”ç©¶é—®é¢˜[ğŸ”—](#(part._.Study_.Questions) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Think of writing in-tree on a table (using filter-by) vs writing it on a tree.
    How many times might each approach compare the name being sought against a name
    in the table/tree?
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æƒ³è±¡åœ¨è¡¨æ ¼ï¼ˆä½¿ç”¨æŒ‰æ¡ä»¶ç­›é€‰ï¼‰ä¸Šç¼–å†™-in-treeï¼Œä¸åœ¨æ ‘ä¸Šç¼–å†™ç›¸æ¯”ï¼Œæ¯ç§æ–¹æ³•å¯èƒ½å¤šå°‘æ¬¡å°†æœç´¢çš„åç§°ä¸è¡¨/æ ‘ä¸­çš„åç§°è¿›è¡Œæ¯”è¾ƒï¼Ÿ
- en: Why do we need to use a recursive function to process the tree?
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦ä½¿ç”¨é€’å½’å‡½æ•°æ¥å¤„ç†æ ‘ï¼Ÿ
- en: In what order will we check the names in the tree version?
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†æŒ‰ä»€ä¹ˆé¡ºåºæ£€æŸ¥æ ‘ç‰ˆæœ¬ä¸­çš„åç§°ï¼Ÿ
- en: For practice, try problems such as
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç»ƒä¹ ï¼Œå°è¯•ä»¥ä¸‹é—®é¢˜
- en: How many blue-eyed people are in the tree?
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ ‘ä¸­æœ‰å¤šå°‘äººåå­—æ˜¯è“è‰²çš„ï¼Ÿ
- en: How many people are in the tree?
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ ‘ä¸­æœ‰å¤šå°‘äººï¼Ÿ
- en: How many generations are in the tree?
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ ‘ä¸­æœ‰å¤šå°‘ä»£ï¼Ÿ
- en: How many people have a given name in a tree?
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ‰å¤šå°‘äººåå­—åœ¨æ ‘ä¸­ï¼Ÿ
- en: How many people have names starting with "A"?
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ‰å¤šå°‘äººåå­—ä»¥"A"å¼€å¤´ï¼Ÿ
- en: '... and so on'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '...ç­‰ç­‰'
