- en: 7.1Â TreesðŸ”—
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŽŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/trees.html](https://dcic-world.org/2025-08-27/trees.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Â Â Â Â [7.1.1Â Data Design Problem â€“ Ancestry Data](#%28part._ancestor-trees%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [7.1.1.1Â Computing Genetic Parents from an Ancestry Table](#%28part._compute-parents-table%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [7.1.1.2Â Computing Grandparents from an Ancestry Table](#%28part._.Computing_.Grandparents_from_an_.Ancestry_.Table%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â Â Â [7.1.1.3Â Creating a Datatype for Ancestor Trees](#%28part._ancestor-tree%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [7.1.2Â Programs to Process Ancestor Trees](#%28part._.Programs_to_.Process_.Ancestor_.Trees%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [7.1.3Â Summarizing How to Approach Tree Problems](#%28part._.Summarizing_.How_to_.Approach_.Tree_.Problems%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [7.1.4Â Study Questions](#%28part._.Study_.Questions%29) |'
  prefs: []
  type: TYPE_TB
- en: 7.1.1Â Data Design Problem â€“ Ancestry Data[ðŸ”—](#(part._ancestor-trees) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Imagine that we wanted to manage ancestry information for purposes of a medical
    research study. Specifically, we want to record peopleâ€™s birthyear, eye colors,
    and genetic parents. Hereâ€™s a sample table of such data, with one row for each
    person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For our research, we want to be able to answer questions such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Who are the genetic grandparents of a specific person?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How frequent is each eye color?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is one specific person an ancestor of another specific person?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many generations do we have information for?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does oneâ€™s eye color correlate with the ages of their genetic parents when they
    were born?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Letâ€™s start with the first question:'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you compute a list of the known grandparents for a given person? For
    purposes of this chapter, you may assume that each person has a unique name (while
    this isnâ€™t realistic in practice, it will simplify our computations for the time
    being; we will revisit it later in the chapter).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '(Hint: Make a task plan. Does it suggest any particular helper functions?)'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Our task plan has two key steps: find the names of the genetic parents of the
    named person, then find the names of the parents of each of those people. Both
    steps share the need to compute the known parents from a name, so we should create
    a helper function for that (weâ€™ll call it `parents-of`). Since this sounds like
    a routine table program, we can use it for a bit of review:'
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1.1Â Computing Genetic Parents from an Ancestry Table[ðŸ”—](#(part._compute-parents-table)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'How do we compute a list of someoneâ€™s genetic parents? Letâ€™s sketch a task
    plan for that:'
  prefs: []
  type: TYPE_NORMAL
- en: filter the table to find the person
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: extract the name of the female parent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: extract the name of the male parent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: make a list of those names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are tasks we have seen before, so we can translate this plan directly
    into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Are you satisfied with this program? With the examples included in the `where`
    block? Write down any critiques you have.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are arguably some issues here. How many of these did you catch?
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples are weak: none of them consider people for whom we are missing
    information on at least one parent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of names returned in the case of an unknown parent includes the empty
    string, which isnâ€™t actually a name. This could cause problems if we use this
    list of names in a subsequent computation (such as to compute the names of someoneâ€™s
    grandparents).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If empty strings are not part of the output list, then weâ€™d get the same result
    from asking for the parents of `"Robert"` (who is in the table) as for `"Kathi"`
    (who is not). These are fundamentally different cases, which arguably demand different
    outputs so we can tell them apart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To fix these problems, we need to remove the empty strings from the produced
    list of parents and return something other than the `empty` list when a name is
    not in the table. Since the output of this function is a list of strings, itâ€™s
    hard to see what to return that couldnâ€™t be confused for a valid list of names.
    Our solution for now is to have Pyret throw an error (like the ones you get when
    Pyret is not able to finish running your program). Hereâ€™s a solution that handles
    both problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `raise` construct tells Pyret to halt the program and produce an error message.
    The error message does not have to match the expected output type of the program.
    If you run this function with a name that is not in the table, youâ€™ll see an error
    appear in the interactions pane, with no result returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `where` block, we see how to check whether an expression will yield
    an error: instead of using `is` to check the equality of values, we use `raises`
    to check whether the provided string is a sub-string of the actual error produced
    by the program.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1.2Â Computing Grandparents from an Ancestry Table[ðŸ”—](#(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Once we have the `parents-of` function, we should be able to compute the grandparents
    by computing parents of parents, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Look back at our sample ancestry tree: for which people would this correctly
    compute the list of grandparents?'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This grandparents-of code works fine for someone who has both parents in the
    table. For someone without two parents, however, the `plist` will have fewer than
    two names, so the expression `plist.rest.first` (if not `plist.first`) will yield
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s a version that checks the number of parents before computing the set
    of grandparents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What if we now wanted to gather up all of someoneâ€™s ancestors? Since we donâ€™t
    know how many generations there are, weâ€™d need to use recursion. This approach
    would also be expensive, since weâ€™d end up filtering over the table over and over,
    which checks every row of the table in each use of `filter`.
  prefs: []
  type: TYPE_NORMAL
- en: Look back at the ancestry tree picture. We donâ€™t do any complicated filtering
    there â€“ we just follow the line in the picture immediately from a person to their
    mother or father. Can we get that idea in code instead? Yes, through datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1.3Â Creating a Datatype for Ancestor Trees[ðŸ”—](#(part._ancestor-tree) "Link
    to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For this approach, we want to create a datatype for Ancestor Trees that has
    a variant (constructor) for setting up a person. Look back at our picture â€“ what
    information makes up a person? Their name, their mother, and their father (along
    with birthyear and eyecolor, which arenâ€™t shown in the picture). This suggests
    the following datatype, which basically turns a row into a person value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, annaâ€™s row might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'What type do we put in the blanks? A quick brainstorm yields several ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '`person`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<person>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: some new datatype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AncTree`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which should it be?
  prefs: []
  type: TYPE_NORMAL
- en: If we use a `String`, weâ€™re back to the table row, and we donâ€™t end up with
    a way to easily get from one person to another. We should therefore make this
    an `AncTree`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the `AncTree` starting from `Anna` using this definition.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you get stuck? What do we do when we run out of known people? To handle
    that, we must add an option in the `AncTree` definition to capture people for
    whom we donâ€™t know anything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Hereâ€™s Annaâ€™s tree written in this datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We could also have named each person data individually.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The latter gives you pieces of the tree to use as other examples, but loses
    the structure that is visible in the indentation of the first version. You could
    get to pieces of the first version by digging into the data, such as writing `anna-tree.mother.mother`
    to get to the tree starting from "Ellen".
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s the `parents-of` function written against `AncTree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 7.1.2Â Programs to Process Ancestor Trees[ðŸ”—](#(part._.Programs_to_.Process_.Ancestor_.Trees)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'How would we write a function to determine whether anyone in the tree had a
    particular name? To be clear, we are trying to fill in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we get started? Add some examples, remembering to check both cases of
    the `AncTree` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'What next? When we were working on lists, we talked about the template, a skeleton
    of code that we knew we could write based on the structure of the data. The template
    names the pieces of each kind of data, and makes recursive calls on pieces that
    have the same type. Hereâ€™s the template over the `AncTree` filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To finish the code, we need to think about how to fill in the ellipses.
  prefs: []
  type: TYPE_NORMAL
- en: When the tree is `noInfo`, it has no more people, so the answer should be false
    (as worked out in the examples).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the tree is a person, there are three possibilities: we could be at a
    person with the name weâ€™re looking for, or the name could be in the motherâ€™s tree,
    or the name could be in the fatherâ€™s tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know how to check whether the personâ€™s name matches the one we are looking
    for. The recursive calls already ask about the name being in the motherâ€™s tree
    or fatherâ€™s tree. We just need to combine those pieces into one Boolean answer.
    Since there are three possibilities, we should combine them with `or`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Hereâ€™s the final code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 7.1.3Â Summarizing How to Approach Tree Problems[ðŸ”—](#(part._.Summarizing_.How_to_.Approach_.Tree_.Problems)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We design tree programs using the same design recipe that we covered on lists:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategy: Writing a Program Over Trees'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the datatype for your tree, including a base/leaf case
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Write examples of your trees for use in testing
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Write the function name, parameters, and types (the `fun` line)
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Write `where` checks for your code
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the template, including the cases and recursive calls. Hereâ€™s the template
    again for an ancestor tree, for an arbitrary function called treeF:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Fill in the template with details specific to the problem
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Test your code using your examples
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1.4Â Study Questions[ðŸ”—](#(part._.Study_.Questions) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Think of writing in-tree on a table (using filter-by) vs writing it on a tree.
    How many times might each approach compare the name being sought against a name
    in the table/tree?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we need to use a recursive function to process the tree?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In what order will we check the names in the tree version?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For practice, try problems such as
  prefs: []
  type: TYPE_NORMAL
- en: How many blue-eyed people are in the tree?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many people are in the tree?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many generations are in the tree?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many people have a given name in a tree?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many people have names starting with "A"?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '... and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1.1Â Data Design Problem â€“ Ancestry Data[ðŸ”—](#(part._ancestor-trees) "Link to
    here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Imagine that we wanted to manage ancestry information for purposes of a medical
    research study. Specifically, we want to record peopleâ€™s birthyear, eye colors,
    and genetic parents. Hereâ€™s a sample table of such data, with one row for each
    person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For our research, we want to be able to answer questions such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Who are the genetic grandparents of a specific person?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How frequent is each eye color?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is one specific person an ancestor of another specific person?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many generations do we have information for?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does oneâ€™s eye color correlate with the ages of their genetic parents when they
    were born?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Letâ€™s start with the first question:'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you compute a list of the known grandparents for a given person? For
    purposes of this chapter, you may assume that each person has a unique name (while
    this isnâ€™t realistic in practice, it will simplify our computations for the time
    being; we will revisit it later in the chapter).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '(Hint: Make a task plan. Does it suggest any particular helper functions?)'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Our task plan has two key steps: find the names of the genetic parents of the
    named person, then find the names of the parents of each of those people. Both
    steps share the need to compute the known parents from a name, so we should create
    a helper function for that (weâ€™ll call it `parents-of`). Since this sounds like
    a routine table program, we can use it for a bit of review:'
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1.1Â Computing Genetic Parents from an Ancestry Table[ðŸ”—](#(part._compute-parents-table)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'How do we compute a list of someoneâ€™s genetic parents? Letâ€™s sketch a task
    plan for that:'
  prefs: []
  type: TYPE_NORMAL
- en: filter the table to find the person
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: extract the name of the female parent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: extract the name of the male parent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: make a list of those names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are tasks we have seen before, so we can translate this plan directly
    into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Are you satisfied with this program? With the examples included in the `where`
    block? Write down any critiques you have.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are arguably some issues here. How many of these did you catch?
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples are weak: none of them consider people for whom we are missing
    information on at least one parent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of names returned in the case of an unknown parent includes the empty
    string, which isnâ€™t actually a name. This could cause problems if we use this
    list of names in a subsequent computation (such as to compute the names of someoneâ€™s
    grandparents).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If empty strings are not part of the output list, then weâ€™d get the same result
    from asking for the parents of `"Robert"` (who is in the table) as for `"Kathi"`
    (who is not). These are fundamentally different cases, which arguably demand different
    outputs so we can tell them apart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To fix these problems, we need to remove the empty strings from the produced
    list of parents and return something other than the `empty` list when a name is
    not in the table. Since the output of this function is a list of strings, itâ€™s
    hard to see what to return that couldnâ€™t be confused for a valid list of names.
    Our solution for now is to have Pyret throw an error (like the ones you get when
    Pyret is not able to finish running your program). Hereâ€™s a solution that handles
    both problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `raise` construct tells Pyret to halt the program and produce an error message.
    The error message does not have to match the expected output type of the program.
    If you run this function with a name that is not in the table, youâ€™ll see an error
    appear in the interactions pane, with no result returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `where` block, we see how to check whether an expression will yield
    an error: instead of using `is` to check the equality of values, we use `raises`
    to check whether the provided string is a sub-string of the actual error produced
    by the program.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1.2Â Computing Grandparents from an Ancestry Table[ðŸ”—](#(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Once we have the `parents-of` function, we should be able to compute the grandparents
    by computing parents of parents, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Look back at our sample ancestry tree: for which people would this correctly
    compute the list of grandparents?'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This grandparents-of code works fine for someone who has both parents in the
    table. For someone without two parents, however, the `plist` will have fewer than
    two names, so the expression `plist.rest.first` (if not `plist.first`) will yield
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s a version that checks the number of parents before computing the set
    of grandparents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: What if we now wanted to gather up all of someoneâ€™s ancestors? Since we donâ€™t
    know how many generations there are, weâ€™d need to use recursion. This approach
    would also be expensive, since weâ€™d end up filtering over the table over and over,
    which checks every row of the table in each use of `filter`.
  prefs: []
  type: TYPE_NORMAL
- en: Look back at the ancestry tree picture. We donâ€™t do any complicated filtering
    there â€“ we just follow the line in the picture immediately from a person to their
    mother or father. Can we get that idea in code instead? Yes, through datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1.3Â Creating a Datatype for Ancestor Trees[ðŸ”—](#(part._ancestor-tree) "Link
    to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For this approach, we want to create a datatype for Ancestor Trees that has
    a variant (constructor) for setting up a person. Look back at our picture â€“ what
    information makes up a person? Their name, their mother, and their father (along
    with birthyear and eyecolor, which arenâ€™t shown in the picture). This suggests
    the following datatype, which basically turns a row into a person value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, annaâ€™s row might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'What type do we put in the blanks? A quick brainstorm yields several ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '`person`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<person>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: some new datatype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AncTree`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which should it be?
  prefs: []
  type: TYPE_NORMAL
- en: If we use a `String`, weâ€™re back to the table row, and we donâ€™t end up with
    a way to easily get from one person to another. We should therefore make this
    an `AncTree`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the `AncTree` starting from `Anna` using this definition.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you get stuck? What do we do when we run out of known people? To handle
    that, we must add an option in the `AncTree` definition to capture people for
    whom we donâ€™t know anything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Hereâ€™s Annaâ€™s tree written in this datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We could also have named each person data individually.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The latter gives you pieces of the tree to use as other examples, but loses
    the structure that is visible in the indentation of the first version. You could
    get to pieces of the first version by digging into the data, such as writing `anna-tree.mother.mother`
    to get to the tree starting from "Ellen".
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s the `parents-of` function written against `AncTree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 7.1.1.1Â Computing Genetic Parents from an Ancestry Table[ðŸ”—](#(part._compute-parents-table)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'How do we compute a list of someoneâ€™s genetic parents? Letâ€™s sketch a task
    plan for that:'
  prefs: []
  type: TYPE_NORMAL
- en: filter the table to find the person
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: extract the name of the female parent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: extract the name of the male parent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: make a list of those names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are tasks we have seen before, so we can translate this plan directly
    into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Are you satisfied with this program? With the examples included in the `where`
    block? Write down any critiques you have.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are arguably some issues here. How many of these did you catch?
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples are weak: none of them consider people for whom we are missing
    information on at least one parent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of names returned in the case of an unknown parent includes the empty
    string, which isnâ€™t actually a name. This could cause problems if we use this
    list of names in a subsequent computation (such as to compute the names of someoneâ€™s
    grandparents).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If empty strings are not part of the output list, then weâ€™d get the same result
    from asking for the parents of `"Robert"` (who is in the table) as for `"Kathi"`
    (who is not). These are fundamentally different cases, which arguably demand different
    outputs so we can tell them apart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To fix these problems, we need to remove the empty strings from the produced
    list of parents and return something other than the `empty` list when a name is
    not in the table. Since the output of this function is a list of strings, itâ€™s
    hard to see what to return that couldnâ€™t be confused for a valid list of names.
    Our solution for now is to have Pyret throw an error (like the ones you get when
    Pyret is not able to finish running your program). Hereâ€™s a solution that handles
    both problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `raise` construct tells Pyret to halt the program and produce an error message.
    The error message does not have to match the expected output type of the program.
    If you run this function with a name that is not in the table, youâ€™ll see an error
    appear in the interactions pane, with no result returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `where` block, we see how to check whether an expression will yield
    an error: instead of using `is` to check the equality of values, we use `raises`
    to check whether the provided string is a sub-string of the actual error produced
    by the program.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1.2Â Computing Grandparents from an Ancestry Table[ðŸ”—](#(part._.Computing_.Grandparents_from_an_.Ancestry_.Table)
    "Link to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Once we have the `parents-of` function, we should be able to compute the grandparents
    by computing parents of parents, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Look back at our sample ancestry tree: for which people would this correctly
    compute the list of grandparents?'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This grandparents-of code works fine for someone who has both parents in the
    table. For someone without two parents, however, the `plist` will have fewer than
    two names, so the expression `plist.rest.first` (if not `plist.first`) will yield
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s a version that checks the number of parents before computing the set
    of grandparents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: What if we now wanted to gather up all of someoneâ€™s ancestors? Since we donâ€™t
    know how many generations there are, weâ€™d need to use recursion. This approach
    would also be expensive, since weâ€™d end up filtering over the table over and over,
    which checks every row of the table in each use of `filter`.
  prefs: []
  type: TYPE_NORMAL
- en: Look back at the ancestry tree picture. We donâ€™t do any complicated filtering
    there â€“ we just follow the line in the picture immediately from a person to their
    mother or father. Can we get that idea in code instead? Yes, through datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1.3Â Creating a Datatype for Ancestor Trees[ðŸ”—](#(part._ancestor-tree) "Link
    to here")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For this approach, we want to create a datatype for Ancestor Trees that has
    a variant (constructor) for setting up a person. Look back at our picture â€“ what
    information makes up a person? Their name, their mother, and their father (along
    with birthyear and eyecolor, which arenâ€™t shown in the picture). This suggests
    the following datatype, which basically turns a row into a person value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, annaâ€™s row might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'What type do we put in the blanks? A quick brainstorm yields several ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '`person`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<person>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: some new datatype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AncTree`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which should it be?
  prefs: []
  type: TYPE_NORMAL
- en: If we use a `String`, weâ€™re back to the table row, and we donâ€™t end up with
    a way to easily get from one person to another. We should therefore make this
    an `AncTree`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the `AncTree` starting from `Anna` using this definition.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you get stuck? What do we do when we run out of known people? To handle
    that, we must add an option in the `AncTree` definition to capture people for
    whom we donâ€™t know anything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Hereâ€™s Annaâ€™s tree written in this datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We could also have named each person data individually.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The latter gives you pieces of the tree to use as other examples, but loses
    the structure that is visible in the indentation of the first version. You could
    get to pieces of the first version by digging into the data, such as writing `anna-tree.mother.mother`
    to get to the tree starting from "Ellen".
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereâ€™s the `parents-of` function written against `AncTree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 7.1.2Â Programs to Process Ancestor Trees[ðŸ”—](#(part._.Programs_to_.Process_.Ancestor_.Trees)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'How would we write a function to determine whether anyone in the tree had a
    particular name? To be clear, we are trying to fill in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we get started? Add some examples, remembering to check both cases of
    the `AncTree` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'What next? When we were working on lists, we talked about the template, a skeleton
    of code that we knew we could write based on the structure of the data. The template
    names the pieces of each kind of data, and makes recursive calls on pieces that
    have the same type. Hereâ€™s the template over the `AncTree` filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To finish the code, we need to think about how to fill in the ellipses.
  prefs: []
  type: TYPE_NORMAL
- en: When the tree is `noInfo`, it has no more people, so the answer should be false
    (as worked out in the examples).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the tree is a person, there are three possibilities: we could be at a
    person with the name weâ€™re looking for, or the name could be in the motherâ€™s tree,
    or the name could be in the fatherâ€™s tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know how to check whether the personâ€™s name matches the one we are looking
    for. The recursive calls already ask about the name being in the motherâ€™s tree
    or fatherâ€™s tree. We just need to combine those pieces into one Boolean answer.
    Since there are three possibilities, we should combine them with `or`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Hereâ€™s the final code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 7.1.3Â Summarizing How to Approach Tree Problems[ðŸ”—](#(part._.Summarizing_.How_to_.Approach_.Tree_.Problems)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We design tree programs using the same design recipe that we covered on lists:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategy: Writing a Program Over Trees'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write the datatype for your tree, including a base/leaf case
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Write examples of your trees for use in testing
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Write the function name, parameters, and types (the `fun` line)
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Write `where` checks for your code
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the template, including the cases and recursive calls. Hereâ€™s the template
    again for an ancestor tree, for an arbitrary function called treeF:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Fill in the template with details specific to the problem
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Test your code using your examples
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1.4Â Study Questions[ðŸ”—](#(part._.Study_.Questions) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Think of writing in-tree on a table (using filter-by) vs writing it on a tree.
    How many times might each approach compare the name being sought against a name
    in the table/tree?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we need to use a recursive function to process the tree?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In what order will we check the names in the tree version?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For practice, try problems such as
  prefs: []
  type: TYPE_NORMAL
- en: How many blue-eyed people are in the tree?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many people are in the tree?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many generations are in the tree?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many people have a given name in a tree?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many people have names starting with "A"?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '... and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
