["```cpp\n// I don't feel like typing \"unsigned long long\" each time typedef __uint16_t u16; typedef __uint32_t u32; typedef __uint64_t u64; typedef __uint128_t u128;   u64 find_factor(u64 n); \n```", "```cpp\nvector<u64> factorize(u64 n) {  vector<u64> factorization; do { u64 d = find_factor(n); factorization.push_back(d); n /= d; } while (d != 1); return factorization; } \n```", "```cpp\nu64 find_factor(u64 n) {  for (u64 d = 2; d < n; d++) if (n % d == 0) return d; return 1; } \n```", "```cpp\nu64 find_factor(u64 n) {  for (u64 d = 2; d * d <= n; d++) if (n % d == 0) return d; return 1; } \n```", "```cpp\ntemplate <int N = (1<<16)> struct Precalc {  unsigned char divisor[N];   constexpr Precalc() : divisor{} { for (int i = 0; i < N; i++) divisor[i] = 1; for (int i = 2; i * i < N; i++) if (divisor[i] == 1) for (int k = i * i; k < N; k += i) divisor[k] = i; } };   constexpr Precalc P{};   u64 find_factor(u64 n) {  return P.divisor[n]; } \n```", "```cpp\nu64 find_factor(u64 n) {  if (n % 2 == 0) return 2; for (u64 d = 3; d * d <= n; d += 2) if (n % d == 0) return d; return 1; } \n```", "```cpp\n(1,) 7, 11, 13, 17, 19, 23, 29,\n31, 37, 41, 43, 47, 49, 53, 59,\n61, 67, 71, 73, 77, 79, 83, 89â€¦\n\n```", "```cpp\nu64 find_factor(u64 n) {  for (u64 d : {2, 3, 5}) if (n % d == 0) return d; u64 offsets[] = {0, 4, 6, 10, 12, 16, 22, 24}; for (u64 d = 7; d * d <= n; d += 30) { for (u64 offset : offsets) { u64 x = d + offset; if (n % x == 0) return x; } } return 1; } \n```", "```cpp\nconst int N = (1 << 16);   struct Precalc {  u16 primes[6542]; // # of primes under N=2^16  constexpr Precalc() : primes{} { bool marked[N] = {}; int n_primes = 0;   for (int i = 2; i < N; i++) { if (!marked[i]) { primes[n_primes++] = i; for (int j = 2 * i; j < N; j += i) marked[j] = true; } } } };   constexpr Precalc P{};   u64 find_factor(u64 n) {  for (u16 p : P.primes) if (n % p == 0) return p; return 1; } \n```", "```cpp\n// ...precomputation is the same as before, // but we store the reciprocal instead of the prime number itself u64 magic[6542]; // for each prime i: magic[n_primes++] = u64(-1) / i + 1;   u64 find_factor(u64 n) {  for (u64 m : P.magic) if (m * n < m) return u64(-1) / m + 1; return 1; } \n```", "```cpp\nu64 f(u64 x, u64 mod) {  return ((u128) x * x + 1) % mod; }   u64 diff(u64 a, u64 b) {  // a and b are unsigned and so is their difference, so we can't just call abs(a - b) return a > b ? a - b : b - a; }   const u64 SEED = 42;   u64 find_factor(u64 n) {  u64 x = SEED, y = SEED, g = 1; while (g == 1) { x = f(f(x, n), n); // advance x twice y = f(y, n);       // advance y once g = gcd(diff(x, y)); } return g; } \n```", "```cpp\nu64 find_factor(u64 n) {  u64 x = SEED;  for (int l = 256; l < (1 << 20); l *= 2) { u64 y = x; for (int i = 0; i < l; i++) { x = f(x, n); if (u64 g = gcd(diff(x, y), n); g != 1) return g; } }   return 1; } \n```", "```cpp\nconst int M = 1024;   u64 find_factor(u64 n) {  u64 x = SEED;  for (int l = M; l < (1 << 20); l *= 2) { u64 y = x, p = 1; for (int i = 0; i < l; i += M) { for (int j = 0; j < M; j++) { y = f(y, n); p = (u128) p * diff(x, y) % n; } if (u64 g = gcd(p, n); g != 1) return g; } }   return 1; } \n```", "```cpp\nstruct Montgomery {  u64 n, nr;  Montgomery(u64 n) : n(n) { nr = 1; for (int i = 0; i < 6; i++) nr *= 2 - n * nr; }   u64 reduce(u128 x) const { u64 q = u64(x) * nr; u64 m = ((u128) q * n) >> 64; return (x >> 64) + n - m; }   u64 multiply(u64 x, u64 y) { return reduce((u128) x * y); } };   u64 f(u64 x, u64 a, Montgomery m) {  return m.multiply(x, x) + a; }   const int M = 1024;   u64 find_factor(u64 n, u64 x0 = 2, u64 a = 1) {  Montgomery m(n); u64 x = SEED;  for (int l = M; l < (1 << 20); l *= 2) { u64 y = x, p = 1; for (int i = 0; i < l; i += M) { for (int j = 0; j < M; j++) { x = f(x, m); p = m.multiply(p, diff(x, y)); } if (u64 g = gcd(p, n); g != 1) return g; } }   return 1; } \n```"]