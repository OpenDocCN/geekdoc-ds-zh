- en: Interpolating Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://phys-sim-book.github.io/lec26.2-interpolating_functions.html](https://phys-sim-book.github.io/lec26.2-interpolating_functions.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
  prefs: []
  type: TYPE_NORMAL
- en: In each time step of the Material Point Method (MPM), particles transfer their
    mass and momentum to the background grid, and later retrieve updated velocities
    from the grid to perform advection. Both transfers rely on **interpolating functions**
    to determine how each particle interacts with nearby grid nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the interpolating function associated with grid node i as Ni​(x).
    Here, i is a multi-index - (i,j) in 2D or (i,j,k) in 3D - and x is an arbitrary
    spatial position. When evaluating this function at a particle location xp​, we
    use the shorthand:'
  prefs: []
  type: TYPE_NORMAL
- en: wip​=Ni​(xp​).
  prefs: []
  type: TYPE_NORMAL
- en: 'This weight determines how strongly particle p influences grid node i: the
    closer the particle is to the node, the larger wip​ becomes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 27.2.1 (Linear Interpolation).** In 1D, the simplest choice of interpolating
    functions is the **linear (tent) function**: N(x)={1−∣x∣0​if 0≤∣x∣<1,otherwise.​
    To apply this in a grid-based setting, we scale the spatial coordinates relative
    to the **grid spacing** h (i.e., the distance between adjacent grid nodes along
    one axis). The scaled version becomes: N(hxp​−xi​​). In higher dimensions (2D,
    3D), we use the **tensor product** of 1D functions: Ni​(xp​)=N(hxp​−xi​​)⋅N(hyp​−yj​​)⋅N(hzp​−zk​​).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Linear interpolation is computationally efficient and easy to implement, and
    is widely used in FLIP [[Brackbill et al. 1988]](bibliography.html#brackbill1988flip)
    [[Bridson 2015]](bibliography.html#bridson2015fluid) for fluid simulation. However,
    it suffers from two serious issues when applied in MPM:'
  prefs: []
  type: TYPE_NORMAL
- en: Its gradient ∇N(x) is **discontinuous**, leading to unstable and noisy force
    evaluations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When particles are near cell boundaries, wip​ becomes small while ∇wip​ remains
    large, causing numerical instabilities known as **cell-crossing instability**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function’s support is too narrow, making it prone to **numerical fracture**
    when neighboring particles do not share enough grid nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because of these issues, linear interpolation is typically avoided in MPM, especially
    in solid simulation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 27.2.2 (Quadratic B-Spline Interpolation).** A better choice is the
    **quadratic B-spline** interpolating functions, which is C1-continuous (with continuous
    gradients) and has wider support: N(x)=⎩⎨⎧​43​−x221​(23​−∣x∣)20​if ∣x∣<21​,if 21​≤∣x∣<23​,otherwise.​'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Quadratic B-splines have a support region of width 3h and provide smooth, stable
    interactions between particles and the grid. They are computationally efficient
    and require less memory than higher-order B-splines.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 27.2.3 (Cubic B-Spline Interpolation).** For even better smoothness
    and broader support, we can use the **cubic B-spline** interpolating functions:
    N(x)=⎩⎨⎧​21​∣x∣3−∣x∣2+32​61​(2−∣x∣)30​if 0≤∣x∣<1,if 1≤∣x∣<2,otherwise.​'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The cubic B-spline has support over [−2h,2h], making it more robust to numerical
    fracture and instabilities. However, the wider support also means that each particle
    interacts with more grid nodes, which increases the **computational overhead during
    transfers** (e.g., mass, momentum, and force). This trade-off between smoothness
    and efficiency should be considered when choosing an interpolation kernel.
  prefs: []
  type: TYPE_NORMAL
- en: '[Gradient of the Interpolating Function](#gradient-of-the-interpolating-function)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Gradients are needed during force computation. For high-dimensional interpolating
    functions defined using tensor products, we compute their gradient using the chain
    rule: ∇Ni​(xp​)=​h1​N′(hxp​−xi​​)N(hyp​−yj​​)N(hzp​−zk​​)N(hxp​−xi​​)h1​N′(hyp​−yj​​)N(hzp​−zk​​)N(hxp​−xi​​)N(hyp​−yj​​)h1​N′(hzp​−zk​​)​​.
    Here, N′(x) is the derivative of the 1D interpolating function N(x).'
  prefs: []
  type: TYPE_NORMAL
