- en: 28Â Pyret for Racketeers and SchemersðŸ”—
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: åŽŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/p4rs.html](https://dcic-world.org/2025-08-27/p4rs.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Â Â Â Â [28.1Â Numbers, Strings, and Booleans](#%28part._.Numbers__.Strings__and_.Booleans%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [28.2Â Infix Expressions](#%28part._.Infix_.Expressions%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [28.3Â Function Definition and Application](#%28part._.Function_.Definition_and_.Application%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [28.4Â Tests](#%28part._.Tests%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [28.5Â Variable Names](#%28part._.Variable_.Names%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [28.6Â Data Definitions](#%28part._.Data_.Definitions%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [28.7Â Conditionals](#%28part._.Conditionals%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [28.8Â Lists](#%28part._.Lists%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [28.9Â First-Class Functions](#%28part._.First-.Class_.Functions%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [28.10Â Annotations](#%28part._.Annotations%29) |'
  prefs: []
  type: TYPE_TB
- en: '| Â Â Â Â [28.11Â What Else?](#%28part._.What_.Else_%29) |'
  prefs: []
  type: TYPE_TB
- en: If youâ€™ve programmed before in a language like Scheme or the student levels
    of Racket (or the WeScheme programming environment), or for that matter even in
    certain parts of OCaml, Haskell, Scala, Erlang, Clojure, or other languages, you
    will find many parts of Pyret very familiar. This chapter is specifically written
    to help you make the transition from (student) Racket/Scheme/WeScheme (abbreviated
    â€œRSWâ€) to Pyret by showing you how to convert the syntax. Most of what we say
    applies to all these languages, though in some cases we will refer specifically
    to Racket (and WeScheme) features not found in Scheme.
  prefs: []
  type: TYPE_NORMAL
- en: In every example below, the two programs will produce the same results.
  prefs: []
  type: TYPE_NORMAL
- en: 28.1Â Numbers, Strings, and Booleans[ðŸ”—](#(part._.Numbers__.Strings__and_.Booleans)
    "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Numbers are very similar between the two. Like Scheme, Pyret implements arbitrary-precision
    numbers and rationals. Some of the more exotic numeric systems of Scheme (such
    as complex numbers) arenâ€™t in Pyret; Pyret also treats imprecise numbers slightly
    differently.
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| 1/2 | `1/2` |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| #i3.14 | `~3.14` |'
  prefs: []
  type: TYPE_TB
- en: Strings are also very similar, though Pyret allows you to use single-quotes
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| "Hello,Â world!" | `"Hello, world!"` |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| "\"Hello\",Â heÂ said" | `"\"Hello\", he said"` |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| "\"Hello\",Â heÂ said" | `''"Hello", he said''` |'
  prefs: []
  type: TYPE_TB
- en: 'Booleans have the same names:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| true | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| false | `false` |'
  prefs: []
  type: TYPE_TB
- en: 28.2Â Infix Expressions[ðŸ”—](#(part._.Infix_.Expressions) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pyret uses an infix syntax, reminiscent of many other textual programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (+Â 1Â 2) | `1 + 2` |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (*Â (-Â 4Â 2)Â 5) | `(4 - 2) * 5` |'
  prefs: []
  type: TYPE_TB
- en: 'Note that Pyret does not have rules about orders of precedence between operators,
    so when you mix operators, you have to parenthesize the expression to make your
    intent clear. When you chain the same operator you donâ€™t need to parenthesize;
    chaining associates to the left in both languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (/Â 1Â 2Â 3Â 4) | `1 / 2 / 3 / 4` |'
  prefs: []
  type: TYPE_TB
- en: These both evaluate to 1/24.
  prefs: []
  type: TYPE_NORMAL
- en: 28.3Â Function Definition and Application[ðŸ”—](#(part._.Function_.Definition_and_.Application)
    "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Function definition and application in Pyret have an infix syntax, more reminiscent
    of many other textual programming languages. Application uses a syntax familiar
    from conventional algebra books:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (distÂ 3Â 4) | `dist(3, 4)` |'
  prefs: []
  type: TYPE_TB
- en: 'Application correspondingly uses a similar syntax in function headers, and
    infix in the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (defineÂ (distÂ xÂ y) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â (sqrtÂ (+Â (*Â xÂ x) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â Â Â Â Â Â Â Â Â (*Â yÂ y)))) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 28.4Â Tests[ðŸ”—](#(part._.Tests) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are essentially three different ways of writing the equivalent of Racketâ€™s
    check-expect tests. They can be translated into check blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (check-expectÂ 1Â 1) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that multiple tests can be put into a single block:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (check-expectÂ 1Â 1) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; (check-expectÂ 2Â 2) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way is this: as an alias for `check` we can also write `examples`.
    The two are functionally identical, but they capture the human difference between
    examples (which explore the problem, and are written before attempting a solution)
    and tests (which try to find bugs in the solution, and are written to probe its
    design).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third way is to write a `where` block to accompany a function definition.
    For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These can even be written for internal functions (i.e., functions contained
    inside other functions), which isnâ€™t true for check-expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Pyret, unlike in Racket, a testing block can contain a documentation string.
    This is used by Pyret when reporting test successes and failures. For instance,
    try to run and see what you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is useful for documenting the purpose of a testing block.
  prefs: []
  type: TYPE_NORMAL
- en: Just as in Racket, there are many testing operators in Pyret (in addition to
    `is`). See [the documentation](https://www.pyret.org/docs/latest/testing.html).
  prefs: []
  type: TYPE_NORMAL
- en: 28.5Â Variable Names[ðŸ”—](#(part._.Variable_.Names) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both languages have a fairly permissive system for naming variables. While
    you can use CamelCase and under_scores in both, it is conventional to instead
    use what is known as [kebab-case](http://c2.com/cgi/wiki?KebabCase).This name
    is inaccurate. The word â€œkebabâ€ just means â€œmeatâ€. The skewer is the â€œshishâ€.
    Therefore, it ought to at least be called â€œshish kebab caseâ€. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| this-is-a-name | `this-is-a-name` |'
  prefs: []
  type: TYPE_TB
- en: Even though Pyret has infix subtraction, the language can unambiguously tell
    apart `this-name` (a variable) from `this - name` (a subtraction expression) because
    the `-` in the latter must be surrounded by spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Despite this spacing convention, Pyret does not permit some of the more exotic
    names permitted by Scheme. For instance, one can write
  prefs: []
  type: TYPE_NORMAL
- en: '| (defineÂ e^i*piÂ -1) |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: in Scheme but that is not a valid variable name in Pyret.
  prefs: []
  type: TYPE_NORMAL
- en: 28.6Â Data Definitions[ðŸ”—](#(part._.Data_.Definitions) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pyret diverges from Racket (and even more so from Scheme) in its handling of
    data definitions. First, we will see how to define a structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (define-structÂ ptÂ (xÂ y)) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'This might seem like a fair bit of overkill, but weâ€™ll see in a moment why
    itâ€™s useful. Meanwhile, itâ€™s worth observing that when you have only a single
    kind of datum in a data definition, it feels unwieldy to take up so many lines.
    Writing it on one line is valid, but now it feels ugly to have the `|` in the
    middle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, Pyret permits you to drop the initial `|`, resulting in the more
    readable
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now suppose we have two kinds of points. In the student languages of Racket,
    we would describe this with a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ;;Â AÂ PointÂ isÂ either |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ;;Â -Â (ptÂ numberÂ number),Â or |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ;;Â -Â (pt3dÂ numberÂ numberÂ number) |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'In Pyret, we can express this directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In short, Racket optimizes for the single-variant case, whereas Pyret optimizes
    for the multi-variant case. As a result, it is difficult to clearly express the
    multi-variant case in Racket, while it is unwieldy to express the single-variant
    case in Pyret.
  prefs: []
  type: TYPE_NORMAL
- en: 'For structures, both Racket and Pyret expose constructors, selectors, and predicates.
    Constructors are just functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (ptÂ 1Â 2) | `pt(1, 2)` |'
  prefs: []
  type: TYPE_TB
- en: 'Predicates are also functions with a particular naming scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (pt?Â x) | is-pt(x) |'
  prefs: []
  type: TYPE_TB
- en: 'and they behave the same way (returning true if the argument was constructed
    by that constructor, and false otherwise). In contrast, selection is different
    in the two languages (and we will see more about selection below, with `cases`):'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (pt-xÂ v) | `v.x` |'
  prefs: []
  type: TYPE_TB
- en: Note that in the Racket case, pt-x checks that the parameter was constructed
    by pt before extracting the value of the x field. Thus, pt-x and pt3d-x are two
    different functions and neither one can be used in place of the other. In contast,
    in Pyret, `.x` extracts an `x` field of any value that has such a field, without
    attention to how it was constructed. Thus, we can use `.x` on a value whether
    it was constructed by `pt` or `pt3d` (or indeed anything else with that field).
    In contrast, `cases` does pay attention to this distinction.
  prefs: []
  type: TYPE_NORMAL
- en: 28.7Â Conditionals[ðŸ”—](#(part._.Conditionals) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several kinds of conditionals in Pyret, one more than in the Racket
    student languages.
  prefs: []
  type: TYPE_NORMAL
- en: General conditionals can be written using `if`, corresponding to Racketâ€™s `if`
    but with more syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (ifÂ full-moon &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â Â "howl" &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â Â "meow") &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (ifÂ full-moon &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â Â "howl" &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â Â (ifÂ new-moon &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â Â Â Â Â Â "bark" &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â Â Â Â Â Â "meow")) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `if` includes `else if`, which makes it possible to list a collection
    of questions at the same level of indentation, which if in Racket does not have.
    The corresponding code in Racket would be written
  prefs: []
  type: TYPE_NORMAL
- en: '| (cond |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Â Â [full-moonÂ "howl"] |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Â Â [new-moonÂ "bark"] |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Â Â [elseÂ "meow"]) |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'to restore the indentation. There is a similar construct in Pyret called `ask`,
    designed to parallel `cond`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In Racket, we also use `cond` to dispatch on a datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '| (cond |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Â Â [(pt?Â v)Â Â Â (+Â (pt-xÂ v)Â (pt-yÂ v))] |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Â Â [(pt3d?Â v)Â (+Â (pt-xÂ v)Â (pt-zÂ v))]) |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'We could write this in close parallel in Pyret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'or even as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: (As in Racket student languages, the Pyret versions will signal an error if
    no branch of the conditional matched.)
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Pyret provides a special syntax just for data definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This checks that `v` is a `Point`, provides a clean syntactic way of identifying
    the different branches, and makes it possible to give a concise local name to
    each field position instead of having to use selectors like `.x`. In general,
    in Pyret we prefer to use `cases` to process data definitions. However, there
    are times when, for instance, there many variants of data but a function processes
    only very few of them. In such situations, it makes more sense to explicitly use
    predicates and selectors.
  prefs: []
  type: TYPE_NORMAL
- en: 28.8Â Lists[ðŸ”—](#(part._.Lists) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Racket, depending on the language level, lists are created using either
    cons or list, with empty for the empty list. The corresponding notions in Pyret
    are called `link`, `list`, and `empty`, respectively. `link` is a two-argument
    function, just as in Racket:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (consÂ 1Â empty) | `link(1, empty)` |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (listÂ 1Â 2Â 3) | `[list: 1, 2, 3]` |'
  prefs: []
  type: TYPE_TB
- en: 'Note that the syntax `[1, 2, 3]`, which represents lists in many languages,
    is not legal in Pyret: lists are not privileged with their own syntax. Rather,
    we must use an explicit constructor: just as `[list: 1, 2, 3]` constructs a list,
    `[set: 1, 2, 3]` constructs a set instead of a list.In fact, we can [create our
    own constructors](https://www.pyret.org/docs/latest/Expressions.html#%28part._s~3aconstruct-expr%29)
    and use them with this syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try typing `[1, 2, 3]` and see the error message.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This shows us how to construct lists. To take them apart, we use `cases`. There
    are two variants, `empty` and `link` (which we used to construct the lists):'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (cond &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â [(empty?Â l)Â 0] &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â [(cons?Â l) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â (+Â (firstÂ l) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â Â Â Â (gÂ (restÂ l)))]) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: It is conventional to call the fields `f` and `r` (for â€œfirstâ€ and â€œrestâ€).
    Of course, this convention does not work if there are other things by the same
    name; in particular, when writing a nested destructuring of a list, we conventionally
    write `fr` and `rr` (for â€œfirst of the restâ€ and â€œrest of the restâ€).
  prefs: []
  type: TYPE_NORMAL
- en: 28.9Â First-Class Functions[ðŸ”—](#(part._.First-.Class_.Functions) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The equivalent of Racketâ€™s lambda is Pyretâ€™s `lam`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (lambdaÂ (xÂ y)Â (+Â xÂ y)) | `lam(x, y): x + y end` |'
  prefs: []
  type: TYPE_TB
- en: 28.10Â Annotations[ðŸ”—](#(part._.Annotations) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In student Racket languages, annotations are usually written as comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ;Â square:Â NumberÂ ->Â Number |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ;Â sort-nums:Â List<Number>Â ->Â List<Number> |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ;Â sort:Â List<T>Â *Â (TÂ *Â TÂ ->Â Boolean)Â ->Â List<T> |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: In Pyret, we write the annotations directly on the parameters and return values.
    Pyret will check them to a limited extent dynamically, and can check them statically
    with its type checker. The corresponding annotations to those above would be written
    as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 28.11Â What Else?[ðŸ”—](#(part._.What_.Else_) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If there are other parts of Scheme or Racket syntax that you would like to see
    translated, please [let us know](http://cs.brown.edu/~sk/Contact/).
  prefs: []
  type: TYPE_NORMAL
- en: 28.1Â Numbers, Strings, and Booleans[ðŸ”—](#(part._.Numbers__.Strings__and_.Booleans)
    "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Numbers are very similar between the two. Like Scheme, Pyret implements arbitrary-precision
    numbers and rationals. Some of the more exotic numeric systems of Scheme (such
    as complex numbers) arenâ€™t in Pyret; Pyret also treats imprecise numbers slightly
    differently.
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| 1/2 | `1/2` |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| #i3.14 | `~3.14` |'
  prefs: []
  type: TYPE_TB
- en: Strings are also very similar, though Pyret allows you to use single-quotes
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| "Hello,Â world!" | `"Hello, world!"` |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| "\"Hello\",Â heÂ said" | `"\"Hello\", he said"` |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| "\"Hello\",Â heÂ said" | `''"Hello", he said''` |'
  prefs: []
  type: TYPE_TB
- en: 'Booleans have the same names:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| true | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| false | `false` |'
  prefs: []
  type: TYPE_TB
- en: 28.2Â Infix Expressions[ðŸ”—](#(part._.Infix_.Expressions) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pyret uses an infix syntax, reminiscent of many other textual programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (+Â 1Â 2) | `1 + 2` |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (*Â (-Â 4Â 2)Â 5) | `(4 - 2) * 5` |'
  prefs: []
  type: TYPE_TB
- en: 'Note that Pyret does not have rules about orders of precedence between operators,
    so when you mix operators, you have to parenthesize the expression to make your
    intent clear. When you chain the same operator you donâ€™t need to parenthesize;
    chaining associates to the left in both languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (/Â 1Â 2Â 3Â 4) | `1 / 2 / 3 / 4` |'
  prefs: []
  type: TYPE_TB
- en: These both evaluate to 1/24.
  prefs: []
  type: TYPE_NORMAL
- en: 28.3Â Function Definition and Application[ðŸ”—](#(part._.Function_.Definition_and_.Application)
    "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Function definition and application in Pyret have an infix syntax, more reminiscent
    of many other textual programming languages. Application uses a syntax familiar
    from conventional algebra books:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (distÂ 3Â 4) | `dist(3, 4)` |'
  prefs: []
  type: TYPE_TB
- en: 'Application correspondingly uses a similar syntax in function headers, and
    infix in the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (defineÂ (distÂ xÂ y) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â (sqrtÂ (+Â (*Â xÂ x) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â Â Â Â Â Â Â Â Â (*Â yÂ y)))) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 28.4Â Tests[ðŸ”—](#(part._.Tests) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are essentially three different ways of writing the equivalent of Racketâ€™s
    check-expect tests. They can be translated into check blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (check-expectÂ 1Â 1) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that multiple tests can be put into a single block:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (check-expectÂ 1Â 1) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; (check-expectÂ 2Â 2) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way is this: as an alias for `check` we can also write `examples`.
    The two are functionally identical, but they capture the human difference between
    examples (which explore the problem, and are written before attempting a solution)
    and tests (which try to find bugs in the solution, and are written to probe its
    design).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third way is to write a `where` block to accompany a function definition.
    For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These can even be written for internal functions (i.e., functions contained
    inside other functions), which isnâ€™t true for check-expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Pyret, unlike in Racket, a testing block can contain a documentation string.
    This is used by Pyret when reporting test successes and failures. For instance,
    try to run and see what you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is useful for documenting the purpose of a testing block.
  prefs: []
  type: TYPE_NORMAL
- en: Just as in Racket, there are many testing operators in Pyret (in addition to
    `is`). See [the documentation](https://www.pyret.org/docs/latest/testing.html).
  prefs: []
  type: TYPE_NORMAL
- en: 28.5Â Variable Names[ðŸ”—](#(part._.Variable_.Names) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both languages have a fairly permissive system for naming variables. While
    you can use CamelCase and under_scores in both, it is conventional to instead
    use what is known as [kebab-case](http://c2.com/cgi/wiki?KebabCase).This name
    is inaccurate. The word â€œkebabâ€ just means â€œmeatâ€. The skewer is the â€œshishâ€.
    Therefore, it ought to at least be called â€œshish kebab caseâ€. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| this-is-a-name | `this-is-a-name` |'
  prefs: []
  type: TYPE_TB
- en: Even though Pyret has infix subtraction, the language can unambiguously tell
    apart `this-name` (a variable) from `this - name` (a subtraction expression) because
    the `-` in the latter must be surrounded by spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Despite this spacing convention, Pyret does not permit some of the more exotic
    names permitted by Scheme. For instance, one can write
  prefs: []
  type: TYPE_NORMAL
- en: '| (defineÂ e^i*piÂ -1) |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: in Scheme but that is not a valid variable name in Pyret.
  prefs: []
  type: TYPE_NORMAL
- en: 28.6Â Data Definitions[ðŸ”—](#(part._.Data_.Definitions) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pyret diverges from Racket (and even more so from Scheme) in its handling of
    data definitions. First, we will see how to define a structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (define-structÂ ptÂ (xÂ y)) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'This might seem like a fair bit of overkill, but weâ€™ll see in a moment why
    itâ€™s useful. Meanwhile, itâ€™s worth observing that when you have only a single
    kind of datum in a data definition, it feels unwieldy to take up so many lines.
    Writing it on one line is valid, but now it feels ugly to have the `|` in the
    middle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, Pyret permits you to drop the initial `|`, resulting in the more
    readable
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now suppose we have two kinds of points. In the student languages of Racket,
    we would describe this with a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ;;Â AÂ PointÂ isÂ either |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ;;Â -Â (ptÂ numberÂ number),Â or |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ;;Â -Â (pt3dÂ numberÂ numberÂ number) |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'In Pyret, we can express this directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In short, Racket optimizes for the single-variant case, whereas Pyret optimizes
    for the multi-variant case. As a result, it is difficult to clearly express the
    multi-variant case in Racket, while it is unwieldy to express the single-variant
    case in Pyret.
  prefs: []
  type: TYPE_NORMAL
- en: 'For structures, both Racket and Pyret expose constructors, selectors, and predicates.
    Constructors are just functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (ptÂ 1Â 2) | `pt(1, 2)` |'
  prefs: []
  type: TYPE_TB
- en: 'Predicates are also functions with a particular naming scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (pt?Â x) | is-pt(x) |'
  prefs: []
  type: TYPE_TB
- en: 'and they behave the same way (returning true if the argument was constructed
    by that constructor, and false otherwise). In contrast, selection is different
    in the two languages (and we will see more about selection below, with `cases`):'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (pt-xÂ v) | `v.x` |'
  prefs: []
  type: TYPE_TB
- en: Note that in the Racket case, pt-x checks that the parameter was constructed
    by pt before extracting the value of the x field. Thus, pt-x and pt3d-x are two
    different functions and neither one can be used in place of the other. In contast,
    in Pyret, `.x` extracts an `x` field of any value that has such a field, without
    attention to how it was constructed. Thus, we can use `.x` on a value whether
    it was constructed by `pt` or `pt3d` (or indeed anything else with that field).
    In contrast, `cases` does pay attention to this distinction.
  prefs: []
  type: TYPE_NORMAL
- en: 28.7Â Conditionals[ðŸ”—](#(part._.Conditionals) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several kinds of conditionals in Pyret, one more than in the Racket
    student languages.
  prefs: []
  type: TYPE_NORMAL
- en: General conditionals can be written using `if`, corresponding to Racketâ€™s `if`
    but with more syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (ifÂ full-moon &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â Â "howl" &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â Â "meow") &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (ifÂ full-moon &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â Â "howl" &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â Â (ifÂ new-moon &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â Â Â Â Â Â "bark" &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â Â Â Â Â Â "meow")) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `if` includes `else if`, which makes it possible to list a collection
    of questions at the same level of indentation, which if in Racket does not have.
    The corresponding code in Racket would be written
  prefs: []
  type: TYPE_NORMAL
- en: '| (cond |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Â Â [full-moonÂ "howl"] |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Â Â [new-moonÂ "bark"] |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Â Â [elseÂ "meow"]) |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'to restore the indentation. There is a similar construct in Pyret called `ask`,
    designed to parallel `cond`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In Racket, we also use `cond` to dispatch on a datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '| (cond |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Â Â [(pt?Â v)Â Â Â (+Â (pt-xÂ v)Â (pt-yÂ v))] |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Â Â [(pt3d?Â v)Â (+Â (pt-xÂ v)Â (pt-zÂ v))]) |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'We could write this in close parallel in Pyret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'or even as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: (As in Racket student languages, the Pyret versions will signal an error if
    no branch of the conditional matched.)
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Pyret provides a special syntax just for data definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This checks that `v` is a `Point`, provides a clean syntactic way of identifying
    the different branches, and makes it possible to give a concise local name to
    each field position instead of having to use selectors like `.x`. In general,
    in Pyret we prefer to use `cases` to process data definitions. However, there
    are times when, for instance, there many variants of data but a function processes
    only very few of them. In such situations, it makes more sense to explicitly use
    predicates and selectors.
  prefs: []
  type: TYPE_NORMAL
- en: 28.8Â Lists[ðŸ”—](#(part._.Lists) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Racket, depending on the language level, lists are created using either
    cons or list, with empty for the empty list. The corresponding notions in Pyret
    are called `link`, `list`, and `empty`, respectively. `link` is a two-argument
    function, just as in Racket:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (consÂ 1Â empty) | `link(1, empty)` |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (listÂ 1Â 2Â 3) | `[list: 1, 2, 3]` |'
  prefs: []
  type: TYPE_TB
- en: 'Note that the syntax `[1, 2, 3]`, which represents lists in many languages,
    is not legal in Pyret: lists are not privileged with their own syntax. Rather,
    we must use an explicit constructor: just as `[list: 1, 2, 3]` constructs a list,
    `[set: 1, 2, 3]` constructs a set instead of a list.In fact, we can [create our
    own constructors](https://www.pyret.org/docs/latest/Expressions.html#%28part._s~3aconstruct-expr%29)
    and use them with this syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try typing `[1, 2, 3]` and see the error message.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This shows us how to construct lists. To take them apart, we use `cases`. There
    are two variants, `empty` and `link` (which we used to construct the lists):'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (cond &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â [(empty?Â l)Â 0] &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â [(cons?Â l) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â (+Â (firstÂ l) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124; Â Â Â Â Â Â (gÂ (restÂ l)))]) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: It is conventional to call the fields `f` and `r` (for â€œfirstâ€ and â€œrestâ€).
    Of course, this convention does not work if there are other things by the same
    name; in particular, when writing a nested destructuring of a list, we conventionally
    write `fr` and `rr` (for â€œfirst of the restâ€ and â€œrest of the restâ€).
  prefs: []
  type: TYPE_NORMAL
- en: 28.9Â First-Class Functions[ðŸ”—](#(part._.First-.Class_.Functions) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The equivalent of Racketâ€™s lambda is Pyretâ€™s `lam`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (lambdaÂ (xÂ y)Â (+Â xÂ y)) | `lam(x, y): x + y end` |'
  prefs: []
  type: TYPE_TB
- en: 28.10Â Annotations[ðŸ”—](#(part._.Annotations) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In student Racket languages, annotations are usually written as comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ;Â square:Â NumberÂ ->Â Number |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ;Â sort-nums:Â List<Number>Â ->Â List<Number> |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ;Â sort:Â List<T>Â *Â (TÂ *Â TÂ ->Â Boolean)Â ->Â List<T> |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: In Pyret, we write the annotations directly on the parameters and return values.
    Pyret will check them to a limited extent dynamically, and can check them statically
    with its type checker. The corresponding annotations to those above would be written
    as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 28.11Â What Else?[ðŸ”—](#(part._.What_.Else_) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If there are other parts of Scheme or Racket syntax that you would like to see
    translated, please [let us know](http://cs.brown.edu/~sk/Contact/).
  prefs: []
  type: TYPE_NORMAL
