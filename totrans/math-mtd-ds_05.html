<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>1.3. Clustering: an objective, an algorithm and a guarantee#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>1.3. Clustering: an objective, an algorithm and a guarantee#</h1>
<blockquote>原文：<a href="https://mmids-textbook.github.io/chap01_intro/03_clustering/roch-mmids-intro-clustering.html">https://mmids-textbook.github.io/chap01_intro/03_clustering/roch-mmids-intro-clustering.html</a></blockquote>

<p>Consider the following fundamental problem in data science.</p>
<p><em>The input:</em> We are given <span class="math notranslate nohighlight">\(n\)</span> vectors <span class="math notranslate nohighlight">\(\mathbf{x}_1,\ldots,\mathbf{x}_n\)</span> in <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span>.</p>
<p>Our goal is to find a good clustering<span class="math notranslate nohighlight">\(\idx{clustering}\xdi\)</span>: loosely speaking, we want to partition these data points into <span class="math notranslate nohighlight">\(k\)</span> disjoint subsets – or clusters – with small pairwise distances within clusters and large pairwise distances across clusters. To make this rather vague problem more precise, we consider a specific objective function known as the <span class="math notranslate nohighlight">\(k\)</span>-means objective. Our approach here will be typical of how one might approach a mathematical data science problem. We will first formulate the problem as an optimization problem, then derive an algorithm to solve it, and finally provide some rigorous guarantees about the output.</p>
<p><strong>Figure:</strong> Data points forming three clusters (<a class="reference external" href="https://commons.wikimedia.org/wiki/File:Cluster-2.svg">Source</a>)</p>
<p><img alt="Data points forming three clusters" src="../Images/c4d356b8ecee59d522f94bb3d77cd0e9.png" data-original-src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c8/Cluster-2.svg/640px-Cluster-2.svg.png"/></p>
<p><span class="math notranslate nohighlight">\(\bowtie\)</span></p>
<p><em>The output:</em> But first, we need to define precisely what we are trying to extract from the data. What is the mathematical structure of the solution sought? Fix a number of clusters <span class="math notranslate nohighlight">\(k\)</span>. Formally, we define a clustering as a partition.</p>
<p><strong>DEFINITION</strong> <strong>(Partition)</strong> <span class="math notranslate nohighlight">\(\idx{partition}\xdi\)</span> A partition of <span class="math notranslate nohighlight">\([n] = \{1,\ldots,n\}\)</span> of size <span class="math notranslate nohighlight">\(k\)</span> is a collection of non-empty subsets <span class="math notranslate nohighlight">\(C_1,\ldots,C_k \subseteq [n]\)</span> that:</p>
<ul class="simple">
<li><p>are pairwise disjoint, i.e., <span class="math notranslate nohighlight">\(C_i \cap C_j = \emptyset\)</span>, <span class="math notranslate nohighlight">\(\forall i \neq j\)</span></p></li>
<li><p>cover all of <span class="math notranslate nohighlight">\([n]\)</span>, i.e., <span class="math notranslate nohighlight">\(\cup_{i=1}^k C_i = [n]\)</span>.</p></li>
</ul>
<p><span class="math notranslate nohighlight">\(\natural\)</span></p>
<p><strong>EXAMPLE:</strong> Suppose we are given <span class="math notranslate nohighlight">\(8\)</span> data points in <span class="math notranslate nohighlight">\(\mathbb{R}^2\)</span> as follows:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
&amp;\mathbf{x}_1 = \begin{pmatrix}1\\0\end{pmatrix},
\mathbf{x}_2 = \begin{pmatrix}-2\\0\end{pmatrix},
\mathbf{x}_3 = \begin{pmatrix}-2\\1\end{pmatrix},
\mathbf{x}_4 = \begin{pmatrix}1\\-3\end{pmatrix},\\
&amp;\mathbf{x}_5 = \begin{pmatrix}-10\\10\end{pmatrix},
\mathbf{x}_6 = \begin{pmatrix}2\\-2\end{pmatrix},
\mathbf{x}_7 = \begin{pmatrix}-3\\1\end{pmatrix},
\mathbf{x}_8 = \begin{pmatrix}3\\-1\end{pmatrix}.
\end{align*}\]</div>
<p>So here <span class="math notranslate nohighlight">\(n=8\)</span> and <span class="math notranslate nohighlight">\(d = 2\)</span>. Assume we look for <span class="math notranslate nohighlight">\(k = 3\)</span> clusters. Then a valid clustering would be for instance:</p>
<div class="math notranslate nohighlight">
\[
C_1 = \{1, 4, 6, 8\}, C_2 = \{2, 3, 7\}, C_3 = \{5\},
\]</div>
<p>which corresponds to assigning data points <span class="math notranslate nohighlight">\(\mathbf{x}_1, \mathbf{x}_4, \mathbf{x}_6, \mathbf{x}_8\)</span> to the first cluster, data points <span class="math notranslate nohighlight">\(\mathbf{x}_2, \mathbf{x}_3, \mathbf{x}_7\)</span> to the second cluster and data point <span class="math notranslate nohighlight">\(\mathbf{x}_5\)</span> to the third cluster. Note in particular that the sets <span class="math notranslate nohighlight">\(C_1, C_2, C_3\)</span> satisfy the conditions of a partition, i.e., they are disjoint and cover all of <span class="math notranslate nohighlight">\([8] = \{1,2,\ldots,8\}\)</span>. Or put differently, each data point is assigned to one and exactly one cluster. <span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p>We number the clusters <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span> for notational convenience, but their order is meaningless. Two partitions are the same if they are the same family of subsets. E.g., in the previous example,
<span class="math notranslate nohighlight">\(C_1 = \{1, 4, 6, 8\}, C_2 = \{2, 3, 7\}, C_3 = \{5\}\)</span> and <span class="math notranslate nohighlight">\(C_1 = \{5\}, C_2 = \{1, 4, 6, 8\}, C_3 = \{2, 3, 7\}\)</span> are equivalent clusterings.</p>
<section id="the-k-means-objective">
<h2><span class="section-number">1.3.1. </span>The k-means objective<a class="headerlink" href="#the-k-means-objective" title="Link to this heading">#</a></h2>
<p>Under the <span class="math notranslate nohighlight">\(k\)</span>-means objective<span class="math notranslate nohighlight">\(\idx{k-means objective}\xdi\)</span>, the “cost” of <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[
\mathcal{G}(C_1,\ldots,C_k) = \min_{\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k \in \mathbb{R}^d} 
\sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2.
\]</div>
<p>Here <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_i \in \mathbb{R}^d\)</span> is the representative – or center – of cluster <span class="math notranslate nohighlight">\(C_i\)</span>. Note that <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_i\)</span> need not be one of the <span class="math notranslate nohighlight">\(\mathbf{x}_j\)</span>’s.</p>
<p>Our goal is to find a partition <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span> that minimizes <span class="math notranslate nohighlight">\(\mathcal{G}(C_1,\ldots,C_k)\)</span>, i.e., solves the problem</p>
<div class="math notranslate nohighlight">
\[
\min_{C_1,\ldots,C_k} \mathcal{G}(C_1,\ldots,C_k)
\]</div>
<p>over all partitions of <span class="math notranslate nohighlight">\([n]\)</span> of size <span class="math notranslate nohighlight">\(k\)</span>. This is a finite optimization problem, as there are only a finite number of such partitions. Note, however, that the objective function itself is an optimization problem over <span class="math notranslate nohighlight">\(\mathbb{R}^d \times \cdots \times \mathbb{R}^{d}\)</span>, that is, <span class="math notranslate nohighlight">\(k\)</span> copies of <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span>.</p>
<p>To quote <a class="reference external" href="https://en.wikipedia.org/wiki/Cluster_analysis#Centroid-based_clustering">Wikipedia</a>:</p>
<blockquote>
<div><p>In centroid-based clustering, clusters are represented by a central vector, which may not necessarily be a member of the data set. When the number of clusters is fixed to k, k-means clustering gives a formal definition as an optimization problem: find the k cluster centers and assign the objects to the nearest cluster center, such that the squared distances from the cluster are minimized.</p>
</div></blockquote>
<p><strong>KNOWLEDGE CHECK:</strong> Is it possible for a global solution of the <span class="math notranslate nohighlight">\(k\)</span>-means clustering problem to contain an empty cluster? <span class="math notranslate nohighlight">\(\checkmark\)</span></p>
<p>In general, the problem is <a class="reference external" href="https://en.wikipedia.org/wiki/NP-hardness">NP-hard</a><span class="math notranslate nohighlight">\(\idx{NP-hardness}\xdi\)</span>, that is, roughly speaking no “fast” algorithm is expected to exist to solve it. Lloyd’s algorithm (also referred to as the <span class="math notranslate nohighlight">\(k\)</span>-means algorithm) is a popular heuristic. It is based on the idea that the following two sub-problems are easy to solve:</p>
<ol class="arabic simple">
<li><p>finding the optimal representatives for a fixed partition;</p></li>
<li><p>finding the optimal partition for a fixed set of representatives.</p></li>
</ol>
<p>One then alternates between the two (perhaps until progress falls below a tolerance). This is reasonable since our goal, as we pointed out above, is to solve the minimization problem</p>
<div class="math notranslate nohighlight">
\[
\min_{C_1,\ldots,C_k} \min_{\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k \in \mathbb{R}^d} 
\sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2
\]</div>
<p>where <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span> ranges over all partitions of <span class="math notranslate nohighlight">\([n]\)</span> of size <span class="math notranslate nohighlight">\(k\)</span>. Fixing partition <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span> and miniminizing over <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k \in \mathbb{R}^d\)</span> corresponds to solving the first problem above, while fixing <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k \in \mathbb{R}^d\)</span> and miniminizing over partitions <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span> corresponds to solving the second problem.</p>
<p><strong>CHAT &amp; LEARN</strong> Ask your favorite AI chatbot about the differences between <span class="math notranslate nohighlight">\(k\)</span>-means, <span class="math notranslate nohighlight">\(k\)</span>-medians, and <span class="math notranslate nohighlight">\(k\)</span>-medoids clustering. <span class="math notranslate nohighlight">\(\ddagger\)</span></p>
<p><strong>Some useful optimization results</strong> To analyze the Lloyd’s algorithm, we will rely on a few basic observations.</p>
<p><em>Minimizing a quadratic function:</em> To elaborate on the first step above, we review an elementary fact about <a class="reference external" href="https://en.wikipedia.org/wiki/Quadratic_function">quadratic functions</a>.Consider the function</p>
<div class="math notranslate nohighlight">
\[
q(x) = a x^2 + b x + c.
\]</div>
<p>When <span class="math notranslate nohighlight">\(a &gt; 0\)</span>, <span class="math notranslate nohighlight">\(q\)</span> has a unique minimum.</p>
<p><strong>LEMMA</strong> <strong>(Minimum of a Quadratic Function)</strong> <span class="math notranslate nohighlight">\(\idx{minimum of a quadratic function}\xdi\)</span> Let <span class="math notranslate nohighlight">\(q(x) = a x^2 + b x + c\)</span> where <span class="math notranslate nohighlight">\(a &gt; 0\)</span> and <span class="math notranslate nohighlight">\(x \in \mathbb{R}\)</span>. The unique global minimum of <span class="math notranslate nohighlight">\(q\)</span> is attained at</p>
<div class="math notranslate nohighlight">
\[
x^* = -\frac{b}{2a}.
\]</div>
<p><span class="math notranslate nohighlight">\(\flat\)</span></p>
<p><em>Proof:</em> By the <em>First-Order Necessary Optimality Condition</em>, a global minimizer of <span class="math notranslate nohighlight">\(q\)</span> (which is necessarily a local minimizer) satisfies the condition</p>
<div class="math notranslate nohighlight">
\[
\frac{\mathrm{d}}{\mathrm{d}x} q(x) = 2 a x + b = 0,
\]</div>
<p>whose unique solution is</p>
<div class="math notranslate nohighlight">
\[
x^*= -\frac{b}{2a}.
\]</div>
<p>To see that <span class="math notranslate nohighlight">\(x^*\)</span> is indeed a global minimizer, we re-write <span class="math notranslate nohighlight">\(q\)</span> as</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
q(x) 
&amp;= a \left(x^2 + 2 \left[\frac{b}{2a}\right] x\right) + c\\
&amp;= a \left(x^2 + 2 \left[\frac{b}{2a}\right] x + \left[\frac{b}{2a}\right]^2\right) - a \left[\frac{b}{2a}\right]^2 + c\\
&amp;= a (x - x^*)^2 + \left[c - \frac{b^2}{4a}\right].
\end{align*}\]</div>
<p>Clearly, any other <span class="math notranslate nohighlight">\(x\)</span> gives a higher value for <span class="math notranslate nohighlight">\(q\)</span>. The step on the second line above is called <a class="reference external" href="https://en.wikipedia.org/wiki/Completing_the_square"><em>Completing the Square</em></a>. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p><strong>NUMERICAL CORNER:</strong> Here’s a numerical example. We first define a quadratic function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span>
</pre></div>
</div>
</div>
</div>
<p>We plot it for different values of the coefficients. Note that the <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> axes are on different scales.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">'$y_1$'</span><span class="p">,</span> <span class="s1">'$y_2$'</span><span class="p">,</span> <span class="s1">'$y_3$'</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/61bc7fdbb91557152ddeef0b81d381a6bfd002c537f7992efa581d8504d503a5.png" src="../Images/eae4bc2fb4c7aab683b47a1a195867e9.png" data-original-src="https://mmids-textbook.github.io/_images/61bc7fdbb91557152ddeef0b81d381a6bfd002c537f7992efa581d8504d503a5.png"/>
</div>
</div>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
<p><em>Optimizing an additively separable function:</em> Functions that can be written as the sum of disjoint sets of coordinates arise commonly in optimization and have convenient “separability” properties.</p>
<p>For vectors <span class="math notranslate nohighlight">\(\mathbf{x}_i \in \mathbb{R}^{d_i}\)</span>, <span class="math notranslate nohighlight">\(i \in [\ell]\)</span>, with <span class="math notranslate nohighlight">\(\sum_{i=1}^\ell d_i = d\)</span>, their concatenation is denoted as <span class="math notranslate nohighlight">\((\mathbf{x}_1, \ldots, \mathbf{x}_\ell) \in \mathbb{R}^d\)</span>. That is the vector obtained by concatenating the coordinates of <span class="math notranslate nohighlight">\(\mathbf{x}_1, \ldots, \mathbf{x}_\ell\)</span> into a single vector. A different way to see this is that <span class="math notranslate nohighlight">\((\mathbf{x}_1, \ldots, \mathbf{x}_\ell)\)</span> is a block vector with blocks <span class="math notranslate nohighlight">\(\mathbf{x}_1, \ldots, \mathbf{x}_\ell\)</span>. For example, if <span class="math notranslate nohighlight">\(\mathbf{x}_1 = (1, 2)\)</span> and <span class="math notranslate nohighlight">\(\mathbf{x}_2 = (-1, -3, -5)\)</span>, then <span class="math notranslate nohighlight">\((\mathbf{x}_1,\mathbf{x}_2) = (1, 2, -1, -3, -5)\)</span>.</p>
<p><strong>LEMMA</strong> <strong>(Optimizing a Separable Function)</strong> <span class="math notranslate nohighlight">\(\idx{optimizing a separable function lemma}\xdi\)</span> Assume that <span class="math notranslate nohighlight">\(\mathbf{z} \in \mathbb{R}^d\)</span> can be broken up into subvectors <span class="math notranslate nohighlight">\(\mathbf{x}_i \in \mathbb{R}^{d_i}\)</span>, <span class="math notranslate nohighlight">\(i \in [\ell]\)</span>, with <span class="math notranslate nohighlight">\(\sum_{i=1}^\ell d_i = d\)</span> as follows <span class="math notranslate nohighlight">\(\mathbf{z}
= (\mathbf{x}_1, \ldots, \mathbf{x}_\ell)\)</span>. Suppose that the real-valued function <span class="math notranslate nohighlight">\(h : \mathbb{R}^d \to \mathbb{R}\)</span> can be written in the additively separable form</p>
<div class="math notranslate nohighlight">
\[
h(\mathbf{z})
= f_1(\mathbf{x}_1) + \cdots + f_\ell(\mathbf{x}_\ell),
\]</div>
<p>for a collection of functions <span class="math notranslate nohighlight">\(f_i : \mathbb{R}^{d_i} \to \mathbb{R}\)</span>, <span class="math notranslate nohighlight">\(i \in [\ell]\)</span>. If, for each <span class="math notranslate nohighlight">\(i \in [\ell]\)</span>, <span class="math notranslate nohighlight">\(\mathbf{x}_i^*\)</span> is a global minimum of <span class="math notranslate nohighlight">\(f_i\)</span>, then
<span class="math notranslate nohighlight">\(\mathbf{z}^* = (\mathbf{x}_1^*, \ldots, \mathbf{x}_\ell^*)\)</span> is a global minimum of <span class="math notranslate nohighlight">\(h\)</span>. <span class="math notranslate nohighlight">\(\flat\)</span></p>
<p><em>Proof idea:</em> Each term in the sum defining <span class="math notranslate nohighlight">\(h\)</span> depends on a separate set of coordinates and therefore is unaffected by the choices made in other terms.</p>
<p><em>Proof:</em> Let <span class="math notranslate nohighlight">\(\mathbf{z}
= (\mathbf{x}_1, \ldots, \mathbf{x}_\ell)\)</span>.
Since <span class="math notranslate nohighlight">\(\mathbf{x}_i^*\)</span> is a global minimum of <span class="math notranslate nohighlight">\(f_i\)</span>, it holds that <span class="math notranslate nohighlight">\(f_i(\mathbf{x}_i^*) \leq f_i(\mathbf{x}_i)\)</span>, for all <span class="math notranslate nohighlight">\(i\)</span>. Hence,</p>
<div class="math notranslate nohighlight">
\[
h(\mathbf{z}^*)
= f_1(\mathbf{x}_1^*) + \cdots + f_\ell(\mathbf{x}_\ell^*)
\leq
f_1(\mathbf{x}_1) + \cdots + f_\ell(\mathbf{x}_\ell) = h(\mathbf{z}).
\]</div>
<p>Since <span class="math notranslate nohighlight">\(\mathbf{z}\)</span> is arbitrary, we have proved the claim. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p><em>Composing with a non-decreasing function:</em> Recall that a real-valued function <span class="math notranslate nohighlight">\(f\)</span> of a single variable is non-decreasing if</p>
<div class="math notranslate nohighlight">
\[
x \leq y \implies f(x) \leq f(y).
\]</div>
<p><strong>LEMMA</strong> <strong>(Composing with a Non-Decreasing Function)</strong> <span class="math notranslate nohighlight">\(\idx{composing with a non-decreasing function lemma}\xdi\)</span> Let <span class="math notranslate nohighlight">\(f : \mathbb{R} \to \mathbb{R}\)</span> be non-decreasing, let <span class="math notranslate nohighlight">\(g : \mathbb{R}^d \to \mathbb{R}\)</span>, and define <span class="math notranslate nohighlight">\(h(\mathbf{x}) = f(g(\mathbf{x}))\)</span>. If <span class="math notranslate nohighlight">\(\mathbf{x}^*\)</span> is a global minimum of <span class="math notranslate nohighlight">\(g\)</span>, then it is also a global minimum of <span class="math notranslate nohighlight">\(h\)</span>. <span class="math notranslate nohighlight">\(\flat\)</span></p>
<p><em>Proof idea:</em> This just follows from applying the definitions.</p>
<p><em>Proof:</em> Let <span class="math notranslate nohighlight">\(\mathbf{x} \in \mathbb{R}^d\)</span>. Because <span class="math notranslate nohighlight">\(\mathbf{x}^*\)</span> is a global minimum of <span class="math notranslate nohighlight">\(g\)</span>, <span class="math notranslate nohighlight">\(g(\mathbf{x}^*)
\leq g(\mathbf{x})\)</span>. Further, since <span class="math notranslate nohighlight">\(f\)</span> is non-decreasing,</p>
<div class="math notranslate nohighlight">
\[
h(\mathbf{x}^*)
=
f(g(\mathbf{x}^*))
\leq f(g(\mathbf{x}))
=
h(\mathbf{x}).
\]</div>
<p>Since <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> is arbitrary, we have proved the claim. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p><strong>Sub-problem 1: finding the optimal representatives</strong> We denote by <span class="math notranslate nohighlight">\(|C_i|\)</span> the number of elements in <span class="math notranslate nohighlight">\(C_i\)</span>.</p>
<p><strong>EXAMPLE:</strong> <strong>(continued)</strong> Continuing the example above, the sizes of the clusters are respectively <span class="math notranslate nohighlight">\(|C_1| = 4, |C_2| = 3, |C_3| = 1\)</span>. Note in particulat that <span class="math notranslate nohighlight">\(|C_1| + |C_2| + |C_3| = 8 = n\)</span>, as follows from the fact that <span class="math notranslate nohighlight">\(C_1, C_2, C_3\)</span> is a partition. <span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p><strong>LEMMA</strong> <strong>(Optimal Representatives)</strong> <span class="math notranslate nohighlight">\(\idx{optimal representatives lemma}\xdi\)</span> Fix a partition <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span>. The optimal representatives under the objective</p>
<div class="math notranslate nohighlight">
\[
G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k)
= \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2,
\]</div>
<p>are the <a class="reference external" href="https://en.wikipedia.org/wiki/Centroid">centroids</a><span class="math notranslate nohighlight">\(\idx{centroid}\xdi\)</span></p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{\mu}_i^* = \frac{1}{|C_i|} \sum_{j\in C_i} \mathbf{x}_j.
\]</div>
<p><span class="math notranslate nohighlight">\(\flat\)</span></p>
<p><em>Proof idea:</em> The objective <span class="math notranslate nohighlight">\(G\)</span> can be written as a sum, where each term is a quadratic function in one component of one of the <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_i\)</span>’s. Each of these terms is minimized by the average of the corresponding components of the <span class="math notranslate nohighlight">\(\mathbf{x}_j\)</span>’s belonging <span class="math notranslate nohighlight">\(C_i\)</span>.</p>
<p><strong>EXAMPLE:</strong> <strong>(continued)</strong> Continuing with the previous example, we compute the optimal representatives for the fixed partition <span class="math notranslate nohighlight">\(C_1, C_2, C_3\)</span> above. We get</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\boldsymbol{\mu}_1^*
&amp;= \frac{1}{4}[\mathbf{x}_1 + \mathbf{x}_4 + \mathbf{x}_6 + \mathbf{x}_8]\\
&amp;= \frac{1}{4}\left[\begin{pmatrix}1\\0\end{pmatrix} +
\begin{pmatrix}1\\-3\end{pmatrix} +
\begin{pmatrix}2\\-2\end{pmatrix} +
\begin{pmatrix}3\\-1\end{pmatrix}
\right]
= \begin{pmatrix}7/4\\-3/2\end{pmatrix},\\
\boldsymbol{\mu}_2^*
&amp;= \frac{1}{3}[\mathbf{x}_2 + \mathbf{x}_3 + \mathbf{x}_7]\\
&amp;= \frac{1}{3}\left[\begin{pmatrix}-2\\0\end{pmatrix}+
\begin{pmatrix}-2\\1\end{pmatrix}+
\begin{pmatrix}-3\\1\end{pmatrix}
\right]
= \begin{pmatrix}-7/3\\2/3\end{pmatrix},\\
\boldsymbol{\mu}_3^*
&amp;= \frac{1}{1}[\mathbf{x}_5]
= \begin{pmatrix}-10\\10\end{pmatrix}.
\end{align*}\]</div>
<p><span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p><em>Proof:</em> <em>(Optimal Representatives)</em> Using the notation <span class="math notranslate nohighlight">\(\mathbf{x}_j = (x_{j1},\ldots,x_{jd})\)</span> and similarly for <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_i\)</span>, note that we can expand the <span class="math notranslate nohighlight">\(k\)</span>-means objective as</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2
&amp;= \sum_{i=1}^k \sum_{j \in C_i} \sum_{m=1}^d (x_{jm} - \mu_{im})^2\\
&amp;= \sum_{i=1}^k \sum_{m=1}^d \left[\sum_{j \in C_i} (x_{jm} - \mu_{im})^2\right].
\end{align*}\]</div>
<p>The expression in square brackets is a quadratic function in <span class="math notranslate nohighlight">\(\mu_{im}\)</span></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
q_{im}(\mu_{im})
&amp;= \sum_{j \in C_i} (x_{jm} - \mu_{im})^2\\
&amp;= \left\{\sum_{j \in C_i} x_{jm}^2\right\} + \left\{- 2 \sum_{j \in C_i} x_{jm}\right\} \mu_{im}  + \left\{|C_i| \right\} \mu_{im}^2.
\end{align*}\]</div>
<p>Therefore, by the formula for the <em>Minimum of a Quadratic Function</em>,
is minimized at</p>
<div class="math notranslate nohighlight">
\[
\mu_{im}^* 
= - \frac{- 2 \sum_{j \in C_i} x_{jm}}{2 |C_i|}
= \frac{1}{|C_i|} \sum_{j \in C_i} x_{jm}.
\]</div>
<p>Since each term <span class="math notranslate nohighlight">\(q_{im}(\mu_{im})\)</span> in the sum over <span class="math notranslate nohighlight">\(i, m\)</span> making up the objective function <span class="math notranslate nohighlight">\(G\)</span> is minimized at <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_1^*,\ldots, \boldsymbol{\mu}_k^*\)</span>, so is <span class="math notranslate nohighlight">\(G\)</span> by <em>Optimizing a Separable Function</em>. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p>That the squared norm decomposes into a sum over the coordinates (which the norm itself doesn’t because of the square root) is one reason why it is convenient to use here, as was hopefully apparent in this last proof.</p>
<p><strong>Sub-problem 2: finding the optimal partition</strong> Given <span class="math notranslate nohighlight">\(n\)</span> vectors <span class="math notranslate nohighlight">\(\mathbf{x}_1,\ldots,\mathbf{x}_n\)</span> in <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span> and a partition <span class="math notranslate nohighlight">\(C_1, \ldots, C_k \subseteq [n]\)</span>, it will be useful to have some notation for the corresponding cluster assignment: we define <span class="math notranslate nohighlight">\(c(j) = i\)</span> if <span class="math notranslate nohighlight">\(j \in C_i\)</span>.</p>
<p><strong>EXAMPLE:</strong> <strong>(continued)</strong> Continuing the example above, the clusters <span class="math notranslate nohighlight">\(C_1 = \{1, 4, 6, 8\}, C_2 = \{2, 3, 7\}, C_3 = \{5\}\)</span> correspond to the assignment</p>
<div class="math notranslate nohighlight">
\[
c(1) = 1, c(2) = 2, c(3) = 2, c(4) = 1, c(5) = 3, c(6) = 1, c(7) = (2), c(8) = 1. 
\]</div>
<p><span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p><strong>LEMMA</strong> <strong>(Optimal Clustering)</strong> <span class="math notranslate nohighlight">\(\idx{optimal clustering lemma}\xdi\)</span> Fix the representatives <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k\)</span>. An optimal partition under  the objective</p>
<div class="math notranslate nohighlight">
\[
G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k)
= \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2,
\]</div>
<p>is obtained as follows. For each <span class="math notranslate nohighlight">\(j\)</span>, find the <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_i\)</span> that minimizes <span class="math notranslate nohighlight">\(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|\)</span> (picking one arbitrarily in the case of ties) and assign <span class="math notranslate nohighlight">\(\mathbf{x}_j\)</span> to <span class="math notranslate nohighlight">\(C_i\)</span> (i.e., add <span class="math notranslate nohighlight">\(j\)</span> to <span class="math notranslate nohighlight">\(C_i\)</span>). <span class="math notranslate nohighlight">\(\flat\)</span></p>
<p><em>Proof:</em> If <span class="math notranslate nohighlight">\(c\)</span> is the cluster assignment associated to <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span>, then we can re-write the objective as</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2
= \sum_{j=1}^n \|\mathbf{x}_j - \boldsymbol{\mu}_{c(j)}\|^2,
\]</div>
<p>By definition, when the <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_i\)</span>’s are fixed, each term in the sum on the right-hand side is minimized separately by the assignment in the statement. Hence so is the sum itself by the <em>Optimizing a Separable Function Lemma</em>. Note that we used the fact that the square root (and the square) is non-decreasing to conclude that minimizing <span class="math notranslate nohighlight">\(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2\)</span> or its square root <span class="math notranslate nohighlight">\(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|\)</span> are equivalent by the <em>Composing with a Non-Decreasing Function Lemma</em>. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p><strong>EXAMPLE:</strong> <strong>(continued)</strong> Continuing the example above, suppose that we choose representatives</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\boldsymbol{\mu}_1 = \begin{pmatrix}-2\\1\end{pmatrix},
\boldsymbol{\mu}_2 = \begin{pmatrix}2\\-1\end{pmatrix},
\boldsymbol{\mu}_3 = \begin{pmatrix}-10\\10\end{pmatrix}.
\end{split}\]</div>
<p>Then we find the cluster assignment of <span class="math notranslate nohighlight">\(\mathbf{x}_1\)</span> by computing its squared distance to each representative:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\|\mathbf{x}_1 - \boldsymbol{\mu}_1\|
= \left\|\begin{pmatrix}1\\0\end{pmatrix} - \begin{pmatrix}-2\\1\end{pmatrix}\right\|
= \sqrt{(1-(-2))^2 + (0-1)^2}
= \sqrt{10},
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\|\mathbf{x}_1 - \boldsymbol{\mu}_2\|
= \left\|\begin{pmatrix}1\\0\end{pmatrix} - \begin{pmatrix}2\\-1\end{pmatrix}\right\|
= \sqrt{(1-2)^2 + (0-(-1))^2}
= \sqrt{2},
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\|\mathbf{x}_1 - \boldsymbol{\mu}_3\|
= \left\|\begin{pmatrix}1\\0\end{pmatrix} - \begin{pmatrix}-10\\10\end{pmatrix}\right\|
= \sqrt{(1-(-10))^2 + (0-10)^2}
= \sqrt{221}.
\end{split}\]</div>
<p>The minimum is achieved for <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_2\)</span> so we assign <span class="math notranslate nohighlight">\(\mathbf{x}_1\)</span> to <span class="math notranslate nohighlight">\(C_2\)</span>, i.e., <span class="math notranslate nohighlight">\(1 \in C_2\)</span> and <span class="math notranslate nohighlight">\(c(1) = 2\)</span>. <span class="math notranslate nohighlight">\(\lhd\)</span></p>
</section>
<section id="lloyds-algorithm-and-its-analysis">
<h2><span class="section-number">1.3.2. </span>Lloyd’s algorithm and its analysis<a class="headerlink" href="#lloyds-algorithm-and-its-analysis" title="Link to this heading">#</a></h2>
<p>We are now ready to describe Lloyd’s algorithm<span class="math notranslate nohighlight">\(\idx{Lloyd's algorithm}\xdi\)</span>. We start from a random assignment of clusters. (An alternative <a class="reference external" href="https://en.wikipedia.org/wiki/K-means_clustering#Initialization_methods">initialization strategy</a> is to choose <span class="math notranslate nohighlight">\(k\)</span> representatives at random among the data points.) We then alternate between the optimal choices in the lemmas. In lieu of pseudo-code, we write out the algorithm in Python. We will use this approach throughout the book.</p>
<p>The input <code class="docutils literal notranslate"><span class="pre">X</span></code> is assumed to be a collection of <span class="math notranslate nohighlight">\(n\)</span> vectors <span class="math notranslate nohighlight">\(\mathbf{x}_1, \ldots, \mathbf{x}_n \in \mathbb{R}^d\)</span> stacked into a matrix, with one row for each data point. The other input, <code class="docutils literal notranslate"><span class="pre">k</span></code>, is the desired number of clusters. There is an optional input <code class="docutils literal notranslate"><span class="pre">maxiter</span></code> for the maximum number of iterations, which is set to <span class="math notranslate nohighlight">\(5\)</span> by default.</p>
<p>We first define separate functions for the two main steps. To find the minimum of an array, we use the function <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.argmin.html"><code class="docutils literal notranslate"><span class="pre">numpy.argmin</span></code></a>. We also use <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.html"><code class="docutils literal notranslate"><span class="pre">numpy.linalg.norm</span></code></a> to compute the Euclidean distance.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">opt_reps</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">assign</span><span class="p">):</span>
    <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">reps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="n">in_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">assign</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>             
        <span class="n">reps</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">in_i</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">reps</span>

<span class="k">def</span> <span class="nf">opt_clust</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">reps</span><span class="p">):</span>
    <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">assign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">dist_to_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">reps</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)])</span>
        <span class="n">assign</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_to_i</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_to_i</span><span class="p">[</span><span class="n">assign</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">assign</span>
</pre></div>
</div>
</div>
</div>
<p>The main function follows. Below, <code class="docutils literal notranslate"><span class="pre">rng.integers(0,k,n)</span></code> is an array of <code class="docutils literal notranslate"><span class="pre">n</span></code> uniformly chosen integers between <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">k-1</span></code> (inclusive). See <a class="reference external" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.integers.html">random.Generator.integers</a> for details. Recall that throughout, when defining a function that uses a random number generator (RNG), we initialize the RNG outside the function and pass the RNG to it. It allows us to maintain control over the random number generation process at a higher level and ensures consistent results across multiple runs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">kmeans</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">assign</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="n">reps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxiter</span><span class="p">):</span>
        <span class="n">reps</span> <span class="o">=</span> <span class="n">opt_reps</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> 
        <span class="n">assign</span> <span class="o">=</span> <span class="n">opt_clust</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">assign</span>
</pre></div>
</div>
</div>
</div>
<p><strong>NUMERICAL CORNER:</strong> We apply our implementation of <span class="math notranslate nohighlight">\(k\)</span>-means to the example above. We fix <code class="docutils literal notranslate"><span class="pre">k</span></code> to <span class="math notranslate nohighlight">\(3\)</span>. Here the data matrix <code class="docutils literal notranslate"><span class="pre">X</span></code> is the following:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">seed</span> <span class="o">=</span> <span class="mi">535</span>
<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">3.</span><span class="p">],</span>
              <span class="p">[</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span><span class="mf">10.</span><span class="p">],[</span><span class="mf">2.</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">],[</span><span class="o">-</span><span class="mf">3.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">]])</span>
<span class="n">assign</span> <span class="o">=</span> <span class="n">kmeans</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>162.7
74.8611111111111
9.083333333333334
9.083333333333334
9.083333333333334
</pre></div>
</div>
</div>
</div>
<p>We vizualize the output by coloring the points according to their cluster assignment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">assign</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'brg'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">11</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/cde50ddf06949815c7068a094c7184fa364e644fe65b83769400c3925c47ee23.png" src="../Images/27a0e5cd18c1654cf2e8093cd3d127f6.png" data-original-src="https://mmids-textbook.github.io/_images/cde50ddf06949815c7068a094c7184fa364e644fe65b83769400c3925c47ee23.png"/>
</div>
</div>
<p>We can compute the final representatives (optimal for the final assignment) by using the subroutine <code class="docutils literal notranslate"><span class="pre">opt_reps</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="nb">print</span><span class="p">(</span><span class="n">opt_reps</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">assign</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[[ -2.33333333   0.66666667]
 [  1.75        -1.5       ]
 [-10.          10.        ]]
</pre></div>
</div>
</div>
</div>
<p>Each row is the center of the corresponding cluster. Note these match with the ones we previously computed. Indeed, the clustering is the same (although not necessarily in the same order).</p>
<p><strong>TRY IT!</strong> Modify <code class="docutils literal notranslate"><span class="pre">kmeans</span></code> to take a tolerance <code class="docutils literal notranslate"><span class="pre">tol</span></code> as input and stop when the improvement in objective value <code class="docutils literal notranslate"><span class="pre">G</span></code> falls below the tolerance. (<a class="reference external" href="https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_intro_notebook.ipynb">Open in Colab</a>)</p>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
<p><img alt="Evolution of the assignment for -means clustering on data generated by a mixture of spherical Gaussians with variance  and respective means  and . The crosses show the cluster representatives. The objective value is shown as . (With help from Claude; inspired by (Source).)" src="../Images/2c9ccfca527fcd49962e30d8a67f4fdb.png" data-original-src="https://mmids-textbook.github.io/_images/kmeans-iterations.png"/></p>
<p><strong>KNOWLEDGE CHECK:</strong> Suppose we have infinite computational resources and run Lloyd’s algorithm forever, do you think it will necessarily converge to a global minimum? If your answer is no, can you think of an alternative algorithm that is guaranteed to output a global minimum provided enough computational resources? <span class="math notranslate nohighlight">\(\checkmark\)</span></p>
<p>Lloyd’s algorithm is only a heuristic. In particular, it is not guaranteed to find the global minimum of the <span class="math notranslate nohighlight">\(k\)</span>-means objective. However, it is guaranteed to improve the objective at every iteration, or more precisely, not to make it worse.</p>
<p><strong>THEOREM</strong> <strong>(Convergence of <span class="math notranslate nohighlight">\(k\)</span>-means cost)</strong> <span class="math notranslate nohighlight">\(\idx{convergence of k-means cost theorem}\xdi\)</span> The sequence of objective function values produced by the <span class="math notranslate nohighlight">\(k\)</span>-means algorithm is non-increasing. <span class="math notranslate nohighlight">\(\sharp\)</span></p>
<p><em>Proof idea:</em> By the <em>Optimal Representatives Lemma</em> and the <em>Optimal Clustering Lemma</em>, each step does not increase the objective.</p>
<p><em>Proof:</em> Let <span class="math notranslate nohighlight">\(C_1',\ldots,C_k'\)</span> be the current clusters, with representatives <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_1',\ldots,\boldsymbol{\mu}_k'\)</span>. After Step 1, the new representatives are <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_1'',\ldots,\boldsymbol{\mu}_k''\)</span>. By the <em>Optimal Representatives Lemma</em>, they satisfy</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
\leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i'\|^2.
\]</div>
<p>After Step 2, the new clusters are <span class="math notranslate nohighlight">\(C_1'',\ldots,C_k''\)</span>. By the <em>Optimal Clustering Lemma</em>, they satisfy</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=1}^k \sum_{j \in C_i''} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
\leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2.
\]</div>
<p>Combining these two inequalities gives</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=1}^k \sum_{j \in C_i''} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
\leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i'\|^2,
\]</div>
<p>as claimed. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p>The sequence of objective values is monotone and bounded from below by <span class="math notranslate nohighlight">\(0\)</span>. <a class="reference external" href="https://en.wikipedia.org/wiki/Monotone_convergence_theorem#Convergence_of_a_monotone_sequence_of_real_numbers">Hence it converges</a>. Note that the limit depends on the starting point.</p>
<p><strong>CHAT &amp; LEARN</strong> AI chatbots can serve as great personal tutors, especially when it comes to coding which they often excel at. In particular, they can provide additional information about the code in this book. Just copy-paste a piece of code and ask “What is this code doing?” Don’t hesitate to ask follow-up questions. <a class="reference external" href="https://chat.openai.com/share/66f9e704-c8e8-4489-9ab6-8e57740cab3b">Here is an example using ChatGPT</a>.</p>
<p><em>Warning:</em> As you probably know, AI chatbots can be wrong so assess what they tell you with a critical mind and/or double-check with other sources (e.g., package documentation).</p>
<p><em>Prompt engineering:</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Prompt_engineering">Finding the right prompt</a>, or series of prompts, can make a big difference. It can also be used to produce more interesting answers. Here is an explanation of the <span class="math notranslate nohighlight">\(k\)</span>-means algorithm in the style of Shakespeare via ChatGPT:</p>
<blockquote>
<div><p><strong>Scene: The Realm of Numerica, in the Enchanted Forest of Analysis</strong></p>
<p><em>Enter LORD VECTOR, LADY PARTITION, and an assembly of WHISPERING WINDS</em></p>
<p>LORD VECTOR (a majestic entity):</p>
<p>Hearken, Whispering Winds, scattered far and wide,</p>
<p>I am Lord Vector, your anchor and your guide.</p>
<p>In clusters, you must settle, by my call and by my side,</p>
<p>To me, you’ll draw nigh, in unity, abide.</p>
<p>LADY PARTITION (a sage enchantress):</p>
<p>And I, Lady Partition, with vision clear and keen,</p>
<p>Determine where amongst the clusters each of you shall lean.</p>
<p>With Lord Vector, a ballet we compose, with steps so fine,</p>
<p>To sort, to gather, to align, under a sign divine.</p>
<p>WHISPERING WIND 1:</p>
<p>But how, noble Vector, wilt thou find thy rightful stead?</p>
<p>In this expanse diverse, how set thy bed?</p>
<p>LORD VECTOR:</p>
<p>Through cycles and through wisdom, I seek my sacred ground,</p>
<p>Where the sum of all distances to me is least found.</p>
<p>From your essence, I emerge, an average pure and sound,</p>
<p>A beacon most true, by which I am crowned.</p>
<p>WHISPERING WIND 2:</p>
<p>And Lady Partition, how do we seek our kin,</p>
<p>In this multitude, how does our journey begin?</p>
<p>LADY PARTITION:</p>
<p>By measure and affinity, to your closest Lord Vector, you’ll gravitate,</p>
<p>To him, your allegiance, you’ll consecrate.</p>
<p>In groups, you’ll assemble, by likeness you’re drawn,</p>
<p>A collective symphony, from dusk till dawn.</p>
<p><em>LORD VECTOR and LADY PARTITION assume their roles, guiding the WHISPERING WINDS to move and regroup.</em></p>
<p>LORD VECTOR:</p>
<p>Observe now how I traverse, as your allegiances refine,</p>
<p>A center more apt, in this spell of mine.</p>
<p>LADY PARTITION:</p>
<p>And as you drift, dear winds, to your Lords true,</p>
<p>A closer union we construe, a balance anew.</p>
<p><em>The WHISPERING WINDS shuffle and align, moving from one cluster to another, as LORD VECTOR adjusts his position with grace.</em></p>
<p>WHISPERING WIND 3:</p>
<p>At length, I perceive, where I am to dwell,</p>
<p>With peers akin, in cluster well.</p>
<p>LORD VECTOR:</p>
<p>So we dance and weave, ‘til stillness we achieve,</p>
<p>When each wind has settled, and we, in relief.</p>
<p>LADY PARTITION:</p>
<p>Thus, optimal clusters come forth, vivid and serene,</p>
<p>With centers well placed, a sight unseen.</p>
<p><em>The WHISPERING WINDS now rest peacefully in clusters around their LORD VECTORS, the Enchanted Forest of Analysis a testament to their orderly ballet.</em></p>
<p>LORD VECTOR &amp; LADY PARTITION (together):</p>
<p>Our task here concludes, with harmony and grace,</p>
<p>The K-means enchantment, a solution embraced.</p>
<p><em>Exeunt omnes, as the WHISPERING WINDS repose in unity around their LORD VECTORS, the realm of Numerica reflecting their harmonious dance.</em></p>
<p><strong>End of Scene</strong></p>
</div></blockquote>
<p><span class="math notranslate nohighlight">\(\ddagger\)</span></p>
<p><strong>NUMERICAL CORNER:</strong> We will test our implementation of <span class="math notranslate nohighlight">\(k\)</span>-means on the penguins dataset introduced earlier in the chapter. We first extract the columns and combine them into a data matrix <code class="docutils literal notranslate"><span class="pre">X</span></code>. As we did previously, we also remove the rows with missing values.</p>
<p><strong>Figure:</strong> Which penguin species? (<em>Credit:</em> Made with <a class="reference external" href="https://www.midjourney.com/">Midjourney</a>)</p>
<p><img alt="Penguins on a glacier" src="../Images/bb7e8602c95a01b1185de572b4c55ec8.png" data-original-src="https://mmids-textbook.github.io/_images/three_penguins_on_a_glacier-small.png"/></p>
<p><span class="math notranslate nohighlight">\(\bowtie\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'penguins-measurements.csv'</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">'bill_length_mm'</span><span class="p">,</span> <span class="s1">'bill_depth_mm'</span><span class="p">,</span> 
        <span class="s1">'flipper_length_mm'</span><span class="p">,</span> <span class="s1">'body_mass_g'</span><span class="p">]]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We  visualize a two-dimensional slice of the data.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">'k'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'bill_depth_mm'</span><span class="p">),</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'body_mass_g'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/024d26811e4631ac8dcb5acb1d23f5c577193d3217b2493260af97e706f2b329.png" src="../Images/e75683392ec1e758370886f76273bfb6.png" data-original-src="https://mmids-textbook.github.io/_images/024d26811e4631ac8dcb5acb1d23f5c577193d3217b2493260af97e706f2b329.png"/>
</div>
</div>
<p>Observe that the features have quite different scales (tens versus thousands in the plot above). In such a case, it is common to standardize the data so that each feature has roughly the same scale. For each column of <code class="docutils literal notranslate"><span class="pre">X</span></code>, we subtract its empirical mean and divide by its empirical standard deviation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">std</span>
</pre></div>
</div>
</div>
</div>
<p>Now we run Lloyd’s algorithm with <span class="math notranslate nohighlight">\(k=2\)</span> clusters.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">assign</span> <span class="o">=</span> <span class="n">kmeans</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>1338.2046936914157
820.9361062178352
603.8787658966849
575.2587351391593
567.7837494880662
</pre></div>
</div>
</div>
</div>
<p>We vizualize the output as we did before, but this time coloring the data points by their cluster assignment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">assign</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'brg'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'bill_depth (standardized)'</span><span class="p">),</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'body_mass (standardized)'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/c8ce542a010e33ab2c018c7c7624c391c5b57fa97d97a1146013f2c8d77068de.png" src="../Images/828f36ddad8cd4ead1a7000754909d59.png" data-original-src="https://mmids-textbook.github.io/_images/c8ce542a010e33ab2c018c7c7624c391c5b57fa97d97a1146013f2c8d77068de.png"/>
</div>
</div>
<p>This clustering looks quite good. Nevertheless recall that:</p>
<ol class="arabic simple">
<li><p>in this plot we are looking at only two of the four variables while <span class="math notranslate nohighlight">\(k\)</span>-means uses all of them,</p></li>
<li><p>we are not guaranteed to find the best solution,</p></li>
<li><p>our objective function is somewhat arbitrary, and</p></li>
<li><p>it is not clear what the right choice of <span class="math notranslate nohighlight">\(k\)</span> is.</p></li>
</ol>
<p>In fact, the original dataset contained the correct answer, as provided by biologists. Despite what the figure above may lead us to believe, there are in reality three separate species. So let us try with <span class="math notranslate nohighlight">\(k=3\)</span> clusters.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">assign</span> <span class="o">=</span> <span class="n">kmeans</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>1312.344945158482
577.1700837839458
428.50397345437966
392.2616692426171
383.3452894259011
</pre></div>
</div>
</div>
</div>
<p>The output does not seem quite right.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">assign</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'brg'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'bill_depth (standardized)'</span><span class="p">),</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'body_mass (standardized)'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/7383cabd085a8a7eba9545c89a27d27d31401b0dc50cd001fbe5cfc405e9131c.png" src="../Images/0cf53aabbe4e2f47806ce1ae1b6cde65.png" data-original-src="https://mmids-textbook.github.io/_images/7383cabd085a8a7eba9545c89a27d27d31401b0dc50cd001fbe5cfc405e9131c.png"/>
</div>
</div>
<p>But, remembering the warnings mentioned previously, let us look at a different two-dimensional slice.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">assign</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'brg'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'bill_length (standardized)'</span><span class="p">),</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'body_mass (standardized)'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/62dde40d80824421548718832e220f969d2f9a28a560918552424440517b225e.png" src="../Images/9702034e7031f67493cefa19852b584d.png" data-original-src="https://mmids-textbook.github.io/_images/62dde40d80824421548718832e220f969d2f9a28a560918552424440517b225e.png"/>
</div>
</div>
<p>Let us load up the truth and compare. We only keep those samples that were not removed because of missing values (see <a class="reference external" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html"><code class="docutils literal notranslate"><span class="pre">pandas.DataFrame.iloc</span></code></a>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">data_truth</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'penguins-species.csv'</span><span class="p">)</span> 
<span class="n">data_truth</span> <span class="o">=</span> <span class="n">data_truth</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
<span class="n">data_truth</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th/>
      <th>species</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Adelie</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Adelie</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Adelie</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Adelie</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Adelie</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>The species are:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">species</span> <span class="o">=</span> <span class="n">data_truth</span><span class="p">[</span><span class="s1">'species'</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">species</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>['Adelie' 'Chinstrap' 'Gentoo']
</pre></div>
</div>
</div>
</div>
<p>To plot the outcome, we color the species blue-green-red using a <a class="reference external" href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries">dictionary</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">species2color_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'Adelie'</span><span class="p">:</span> <span class="s1">'blue'</span><span class="p">,</span> <span class="s1">'Chinstrap'</span><span class="p">:</span> <span class="s1">'lime'</span><span class="p">,</span> <span class="s1">'Gentoo'</span><span class="p">:</span> <span class="s1">'red'</span><span class="p">}</span>
<span class="n">truth</span> <span class="o">=</span> <span class="p">[</span><span class="n">species2color_dict</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">species</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we can compare the output to the truth. The match is quite good – but certainly not perfect.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">6.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">truth</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'truth'</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">assign</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'brg'</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'kmeans'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/00f2abf0740c5bf6a562d8f607ab3a6d116d7ba0e1b03f9e035f875e36954e86.png" src="../Images/1de9d394fa9649dc467bc539e8b0de94.png" data-original-src="https://mmids-textbook.github.io/_images/00f2abf0740c5bf6a562d8f607ab3a6d116d7ba0e1b03f9e035f875e36954e86.png"/>
</div>
</div>
<p>Determining the appropriate number of clusters is not a straighforward problem. To quote <a class="reference external" href="https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set">Wikipedia</a>:</p>
<blockquote>
<div><p>The correct choice of <span class="math notranslate nohighlight">\(k\)</span> is often ambiguous, with interpretations depending on the shape and scale of the distribution of points in a data set and the desired clustering resolution of the user. In addition, increasing <span class="math notranslate nohighlight">\(k\)</span> without penalty will always reduce the amount of error in the resulting clustering, to the extreme case of zero error if each data point is considered its own cluster (i.e., when <span class="math notranslate nohighlight">\(k\)</span> equals the number of data points, <span class="math notranslate nohighlight">\(n\)</span>). Intuitively then, the optimal choice of <span class="math notranslate nohighlight">\(k\)</span> will strike a balance between maximum compression of the data using a single cluster, and maximum accuracy by assigning each data point to its own cluster. If an appropriate value of <span class="math notranslate nohighlight">\(k\)</span> is not apparent from prior knowledge of the properties of the data set, it must be chosen somehow. There are several categories of methods for making this decision.</p>
</div></blockquote>
<p>In practice, <a class="reference external" href="https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set">several heuristics</a> are in use. Other approaches to clustering, e.g. <a class="reference external" href="https://en.wikipedia.org/wiki/DBSCAN">DBSCAN</a> and <a class="reference external" href="https://en.wikipedia.org/wiki/Hierarchical_clustering">hierarchical clustering</a>, do not require a number of clusters as input.</p>
<p><strong>TRY IT!</strong> Run the analysis again, but this time <em>without the standardization step</em>. What do you observe? Is one feature more influential on the final output than the others? Why do you think that is? (<a class="reference external" href="https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_intro_notebook.ipynb">Open in Colab</a>)</p>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
</section>
<section id="matrix-form-of-k-means-clustering">
<h2><span class="section-number">1.3.3. </span>Matrix form of k-means clustering<a class="headerlink" href="#matrix-form-of-k-means-clustering" title="Link to this heading">#</a></h2>
<p>In this section, we show that the <span class="math notranslate nohighlight">\(k\)</span>-means clustering objective can be written in matrix form. We start with some notation and definitions that will be useful throughout.</p>
<p>As we indicated before, for a collection of <span class="math notranslate nohighlight">\(n\)</span> data vectors <span class="math notranslate nohighlight">\(\mathbf{x}_1, \ldots, \mathbf{x}_n\)</span> in <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span>, it is often convenient to stack them up into a matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}
X =
\begin{bmatrix}
\mathbf{x}_1^T \\
\mathbf{x}_2^T \\
\vdots \\
\mathbf{x}_n^T \\
\end{bmatrix}
=
\begin{bmatrix}
x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d} \\
x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2d} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{n1} &amp; x_{n2} &amp; \cdots &amp; x_{nd} \\
\end{bmatrix}.
\end{split}\]</div>
<p>We can do the same with cluster representatives. Given <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k\)</span> also in <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span>, we form the matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}
U =
\begin{bmatrix}
\boldsymbol{\mu}_1^T \\
\boldsymbol{\mu}_2^T \\
\vdots \\
\boldsymbol{\mu}_k^T \\
\end{bmatrix}
=
\begin{bmatrix}
\mu_{11} &amp; \mu_{12} &amp; \cdots &amp; \mu_{1d} \\
\mu_{21} &amp; \mu_{22} &amp; \cdots &amp; \mu_{2d} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\mu_{k1} &amp; \mu_{k2} &amp; \cdots &amp; \mu_{kd} \\
\end{bmatrix}.
\end{split}\]</div>
<p>Perhaps less obviously, cluster assignments can also be encoded in matrix form. Recall that, given a partition <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span> of <span class="math notranslate nohighlight">\([n]\)</span>, we define <span class="math notranslate nohighlight">\(c(j) = i\)</span> if <span class="math notranslate nohighlight">\(j \in C_i\)</span>. For <span class="math notranslate nohighlight">\(j=1,\ldots,n\)</span> and <span class="math notranslate nohighlight">\(\ell=1,\ldots,k\)</span>, set <span class="math notranslate nohighlight">\(Z_{j\ell} = 1\)</span> if <span class="math notranslate nohighlight">\(c(j) = \ell\)</span> and <span class="math notranslate nohighlight">\(0\)</span> otherwise, and let <span class="math notranslate nohighlight">\(Z\)</span> be the <span class="math notranslate nohighlight">\(n \times k\)</span> matrix with entries <span class="math notranslate nohighlight">\(Z = [Z_{j\ell}]_{j,\ell}\)</span>. That is, row <span class="math notranslate nohighlight">\(j\)</span> has exactly one entry with value <span class="math notranslate nohighlight">\(1\)</span>, corresponding to the assigned cluster <span class="math notranslate nohighlight">\(c(j)\)</span> of data point <span class="math notranslate nohighlight">\(\mathbf{x}_j\)</span>, and all other entries <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>With this notation, the representative of the cluster assigned to data point <span class="math notranslate nohighlight">\(\mathbf{x}_j\)</span> is obtained through a matrix product</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{\mu}_{c(j)}^T 
= \sum_{\ell = 1}^k Z_{j\ell} \boldsymbol{\mu}_{\ell}^T
= \sum_{\ell = 1}^k Z_{j\ell} U_{\ell,\cdot}
= \left(Z U\right)_{j,\cdot}
\]</div>
<p>where we used that the <span class="math notranslate nohighlight">\(j\)</span>-th row of a matrix product is a linear combination of the rows of the second matrix, where the coefficients are the entries on the <span class="math notranslate nohighlight">\(j\)</span>-th row of the first one.</p>
<p><strong>EXAMPLE:</strong> <strong>(continued)</strong> Continuing with our previous example, the clusters <span class="math notranslate nohighlight">\(C_1 = \{1, 4, 6, 8\}, C_2 = \{2, 3, 7\}, C_3 = \{5\}\)</span> are encoded as the matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}
Z 
= \begin{bmatrix}
1 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0\\
0 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0
\end{bmatrix}.
\end{split}\]</div>
<p>Suppose again that the representatives are</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\boldsymbol{\mu}_1 = \begin{pmatrix}-2\\1\end{pmatrix},
\boldsymbol{\mu}_2 = \begin{pmatrix}2\\-1\end{pmatrix},
\boldsymbol{\mu}_3 = \begin{pmatrix}-10\\10\end{pmatrix}.
\end{split}\]</div>
<p>The corresponding matrix <span class="math notranslate nohighlight">\(U\)</span> is then</p>
<div class="math notranslate nohighlight">
\[\begin{split}
U 
= 
\begin{bmatrix}
-2 &amp; 1\\
2 &amp; -1\\
-10 &amp; 10
\end{bmatrix}.
\end{split}\]</div>
<p>Hence multiplying <span class="math notranslate nohighlight">\(Z\)</span> and <span class="math notranslate nohighlight">\(U\)</span> produces a matrix where each row is the representative of the assigned cluster of the corresponding data point</p>
<div class="math notranslate nohighlight">
\[\begin{split}
ZU 
= 
\begin{bmatrix}
1 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0\\
0 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0
\end{bmatrix}
\,
\begin{bmatrix}
-2 &amp; 1\\
2 &amp; -1\\
-10 &amp; 10
\end{bmatrix}
= 
\begin{bmatrix}
-2 &amp; 1\\
2 &amp; -1\\
2 &amp; -1\\
-2 &amp; 1\\
-10 &amp; 10\\
-2 &amp; 1\\
2 &amp; -1\\
-2 &amp; 1
\end{bmatrix}.
\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p>Recall that the Frobenius norm of an <span class="math notranslate nohighlight">\(n \times m\)</span> matrix <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{n \times m}\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[
\|A\|_F
= \sqrt{\sum_{i=1}^n \sum_{j=1}^m A_{ij}^2}.
\]</div>
<p>Using row notation, it can be written as the sum of the squared Euclidean norms of the rows</p>
<div class="math notranslate nohighlight">
\[
\|A\|_F^2 = \sum_{i=1}^n \|A_{i,\cdot}\|^2.
\]</div>
<p>For two matrices <span class="math notranslate nohighlight">\(A, B \in \mathbb{R}^{n \times m}\)</span>, the Frobenius norm of their difference <span class="math notranslate nohighlight">\(\|A - B\|_F\)</span> can be interpreted as a distance between <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, that is, a measure of how dissimilar they are.</p>
<p>Finally, we return to the <span class="math notranslate nohighlight">\(k\)</span>-means objective. Using the notation introduced in this section and the equivalent formula for the objective <span class="math notranslate nohighlight">\(G\)</span> derived in the proof of the <em>Optimal Clustering Lemma</em>, we note that</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k)
&amp;= \sum_{i=1}^n \|\mathbf{x}_i - \boldsymbol{\mu}_{c(i)}\|^2\\
&amp;= \sum_{i=1}^n \sum_{\ell=1}^d \left(x_{i\ell} - (Z U)_{i\ell}\right)^2\\
&amp;= \|X - Z U \|^2_F,
\end{align*}\]</div>
<p>where we used the definition of the Frobenius norm.</p>
<p>In other words, minimizing the <span class="math notranslate nohighlight">\(k\)</span>-means objective is equivalent to finding a matrix factorization of the form <span class="math notranslate nohighlight">\(ZU\)</span> that is a good fit to the data matrix <span class="math notranslate nohighlight">\(X\)</span> in Frobenius norm. This formulation expresses in a more compact form the idea of representing <span class="math notranslate nohighlight">\(X\)</span> as a combination of a small number of representatives. Matrix factorization will come back repeatedly in this course.</p>
<p><em><strong>Self-assessment quiz</strong></em> <em>(with help from Claude, Gemini, and ChatGPT)</em></p>
<p><strong>1</strong> Which of these is NOT a property of a valid partition <span class="math notranslate nohighlight">\(C_1, \ldots, C_k\)</span> in the context of <span class="math notranslate nohighlight">\(k\)</span>-means?</p>
<p>a) The subsets are pairwise disjoint</p>
<p>b) The subsets cover all data points</p>
<p>c) Each subset is non-empty</p>
<p>d) Each subset contains an equal number of points</p>
<p><strong>2</strong> In the <span class="math notranslate nohighlight">\(k\)</span>-means objective function, what does the variable <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_i\)</span> represent?</p>
<p>a) The centroid of cluster <span class="math notranslate nohighlight">\(i\)</span></p>
<p>b) The number of points in cluster <span class="math notranslate nohighlight">\(i\)</span></p>
<p>c) The distance between clusters <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span></p>
<p>d) The assignment of point <span class="math notranslate nohighlight">\(j\)</span> to a cluster</p>
<p><strong>3</strong> The <span class="math notranslate nohighlight">\(k\)</span>-means objective function is a measure of what?</p>
<p>a) The total number of clusters.</p>
<p>b) The average distance between data points.</p>
<p>c) The sum of squared distances between each data point and its assigned cluster center.</p>
<p>d) The maximum distance between any two cluster centers.</p>
<p><strong>4</strong> What is a key property of the sequence of objective function values produced by the <span class="math notranslate nohighlight">\(k\)</span>-means algorithm?</p>
<p>a) It is strictly decreasing</p>
<p>b) It is non-increasing</p>
<p>c) It is strictly increasing</p>
<p>d) It alternates between two values</p>
<p><strong>5</strong> What is the interpretation of the matrix <span class="math notranslate nohighlight">\(Z\)</span> in the matrix formulation of <span class="math notranslate nohighlight">\(k\)</span>-means?</p>
<p>a) It represents the cluster centers.</p>
<p>b) It represents the distances between data points.</p>
<p>c) It encodes the cluster assignments of each data point.</p>
<p>d) It represents the covariance matrix of the data.</p>
<p>Answer for 1: d. Justification: “Formally, we define a clustering as a partition. A partition of <span class="math notranslate nohighlight">\([n] = {1,\ldots,n}\)</span> of size <span class="math notranslate nohighlight">\(k\)</span> is a collection of non-empty subsets <span class="math notranslate nohighlight">\(C_1,\ldots,C_k \subseteq [n]\)</span> that: are pairwise disjoint, i.e., <span class="math notranslate nohighlight">\(C_i \cap C_j = \emptyset\)</span>, <span class="math notranslate nohighlight">\(\forall i \neq j\)</span>; cover all of <span class="math notranslate nohighlight">\([n]\)</span>, i.e., <span class="math notranslate nohighlight">\(\cup_{i=1}^k C_i = [n]\)</span>.” No requirement for equal-sized subsets is mentioned.</p>
<p>Answer for 2: a. Justification: “Here <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_i \in \mathbb{R}^d\)</span> is the representative – or center – of cluster <span class="math notranslate nohighlight">\(C_i\)</span>.”</p>
<p>Answer for 3: c. Justification: The <span class="math notranslate nohighlight">\(k\)</span>-means objective is defined in the text as minimizing the sum of squared distances between data points and their assigned cluster centers.</p>
<p>Answer for 4: b. Justification: “The sequence of objective function values produced by the <span class="math notranslate nohighlight">\(k\)</span>-means algorithm is non-increasing.”</p>
<p>Answer for 5: c. Justification: The text defines <span class="math notranslate nohighlight">\(Z\)</span> as a matrix where “each row has exactly one entry with value 1, corresponding to the assigned cluster of data point.”</p>
</section>
&#13;

<h2><span class="section-number">1.3.1. </span>The k-means objective<a class="headerlink" href="#the-k-means-objective" title="Link to this heading">#</a></h2>
<p>Under the <span class="math notranslate nohighlight">\(k\)</span>-means objective<span class="math notranslate nohighlight">\(\idx{k-means objective}\xdi\)</span>, the “cost” of <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[
\mathcal{G}(C_1,\ldots,C_k) = \min_{\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k \in \mathbb{R}^d} 
\sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2.
\]</div>
<p>Here <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_i \in \mathbb{R}^d\)</span> is the representative – or center – of cluster <span class="math notranslate nohighlight">\(C_i\)</span>. Note that <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_i\)</span> need not be one of the <span class="math notranslate nohighlight">\(\mathbf{x}_j\)</span>’s.</p>
<p>Our goal is to find a partition <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span> that minimizes <span class="math notranslate nohighlight">\(\mathcal{G}(C_1,\ldots,C_k)\)</span>, i.e., solves the problem</p>
<div class="math notranslate nohighlight">
\[
\min_{C_1,\ldots,C_k} \mathcal{G}(C_1,\ldots,C_k)
\]</div>
<p>over all partitions of <span class="math notranslate nohighlight">\([n]\)</span> of size <span class="math notranslate nohighlight">\(k\)</span>. This is a finite optimization problem, as there are only a finite number of such partitions. Note, however, that the objective function itself is an optimization problem over <span class="math notranslate nohighlight">\(\mathbb{R}^d \times \cdots \times \mathbb{R}^{d}\)</span>, that is, <span class="math notranslate nohighlight">\(k\)</span> copies of <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span>.</p>
<p>To quote <a class="reference external" href="https://en.wikipedia.org/wiki/Cluster_analysis#Centroid-based_clustering">Wikipedia</a>:</p>
<blockquote>
<div><p>In centroid-based clustering, clusters are represented by a central vector, which may not necessarily be a member of the data set. When the number of clusters is fixed to k, k-means clustering gives a formal definition as an optimization problem: find the k cluster centers and assign the objects to the nearest cluster center, such that the squared distances from the cluster are minimized.</p>
</div></blockquote>
<p><strong>KNOWLEDGE CHECK:</strong> Is it possible for a global solution of the <span class="math notranslate nohighlight">\(k\)</span>-means clustering problem to contain an empty cluster? <span class="math notranslate nohighlight">\(\checkmark\)</span></p>
<p>In general, the problem is <a class="reference external" href="https://en.wikipedia.org/wiki/NP-hardness">NP-hard</a><span class="math notranslate nohighlight">\(\idx{NP-hardness}\xdi\)</span>, that is, roughly speaking no “fast” algorithm is expected to exist to solve it. Lloyd’s algorithm (also referred to as the <span class="math notranslate nohighlight">\(k\)</span>-means algorithm) is a popular heuristic. It is based on the idea that the following two sub-problems are easy to solve:</p>
<ol class="arabic simple">
<li><p>finding the optimal representatives for a fixed partition;</p></li>
<li><p>finding the optimal partition for a fixed set of representatives.</p></li>
</ol>
<p>One then alternates between the two (perhaps until progress falls below a tolerance). This is reasonable since our goal, as we pointed out above, is to solve the minimization problem</p>
<div class="math notranslate nohighlight">
\[
\min_{C_1,\ldots,C_k} \min_{\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k \in \mathbb{R}^d} 
\sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2
\]</div>
<p>where <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span> ranges over all partitions of <span class="math notranslate nohighlight">\([n]\)</span> of size <span class="math notranslate nohighlight">\(k\)</span>. Fixing partition <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span> and miniminizing over <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k \in \mathbb{R}^d\)</span> corresponds to solving the first problem above, while fixing <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k \in \mathbb{R}^d\)</span> and miniminizing over partitions <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span> corresponds to solving the second problem.</p>
<p><strong>CHAT &amp; LEARN</strong> Ask your favorite AI chatbot about the differences between <span class="math notranslate nohighlight">\(k\)</span>-means, <span class="math notranslate nohighlight">\(k\)</span>-medians, and <span class="math notranslate nohighlight">\(k\)</span>-medoids clustering. <span class="math notranslate nohighlight">\(\ddagger\)</span></p>
<p><strong>Some useful optimization results</strong> To analyze the Lloyd’s algorithm, we will rely on a few basic observations.</p>
<p><em>Minimizing a quadratic function:</em> To elaborate on the first step above, we review an elementary fact about <a class="reference external" href="https://en.wikipedia.org/wiki/Quadratic_function">quadratic functions</a>.Consider the function</p>
<div class="math notranslate nohighlight">
\[
q(x) = a x^2 + b x + c.
\]</div>
<p>When <span class="math notranslate nohighlight">\(a &gt; 0\)</span>, <span class="math notranslate nohighlight">\(q\)</span> has a unique minimum.</p>
<p><strong>LEMMA</strong> <strong>(Minimum of a Quadratic Function)</strong> <span class="math notranslate nohighlight">\(\idx{minimum of a quadratic function}\xdi\)</span> Let <span class="math notranslate nohighlight">\(q(x) = a x^2 + b x + c\)</span> where <span class="math notranslate nohighlight">\(a &gt; 0\)</span> and <span class="math notranslate nohighlight">\(x \in \mathbb{R}\)</span>. The unique global minimum of <span class="math notranslate nohighlight">\(q\)</span> is attained at</p>
<div class="math notranslate nohighlight">
\[
x^* = -\frac{b}{2a}.
\]</div>
<p><span class="math notranslate nohighlight">\(\flat\)</span></p>
<p><em>Proof:</em> By the <em>First-Order Necessary Optimality Condition</em>, a global minimizer of <span class="math notranslate nohighlight">\(q\)</span> (which is necessarily a local minimizer) satisfies the condition</p>
<div class="math notranslate nohighlight">
\[
\frac{\mathrm{d}}{\mathrm{d}x} q(x) = 2 a x + b = 0,
\]</div>
<p>whose unique solution is</p>
<div class="math notranslate nohighlight">
\[
x^*= -\frac{b}{2a}.
\]</div>
<p>To see that <span class="math notranslate nohighlight">\(x^*\)</span> is indeed a global minimizer, we re-write <span class="math notranslate nohighlight">\(q\)</span> as</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
q(x) 
&amp;= a \left(x^2 + 2 \left[\frac{b}{2a}\right] x\right) + c\\
&amp;= a \left(x^2 + 2 \left[\frac{b}{2a}\right] x + \left[\frac{b}{2a}\right]^2\right) - a \left[\frac{b}{2a}\right]^2 + c\\
&amp;= a (x - x^*)^2 + \left[c - \frac{b^2}{4a}\right].
\end{align*}\]</div>
<p>Clearly, any other <span class="math notranslate nohighlight">\(x\)</span> gives a higher value for <span class="math notranslate nohighlight">\(q\)</span>. The step on the second line above is called <a class="reference external" href="https://en.wikipedia.org/wiki/Completing_the_square"><em>Completing the Square</em></a>. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p><strong>NUMERICAL CORNER:</strong> Here’s a numerical example. We first define a quadratic function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span>
</pre></div>
</div>
</div>
</div>
<p>We plot it for different values of the coefficients. Note that the <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> axes are on different scales.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">'$y_1$'</span><span class="p">,</span> <span class="s1">'$y_2$'</span><span class="p">,</span> <span class="s1">'$y_3$'</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/61bc7fdbb91557152ddeef0b81d381a6bfd002c537f7992efa581d8504d503a5.png" src="../Images/eae4bc2fb4c7aab683b47a1a195867e9.png" data-original-src="https://mmids-textbook.github.io/_images/61bc7fdbb91557152ddeef0b81d381a6bfd002c537f7992efa581d8504d503a5.png"/>
</div>
</div>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
<p><em>Optimizing an additively separable function:</em> Functions that can be written as the sum of disjoint sets of coordinates arise commonly in optimization and have convenient “separability” properties.</p>
<p>For vectors <span class="math notranslate nohighlight">\(\mathbf{x}_i \in \mathbb{R}^{d_i}\)</span>, <span class="math notranslate nohighlight">\(i \in [\ell]\)</span>, with <span class="math notranslate nohighlight">\(\sum_{i=1}^\ell d_i = d\)</span>, their concatenation is denoted as <span class="math notranslate nohighlight">\((\mathbf{x}_1, \ldots, \mathbf{x}_\ell) \in \mathbb{R}^d\)</span>. That is the vector obtained by concatenating the coordinates of <span class="math notranslate nohighlight">\(\mathbf{x}_1, \ldots, \mathbf{x}_\ell\)</span> into a single vector. A different way to see this is that <span class="math notranslate nohighlight">\((\mathbf{x}_1, \ldots, \mathbf{x}_\ell)\)</span> is a block vector with blocks <span class="math notranslate nohighlight">\(\mathbf{x}_1, \ldots, \mathbf{x}_\ell\)</span>. For example, if <span class="math notranslate nohighlight">\(\mathbf{x}_1 = (1, 2)\)</span> and <span class="math notranslate nohighlight">\(\mathbf{x}_2 = (-1, -3, -5)\)</span>, then <span class="math notranslate nohighlight">\((\mathbf{x}_1,\mathbf{x}_2) = (1, 2, -1, -3, -5)\)</span>.</p>
<p><strong>LEMMA</strong> <strong>(Optimizing a Separable Function)</strong> <span class="math notranslate nohighlight">\(\idx{optimizing a separable function lemma}\xdi\)</span> Assume that <span class="math notranslate nohighlight">\(\mathbf{z} \in \mathbb{R}^d\)</span> can be broken up into subvectors <span class="math notranslate nohighlight">\(\mathbf{x}_i \in \mathbb{R}^{d_i}\)</span>, <span class="math notranslate nohighlight">\(i \in [\ell]\)</span>, with <span class="math notranslate nohighlight">\(\sum_{i=1}^\ell d_i = d\)</span> as follows <span class="math notranslate nohighlight">\(\mathbf{z}
= (\mathbf{x}_1, \ldots, \mathbf{x}_\ell)\)</span>. Suppose that the real-valued function <span class="math notranslate nohighlight">\(h : \mathbb{R}^d \to \mathbb{R}\)</span> can be written in the additively separable form</p>
<div class="math notranslate nohighlight">
\[
h(\mathbf{z})
= f_1(\mathbf{x}_1) + \cdots + f_\ell(\mathbf{x}_\ell),
\]</div>
<p>for a collection of functions <span class="math notranslate nohighlight">\(f_i : \mathbb{R}^{d_i} \to \mathbb{R}\)</span>, <span class="math notranslate nohighlight">\(i \in [\ell]\)</span>. If, for each <span class="math notranslate nohighlight">\(i \in [\ell]\)</span>, <span class="math notranslate nohighlight">\(\mathbf{x}_i^*\)</span> is a global minimum of <span class="math notranslate nohighlight">\(f_i\)</span>, then
<span class="math notranslate nohighlight">\(\mathbf{z}^* = (\mathbf{x}_1^*, \ldots, \mathbf{x}_\ell^*)\)</span> is a global minimum of <span class="math notranslate nohighlight">\(h\)</span>. <span class="math notranslate nohighlight">\(\flat\)</span></p>
<p><em>Proof idea:</em> Each term in the sum defining <span class="math notranslate nohighlight">\(h\)</span> depends on a separate set of coordinates and therefore is unaffected by the choices made in other terms.</p>
<p><em>Proof:</em> Let <span class="math notranslate nohighlight">\(\mathbf{z}
= (\mathbf{x}_1, \ldots, \mathbf{x}_\ell)\)</span>.
Since <span class="math notranslate nohighlight">\(\mathbf{x}_i^*\)</span> is a global minimum of <span class="math notranslate nohighlight">\(f_i\)</span>, it holds that <span class="math notranslate nohighlight">\(f_i(\mathbf{x}_i^*) \leq f_i(\mathbf{x}_i)\)</span>, for all <span class="math notranslate nohighlight">\(i\)</span>. Hence,</p>
<div class="math notranslate nohighlight">
\[
h(\mathbf{z}^*)
= f_1(\mathbf{x}_1^*) + \cdots + f_\ell(\mathbf{x}_\ell^*)
\leq
f_1(\mathbf{x}_1) + \cdots + f_\ell(\mathbf{x}_\ell) = h(\mathbf{z}).
\]</div>
<p>Since <span class="math notranslate nohighlight">\(\mathbf{z}\)</span> is arbitrary, we have proved the claim. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p><em>Composing with a non-decreasing function:</em> Recall that a real-valued function <span class="math notranslate nohighlight">\(f\)</span> of a single variable is non-decreasing if</p>
<div class="math notranslate nohighlight">
\[
x \leq y \implies f(x) \leq f(y).
\]</div>
<p><strong>LEMMA</strong> <strong>(Composing with a Non-Decreasing Function)</strong> <span class="math notranslate nohighlight">\(\idx{composing with a non-decreasing function lemma}\xdi\)</span> Let <span class="math notranslate nohighlight">\(f : \mathbb{R} \to \mathbb{R}\)</span> be non-decreasing, let <span class="math notranslate nohighlight">\(g : \mathbb{R}^d \to \mathbb{R}\)</span>, and define <span class="math notranslate nohighlight">\(h(\mathbf{x}) = f(g(\mathbf{x}))\)</span>. If <span class="math notranslate nohighlight">\(\mathbf{x}^*\)</span> is a global minimum of <span class="math notranslate nohighlight">\(g\)</span>, then it is also a global minimum of <span class="math notranslate nohighlight">\(h\)</span>. <span class="math notranslate nohighlight">\(\flat\)</span></p>
<p><em>Proof idea:</em> This just follows from applying the definitions.</p>
<p><em>Proof:</em> Let <span class="math notranslate nohighlight">\(\mathbf{x} \in \mathbb{R}^d\)</span>. Because <span class="math notranslate nohighlight">\(\mathbf{x}^*\)</span> is a global minimum of <span class="math notranslate nohighlight">\(g\)</span>, <span class="math notranslate nohighlight">\(g(\mathbf{x}^*)
\leq g(\mathbf{x})\)</span>. Further, since <span class="math notranslate nohighlight">\(f\)</span> is non-decreasing,</p>
<div class="math notranslate nohighlight">
\[
h(\mathbf{x}^*)
=
f(g(\mathbf{x}^*))
\leq f(g(\mathbf{x}))
=
h(\mathbf{x}).
\]</div>
<p>Since <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> is arbitrary, we have proved the claim. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p><strong>Sub-problem 1: finding the optimal representatives</strong> We denote by <span class="math notranslate nohighlight">\(|C_i|\)</span> the number of elements in <span class="math notranslate nohighlight">\(C_i\)</span>.</p>
<p><strong>EXAMPLE:</strong> <strong>(continued)</strong> Continuing the example above, the sizes of the clusters are respectively <span class="math notranslate nohighlight">\(|C_1| = 4, |C_2| = 3, |C_3| = 1\)</span>. Note in particulat that <span class="math notranslate nohighlight">\(|C_1| + |C_2| + |C_3| = 8 = n\)</span>, as follows from the fact that <span class="math notranslate nohighlight">\(C_1, C_2, C_3\)</span> is a partition. <span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p><strong>LEMMA</strong> <strong>(Optimal Representatives)</strong> <span class="math notranslate nohighlight">\(\idx{optimal representatives lemma}\xdi\)</span> Fix a partition <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span>. The optimal representatives under the objective</p>
<div class="math notranslate nohighlight">
\[
G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k)
= \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2,
\]</div>
<p>are the <a class="reference external" href="https://en.wikipedia.org/wiki/Centroid">centroids</a><span class="math notranslate nohighlight">\(\idx{centroid}\xdi\)</span></p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{\mu}_i^* = \frac{1}{|C_i|} \sum_{j\in C_i} \mathbf{x}_j.
\]</div>
<p><span class="math notranslate nohighlight">\(\flat\)</span></p>
<p><em>Proof idea:</em> The objective <span class="math notranslate nohighlight">\(G\)</span> can be written as a sum, where each term is a quadratic function in one component of one of the <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_i\)</span>’s. Each of these terms is minimized by the average of the corresponding components of the <span class="math notranslate nohighlight">\(\mathbf{x}_j\)</span>’s belonging <span class="math notranslate nohighlight">\(C_i\)</span>.</p>
<p><strong>EXAMPLE:</strong> <strong>(continued)</strong> Continuing with the previous example, we compute the optimal representatives for the fixed partition <span class="math notranslate nohighlight">\(C_1, C_2, C_3\)</span> above. We get</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\boldsymbol{\mu}_1^*
&amp;= \frac{1}{4}[\mathbf{x}_1 + \mathbf{x}_4 + \mathbf{x}_6 + \mathbf{x}_8]\\
&amp;= \frac{1}{4}\left[\begin{pmatrix}1\\0\end{pmatrix} +
\begin{pmatrix}1\\-3\end{pmatrix} +
\begin{pmatrix}2\\-2\end{pmatrix} +
\begin{pmatrix}3\\-1\end{pmatrix}
\right]
= \begin{pmatrix}7/4\\-3/2\end{pmatrix},\\
\boldsymbol{\mu}_2^*
&amp;= \frac{1}{3}[\mathbf{x}_2 + \mathbf{x}_3 + \mathbf{x}_7]\\
&amp;= \frac{1}{3}\left[\begin{pmatrix}-2\\0\end{pmatrix}+
\begin{pmatrix}-2\\1\end{pmatrix}+
\begin{pmatrix}-3\\1\end{pmatrix}
\right]
= \begin{pmatrix}-7/3\\2/3\end{pmatrix},\\
\boldsymbol{\mu}_3^*
&amp;= \frac{1}{1}[\mathbf{x}_5]
= \begin{pmatrix}-10\\10\end{pmatrix}.
\end{align*}\]</div>
<p><span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p><em>Proof:</em> <em>(Optimal Representatives)</em> Using the notation <span class="math notranslate nohighlight">\(\mathbf{x}_j = (x_{j1},\ldots,x_{jd})\)</span> and similarly for <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_i\)</span>, note that we can expand the <span class="math notranslate nohighlight">\(k\)</span>-means objective as</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2
&amp;= \sum_{i=1}^k \sum_{j \in C_i} \sum_{m=1}^d (x_{jm} - \mu_{im})^2\\
&amp;= \sum_{i=1}^k \sum_{m=1}^d \left[\sum_{j \in C_i} (x_{jm} - \mu_{im})^2\right].
\end{align*}\]</div>
<p>The expression in square brackets is a quadratic function in <span class="math notranslate nohighlight">\(\mu_{im}\)</span></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
q_{im}(\mu_{im})
&amp;= \sum_{j \in C_i} (x_{jm} - \mu_{im})^2\\
&amp;= \left\{\sum_{j \in C_i} x_{jm}^2\right\} + \left\{- 2 \sum_{j \in C_i} x_{jm}\right\} \mu_{im}  + \left\{|C_i| \right\} \mu_{im}^2.
\end{align*}\]</div>
<p>Therefore, by the formula for the <em>Minimum of a Quadratic Function</em>,
is minimized at</p>
<div class="math notranslate nohighlight">
\[
\mu_{im}^* 
= - \frac{- 2 \sum_{j \in C_i} x_{jm}}{2 |C_i|}
= \frac{1}{|C_i|} \sum_{j \in C_i} x_{jm}.
\]</div>
<p>Since each term <span class="math notranslate nohighlight">\(q_{im}(\mu_{im})\)</span> in the sum over <span class="math notranslate nohighlight">\(i, m\)</span> making up the objective function <span class="math notranslate nohighlight">\(G\)</span> is minimized at <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_1^*,\ldots, \boldsymbol{\mu}_k^*\)</span>, so is <span class="math notranslate nohighlight">\(G\)</span> by <em>Optimizing a Separable Function</em>. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p>That the squared norm decomposes into a sum over the coordinates (which the norm itself doesn’t because of the square root) is one reason why it is convenient to use here, as was hopefully apparent in this last proof.</p>
<p><strong>Sub-problem 2: finding the optimal partition</strong> Given <span class="math notranslate nohighlight">\(n\)</span> vectors <span class="math notranslate nohighlight">\(\mathbf{x}_1,\ldots,\mathbf{x}_n\)</span> in <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span> and a partition <span class="math notranslate nohighlight">\(C_1, \ldots, C_k \subseteq [n]\)</span>, it will be useful to have some notation for the corresponding cluster assignment: we define <span class="math notranslate nohighlight">\(c(j) = i\)</span> if <span class="math notranslate nohighlight">\(j \in C_i\)</span>.</p>
<p><strong>EXAMPLE:</strong> <strong>(continued)</strong> Continuing the example above, the clusters <span class="math notranslate nohighlight">\(C_1 = \{1, 4, 6, 8\}, C_2 = \{2, 3, 7\}, C_3 = \{5\}\)</span> correspond to the assignment</p>
<div class="math notranslate nohighlight">
\[
c(1) = 1, c(2) = 2, c(3) = 2, c(4) = 1, c(5) = 3, c(6) = 1, c(7) = (2), c(8) = 1. 
\]</div>
<p><span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p><strong>LEMMA</strong> <strong>(Optimal Clustering)</strong> <span class="math notranslate nohighlight">\(\idx{optimal clustering lemma}\xdi\)</span> Fix the representatives <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k\)</span>. An optimal partition under  the objective</p>
<div class="math notranslate nohighlight">
\[
G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k)
= \sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2,
\]</div>
<p>is obtained as follows. For each <span class="math notranslate nohighlight">\(j\)</span>, find the <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_i\)</span> that minimizes <span class="math notranslate nohighlight">\(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|\)</span> (picking one arbitrarily in the case of ties) and assign <span class="math notranslate nohighlight">\(\mathbf{x}_j\)</span> to <span class="math notranslate nohighlight">\(C_i\)</span> (i.e., add <span class="math notranslate nohighlight">\(j\)</span> to <span class="math notranslate nohighlight">\(C_i\)</span>). <span class="math notranslate nohighlight">\(\flat\)</span></p>
<p><em>Proof:</em> If <span class="math notranslate nohighlight">\(c\)</span> is the cluster assignment associated to <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span>, then we can re-write the objective as</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=1}^k \sum_{j \in C_i} \|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2
= \sum_{j=1}^n \|\mathbf{x}_j - \boldsymbol{\mu}_{c(j)}\|^2,
\]</div>
<p>By definition, when the <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_i\)</span>’s are fixed, each term in the sum on the right-hand side is minimized separately by the assignment in the statement. Hence so is the sum itself by the <em>Optimizing a Separable Function Lemma</em>. Note that we used the fact that the square root (and the square) is non-decreasing to conclude that minimizing <span class="math notranslate nohighlight">\(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|^2\)</span> or its square root <span class="math notranslate nohighlight">\(\|\mathbf{x}_j - \boldsymbol{\mu}_i\|\)</span> are equivalent by the <em>Composing with a Non-Decreasing Function Lemma</em>. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p><strong>EXAMPLE:</strong> <strong>(continued)</strong> Continuing the example above, suppose that we choose representatives</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\boldsymbol{\mu}_1 = \begin{pmatrix}-2\\1\end{pmatrix},
\boldsymbol{\mu}_2 = \begin{pmatrix}2\\-1\end{pmatrix},
\boldsymbol{\mu}_3 = \begin{pmatrix}-10\\10\end{pmatrix}.
\end{split}\]</div>
<p>Then we find the cluster assignment of <span class="math notranslate nohighlight">\(\mathbf{x}_1\)</span> by computing its squared distance to each representative:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\|\mathbf{x}_1 - \boldsymbol{\mu}_1\|
= \left\|\begin{pmatrix}1\\0\end{pmatrix} - \begin{pmatrix}-2\\1\end{pmatrix}\right\|
= \sqrt{(1-(-2))^2 + (0-1)^2}
= \sqrt{10},
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\|\mathbf{x}_1 - \boldsymbol{\mu}_2\|
= \left\|\begin{pmatrix}1\\0\end{pmatrix} - \begin{pmatrix}2\\-1\end{pmatrix}\right\|
= \sqrt{(1-2)^2 + (0-(-1))^2}
= \sqrt{2},
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\|\mathbf{x}_1 - \boldsymbol{\mu}_3\|
= \left\|\begin{pmatrix}1\\0\end{pmatrix} - \begin{pmatrix}-10\\10\end{pmatrix}\right\|
= \sqrt{(1-(-10))^2 + (0-10)^2}
= \sqrt{221}.
\end{split}\]</div>
<p>The minimum is achieved for <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_2\)</span> so we assign <span class="math notranslate nohighlight">\(\mathbf{x}_1\)</span> to <span class="math notranslate nohighlight">\(C_2\)</span>, i.e., <span class="math notranslate nohighlight">\(1 \in C_2\)</span> and <span class="math notranslate nohighlight">\(c(1) = 2\)</span>. <span class="math notranslate nohighlight">\(\lhd\)</span></p>
&#13;

<h2><span class="section-number">1.3.2. </span>Lloyd’s algorithm and its analysis<a class="headerlink" href="#lloyds-algorithm-and-its-analysis" title="Link to this heading">#</a></h2>
<p>We are now ready to describe Lloyd’s algorithm<span class="math notranslate nohighlight">\(\idx{Lloyd's algorithm}\xdi\)</span>. We start from a random assignment of clusters. (An alternative <a class="reference external" href="https://en.wikipedia.org/wiki/K-means_clustering#Initialization_methods">initialization strategy</a> is to choose <span class="math notranslate nohighlight">\(k\)</span> representatives at random among the data points.) We then alternate between the optimal choices in the lemmas. In lieu of pseudo-code, we write out the algorithm in Python. We will use this approach throughout the book.</p>
<p>The input <code class="docutils literal notranslate"><span class="pre">X</span></code> is assumed to be a collection of <span class="math notranslate nohighlight">\(n\)</span> vectors <span class="math notranslate nohighlight">\(\mathbf{x}_1, \ldots, \mathbf{x}_n \in \mathbb{R}^d\)</span> stacked into a matrix, with one row for each data point. The other input, <code class="docutils literal notranslate"><span class="pre">k</span></code>, is the desired number of clusters. There is an optional input <code class="docutils literal notranslate"><span class="pre">maxiter</span></code> for the maximum number of iterations, which is set to <span class="math notranslate nohighlight">\(5\)</span> by default.</p>
<p>We first define separate functions for the two main steps. To find the minimum of an array, we use the function <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.argmin.html"><code class="docutils literal notranslate"><span class="pre">numpy.argmin</span></code></a>. We also use <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.html"><code class="docutils literal notranslate"><span class="pre">numpy.linalg.norm</span></code></a> to compute the Euclidean distance.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">opt_reps</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">assign</span><span class="p">):</span>
    <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">reps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="n">in_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">assign</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>             
        <span class="n">reps</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">in_i</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">reps</span>

<span class="k">def</span> <span class="nf">opt_clust</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">reps</span><span class="p">):</span>
    <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">assign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">dist_to_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">reps</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)])</span>
        <span class="n">assign</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_to_i</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_to_i</span><span class="p">[</span><span class="n">assign</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">assign</span>
</pre></div>
</div>
</div>
</div>
<p>The main function follows. Below, <code class="docutils literal notranslate"><span class="pre">rng.integers(0,k,n)</span></code> is an array of <code class="docutils literal notranslate"><span class="pre">n</span></code> uniformly chosen integers between <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">k-1</span></code> (inclusive). See <a class="reference external" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.integers.html">random.Generator.integers</a> for details. Recall that throughout, when defining a function that uses a random number generator (RNG), we initialize the RNG outside the function and pass the RNG to it. It allows us to maintain control over the random number generation process at a higher level and ensures consistent results across multiple runs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">kmeans</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">assign</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="n">reps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxiter</span><span class="p">):</span>
        <span class="n">reps</span> <span class="o">=</span> <span class="n">opt_reps</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> 
        <span class="n">assign</span> <span class="o">=</span> <span class="n">opt_clust</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">assign</span>
</pre></div>
</div>
</div>
</div>
<p><strong>NUMERICAL CORNER:</strong> We apply our implementation of <span class="math notranslate nohighlight">\(k\)</span>-means to the example above. We fix <code class="docutils literal notranslate"><span class="pre">k</span></code> to <span class="math notranslate nohighlight">\(3\)</span>. Here the data matrix <code class="docutils literal notranslate"><span class="pre">X</span></code> is the following:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">seed</span> <span class="o">=</span> <span class="mi">535</span>
<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">3.</span><span class="p">],</span>
              <span class="p">[</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span><span class="mf">10.</span><span class="p">],[</span><span class="mf">2.</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">],[</span><span class="o">-</span><span class="mf">3.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">]])</span>
<span class="n">assign</span> <span class="o">=</span> <span class="n">kmeans</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>162.7
74.8611111111111
9.083333333333334
9.083333333333334
9.083333333333334
</pre></div>
</div>
</div>
</div>
<p>We vizualize the output by coloring the points according to their cluster assignment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">assign</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'brg'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">11</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/cde50ddf06949815c7068a094c7184fa364e644fe65b83769400c3925c47ee23.png" src="../Images/27a0e5cd18c1654cf2e8093cd3d127f6.png" data-original-src="https://mmids-textbook.github.io/_images/cde50ddf06949815c7068a094c7184fa364e644fe65b83769400c3925c47ee23.png"/>
</div>
</div>
<p>We can compute the final representatives (optimal for the final assignment) by using the subroutine <code class="docutils literal notranslate"><span class="pre">opt_reps</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="nb">print</span><span class="p">(</span><span class="n">opt_reps</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">assign</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>[[ -2.33333333   0.66666667]
 [  1.75        -1.5       ]
 [-10.          10.        ]]
</pre></div>
</div>
</div>
</div>
<p>Each row is the center of the corresponding cluster. Note these match with the ones we previously computed. Indeed, the clustering is the same (although not necessarily in the same order).</p>
<p><strong>TRY IT!</strong> Modify <code class="docutils literal notranslate"><span class="pre">kmeans</span></code> to take a tolerance <code class="docutils literal notranslate"><span class="pre">tol</span></code> as input and stop when the improvement in objective value <code class="docutils literal notranslate"><span class="pre">G</span></code> falls below the tolerance. (<a class="reference external" href="https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_intro_notebook.ipynb">Open in Colab</a>)</p>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
<p><img alt="Evolution of the assignment for -means clustering on data generated by a mixture of spherical Gaussians with variance  and respective means  and . The crosses show the cluster representatives. The objective value is shown as . (With help from Claude; inspired by (Source).)" src="../Images/2c9ccfca527fcd49962e30d8a67f4fdb.png" data-original-src="https://mmids-textbook.github.io/_images/kmeans-iterations.png"/></p>
<p><strong>KNOWLEDGE CHECK:</strong> Suppose we have infinite computational resources and run Lloyd’s algorithm forever, do you think it will necessarily converge to a global minimum? If your answer is no, can you think of an alternative algorithm that is guaranteed to output a global minimum provided enough computational resources? <span class="math notranslate nohighlight">\(\checkmark\)</span></p>
<p>Lloyd’s algorithm is only a heuristic. In particular, it is not guaranteed to find the global minimum of the <span class="math notranslate nohighlight">\(k\)</span>-means objective. However, it is guaranteed to improve the objective at every iteration, or more precisely, not to make it worse.</p>
<p><strong>THEOREM</strong> <strong>(Convergence of <span class="math notranslate nohighlight">\(k\)</span>-means cost)</strong> <span class="math notranslate nohighlight">\(\idx{convergence of k-means cost theorem}\xdi\)</span> The sequence of objective function values produced by the <span class="math notranslate nohighlight">\(k\)</span>-means algorithm is non-increasing. <span class="math notranslate nohighlight">\(\sharp\)</span></p>
<p><em>Proof idea:</em> By the <em>Optimal Representatives Lemma</em> and the <em>Optimal Clustering Lemma</em>, each step does not increase the objective.</p>
<p><em>Proof:</em> Let <span class="math notranslate nohighlight">\(C_1',\ldots,C_k'\)</span> be the current clusters, with representatives <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_1',\ldots,\boldsymbol{\mu}_k'\)</span>. After Step 1, the new representatives are <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_1'',\ldots,\boldsymbol{\mu}_k''\)</span>. By the <em>Optimal Representatives Lemma</em>, they satisfy</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
\leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i'\|^2.
\]</div>
<p>After Step 2, the new clusters are <span class="math notranslate nohighlight">\(C_1'',\ldots,C_k''\)</span>. By the <em>Optimal Clustering Lemma</em>, they satisfy</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=1}^k \sum_{j \in C_i''} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
\leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2.
\]</div>
<p>Combining these two inequalities gives</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=1}^k \sum_{j \in C_i''} \|\mathbf{x}_j - \boldsymbol{\mu}_i''\|^2
\leq \sum_{i=1}^k \sum_{j \in C_i'} \|\mathbf{x}_j - \boldsymbol{\mu}_i'\|^2,
\]</div>
<p>as claimed. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p>The sequence of objective values is monotone and bounded from below by <span class="math notranslate nohighlight">\(0\)</span>. <a class="reference external" href="https://en.wikipedia.org/wiki/Monotone_convergence_theorem#Convergence_of_a_monotone_sequence_of_real_numbers">Hence it converges</a>. Note that the limit depends on the starting point.</p>
<p><strong>CHAT &amp; LEARN</strong> AI chatbots can serve as great personal tutors, especially when it comes to coding which they often excel at. In particular, they can provide additional information about the code in this book. Just copy-paste a piece of code and ask “What is this code doing?” Don’t hesitate to ask follow-up questions. <a class="reference external" href="https://chat.openai.com/share/66f9e704-c8e8-4489-9ab6-8e57740cab3b">Here is an example using ChatGPT</a>.</p>
<p><em>Warning:</em> As you probably know, AI chatbots can be wrong so assess what they tell you with a critical mind and/or double-check with other sources (e.g., package documentation).</p>
<p><em>Prompt engineering:</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Prompt_engineering">Finding the right prompt</a>, or series of prompts, can make a big difference. It can also be used to produce more interesting answers. Here is an explanation of the <span class="math notranslate nohighlight">\(k\)</span>-means algorithm in the style of Shakespeare via ChatGPT:</p>
<blockquote>
<div><p><strong>Scene: The Realm of Numerica, in the Enchanted Forest of Analysis</strong></p>
<p><em>Enter LORD VECTOR, LADY PARTITION, and an assembly of WHISPERING WINDS</em></p>
<p>LORD VECTOR (a majestic entity):</p>
<p>Hearken, Whispering Winds, scattered far and wide,</p>
<p>I am Lord Vector, your anchor and your guide.</p>
<p>In clusters, you must settle, by my call and by my side,</p>
<p>To me, you’ll draw nigh, in unity, abide.</p>
<p>LADY PARTITION (a sage enchantress):</p>
<p>And I, Lady Partition, with vision clear and keen,</p>
<p>Determine where amongst the clusters each of you shall lean.</p>
<p>With Lord Vector, a ballet we compose, with steps so fine,</p>
<p>To sort, to gather, to align, under a sign divine.</p>
<p>WHISPERING WIND 1:</p>
<p>But how, noble Vector, wilt thou find thy rightful stead?</p>
<p>In this expanse diverse, how set thy bed?</p>
<p>LORD VECTOR:</p>
<p>Through cycles and through wisdom, I seek my sacred ground,</p>
<p>Where the sum of all distances to me is least found.</p>
<p>From your essence, I emerge, an average pure and sound,</p>
<p>A beacon most true, by which I am crowned.</p>
<p>WHISPERING WIND 2:</p>
<p>And Lady Partition, how do we seek our kin,</p>
<p>In this multitude, how does our journey begin?</p>
<p>LADY PARTITION:</p>
<p>By measure and affinity, to your closest Lord Vector, you’ll gravitate,</p>
<p>To him, your allegiance, you’ll consecrate.</p>
<p>In groups, you’ll assemble, by likeness you’re drawn,</p>
<p>A collective symphony, from dusk till dawn.</p>
<p><em>LORD VECTOR and LADY PARTITION assume their roles, guiding the WHISPERING WINDS to move and regroup.</em></p>
<p>LORD VECTOR:</p>
<p>Observe now how I traverse, as your allegiances refine,</p>
<p>A center more apt, in this spell of mine.</p>
<p>LADY PARTITION:</p>
<p>And as you drift, dear winds, to your Lords true,</p>
<p>A closer union we construe, a balance anew.</p>
<p><em>The WHISPERING WINDS shuffle and align, moving from one cluster to another, as LORD VECTOR adjusts his position with grace.</em></p>
<p>WHISPERING WIND 3:</p>
<p>At length, I perceive, where I am to dwell,</p>
<p>With peers akin, in cluster well.</p>
<p>LORD VECTOR:</p>
<p>So we dance and weave, ‘til stillness we achieve,</p>
<p>When each wind has settled, and we, in relief.</p>
<p>LADY PARTITION:</p>
<p>Thus, optimal clusters come forth, vivid and serene,</p>
<p>With centers well placed, a sight unseen.</p>
<p><em>The WHISPERING WINDS now rest peacefully in clusters around their LORD VECTORS, the Enchanted Forest of Analysis a testament to their orderly ballet.</em></p>
<p>LORD VECTOR &amp; LADY PARTITION (together):</p>
<p>Our task here concludes, with harmony and grace,</p>
<p>The K-means enchantment, a solution embraced.</p>
<p><em>Exeunt omnes, as the WHISPERING WINDS repose in unity around their LORD VECTORS, the realm of Numerica reflecting their harmonious dance.</em></p>
<p><strong>End of Scene</strong></p>
</div></blockquote>
<p><span class="math notranslate nohighlight">\(\ddagger\)</span></p>
<p><strong>NUMERICAL CORNER:</strong> We will test our implementation of <span class="math notranslate nohighlight">\(k\)</span>-means on the penguins dataset introduced earlier in the chapter. We first extract the columns and combine them into a data matrix <code class="docutils literal notranslate"><span class="pre">X</span></code>. As we did previously, we also remove the rows with missing values.</p>
<p><strong>Figure:</strong> Which penguin species? (<em>Credit:</em> Made with <a class="reference external" href="https://www.midjourney.com/">Midjourney</a>)</p>
<p><img alt="Penguins on a glacier" src="../Images/bb7e8602c95a01b1185de572b4c55ec8.png" data-original-src="https://mmids-textbook.github.io/_images/three_penguins_on_a_glacier-small.png"/></p>
<p><span class="math notranslate nohighlight">\(\bowtie\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'penguins-measurements.csv'</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">'bill_length_mm'</span><span class="p">,</span> <span class="s1">'bill_depth_mm'</span><span class="p">,</span> 
        <span class="s1">'flipper_length_mm'</span><span class="p">,</span> <span class="s1">'body_mass_g'</span><span class="p">]]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We  visualize a two-dimensional slice of the data.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">'k'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'bill_depth_mm'</span><span class="p">),</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'body_mass_g'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/024d26811e4631ac8dcb5acb1d23f5c577193d3217b2493260af97e706f2b329.png" src="../Images/e75683392ec1e758370886f76273bfb6.png" data-original-src="https://mmids-textbook.github.io/_images/024d26811e4631ac8dcb5acb1d23f5c577193d3217b2493260af97e706f2b329.png"/>
</div>
</div>
<p>Observe that the features have quite different scales (tens versus thousands in the plot above). In such a case, it is common to standardize the data so that each feature has roughly the same scale. For each column of <code class="docutils literal notranslate"><span class="pre">X</span></code>, we subtract its empirical mean and divide by its empirical standard deviation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">std</span>
</pre></div>
</div>
</div>
</div>
<p>Now we run Lloyd’s algorithm with <span class="math notranslate nohighlight">\(k=2\)</span> clusters.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">assign</span> <span class="o">=</span> <span class="n">kmeans</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>1338.2046936914157
820.9361062178352
603.8787658966849
575.2587351391593
567.7837494880662
</pre></div>
</div>
</div>
</div>
<p>We vizualize the output as we did before, but this time coloring the data points by their cluster assignment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">assign</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'brg'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'bill_depth (standardized)'</span><span class="p">),</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'body_mass (standardized)'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/c8ce542a010e33ab2c018c7c7624c391c5b57fa97d97a1146013f2c8d77068de.png" src="../Images/828f36ddad8cd4ead1a7000754909d59.png" data-original-src="https://mmids-textbook.github.io/_images/c8ce542a010e33ab2c018c7c7624c391c5b57fa97d97a1146013f2c8d77068de.png"/>
</div>
</div>
<p>This clustering looks quite good. Nevertheless recall that:</p>
<ol class="arabic simple">
<li><p>in this plot we are looking at only two of the four variables while <span class="math notranslate nohighlight">\(k\)</span>-means uses all of them,</p></li>
<li><p>we are not guaranteed to find the best solution,</p></li>
<li><p>our objective function is somewhat arbitrary, and</p></li>
<li><p>it is not clear what the right choice of <span class="math notranslate nohighlight">\(k\)</span> is.</p></li>
</ol>
<p>In fact, the original dataset contained the correct answer, as provided by biologists. Despite what the figure above may lead us to believe, there are in reality three separate species. So let us try with <span class="math notranslate nohighlight">\(k=3\)</span> clusters.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">assign</span> <span class="o">=</span> <span class="n">kmeans</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>1312.344945158482
577.1700837839458
428.50397345437966
392.2616692426171
383.3452894259011
</pre></div>
</div>
</div>
</div>
<p>The output does not seem quite right.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">assign</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'brg'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'bill_depth (standardized)'</span><span class="p">),</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'body_mass (standardized)'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/7383cabd085a8a7eba9545c89a27d27d31401b0dc50cd001fbe5cfc405e9131c.png" src="../Images/0cf53aabbe4e2f47806ce1ae1b6cde65.png" data-original-src="https://mmids-textbook.github.io/_images/7383cabd085a8a7eba9545c89a27d27d31401b0dc50cd001fbe5cfc405e9131c.png"/>
</div>
</div>
<p>But, remembering the warnings mentioned previously, let us look at a different two-dimensional slice.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">assign</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'brg'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'bill_length (standardized)'</span><span class="p">),</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'body_mass (standardized)'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/62dde40d80824421548718832e220f969d2f9a28a560918552424440517b225e.png" src="../Images/9702034e7031f67493cefa19852b584d.png" data-original-src="https://mmids-textbook.github.io/_images/62dde40d80824421548718832e220f969d2f9a28a560918552424440517b225e.png"/>
</div>
</div>
<p>Let us load up the truth and compare. We only keep those samples that were not removed because of missing values (see <a class="reference external" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html"><code class="docutils literal notranslate"><span class="pre">pandas.DataFrame.iloc</span></code></a>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">data_truth</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'penguins-species.csv'</span><span class="p">)</span> 
<span class="n">data_truth</span> <span class="o">=</span> <span class="n">data_truth</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
<span class="n">data_truth</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th/>
      <th>species</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Adelie</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Adelie</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Adelie</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Adelie</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Adelie</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>The species are:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">species</span> <span class="o">=</span> <span class="n">data_truth</span><span class="p">[</span><span class="s1">'species'</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">species</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span/>['Adelie' 'Chinstrap' 'Gentoo']
</pre></div>
</div>
</div>
</div>
<p>To plot the outcome, we color the species blue-green-red using a <a class="reference external" href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries">dictionary</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">species2color_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'Adelie'</span><span class="p">:</span> <span class="s1">'blue'</span><span class="p">,</span> <span class="s1">'Chinstrap'</span><span class="p">:</span> <span class="s1">'lime'</span><span class="p">,</span> <span class="s1">'Gentoo'</span><span class="p">:</span> <span class="s1">'red'</span><span class="p">}</span>
<span class="n">truth</span> <span class="o">=</span> <span class="p">[</span><span class="n">species2color_dict</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">species</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we can compare the output to the truth. The match is quite good – but certainly not perfect.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span/><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">6.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">truth</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'truth'</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">assign</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'brg'</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'kmeans'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/00f2abf0740c5bf6a562d8f607ab3a6d116d7ba0e1b03f9e035f875e36954e86.png" src="../Images/1de9d394fa9649dc467bc539e8b0de94.png" data-original-src="https://mmids-textbook.github.io/_images/00f2abf0740c5bf6a562d8f607ab3a6d116d7ba0e1b03f9e035f875e36954e86.png"/>
</div>
</div>
<p>Determining the appropriate number of clusters is not a straighforward problem. To quote <a class="reference external" href="https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set">Wikipedia</a>:</p>
<blockquote>
<div><p>The correct choice of <span class="math notranslate nohighlight">\(k\)</span> is often ambiguous, with interpretations depending on the shape and scale of the distribution of points in a data set and the desired clustering resolution of the user. In addition, increasing <span class="math notranslate nohighlight">\(k\)</span> without penalty will always reduce the amount of error in the resulting clustering, to the extreme case of zero error if each data point is considered its own cluster (i.e., when <span class="math notranslate nohighlight">\(k\)</span> equals the number of data points, <span class="math notranslate nohighlight">\(n\)</span>). Intuitively then, the optimal choice of <span class="math notranslate nohighlight">\(k\)</span> will strike a balance between maximum compression of the data using a single cluster, and maximum accuracy by assigning each data point to its own cluster. If an appropriate value of <span class="math notranslate nohighlight">\(k\)</span> is not apparent from prior knowledge of the properties of the data set, it must be chosen somehow. There are several categories of methods for making this decision.</p>
</div></blockquote>
<p>In practice, <a class="reference external" href="https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set">several heuristics</a> are in use. Other approaches to clustering, e.g. <a class="reference external" href="https://en.wikipedia.org/wiki/DBSCAN">DBSCAN</a> and <a class="reference external" href="https://en.wikipedia.org/wiki/Hierarchical_clustering">hierarchical clustering</a>, do not require a number of clusters as input.</p>
<p><strong>TRY IT!</strong> Run the analysis again, but this time <em>without the standardization step</em>. What do you observe? Is one feature more influential on the final output than the others? Why do you think that is? (<a class="reference external" href="https://colab.research.google.com/github/MMiDS-textbook/MMiDS-textbook.github.io/blob/main/just_the_code/roch_mmids_chap_intro_notebook.ipynb">Open in Colab</a>)</p>
<p><span class="math notranslate nohighlight">\(\unlhd\)</span></p>
&#13;

<h2><span class="section-number">1.3.3. </span>Matrix form of k-means clustering<a class="headerlink" href="#matrix-form-of-k-means-clustering" title="Link to this heading">#</a></h2>
<p>In this section, we show that the <span class="math notranslate nohighlight">\(k\)</span>-means clustering objective can be written in matrix form. We start with some notation and definitions that will be useful throughout.</p>
<p>As we indicated before, for a collection of <span class="math notranslate nohighlight">\(n\)</span> data vectors <span class="math notranslate nohighlight">\(\mathbf{x}_1, \ldots, \mathbf{x}_n\)</span> in <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span>, it is often convenient to stack them up into a matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}
X =
\begin{bmatrix}
\mathbf{x}_1^T \\
\mathbf{x}_2^T \\
\vdots \\
\mathbf{x}_n^T \\
\end{bmatrix}
=
\begin{bmatrix}
x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d} \\
x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2d} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{n1} &amp; x_{n2} &amp; \cdots &amp; x_{nd} \\
\end{bmatrix}.
\end{split}\]</div>
<p>We can do the same with cluster representatives. Given <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_1,\ldots,\boldsymbol{\mu}_k\)</span> also in <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span>, we form the matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}
U =
\begin{bmatrix}
\boldsymbol{\mu}_1^T \\
\boldsymbol{\mu}_2^T \\
\vdots \\
\boldsymbol{\mu}_k^T \\
\end{bmatrix}
=
\begin{bmatrix}
\mu_{11} &amp; \mu_{12} &amp; \cdots &amp; \mu_{1d} \\
\mu_{21} &amp; \mu_{22} &amp; \cdots &amp; \mu_{2d} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\mu_{k1} &amp; \mu_{k2} &amp; \cdots &amp; \mu_{kd} \\
\end{bmatrix}.
\end{split}\]</div>
<p>Perhaps less obviously, cluster assignments can also be encoded in matrix form. Recall that, given a partition <span class="math notranslate nohighlight">\(C_1,\ldots,C_k\)</span> of <span class="math notranslate nohighlight">\([n]\)</span>, we define <span class="math notranslate nohighlight">\(c(j) = i\)</span> if <span class="math notranslate nohighlight">\(j \in C_i\)</span>. For <span class="math notranslate nohighlight">\(j=1,\ldots,n\)</span> and <span class="math notranslate nohighlight">\(\ell=1,\ldots,k\)</span>, set <span class="math notranslate nohighlight">\(Z_{j\ell} = 1\)</span> if <span class="math notranslate nohighlight">\(c(j) = \ell\)</span> and <span class="math notranslate nohighlight">\(0\)</span> otherwise, and let <span class="math notranslate nohighlight">\(Z\)</span> be the <span class="math notranslate nohighlight">\(n \times k\)</span> matrix with entries <span class="math notranslate nohighlight">\(Z = [Z_{j\ell}]_{j,\ell}\)</span>. That is, row <span class="math notranslate nohighlight">\(j\)</span> has exactly one entry with value <span class="math notranslate nohighlight">\(1\)</span>, corresponding to the assigned cluster <span class="math notranslate nohighlight">\(c(j)\)</span> of data point <span class="math notranslate nohighlight">\(\mathbf{x}_j\)</span>, and all other entries <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>With this notation, the representative of the cluster assigned to data point <span class="math notranslate nohighlight">\(\mathbf{x}_j\)</span> is obtained through a matrix product</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{\mu}_{c(j)}^T 
= \sum_{\ell = 1}^k Z_{j\ell} \boldsymbol{\mu}_{\ell}^T
= \sum_{\ell = 1}^k Z_{j\ell} U_{\ell,\cdot}
= \left(Z U\right)_{j,\cdot}
\]</div>
<p>where we used that the <span class="math notranslate nohighlight">\(j\)</span>-th row of a matrix product is a linear combination of the rows of the second matrix, where the coefficients are the entries on the <span class="math notranslate nohighlight">\(j\)</span>-th row of the first one.</p>
<p><strong>EXAMPLE:</strong> <strong>(continued)</strong> Continuing with our previous example, the clusters <span class="math notranslate nohighlight">\(C_1 = \{1, 4, 6, 8\}, C_2 = \{2, 3, 7\}, C_3 = \{5\}\)</span> are encoded as the matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}
Z 
= \begin{bmatrix}
1 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0\\
0 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0
\end{bmatrix}.
\end{split}\]</div>
<p>Suppose again that the representatives are</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\boldsymbol{\mu}_1 = \begin{pmatrix}-2\\1\end{pmatrix},
\boldsymbol{\mu}_2 = \begin{pmatrix}2\\-1\end{pmatrix},
\boldsymbol{\mu}_3 = \begin{pmatrix}-10\\10\end{pmatrix}.
\end{split}\]</div>
<p>The corresponding matrix <span class="math notranslate nohighlight">\(U\)</span> is then</p>
<div class="math notranslate nohighlight">
\[\begin{split}
U 
= 
\begin{bmatrix}
-2 &amp; 1\\
2 &amp; -1\\
-10 &amp; 10
\end{bmatrix}.
\end{split}\]</div>
<p>Hence multiplying <span class="math notranslate nohighlight">\(Z\)</span> and <span class="math notranslate nohighlight">\(U\)</span> produces a matrix where each row is the representative of the assigned cluster of the corresponding data point</p>
<div class="math notranslate nohighlight">
\[\begin{split}
ZU 
= 
\begin{bmatrix}
1 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0\\
0 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0
\end{bmatrix}
\,
\begin{bmatrix}
-2 &amp; 1\\
2 &amp; -1\\
-10 &amp; 10
\end{bmatrix}
= 
\begin{bmatrix}
-2 &amp; 1\\
2 &amp; -1\\
2 &amp; -1\\
-2 &amp; 1\\
-10 &amp; 10\\
-2 &amp; 1\\
2 &amp; -1\\
-2 &amp; 1
\end{bmatrix}.
\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(\lhd\)</span></p>
<p>Recall that the Frobenius norm of an <span class="math notranslate nohighlight">\(n \times m\)</span> matrix <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{n \times m}\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[
\|A\|_F
= \sqrt{\sum_{i=1}^n \sum_{j=1}^m A_{ij}^2}.
\]</div>
<p>Using row notation, it can be written as the sum of the squared Euclidean norms of the rows</p>
<div class="math notranslate nohighlight">
\[
\|A\|_F^2 = \sum_{i=1}^n \|A_{i,\cdot}\|^2.
\]</div>
<p>For two matrices <span class="math notranslate nohighlight">\(A, B \in \mathbb{R}^{n \times m}\)</span>, the Frobenius norm of their difference <span class="math notranslate nohighlight">\(\|A - B\|_F\)</span> can be interpreted as a distance between <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, that is, a measure of how dissimilar they are.</p>
<p>Finally, we return to the <span class="math notranslate nohighlight">\(k\)</span>-means objective. Using the notation introduced in this section and the equivalent formula for the objective <span class="math notranslate nohighlight">\(G\)</span> derived in the proof of the <em>Optimal Clustering Lemma</em>, we note that</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
G(C_1,\ldots,C_k; \boldsymbol{\mu}_1, \ldots, \boldsymbol{\mu}_k)
&amp;= \sum_{i=1}^n \|\mathbf{x}_i - \boldsymbol{\mu}_{c(i)}\|^2\\
&amp;= \sum_{i=1}^n \sum_{\ell=1}^d \left(x_{i\ell} - (Z U)_{i\ell}\right)^2\\
&amp;= \|X - Z U \|^2_F,
\end{align*}\]</div>
<p>where we used the definition of the Frobenius norm.</p>
<p>In other words, minimizing the <span class="math notranslate nohighlight">\(k\)</span>-means objective is equivalent to finding a matrix factorization of the form <span class="math notranslate nohighlight">\(ZU\)</span> that is a good fit to the data matrix <span class="math notranslate nohighlight">\(X\)</span> in Frobenius norm. This formulation expresses in a more compact form the idea of representing <span class="math notranslate nohighlight">\(X\)</span> as a combination of a small number of representatives. Matrix factorization will come back repeatedly in this course.</p>
<p><em><strong>Self-assessment quiz</strong></em> <em>(with help from Claude, Gemini, and ChatGPT)</em></p>
<p><strong>1</strong> Which of these is NOT a property of a valid partition <span class="math notranslate nohighlight">\(C_1, \ldots, C_k\)</span> in the context of <span class="math notranslate nohighlight">\(k\)</span>-means?</p>
<p>a) The subsets are pairwise disjoint</p>
<p>b) The subsets cover all data points</p>
<p>c) Each subset is non-empty</p>
<p>d) Each subset contains an equal number of points</p>
<p><strong>2</strong> In the <span class="math notranslate nohighlight">\(k\)</span>-means objective function, what does the variable <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_i\)</span> represent?</p>
<p>a) The centroid of cluster <span class="math notranslate nohighlight">\(i\)</span></p>
<p>b) The number of points in cluster <span class="math notranslate nohighlight">\(i\)</span></p>
<p>c) The distance between clusters <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span></p>
<p>d) The assignment of point <span class="math notranslate nohighlight">\(j\)</span> to a cluster</p>
<p><strong>3</strong> The <span class="math notranslate nohighlight">\(k\)</span>-means objective function is a measure of what?</p>
<p>a) The total number of clusters.</p>
<p>b) The average distance between data points.</p>
<p>c) The sum of squared distances between each data point and its assigned cluster center.</p>
<p>d) The maximum distance between any two cluster centers.</p>
<p><strong>4</strong> What is a key property of the sequence of objective function values produced by the <span class="math notranslate nohighlight">\(k\)</span>-means algorithm?</p>
<p>a) It is strictly decreasing</p>
<p>b) It is non-increasing</p>
<p>c) It is strictly increasing</p>
<p>d) It alternates between two values</p>
<p><strong>5</strong> What is the interpretation of the matrix <span class="math notranslate nohighlight">\(Z\)</span> in the matrix formulation of <span class="math notranslate nohighlight">\(k\)</span>-means?</p>
<p>a) It represents the cluster centers.</p>
<p>b) It represents the distances between data points.</p>
<p>c) It encodes the cluster assignments of each data point.</p>
<p>d) It represents the covariance matrix of the data.</p>
<p>Answer for 1: d. Justification: “Formally, we define a clustering as a partition. A partition of <span class="math notranslate nohighlight">\([n] = {1,\ldots,n}\)</span> of size <span class="math notranslate nohighlight">\(k\)</span> is a collection of non-empty subsets <span class="math notranslate nohighlight">\(C_1,\ldots,C_k \subseteq [n]\)</span> that: are pairwise disjoint, i.e., <span class="math notranslate nohighlight">\(C_i \cap C_j = \emptyset\)</span>, <span class="math notranslate nohighlight">\(\forall i \neq j\)</span>; cover all of <span class="math notranslate nohighlight">\([n]\)</span>, i.e., <span class="math notranslate nohighlight">\(\cup_{i=1}^k C_i = [n]\)</span>.” No requirement for equal-sized subsets is mentioned.</p>
<p>Answer for 2: a. Justification: “Here <span class="math notranslate nohighlight">\(\boldsymbol{\mu}_i \in \mathbb{R}^d\)</span> is the representative – or center – of cluster <span class="math notranslate nohighlight">\(C_i\)</span>.”</p>
<p>Answer for 3: c. Justification: The <span class="math notranslate nohighlight">\(k\)</span>-means objective is defined in the text as minimizing the sum of squared distances between data points and their assigned cluster centers.</p>
<p>Answer for 4: b. Justification: “The sequence of objective function values produced by the <span class="math notranslate nohighlight">\(k\)</span>-means algorithm is non-increasing.”</p>
<p>Answer for 5: c. Justification: The text defines <span class="math notranslate nohighlight">\(Z\)</span> as a matrix where “each row has exactly one entry with value 1, corresponding to the assigned cluster of data point.”</p>
    
</body>
</html>