- en: 27¬†Interactive Games as Reactive Systemsüîó
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://dcic-world.org/2025-08-27/games-reactive.html](https://dcic-world.org/2025-08-27/games-reactive.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ¬†¬†¬†¬†[27.1¬†About Reactive Animations](#%28part._.About_.Reactive_.Animations%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[27.2¬†Preliminaries](#%28part._.Preliminaries%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[27.3¬†Version: Airplane Moving Across the Screen](#%28part._.Version__.Airplane_.Moving_.Across_the_.Screen%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[27.3.1¬†Updating the World State](#%28part._.Updating_the_.World_.State%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[27.3.2¬†Displaying the World State](#%28part._.Displaying_the_.World_.State%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[27.3.3¬†Observing Time (and Combining the Pieces)](#%28part._.Observing_.Time__and_.Combining_the_.Pieces_%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[27.4¬†Version: Wrapping Around](#%28part._.Version__.Wrapping_.Around%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[27.5¬†Version: Descending](#%28part._.Version__.Descending%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[27.5.1¬†Moving the Airplane](#%28part._.Moving_the_.Airplane%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[27.5.2¬†Drawing the Scene](#%28part._.Drawing_the_.Scene%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†¬†¬†[27.5.3¬†Finishing Touches](#%28part._.Finishing_.Touches%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[27.6¬†Version: Responding to Keystrokes](#%28part._.Version__.Responding_to_.Keystrokes%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[27.7¬†Version: Landing](#%28part._.Version__.Landing%29) |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[27.8¬†Version: A Fixed Balloon](#%28part._.Version__.A_.Fixed_.Balloon%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[27.9¬†Version: Keep Your Eye on the Tank](#%28part._.Version__.Keep_.Your_.Eye_on_the_.Tank%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[27.10¬†Version: The Balloon Moves, Too](#%28part._.Version__.The_.Balloon_.Moves__.Too%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ¬†¬†¬†¬†[27.11¬†Version: One, Two, ..., Ninety-Nine Luftballons!](#%28part._.Version__.One__.Two_______.Ninety-.Nine_.Luftballons_%29)
    |'
  prefs: []
  type: TYPE_TB
- en: In this tutorial we‚Äôre going to write a little interactive game. The game won‚Äôt
    be sophisticated, but it‚Äôll have all the elements you need to build much richer
    games of your own.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/998e83245f5c413f941ee7fad3ab6d30.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: Albuquerque Balloon Fiesta
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Imagine we have an airplane coming in to land. It‚Äôs unfortunately trying to
    do so amidst a hot-air balloon festival, so it naturally wants to avoid colliding
    with any (moving) balloons. In addition, there is both land and water, and the
    airplane needs to alight on land. We might also equip it with limited amounts
    of fuel to complete its task. Here are some animations of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[The airplane comes in to land succcessfully.](https://drive.google.com/file/d/1RyDtWXnodN1rzUwwe79InaVUTfIW5GC8/view?usp=share_link)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Uh oh‚Äî<wbr>the airplane collides with a balloon!](https://drive.google.com/file/d/1N8H8T4ssaIlzGfL8XD99QruxLlrIAnAu/view?usp=sharing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Uh oh‚Äî<wbr>the airplane lands in the water!](https://drive.google.com/file/d/1zdlxGY8InPkyYRWi3ROWDHLZPtuj2KZu/view?usp=share_link)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end, you will have written all the relevant portions of this program.
    Your program will:'
  prefs: []
  type: TYPE_NORMAL
- en: animate the airplane to move autonomously;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: detect keystrokes and adjust the airplane accordingly;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: have multiple moving balloons;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: detect collisions between the airplane and balloons;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: check for landing on water and land; and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: account for the use of fuel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Phew: that‚Äôs a lot going on! Therefore, we won‚Äôt write it all at once; instead,
    we‚Äôll build it up bit-by-bit. But we‚Äôll get there by the end.'
  prefs: []
  type: TYPE_NORMAL
- en: 27.1¬†About Reactive Animations[üîó](#(part._.About_.Reactive_.Animations) "Link
    to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are writing a program with two important interactive elements: it is an
    animation, meaning it gives the impression of motion, and it is reactive, meaning
    it responds to user input. Both of these can be challenging to program, but Pyret
    provides a simple mechanism that accommodates both and integrates well with other
    programming principles such as testing. We will learn about this as we go along.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to creating an animation is the Movie Principle. Even in the most sophisticated
    movie you can watch, there is no motion (indeed, the very term ‚Äúmovie‚Äù‚Äî<wbr>short
    for ‚Äúmoving picture‚Äù‚Äî<wbr>is a clever bit of false advertising). Rather, there
    is just a sequence of still images shown in rapid succession, relying on the human
    brain to create the impression of motion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5c8adbce3d9a918184e456af57b76f30.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: 'We are going to exploit the same idea: our animations will consist of a sequence
    of individual images, and we will ask Pyret to show these in rapid succession.
    We will then see how reactivity folds into the same process.'
  prefs: []
  type: TYPE_NORMAL
- en: 27.2¬†Preliminaries[üîó](#(part._.Preliminaries) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To begin with, we should inform Pyret that we plan to make use of both images
    and animations. We load the libraries as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This tells Pyret to load these two libraries and bind the results to the corresponding
    names, `I` and `R`. Thus, all image operations are obtained from `I` and animation
    operations from `R`.
  prefs: []
  type: TYPE_NORMAL
- en: '27.3¬†Version: Airplane Moving Across the Screen[üîó](#(part._.Version__.Airplane_.Moving_.Across_the_.Screen)
    "Link to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start with the simplest version: one in which the airplane moves horizontally
    across the screen. Watch [this video](https://drive.google.com/file/d/1rbDJJJEQV2z-FZT3R1c15xelLsCwhaLI/view?usp=share_link).'
  prefs: []
  type: TYPE_NORMAL
- en: First, here‚Äôs an image of an airplane:Have fun finding your preferred airplane
    image! But don‚Äôt spend too long on it, because we‚Äôve still got a lot of work to
    do.
  prefs: []
  type: TYPE_NORMAL
- en: '[http://world.cs.brown.edu/1/clipart/airplane-small.png](http://world.cs.brown.edu/1/clipart/airplane-small.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can tell Pyret to load this image and give it a name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Henceforth, when we refer to `AIRPLANE`, it will always refer to this image.
    (Try it out in the interactions area!)
  prefs: []
  type: TYPE_NORMAL
- en: Now look at the video again. Watch what happens at different points in time.
    What stays the same, and what changes? What‚Äôs common is the water and land, which
    stay the same. What changes is the (horizontal) position of the airplane.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The World State consists of everything that changes. Things that stay the same
    do not need to get recorded in the World State.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can now define our first World State:'
  prefs: []
  type: TYPE_NORMAL
- en: World Definition
  prefs: []
  type: TYPE_NORMAL
- en: The World State is a number, representing the x-position of the airplane.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Observe something important above:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When we record a World State, we don‚Äôt capture only the type of the values,
    but also their intended meaning.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now we have a representation of the core data, but to generate the above animation,
    we still have to do several things:'
  prefs: []
  type: TYPE_NORMAL
- en: Ask to be notified of the passage of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As time passes, correspondingly update the World State.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given an updated World State, produce the corresponding visual display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This sounds like a lot! Fortunately, Pyret makes this much easier than it sounds.
    We‚Äôll do these in a slightly different order than listed above.
  prefs: []
  type: TYPE_NORMAL
- en: 27.3.1¬†Updating the World State[üîó](#(part._.Updating_the_.World_.State) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we‚Äôve noted, the airplane doesn‚Äôt actually ‚Äúmove‚Äù. Rather, we can ask Pyret
    to notify us every time a clock ticks. If on each tick we place the airplane in
    an appropriately different position, and the ticks happen often enough, we will
    get the impression of motion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the World State consists of just the airplane‚Äôs x-position, to move
    it to the right, we simply increment its value. Let‚Äôs first give this constant
    distance a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to write a function that reflects this movement. Let‚Äôs first write
    some test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The function‚Äôs definition is now clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: And sure enough, Pyret will confirm that this function passes all of its tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have prior experience programming animations and reactive programs,
    you will immediately notice an important difference: it‚Äôs easy to test parts of
    your program in Pyret!'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 27.3.2¬†Displaying the World State[üîó](#(part._.Displaying_the_.World_.State)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we‚Äôre ready to draw the game‚Äôs visual output. We produce an image that
    consists of all the necessary components. It first helps to define some constants
    representing the visual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using these, we can create a blank canvas, and overlay rectangles representing
    water and land:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Examine the value of `BACKGROUND` in the interactions area to confirm that it
    looks right.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The reason we divide by two when placing `BASE` is because Pyret puts the middle
    of the image at the given location. Remove the division and see what happens to
    the resulting image.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now that we know how to get our background, we‚Äôre ready to place the airplane
    on it. The expression to do so looks roughly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'but what x position do we use? Actually, that‚Äôs just what the World State represents!
    So we create a function out of this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 27.3.3¬†Observing Time (and Combining the Pieces)[üîó](#(part._.Observing_.Time__and_.Combining_the_.Pieces_)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, we‚Äôre ready to put these pieces together.
  prefs: []
  type: TYPE_NORMAL
- en: We create a special kind of Pyret value called a reactor, which creates animations.
    We‚Äôll start by creating a fairly simple kind of reactor, then grow it as the program
    gets more sophisticated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates a reactor named `anim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A reactor needs to be given an initial World State as well as handlers that
    tell it how to react. Specifying `on-tick` tells Pyret to run a clock and, every
    time the clock ticks (roughly thirty times a second), invoke the associated handler.
    The `to-draw` handler is used by Pyret to refresh the visual display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having defined this reactor, we can run it in several ways that are useful
    for finding errors, running scientific experiments, and so on. Our needs here
    are simple; we ask Pyret to just run the program on the screen interactively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This creates a running program where the airplane flies across the background!
  prefs: []
  type: TYPE_NORMAL
- en: That‚Äôs it! We‚Äôve created our first animation. Now that we‚Äôve gotten all the
    preliminaries out of the way, we can go about enhancing it.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you want the airplane to appear to move faster, what can you change?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '27.4¬†Version: Wrapping Around[üîó](#(part._.Version__.Wrapping_.Around) "Link
    to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you run the preceding program, you‚Äôll notice that after a while, the airplane
    just disappears. This is because it has gone past the right edge of the screen;
    it is still being ‚Äúdrawn‚Äù, but in a location that you cannot see. That‚Äôs not very
    useful!Also, after a long while you might get an error because the computer is
    being asked to draw the airplane at a location beyond what the graphics system
    can manage. Instead, when the airplane is about to go past the right edge of the
    screen, we‚Äôd like it to reappear on the left by a corresponding amount: ‚Äúwrapping
    around‚Äù, as it were.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Here‚Äôs the video for this version.](https://drive.google.com/file/d/1zL4PY1vOWgFMBuPmMvr8wixh5VE9Pg_r/view?usp=share_link)'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What needs to change?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Clearly, we need to modify the function that updates the airplane‚Äôs location,
    since this must now reflect our decision to wrap around. But the task of how to
    draw the airplane doesn‚Äôt need to change at all! Similarly, the definition of
    the World State does not need to change, either.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we only need to modify `move-airplane-x-on-tick`. The function `num-modulo`
    does exactly what we need. That is, we want the x-location to always be modulo
    the width of the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that, instead of copying the content of the previous definition we can
    simply reuse it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'which makes our intent clearer: compute whatever position we would have had
    before, but adapt the coordinate to remain within the scene‚Äôs width.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, that‚Äôs a proposed re-definition. Be sure to test this function thoroughly:
    it‚Äôs tricker than you might think! Have you thought about all the cases? For instance,
    what happens if the airplane is half-way off the right edge of the screen?'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define quality tests for `move-airplane-wrapping-x-on-tick`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to leave `move-airplane-x-on-tick` unchanged and perform the
    modular arithmetic in `place-airplane-x` instead. We choose not to do that for
    the following reason. In this version, we really do think of the airplane as circling
    around and starting again from the left edge (imagine the world is a cylinder...).
    Thus, the airplane‚Äôs x-position really does keep going back down. If instead we
    allowed the World State to increase monotonically, then it would really be representing
    the total distance traveled, contradicting our definition of the World State.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After adding this function, run your program again. Did you see any change in
    behavior?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you didn‚Äôt‚Ä¶did you remember to update your reactor to use the new airplane-moving
    function?
  prefs: []
  type: TYPE_NORMAL
- en: '27.5¬†Version: Descending[üîó](#(part._.Version__.Descending) "Link to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of course, we need our airplane to move in more than just one dimension: to
    get to the final game, it must both ascend and descend as well. For now, we‚Äôll
    focus on the simplest version of this, which is an airplane that continuously
    descends. [Here‚Äôs a video.](https://drive.google.com/file/d/1fJ7eJ7Uv-YCXm87OKH5obAYFXp1pAnZo/view?usp=share_link)'
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs again consider individual frames of this video. What‚Äôs staying the same?
    Once again, the water and the land. What‚Äôs changing? The position of the airplane.
    But, whereas before the airplane moved only in the x-dimension, now it moves in
    both x and y. That immediately tells us that our definition of the World State
    is inadequate, and must be modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'We therefore define a new structure to hold this pair of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this, we can revise our definition:'
  prefs: []
  type: TYPE_NORMAL
- en: World Definition
  prefs: []
  type: TYPE_NORMAL
- en: The World State is a `posn`, representing the x-position and y-position of the
    airplane on the screen.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 27.5.1¬†Moving the Airplane[üîó](#(part._.Moving_the_.Airplane) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, let‚Äôs consider `move-airplane-wrapping-x-on-tick`. Previously our airplane
    moved only in the x-direction; now we want it to descend as well, which means
    we must add something to the current y value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs write some test cases for the new function. Here‚Äôs one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to write the test would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Which method of writing tests is better? Both! They each offer different advantages:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The former method has the benefit of being very concrete: there‚Äôs no question
    what you expect, and it demonstrates that you really can compute the desired answer
    from first principles.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The latter method has the advantage that, if you change the constants in your
    program (such as the rate of descent), seemingly correct tests do not suddenly
    fail. That is, this form of testing is more about the relationships between things
    rather than their precise values.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There is one more choice available, which often combines the best of both worlds:
    write the answer as concretely as possible (the former style), but using constants
    to compute the answer (the advantage of the latter style). For instance:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Before you proceed, have you written enough test cases? Are you sure? Have you,
    for instance, tested what should happen when the airplane is near the edge of
    the screen in either or both dimensions? We thought not‚Äî<wbr>go back and write
    more tests before you proceed!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Using the design recipe, now define `move-airplane-xy-on-tick`. You should
    end up with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have reused the existing function for the x-dimension and, correspondingly,
    created a helper for the y dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This may be slight overkill for now, but it does lead to a cleaner separation
    of concerns, and makes it possible for the complexity of movement in each dimension
    to evolve independently while keeping the code relatively readable.
  prefs: []
  type: TYPE_NORMAL
- en: 27.5.2¬†Drawing the Scene[üîó](#(part._.Drawing_the_.Scene) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have to also examine and update `place-airplane-x`. Our earlier definition
    placed the airplane at an arbitrary y-coordinate; now we have to take the y-coordinate
    from the World State:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we can‚Äôt really reuse the previous definition because it hard-coded
    the y-position, which we must now make a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 27.5.3¬†Finishing Touches[üîó](#(part._.Finishing_.Touches) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Are we done? It would seem so: we‚Äôve examined all the procedures that consume
    and produce World State and updated them appropriately. Actually, we‚Äôre forgetting
    one small thing: the initial World State given to the reactor! If we‚Äôve changed
    the definition of World State, then we need to update this too. (We also need
    to use the new functions rather than the old ones.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It‚Äôs a little unsatisfactory to have the airplane truncated by the screen. You
    can use `I.image-width` and `I.image-height` to obtain the dimensions of an image,
    such as the airplane. Use these to ensure the airplane fits entirely within the
    screen for the initial scene, and similarly in `move-airplane-xy-on-tick`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '27.6¬†Version: Responding to Keystrokes[üîó](#(part._.Version__.Responding_to_.Keystrokes)
    "Link to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the airplane descending, there‚Äôs no reason it can‚Äôt ascend
    as well. [Here‚Äôs a video.](https://drive.google.com/file/d/1IZw4NrmXsJ-KRaE1GNRhL2Cl3kU27whu/view?usp=share_link)
  prefs: []
  type: TYPE_NORMAL
- en: 'We‚Äôll use the keyboard to control its motion: specifically, the up-key will
    make it move up, while the down-key will make it descend even faster. This is
    easy to support using what we already know: we just need to provide one more handler
    using `on-key`. This handler takes two arguments: the first is the current value
    of the world, while the second is a representation of which key was pressed. For
    the purposes of this program, the only key values we care about are `"up"` and
    `"down"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us a fairly comprehensive view of the core capabilities of reactors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4925a999ce7daf16dda269c55117e5c5.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: We just define a group of functions to perform all our desired actions, and
    the reactor strings them together. Some functions update world values (sometimes
    taking additional information about a stimulus, such as the key pressed), while
    others transform them into output (such as what we see on the screen).
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to our program, let‚Äôs define a constant representing how much distance
    a key represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define a function that alter‚Äôs the airplane‚Äôs position by that distance
    depending on which key is pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does this function definition contain
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: as its last condition?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notice that if we receive any key other than the two we expect, we leave the
    World State as it was; from the user‚Äôs perspective, this has the effect of just
    ignoring the keystroke. Remove this last clause, press some other key, and watch
    what happens!
  prefs: []
  type: TYPE_NORMAL
- en: No matter what you choose, be sure to test this! Can the airplane drift off
    the top of the screen? How about off the screen at the bottom? Can it overlap
    with the land or water?
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we‚Äôve written and thoroughly tested this function, we simply need to ask
    Pyret to use it to handle keystrokes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now your airplane moves not only with the passage of time but also in response
    to your keystrokes. You can keep it up in the air forever!
  prefs: []
  type: TYPE_NORMAL
- en: '27.7¬†Version: Landing[üîó](#(part._.Version__.Landing) "Link to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the objective of our game is to land the airplane, not to keep
    it airborne indefinitely. That means we need to detect when the airplane reaches
    the land or water level and, when it does, [terminate the animation](https://drive.google.com/file/d/1XbO-FHQIveD0f3KCvVlUZPjVLNpHW9NT/view?usp=share_link).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let‚Äôs try to characterize when the animation should halt. This means
    writing a function that consumes the current World State and produces a boolean
    value: `true` if the animation should halt, `false` otherwise. This requires a
    little arithmetic based on the airplane‚Äôs size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need to inform Pyret to use this predicate to automatically halt the
    reactor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you test this, you‚Äôll see it isn‚Äôt quite right because it doesn‚Äôt take
    account of the size of the airplane‚Äôs image. As a result, the airplane only halts
    when it‚Äôs half-way into the land or water, not when it first touches down. Adjust
    the formula so that it halts upon first contact.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend this so that the airplane rolls for a while upon touching land, decelerating
    according to the laws of physics.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose the airplane is actually landing at a secret subterranean airbase. The
    actual landing strip is actually below ground level, and opens up only when the
    airplane comes in to land. That means, after landing, only the parts of the airplane
    that stick above ground level would be visible. Implement this. As a hint, consider
    modifying `place-airplane-xy`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '27.8¬†Version: A Fixed Balloon[üîó](#(part._.Version__.A_.Fixed_.Balloon) "Link
    to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let‚Äôs add a balloon to the scene. [Here‚Äôs a video of the action.](https://drive.google.com/file/d/1QLt9tdt2sSPWR90-mmMLCDW4ZklgR_lN/view?usp=share_link)
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that while the airplane moves, everything else‚Äî<wbr>including the balloon‚Äî<wbr>stays
    immobile. Therefore, we do not need to alter the World State to record the balloon‚Äôs
    position. All we need to do is alter the conditions under which the program halts:
    effectively, there is one more situation under which it terminates, and that is
    a collision with the balloon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When does the game halt? There are now two circumstances: one is contact with
    land or water, and the other is contact with the balloon. The former remains unchanged
    from what it was before, so we can focus on the latter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Where is the balloon, and how do we represent where it is? The latter is easy
    to answer: that‚Äôs what `posn`s are good for. As for the former, we can decide
    where it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'or we can let Pyret pick a random position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Improve the random placement of the balloon so that it is in credible spaces
    (e.g., not submerged).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given a position for the balloon, we just need to detect collision. One simple
    way is as follows: determine whether the distance between the airplane and the
    balloon is within some threshold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: where `COLLISION-THRESHOLD` is some suitable constant computed based on the
    sizes of the airplane and balloon images. (For these particular images, `75` works
    pretty well.)
  prefs: []
  type: TYPE_NORMAL
- en: 'What is `distance`? It consumes two `posn`s and determines the Euclidean distance
    between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to weave together the two termination conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'and use it instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Were you surprised by anything? Did the game look as you expected?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Odds are you didn‚Äôt see a balloon on the screen! That‚Äôs because we didn‚Äôt update
    our display.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to define the balloon‚Äôs image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'and also update the drawing function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see how to write `game-ends` more concisely?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here‚Äôs another version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '27.9¬†Version: Keep Your Eye on the Tank[üîó](#(part._.Version__.Keep_.Your_.Eye_on_the_.Tank)
    "Link to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we‚Äôll introduce the idea of fuel. In our simplified world, fuel isn‚Äôt necessary
    to descend‚Äî<wbr>gravity does that automatically‚Äî<wbr>but it is needed to climb.
    We‚Äôll assume that fuel is counted in whole number units, and every ascension consumes
    one unit of fuel. When you run out of fuel, the program no longer responds to
    the up-arrow, so you can no longer avoid either the balloon or water.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, we‚Äôve looked at still images of the game video to determine what
    is changing and what isn‚Äôt. For this version, we could easily place a little gauge
    on the screen to show the quantity of fuel left. However, we don‚Äôt on purpose,
    to illustrate a principle.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can‚Äôt always determine what is fixed and what is changing just by looking
    at the image. You have to also read the problem statement carefully, and think
    about it in depth.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It‚Äôs clear from our description that there are two things changing: the position
    of the airplane and the quantity of fuel left. Therefore, the World State must
    capture the current values of both of these. The fuel is best represented as a
    single number. However, we do need to create a new structure to represent the
    combination of these two.'
  prefs: []
  type: TYPE_NORMAL
- en: World Definition
  prefs: []
  type: TYPE_NORMAL
- en: The World State is a structure representing the airplane‚Äôs current position
    and the quantity of fuel left.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Concretely, we will use this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We could have also defined the World to be a structure consisting of three
    components: the airplane‚Äôs x-position, the airplane‚Äôs y-position, and the quantity
    of fuel. Why do we choose to use the representation above?'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: We can again look at each of the parts of the program to determine what can
    stay the same and what changes. Concretely, we must focus on the functions that
    consume and produce `World`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'On each tick, we consume a world and compute one. The passage of time does
    not consume any fuel, so this code can remain unchanged, other than having to
    create a structure containing the current amount of fuel. Concretely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the function that responds to keystrokes clearly needs to take into
    account how much fuel is left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Updating the function that renders a scene. Recall that the world has two fields;
    one of them corresponds to what we used to draw before, and the other isn‚Äôt being
    drawn in the output.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What else do you need to change to get a working program?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: You should have noticed that your initial world value is also incorrect because
    it doesn‚Äôt account for fuel. What are interesting fuel values to try?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend your program to draw a fuel gauge.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '27.10¬†Version: The Balloon Moves, Too[üîó](#(part._.Version__.The_.Balloon_.Moves__.Too)
    "Link to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Until now we‚Äôve left our balloon immobile. Let‚Äôs now make the game more interesting
    by letting the balloon move, as [this video shows.](https://drive.google.com/file/d/19kxqArza5y72V9xIezUtPi8PNV33KsG3/view?usp=share_link)
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the balloon‚Äôs location needs to also become part of the World State.
  prefs: []
  type: TYPE_NORMAL
- en: World Definition
  prefs: []
  type: TYPE_NORMAL
- en: The World State is a structure representing the plane‚Äôs current position, the
    balloon‚Äôs current position, and the quantity of fuel left.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here is a representation of the world state. As these states become more complex,
    it‚Äôs important to add annotations so we can keep track of what‚Äôs what.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition, we obviously need to re-write all our previous definitions.
    Most of this is quite routine relative to what we‚Äôve seen before. The only detail
    we haven‚Äôt really specified is how the balloon is supposed to move: in what direction,
    at what speed, and what to do at the edges. We‚Äôll let you use your imagination
    for this one! (Remember that the closer the balloon is to land, the harder it
    is to safely land the plane.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We thus have to modify:'
  prefs: []
  type: TYPE_NORMAL
- en: The background image (to remove the static balloon).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The drawing handler (to draw the balloon at its position).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The timer handler (to move the balloon as well as the airplane).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key handler (to construct world data that leaves the balloon unchanged).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The termination condition (to account for the balloon‚Äôs dynamic location).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify each of the above functions, along with their test cases.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '27.11¬†Version: One, Two, ..., Ninety-Nine Luftballons![üîó](#(part._.Version__.One__.Two_______.Ninety-.Nine_.Luftballons_)
    "Link to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, there‚Äôs no need to limit ourselves to only one balloon. How many is
    right? Two? Three? Ten? ... Why fix any one number? It could be a balloon festival!
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, many games have levels that become progressively harder; we could
    do the same, letting the number of balloons be part of what changes across levels.
    However, there is conceptually no big difference between having two balloons and
    five; the code to control each balloon is essentially the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to represent a collection of balloons. We can use a list to represent
    them. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: World Definition
  prefs: []
  type: TYPE_NORMAL
- en: The World State is a structure representing the plane‚Äôs current position, a
    list of balloon positions, and the quantity of fuel left.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You should now use the design recipe for lists of structures to rewrite the
    functions. Notice that you‚Äôve already written the function to move one balloon.
    What‚Äôs left?
  prefs: []
  type: TYPE_NORMAL
- en: Apply the same function to each balloon in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine what to do if two balloons collide.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, you can avoid the latter problem by placing each balloon sufficiently
    spread apart along the x-dimension and letting them move only up and down.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Introduce a concept of wind, which affects balloons but not the airplane. After
    random periods of time, the wind blows with random speed and direction, causing
    the ballooons to move laterally.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 27.1¬†About Reactive Animations[üîó](#(part._.About_.Reactive_.Animations) "Link
    to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are writing a program with two important interactive elements: it is an
    animation, meaning it gives the impression of motion, and it is reactive, meaning
    it responds to user input. Both of these can be challenging to program, but Pyret
    provides a simple mechanism that accommodates both and integrates well with other
    programming principles such as testing. We will learn about this as we go along.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to creating an animation is the Movie Principle. Even in the most sophisticated
    movie you can watch, there is no motion (indeed, the very term ‚Äúmovie‚Äù‚Äî<wbr>short
    for ‚Äúmoving picture‚Äù‚Äî<wbr>is a clever bit of false advertising). Rather, there
    is just a sequence of still images shown in rapid succession, relying on the human
    brain to create the impression of motion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5c8adbce3d9a918184e456af57b76f30.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: 'We are going to exploit the same idea: our animations will consist of a sequence
    of individual images, and we will ask Pyret to show these in rapid succession.
    We will then see how reactivity folds into the same process.'
  prefs: []
  type: TYPE_NORMAL
- en: 27.2¬†Preliminaries[üîó](#(part._.Preliminaries) "Link to here")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To begin with, we should inform Pyret that we plan to make use of both images
    and animations. We load the libraries as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This tells Pyret to load these two libraries and bind the results to the corresponding
    names, `I` and `R`. Thus, all image operations are obtained from `I` and animation
    operations from `R`.
  prefs: []
  type: TYPE_NORMAL
- en: '27.3¬†Version: Airplane Moving Across the Screen[üîó](#(part._.Version__.Airplane_.Moving_.Across_the_.Screen)
    "Link to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start with the simplest version: one in which the airplane moves horizontally
    across the screen. Watch [this video](https://drive.google.com/file/d/1rbDJJJEQV2z-FZT3R1c15xelLsCwhaLI/view?usp=share_link).'
  prefs: []
  type: TYPE_NORMAL
- en: First, here‚Äôs an image of an airplane:Have fun finding your preferred airplane
    image! But don‚Äôt spend too long on it, because we‚Äôve still got a lot of work to
    do.
  prefs: []
  type: TYPE_NORMAL
- en: '[http://world.cs.brown.edu/1/clipart/airplane-small.png](http://world.cs.brown.edu/1/clipart/airplane-small.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can tell Pyret to load this image and give it a name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Henceforth, when we refer to `AIRPLANE`, it will always refer to this image.
    (Try it out in the interactions area!)
  prefs: []
  type: TYPE_NORMAL
- en: Now look at the video again. Watch what happens at different points in time.
    What stays the same, and what changes? What‚Äôs common is the water and land, which
    stay the same. What changes is the (horizontal) position of the airplane.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The World State consists of everything that changes. Things that stay the same
    do not need to get recorded in the World State.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can now define our first World State:'
  prefs: []
  type: TYPE_NORMAL
- en: World Definition
  prefs: []
  type: TYPE_NORMAL
- en: The World State is a number, representing the x-position of the airplane.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Observe something important above:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When we record a World State, we don‚Äôt capture only the type of the values,
    but also their intended meaning.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now we have a representation of the core data, but to generate the above animation,
    we still have to do several things:'
  prefs: []
  type: TYPE_NORMAL
- en: Ask to be notified of the passage of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As time passes, correspondingly update the World State.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given an updated World State, produce the corresponding visual display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This sounds like a lot! Fortunately, Pyret makes this much easier than it sounds.
    We‚Äôll do these in a slightly different order than listed above.
  prefs: []
  type: TYPE_NORMAL
- en: 27.3.1¬†Updating the World State[üîó](#(part._.Updating_the_.World_.State) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we‚Äôve noted, the airplane doesn‚Äôt actually ‚Äúmove‚Äù. Rather, we can ask Pyret
    to notify us every time a clock ticks. If on each tick we place the airplane in
    an appropriately different position, and the ticks happen often enough, we will
    get the impression of motion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the World State consists of just the airplane‚Äôs x-position, to move
    it to the right, we simply increment its value. Let‚Äôs first give this constant
    distance a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to write a function that reflects this movement. Let‚Äôs first write
    some test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The function‚Äôs definition is now clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: And sure enough, Pyret will confirm that this function passes all of its tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have prior experience programming animations and reactive programs,
    you will immediately notice an important difference: it‚Äôs easy to test parts of
    your program in Pyret!'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 27.3.2¬†Displaying the World State[üîó](#(part._.Displaying_the_.World_.State)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we‚Äôre ready to draw the game‚Äôs visual output. We produce an image that
    consists of all the necessary components. It first helps to define some constants
    representing the visual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Using these, we can create a blank canvas, and overlay rectangles representing
    water and land:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Examine the value of `BACKGROUND` in the interactions area to confirm that it
    looks right.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The reason we divide by two when placing `BASE` is because Pyret puts the middle
    of the image at the given location. Remove the division and see what happens to
    the resulting image.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now that we know how to get our background, we‚Äôre ready to place the airplane
    on it. The expression to do so looks roughly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'but what x position do we use? Actually, that‚Äôs just what the World State represents!
    So we create a function out of this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 27.3.3¬†Observing Time (and Combining the Pieces)[üîó](#(part._.Observing_.Time__and_.Combining_the_.Pieces_)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, we‚Äôre ready to put these pieces together.
  prefs: []
  type: TYPE_NORMAL
- en: We create a special kind of Pyret value called a reactor, which creates animations.
    We‚Äôll start by creating a fairly simple kind of reactor, then grow it as the program
    gets more sophisticated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates a reactor named `anim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: A reactor needs to be given an initial World State as well as handlers that
    tell it how to react. Specifying `on-tick` tells Pyret to run a clock and, every
    time the clock ticks (roughly thirty times a second), invoke the associated handler.
    The `to-draw` handler is used by Pyret to refresh the visual display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having defined this reactor, we can run it in several ways that are useful
    for finding errors, running scientific experiments, and so on. Our needs here
    are simple; we ask Pyret to just run the program on the screen interactively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This creates a running program where the airplane flies across the background!
  prefs: []
  type: TYPE_NORMAL
- en: That‚Äôs it! We‚Äôve created our first animation. Now that we‚Äôve gotten all the
    preliminaries out of the way, we can go about enhancing it.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you want the airplane to appear to move faster, what can you change?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 27.3.1¬†Updating the World State[üîó](#(part._.Updating_the_.World_.State) "Link
    to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we‚Äôve noted, the airplane doesn‚Äôt actually ‚Äúmove‚Äù. Rather, we can ask Pyret
    to notify us every time a clock ticks. If on each tick we place the airplane in
    an appropriately different position, and the ticks happen often enough, we will
    get the impression of motion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the World State consists of just the airplane‚Äôs x-position, to move
    it to the right, we simply increment its value. Let‚Äôs first give this constant
    distance a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to write a function that reflects this movement. Let‚Äôs first write
    some test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The function‚Äôs definition is now clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: And sure enough, Pyret will confirm that this function passes all of its tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have prior experience programming animations and reactive programs,
    you will immediately notice an important difference: it‚Äôs easy to test parts of
    your program in Pyret!'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 27.3.2¬†Displaying the World State[üîó](#(part._.Displaying_the_.World_.State)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we‚Äôre ready to draw the game‚Äôs visual output. We produce an image that
    consists of all the necessary components. It first helps to define some constants
    representing the visual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Using these, we can create a blank canvas, and overlay rectangles representing
    water and land:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Examine the value of `BACKGROUND` in the interactions area to confirm that it
    looks right.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The reason we divide by two when placing `BASE` is because Pyret puts the middle
    of the image at the given location. Remove the division and see what happens to
    the resulting image.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now that we know how to get our background, we‚Äôre ready to place the airplane
    on it. The expression to do so looks roughly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'but what x position do we use? Actually, that‚Äôs just what the World State represents!
    So we create a function out of this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 27.3.3¬†Observing Time (and Combining the Pieces)[üîó](#(part._.Observing_.Time__and_.Combining_the_.Pieces_)
    "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, we‚Äôre ready to put these pieces together.
  prefs: []
  type: TYPE_NORMAL
- en: We create a special kind of Pyret value called a reactor, which creates animations.
    We‚Äôll start by creating a fairly simple kind of reactor, then grow it as the program
    gets more sophisticated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates a reactor named `anim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: A reactor needs to be given an initial World State as well as handlers that
    tell it how to react. Specifying `on-tick` tells Pyret to run a clock and, every
    time the clock ticks (roughly thirty times a second), invoke the associated handler.
    The `to-draw` handler is used by Pyret to refresh the visual display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having defined this reactor, we can run it in several ways that are useful
    for finding errors, running scientific experiments, and so on. Our needs here
    are simple; we ask Pyret to just run the program on the screen interactively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This creates a running program where the airplane flies across the background!
  prefs: []
  type: TYPE_NORMAL
- en: That‚Äôs it! We‚Äôve created our first animation. Now that we‚Äôve gotten all the
    preliminaries out of the way, we can go about enhancing it.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you want the airplane to appear to move faster, what can you change?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '27.4¬†Version: Wrapping Around[üîó](#(part._.Version__.Wrapping_.Around) "Link
    to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you run the preceding program, you‚Äôll notice that after a while, the airplane
    just disappears. This is because it has gone past the right edge of the screen;
    it is still being ‚Äúdrawn‚Äù, but in a location that you cannot see. That‚Äôs not very
    useful!Also, after a long while you might get an error because the computer is
    being asked to draw the airplane at a location beyond what the graphics system
    can manage. Instead, when the airplane is about to go past the right edge of the
    screen, we‚Äôd like it to reappear on the left by a corresponding amount: ‚Äúwrapping
    around‚Äù, as it were.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Here‚Äôs the video for this version.](https://drive.google.com/file/d/1zL4PY1vOWgFMBuPmMvr8wixh5VE9Pg_r/view?usp=share_link)'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What needs to change?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Clearly, we need to modify the function that updates the airplane‚Äôs location,
    since this must now reflect our decision to wrap around. But the task of how to
    draw the airplane doesn‚Äôt need to change at all! Similarly, the definition of
    the World State does not need to change, either.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we only need to modify `move-airplane-x-on-tick`. The function `num-modulo`
    does exactly what we need. That is, we want the x-location to always be modulo
    the width of the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that, instead of copying the content of the previous definition we can
    simply reuse it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'which makes our intent clearer: compute whatever position we would have had
    before, but adapt the coordinate to remain within the scene‚Äôs width.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, that‚Äôs a proposed re-definition. Be sure to test this function thoroughly:
    it‚Äôs tricker than you might think! Have you thought about all the cases? For instance,
    what happens if the airplane is half-way off the right edge of the screen?'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define quality tests for `move-airplane-wrapping-x-on-tick`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to leave `move-airplane-x-on-tick` unchanged and perform the
    modular arithmetic in `place-airplane-x` instead. We choose not to do that for
    the following reason. In this version, we really do think of the airplane as circling
    around and starting again from the left edge (imagine the world is a cylinder...).
    Thus, the airplane‚Äôs x-position really does keep going back down. If instead we
    allowed the World State to increase monotonically, then it would really be representing
    the total distance traveled, contradicting our definition of the World State.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After adding this function, run your program again. Did you see any change in
    behavior?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you didn‚Äôt‚Ä¶did you remember to update your reactor to use the new airplane-moving
    function?
  prefs: []
  type: TYPE_NORMAL
- en: '27.5¬†Version: Descending[üîó](#(part._.Version__.Descending) "Link to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of course, we need our airplane to move in more than just one dimension: to
    get to the final game, it must both ascend and descend as well. For now, we‚Äôll
    focus on the simplest version of this, which is an airplane that continuously
    descends. [Here‚Äôs a video.](https://drive.google.com/file/d/1fJ7eJ7Uv-YCXm87OKH5obAYFXp1pAnZo/view?usp=share_link)'
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs again consider individual frames of this video. What‚Äôs staying the same?
    Once again, the water and the land. What‚Äôs changing? The position of the airplane.
    But, whereas before the airplane moved only in the x-dimension, now it moves in
    both x and y. That immediately tells us that our definition of the World State
    is inadequate, and must be modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'We therefore define a new structure to hold this pair of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this, we can revise our definition:'
  prefs: []
  type: TYPE_NORMAL
- en: World Definition
  prefs: []
  type: TYPE_NORMAL
- en: The World State is a `posn`, representing the x-position and y-position of the
    airplane on the screen.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 27.5.1¬†Moving the Airplane[üîó](#(part._.Moving_the_.Airplane) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, let‚Äôs consider `move-airplane-wrapping-x-on-tick`. Previously our airplane
    moved only in the x-direction; now we want it to descend as well, which means
    we must add something to the current y value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs write some test cases for the new function. Here‚Äôs one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to write the test would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Which method of writing tests is better? Both! They each offer different advantages:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The former method has the benefit of being very concrete: there‚Äôs no question
    what you expect, and it demonstrates that you really can compute the desired answer
    from first principles.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The latter method has the advantage that, if you change the constants in your
    program (such as the rate of descent), seemingly correct tests do not suddenly
    fail. That is, this form of testing is more about the relationships between things
    rather than their precise values.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There is one more choice available, which often combines the best of both worlds:
    write the answer as concretely as possible (the former style), but using constants
    to compute the answer (the advantage of the latter style). For instance:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Before you proceed, have you written enough test cases? Are you sure? Have you,
    for instance, tested what should happen when the airplane is near the edge of
    the screen in either or both dimensions? We thought not‚Äî<wbr>go back and write
    more tests before you proceed!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Using the design recipe, now define `move-airplane-xy-on-tick`. You should
    end up with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have reused the existing function for the x-dimension and, correspondingly,
    created a helper for the y dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This may be slight overkill for now, but it does lead to a cleaner separation
    of concerns, and makes it possible for the complexity of movement in each dimension
    to evolve independently while keeping the code relatively readable.
  prefs: []
  type: TYPE_NORMAL
- en: 27.5.2¬†Drawing the Scene[üîó](#(part._.Drawing_the_.Scene) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have to also examine and update `place-airplane-x`. Our earlier definition
    placed the airplane at an arbitrary y-coordinate; now we have to take the y-coordinate
    from the World State:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we can‚Äôt really reuse the previous definition because it hard-coded
    the y-position, which we must now make a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 27.5.3¬†Finishing Touches[üîó](#(part._.Finishing_.Touches) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Are we done? It would seem so: we‚Äôve examined all the procedures that consume
    and produce World State and updated them appropriately. Actually, we‚Äôre forgetting
    one small thing: the initial World State given to the reactor! If we‚Äôve changed
    the definition of World State, then we need to update this too. (We also need
    to use the new functions rather than the old ones.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It‚Äôs a little unsatisfactory to have the airplane truncated by the screen. You
    can use `I.image-width` and `I.image-height` to obtain the dimensions of an image,
    such as the airplane. Use these to ensure the airplane fits entirely within the
    screen for the initial scene, and similarly in `move-airplane-xy-on-tick`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 27.5.1¬†Moving the Airplane[üîó](#(part._.Moving_the_.Airplane) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, let‚Äôs consider `move-airplane-wrapping-x-on-tick`. Previously our airplane
    moved only in the x-direction; now we want it to descend as well, which means
    we must add something to the current y value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs write some test cases for the new function. Here‚Äôs one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to write the test would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Which method of writing tests is better? Both! They each offer different advantages:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The former method has the benefit of being very concrete: there‚Äôs no question
    what you expect, and it demonstrates that you really can compute the desired answer
    from first principles.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The latter method has the advantage that, if you change the constants in your
    program (such as the rate of descent), seemingly correct tests do not suddenly
    fail. That is, this form of testing is more about the relationships between things
    rather than their precise values.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There is one more choice available, which often combines the best of both worlds:
    write the answer as concretely as possible (the former style), but using constants
    to compute the answer (the advantage of the latter style). For instance:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Before you proceed, have you written enough test cases? Are you sure? Have you,
    for instance, tested what should happen when the airplane is near the edge of
    the screen in either or both dimensions? We thought not‚Äî<wbr>go back and write
    more tests before you proceed!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Using the design recipe, now define `move-airplane-xy-on-tick`. You should
    end up with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have reused the existing function for the x-dimension and, correspondingly,
    created a helper for the y dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This may be slight overkill for now, but it does lead to a cleaner separation
    of concerns, and makes it possible for the complexity of movement in each dimension
    to evolve independently while keeping the code relatively readable.
  prefs: []
  type: TYPE_NORMAL
- en: 27.5.2¬†Drawing the Scene[üîó](#(part._.Drawing_the_.Scene) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have to also examine and update `place-airplane-x`. Our earlier definition
    placed the airplane at an arbitrary y-coordinate; now we have to take the y-coordinate
    from the World State:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we can‚Äôt really reuse the previous definition because it hard-coded
    the y-position, which we must now make a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 27.5.3¬†Finishing Touches[üîó](#(part._.Finishing_.Touches) "Link to here")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Are we done? It would seem so: we‚Äôve examined all the procedures that consume
    and produce World State and updated them appropriately. Actually, we‚Äôre forgetting
    one small thing: the initial World State given to the reactor! If we‚Äôve changed
    the definition of World State, then we need to update this too. (We also need
    to use the new functions rather than the old ones.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It‚Äôs a little unsatisfactory to have the airplane truncated by the screen. You
    can use `I.image-width` and `I.image-height` to obtain the dimensions of an image,
    such as the airplane. Use these to ensure the airplane fits entirely within the
    screen for the initial scene, and similarly in `move-airplane-xy-on-tick`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '27.6¬†Version: Responding to Keystrokes[üîó](#(part._.Version__.Responding_to_.Keystrokes)
    "Link to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the airplane descending, there‚Äôs no reason it can‚Äôt ascend
    as well. [Here‚Äôs a video.](https://drive.google.com/file/d/1IZw4NrmXsJ-KRaE1GNRhL2Cl3kU27whu/view?usp=share_link)
  prefs: []
  type: TYPE_NORMAL
- en: 'We‚Äôll use the keyboard to control its motion: specifically, the up-key will
    make it move up, while the down-key will make it descend even faster. This is
    easy to support using what we already know: we just need to provide one more handler
    using `on-key`. This handler takes two arguments: the first is the current value
    of the world, while the second is a representation of which key was pressed. For
    the purposes of this program, the only key values we care about are `"up"` and
    `"down"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us a fairly comprehensive view of the core capabilities of reactors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4925a999ce7daf16dda269c55117e5c5.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: We just define a group of functions to perform all our desired actions, and
    the reactor strings them together. Some functions update world values (sometimes
    taking additional information about a stimulus, such as the key pressed), while
    others transform them into output (such as what we see on the screen).
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to our program, let‚Äôs define a constant representing how much distance
    a key represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define a function that alter‚Äôs the airplane‚Äôs position by that distance
    depending on which key is pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does this function definition contain
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: as its last condition?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notice that if we receive any key other than the two we expect, we leave the
    World State as it was; from the user‚Äôs perspective, this has the effect of just
    ignoring the keystroke. Remove this last clause, press some other key, and watch
    what happens!
  prefs: []
  type: TYPE_NORMAL
- en: No matter what you choose, be sure to test this! Can the airplane drift off
    the top of the screen? How about off the screen at the bottom? Can it overlap
    with the land or water?
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we‚Äôve written and thoroughly tested this function, we simply need to ask
    Pyret to use it to handle keystrokes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Now your airplane moves not only with the passage of time but also in response
    to your keystrokes. You can keep it up in the air forever!
  prefs: []
  type: TYPE_NORMAL
- en: '27.7¬†Version: Landing[üîó](#(part._.Version__.Landing) "Link to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the objective of our game is to land the airplane, not to keep
    it airborne indefinitely. That means we need to detect when the airplane reaches
    the land or water level and, when it does, [terminate the animation](https://drive.google.com/file/d/1XbO-FHQIveD0f3KCvVlUZPjVLNpHW9NT/view?usp=share_link).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let‚Äôs try to characterize when the animation should halt. This means
    writing a function that consumes the current World State and produces a boolean
    value: `true` if the animation should halt, `false` otherwise. This requires a
    little arithmetic based on the airplane‚Äôs size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need to inform Pyret to use this predicate to automatically halt the
    reactor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you test this, you‚Äôll see it isn‚Äôt quite right because it doesn‚Äôt take
    account of the size of the airplane‚Äôs image. As a result, the airplane only halts
    when it‚Äôs half-way into the land or water, not when it first touches down. Adjust
    the formula so that it halts upon first contact.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend this so that the airplane rolls for a while upon touching land, decelerating
    according to the laws of physics.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose the airplane is actually landing at a secret subterranean airbase. The
    actual landing strip is actually below ground level, and opens up only when the
    airplane comes in to land. That means, after landing, only the parts of the airplane
    that stick above ground level would be visible. Implement this. As a hint, consider
    modifying `place-airplane-xy`.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '27.8¬†Version: A Fixed Balloon[üîó](#(part._.Version__.A_.Fixed_.Balloon) "Link
    to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let‚Äôs add a balloon to the scene. [Here‚Äôs a video of the action.](https://drive.google.com/file/d/1QLt9tdt2sSPWR90-mmMLCDW4ZklgR_lN/view?usp=share_link)
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that while the airplane moves, everything else‚Äî<wbr>including the balloon‚Äî<wbr>stays
    immobile. Therefore, we do not need to alter the World State to record the balloon‚Äôs
    position. All we need to do is alter the conditions under which the program halts:
    effectively, there is one more situation under which it terminates, and that is
    a collision with the balloon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When does the game halt? There are now two circumstances: one is contact with
    land or water, and the other is contact with the balloon. The former remains unchanged
    from what it was before, so we can focus on the latter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Where is the balloon, and how do we represent where it is? The latter is easy
    to answer: that‚Äôs what `posn`s are good for. As for the former, we can decide
    where it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'or we can let Pyret pick a random position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Improve the random placement of the balloon so that it is in credible spaces
    (e.g., not submerged).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given a position for the balloon, we just need to detect collision. One simple
    way is as follows: determine whether the distance between the airplane and the
    balloon is within some threshold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: where `COLLISION-THRESHOLD` is some suitable constant computed based on the
    sizes of the airplane and balloon images. (For these particular images, `75` works
    pretty well.)
  prefs: []
  type: TYPE_NORMAL
- en: 'What is `distance`? It consumes two `posn`s and determines the Euclidean distance
    between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to weave together the two termination conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'and use it instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Were you surprised by anything? Did the game look as you expected?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Odds are you didn‚Äôt see a balloon on the screen! That‚Äôs because we didn‚Äôt update
    our display.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to define the balloon‚Äôs image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'and also update the drawing function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see how to write `game-ends` more concisely?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here‚Äôs another version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '27.9¬†Version: Keep Your Eye on the Tank[üîó](#(part._.Version__.Keep_.Your_.Eye_on_the_.Tank)
    "Link to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we‚Äôll introduce the idea of fuel. In our simplified world, fuel isn‚Äôt necessary
    to descend‚Äî<wbr>gravity does that automatically‚Äî<wbr>but it is needed to climb.
    We‚Äôll assume that fuel is counted in whole number units, and every ascension consumes
    one unit of fuel. When you run out of fuel, the program no longer responds to
    the up-arrow, so you can no longer avoid either the balloon or water.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, we‚Äôve looked at still images of the game video to determine what
    is changing and what isn‚Äôt. For this version, we could easily place a little gauge
    on the screen to show the quantity of fuel left. However, we don‚Äôt on purpose,
    to illustrate a principle.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can‚Äôt always determine what is fixed and what is changing just by looking
    at the image. You have to also read the problem statement carefully, and think
    about it in depth.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It‚Äôs clear from our description that there are two things changing: the position
    of the airplane and the quantity of fuel left. Therefore, the World State must
    capture the current values of both of these. The fuel is best represented as a
    single number. However, we do need to create a new structure to represent the
    combination of these two.'
  prefs: []
  type: TYPE_NORMAL
- en: World Definition
  prefs: []
  type: TYPE_NORMAL
- en: The World State is a structure representing the airplane‚Äôs current position
    and the quantity of fuel left.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Concretely, we will use this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We could have also defined the World to be a structure consisting of three
    components: the airplane‚Äôs x-position, the airplane‚Äôs y-position, and the quantity
    of fuel. Why do we choose to use the representation above?'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: We can again look at each of the parts of the program to determine what can
    stay the same and what changes. Concretely, we must focus on the functions that
    consume and produce `World`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'On each tick, we consume a world and compute one. The passage of time does
    not consume any fuel, so this code can remain unchanged, other than having to
    create a structure containing the current amount of fuel. Concretely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the function that responds to keystrokes clearly needs to take into
    account how much fuel is left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Updating the function that renders a scene. Recall that the world has two fields;
    one of them corresponds to what we used to draw before, and the other isn‚Äôt being
    drawn in the output.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What else do you need to change to get a working program?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: You should have noticed that your initial world value is also incorrect because
    it doesn‚Äôt account for fuel. What are interesting fuel values to try?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extend your program to draw a fuel gauge.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '27.10¬†Version: The Balloon Moves, Too[üîó](#(part._.Version__.The_.Balloon_.Moves__.Too)
    "Link to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Until now we‚Äôve left our balloon immobile. Let‚Äôs now make the game more interesting
    by letting the balloon move, as [this video shows.](https://drive.google.com/file/d/19kxqArza5y72V9xIezUtPi8PNV33KsG3/view?usp=share_link)
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the balloon‚Äôs location needs to also become part of the World State.
  prefs: []
  type: TYPE_NORMAL
- en: World Definition
  prefs: []
  type: TYPE_NORMAL
- en: The World State is a structure representing the plane‚Äôs current position, the
    balloon‚Äôs current position, and the quantity of fuel left.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here is a representation of the world state. As these states become more complex,
    it‚Äôs important to add annotations so we can keep track of what‚Äôs what.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition, we obviously need to re-write all our previous definitions.
    Most of this is quite routine relative to what we‚Äôve seen before. The only detail
    we haven‚Äôt really specified is how the balloon is supposed to move: in what direction,
    at what speed, and what to do at the edges. We‚Äôll let you use your imagination
    for this one! (Remember that the closer the balloon is to land, the harder it
    is to safely land the plane.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We thus have to modify:'
  prefs: []
  type: TYPE_NORMAL
- en: The background image (to remove the static balloon).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The drawing handler (to draw the balloon at its position).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The timer handler (to move the balloon as well as the airplane).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key handler (to construct world data that leaves the balloon unchanged).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The termination condition (to account for the balloon‚Äôs dynamic location).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify each of the above functions, along with their test cases.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '27.11¬†Version: One, Two, ..., Ninety-Nine Luftballons![üîó](#(part._.Version__.One__.Two_______.Ninety-.Nine_.Luftballons_)
    "Link to here")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, there‚Äôs no need to limit ourselves to only one balloon. How many is
    right? Two? Three? Ten? ... Why fix any one number? It could be a balloon festival!
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, many games have levels that become progressively harder; we could
    do the same, letting the number of balloons be part of what changes across levels.
    However, there is conceptually no big difference between having two balloons and
    five; the code to control each balloon is essentially the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to represent a collection of balloons. We can use a list to represent
    them. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: World Definition
  prefs: []
  type: TYPE_NORMAL
- en: The World State is a structure representing the plane‚Äôs current position, a
    list of balloon positions, and the quantity of fuel left.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You should now use the design recipe for lists of structures to rewrite the
    functions. Notice that you‚Äôve already written the function to move one balloon.
    What‚Äôs left?
  prefs: []
  type: TYPE_NORMAL
- en: Apply the same function to each balloon in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine what to do if two balloons collide.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, you can avoid the latter problem by placing each balloon sufficiently
    spread apart along the x-dimension and letting them move only up and down.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Introduce a concept of wind, which affects balloons but not the airplane. After
    random periods of time, the wind blows with random speed and direction, causing
    the ballooons to move laterally.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
