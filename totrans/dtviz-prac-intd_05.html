<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>4 Show the right numbers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>4 Show the right numbers</h1>
<blockquote>原文：<a href="https://socviz.co/groupfacettx.html">https://socviz.co/groupfacettx.html</a></blockquote>

<p>This Chapter will continue to develop your fluency with ggplot’s
central workflow, while also expanding the range of things you can do
with it. One of our goals is to learn how to make new kinds of graph.
This means learning some new geoms, the functions that make particular
kinds of plots. But we will also get a better sense of what ggplot is
doing when it draws plots, and learn more about how to write code that
prepares our data to be plotted.</p>
<p>Code almost never works properly the first time you write it. This is
the main reason that, when learning a new language, it is important to
type out the exercises and follow along manually. It gives you a much
better sense of how the syntax of the language works, where you’re
likely to make errors, and what the computer does when that happens.
Running into bugs and errors is frustrating, but it’s also an
opportunity to learn a bit more. Errors can be obscure but they are
usually not malicious or random. If something has gone wrong, you can
find out why it happened.</p>
<p>In R and ggplot, errors in code can result in figures that don’t look
right. We have already seen the result of one of the most common
problems, when an aesthetic is mistakenly set to a constant value
instead of being mapped to a variable. In this chapter we will discuss
some useful features of ggplot that also commonly cause trouble. They
have to do with how to tell ggplot more about the internal structure
of your data (<em>grouping</em>), how to break up your data into pieces for a
plot (<em>faceting</em>), and how to get ggplot to perform some calculations
on or summarize your data before producing the plot (<em>transforming</em>).
Some of these tasks are part of ggplot proper, and so we will learn
more about how geoms, with the help of their associated <em>stat</em>
functions, can act on data before plotting it. As we shall also see,
while it is possible to do a lot of transformation directly in ggplot,
there can be more convenient ways to approach the same task.</p>
<div id="colorless-green-data-sleeps-furiously" class="section level2">
<h2><span class="header-section-number">4.1</span> Colorless green data sleeps furiously</h2>
<p>When you write ggplot code in R you are in effect trying to “say”
something visually. It usually takes several iterations to say exactly
what you mean. This is more than a metaphor here. The ggplot library is an
implementation of the “grammar” of graphics, an idea developed by
<span class="citation">Wilkinson (2005)</span>. The grammar is a set of rules for producing
graphics from data, taking pieces of data and mapping them to
geometric objects (like points and lines) that have aesthetic
attributes (like position, color and size), together with further
rules for transforming the data if needed (e.g. to a smoothed line),
adjusting scales (e.g. to a log scale),<label for="tufte-mn-44" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-44" class="margin-toggle"/><span class="marginnote shownote">We will see some alternatives to cartesian coordinates later.</span> and projecting the results onto a different coordinate system (usually cartesian).</p>
<p>A key point is that, like other rules of syntax, the grammar limits
the structure of what you can say, but it does not automatically make
what you say sensible or meaningful. It allows you to produce long
“sentences” that begin with mappings of data to visual elements and
add clauses about what sort of plot it is, how the axes are scaled,
and so on. But these sentences can easily be garbled. Sometimes your
code will not produce a plot at all because of some syntax error in R.
You will forget a <code>+</code> sign between <code>geom_</code> functions, or lose a
parenthesis somewhere so that your function statement becomes
unbalanced. In those cases R will complain (perhaps in an opaque way)
that something has gone wrong. At other times, your code will
successfully produce a plot, but it will not look the way you expected
it to. Sometimes the results will look very weird indeed. In those
cases, the chances are you have given ggplot a series of grammatically
correct instructions that are either nonsensical in some way, or have
accidentally twisted what you meant to say. These problems often arise
when ggplot does not have quite all the information it needs in order
make your graphic say what you want it to say.</p>
</div>
<div id="grouped-data-and-the-group-aesthetic" class="section level2">
<h2><span class="header-section-number">4.2</span> Grouped data and the “group” aesthetic</h2>
<p>Let’s begin again with our Gapminder dataset. Imagine we wanted to
plot the trajectory of life expectancy over time for each country in
the data. We map <code>year</code> to <code>x</code> and <code>lifeExp</code> to <code>y</code>. We take a quick
look at the documentation and discover that <code>geom_line()</code> will draw
lines by connecting observations in order of the variable on the
x-axis, which seems right. We write our code:</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gapminder-1"/>
<img src="../Images/13e4a87d0b85be4bf9aaa5565bf105ab.png" alt="Trying to plot the data over time by country." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gapminder-1-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.1: Trying to plot the data over time by country.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb97-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gapminder,</a>
<a class="sourceLine" id="cb97-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year,</a>
<a class="sourceLine" id="cb97-3" data-line-number="3">                          <span class="dt">y =</span> gdpPercap))</a>
<a class="sourceLine" id="cb97-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>() </a></code></pre>
<p>Something has gone wrong. What happened? While ggplot will make a
pretty good guess as to the structure of the data, it does not know
that the yearly observations in the data are grouped by country. We
have to tell it. Because we have not, <code>geom_line()</code> gamely tries to
join up all the lines for each particular year in the order they
appear in the dataset, as promised. It starts with an observation for
1952 in the first row of the data. It doesn’t know this belongs to
Afghanistan. Instead of going to Afghanistan 1953, it finds there are
a series of 1952 observations, so it joins all of those up first,
alphabetically by country, all the way down to the 1952 observation
that belongs to Zimbabwe. Then it moves to the first observation in
the next year, 1957.<label for="tufte-mn-45" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-45" class="margin-toggle"/><span class="marginnote shownote">This would have worked if there
were only one country in the dataset.</span></p>
<p>The result is meaningless when plotted. Bizarre-looking output in
ggplot is common enough, because everyone works out their plots one
bit at a time, and making mistakes is just a feature of puzzling out
how you want the plot to look. When ggplot successfully makes a plot
but the result looks insane, the reason is almost always that
something has gone wrong in the mapping between the data and
aesthetics for the geom being used. This is so common there’s even
a <a href="https://twitter.com/accidental__art">Twitter account</a> devoted to
the “Accidental aRt” that results. So don’t despair!</p>
<p>In this case, we can use the <code>group</code> aesthetic to tell ggplot
explicitly about this country-level structure.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gapminder-02"/>
<img src="../Images/96c7456a2639085700e54274b64c86cc.png" alt="Plotting the data over time by country, again." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gapminder-02-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.2: Plotting the data over time by country, again.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb98-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gapminder,</a>
<a class="sourceLine" id="cb98-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year,</a>
<a class="sourceLine" id="cb98-3" data-line-number="3">                          <span class="dt">y =</span> gdpPercap))</a>
<a class="sourceLine" id="cb98-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">group=</span>country)) </a></code></pre>
<p>The plot here is still fairly rough, but it is showing the data
properly, with each line representing the trajectory of a country over
time. The gigantic outlier is Kuwait, in case you are interested.</p>
<p>The <code>group</code> aesthetic is usually only needed when the grouping
information you need to tell ggplot about is not built-in to the
variables being mapped. For example, when we were plotting the points by
continent, mapping <code>color</code> to <code>continent</code> was enough to get the right
answer, because <code>continent</code> is already a categorical variable, so the
grouping is clear. When mapping the <code>x</code> to <code>year</code>, however, there is
no information in the <code>year</code> variable itself to let ggplot know that
it is grouped by country for the purposes of drawing lines with it. So
we need to say that explicitly.</p>
</div>
<div id="facet-to-make-small-multiples" class="section level2">
<h2><span class="header-section-number">4.3</span> Facet to make small multiples</h2>
<p>The plot we just made has a lot of lines on it. While the overall
trend is more or less clear, it looks a little messy. One option is to
<em>facet</em> the data by some third variable, making a “small multiple”
plot. This is a very powerful technique that allows a lot of
information to be presented compactly, and in a consistently
comparable way. A separate panel is drawn for each value of the
faceting variable. Facets are not a geom, but rather a way of
organizing a series of geoms. In this case we have the <code>continent</code>
variable available to us. We will use <code>facet_wrap()</code> to split our plot
by <code>continent</code>.</p>
<p>The <code>facet_wrap()</code> function can take a series of arguments, but the
most important is the first one, which is specified using R’s
“formula” syntax, which uses the tilde character, <code>~</code>. Facets are
usually a one-sided formula. Most of the time you will just want a
single variable on the right side of the formula. But faceting is
powerful enough to accommodate what are in effect the graphical
equivalent of multi-way contingency tables, if your data is complex
enough to require that. For our first example, we will just use a
single term in our formula, which is the variable we want the data
broken up by: <code>facet_wrap(~ continent)</code>.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gapminder-03"/>
<img src="../Images/dca4514d8ec42a6f9aabcba51b2de069.png" alt="Faceting by continent." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gapminder-03-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.3: Faceting by continent.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb99-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gapminder,</a>
<a class="sourceLine" id="cb99-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year,</a>
<a class="sourceLine" id="cb99-3" data-line-number="3">                          <span class="dt">y =</span> gdpPercap))</a>
<a class="sourceLine" id="cb99-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">group =</span> country)) <span class="op">+</span><span class="st"> </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>continent)</a></code></pre>
<p>Each facet is labeled at the top. The overall layout minimizes the
duplication of axis labels and other scales. Remember, too that we can
still include other geoms as before, and they will be layered within
each facet. We can also use the <code>ncol</code> argument to <code>facet_wrap()</code> to
control the number of columns used to lay out the facets. Because we
have only five continents it might be worth seeing if we can fit them
on a single row (which means we’ll have five columns). In addition, we
can add a smoother, and a few cosmetic enhancements that make the
graph a little more effective. In particular we will make the country
trends a light gray color. We need to write a little more code to make
all this happen. If you are unsure of what each piece of code does,
take advantage of ggplot’s additive character. Working backwards from
the bottom up, remove each <code>+ some_function(...)</code> statement one at a
time to see how the plot changes.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb100-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gapminder, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year, <span class="dt">y =</span> gdpPercap))</a>
<a class="sourceLine" id="cb100-2" data-line-number="2">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>(<span class="dt">color=</span><span class="st">"gray70"</span>, <span class="kw">aes</span>(<span class="dt">group =</span> country)) <span class="op">+</span></a>
<a class="sourceLine" id="cb100-3" data-line-number="3"><span class="st">    </span><span class="kw">geom_smooth</span>(<span class="dt">size =</span> <span class="fl">1.1</span>, <span class="dt">method =</span> <span class="st">"loess"</span>, <span class="dt">se =</span> <span class="ot">FALSE</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb100-4" data-line-number="4"><span class="st">    </span><span class="kw">scale_y_log10</span>(<span class="dt">labels=</span>scales<span class="op">::</span>dollar) <span class="op">+</span></a>
<a class="sourceLine" id="cb100-5" data-line-number="5"><span class="st">    </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>continent, <span class="dt">ncol =</span> <span class="dv">5</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb100-6" data-line-number="6"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">"Year"</span>,</a>
<a class="sourceLine" id="cb100-7" data-line-number="7">         <span class="dt">y =</span> <span class="st">"GDP per capita"</span>,</a>
<a class="sourceLine" id="cb100-8" data-line-number="8">         <span class="dt">title =</span> <span class="st">"GDP per capita on Five Continents"</span>)</a></code></pre>
<div class="figure fullwidth"><span id="fig:ch-04-gapminder-04"/>
<img src="../Images/ef23f240e741e69c5821cbffcd49744d.png" alt="Faceting by continent, again." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gapminder-04-1.png"/>
<p class="caption marginnote shownote">
Figure 4.4: Faceting by continent, again.
</p>
</div>
<p>This plot<label for="tufte-mn-46" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-46" class="margin-toggle"/><span class="marginnote shownote">We could also have faceted by country, which would have made the group mapping superfluous. But that would make almost a hundred and fifty panels.</span> brings together an aesthetic mapping of <code>x</code> and <code>y</code> variables, a grouping aesthetic (<code>country</code>), two geoms (a lineplot and a smoother), a log-transformed y-axis with appropriate tick labels, a faceting variable (<code>continent</code>), and finally axis labels and a title.</p>
<p>The <code>facet_wrap()</code> function is best used when you want a series of
small multiples based on a single categorical variable. Your panels
will be laid out in order and then wrapped into a grid. If you wish
you can specify the number or rows or the number of columns in the
resulting layout. Facets can be more complex than this. For instance,
you might want to cross-classify some data by two categorical
variables. In that case you should try <code>facet_grid()</code> instead. This
function will lay out your plot in a true two-dimensional arrangement,
instead of a series of panels wrapped into a grid.</p>
<p>To see the difference, let’s introduce <code>gss_sm</code>, a new dataset that we will use in the next few sections, as well as later on in the book. It is a small subset of the questions from the 2016 General Social Survey, or GSS. The GSS is a long-running survey of American adults that asks about a range of topics of interest to social scientists.<label for="tufte-mn-47" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-47" class="margin-toggle"/><span class="marginnote shownote">To begin with, we will use the GSS data in a slightly naive way. In particular we will not consider sample weights when making the figures in this chapter. In Chapter 6 we will learn how to calculate frequencies and other statistics from data with a complex or weighted survey design.</span> The <code>gapminder</code> data consists mostly of <em>continuous</em> variables measured within countries by year. Measures like GDP per capita can take any value across a large range and they vary smoothly. The only <em>categorical</em> grouping variable is <code>continent</code>. It is an unordered categorical variable. Each country belongs to one continent, but the continents themselves have no natural ordering.</p>
<p>In social scientific work, especially when analyzing individual-level survey data, we very often work with categorical data of various kinds. Sometimes the categories are unordered, as with ethnicity or sex. But they may also be ordered, as when me measure highest level of education attained on a scale ranging from elementary school to postgraduate degree. Opinion questions may be asked in yes-or-no terms, or on a five or seven point scale with a neutral value in the middle. Meanwhile, many numeric measures, such as number of children, may still only take integer values within a relatively narrow range. In practice these too may be treated as ordered categorical variables running from zero to some top-coded value such as “Six or more”. Even properly continuous measures, such as income, are rarely reported to the dollar and are often only obtainable as ordered categories. The GSS data in <code>gss_sm</code> contains many measures of this sort. You can take a peek at it, as usual, by typing its name at the console. You could also try <code>glimpse(gss_sm)</code>, which will give a very compact summary of all the variables in the data.</p>
<p>We will make a smoothed scatterplot of the relationship between the
age of the respondent and the number of children they have. In
<code>gss_sm</code> the <code>childs</code> variable is a numeric count of the respondent’s
children. (There is also a variable named <code>kids</code> that is the same
measure, but its class is an ordered factor rather than a number.) We
will then facet this relationship by sex and race of the respondent. We
use R’s formula notation in the <code>facet_grid</code> function to facet sex and
race. This time, because we are cross-classifying our results, the formula is two-sided: <code>facet_grid(sex ~ race)</code>.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb101-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb101-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> age, <span class="dt">y =</span> childs))</a>
<a class="sourceLine" id="cb101-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">alpha =</span> <span class="fl">0.2</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb101-4" data-line-number="4"><span class="st">    </span><span class="kw">geom_smooth</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb101-5" data-line-number="5"><span class="st">    </span><span class="kw">facet_grid</span>(sex <span class="op">~</span><span class="st"> </span>race)</a></code></pre>
<div class="figure"><span id="fig:ch-04-gss-01"/>
<p class="caption marginnote shownote">
Figure 4.5: Faceting on two categorical variables. Each panel plots the relationship between age and number of children, with the facets breaking out the data by sex (in the rows) and race (in the columns).
</p>
<img src="../Images/1f460868c6045f5292cdf1c6e2d517e0.png" alt="Faceting on two categorical variables. Each panel plots the relationship between age and number of children, with the facets breaking out the data by sex (in the rows) and race (in the columns)." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-01-1.png"/>
</div>
<p>Multi-panel layouts of this kind are especially effective when used to
summarize continuous variation (as in a scatterplot) across two or
more categorical variables, with the categories (and hence the panels)
ordered in some sensible way. We are not limited to two-way
comparison. Further categorical variables can be added to the formula,
too, (e.g. <code>sex ~ race + degree</code>) for more complex multi-way plots.
However, the multiple dimensions of plots like this will become very
complicated very quickly if the variables have more than a few
categories each.</p>
</div>
<div id="statfunctions" class="section level2">
<h2><span class="header-section-number">4.4</span> Geoms can transform data</h2>
<p>We have already seen several examples where <code>geom_smooth()</code> was
included as a way to add a trend line to the figure. Sometimes we
plotted a LOESS line, sometimes a straight line from an OLS
regression, and sometimes the result of a Generalized Additive Model. We did not have to have any strong idea of the differences between these methods. Neither did
we have to write any code to specify the underlying models, beyond
telling the <code>method</code> argument in <code>geom_smooth()</code> which one we wanted
to use. The <code>geom_smooth()</code> function did the rest.</p>
<p>Thus, some geoms plot our data directly on the figure, as is
the case with <code>geom_point()</code>, which takes variables designated as <code>x</code>
and <code>y</code> and plots the points on a grid. But other geoms clearly do
more work on the data before it gets plotted.<label for="tufte-mn-48" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-48" class="margin-toggle"/><span class="marginnote shownote">Try <code>p +
stat_smooth()</code>, for example.</span> Every <code>geom_</code> function has an
associated <code>stat_</code> function that it uses by default. The reverse is
also the case: every <code>stat_</code> function has an associated <code>geom_</code>
function that it will plot by default if you ask it to. This is not
particularly important to know by itself, but as we will see in the
next section, we sometimes want to calculate a different statistic
for the geom from the default.</p>
<p>Sometimes the calculations being done by the <code>stat_</code> functions that
work together with the <code>geom_</code> functions might not be immediately
obvious. For example, consider this figure produced by a new geom,
<code>geom_bar()</code>.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gss-02"/>
<img src="../Images/43146b8d2717e9fa73fca324ab1d9701.png" alt="A bar chart." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-02-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.6: A bar chart.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb102-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb102-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> bigregion))</a>
<a class="sourceLine" id="cb102-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>()</a></code></pre>
<p>Here we specified just one mapping, <code>aes(x = bigregion)</code>. The bar chart produced gives us a count of the number of (individual) observations in the data set by region of the United States. This seems sensible. But there is a y-axis variable here, <code>count</code>, that is not in the data. It has been calculated for us. Behind the scenes, <code>geom_bar</code> called the default <code>stat_</code> function associated with it, <code>stat_count()</code>. This function computes two new variables, <code>count</code>, and <code>prop</code> (short for proportion). The <code>count</code> statistic is the one <code>geom_bar()</code> uses by default.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gss-03"/>
<img src="../Images/d895e729bfd30955cff742f410fc027e.png" alt="A first go at a bar chart with proportions." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-03-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.7: A first go at a bar chart with proportions.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb103-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb103-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> bigregion))</a>
<a class="sourceLine" id="cb103-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">y =</span> ..prop..))</a></code></pre>
<p>If we want a chart of relative frequencies rather than counts, we will
need to get the <code>prop</code> statistic instead. When ggplot calculates the
count or the proportion, it returns temporary variables that we can
use as mappings in our plots. The relevant statistic is called
<code>..prop..</code> rather than <code>prop</code>. To make sure these temporary variables
won’t be confused with others we are working with, their names begin
and end with two periods. (This is because we might already have a variable called
<code>count</code> or <code>prop</code> in our dataset.) So our calls to it from the <code>aes()</code>
function will generically look like this: <code>&lt;mapping&gt; = &lt;..statistic..&gt;</code>. In this case, we want <code>y</code> to use the calculated
proportion, so we say <code>aes(y = ..prop..)</code>.</p>
<p>The resulting plot is still not right. We no longer have a count on
the y-axis, but the proportions of the bars all have a value of 1, so
all the bars are the same height. We want them to <em>sum</em> to 1, so that
we get the number of observations per continent as a proportion of the
total number of observations. This is a grouping issue again. In a
sense, it’s the reverse of the earlier grouping problem we faced when
we needed to tell ggplot that our yearly data was grouped by country.
In this case, we need to tell ggplot to <em>ignore</em> the x-categories when
calculating denominator of the proportion, and use the total number
observations instead. To do so we specify <code>group = 1</code> inside the
<code>aes()</code> call. The value of <code>1</code> is just a kind of “dummy group” that
tells ggplot to use the whole dataset when establishing the
denominator for its <code>prop</code> calculations.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gss-04"/>
<img src="../Images/d442715fd8354e2e5dffe326391aa143.png" alt="A bar chart with correct proportions." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-04-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.8: A bar chart with correct proportions.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb104-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb104-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> bigregion))</a>
<a class="sourceLine" id="cb104-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">y =</span> ..prop.., <span class="dt">group =</span> <span class="dv">1</span>)) </a></code></pre>
<p>Let’s look at another question from the survey. The <code>gss_sm</code> data contains a <code>religion</code> variable derived from a question asking “What is your religious preference? Is it Protestant, Catholic, Jewish, some other religion, or no religion?”</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb105-1" data-line-number="1"><span class="kw">table</span>(gss_sm<span class="op">$</span>religion)</a></code></pre>
<pre><code>## 
## Protestant   Catholic     Jewish       None      Other 
##       1371        649         51        619        159</code></pre>
<p>To<label for="tufte-mn-49" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-49" class="margin-toggle"/><span class="marginnote shownote">Recall that the <code>$</code> character is one way of accessing individual columns within a data frame or tibble.</span> graph this, we want a bar chart with <code>religion</code> on the x axis (as a
categorical variable), and with the bars in the chart also colored by
<code>religion</code>. If the gray bars look boring and we want to fill them with color instead, we can map the <code>religion</code> variable to <code>fill</code> in addition to mapping it to <code>x</code>. Remember, <code>fill</code> is for painting the insides of shapes. If we map religion to <code>color</code>, only the border lines of the bars will be assigned colors, and the insides will remain gray.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb107-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb107-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> religion, <span class="dt">color =</span> religion))</a>
<a class="sourceLine" id="cb107-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>()</a>
<a class="sourceLine" id="cb107-4" data-line-number="4"/>
<a class="sourceLine" id="cb107-5" data-line-number="5">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb107-6" data-line-number="6">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> religion, <span class="dt">fill =</span> religion))</a>
<a class="sourceLine" id="cb107-7" data-line-number="7">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>() <span class="op">+</span><span class="st"> </span><span class="kw">guides</span>(<span class="dt">fill =</span> <span class="ot">FALSE</span>) </a></code></pre>
<div class="figure"><span id="fig:ch-04-gss-05"/>
<p class="caption marginnote shownote">
Figure 4.9: GSS Religious Preference mapped to color (left) and both color and fill (right).
</p>
<img src="../Images/e1f8eb224fc0ea1a1e230d212dc6b3de.png" alt="GSS Religious Preference mapped to color (left) and both color and fill (right)." width="50%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-05-1.png"/><img src="../Images/0e14eabd1fe63de92809da7f35e9fa61.png" alt="GSS Religious Preference mapped to color (left) and both color and fill (right)." width="50%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-05-2.png"/>
</div>
<p>By doing this, we have mapped two aesthetics to the same variable.
Both <code>x</code> and <code>fill</code> are mapped to <code>religion</code>. There is nothing wrong
with this. However, these are still two separate
mappings, and so they get two separate scales. The default is to show a legend for the color variable. This legend is redundant, because the categories of
<code>religion</code> are already separated out on the x-axis. In its simplest
use, the <code>guides()</code> function controls whether guiding information
about any particular mapping appears or not. If we set <code>guides(fill = FALSE)</code>, the legend is removed, in effect saying that the viewer of
the figure does not need to be shown any guiding information about
this mapping. Setting the guide for some mapping to <code>FALSE</code> only has
an effect if there is a legend to turn off to begin with. Trying <code>x = FALSE</code> or <code>y = FALSE</code> will have no effect, as these mappings have no
additional guides or legends separate from their scales. It is
possible to turn the x and y scales off altogether, but this is done
though a different function, one from the <code>scale_</code> family.</p>
</div>
<div id="frequency-plots-the-slightly-awkward-way" class="section level2">
<h2><span class="header-section-number">4.5</span> Frequency plots the slightly awkward way</h2>
<p>A more appropriate use of the <code>fill</code> aesthetic with <code>geom_bar()</code> is to
cross-classify two categorical variables. This is the graphical
equivalent of a frequency table of counts or proportions. Using the
GSS data, for instance, we might want to examine the distribution of
religious preferences within different regions of the United States.
In the next few paragraphs we will see how to do this just using
ggplot. However, as we shall also discover, it is often not the most
transparent way to make frequency tables of this sort. The next
chapter introduces a simpler and less error-prone approach where we
calculate the table first before passing the results along to ggplot
to graph. As you work through this section, bear in mind that if you
find things slightly awkward or confusing it is because that’s exactly
what they are.</p>
<p>Let’s say we want to look at religious preference by census region.
That is, we want the <code>religion</code> variable broken down proportionally
within <code>bigregion</code>. When we cross-classify categories in bar charts,
there are several ways to display the results. With <code>geom_bar()</code> the
output is controlled by the <code>position</code> argument. Let’s begin by
mapping <code>fill</code> to <code>religion</code>.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gss-06"/>
<img src="../Images/e414ea7d060124909f69fd5b85452631.png" alt="A stacked bar chart of Religious Preference by Census Region." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-06-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.10: A stacked bar chart of Religious Preference by Census Region.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb108-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb108-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> bigregion, <span class="dt">fill =</span> religion))</a>
<a class="sourceLine" id="cb108-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>()</a></code></pre>
<p>The default output of <code>geom_bar()</code> is a stacked bar chart, with counts
on the y-axis (and hence counts within the stacked segments of the
bars also). Region of the country is on the x-axis, and counts of
religious preference are stacked within the bars. As we saw in Chapter <a href="lookatdata.html#lookatdata">1</a>,
it is somewhat difficult for readers of the chart to compare lengths
an areas on an unaligned scale. So while the relative position of the
bottom categories are quite clear (thanks to them all being aligned on
the x-axis), the relative positions of say, the “Catholic” category is
harder to assess. An alternative choice is to set the <code>position</code>
argument to <code>"fill"</code>. (This is different from the <code>fill</code>
aesthetic.)</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gss-06A"/>
<img src="../Images/73484330223ad56919c8ece2f1c08d48.png" alt="Using the fill position adjustment to show relative proportions across categories." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-06A-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.11: Using the fill position adjustment to show relative proportions across categories.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb109-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb109-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> bigregion, <span class="dt">fill =</span> religion))</a>
<a class="sourceLine" id="cb109-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>(<span class="dt">position =</span> <span class="st">"fill"</span>)</a></code></pre>
<p>Now the bars are all the same height, which makes it easier to compare
proportions across groups. But we lose the ability to see the relative
size of each cut with respect to the overall total. What if we wanted
to show the proportion or percentage of religions within regions of
the country, like in Figure <a href="groupfacettx.html#fig:ch-04-gss-06A">4.11</a>, but instead of
stacking the bars we wanted separate bars instead? As a first attempt, we
can use <code>position="dodge"</code> to make the bars within each region of the
country appear side by side. However, if we do it this way (try it),
we will find that ggplot places the bars side-by-side as intended, but
changes the y-axis back to a <em>count</em> of cases within each category
rather than showing us a proportion. We saw in Figure
<a href="groupfacettx.html#fig:ch-04-gss-04">4.8</a> that to display a proportion we needed to map
<code>y = ..prop..</code>, so the correct statistic would be calculated. Let’s
see if that works.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gss-07"/>
<img src="../Images/122f0ae3696aefaeec2a9fbe35080d45.png" alt="A first go at a dodged bar chart with proportional bars." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-07-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.12: A first go at a dodged bar chart with proportional bars.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb110-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb110-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> bigregion, <span class="dt">fill =</span> religion))</a>
<a class="sourceLine" id="cb110-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>(<span class="dt">position =</span> <span class="st">"dodge"</span>,</a>
<a class="sourceLine" id="cb110-4" data-line-number="4">             <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">y =</span> ..prop..))</a></code></pre>
<p>The result is certainly colorful, but not what we wanted.
Just as in Figure <a href="groupfacettx.html#fig:ch-04-gss-03">4.7</a>, there seems to be an
issue with the grouping. When we just wanted the overall proportions
for one variable, we mapped <code>group = 1</code> to tell ggplot to calculate
the proportions with respect to the overall N. In this case our
grouping variable is <code>religion</code>, so we might try mapping that to the
<code>group</code> aesthetic.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb111-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb111-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> bigregion, <span class="dt">fill =</span> religion))</a>
<a class="sourceLine" id="cb111-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>(<span class="dt">position =</span> <span class="st">"dodge"</span>,</a>
<a class="sourceLine" id="cb111-4" data-line-number="4">             <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">y =</span> ..prop.., <span class="dt">group =</span> religion))</a></code></pre>
<p>This gives us a bar chart where the values of <code>religion</code> are broken
down across regions, with a proportion showing on the y-axis. If you
inspect the bars in Figure <a href="groupfacettx.html#fig:ch-04-gss-08">4.13</a>, you will
see that they do not sum to one within each region. Instead, the bars
for any particular religion sum to one <em>across</em> regions.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gss-08"/>
<img src="../Images/62ddd4c886912aa5429cf43d7e0aaaee.png" alt="A second attempt at a dodged bar chart with proportional bars." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-08-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.13: A second attempt at a dodged bar chart with proportional bars.<!--</p>-->
<!--</div>--></span>
</p>
<p>This lets us see that nearly half of those who said they were Protestant live in the South, for example. Meanwhile, just over ten percent of those saying they were Protestant live in the Northeast. Similarly, it shows that over half of those saying they were Jewish live in the Northeast, compared to about a quarter who live in the South.<label for="tufte-mn-50" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-50" class="margin-toggle"/><span class="marginnote shownote">Proportions for smaller sub-populations tend to bounce around from year to year in the GSS.</span></p>
<p>We are still not quite where we originally wanted to be. Our goal was to take the stacked bar chart in Figure <a href="groupfacettx.html#fig:ch-04-gss-06">4.10</a> but have the proportions shown side-by-side instead of on top of one another.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb112-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb112-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> religion))</a>
<a class="sourceLine" id="cb112-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>(<span class="dt">position =</span> <span class="st">"dodge"</span>,</a>
<a class="sourceLine" id="cb112-4" data-line-number="4">             <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">y =</span> ..prop.., <span class="dt">group =</span> bigregion)) <span class="op">+</span></a>
<a class="sourceLine" id="cb112-5" data-line-number="5"><span class="st">    </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>bigregion, <span class="dt">ncol =</span> <span class="dv">1</span>)</a></code></pre>
<p>It turns out that the easiest thing to do is to stop trying to force <code>geom_bar()</code> to do all the work in a single step. Instead, we can ask ggplot to give us a proportional bar chart of religious affiliation, and then facet that by region. The proportions are calculated within each panel, which is the breakdown we wanted. This has the added advantage of not producing too many bars within each category.</p>
<div class="figure"><span id="fig:ch-04-gss-09"/>
<p class="caption marginnote shownote">
Figure 4.14: Faceting proportions within region.
</p>
<img src="../Images/d67901facd927e98d4056ebe5e2ff2aa.png" alt="Faceting proportions within region." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-09-1.png"/>
</div>
<p>We could polish this plot further, but for the moment we will stop here. When constructing frequency plots directly in ggplot, it is a little too easy to get stuck in a cycle of not quite getting the marginal comparison that you want, and more or less randomly poking at the mappings to try to stumble on the the right breakdown. In the next Chapter, we will learn how to use the tidyverse’s <code>dplyr</code> library to produce the tables we want <em>before</em> we try to plot them. This is a more reliable approach, and easier to check for errors. It will also give us tools that can be used for many more tasks than producing summaries.</p>
</div>
<div id="histograms" class="section level2">
<h2><span class="header-section-number">4.6</span> Histograms and density plots</h2>
<p>Different geoms transform data in different ways, but ggplot’s vocabulary for them is consistent. We can see similar transformations at work when summarizing a continuous variable using a histogram, for example. A histogram is a way of summarizing a continuous variable by chopping it up into segments or “bins” and counting how many observations are found within each bin. In a bar chart, the categories are given to us going in (e.g., regions of the country, or religious affiliation). With a histogram, we have to decide how finely to bin the data.</p>
<p>For example, ggplot comes with a dataset, <code>midwest</code>, containing information on counties in several midwestern states of the USA. Counties vary in size, so we can make a histogram showing the distribution of their geographical areas. Area is measured in square miles. Because we are summarizing a continuous variable using a series of bars, we need to divide the observations into groups, or bins, and count how many are in each one. By default, the <code>geom_histogram()</code> function will choose a bin size for us based on a rule of thumb.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb113-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> midwest,</a>
<a class="sourceLine" id="cb113-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> area))</a>
<a class="sourceLine" id="cb113-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_histogram</span>()</a></code></pre>
<pre><code>## `stat_bin()` using `bins = 30`. Pick better value with
## `binwidth`.</code></pre>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb115-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> midwest,</a>
<a class="sourceLine" id="cb115-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> area))</a>
<a class="sourceLine" id="cb115-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_histogram</span>(<span class="dt">bins =</span> <span class="dv">10</span>)</a></code></pre>
<div class="figure"><span id="fig:ch-04-midwest-01"/>
<p class="caption marginnote shownote">
Figure 4.15: Histograms of the same variable, using different numbers of bins.
</p>
<img src="../Images/1d7fb516aa00dbbe85f20728243a9b60.png" alt="Histograms of the same variable, using different numbers of bins." width="50%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-midwest-01-1.png"/><img src="../Images/afaa4400507757217c75298e5fc5791f.png" alt="Histograms of the same variable, using different numbers of bins." width="50%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-midwest-01-2.png"/>
</div>
<p>As with the bar charts, a newly-calculated variable, <code>count</code>, appears on the x-axis. The notification from R tells us that behind the scenes the <code>stat_bin()</code> function picked 30 bins, but we might want to try something else. When drawing histograms it is worth experimenting with <code>bins</code> and also optionally the <code>origin</code> of the x-axis. Each, and
especially <code>bins</code>, will make a big difference to how the resulting
figure looks.</p>
<p>While histograms summarize single variables, it’s also possible to use
several at once to compare distributions. We can facet histograms by
some variable of interest, or as here we can compare them in the
same plot using the <code>fill</code> mapping.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-midwest-02"/>
<img src="../Images/f1dd80bb96810898efdb7d0e6eed506a.png" alt="Comparing two histograms." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-midwest-02-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.16: Comparing two histograms.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb116-1" data-line-number="1">oh_wi &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"OH"</span>, <span class="st">"WI"</span>)</a>
<a class="sourceLine" id="cb116-2" data-line-number="2"/>
<a class="sourceLine" id="cb116-3" data-line-number="3">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> <span class="kw">subset</span>(midwest, <span class="dt">subset =</span> state <span class="op">%in%</span><span class="st"> </span>oh_wi),</a>
<a class="sourceLine" id="cb116-4" data-line-number="4">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> percollege, <span class="dt">fill =</span> state))</a>
<a class="sourceLine" id="cb116-5" data-line-number="5">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_histogram</span>(<span class="dt">alpha =</span> <span class="fl">0.4</span>, <span class="dt">bins =</span> <span class="dv">20</span>)</a></code></pre>
<p>We subset the data here to pick out just two states. To do this we
create a character vector with just two elements, “OH” and “WI”. Then
we use the <code>subset()</code> function to take our data and filter it so that
we only select rows whose <code>state</code> name is in this vector. The <code>%in%</code>
operator is a convenient way to filter on more than one term in a
variable when using <code>subset()</code>.</p>
<p>When working with a continuous variable, an alternative to binning the
data and making a histogram is to calculate a kernel density estimate
of the underlying distribution. The <code>geom_density()</code> function will do
this for us.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-midwest-03"/>
<img src="../Images/d0c2f356c27a2ba25016e64519992e3f.png" alt="Kernel density estimate of county areas." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-midwest-03-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.17: Kernel density estimate of county areas.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb117-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> midwest,</a>
<a class="sourceLine" id="cb117-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> area))</a>
<a class="sourceLine" id="cb117-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_density</span>()</a></code></pre>
<p>We can use <code>color</code> (for the lines) and <code>fill</code> (for the body of the
density curve) here, too. These figures often look quite nice.
But when there are several filled areas on the plot, as in this
case, the overlap can become hard to read. If you want to make the
baselines of the density curves go away, you can use <code>geom_line(stat = "density")</code> instead. This also removes the possibility of using the
<code>fill</code> aesthetic. But this may be an improvement in some cases. Try it
with the plot of state areas and see how they compare.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb118-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> midwest,</a>
<a class="sourceLine" id="cb118-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> area, <span class="dt">fill =</span> state, <span class="dt">color =</span> state))</a>
<a class="sourceLine" id="cb118-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_density</span>(<span class="dt">alpha =</span> <span class="fl">0.3</span>)</a></code></pre>
<div class="figure"><span id="fig:ch-04-midwest-04"/>
<p class="caption marginnote shownote">
Figure 4.18: Comparing distributions.
</p>
<img src="../Images/65ad622a4337f78bd834678e61fc0eee.png" alt="Comparing distributions." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-midwest-04-1.png"/>
</div>
<p>Just like <code>geom_bar()</code>, the count-based defaults computed by the
<code>stat_</code> functions used by <code>geom_histogram()</code> and <code>geom_density()</code> will
return proportional measures if we ask them. For <code>geom_density()</code>, the
<code>stat_density()</code> function can return its default <code>..density..</code>
statistic, or <code>..scaled..</code>, which will give a proportional density
estimate. It can also return a statistic called <code>..count..</code>, which is
the density times the number of points. This can be used in stacked
density plots.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-midwest-05"/>
<img src="../Images/170a065023026a8f463517a53b7c2297.png" alt="Scaled densities." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-midwest-05-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.19: Scaled densities.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb119-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> <span class="kw">subset</span>(midwest, <span class="dt">subset =</span> state <span class="op">%in%</span><span class="st"> </span>oh_wi),</a>
<a class="sourceLine" id="cb119-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> area, <span class="dt">fill =</span> state, <span class="dt">color =</span> state))</a>
<a class="sourceLine" id="cb119-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_density</span>(<span class="dt">alpha =</span> <span class="fl">0.3</span>, <span class="dt">mapping =</span> (<span class="kw">aes</span>(<span class="dt">y =</span> ..scaled..)))</a></code></pre>
</div>
<div id="avoid-transformations-when-necessary" class="section level2">
<h2><span class="header-section-number">4.7</span> Avoid transformations when necessary</h2>
<p>As we have seen from the beginning, ggplot normally makes its charts
starting from a full dataset. When we call <code>geom_bar()</code> it does its
calculations on the fly using <code>stat_count()</code> behind the scenes to
produce the counts or proportions it displays. In the previous
section, we looked at a case where we wanted to group and aggregate
our data ourselves before handing it off to ggplot. But often, our
data is in effect <em>already</em> a summary table. This can happen when we
have computed a table of marginal frequencies or percentages from our
original data already. Plotting results from statistical models also
puts us in this position, as we will see later. Or it may be that we
just have a finished table of data (from the Census, say, or an
official report) that we want to make into a graph. For example,
perhaps we do not have the individual-level data on who survived the
<em>Titanic</em> disaster, but we do have a small table of counts of
survivors by sex:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb120-1" data-line-number="1">titanic</a></code></pre>
<pre><code>##       fate    sex    n percent
## 1 perished   male 1364    62.0
## 2 perished female  126     5.7
## 3 survived   male  367    16.7
## 4 survived female  344    15.6</code></pre>
<p>Because we are working directly with percentage values in a summary
table, we no longer have any need for ggplot to count up values for us
or perform any other calculations. That is, we do not need the
services of any <code>stat_</code> functions that <code>geom_bar()</code> would normally
call. We can tell <code>geom_bar()</code> not to do any work on the variable
before plotting it. To do this we say <code>stat = 'identity'</code> in the
<code>geom_bar()</code> call. We’ll also move the legend to the top of the chart.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-titanic-01"/>
<img src="../Images/771b705af5b3db7232da929fdd911d8f.png" alt="Survival on the Titanic, by Sex." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-titanic-01-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.20: Survival on the Titanic, by Sex.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb122-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> titanic,</a>
<a class="sourceLine" id="cb122-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> fate, <span class="dt">y =</span> percent, <span class="dt">fill =</span> sex))</a>
<a class="sourceLine" id="cb122-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>(<span class="dt">position =</span> <span class="st">"dodge"</span>, <span class="dt">stat =</span> <span class="st">"identity"</span>) <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
<p>For convenience ggplot also provides a related geom, <code>geom_col()</code>,
which has exactly the same effect but assumes that <code>stat = "identity"</code>. We will use this form in future when we don’t need any calculations done on the plot.</p>
<p>The <code>position</code> argument in <code>geom_bar()</code> and <code>geom_col()</code> can also take the value of <code>"identity"</code>. Just as <code>stat = "identity"</code> means “don’t do any summary calculations”, <code>position = "identity"</code> means “just plot the values as given”. This allows us to do things like, for example, plot a flow of positive and negative values in a bar chart. This sort of graph is an alternative to a line plot and is often seen in public policy settings where changes relative to some threshold level or baseline are of interest. For example, the <code>oecd_sum</code> table in <code>socviz</code> contains information on average life expectancy at birth within the United States, and across other OECD countries.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb123-1" data-line-number="1">oecd_sum</a></code></pre>
<pre><code>## # A tibble: 57 x 5
## # Groups:   year [57]
##     year other   usa  diff hi_lo
##    &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;
##  1  1960  68.6  69.9 1.30  Below
##  2  1961  69.2  70.4 1.20  Below
##  3  1962  68.9  70.2 1.30  Below
##  4  1963  69.1  70.0 0.900 Below
##  5  1964  69.5  70.3 0.800 Below
##  6  1965  69.6  70.3 0.700 Below
##  7  1966  69.9  70.3 0.400 Below
##  8  1967  70.1  70.7 0.600 Below
##  9  1968  70.1  70.4 0.300 Below
## 10  1969  70.1  70.6 0.500 Below
## # ... with 47 more rows</code></pre>
<p>The <code>other</code> column is the average life expectancy in a given year for OECD countries, excluding the United States. The <code>usa</code> column is the US life expectancy, <code>diff</code> is the difference between the two values, and <code>hi_lo</code> indicates whether the US value for that year was above or below the OECD average. We will plot the difference over time, and use the <code>hi_lo</code> variable to color the columns in the chart.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb125-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> oecd_sum,</a>
<a class="sourceLine" id="cb125-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year, <span class="dt">y =</span> diff, <span class="dt">fill =</span> hi_lo))</a>
<a class="sourceLine" id="cb125-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_col</span>() <span class="op">+</span><span class="st"> </span><span class="kw">guides</span>(<span class="dt">fill =</span> <span class="ot">FALSE</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb125-4" data-line-number="4"><span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">"Difference in Years"</span>,</a>
<a class="sourceLine" id="cb125-5" data-line-number="5">       <span class="dt">title =</span> <span class="st">"The US Life Expectancy Gap"</span>,</a>
<a class="sourceLine" id="cb125-6" data-line-number="6">       <span class="dt">subtitle =</span> <span class="st">"Difference between US and OECD</span></a>
<a class="sourceLine" id="cb125-7" data-line-number="7"><span class="st">                   average life expectancies, 1960-2015"</span>,</a>
<a class="sourceLine" id="cb125-8" data-line-number="8">       <span class="dt">caption =</span> <span class="st">"Data: OECD. After a chart by Christopher Ingraham,</span></a>
<a class="sourceLine" id="cb125-9" data-line-number="9"><span class="st">                  Washington Post, December 27th 2017."</span>)</a></code></pre>
<div class="figure fullwidth"><span id="fig:ch-04-oecd-01"/>
<img src="../Images/06bcc4f1333270280d72e98d90d0a5dc.png" alt="Using &lt;code&gt;geom\_col()&lt;/code&gt; to plot negative and positive values in a bar chart." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-oecd-01-1.png"/>
<p class="caption marginnote shownote">
Figure 4.21: Using <code>geom_col()</code> to plot negative and positive values in a bar chart.
</p>
</div>
<p>As with the <code>titanic</code> plot, the default action of <code>geom_col()</code> is to set both <code>stat</code> and <code>position</code> to “<code>identity</code>”. To get the same effect with <code>geom_bar()</code> we would need to say <code>geom_bar(position = "identity")</code>. As before, the <code>guides(fill=FALSE)</code> instruction at the end tells ggplot to drop the unnecessary legend that would otherwise be automatically generated to accompany the <code>fill</code> mapping.</p>
<p>At this point, we have a pretty good sense of the core steps we must
take to visualize our data. In fact, thanks to ggplot’s default
settings, we now have the ability to make good-looking and informative
plots. Starting with a tidy dataset, we know how to map variables to
aesthetics, to choose from a variety of geoms, and make some
adjustments to the scales of the plot. We also know more about
selecting the right sort of computed statistic to show on the graph,
if that’s what’s needed, and how to facet our core plot by one or more
variables. We know how to set descriptive labels for axes, and write a
title, subtitle, and caption. Now we’re in a position to put these
skills to work in a more fluent way.</p>
</div>
<div id="where-to-go-next-3" class="section level2">
<h2><span class="header-section-number">4.8</span> Where to go next</h2>
<ul>
<li>Revisit the <code>gapminder</code> plots at the beginning of the chapter and experiment with different ways to facet the data. Try plotting population and per capita GDP while faceting on year, or even on country. In the latter case you will get a lot of panels, and plotting them straight to the screen may take a long time. Instead, assign the plot to an object and save it as a PDF file to your <code>figures/</code> folder. Experiment with the height and width of the figure.</li>
<li>Investigate the difference between a formula written as <code>facet_grid(sex ~ race)</code> versus one written as <code>facet_grid(~ sex + race)</code>.</li>
<li>Experiment to see what happens when you use <code>facet_wrap()</code> with more complex forumulas like <code>facet_wrap(~ sex + race)</code> instead of <code>facet_grid</code>. Like <code>facet_grid()</code>, the <code>facet_wrap()</code> function can facet on two or more variables at once. But it will do it by laying the results out in a wrapped one-dimensional table instead of a fully cross-classified grid.</li>
<li>Frequency polygons are closely related to histograms. Instead of displaying the count of observations using bars, they display it with a series of connected lines instead. You can try the various <code>geom_histogram()</code> calls in this chapter using <code>geom_freqpoly()</code> instead.</li>
<li>A histogram bins observations for one variable and shows a bars with the count in each bin. We can do this for two variables at once, too. The <code>geom_bin2d()</code> function takes two mappings, <code>x</code> and <code>y</code>. It divides your plot into a grid and colors the bins by the count of observations in them. Try using it on the <code>gapminder</code> data to plot life expectancy versus per capita GDP. Like a histogram, you can vary the number or width of the bins for both <code>x</code> or <code>y</code>. Instead of saying <code>bins = 30</code> or <code>binwidth = 1</code>, provide a number for both <code>x</code> and <code>y</code> with, for example, <code>bins = c(20, 50)</code>. If you specify <code>bindwith</code> instead, you will need to pick values that are on the same scale as the variable you are mapping.</li>
<li>Density estimates can also be drawn in two dimensions. The <code>geom_density_2d()</code> function draws contour lines estimating the joint distribution of two variables. Try it with the <code>midwest</code> data, for example, plotting percent below the poverty line (<code>percbelowpoverty</code>) against percent college-educated (<code>percollege</code>). Try it with and without a <code>geom_point()</code> layer.</li>
</ul>

</div>
&#13;

<h2><span class="header-section-number">4.1</span> Colorless green data sleeps furiously</h2>
<p>When you write ggplot code in R you are in effect trying to “say”
something visually. It usually takes several iterations to say exactly
what you mean. This is more than a metaphor here. The ggplot library is an
implementation of the “grammar” of graphics, an idea developed by
<span class="citation">Wilkinson (2005)</span>. The grammar is a set of rules for producing
graphics from data, taking pieces of data and mapping them to
geometric objects (like points and lines) that have aesthetic
attributes (like position, color and size), together with further
rules for transforming the data if needed (e.g. to a smoothed line),
adjusting scales (e.g. to a log scale),<label for="tufte-mn-44" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-44" class="margin-toggle"/><span class="marginnote shownote">We will see some alternatives to cartesian coordinates later.</span> and projecting the results onto a different coordinate system (usually cartesian).</p>
<p>A key point is that, like other rules of syntax, the grammar limits
the structure of what you can say, but it does not automatically make
what you say sensible or meaningful. It allows you to produce long
“sentences” that begin with mappings of data to visual elements and
add clauses about what sort of plot it is, how the axes are scaled,
and so on. But these sentences can easily be garbled. Sometimes your
code will not produce a plot at all because of some syntax error in R.
You will forget a <code>+</code> sign between <code>geom_</code> functions, or lose a
parenthesis somewhere so that your function statement becomes
unbalanced. In those cases R will complain (perhaps in an opaque way)
that something has gone wrong. At other times, your code will
successfully produce a plot, but it will not look the way you expected
it to. Sometimes the results will look very weird indeed. In those
cases, the chances are you have given ggplot a series of grammatically
correct instructions that are either nonsensical in some way, or have
accidentally twisted what you meant to say. These problems often arise
when ggplot does not have quite all the information it needs in order
make your graphic say what you want it to say.</p>
&#13;

<h2><span class="header-section-number">4.2</span> Grouped data and the “group” aesthetic</h2>
<p>Let’s begin again with our Gapminder dataset. Imagine we wanted to
plot the trajectory of life expectancy over time for each country in
the data. We map <code>year</code> to <code>x</code> and <code>lifeExp</code> to <code>y</code>. We take a quick
look at the documentation and discover that <code>geom_line()</code> will draw
lines by connecting observations in order of the variable on the
x-axis, which seems right. We write our code:</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gapminder-1"/>
<img src="../Images/13e4a87d0b85be4bf9aaa5565bf105ab.png" alt="Trying to plot the data over time by country." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gapminder-1-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.1: Trying to plot the data over time by country.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb97-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gapminder,</a>
<a class="sourceLine" id="cb97-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year,</a>
<a class="sourceLine" id="cb97-3" data-line-number="3">                          <span class="dt">y =</span> gdpPercap))</a>
<a class="sourceLine" id="cb97-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>() </a></code></pre>
<p>Something has gone wrong. What happened? While ggplot will make a
pretty good guess as to the structure of the data, it does not know
that the yearly observations in the data are grouped by country. We
have to tell it. Because we have not, <code>geom_line()</code> gamely tries to
join up all the lines for each particular year in the order they
appear in the dataset, as promised. It starts with an observation for
1952 in the first row of the data. It doesn’t know this belongs to
Afghanistan. Instead of going to Afghanistan 1953, it finds there are
a series of 1952 observations, so it joins all of those up first,
alphabetically by country, all the way down to the 1952 observation
that belongs to Zimbabwe. Then it moves to the first observation in
the next year, 1957.<label for="tufte-mn-45" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-45" class="margin-toggle"/><span class="marginnote shownote">This would have worked if there
were only one country in the dataset.</span></p>
<p>The result is meaningless when plotted. Bizarre-looking output in
ggplot is common enough, because everyone works out their plots one
bit at a time, and making mistakes is just a feature of puzzling out
how you want the plot to look. When ggplot successfully makes a plot
but the result looks insane, the reason is almost always that
something has gone wrong in the mapping between the data and
aesthetics for the geom being used. This is so common there’s even
a <a href="https://twitter.com/accidental__art">Twitter account</a> devoted to
the “Accidental aRt” that results. So don’t despair!</p>
<p>In this case, we can use the <code>group</code> aesthetic to tell ggplot
explicitly about this country-level structure.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gapminder-02"/>
<img src="../Images/96c7456a2639085700e54274b64c86cc.png" alt="Plotting the data over time by country, again." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gapminder-02-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.2: Plotting the data over time by country, again.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb98-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gapminder,</a>
<a class="sourceLine" id="cb98-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year,</a>
<a class="sourceLine" id="cb98-3" data-line-number="3">                          <span class="dt">y =</span> gdpPercap))</a>
<a class="sourceLine" id="cb98-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">group=</span>country)) </a></code></pre>
<p>The plot here is still fairly rough, but it is showing the data
properly, with each line representing the trajectory of a country over
time. The gigantic outlier is Kuwait, in case you are interested.</p>
<p>The <code>group</code> aesthetic is usually only needed when the grouping
information you need to tell ggplot about is not built-in to the
variables being mapped. For example, when we were plotting the points by
continent, mapping <code>color</code> to <code>continent</code> was enough to get the right
answer, because <code>continent</code> is already a categorical variable, so the
grouping is clear. When mapping the <code>x</code> to <code>year</code>, however, there is
no information in the <code>year</code> variable itself to let ggplot know that
it is grouped by country for the purposes of drawing lines with it. So
we need to say that explicitly.</p>
&#13;

<h2><span class="header-section-number">4.3</span> Facet to make small multiples</h2>
<p>The plot we just made has a lot of lines on it. While the overall
trend is more or less clear, it looks a little messy. One option is to
<em>facet</em> the data by some third variable, making a “small multiple”
plot. This is a very powerful technique that allows a lot of
information to be presented compactly, and in a consistently
comparable way. A separate panel is drawn for each value of the
faceting variable. Facets are not a geom, but rather a way of
organizing a series of geoms. In this case we have the <code>continent</code>
variable available to us. We will use <code>facet_wrap()</code> to split our plot
by <code>continent</code>.</p>
<p>The <code>facet_wrap()</code> function can take a series of arguments, but the
most important is the first one, which is specified using R’s
“formula” syntax, which uses the tilde character, <code>~</code>. Facets are
usually a one-sided formula. Most of the time you will just want a
single variable on the right side of the formula. But faceting is
powerful enough to accommodate what are in effect the graphical
equivalent of multi-way contingency tables, if your data is complex
enough to require that. For our first example, we will just use a
single term in our formula, which is the variable we want the data
broken up by: <code>facet_wrap(~ continent)</code>.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gapminder-03"/>
<img src="../Images/dca4514d8ec42a6f9aabcba51b2de069.png" alt="Faceting by continent." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gapminder-03-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.3: Faceting by continent.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb99-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gapminder,</a>
<a class="sourceLine" id="cb99-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year,</a>
<a class="sourceLine" id="cb99-3" data-line-number="3">                          <span class="dt">y =</span> gdpPercap))</a>
<a class="sourceLine" id="cb99-4" data-line-number="4">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">group =</span> country)) <span class="op">+</span><span class="st"> </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>continent)</a></code></pre>
<p>Each facet is labeled at the top. The overall layout minimizes the
duplication of axis labels and other scales. Remember, too that we can
still include other geoms as before, and they will be layered within
each facet. We can also use the <code>ncol</code> argument to <code>facet_wrap()</code> to
control the number of columns used to lay out the facets. Because we
have only five continents it might be worth seeing if we can fit them
on a single row (which means we’ll have five columns). In addition, we
can add a smoother, and a few cosmetic enhancements that make the
graph a little more effective. In particular we will make the country
trends a light gray color. We need to write a little more code to make
all this happen. If you are unsure of what each piece of code does,
take advantage of ggplot’s additive character. Working backwards from
the bottom up, remove each <code>+ some_function(...)</code> statement one at a
time to see how the plot changes.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb100-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gapminder, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year, <span class="dt">y =</span> gdpPercap))</a>
<a class="sourceLine" id="cb100-2" data-line-number="2">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>(<span class="dt">color=</span><span class="st">"gray70"</span>, <span class="kw">aes</span>(<span class="dt">group =</span> country)) <span class="op">+</span></a>
<a class="sourceLine" id="cb100-3" data-line-number="3"><span class="st">    </span><span class="kw">geom_smooth</span>(<span class="dt">size =</span> <span class="fl">1.1</span>, <span class="dt">method =</span> <span class="st">"loess"</span>, <span class="dt">se =</span> <span class="ot">FALSE</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb100-4" data-line-number="4"><span class="st">    </span><span class="kw">scale_y_log10</span>(<span class="dt">labels=</span>scales<span class="op">::</span>dollar) <span class="op">+</span></a>
<a class="sourceLine" id="cb100-5" data-line-number="5"><span class="st">    </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>continent, <span class="dt">ncol =</span> <span class="dv">5</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb100-6" data-line-number="6"><span class="st">    </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">"Year"</span>,</a>
<a class="sourceLine" id="cb100-7" data-line-number="7">         <span class="dt">y =</span> <span class="st">"GDP per capita"</span>,</a>
<a class="sourceLine" id="cb100-8" data-line-number="8">         <span class="dt">title =</span> <span class="st">"GDP per capita on Five Continents"</span>)</a></code></pre>
<div class="figure fullwidth"><span id="fig:ch-04-gapminder-04"/>
<img src="../Images/ef23f240e741e69c5821cbffcd49744d.png" alt="Faceting by continent, again." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gapminder-04-1.png"/>
<p class="caption marginnote shownote">
Figure 4.4: Faceting by continent, again.
</p>
</div>
<p>This plot<label for="tufte-mn-46" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-46" class="margin-toggle"/><span class="marginnote shownote">We could also have faceted by country, which would have made the group mapping superfluous. But that would make almost a hundred and fifty panels.</span> brings together an aesthetic mapping of <code>x</code> and <code>y</code> variables, a grouping aesthetic (<code>country</code>), two geoms (a lineplot and a smoother), a log-transformed y-axis with appropriate tick labels, a faceting variable (<code>continent</code>), and finally axis labels and a title.</p>
<p>The <code>facet_wrap()</code> function is best used when you want a series of
small multiples based on a single categorical variable. Your panels
will be laid out in order and then wrapped into a grid. If you wish
you can specify the number or rows or the number of columns in the
resulting layout. Facets can be more complex than this. For instance,
you might want to cross-classify some data by two categorical
variables. In that case you should try <code>facet_grid()</code> instead. This
function will lay out your plot in a true two-dimensional arrangement,
instead of a series of panels wrapped into a grid.</p>
<p>To see the difference, let’s introduce <code>gss_sm</code>, a new dataset that we will use in the next few sections, as well as later on in the book. It is a small subset of the questions from the 2016 General Social Survey, or GSS. The GSS is a long-running survey of American adults that asks about a range of topics of interest to social scientists.<label for="tufte-mn-47" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-47" class="margin-toggle"/><span class="marginnote shownote">To begin with, we will use the GSS data in a slightly naive way. In particular we will not consider sample weights when making the figures in this chapter. In Chapter 6 we will learn how to calculate frequencies and other statistics from data with a complex or weighted survey design.</span> The <code>gapminder</code> data consists mostly of <em>continuous</em> variables measured within countries by year. Measures like GDP per capita can take any value across a large range and they vary smoothly. The only <em>categorical</em> grouping variable is <code>continent</code>. It is an unordered categorical variable. Each country belongs to one continent, but the continents themselves have no natural ordering.</p>
<p>In social scientific work, especially when analyzing individual-level survey data, we very often work with categorical data of various kinds. Sometimes the categories are unordered, as with ethnicity or sex. But they may also be ordered, as when me measure highest level of education attained on a scale ranging from elementary school to postgraduate degree. Opinion questions may be asked in yes-or-no terms, or on a five or seven point scale with a neutral value in the middle. Meanwhile, many numeric measures, such as number of children, may still only take integer values within a relatively narrow range. In practice these too may be treated as ordered categorical variables running from zero to some top-coded value such as “Six or more”. Even properly continuous measures, such as income, are rarely reported to the dollar and are often only obtainable as ordered categories. The GSS data in <code>gss_sm</code> contains many measures of this sort. You can take a peek at it, as usual, by typing its name at the console. You could also try <code>glimpse(gss_sm)</code>, which will give a very compact summary of all the variables in the data.</p>
<p>We will make a smoothed scatterplot of the relationship between the
age of the respondent and the number of children they have. In
<code>gss_sm</code> the <code>childs</code> variable is a numeric count of the respondent’s
children. (There is also a variable named <code>kids</code> that is the same
measure, but its class is an ordered factor rather than a number.) We
will then facet this relationship by sex and race of the respondent. We
use R’s formula notation in the <code>facet_grid</code> function to facet sex and
race. This time, because we are cross-classifying our results, the formula is two-sided: <code>facet_grid(sex ~ race)</code>.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb101-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb101-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> age, <span class="dt">y =</span> childs))</a>
<a class="sourceLine" id="cb101-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">alpha =</span> <span class="fl">0.2</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb101-4" data-line-number="4"><span class="st">    </span><span class="kw">geom_smooth</span>() <span class="op">+</span></a>
<a class="sourceLine" id="cb101-5" data-line-number="5"><span class="st">    </span><span class="kw">facet_grid</span>(sex <span class="op">~</span><span class="st"> </span>race)</a></code></pre>
<div class="figure"><span id="fig:ch-04-gss-01"/>
<p class="caption marginnote shownote">
Figure 4.5: Faceting on two categorical variables. Each panel plots the relationship between age and number of children, with the facets breaking out the data by sex (in the rows) and race (in the columns).
</p>
<img src="../Images/1f460868c6045f5292cdf1c6e2d517e0.png" alt="Faceting on two categorical variables. Each panel plots the relationship between age and number of children, with the facets breaking out the data by sex (in the rows) and race (in the columns)." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-01-1.png"/>
</div>
<p>Multi-panel layouts of this kind are especially effective when used to
summarize continuous variation (as in a scatterplot) across two or
more categorical variables, with the categories (and hence the panels)
ordered in some sensible way. We are not limited to two-way
comparison. Further categorical variables can be added to the formula,
too, (e.g. <code>sex ~ race + degree</code>) for more complex multi-way plots.
However, the multiple dimensions of plots like this will become very
complicated very quickly if the variables have more than a few
categories each.</p>
&#13;

<h2><span class="header-section-number">4.4</span> Geoms can transform data</h2>
<p>We have already seen several examples where <code>geom_smooth()</code> was
included as a way to add a trend line to the figure. Sometimes we
plotted a LOESS line, sometimes a straight line from an OLS
regression, and sometimes the result of a Generalized Additive Model. We did not have to have any strong idea of the differences between these methods. Neither did
we have to write any code to specify the underlying models, beyond
telling the <code>method</code> argument in <code>geom_smooth()</code> which one we wanted
to use. The <code>geom_smooth()</code> function did the rest.</p>
<p>Thus, some geoms plot our data directly on the figure, as is
the case with <code>geom_point()</code>, which takes variables designated as <code>x</code>
and <code>y</code> and plots the points on a grid. But other geoms clearly do
more work on the data before it gets plotted.<label for="tufte-mn-48" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-48" class="margin-toggle"/><span class="marginnote shownote">Try <code>p +
stat_smooth()</code>, for example.</span> Every <code>geom_</code> function has an
associated <code>stat_</code> function that it uses by default. The reverse is
also the case: every <code>stat_</code> function has an associated <code>geom_</code>
function that it will plot by default if you ask it to. This is not
particularly important to know by itself, but as we will see in the
next section, we sometimes want to calculate a different statistic
for the geom from the default.</p>
<p>Sometimes the calculations being done by the <code>stat_</code> functions that
work together with the <code>geom_</code> functions might not be immediately
obvious. For example, consider this figure produced by a new geom,
<code>geom_bar()</code>.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gss-02"/>
<img src="../Images/43146b8d2717e9fa73fca324ab1d9701.png" alt="A bar chart." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-02-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.6: A bar chart.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb102-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb102-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> bigregion))</a>
<a class="sourceLine" id="cb102-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>()</a></code></pre>
<p>Here we specified just one mapping, <code>aes(x = bigregion)</code>. The bar chart produced gives us a count of the number of (individual) observations in the data set by region of the United States. This seems sensible. But there is a y-axis variable here, <code>count</code>, that is not in the data. It has been calculated for us. Behind the scenes, <code>geom_bar</code> called the default <code>stat_</code> function associated with it, <code>stat_count()</code>. This function computes two new variables, <code>count</code>, and <code>prop</code> (short for proportion). The <code>count</code> statistic is the one <code>geom_bar()</code> uses by default.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gss-03"/>
<img src="../Images/d895e729bfd30955cff742f410fc027e.png" alt="A first go at a bar chart with proportions." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-03-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.7: A first go at a bar chart with proportions.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb103-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb103-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> bigregion))</a>
<a class="sourceLine" id="cb103-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">y =</span> ..prop..))</a></code></pre>
<p>If we want a chart of relative frequencies rather than counts, we will
need to get the <code>prop</code> statistic instead. When ggplot calculates the
count or the proportion, it returns temporary variables that we can
use as mappings in our plots. The relevant statistic is called
<code>..prop..</code> rather than <code>prop</code>. To make sure these temporary variables
won’t be confused with others we are working with, their names begin
and end with two periods. (This is because we might already have a variable called
<code>count</code> or <code>prop</code> in our dataset.) So our calls to it from the <code>aes()</code>
function will generically look like this: <code>&lt;mapping&gt; = &lt;..statistic..&gt;</code>. In this case, we want <code>y</code> to use the calculated
proportion, so we say <code>aes(y = ..prop..)</code>.</p>
<p>The resulting plot is still not right. We no longer have a count on
the y-axis, but the proportions of the bars all have a value of 1, so
all the bars are the same height. We want them to <em>sum</em> to 1, so that
we get the number of observations per continent as a proportion of the
total number of observations. This is a grouping issue again. In a
sense, it’s the reverse of the earlier grouping problem we faced when
we needed to tell ggplot that our yearly data was grouped by country.
In this case, we need to tell ggplot to <em>ignore</em> the x-categories when
calculating denominator of the proportion, and use the total number
observations instead. To do so we specify <code>group = 1</code> inside the
<code>aes()</code> call. The value of <code>1</code> is just a kind of “dummy group” that
tells ggplot to use the whole dataset when establishing the
denominator for its <code>prop</code> calculations.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gss-04"/>
<img src="../Images/d442715fd8354e2e5dffe326391aa143.png" alt="A bar chart with correct proportions." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-04-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.8: A bar chart with correct proportions.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb104-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb104-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> bigregion))</a>
<a class="sourceLine" id="cb104-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">y =</span> ..prop.., <span class="dt">group =</span> <span class="dv">1</span>)) </a></code></pre>
<p>Let’s look at another question from the survey. The <code>gss_sm</code> data contains a <code>religion</code> variable derived from a question asking “What is your religious preference? Is it Protestant, Catholic, Jewish, some other religion, or no religion?”</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb105-1" data-line-number="1"><span class="kw">table</span>(gss_sm<span class="op">$</span>religion)</a></code></pre>
<pre><code>## 
## Protestant   Catholic     Jewish       None      Other 
##       1371        649         51        619        159</code></pre>
<p>To<label for="tufte-mn-49" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-49" class="margin-toggle"/><span class="marginnote shownote">Recall that the <code>$</code> character is one way of accessing individual columns within a data frame or tibble.</span> graph this, we want a bar chart with <code>religion</code> on the x axis (as a
categorical variable), and with the bars in the chart also colored by
<code>religion</code>. If the gray bars look boring and we want to fill them with color instead, we can map the <code>religion</code> variable to <code>fill</code> in addition to mapping it to <code>x</code>. Remember, <code>fill</code> is for painting the insides of shapes. If we map religion to <code>color</code>, only the border lines of the bars will be assigned colors, and the insides will remain gray.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb107-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb107-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> religion, <span class="dt">color =</span> religion))</a>
<a class="sourceLine" id="cb107-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>()</a>
<a class="sourceLine" id="cb107-4" data-line-number="4"/>
<a class="sourceLine" id="cb107-5" data-line-number="5">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb107-6" data-line-number="6">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> religion, <span class="dt">fill =</span> religion))</a>
<a class="sourceLine" id="cb107-7" data-line-number="7">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>() <span class="op">+</span><span class="st"> </span><span class="kw">guides</span>(<span class="dt">fill =</span> <span class="ot">FALSE</span>) </a></code></pre>
<div class="figure"><span id="fig:ch-04-gss-05"/>
<p class="caption marginnote shownote">
Figure 4.9: GSS Religious Preference mapped to color (left) and both color and fill (right).
</p>
<img src="../Images/e1f8eb224fc0ea1a1e230d212dc6b3de.png" alt="GSS Religious Preference mapped to color (left) and both color and fill (right)." width="50%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-05-1.png"/><img src="../Images/0e14eabd1fe63de92809da7f35e9fa61.png" alt="GSS Religious Preference mapped to color (left) and both color and fill (right)." width="50%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-05-2.png"/>
</div>
<p>By doing this, we have mapped two aesthetics to the same variable.
Both <code>x</code> and <code>fill</code> are mapped to <code>religion</code>. There is nothing wrong
with this. However, these are still two separate
mappings, and so they get two separate scales. The default is to show a legend for the color variable. This legend is redundant, because the categories of
<code>religion</code> are already separated out on the x-axis. In its simplest
use, the <code>guides()</code> function controls whether guiding information
about any particular mapping appears or not. If we set <code>guides(fill = FALSE)</code>, the legend is removed, in effect saying that the viewer of
the figure does not need to be shown any guiding information about
this mapping. Setting the guide for some mapping to <code>FALSE</code> only has
an effect if there is a legend to turn off to begin with. Trying <code>x = FALSE</code> or <code>y = FALSE</code> will have no effect, as these mappings have no
additional guides or legends separate from their scales. It is
possible to turn the x and y scales off altogether, but this is done
though a different function, one from the <code>scale_</code> family.</p>
&#13;

<h2><span class="header-section-number">4.5</span> Frequency plots the slightly awkward way</h2>
<p>A more appropriate use of the <code>fill</code> aesthetic with <code>geom_bar()</code> is to
cross-classify two categorical variables. This is the graphical
equivalent of a frequency table of counts or proportions. Using the
GSS data, for instance, we might want to examine the distribution of
religious preferences within different regions of the United States.
In the next few paragraphs we will see how to do this just using
ggplot. However, as we shall also discover, it is often not the most
transparent way to make frequency tables of this sort. The next
chapter introduces a simpler and less error-prone approach where we
calculate the table first before passing the results along to ggplot
to graph. As you work through this section, bear in mind that if you
find things slightly awkward or confusing it is because that’s exactly
what they are.</p>
<p>Let’s say we want to look at religious preference by census region.
That is, we want the <code>religion</code> variable broken down proportionally
within <code>bigregion</code>. When we cross-classify categories in bar charts,
there are several ways to display the results. With <code>geom_bar()</code> the
output is controlled by the <code>position</code> argument. Let’s begin by
mapping <code>fill</code> to <code>religion</code>.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gss-06"/>
<img src="../Images/e414ea7d060124909f69fd5b85452631.png" alt="A stacked bar chart of Religious Preference by Census Region." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-06-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.10: A stacked bar chart of Religious Preference by Census Region.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb108-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb108-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> bigregion, <span class="dt">fill =</span> religion))</a>
<a class="sourceLine" id="cb108-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>()</a></code></pre>
<p>The default output of <code>geom_bar()</code> is a stacked bar chart, with counts
on the y-axis (and hence counts within the stacked segments of the
bars also). Region of the country is on the x-axis, and counts of
religious preference are stacked within the bars. As we saw in Chapter <a href="lookatdata.html#lookatdata">1</a>,
it is somewhat difficult for readers of the chart to compare lengths
an areas on an unaligned scale. So while the relative position of the
bottom categories are quite clear (thanks to them all being aligned on
the x-axis), the relative positions of say, the “Catholic” category is
harder to assess. An alternative choice is to set the <code>position</code>
argument to <code>"fill"</code>. (This is different from the <code>fill</code>
aesthetic.)</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gss-06A"/>
<img src="../Images/73484330223ad56919c8ece2f1c08d48.png" alt="Using the fill position adjustment to show relative proportions across categories." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-06A-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.11: Using the fill position adjustment to show relative proportions across categories.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb109-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb109-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> bigregion, <span class="dt">fill =</span> religion))</a>
<a class="sourceLine" id="cb109-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>(<span class="dt">position =</span> <span class="st">"fill"</span>)</a></code></pre>
<p>Now the bars are all the same height, which makes it easier to compare
proportions across groups. But we lose the ability to see the relative
size of each cut with respect to the overall total. What if we wanted
to show the proportion or percentage of religions within regions of
the country, like in Figure <a href="groupfacettx.html#fig:ch-04-gss-06A">4.11</a>, but instead of
stacking the bars we wanted separate bars instead? As a first attempt, we
can use <code>position="dodge"</code> to make the bars within each region of the
country appear side by side. However, if we do it this way (try it),
we will find that ggplot places the bars side-by-side as intended, but
changes the y-axis back to a <em>count</em> of cases within each category
rather than showing us a proportion. We saw in Figure
<a href="groupfacettx.html#fig:ch-04-gss-04">4.8</a> that to display a proportion we needed to map
<code>y = ..prop..</code>, so the correct statistic would be calculated. Let’s
see if that works.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gss-07"/>
<img src="../Images/122f0ae3696aefaeec2a9fbe35080d45.png" alt="A first go at a dodged bar chart with proportional bars." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-07-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.12: A first go at a dodged bar chart with proportional bars.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb110-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb110-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> bigregion, <span class="dt">fill =</span> religion))</a>
<a class="sourceLine" id="cb110-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>(<span class="dt">position =</span> <span class="st">"dodge"</span>,</a>
<a class="sourceLine" id="cb110-4" data-line-number="4">             <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">y =</span> ..prop..))</a></code></pre>
<p>The result is certainly colorful, but not what we wanted.
Just as in Figure <a href="groupfacettx.html#fig:ch-04-gss-03">4.7</a>, there seems to be an
issue with the grouping. When we just wanted the overall proportions
for one variable, we mapped <code>group = 1</code> to tell ggplot to calculate
the proportions with respect to the overall N. In this case our
grouping variable is <code>religion</code>, so we might try mapping that to the
<code>group</code> aesthetic.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb111-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb111-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> bigregion, <span class="dt">fill =</span> religion))</a>
<a class="sourceLine" id="cb111-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>(<span class="dt">position =</span> <span class="st">"dodge"</span>,</a>
<a class="sourceLine" id="cb111-4" data-line-number="4">             <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">y =</span> ..prop.., <span class="dt">group =</span> religion))</a></code></pre>
<p>This gives us a bar chart where the values of <code>religion</code> are broken
down across regions, with a proportion showing on the y-axis. If you
inspect the bars in Figure <a href="groupfacettx.html#fig:ch-04-gss-08">4.13</a>, you will
see that they do not sum to one within each region. Instead, the bars
for any particular religion sum to one <em>across</em> regions.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-gss-08"/>
<img src="../Images/62ddd4c886912aa5429cf43d7e0aaaee.png" alt="A second attempt at a dodged bar chart with proportional bars." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-08-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.13: A second attempt at a dodged bar chart with proportional bars.<!--</p>-->
<!--</div>--></span>
</p>
<p>This lets us see that nearly half of those who said they were Protestant live in the South, for example. Meanwhile, just over ten percent of those saying they were Protestant live in the Northeast. Similarly, it shows that over half of those saying they were Jewish live in the Northeast, compared to about a quarter who live in the South.<label for="tufte-mn-50" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-50" class="margin-toggle"/><span class="marginnote shownote">Proportions for smaller sub-populations tend to bounce around from year to year in the GSS.</span></p>
<p>We are still not quite where we originally wanted to be. Our goal was to take the stacked bar chart in Figure <a href="groupfacettx.html#fig:ch-04-gss-06">4.10</a> but have the proportions shown side-by-side instead of on top of one another.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb112-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> gss_sm,</a>
<a class="sourceLine" id="cb112-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> religion))</a>
<a class="sourceLine" id="cb112-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>(<span class="dt">position =</span> <span class="st">"dodge"</span>,</a>
<a class="sourceLine" id="cb112-4" data-line-number="4">             <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">y =</span> ..prop.., <span class="dt">group =</span> bigregion)) <span class="op">+</span></a>
<a class="sourceLine" id="cb112-5" data-line-number="5"><span class="st">    </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>bigregion, <span class="dt">ncol =</span> <span class="dv">1</span>)</a></code></pre>
<p>It turns out that the easiest thing to do is to stop trying to force <code>geom_bar()</code> to do all the work in a single step. Instead, we can ask ggplot to give us a proportional bar chart of religious affiliation, and then facet that by region. The proportions are calculated within each panel, which is the breakdown we wanted. This has the added advantage of not producing too many bars within each category.</p>
<div class="figure"><span id="fig:ch-04-gss-09"/>
<p class="caption marginnote shownote">
Figure 4.14: Faceting proportions within region.
</p>
<img src="../Images/d67901facd927e98d4056ebe5e2ff2aa.png" alt="Faceting proportions within region." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-gss-09-1.png"/>
</div>
<p>We could polish this plot further, but for the moment we will stop here. When constructing frequency plots directly in ggplot, it is a little too easy to get stuck in a cycle of not quite getting the marginal comparison that you want, and more or less randomly poking at the mappings to try to stumble on the the right breakdown. In the next Chapter, we will learn how to use the tidyverse’s <code>dplyr</code> library to produce the tables we want <em>before</em> we try to plot them. This is a more reliable approach, and easier to check for errors. It will also give us tools that can be used for many more tasks than producing summaries.</p>
&#13;

<h2><span class="header-section-number">4.6</span> Histograms and density plots</h2>
<p>Different geoms transform data in different ways, but ggplot’s vocabulary for them is consistent. We can see similar transformations at work when summarizing a continuous variable using a histogram, for example. A histogram is a way of summarizing a continuous variable by chopping it up into segments or “bins” and counting how many observations are found within each bin. In a bar chart, the categories are given to us going in (e.g., regions of the country, or religious affiliation). With a histogram, we have to decide how finely to bin the data.</p>
<p>For example, ggplot comes with a dataset, <code>midwest</code>, containing information on counties in several midwestern states of the USA. Counties vary in size, so we can make a histogram showing the distribution of their geographical areas. Area is measured in square miles. Because we are summarizing a continuous variable using a series of bars, we need to divide the observations into groups, or bins, and count how many are in each one. By default, the <code>geom_histogram()</code> function will choose a bin size for us based on a rule of thumb.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb113-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> midwest,</a>
<a class="sourceLine" id="cb113-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> area))</a>
<a class="sourceLine" id="cb113-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_histogram</span>()</a></code></pre>
<pre><code>## `stat_bin()` using `bins = 30`. Pick better value with
## `binwidth`.</code></pre>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb115-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> midwest,</a>
<a class="sourceLine" id="cb115-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> area))</a>
<a class="sourceLine" id="cb115-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_histogram</span>(<span class="dt">bins =</span> <span class="dv">10</span>)</a></code></pre>
<div class="figure"><span id="fig:ch-04-midwest-01"/>
<p class="caption marginnote shownote">
Figure 4.15: Histograms of the same variable, using different numbers of bins.
</p>
<img src="../Images/1d7fb516aa00dbbe85f20728243a9b60.png" alt="Histograms of the same variable, using different numbers of bins." width="50%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-midwest-01-1.png"/><img src="../Images/afaa4400507757217c75298e5fc5791f.png" alt="Histograms of the same variable, using different numbers of bins." width="50%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-midwest-01-2.png"/>
</div>
<p>As with the bar charts, a newly-calculated variable, <code>count</code>, appears on the x-axis. The notification from R tells us that behind the scenes the <code>stat_bin()</code> function picked 30 bins, but we might want to try something else. When drawing histograms it is worth experimenting with <code>bins</code> and also optionally the <code>origin</code> of the x-axis. Each, and
especially <code>bins</code>, will make a big difference to how the resulting
figure looks.</p>
<p>While histograms summarize single variables, it’s also possible to use
several at once to compare distributions. We can facet histograms by
some variable of interest, or as here we can compare them in the
same plot using the <code>fill</code> mapping.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-midwest-02"/>
<img src="../Images/f1dd80bb96810898efdb7d0e6eed506a.png" alt="Comparing two histograms." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-midwest-02-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.16: Comparing two histograms.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb116-1" data-line-number="1">oh_wi &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"OH"</span>, <span class="st">"WI"</span>)</a>
<a class="sourceLine" id="cb116-2" data-line-number="2"/>
<a class="sourceLine" id="cb116-3" data-line-number="3">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> <span class="kw">subset</span>(midwest, <span class="dt">subset =</span> state <span class="op">%in%</span><span class="st"> </span>oh_wi),</a>
<a class="sourceLine" id="cb116-4" data-line-number="4">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> percollege, <span class="dt">fill =</span> state))</a>
<a class="sourceLine" id="cb116-5" data-line-number="5">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_histogram</span>(<span class="dt">alpha =</span> <span class="fl">0.4</span>, <span class="dt">bins =</span> <span class="dv">20</span>)</a></code></pre>
<p>We subset the data here to pick out just two states. To do this we
create a character vector with just two elements, “OH” and “WI”. Then
we use the <code>subset()</code> function to take our data and filter it so that
we only select rows whose <code>state</code> name is in this vector. The <code>%in%</code>
operator is a convenient way to filter on more than one term in a
variable when using <code>subset()</code>.</p>
<p>When working with a continuous variable, an alternative to binning the
data and making a histogram is to calculate a kernel density estimate
of the underlying distribution. The <code>geom_density()</code> function will do
this for us.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-midwest-03"/>
<img src="../Images/d0c2f356c27a2ba25016e64519992e3f.png" alt="Kernel density estimate of county areas." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-midwest-03-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.17: Kernel density estimate of county areas.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb117-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> midwest,</a>
<a class="sourceLine" id="cb117-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> area))</a>
<a class="sourceLine" id="cb117-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_density</span>()</a></code></pre>
<p>We can use <code>color</code> (for the lines) and <code>fill</code> (for the body of the
density curve) here, too. These figures often look quite nice.
But when there are several filled areas on the plot, as in this
case, the overlap can become hard to read. If you want to make the
baselines of the density curves go away, you can use <code>geom_line(stat = "density")</code> instead. This also removes the possibility of using the
<code>fill</code> aesthetic. But this may be an improvement in some cases. Try it
with the plot of state areas and see how they compare.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb118-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> midwest,</a>
<a class="sourceLine" id="cb118-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> area, <span class="dt">fill =</span> state, <span class="dt">color =</span> state))</a>
<a class="sourceLine" id="cb118-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_density</span>(<span class="dt">alpha =</span> <span class="fl">0.3</span>)</a></code></pre>
<div class="figure"><span id="fig:ch-04-midwest-04"/>
<p class="caption marginnote shownote">
Figure 4.18: Comparing distributions.
</p>
<img src="../Images/65ad622a4337f78bd834678e61fc0eee.png" alt="Comparing distributions." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-midwest-04-1.png"/>
</div>
<p>Just like <code>geom_bar()</code>, the count-based defaults computed by the
<code>stat_</code> functions used by <code>geom_histogram()</code> and <code>geom_density()</code> will
return proportional measures if we ask them. For <code>geom_density()</code>, the
<code>stat_density()</code> function can return its default <code>..density..</code>
statistic, or <code>..scaled..</code>, which will give a proportional density
estimate. It can also return a statistic called <code>..count..</code>, which is
the density times the number of points. This can be used in stacked
density plots.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-midwest-05"/>
<img src="../Images/170a065023026a8f463517a53b7c2297.png" alt="Scaled densities." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-midwest-05-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.19: Scaled densities.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb119-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> <span class="kw">subset</span>(midwest, <span class="dt">subset =</span> state <span class="op">%in%</span><span class="st"> </span>oh_wi),</a>
<a class="sourceLine" id="cb119-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> area, <span class="dt">fill =</span> state, <span class="dt">color =</span> state))</a>
<a class="sourceLine" id="cb119-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_density</span>(<span class="dt">alpha =</span> <span class="fl">0.3</span>, <span class="dt">mapping =</span> (<span class="kw">aes</span>(<span class="dt">y =</span> ..scaled..)))</a></code></pre>
&#13;

<h2><span class="header-section-number">4.7</span> Avoid transformations when necessary</h2>
<p>As we have seen from the beginning, ggplot normally makes its charts
starting from a full dataset. When we call <code>geom_bar()</code> it does its
calculations on the fly using <code>stat_count()</code> behind the scenes to
produce the counts or proportions it displays. In the previous
section, we looked at a case where we wanted to group and aggregate
our data ourselves before handing it off to ggplot. But often, our
data is in effect <em>already</em> a summary table. This can happen when we
have computed a table of marginal frequencies or percentages from our
original data already. Plotting results from statistical models also
puts us in this position, as we will see later. Or it may be that we
just have a finished table of data (from the Census, say, or an
official report) that we want to make into a graph. For example,
perhaps we do not have the individual-level data on who survived the
<em>Titanic</em> disaster, but we do have a small table of counts of
survivors by sex:</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb120-1" data-line-number="1">titanic</a></code></pre>
<pre><code>##       fate    sex    n percent
## 1 perished   male 1364    62.0
## 2 perished female  126     5.7
## 3 survived   male  367    16.7
## 4 survived female  344    15.6</code></pre>
<p>Because we are working directly with percentage values in a summary
table, we no longer have any need for ggplot to count up values for us
or perform any other calculations. That is, we do not need the
services of any <code>stat_</code> functions that <code>geom_bar()</code> would normally
call. We can tell <code>geom_bar()</code> not to do any work on the variable
before plotting it. To do this we say <code>stat = 'identity'</code> in the
<code>geom_bar()</code> call. We’ll also move the legend to the top of the chart.</p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:ch-04-titanic-01"/>
<img src="../Images/771b705af5b3db7232da929fdd911d8f.png" alt="Survival on the Titanic, by Sex." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-titanic-01-1.png"/>
<!--
<p class="caption marginnote">-->Figure 4.20: Survival on the Titanic, by Sex.<!--</p>-->
<!--</div>--></span>
</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb122-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> titanic,</a>
<a class="sourceLine" id="cb122-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> fate, <span class="dt">y =</span> percent, <span class="dt">fill =</span> sex))</a>
<a class="sourceLine" id="cb122-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_bar</span>(<span class="dt">position =</span> <span class="st">"dodge"</span>, <span class="dt">stat =</span> <span class="st">"identity"</span>) <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">"top"</span>)</a></code></pre>
<p>For convenience ggplot also provides a related geom, <code>geom_col()</code>,
which has exactly the same effect but assumes that <code>stat = "identity"</code>. We will use this form in future when we don’t need any calculations done on the plot.</p>
<p>The <code>position</code> argument in <code>geom_bar()</code> and <code>geom_col()</code> can also take the value of <code>"identity"</code>. Just as <code>stat = "identity"</code> means “don’t do any summary calculations”, <code>position = "identity"</code> means “just plot the values as given”. This allows us to do things like, for example, plot a flow of positive and negative values in a bar chart. This sort of graph is an alternative to a line plot and is often seen in public policy settings where changes relative to some threshold level or baseline are of interest. For example, the <code>oecd_sum</code> table in <code>socviz</code> contains information on average life expectancy at birth within the United States, and across other OECD countries.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb123-1" data-line-number="1">oecd_sum</a></code></pre>
<pre><code>## # A tibble: 57 x 5
## # Groups:   year [57]
##     year other   usa  diff hi_lo
##    &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;
##  1  1960  68.6  69.9 1.30  Below
##  2  1961  69.2  70.4 1.20  Below
##  3  1962  68.9  70.2 1.30  Below
##  4  1963  69.1  70.0 0.900 Below
##  5  1964  69.5  70.3 0.800 Below
##  6  1965  69.6  70.3 0.700 Below
##  7  1966  69.9  70.3 0.400 Below
##  8  1967  70.1  70.7 0.600 Below
##  9  1968  70.1  70.4 0.300 Below
## 10  1969  70.1  70.6 0.500 Below
## # ... with 47 more rows</code></pre>
<p>The <code>other</code> column is the average life expectancy in a given year for OECD countries, excluding the United States. The <code>usa</code> column is the US life expectancy, <code>diff</code> is the difference between the two values, and <code>hi_lo</code> indicates whether the US value for that year was above or below the OECD average. We will plot the difference over time, and use the <code>hi_lo</code> variable to color the columns in the chart.</p>
<p class="sourceCode"/><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb125-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> oecd_sum,</a>
<a class="sourceLine" id="cb125-2" data-line-number="2">            <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> year, <span class="dt">y =</span> diff, <span class="dt">fill =</span> hi_lo))</a>
<a class="sourceLine" id="cb125-3" data-line-number="3">p <span class="op">+</span><span class="st"> </span><span class="kw">geom_col</span>() <span class="op">+</span><span class="st"> </span><span class="kw">guides</span>(<span class="dt">fill =</span> <span class="ot">FALSE</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb125-4" data-line-number="4"><span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="st">"Difference in Years"</span>,</a>
<a class="sourceLine" id="cb125-5" data-line-number="5">       <span class="dt">title =</span> <span class="st">"The US Life Expectancy Gap"</span>,</a>
<a class="sourceLine" id="cb125-6" data-line-number="6">       <span class="dt">subtitle =</span> <span class="st">"Difference between US and OECD</span></a>
<a class="sourceLine" id="cb125-7" data-line-number="7"><span class="st">                   average life expectancies, 1960-2015"</span>,</a>
<a class="sourceLine" id="cb125-8" data-line-number="8">       <span class="dt">caption =</span> <span class="st">"Data: OECD. After a chart by Christopher Ingraham,</span></a>
<a class="sourceLine" id="cb125-9" data-line-number="9"><span class="st">                  Washington Post, December 27th 2017."</span>)</a></code></pre>
<div class="figure fullwidth"><span id="fig:ch-04-oecd-01"/>
<img src="../Images/06bcc4f1333270280d72e98d90d0a5dc.png" alt="Using &lt;code&gt;geom\_col()&lt;/code&gt; to plot negative and positive values in a bar chart." width="100%" data-original-src="https://socviz.co/dataviz-pdfl_files/figure-html4/ch-04-oecd-01-1.png"/>
<p class="caption marginnote shownote">
Figure 4.21: Using <code>geom_col()</code> to plot negative and positive values in a bar chart.
</p>
</div>
<p>As with the <code>titanic</code> plot, the default action of <code>geom_col()</code> is to set both <code>stat</code> and <code>position</code> to “<code>identity</code>”. To get the same effect with <code>geom_bar()</code> we would need to say <code>geom_bar(position = "identity")</code>. As before, the <code>guides(fill=FALSE)</code> instruction at the end tells ggplot to drop the unnecessary legend that would otherwise be automatically generated to accompany the <code>fill</code> mapping.</p>
<p>At this point, we have a pretty good sense of the core steps we must
take to visualize our data. In fact, thanks to ggplot’s default
settings, we now have the ability to make good-looking and informative
plots. Starting with a tidy dataset, we know how to map variables to
aesthetics, to choose from a variety of geoms, and make some
adjustments to the scales of the plot. We also know more about
selecting the right sort of computed statistic to show on the graph,
if that’s what’s needed, and how to facet our core plot by one or more
variables. We know how to set descriptive labels for axes, and write a
title, subtitle, and caption. Now we’re in a position to put these
skills to work in a more fluent way.</p>
&#13;

<h2><span class="header-section-number">4.8</span> Where to go next</h2>
<ul>
<li>Revisit the <code>gapminder</code> plots at the beginning of the chapter and experiment with different ways to facet the data. Try plotting population and per capita GDP while faceting on year, or even on country. In the latter case you will get a lot of panels, and plotting them straight to the screen may take a long time. Instead, assign the plot to an object and save it as a PDF file to your <code>figures/</code> folder. Experiment with the height and width of the figure.</li>
<li>Investigate the difference between a formula written as <code>facet_grid(sex ~ race)</code> versus one written as <code>facet_grid(~ sex + race)</code>.</li>
<li>Experiment to see what happens when you use <code>facet_wrap()</code> with more complex forumulas like <code>facet_wrap(~ sex + race)</code> instead of <code>facet_grid</code>. Like <code>facet_grid()</code>, the <code>facet_wrap()</code> function can facet on two or more variables at once. But it will do it by laying the results out in a wrapped one-dimensional table instead of a fully cross-classified grid.</li>
<li>Frequency polygons are closely related to histograms. Instead of displaying the count of observations using bars, they display it with a series of connected lines instead. You can try the various <code>geom_histogram()</code> calls in this chapter using <code>geom_freqpoly()</code> instead.</li>
<li>A histogram bins observations for one variable and shows a bars with the count in each bin. We can do this for two variables at once, too. The <code>geom_bin2d()</code> function takes two mappings, <code>x</code> and <code>y</code>. It divides your plot into a grid and colors the bins by the count of observations in them. Try using it on the <code>gapminder</code> data to plot life expectancy versus per capita GDP. Like a histogram, you can vary the number or width of the bins for both <code>x</code> or <code>y</code>. Instead of saying <code>bins = 30</code> or <code>binwidth = 1</code>, provide a number for both <code>x</code> and <code>y</code> with, for example, <code>bins = c(20, 50)</code>. If you specify <code>bindwith</code> instead, you will need to pick values that are on the same scale as the variable you are mapping.</li>
<li>Density estimates can also be drawn in two dimensions. The <code>geom_density_2d()</code> function draws contour lines estimating the joint distribution of two variables. Try it with the <code>midwest</code> data, for example, plotting percent below the poverty line (<code>percbelowpoverty</code>) against percent college-educated (<code>percollege</code>). Try it with and without a <code>geom_point()</code> layer.</li>
</ul>

    
</body>
</html>