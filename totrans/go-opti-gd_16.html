<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Immutable Data Sharing¶</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Immutable Data Sharing¶</h1>
<blockquote>原文：<a href="https://goperf.dev/01-common-patterns/immutable-data/">https://goperf.dev/01-common-patterns/immutable-data/</a></blockquote>
                
                  


  
  



<p>One common source of slowdown in high-performance Go programs is the way shared data is accessed under concurrency. The usual tools—mutexes and channels—work well, but they’re not free. Mutexes can become choke points if many goroutines try to grab the same lock. Channels, while elegant for coordination, can introduce blocking and make control flow harder to reason about. Both require careful use: it’s easy to introduce subtle bugs or unexpected performance issues if synchronization isn’t tight.</p>
<p>A powerful alternative is immutable data sharing. Instead of protecting data with locks, you design your system so that shared data is never mutated after it's created. This minimizes contention and simplifies reasoning about your program.</p>
<h2 id="why-immutable-data">Why Immutable Data?<a class="headerlink" href="#why-immutable-data" title="Permanent link">¶</a></h2>
<p>Immutability brings several advantages to concurrent programs:</p>
<ul>
<li>No locks needed: Multiple goroutines can safely read immutable data without synchronization.</li>
<li>Easier reasoning: If data can't change, you avoid entire classes of race conditions.</li>
<li>Copy-on-write optimizations: You can create new versions of a structure without altering the original, which is useful for config reloading or versioning a state.</li>
</ul>
<h2 id="practical-example-shared-config">Practical Example: Shared Config<a class="headerlink" href="#practical-example-shared-config" title="Permanent link">¶</a></h2>
<p>Imagine you have a long-running service that periodically reloads its configuration from a disk or a remote source. Multiple goroutines read this configuration to make decisions.</p>
<p>Here's how immutable data helps:</p>
<h3 id="step-1-define-the-config-struct">Step 1: Define the Config Struct<a class="headerlink" href="#step-1-define-the-config-struct" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><code>// config.go
type Config struct {
    LogLevel string
    Timeout  time.Duration
    Features map[string]bool // This needs attention!
}
</code></pre></div>
<h3 id="step-2-ensure-deep-immutability">Step 2: Ensure Deep Immutability<a class="headerlink" href="#step-2-ensure-deep-immutability" title="Permanent link">¶</a></h3>
<p>Maps and slices in Go are reference types. Even if the Config struct isn't changed, someone could accidentally mutate a shared map. To prevent this, we make defensive copies:</p>
<div class="highlight"><pre><code>func NewConfig(logLevel string, timeout time.Duration, features map[string]bool) *Config {
    copiedFeatures := make(map[string]bool, len(features))
    for k, v := range features {
        copiedFeatures[k] = v
    }

    return &amp;Config{
        LogLevel: logLevel,
        Timeout:  timeout,
        Features: copiedFeatures,
    }
}
</code></pre></div>
<p>Now, every config instance is self-contained and safe to share.</p>
<h3 id="step-3-atomic-swapping">Step 3: Atomic Swapping<a class="headerlink" href="#step-3-atomic-swapping" title="Permanent link">¶</a></h3>
<p>Use <code>atomic.Value</code> to store and safely update the current config.</p>
<div class="highlight"><pre><code>var currentConfig atomic.Pointer[Config]

func LoadInitialConfig() {
    cfg := NewConfig("info", 5*time.Second, map[string]bool{"beta": true})
    currentConfig.Store(cfg)
}

func GetConfig() *Config {
    return currentConfig.Load()
}
</code></pre></div>
<p>Now all goroutines can safely call <code>GetConfig()</code> with no locks. When the config is reloaded, you just <code>Store</code> a new immutable copy.</p>
<h3 id="step-4-using-it-in-handlers">Step 4: Using It in Handlers<a class="headerlink" href="#step-4-using-it-in-handlers" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><code>func handler(w http.ResponseWriter, r *http.Request) {
    cfg := GetConfig()
    if cfg.Features["beta"] {
        // Enable beta path
    }
    // Use cfg.Timeout, cfg.LogLevel, etc.
}
</code></pre></div>
<h2 id="practical-example-immutable-routing-table">Practical Example: Immutable Routing Table<a class="headerlink" href="#practical-example-immutable-routing-table" title="Permanent link">¶</a></h2>
<p>Suppose you're building a lightweight reverse proxy or API gateway and must route incoming requests based on path or host. The routing table is read thousands of times per second and updated only occasionally (e.g., from a config file or service discovery).</p>
<h3 id="step-1-define-route-structs">Step 1: Define Route Structs<a class="headerlink" href="#step-1-define-route-structs" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><code>type Route struct {
    Path    string
    Backend string
}

type RoutingTable struct {
    Routes []Route
}
</code></pre></div>
<h3 id="step-2-build-immutable-version">Step 2: Build Immutable Version<a class="headerlink" href="#step-2-build-immutable-version" title="Permanent link">¶</a></h3>
<p>To ensure immutability, we deep-copy the slice of routes when constructing a new routing table.</p>
<div class="highlight"><pre><code>func NewRoutingTable(routes []Route) *RoutingTable {
    copied := make([]Route, len(routes))
    copy(copied, routes)
    return &amp;RoutingTable{Routes: copied}
}
</code></pre></div>
<h3 id="step-3-store-it-atomically">Step 3: Store It Atomically<a class="headerlink" href="#step-3-store-it-atomically" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><code>var currentRoutes atomic.Pointer[RoutingTable]

func LoadInitialRoutes() {
    table := NewRoutingTable([]Route{
        {Path: "/api", Backend: "http://api.internal"},
        {Path: "/admin", Backend: "http://admin.internal"},
    })
    currentRoutes.Store(table)
}

func GetRoutingTable() *RoutingTable {
    return currentRoutes.Load()
}
</code></pre></div>
<h3 id="step-4-route-requests-concurrently">Step 4: Route Requests Concurrently<a class="headerlink" href="#step-4-route-requests-concurrently" title="Permanent link">¶</a></h3>
<div class="highlight"><pre><code>func routeRequest(path string) string {
    table := GetRoutingTable()
    for _, route := range table.Routes {
        if strings.HasPrefix(path, route.Path) {
            return route.Backend
        }
    }
    return ""
}
</code></pre></div>
<p>Now, your routing logic can scale safely under load with zero locking overhead.</p>
<h2 id="scaling-immutable-routing-tables">Scaling Immutable Routing Tables<a class="headerlink" href="#scaling-immutable-routing-tables" title="Permanent link">¶</a></h2>
<p>As systems grow, routing tables can expand to hundreds or even thousands of entries. While immutability brings clear benefits—safe concurrent access, predictable behavior—it becomes costly if every update means copying the entire structure. At some point, rebuilding the whole table for each minor change doesn’t scale.</p>
<p>To keep immutability without paying for full reconstruction on every update, the design needs to evolve. There are several ways to do this—each preserving the core benefits while reducing overhead.</p>
<h3 id="scenario-1-segmented-routing">Scenario 1: Segmented Routing<a class="headerlink" href="#scenario-1-segmented-routing" title="Permanent link">¶</a></h3>
<p>Imagine a multi-tenant system where each customer has their own set of routing rules. Instead of one giant slice of routes, you can split them into a map:</p>
<div class="highlight"><pre><code>type MultiTable struct {
    Tables map[string]RoutingTable // key = tenant ID
}
</code></pre></div>
<p>If only customer "acme" updates their rules, you clone just that slice and update the map. Then you atomically swap in a new version of the full map. All other tenants continue using their existing, untouched routing tables.</p>
<p>This approach reduces memory pressure and speeds up updates without losing immutability. It also isolates blast radius: a broken rule set in one segment doesn’t affect others.</p>
<h3 id="scenario-2-indexed-routing-table">Scenario 2: Indexed Routing Table<a class="headerlink" href="#scenario-2-indexed-routing-table" title="Permanent link">¶</a></h3>
<p>Let’s say your router matches by exact path, and lookup speed is critical. You can use a <code>map[string]RouteHandler</code> as an index:</p>
<div class="highlight"><pre><code>type RouteIndex map[string]RouteHandler
</code></pre></div>
<p>When a new path is added, clone the current map, add the new route, and publish the new version. Because maps are shallow, this is fast for moderate numbers of routes. Reads are constant time, and updates are efficient because only a small part of the structure changes.</p>
<h3 id="scenario-3-hybrid-staging-and-publishing">Scenario 3: Hybrid Staging and Publishing<a class="headerlink" href="#scenario-3-hybrid-staging-and-publishing" title="Permanent link">¶</a></h3>
<p>Suppose you’re doing a batch update — maybe reading hundreds of routes from a database. Instead of rebuilding live, you keep a mutable staging area:</p>
<div class="highlight"><pre><code>var mu sync.Mutex
var stagingRoutes []Route
</code></pre></div>
<p>You load and manipulate data in staging under a mutex, then convert to an immutable <code>RoutingTable</code> and store it atomically. This lets you safely prepare complex changes without locking readers or affecting live traffic.</p>
<h2 id="benchmarking-impact">Benchmarking Impact<a class="headerlink" href="#benchmarking-impact" title="Permanent link">¶</a></h2>
<p>Benchmarking immutable data sharing in real-world systems is difficult to do in a generic, meaningful way. Factors like structure size, read/write ratio, and memory layout all heavily influence results.</p>
<p>Rather than presenting artificial benchmarks here, we recommend reviewing the results in the <a href="../atomic-ops/#benchmarking-impact">Atomic Operations and Synchronization Primitives</a> article. Those benchmarks clearly illustrate the potential performance benefits of using atomic.Value over traditional synchronization primitives like sync.RWMutex, especially in highly concurrent read scenarios.</p>
<h2 id="when-to-use-this-pattern">When to Use This Pattern<a class="headerlink" href="#when-to-use-this-pattern" title="Permanent link">¶</a></h2>
<p><svg viewbox="0 0 24 24"><path d="M20 12a8 8 0 0 1-8 8 8 8 0 0 1-8-8 8 8 0 0 1 8-8c.76 0 1.5.11 2.2.31l1.57-1.57A9.8 9.8 0 0 0 12 2 10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10M7.91 10.08 6.5 11.5 11 16 21 6l-1.41-1.42L11 13.17z"/></svg> Immutable data sharing is ideal when:</p>
<ul>
<li>
<p>The data is read-heavy and write-light (e.g., configuration, feature flags, global mappings). This works well because the cost of creating new immutable versions is amortized over many reads, and avoiding locks provides a performance boost.</p>
</li>
<li>
<p>You want to minimize locking without sacrificing safety. By sharing read-only data, you remove the need for mutexes or coordination, reducing the chances of deadlocks or race conditions.</p>
</li>
<li>
<p>You can tolerate minor delays between update and read (eventual consistency). Since data updates are not coordinated with readers, there might be a small delay before all goroutines see the new version. If exact timing isn't critical, this tradeoff simplifies your concurrency model.</p>
</li>
</ul>
<p><svg viewbox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M448 128H270.4c1 5.2 1.6 10.5 1.6 16v16h176c8.8 0 16-7.2 16-16s-7.2-16-16-16m-224 16c0-17.7-14.3-32-32-32h-24c-66.3 0-120 53.7-120 120v48c0 52.5 33.7 97.1 80.7 113.4-.5-3.1-.7-6.2-.7-9.4 0-20 9.2-37.9 23.6-49.7-4.9-9-7.6-19.4-7.6-30.3 0-15.1 5.3-29 14-40-8.8-11-14-24.9-14-40v-40c0-13.3 10.7-24 24-24s24 10.7 24 24v40c0 8.8 7.2 16 16 16s16-7.2 16-16zm-32-80c18 0 34.6 6 48 16h208c35.3 0 64 28.7 64 64s-28.7 64-64 64h-82c1.3 5.1 2 10.5 2 16 0 25.3-14.7 47.2-36 57.6 2.6 7 4 14.5 4 22.4 0 20-9.2 37.9-23.6 49.7 4.9 9 7.6 19.4 7.6 30.3 0 35.3-28.7 64-64 64h-88C75.2 448 0 372.8 0 280v-48C0 139.2 75.2 64 168 64zm64 336c8.8 0 16-7.2 16-16s-7.2-16-16-16h-64c-8.8 0-16 7.2-16 16s7.2 16 16 16zm16-176c0 5.5-.7 10.9-2 16h34c8.8 0 16-7.2 16-16s-7.2-16-16-16h-32zm-24 64h-40c-8.8 0-16 7.2-16 16s7.2 16 16 16h64c8.8 0 16-7.2 16-16s-7.2-16-16-16z"/></svg> It’s less suitable when updates must be transactional across multiple pieces of data or happen frequently. In those cases, the cost of repeated copying or lack of coordination can outweigh the benefits.</p>









  




                
                  
</body>
</html>