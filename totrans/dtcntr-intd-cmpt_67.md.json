["```py\nfun catalan(n):\n  if n == 0: 1\n  else if n > 0:\n    for fold(acc from 0, k from range(0, n)):\n      acc + (catalan(k) * catalan(n - 1 - k))\n    end\n  end\nend\n```", "```py\ncheck:\n  catalan(0) is 1\n  catalan(1) is 1\n  catalan(2) is 2\n  catalan(3) is 5\n  catalan(4) is 14\n  catalan(5) is 42\n  catalan(6) is 132\n  catalan(7) is 429\n  catalan(8) is 1430\n  catalan(9) is 4862\n  catalan(10) is 16796\n  catalan(11) is 58786\nend\n```", "```py\ndata MemoryCell:\n  | mem(in, out)\nend\n\nvar memory :: List<MemoryCell> = empty\n```", "```py\nfun catalan(n :: Number) -> Number:\n  answer = find(lam(elt): elt.in == n end, memory)\n  cases (Option) answer block:\n    | none =>\n      result =\n        if n == 0: 1\n        else if n > 0:\n          for fold(acc from 0, k from range(0, n)):\n            acc + (catalan(k) * catalan(n - 1 - k))\n          end\n        end\n      memory := link(mem(n, result), memory)\n      result\n    | some(v) => v.out\n  end\nend\n```", "```py\ndata MemoryCell:\n  | mem(in, out)\nend\n\nfun memoize-1<T, U>(f :: (T -> U)) -> (T -> U):\n\n  var memory :: List<MemoryCell> = empty\n\n  lam(n):\n    answer = find(lam(elt): elt.in == n end, memory)\n    cases (Option) answer block:\n      | none =>\n        result = f(n)\n        memory := link(mem(n, result), memory)\n        result\n      | some(v) => v.out\n    end\n  end\nend\n```", "```py\nrec catalan :: (Number -> Number) =\n  memoize-1(\n    lam(n):\n      if n == 0: 1\n      else if n > 0:\n        for fold(acc from 0, k from range(0, n)):\n          acc + (catalan(k) * catalan(n - 1 - k))\n        end\n      end\n    end)\n```", "```py\ncheck:\n  levenshtein(empty, empty) is 0\n  levenshtein([list: \"x\"], [list: \"x\"]) is 0\n  levenshtein([list: \"x\"], [list: \"y\"]) is 1\n  # one of about 600\n  levenshtein(\n    [list: \"b\", \"r\", \"i\", \"t\", \"n\", \"e\", \"y\"],\n    [list: \"b\", \"r\", \"i\", \"t\", \"t\", \"a\", \"n\", \"y\"])\n    is 3\n  # http://en.wikipedia.org/wiki/Levenshtein_distance\n  levenshtein(\n    [list: \"k\", \"i\", \"t\", \"t\", \"e\", \"n\"],\n    [list: \"s\", \"i\", \"t\", \"t\", \"i\", \"n\", \"g\"])\n    is 3\n  levenshtein(\n    [list: \"k\", \"i\", \"t\", \"t\", \"e\", \"n\"],\n    [list: \"k\", \"i\", \"t\", \"t\", \"e\", \"n\"])\n    is 0\n  # http://en.wikipedia.org/wiki/Levenshtein_distance\n  levenshtein(\n    [list: \"S\", \"u\", \"n\", \"d\", \"a\", \"y\"],\n    [list: \"S\", \"a\", \"t\", \"u\", \"r\", \"d\", \"a\", \"y\"])\n    is 3\n  # http://www.merriampark.com/ld.htm\n  levenshtein(\n    [list: \"g\", \"u\", \"m\", \"b\", \"o\"],\n    [list: \"g\", \"a\", \"m\", \"b\", \"o\", \"l\"])\n    is 2\n  # http://www.csse.monash.edu.au/~lloyd/tildeStrings/Alignment/92.IPL.html\n  levenshtein(\n    [list: \"a\", \"c\", \"g\", \"t\", \"a\", \"c\", \"g\", \"t\", \"a\", \"c\", \"g\", \"t\"],\n    [list: \"a\", \"c\", \"a\", \"t\", \"a\", \"c\", \"t\", \"t\", \"g\", \"t\", \"a\", \"c\", \"t\"])\n    is 4\n  levenshtein(\n    [list: \"s\", \"u\", \"p\", \"e\", \"r\", \"c\", \"a\", \"l\", \"i\",\n      \"f\", \"r\", \"a\", \"g\", \"i\", \"l\", \"i\", \"s\", \"t\" ],\n    [list: \"s\", \"u\", \"p\", \"e\", \"r\", \"c\", \"a\", \"l\", \"y\",\n      \"f\", \"r\", \"a\", \"g\", \"i\", \"l\", \"e\", \"s\", \"t\" ])\n    is 2\nend\n```", "```py\nrec levenshtein :: (List<String>, List<String> -> Number) =\n  [<levenshtein-body>](#%28elem._levenshtein-body%29)\n```", "```py\nlam(s, t):\n  [<levenshtein-both-empty>](#%28elem._levenshtein-both-empty%29)\n  [<levenshtein-one-empty>](#%28elem._levenshtein-one-empty%29)\n  [<levenshtein-neither-empty>](#%28elem._levenshtein-neither-empty%29)\nend\n```", "```py\nif is-empty(s) and is-empty(t): 0\n```", "```py\nelse if is-empty(s): t.length()\nelse if is-empty(t): s.length()\n```", "```py\nelse:\n  if s.first == t.first:\n    levenshtein(s.rest, t.rest)\n  else:\n    min3(\n      1 + levenshtein(s.rest, t),\n      1 + levenshtein(s, t.rest),\n      1 + levenshtein(s.rest, t.rest))\n  end\nend\n```", "```py\nfun min3(a :: Number, b :: Number, c :: Number):\n  num-min(a, num-min(b, c))\nend\n```", "```py\ndata MemoryCell2<T, U, V>:\n  | mem(in-1 :: T, in-2 :: U, out :: V)\nend\n\nfun memoize-2<T, U, V>(f :: (T, U -> V)) -> (T, U -> V):\n\n  var memory :: List<MemoryCell2<T, U, V>> = empty\n\n  lam(p, q):\n    answer = find(\n      lam(elt): (elt.in-1 == p) and (elt.in-2 == q) end,\n      memory)\n    cases (Option) answer block:\n      | none =>\n        result = f(p, q)\n        memory :=\n        link(mem(p, q, result), memory)\n        result\n      | some(v) => v.out\n    end\n  end\nend\n```", "```py\nrec levenshtein :: (List<String>, List<String> -> Number) =\n  memoize-2(\n    lam(s, t):\n      if is-empty(s) and is-empty(t): 0\n      else if is-empty(s): t.length()\n      else if is-empty(t): s.length()\n      else:\n        if s.first == t.first:\n          levenshtein(s.rest, t.rest)\n        else:\n          min3(\n            1 + levenshtein(s.rest, t),\n            1 + levenshtein(s, t.rest),\n            1 + levenshtein(s.rest, t.rest))\n        end\n      end\n    end)\n```", "```py\nMAX-CAT = 11\n\nanswers :: Array<Option<Number>> = array-of(none, MAX-CAT + 1)\n```", "```py\nfun catalan(n):\n  cases (Option) array-get-now(answers, n):\n    | none => raise(\"looking at uninitialized value\")\n    | some(v) => v\n  end\nend\n```", "```py\nfun fill-catalan(upper) block:\n  array-set-now(answers, 0, some(1))\n  when upper > 0:\n    for each(n from range(1, upper + 1)):\n      block:\n        cat-at-n =\n          for fold(acc from 0, k from range(0, n)):\n            acc + (catalan(k) * catalan(n - 1 - k))\n          end\n        array-set-now(answers, n, some(cat-at-n))\n      end\n    end\n  end\nend\n\nfill-catalan(MAX-CAT)\n```", "```py\nfun levenshtein(s1 :: List<String>, s2 :: List<String>) block:\n  [<levenshtein-dp/1>](#%28elem._levenshtein-dp%2F1%29)\nend\n```", "```py\ns1-len = s1.length()\ns2-len = s2.length()\nanswers = array2d(s1-len + 1, s2-len + 1, none)\n[<levenshtein-dp/2>](#%28elem._levenshtein-dp%2F2%29)\n```", "```py\n> > array2d :: Number, Number, A -> Array<A>\n> > set-answer :: Array<A>, Number, Number, A -> Nothing\n> > get-answer :: Array<A>, Number, Number -> A\n> > ```", "```py\nfun put(s1-idx :: Number, s2-idx :: Number, n :: Number):\n  set-answer(answers, s1-idx, s2-idx, some(n))\nend\nfun lookup(s1-idx :: Number, s2-idx :: Number) -> Number block:\n  a = get-answer(answers, s1-idx, s2-idx)\n  cases (Option) a:\n    | none => raise(\"looking at uninitialized value\")\n    | some(v) => v\n  end\nend\n```", "```py\nfor each(s1i from range(0, s1-len + 1)):\n  put(s1i, 0, s1i)\nend\nfor each(s2i from range(0, s2-len + 1)):\n  put(0, s2i, s2i)\nend\n[<levenshtein-dp/4>](#%28elem._levenshtein-dp%2F4%29)\n```", "```py\nfor each(s1i from range(0, s1-len)):\n  for each(s2i from range(0, s2-len)):\n  [<levenshtein-dp/compute-dist>](#%28elem._levenshtein-dp%2Fcompute-dist%29)\n  end\nend\n[<levenshtein-dp/get-result>](#%28elem._levenshtein-dp%2Fget-result%29)\n```", "```py\ndist =\n  if get(s1, s1i) == get(s2, s2i):\n    lookup(s1i, s2i)\n  else:\n    min3(\n      1 + lookup(s1i, s2i + 1),\n      1 + lookup(s1i + 1, s2i),\n      1 + lookup(s1i, s2i))\n  end\nput(s1i + 1, s2i + 1, dist)\n```", "```py\nlookup(s1-len, s2-len)\n```", "```py\nfun levenshtein(s1 :: List<String>, s2 :: List<String>) block:\n  s1-len = s1.length()\n  s2-len = s2.length()\n  answers = array2d(s1-len + 1, s2-len + 1, none)\n\n  fun put(s1-idx :: Number, s2-idx :: Number, n :: Number):\n    set-answer(answers, s1-idx, s2-idx, some(n))\n  end\n  fun lookup(s1-idx :: Number, s2-idx :: Number) -> Number block:\n    a = get-answer(answers, s1-idx, s2-idx)\n    cases (Option) a:\n      | none => raise(\"looking at uninitialized value\")\n      | some(v) => v\n    end\n  end\n\n  for each(s1i from range(0, s1-len + 1)):\n    put(s1i, 0, s1i)\n  end\n  for each(s2i from range(0, s2-len + 1)):\n    put(0, s2i, s2i)\n  end\n\n  for each(s1i from range(0, s1-len)):\n    for each(s2i from range(0, s2-len)):\n      dist =\n        if get(s1, s1i) == get(s2, s2i):\n          lookup(s1i, s2i)\n        else:\n          min3(\n            1 + lookup(s1i, s2i + 1),\n            1 + lookup(s1i + 1, s2i),\n            1 + lookup(s1i, s2i))\n        end\n      put(s1i + 1, s2i + 1, dist)\n    end\n  end\n\n  lookup(s1-len, s2-len)\nend\n```", "```py\nfun catalan(n):\n  if n == 0: 1\n  else if n > 0:\n    for fold(acc from 0, k from range(0, n)):\n      acc + (catalan(k) * catalan(n - 1 - k))\n    end\n  end\nend\n```", "```py\ncheck:\n  catalan(0) is 1\n  catalan(1) is 1\n  catalan(2) is 2\n  catalan(3) is 5\n  catalan(4) is 14\n  catalan(5) is 42\n  catalan(6) is 132\n  catalan(7) is 429\n  catalan(8) is 1430\n  catalan(9) is 4862\n  catalan(10) is 16796\n  catalan(11) is 58786\nend\n```", "```py\ndata MemoryCell:\n  | mem(in, out)\nend\n\nvar memory :: List<MemoryCell> = empty\n```", "```py\nfun catalan(n :: Number) -> Number:\n  answer = find(lam(elt): elt.in == n end, memory)\n  cases (Option) answer block:\n    | none =>\n      result =\n        if n == 0: 1\n        else if n > 0:\n          for fold(acc from 0, k from range(0, n)):\n            acc + (catalan(k) * catalan(n - 1 - k))\n          end\n        end\n      memory := link(mem(n, result), memory)\n      result\n    | some(v) => v.out\n  end\nend\n```", "```py\ndata MemoryCell:\n  | mem(in, out)\nend\n\nfun memoize-1<T, U>(f :: (T -> U)) -> (T -> U):\n\n  var memory :: List<MemoryCell> = empty\n\n  lam(n):\n    answer = find(lam(elt): elt.in == n end, memory)\n    cases (Option) answer block:\n      | none =>\n        result = f(n)\n        memory := link(mem(n, result), memory)\n        result\n      | some(v) => v.out\n    end\n  end\nend\n```", "```py\nrec catalan :: (Number -> Number) =\n  memoize-1(\n    lam(n):\n      if n == 0: 1\n      else if n > 0:\n        for fold(acc from 0, k from range(0, n)):\n          acc + (catalan(k) * catalan(n - 1 - k))\n        end\n      end\n    end)\n```", "```py\ndata MemoryCell:\n  | mem(in, out)\nend\n\nvar memory :: List<MemoryCell> = empty\n```", "```py\nfun catalan(n :: Number) -> Number:\n  answer = find(lam(elt): elt.in == n end, memory)\n  cases (Option) answer block:\n    | none =>\n      result =\n        if n == 0: 1\n        else if n > 0:\n          for fold(acc from 0, k from range(0, n)):\n            acc + (catalan(k) * catalan(n - 1 - k))\n          end\n        end\n      memory := link(mem(n, result), memory)\n      result\n    | some(v) => v.out\n  end\nend\n```", "```py\ndata MemoryCell:\n  | mem(in, out)\nend\n\nfun memoize-1<T, U>(f :: (T -> U)) -> (T -> U):\n\n  var memory :: List<MemoryCell> = empty\n\n  lam(n):\n    answer = find(lam(elt): elt.in == n end, memory)\n    cases (Option) answer block:\n      | none =>\n        result = f(n)\n        memory := link(mem(n, result), memory)\n        result\n      | some(v) => v.out\n    end\n  end\nend\n```", "```py\nrec catalan :: (Number -> Number) =\n  memoize-1(\n    lam(n):\n      if n == 0: 1\n      else if n > 0:\n        for fold(acc from 0, k from range(0, n)):\n          acc + (catalan(k) * catalan(n - 1 - k))\n        end\n      end\n    end)\n```", "```py\ncheck:\n  levenshtein(empty, empty) is 0\n  levenshtein([list: \"x\"], [list: \"x\"]) is 0\n  levenshtein([list: \"x\"], [list: \"y\"]) is 1\n  # one of about 600\n  levenshtein(\n    [list: \"b\", \"r\", \"i\", \"t\", \"n\", \"e\", \"y\"],\n    [list: \"b\", \"r\", \"i\", \"t\", \"t\", \"a\", \"n\", \"y\"])\n    is 3\n  # http://en.wikipedia.org/wiki/Levenshtein_distance\n  levenshtein(\n    [list: \"k\", \"i\", \"t\", \"t\", \"e\", \"n\"],\n    [list: \"s\", \"i\", \"t\", \"t\", \"i\", \"n\", \"g\"])\n    is 3\n  levenshtein(\n    [list: \"k\", \"i\", \"t\", \"t\", \"e\", \"n\"],\n    [list: \"k\", \"i\", \"t\", \"t\", \"e\", \"n\"])\n    is 0\n  # http://en.wikipedia.org/wiki/Levenshtein_distance\n  levenshtein(\n    [list: \"S\", \"u\", \"n\", \"d\", \"a\", \"y\"],\n    [list: \"S\", \"a\", \"t\", \"u\", \"r\", \"d\", \"a\", \"y\"])\n    is 3\n  # http://www.merriampark.com/ld.htm\n  levenshtein(\n    [list: \"g\", \"u\", \"m\", \"b\", \"o\"],\n    [list: \"g\", \"a\", \"m\", \"b\", \"o\", \"l\"])\n    is 2\n  # http://www.csse.monash.edu.au/~lloyd/tildeStrings/Alignment/92.IPL.html\n  levenshtein(\n    [list: \"a\", \"c\", \"g\", \"t\", \"a\", \"c\", \"g\", \"t\", \"a\", \"c\", \"g\", \"t\"],\n    [list: \"a\", \"c\", \"a\", \"t\", \"a\", \"c\", \"t\", \"t\", \"g\", \"t\", \"a\", \"c\", \"t\"])\n    is 4\n  levenshtein(\n    [list: \"s\", \"u\", \"p\", \"e\", \"r\", \"c\", \"a\", \"l\", \"i\",\n      \"f\", \"r\", \"a\", \"g\", \"i\", \"l\", \"i\", \"s\", \"t\" ],\n    [list: \"s\", \"u\", \"p\", \"e\", \"r\", \"c\", \"a\", \"l\", \"y\",\n      \"f\", \"r\", \"a\", \"g\", \"i\", \"l\", \"e\", \"s\", \"t\" ])\n    is 2\nend\n```", "```py\nrec levenshtein :: (List<String>, List<String> -> Number) =\n  [<levenshtein-body>](#%28elem._levenshtein-body%29)\n```", "```py\nlam(s, t):\n  [<levenshtein-both-empty>](#%28elem._levenshtein-both-empty%29)\n  [<levenshtein-one-empty>](#%28elem._levenshtein-one-empty%29)\n  [<levenshtein-neither-empty>](#%28elem._levenshtein-neither-empty%29)\nend\n```", "```py\nif is-empty(s) and is-empty(t): 0\n```", "```py\nelse if is-empty(s): t.length()\nelse if is-empty(t): s.length()\n```", "```py\nelse:\n  if s.first == t.first:\n    levenshtein(s.rest, t.rest)\n  else:\n    min3(\n      1 + levenshtein(s.rest, t),\n      1 + levenshtein(s, t.rest),\n      1 + levenshtein(s.rest, t.rest))\n  end\nend\n```", "```py\nfun min3(a :: Number, b :: Number, c :: Number):\n  num-min(a, num-min(b, c))\nend\n```", "```py\ndata MemoryCell2<T, U, V>:\n  | mem(in-1 :: T, in-2 :: U, out :: V)\nend\n\nfun memoize-2<T, U, V>(f :: (T, U -> V)) -> (T, U -> V):\n\n  var memory :: List<MemoryCell2<T, U, V>> = empty\n\n  lam(p, q):\n    answer = find(\n      lam(elt): (elt.in-1 == p) and (elt.in-2 == q) end,\n      memory)\n    cases (Option) answer block:\n      | none =>\n        result = f(p, q)\n        memory :=\n        link(mem(p, q, result), memory)\n        result\n      | some(v) => v.out\n    end\n  end\nend\n```", "```py\nrec levenshtein :: (List<String>, List<String> -> Number) =\n  memoize-2(\n    lam(s, t):\n      if is-empty(s) and is-empty(t): 0\n      else if is-empty(s): t.length()\n      else if is-empty(t): s.length()\n      else:\n        if s.first == t.first:\n          levenshtein(s.rest, t.rest)\n        else:\n          min3(\n            1 + levenshtein(s.rest, t),\n            1 + levenshtein(s, t.rest),\n            1 + levenshtein(s.rest, t.rest))\n        end\n      end\n    end)\n```", "```py\nMAX-CAT = 11\n\nanswers :: Array<Option<Number>> = array-of(none, MAX-CAT + 1)\n```", "```py\nfun catalan(n):\n  cases (Option) array-get-now(answers, n):\n    | none => raise(\"looking at uninitialized value\")\n    | some(v) => v\n  end\nend\n```", "```py\nfun fill-catalan(upper) block:\n  array-set-now(answers, 0, some(1))\n  when upper > 0:\n    for each(n from range(1, upper + 1)):\n      block:\n        cat-at-n =\n          for fold(acc from 0, k from range(0, n)):\n            acc + (catalan(k) * catalan(n - 1 - k))\n          end\n        array-set-now(answers, n, some(cat-at-n))\n      end\n    end\n  end\nend\n\nfill-catalan(MAX-CAT)\n```", "```py\nfun levenshtein(s1 :: List<String>, s2 :: List<String>) block:\n  [<levenshtein-dp/1>](#%28elem._levenshtein-dp%2F1%29)\nend\n```", "```py\ns1-len = s1.length()\ns2-len = s2.length()\nanswers = array2d(s1-len + 1, s2-len + 1, none)\n[<levenshtein-dp/2>](#%28elem._levenshtein-dp%2F2%29)\n```", "```py\n> > array2d :: Number, Number, A -> Array<A>\n> > set-answer :: Array<A>, Number, Number, A -> Nothing\n> > get-answer :: Array<A>, Number, Number -> A\n> > ```", "```py\nfun put(s1-idx :: Number, s2-idx :: Number, n :: Number):\n  set-answer(answers, s1-idx, s2-idx, some(n))\nend\nfun lookup(s1-idx :: Number, s2-idx :: Number) -> Number block:\n  a = get-answer(answers, s1-idx, s2-idx)\n  cases (Option) a:\n    | none => raise(\"looking at uninitialized value\")\n    | some(v) => v\n  end\nend\n```", "```py\nfor each(s1i from range(0, s1-len + 1)):\n  put(s1i, 0, s1i)\nend\nfor each(s2i from range(0, s2-len + 1)):\n  put(0, s2i, s2i)\nend\n[<levenshtein-dp/4>](#%28elem._levenshtein-dp%2F4%29)\n```", "```py\nfor each(s1i from range(0, s1-len)):\n  for each(s2i from range(0, s2-len)):\n  [<levenshtein-dp/compute-dist>](#%28elem._levenshtein-dp%2Fcompute-dist%29)\n  end\nend\n[<levenshtein-dp/get-result>](#%28elem._levenshtein-dp%2Fget-result%29)\n```", "```py\ndist =\n  if get(s1, s1i) == get(s2, s2i):\n    lookup(s1i, s2i)\n  else:\n    min3(\n      1 + lookup(s1i, s2i + 1),\n      1 + lookup(s1i + 1, s2i),\n      1 + lookup(s1i, s2i))\n  end\nput(s1i + 1, s2i + 1, dist)\n```", "```py\nlookup(s1-len, s2-len)\n```", "```py\nfun levenshtein(s1 :: List<String>, s2 :: List<String>) block:\n  s1-len = s1.length()\n  s2-len = s2.length()\n  answers = array2d(s1-len + 1, s2-len + 1, none)\n\n  fun put(s1-idx :: Number, s2-idx :: Number, n :: Number):\n    set-answer(answers, s1-idx, s2-idx, some(n))\n  end\n  fun lookup(s1-idx :: Number, s2-idx :: Number) -> Number block:\n    a = get-answer(answers, s1-idx, s2-idx)\n    cases (Option) a:\n      | none => raise(\"looking at uninitialized value\")\n      | some(v) => v\n    end\n  end\n\n  for each(s1i from range(0, s1-len + 1)):\n    put(s1i, 0, s1i)\n  end\n  for each(s2i from range(0, s2-len + 1)):\n    put(0, s2i, s2i)\n  end\n\n  for each(s1i from range(0, s1-len)):\n    for each(s2i from range(0, s2-len)):\n      dist =\n        if get(s1, s1i) == get(s2, s2i):\n          lookup(s1i, s2i)\n        else:\n          min3(\n            1 + lookup(s1i, s2i + 1),\n            1 + lookup(s1i + 1, s2i),\n            1 + lookup(s1i, s2i))\n        end\n      put(s1i + 1, s2i + 1, dist)\n    end\n  end\n\n  lookup(s1-len, s2-len)\nend\n```", "```py\nMAX-CAT = 11\n\nanswers :: Array<Option<Number>> = array-of(none, MAX-CAT + 1)\n```", "```py\nfun catalan(n):\n  cases (Option) array-get-now(answers, n):\n    | none => raise(\"looking at uninitialized value\")\n    | some(v) => v\n  end\nend\n```", "```py\nfun fill-catalan(upper) block:\n  array-set-now(answers, 0, some(1))\n  when upper > 0:\n    for each(n from range(1, upper + 1)):\n      block:\n        cat-at-n =\n          for fold(acc from 0, k from range(0, n)):\n            acc + (catalan(k) * catalan(n - 1 - k))\n          end\n        array-set-now(answers, n, some(cat-at-n))\n      end\n    end\n  end\nend\n\nfill-catalan(MAX-CAT)\n```", "```py\nfun levenshtein(s1 :: List<String>, s2 :: List<String>) block:\n  [<levenshtein-dp/1>](#%28elem._levenshtein-dp%2F1%29)\nend\n```", "```py\ns1-len = s1.length()\ns2-len = s2.length()\nanswers = array2d(s1-len + 1, s2-len + 1, none)\n[<levenshtein-dp/2>](#%28elem._levenshtein-dp%2F2%29)\n```", "```py\n> > array2d :: Number, Number, A -> Array<A>\n> > set-answer :: Array<A>, Number, Number, A -> Nothing\n> > get-answer :: Array<A>, Number, Number -> A\n> > ```", "```py\nfun put(s1-idx :: Number, s2-idx :: Number, n :: Number):\n  set-answer(answers, s1-idx, s2-idx, some(n))\nend\nfun lookup(s1-idx :: Number, s2-idx :: Number) -> Number block:\n  a = get-answer(answers, s1-idx, s2-idx)\n  cases (Option) a:\n    | none => raise(\"looking at uninitialized value\")\n    | some(v) => v\n  end\nend\n```", "```py\nfor each(s1i from range(0, s1-len + 1)):\n  put(s1i, 0, s1i)\nend\nfor each(s2i from range(0, s2-len + 1)):\n  put(0, s2i, s2i)\nend\n[<levenshtein-dp/4>](#%28elem._levenshtein-dp%2F4%29)\n```", "```py\nfor each(s1i from range(0, s1-len)):\n  for each(s2i from range(0, s2-len)):\n  [<levenshtein-dp/compute-dist>](#%28elem._levenshtein-dp%2Fcompute-dist%29)\n  end\nend\n[<levenshtein-dp/get-result>](#%28elem._levenshtein-dp%2Fget-result%29)\n```", "```py\ndist =\n  if get(s1, s1i) == get(s2, s2i):\n    lookup(s1i, s2i)\n  else:\n    min3(\n      1 + lookup(s1i, s2i + 1),\n      1 + lookup(s1i + 1, s2i),\n      1 + lookup(s1i, s2i))\n  end\nput(s1i + 1, s2i + 1, dist)\n```", "```py\nlookup(s1-len, s2-len)\n```", "```py\nfun levenshtein(s1 :: List<String>, s2 :: List<String>) block:\n  s1-len = s1.length()\n  s2-len = s2.length()\n  answers = array2d(s1-len + 1, s2-len + 1, none)\n\n  fun put(s1-idx :: Number, s2-idx :: Number, n :: Number):\n    set-answer(answers, s1-idx, s2-idx, some(n))\n  end\n  fun lookup(s1-idx :: Number, s2-idx :: Number) -> Number block:\n    a = get-answer(answers, s1-idx, s2-idx)\n    cases (Option) a:\n      | none => raise(\"looking at uninitialized value\")\n      | some(v) => v\n    end\n  end\n\n  for each(s1i from range(0, s1-len + 1)):\n    put(s1i, 0, s1i)\n  end\n  for each(s2i from range(0, s2-len + 1)):\n    put(0, s2i, s2i)\n  end\n\n  for each(s1i from range(0, s1-len)):\n    for each(s2i from range(0, s2-len)):\n      dist =\n        if get(s1, s1i) == get(s2, s2i):\n          lookup(s1i, s2i)\n        else:\n          min3(\n            1 + lookup(s1i, s2i + 1),\n            1 + lookup(s1i + 1, s2i),\n            1 + lookup(s1i, s2i))\n        end\n      put(s1i + 1, s2i + 1, dist)\n    end\n  end\n\n  lookup(s1-len, s2-len)\nend\n```"]