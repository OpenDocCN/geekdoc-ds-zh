- en: 5.2Â Processing ListsğŸ”—
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.2 å¤„ç†åˆ—è¡¨ğŸ”—
- en: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/processing-lists.html](https://dcic-world.org/2025-08-27/processing-lists.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://dcic-world.org/2025-08-27/processing-lists.html](https://dcic-world.org/2025-08-27/processing-lists.html)
- en: '| Â Â Â Â [5.2.1Â Making Lists and Taking Them Apart](#%28part._.Making_.Lists_and_.Taking_.Them_.Apart%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.1 åˆ¶ä½œåˆ—è¡¨å’Œæ‹†åˆ†åˆ—è¡¨](#%28part._.Making_.Lists_and_.Taking_.Them_.Apart%29)
    |'
- en: '| Â Â Â Â [5.2.2Â Some Example Exercises](#%28part._my-len%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.2 ä¸€äº›ç¤ºä¾‹ç»ƒä¹ ](#%28part._my-len%29) |'
- en: '| Â Â Â Â [5.2.3Â Structural Problems with Scalar Answers](#%28part._.Structural_.Problems_with_.Scalar_.Answers%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.3 ç»“æ„åŒ–é—®é¢˜å…·æœ‰æ ‡é‡ç­”æ¡ˆ](#%28part._.Structural_.Problems_with_.Scalar_.Answers%29)
    |'
- en: '| Â Â Â Â Â Â [5.2.3.1Â `my-len`: Examples](#%28part._len-eg%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.3.1 `my-len`: ç¤ºä¾‹](#%28part._len-eg%29)'
- en: '| Â Â Â Â Â Â [5.2.3.2Â `my-sum`: Examples](#%28part._sum-eg%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.3.2 `my-sum`: ç¤ºä¾‹](#%28part._sum-eg%29) |'
- en: '| Â Â Â Â Â Â [5.2.3.3Â From Examples to Code](#%28part._.From_.Examples_to_.Code%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.3.3 ä»ç¤ºä¾‹åˆ°ä»£ç ](#%28part._.From_.Examples_to_.Code%29) |'
- en: '| Â Â Â Â [5.2.4Â Structural Problems that Transform Lists](#%28part._.Structural_.Problems_that_.Transform_.Lists%29)
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.4 ç»“æ„åŒ–é—®é¢˜è½¬æ¢åˆ—è¡¨](#%28part._.Structural_.Problems_that_.Transform_.Lists%29)
    |'
- en: '| Â Â Â Â Â Â [5.2.4.1Â `my-doubles`: Examples and Code](#%28part._doubles-eg-code%29)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.4.1 `my-doubles`: ç¤ºä¾‹å’Œä»£ç ](#%28part._doubles-eg-code%29) |'
- en: '| Â Â Â Â Â Â [5.2.4.2Â `my-str-len`: Examples and Code](#%28part._str-len-eg-code%29)
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.4.2 `my-str-len`: ç¤ºä¾‹å’Œä»£ç ](#%28part._str-len-eg-code%29) |'
- en: '| Â Â Â Â [5.2.5Â Structural Problems that Select from Lists](#%28part._.Structural_.Problems_that_.Select_from_.Lists%29)
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.5 ç»“æ„åŒ–é—®é¢˜ä»åˆ—è¡¨ä¸­é€‰æ‹©](#%28part._.Structural_.Problems_that_.Select_from_.Lists%29)
    |'
- en: '| Â Â Â Â Â Â [5.2.5.1Â `my-pos-nums`: Examples and Code](#%28part._pos-nums-eg-code%29)
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.5.1 `my-pos-nums`: ç¤ºä¾‹å’Œä»£ç ](#%28part._pos-nums-eg-code%29) |'
- en: '| Â Â Â Â Â Â [5.2.5.2Â `my-alternating`: Examples and Code](#%28part._alternating-eg-code%29)
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.5.2 `my-alternating`: ç¤ºä¾‹å’Œä»£ç ](#%28part._alternating-eg-code%29) |'
- en: '| Â Â Â Â [5.2.6Â Structural Problems Over Relaxed Domains](#%28part._struct-prob-sub-dom%29)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.6 ç»“æ„åŒ–é—®é¢˜åœ¨æ”¾å®½åŸŸä¸Š](#%28part._struct-prob-sub-dom%29) |'
- en: '| Â Â Â Â Â Â [5.2.6.1Â `my-max`: Examples](#%28part._my-max%29) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.6.1 `my-max`: ç¤ºä¾‹](#%28part._my-max%29) |'
- en: '| Â Â Â Â Â Â [5.2.6.2Â `my-max`: From Examples to Code](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code%29)
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.6.2 `my-max`: ä»ç¤ºä¾‹åˆ°ä»£ç ](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code%29)
    |'
- en: '| Â Â Â Â [5.2.7Â More Structural Problems with Scalar Answers](#%28part._.More_.Structural_.Problems_with_.Scalar_.Answers%29)
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.7 æ›´å¤šç»“æ„åŒ–é—®é¢˜å…·æœ‰æ ‡é‡ç­”æ¡ˆ](#%28part._.More_.Structural_.Problems_with_.Scalar_.Answers%29)
    |'
- en: '| Â Â Â Â Â Â [5.2.7.1Â `my-avg`: Examples](#%28part._avg-eg%29) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.7.1 `my-avg`: ç¤ºä¾‹](#%28part._avg-eg%29) |'
- en: '| Â Â Â Â [5.2.8Â Structural Problems with Accumulators](#%28part._accumulators%29)
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.8 ç»“æ„åŒ–é—®é¢˜å…·æœ‰ç´¯åŠ å™¨](#%28part._accumulators%29) |'
- en: '| Â Â Â Â Â Â [5.2.8.1Â `my-running-sum`: First Attempt](#%28part._running-sum-1st-attempt%29)
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.8.1 `my-running-sum`: ç¬¬ä¸€æ¬¡å°è¯•](#%28part._running-sum-1st-attempt%29)
    |'
- en: '| Â Â Â Â Â Â [5.2.8.2Â `my-running-sum`: Examples and Code](#%28part._running-sum-eg-code%29)
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.8.2 `my-running-sum`: ç¤ºä¾‹å’Œä»£ç ](#%28part._running-sum-eg-code%29) |'
- en: '| Â Â Â Â Â Â [5.2.8.3Â `my-alternating`: Examples and Code](#%28part._alternating-accumulator%29)
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.8.3 `my-alternating`: ç¤ºä¾‹å’Œä»£ç ](#%28part._alternating-accumulator%29)
    |'
- en: '| Â Â Â Â [5.2.9Â Dealing with Multiple Answers](#%28part._.Dealing_with_.Multiple_.Answers%29)
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.9 å¤„ç†å¤šä¸ªç­”æ¡ˆ](#%28part._.Dealing_with_.Multiple_.Answers%29) |'
- en: '| Â Â Â Â Â Â [5.2.9.1Â `uniq`: Problem Setup](#%28part._uniq%29) |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.9.1 `uniq`: é—®é¢˜è®¾ç½®](#%28part._uniq%29) |'
- en: '| Â Â Â Â Â Â [5.2.9.2Â `uniq`: Examples](#%28part._uniq-eg%29) |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.9.2 `uniq`: ç¤ºä¾‹](#%28part._uniq-eg%29) |'
- en: '| Â Â Â Â Â Â [5.2.9.3Â `uniq`: Code](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code%29)
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.9.3 `uniq`: ä»£ç ](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code%29)
    |'
- en: '| Â Â Â Â Â Â [5.2.9.4Â `uniq`: Reducing Computation](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation%29)
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.9.4 `uniq`: å‡å°‘è®¡ç®—](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation%29)
    |'
- en: '| Â Â Â Â Â Â [5.2.9.5Â `uniq`: Example and Code Variations](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations%29)
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.9.5 `uniq`: ç¤ºä¾‹å’Œä»£ç å˜ä½“](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations%29)
    |'
- en: '| Â Â Â Â Â Â [5.2.9.6Â `uniq`: Why Produce a List?](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_%29)
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.9.6 `uniq`: ä¸ºä»€ä¹ˆç”Ÿæˆåˆ—è¡¨ï¼Ÿ](#%28part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_%29)
    |'
- en: '| Â Â Â Â [5.2.10Â Monomorphic Lists and Polymorphic Types](#%28part._polymorphic-data%29)
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|   [5.2.10 å•æ€åˆ—è¡¨å’Œå¤šæ€ç±»å‹](#%28part._polymorphic-data%29) |'
- en: 'We have already seen [[From Tables to Lists](tables-to-lists.html)] several
    examples of list-processing functions. They have been especially useful for advanced
    processing of tables. However, lists arise frequently in programs, and they do
    so naturally because so many things in our livesâ€”<wbr>from shopping lists to to-do
    lists to checklistsâ€”<wbr>are naturally lists. Thinking about the functions that
    we might want when processing lists, we can observe that there are some interesting
    categories regarding the types of the data in the list:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»çœ‹åˆ°äº† [[ä»è¡¨æ ¼åˆ°åˆ—è¡¨](tables-to-lists.html)] å‡ ä¸ªåˆ—è¡¨å¤„ç†å‡½æ•°çš„ä¾‹å­ã€‚å®ƒä»¬åœ¨é«˜çº§è¡¨æ ¼å¤„ç†ä¸­ç‰¹åˆ«æœ‰ç”¨ã€‚ç„¶è€Œï¼Œåˆ—è¡¨åœ¨ç¨‹åºä¸­ç»å¸¸å‡ºç°ï¼Œå¹¶ä¸”å®ƒä»¬è‡ªç„¶åœ°å‡ºç°ï¼Œå› ä¸ºåœ¨æˆ‘ä»¬ç”Ÿæ´»ä¸­è®¸å¤šäº‹ç‰©â€”â€”ä»è´­ç‰©æ¸…å•åˆ°å¾…åŠäº‹é¡¹æ¸…å•åˆ°æ£€æŸ¥æ¸…å•â€”â€”éƒ½æ˜¯è‡ªç„¶åˆ—è¡¨ã€‚æ€è€ƒæˆ‘ä»¬åœ¨å¤„ç†åˆ—è¡¨æ—¶å¯èƒ½æƒ³è¦çš„å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°å…³äºåˆ—è¡¨ä¸­æ•°æ®ç±»å‹çš„ä¸€äº›æœ‰è¶£çš„ç±»åˆ«ï¼š
- en: 'some list functions are generic and operate on any kind of list: e.g., the
    length of a list is the same irrespective of what kind of values it contains;'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€äº›åˆ—è¡¨å‡½æ•°æ˜¯é€šç”¨çš„ï¼Œå¯ä»¥åœ¨ä»»ä½•ç±»å‹çš„åˆ—è¡¨ä¸Šæ“ä½œï¼šä¾‹å¦‚ï¼Œåˆ—è¡¨çš„é•¿åº¦ä¸å…¶åŒ…å«çš„å€¼ç±»å‹æ— å…³ï¼›
- en: 'some are specific at least to the type of data: e.g., the sum assumes that
    all the values are numbers (though they may be ages or prices or other information
    represented by numbers); and'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€äº›è‡³å°‘æ˜¯é’ˆå¯¹æ•°æ®ç±»å‹çš„ç‰¹å®šï¼šä¾‹å¦‚ï¼Œæ€»å’Œå‡è®¾æ‰€æœ‰å€¼éƒ½æ˜¯æ•°å­—ï¼ˆå°½ç®¡å®ƒä»¬å¯èƒ½æ˜¯å¹´é¾„æˆ–ä»·æ ¼æˆ–å…¶ä»–ç”±æ•°å­—è¡¨ç¤ºçš„ä¿¡æ¯ï¼‰ï¼›å¹¶ä¸”
- en: 'some are somewhere in-between: e.g., a maximum function applies to any list
    of comparable values, such as numbers or strings.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€äº›åˆ™ä»‹äºä¸¤è€…ä¹‹é—´ï¼šä¾‹å¦‚ï¼Œæœ€å¤§å€¼å‡½æ•°é€‚ç”¨äºä»»ä½•å¯æ¯”è¾ƒå€¼çš„åˆ—è¡¨ï¼Œå¦‚æ•°å­—æˆ–å­—ç¬¦ä¸²ã€‚
- en: This seems like a great variety, and we might worry about how we can handle
    this many different kinds of functions. Fortunately, and perhaps surprisingly,
    there is one standard way in which we can think about writing all these functions!
    Understanding and internalizing this process is the goal of this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™çœ‹èµ·æ¥æœ‰å¾ˆå¤šç§ç±»ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šæ‹…å¿ƒæˆ‘ä»¬å¦‚ä½•å¤„ç†è¿™ä¹ˆå¤šä¸åŒç§ç±»çš„å‡½æ•°ã€‚å¹¸è¿çš„æ˜¯ï¼Œä¹Ÿè®¸ä»¤äººæƒŠè®¶çš„æ˜¯ï¼Œæœ‰ä¸€ç§æ ‡å‡†çš„æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥æ€è€ƒç¼–å†™æ‰€æœ‰è¿™äº›å‡½æ•°ï¼ç†è§£å’Œå†…åŒ–è¿™ä¸ªè¿‡ç¨‹æ˜¯æœ¬ç« çš„ç›®æ ‡ã€‚
- en: 5.2.1Â Making Lists and Taking Them Apart[ğŸ”—](#(part._.Making_.Lists_and_.Taking_.Them_.Apart)
    "Link to here")
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1 åˆ›å»ºåˆ—è¡¨å’Œæ‹†åˆ†åˆ—è¡¨[ğŸ”—](#(part._.Making_.Lists_and_.Taking_.Them_.Apart) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'So far weâ€™ve seen one way to make a list: by writing `[list: â€¦]`. While useful,
    writing lists this way actually hides their true nature. Every list actually has
    two parts: a first element and the rest of the list. The rest of the list is itself
    a list, so it too has two partsâ€¦and so on.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 'åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°äº†ä¸€ç§åˆ›å»ºåˆ—è¡¨çš„æ–¹æ³•ï¼šé€šè¿‡ç¼–å†™ `[list: â€¦]`ã€‚è™½ç„¶æœ‰ç”¨ï¼Œä½†è¿™æ ·ç¼–å†™åˆ—è¡¨å®é™…ä¸Šéšè—äº†å®ƒä»¬çš„çœŸå®æœ¬è´¨ã€‚æ¯ä¸ªåˆ—è¡¨å®é™…ä¸Šéƒ½æœ‰ä¸¤éƒ¨åˆ†ï¼šä¸€ä¸ªç¬¬ä¸€ä¸ªå…ƒç´ å’Œåˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†ã€‚åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œå› æ­¤å®ƒä¹Ÿæœ‰ä¸¤éƒ¨åˆ†â€¦â€¦ä»¥æ­¤ç±»æ¨ã€‚'
- en: 'Consider the list `[list: 1, 2, 3]`. Its first element is `1`, and the rest
    of it is `[list: 2, 3]`. For this second list, the first element is `2` and the
    rest is `[list: 3]`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 'è€ƒè™‘åˆ—è¡¨ `[list: 1, 2, 3]`ã€‚å®ƒçš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ `1`ï¼Œå…¶ä½™çš„æ˜¯ `[list: 2, 3]`ã€‚å¯¹äºè¿™ä¸ªç¬¬äºŒä¸ªåˆ—è¡¨ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ `2`ï¼Œå…¶ä½™çš„æ˜¯
    `[list: 3]`ã€‚'
- en: Do Now!
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Take apart this third list.
  id: totrans-41
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ‹†åˆ†è¿™ä¸ªç¬¬ä¸‰ä¸ªåˆ—è¡¨ã€‚
- en: 'For the third list, the first element is `3` and the rest is `[list: ]`, i.e.,
    the empty list. In Pyret, we have another way of writing the empty list: `empty`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¯¹äºç¬¬ä¸‰ä¸ªåˆ—è¡¨ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ `3`ï¼Œå…¶ä½™çš„æ˜¯ `[list: ]`ï¼Œå³ç©ºåˆ—è¡¨ã€‚åœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬è¿˜æœ‰å¦ä¸€ç§ç¼–å†™ç©ºåˆ—è¡¨çš„æ–¹æ³•ï¼š`empty`ã€‚'
- en: 'Lists are an instance of structured data: data with component parts and a well-defined
    format for the shape of the parts. Lists are formatted by the first element and
    the rest of the elements. Tables are somewhat structured: they are formatted by
    rows and columns, but the column names arenâ€™t consistent across all tables. Structured
    data is valuable in programming because a predictable format (the structure) lets
    us write programs based on that structure. What do we mean by that?'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨æ˜¯ç»“æ„åŒ–æ•°æ®çš„ä¸€ä¸ªå®ä¾‹ï¼šå…·æœ‰ç»„æˆéƒ¨åˆ†å’Œç»„æˆéƒ¨åˆ†å½¢çŠ¶çš„è‰¯å¥½å®šä¹‰æ ¼å¼çš„æ•°æ®ã€‚åˆ—è¡¨é€šè¿‡ç¬¬ä¸€ä¸ªå…ƒç´ å’Œå…¶ä½™å…ƒç´ è¿›è¡Œæ ¼å¼åŒ–ã€‚è¡¨æ ¼åœ¨ä¸€å®šç¨‹åº¦ä¸Šæ˜¯ç»“æ„åŒ–çš„ï¼šå®ƒä»¬é€šè¿‡è¡Œå’Œåˆ—è¿›è¡Œæ ¼å¼åŒ–ï¼Œä½†åˆ—ååœ¨æ‰€æœ‰è¡¨æ ¼ä¸­å¹¶ä¸ä¸€è‡´ã€‚ç»“æ„åŒ–æ•°æ®åœ¨ç¼–ç¨‹ä¸­å¾ˆæœ‰ä»·å€¼ï¼Œå› ä¸ºå¯é¢„æµ‹çš„æ ¼å¼ï¼ˆç»“æ„ï¼‰è®©æˆ‘ä»¬èƒ½å¤Ÿæ ¹æ®è¯¥ç»“æ„ç¼–å†™ç¨‹åºã€‚æˆ‘ä»¬è¿™æ˜¯ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿ
- en: 'Programming languages can (and do!) provide built-in operators for taking apart
    structured data. These operators are called accessors. Accessors are defined on
    the structure of the datatype alone, independent of the contents of the data.
    In the case of lists, there are two accessors: `first` and `rest`. We use an accessor
    by writing an expression, followed by a dot (`.`), followed by the accessorâ€™s
    name. As we saw with tables, the dot means "dig into". Thus:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ç¼–ç¨‹è¯­è¨€å¯ä»¥ï¼ˆå¹¶ä¸”ç¡®å®ï¼ï¼‰æä¾›ç”¨äºæ‹†åˆ†ç»“æ„åŒ–æ•°æ®çš„å†…ç½®æ“ä½œç¬¦ã€‚è¿™äº›æ“ä½œç¬¦è¢«ç§°ä¸ºè®¿é—®å™¨ã€‚è®¿é—®å™¨æ˜¯åœ¨æ•°æ®ç±»å‹çš„ç»“æ„ä¸Šå®šä¹‰çš„ï¼Œä¸æ•°æ®å†…å®¹æ— å…³ã€‚åœ¨åˆ—è¡¨çš„æƒ…å†µä¸‹ï¼Œæœ‰ä¸¤ä¸ªè®¿é—®å™¨ï¼š`first`
    å’Œ `rest`ã€‚æˆ‘ä»¬é€šè¿‡ç¼–å†™ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œç„¶åæ˜¯ä¸€ä¸ªç‚¹ï¼ˆ`.`ï¼‰ï¼Œç„¶åæ˜¯è®¿é—®å™¨åç§°æ¥ä½¿ç”¨è®¿é—®å™¨ã€‚æ­£å¦‚æˆ‘ä»¬åœ¨è¡¨æ ¼ä¸­çœ‹åˆ°çš„é‚£æ ·ï¼Œç‚¹æ„å‘³ç€â€œæ·±å…¥æŒ–æ˜â€ã€‚å› æ­¤ï¼š
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Do Now!
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the accessors for tables?
  id: totrans-48
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¡¨æ ¼çš„è®¿é—®å™¨æ˜¯ä»€ä¹ˆï¼Ÿ
- en: 'Accessors give a way to take data apart based on their structure (there is
    another way that we will see shortly). Is there a way to also build data based
    on its structure? So far, we have been building lists using the `[list: ...]`
    form, but that doesnâ€™t emphasize the structural constraint that the `rest` is
    itself a list. A structured operator for building lists would clearly show both
    a `first` element and a `rest` that is itself a list. Operators for building structured
    data are called constructors.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®¿é—®å™¨æä¾›äº†ä¸€ç§æ ¹æ®å…¶ç»“æ„æ‹†åˆ†æ•°æ®çš„æ–¹æ³•ï¼ˆæˆ‘ä»¬å¾ˆå¿«å°±ä¼šçœ‹åˆ°å¦ä¸€ç§æ–¹æ³•ï¼‰ã€‚æœ‰æ²¡æœ‰ä¸€ç§æ–¹æ³•ä¹Ÿå¯ä»¥æ ¹æ®å…¶ç»“æ„æ„å»ºæ•°æ®ï¼Ÿåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¸€ç›´åœ¨ä½¿ç”¨ `[list:
    ...]` å½¢å¼æ„å»ºåˆ—è¡¨ï¼Œä½†è¿™å¹¶æ²¡æœ‰å¼ºè°ƒ `rest` æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªåˆ—è¡¨çš„ç»“æ„çº¦æŸã€‚ç”¨äºæ„å»ºåˆ—è¡¨çš„ç»“æ„åŒ–æ“ä½œç¬¦å°†æ¸…æ¥šåœ°æ˜¾ç¤ºä¸€ä¸ª `first` å…ƒç´ å’Œä¸€ä¸ªè‡ªèº«ä¹Ÿæ˜¯åˆ—è¡¨çš„
    `rest`ã€‚ç”¨äºæ„å»ºç»“æ„åŒ–æ•°æ®çš„æ“ä½œç¬¦ç§°ä¸ºæ„é€ å™¨ã€‚'
- en: 'The constructor for lists is called `link`. It takes two arguments: a `first`
    element, and the list to build on (the `rest` part). Hereâ€™s an example of using
    `link` to create a three-element list.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨çš„æ„é€ å™¨ç§°ä¸º `link`ã€‚å®ƒæ¥å—ä¸¤ä¸ªå‚æ•°ï¼šä¸€ä¸ª `first` å…ƒç´ ï¼Œä»¥åŠæ„å»ºåˆ—è¡¨çš„åŸºç¡€ï¼ˆ`rest` éƒ¨åˆ†ï¼‰ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨ `link` åˆ›å»ºä¸‰ä¸ªå…ƒç´ åˆ—è¡¨çš„ç¤ºä¾‹ã€‚
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `link` form creates the same underlying list datum as our previous `[list:
    ...]` operation, as confirmed by the following check:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`link` å½¢å¼åˆ›å»ºçš„åº•å±‚åˆ—è¡¨æ•°æ®ä¸æˆ‘ä»¬çš„å‰ä¸€ä¸ª `[list: ...]` æ“ä½œç›¸åŒï¼Œå¦‚ä¸‹é¢çš„æ£€æŸ¥æ‰€ç¡®è®¤çš„ï¼š'
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Do Now!
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Look at these two forms of writing lists: what differences do you notice?'
  id: totrans-56
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: çœ‹çœ‹è¿™ä¸¤ç§å†™åˆ—è¡¨çš„å½¢å¼ï¼šä½ æ³¨æ„åˆ°äº†ä»€ä¹ˆå·®å¼‚ï¼Ÿ
- en: Do Now!
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the `link` form to write a four-element list of fruits containing `"lychee"`,
    `"dates"`, `"mango"`, and `"durian"`.
  id: totrans-59
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ `link` å½¢å¼ç¼–å†™ä¸€ä¸ªåŒ…å« `"lychee"`ã€`"dates"`ã€`"mango"` å’Œ `"durian"` çš„å››ä¸ªå…ƒç´ åˆ—è¡¨ã€‚
- en: 'After doing this exercise, you might wonder why anyone would use the `link`
    form: itâ€™s more verbose, and makes the individual elements harder to discern.
    This form is not very convenient to humans. But it will prove very valuable to
    programs!'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: åšå®Œè¿™ä¸ªç»ƒä¹ åï¼Œä½ å¯èƒ½ä¼šæƒ³çŸ¥é“ä¸ºä»€ä¹ˆæœ‰äººä¼šä½¿ç”¨ `link` å½¢å¼ï¼šå®ƒæ›´å†—é•¿ï¼Œå¹¶ä¸”ä½¿å¾—å•ä¸ªå…ƒç´ æ›´éš¾è¾¨è®¤ã€‚è¿™ç§å½¢å¼å¯¹äººç±»æ¥è¯´å¹¶ä¸æ–¹ä¾¿ã€‚ä½†è¿™å¯¹ç¨‹åºæ¥è¯´å°†éå¸¸æœ‰ä»·å€¼ï¼
- en: In particular, the `link` form highlights that we really have two different
    structures of lists. Some lists are empty. All other lists are non-empty lists,
    meaning they have at least one `link`. There may be more interesting structure
    to some lists (as we will see later), but all lists have this much in common.
    Specifically, a list is either
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: å°¤å…¶æ˜¯é“¾æ¥å½¢å¼çªå‡ºäº†æˆ‘ä»¬å®é™…ä¸Šæœ‰ä¸¤ç§ä¸åŒçš„åˆ—è¡¨ç»“æ„ã€‚æœ‰äº›åˆ—è¡¨æ˜¯ç©ºçš„ã€‚æ‰€æœ‰å…¶ä»–åˆ—è¡¨éƒ½æ˜¯éç©ºåˆ—è¡¨ï¼Œè¿™æ„å‘³ç€å®ƒä»¬è‡³å°‘æœ‰ä¸€ä¸ª `link`ã€‚æœ‰äº›åˆ—è¡¨å¯èƒ½æœ‰æ›´å¤æ‚çš„ç»“æ„ï¼ˆæˆ‘ä»¬ç¨åä¼šçœ‹åˆ°ï¼‰ï¼Œä½†æ‰€æœ‰åˆ—è¡¨éƒ½æœ‰è¿™ä¸ªå…±åŒç‚¹ã€‚å…·ä½“æ¥è¯´ï¼Œä¸€ä¸ªåˆ—è¡¨è¦ä¹ˆ
- en: 'empty (written `empty` or `[list: ]`), or'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ç©ºçš„ï¼ˆå†™æˆ `empty` æˆ– `[list: ]`ï¼‰ï¼Œæˆ–è€…'
- en: 'non-empty (written `link(â€¦, â€¦)` or `[list: ]` with at least one value inside
    the brackets), where the rest is also a list (and hence may in turn be empty or
    non-empty, â€¦).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'éç©ºï¼ˆå†™æˆ `link(â€¦, â€¦)` æˆ– `[list: ]`ï¼Œæ‹¬å·å†…è‡³å°‘æœ‰ä¸€ä¸ªå€¼ï¼‰ï¼Œå…¶ä¸­å…¶ä½™éƒ¨åˆ†ä¹Ÿæ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼ˆå› æ­¤å¯èƒ½è¿›ä¸€æ­¥æ˜¯ç©ºçš„æˆ–éç©ºçš„ï¼Œâ€¦â€¦ï¼‰ã€‚'
- en: 'This means we actually have two structural features of lists, both of which
    are important when writing programs over lists:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€æˆ‘ä»¬å®é™…ä¸Šæœ‰ä¸¤ä¸ªåˆ—è¡¨çš„ç»“æ„ç‰¹å¾ï¼Œè¿™ä¸¤ä¸ªç‰¹å¾åœ¨ç¼–å†™åˆ—è¡¨ç¨‹åºæ—¶éƒ½å¾ˆé‡è¦ï¼š
- en: Lists can be empty or non-empty
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åˆ—è¡¨å¯ä»¥æ˜¯ç©ºçš„æˆ–éç©ºçš„
- en: Non-empty lists have a first element and a rest of the list
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: éç©ºåˆ—è¡¨æœ‰ä¸€ä¸ªç¬¬ä¸€ä¸ªå…ƒç´ å’Œåˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†
- en: Letâ€™s leverage these two structural features to write some programs to process
    lists!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åˆ©ç”¨è¿™ä¸¤ä¸ªç»“æ„ç‰¹å¾æ¥ç¼–å†™ä¸€äº›å¤„ç†åˆ—è¡¨çš„ç¨‹åºï¼
- en: 5.2.2Â Some Example Exercises[ğŸ”—](#(part._my-len) "Link to here")
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2 ä¸€äº›ç¤ºä¾‹ç»ƒä¹ [ğŸ”—](#(part._my-len) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'To illustrate our thinking, letâ€™s work through a few concrete examples of list-processing
    functions. All of these will consume lists; some will even produce them. Some
    will transform their inputs (like `map`), some will select from their inputs (like
    `filter`), and some will aggregate their inputs. Since some of these functions
    already exist in Pyret, weâ€™ll name them with the prefix `my-` to avoid errors.Be
    sure to use the `my-` name consistently, including inside the body of the function.
    As we will see, there is a standard strategy that we can use to approach writing
    all of these functions: having you learn this strategy is the goal of this chapter.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†è¯´æ˜æˆ‘ä»¬çš„æ€è€ƒè¿‡ç¨‹ï¼Œè®©æˆ‘ä»¬é€šè¿‡å‡ ä¸ªå…·ä½“çš„åˆ—è¡¨å¤„ç†å‡½æ•°çš„ä¾‹å­æ¥è¿›è¡Œåˆ†æã€‚æ‰€æœ‰è¿™äº›å‡½æ•°éƒ½å°†æ¶ˆè€—åˆ—è¡¨ï¼›å…¶ä¸­ä¸€äº›ç”šè‡³ä¼šäº§ç”Ÿåˆ—è¡¨ã€‚ä¸€äº›ä¼šè½¬æ¢å®ƒä»¬çš„è¾“å…¥ï¼ˆå¦‚`map`ï¼‰ï¼Œä¸€äº›ä¼šä»å®ƒä»¬çš„è¾“å…¥ä¸­é€‰æ‹©ï¼ˆå¦‚`filter`ï¼‰ï¼Œè¿˜æœ‰ä¸€äº›ä¼šèšåˆå®ƒä»¬çš„è¾“å…¥ã€‚ç”±äºå…¶ä¸­ä¸€äº›å‡½æ•°å·²ç»åœ¨Pyretä¸­å­˜åœ¨ï¼Œæˆ‘ä»¬å°†ç”¨å‰ç¼€`my-`æ¥å‘½åå®ƒä»¬ä»¥é¿å…é”™è¯¯ã€‚è¯·ç¡®ä¿åœ¨å‡½æ•°ä½“å†…ä¸€è‡´åœ°ä½¿ç”¨`my-`åç§°ã€‚æ­£å¦‚æˆ‘ä»¬å°†çœ‹åˆ°çš„ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ç§æ ‡å‡†ç­–ç•¥æ¥ç¼–å†™æ‰€æœ‰è¿™äº›å‡½æ•°ï¼šå­¦ä¹ è¿™ç§ç­–ç•¥æ˜¯æœ¬ç« çš„ç›®æ ‡ã€‚
- en: 5.2.3Â Structural Problems with Scalar Answers[ğŸ”—](#(part._.Structural_.Problems_with_.Scalar_.Answers)
    "Link to here")
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.3 ç»“æ„æ€§é—®é¢˜[ğŸ”—](#(part._.Structural_.Problems_with_.Scalar_.Answers) "é“¾æ¥è‡³æ­¤")
- en: 'Letâ€™s write out examples for a few of the functions described above. Weâ€™ll
    approach writing examples in a very specific, stylized way. First of all, we should
    always construct at least two examples: one with `empty` and the other with at
    least one `link`, so that weâ€™ve covered the two very broad kinds of lists. Then,
    we should have more examples specific to the kind of list stated in the problem.
    Finally, we should have even more examples to illustrate how we think about solving
    the problem.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä¸ºä¸Šè¿°æè¿°çš„å‡ ä¸ªå‡½æ•°å†™å‡ºä¸€äº›ä¾‹å­ã€‚æˆ‘ä»¬å°†ä»¥éå¸¸å…·ä½“ã€é£æ ¼åŒ–çš„æ–¹å¼æ¥ç¼–å†™ä¾‹å­ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬åº”è¯¥å§‹ç»ˆæ„é€ è‡³å°‘ä¸¤ä¸ªä¾‹å­ï¼šä¸€ä¸ªåŒ…å«`empty`ï¼Œå¦ä¸€ä¸ªè‡³å°‘åŒ…å«ä¸€ä¸ª`link`ï¼Œè¿™æ ·æˆ‘ä»¬å°±æ¶µç›–äº†ä¸¤ç§éå¸¸å¹¿æ³›çš„åˆ—è¡¨ç±»å‹ã€‚ç„¶åï¼Œæˆ‘ä»¬åº”è¯¥æœ‰æ›´å¤šé’ˆå¯¹é—®é¢˜ä¸­æ‰€è¿°åˆ—è¡¨ç±»å‹çš„ç‰¹å®šä¾‹å­ã€‚æœ€åï¼Œæˆ‘ä»¬åº”è¯¥æœ‰æ›´å¤šä¾‹å­æ¥è¯´æ˜æˆ‘ä»¬å¦‚ä½•æ€è€ƒè§£å†³é—®é¢˜ã€‚
- en: '5.2.3.1Â `my-len`: Examples[ğŸ”—](#(part._len-eg) "Link to here")'
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.3.1 `my-len`ï¼šä¾‹å­[ğŸ”—](#(part._len-eg) "é“¾æ¥è‡³æ­¤")
- en: We haveâ€™t precisely defined what it means to be â€œthe lengthâ€ of a list. We confront
    this right away when trying to write an example. What is the length of the list
    `empty`?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜æ²¡æœ‰ç²¾ç¡®åœ°å®šä¹‰åˆ—è¡¨çš„â€œé•¿åº¦â€æ˜¯ä»€ä¹ˆæ„æ€ã€‚å½“æˆ‘ä»¬è¯•å›¾ç¼–å†™ä¸€ä¸ªä¾‹å­æ—¶ï¼Œæˆ‘ä»¬ç«‹å³é¢ä¸´è¿™ä¸ªé—®é¢˜ã€‚ç©ºåˆ—è¡¨`empty`çš„é•¿åº¦æ˜¯å¤šå°‘ï¼Ÿ
- en: Do Now!
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think?
  id: totrans-76
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ è®¤ä¸ºå‘¢ï¼Ÿ
- en: 'Two common examples are `0` and `1`. The latter, `1`, certainly looks reasonable.
    However, if you write the list as `[list: ]`, now it doesnâ€™t look so right: this
    is clearly (as the name `empty` also suggests) an empty list, and an empty list
    has zero elements in it. Therefore, itâ€™s conventional to declare that'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸¤ä¸ªå¸¸è§çš„ä¾‹å­æ˜¯`0`å’Œ`1`ã€‚åè€…`1`çœ‹èµ·æ¥æ˜¯åˆç†çš„ã€‚ç„¶è€Œï¼Œå¦‚æœä½ å°†åˆ—è¡¨å†™æˆ`[list: ]`ï¼Œç°åœ¨å®ƒçœ‹èµ·æ¥å°±ä¸é‚£ä¹ˆå¯¹äº†ï¼šè¿™æ˜¾ç„¶ï¼ˆæ­£å¦‚åç§°`empty`ä¹Ÿæš—ç¤ºçš„ï¼‰æ˜¯ä¸€ä¸ªç©ºåˆ—è¡¨ï¼Œè€Œç©ºåˆ—è¡¨ä¸­æ²¡æœ‰ä»»ä½•å…ƒç´ ã€‚å› æ­¤ï¼Œä¼ ç»Ÿä¸Šæˆ‘ä»¬å£°æ˜'
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'How about a list like `[list: 7]`? Well, itâ€™s clearly got one element (`7`)
    in it, so'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 'é‚£ä¹ˆï¼Œåƒ`[list: 7]`è¿™æ ·çš„åˆ—è¡¨æ€ä¹ˆæ ·ï¼Ÿå¾ˆæ˜æ˜¾ï¼Œå®ƒåŒ…å«ä¸€ä¸ªå…ƒç´ ï¼ˆ`7`ï¼‰ï¼Œæ‰€ä»¥'
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Similarly, for a list like `[list: 7, 8, 9]`, we would say'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç±»ä¼¼åœ°ï¼Œå¯¹äºåƒ`[list: 7, 8, 9]`è¿™æ ·çš„åˆ—è¡¨ï¼Œæˆ‘ä»¬ä¼šè¯´'
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now letâ€™s look at that last example in a different light. Consider the argument
    `[list: 7, 8, 9]`. Its first element is `7` and the rest of it is `[list: 8, 9]`.
    Well, `7` is a number, not a list; but `[list: 8, 9]` certainly is a list, so
    we can ask for its length. What is `my-len([list: 8, 9])`? It has two elements,
    so'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä»ä¸åŒçš„è§’åº¦å®¡è§†æœ€åä¸€ä¸ªä¾‹å­ã€‚è€ƒè™‘å‚æ•°`[list: 7, 8, 9]`ã€‚å®ƒçš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯`7`ï¼Œå…¶ä½™çš„æ˜¯`[list: 8, 9]`ã€‚å¥½å§ï¼Œ`7`æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œä¸æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼›ä½†`[list:
    8, 9]`æ˜¾ç„¶æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥è¯¢é—®å®ƒçš„é•¿åº¦ã€‚`my-len([list: 8, 9])`æ˜¯ä»€ä¹ˆï¼Ÿå®ƒæœ‰ä¸¤ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥'
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first element of that list is `8` while its rest is `[list: 9]`. What is
    its length? Note that we asked a very similar question before, for the length
    of the list `[list: 7]`. But `[list: 7]` is not a sub-list of `[list: 7, 8, 9]`,
    which we started with, whereas `[list: 9]` is. And using the same reasoning as
    before, we can say'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¯¥åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯`8`ï¼Œå…¶ä½™çš„æ˜¯`[list: 9]`ã€‚å®ƒçš„é•¿åº¦æ˜¯å¤šå°‘ï¼Ÿè¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä¹‹å‰å·²ç»æå‡ºäº†ä¸€ä¸ªéå¸¸ç±»ä¼¼çš„é—®é¢˜ï¼Œå³åˆ—è¡¨`[list: 7]`çš„é•¿åº¦ã€‚ä½†æ˜¯`[list:
    7]`ä¸æ˜¯æˆ‘ä»¬ä»`[list: 7, 8, 9]`å¼€å§‹çš„å­åˆ—è¡¨ï¼Œè€Œ`[list: 9]`æ˜¯ã€‚å¹¶ä¸”ä½¿ç”¨ä¸ä¹‹å‰ç›¸åŒçš„æ¨ç†ï¼Œæˆ‘ä»¬å¯ä»¥è¯´'
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The rest of this last list is, of course, the empty list, whose length we have
    already decided is `0`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œè¿™ä¸ªåˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æ˜¯ç©ºåˆ—è¡¨ï¼Œå…¶é•¿åº¦æˆ‘ä»¬å·²å†³å®šæ˜¯`0`ã€‚
- en: 'Putting together these examples, and writing out `empty` in its other form,
    hereâ€™s what we get:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: å°†è¿™äº›ä¾‹å­æ”¾åœ¨ä¸€èµ·ï¼Œå¹¶ä»¥å…¶ä»–å½¢å¼å†™å‡º`empty`ï¼Œæˆ‘ä»¬å¾—åˆ°ä»¥ä¸‹å†…å®¹ï¼š
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Another way we can write this (paying attention to the right side) is
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ç§æˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ï¼ˆæ³¨æ„å³ä¾§ï¼‰çš„æ–¹å¼æ˜¯
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Where did the `2`, `1`, and `0` on the right sides of each `+` operation come
    from? Those are the lengths of the `rest` component of the input list. In the
    previous example block, we wrote those lengths as explicit examples. Letâ€™s substitute
    the numbers `2`, `1`, and `0` with the `my-len` expressions that produce them:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ªåŠ æ³•æ“ä½œå³ä¾§çš„`2`ã€`1`å’Œ`0`æ˜¯ä»å“ªé‡Œæ¥çš„ï¼Ÿè¿™äº›æ˜¯è¾“å…¥åˆ—è¡¨`rest`ç»„ä»¶çš„é•¿åº¦ã€‚åœ¨å‰é¢çš„ç¤ºä¾‹å—ä¸­ï¼Œæˆ‘ä»¬å°†è¿™äº›é•¿åº¦ä½œä¸ºæ˜ç¡®çš„ç¤ºä¾‹å†™å‡ºæ¥ã€‚è®©æˆ‘ä»¬ç”¨äº§ç”Ÿè¿™äº›é•¿åº¦çš„`my-len`è¡¨è¾¾å¼æ¥æ›¿æ¢æ•°å­—`2`ã€`1`å’Œ`0`ï¼š
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From this, maybe you can start to see a pattern. For an empty list, the length
    is `0`. For a non-empty list, itâ€™s the sum of `1` (the first elementâ€™s â€œcontributionâ€
    to the listâ€™s length) to the length of the rest of the list. In other words, we
    can use the result of computing `my-len` on the rest of the list to compute the
    answer for the entire list.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™ä¸ªä¾‹å­ä¸­ï¼Œä¹Ÿè®¸ä½ å¯ä»¥å¼€å§‹çœ‹åˆ°ä¸€ç§æ¨¡å¼ã€‚å¯¹äºç©ºåˆ—è¡¨ï¼Œé•¿åº¦æ˜¯`0`ã€‚å¯¹äºéç©ºåˆ—è¡¨ï¼Œå®ƒæ˜¯`1`ï¼ˆç¬¬ä¸€ä¸ªå…ƒç´ å¯¹åˆ—è¡¨é•¿åº¦çš„â€œè´¡çŒ®â€ï¼‰åŠ ä¸Šå‰©ä½™åˆ—è¡¨çš„é•¿åº¦ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è®¡ç®—å‰©ä½™åˆ—è¡¨çš„`my-len`çš„ç»“æœæ¥è®¡ç®—æ•´ä¸ªåˆ—è¡¨çš„ç­”æ¡ˆã€‚
- en: Do Now!
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Each of our examples in this section has written a different check on the expression
    `my-len([list: 7, 8, 9])`. Here are those examples presented together, along with
    one last one that explicitly uses the `rest` operation:'
  id: totrans-97
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'æœ¬èŠ‚ä¸­çš„æ¯ä¸ªç¤ºä¾‹éƒ½å¯¹è¡¨è¾¾å¼`my-len([list: 7, 8, 9])`è¿›è¡Œäº†ä¸åŒçš„æ£€æŸ¥ã€‚ä»¥ä¸‹æ˜¯è¿™äº›ç¤ºä¾‹ä¸€èµ·å±•ç¤ºï¼Œä»¥åŠä¸€ä¸ªæœ€åä½¿ç”¨`rest`æ“ä½œçš„ç¤ºä¾‹ï¼š'
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-99
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check that you agree with each of these assertions. Also check whether you understand
    how the right-hand side of each `is` expression derives from the right-hand-side
    just above it. The goal of this exercise is to make sure that you believe that
    the last check (which we will turn into code) is equivalent to the first (which
    we wrote down when understanding the problem).
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¡®è®¤ä½ åŒæ„è¿™äº›æ–­è¨€ä¸­çš„æ¯ä¸€ä¸ªã€‚ä¹Ÿè¦ç¡®è®¤ä½ æ˜¯å¦ç†è§£äº†æ¯ä¸ª`is`è¡¨è¾¾å¼çš„å³ä¾§æ˜¯å¦‚ä½•ä»å…¶ä¸Šé¢çš„å³ä¾§æ¨å¯¼å‡ºæ¥çš„ã€‚è¿™ä¸ªç»ƒä¹ çš„ç›®çš„æ˜¯ç¡®ä¿ä½ ç›¸ä¿¡æœ€åä¸€ä¸ªæ£€æŸ¥ï¼ˆæˆ‘ä»¬å°†å°†å…¶è½¬æ¢ä¸ºä»£ç ï¼‰ä¸ç¬¬ä¸€ä¸ªï¼ˆæˆ‘ä»¬åœ¨ç†è§£é—®é¢˜æ—¶å†™ä¸‹æ¥çš„ï¼‰æ˜¯ç­‰ä»·çš„ã€‚
- en: '5.2.3.2Â `my-sum`: Examples[ğŸ”—](#(part._sum-eg) "Link to here")'
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.3.2 `my-sum`ï¼šç¤ºä¾‹[ğŸ”—](#(part._sum-eg) "é“¾æ¥è‡³æ­¤")
- en: 'Letâ€™s repeat this process of developing examples on a second function, this
    time one that computes the sum of the elements in a list of numbers. What is the
    sum of the list `[list: 7, 8, 9]`? Just adding up the numbers by hand, the result
    should be `24`. Letâ€™s see how that works out through the examples.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®©æˆ‘ä»¬é‡å¤è¿™ä¸ªè¿‡ç¨‹ï¼Œåœ¨ç¬¬äºŒä¸ªå‡½æ•°ä¸Šå¼€å‘ç¤ºä¾‹ï¼Œè¿™æ¬¡æ˜¯ä¸€ä¸ªè®¡ç®—æ•°å­—åˆ—è¡¨å…ƒç´ æ€»å’Œçš„å‡½æ•°ã€‚åˆ—è¡¨`[list: 7, 8, 9]`çš„æ€»å’Œæ˜¯å¤šå°‘ï¼Ÿé€šè¿‡æ‰‹å·¥åŠ èµ·æ¥ï¼Œç»“æœåº”è¯¥æ˜¯`24`ã€‚è®©æˆ‘ä»¬é€šè¿‡ç¤ºä¾‹çœ‹çœ‹è¿™æ˜¯å¦‚ä½•å®ç°çš„ã€‚'
- en: 'Setting aside the empty list for a moment, here are examples that show the
    sum computations:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: æš‚æ—¶å¿½ç•¥ç©ºåˆ—è¡¨ï¼Œä»¥ä¸‹æ˜¯ä¸€äº›æ˜¾ç¤ºæ±‚å’Œè®¡ç®—çš„ç¤ºä¾‹ï¼š
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: which (by substitution) is the same as
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡æ›¿æ¢ï¼Œå®ƒä¸
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From this, we can see that the sum of the empty list must be `0`:Zero is called
    the additive identity: a fancy way of saying, adding zero to any number N gives
    you N. Therefore, it makes sense that it would be the length of the empty list,
    because the empty list has no items to contribute to a sum. Can you figure out
    what the multiplicative identity is?'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ç©ºåˆ—è¡¨çš„æ€»å’Œå¿…é¡»æ˜¯`0`ï¼šé›¶è¢«ç§°ä¸ºåŠ æ³•æ’ç­‰å…ƒï¼šä¸€ç§è¯´æ³•ï¼Œå³å‘ä»»ä½•æ•°å­—NåŠ ä¸Šé›¶ï¼Œä½ å¾—åˆ°Nã€‚å› æ­¤ï¼Œå®ƒæœ‰é“ç†ä¼šæ˜¯ç©ºåˆ—è¡¨çš„é•¿åº¦ï¼Œå› ä¸ºç©ºåˆ—è¡¨æ²¡æœ‰é¡¹ç›®å¯ä»¥è´¡çŒ®åˆ°æ€»å’Œã€‚ä½ èƒ½æ‰¾å‡ºä¹˜æ³•æ’ç­‰å…ƒæ˜¯ä»€ä¹ˆå—ï¼Ÿ
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Observe, again, how we can use the result of computing `my-sum` of the rest
    of the list to compute its result for the whole list.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡è§‚å¯Ÿï¼Œæˆ‘ä»¬å¦‚ä½•ä½¿ç”¨è®¡ç®—åˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„`my-sum`çš„ç»“æœæ¥è®¡ç®—æ•´ä¸ªåˆ—è¡¨çš„ç»“æœã€‚
- en: 5.2.3.3Â From Examples to Code[ğŸ”—](#(part._.From_.Examples_to_.Code) "Link to
    here")
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.3.3 ä»ç¤ºä¾‹åˆ°ä»£ç [ğŸ”—](#(part._.From_.Examples_to_.Code) "é“¾æ¥è‡³æ­¤")
- en: Having developed these examples, we now want to use them to develop a program
    that can compute the length or the sum of any list, not just the specific ones
    we used in these examples. As we have done up in earlier chapters, we will leverage
    patterns in the examples to figure out how to define the general-purpose function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¼€å‘è¿™äº›ç¤ºä¾‹ä¹‹åï¼Œæˆ‘ä»¬ç°åœ¨æƒ³åˆ©ç”¨å®ƒä»¬æ¥å¼€å‘ä¸€ä¸ªç¨‹åºï¼Œè¯¥ç¨‹åºå¯ä»¥è®¡ç®—ä»»ä½•åˆ—è¡¨çš„é•¿åº¦æˆ–æ€»å’Œï¼Œè€Œä¸ä»…ä»…æ˜¯è¿™äº›ç¤ºä¾‹ä¸­ä½¿ç”¨çš„ç‰¹å®šåˆ—è¡¨ã€‚æ­£å¦‚æˆ‘ä»¬åœ¨å‰é¢çš„ç« èŠ‚ä¸­æ‰€åšçš„é‚£æ ·ï¼Œæˆ‘ä»¬å°†åˆ©ç”¨ç¤ºä¾‹ä¸­çš„æ¨¡å¼æ¥æ‰¾å‡ºå¦‚ä½•å®šä¹‰é€šç”¨å‡½æ•°ã€‚
- en: 'Here is one last version of the examples for `my-len`, this time making the
    `rest` explicit on the right-hand sides of `is`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯`my-len`çš„æœ€åä¸€ä¸ªç¤ºä¾‹ç‰ˆæœ¬ï¼Œè¿™æ¬¡åœ¨`is`çš„å³ä¾§æ˜ç¡®ä½¿ç”¨äº†`rest`ï¼š
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we did when developing functions over images, letâ€™s try to identify the
    common parts of these examples. We start by noticing that most of the examples
    have a lot in common, except for the `[list: ]` (`empty`) case. So letâ€™s separate
    this into two sets of examples:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ­£å¦‚æˆ‘ä»¬åœ¨å›¾åƒä¸Šå¼€å‘å‡½æ•°æ—¶åšçš„é‚£æ ·ï¼Œè®©æˆ‘ä»¬å°è¯•è¯†åˆ«è¿™äº›ç¤ºä¾‹çš„å…±åŒéƒ¨åˆ†ã€‚æˆ‘ä»¬é¦–å…ˆæ³¨æ„åˆ°ï¼Œå¤§å¤šæ•°ç¤ºä¾‹æœ‰å¾ˆå¤šå…±åŒä¹‹å¤„ï¼Œé™¤äº† `[list: ]` (`empty`)
    æƒ…å†µã€‚æ‰€ä»¥è®©æˆ‘ä»¬å°†å®ƒä»¬åˆ†æˆä¸¤ç»„ç¤ºä¾‹ï¼š'
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this separation (which follows one of the structural features of lists
    that we mentioned earlier), a clearer pattern emerges: for a non-empty list (called
    `someList`), we compute its length via the expression:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡è¿™ç§åˆ†ç¦»ï¼ˆéµå¾ªæˆ‘ä»¬ä¹‹å‰æåˆ°çš„åˆ—è¡¨çš„ç»“æ„ç‰¹å¾ä¹‹ä¸€ï¼‰ï¼Œä¸€ä¸ªæ›´æ¸…æ™°çš„æ¨¡å¼å‡ºç°äº†ï¼šå¯¹äºéç©ºåˆ—è¡¨ï¼ˆç§°ä¸º `someList`ï¼‰ï¼Œæˆ‘ä»¬é€šè¿‡ä»¥ä¸‹è¡¨è¾¾å¼è®¡ç®—å…¶é•¿åº¦ï¼š
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In general, then, our `my-len` program needs to determine whether its input
    list is empty or non-empty, using this expression with `.rest` in the non-empty
    case. How do we indicate different code based on the structure of the list?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæ€»çš„æ¥è¯´ï¼Œæˆ‘ä»¬çš„ `my-len` ç¨‹åºéœ€è¦ç¡®å®šå…¶è¾“å…¥åˆ—è¡¨æ˜¯å¦ä¸ºç©ºæˆ–éç©ºï¼Œåœ¨éç©ºæƒ…å†µä¸‹ä½¿ç”¨å¸¦æœ‰ `.rest` çš„æ­¤è¡¨è¾¾å¼ã€‚æˆ‘ä»¬å¦‚ä½•æ ¹æ®åˆ—è¡¨çš„ç»“æ„æ¥æŒ‡ç¤ºä¸åŒçš„ä»£ç ï¼Ÿ
- en: 'Pyret has a construct called `cases` which is used to distinguish different
    forms within a structured datatype. When working with lists, the general shape
    of a `cases` expression is:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret æœ‰ä¸€ä¸ªåä¸º `cases` çš„æ„é€ ï¼Œç”¨äºåŒºåˆ†ç»“æ„åŒ–æ•°æ®ç±»å‹ä¸­çš„ä¸åŒå½¢å¼ã€‚å½“ä¸åˆ—è¡¨ä¸€èµ·ä½¿ç”¨æ—¶ï¼Œ`cases` è¡¨è¾¾å¼çš„ä¸€èˆ¬å½¢çŠ¶æ˜¯ï¼š
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'where most parts are fixed, but a few youâ€™re free to change:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­å¤§éƒ¨åˆ†éƒ¨åˆ†æ˜¯å›ºå®šçš„ï¼Œä½†æœ‰ä¸€äº›ä½ å¯ä»¥è‡ªç”±æ›´æ”¹ï¼š
- en: '`e` is an expression whose value needs to be a list; it could be a variable
    bound to a list, or some complex expression that evaluates to a list.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e` æ˜¯ä¸€ä¸ªéœ€è¦å…¶å€¼ä¸ºåˆ—è¡¨çš„è¡¨è¾¾å¼ï¼›å®ƒå¯ä»¥æ˜¯ç»‘å®šåˆ°åˆ—è¡¨çš„å˜é‡ï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªè®¡ç®—ç»“æœä¸ºåˆ—è¡¨çš„å¤æ‚è¡¨è¾¾å¼ã€‚'
- en: '`f` and `r` are names given to the first and rest of the list. You can choose
    any names you like, though in Pyret, itâ€™s conventional to use `f` and `r`.Occasionally
    using different names can help students recall that they can choose how to label
    the `first` and `rest` components. This can be particularly useful for `first`,
    which has a problem-specific meaning (such as `price` in a list of prices, and
    so on).'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f` å’Œ `r` æ˜¯åˆ†é…ç»™åˆ—è¡¨çš„é¦–éƒ¨å’Œå‰©ä½™éƒ¨åˆ†çš„åç§°ã€‚ä½ å¯ä»¥é€‰æ‹©ä»»ä½•ä½ å–œæ¬¢çš„åç§°ï¼Œå°½ç®¡åœ¨ Pyret ä¸­ï¼Œä½¿ç”¨ `f` å’Œ `r` æ˜¯ä¸€ç§æƒ¯ä¾‹ã€‚å¶å°”ä½¿ç”¨ä¸åŒçš„åç§°å¯ä»¥å¸®åŠ©å­¦ç”Ÿè®°ä½ä»–ä»¬å¯ä»¥é€‰æ‹©å¦‚ä½•æ ‡è®°
    `first` å’Œ `rest` ç»„ä»¶ã€‚è¿™ç‰¹åˆ«æœ‰ç”¨ï¼Œå› ä¸º `first` æœ‰ä¸€ä¸ªç‰¹å®šé—®é¢˜çš„å«ä¹‰ï¼ˆä¾‹å¦‚ï¼Œåœ¨ä»·æ ¼åˆ—è¡¨ä¸­çš„ `price` ç­‰ï¼‰ã€‚'
- en: The right-hand side of every `=>` is an expression.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ª `=>` çš„å³ä¾§éƒ½æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ã€‚
- en: Hereâ€™s how `cases` works in this instance. Pyret first evaluates `e`. It then
    checks that the resulting value truly is a list; otherwise it halts with an error.
    If it is a list, Pyret examines what kind of list it is. If itâ€™s an empty list,
    it runs the expression after the `=>` in the `empty` clause. Otherwise, the list
    is not empty, which means it has a first and rest; Pyret binds `f` and `r` to
    the two parts, respectively, and then evaluates the expression after the `=>`
    in the `link` clause.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯å¦‚ä½•åœ¨è¿™ä¸ªå®ä¾‹ä¸­ä½¿ç”¨ `cases` çš„ã€‚Pyret é¦–å…ˆè¯„ä¼° `e`ã€‚ç„¶åæ£€æŸ¥ç»“æœå€¼æ˜¯å¦ç¡®å®æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼›å¦‚æœä¸æ˜¯ï¼Œå®ƒå°†å› é”™è¯¯è€Œåœæ­¢ã€‚å¦‚æœæ˜¯åˆ—è¡¨ï¼ŒPyret
    ä¼šæ£€æŸ¥å®ƒæ˜¯ä»€ä¹ˆç±»å‹çš„åˆ—è¡¨ã€‚å¦‚æœæ˜¯ç©ºåˆ—è¡¨ï¼Œå®ƒå°†è¿è¡Œ `empty` å­å¥åé¢çš„è¡¨è¾¾å¼ã€‚å¦åˆ™ï¼Œåˆ—è¡¨ä¸ä¸ºç©ºï¼Œè¿™æ„å‘³ç€å®ƒæœ‰ä¸€ä¸ªé¦–éƒ¨å’Œå‰©ä½™éƒ¨åˆ†ï¼›Pyret åˆ†åˆ«å°† `f`
    å’Œ `r` ç»‘å®šåˆ°è¿™ä¸¤éƒ¨åˆ†ï¼Œç„¶åè¯„ä¼° `link` å­å¥åé¢çš„è¡¨è¾¾å¼ã€‚
- en: Exercise
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try using a non-listâ€”<wbr>e.g., a numberâ€”<wbr>in the `e` position and see what
    happens!
  id: totrans-129
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°è¯•åœ¨ `e` ä½ç½®ä½¿ç”¨éåˆ—è¡¨â€”â€”ä¾‹å¦‚ï¼Œä¸€ä¸ªæ•°å­—â€”â€”çœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆï¼
- en: 'Now letâ€™s use `cases` to define `my-len`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬ä½¿ç”¨ `cases` æ¥å®šä¹‰ `my-len`ï¼š
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This follows from our examples: when the list is empty `my-len` produces `0`;
    when it is not empty, we add one to the length of the rest of the list (here,
    `r`).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä»æˆ‘ä»¬çš„ç¤ºä¾‹ä¸­å¾—å‡ºçš„ï¼šå½“åˆ—è¡¨ä¸ºç©ºæ—¶ï¼Œ`my-len` äº§ç”Ÿ `0`ï¼›å½“å®ƒä¸ä¸ºç©ºæ—¶ï¼Œæˆ‘ä»¬å‘åˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„é•¿åº¦ï¼ˆè¿™é‡Œï¼Œ`r`ï¼‰åŠ ä¸€ã€‚
- en: Note that while our most recent collection of `my-len` examples explicitly said
    `.rest`, when using `cases` we instead use just the name `r`, which Pyret has
    already defined (under the hood) to be `l.rest`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè™½ç„¶æˆ‘ä»¬æœ€è¿‘çš„ `my-len` ç¤ºä¾‹æ˜ç¡®æåˆ°äº† `.rest`ï¼Œä½†åœ¨ä½¿ç”¨ `cases` æ—¶ï¼Œæˆ‘ä»¬åªä½¿ç”¨åç§° `r`ï¼Œè¿™æ˜¯ Pyret å·²ç»å®šä¹‰çš„ï¼ˆåœ¨å¹•åï¼‰ä¸º
    `l.rest`ã€‚
- en: 'Similarly, letâ€™s define `my-sum`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»ä¼¼åœ°ï¼Œè®©æˆ‘ä»¬å®šä¹‰ `my-sum`ï¼š
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how similar they are in code, and how readily the structure of the data
    suggest a structure for the program. This is a pattern you will get very used
    to soon!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„å®ƒä»¬åœ¨ä»£ç ä¸Šçš„ç›¸ä¼¼æ€§ï¼Œä»¥åŠæ•°æ®ç»“æ„å¦‚ä½•è‡ªç„¶è€Œç„¶åœ°å»ºè®®ç¨‹åºçš„ç»“æ„ã€‚è¿™å°†æ˜¯æ‚¨å¾ˆå¿«å°±ä¼šä¹ æƒ¯çš„æ¨¡å¼ï¼
- en: 'Strategy: Developing Functions Over Lists'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç­–ç•¥ï¼šåœ¨åˆ—è¡¨ä¸Šå¼€å‘å‡½æ•°
- en: ''
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Leverage the structure of lists and the power of concrete examples to develop
    list-processing functions.
  id: totrans-139
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åˆ©ç”¨åˆ—è¡¨çš„ç»“æ„å’Œå…·ä½“ç¤ºä¾‹çš„å¼ºå¤§åŠŸèƒ½æ¥å¼€å‘åˆ—è¡¨å¤„ç†å‡½æ•°ã€‚
- en: ''
  id: totrans-140
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pick a concrete list with (at least) three elements. Write a sequence of examples
    for each of the entire list and each suffix of the list (including the empty list).
  id: totrans-141
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€‰æ‹©ä¸€ä¸ªå…·æœ‰ï¼ˆè‡³å°‘ï¼‰ä¸‰ä¸ªå…ƒç´ çš„å…·ä½“ç³»åˆ—ã€‚ä¸ºæ•´ä¸ªåˆ—è¡¨å’Œåˆ—è¡¨çš„æ¯ä¸ªåç¼€ï¼ˆåŒ…æ‹¬ç©ºåˆ—è¡¨ï¼‰ç¼–å†™ä¸€ç³»åˆ—ç¤ºä¾‹ã€‚
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-143
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Rewrite each example to express its expected answer in terms of the `first`
    and `rest` data of its input list. You donâ€™t have to use the `first` and `rest`
    operators in the new answers, but you should see the `first` and `rest` values
    represented explicitly in the answer.
  id: totrans-144
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å°†æ¯ä¸ªä¾‹å­é‡å†™ï¼Œç”¨å…¶è¾“å…¥åˆ—è¡¨çš„`first`å’Œ`rest`æ•°æ®æ¥è¡¨ç¤ºå…¶é¢„æœŸçš„ç­”æ¡ˆã€‚ä½ ä¸å¿…åœ¨æ–°ç­”æ¡ˆä¸­ä½¿ç”¨`first`å’Œ`rest`è¿ç®—ç¬¦ï¼Œä½†ä½ åº”è¯¥çœ‹åˆ°`first`å’Œ`rest`å€¼åœ¨ç­”æ¡ˆä¸­æ˜ç¡®è¡¨ç¤ºã€‚
- en: ''
  id: totrans-145
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Look for a pattern across the answers in the examples. Use these to develop
    the code: write a `cases` expression, filling in the right side of each `=>` based
    on your examples.'
  id: totrans-147
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ä¾‹å­ä¸­çš„ç­”æ¡ˆä¸­å¯»æ‰¾æ¨¡å¼ã€‚ä½¿ç”¨è¿™äº›æ¥å¼€å‘ä»£ç ï¼šç¼–å†™ä¸€ä¸ª`cases`è¡¨è¾¾å¼ï¼Œæ ¹æ®ä½ çš„ä¾‹å­å¡«å†™æ¯ä¸ª`=>`çš„å³ä¾§ã€‚
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This strategy applies to structured data in general, leveraging components of
    each datum rather than specifically `first` and `rest` as presented so far.
  id: totrans-151
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ç§ç­–ç•¥é€‚ç”¨äºç»“æ„åŒ–æ•°æ®ï¼Œåˆ©ç”¨æ¯ä¸ªæ•°æ®é¡¹çš„ç»„ä»¶ï¼Œè€Œä¸æ˜¯åƒè¿„ä»Šä¸ºæ­¢æ‰€å±•ç¤ºçš„é‚£æ ·å…·ä½“ä½¿ç”¨`first`å’Œ`rest`ã€‚
- en: 5.2.4Â Structural Problems that Transform Lists[ğŸ”—](#(part._.Structural_.Problems_that_.Transform_.Lists)
    "Link to here")
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.4 ç»“æ„åŒ–é—®é¢˜ï¼Œè½¬æ¢åˆ—è¡¨[ğŸ”—](#(part._.Structural_.Problems_that_.Transform_.Lists) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Now that we have a systematic way to develop functions that take lists as input,
    letâ€™s apply that same strategy to functions that produce a list as the answer.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†å¼€å‘ä»¥åˆ—è¡¨ä¸ºè¾“å…¥çš„å‡½æ•°çš„ç³»ç»Ÿæ–¹æ³•ï¼Œè®©æˆ‘ä»¬å°†ç›¸åŒçš„ç­–ç•¥åº”ç”¨åˆ°äº§ç”Ÿåˆ—è¡¨ä½œä¸ºç­”æ¡ˆçš„å‡½æ•°ã€‚
- en: '5.2.4.1Â `my-doubles`: Examples and Code[ğŸ”—](#(part._doubles-eg-code) "Link to
    here")'
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.4.1 `my-doubles`ï¼šç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._doubles-eg-code) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'As always, weâ€™ll begin with some examples. Given a list of numbers, we want
    a list that doubles each number (in the order of the original list). Hereâ€™s a
    reasonable example with three numbers:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: å’Œå¾€å¸¸ä¸€æ ·ï¼Œæˆ‘ä»¬å°†ä»ä¸€äº›ä¾‹å­å¼€å§‹ã€‚ç»™å®šä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œæˆ‘ä»¬æƒ³è¦ä¸€ä¸ªåˆ—è¡¨ï¼Œå…¶ä¸­æ¯ä¸ªæ•°å­—éƒ½ç¿»å€ï¼ˆæŒ‰ç…§åŸå§‹åˆ—è¡¨çš„é¡ºåºï¼‰ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªåŒ…å«ä¸‰ä¸ªæ•°å­—çš„åˆç†ç¤ºä¾‹ï¼š
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As before, letâ€™s write out the answers for each suffix of our example list
    as well, including for the `empty` list:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: å’Œä»¥å‰ä¸€æ ·ï¼Œè®©æˆ‘ä»¬å†™å‡ºæˆ‘ä»¬ä¾‹å­åˆ—è¡¨æ¯ä¸ªåç¼€çš„ç­”æ¡ˆï¼ŒåŒ…æ‹¬å¯¹äº`empty`åˆ—è¡¨ï¼š
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we rewrite the answer expressions to include the concrete `first` and
    `rest` data for each example. Letâ€™s start with just the `first` data, and just
    on the first example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å°†ç­”æ¡ˆè¡¨è¾¾å¼é‡å†™ï¼ŒåŒ…æ‹¬æ¯ä¸ªä¾‹å­çš„å…·ä½“`first`å’Œ`rest`æ•°æ®ã€‚è®©æˆ‘ä»¬ä»åªåŒ…å«`first`æ•°æ®å¼€å§‹ï¼Œåªé’ˆå¯¹ç¬¬ä¸€ä¸ªä¾‹å­ï¼š
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, letâ€™s include the `rest` data (`[list: 5, 2]`) in the first example.
    The current answer in the first example is'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ¥ä¸‹æ¥ï¼Œè®©æˆ‘ä»¬åœ¨ç¬¬ä¸€ä¸ªä¾‹å­ä¸­åŒ…å«`rest`æ•°æ®ï¼ˆ`[list: 5, 2]`ï¼‰ã€‚ç¬¬ä¸€ä¸ªä¾‹å­ä¸­çš„å½“å‰ç­”æ¡ˆæ˜¯'
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'and that `[list: 10, 4]` is the result of using the function on `[list: 5,
    2]`. We might therefore be tempted to replace the right side of the first example
    with:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¹¶ä¸”`[list: 10, 4]`æ˜¯ä½¿ç”¨å‡½æ•°å¯¹`[list: 5, 2]`åº”ç”¨çš„ç»“æœã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šæƒ³ç”¨ä»¥ä¸‹å†…å®¹æ›¿æ¢ç¬¬ä¸€ä¸ªä¾‹å­ä¸­çš„å³ä¾§ï¼š'
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Do Now!
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What value would this expression produce? You might want to try this example
    that doesnâ€™t use `my-doubles` directly:'
  id: totrans-167
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè¡¨è¾¾å¼ä¼šäº§ç”Ÿä»€ä¹ˆå€¼ï¼Ÿä½ å¯èƒ½æƒ³å°è¯•è¿™ä¸ªä¸ç›´æ¥ä½¿ç”¨`my-doubles`çš„ä¾‹å­ï¼š
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-169
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Oops! We want a single (flat) list, not a list-within-a-list. This feels like
    it is on the right track in terms of reworking the answer to use the `first` and
    `rest` values, but weâ€™re clearly not quite there yet.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: å“å‘€ï¼æˆ‘ä»¬æƒ³è¦ä¸€ä¸ªå•ä¸€çš„ï¼ˆæ‰å¹³ï¼‰åˆ—è¡¨ï¼Œè€Œä¸æ˜¯åˆ—è¡¨ä¸­çš„åˆ—è¡¨ã€‚ä»é‡æ–°æ„å»ºç­”æ¡ˆä»¥ä½¿ç”¨`first`å’Œ`rest`å€¼çš„è§’åº¦æ¥çœ‹ï¼Œè¿™æ„Ÿè§‰æ˜¯æ­£ç¡®çš„æ–¹å‘ï¼Œä½†æˆ‘ä»¬æ˜¾ç„¶è¿˜æ²¡æœ‰å®Œå…¨åˆ°è¾¾é‚£é‡Œã€‚
- en: Do Now!
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What value does the following expression produce?
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹è¡¨è¾¾å¼ä¼šäº§ç”Ÿä»€ä¹ˆå€¼ï¼Ÿ
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-175
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice the difference between the two expressions in these last two exercises:
    the latter used `link` to put the value involving `first` into the conversion
    of the `rest`, while the former tried to do this with `list:`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„è¿™ä¸¤ä¸ªæœ€åç»ƒä¹ ä¸­çš„ä¸¤ä¸ªè¡¨è¾¾å¼çš„åŒºåˆ«ï¼šåè€…ä½¿ç”¨`link`å°†æ¶‰åŠ`first`çš„å€¼æ”¾å…¥`rest`çš„è½¬æ¢ä¸­ï¼Œè€Œå‰è€…è¯•å›¾ç”¨`list:`æ¥åšè¿™ä»¶äº‹ã€‚
- en: Do Now!
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many elements are in the lists that result from each of the following expressions?
  id: totrans-179
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¯ä¸ªä»¥ä¸‹è¡¨è¾¾å¼äº§ç”Ÿçš„åˆ—è¡¨ä¸­æœ‰å¤šå°‘ä¸ªå…ƒç´ ï¼Ÿ
- en: ''
  id: totrans-180
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-181
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Do Now!
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summarize the difference between how `link` and `list:` combine an element and
    a list. Try additional examples at the interactions prompt if needed to explore
    these ideas.
  id: totrans-184
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ€»ç»“`link`å’Œ`list:`å¦‚ä½•ç»„åˆå…ƒç´ å’Œåˆ—è¡¨ä¹‹é—´çš„åŒºåˆ«ã€‚å¦‚æœéœ€è¦ï¼Œåœ¨äº¤äº’æç¤ºç¬¦ä¸­å°è¯•é¢å¤–çš„ä¾‹å­æ¥æ¢ç´¢è¿™äº›æƒ³æ³•ã€‚
- en: 'The takeaway here is that we use `link` to insert an element into an existing
    list, whereas we use `list:` to make a new list that contains the old list as
    an element. Going back to our examples, then, we include `rest` in the first example
    by writing it as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„å¯ç¤ºæ˜¯ï¼Œæˆ‘ä»¬ä½¿ç”¨ `link` å°†å…ƒç´ æ’å…¥åˆ°ç°æœ‰åˆ—è¡¨ä¸­ï¼Œè€Œä½¿ç”¨ `list:` æ¥åˆ›å»ºä¸€ä¸ªåŒ…å«æ—§åˆ—è¡¨ä½œä¸ºå…ƒç´ çš„æ–°åˆ—è¡¨ã€‚å›åˆ°æˆ‘ä»¬çš„ä¾‹å­ï¼Œé‚£ä¹ˆï¼Œæˆ‘ä»¬åœ¨ç¬¬ä¸€ä¸ªä¾‹å­ä¸­é€šè¿‡ä»¥ä¸‹æ–¹å¼åŒ…å«
    `rest`ï¼š
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: which we then convert to
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åå°†å…¶è½¬æ¢ä¸º
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Applying this idea across the examples, we get:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: å°†è¿™ä¸ªæƒ³æ³•åº”ç”¨åˆ°ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬å¾—åˆ°ï¼š
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that we have examples that explicitly use the `first` and `rest` elements,
    we can produce to write the `my-doubles` function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†æ˜ç¡®ä½¿ç”¨ `first` å’Œ `rest` å…ƒç´ çš„ç¤ºä¾‹ï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™ `my-doubles` å‡½æ•°ï¼š
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '5.2.4.2Â `my-str-len`: Examples and Code[ğŸ”—](#(part._str-len-eg-code) "Link to
    here")'
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.4.2 `my-str-len`: ç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._str-len-eg-code) "é“¾æ¥è‡³æ­¤")'
- en: 'In `my-doubles`, the input and output lists have the same type of element.
    Functions can also produce lists whose contents have a different type from the
    input list. Letâ€™s work through an example. Given a list of strings, we want the
    lengths of each string (in the same order as in the input list). Thus, hereâ€™s
    a reasonable example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ `my-doubles` ä¸­ï¼Œè¾“å…¥å’Œè¾“å‡ºåˆ—è¡¨å…·æœ‰ç›¸åŒçš„å…ƒç´ ç±»å‹ã€‚å‡½æ•°ä¹Ÿå¯ä»¥ç”Ÿæˆå†…å®¹ç±»å‹ä¸è¾“å…¥åˆ—è¡¨ä¸åŒçš„åˆ—è¡¨ã€‚è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªä¾‹å­æ¥åˆ†æã€‚ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œæˆ‘ä»¬æƒ³è¦æ¯ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦ï¼ˆä¸è¾“å…¥åˆ—è¡¨ä¸­çš„é¡ºåºç›¸åŒï¼‰ã€‚å› æ­¤ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªåˆç†çš„ä¾‹å­ï¼š
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As we have before, we should consider the answers for each sub-problem of the
    above example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚åŒä¹‹å‰ï¼Œæˆ‘ä»¬åº”è¯¥è€ƒè™‘ä¸Šè¿°ç¤ºä¾‹ä¸­æ¯ä¸ªå­é—®é¢˜çš„ç­”æ¡ˆï¼š
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Or, in other words:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…æ¢å¥è¯è¯´ï¼š
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'which tells us that the response for the empty list should be `empty`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å‘Šè¯‰æˆ‘ä»¬ç©ºåˆ—è¡¨çš„å“åº”åº”è¯¥æ˜¯ `empty`ï¼š
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The next step is to rework the answers in the examples to make the `first`
    and `rest` parts explicit. Hopefully by now you are starting to detect a pattern:
    The result on the rest of the list appears explicitly as another example. Therefore,
    weâ€™ll start by getting the `rest` value of each example input into the answer:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹ä¸€æ­¥æ˜¯å°†ç¤ºä¾‹ä¸­çš„ç­”æ¡ˆé‡æ–°æ•´ç†ï¼Œä½¿ `first` å’Œ `rest` éƒ¨åˆ†æ˜ç¡®åŒ–ã€‚å¸Œæœ›åˆ°ç°åœ¨ä½ å·²ç»å¼€å§‹å‘ç°ä¸€ä¸ªæ¨¡å¼ï¼šåˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†çš„è¾“å‡ºæ˜ç¡®åœ°ä½œä¸ºå¦ä¸€ä¸ªç¤ºä¾‹å‡ºç°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†é¦–å…ˆè·å–æ¯ä¸ªç¤ºä¾‹è¾“å…¥çš„
    `rest` å€¼æ”¾å…¥ç­”æ¡ˆä¸­ï¼š
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'All that remains now is to figure out how to work the `first` values into the
    outputs. In the context of this problem, this means we need to convert `"hi"`
    into `2`, `"there"` into `5`, and so on. From the problem statement, we know that
    `2` and `5` are meant to be the lengths (character counts) of the corresponding
    strings. The operation that determines the length of a string is called `string-length`.
    Thus, our examples appear as:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨å‰©ä¸‹çš„åªæ˜¯å¼„æ¸…æ¥šå¦‚ä½•å°† `first` å€¼æ•´åˆåˆ°è¾“å‡ºä¸­ã€‚åœ¨è¿™ä¸ªé—®é¢˜çš„èƒŒæ™¯ä¸‹ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬éœ€è¦å°† `"hi"` è½¬æ¢ä¸º `2`ï¼Œå°† `"there"`
    è½¬æ¢ä¸º `5`ï¼Œä¾æ­¤ç±»æ¨ã€‚ä»é—®é¢˜é™ˆè¿°ä¸­ï¼Œæˆ‘ä»¬çŸ¥é“ `2` å’Œ `5` æ˜¯æŒ‡ç›¸åº”å­—ç¬¦ä¸²çš„é•¿åº¦ï¼ˆå­—ç¬¦è®¡æ•°ï¼‰ã€‚ç¡®å®šå­—ç¬¦ä¸²é•¿åº¦çš„æ“ä½œç§°ä¸º `string-length`ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„ç¤ºä¾‹å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'From here, we write a function that captures the pattern developed across our
    examples:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™é‡Œï¼Œæˆ‘ä»¬ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æ•æ‰æˆ‘ä»¬åœ¨ç¤ºä¾‹ä¸­å¼€å‘çš„æ¨¡å¼ï¼š
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 5.2.5Â Structural Problems that Select from Lists[ğŸ”—](#(part._.Structural_.Problems_that_.Select_from_.Lists)
    "Link to here")
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.5 ä»åˆ—è¡¨ä¸­é€‰æ‹©çš„ç»“æ„æ€§é—®é¢˜[ğŸ”—](#(part._.Structural_.Problems_that_.Select_from_.Lists)
    "é“¾æ¥è‡³æ­¤")
- en: 'In the previous section, we saw functions that transform list elements (by
    doubling numbers or counting characters). The type of the output list may or may
    not be the same as the type of the input list. Other functions that produce lists
    instead select elements: every element in the output list was in the input list,
    but some input-list elements might not appear in the output list. This section
    adapts our method of deriving functions from examples to accommodate selection
    of elements.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸Šä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†è½¬æ¢åˆ—è¡¨å…ƒç´ ï¼ˆé€šè¿‡åŠ å€æ•°å­—æˆ–è®¡æ•°å­—ç¬¦ï¼‰çš„å‡½æ•°ã€‚è¾“å‡ºåˆ—è¡¨çš„ç±»å‹å¯èƒ½ä¸è¾“å…¥åˆ—è¡¨çš„ç±»å‹ç›¸åŒï¼Œä¹Ÿå¯èƒ½ä¸åŒã€‚å…¶ä»–ç”Ÿæˆåˆ—è¡¨è€Œä¸æ˜¯é€‰æ‹©å…ƒç´ çš„å‡½æ•°ï¼Œå…¶è¾“å‡ºåˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½åœ¨è¾“å…¥åˆ—è¡¨ä¸­ï¼Œä½†è¾“å…¥åˆ—è¡¨ä¸­çš„ä¸€äº›å…ƒç´ å¯èƒ½ä¸ä¼šå‡ºç°åœ¨è¾“å‡ºåˆ—è¡¨ä¸­ã€‚æœ¬èŠ‚å°†æˆ‘ä»¬çš„ä»ç¤ºä¾‹æ¨å¯¼å‡½æ•°çš„æ–¹æ³•é€‚åº”å…ƒç´ é€‰æ‹©ã€‚
- en: '5.2.5.1Â `my-pos-nums`: Examples and Code[ğŸ”—](#(part._pos-nums-eg-code) "Link
    to here")'
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.5.1 `my-pos-nums`: ç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._pos-nums-eg-code) "é“¾æ¥è‡³æ­¤")'
- en: As our first example, we will select the positive numbers from a list that contains
    both positive and non-positive numbers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªç¤ºä¾‹ï¼Œæˆ‘ä»¬å°†ä»åŒ…å«æ­£æ•°å’Œéæ­£æ•°çš„åˆ—è¡¨ä¸­é€‰æ‹©æ­£æ•°ã€‚
- en: Do Now!
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Construct the sequence of examples that we obtain from the input `[list: 1,
    -2, 3, -4]`.'
  id: totrans-214
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'æ„å»ºä»è¾“å…¥åˆ—è¡¨ `[list: 1, -2, 3, -4]` ä¸­è·å¾—çš„ç¤ºä¾‹åºåˆ—ã€‚'
- en: 'Here we go:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¼€å§‹å§ï¼š
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can write this in the following form:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å†™æˆä»¥ä¸‹å½¢å¼ï¼š
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: or, even more explicitly,
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…ï¼Œæ›´æ˜ç¡®åœ°è¯´ï¼Œ
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Unlike in the example sequences for functions that transform lists, here we
    see that the answers have different shapes: some involve a `link`, while others
    simply process the `rest` of the list. Whenever we need different shapes of outputs
    across a set of examples, we will need an `if` expression in our code to distinguish
    the conditions that yield each shape.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å‡½æ•°å˜æ¢åˆ—è¡¨çš„ç¤ºä¾‹åºåˆ—ä¸åŒï¼Œè¿™é‡Œæˆ‘ä»¬çœ‹åˆ°ç­”æ¡ˆæœ‰ä¸åŒçš„å½¢çŠ¶ï¼šä¸€äº›æ¶‰åŠä¸€ä¸ª`é“¾æ¥`ï¼Œè€Œå¦ä¸€äº›åªæ˜¯å¤„ç†åˆ—è¡¨çš„`å‰©ä½™éƒ¨åˆ†`ã€‚æ¯å½“æˆ‘ä»¬éœ€è¦åœ¨ä¸€ç³»åˆ—ç¤ºä¾‹ä¸­è¾“å‡ºä¸åŒå½¢çŠ¶æ—¶ï¼Œæˆ‘ä»¬å°†åœ¨ä»£ç ä¸­ä½¿ç”¨`if`è¡¨è¾¾å¼æ¥åŒºåˆ†äº§ç”Ÿæ¯ç§å½¢çŠ¶çš„æ¡ä»¶ã€‚
- en: 'What determines which shape of output we get? Letâ€™s rearrange the examples
    (other than the empty-list input) by output shape:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¯ä»€ä¹ˆå†³å®šäº†æˆ‘ä»¬å¾—åˆ°å“ªç§å½¢çŠ¶çš„è¾“å‡ºï¼Ÿè®©æˆ‘ä»¬æŒ‰ç…§è¾“å‡ºå½¢çŠ¶é‡æ–°æ’åˆ—ç¤ºä¾‹ï¼ˆé™¤äº†ç©ºåˆ—è¡¨è¾“å…¥ï¼‰ï¼š
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Re-organized, we can see that the examples that use `link` have a positive
    number in the `first` position, while the ones that donâ€™t simply process the `rest`
    of the list. That indicates that our `if` expression needs to ask whether the
    `first` element in the list is positive. This yields the following program:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: é‡æ–°ç»„ç»‡åï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä½¿ç”¨`link`çš„ç¤ºä¾‹åœ¨`first`ä½ç½®æœ‰ä¸€ä¸ªæ­£æ•°ï¼Œè€Œæ²¡æœ‰ä½¿ç”¨`link`çš„ç¤ºä¾‹åªæ˜¯å¤„ç†åˆ—è¡¨çš„`rest`éƒ¨åˆ†ã€‚è¿™è¡¨æ˜æˆ‘ä»¬çš„`if`è¡¨è¾¾å¼éœ€è¦è¯¢é—®åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¦ä¸ºæ­£æ•°ã€‚è¿™äº§ç”Ÿäº†ä»¥ä¸‹ç¨‹åºï¼š
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Do Now!
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is our set of examples comprehensive?
  id: totrans-228
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ç¤ºä¾‹é›†æ˜¯å¦å…¨é¢ï¼Ÿ
- en: Not really. There are many examples we havenâ€™t considered, such as lists that
    end with positive numbers and lists with `0`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šä¸æ˜¯ã€‚è¿˜æœ‰å¾ˆå¤šæˆ‘ä»¬æ²¡æœ‰è€ƒè™‘åˆ°çš„ç¤ºä¾‹ï¼Œä¾‹å¦‚ä»¥æ­£æ•°ç»“å°¾çš„åˆ—è¡¨å’ŒåŒ…å«`0`çš„åˆ—è¡¨ã€‚
- en: Exercise
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Work through these examples and see how they affect the program!
  id: totrans-232
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: é€ä¸ªåˆ†æè¿™äº›ç¤ºä¾‹ï¼Œçœ‹çœ‹å®ƒä»¬å¦‚ä½•å½±å“ç¨‹åºï¼
- en: '5.2.5.2Â `my-alternating`: Examples and Code[ğŸ”—](#(part._alternating-eg-code)
    "Link to here")'
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.5.2Â `my-alternating`: ç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._alternating-eg-code) "é“¾æ¥è‡³æ­¤")'
- en: Now letâ€™s consider a problem that selects elements not by value, but by position.
    We want to write a function that selects alternating elements from a list. Once
    again, weâ€™re going to work from examples.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ªé—®é¢˜ï¼Œå®ƒä¸æ˜¯é€šè¿‡å€¼è€Œæ˜¯é€šè¿‡ä½ç½®é€‰æ‹©å…ƒç´ ã€‚æˆ‘ä»¬æƒ³è¦ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œä»åˆ—è¡¨ä¸­é€‰æ‹©äº¤æ›¿å…ƒç´ ã€‚æˆ‘ä»¬å†æ¬¡å°†ä»ç¤ºä¾‹å¼€å§‹å·¥ä½œã€‚
- en: Do Now!
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Work out the results for `my-alternating` starting from the list `[list: 1,
    2, 3, 4, 5, 6]`.'
  id: totrans-237
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'ä»åˆ—è¡¨`[list: 1, 2, 3, 4, 5, 6]`å¼€å§‹ï¼Œè®¡ç®—`my-alternating`çš„ç»“æœã€‚'
- en: 'Hereâ€™s how they work out:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å®ƒä»¬å¦‚ä½•å·¥ä½œçš„ï¼š
- en: <alternating-egs-1> ::=
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <alternating-egs-1> ::=
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Wait, whatâ€™s that? The two answers above are each correct, but the second answer
    does not help us in any way construct the first answer. That means the way weâ€™ve
    solved these problems until now is not enough for this new kind of problem. Itâ€™s
    still useful, though: notice that thereâ€™s a connection between the first example
    and the third, as well as between the second example and the fourth. This observation
    is consistent with our goal of selecting alternating elements.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ç­‰ç­‰ï¼Œé‚£æ˜¯ä»€ä¹ˆï¼Ÿä¸Šé¢çš„ä¸¤ä¸ªç­”æ¡ˆéƒ½æ˜¯æ­£ç¡®çš„ï¼Œä½†ç¬¬äºŒä¸ªç­”æ¡ˆå¹¶ä¸èƒ½å¸®åŠ©æˆ‘ä»¬ä»¥ä»»ä½•æ–¹å¼æ„å»ºç¬¬ä¸€ä¸ªç­”æ¡ˆã€‚è¿™æ„å‘³ç€æˆ‘ä»¬åˆ°ç›®å‰ä¸ºæ­¢è§£å†³é—®é¢˜çš„æ–¹æ³•å¯¹äºè¿™ç§æ–°ç±»å‹çš„é—®é¢˜è¿˜ä¸å¤Ÿã€‚å°½ç®¡å¦‚æ­¤ï¼Œå®ƒä»ç„¶æ˜¯æœ‰ç”¨çš„ï¼šè¯·æ³¨æ„ï¼Œç¬¬ä¸€ä¸ªç¤ºä¾‹å’Œç¬¬ä¸‰ä¸ªç¤ºä¾‹ä¹‹é—´ï¼Œä»¥åŠç¬¬äºŒä¸ªç¤ºä¾‹å’Œç¬¬å››ä¸ªç¤ºä¾‹ä¹‹é—´æœ‰è”ç³»ã€‚è¿™ä¸ªè§‚å¯Ÿç»“æœä¸æˆ‘ä»¬çš„é€‰æ‹©äº¤æ›¿å…ƒç´ çš„ç›®æ ‡ä¸€è‡´ã€‚
- en: 'What would something like this look like in code? Before we try to write the
    function, letâ€™s rewrite the first example in terms of the third:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ ·çš„ä»£ç ä¼šæ˜¯ä»€ä¹ˆæ ·å­ï¼Ÿåœ¨æˆ‘ä»¬å°è¯•ç¼–å†™å‡½æ•°ä¹‹å‰ï¼Œè®©æˆ‘ä»¬ç”¨ç¬¬ä¸‰ç§æ–¹å¼é‡å†™ç¬¬ä¸€ä¸ªç¤ºä¾‹ï¼š
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that in the rewritten version, we are dropping two elements from the list
    before using `my-alternating` again, not just one. We will have to figure out
    how to handle that in our code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨é‡å†™çš„ç‰ˆæœ¬ä¸­ï¼Œæˆ‘ä»¬åœ¨å†æ¬¡ä½¿ç”¨`my-alternating`ä¹‹å‰ä»åˆ—è¡¨ä¸­åˆ é™¤äº†ä¸¤ä¸ªå…ƒç´ ï¼Œè€Œä¸ä»…ä»…æ˜¯åˆ é™¤ä¸€ä¸ªã€‚æˆ‘ä»¬å°†åœ¨ä»£ç ä¸­æ‰¾å‡ºå¦‚ä½•å¤„ç†è¿™ä¸€ç‚¹ã€‚
- en: 'Letâ€™s start with our usual function pattern with a `cases` expression:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»æˆ‘ä»¬å¸¸ç”¨çš„å¸¦æœ‰`cases`è¡¨è¾¾å¼çš„å‡½æ•°æ¨¡å¼å¼€å§‹ï¼š
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note that we cannot simply call `my-alternating` on `r`, because `r` excludes
    only one item from the list, not two as this problem requires. We have to break
    down `r` as well, in order to get to the `rest` of the `rest` of the original
    list. To do this, we use another `cases` expression, nested within the first `cases`
    expression:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬ä¸èƒ½ç®€å•åœ°åœ¨å¯¹`r`è°ƒç”¨`my-alternating`ï¼Œå› ä¸º`r`åªä»åˆ—è¡¨ä¸­æ’é™¤äº†ä¸€ä¸ªé¡¹ç›®ï¼Œè€Œä¸æ˜¯åƒè¿™ä¸ªé—®é¢˜æ‰€è¦æ±‚çš„é‚£æ ·æ’é™¤ä¸¤ä¸ªã€‚æˆ‘ä»¬å¿…é¡»å°†`r`åˆ†è§£ï¼Œä»¥ä¾¿åˆ°è¾¾åŸå§‹åˆ—è¡¨çš„`rest`çš„`rest`ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨å¦ä¸€ä¸ª`cases`è¡¨è¾¾å¼ï¼Œå®ƒåµŒå¥—åœ¨ç¬¬ä¸€ä¸ª`cases`è¡¨è¾¾å¼ä¸­ï¼š
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This code is consistent with the example that we just worked out. But note
    that we still have a bit of unfinished work to do: we need to decide what to do
    in the `empty` case of the inner `cases` expression (marked by `???` in the code).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µä»£ç ä¸æˆ‘ä»¬åˆšåˆšå·¥ä½œçš„ç¤ºä¾‹ä¸€è‡´ã€‚ä½†è¯·æ³¨æ„ï¼Œæˆ‘ä»¬è¿˜æœ‰ä¸€äº›æœªå®Œæˆçš„å·¥ä½œè¦åšï¼šæˆ‘ä»¬éœ€è¦å†³å®šåœ¨å†…å±‚`cases`è¡¨è¾¾å¼çš„`empty`æƒ…å†µä¸‹ï¼ˆåœ¨ä»£ç ä¸­ç”¨`???`æ ‡è®°ï¼‰è¦åšä»€ä¹ˆã€‚
- en: A common temptation at this point is to replace the `???` with `[list:]`. After
    all, havenâ€™t we always returned `[list:]` in the `empty` cases?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªé˜¶æ®µï¼Œä¸€ä¸ªå¸¸è§çš„è¯±æƒ‘æ˜¯å°†`???`æ›¿æ¢ä¸º`[list:]`ã€‚æ¯•ç«Ÿï¼Œæˆ‘ä»¬ä¸æ˜¯æ€»æ˜¯åœ¨`empty`æƒ…å†µä¸‹è¿”å›`[list:]`å—ï¼Ÿ
- en: Do Now!
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Replace `???` with `[list:]` and test the program on our original examples:'
  id: totrans-253
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°†`???`æ›¿æ¢ä¸º`[list:]`å¹¶åœ¨æˆ‘ä»¬çš„åŸå§‹ç¤ºä¾‹ä¸Šæµ‹è¯•ç¨‹åºï¼š
- en: ''
  id: totrans-254
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-255
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ''
  id: totrans-256
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you observe?
  id: totrans-257
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ è§‚å¯Ÿåˆ°äº†ä»€ä¹ˆï¼Ÿ
- en: Oops! Weâ€™ve written a program that appears to work on lists with an even number
    of elements, but not on lists with an odd number of elements. How did that happen?
    The only part of this code that we guessed at was how to fill in the `empty` case
    of the inner `cases`, so the issue must be there. Rather than focus on the code,
    however, focus on the examples. We need a simple example that would land on that
    part of the code. We get to that spot when the list `l` is not empty, but `r`
    (the rest of `l`) is empty. In other words, we need an example with only one element.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: å“å‘€ï¼æˆ‘ä»¬ç¼–å†™äº†ä¸€ä¸ªä¼¼ä¹åœ¨å¶æ•°å…ƒç´ åˆ—è¡¨ä¸Šå·¥ä½œä½†åœ¨å¥‡æ•°å…ƒç´ åˆ—è¡¨ä¸Šä¸å·¥ä½œçš„ç¨‹åºã€‚è¿™æ˜¯æ€ä¹ˆå‘ç”Ÿçš„ï¼Ÿæˆ‘ä»¬çŒœæµ‹çš„è¿™éƒ¨åˆ†ä»£ç æ˜¯å¦‚ä½•å¡«å……å†…éƒ¨`cases`çš„`empty`æƒ…å†µï¼Œæ‰€ä»¥é—®é¢˜è‚¯å®šåœ¨é‚£é‡Œã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ä¸å…¶å…³æ³¨ä»£ç ï¼Œä¸å¦‚å…³æ³¨ç¤ºä¾‹ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½åˆ°è¾¾é‚£æ®µä»£ç ã€‚å½“æˆ‘ä»¬åˆ—è¡¨`l`ä¸ä¸ºç©ºï¼Œä½†`r`ï¼ˆ`l`çš„å…¶ä½™éƒ¨åˆ†ï¼‰ä¸ºç©ºæ—¶ï¼Œæˆ‘ä»¬å°±åˆ°è¾¾äº†é‚£ä¸ªåœ°æ–¹ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåªæœ‰ä¸€ä¸ªå…ƒç´ çš„ç¤ºä¾‹ã€‚
- en: Do Now!
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Finish the following example:'
  id: totrans-261
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®Œæˆä»¥ä¸‹ç¤ºä¾‹ï¼š
- en: ''
  id: totrans-262
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-263
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Given a list with one element, that element should be included in a list of
    alternating elements. Thus, we should finish this example as
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªåªæœ‰ä¸€ä¸ªå…ƒç´ çš„åˆ—è¡¨ï¼Œè¯¥å…ƒç´ åº”åŒ…å«åœ¨äº¤æ›¿å…ƒç´ åˆ—è¡¨ä¸­ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥è¿™æ ·å®Œæˆè¿™ä¸ªç¤ºä¾‹
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Do Now!
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use this example to update the result of `my-alternating` when `r` is `empty`
    in our code.
  id: totrans-268
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸ªç¤ºä¾‹æ¥æ›´æ–°æˆ‘ä»¬ä»£ç ä¸­`r`ä¸º`empty`æ—¶`my-alternating`çš„ç»“æœã€‚
- en: 'Leveraging this new example, the final version of `my-alternating` is as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ©ç”¨è¿™ä¸ªæ–°ç¤ºä¾‹ï¼Œ`my-alternating`çš„æœ€ç»ˆç‰ˆæœ¬å¦‚ä¸‹ï¼š
- en: '[PRE52]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Whatâ€™s the takeaway from this problem? There are two:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªé—®é¢˜çš„å¯ç¤ºæ˜¯ä»€ä¹ˆï¼Ÿæœ‰ä¸¤ä¸ªï¼š
- en: 'Donâ€™t skip the small examples: the result of a list-processing function on
    the `empty` case wonâ€™t always be `empty`.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸è¦å¿½ç•¥å°ä¾‹å­ï¼šåˆ—è¡¨å¤„ç†å‡½æ•°åœ¨`empty`æƒ…å†µä¸‹çš„ç»“æœä¸æ€»æ˜¯`empty`ã€‚
- en: If a problem asks you to work with multiple elements from the front of a list,
    you can nest `cases` expressions to access later elements.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœä¸€ä¸ªé—®é¢˜è¦æ±‚ä½ å¤„ç†åˆ—è¡¨å‰é¢çš„å¤šä¸ªå…ƒç´ ï¼Œä½ å¯ä»¥åµŒå¥—`cases`è¡¨è¾¾å¼æ¥è®¿é—®åé¢çš„å…ƒç´ ã€‚
- en: 'These takeaways will matter again in future examples: keep an eye out for them!'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›è¦ç‚¹åœ¨æœªæ¥ç¤ºä¾‹ä¸­è¿˜ä¼šå¾ˆé‡è¦ï¼šè¯·æ³¨æ„å®ƒä»¬ï¼
- en: 5.2.6Â Structural Problems Over Relaxed Domains[ğŸ”—](#(part._struct-prob-sub-dom)
    "Link to here")
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.6Â å…³äºå®½æ¾åŸŸçš„ç»“æ„é—®é¢˜[ğŸ”—](#(part._struct-prob-sub-dom) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: '5.2.6.1Â `my-max`: Examples[ğŸ”—](#(part._my-max) "Link to here")'
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.6.1Â `my-max`: ç¤ºä¾‹[ğŸ”—](#(part._my-max) "é“¾æ¥åˆ°è¿™é‡Œ")'
- en: 'Now letâ€™s find the maximum value of a list. Letâ€™s assume for simplicity that
    weâ€™re dealing with just lists of numbers. What kinds of lists should we construct?
    Clearly, we should have empty and non-empty listsâ€¦but what else? Is a list like
    `[list: 1, 2, 3]` a good example? Well, thereâ€™s nothing wrong with it, but we
    should also consider lists where the maximum is at the beginning rather than at
    the end; the maximum might be in the middle; the maximum might be repeated; the
    maximum might be negative; and so on. While not comprehensive, here is a small
    but interesting set of examples:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨æˆ‘ä»¬æ¥æ‰¾å‡ºåˆ—è¡¨ä¸­çš„æœ€å¤§å€¼ã€‚ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å‡è®¾æˆ‘ä»¬åªå¤„ç†æ•°å­—åˆ—è¡¨ã€‚æˆ‘ä»¬åº”è¯¥æ„å»ºä»€ä¹ˆæ ·çš„åˆ—è¡¨å‘¢ï¼Ÿæ˜¾ç„¶ï¼Œæˆ‘ä»¬åº”è¯¥æœ‰ç©ºåˆ—è¡¨å’Œéç©ºåˆ—è¡¨â€¦â€¦ä½†æ˜¯è¿˜æœ‰ä»€ä¹ˆï¼Ÿä¸€ä¸ªåƒ`[list:
    1, 2, 3]`è¿™æ ·çš„åˆ—è¡¨æ˜¯ä¸€ä¸ªå¥½ä¾‹å­å—ï¼Ÿå—¯ï¼Œå®ƒæ²¡æœ‰é—®é¢˜ï¼Œä½†æˆ‘ä»¬è¿˜åº”è¯¥è€ƒè™‘æœ€å¤§å€¼åœ¨å¼€å¤´è€Œä¸æ˜¯ç»“å°¾çš„åˆ—è¡¨ï¼›æœ€å¤§å€¼å¯èƒ½åœ¨ä¸­é—´ï¼›æœ€å¤§å€¼å¯èƒ½é‡å¤ï¼›æœ€å¤§å€¼å¯èƒ½æ˜¯è´Ÿæ•°ï¼›ç­‰ç­‰ã€‚è™½ç„¶ä¸æ˜¯å…¨é¢çš„ï¼Œä½†è¿™é‡Œæœ‰ä¸€ç»„å°è€Œæœ‰è¶£çš„ä¾‹å­ï¼š'
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: What about `my-max(empty)`?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆ`my-max(empty)`å‘¢ï¼Ÿ
- en: Do Now!
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Could we define `my-max(empty)` to be `0`? Returning `0` for the empty list
    has worked well twice already!
  id: totrans-282
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬èƒ½å¦å®šä¹‰`my-max(empty)`ä¸º`0`ï¼Ÿå¯¹äºç©ºåˆ—è¡¨ï¼Œè¿”å›`0`å·²ç»æœ‰æ•ˆä¸¤æ¬¡äº†ï¼
- en: Weâ€™ll return to this in a while.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç¨åå†å›åˆ°è¿™ä¸ªé—®é¢˜ã€‚
- en: 'Before we proceed, itâ€™s useful to know that thereâ€™s a function called `num-max`
    already defined in Pyret, that compares two numbers:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬ç»§ç»­ä¹‹å‰ï¼Œäº†è§£Pyretä¸­å·²ç»å®šä¹‰äº†ä¸€ä¸ªåä¸º`num-max`çš„å‡½æ•°æ˜¯æœ‰ç”¨çš„ï¼Œè¯¥å‡½æ•°ç”¨äºæ¯”è¾ƒä¸¤ä¸ªæ•°å­—ï¼š
- en: '[PRE54]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Exercise
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose `num-max` were not already built in. Can you define it? You will find
    what you learned about [Booleans](Conditionals_and_Booleans.html#%28part._booleans%29)
    handy. Remember to write some tests!
  id: totrans-288
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‡è®¾`num-max`è¿˜æ²¡æœ‰å†…ç½®ã€‚ä½ èƒ½å®šä¹‰å®ƒå—ï¼Ÿä½ ä¼šå‘ç°ä½ å­¦åˆ°çš„å…³äº[å¸ƒå°”å€¼](Conditionals_and_Booleans.html#%28part._booleans%29)çš„çŸ¥è¯†å¾ˆæœ‰ç”¨ã€‚è®°å¾—å†™ä¸€äº›æµ‹è¯•ï¼
- en: 'Now we can look at `my-max` at work:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥çœ‹çœ‹`my-max`æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼š
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Hmm. That didnâ€™t really teach us anything, did it? Maybe, we canâ€™t be sure.
    And we still donâ€™t know what to do with `empty`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: å—¯ã€‚è¿™å¹¶æ²¡æœ‰çœŸæ­£æ•™ä¼šæˆ‘ä»¬ä»€ä¹ˆï¼Œæ˜¯å—ï¼Ÿä¹Ÿè®¸ï¼Œæˆ‘ä»¬æ— æ³•ç¡®å®šã€‚æˆ‘ä»¬ä»ç„¶ä¸çŸ¥é“å¦‚ä½•å¤„ç†`empty`ã€‚
- en: 'Letâ€™s try the second example input:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°è¯•ç¬¬äºŒä¸ªç¤ºä¾‹è¾“å…¥ï¼š
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is actually telling us something useful as well, but maybe we canâ€™t see
    it yet. Letâ€™s take on something more ambitious:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å®é™…ä¸Šä¹Ÿåœ¨å‘Šè¯‰æˆ‘ä»¬ä¸€äº›æœ‰ç”¨çš„ä¿¡æ¯ï¼Œä½†æˆ‘ä»¬å¯èƒ½è¿˜æ²¡æœ‰çœ‹åˆ°ã€‚è®©æˆ‘ä»¬æ‰¿æ‹…ä¸€ä¸ªæ›´æœ‰é›„å¿ƒçš„ä»»åŠ¡ï¼š
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Observe how the maximum of the rest of the list gives us a candidate answer,
    but comparing it to the first element gives us a definitive one:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿåˆ°åˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„æœ€å¤§å€¼ç»™æˆ‘ä»¬æä¾›äº†ä¸€ä¸ªå€™é€‰ç­”æ¡ˆï¼Œä½†ä¸ç¬¬ä¸€ä¸ªå…ƒç´ æ¯”è¾ƒåï¼Œæˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªç¡®å®šçš„ç­”æ¡ˆï¼š
- en: '[PRE58]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The last one is a little awkward: weâ€™d like to write'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åä¸€ä¸ªæ˜¯æœ‰ç‚¹å°´å°¬ï¼šæˆ‘ä»¬å¸Œæœ›å†™æˆ
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: but we donâ€™t really know what the maximum (or minimum, or any other element)
    of the empty list is, but we can only provide numbers to `num-max`. Therefore,
    leaving out that dodgy case, weâ€™re left with
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æˆ‘ä»¬å®é™…ä¸Šå¹¶ä¸çŸ¥é“ç©ºåˆ—è¡¨çš„æœ€å¤§å€¼ï¼ˆæˆ–æœ€å°å€¼ï¼Œæˆ–ä»»ä½•å…¶ä»–å…ƒç´ ï¼‰æ˜¯ä»€ä¹ˆï¼Œæˆ‘ä»¬åªèƒ½å‘`num-max`æä¾›æ•°å­—ã€‚å› æ­¤ï¼Œæ’é™¤äº†é‚£ä¸ªå¯ç–‘çš„æƒ…å†µåï¼Œæˆ‘ä»¬åªå‰©ä¸‹
- en: '[PRE60]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Our examples have again helped: theyâ€™ve revealed how we can use the answer
    for each rest of the list to compute the answer for the whole list, which in turn
    is the rest of some other list, and so on. If you go back and look at the other
    example lists we wrote above, youâ€™ll see the pattern holds there too.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ç¤ºä¾‹å†æ¬¡å¸®åˆ°äº†æˆ‘ä»¬ï¼šå®ƒä»¬æ­ç¤ºäº†æˆ‘ä»¬å¯ä»¥å¦‚ä½•ä½¿ç”¨åˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„ç­”æ¡ˆæ¥è®¡ç®—æ•´ä¸ªåˆ—è¡¨çš„ç­”æ¡ˆï¼Œè€Œè¿™ä¸ªç­”æ¡ˆåè¿‡æ¥åˆæ˜¯å¦ä¸€ä¸ªåˆ—è¡¨çš„å‰©ä½™éƒ¨åˆ†ï¼Œä»¥æ­¤ç±»æ¨ã€‚å¦‚æœä½ å›é¡¾ä¸€ä¸‹æˆ‘ä»¬ä¸Šé¢å†™çš„å…¶ä»–ç¤ºä¾‹åˆ—è¡¨ï¼Œä½ ä¹Ÿä¼šçœ‹åˆ°è¿™ä¸ªæ¨¡å¼åœ¨é‚£é‡ŒåŒæ ·é€‚ç”¨ã€‚
- en: 'However, itâ€™s time we now confront the `empty` case. The real problem is that
    we donâ€™t have a maximum for the empty list: for any number we might provide, there
    is always a number bigger than it (assuming our computer is large enough) that
    could have been the answer instead. In short, itâ€™s nonsensical to ask for the
    maximum (or minimum) of the empty list: the concept of â€œmaximumâ€ is only defined
    on non-empty lists! That is, when asked for the maximum of an empty list, we should
    signal an error:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œç°åœ¨æ˜¯æ—¶å€™é¢å¯¹`empty`æƒ…å†µäº†ã€‚çœŸæ­£çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬æ²¡æœ‰ç©ºåˆ—è¡¨çš„æœ€å¤§å€¼ï¼šå¯¹äºæˆ‘ä»¬å¯èƒ½æä¾›çš„ä»»ä½•æ•°å­—ï¼Œæ€»æœ‰ä¸€ä¸ªæ›´å¤§çš„æ•°å­—ï¼ˆå‡è®¾æˆ‘ä»¬çš„è®¡ç®—æœºè¶³å¤Ÿå¤§ï¼‰å¯èƒ½æ˜¯ç­”æ¡ˆã€‚ç®€è€Œè¨€ä¹‹ï¼Œè¦æ±‚ç©ºåˆ—è¡¨çš„æœ€å¤§å€¼ï¼ˆæˆ–æœ€å°å€¼ï¼‰æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼šæœ€å¤§å€¼çš„æ¦‚å¿µä»…åœ¨éç©ºåˆ—è¡¨ä¸Šå®šä¹‰ï¼ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“è¦æ±‚ç©ºåˆ—è¡¨çš„æœ€å¤§å€¼æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥å‘å‡ºé”™è¯¯ä¿¡å·ï¼š
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: (which is how, in Pyret, we say that it will generate an error; we donâ€™t care
    about the details of the error, hence the empty string).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆè¿™æ˜¯æˆ‘ä»¬å¦‚ä½•åœ¨Pyretä¸­è¡¨ç¤ºå®ƒå°†å¼•å‘é”™è¯¯çš„æ–¹å¼ï¼›æˆ‘ä»¬ä¸åœ¨ä¹é”™è¯¯çš„ç»†èŠ‚ï¼Œå› æ­¤æ˜¯ç©ºå­—ç¬¦ä¸²ï¼‰ã€‚
- en: '5.2.6.2Â `my-max`: From Examples to Code[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)
    "Link to here")'
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.6.2Â `my-max`: ä»ç¤ºä¾‹åˆ°ä»£ç [ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)
    "é“¾æ¥åˆ°æ­¤å¤„")'
- en: 'Once again, we can codify the examples above, i.e., turn them into a uniform
    program that works for all instances. However, we now have a twist. If we blindly
    followed the pattern weâ€™ve used earlier, we would end up with:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸Šè¿°ç¤ºä¾‹ç¼–ç åŒ–ï¼Œå³ï¼Œå°†å®ƒä»¬è½¬æ¢æˆä¸€ä¸ªé€‚ç”¨äºæ‰€æœ‰å®ä¾‹çš„ç»Ÿä¸€ç¨‹åºã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ç°åœ¨æœ‰ä¸€ä¸ªè½¬æŠ˜ç‚¹ã€‚å¦‚æœæˆ‘ä»¬ç›²ç›®åœ°éµå¾ªä¹‹å‰ä½¿ç”¨çš„æ¨¡å¼ï¼Œæˆ‘ä»¬æœ€ç»ˆä¼šå¾—åˆ°ï¼š
- en: '[PRE62]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Do Now!
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whatâ€™s wrong with this?
  id: totrans-311
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™æœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ
- en: 'Consider the list `[list: 2]`. This turns into'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 'è€ƒè™‘åˆ—è¡¨`[list: 2]`ã€‚è¿™å˜æˆäº†'
- en: '[PRE63]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: which of course raises an error. Therefore, this function never works for any
    list that has one or more elements!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å½“ç„¶ä¼šå¼•å‘é”™è¯¯ã€‚å› æ­¤ï¼Œè¿™ä¸ªå‡½æ•°å¯¹ä»»ä½•åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªå…ƒç´ çš„åˆ—è¡¨éƒ½ä¸ä¼šå·¥ä½œï¼
- en: 'Thatâ€™s because we need to make sure we arenâ€™t trying to compute the maximum
    of the empty list. Going back to our examples, we see that what we need to do,
    before calling `my-max`, is check whether the rest of the list is empty. If it
    is, we do not want to call `my-max` at all. That is:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å› ä¸ºæˆ‘ä»¬éœ€è¦ç¡®ä¿æˆ‘ä»¬ä¸æ˜¯åœ¨å°è¯•è®¡ç®—ç©ºåˆ—è¡¨çš„æœ€å¤§å€¼ã€‚å›åˆ°æˆ‘ä»¬çš„ç¤ºä¾‹ï¼Œæˆ‘ä»¬çœ‹åˆ°åœ¨æˆ‘ä»¬è°ƒç”¨`my-max`ä¹‹å‰éœ€è¦åšçš„äº‹æƒ…æ˜¯æ£€æŸ¥åˆ—è¡¨çš„å‰©ä½™éƒ¨åˆ†æ˜¯å¦ä¸ºç©ºã€‚å¦‚æœæ˜¯ï¼Œæˆ‘ä»¬æ ¹æœ¬ä¸æƒ³è°ƒç”¨`my-max`ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼š
- en: '[PRE64]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Weâ€™ll return to what to do when the rest is not empty in a moment.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç¨åå›åˆ°å½“å‰©ä½™éƒ¨åˆ†ä¸ä¸ºç©ºæ—¶åº”è¯¥åšä»€ä¹ˆã€‚
- en: 'If the rest of the list `l` is empty, our examples above tell us that the maximum
    is the first element in the list. Therefore, we can fill this in:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœåˆ—è¡¨çš„å‰©ä½™éƒ¨åˆ†`l`ä¸ºç©ºï¼Œæˆ‘ä»¬çš„ä¸Šè¿°ç¤ºä¾‹å‘Šè¯‰æˆ‘ä»¬æœ€å¤§å€¼æ˜¯åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å¡«å†™ï¼š
- en: '[PRE65]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Note in particular the absence of a call to `my-max`. If the list is not empty,
    however, our examples above tell us that `my-max` will give us the maximum of
    the rest of the list, and we just need to compare this answer with the first element
    (`f`):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ç‰¹åˆ«æ³¨æ„ï¼Œæ²¡æœ‰è°ƒç”¨`my-max`ã€‚ç„¶è€Œï¼Œå¦‚æœåˆ—è¡¨ä¸ä¸ºç©ºï¼Œæˆ‘ä»¬çš„ä¸Šè¿°ç¤ºä¾‹å‘Šè¯‰æˆ‘ä»¬`my-max`å°†ç»™å‡ºåˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„æœ€å¤§å€¼ï¼Œæˆ‘ä»¬åªéœ€è¦å°†è¿™ä¸ªç­”æ¡ˆä¸ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ˆ`f`ï¼‰è¿›è¡Œæ¯”è¾ƒï¼š
- en: '[PRE66]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: And sure enough, this definition does the job!
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œè¿™ä¸ªå®šä¹‰ç¡®å®å®Œæˆäº†ä»»åŠ¡ï¼
- en: 5.2.7Â More Structural Problems with Scalar Answers[ğŸ”—](#(part._.More_.Structural_.Problems_with_.Scalar_.Answers)
    "Link to here")
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.7Â å…·æœ‰æ ‡é‡ç­”æ¡ˆçš„æ›´å¤šç»“æ„åŒ–é—®é¢˜[ğŸ”—](#(part._.More_.Structural_.Problems_with_.Scalar_.Answers)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: '5.2.7.1Â `my-avg`: Examples[ğŸ”—](#(part._avg-eg) "Link to here")'
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.7.1Â `my-avg`: ç¤ºä¾‹[ğŸ”—](#(part._avg-eg) "é“¾æ¥åˆ°æ­¤å¤„")'
- en: 'Letâ€™s now try to compute the average of a list of numbers. Letâ€™s start with
    the example list `[list: 1, 2, 3, 4]` and work out more examples from it. The
    average of numbers in this list is clearly `(1 + 2 + 3 + 4)/4`, or `10/4`.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨æˆ‘ä»¬æ¥å°è¯•è®¡ç®—ä¸€ä¸ªæ•°å­—åˆ—è¡¨çš„å¹³å‡å€¼ã€‚è®©æˆ‘ä»¬ä»ä¸€ä¸ªä¾‹å­åˆ—è¡¨ `[list: 1, 2, 3, 4]` å¼€å§‹ï¼Œå¹¶ä»ä¸­æ¨å¯¼å‡ºæ›´å¤šçš„ä¾‹å­ã€‚è¿™ä¸ªåˆ—è¡¨ä¸­æ•°å­—çš„å¹³å‡å€¼æ˜¾ç„¶æ˜¯
    `(1 + 2 + 3 + 4)/4`ï¼Œå³ `10/4`ã€‚'
- en: 'Based on the listâ€™s structure, we see that the rest of the list is `[list:
    2, 3, 4]`, and the rest of that is `[list: 3, 4]`, and so on. The resulting averages
    are:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ ¹æ®åˆ—è¡¨çš„ç»“æ„ï¼Œæˆ‘ä»¬çœ‹åˆ°åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æ˜¯ `[list: 2, 3, 4]`ï¼Œè€Œé‚£éƒ¨åˆ†å‰©ä½™çš„æ˜¯ `[list: 3, 4]`ï¼Œä¾æ­¤ç±»æ¨ã€‚å¾—åˆ°çš„ç»“æœå¹³å‡å€¼æ˜¯ï¼š'
- en: '[PRE67]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The problem is, itâ€™s simply not clear how we get from the answer for the sub-list
    to the answer for the whole list. That is, given the following two bits of information:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜åœ¨äºï¼Œæˆ‘ä»¬æ ¹æœ¬ä¸æ¸…æ¥šå¦‚ä½•ä»å­åˆ—è¡¨çš„ç­”æ¡ˆå¾—åˆ°æ•´ä¸ªåˆ—è¡¨çš„ç­”æ¡ˆã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œç»™å®šä»¥ä¸‹ä¸¤ä¸ªä¿¡æ¯ï¼š
- en: The average of the remainder of the list is `9/3`, i.e., `3`.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„å¹³å‡å€¼æ˜¯ `9/3`ï¼Œå³ `3`ã€‚
- en: The first number in the list is `1`.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªæ•°å­—æ˜¯ `1`ã€‚
- en: 'How do we determine that the average of the whole list must be `10/4`? If itâ€™s
    not clear to you, donâ€™t worry: with just those two pieces of information, itâ€™s
    impossible!'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•ç¡®å®šæ•´ä¸ªåˆ—è¡¨çš„å¹³å‡å€¼å¿…é¡»æ˜¯ `10/4`ï¼Ÿå¦‚æœä½ è§‰å¾—ä¸æ¸…æ¥šï¼Œä¸è¦æ‹…å¿ƒï¼šåªæœ‰è¿™ä¸¤æ¡ä¿¡æ¯ï¼Œæ˜¯ä¸å¯èƒ½åšåˆ°çš„ï¼
- en: 'Hereâ€™s a simpler example that explains why. Letâ€™s suppose the first value in
    a list is `1`, and the average of the rest of the list is `2`. Here are two very
    different lists that fit this description:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªæ›´ç®€å•çš„ä¾‹å­ï¼Œå¯ä»¥è§£é‡ŠåŸå› ã€‚å‡è®¾åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå€¼æ˜¯ `1`ï¼Œåˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„å¹³å‡å€¼æ˜¯ `2`ã€‚è¿™é‡Œæœ‰ä¸¤ç»„éå¸¸ä¸åŒçš„åˆ—è¡¨ç¬¦åˆè¿™ä¸ªæè¿°ï¼š
- en: '[PRE68]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The average of the entire first list is `3/2`, while the average of the entire
    second list is `5/3`, and the two are not the same.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: æ•´ä¸ªç¬¬ä¸€ä¸ªåˆ—è¡¨çš„å¹³å‡å€¼æ˜¯ `3/2`ï¼Œè€Œæ•´ä¸ªç¬¬äºŒä¸ªåˆ—è¡¨çš„å¹³å‡å€¼æ˜¯ `5/3`ï¼Œè¿™ä¸¤ä¸ªå€¼å¹¶ä¸ç›¸åŒã€‚
- en: That is, to compute the average of a whole list, itâ€™s not even useful to know
    the average of the rest of the list. Rather, we need to know the sum and the length
    of the rest of the list. With these two, we can add the first to the sum, and
    `1` to the length, and compute the new average.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸ºäº†è®¡ç®—æ•´ä¸ªåˆ—è¡¨çš„å¹³å‡å€¼ï¼Œç”šè‡³çŸ¥é“åˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„å¹³å‡å€¼éƒ½æ²¡æœ‰ç”¨ã€‚ç›¸åï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“åˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„å’Œä»¥åŠé•¿åº¦ã€‚æœ‰äº†è¿™ä¸¤ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥å°†ç¬¬ä¸€ä¸ªå€¼åŠ åˆ°å’Œä¸Šï¼Œå¹¶å°†
    `1` åŠ åˆ°é•¿åº¦ä¸Šï¼Œç„¶åè®¡ç®—æ–°çš„å¹³å‡å€¼ã€‚
- en: 'In principle, we could try to make a `average` function that returns all this
    information. Instead, it will be a lot simpler to simply decompose the task into
    two smaller tasks. After all, we have already seen how to compute the length and
    how to compute the sum. The average, therefore, can just use these existing functions:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ä»åŸåˆ™ä¸Šè®²ï¼Œæˆ‘ä»¬å¯ä»¥å°è¯•åˆ›å»ºä¸€ä¸ª `average` å‡½æ•°ï¼Œå®ƒè¿”å›æ‰€æœ‰è¿™äº›ä¿¡æ¯ã€‚ç„¶è€Œï¼Œå°†ä»»åŠ¡åˆ†è§£æˆä¸¤ä¸ªæ›´å°çš„ä»»åŠ¡ä¼šç®€å•å¾—å¤šã€‚æ¯•ç«Ÿï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å¦‚ä½•è®¡ç®—é•¿åº¦å’Œå¦‚ä½•è®¡ç®—å’Œã€‚å› æ­¤ï¼Œå¹³å‡å€¼å¯ä»¥ç›´æ¥ä½¿ç”¨è¿™äº›ç°æœ‰çš„å‡½æ•°ï¼š
- en: '[PRE69]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Do Now!
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹å³è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What should be the average of the empty list? Does the above code produce what
    you would expect?
  id: totrans-340
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç©ºåˆ—è¡¨çš„å¹³å‡å€¼åº”è¯¥æ˜¯å¤šå°‘ï¼Ÿä¸Šé¢çš„ä»£ç æ˜¯å¦äº§ç”Ÿäº†ä½ é¢„æœŸçš„ç»“æœï¼Ÿ
- en: 'Just as we argued earlier about the maximum [[Structural Problems Over Relaxed
    Domains](#%28part._struct-prob-sub-dom%29)], the average of the empty list isnâ€™t
    a well-defined concept. Therefore, it would be appropriate to signal an error.
    The implementation above does this, but poorly: it reports an error on division.
    A better programming practice would be to catch this situation and report the
    error right away, rather than hoping some other function will report the error.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬ä¹‹å‰å…³äºæœ€å¤§[[ç»“æ„åŒ–é—®é¢˜åœ¨æ”¾å®½åŸŸä¸­](#(part._struct-prob-sub-dom%29)]çš„è®¨è®ºï¼Œç©ºåˆ—è¡¨çš„å¹³å‡å€¼ä¸æ˜¯ä¸€ä¸ªå®šä¹‰è‰¯å¥½çš„æ¦‚å¿µã€‚å› æ­¤ï¼Œå‘å‡ºä¸€ä¸ªé”™è¯¯ä¿¡å·æ˜¯åˆé€‚çš„ã€‚ä¸Šé¢çš„å®ç°å°±æ˜¯è¿™æ ·åšçš„ï¼Œä½†åšå¾—ä¸å¥½ï¼šå®ƒåœ¨é™¤æ³•æ—¶æŠ¥å‘Šé”™è¯¯ã€‚æ›´å¥½çš„ç¼–ç¨‹å®è·µæ˜¯ç«‹å³æ•è·è¿™ç§æƒ…å†µå¹¶æŠ¥å‘Šé”™è¯¯ï¼Œè€Œä¸æ˜¯å¸Œæœ›å…¶ä»–å‡½æ•°ä¼šæŠ¥å‘Šé”™è¯¯ã€‚
- en: Exercise
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alter `my-avg` above to signal an error when given the empty list.
  id: totrans-344
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¿®æ”¹ `my-avg` ä»¥åœ¨ç»™å®šç©ºåˆ—è¡¨æ—¶å‘å‡ºé”™è¯¯ä¿¡å·ã€‚
- en: 'Therefore, we see that the process weâ€™ve usedâ€”<wbr>of inferring code from examplesâ€”<wbr>wonâ€™t
    always suffice, and weâ€™ll need more sophisticated techniques to solve some problems.
    However, notice that working from examples helps us quickly identify situations
    where this approach does and doesnâ€™t work. Furthermore, if you look more closely
    youâ€™ll notice that the examples above do hint at how to solve the problem: in
    our very first examples, we wrote answers like `10/4`, `9/3`, and `7/2`, which
    correspond to the sum of the numbers divided by the length. Thus, writing the
    answers in this form (as opposed, for instance, to writing the second of those
    as `3`) already reveals a structure for a solution.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬çœ‹åˆ°æˆ‘ä»¬ä½¿ç”¨çš„æµç¨‹â€”â€”ä»ä¾‹å­ä¸­æ¨æ–­ä»£ç â€”â€”å¹¶ä¸æ€»æ˜¯è¶³å¤Ÿï¼Œæˆ‘ä»¬éœ€è¦æ›´é«˜çº§çš„æŠ€æœ¯æ¥è§£å†³ä¸€äº›é—®é¢˜ã€‚ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œä»ä¾‹å­å¼€å§‹å¯ä»¥å¸®åŠ©æˆ‘ä»¬å¿«é€Ÿè¯†åˆ«è¿™ç§æ–¹æ³•æ˜¯å¦æœ‰æ•ˆã€‚æ­¤å¤–ï¼Œå¦‚æœä½ æ›´ä»”ç»†åœ°è§‚å¯Ÿï¼Œä½ ä¼šæ³¨æ„åˆ°ä¸Šè¿°ä¾‹å­ç¡®å®æš—ç¤ºäº†å¦‚ä½•è§£å†³é—®é¢˜ï¼šåœ¨æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å†™å‡ºäº†åƒ`10/4`ã€`9/3`å’Œ`7/2`è¿™æ ·çš„ç­”æ¡ˆï¼Œè¿™äº›ç­”æ¡ˆå¯¹åº”äºæ•°å­—çš„æ€»å’Œé™¤ä»¥é•¿åº¦ã€‚å› æ­¤ï¼Œä»¥è¿™ç§å½¢å¼ï¼ˆä¾‹å¦‚ï¼Œå°†ç¬¬äºŒä¸ªå†™æˆ`3`ï¼‰å†™å‡ºç­”æ¡ˆå·²ç»æ­ç¤ºäº†è§£å†³æ–¹æ¡ˆçš„ç»“æ„ã€‚
- en: 5.2.8Â Structural Problems with Accumulators[ğŸ”—](#(part._accumulators) "Link to
    here")
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.8Â ç´¯åŠ å™¨çš„ç»“æ„é—®é¢˜[ğŸ”—](#(part._accumulators) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: '5.2.8.1Â `my-running-sum`: First Attempt[ğŸ”—](#(part._running-sum-1st-attempt)
    "Link to here")'
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.8.1Â `my-running-sum`: é¦–æ¬¡å°è¯•[ğŸ”—](#(part._running-sum-1st-attempt) "é“¾æ¥åˆ°è¿™é‡Œ")'
- en: One more time, weâ€™ll begin with an example.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: å†ä¸€æ¬¡ï¼Œæˆ‘ä»¬å°†ä»ä¸€ä¸ªä¾‹å­å¼€å§‹ã€‚
- en: Do Now!
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Work out the results for `my-running-sum` starting from the list `[list: 1,
    2, 3, 4, 5]`.'
  id: totrans-351
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'è®¡ç®—ä»åˆ—è¡¨ `[list: 1, 2, 3, 4, 5]` å¼€å§‹çš„`my-running-sum`çš„ç»“æœã€‚'
- en: 'Hereâ€™s what our first few examples look like:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯æˆ‘ä»¬å‰å‡ ä¸ªä¾‹å­çœ‹èµ·æ¥åƒè¿™æ ·ï¼š
- en: <running-sum-egs-1> ::=
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: <running-sum-egs-1> ::=
- en: '[PRE70]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Again, there doesnâ€™t appear to be any clear connection between the result on
    the rest of the list and the result on the entire list.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡ï¼Œä¼¼ä¹æ²¡æœ‰æ˜æ˜¾çš„è”ç³»å­˜åœ¨äºåˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„ç»“æœå’Œæ•´ä¸ªåˆ—è¡¨çš„ç»“æœä¹‹é—´ã€‚
- en: '(That isnâ€™t strictly true: we can still line up the answers as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆè¿™å¹¶ä¸å®Œå…¨æ­£ç¡®ï¼šæˆ‘ä»¬ä»ç„¶å¯ä»¥åƒä»¥ä¸‹è¿™æ ·æ’åˆ—ç­”æ¡ˆï¼š
- en: '[PRE71]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: and observe that weâ€™re computing the answer for the rest of the list, then adding
    the first element to each element in the answer, and `link`ing the first element
    to the front. In principle, we can compute this solution directly, but for now
    that may be more work than finding a simpler way to answer it.)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¶è§‚å¯Ÿæˆ‘ä»¬æ­£åœ¨è®¡ç®—åˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„ç­”æ¡ˆï¼Œç„¶åå°†ç¬¬ä¸€ä¸ªå…ƒç´ æ·»åŠ åˆ°ç­”æ¡ˆä¸­çš„æ¯ä¸ªå…ƒç´ ä¸Šï¼Œå¹¶å°†ç¬¬ä¸€ä¸ªå…ƒç´ `link`åˆ°å‰é¢ã€‚åŸåˆ™ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è®¡ç®—è¿™ä¸ªè§£å†³æ–¹æ¡ˆï¼Œä½†å°±ç›®å‰è€Œè¨€ï¼Œè¿™å¯èƒ½æ¯”æ‰¾åˆ°æ›´ç®€å•çš„ç­”æ¡ˆè¦å¤æ‚ã€‚
- en: '5.2.8.2Â `my-running-sum`: Examples and Code[ğŸ”—](#(part._running-sum-eg-code)
    "Link to here")'
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.8.2Â `my-running-sum`: ç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._running-sum-eg-code) "é“¾æ¥åˆ°è¿™é‡Œ")'
- en: 'Recall how we began in [`my-running-sum`: First Attempt](#%28part._running-sum-1st-attempt%29).
    Our examples [[<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)] showed the
    following problem. When we process the rest of the list, we have forgotten everything
    about what preceded it. That is, when processing the list starting at `2` we forget
    that weâ€™ve seen a `1` earlier; when starting from `3`, we forget that weâ€™ve seen
    both `1` and `2` earlier; and so on. In other words, we keep forgetting the past.
    We need some way of avoiding that.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 'å›æƒ³ä¸€ä¸‹æˆ‘ä»¬æ˜¯å¦‚ä½•åœ¨[`my-running-sum`: é¦–æ¬¡å°è¯•](#(part._running-sum-1st-attempt))å¼€å§‹çš„ã€‚æˆ‘ä»¬çš„ä¾‹å­
    [[<running-sum-egs-1>](#(elem._running-sum-egs-1))] å±•ç¤ºäº†ä»¥ä¸‹é—®é¢˜ã€‚å½“æˆ‘ä»¬å¤„ç†åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æ—¶ï¼Œæˆ‘ä»¬å·²ç»å¿˜è®°äº†ä¹‹å‰çš„ä¸€åˆ‡ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“æˆ‘ä»¬ä»`2`å¼€å§‹å¤„ç†åˆ—è¡¨æ—¶ï¼Œæˆ‘ä»¬å¿˜è®°äº†ä¹‹å‰å·²ç»çœ‹åˆ°è¿‡`1`ï¼›å½“æˆ‘ä»¬ä»`3`å¼€å§‹æ—¶ï¼Œæˆ‘ä»¬å¿˜è®°äº†ä¹‹å‰å·²ç»çœ‹åˆ°è¿‡`1`å’Œ`2`ï¼›ä»¥æ­¤ç±»æ¨ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬ä¸€ç›´åœ¨å¿˜è®°è¿‡å»ã€‚æˆ‘ä»¬éœ€è¦ä¸€ç§é¿å…è¿™ç§æƒ…å†µçš„æ–¹æ³•ã€‚'
- en: The easiest thing we can do is simply change our function to carry along this
    â€œmemoryâ€, or what weâ€™ll call an accumulator. That is, imagine we were defining
    a new function, called `my-rs`. It will consume a list of numbers and produce
    a list of numbers, but in addition it will also take the sum of numbers preceding
    the current list.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬èƒ½åšçš„æœ€ç®€å•çš„äº‹æƒ…å°±æ˜¯ç®€å•åœ°æ”¹å˜æˆ‘ä»¬çš„å‡½æ•°ï¼Œä½¿å…¶æºå¸¦è¿™ç§â€œè®°å¿†â€ï¼Œæˆ–è€…æˆ‘ä»¬ç§°ä¹‹ä¸ºç´¯åŠ å™¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæƒ³è±¡æˆ‘ä»¬æ­£åœ¨å®šä¹‰ä¸€ä¸ªæ–°çš„å‡½æ•°ï¼Œç§°ä¸º`my-rs`ã€‚å®ƒå°†æ¶ˆè€—ä¸€ä¸ªæ•°å­—åˆ—è¡¨å¹¶äº§ç”Ÿä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œä½†é™¤æ­¤ä¹‹å¤–ï¼Œå®ƒè¿˜ä¼šä¹Ÿå–å½“å‰åˆ—è¡¨ä¹‹å‰æ•°å­—çš„æ€»å’Œã€‚
- en: Do Now!
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What should the initial sum be?
  id: totrans-364
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åˆå§‹æ€»å’Œåº”è¯¥æ˜¯å¤šå°‘ï¼Ÿ
- en: 'Initially there is no â€œpreceding listâ€, so we will use the additive identity:
    `0`. The type of `my-rs` is'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: åˆå§‹æ—¶æ²¡æœ‰â€œå…ˆå‰çš„åˆ—è¡¨â€ï¼Œå› æ­¤æˆ‘ä»¬å°†ä½¿ç”¨åŠ æ³•æ’ç­‰å¼ï¼š`0`ã€‚`my-rs`çš„ç±»å‹æ˜¯
- en: '[PRE72]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Letâ€™s now re-work our examples from [<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)
    as examples of `my-rs` instead. The examples use the `+` operator to append two
    lists into one (the elements of the first list followed by the elements of the
    second):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç°åœ¨å°†æˆ‘ä»¬çš„ä¾‹å­ä» [<running-sum-egs-1>](#(elem._running-sum-egs-1)) ä½œä¸º`my-rs`çš„ä¾‹å­é‡æ–°å·¥ä½œã€‚è¿™äº›ä¾‹å­ä½¿ç”¨`+`è¿ç®—ç¬¦å°†ä¸¤ä¸ªåˆ—è¡¨åˆå¹¶æˆä¸€ä¸ªï¼ˆç¬¬ä¸€ä¸ªåˆ—è¡¨çš„å…ƒç´ åé¢è·Ÿç€ç¬¬äºŒä¸ªåˆ—è¡¨çš„å…ƒç´ ï¼‰ï¼š
- en: '[PRE73]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'That is, `my-rs` translates into the following code:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿå°±æ˜¯è¯´ï¼Œ`my-rs`è½¬æ¢æˆä»¥ä¸‹ä»£ç ï¼š
- en: '[PRE74]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'All thatâ€™s then left is to call it from `my-running-sum`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åå‰©ä¸‹çš„å°±æ˜¯ä»`my-running-sum`ä¸­è°ƒç”¨å®ƒï¼š
- en: '[PRE75]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Observe that we do not change `my-running-sum` itself to take extra arguments.
    The correctness of our code depends on the initial value of `acc` being 0\. If
    we added a parameter for `acc`, any code that calls `my-running-sum` could supply
    an unexpected value, which would distort the result. In addition, since the value
    is fixed, adding the parameter would amount to shifting additional (and needless)
    work onto others who use our code.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬æ²¡æœ‰æ”¹å˜`my-running-sum`æœ¬èº«ä»¥æ¥å—é¢å¤–çš„å‚æ•°ã€‚æˆ‘ä»¬ä»£ç çš„æ­£ç¡®æ€§å–å†³äº`acc`çš„åˆå§‹å€¼ä¸º0ã€‚å¦‚æœæˆ‘ä»¬ä¸º`acc`æ·»åŠ äº†ä¸€ä¸ªå‚æ•°ï¼Œä»»ä½•è°ƒç”¨`my-running-sum`çš„ä»£ç éƒ½å¯èƒ½æä¾›ä¸€ä¸ªæ„å¤–çš„å€¼ï¼Œè¿™ä¼šæ‰­æ›²ç»“æœã€‚æ­¤å¤–ï¼Œç”±äºå€¼æ˜¯å›ºå®šçš„ï¼Œæ·»åŠ å‚æ•°ç›¸å½“äºå°†é¢å¤–çš„ï¼ˆä¸”ä¸å¿…è¦çš„ï¼‰å·¥ä½œè½¬ç§»åˆ°ä½¿ç”¨æˆ‘ä»¬ä»£ç çš„å…¶ä»–äººèº«ä¸Šã€‚
- en: '5.2.8.3Â `my-alternating`: Examples and Code[ğŸ”—](#(part._alternating-accumulator)
    "Link to here")'
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.8.3Â `my-alternating`ï¼šç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._alternating-accumulator) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Recall our examples in [`my-alternating`: Examples and Code](#%28part._alternating-eg-code%29).
    There, we noticed that the code built on every-other example. We might have chosen
    our examples differently, so that from one example to the next we skipped two
    elements rather than one. Here we will see another way to think about the same
    problem.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ä¸€ä¸‹æˆ‘ä»¬åœ¨[æˆ‘çš„äº¤æ›¿ç¤ºä¾‹ï¼šç¤ºä¾‹å’Œä»£ç ](#(part._alternating-eg-code%29)ä¸­çš„ä¾‹å­ã€‚åœ¨é‚£é‡Œï¼Œæˆ‘ä»¬æ³¨æ„åˆ°ä»£ç æ˜¯åŸºäºæ¯éš”ä¸€ä¸ªä¾‹å­æ„å»ºçš„ã€‚æˆ‘ä»¬å¯èƒ½é€‰æ‹©äº†ä¸åŒçš„ä¾‹å­ï¼Œå› æ­¤ä»ä¸€ä¸ªä¾‹å­åˆ°ä¸‹ä¸€ä¸ªä¾‹å­æˆ‘ä»¬è·³è¿‡äº†ä¸¤ä¸ªå…ƒç´ è€Œä¸æ˜¯ä¸€ä¸ªã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†çœ‹åˆ°å¦ä¸€ç§æ€è€ƒç›¸åŒé—®é¢˜çš„æ–¹æ³•ã€‚
- en: 'Return to the examples weâ€™ve already seen [[<alternating-egs-1>](#%28elem._alternating-egs-1%29)].
    We wrote `my-alternating` to traverse the list essentially two elements at a time.
    Another option is to traverse it just one element at a time, but keeping track
    of whether weâ€™re at an odd or even elementâ€”<wbr>i.e., add â€œmemoryâ€ to our program.
    Since we just need to track that one piece of information, we can use a `Boolean`
    to do it. Letâ€™s define a new function for this purpose:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: å›åˆ°æˆ‘ä»¬å·²ç»çœ‹åˆ°çš„ä¾‹å­[[<alternating-egs-1>](#(elem._alternating-egs-1%29)]ã€‚æˆ‘ä»¬ç¼–å†™äº†`my-alternating`æ¥éå†åˆ—è¡¨ï¼Œå®é™…ä¸Šæ¯æ¬¡ä¸¤ä¸ªå…ƒç´ ã€‚å¦ä¸€ä¸ªé€‰æ‹©æ˜¯é€ä¸ªå…ƒç´ éå†å®ƒï¼Œä½†ä¿æŒè·Ÿè¸ªæˆ‘ä»¬æ˜¯å¦å¤„äºå¥‡æ•°æˆ–å¶æ•°å…ƒç´ â€”â€”å³ï¼Œç»™æˆ‘ä»¬çš„ç¨‹åºæ·»åŠ â€œè®°å¿†â€ã€‚ç”±äºæˆ‘ä»¬åªéœ€è¦è·Ÿè¸ªé‚£ä¸€æ¡ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ª`Boolean`æ¥åšåˆ°è¿™ä¸€ç‚¹ã€‚è®©æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæ–°çš„å‡½æ•°æ¥å®Œæˆè¿™ä¸ªç›®çš„ï¼š
- en: '[PRE76]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The extra argument accumulates whether weâ€™re at an element to keep or one to
    discard.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: é¢å¤–çš„å‚æ•°ç´¯ç§¯æˆ‘ä»¬æ˜¯å¦å¤„äºè¦ä¿ç•™çš„å…ƒç´ è¿˜æ˜¯è¦ä¸¢å¼ƒçš„å…ƒç´ ã€‚
- en: 'We can reuse the existing template for list functions. When we have an element,
    we have to consult the accumulator whether to keep it or not. If its value is
    `true` we `link` it to the answer; otherwise we ignore it. As we process the rest
    of the list, however, we have to remember to update the accumulator: if we kept
    an element we donâ€™t wish to keep the next one, and vice versa.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é‡ç”¨ç°æœ‰çš„åˆ—è¡¨å‡½æ•°æ¨¡æ¿ã€‚å½“æˆ‘ä»¬æœ‰ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»å’¨è¯¢ç´¯åŠ å™¨æ˜¯å¦è¦ä¿ç•™å®ƒã€‚å¦‚æœå…¶å€¼ä¸º`true`ï¼Œæˆ‘ä»¬å°†å…¶`link`åˆ°ç­”æ¡ˆï¼›å¦åˆ™æˆ‘ä»¬å¿½ç•¥å®ƒã€‚ç„¶è€Œï¼Œå½“æˆ‘ä»¬å¤„ç†åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»è®°ä½æ›´æ–°ç´¯åŠ å™¨ï¼šå¦‚æœæˆ‘ä»¬ä¿ç•™äº†ä¸€ä¸ªæˆ‘ä»¬ä¸å¸Œæœ›ä¿ç•™çš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œåä¹‹äº¦ç„¶ã€‚
- en: '[PRE77]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Finally, we have to determine the initial value of the accumulator. In this
    case, since we want to keep alternating elements starting with the first one,
    its initial value should be `true`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬å¿…é¡»ç¡®å®šç´¯åŠ å™¨çš„åˆå§‹å€¼ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå› ä¸ºæˆ‘ä»¬æƒ³ä»ç¬¬ä¸€ä¸ªå…ƒç´ å¼€å§‹äº¤æ›¿å…ƒç´ ï¼Œæ‰€ä»¥å®ƒçš„åˆå§‹å€¼åº”è¯¥æ˜¯`true`ï¼š
- en: '[PRE78]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Exercise
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define `my-max` using an accumulator. What does the accumulator represent? Do
    you encounter any difficulty?
  id: totrans-385
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ç´¯åŠ å™¨å®šä¹‰`my-max`ã€‚ç´¯åŠ å™¨ä»£è¡¨ä»€ä¹ˆï¼Ÿä½ é‡åˆ°ä»»ä½•å›°éš¾å—ï¼Ÿ
- en: 5.2.9Â Dealing with Multiple Answers[ğŸ”—](#(part._.Dealing_with_.Multiple_.Answers)
    "Link to here")
  id: totrans-386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.9Â å¤„ç†å¤šä¸ªç­”æ¡ˆ[ğŸ”—](#(part._.Dealing_with_.Multiple_.Answers) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Our discussion above has assumed there is only one answer for a given input.
    This is often true, but it also depends on how the problem is worded and how we
    choose to generate examples. We will study this in some detail now.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸Šé¢çš„è®¨è®ºå‡è®¾å¯¹äºç»™å®šçš„è¾“å…¥åªæœ‰ä¸€ä¸ªç­”æ¡ˆã€‚è¿™é€šå¸¸æ˜¯æ­£ç¡®çš„ï¼Œä½†ä¹Ÿå–å†³äºé—®é¢˜çš„æªè¾ä»¥åŠæˆ‘ä»¬å¦‚ä½•é€‰æ‹©ç”Ÿæˆä¾‹å­ã€‚æˆ‘ä»¬ç°åœ¨å°†å¯¹æ­¤è¿›è¡Œè¯¦ç»†ç ”ç©¶ã€‚
- en: '5.2.9.1Â `uniq`: Problem Setup[ğŸ”—](#(part._uniq) "Link to here")'
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.9.1Â `uniq`ï¼šé—®é¢˜è®¾ç½®[ğŸ”—](#(part._uniq) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Consider the task of writing `uniq`:uniq is the name of a Unix utility with
    similar behavior; hence the spelling of the name. given a list of values, it produces
    a collection of the same elements while avoiding any duplicates (hence `uniq`,
    short for â€œuniqueâ€).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘ç¼–å†™`uniq`çš„ä»»åŠ¡ï¼š`uniq`æ˜¯Unixå®ç”¨å·¥å…·çš„ä¸€ä¸ªå…·æœ‰ç±»ä¼¼è¡Œä¸ºçš„åç§°ï¼›å› æ­¤ï¼Œåç§°çš„æ‹¼å†™ã€‚ç»™å®šä¸€ä¸ªå€¼åˆ—è¡¨ï¼Œå®ƒäº§ç”Ÿä¸€ä¸ªåŒ…å«ç›¸åŒå…ƒç´ çš„é›†åˆï¼ŒåŒæ—¶é¿å…ä»»ä½•é‡å¤ï¼ˆå› æ­¤ç§°ä¸º`uniq`ï¼Œæ„ä¸ºâ€œå”¯ä¸€â€ï¼‰ã€‚
- en: 'Consider the following input: `[list: 1, 2, 1, 3, 1, 2, 4, 1]`.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 'è€ƒè™‘ä»¥ä¸‹è¾“å…¥ï¼š`[list: 1, 2, 1, 3, 1, 2, 4, 1]`ã€‚'
- en: Do Now!
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the sequence of examples this input generates? Itâ€™s really important
    you stop and try to do this by hand. As we will see there are multiple solutions,
    and itâ€™s useful for you to consider what you generate. Even if you canâ€™t generate
    a sequence, trying to do so will better prepare you for what you read next.
  id: totrans-393
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè¾“å…¥ç”Ÿæˆäº†å“ªäº›ç¤ºä¾‹åºåˆ—ï¼Ÿè¿™éå¸¸é‡è¦ï¼Œä½ éœ€è¦åœä¸‹æ¥å¹¶å°è¯•æ‰‹åŠ¨å®Œæˆè¿™ä¸ªä»»åŠ¡ã€‚æ­£å¦‚æˆ‘ä»¬å°†çœ‹åˆ°çš„ï¼Œå­˜åœ¨å¤šä¸ªè§£å†³æ–¹æ¡ˆï¼Œè€ƒè™‘ä½ ç”Ÿæˆçš„ç»“æœæ˜¯æœ‰ç”¨çš„ã€‚å³ä½¿ä½ ä¸èƒ½ç”Ÿæˆä¸€ä¸ªåºåˆ—ï¼Œå°è¯•è¿™æ ·åšä¹Ÿä¼šæ›´å¥½åœ°ä¸ºä½ é˜…è¯»ä¸‹ä¸€éƒ¨åˆ†åšå¥½å‡†å¤‡ã€‚
- en: How did you obtain your example? If you just â€œthought about it for a moment
    and wrote something downâ€, you may or may not have gotten something you can turn
    into a program. Programs can only proceed systematically; they canâ€™t â€œthinkâ€.
    So, hopefully you took a well-defined path to computing the answer.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æ˜¯å¦‚ä½•å¾—åˆ°ä½ çš„ç¤ºä¾‹çš„ï¼Ÿå¦‚æœä½ åªæ˜¯â€œæ€è€ƒäº†ä¸€ä¼šå„¿å¹¶å†™ä¸‹äº†ä¸€äº›ä¸œè¥¿â€ï¼Œä½ å¯èƒ½å¾—åˆ°äº†å¯ä»¥è½¬åŒ–ä¸ºç¨‹åºçš„ä¸œè¥¿ï¼Œä¹Ÿå¯èƒ½æ²¡æœ‰ã€‚ç¨‹åºåªèƒ½ç³»ç»Ÿåœ°æ‰§è¡Œï¼›å®ƒä»¬ä¸èƒ½â€œæ€è€ƒâ€ã€‚æ‰€ä»¥ï¼Œå¸Œæœ›ä½ å·²ç»é‡‡å–äº†ä¸€ä¸ªæ˜ç¡®çš„è·¯å¾„æ¥è®¡ç®—ç­”æ¡ˆã€‚
- en: '5.2.9.2Â `uniq`: Examples[ğŸ”—](#(part._uniq-eg) "Link to here")'
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.9.2Â `uniq`: ç¤ºä¾‹[ğŸ”—](#(part._uniq-eg) "é“¾æ¥è‡³æ­¤")'
- en: It turns out there are several possible answers, because we have (intentionally)
    left the problem unspecified. Suppose there are two instances of a value in the
    list; which one do we keep, the first or the second? On the one hand, since the
    two instances must be equivalent it doesnâ€™t matter, but it does for writing concrete
    examples and deriving a solution.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœæ˜¯æœ‰å‡ ä¸ªå¯èƒ½çš„ç­”æ¡ˆï¼Œå› ä¸ºæˆ‘ä»¬ï¼ˆæ•…æ„ï¼‰æ²¡æœ‰å…·ä½“è¯´æ˜é—®é¢˜ã€‚å‡è®¾åˆ—è¡¨ä¸­æœ‰ä¸¤ä¸ªç›¸åŒçš„å€¼å®ä¾‹ï¼›æˆ‘ä»¬ä¿ç•™å“ªä¸€ä¸ªï¼Œç¬¬ä¸€ä¸ªè¿˜æ˜¯ç¬¬äºŒä¸ªï¼Ÿä¸€æ–¹é¢ï¼Œç”±äºè¿™ä¸¤ä¸ªå®ä¾‹å¿…é¡»ç­‰æ•ˆï¼Œæ‰€ä»¥è¿™å¹¶ä¸é‡è¦ï¼Œä½†åœ¨ç¼–å†™å…·ä½“ç¤ºä¾‹å’Œæ¨å¯¼è§£å†³æ–¹æ¡ˆæ—¶ï¼Œè¿™å¾ˆé‡è¦ã€‚
- en: 'For instance, you might have generated this sequence:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œä½ å¯èƒ½å·²ç»ç”Ÿæˆäº†ä»¥ä¸‹åºåˆ—ï¼š
- en: '[PRE79]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: However, you might have also generated sequences that began with
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œä½ ä¹Ÿå¯èƒ½ç”Ÿæˆäº†ä»¥ä¸‹åºåˆ—ï¼š
- en: '[PRE80]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: or
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…
- en: '[PRE81]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: and so on. Letâ€™s work with the examples weâ€™ve worked out above.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥æ­¤ç±»æ¨ã€‚è®©æˆ‘ä»¬å¤„ç†æˆ‘ä»¬ä¸Šé¢å·²ç»è§£å†³çš„é—®é¢˜ã€‚
- en: '5.2.9.3Â `uniq`: Code[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)
    "Link to here")'
  id: totrans-404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.9.3Â `uniq`: ä»£ç [ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)
    "é“¾æ¥è‡³æ­¤")'
- en: 'What is the systematic approach that gets us to this answer? When given a non-empty
    list, we split it into its first element and the rest of the list. Suppose we
    have the answer to `uniq` applied to the rest of the list. Now we can ask: is
    the first element in the rest of the list? If it is, then we can ignore it, since
    it is certain to be in the `uniq` of the rest of the list. If, however, it is
    not in the rest of the list, itâ€™s critical that we `link` it to the answer.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•ç³»ç»Ÿåœ°å¾—åˆ°è¿™ä¸ªç­”æ¡ˆï¼Ÿå½“ç»™å®šä¸€ä¸ªéç©ºåˆ—è¡¨æ—¶ï¼Œæˆ‘ä»¬å°†å…¶åˆ†ä¸ºå…¶ç¬¬ä¸€ä¸ªå…ƒç´ å’Œå…¶ä½™éƒ¨åˆ†ã€‚å‡è®¾æˆ‘ä»¬å·²ç»å¯¹åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†åº”ç”¨äº† `uniq`ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥é—®ï¼šç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¦åœ¨åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†ä¸­ï¼Ÿå¦‚æœæ˜¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å¿½ç•¥å®ƒï¼Œå› ä¸ºå®ƒè‚¯å®šä¼šåœ¨å…¶ä½™éƒ¨åˆ†çš„
    `uniq` ä¸­ã€‚å¦‚æœä¸æ˜¯ï¼Œé‚£ä¹ˆå°†è¿™ä¸ªå…ƒç´ ä¸ç­”æ¡ˆ `link` æ˜¯è‡³å…³é‡è¦çš„ã€‚
- en: This translates into the following program. For the empty list, we return the
    empty list. If the list is non-empty, we check whether the first is in the rest
    of the list. If it is not, we include it; otherwise we can ignore it for now.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è½¬åŒ–ä¸ºä»¥ä¸‹ç¨‹åºã€‚å¯¹äºç©ºåˆ—è¡¨ï¼Œæˆ‘ä»¬è¿”å›ç©ºåˆ—è¡¨ã€‚å¦‚æœåˆ—è¡¨éç©ºï¼Œæˆ‘ä»¬æ£€æŸ¥ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¦åœ¨åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†ä¸­ã€‚å¦‚æœä¸æ˜¯ï¼Œæˆ‘ä»¬åŒ…æ‹¬å®ƒï¼›å¦åˆ™ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥å¿½ç•¥å®ƒã€‚
- en: 'This results in the following program:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯¼è‡´ä»¥ä¸‹ç¨‹åºï¼š
- en: '[PRE82]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: which weâ€™ve called `uniq-rec` instead of `uniq` to differentiate it from other
    versions of `uniq`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†å…¶ç§°ä¸º `uniq-rec` è€Œä¸æ˜¯ `uniq`ï¼Œä»¥åŒºåˆ†å…¶ä»–ç‰ˆæœ¬çš„ `uniq`ã€‚
- en: Exercise
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that weâ€™re using `.member` to check whether an element is a member of the
    list. Write a function `member` that consumes an element and a list, and tells
    us whether the element is a member of the list.
  id: totrans-412
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬æ­£åœ¨ä½¿ç”¨ `.member` æ¥æ£€æŸ¥ä¸€ä¸ªå…ƒç´ æ˜¯å¦æ˜¯åˆ—è¡¨çš„æˆå‘˜ã€‚ç¼–å†™ä¸€ä¸ª `member` å‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ªå…ƒç´ å’Œä¸€ä¸ªåˆ—è¡¨ï¼Œå¹¶å‘Šè¯‰æˆ‘ä»¬è¯¥å…ƒç´ æ˜¯å¦æ˜¯åˆ—è¡¨çš„æˆå‘˜ã€‚
- en: Exercise
  id: totrans-413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Uniqueness checking has many practical applications. For example, one might
    have a list of names of people who have registered to vote in an election. To
    keep the voting fair, with only one vote allowed per person, we should remove
    duplicate names from the list.
  id: totrans-415
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å”¯ä¸€æ€§æ£€æŸ¥æœ‰è®¸å¤šå®é™…åº”ç”¨ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªäººå¯èƒ½æœ‰ä¸€ä»½æ³¨å†Œå‚åŠ é€‰ä¸¾çš„äººçš„åå•ã€‚ä¸ºäº†ä¿æŒé€‰ä¸¾çš„å…¬å¹³æ€§ï¼Œæ¯äººåªèƒ½æŠ•ä¸€ç¥¨ï¼Œæˆ‘ä»¬åº”è¯¥ä»åˆ—è¡¨ä¸­åˆ é™¤é‡å¤çš„åå­—ã€‚
- en: ''
  id: totrans-416
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a set of examples for a function `rem-duplicate-voters` that takes a
    list of voter names and returns a list in which duplicate registrations have been
    removed. In developing your examples, consider real-world scenarios that you can
    imagine arising when identifying duplicate names. Can you identify cases in which
    two names might appear to be the same person, but not be? Cases in which two names
    might appear different but be referring to the same person?
  id: totrans-417
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: æå‡ºä¸€ç»„ç¤ºä¾‹ï¼Œç”¨äºä¸€ä¸ªåä¸º`rem-duplicate-voters`çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªæŠ•ç¥¨è€…åå•åˆ—è¡¨ï¼Œå¹¶è¿”å›ä¸€ä¸ªå·²ç§»é™¤é‡å¤æ³¨å†Œçš„åˆ—è¡¨ã€‚åœ¨å¼€å‘ä½ çš„ç¤ºä¾‹æ—¶ï¼Œè¯·è€ƒè™‘åœ¨è¯†åˆ«é‡å¤å§“åæ—¶å¯èƒ½å‡ºç°çš„ç°å®ä¸–ç•Œåœºæ™¯ã€‚ä½ èƒ½è¯†åˆ«å‡ºä¸¤ä¸ªå§“åå¯èƒ½çœ‹èµ·æ¥æ˜¯åŒä¸€ä¸ªäººï¼Œä½†å®é™…ä¸Šä¸æ˜¯çš„æƒ…å†µå—ï¼Ÿä¸¤ä¸ªå§“åå¯èƒ½çœ‹èµ·æ¥ä¸åŒï¼Œä½†å®é™…ä¸Šæ˜¯æŒ‡åŒä¸€ä¸ªäººçš„æƒ…å†µå—ï¼Ÿ
- en: ''
  id: totrans-418
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-419
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: What might you need to change about our current `uniq-rec` function to handle
    a situation like removing duplicate voters?
  id: totrans-420
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½éœ€è¦å¯¹æˆ‘ä»¬å½“å‰çš„`uniq-rec`å‡½æ•°è¿›è¡Œå“ªäº›ä¿®æ”¹ï¼Œä»¥å¤„ç†åƒç§»é™¤é‡å¤æŠ•ç¥¨è€…è¿™æ ·çš„æƒ…å†µï¼Ÿ
- en: 'Responsible Computing: Context Matters When Comparing Values'
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è´Ÿè´£ä»»è®¡ç®—ï¼šæ¯”è¾ƒå€¼æ—¶ä¸Šä¸‹æ–‡å¾ˆé‡è¦
- en: ''
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The data de-duplication context in the above exercise reminds us that different
    contexts may call for different notions of when two data values are the same.
    Sometimes, we want exact matching to determine that two strings are equal. Sometimes,
    we need methods that normalize data, either in simple ways like capitalization
    or subtler ways based on middle initials. Sometimes, we need more information
    (like street addresses in addition to names) in order to determine whether two
    items in a list should be considered â€œthe sameâ€.
  id: totrans-423
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨ä¸Šè¿°ç»ƒä¹ ä¸­çš„æ•°æ®å»é‡ä¸Šä¸‹æ–‡æé†’æˆ‘ä»¬ï¼Œä¸åŒçš„ä¸Šä¸‹æ–‡å¯èƒ½éœ€è¦ä¸åŒçš„æ¦‚å¿µæ¥åˆ¤æ–­ä¸¤ä¸ªæ•°æ®å€¼æ˜¯å¦ç›¸åŒã€‚æœ‰æ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›è¿›è¡Œç²¾ç¡®åŒ¹é…ä»¥ç¡®å®šä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰ã€‚æœ‰æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨æ–¹æ³•æ¥è§„èŒƒåŒ–æ•°æ®ï¼Œæ— è®ºæ˜¯ç®€å•çš„æ–¹å¼ï¼ˆå¦‚å¤§å†™å­—æ¯ï¼‰è¿˜æ˜¯æ›´å¾®å¦™çš„æ–¹å¼ï¼ˆå¦‚åŸºäºä¸­é—´åé¦–å­—æ¯ï¼‰ã€‚æœ‰æ—¶ï¼Œæˆ‘ä»¬éœ€è¦æ›´å¤šä¿¡æ¯ï¼ˆå¦‚é™¤äº†å§“åä¹‹å¤–è¿˜æœ‰è¡—é“åœ°å€ï¼‰æ¥åˆ¤æ–­åˆ—è¡¨ä¸­çš„ä¸¤ä¸ªé¡¹ç›®æ˜¯å¦åº”è¯¥è¢«è§†ä¸ºâ€œç›¸åŒâ€ã€‚
- en: ''
  id: totrans-424
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is easy to write programs that encode assumptions about our data that might
    not apply in practice. This is again a situation that can be helped by thinking
    about the concrete examples on which your code needs to work in context.
  id: totrans-425
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™å‡è®¾æˆ‘ä»¬çš„æ•°æ®å¯èƒ½ä¸é€‚ç”¨äºå®è·µçš„ç¨‹åºçš„ä»£ç å¾ˆå®¹æ˜“ã€‚è¿™åˆæ˜¯ä¸€ä¸ªå¯ä»¥é€šè¿‡è€ƒè™‘ä»£ç åœ¨ä¸Šä¸‹æ–‡ä¸­éœ€è¦å·¥ä½œçš„å…·ä½“ç¤ºä¾‹æ¥å¸®åŠ©çš„æƒ…å†µã€‚
- en: '5.2.9.4Â `uniq`: Reducing Computation[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)
    "Link to here")'
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.9.4 `uniq`ï¼šå‡å°‘è®¡ç®—[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Notice that this function has a repeated expression. Instead of writing it
    twice, we could call it just once and use the result in both places:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™ä¸ªå‡½æ•°æœ‰ä¸€ä¸ªé‡å¤çš„è¡¨è¾¾å¼ã€‚æˆ‘ä»¬ä¸å¿…å†™ä¸¤æ¬¡ï¼Œåªéœ€è°ƒç”¨ä¸€æ¬¡ï¼Œå¹¶åœ¨ä¸¤ä¸ªåœ°æ–¹ä½¿ç”¨ç»“æœï¼š
- en: '[PRE83]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You might think, because we replaced two function calls with one, that weâ€™ve
    reduced the amount of computation the program does. It does not! The two function
    calls are both in the two branches of the same conditional; therefore, for any
    given list element, only one or the other call to `uniq` happens. In fact, in
    both cases, there was one call to `uniq` before, and there is one now. So we have
    reduced the number of calls in the source program, but not the number that take
    place when the program runs. In that sense, the name of this section was intentionally
    misleading!
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½ä¼šæƒ³ï¼Œå› ä¸ºæˆ‘ä»¬ç”¨ä¸€ä¸ªå‡½æ•°è°ƒç”¨æ›¿æ¢äº†ä¸¤ä¸ªï¼Œæ‰€ä»¥å‡å°‘äº†ç¨‹åºçš„è®¡ç®—é‡ã€‚ä½†è¿™å¹¶ä¸æ­£ç¡®ï¼è¿™ä¸¤ä¸ªå‡½æ•°è°ƒç”¨éƒ½åœ¨åŒä¸€ä¸ªæ¡ä»¶è¯­å¥çš„ä¸¤ä¸ªåˆ†æ”¯ä¸­ï¼›å› æ­¤ï¼Œå¯¹äºä»»ä½•ç»™å®šçš„åˆ—è¡¨å…ƒç´ ï¼Œåªä¼šå‘ç”Ÿ`uniq`çš„å…¶ä¸­ä¸€ä¸ªè°ƒç”¨ã€‚å®é™…ä¸Šï¼Œåœ¨ä¸¤ç§æƒ…å†µä¸‹ï¼Œä¹‹å‰éƒ½æœ‰ä¸€ä¸ª`uniq`çš„è°ƒç”¨ï¼Œç°åœ¨ä»ç„¶æœ‰ä¸€ä¸ªã€‚æ‰€ä»¥æˆ‘ä»¬åœ¨æºç¨‹åºä¸­å‡å°‘äº†è°ƒç”¨æ¬¡æ•°ï¼Œä½†å¹¶æ²¡æœ‰å‡å°‘ç¨‹åºè¿è¡Œæ—¶çš„è°ƒç”¨æ¬¡æ•°ã€‚ä»è¿™ä¸ªæ„ä¹‰ä¸Šè¯´ï¼Œè¿™ä¸ªç« èŠ‚çš„åç§°æ˜¯æœ‰æ„è¯¯å¯¼çš„ï¼
- en: 'However, there is one useful reduction we can perform, which is enabled by
    the structure of `uniq-rec2`. We currently check whether `f` is a member of `r`,
    which is the list of all the remaining elements. In our example, this means that
    in the very second turn, we check whether `2` is a member of the list `[list:
    1, 3, 1, 2, 4, 1]`. This is a list of six elements, including three copies of
    `1`. We compare `2` against two copies of `1`. However, we gain nothing from the
    second comparison. Put differently, we can think of `uniq(r)` as a â€œsummaryâ€ of
    the rest of the list that is exactly as good as `r` itself for checking membership,
    with the advantage that it might be significantly shorter. This, of course, is
    exactly what `ur` represents. Therefore, we can encode this intuition as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç„¶è€Œï¼Œæˆ‘ä»¬å¯ä»¥æ‰§è¡Œä¸€ä¸ªæœ‰ç”¨çš„ç®€åŒ–ï¼Œè¿™æ˜¯ç”±`uniq-rec2`çš„ç»“æ„æ‰€å¯ç”¨çš„ã€‚æˆ‘ä»¬ç›®å‰æ£€æŸ¥`f`æ˜¯å¦æ˜¯`r`çš„æˆå‘˜ï¼Œå³æ‰€æœ‰å‰©ä½™å…ƒç´ çš„åˆ—è¡¨ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œè¿™æ„å‘³ç€åœ¨ç¬¬äºŒæ¬¡è¿­ä»£æ—¶ï¼Œæˆ‘ä»¬æ£€æŸ¥`2`æ˜¯å¦æ˜¯åˆ—è¡¨`[list:
    1, 3, 1, 2, 4, 1]`çš„æˆå‘˜ã€‚è¿™æ˜¯ä¸€ä¸ªåŒ…å«å…­ä¸ªå…ƒç´ çš„åˆ—è¡¨ï¼ŒåŒ…æ‹¬ä¸‰ä¸ª`1`çš„å‰¯æœ¬ã€‚æˆ‘ä»¬å°†`2`ä¸ä¸¤ä¸ª`1`è¿›è¡Œæ¯”è¾ƒã€‚ç„¶è€Œï¼Œç¬¬äºŒæ¬¡æ¯”è¾ƒæˆ‘ä»¬æ²¡æœ‰å¾—åˆ°ä»»ä½•æ”¶è·ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥å°†`uniq(r)`è§†ä¸ºåˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„â€œæ‘˜è¦â€ï¼Œå®ƒåœ¨æ£€æŸ¥æˆå‘˜èµ„æ ¼æ–¹é¢ä¸`r`æœ¬èº«ä¸€æ ·å¥½ï¼Œè€Œä¸”å¯èƒ½æ˜¾è‘—æ›´çŸ­ã€‚è¿™æ­£æ˜¯`ur`æ‰€ä»£è¡¨çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™ç§ç›´è§‰ç¼–ç å¦‚ä¸‹ï¼š'
- en: '[PRE84]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note that all that changed is that we check for membership in `ur` rather than
    in `r`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæ‰€æœ‰æ”¹å˜çš„å°±æ˜¯æˆ‘ä»¬æ£€æŸ¥`ur`ä¸­çš„æˆå‘˜èµ„æ ¼è€Œä¸æ˜¯`r`ä¸­çš„ã€‚
- en: Exercise
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Later [[Predicting Growth](predicting-growth.html)] we will study how to formally
    study how long a program takes to run. By the measure introduced in that section,
    does the change we just made make any difference? Be careful with your answer:
    it depends on how we count â€œthe lengthâ€ of the list.'
  id: totrans-435
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨[é¢„æµ‹å¢é•¿](predicting-growth.html)ä¸­ï¼Œæˆ‘ä»¬ç¨åå°†ä¼šç ”ç©¶å¦‚ä½•æ­£å¼ç ”ç©¶ç¨‹åºè¿è¡Œæ‰€éœ€çš„æ—¶é—´ã€‚æ ¹æ®è¯¥èŠ‚ä¸­å¼•å…¥çš„åº¦é‡æ ‡å‡†ï¼Œæˆ‘ä»¬åˆšæ‰æ‰€åšçš„æ›´æ”¹æ˜¯å¦æœ‰æ‰€å½±å“ï¼Ÿè¯·æ³¨æ„æ‚¨çš„ç­”æ¡ˆï¼šè¿™å–å†³äºæˆ‘ä»¬å¦‚ä½•è®¡ç®—â€œåˆ—è¡¨çš„é•¿åº¦â€ã€‚
- en: Observe that if the list never contained duplicates in the first place, then
    it wouldnâ€™t matter which list we check membership inâ€”<wbr>but if we knew the list
    didnâ€™t contain duplicates, we wouldnâ€™t be using `uniq` in the first place! We
    will return to the issue of lists and duplicate elements in [Representing Sets
    as Lists](sets-from-lists.html).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¦‚æœåˆ—è¡¨æœ€åˆå°±æ²¡æœ‰é‡å¤é¡¹ï¼Œé‚£ä¹ˆæ£€æŸ¥å“ªä¸ªåˆ—è¡¨ä¸­çš„æˆå‘˜èµ„æ ¼å°±æ— å…³ç´§è¦â€”â€”<wbr>ä½†å¦‚æœæˆ‘ä»¬çŸ¥é“åˆ—è¡¨ä¸­æ²¡æœ‰é‡å¤é¡¹ï¼Œæˆ‘ä»¬æœ€åˆå°±ä¸ä¼šä½¿ç”¨`uniq`ï¼æˆ‘ä»¬å°†åœ¨[è¡¨ç¤ºåˆ—è¡¨ä½œä¸ºé›†åˆ](sets-from-lists.html)ä¸­è¿”å›åˆ°åˆ—è¡¨å’Œé‡å¤å…ƒç´ çš„é—®é¢˜ã€‚
- en: '5.2.9.5Â `uniq`: Example and Code Variations[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)
    "Link to here")'
  id: totrans-437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.9.5Â `uniq`: ç¤ºä¾‹å’Œä»£ç å˜åŒ–[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)
    "é“¾æ¥è‡³æ­¤")'
- en: 'As we mentioned earlier, there are other example sequences you might have written
    down. Hereâ€™s a very different process:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æˆ‘ä»¬ä¹‹å‰æåˆ°çš„ï¼Œä½ å¯èƒ½å·²ç»ç¼–å†™äº†å…¶ä»–ç¤ºä¾‹åºåˆ—ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªéå¸¸ä¸åŒçš„è¿‡ç¨‹ï¼š
- en: Start with the entire given list and with the empty answer (so far).
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»æ•´ä¸ªç»™å®šçš„åˆ—è¡¨å’Œç©ºç­”æ¡ˆï¼ˆåˆ°ç›®å‰ä¸ºæ­¢ï¼‰å¼€å§‹ã€‚
- en: For each list element, check whether itâ€™s already in the answer so far. If it
    is, ignore it, otherwise extend the answer with it.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºåˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦å·²ç»åœ¨åˆ°ç›®å‰ä¸ºæ­¢çš„ç­”æ¡ˆä¸­ã€‚å¦‚æœæ˜¯ï¼Œå¿½ç•¥å®ƒï¼Œå¦åˆ™ç”¨å®ƒæ‰©å±•ç­”æ¡ˆã€‚
- en: When there are no more elements in the list, the answer so far is the answer
    for the whole list.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“åˆ—è¡¨ä¸­æ²¡æœ‰æ›´å¤šå…ƒç´ æ—¶ï¼Œåˆ°ç›®å‰ä¸ºæ­¢çš„ç­”æ¡ˆæ˜¯æ•´ä¸ªåˆ—è¡¨çš„ç­”æ¡ˆã€‚
- en: Notice that this solution assumes that we will be accumulating the answer as
    we traverse the list. Therefore, we canâ€™t even write the example with one parameter
    as we did before. We would argue that a natural solution asks whether we can solve
    the problem just from the structure of the data using the computation we are already
    defining, as we did above. If we cannot, then we have to resort to an accumulator.
    But because we can, the accumulator is unnecessary here and greatly complicates
    even writing down examples (give it a try!).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™ä¸ªè§£å†³æ–¹æ¡ˆå‡è®¾æˆ‘ä»¬å°†åœ¨éå†åˆ—è¡¨æ—¶ç´¯ç§¯ç­”æ¡ˆã€‚å› æ­¤ï¼Œæˆ‘ä»¬ç”šè‡³ä¸èƒ½åƒä»¥å‰é‚£æ ·ç”¨ä¸€ä¸ªå‚æ•°ç¼–å†™ç¤ºä¾‹ã€‚æˆ‘ä»¬ä¼šäº‰è¾©è¯´ï¼Œä¸€ä¸ªè‡ªç„¶çš„è§£å†³æ–¹æ¡ˆæ˜¯è¯¢é—®æˆ‘ä»¬æ˜¯å¦å¯ä»¥ä»…ä½¿ç”¨æˆ‘ä»¬å·²ç»åœ¨å®šä¹‰çš„è®¡ç®—ä»æ•°æ®ç»“æ„ä¸­è§£å†³é—®é¢˜ï¼Œå°±åƒæˆ‘ä»¬ä¸Šé¢æ‰€åšçš„é‚£æ ·ã€‚å¦‚æœæˆ‘ä»¬ä¸èƒ½ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¿…é¡»æ±‚åŠ©äºç´¯åŠ å™¨ã€‚ä½†ç”±äºæˆ‘ä»¬å¯ä»¥ï¼Œç´¯åŠ å™¨åœ¨è¿™é‡Œæ˜¯ä¸å¿…è¦çš„ï¼Œå¹¶ä¸”æå¤§åœ°å¤æ‚äº†ç¤ºä¾‹çš„ç¼–å†™ï¼ˆè¯•ä¸€è¯•ï¼ï¼‰ã€‚
- en: '5.2.9.6Â `uniq`: Why Produce a List?[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)
    "Link to here")'
  id: totrans-443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.9.6Â `uniq`: ä¸ºä»€ä¹ˆç”Ÿæˆä¸€ä¸ªåˆ—è¡¨?[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)
    "é“¾æ¥è‡³æ­¤")'
- en: 'If you go back to the original statement of the `uniq` problem [[`uniq`: Problem
    Setup](#%28part._uniq%29)], youâ€™ll notice it said nothing about what order the
    output should have; in fact, it didnâ€™t even say the output needs to be a list
    (and hence have an order). In that case, we should think about whether a list
    even makes sense for this problem. In fact, if we donâ€™t care about order and donâ€™t
    want duplicates (by definition of `uniq`), then there is a much simpler solution,
    which is to produce a set. Pyret already has sets built in, and converting the
    list to a set automatically takes care of duplicates. This is of course cheating
    from the perspective of learning how to write `uniq`, but it is worth remembering
    that sometimes the right data structure to produce isnâ€™t necessarily the same
    as the one we were given. Also, later [[Representing Sets as Lists](sets-from-lists.html)],
    we will see how to build sets for ourselves (at which point, `uniq` will look
    familiar, since it is at the heart of set-ness).'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¦‚æœä½ å›åˆ°`uniq`é—®é¢˜çš„åŸå§‹é™ˆè¿°[[`uniq`: é—®é¢˜è®¾ç½®](#%28part._uniq%29)]ï¼Œä½ ä¼šæ³¨æ„åˆ°å®ƒæ²¡æœ‰è¯´è¾“å‡ºåº”è¯¥æœ‰ä»€ä¹ˆé¡ºåºï¼›äº‹å®ä¸Šï¼Œå®ƒç”šè‡³æ²¡æœ‰è¯´è¾“å‡ºéœ€è¦æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼ˆå› æ­¤æœ‰é¡ºåºï¼‰ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åº”è¯¥è€ƒè™‘åˆ—è¡¨å¯¹äºè¿™ä¸ªé—®é¢˜æ˜¯å¦æœ‰æ„ä¹‰ã€‚äº‹å®ä¸Šï¼Œå¦‚æœæˆ‘ä»¬ä¸å…³å¿ƒé¡ºåºå¹¶ä¸”ä¸æƒ³æœ‰é‡å¤ï¼ˆæ ¹æ®`uniq`çš„å®šä¹‰ï¼‰ï¼Œé‚£ä¹ˆæœ‰ä¸€ä¸ªæ›´ç®€å•çš„è§£å†³æ–¹æ¡ˆï¼Œé‚£å°±æ˜¯ç”Ÿæˆä¸€ä¸ªé›†åˆã€‚Pyretå·²ç»å†…ç½®äº†é›†åˆï¼Œå°†åˆ—è¡¨è½¬æ¢ä¸ºé›†åˆä¼šè‡ªåŠ¨å¤„ç†é‡å¤é¡¹ã€‚å½“ç„¶ï¼Œä»å­¦ä¹ å¦‚ä½•ç¼–å†™`uniq`çš„è§’åº¦æ¥çœ‹ï¼Œè¿™æ˜¯ä¸€ç§ä½œå¼Šè¡Œä¸ºï¼Œä½†å€¼å¾—è®°ä½çš„æ˜¯ï¼Œæœ‰æ—¶äº§ç”Ÿæ­£ç¡®æ•°æ®ç»“æ„çš„æ–¹æ³•å¹¶ä¸ä¸€å®šæ˜¯æˆ‘ä»¬ç»™å‡ºçš„é‚£ä¸ªã€‚æ­¤å¤–ï¼Œåœ¨[[å°†é›†åˆè¡¨ç¤ºä¸ºåˆ—è¡¨](sets-from-lists.html)]ä¸­ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°å¦‚ä½•è‡ªå·±æ„å»ºé›†åˆï¼ˆåˆ°é‚£æ—¶ï¼Œ`uniq`å°†çœ‹èµ·æ¥å¾ˆç†Ÿæ‚‰ï¼Œå› ä¸ºå®ƒå¤„äºé›†åˆçš„æ ¸å¿ƒï¼‰ã€‚'
- en: 5.2.10Â Monomorphic Lists and Polymorphic Types[ğŸ”—](#(part._polymorphic-data)
    "Link to here")
  id: totrans-445
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.10 å•å½¢åˆ—è¡¨å’Œå¤šå½¢ç±»å‹[ğŸ”—](#(part._polymorphic-data) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Earlier we wrote contracts like:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹å‰æˆ‘ä»¬ç¼–å†™äº†åƒè¿™æ ·çš„åˆåŒï¼š
- en: '[PRE85]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'These are unsatisfying for several reasons. Consider `my-max`. The contract
    suggests that any kind of element can be in the input list, but in fact that isnâ€™t
    true: the input `[list: 1, "two", 3]` is not valid, because we canâ€™t compare `1`
    with `"two"` or `"two"` with `3`.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™æœ‰å‡ ä¸ªä»¤äººä¸æ»¡æ„çš„åŸå› ã€‚è€ƒè™‘`my-max`ã€‚åˆåŒè¡¨æ˜è¾“å…¥åˆ—è¡¨ä¸­å¯ä»¥åŒ…å«ä»»ä½•ç±»å‹çš„å…ƒç´ ï¼Œä½†å®é™…ä¸Šå¹¶éå¦‚æ­¤ï¼šè¾“å…¥`[list: 1, "two", 3]`æ˜¯æ— æ•ˆçš„ï¼Œå› ä¸ºæˆ‘ä»¬ä¸èƒ½æ¯”è¾ƒ`1`å’Œ`"two"`æˆ–`"two"`å’Œ`3`ã€‚'
- en: Exercise
  id: totrans-449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if we run `1 > "two"` or `"two" > 3`?
  id: totrans-451
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬è¿è¡Œ`1 > "two"`æˆ–`"two" > 3`ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- en: 'Rather, what we mean is a list where all the elements are of the same kind,Technically,
    elements that are also comparable. and the contract has not captured that. Furthermore,
    we donâ€™t mean that `my-max` might return any old type: if we supply it with a
    list of numbers, we will not get a string as the maximum element! Rather, it will
    only return the kind of element that is in the provided list.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åï¼Œæˆ‘ä»¬çš„æ„æ€æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œå…¶ä¸­æ‰€æœ‰å…ƒç´ éƒ½æ˜¯åŒä¸€ç±»å‹çš„ï¼ŒæŠ€æœ¯ä¸Šè®²ï¼Œæ˜¯å¯æ¯”è¾ƒçš„å…ƒç´ ï¼Œå¹¶ä¸”åˆåŒå¹¶æ²¡æœ‰æ•æ‰åˆ°è¿™ä¸€ç‚¹ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬çš„æ„æ€å¹¶ä¸æ˜¯`my-max`å¯ä»¥è¿”å›ä»»ä½•æ—§ç±»å‹ï¼šå¦‚æœæˆ‘ä»¬å‘å®ƒæä¾›ä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œæˆ‘ä»¬ä¸ä¼šå¾—åˆ°ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºæœ€å¤§å…ƒç´ ï¼ç›¸åï¼Œå®ƒåªä¼šè¿”å›åˆ—è¡¨ä¸­å­˜åœ¨çš„å…ƒç´ ç±»å‹ã€‚
- en: 'In short, we mean that all elements of the list are of the same type, but they
    can be of any type. We call the former monomorphic: â€œmonoâ€ meaning one, and â€œmorphicâ€
    meaning shape, i.e., all values have one type. But the function `my-max` itself
    can operate over many of these kinds of lists, so we call it polymorphic (â€œpolyâ€
    meaning many).'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬çš„æ„æ€æ˜¯åˆ—è¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½æ˜¯åŒä¸€ç±»å‹çš„ï¼Œä½†å®ƒä»¬å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ã€‚æˆ‘ä»¬ç§°å‰è€…ä¸ºå•å½¢ï¼šâ€œmonoâ€æ„å‘³ç€ä¸€ä¸ªï¼Œè€Œâ€œmorphicâ€æ„å‘³ç€å½¢çŠ¶ï¼Œå³æ‰€æœ‰å€¼éƒ½æœ‰ä¸€ä¸ªç±»å‹ã€‚ä½†`my-max`å‡½æ•°æœ¬èº«å¯ä»¥æ“ä½œè®¸å¤šè¿™ç±»åˆ—è¡¨ï¼Œæ‰€ä»¥æˆ‘ä»¬ç§°å®ƒä¸ºå¤šå½¢ï¼ˆâ€œpolyâ€æ„å‘³ç€è®¸å¤šï¼‰ã€‚
- en: 'Therefore, we need a better way of writing these contracts. Essentially, we
    want to say that there is a type variable (as opposed to regular program variable)
    that represents the type of element in the list. Given that type, `my-max` will
    return an element of that type. We write this syntactically as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§æ›´å¥½çš„æ–¹å¼æ¥ç¼–å†™è¿™äº›åˆåŒã€‚æœ¬è´¨ä¸Šï¼Œæˆ‘ä»¬æƒ³è¦è¡¨è¾¾çš„æ˜¯å­˜åœ¨ä¸€ä¸ªç±»å‹å˜é‡ï¼ˆä¸å¸¸è§„ç¨‹åºå˜é‡ç›¸å¯¹ï¼‰æ¥è¡¨ç¤ºåˆ—è¡¨ä¸­å…ƒç´ çš„ç±»å‹ã€‚ç»™å®šè¿™ä¸ªç±»å‹ï¼Œ`my-max`å°†è¿”å›è¯¥ç±»å‹çš„å…ƒç´ ã€‚æˆ‘ä»¬æŒ‰ç…§ä»¥ä¸‹è¯­æ³•æ¥ç¼–å†™ï¼š
- en: '[PRE86]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The notation `<T>` says that `T` is a type variable parameter that will be used
    in the rest of the function (both the header and the body).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`<T>`è¡¨ç¤ºæ³•è¡¨ç¤º`T`æ˜¯ä¸€ä¸ªç±»å‹å˜é‡å‚æ•°ï¼Œå®ƒå°†åœ¨å‡½æ•°çš„å…¶ä½™éƒ¨åˆ†ï¼ˆå¤´å’Œä½“ï¼‰ä¸­ä½¿ç”¨ã€‚'
- en: 'Using this notation, we can also revisit `my-len`. Its header now becomes:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ç§è¡¨ç¤ºæ³•ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥é‡æ–°å®¡è§†`my-len`ã€‚å…¶å¤´ç°åœ¨å˜ä¸ºï¼š
- en: '[PRE87]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Note that `my-len` did not actually â€œcareâ€ that whether all the values were
    of the same type or not: it never looks at the individual elements, much less
    at pairs of them. However, as a convention we demand that lists always be monomorphic.
    This is important because it enables us to process the elements of the list uniformly:
    if we know how to process elements of type `T`, then we will know how to process
    a `List<T>`. If the list elements can be of truly any old type, we canâ€™t know
    how to process its elements.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œ`my-len` å®é™…ä¸Šå¹¶ä¸â€œå…³å¿ƒâ€æ‰€æœ‰å€¼æ˜¯å¦ä¸ºåŒä¸€ç±»å‹ï¼šå®ƒä»ä¸æŸ¥çœ‹å•ä¸ªå…ƒç´ ï¼Œæ›´ä¸ç”¨è¯´ä¸€å¯¹å…ƒç´ äº†ã€‚ç„¶è€Œï¼Œä½œä¸ºä¸€ç§æƒ¯ä¾‹ï¼Œæˆ‘ä»¬è¦æ±‚åˆ—è¡¨å§‹ç»ˆæ˜¯å•æ€çš„ã€‚è¿™å¾ˆé‡è¦ï¼Œå› ä¸ºå®ƒä½¿æˆ‘ä»¬èƒ½å¤Ÿç»Ÿä¸€å¤„ç†åˆ—è¡¨çš„å…ƒç´ ï¼šå¦‚æœæˆ‘ä»¬çŸ¥é“å¦‚ä½•å¤„ç†ç±»å‹
    `T` çš„å…ƒç´ ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±çŸ¥é“å¦‚ä½•å¤„ç† `List<T>`ã€‚å¦‚æœåˆ—è¡¨å…ƒç´ å¯ä»¥æ˜¯çœŸæ­£ä»»ä½•æ—§ç±»å‹ï¼Œæˆ‘ä»¬å°±æ— æ³•çŸ¥é“å¦‚ä½•å¤„ç†å…¶å…ƒç´ ã€‚
- en: 5.2.1Â Making Lists and Taking Them Apart[ğŸ”—](#(part._.Making_.Lists_and_.Taking_.Them_.Apart)
    "Link to here")
  id: totrans-460
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1Â åˆ›å»ºåˆ—è¡¨å¹¶æ‹†åˆ†å®ƒä»¬[ğŸ”—](#(part._.Making_.Lists_and_.Taking_.Them_.Apart) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'So far weâ€™ve seen one way to make a list: by writing `[list: â€¦]`. While useful,
    writing lists this way actually hides their true nature. Every list actually has
    two parts: a first element and the rest of the list. The rest of the list is itself
    a list, so it too has two partsâ€¦and so on.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 'åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†ä¸€ç§åˆ›å»ºåˆ—è¡¨çš„æ–¹æ³•ï¼šé€šè¿‡ç¼–å†™ `[list: â€¦]`ã€‚è™½ç„¶è¿™ç§æ–¹æ³•å¾ˆæœ‰ç”¨ï¼Œä½†è¿™æ ·ç¼–å†™åˆ—è¡¨å®é™…ä¸Šéšè—äº†å®ƒä»¬çš„çœŸæ­£æœ¬è´¨ã€‚æ¯ä¸ªåˆ—è¡¨å®é™…ä¸Šéƒ½æœ‰ä¸¤ä¸ªéƒ¨åˆ†ï¼šä¸€ä¸ªç¬¬ä¸€ä¸ªå…ƒç´ å’Œåˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†ã€‚åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œå› æ­¤å®ƒä¹Ÿæœ‰ä¸¤ä¸ªéƒ¨åˆ†â€¦â€¦ä»¥æ­¤ç±»æ¨ã€‚'
- en: 'Consider the list `[list: 1, 2, 3]`. Its first element is `1`, and the rest
    of it is `[list: 2, 3]`. For this second list, the first element is `2` and the
    rest is `[list: 3]`.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 'è€ƒè™‘åˆ—è¡¨ `[list: 1, 2, 3]`ã€‚å®ƒçš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ `1`ï¼Œå…¶ä½™çš„æ˜¯ `[list: 2, 3]`ã€‚å¯¹äºè¿™ä¸ªç¬¬äºŒä¸ªåˆ—è¡¨ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ `2`ï¼Œå…¶ä½™çš„æ˜¯
    `[list: 3]`ã€‚'
- en: Do Now!
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-464
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Take apart this third list.
  id: totrans-465
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ‹†åˆ†è¿™ä¸ªç¬¬ä¸‰ä¸ªåˆ—è¡¨ã€‚
- en: 'For the third list, the first element is `3` and the rest is `[list: ]`, i.e.,
    the empty list. In Pyret, we have another way of writing the empty list: `empty`.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¯¹äºç¬¬ä¸‰ä¸ªåˆ—è¡¨ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ `3`ï¼Œå…¶ä½™çš„æ˜¯ `[list: ]`ï¼Œå³ç©ºåˆ—è¡¨ã€‚åœ¨ Pyret ä¸­ï¼Œæˆ‘ä»¬è¿˜æœ‰å¦ä¸€ç§ç¼–å†™ç©ºåˆ—è¡¨çš„æ–¹æ³•ï¼š`empty`ã€‚'
- en: 'Lists are an instance of structured data: data with component parts and a well-defined
    format for the shape of the parts. Lists are formatted by the first element and
    the rest of the elements. Tables are somewhat structured: they are formatted by
    rows and columns, but the column names arenâ€™t consistent across all tables. Structured
    data is valuable in programming because a predictable format (the structure) lets
    us write programs based on that structure. What do we mean by that?'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨æ˜¯ç»“æ„åŒ–æ•°æ®çš„ä¸€ä¸ªå®ä¾‹ï¼šå…·æœ‰ç»„æˆéƒ¨åˆ†å’Œç»„æˆéƒ¨åˆ†å½¢çŠ¶çš„æ˜ç¡®æ ¼å¼ã€‚åˆ—è¡¨é€šè¿‡ç¬¬ä¸€ä¸ªå…ƒç´ å’Œå…¶ä½™å…ƒç´ è¿›è¡Œæ ¼å¼åŒ–ã€‚è¡¨æ ¼åœ¨ä¸€å®šç¨‹åº¦ä¸Šæ˜¯ç»“æ„åŒ–çš„ï¼šå®ƒä»¬é€šè¿‡è¡Œå’Œåˆ—è¿›è¡Œæ ¼å¼åŒ–ï¼Œä½†åˆ—ååœ¨æ‰€æœ‰è¡¨æ ¼ä¸­å¹¶ä¸ä¸€è‡´ã€‚ç»“æ„åŒ–æ•°æ®åœ¨ç¼–ç¨‹ä¸­å¾ˆæœ‰ä»·å€¼ï¼Œå› ä¸ºå¯é¢„æµ‹çš„æ ¼å¼ï¼ˆç»“æ„ï¼‰è®©æˆ‘ä»¬èƒ½å¤Ÿæ ¹æ®è¯¥ç»“æ„ç¼–å†™ç¨‹åºã€‚æˆ‘ä»¬è¿™æ˜¯ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿ
- en: 'Programming languages can (and do!) provide built-in operators for taking apart
    structured data. These operators are called accessors. Accessors are defined on
    the structure of the datatype alone, independent of the contents of the data.
    In the case of lists, there are two accessors: `first` and `rest`. We use an accessor
    by writing an expression, followed by a dot (`.`), followed by the accessorâ€™s
    name. As we saw with tables, the dot means "dig into". Thus:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: ç¼–ç¨‹è¯­è¨€å¯ä»¥ï¼ˆå¹¶ä¸”ç¡®å®ï¼ï¼‰æä¾›ç”¨äºæ‹†åˆ†ç»“æ„åŒ–æ•°æ®çš„å†…ç½®æ“ä½œç¬¦ã€‚è¿™äº›æ“ä½œç¬¦ç§°ä¸ºè®¿é—®å™¨ã€‚è®¿é—®å™¨ä»…æ ¹æ®æ•°æ®ç±»å‹çš„ç»“æ„å®šä¹‰ï¼Œè€Œä¸æ•°æ®å†…å®¹æ— å…³ã€‚åœ¨åˆ—è¡¨çš„æƒ…å†µä¸‹ï¼Œæœ‰ä¸¤ä¸ªè®¿é—®å™¨ï¼š`first`
    å’Œ `rest`ã€‚æˆ‘ä»¬é€šè¿‡ç¼–å†™ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œç„¶åæ˜¯ä¸€ä¸ªç‚¹ï¼ˆ`.`ï¼‰ï¼Œç„¶åæ˜¯è®¿é—®å™¨åç§°æ¥ä½¿ç”¨è®¿é—®å™¨ã€‚æ­£å¦‚æˆ‘ä»¬åœ¨è¡¨æ ¼ä¸­çœ‹åˆ°çš„é‚£æ ·ï¼Œç‚¹æ„å‘³ç€â€œæ·±å…¥â€ã€‚å› æ­¤ï¼š
- en: '[PRE88]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Do Now!
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the accessors for tables?
  id: totrans-472
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¡¨çš„è®¿é—®å™¨æ˜¯ä»€ä¹ˆï¼Ÿ
- en: 'Accessors give a way to take data apart based on their structure (there is
    another way that we will see shortly). Is there a way to also build data based
    on its structure? So far, we have been building lists using the `[list: ...]`
    form, but that doesnâ€™t emphasize the structural constraint that the `rest` is
    itself a list. A structured operator for building lists would clearly show both
    a `first` element and a `rest` that is itself a list. Operators for building structured
    data are called constructors.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®¿é—®å™¨æä¾›äº†ä¸€ç§æ ¹æ®å…¶ç»“æ„æ‹†åˆ†æ•°æ®çš„æ–¹æ³•ï¼ˆæˆ‘ä»¬å¾ˆå¿«å°±ä¼šçœ‹åˆ°å¦ä¸€ç§æ–¹æ³•ï¼‰ã€‚æœ‰æ²¡æœ‰ä¸€ç§æ–¹æ³•ä¹Ÿå¯ä»¥æ ¹æ®å…¶ç»“æ„æ„å»ºæ•°æ®ï¼Ÿåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¸€ç›´ä½¿ç”¨ `[list:
    ...]` å½¢å¼æ¥æ„å»ºåˆ—è¡¨ï¼Œä½†è¿™å¹¶æ²¡æœ‰å¼ºè°ƒ `rest` æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªåˆ—è¡¨çš„ç»“æ„çº¦æŸã€‚ç”¨äºæ„å»ºåˆ—è¡¨çš„ç»“æ„åŒ–æ“ä½œç¬¦å°†æ¸…æ¥šåœ°æ˜¾ç¤ºä¸€ä¸ª `first` å…ƒç´ å’Œä¸€ä¸ªæœ¬èº«ä¹Ÿæ˜¯åˆ—è¡¨çš„
    `rest`ã€‚ç”¨äºæ„å»ºç»“æ„åŒ–æ•°æ®çš„æ“ä½œç¬¦ç§°ä¸ºæ„é€ å™¨ã€‚'
- en: 'The constructor for lists is called `link`. It takes two arguments: a `first`
    element, and the list to build on (the `rest` part). Hereâ€™s an example of using
    `link` to create a three-element list.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨çš„æ„é€ å™¨ç§°ä¸º `link`ã€‚å®ƒæ¥å—ä¸¤ä¸ªå‚æ•°ï¼šä¸€ä¸ª `first` å…ƒç´ ï¼Œä»¥åŠæ„å»ºåˆ—è¡¨çš„åŸºç¡€ï¼ˆ`rest` éƒ¨åˆ†ï¼‰ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨ `link` åˆ›å»ºä¸‰ä¸ªå…ƒç´ åˆ—è¡¨çš„ç¤ºä¾‹ã€‚
- en: '[PRE89]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The `link` form creates the same underlying list datum as our previous `[list:
    ...]` operation, as confirmed by the following check:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`link`å½¢å¼åˆ›å»ºçš„åº•å±‚åˆ—è¡¨æ•°æ®ä¸æˆ‘ä»¬çš„å‰ä¸€ä¸ª`[list: ...]`æ“ä½œç›¸åŒï¼Œå¦‚ä¸‹é¢çš„æ£€æŸ¥æ‰€ç¡®è®¤ï¼š'
- en: '[PRE90]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Do Now!
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Look at these two forms of writing lists: what differences do you notice?'
  id: totrans-480
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: çœ‹çœ‹è¿™ä¸¤ç§å†™åˆ—è¡¨çš„å½¢å¼ï¼šä½ æ³¨æ„åˆ°ä»€ä¹ˆåŒºåˆ«ï¼Ÿ
- en: Do Now!
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the `link` form to write a four-element list of fruits containing `"lychee"`,
    `"dates"`, `"mango"`, and `"durian"`.
  id: totrans-483
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`link`å½¢å¼ç¼–å†™ä¸€ä¸ªåŒ…å«â€œè”æâ€ã€â€œæ£â€ã€â€œèŠ’æœâ€å’Œâ€œæ¦´è²â€çš„å››ä¸ªå…ƒç´ çš„åˆ—è¡¨ã€‚
- en: 'After doing this exercise, you might wonder why anyone would use the `link`
    form: itâ€™s more verbose, and makes the individual elements harder to discern.
    This form is not very convenient to humans. But it will prove very valuable to
    programs!'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: å®Œæˆè¿™ä¸ªç»ƒä¹ åï¼Œä½ å¯èƒ½ä¼šæƒ³çŸ¥é“ä¸ºä»€ä¹ˆæœ‰äººä¼šä½¿ç”¨`link`å½¢å¼ï¼šå®ƒæ›´å†—é•¿ï¼Œå¹¶ä¸”ä½¿å¾—å•ç‹¬çš„å…ƒç´ æ›´éš¾è¾¨è®¤ã€‚è¿™ç§å½¢å¼å¯¹äººç±»æ¥è¯´å¹¶ä¸æ–¹ä¾¿ã€‚ä½†è¿™å¯¹ç¨‹åºæ¥è¯´å°†éå¸¸æœ‰ä»·å€¼ï¼
- en: In particular, the `link` form highlights that we really have two different
    structures of lists. Some lists are empty. All other lists are non-empty lists,
    meaning they have at least one `link`. There may be more interesting structure
    to some lists (as we will see later), but all lists have this much in common.
    Specifically, a list is either
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: å°¤å…¶æ˜¯é“¾æ¥å½¢å¼çªå‡ºäº†æˆ‘ä»¬å®é™…ä¸Šæœ‰ä¸¤ç§ä¸åŒçš„åˆ—è¡¨ç»“æ„ã€‚æœ‰äº›åˆ—è¡¨æ˜¯ç©ºçš„ã€‚æ‰€æœ‰å…¶ä»–åˆ—è¡¨éƒ½æ˜¯éç©ºåˆ—è¡¨ï¼Œè¿™æ„å‘³ç€å®ƒä»¬è‡³å°‘æœ‰ä¸€ä¸ª`link`ã€‚æœ‰äº›åˆ—è¡¨å¯èƒ½æœ‰æ›´å¤æ‚çš„ç»“æ„ï¼ˆæˆ‘ä»¬ç¨åä¼šçœ‹åˆ°ï¼‰ï¼Œä½†æ‰€æœ‰åˆ—è¡¨éƒ½æœ‰è¿™ä¸ªå…±åŒç‚¹ã€‚å…·ä½“æ¥è¯´ï¼Œä¸€ä¸ªåˆ—è¡¨è¦ä¹ˆæ˜¯
- en: 'empty (written `empty` or `[list: ]`), or'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ç©ºçš„ï¼ˆå†™æˆ`empty`æˆ–`[list: ]`ï¼‰ï¼Œæˆ–è€…'
- en: 'non-empty (written `link(â€¦, â€¦)` or `[list: ]` with at least one value inside
    the brackets), where the rest is also a list (and hence may in turn be empty or
    non-empty, â€¦).'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'éç©ºï¼ˆå†™æˆ`link(â€¦, â€¦)`æˆ–`[list: ]`ï¼Œæ‹¬å·å†…è‡³å°‘æœ‰ä¸€ä¸ªå€¼ï¼‰ï¼Œå…¶ä¸­å…¶ä½™éƒ¨åˆ†ä¹Ÿæ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼ˆå› æ­¤å¯èƒ½ä¸ºç©ºæˆ–éç©ºï¼Œâ€¦â€¦ï¼‰ã€‚'
- en: 'This means we actually have two structural features of lists, both of which
    are important when writing programs over lists:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€æˆ‘ä»¬å®é™…ä¸Šæœ‰ä¸¤ä¸ªåˆ—è¡¨çš„ç»“æ„ç‰¹æ€§ï¼Œè¿™ä¸¤ä¸ªç‰¹æ€§åœ¨ç¼–å†™åˆ—è¡¨ç¨‹åºæ—¶éƒ½å¾ˆé‡è¦ï¼š
- en: Lists can be empty or non-empty
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åˆ—è¡¨å¯ä»¥æ˜¯ç©ºçš„æˆ–éç©ºçš„
- en: Non-empty lists have a first element and a rest of the list
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: éç©ºåˆ—è¡¨æœ‰ä¸€ä¸ªç¬¬ä¸€ä¸ªå…ƒç´ å’Œåˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†
- en: Letâ€™s leverage these two structural features to write some programs to process
    lists!
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åˆ©ç”¨è¿™ä¸¤ä¸ªç»“æ„ç‰¹æ€§æ¥ç¼–å†™ä¸€äº›å¤„ç†åˆ—è¡¨çš„ç¨‹åºï¼
- en: 5.2.2Â Some Example Exercises[ğŸ”—](#(part._my-len) "Link to here")
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2 ä¸€äº›ç¤ºä¾‹ç»ƒä¹ [ğŸ”—](#(part._my-len) "é“¾æ¥è‡³æ­¤")
- en: 'To illustrate our thinking, letâ€™s work through a few concrete examples of list-processing
    functions. All of these will consume lists; some will even produce them. Some
    will transform their inputs (like `map`), some will select from their inputs (like
    `filter`), and some will aggregate their inputs. Since some of these functions
    already exist in Pyret, weâ€™ll name them with the prefix `my-` to avoid errors.Be
    sure to use the `my-` name consistently, including inside the body of the function.
    As we will see, there is a standard strategy that we can use to approach writing
    all of these functions: having you learn this strategy is the goal of this chapter.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†è¯´æ˜æˆ‘ä»¬çš„æ€è€ƒæ–¹å¼ï¼Œè®©æˆ‘ä»¬é€šè¿‡å‡ ä¸ªå…·ä½“çš„åˆ—è¡¨å¤„ç†å‡½æ•°ç¤ºä¾‹æ¥æ“ä½œã€‚æ‰€æœ‰è¿™äº›å‡½æ•°éƒ½å°†æ¶ˆè€—åˆ—è¡¨ï¼›å…¶ä¸­ä¸€äº›ç”šè‡³ä¼šäº§ç”Ÿåˆ—è¡¨ã€‚ä¸€äº›ä¼šè½¬æ¢å®ƒä»¬çš„è¾“å…¥ï¼ˆå¦‚`map`ï¼‰ï¼Œä¸€äº›ä¼šä»å®ƒä»¬çš„è¾“å…¥ä¸­é€‰æ‹©ï¼ˆå¦‚`filter`ï¼‰ï¼Œè¿˜æœ‰ä¸€äº›ä¼šèšåˆå®ƒä»¬çš„è¾“å…¥ã€‚ç”±äºå…¶ä¸­ä¸€äº›å‡½æ•°å·²ç»åœ¨Pyretä¸­å­˜åœ¨ï¼Œæˆ‘ä»¬å°†ç”¨å‰ç¼€`my-`æ¥å‘½åå®ƒä»¬ä»¥é¿å…é”™è¯¯ã€‚è¯·ç¡®ä¿åœ¨å‡½æ•°ä½“å†…ä¸€è‡´åœ°ä½¿ç”¨`my-`åç§°ã€‚æ­£å¦‚æˆ‘ä»¬å°†çœ‹åˆ°çš„ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ç§æ ‡å‡†ç­–ç•¥æ¥ç¼–å†™æ‰€æœ‰è¿™äº›å‡½æ•°ï¼šæœ¬ç« èŠ‚çš„ç›®æ ‡å°±æ˜¯è®©ä½ å­¦ä¹ è¿™ç§ç­–ç•¥ã€‚
- en: 5.2.3Â Structural Problems with Scalar Answers[ğŸ”—](#(part._.Structural_.Problems_with_.Scalar_.Answers)
    "Link to here")
  id: totrans-494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.3 ç»“æ„åŒ–é—®é¢˜ï¼šæ ‡é‡ç­”æ¡ˆ[ğŸ”—](#(part._.Structural_.Problems_with_.Scalar_.Answers) "é“¾æ¥è‡³æ­¤")
- en: 'Letâ€™s write out examples for a few of the functions described above. Weâ€™ll
    approach writing examples in a very specific, stylized way. First of all, we should
    always construct at least two examples: one with `empty` and the other with at
    least one `link`, so that weâ€™ve covered the two very broad kinds of lists. Then,
    we should have more examples specific to the kind of list stated in the problem.
    Finally, we should have even more examples to illustrate how we think about solving
    the problem.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä¸ºä¸Šè¿°æè¿°çš„å‡ ä¸ªå‡½æ•°ç¼–å†™ä¸€äº›ç¤ºä¾‹ã€‚æˆ‘ä»¬å°†ä»¥éå¸¸å…·ä½“ã€é£æ ¼åŒ–çš„æ–¹å¼ç¼–å†™ç¤ºä¾‹ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬åº”è¯¥å§‹ç»ˆæ„é€ è‡³å°‘ä¸¤ä¸ªç¤ºä¾‹ï¼šä¸€ä¸ªä½¿ç”¨`empty`ï¼Œå¦ä¸€ä¸ªè‡³å°‘æœ‰ä¸€ä¸ª`link`ï¼Œè¿™æ ·æˆ‘ä»¬å°±æ¶µç›–äº†ä¸¤ç§éå¸¸å¹¿æ³›çš„åˆ—è¡¨ç±»å‹ã€‚ç„¶åï¼Œæˆ‘ä»¬åº”è¯¥æœ‰æ›´å¤šé’ˆå¯¹é—®é¢˜ä¸­æ‰€è¿°åˆ—è¡¨ç±»å‹çš„ç‰¹å®šç¤ºä¾‹ã€‚æœ€åï¼Œæˆ‘ä»¬åº”è¯¥æœ‰æ›´å¤šç¤ºä¾‹æ¥è¯´æ˜æˆ‘ä»¬å¦‚ä½•æ€è€ƒè§£å†³é—®é¢˜ã€‚
- en: '5.2.3.1Â `my-len`: Examples[ğŸ”—](#(part._len-eg) "Link to here")'
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.3.1 `my-len`ï¼šç¤ºä¾‹[ğŸ”—](#(part._len-eg) "é“¾æ¥è‡³æ­¤")
- en: We haveâ€™t precisely defined what it means to be â€œthe lengthâ€ of a list. We confront
    this right away when trying to write an example. What is the length of the list
    `empty`?
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜æ²¡æœ‰ç²¾ç¡®åœ°å®šä¹‰åˆ—è¡¨çš„â€œé•¿åº¦â€æ˜¯ä»€ä¹ˆæ„æ€ã€‚å½“æˆ‘ä»¬è¯•å›¾ç¼–å†™ä¸€ä¸ªä¾‹å­æ—¶ï¼Œæˆ‘ä»¬ç«‹å³é¢ä¸´è¿™ä¸ªé—®é¢˜ã€‚åˆ—è¡¨`empty`çš„é•¿åº¦æ˜¯å¤šå°‘ï¼Ÿ
- en: Do Now!
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think?
  id: totrans-500
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ è®¤ä¸ºå‘¢ï¼Ÿ
- en: 'Two common examples are `0` and `1`. The latter, `1`, certainly looks reasonable.
    However, if you write the list as `[list: ]`, now it doesnâ€™t look so right: this
    is clearly (as the name `empty` also suggests) an empty list, and an empty list
    has zero elements in it. Therefore, itâ€™s conventional to declare that'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸¤ä¸ªå¸¸è§çš„ä¾‹å­æ˜¯`0`å’Œ`1`ã€‚åè€…`1`çœ‹èµ·æ¥æ˜¯åˆç†çš„ã€‚ç„¶è€Œï¼Œå¦‚æœä½ å°†åˆ—è¡¨å†™æˆ`[list: ]`ï¼Œç°åœ¨å®ƒçœ‹èµ·æ¥å°±ä¸å¤ªå¯¹äº†ï¼šè¿™æ˜¾ç„¶ï¼ˆæ­£å¦‚åç§°`empty`æ‰€æš—ç¤ºçš„ï¼‰æ˜¯ä¸€ä¸ªç©ºåˆ—è¡¨ï¼Œè€Œç©ºåˆ—è¡¨ä¸­æ²¡æœ‰ä»»ä½•å…ƒç´ ã€‚å› æ­¤ï¼Œæˆ‘ä»¬é€šå¸¸å£°æ˜'
- en: '[PRE91]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'How about a list like `[list: 7]`? Well, itâ€™s clearly got one element (`7`)
    in it, so'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 'é‚£ä¹ˆï¼Œåƒ`[list: 7]`è¿™æ ·çš„åˆ—è¡¨å‘¢ï¼Ÿå¾ˆæ˜æ˜¾ï¼Œå®ƒé‡Œé¢æœ‰ä¸€ä¸ªå…ƒç´ ï¼ˆ`7`ï¼‰ï¼Œæ‰€ä»¥'
- en: '[PRE92]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Similarly, for a list like `[list: 7, 8, 9]`, we would say'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç±»ä¼¼åœ°ï¼Œå¯¹äºä¸€ä¸ªåƒ`[list: 7, 8, 9]`è¿™æ ·çš„åˆ—è¡¨ï¼Œæˆ‘ä»¬ä¼šè¯´'
- en: '[PRE93]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now letâ€™s look at that last example in a different light. Consider the argument
    `[list: 7, 8, 9]`. Its first element is `7` and the rest of it is `[list: 8, 9]`.
    Well, `7` is a number, not a list; but `[list: 8, 9]` certainly is a list, so
    we can ask for its length. What is `my-len([list: 8, 9])`? It has two elements,
    so'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä»¥ä¸åŒçš„è§’åº¦çœ‹çœ‹æœ€åä¸€ä¸ªä¾‹å­ã€‚è€ƒè™‘å‚æ•°`[list: 7, 8, 9]`ã€‚å®ƒçš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯`7`ï¼Œå…¶ä½™éƒ¨åˆ†æ˜¯`[list: 8, 9]`ã€‚å¥½å§ï¼Œ`7`æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œä¸æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼›ä½†æ˜¯`[list:
    8, 9]`è‚¯å®šæ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¯¢é—®å®ƒçš„é•¿åº¦ã€‚`my-len([list: 8, 9])`æ˜¯å¤šå°‘ï¼Ÿå®ƒæœ‰ä¸¤ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥'
- en: '[PRE94]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The first element of that list is `8` while its rest is `[list: 9]`. What is
    its length? Note that we asked a very similar question before, for the length
    of the list `[list: 7]`. But `[list: 7]` is not a sub-list of `[list: 7, 8, 9]`,
    which we started with, whereas `[list: 9]` is. And using the same reasoning as
    before, we can say'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¯¥åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯`8`ï¼Œå…¶ä½™éƒ¨åˆ†æ˜¯`[list: 9]`ã€‚å®ƒçš„é•¿åº¦æ˜¯å¤šå°‘ï¼Ÿæ³¨æ„ï¼Œæˆ‘ä»¬ä¹‹å‰å·²ç»æå‡ºäº†ä¸€ä¸ªéå¸¸ç±»ä¼¼çš„é—®é¢˜ï¼Œå³åˆ—è¡¨`[list: 7]`çš„é•¿åº¦ã€‚ä½†æ˜¯`[list:
    7]`ä¸æ˜¯æˆ‘ä»¬ä»`[list: 7, 8, 9]`å¼€å§‹çš„åˆ—è¡¨çš„å­åˆ—è¡¨ï¼Œè€Œ`[list: 9]`æ˜¯ã€‚ä½¿ç”¨ä¹‹å‰çš„æ¨ç†ï¼Œæˆ‘ä»¬å¯ä»¥è¯´'
- en: '[PRE95]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The rest of this last list is, of course, the empty list, whose length we have
    already decided is `0`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œè¿™ä¸ªåˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æ˜¯ç©ºåˆ—è¡¨ï¼Œå…¶é•¿åº¦æˆ‘ä»¬å·²å†³å®šæ˜¯`0`ã€‚
- en: 'Putting together these examples, and writing out `empty` in its other form,
    hereâ€™s what we get:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“åˆè¿™äº›ä¾‹å­ï¼Œå¹¶å†™å‡º`empty`çš„å…¶ä»–å½¢å¼ï¼Œæˆ‘ä»¬å¾—åˆ°ä»¥ä¸‹ç»“æœï¼š
- en: '[PRE96]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Another way we can write this (paying attention to the right side) is
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ç§æˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ï¼ˆæ³¨æ„å³ä¾§ï¼‰çš„æ–¹å¼æ˜¯
- en: '[PRE97]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Where did the `2`, `1`, and `0` on the right sides of each `+` operation come
    from? Those are the lengths of the `rest` component of the input list. In the
    previous example block, we wrote those lengths as explicit examples. Letâ€™s substitute
    the numbers `2`, `1`, and `0` with the `my-len` expressions that produce them:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ªåŠ æ³•æ“ä½œå³ä¾§çš„`2`ã€`1`å’Œ`0`æ˜¯ä»å“ªé‡Œæ¥çš„ï¼Ÿé‚£äº›æ˜¯è¾“å…¥åˆ—è¡¨`rest`éƒ¨åˆ†çš„é•¿åº¦ã€‚åœ¨ä¹‹å‰çš„ä¾‹å­å—ä¸­ï¼Œæˆ‘ä»¬å°†è¿™äº›é•¿åº¦ä½œä¸ºæ˜ç¡®çš„ä¾‹å­å†™å‡ºæ¥ã€‚è®©æˆ‘ä»¬ç”¨äº§ç”Ÿå®ƒä»¬çš„`my-len`è¡¨è¾¾å¼æ¥æ›¿æ¢æ•°å­—`2`ã€`1`å’Œ`0`ï¼š
- en: '[PRE98]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: From this, maybe you can start to see a pattern. For an empty list, the length
    is `0`. For a non-empty list, itâ€™s the sum of `1` (the first elementâ€™s â€œcontributionâ€
    to the listâ€™s length) to the length of the rest of the list. In other words, we
    can use the result of computing `my-len` on the rest of the list to compute the
    answer for the entire list.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™ä¸ªä¾‹å­ä¸­ï¼Œä½ å¯èƒ½å¼€å§‹çœ‹åˆ°ä¸€ç§æ¨¡å¼ã€‚å¯¹äºä¸€ä¸ªç©ºåˆ—è¡¨ï¼Œå…¶é•¿åº¦æ˜¯`0`ã€‚å¯¹äºä¸€ä¸ªéç©ºåˆ—è¡¨ï¼Œå®ƒæ˜¯`1`ï¼ˆç¬¬ä¸€ä¸ªå…ƒç´ å¯¹åˆ—è¡¨é•¿åº¦çš„â€œè´¡çŒ®â€ï¼‰åŠ ä¸Šåˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„é•¿åº¦ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¯¹åˆ—è¡¨å…¶ä½™éƒ¨åˆ†è®¡ç®—`my-len`çš„ç»“æœæ¥è®¡ç®—æ•´ä¸ªåˆ—è¡¨çš„ç­”æ¡ˆã€‚
- en: Do Now!
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Each of our examples in this section has written a different check on the expression
    `my-len([list: 7, 8, 9])`. Here are those examples presented together, along with
    one last one that explicitly uses the `rest` operation:'
  id: totrans-521
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'æœ¬èŠ‚ä¸­çš„æ¯ä¸ªä¾‹å­éƒ½å¯¹è¿™ä¸ªè¡¨è¾¾å¼`my-len([list: 7, 8, 9])`è¿›è¡Œäº†ä¸åŒçš„æ£€æŸ¥ã€‚ä»¥ä¸‹æ˜¯è¿™äº›ä¾‹å­ä¸€èµ·å‘ˆç°ï¼Œä»¥åŠä¸€ä¸ªæ˜ç¡®ä½¿ç”¨`rest`æ“ä½œçš„æœ€åä¸€ä¸ªä¾‹å­ï¼š'
- en: ''
  id: totrans-522
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-523
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE99]'
- en: ''
  id: totrans-524
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check that you agree with each of these assertions. Also check whether you understand
    how the right-hand side of each `is` expression derives from the right-hand-side
    just above it. The goal of this exercise is to make sure that you believe that
    the last check (which we will turn into code) is equivalent to the first (which
    we wrote down when understanding the problem).
  id: totrans-525
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¡®è®¤ä½ åŒæ„è¿™äº›æ–­è¨€ä¸­çš„æ¯ä¸€ä¸ªã€‚ä¹Ÿè¦ç¡®è®¤ä½ æ˜¯å¦ç†è§£äº†æ¯ä¸ª`is`è¡¨è¾¾å¼çš„å³ä¾§æ˜¯å¦‚ä½•ä»å…¶ä¸Šæ–¹å³ä¾§æ¨å¯¼å‡ºæ¥çš„ã€‚è¿™ä¸ªç»ƒä¹ çš„ç›®çš„æ˜¯ç¡®ä¿ä½ ç›¸ä¿¡æœ€åä¸€ä¸ªæ£€æŸ¥ï¼ˆæˆ‘ä»¬å°†å°†å…¶è½¬æ¢ä¸ºä»£ç ï¼‰ä¸ç¬¬ä¸€ä¸ªï¼ˆæˆ‘ä»¬åœ¨ç†è§£é—®é¢˜æ—¶å†™ä¸‹æ¥çš„ï¼‰æ˜¯ç­‰ä»·çš„ã€‚
- en: '5.2.3.2Â `my-sum`: Examples[ğŸ”—](#(part._sum-eg) "Link to here")'
  id: totrans-526
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.3.2Â `my-sum`: ç¤ºä¾‹[ğŸ”—](#(part._sum-eg) "é“¾æ¥è‡³æ­¤")'
- en: 'Letâ€™s repeat this process of developing examples on a second function, this
    time one that computes the sum of the elements in a list of numbers. What is the
    sum of the list `[list: 7, 8, 9]`? Just adding up the numbers by hand, the result
    should be `24`. Letâ€™s see how that works out through the examples.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®©æˆ‘ä»¬åœ¨ç¬¬äºŒä¸ªå‡½æ•°ä¸Šé‡å¤å¼€å‘ç¤ºä¾‹çš„è¿‡ç¨‹ï¼Œè¿™æ¬¡æ˜¯ä¸€ä¸ªè®¡ç®—æ•°å­—åˆ—è¡¨ä¸­å…ƒç´ æ€»å’Œçš„å‡½æ•°ã€‚åˆ—è¡¨`[list: 7, 8, 9]`çš„æ€»å’Œæ˜¯å¤šå°‘ï¼Ÿåªéœ€æ‰‹åŠ¨å°†æ•°å­—ç›¸åŠ ï¼Œç»“æœåº”è¯¥æ˜¯`24`ã€‚è®©æˆ‘ä»¬é€šè¿‡ç¤ºä¾‹çœ‹çœ‹è¿™æ˜¯å¦‚ä½•å®ç°çš„ã€‚'
- en: 'Setting aside the empty list for a moment, here are examples that show the
    sum computations:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: æš‚æ—¶å°†ç©ºåˆ—è¡¨æ”¾åœ¨ä¸€è¾¹ï¼Œä»¥ä¸‹æ˜¯ä¸€äº›å±•ç¤ºæ±‚å’Œè®¡ç®—çš„ç¤ºä¾‹ï¼š
- en: '[PRE100]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: which (by substitution) is the same as
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡æ›¿æ¢ï¼Œå®ƒä¸ä»¥ä¸‹å†…å®¹ç›¸åŒ
- en: '[PRE101]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'From this, we can see that the sum of the empty list must be `0`:Zero is called
    the additive identity: a fancy way of saying, adding zero to any number N gives
    you N. Therefore, it makes sense that it would be the length of the empty list,
    because the empty list has no items to contribute to a sum. Can you figure out
    what the multiplicative identity is?'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™é‡Œï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºç©ºåˆ—è¡¨çš„æ€»å’Œå¿…é¡»æ˜¯`0`ï¼šé›¶è¢«ç§°ä¸ºåŠ æ³•æ’ç­‰å¼ï¼šä¸€ç§è¯´æ³•ï¼Œå³å‘ä»»ä½•æ•°å­—NåŠ ä¸Šé›¶ï¼Œä½ å¾—åˆ°Nã€‚å› æ­¤ï¼Œå®ƒæœ‰é“ç†æˆä¸ºç©ºåˆ—è¡¨çš„é•¿åº¦ï¼Œå› ä¸ºç©ºåˆ—è¡¨æ²¡æœ‰é¡¹ç›®å¯ä»¥è´¡çŒ®åˆ°æ±‚å’Œã€‚ä½ èƒ½æ‰¾å‡ºä¹˜æ³•æ’ç­‰å¼æ˜¯ä»€ä¹ˆå—ï¼Ÿ
- en: '[PRE102]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Observe, again, how we can use the result of computing `my-sum` of the rest
    of the list to compute its result for the whole list.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡è§‚å¯Ÿï¼Œæˆ‘ä»¬å¦‚ä½•ä½¿ç”¨è®¡ç®—åˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„`my-sum`çš„ç»“æœæ¥è®¡ç®—æ•´ä¸ªåˆ—è¡¨çš„ç»“æœã€‚
- en: 5.2.3.3Â From Examples to Code[ğŸ”—](#(part._.From_.Examples_to_.Code) "Link to
    here")
  id: totrans-535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.3.3 ä»ç¤ºä¾‹åˆ°ä»£ç [ğŸ”—](#(part._.From_.Examples_to_.Code) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Having developed these examples, we now want to use them to develop a program
    that can compute the length or the sum of any list, not just the specific ones
    we used in these examples. As we have done up in earlier chapters, we will leverage
    patterns in the examples to figure out how to define the general-purpose function.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¼€å‘è¿™äº›ç¤ºä¾‹ä¹‹åï¼Œæˆ‘ä»¬ç°åœ¨æƒ³ä½¿ç”¨å®ƒä»¬æ¥å¼€å‘ä¸€ä¸ªç¨‹åºï¼Œè¯¥ç¨‹åºå¯ä»¥è®¡ç®—ä»»ä½•åˆ—è¡¨çš„é•¿åº¦æˆ–æ€»å’Œï¼Œè€Œä¸ä»…ä»…æ˜¯è¿™äº›ç¤ºä¾‹ä¸­ä½¿ç”¨çš„ç‰¹å®šåˆ—è¡¨ã€‚æ­£å¦‚æˆ‘ä»¬åœ¨å‰é¢çš„ç« èŠ‚ä¸­æ‰€åšçš„é‚£æ ·ï¼Œæˆ‘ä»¬å°†åˆ©ç”¨ç¤ºä¾‹ä¸­çš„æ¨¡å¼æ¥æ‰¾å‡ºå¦‚ä½•å®šä¹‰é€šç”¨å‡½æ•°ã€‚
- en: 'Here is one last version of the examples for `my-len`, this time making the
    `rest` explicit on the right-hand sides of `is`:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯`my-len`çš„æœ€åä¸€ä¸ªç¤ºä¾‹ç‰ˆæœ¬ï¼Œè¿™æ¬¡åœ¨`is`çš„å³ä¾§æ˜ç¡®è¡¨ç¤ºäº†`rest`ï¼š
- en: '[PRE103]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'As we did when developing functions over images, letâ€™s try to identify the
    common parts of these examples. We start by noticing that most of the examples
    have a lot in common, except for the `[list: ]` (`empty`) case. So letâ€™s separate
    this into two sets of examples:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 'å°±åƒæˆ‘ä»¬åœ¨å¯¹å›¾åƒä¸Šçš„å‡½æ•°è¿›è¡Œå¼€å‘æ—¶åšçš„é‚£æ ·ï¼Œè®©æˆ‘ä»¬å°è¯•è¯†åˆ«è¿™äº›ç¤ºä¾‹çš„å…±åŒéƒ¨åˆ†ã€‚æˆ‘ä»¬é¦–å…ˆæ³¨æ„åˆ°ï¼Œå¤§å¤šæ•°ç¤ºä¾‹æœ‰å¾ˆå¤šå…±åŒä¹‹å¤„ï¼Œé™¤äº†`[list: ]`ï¼ˆç©ºï¼‰çš„æƒ…å†µã€‚å› æ­¤ï¼Œè®©æˆ‘ä»¬å°†å®ƒä»¬åˆ†ä¸ºä¸¤ç»„ç¤ºä¾‹ï¼š'
- en: '[PRE104]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'With this separation (which follows one of the structural features of lists
    that we mentioned earlier), a clearer pattern emerges: for a non-empty list (called
    `someList`), we compute its length via the expression:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡è¿™ç§åˆ†ç¦»ï¼ˆè¿™éµå¾ªäº†æˆ‘ä»¬ä¹‹å‰æåˆ°çš„åˆ—è¡¨çš„ç»“æ„ç‰¹å¾ä¹‹ä¸€ï¼‰ï¼Œä¸€ä¸ªæ›´æ¸…æ™°çš„æ¨¡å¼å‡ºç°äº†ï¼šå¯¹äºä¸€ä¸ªéç©ºåˆ—è¡¨ï¼ˆç§°ä¸º`someList`ï¼‰ï¼Œæˆ‘ä»¬é€šè¿‡ä»¥ä¸‹è¡¨è¾¾å¼è®¡ç®—å…¶é•¿åº¦ï¼š
- en: '[PRE105]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In general, then, our `my-len` program needs to determine whether its input
    list is empty or non-empty, using this expression with `.rest` in the non-empty
    case. How do we indicate different code based on the structure of the list?
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬çš„`my-len`ç¨‹åºéœ€è¦ç¡®å®šå…¶è¾“å…¥åˆ—è¡¨æ˜¯ç©ºè¿˜æ˜¯éç©ºï¼Œåœ¨éç©ºæƒ…å†µä¸‹ä½¿ç”¨è¿™ä¸ªå¸¦æœ‰`.rest`çš„è¡¨è¾¾å¼ã€‚æˆ‘ä»¬å¦‚ä½•æ ¹æ®åˆ—è¡¨çš„ç»“æ„æ¥æŒ‡ç¤ºä¸åŒçš„ä»£ç ï¼Ÿ
- en: 'Pyret has a construct called `cases` which is used to distinguish different
    forms within a structured datatype. When working with lists, the general shape
    of a `cases` expression is:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretæœ‰ä¸€ä¸ªåä¸º`cases`çš„ç»“æ„ï¼Œç”¨äºåŒºåˆ†ç»“æ„åŒ–æ•°æ®ç±»å‹ä¸­çš„ä¸åŒå½¢å¼ã€‚å½“å¤„ç†åˆ—è¡¨æ—¶ï¼Œ`cases`è¡¨è¾¾å¼çš„é€šç”¨å½¢çŠ¶æ˜¯ï¼š
- en: '[PRE106]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'where most parts are fixed, but a few youâ€™re free to change:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­å¤§éƒ¨åˆ†éƒ¨åˆ†æ˜¯å›ºå®šçš„ï¼Œä½†æœ‰ä¸€äº›ä½ å¯ä»¥è‡ªç”±æ›´æ”¹ï¼š
- en: '`e` is an expression whose value needs to be a list; it could be a variable
    bound to a list, or some complex expression that evaluates to a list.'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e`æ˜¯ä¸€ä¸ªéœ€è¦è¿”å›åˆ—è¡¨å€¼çš„è¡¨è¾¾å¼ï¼›å®ƒå¯ä»¥æ˜¯ç»‘å®šåˆ°åˆ—è¡¨çš„å˜é‡ï¼Œæˆ–è€…æ˜¯ä¸€äº›è®¡ç®—ç»“æœä¸ºåˆ—è¡¨çš„å¤æ‚è¡¨è¾¾å¼ã€‚'
- en: '`f` and `r` are names given to the first and rest of the list. You can choose
    any names you like, though in Pyret, itâ€™s conventional to use `f` and `r`.Occasionally
    using different names can help students recall that they can choose how to label
    the `first` and `rest` components. This can be particularly useful for `first`,
    which has a problem-specific meaning (such as `price` in a list of prices, and
    so on).'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`å’Œ`r`æ˜¯åˆ†é…ç»™åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ å’Œå…¶ä½™éƒ¨åˆ†çš„åç§°ã€‚ä½ å¯ä»¥é€‰æ‹©ä»»ä½•ä½ å–œæ¬¢çš„åç§°ï¼Œå°½ç®¡åœ¨Pyretä¸­ï¼Œä¼ ç»Ÿä¸Šä½¿ç”¨`f`å’Œ`r`ã€‚å¶å°”ä½¿ç”¨ä¸åŒçš„åç§°å¯ä»¥å¸®åŠ©å­¦ç”Ÿè®°ä½ä»–ä»¬å¯ä»¥é€‰æ‹©å¦‚ä½•æ ‡è®°`first`å’Œ`rest`ç»„ä»¶ã€‚è¿™å¯¹äº`first`å°¤å…¶æœ‰ç”¨ï¼Œå› ä¸ºå®ƒå…·æœ‰ç‰¹å®šçš„å«ä¹‰ï¼ˆä¾‹å¦‚ï¼Œåœ¨ä»·æ ¼åˆ—è¡¨ä¸­çš„`price`ç­‰ï¼‰ã€‚'
- en: The right-hand side of every `=>` is an expression.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ª`=>`çš„å³ä¾§éƒ½æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ã€‚
- en: Hereâ€™s how `cases` works in this instance. Pyret first evaluates `e`. It then
    checks that the resulting value truly is a list; otherwise it halts with an error.
    If it is a list, Pyret examines what kind of list it is. If itâ€™s an empty list,
    it runs the expression after the `=>` in the `empty` clause. Otherwise, the list
    is not empty, which means it has a first and rest; Pyret binds `f` and `r` to
    the two parts, respectively, and then evaluates the expression after the `=>`
    in the `link` clause.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯å¦‚ä½•åœ¨è¿™ä¸ªå®ä¾‹ä¸­ä½¿ç”¨`cases`çš„ã€‚Pyreté¦–å…ˆè¯„ä¼°`e`ã€‚ç„¶åæ£€æŸ¥ç»“æœå€¼æ˜¯å¦ç¡®å®æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼›å¦‚æœä¸æ˜¯ï¼Œå®ƒå°†å› é”™è¯¯è€Œåœæ­¢ã€‚å¦‚æœæ˜¯åˆ—è¡¨ï¼ŒPyretæ£€æŸ¥å®ƒæ˜¯ä»€ä¹ˆç±»å‹çš„åˆ—è¡¨ã€‚å¦‚æœæ˜¯ç©ºåˆ—è¡¨ï¼Œå®ƒå°†è¿è¡Œ`empty`å­å¥åçš„è¡¨è¾¾å¼ã€‚å¦åˆ™ï¼Œåˆ—è¡¨ä¸ä¸ºç©ºï¼Œè¿™æ„å‘³ç€å®ƒæœ‰ä¸€ä¸ªé¦–å…ƒç´ å’Œå‰©ä½™éƒ¨åˆ†ï¼›Pyretå°†`f`å’Œ`r`åˆ†åˆ«ç»‘å®šåˆ°ä¸¤ä¸ªéƒ¨åˆ†ï¼Œç„¶åè¯„ä¼°`link`å­å¥åçš„è¡¨è¾¾å¼ã€‚
- en: Exercise
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try using a non-listâ€”<wbr>e.g., a numberâ€”<wbr>in the `e` position and see what
    happens!
  id: totrans-553
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°è¯•åœ¨`e`ä½ç½®ä½¿ç”¨ä¸€ä¸ªéåˆ—è¡¨â€”â€”ä¾‹å¦‚ï¼Œä¸€ä¸ªæ•°å­—â€”â€”çœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆï¼
- en: 'Now letâ€™s use `cases` to define `my-len`:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨`cases`æ¥å®šä¹‰`my-len`ï¼š
- en: '[PRE107]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'This follows from our examples: when the list is empty `my-len` produces `0`;
    when it is not empty, we add one to the length of the rest of the list (here,
    `r`).'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯ä»¥ä»æˆ‘ä»¬çš„ç¤ºä¾‹ä¸­å¾—å‡ºï¼šå½“åˆ—è¡¨ä¸ºç©ºæ—¶ï¼Œ`my-len`äº§ç”Ÿ`0`ï¼›å½“åˆ—è¡¨ä¸ä¸ºç©ºæ—¶ï¼Œæˆ‘ä»¬ç»™åˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„é•¿åº¦åŠ ä¸€ï¼ˆåœ¨è¿™é‡Œï¼Œ`r`ï¼‰ã€‚
- en: Note that while our most recent collection of `my-len` examples explicitly said
    `.rest`, when using `cases` we instead use just the name `r`, which Pyret has
    already defined (under the hood) to be `l.rest`.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè™½ç„¶æˆ‘ä»¬æœ€æ–°çš„`my-len`ç¤ºä¾‹æ˜ç¡®è¯´äº†`.rest`ï¼Œä½†åœ¨ä½¿ç”¨`cases`æ—¶ï¼Œæˆ‘ä»¬åªä½¿ç”¨åç§°`r`ï¼Œè¿™æ˜¯Pyretå·²ç»å®šä¹‰ï¼ˆåœ¨åº•å±‚ï¼‰ä¸º`l.rest`çš„ã€‚
- en: 'Similarly, letâ€™s define `my-sum`:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ ·ï¼Œè®©æˆ‘ä»¬å®šä¹‰`my-sum`ï¼š
- en: '[PRE108]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Notice how similar they are in code, and how readily the structure of the data
    suggest a structure for the program. This is a pattern you will get very used
    to soon!
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„å®ƒä»¬åœ¨ä»£ç ä¸Šçš„ç›¸ä¼¼æ€§ï¼Œä»¥åŠæ•°æ®ç»“æ„å¦‚ä½•è½»æ˜“åœ°æš—ç¤ºç¨‹åºçš„ç»“æ„ã€‚ä½ å¾ˆå¿«å°±ä¼šä¹ æƒ¯è¿™ç§æ¨¡å¼ï¼
- en: 'Strategy: Developing Functions Over Lists'
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç­–ç•¥ï¼šåœ¨åˆ—è¡¨ä¸Šå¼€å‘å‡½æ•°
- en: ''
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Leverage the structure of lists and the power of concrete examples to develop
    list-processing functions.
  id: totrans-563
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åˆ©ç”¨åˆ—è¡¨çš„ç»“æ„å’Œå…·ä½“ç¤ºä¾‹çš„å¼ºå¤§åŠŸèƒ½æ¥å¼€å‘åˆ—è¡¨å¤„ç†å‡½æ•°ã€‚
- en: ''
  id: totrans-564
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pick a concrete list with (at least) three elements. Write a sequence of examples
    for each of the entire list and each suffix of the list (including the empty list).
  id: totrans-565
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€‰æ‹©ä¸€ä¸ªå…·æœ‰ï¼ˆè‡³å°‘ï¼‰ä¸‰ä¸ªå…ƒç´ çš„å…·ä½“åˆ—è¡¨ã€‚ä¸ºæ•´ä¸ªåˆ—è¡¨å’Œæ¯ä¸ªåç¼€ï¼ˆåŒ…æ‹¬ç©ºåˆ—è¡¨ï¼‰ç¼–å†™ä¸€ç³»åˆ—ç¤ºä¾‹ã€‚
- en: ''
  id: totrans-566
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-567
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Rewrite each example to express its expected answer in terms of the `first`
    and `rest` data of its input list. You donâ€™t have to use the `first` and `rest`
    operators in the new answers, but you should see the `first` and `rest` values
    represented explicitly in the answer.
  id: totrans-568
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å°†æ¯ä¸ªç¤ºä¾‹é‡å†™ï¼Œç”¨è¾“å…¥åˆ—è¡¨çš„`first`å’Œ`rest`æ•°æ®æ¥è¡¨ç¤ºå…¶é¢„æœŸçš„ç­”æ¡ˆã€‚ä½ ä¸å¿…åœ¨æ–°ç­”æ¡ˆä¸­ä½¿ç”¨`first`å’Œ`rest`è¿ç®—ç¬¦ï¼Œä½†ä½ åº”è¯¥çœ‹åˆ°`first`å’Œ`rest`å€¼åœ¨ç­”æ¡ˆä¸­æ˜ç¡®è¡¨ç¤ºã€‚
- en: ''
  id: totrans-569
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-570
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Look for a pattern across the answers in the examples. Use these to develop
    the code: write a `cases` expression, filling in the right side of each `=>` based
    on your examples.'
  id: totrans-571
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ç¤ºä¾‹çš„ç­”æ¡ˆä¸­å¯»æ‰¾ä¸€ä¸ªæ¨¡å¼ã€‚ä½¿ç”¨è¿™äº›æ¥å¼€å‘ä»£ç ï¼šç¼–å†™ä¸€ä¸ª`cases`è¡¨è¾¾å¼ï¼Œæ ¹æ®ä½ çš„ç¤ºä¾‹å¡«å†™æ¯ä¸ª`=>`çš„å³ä¾§ã€‚
- en: ''
  id: totrans-572
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-573
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-574
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This strategy applies to structured data in general, leveraging components of
    each datum rather than specifically `first` and `rest` as presented so far.
  id: totrans-575
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ç§ç­–ç•¥é€‚ç”¨äºç»“æ„åŒ–æ•°æ®ï¼Œåˆ©ç”¨æ¯ä¸ªæ•°æ®é¡¹çš„ç»„ä»¶ï¼Œè€Œä¸æ˜¯åƒä¹‹å‰æ‰€å±•ç¤ºçš„é‚£æ ·å…·ä½“ä½¿ç”¨`first`å’Œ`rest`ã€‚
- en: '5.2.3.1Â `my-len`: Examples[ğŸ”—](#(part._len-eg) "Link to here")'
  id: totrans-576
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.3.1 `my-len`ï¼šç¤ºä¾‹[ğŸ”—](#(part._len-eg) "é“¾æ¥åˆ°æ­¤å¤„")
- en: We haveâ€™t precisely defined what it means to be â€œthe lengthâ€ of a list. We confront
    this right away when trying to write an example. What is the length of the list
    `empty`?
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜æ²¡æœ‰ç²¾ç¡®åœ°å®šä¹‰åˆ—è¡¨çš„â€œé•¿åº¦â€æ˜¯ä»€ä¹ˆæ„æ€ã€‚å½“æˆ‘ä»¬å°è¯•ç¼–å†™ç¤ºä¾‹æ—¶ï¼Œæˆ‘ä»¬ç«‹å³é¢ä¸´è¿™ä¸ªé—®é¢˜ã€‚ç©ºåˆ—è¡¨`empty`çš„é•¿åº¦æ˜¯å¤šå°‘ï¼Ÿ
- en: Do Now!
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you think?
  id: totrans-580
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ è®¤ä¸ºå‘¢ï¼Ÿ
- en: 'Two common examples are `0` and `1`. The latter, `1`, certainly looks reasonable.
    However, if you write the list as `[list: ]`, now it doesnâ€™t look so right: this
    is clearly (as the name `empty` also suggests) an empty list, and an empty list
    has zero elements in it. Therefore, itâ€™s conventional to declare that'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸¤ä¸ªå¸¸è§çš„ç¤ºä¾‹æ˜¯`0`å’Œ`1`ã€‚åè€…`1`çœ‹èµ·æ¥æ˜¯åˆç†çš„ã€‚ç„¶è€Œï¼Œå¦‚æœä½ å°†åˆ—è¡¨å†™æˆ`[list: ]`ï¼Œç°åœ¨å®ƒçœ‹èµ·æ¥å°±ä¸å¤ªå¯¹äº†ï¼šè¿™æ˜¾ç„¶ï¼ˆæ­£å¦‚åç§°`empty`æ‰€æš—ç¤ºçš„ï¼‰æ˜¯ä¸€ä¸ªç©ºåˆ—è¡¨ï¼Œè€Œç©ºåˆ—è¡¨ä¸­æ²¡æœ‰ä»»ä½•å…ƒç´ ã€‚å› æ­¤ï¼Œé€šå¸¸å£°æ˜'
- en: '[PRE109]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'How about a list like `[list: 7]`? Well, itâ€™s clearly got one element (`7`)
    in it, so'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 'é‚£ä¹ˆï¼Œåƒ`[list: 7]`è¿™æ ·çš„åˆ—è¡¨æ€ä¹ˆæ ·ï¼Ÿå—¯ï¼Œå®ƒæ˜¾ç„¶æœ‰ä¸€ä¸ªå…ƒç´ ï¼ˆ`7`ï¼‰ï¼Œæ‰€ä»¥'
- en: '[PRE110]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Similarly, for a list like `[list: 7, 8, 9]`, we would say'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 'åŒæ ·ï¼Œå¯¹äºåƒ`[list: 7, 8, 9]`è¿™æ ·çš„åˆ—è¡¨ï¼Œæˆ‘ä»¬å¯ä»¥è¯´'
- en: '[PRE111]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Now letâ€™s look at that last example in a different light. Consider the argument
    `[list: 7, 8, 9]`. Its first element is `7` and the rest of it is `[list: 8, 9]`.
    Well, `7` is a number, not a list; but `[list: 8, 9]` certainly is a list, so
    we can ask for its length. What is `my-len([list: 8, 9])`? It has two elements,
    so'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä»¥ä¸åŒçš„è§’åº¦æ¥å®¡è§†é‚£ä¸ªæœ€åçš„ä¾‹å­ã€‚è€ƒè™‘å‚æ•°`[list: 7, 8, 9]`ã€‚å®ƒçš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯`7`ï¼Œå…¶ä½™çš„æ˜¯`[list: 8, 9]`ã€‚å—¯ï¼Œ`7`æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œä¸æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼›ä½†`[list:
    8, 9]`ç¡®å®æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¯¢é—®å®ƒçš„é•¿åº¦ã€‚`my-len([list: 8, 9])`æ˜¯ä»€ä¹ˆï¼Ÿå®ƒæœ‰ä¸¤ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥'
- en: '[PRE112]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The first element of that list is `8` while its rest is `[list: 9]`. What is
    its length? Note that we asked a very similar question before, for the length
    of the list `[list: 7]`. But `[list: 7]` is not a sub-list of `[list: 7, 8, 9]`,
    which we started with, whereas `[list: 9]` is. And using the same reasoning as
    before, we can say'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¯¥åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯`8`ï¼Œå…¶ä½™çš„æ˜¯`[list: 9]`ã€‚å®ƒçš„é•¿åº¦æ˜¯å¤šå°‘ï¼Ÿæ³¨æ„ï¼Œæˆ‘ä»¬ä¹‹å‰å·²ç»æå‡ºäº†ä¸€ä¸ªéå¸¸ç±»ä¼¼çš„é—®é¢˜ï¼Œå³åˆ—è¡¨`[list: 7]`çš„é•¿åº¦ã€‚ä½†æ˜¯`[list:
    7]`ä¸æ˜¯æˆ‘ä»¬ä»`[list: 7, 8, 9]`å¼€å§‹çš„å­åˆ—è¡¨ï¼Œè€Œ`[list: 9]`æ˜¯ã€‚å¹¶ä¸”ä½¿ç”¨ä¸ä¹‹å‰ç›¸åŒçš„æ¨ç†ï¼Œæˆ‘ä»¬å¯ä»¥è¯´'
- en: '[PRE113]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The rest of this last list is, of course, the empty list, whose length we have
    already decided is `0`.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œè¿™ä¸ªåˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æ˜¯ç©ºåˆ—è¡¨ï¼Œå…¶é•¿åº¦æˆ‘ä»¬å·²å†³å®šæ˜¯`0`ã€‚
- en: 'Putting together these examples, and writing out `empty` in its other form,
    hereâ€™s what we get:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“åˆè¿™äº›ä¾‹å­ï¼Œå¹¶å†™å‡º`empty`çš„å…¶ä»–å½¢å¼ï¼Œæˆ‘ä»¬å¾—åˆ°ä»¥ä¸‹ç»“æœï¼š
- en: '[PRE114]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Another way we can write this (paying attention to the right side) is
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ç§æˆ‘ä»¬å¯ä»¥å†™è¿™ä¸ªçš„æ–¹å¼ï¼ˆæ³¨æ„å³ä¾§ï¼‰æ˜¯
- en: '[PRE115]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Where did the `2`, `1`, and `0` on the right sides of each `+` operation come
    from? Those are the lengths of the `rest` component of the input list. In the
    previous example block, we wrote those lengths as explicit examples. Letâ€™s substitute
    the numbers `2`, `1`, and `0` with the `my-len` expressions that produce them:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ªåŠ æ³•æ“ä½œå³ä¾§çš„`2`ã€`1`å’Œ`0`æ˜¯ä»å“ªé‡Œæ¥çš„ï¼Ÿé‚£äº›æ˜¯è¾“å…¥åˆ—è¡¨`rest`ç»„ä»¶çš„é•¿åº¦ã€‚åœ¨å…ˆå‰çš„ä¾‹å­å—ä¸­ï¼Œæˆ‘ä»¬å°†è¿™äº›é•¿åº¦ä½œä¸ºæ˜ç¡®çš„ä¾‹å­å†™å‡ºæ¥ã€‚è®©æˆ‘ä»¬ç”¨äº§ç”Ÿå®ƒä»¬çš„`my-len`è¡¨è¾¾å¼æ›¿æ¢æ•°å­—`2`ã€`1`å’Œ`0`ï¼š
- en: '[PRE116]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: From this, maybe you can start to see a pattern. For an empty list, the length
    is `0`. For a non-empty list, itâ€™s the sum of `1` (the first elementâ€™s â€œcontributionâ€
    to the listâ€™s length) to the length of the rest of the list. In other words, we
    can use the result of computing `my-len` on the rest of the list to compute the
    answer for the entire list.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™ä¸ªä¾‹å­ä¸­ï¼Œä½ å¯èƒ½å¼€å§‹çœ‹åˆ°ä¸€ç§æ¨¡å¼ã€‚å¯¹äºä¸€ä¸ªç©ºåˆ—è¡¨ï¼Œå…¶é•¿åº¦æ˜¯`0`ã€‚å¯¹äºä¸€ä¸ªéç©ºåˆ—è¡¨ï¼Œå®ƒæ˜¯`1`ï¼ˆç¬¬ä¸€ä¸ªå…ƒç´ å¯¹åˆ—è¡¨é•¿åº¦çš„â€œè´¡çŒ®â€ï¼‰åŠ ä¸Šåˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„é•¿åº¦ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¯¹åˆ—è¡¨å…¶ä½™éƒ¨åˆ†è®¡ç®—`my-len`çš„ç»“æœæ¥è®¡ç®—æ•´ä¸ªåˆ—è¡¨çš„ç­”æ¡ˆã€‚
- en: Do Now!
  id: totrans-599
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Each of our examples in this section has written a different check on the expression
    `my-len([list: 7, 8, 9])`. Here are those examples presented together, along with
    one last one that explicitly uses the `rest` operation:'
  id: totrans-601
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'åœ¨æœ¬èŠ‚ä¸­çš„æ¯ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬éƒ½å¯¹è¡¨è¾¾å¼`my-len([list: 7, 8, 9])`è¿›è¡Œäº†ä¸åŒçš„æ£€æŸ¥ã€‚ä»¥ä¸‹æ˜¯è¿™äº›ä¾‹å­ä¸€èµ·å±•ç¤ºï¼Œä»¥åŠä¸€ä¸ªæ˜ç¡®ä½¿ç”¨`rest`æ“ä½œçš„æœ€åä¸€ä¸ªä¾‹å­ï¼š'
- en: ''
  id: totrans-602
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-603
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE117]'
- en: ''
  id: totrans-604
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check that you agree with each of these assertions. Also check whether you understand
    how the right-hand side of each `is` expression derives from the right-hand-side
    just above it. The goal of this exercise is to make sure that you believe that
    the last check (which we will turn into code) is equivalent to the first (which
    we wrote down when understanding the problem).
  id: totrans-605
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¯·ç¡®è®¤ä½ åŒæ„è¿™äº›æ–­è¨€ä¸­çš„æ¯ä¸€ä¸ªã€‚ä¹Ÿè¦ç¡®è®¤ä½ æ˜¯å¦ç†è§£äº†æ¯ä¸ª`is`è¡¨è¾¾å¼çš„å³ä¾§æ˜¯å¦‚ä½•ä»å…¶ä¸Šæ–¹å³ä¾§æ¨å¯¼å‡ºæ¥çš„ã€‚è¿™ä¸ªç»ƒä¹ çš„ç›®çš„æ˜¯ç¡®ä¿ä½ ç›¸ä¿¡æœ€åä¸€ä¸ªæ£€æŸ¥ï¼ˆæˆ‘ä»¬å°†å°†å…¶è½¬æ¢ä¸ºä»£ç ï¼‰ä¸ç¬¬ä¸€ä¸ªï¼ˆæˆ‘ä»¬åœ¨ç†è§£é—®é¢˜æ—¶å†™ä¸‹æ¥çš„ï¼‰æ˜¯ç­‰ä»·çš„ã€‚
- en: '5.2.3.2Â `my-sum`: Examples[ğŸ”—](#(part._sum-eg) "Link to here")'
  id: totrans-606
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.3.2 `my-sum`ï¼šç¤ºä¾‹[ğŸ”—](#(part._sum-eg) "é“¾æ¥è‡³æ­¤")
- en: 'Letâ€™s repeat this process of developing examples on a second function, this
    time one that computes the sum of the elements in a list of numbers. What is the
    sum of the list `[list: 7, 8, 9]`? Just adding up the numbers by hand, the result
    should be `24`. Letâ€™s see how that works out through the examples.'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 'è®©æˆ‘ä»¬åœ¨ç¬¬äºŒä¸ªå‡½æ•°ä¸Šé‡å¤è¿™ä¸ªå¼€å‘ä¾‹å­çš„è¿‡ç¨‹ï¼Œè¿™æ¬¡æ˜¯ä¸€ä¸ªè®¡ç®—æ•°å­—åˆ—è¡¨ä¸­å…ƒç´ æ€»å’Œçš„å‡½æ•°ã€‚åˆ—è¡¨`[list: 7, 8, 9]`çš„æ€»å’Œæ˜¯å¤šå°‘ï¼Ÿæ‰‹åŠ¨ç›¸åŠ è¿™äº›æ•°å­—ï¼Œç»“æœåº”è¯¥æ˜¯`24`ã€‚è®©æˆ‘ä»¬é€šè¿‡ä¾‹å­çœ‹çœ‹è¿™æ˜¯å¦‚ä½•å®ç°çš„ã€‚'
- en: 'Setting aside the empty list for a moment, here are examples that show the
    sum computations:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: æš‚æ—¶å¿½ç•¥ç©ºåˆ—è¡¨ï¼Œä»¥ä¸‹æ˜¯ä¸€äº›å±•ç¤ºæ±‚å’Œè®¡ç®—çš„ä¾‹å­ï¼š
- en: '[PRE118]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: which (by substitution) is the same as
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ï¼ˆé€šè¿‡æ›¿æ¢ï¼‰ç­‰åŒäº
- en: '[PRE119]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'From this, we can see that the sum of the empty list must be `0`:Zero is called
    the additive identity: a fancy way of saying, adding zero to any number N gives
    you N. Therefore, it makes sense that it would be the length of the empty list,
    because the empty list has no items to contribute to a sum. Can you figure out
    what the multiplicative identity is?'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™é‡Œï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºç©ºåˆ—è¡¨çš„æ€»å’Œå¿…é¡»æ˜¯`0`ï¼šé›¶è¢«ç§°ä¸ºåŠ æ³•æ’ç­‰å¼ï¼šä¸€ç§è¯´æ³•ï¼Œå³å‘ä»»ä½•æ•°å­—Næ·»åŠ é›¶ä¼šå¾—åˆ°Nã€‚å› æ­¤ï¼Œå®ƒæœ‰é“ç†æˆä¸ºç©ºåˆ—è¡¨çš„é•¿åº¦ï¼Œå› ä¸ºç©ºåˆ—è¡¨æ²¡æœ‰é¡¹ç›®å¯ä»¥è´¡çŒ®åˆ°æ€»å’Œã€‚ä½ èƒ½æ‰¾å‡ºä¹˜æ³•æ’ç­‰å¼æ˜¯ä»€ä¹ˆå—ï¼Ÿ
- en: '[PRE120]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Observe, again, how we can use the result of computing `my-sum` of the rest
    of the list to compute its result for the whole list.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡è§‚å¯Ÿï¼Œæˆ‘ä»¬å¯ä»¥å¦‚ä½•ä½¿ç”¨è®¡ç®—åˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„`my-sum`çš„ç»“æœæ¥è®¡ç®—æ•´ä¸ªåˆ—è¡¨çš„ç»“æœã€‚
- en: 5.2.3.3Â From Examples to Code[ğŸ”—](#(part._.From_.Examples_to_.Code) "Link to
    here")
  id: totrans-615
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.3.3 ä»ç¤ºä¾‹åˆ°ä»£ç [ğŸ”—](#(part._.From_.Examples_to_.Code) "é“¾æ¥åˆ°æ­¤å¤„")
- en: Having developed these examples, we now want to use them to develop a program
    that can compute the length or the sum of any list, not just the specific ones
    we used in these examples. As we have done up in earlier chapters, we will leverage
    patterns in the examples to figure out how to define the general-purpose function.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¼€å‘è¿™äº›ç¤ºä¾‹ä¹‹åï¼Œæˆ‘ä»¬ç°åœ¨æƒ³åˆ©ç”¨å®ƒä»¬æ¥å¼€å‘ä¸€ä¸ªç¨‹åºï¼Œè¯¥ç¨‹åºå¯ä»¥è®¡ç®—ä»»ä½•åˆ—è¡¨çš„é•¿åº¦æˆ–æ€»å’Œï¼Œè€Œä¸ä»…ä»…æ˜¯æˆ‘ä»¬åœ¨è¿™äº›ç¤ºä¾‹ä¸­ä½¿ç”¨çš„å…·ä½“åˆ—è¡¨ã€‚æ­£å¦‚æˆ‘ä»¬åœ¨å‰é¢çš„ç« èŠ‚ä¸­æ‰€åšçš„é‚£æ ·ï¼Œæˆ‘ä»¬å°†åˆ©ç”¨ç¤ºä¾‹ä¸­çš„æ¨¡å¼æ¥æ‰¾å‡ºå¦‚ä½•å®šä¹‰é€šç”¨å‡½æ•°ã€‚
- en: 'Here is one last version of the examples for `my-len`, this time making the
    `rest` explicit on the right-hand sides of `is`:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯`my-len`çš„æœ€åä¸€ä¸ªç¤ºä¾‹ç‰ˆæœ¬ï¼Œè¿™æ¬¡åœ¨`is`çš„å³ä¾§æ˜ç¡®æ˜¾ç¤ºäº†`rest`ï¼š
- en: '[PRE121]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'As we did when developing functions over images, letâ€™s try to identify the
    common parts of these examples. We start by noticing that most of the examples
    have a lot in common, except for the `[list: ]` (`empty`) case. So letâ€™s separate
    this into two sets of examples:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ­£å¦‚æˆ‘ä»¬åœ¨å¼€å‘å›¾åƒä¸Šçš„å‡½æ•°æ—¶æ‰€åšçš„ï¼Œè®©æˆ‘ä»¬å°è¯•è¯†åˆ«è¿™äº›ç¤ºä¾‹çš„å…±åŒéƒ¨åˆ†ã€‚æˆ‘ä»¬é¦–å…ˆæ³¨æ„åˆ°ï¼Œå¤§å¤šæ•°ç¤ºä¾‹æœ‰å¾ˆå¤šå…±åŒä¹‹å¤„ï¼Œé™¤äº†`[list: ]`ï¼ˆ`empty`ï¼‰æƒ…å†µã€‚æ‰€ä»¥è®©æˆ‘ä»¬å°†è¿™ä¸ªåˆ†æˆä¸¤ç»„ç¤ºä¾‹ï¼š'
- en: '[PRE122]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'With this separation (which follows one of the structural features of lists
    that we mentioned earlier), a clearer pattern emerges: for a non-empty list (called
    `someList`), we compute its length via the expression:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡è¿™ç§åˆ†ç¦»ï¼ˆè¿™éµå¾ªäº†æˆ‘ä»¬ä¹‹å‰æåˆ°çš„åˆ—è¡¨çš„ç»“æ„ç‰¹å¾ä¹‹ä¸€ï¼‰ï¼Œä¸€ä¸ªæ›´æ¸…æ™°çš„æ¨¡å¼å‡ºç°äº†ï¼šå¯¹äºä¸€ä¸ªéç©ºåˆ—è¡¨ï¼ˆç§°ä¸º`someList`ï¼‰ï¼Œæˆ‘ä»¬é€šè¿‡ä»¥ä¸‹è¡¨è¾¾å¼æ¥è®¡ç®—å…¶é•¿åº¦ï¼š
- en: '[PRE123]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: In general, then, our `my-len` program needs to determine whether its input
    list is empty or non-empty, using this expression with `.rest` in the non-empty
    case. How do we indicate different code based on the structure of the list?
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬çš„`my-len`ç¨‹åºéœ€è¦ç¡®å®šå…¶è¾“å…¥åˆ—è¡¨æ˜¯ç©ºè¿˜æ˜¯éç©ºï¼Œåœ¨éç©ºæƒ…å†µä¸‹ä½¿ç”¨`.rest`è¿™ä¸ªè¡¨è¾¾å¼ã€‚æˆ‘ä»¬å¦‚ä½•æ ¹æ®åˆ—è¡¨çš„ç»“æ„æ¥æŒ‡ç¤ºä¸åŒçš„ä»£ç ï¼Ÿ
- en: 'Pyret has a construct called `cases` which is used to distinguish different
    forms within a structured datatype. When working with lists, the general shape
    of a `cases` expression is:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: Pyretæœ‰ä¸€ä¸ªåä¸º`cases`çš„ç»“æ„ï¼Œç”¨äºåŒºåˆ†ç»“æ„åŒ–æ•°æ®ç±»å‹ä¸­çš„ä¸åŒå½¢å¼ã€‚å½“å¤„ç†åˆ—è¡¨æ—¶ï¼Œ`cases`è¡¨è¾¾å¼çš„é€šç”¨å½¢çŠ¶å¦‚ä¸‹ï¼š
- en: '[PRE124]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'where most parts are fixed, but a few youâ€™re free to change:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­å¤§éƒ¨åˆ†éƒ¨åˆ†æ˜¯å›ºå®šçš„ï¼Œä½†æœ‰ä¸€å°éƒ¨åˆ†ä½ å¯ä»¥è‡ªç”±æ›´æ”¹ï¼š
- en: '`e` is an expression whose value needs to be a list; it could be a variable
    bound to a list, or some complex expression that evaluates to a list.'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e`æ˜¯ä¸€ä¸ªéœ€è¦å…¶å€¼ä¸ºåˆ—è¡¨çš„è¡¨è¾¾å¼ï¼›å®ƒå¯ä»¥æ˜¯ç»‘å®šåˆ°åˆ—è¡¨çš„å˜é‡ï¼Œæˆ–è€…æŸäº›å¤æ‚çš„è¡¨è¾¾å¼ï¼Œå…¶ç»“æœä¸ºåˆ—è¡¨ã€‚'
- en: '`f` and `r` are names given to the first and rest of the list. You can choose
    any names you like, though in Pyret, itâ€™s conventional to use `f` and `r`.Occasionally
    using different names can help students recall that they can choose how to label
    the `first` and `rest` components. This can be particularly useful for `first`,
    which has a problem-specific meaning (such as `price` in a list of prices, and
    so on).'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`å’Œ`r`æ˜¯åˆ†é…ç»™åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ å’Œå…¶ä½™éƒ¨åˆ†çš„åç§°ã€‚ä½ å¯ä»¥é€‰æ‹©ä»»ä½•ä½ å–œæ¬¢çš„åç§°ï¼Œå°½ç®¡åœ¨Pyretä¸­ï¼Œä¼ ç»Ÿä¸Šä½¿ç”¨`f`å’Œ`r`ã€‚å¶å°”ä½¿ç”¨ä¸åŒçš„åç§°å¯ä»¥å¸®åŠ©å­¦ç”Ÿè®°ä½ä»–ä»¬å¯ä»¥é€‰æ‹©å¦‚ä½•æ ‡è®°`first`å’Œ`rest`ç»„ä»¶ã€‚è¿™å¯¹äº`first`å°¤å…¶æœ‰ç”¨ï¼Œå› ä¸ºå®ƒå…·æœ‰ç‰¹å®šçš„å«ä¹‰ï¼ˆä¾‹å¦‚ï¼Œåœ¨ä»·æ ¼åˆ—è¡¨ä¸­çš„`price`ç­‰ï¼‰ã€‚'
- en: The right-hand side of every `=>` is an expression.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ª`=>`çš„å³ä¾§éƒ½æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ã€‚
- en: Hereâ€™s how `cases` works in this instance. Pyret first evaluates `e`. It then
    checks that the resulting value truly is a list; otherwise it halts with an error.
    If it is a list, Pyret examines what kind of list it is. If itâ€™s an empty list,
    it runs the expression after the `=>` in the `empty` clause. Otherwise, the list
    is not empty, which means it has a first and rest; Pyret binds `f` and `r` to
    the two parts, respectively, and then evaluates the expression after the `=>`
    in the `link` clause.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯åœ¨è¿™ä¸ªä¾‹å­ä¸­`cases`æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚Pyreté¦–å…ˆè¯„ä¼°`e`ã€‚ç„¶åæ£€æŸ¥ç»“æœå€¼æ˜¯å¦ç¡®å®æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼›å¦‚æœä¸æ˜¯ï¼Œå®ƒå°†å› é”™è¯¯è€Œåœæ­¢ã€‚å¦‚æœæ˜¯åˆ—è¡¨ï¼ŒPyretå°†æ£€æŸ¥å®ƒæ˜¯ä»€ä¹ˆç±»å‹çš„åˆ—è¡¨ã€‚å¦‚æœæ˜¯ç©ºåˆ—è¡¨ï¼Œå®ƒå°†è¿è¡Œ`empty`å­å¥ä¸­`=>`åé¢çš„è¡¨è¾¾å¼ã€‚å¦åˆ™ï¼Œåˆ—è¡¨ä¸ä¸ºç©ºï¼Œè¿™æ„å‘³ç€å®ƒæœ‰ä¸€ä¸ªé¦–å…ƒç´ å’Œå…¶ä½™éƒ¨åˆ†ï¼›Pyretå°†`f`å’Œ`r`åˆ†åˆ«ç»‘å®šåˆ°è¿™ä¸¤éƒ¨åˆ†ï¼Œç„¶åè¯„ä¼°`link`å­å¥ä¸­`=>`åé¢çš„è¡¨è¾¾å¼ã€‚
- en: Exercise
  id: totrans-631
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-632
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try using a non-listâ€”<wbr>e.g., a numberâ€”<wbr>in the `e` position and see what
    happens!
  id: totrans-633
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°è¯•ä½¿ç”¨éåˆ—è¡¨â€”â€”ä¾‹å¦‚ï¼Œä¸€ä¸ªæ•°å­—â€”â€”åœ¨`e`ä½ç½®ï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆï¼
- en: 'Now letâ€™s use `cases` to define `my-len`:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨`cases`æ¥å®šä¹‰`my-len`ï¼š
- en: '[PRE125]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'This follows from our examples: when the list is empty `my-len` produces `0`;
    when it is not empty, we add one to the length of the rest of the list (here,
    `r`).'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä»æˆ‘ä»¬çš„ç¤ºä¾‹ä¸­å¾—å‡ºçš„ï¼šå½“åˆ—è¡¨ä¸ºç©ºæ—¶ï¼Œ`my-len`äº§ç”Ÿ`0`ï¼›å½“å®ƒä¸ä¸ºç©ºæ—¶ï¼Œæˆ‘ä»¬å°†å…¶ä½™åˆ—è¡¨çš„é•¿åº¦åŠ ä¸€ï¼ˆåœ¨è¿™é‡Œï¼Œ`r`ï¼‰ã€‚
- en: Note that while our most recent collection of `my-len` examples explicitly said
    `.rest`, when using `cases` we instead use just the name `r`, which Pyret has
    already defined (under the hood) to be `l.rest`.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè™½ç„¶æˆ‘ä»¬æœ€è¿‘çš„`my-len`ç¤ºä¾‹æ˜ç¡®æåˆ°äº†`.rest`ï¼Œä½†åœ¨ä½¿ç”¨`cases`æ—¶ï¼Œæˆ‘ä»¬åªä½¿ç”¨åç§°`r`ï¼ŒPyretå·²ç»ï¼ˆåœ¨åº•å±‚ï¼‰å°†å…¶å®šä¹‰ä¸º`l.rest`ã€‚
- en: 'Similarly, letâ€™s define `my-sum`:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: ç±»ä¼¼åœ°ï¼Œè®©æˆ‘ä»¬å®šä¹‰`my-sum`ï¼š
- en: '[PRE126]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Notice how similar they are in code, and how readily the structure of the data
    suggest a structure for the program. This is a pattern you will get very used
    to soon!
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„å®ƒä»¬åœ¨ä»£ç ä¸Šçš„ç›¸ä¼¼æ€§ï¼Œä»¥åŠæ•°æ®ç»“æ„å¦‚ä½•è‡ªç„¶è€Œç„¶åœ°æš—ç¤ºç¨‹åºçš„ç»“æ„ã€‚è¿™å°†æ˜¯æ‚¨å¾ˆå¿«å°±ä¼šä¹ æƒ¯çš„æ¨¡å¼ï¼
- en: 'Strategy: Developing Functions Over Lists'
  id: totrans-641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç­–ç•¥ï¼šåœ¨åˆ—è¡¨ä¸Šå¼€å‘å‡½æ•°
- en: ''
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Leverage the structure of lists and the power of concrete examples to develop
    list-processing functions.
  id: totrans-643
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åˆ©ç”¨åˆ—è¡¨çš„ç»“æ„å’Œå…·ä½“ç¤ºä¾‹çš„åŠ›é‡æ¥å¼€å‘åˆ—è¡¨å¤„ç†å‡½æ•°ã€‚
- en: ''
  id: totrans-644
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pick a concrete list with (at least) three elements. Write a sequence of examples
    for each of the entire list and each suffix of the list (including the empty list).
  id: totrans-645
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€‰æ‹©ä¸€ä¸ªå…·æœ‰ï¼ˆè‡³å°‘ï¼‰ä¸‰ä¸ªå…ƒç´ çš„åˆ—è¡¨ã€‚ä¸ºæ•´ä¸ªåˆ—è¡¨å’Œæ¯ä¸ªåç¼€ï¼ˆåŒ…æ‹¬ç©ºåˆ—è¡¨ï¼‰ç¼–å†™ä¸€ç³»åˆ—ç¤ºä¾‹ã€‚
- en: ''
  id: totrans-646
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-647
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Rewrite each example to express its expected answer in terms of the `first`
    and `rest` data of its input list. You donâ€™t have to use the `first` and `rest`
    operators in the new answers, but you should see the `first` and `rest` values
    represented explicitly in the answer.
  id: totrans-648
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: å°†æ¯ä¸ªç¤ºä¾‹é‡å†™ï¼Œç”¨å…¶è¾“å…¥åˆ—è¡¨çš„`first`å’Œ`rest`æ•°æ®æ¥è¡¨ç¤ºé¢„æœŸçš„ç­”æ¡ˆã€‚æ‚¨ä¸å¿…åœ¨æ–°ç­”æ¡ˆä¸­ä½¿ç”¨`first`å’Œ`rest`è¿ç®—ç¬¦ï¼Œä½†æ‚¨åº”è¯¥çœ‹åˆ°`first`å’Œ`rest`å€¼åœ¨ç­”æ¡ˆä¸­æ˜ç¡®è¡¨ç¤ºã€‚
- en: ''
  id: totrans-649
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-650
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Look for a pattern across the answers in the examples. Use these to develop
    the code: write a `cases` expression, filling in the right side of each `=>` based
    on your examples.'
  id: totrans-651
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ç¤ºä¾‹çš„ç­”æ¡ˆä¸­å¯»æ‰¾æ¨¡å¼ã€‚ä½¿ç”¨è¿™äº›æ¥å¼€å‘ä»£ç ï¼šç¼–å†™ä¸€ä¸ª`cases`è¡¨è¾¾å¼ï¼Œæ ¹æ®æ‚¨çš„ç¤ºä¾‹å¡«å†™æ¯ä¸ª`=>`çš„å³ä¾§ã€‚
- en: ''
  id: totrans-652
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-653
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-654
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: This strategy applies to structured data in general, leveraging components of
    each datum rather than specifically `first` and `rest` as presented so far.
  id: totrans-655
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ç§ç­–ç•¥é€‚ç”¨äºç»“æ„åŒ–æ•°æ®ï¼Œåˆ©ç”¨æ¯ä¸ªæ•°æ®é¡¹çš„ç»„ä»¶ï¼Œè€Œä¸æ˜¯åƒè¿„ä»Šä¸ºæ­¢æ‰€å±•ç¤ºçš„é‚£æ ·å…·ä½“ä½¿ç”¨`first`å’Œ`rest`ã€‚
- en: 5.2.4Â Structural Problems that Transform Lists[ğŸ”—](#(part._.Structural_.Problems_that_.Transform_.Lists)
    "Link to here")
  id: totrans-656
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.4Â å°†åˆ—è¡¨è½¬æ¢ä¸ºç»“æ„åŒ–é—®é¢˜çš„æ–¹æ³•[ğŸ”—](#(part._.Structural_.Problems_that_.Transform_.Lists)
    "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Now that we have a systematic way to develop functions that take lists as input,
    letâ€™s apply that same strategy to functions that produce a list as the answer.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†å¼€å‘ä»¥åˆ—è¡¨ä¸ºè¾“å…¥çš„å‡½æ•°çš„ç³»ç»Ÿæ–¹æ³•ï¼Œè®©æˆ‘ä»¬å°†ç›¸åŒçš„ç­–ç•¥åº”ç”¨åˆ°äº§ç”Ÿåˆ—è¡¨ä½œä¸ºç­”æ¡ˆçš„å‡½æ•°ä¸Šã€‚
- en: '5.2.4.1Â `my-doubles`: Examples and Code[ğŸ”—](#(part._doubles-eg-code) "Link to
    here")'
  id: totrans-658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.4.1Â `my-doubles`ï¼šç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._doubles-eg-code) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'As always, weâ€™ll begin with some examples. Given a list of numbers, we want
    a list that doubles each number (in the order of the original list). Hereâ€™s a
    reasonable example with three numbers:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: å’Œå¾€å¸¸ä¸€æ ·ï¼Œæˆ‘ä»¬å°†ä»ä¸€äº›ç¤ºä¾‹å¼€å§‹ã€‚ç»™å®šä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œæˆ‘ä»¬æƒ³è¦ä¸€ä¸ªåˆ—è¡¨ï¼Œå®ƒå°†æ¯ä¸ªæ•°å­—ç¿»å€ï¼ˆæŒ‰ç…§åŸå§‹åˆ—è¡¨çš„é¡ºåºï¼‰ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªåŒ…å«ä¸‰ä¸ªæ•°å­—çš„åˆç†ç¤ºä¾‹ï¼š
- en: '[PRE127]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'As before, letâ€™s write out the answers for each suffix of our example list
    as well, including for the `empty` list:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚å‰æ‰€è¿°ï¼Œè®©æˆ‘ä»¬ä¸ºç¤ºä¾‹åˆ—è¡¨çš„æ¯ä¸ªåç¼€å†™å‡ºç­”æ¡ˆï¼ŒåŒ…æ‹¬ç©ºåˆ—è¡¨ï¼š
- en: '[PRE128]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Now, we rewrite the answer expressions to include the concrete `first` and
    `rest` data for each example. Letâ€™s start with just the `first` data, and just
    on the first example:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å°†é‡å†™ç­”æ¡ˆè¡¨è¾¾å¼ï¼ŒåŒ…æ‹¬æ¯ä¸ªç¤ºä¾‹çš„`first`å’Œ`rest`æ•°æ®ã€‚è®©æˆ‘ä»¬å…ˆä»`first`æ•°æ®å¼€å§‹ï¼Œåªé’ˆå¯¹ç¬¬ä¸€ä¸ªç¤ºä¾‹ï¼š
- en: '[PRE129]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Next, letâ€™s include the `rest` data (`[list: 5, 2]`) in the first example.
    The current answer in the first example is'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ¥ä¸‹æ¥ï¼Œè®©æˆ‘ä»¬åœ¨ç¬¬ä¸€ä¸ªä¾‹å­ä¸­åŒ…å«`rest`æ•°æ®ï¼ˆ`[list: 5, 2]`ï¼‰ã€‚ç¬¬ä¸€ä¸ªä¾‹å­ä¸­çš„å½“å‰ç­”æ¡ˆæ˜¯'
- en: '[PRE130]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'and that `[list: 10, 4]` is the result of using the function on `[list: 5,
    2]`. We might therefore be tempted to replace the right side of the first example
    with:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¹¶ä¸”`[list: 10, 4]`æ˜¯ä½¿ç”¨å‡½æ•°å¯¹`[list: 5, 2]`åº”ç”¨çš„ç»“æœã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šæƒ³ç”¨ä»¥ä¸‹æ–¹å¼æ›¿æ¢ç¬¬ä¸€ä¸ªä¾‹å­çš„å³ä¾§ï¼š'
- en: '[PRE131]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Do Now!
  id: totrans-669
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What value would this expression produce? You might want to try this example
    that doesnâ€™t use `my-doubles` directly:'
  id: totrans-671
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè¡¨è¾¾å¼ä¼šäº§ç”Ÿä»€ä¹ˆå€¼ï¼Ÿä½ å¯èƒ½æƒ³å°è¯•è¿™ä¸ªä¸ç›´æ¥ä½¿ç”¨`my-doubles`çš„ä¾‹å­ï¼š
- en: ''
  id: totrans-672
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-673
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Oops! We want a single (flat) list, not a list-within-a-list. This feels like
    it is on the right track in terms of reworking the answer to use the `first` and
    `rest` values, but weâ€™re clearly not quite there yet.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: å“å‘€ï¼æˆ‘ä»¬æƒ³è¦ä¸€ä¸ªå•ä¸€çš„ï¼ˆæ‰å¹³ï¼‰åˆ—è¡¨ï¼Œè€Œä¸æ˜¯åµŒå¥—åˆ—è¡¨ã€‚ä»é‡æ–°æ„æ€ç­”æ¡ˆä»¥ä½¿ç”¨`first`å’Œ`rest`å€¼çš„è§’åº¦æ¥çœ‹ï¼Œè¿™ä¼¼ä¹æ˜¯æ­£ç¡®çš„æ–¹å‘ï¼Œä½†æˆ‘ä»¬æ˜¾ç„¶è¿˜æ²¡æœ‰å®Œå…¨è¾¾åˆ°ç›®æ ‡ã€‚
- en: Do Now!
  id: totrans-675
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What value does the following expression produce?
  id: totrans-677
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹è¡¨è¾¾å¼ä¼šäº§ç”Ÿä»€ä¹ˆå€¼ï¼Ÿ
- en: ''
  id: totrans-678
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-679
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Notice the difference between the two expressions in these last two exercises:
    the latter used `link` to put the value involving `first` into the conversion
    of the `rest`, while the former tried to do this with `list:`.'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„è¿™ä¸¤ä¸ªæœ€åç»ƒä¹ ä¸­çš„ä¸¤ä¸ªè¡¨è¾¾å¼çš„åŒºåˆ«ï¼šåè€…ä½¿ç”¨`link`å°†æ¶‰åŠ`first`çš„å€¼æ”¾å…¥`rest`çš„è½¬æ¢ä¸­ï¼Œè€Œå‰è€…å°è¯•ä½¿ç”¨`list:`æ¥å®Œæˆè¿™ä¸ªæ“ä½œã€‚
- en: Do Now!
  id: totrans-681
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many elements are in the lists that result from each of the following expressions?
  id: totrans-683
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¯ä¸ªä»¥ä¸‹è¡¨è¾¾å¼äº§ç”Ÿçš„åˆ—è¡¨ä¸­æœ‰å¤šå°‘ä¸ªå…ƒç´ ï¼Ÿ
- en: ''
  id: totrans-684
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-685
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Do Now!
  id: totrans-686
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summarize the difference between how `link` and `list:` combine an element and
    a list. Try additional examples at the interactions prompt if needed to explore
    these ideas.
  id: totrans-688
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ€»ç»“ä¸€ä¸‹`link`å’Œ`list:`å¦‚ä½•ç»„åˆå…ƒç´ å’Œåˆ—è¡¨ä¹‹é—´çš„åŒºåˆ«ã€‚å¦‚æœéœ€è¦ï¼Œåœ¨äº¤äº’æç¤ºç¬¦ä¸­å°è¯•é¢å¤–çš„ç¤ºä¾‹æ¥æ¢ç´¢è¿™äº›æƒ³æ³•ã€‚
- en: 'The takeaway here is that we use `link` to insert an element into an existing
    list, whereas we use `list:` to make a new list that contains the old list as
    an element. Going back to our examples, then, we include `rest` in the first example
    by writing it as follows:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„è¦ç‚¹æ˜¯ï¼Œæˆ‘ä»¬ä½¿ç”¨`link`å°†å…ƒç´ æ’å…¥åˆ°ç°æœ‰åˆ—è¡¨ä¸­ï¼Œè€Œä½¿ç”¨`list:`æ¥åˆ›å»ºä¸€ä¸ªåŒ…å«æ—§åˆ—è¡¨ä½œä¸ºå…ƒç´ çš„æ–°åˆ—è¡¨ã€‚å›åˆ°æˆ‘ä»¬çš„ä¾‹å­ï¼Œé‚£ä¹ˆï¼Œæˆ‘ä»¬åœ¨ç¬¬ä¸€ä¸ªä¾‹å­ä¸­é€šè¿‡ä»¥ä¸‹æ–¹å¼åŒ…å«`rest`ï¼š
- en: '[PRE135]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: which we then convert to
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†å…¶è½¬æ¢ä¸º
- en: '[PRE136]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Applying this idea across the examples, we get:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: å°†è¿™ä¸ªæƒ³æ³•åº”ç”¨åˆ°ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬å¾—åˆ°ï¼š
- en: '[PRE137]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Now that we have examples that explicitly use the `first` and `rest` elements,
    we can produce to write the `my-doubles` function:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†æ˜ç¡®ä½¿ç”¨`first`å’Œ`rest`å…ƒç´ çš„ä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™`my-doubles`å‡½æ•°ï¼š
- en: '[PRE138]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '5.2.4.2Â `my-str-len`: Examples and Code[ğŸ”—](#(part._str-len-eg-code) "Link to
    here")'
  id: totrans-697
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.4.2Â `my-str-len`ï¼šç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._str-len-eg-code) "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'In `my-doubles`, the input and output lists have the same type of element.
    Functions can also produce lists whose contents have a different type from the
    input list. Letâ€™s work through an example. Given a list of strings, we want the
    lengths of each string (in the same order as in the input list). Thus, hereâ€™s
    a reasonable example:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨`my-doubles`ä¸­ï¼Œè¾“å…¥å’Œè¾“å‡ºåˆ—è¡¨å…·æœ‰ç›¸åŒç±»å‹çš„å…ƒç´ ã€‚å‡½æ•°ä¹Ÿå¯ä»¥ç”Ÿæˆå†…å®¹ç±»å‹ä¸è¾“å…¥åˆ—è¡¨ä¸åŒçš„åˆ—è¡¨ã€‚è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªä¾‹å­æ¥åˆ†æã€‚ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œæˆ‘ä»¬æƒ³è¦æ¯ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦ï¼ˆä¸è¾“å…¥åˆ—è¡¨ä¸­çš„é¡ºåºç›¸åŒï¼‰ã€‚å› æ­¤ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªåˆç†çš„ä¾‹å­ï¼š
- en: '[PRE139]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'As we have before, we should consider the answers for each sub-problem of the
    above example:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚åŒä¹‹å‰ï¼Œæˆ‘ä»¬åº”è¯¥è€ƒè™‘ä¸Šè¿°ä¾‹å­ä¸­æ¯ä¸ªå­é—®é¢˜çš„ç­”æ¡ˆï¼š
- en: '[PRE140]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Or, in other words:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…æ¢å¥è¯è¯´ï¼š
- en: '[PRE141]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'which tells us that the response for the empty list should be `empty`:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å‘Šè¯‰æˆ‘ä»¬ç©ºåˆ—è¡¨çš„å“åº”åº”è¯¥æ˜¯`empty`ï¼š
- en: '[PRE142]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The next step is to rework the answers in the examples to make the `first`
    and `rest` parts explicit. Hopefully by now you are starting to detect a pattern:
    The result on the rest of the list appears explicitly as another example. Therefore,
    weâ€™ll start by getting the `rest` value of each example input into the answer:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹ä¸€æ­¥æ˜¯å°†ç¤ºä¾‹ä¸­çš„ç­”æ¡ˆé‡æ–°æ„æ€ï¼Œä½¿`first`å’Œ`rest`éƒ¨åˆ†æ˜ç¡®ã€‚å¸Œæœ›åˆ°ç°åœ¨ä½ å·²ç»å¼€å§‹å‘ç°ä¸€ä¸ªæ¨¡å¼ï¼šåˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†çš„è¾“å‡ºæ˜ç¡®åœ°ä½œä¸ºå¦ä¸€ä¸ªä¾‹å­å‡ºç°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†é¦–å…ˆè·å–æ¯ä¸ªç¤ºä¾‹è¾“å…¥çš„`rest`å€¼åˆ°ç­”æ¡ˆä¸­ï¼š
- en: '[PRE143]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'All that remains now is to figure out how to work the `first` values into the
    outputs. In the context of this problem, this means we need to convert `"hi"`
    into `2`, `"there"` into `5`, and so on. From the problem statement, we know that
    `2` and `5` are meant to be the lengths (character counts) of the corresponding
    strings. The operation that determines the length of a string is called `string-length`.
    Thus, our examples appear as:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨å‰©ä¸‹çš„å°±æ˜¯å¼„æ¸…æ¥šå¦‚ä½•å°†`first`å€¼æ•´åˆåˆ°è¾“å‡ºä¸­ã€‚åœ¨è¿™ä¸ªé—®é¢˜çš„èƒŒæ™¯ä¸‹ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬éœ€è¦å°†`"hi"`è½¬æ¢ä¸º`2`ï¼Œå°†`"there"`è½¬æ¢ä¸º`5`ç­‰ç­‰ã€‚ä»é—®é¢˜é™ˆè¿°ä¸­ï¼Œæˆ‘ä»¬çŸ¥é“`2`å’Œ`5`æ˜¯æŒ‡å¯¹åº”å­—ç¬¦ä¸²çš„é•¿åº¦ï¼ˆå­—ç¬¦è®¡æ•°ï¼‰ã€‚ç¡®å®šå­—ç¬¦ä¸²é•¿åº¦çš„æ“ä½œç§°ä¸º`string-length`ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„ä¾‹å­å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE144]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'From here, we write a function that captures the pattern developed across our
    examples:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™é‡Œï¼Œæˆ‘ä»¬ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æ•æ‰æˆ‘ä»¬ä¾‹å­ä¸­å¼€å‘çš„æ¨¡å¼ï¼š
- en: '[PRE145]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '5.2.4.1Â `my-doubles`: Examples and Code[ğŸ”—](#(part._doubles-eg-code) "Link to
    here")'
  id: totrans-712
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.4.1Â `my-doubles`: ç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._doubles-eg-code) "é“¾æ¥è‡³æ­¤")'
- en: 'As always, weâ€™ll begin with some examples. Given a list of numbers, we want
    a list that doubles each number (in the order of the original list). Hereâ€™s a
    reasonable example with three numbers:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»æ˜¯ï¼Œæˆ‘ä»¬å°†ä»ä¸€äº›ä¾‹å­å¼€å§‹ã€‚ç»™å®šä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œæˆ‘ä»¬æƒ³è¦ä¸€ä¸ªåˆ—è¡¨ï¼Œå®ƒå°†æ¯ä¸ªæ•°å­—åŠ å€ï¼ˆæŒ‰åŸå§‹åˆ—è¡¨çš„é¡ºåºï¼‰ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªåŒ…å«ä¸‰ä¸ªæ•°å­—çš„åˆç†ä¾‹å­ï¼š
- en: '[PRE146]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'As before, letâ€™s write out the answers for each suffix of our example list
    as well, including for the `empty` list:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚å‰æ‰€è¿°ï¼Œè®©æˆ‘ä»¬ä¸ºæˆ‘ä»¬çš„ä¾‹å­åˆ—è¡¨çš„æ¯ä¸ªåç¼€å†™å‡ºç­”æ¡ˆï¼ŒåŒ…æ‹¬ç©ºåˆ—è¡¨ï¼š
- en: '[PRE147]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Now, we rewrite the answer expressions to include the concrete `first` and
    `rest` data for each example. Letâ€™s start with just the `first` data, and just
    on the first example:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬é‡å†™ç­”æ¡ˆè¡¨è¾¾å¼ï¼ŒåŒ…æ‹¬æ¯ä¸ªä¾‹å­çš„å…·ä½“ `first` å’Œ `rest` æ•°æ®ã€‚è®©æˆ‘ä»¬å…ˆä» `first` æ•°æ®å¼€å§‹ï¼Œä»…é’ˆå¯¹ç¬¬ä¸€ä¸ªä¾‹å­ï¼š
- en: '[PRE148]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Next, letâ€™s include the `rest` data (`[list: 5, 2]`) in the first example.
    The current answer in the first example is'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ¥ä¸‹æ¥ï¼Œè®©æˆ‘ä»¬åœ¨ç¬¬ä¸€ä¸ªä¾‹å­ä¸­åŒ…å« `rest` æ•°æ® (`[list: 5, 2]`)ã€‚ç¬¬ä¸€ä¸ªä¾‹å­ä¸­çš„å½“å‰ç­”æ¡ˆæ˜¯'
- en: '[PRE149]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'and that `[list: 10, 4]` is the result of using the function on `[list: 5,
    2]`. We might therefore be tempted to replace the right side of the first example
    with:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¹¶ä¸” `[list: 10, 4]` æ˜¯ä½¿ç”¨å‡½æ•° `[list: 5, 2]` çš„ç»“æœã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šæƒ³ç”¨ä»¥ä¸‹å†…å®¹æ›¿æ¢ç¬¬ä¸€ä¸ªä¾‹å­çš„å³ä¾§ï¼š'
- en: '[PRE150]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Do Now!
  id: totrans-723
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-724
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What value would this expression produce? You might want to try this example
    that doesnâ€™t use `my-doubles` directly:'
  id: totrans-725
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè¡¨è¾¾å¼ä¼šäº§ç”Ÿä»€ä¹ˆå€¼ï¼Ÿä½ å¯èƒ½æƒ³å°è¯•è¿™ä¸ªä¸ç›´æ¥ä½¿ç”¨ `my-doubles` çš„ä¾‹å­ï¼š
- en: ''
  id: totrans-726
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-727
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Oops! We want a single (flat) list, not a list-within-a-list. This feels like
    it is on the right track in terms of reworking the answer to use the `first` and
    `rest` values, but weâ€™re clearly not quite there yet.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: å“å‘€ï¼æˆ‘ä»¬æƒ³è¦ä¸€ä¸ªå•ä¸€çš„ï¼ˆæ‰å¹³ï¼‰åˆ—è¡¨ï¼Œè€Œä¸æ˜¯åˆ—è¡¨ä¸­çš„åˆ—è¡¨ã€‚è¿™æ„Ÿè§‰åœ¨é‡æ–°è®¾è®¡ç­”æ¡ˆä»¥ä½¿ç”¨ `first` å’Œ `rest` å€¼æ–¹é¢æ˜¯æ­£ç¡®çš„æ–¹å‘ï¼Œä½†æˆ‘ä»¬æ˜¾ç„¶è¿˜æ²¡æœ‰å®Œå…¨åšåˆ°ã€‚
- en: Do Now!
  id: totrans-729
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-730
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What value does the following expression produce?
  id: totrans-731
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹è¡¨è¾¾å¼ä¼šäº§ç”Ÿä»€ä¹ˆå€¼ï¼Ÿ
- en: ''
  id: totrans-732
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-733
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Notice the difference between the two expressions in these last two exercises:
    the latter used `link` to put the value involving `first` into the conversion
    of the `rest`, while the former tried to do this with `list:`.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„è¿™ä¸¤ä¸ªæœ€åç»ƒä¹ ä¸­çš„ä¸¤ä¸ªè¡¨è¾¾å¼çš„åŒºåˆ«ï¼šåè€…ä½¿ç”¨ `link` å°†æ¶‰åŠ `first` çš„å€¼æ”¾å…¥ `rest` çš„è½¬æ¢ä¸­ï¼Œè€Œå‰è€…è¯•å›¾ä½¿ç”¨ `list:`
    æ¥åšè¿™ä»¶äº‹ã€‚
- en: Do Now!
  id: totrans-735
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-736
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many elements are in the lists that result from each of the following expressions?
  id: totrans-737
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ¯ä¸ªä»¥ä¸‹è¡¨è¾¾å¼äº§ç”Ÿçš„åˆ—è¡¨ä¸­æœ‰å¤šå°‘ä¸ªå…ƒç´ ï¼Ÿ
- en: ''
  id: totrans-738
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-739
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Do Now!
  id: totrans-740
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-741
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summarize the difference between how `link` and `list:` combine an element and
    a list. Try additional examples at the interactions prompt if needed to explore
    these ideas.
  id: totrans-742
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ€»ç»“ `link` å’Œ `list:` å¦‚ä½•ç»„åˆå…ƒç´ å’Œåˆ—è¡¨ä¹‹é—´çš„åŒºåˆ«ã€‚å¦‚æœéœ€è¦ï¼Œåœ¨äº¤äº’æç¤ºç¬¦ä¸­å°è¯•é¢å¤–çš„ä¾‹å­æ¥æ¢ç´¢è¿™äº›æƒ³æ³•ã€‚
- en: 'The takeaway here is that we use `link` to insert an element into an existing
    list, whereas we use `list:` to make a new list that contains the old list as
    an element. Going back to our examples, then, we include `rest` in the first example
    by writing it as follows:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„è¦ç‚¹æ˜¯ï¼Œæˆ‘ä»¬ä½¿ç”¨ `link` åœ¨ç°æœ‰åˆ—è¡¨ä¸­æ’å…¥ä¸€ä¸ªå…ƒç´ ï¼Œè€Œä½¿ç”¨ `list:` æ¥åˆ›å»ºä¸€ä¸ªåŒ…å«æ—§åˆ—è¡¨ä½œä¸ºå…ƒç´ çš„æ–°åˆ—è¡¨ã€‚å›åˆ°æˆ‘ä»¬çš„ä¾‹å­ï¼Œé‚£ä¹ˆï¼Œæˆ‘ä»¬é€šè¿‡ä»¥ä¸‹æ–¹å¼åœ¨ç¬¬ä¸€ä¸ªä¾‹å­ä¸­åŒ…å«
    `rest`ï¼š
- en: '[PRE154]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: which we then convert to
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬å°†å®ƒè½¬æ¢ä¸º
- en: '[PRE155]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Applying this idea across the examples, we get:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: å°†è¿™ä¸ªæƒ³æ³•åº”ç”¨åˆ°ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å¾—åˆ°ï¼š
- en: '[PRE156]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Now that we have examples that explicitly use the `first` and `rest` elements,
    we can produce to write the `my-doubles` function:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†æ˜ç¡®ä½¿ç”¨ `first` å’Œ `rest` å…ƒç´ çš„ä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™ `my-doubles` å‡½æ•°ï¼š
- en: '[PRE157]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '5.2.4.2Â `my-str-len`: Examples and Code[ğŸ”—](#(part._str-len-eg-code) "Link to
    here")'
  id: totrans-751
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.4.2Â `my-str-len`: ç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._str-len-eg-code) "é“¾æ¥è‡³æ­¤")'
- en: 'In `my-doubles`, the input and output lists have the same type of element.
    Functions can also produce lists whose contents have a different type from the
    input list. Letâ€™s work through an example. Given a list of strings, we want the
    lengths of each string (in the same order as in the input list). Thus, hereâ€™s
    a reasonable example:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ `my-doubles` ä¸­ï¼Œè¾“å…¥å’Œè¾“å‡ºåˆ—è¡¨å…·æœ‰ç›¸åŒç±»å‹çš„å…ƒç´ ã€‚å‡½æ•°è¿˜å¯ä»¥ç”Ÿæˆå†…å®¹ç±»å‹ä¸è¾“å…¥åˆ—è¡¨ä¸åŒçš„åˆ—è¡¨ã€‚è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªä¾‹å­æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œæˆ‘ä»¬æƒ³è¦æ¯ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦ï¼ˆä¸è¾“å…¥åˆ—è¡¨ä¸­çš„é¡ºåºç›¸åŒï¼‰ã€‚å› æ­¤ï¼Œè¿™é‡Œæ˜¯ä¸€ä¸ªåˆç†çš„ä¾‹å­ï¼š
- en: '[PRE158]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'As we have before, we should consider the answers for each sub-problem of the
    above example:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æˆ‘ä»¬ä¹‹å‰æ‰€åšçš„é‚£æ ·ï¼Œæˆ‘ä»¬åº”è¯¥è€ƒè™‘ä¸Šè¿°ä¾‹å­ä¸­æ¯ä¸ªå­é—®é¢˜çš„ç­”æ¡ˆï¼š
- en: '[PRE159]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Or, in other words:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…ï¼Œæ¢å¥è¯è¯´ï¼š
- en: '[PRE160]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'which tells us that the response for the empty list should be `empty`:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å‘Šè¯‰æˆ‘ä»¬ç©ºåˆ—è¡¨çš„å“åº”åº”è¯¥æ˜¯ `empty`ï¼š
- en: '[PRE161]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'The next step is to rework the answers in the examples to make the `first`
    and `rest` parts explicit. Hopefully by now you are starting to detect a pattern:
    The result on the rest of the list appears explicitly as another example. Therefore,
    weâ€™ll start by getting the `rest` value of each example input into the answer:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹ä¸€æ­¥æ˜¯å°†ç¤ºä¾‹ä¸­çš„ç­”æ¡ˆé‡æ–°æ•´ç†ï¼Œä½¿`first`å’Œ`rest`éƒ¨åˆ†æ˜ç¡®ã€‚å¸Œæœ›åˆ°ç°åœ¨ä¸ºæ­¢ï¼Œä½ å·²ç»å¼€å§‹å‘ç°ä¸€ä¸ªæ¨¡å¼ï¼šåˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„ç»“æœæ˜ç¡®åœ°ä½œä¸ºå¦ä¸€ä¸ªç¤ºä¾‹å‡ºç°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†é¦–å…ˆå°†æ¯ä¸ªç¤ºä¾‹è¾“å…¥çš„`rest`å€¼æ”¾å…¥ç­”æ¡ˆä¸­ï¼š
- en: '[PRE162]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'All that remains now is to figure out how to work the `first` values into the
    outputs. In the context of this problem, this means we need to convert `"hi"`
    into `2`, `"there"` into `5`, and so on. From the problem statement, we know that
    `2` and `5` are meant to be the lengths (character counts) of the corresponding
    strings. The operation that determines the length of a string is called `string-length`.
    Thus, our examples appear as:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨å‰©ä¸‹çš„å°±æ˜¯å¼„æ¸…æ¥šå¦‚ä½•å°†`first`å€¼æ•´åˆåˆ°è¾“å‡ºä¸­ã€‚åœ¨è¿™ä¸ªé—®é¢˜çš„èƒŒæ™¯ä¸‹ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬éœ€è¦å°†`"hi"`è½¬æ¢ä¸º`2`ï¼Œå°†`"there"`è½¬æ¢ä¸º`5`ï¼Œä¾æ­¤ç±»æ¨ã€‚ä»é—®é¢˜é™ˆè¿°ä¸­ï¼Œæˆ‘ä»¬çŸ¥é“`2`å’Œ`5`æ˜¯æŒ‡å¯¹åº”å­—ç¬¦ä¸²çš„é•¿åº¦ï¼ˆå­—ç¬¦è®¡æ•°ï¼‰ã€‚ç¡®å®šå­—ç¬¦ä¸²é•¿åº¦çš„æ“ä½œç§°ä¸º`string-length`ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„ç¤ºä¾‹å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE163]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'From here, we write a function that captures the pattern developed across our
    examples:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™é‡Œï¼Œæˆ‘ä»¬ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æ•æ‰æˆ‘ä»¬åœ¨ç¤ºä¾‹ä¸­å¼€å‘çš„æ¨¡å¼ï¼š
- en: '[PRE164]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 5.2.5Â Structural Problems that Select from Lists[ğŸ”—](#(part._.Structural_.Problems_that_.Select_from_.Lists)
    "Link to here")
  id: totrans-766
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.5 ç»“æ„åŒ–é—®é¢˜ï¼Œä»åˆ—è¡¨ä¸­é€‰æ‹©[ğŸ”—](#(part._.Structural_.Problems_that_.Select_from_.Lists)
    "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'In the previous section, we saw functions that transform list elements (by
    doubling numbers or counting characters). The type of the output list may or may
    not be the same as the type of the input list. Other functions that produce lists
    instead select elements: every element in the output list was in the input list,
    but some input-list elements might not appear in the output list. This section
    adapts our method of deriving functions from examples to accommodate selection
    of elements.'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸Šä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†è½¬æ¢åˆ—è¡¨å…ƒç´ çš„å‡½æ•°ï¼ˆé€šè¿‡åŠ å€æ•°å­—æˆ–è®¡ç®—å­—ç¬¦ï¼‰ã€‚è¾“å‡ºåˆ—è¡¨çš„ç±»å‹å¯èƒ½ä¸è¾“å…¥åˆ—è¡¨çš„ç±»å‹ç›¸åŒï¼Œä¹Ÿå¯èƒ½ä¸åŒã€‚å…¶ä»–äº§ç”Ÿåˆ—è¡¨è€Œä¸æ˜¯é€‰æ‹©å…ƒç´ çš„å‡½æ•°ï¼Œè¾“å‡ºåˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½åœ¨è¾“å…¥åˆ—è¡¨ä¸­ï¼Œä½†è¾“å…¥åˆ—è¡¨ä¸­çš„ä¸€äº›å…ƒç´ å¯èƒ½ä¸ä¼šå‡ºç°åœ¨è¾“å‡ºåˆ—è¡¨ä¸­ã€‚æœ¬èŠ‚å°†æˆ‘ä»¬çš„ä»ç¤ºä¾‹æ¨å¯¼å‡½æ•°çš„æ–¹æ³•é€‚åº”å…ƒç´ é€‰æ‹©ã€‚
- en: '5.2.5.1Â `my-pos-nums`: Examples and Code[ğŸ”—](#(part._pos-nums-eg-code) "Link
    to here")'
  id: totrans-768
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.5.1 `my-pos-nums`ï¼šç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._pos-nums-eg-code) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: As our first example, we will select the positive numbers from a list that contains
    both positive and non-positive numbers.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªç¤ºä¾‹ï¼Œæˆ‘ä»¬å°†ä»åŒ…å«æ­£æ•°å’Œéæ­£æ•°çš„åˆ—è¡¨ä¸­é€‰æ‹©æ­£æ•°ã€‚
- en: Do Now!
  id: totrans-770
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-771
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Construct the sequence of examples that we obtain from the input `[list: 1,
    -2, 3, -4]`.'
  id: totrans-772
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'æ„å»ºä»è¾“å…¥`[list: 1, -2, 3, -4]`è·å¾—çš„ç¤ºä¾‹åºåˆ—ã€‚'
- en: 'Here we go:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯ï¼š
- en: '[PRE165]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'We can write this in the following form:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å†™æˆä»¥ä¸‹å½¢å¼ï¼š
- en: '[PRE166]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: or, even more explicitly,
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…ï¼Œæ›´æ˜ç¡®åœ°è¯´ï¼Œ
- en: '[PRE167]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Unlike in the example sequences for functions that transform lists, here we
    see that the answers have different shapes: some involve a `link`, while others
    simply process the `rest` of the list. Whenever we need different shapes of outputs
    across a set of examples, we will need an `if` expression in our code to distinguish
    the conditions that yield each shape.'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å‡½æ•°è½¬æ¢åˆ—è¡¨çš„ç¤ºä¾‹åºåˆ—ä¸åŒï¼Œè¿™é‡Œæˆ‘ä»¬çœ‹åˆ°ç­”æ¡ˆæœ‰ä¸åŒçš„å½¢çŠ¶ï¼šä¸€äº›æ¶‰åŠ`link`ï¼Œè€Œå¦ä¸€äº›åªæ˜¯å¤„ç†åˆ—è¡¨çš„`rest`éƒ¨åˆ†ã€‚æ¯å½“æˆ‘ä»¬éœ€è¦åœ¨ä¸€ç³»åˆ—ç¤ºä¾‹ä¸­å…·æœ‰ä¸åŒå½¢çŠ¶çš„è¾“å‡ºæ—¶ï¼Œæˆ‘ä»¬å°†åœ¨ä»£ç ä¸­éœ€è¦ä¸€ä¸ª`if`è¡¨è¾¾å¼æ¥åŒºåˆ†äº§ç”Ÿæ¯ç§å½¢çŠ¶çš„æ¡ä»¶ã€‚
- en: 'What determines which shape of output we get? Letâ€™s rearrange the examples
    (other than the empty-list input) by output shape:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¯ä»€ä¹ˆå†³å®šäº†æˆ‘ä»¬å¾—åˆ°çš„è¾“å‡ºå½¢çŠ¶ï¼Ÿè®©æˆ‘ä»¬æŒ‰ç…§è¾“å‡ºå½¢çŠ¶é‡æ–°æ’åˆ—ç¤ºä¾‹ï¼ˆé™¤äº†ç©ºåˆ—è¡¨è¾“å…¥ä¹‹å¤–ï¼‰ï¼š
- en: '[PRE168]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Re-organized, we can see that the examples that use `link` have a positive
    number in the `first` position, while the ones that donâ€™t simply process the `rest`
    of the list. That indicates that our `if` expression needs to ask whether the
    `first` element in the list is positive. This yields the following program:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: é‡æ–°ç»„ç»‡åï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä½¿ç”¨`link`çš„ç¤ºä¾‹åœ¨`first`ä½ç½®æœ‰ä¸€ä¸ªæ­£æ•°ï¼Œè€Œæ²¡æœ‰ä½¿ç”¨`link`çš„ç¤ºä¾‹åªæ˜¯å¤„ç†åˆ—è¡¨çš„`rest`éƒ¨åˆ†ã€‚è¿™è¡¨æ˜æˆ‘ä»¬çš„`if`è¡¨è¾¾å¼éœ€è¦è¯¢é—®åˆ—è¡¨ä¸­çš„`first`å…ƒç´ æ˜¯å¦ä¸ºæ­£æ•°ã€‚è¿™äº§ç”Ÿäº†ä»¥ä¸‹ç¨‹åºï¼š
- en: '[PRE169]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Do Now!
  id: totrans-784
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-785
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is our set of examples comprehensive?
  id: totrans-786
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ç¤ºä¾‹é›†æ˜¯å¦å…¨é¢ï¼Ÿ
- en: Not really. There are many examples we havenâ€™t considered, such as lists that
    end with positive numbers and lists with `0`.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šä¸æ˜¯ã€‚è¿˜æœ‰å¾ˆå¤šæˆ‘ä»¬æ²¡æœ‰è€ƒè™‘åˆ°çš„ç¤ºä¾‹ï¼Œä¾‹å¦‚ä»¥æ­£æ•°ç»“å°¾çš„åˆ—è¡¨å’ŒåŒ…å«`0`çš„åˆ—è¡¨ã€‚
- en: Exercise
  id: totrans-788
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-789
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Work through these examples and see how they affect the program!
  id: totrans-790
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä»”ç»†ç ”ç©¶è¿™äº›ç¤ºä¾‹ï¼Œçœ‹çœ‹å®ƒä»¬å¦‚ä½•å½±å“ç¨‹åºï¼
- en: '5.2.5.2Â `my-alternating`: Examples and Code[ğŸ”—](#(part._alternating-eg-code)
    "Link to here")'
  id: totrans-791
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.5.2 `my-alternating`ï¼šç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._alternating-eg-code) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: Now letâ€™s consider a problem that selects elements not by value, but by position.
    We want to write a function that selects alternating elements from a list. Once
    again, weâ€™re going to work from examples.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ªé€šè¿‡ä½ç½®è€Œä¸æ˜¯å€¼é€‰æ‹©å…ƒç´ çš„é—®é¢˜ã€‚æˆ‘ä»¬æƒ³è¦ç¼–å†™ä¸€ä¸ªä»åˆ—è¡¨ä¸­é€‰æ‹©äº¤æ›¿å…ƒç´ çš„åŠŸèƒ½ã€‚å†ä¸€æ¬¡ï¼Œæˆ‘ä»¬å°†ä»ç¤ºä¾‹å¼€å§‹å·¥ä½œã€‚
- en: Do Now!
  id: totrans-793
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-794
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Work out the results for `my-alternating` starting from the list `[list: 1,
    2, 3, 4, 5, 6]`.'
  id: totrans-795
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'ä»åˆ—è¡¨`[list: 1, 2, 3, 4, 5, 6]`å¼€å§‹ï¼Œè®¡ç®—`my-alternating`çš„ç»“æœã€‚'
- en: 'Hereâ€™s how they work out:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å®ƒä»¬æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼š
- en: <alternating-egs-1> ::=
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: <alternating-egs-1> ::=
- en: '[PRE170]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Wait, whatâ€™s that? The two answers above are each correct, but the second answer
    does not help us in any way construct the first answer. That means the way weâ€™ve
    solved these problems until now is not enough for this new kind of problem. Itâ€™s
    still useful, though: notice that thereâ€™s a connection between the first example
    and the third, as well as between the second example and the fourth. This observation
    is consistent with our goal of selecting alternating elements.'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: ç­‰ç­‰ï¼Œé‚£æ˜¯ä»€ä¹ˆï¼Ÿä¸Šé¢çš„ä¸¤ä¸ªç­”æ¡ˆéƒ½æ˜¯æ­£ç¡®çš„ï¼Œä½†ç¬¬äºŒä¸ªç­”æ¡ˆå¹¶ä¸èƒ½å¸®åŠ©æˆ‘ä»¬æ„å»ºç¬¬ä¸€ä¸ªç­”æ¡ˆã€‚è¿™æ„å‘³ç€æˆ‘ä»¬åˆ°ç›®å‰ä¸ºæ­¢è§£å†³é—®é¢˜çš„æ–¹æ³•ä¸è¶³ä»¥è§£å†³è¿™ç§æ–°ç±»å‹çš„é—®é¢˜ã€‚å°½ç®¡å¦‚æ­¤ï¼Œå®ƒä»ç„¶æ˜¯æœ‰ç”¨çš„ï¼šæ³¨æ„ï¼Œç¬¬ä¸€ä¸ªç¤ºä¾‹å’Œç¬¬ä¸‰ä¸ªç¤ºä¾‹ä¹‹é—´ï¼Œä»¥åŠç¬¬äºŒä¸ªç¤ºä¾‹å’Œç¬¬å››ä¸ªç¤ºä¾‹ä¹‹é—´ï¼Œå­˜åœ¨è”ç³»ã€‚è¿™ä¸€è§‚å¯Ÿä¸æˆ‘ä»¬çš„é€‰æ‹©äº¤æ›¿å…ƒç´ çš„ç›®æ ‡æ˜¯ä¸€è‡´çš„ã€‚
- en: 'What would something like this look like in code? Before we try to write the
    function, letâ€™s rewrite the first example in terms of the third:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åœ¨ä»£ç ä¸­ä¼šæ˜¯ä»€ä¹ˆæ ·å­ï¼Ÿåœ¨æˆ‘ä»¬å°è¯•ç¼–å†™å‡½æ•°ä¹‹å‰ï¼Œè®©æˆ‘ä»¬ç”¨ç¬¬ä¸‰ä¸ªç¤ºä¾‹æ¥é‡å†™ç¬¬ä¸€ä¸ªç¤ºä¾‹ï¼š
- en: '[PRE171]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Note that in the rewritten version, we are dropping two elements from the list
    before using `my-alternating` again, not just one. We will have to figure out
    how to handle that in our code.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨é‡å†™çš„ç‰ˆæœ¬ä¸­ï¼Œæˆ‘ä»¬åœ¨å†æ¬¡ä½¿ç”¨`my-alternating`ä¹‹å‰ä»åˆ—è¡¨ä¸­åˆ é™¤äº†ä¸¤ä¸ªå…ƒç´ ï¼Œè€Œä¸ä»…ä»…æ˜¯å…¶ä¸­ä¸€ä¸ªã€‚æˆ‘ä»¬å°†åœ¨ä»£ç ä¸­æ‰¾å‡ºå¦‚ä½•å¤„ç†è¿™ä¸€ç‚¹ã€‚
- en: 'Letâ€™s start with our usual function pattern with a `cases` expression:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»å¸¦æœ‰`cases`è¡¨è¾¾å¼çš„å¸¸è§„å‡½æ•°æ¨¡å¼å¼€å§‹ï¼š
- en: '[PRE172]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Note that we cannot simply call `my-alternating` on `r`, because `r` excludes
    only one item from the list, not two as this problem requires. We have to break
    down `r` as well, in order to get to the `rest` of the `rest` of the original
    list. To do this, we use another `cases` expression, nested within the first `cases`
    expression:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬ä¸èƒ½ç®€å•åœ°è°ƒç”¨`my-alternating`åœ¨`r`ä¸Šï¼Œå› ä¸º`r`åªä»åˆ—è¡¨ä¸­æ’é™¤ä¸€ä¸ªå…ƒç´ ï¼Œè€Œä¸æ˜¯è¿™ä¸ªé—®é¢˜çš„ä¸¤ä¸ªå…ƒç´ ã€‚æˆ‘ä»¬å¿…é¡»åˆ†è§£`r`ï¼Œä»¥ä¾¿åˆ°è¾¾åŸå§‹åˆ—è¡¨çš„`rest`çš„`rest`ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨å¦ä¸€ä¸ª`cases`è¡¨è¾¾å¼ï¼Œå®ƒåµŒå¥—åœ¨ç¬¬ä¸€ä¸ª`cases`è¡¨è¾¾å¼ä¸­ï¼š
- en: '[PRE173]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'This code is consistent with the example that we just worked out. But note
    that we still have a bit of unfinished work to do: we need to decide what to do
    in the `empty` case of the inner `cases` expression (marked by `???` in the code).'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™æ®µä»£ç ä¸æˆ‘ä»¬åˆšåˆšè§£å†³çš„ç¤ºä¾‹ä¸€è‡´ã€‚ä½†è¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä»ç„¶æœ‰ä¸€äº›æœªå®Œæˆçš„å·¥ä½œè¦åšï¼šæˆ‘ä»¬éœ€è¦å†³å®šåœ¨å†…å±‚`cases`è¡¨è¾¾å¼çš„`empty`æƒ…å†µä¸‹è¦åšä»€ä¹ˆï¼ˆåœ¨ä»£ç ä¸­ç”¨`???`æ ‡è®°ï¼‰ã€‚ '
- en: A common temptation at this point is to replace the `???` with `[list:]`. After
    all, havenâ€™t we always returned `[list:]` in the `empty` cases?
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œä¸€ä¸ªå¸¸è§çš„è¯±æƒ‘æ˜¯å°†`???`æ›¿æ¢ä¸º`[list:]`ã€‚æ¯•ç«Ÿï¼Œåœ¨`empty`æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸æ˜¯æ€»æ˜¯è¿”å›`[list:]`å—ï¼Ÿ
- en: Do Now!
  id: totrans-809
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-810
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Replace `???` with `[list:]` and test the program on our original examples:'
  id: totrans-811
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°†`???`æ›¿æ¢ä¸º`[list:]`å¹¶åœ¨æˆ‘ä»¬çš„åŸå§‹ç¤ºä¾‹ä¸Šæµ‹è¯•ç¨‹åºï¼š
- en: ''
  id: totrans-812
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-813
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE174]'
- en: ''
  id: totrans-814
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you observe?
  id: totrans-815
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ è§‚å¯Ÿåˆ°äº†ä»€ä¹ˆï¼Ÿ
- en: Oops! Weâ€™ve written a program that appears to work on lists with an even number
    of elements, but not on lists with an odd number of elements. How did that happen?
    The only part of this code that we guessed at was how to fill in the `empty` case
    of the inner `cases`, so the issue must be there. Rather than focus on the code,
    however, focus on the examples. We need a simple example that would land on that
    part of the code. We get to that spot when the list `l` is not empty, but `r`
    (the rest of `l`) is empty. In other words, we need an example with only one element.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: å“å‘€ï¼æˆ‘ä»¬ç¼–å†™äº†ä¸€ä¸ªä¼¼ä¹åœ¨å¶æ•°å…ƒç´ åˆ—è¡¨ä¸Šå·¥ä½œä½†åœ¨å¥‡æ•°å…ƒç´ åˆ—è¡¨ä¸Šä¸å·¥ä½œçš„ç¨‹åºã€‚è¿™æ˜¯æ€ä¹ˆå‘ç”Ÿçš„ï¼Ÿæˆ‘ä»¬å”¯ä¸€çŒœæµ‹çš„éƒ¨åˆ†æ˜¯å†…å±‚`cases`çš„`empty`æƒ…å†µï¼Œæ‰€ä»¥é—®é¢˜è‚¯å®šåœ¨é‚£é‡Œã€‚ç„¶è€Œï¼Œä¸å…¶å…³æ³¨ä»£ç ï¼Œä¸å¦‚å…³æ³¨ç¤ºä¾‹ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ï¼Œä»¥ä¾¿å®šä½åˆ°ä»£ç çš„è¯¥éƒ¨åˆ†ã€‚å½“åˆ—è¡¨`l`ä¸ä¸ºç©ºä½†`r`ï¼ˆ`l`çš„å…¶ä½™éƒ¨åˆ†ï¼‰ä¸ºç©ºæ—¶ï¼Œæˆ‘ä»¬å°±ä¼šåˆ°è¾¾é‚£ä¸ªä½ç½®ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåªæœ‰ä¸€ä¸ªå…ƒç´ çš„ç¤ºä¾‹ã€‚
- en: Do Now!
  id: totrans-817
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Finish the following example:'
  id: totrans-819
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®Œæˆä»¥ä¸‹ç¤ºä¾‹ï¼š
- en: ''
  id: totrans-820
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-821
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Given a list with one element, that element should be included in a list of
    alternating elements. Thus, we should finish this example as
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªåªæœ‰ä¸€ä¸ªå…ƒç´ çš„åˆ—è¡¨ï¼Œè¯¥å…ƒç´ åº”åŒ…å«åœ¨äº¤æ›¿å…ƒç´ åˆ—è¡¨ä¸­ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥å°†æ­¤ç¤ºä¾‹å®Œæˆå¦‚ä¸‹
- en: '[PRE176]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Do Now!
  id: totrans-824
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-825
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use this example to update the result of `my-alternating` when `r` is `empty`
    in our code.
  id: totrans-826
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨æ­¤ç¤ºä¾‹æ¥æ›´æ–°ä»£ç ä¸­`r`ä¸ºç©ºæ—¶`my-alternating`çš„ç»“æœã€‚
- en: 'Leveraging this new example, the final version of `my-alternating` is as follows:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ©ç”¨è¿™ä¸ªæ–°ç¤ºä¾‹ï¼Œ`my-alternating`çš„æœ€ç»ˆç‰ˆæœ¬å¦‚ä¸‹ï¼š
- en: '[PRE177]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Whatâ€™s the takeaway from this problem? There are two:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªé—®é¢˜æœ‰ä»€ä¹ˆå¯ç¤ºï¼Ÿæœ‰ä¸¤ä¸ªï¼š
- en: 'Donâ€™t skip the small examples: the result of a list-processing function on
    the `empty` case wonâ€™t always be `empty`.'
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸è¦å¿½ç•¥å°ä¾‹å­ï¼šåˆ—è¡¨å¤„ç†å‡½æ•°åœ¨`empty`æƒ…å†µä¸‹çš„ç»“æœä¸æ€»æ˜¯`empty`ã€‚
- en: If a problem asks you to work with multiple elements from the front of a list,
    you can nest `cases` expressions to access later elements.
  id: totrans-831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœä¸€ä¸ªé—®é¢˜è¦æ±‚ä½ å¤„ç†åˆ—è¡¨å‰é¢çš„å¤šä¸ªå…ƒç´ ï¼Œä½ å¯ä»¥åµŒå¥—`cases`è¡¨è¾¾å¼æ¥è®¿é—®åç»­å…ƒç´ ã€‚
- en: 'These takeaways will matter again in future examples: keep an eye out for them!'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›å¯ç¤ºåœ¨æœªæ¥ä¾‹å­ä¸­è¿˜ä¼šå¾ˆé‡è¦ï¼šè¯·æ³¨æ„å®ƒä»¬ï¼
- en: '5.2.5.1Â `my-pos-nums`: Examples and Code[ğŸ”—](#(part._pos-nums-eg-code) "Link
    to here")'
  id: totrans-833
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.5.1Â `my-pos-nums`: ç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._pos-nums-eg-code) "é“¾æ¥åˆ°è¿™é‡Œ")'
- en: As our first example, we will select the positive numbers from a list that contains
    both positive and non-positive numbers.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºæˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å°†ä»åŒ…å«æ­£æ•°å’Œéæ­£æ•°çš„åˆ—è¡¨ä¸­é€‰æ‹©æ­£æ•°ã€‚
- en: Do Now!
  id: totrans-835
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹å³è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-836
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Construct the sequence of examples that we obtain from the input `[list: 1,
    -2, 3, -4]`.'
  id: totrans-837
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'æ„å»ºä»è¾“å…¥`[list: 1, -2, 3, -4]`è·å¾—çš„ç¤ºä¾‹åºåˆ—ã€‚'
- en: 'Here we go:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæˆ‘ä»¬å¼€å§‹ï¼š
- en: '[PRE178]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'We can write this in the following form:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å†™æˆä»¥ä¸‹å½¢å¼ï¼š
- en: '[PRE179]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: or, even more explicitly,
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…ï¼Œç”šè‡³æ›´æ˜ç¡®åœ°ï¼Œ
- en: '[PRE180]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Unlike in the example sequences for functions that transform lists, here we
    see that the answers have different shapes: some involve a `link`, while others
    simply process the `rest` of the list. Whenever we need different shapes of outputs
    across a set of examples, we will need an `if` expression in our code to distinguish
    the conditions that yield each shape.'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å˜æ¢åˆ—è¡¨çš„å‡½æ•°çš„ç¤ºä¾‹åºåˆ—ä¸åŒï¼Œè¿™é‡Œæˆ‘ä»¬çœ‹åˆ°ç­”æ¡ˆæœ‰ä¸åŒçš„å½¢çŠ¶ï¼šä¸€äº›æ¶‰åŠ`link`ï¼Œè€Œå¦ä¸€äº›åˆ™ç®€å•åœ°å¤„ç†åˆ—è¡¨çš„`rest`éƒ¨åˆ†ã€‚æ¯å½“æˆ‘ä»¬éœ€è¦åœ¨ä¸€ç³»åˆ—ç¤ºä¾‹ä¸­è·å–ä¸åŒå½¢çŠ¶çš„è¾“å‡ºæ—¶ï¼Œæˆ‘ä»¬éƒ½éœ€è¦åœ¨ä»£ç ä¸­ä½¿ç”¨`if`è¡¨è¾¾å¼æ¥åŒºåˆ†äº§ç”Ÿæ¯ç§å½¢çŠ¶çš„æ¡ä»¶ã€‚
- en: 'What determines which shape of output we get? Letâ€™s rearrange the examples
    (other than the empty-list input) by output shape:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¯ä»€ä¹ˆå†³å®šäº†æˆ‘ä»¬å¾—åˆ°å“ªç§å½¢çŠ¶çš„è¾“å‡ºï¼Ÿè®©æˆ‘ä»¬æŒ‰è¾“å‡ºå½¢çŠ¶é‡æ–°æ’åˆ—ç¤ºä¾‹ï¼ˆé™¤äº†ç©ºåˆ—è¡¨è¾“å…¥ï¼‰ï¼š
- en: '[PRE181]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Re-organized, we can see that the examples that use `link` have a positive
    number in the `first` position, while the ones that donâ€™t simply process the `rest`
    of the list. That indicates that our `if` expression needs to ask whether the
    `first` element in the list is positive. This yields the following program:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: é‡æ–°ç»„ç»‡åï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä½¿ç”¨`link`çš„ä¾‹å­åœ¨`first`ä½ç½®æœ‰ä¸€ä¸ªæ­£æ•°ï¼Œè€Œæ²¡æœ‰ä½¿ç”¨`link`çš„ä¾‹å­åˆ™ç®€å•åœ°å¤„ç†åˆ—è¡¨çš„`rest`éƒ¨åˆ†ã€‚è¿™è¡¨æ˜æˆ‘ä»¬çš„`if`è¡¨è¾¾å¼éœ€è¦è¯¢é—®åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¦ä¸ºæ­£ã€‚è¿™å¯¼è‡´äº†ä»¥ä¸‹ç¨‹åºï¼š
- en: '[PRE182]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Do Now!
  id: totrans-849
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹å³è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-850
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is our set of examples comprehensive?
  id: totrans-851
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ç¤ºä¾‹é›†æ˜¯å¦å…¨é¢ï¼Ÿ
- en: Not really. There are many examples we havenâ€™t considered, such as lists that
    end with positive numbers and lists with `0`.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: å®é™…ä¸Šå¹¶ä¸å…¨é¢ã€‚è¿˜æœ‰å¾ˆå¤šæˆ‘ä»¬æ²¡æœ‰è€ƒè™‘çš„ä¾‹å­ï¼Œæ¯”å¦‚ä»¥æ­£æ•°ç»“å°¾çš„åˆ—è¡¨å’ŒåŒ…å«`0`çš„åˆ—è¡¨ã€‚
- en: Exercise
  id: totrans-853
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-854
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Work through these examples and see how they affect the program!
  id: totrans-855
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: é€šè¿‡è¿™äº›ä¾‹å­ï¼Œçœ‹çœ‹å®ƒä»¬å¦‚ä½•å½±å“ç¨‹åºï¼
- en: '5.2.5.2Â `my-alternating`: Examples and Code[ğŸ”—](#(part._alternating-eg-code)
    "Link to here")'
  id: totrans-856
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.5.2Â `my-alternating`: ç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._alternating-eg-code) "é“¾æ¥åˆ°è¿™é‡Œ")'
- en: Now letâ€™s consider a problem that selects elements not by value, but by position.
    We want to write a function that selects alternating elements from a list. Once
    again, weâ€™re going to work from examples.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ªé—®é¢˜ï¼Œå®ƒä¸æ˜¯æ ¹æ®å€¼è€Œæ˜¯æ ¹æ®ä½ç½®é€‰æ‹©å…ƒç´ ã€‚æˆ‘ä»¬æƒ³è¦ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œä»åˆ—è¡¨ä¸­é€‰æ‹©äº¤æ›¿å…ƒç´ ã€‚å†ä¸€æ¬¡ï¼Œæˆ‘ä»¬å°†ä»ä¾‹å­å¼€å§‹å·¥ä½œã€‚
- en: Do Now!
  id: totrans-858
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹å³è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-859
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Work out the results for `my-alternating` starting from the list `[list: 1,
    2, 3, 4, 5, 6]`.'
  id: totrans-860
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'ä»åˆ—è¡¨`[list: 1, 2, 3, 4, 5, 6]`å¼€å§‹ï¼Œè®¡ç®—`my-alternating`çš„ç»“æœã€‚'
- en: 'Hereâ€™s how they work out:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å®ƒä»¬æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼š
- en: <alternating-egs-1> ::=
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: <alternating-egs-1> ::=
- en: '[PRE183]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Wait, whatâ€™s that? The two answers above are each correct, but the second answer
    does not help us in any way construct the first answer. That means the way weâ€™ve
    solved these problems until now is not enough for this new kind of problem. Itâ€™s
    still useful, though: notice that thereâ€™s a connection between the first example
    and the third, as well as between the second example and the fourth. This observation
    is consistent with our goal of selecting alternating elements.'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: ç­‰ç­‰ï¼Œé‚£æ˜¯ä»€ä¹ˆï¼Ÿä¸Šé¢çš„ä¸¤ä¸ªç­”æ¡ˆéƒ½æ˜¯æ­£ç¡®çš„ï¼Œä½†ç¬¬äºŒä¸ªç­”æ¡ˆå¹¶ä¸èƒ½å¸®åŠ©æˆ‘ä»¬æ„å»ºç¬¬ä¸€ä¸ªç­”æ¡ˆã€‚è¿™æ„å‘³ç€æˆ‘ä»¬åˆ°ç›®å‰ä¸ºæ­¢è§£å†³é—®é¢˜çš„æ–¹æ³•å¯¹äºè¿™ç§æ–°ç±»å‹çš„é—®é¢˜è¿˜ä¸å¤Ÿã€‚å°½ç®¡å¦‚æ­¤ï¼Œå®ƒä»ç„¶æ˜¯æœ‰ç”¨çš„ï¼šæ³¨æ„ç¬¬ä¸€ä¸ªä¾‹å­å’Œç¬¬ä¸‰ä¸ªä¾‹å­ä¹‹é—´ï¼Œä»¥åŠç¬¬äºŒä¸ªä¾‹å­å’Œç¬¬å››ä¸ªä¾‹å­ä¹‹é—´çš„è”ç³»ã€‚è¿™ä¸ªè§‚å¯Ÿä¸æˆ‘ä»¬çš„é€‰æ‹©äº¤æ›¿å…ƒç´ çš„ç›®æ ‡æ˜¯ä¸€è‡´çš„ã€‚
- en: 'What would something like this look like in code? Before we try to write the
    function, letâ€™s rewrite the first example in terms of the third:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ ·çš„ä»£ç ä¼šæ˜¯ä»€ä¹ˆæ ·å­ï¼Ÿåœ¨æˆ‘ä»¬å°è¯•ç¼–å†™å‡½æ•°ä¹‹å‰ï¼Œè®©æˆ‘ä»¬ç”¨ç¬¬ä¸‰ä¸ªä¾‹å­æ¥é‡å†™ç¬¬ä¸€ä¸ªä¾‹å­ï¼š
- en: '[PRE184]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Note that in the rewritten version, we are dropping two elements from the list
    before using `my-alternating` again, not just one. We will have to figure out
    how to handle that in our code.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨é‡å†™çš„ç‰ˆæœ¬ä¸­ï¼Œæˆ‘ä»¬åœ¨å†æ¬¡ä½¿ç”¨`my-alternating`ä¹‹å‰ä»åˆ—è¡¨ä¸­åˆ é™¤äº†ä¸¤ä¸ªå…ƒç´ ï¼Œè€Œä¸ä»…ä»…æ˜¯å…¶ä¸­ä¸€ä¸ªã€‚æˆ‘ä»¬å°†åœ¨ä»£ç ä¸­æ‰¾å‡ºå¦‚ä½•å¤„ç†è¿™ä¸€ç‚¹ã€‚
- en: 'Letâ€™s start with our usual function pattern with a `cases` expression:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ä»æˆ‘ä»¬å¸¸ç”¨çš„å¸¦æœ‰`cases`è¡¨è¾¾å¼çš„å‡½æ•°æ¨¡å¼å¼€å§‹ï¼š
- en: '[PRE185]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Note that we cannot simply call `my-alternating` on `r`, because `r` excludes
    only one item from the list, not two as this problem requires. We have to break
    down `r` as well, in order to get to the `rest` of the `rest` of the original
    list. To do this, we use another `cases` expression, nested within the first `cases`
    expression:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬ä¸èƒ½ç®€å•åœ°è°ƒç”¨`my-alternating`åœ¨`r`ä¸Šï¼Œå› ä¸º`r`åªæ’é™¤äº†åˆ—è¡¨ä¸­çš„ä¸€ä¸ªå…ƒç´ ï¼Œè€Œä¸æ˜¯è¿™ä¸ªé—®é¢˜çš„ä¸¤ä¸ªå…ƒç´ ã€‚æˆ‘ä»¬å¿…é¡»åˆ†è§£`r`ï¼Œä»¥ä¾¿åˆ°è¾¾åŸå§‹åˆ—è¡¨çš„`rest`çš„`rest`ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨å¦ä¸€ä¸ª`cases`è¡¨è¾¾å¼ï¼ŒåµŒå¥—åœ¨ç¬¬ä¸€ä¸ª`cases`è¡¨è¾¾å¼å†…éƒ¨ï¼š
- en: '[PRE186]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'This code is consistent with the example that we just worked out. But note
    that we still have a bit of unfinished work to do: we need to decide what to do
    in the `empty` case of the inner `cases` expression (marked by `???` in the code).'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µä»£ç ä¸æˆ‘ä»¬åˆšåˆšè§£å†³çš„é‚£ä¸ªä¾‹å­ä¸€è‡´ã€‚ä½†è¯·æ³¨æ„ï¼Œæˆ‘ä»¬è¿˜æœ‰ä¸€äº›æœªå®Œæˆçš„å·¥ä½œè¦åšï¼šæˆ‘ä»¬éœ€è¦å†³å®šåœ¨å†…éƒ¨`cases`è¡¨è¾¾å¼çš„`empty`æƒ…å†µä¸‹åº”è¯¥åšä»€ä¹ˆï¼ˆåœ¨ä»£ç ä¸­ç”¨`???`æ ‡è®°ï¼‰ã€‚
- en: A common temptation at this point is to replace the `???` with `[list:]`. After
    all, havenâ€™t we always returned `[list:]` in the `empty` cases?
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œä¸€ä¸ªå¸¸è§çš„è¯±æƒ‘æ˜¯å°†`???`æ›¿æ¢ä¸º`[list:]`ã€‚æ¯•ç«Ÿï¼Œæˆ‘ä»¬ä¸æ˜¯æ€»æ˜¯åœ¨`empty`æƒ…å†µä¸‹è¿”å›`[list:]`å—ï¼Ÿ
- en: Do Now!
  id: totrans-874
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-875
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Replace `???` with `[list:]` and test the program on our original examples:'
  id: totrans-876
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°†`???`æ›¿æ¢ä¸º`[list:]`å¹¶åœ¨æˆ‘ä»¬çš„åŸå§‹ä¾‹å­ä¸Šæµ‹è¯•ç¨‹åºï¼š
- en: ''
  id: totrans-877
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-878
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE187]'
- en: ''
  id: totrans-879
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you observe?
  id: totrans-880
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½ è§‚å¯Ÿåˆ°äº†ä»€ä¹ˆï¼Ÿ
- en: Oops! Weâ€™ve written a program that appears to work on lists with an even number
    of elements, but not on lists with an odd number of elements. How did that happen?
    The only part of this code that we guessed at was how to fill in the `empty` case
    of the inner `cases`, so the issue must be there. Rather than focus on the code,
    however, focus on the examples. We need a simple example that would land on that
    part of the code. We get to that spot when the list `l` is not empty, but `r`
    (the rest of `l`) is empty. In other words, we need an example with only one element.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: å“å‘€ï¼æˆ‘ä»¬ç¼–å†™äº†ä¸€ä¸ªä¼¼ä¹åªé€‚ç”¨äºå…ƒç´ æ•°é‡ä¸ºå¶æ•°çš„åˆ—è¡¨çš„ç¨‹åºï¼Œä½†ä¸é€‚ç”¨äºå…ƒç´ æ•°é‡ä¸ºå¥‡æ•°çš„åˆ—è¡¨ã€‚è¿™æ˜¯æ€ä¹ˆå‘ç”Ÿçš„ï¼Ÿæˆ‘ä»¬å”¯ä¸€çŒœæµ‹çš„éƒ¨åˆ†æ˜¯å¦‚ä½•å¡«å……å†…éƒ¨`cases`çš„`empty`æƒ…å†µï¼Œæ‰€ä»¥é—®é¢˜è‚¯å®šåœ¨é‚£é‡Œã€‚ç„¶è€Œï¼Œä¸å…¶å…³æ³¨ä»£ç ï¼Œä¸å¦‚å…³æ³¨ä¾‹å­ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œä»¥ä¾¿å®šä½åˆ°ä»£ç çš„è¿™éƒ¨åˆ†ã€‚å½“åˆ—è¡¨`l`ä¸ä¸ºç©ºï¼Œä½†`r`ï¼ˆ`l`çš„å…¶ä½™éƒ¨åˆ†ï¼‰ä¸ºç©ºæ—¶ï¼Œæˆ‘ä»¬å°±åˆ°è¾¾äº†é‚£ä¸ªä½ç½®ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåªæœ‰ä¸€ä¸ªå…ƒç´ çš„ä¾‹å­ã€‚
- en: Do Now!
  id: totrans-882
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-883
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Finish the following example:'
  id: totrans-884
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®Œæˆä»¥ä¸‹ä¾‹å­ï¼š
- en: ''
  id: totrans-885
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-886
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Given a list with one element, that element should be included in a list of
    alternating elements. Thus, we should finish this example as
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªåªæœ‰ä¸€ä¸ªå…ƒç´ çš„åˆ—è¡¨ï¼Œè¯¥å…ƒç´ åº”è¯¥åŒ…å«åœ¨äº¤æ›¿å…ƒç´ åˆ—è¡¨ä¸­ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥å®Œæˆè¿™ä¸ªä¾‹å­å¦‚ä¸‹ï¼š
- en: '[PRE189]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Do Now!
  id: totrans-889
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-890
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use this example to update the result of `my-alternating` when `r` is `empty`
    in our code.
  id: totrans-891
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸ªä¾‹å­æ¥æ›´æ–°æˆ‘ä»¬ä»£ç ä¸­`r`ä¸º`empty`æ—¶`my-alternating`çš„ç»“æœã€‚
- en: 'Leveraging this new example, the final version of `my-alternating` is as follows:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ©ç”¨è¿™ä¸ªæ–°ä¾‹å­ï¼Œ`my-alternating`çš„æœ€ç»ˆç‰ˆæœ¬å¦‚ä¸‹ï¼š
- en: '[PRE190]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Whatâ€™s the takeaway from this problem? There are two:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªé—®é¢˜çš„å¯ç¤ºæœ‰å“ªäº›ï¼Ÿæœ‰ä¸¤ä¸ªï¼š
- en: 'Donâ€™t skip the small examples: the result of a list-processing function on
    the `empty` case wonâ€™t always be `empty`.'
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸è¦å¿½ç•¥å°ä¾‹å­ï¼šåˆ—è¡¨å¤„ç†å‡½æ•°åœ¨`empty`æƒ…å†µä¸‹çš„ç»“æœä¸æ€»æ˜¯`empty`ã€‚
- en: If a problem asks you to work with multiple elements from the front of a list,
    you can nest `cases` expressions to access later elements.
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœä¸€ä¸ªé—®é¢˜è¦æ±‚ä½ å¤„ç†åˆ—è¡¨å‰é¢çš„å¤šä¸ªå…ƒç´ ï¼Œä½ å¯ä»¥åµŒå¥—`cases`è¡¨è¾¾å¼æ¥è®¿é—®åç»­å…ƒç´ ã€‚
- en: 'These takeaways will matter again in future examples: keep an eye out for them!'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›å¯ç¤ºåœ¨æœªæ¥ä¾‹å­ä¸­è¿˜ä¼šå†æ¬¡å‘æŒ¥ä½œç”¨ï¼šç•™æ„å®ƒä»¬ï¼
- en: 5.2.6Â Structural Problems Over Relaxed Domains[ğŸ”—](#(part._struct-prob-sub-dom)
    "Link to here")
  id: totrans-898
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.6 ç»“æ„åŒ–é—®é¢˜åœ¨æ”¾å®½åŸŸä¸Š[ğŸ”—](#(part._struct-prob-sub-dom) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: '5.2.6.1Â `my-max`: Examples[ğŸ”—](#(part._my-max) "Link to here")'
  id: totrans-899
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.6.1 `my-max`ï¼šä¾‹å­[ğŸ”—](#(part._my-max) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'Now letâ€™s find the maximum value of a list. Letâ€™s assume for simplicity that
    weâ€™re dealing with just lists of numbers. What kinds of lists should we construct?
    Clearly, we should have empty and non-empty listsâ€¦but what else? Is a list like
    `[list: 1, 2, 3]` a good example? Well, thereâ€™s nothing wrong with it, but we
    should also consider lists where the maximum is at the beginning rather than at
    the end; the maximum might be in the middle; the maximum might be repeated; the
    maximum might be negative; and so on. While not comprehensive, here is a small
    but interesting set of examples:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨æˆ‘ä»¬æ¥æ‰¾å‡ºåˆ—è¡¨ä¸­çš„æœ€å¤§å€¼ã€‚ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å‡è®¾æˆ‘ä»¬åªå¤„ç†æ•°å­—åˆ—è¡¨ã€‚æˆ‘ä»¬åº”è¯¥æ„å»ºå“ªäº›ç±»å‹çš„åˆ—è¡¨ï¼Ÿæ˜¾ç„¶ï¼Œæˆ‘ä»¬åº”è¯¥æœ‰ç©ºåˆ—è¡¨å’Œéç©ºåˆ—è¡¨â€¦â€¦ä½†æ˜¯è¿˜æœ‰ä»€ä¹ˆï¼Ÿåƒ`[list:
    1, 2, 3]`è¿™æ ·çš„åˆ—è¡¨æ˜¯ä¸€ä¸ªå¥½ä¾‹å­å—ï¼Ÿå—¯ï¼Œå®ƒæ²¡æœ‰é—®é¢˜ï¼Œä½†æˆ‘ä»¬è¿˜åº”è¯¥è€ƒè™‘æœ€å¤§å€¼åœ¨å¼€å¤´è€Œä¸æ˜¯ç»“å°¾çš„åˆ—è¡¨ï¼›æœ€å¤§å€¼å¯èƒ½åœ¨ä¸­é—´ï¼›æœ€å¤§å€¼å¯èƒ½é‡å¤ï¼›æœ€å¤§å€¼å¯èƒ½æ˜¯è´Ÿæ•°ï¼›ç­‰ç­‰ã€‚è™½ç„¶ä¸æ˜¯å…¨é¢çš„ï¼Œä½†è¿™é‡Œæœ‰ä¸€ç»„å°è€Œæœ‰è¶£çš„ä¾‹å­ï¼š'
- en: '[PRE191]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: What about `my-max(empty)`?
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆ`my-max(empty)`å‘¢ï¼Ÿ
- en: Do Now!
  id: totrans-903
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-904
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Could we define `my-max(empty)` to be `0`? Returning `0` for the empty list
    has worked well twice already!
  id: totrans-905
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬èƒ½å¦å®šä¹‰`my-max(empty)`ä¸º`0`ï¼Ÿå¯¹äºç©ºåˆ—è¡¨è¿”å›`0`å·²ç»æœ‰æ•ˆä¸¤æ¬¡äº†ï¼
- en: Weâ€™ll return to this in a while.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç¨åä¼šå›åˆ°è¿™ä¸ªé—®é¢˜ã€‚
- en: 'Before we proceed, itâ€™s useful to know that thereâ€™s a function called `num-max`
    already defined in Pyret, that compares two numbers:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬ç»§ç»­ä¹‹å‰ï¼Œäº†è§£Pyretä¸­å·²ç»å®šä¹‰äº†ä¸€ä¸ªåä¸º`num-max`çš„å‡½æ•°æ˜¯æœ‰ç”¨çš„ï¼Œè¯¥å‡½æ•°ç”¨äºæ¯”è¾ƒä¸¤ä¸ªæ•°å­—ï¼š
- en: '[PRE192]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Exercise
  id: totrans-909
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-910
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose `num-max` were not already built in. Can you define it? You will find
    what you learned about [Booleans](Conditionals_and_Booleans.html#%28part._booleans%29)
    handy. Remember to write some tests!
  id: totrans-911
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‡è®¾`num-max`å°šæœªå†…ç½®ã€‚ä½ èƒ½å®šä¹‰å®ƒå—ï¼Ÿä½ ä¼šå‘ç°ä½ å­¦åˆ°çš„å…³äº[å¸ƒå°”å€¼](Conditionals_and_Booleans.html#%28part._booleans%29)çš„çŸ¥è¯†å¾ˆæœ‰ç”¨ã€‚è®°å¾—å†™ä¸€äº›æµ‹è¯•ï¼
- en: 'Now we can look at `my-max` at work:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥çœ‹çœ‹`my-max`æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼š
- en: '[PRE193]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Hmm. That didnâ€™t really teach us anything, did it? Maybe, we canâ€™t be sure.
    And we still donâ€™t know what to do with `empty`.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: å—¯ã€‚è¿™å¹¶æ²¡æœ‰çœŸæ­£æ•™ä¼šæˆ‘ä»¬ä»€ä¹ˆï¼Œå¯¹å§ï¼Ÿä¹Ÿè®¸ï¼Œæˆ‘ä»¬æ— æ³•ç¡®å®šã€‚è€Œä¸”æˆ‘ä»¬ä»ç„¶ä¸çŸ¥é“å¦‚ä½•å¤„ç†`empty`ã€‚
- en: 'Letâ€™s try the second example input:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°è¯•ç¬¬äºŒä¸ªç¤ºä¾‹è¾“å…¥ï¼š
- en: '[PRE194]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'This is actually telling us something useful as well, but maybe we canâ€™t see
    it yet. Letâ€™s take on something more ambitious:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å®é™…ä¸Šä¹Ÿåœ¨å‘Šè¯‰æˆ‘ä»¬ä¸€äº›æœ‰ç”¨çš„ä¿¡æ¯ï¼Œä½†æˆ‘ä»¬å¯èƒ½è¿˜æ²¡æœ‰çœ‹åˆ°ã€‚è®©æˆ‘ä»¬æ‰¿æ‹…ä¸€ä¸ªæ›´æœ‰é›„å¿ƒçš„ä»»åŠ¡ï¼š
- en: '[PRE195]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Observe how the maximum of the rest of the list gives us a candidate answer,
    but comparing it to the first element gives us a definitive one:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿåˆ—è¡¨restçš„æœ€å¤§å€¼å¦‚ä½•ç»™æˆ‘ä»¬ä¸€ä¸ªå€™é€‰ç­”æ¡ˆï¼Œä½†ä¸ç¬¬ä¸€ä¸ªå…ƒç´ æ¯”è¾ƒåˆ™ç»™å‡ºäº†ä¸€ä¸ªç¡®å®šçš„ç­”æ¡ˆï¼š
- en: '[PRE196]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'The last one is a little awkward: weâ€™d like to write'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åä¸€ä¸ªæ˜¯æœ‰ç‚¹å°´å°¬ï¼šæˆ‘ä»¬å¸Œæœ›å†™
- en: '[PRE197]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: but we donâ€™t really know what the maximum (or minimum, or any other element)
    of the empty list is, but we can only provide numbers to `num-max`. Therefore,
    leaving out that dodgy case, weâ€™re left with
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æˆ‘ä»¬å®é™…ä¸Šå¹¶ä¸çŸ¥é“ç©ºåˆ—è¡¨çš„æœ€å¤§å€¼ï¼ˆæˆ–æœ€å°å€¼ï¼Œæˆ–ä»»ä½•å…¶ä»–å…ƒç´ ï¼‰æ˜¯ä»€ä¹ˆï¼Œä½†æˆ‘ä»¬åªèƒ½å‘`num-max`æä¾›æ•°å­—ã€‚å› æ­¤ï¼Œæ’é™¤äº†é‚£ä¸ªå¯ç–‘çš„æƒ…å†µï¼Œæˆ‘ä»¬åªå‰©ä¸‹
- en: '[PRE198]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Our examples have again helped: theyâ€™ve revealed how we can use the answer
    for each rest of the list to compute the answer for the whole list, which in turn
    is the rest of some other list, and so on. If you go back and look at the other
    example lists we wrote above, youâ€™ll see the pattern holds there too.'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ç¤ºä¾‹å†æ¬¡å¸®åˆ°äº†æˆ‘ä»¬ï¼šå®ƒä»¬æ­ç¤ºäº†æˆ‘ä»¬å¯ä»¥å¦‚ä½•ä½¿ç”¨æ¯ä¸ªreståˆ—è¡¨çš„ç­”æ¡ˆæ¥è®¡ç®—æ•´ä¸ªåˆ—è¡¨çš„ç­”æ¡ˆï¼Œè€Œè¿™ä¸ªç­”æ¡ˆåˆæ˜¯å¦ä¸€ä¸ªåˆ—è¡¨çš„restï¼Œä¾æ­¤ç±»æ¨ã€‚å¦‚æœä½ å›è¿‡å¤´å»çœ‹æˆ‘ä»¬ä¸Šé¢å†™çš„å…¶ä»–ç¤ºä¾‹åˆ—è¡¨ï¼Œä½ ä¹Ÿä¼šçœ‹åˆ°è¿™ä¸ªæ¨¡å¼ã€‚
- en: 'However, itâ€™s time we now confront the `empty` case. The real problem is that
    we donâ€™t have a maximum for the empty list: for any number we might provide, there
    is always a number bigger than it (assuming our computer is large enough) that
    could have been the answer instead. In short, itâ€™s nonsensical to ask for the
    maximum (or minimum) of the empty list: the concept of â€œmaximumâ€ is only defined
    on non-empty lists! That is, when asked for the maximum of an empty list, we should
    signal an error:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œç°åœ¨æ˜¯æ—¶å€™é¢å¯¹`empty`çš„æƒ…å†µäº†ã€‚çœŸæ­£çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬æ²¡æœ‰ç©ºåˆ—è¡¨çš„æœ€å¤§å€¼ï¼šå¯¹äºæˆ‘ä»¬å¯èƒ½æä¾›çš„ä»»ä½•æ•°å­—ï¼Œæ€»æœ‰ä¸€ä¸ªæ›´å¤§çš„æ•°å­—ï¼ˆå‡è®¾æˆ‘ä»¬çš„è®¡ç®—æœºè¶³å¤Ÿå¤§ï¼‰å¯èƒ½æ˜¯ç­”æ¡ˆã€‚ç®€è€Œè¨€ä¹‹ï¼Œè¯¢é—®ç©ºåˆ—è¡¨çš„æœ€å¤§å€¼ï¼ˆæˆ–æœ€å°å€¼ï¼‰æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼šæœ€å¤§å€¼çš„æ¦‚å¿µä»…åœ¨éç©ºåˆ—è¡¨ä¸Šå®šä¹‰ï¼ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“è¯¢é—®ç©ºåˆ—è¡¨çš„æœ€å¤§å€¼æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥å¼•å‘é”™è¯¯ï¼š
- en: '[PRE199]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: (which is how, in Pyret, we say that it will generate an error; we donâ€™t care
    about the details of the error, hence the empty string).
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆè¿™æ˜¯åœ¨Pyretä¸­æˆ‘ä»¬è¯´å®ƒä¼šç”Ÿæˆé”™è¯¯çš„æ–¹å¼ï¼›æˆ‘ä»¬ä¸åœ¨ä¹é”™è¯¯çš„ç»†èŠ‚ï¼Œå› æ­¤æ˜¯ç©ºå­—ç¬¦ä¸²ï¼‰ã€‚
- en: '5.2.6.2Â `my-max`: From Examples to Code[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)
    "Link to here")'
  id: totrans-929
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.6.2Â `my-max`ï¼šä»ç¤ºä¾‹åˆ°ä»£ç [ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Once again, we can codify the examples above, i.e., turn them into a uniform
    program that works for all instances. However, we now have a twist. If we blindly
    followed the pattern weâ€™ve used earlier, we would end up with:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸Šé¢çš„ä¾‹å­ç¼–ç åŒ–ï¼Œå³ï¼Œå°†å®ƒä»¬è½¬æ¢æˆä¸€ä¸ªé€‚ç”¨äºæ‰€æœ‰å®ä¾‹çš„ç»Ÿä¸€ç¨‹åºã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ç°åœ¨æœ‰ä¸€ä¸ªè½¬æŠ˜ã€‚å¦‚æœæˆ‘ä»¬ç›²ç›®åœ°éµå¾ªä¹‹å‰ä½¿ç”¨çš„æ¨¡å¼ï¼Œæˆ‘ä»¬æœ€ç»ˆä¼šå¾—åˆ°ï¼š
- en: '[PRE200]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: Do Now!
  id: totrans-932
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-933
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whatâ€™s wrong with this?
  id: totrans-934
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™æœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ
- en: 'Consider the list `[list: 2]`. This turns into'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 'è€ƒè™‘åˆ—è¡¨`[list: 2]`ã€‚è¿™å˜æˆäº†'
- en: '[PRE201]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: which of course raises an error. Therefore, this function never works for any
    list that has one or more elements!
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œè¿™ä¼šå¼•å‘é”™è¯¯ã€‚å› æ­¤ï¼Œè¿™ä¸ªå‡½æ•°å¯¹ä»»ä½•åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªå…ƒç´ çš„åˆ—è¡¨éƒ½ä¸ä¼šå·¥ä½œï¼
- en: 'Thatâ€™s because we need to make sure we arenâ€™t trying to compute the maximum
    of the empty list. Going back to our examples, we see that what we need to do,
    before calling `my-max`, is check whether the rest of the list is empty. If it
    is, we do not want to call `my-max` at all. That is:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å› ä¸ºæˆ‘ä»¬éœ€è¦ç¡®ä¿æˆ‘ä»¬ä¸æ˜¯åœ¨å°è¯•è®¡ç®—ç©ºåˆ—è¡¨çš„æœ€å¤§å€¼ã€‚å›åˆ°æˆ‘ä»¬çš„ä¾‹å­ï¼Œæˆ‘ä»¬çœ‹åˆ°åœ¨æˆ‘ä»¬è°ƒç”¨`my-max`ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥åˆ—è¡¨çš„å‰©ä½™éƒ¨åˆ†æ˜¯å¦ä¸ºç©ºã€‚å¦‚æœæ˜¯ï¼Œæˆ‘ä»¬æ ¹æœ¬ä¸æƒ³è°ƒç”¨`my-max`ã€‚é‚£å°±æ˜¯ï¼š
- en: '[PRE202]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Weâ€™ll return to what to do when the rest is not empty in a moment.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç¨åä¼šå›åˆ°å½“å‰©ä½™éƒ¨åˆ†ä¸ä¸ºç©ºæ—¶åº”è¯¥åšä»€ä¹ˆã€‚
- en: 'If the rest of the list `l` is empty, our examples above tell us that the maximum
    is the first element in the list. Therefore, we can fill this in:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœåˆ—è¡¨çš„å‰©ä½™éƒ¨åˆ†`l`ä¸ºç©ºï¼Œæˆ‘ä»¬ä¸Šé¢çš„ä¾‹å­å‘Šè¯‰æˆ‘ä»¬æœ€å¤§å€¼æ˜¯åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å¡«å†™è¿™ä¸ªç©ºç™½ï¼š
- en: '[PRE203]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Note in particular the absence of a call to `my-max`. If the list is not empty,
    however, our examples above tell us that `my-max` will give us the maximum of
    the rest of the list, and we just need to compare this answer with the first element
    (`f`):'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: ç‰¹åˆ«æ³¨æ„ï¼Œæ²¡æœ‰è°ƒç”¨`my-max`ã€‚ç„¶è€Œï¼Œå¦‚æœåˆ—è¡¨ä¸ä¸ºç©ºï¼Œæˆ‘ä»¬ä¸Šé¢çš„ä¾‹å­å‘Šè¯‰æˆ‘ä»¬`my-max`ä¼šç»™å‡ºåˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„æœ€å¤§å€¼ï¼Œæˆ‘ä»¬åªéœ€è¦å°†è¿™ä¸ªç­”æ¡ˆä¸ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ˆ`f`ï¼‰è¿›è¡Œæ¯”è¾ƒï¼š
- en: '[PRE204]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: And sure enough, this definition does the job!
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œè¿™ä¸ªå®šä¹‰ç¡®å®å®Œæˆäº†ä»»åŠ¡ï¼
- en: '5.2.6.1Â `my-max`: Examples[ğŸ”—](#(part._my-max) "Link to here")'
  id: totrans-946
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.6.1Â `my-max`: ç¤ºä¾‹[ğŸ”—](#(part._my-max) "é“¾æ¥åˆ°è¿™é‡Œ")'
- en: 'Now letâ€™s find the maximum value of a list. Letâ€™s assume for simplicity that
    weâ€™re dealing with just lists of numbers. What kinds of lists should we construct?
    Clearly, we should have empty and non-empty listsâ€¦but what else? Is a list like
    `[list: 1, 2, 3]` a good example? Well, thereâ€™s nothing wrong with it, but we
    should also consider lists where the maximum is at the beginning rather than at
    the end; the maximum might be in the middle; the maximum might be repeated; the
    maximum might be negative; and so on. While not comprehensive, here is a small
    but interesting set of examples:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨è®©æˆ‘ä»¬æ‰¾åˆ°åˆ—è¡¨çš„æœ€å¤§å€¼ã€‚ä¸ºäº†ç®€å•èµ·è§ï¼Œå‡è®¾æˆ‘ä»¬åªå¤„ç†æ•°å­—åˆ—è¡¨ã€‚æˆ‘ä»¬åº”è¯¥æ„å»ºä»€ä¹ˆæ ·çš„åˆ—è¡¨ï¼Ÿæ˜¾ç„¶ï¼Œæˆ‘ä»¬åº”è¯¥æœ‰ç©ºåˆ—è¡¨å’Œéç©ºåˆ—è¡¨â€¦â€¦ä½†æ˜¯è¿˜æœ‰ä»€ä¹ˆï¼Ÿåˆ—è¡¨`[list:
    1, 2, 3]`æ˜¯ä¸€ä¸ªå¥½ä¾‹å­å—ï¼Ÿå—¯ï¼Œå®ƒæ²¡æœ‰é—®é¢˜ï¼Œä½†æˆ‘ä»¬è¿˜åº”è¯¥è€ƒè™‘æœ€å¤§å€¼åœ¨å¼€å¤´è€Œä¸æ˜¯ç»“å°¾çš„åˆ—è¡¨ï¼›æœ€å¤§å€¼å¯èƒ½åœ¨ä¸­é—´ï¼›æœ€å¤§å€¼å¯èƒ½é‡å¤ï¼›æœ€å¤§å€¼å¯èƒ½æ˜¯è´Ÿæ•°ï¼›ç­‰ç­‰ã€‚è™½ç„¶ä¸æ˜¯å…¨é¢çš„ï¼Œä½†è¿™é‡Œæœ‰ä¸€ç»„å°è€Œæœ‰è¶£çš„ä¾‹å­ï¼š'
- en: '[PRE205]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: What about `my-max(empty)`?
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '`my-max(empty)`æ€ä¹ˆåŠï¼Ÿ'
- en: Do Now!
  id: totrans-950
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-951
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Could we define `my-max(empty)` to be `0`? Returning `0` for the empty list
    has worked well twice already!
  id: totrans-952
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬èƒ½å¦å®šä¹‰`my-max(empty)`ä¸º`0`ï¼Ÿå¯¹äºç©ºåˆ—è¡¨ï¼Œè¿”å›`0`å·²ç»æœ‰æ•ˆä¸¤æ¬¡äº†ï¼
- en: Weâ€™ll return to this in a while.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç¨åä¼šå›åˆ°è¿™ä¸ªé—®é¢˜ã€‚
- en: 'Before we proceed, itâ€™s useful to know that thereâ€™s a function called `num-max`
    already defined in Pyret, that compares two numbers:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬ç»§ç»­ä¹‹å‰ï¼Œäº†è§£Pyretä¸­å·²ç»å®šä¹‰äº†ä¸€ä¸ªåä¸º`num-max`çš„å‡½æ•°æ˜¯æœ‰ç”¨çš„ï¼Œè¯¥å‡½æ•°æ¯”è¾ƒä¸¤ä¸ªæ•°å­—ï¼š
- en: '[PRE206]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Exercise
  id: totrans-956
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-957
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose `num-max` were not already built in. Can you define it? You will find
    what you learned about [Booleans](Conditionals_and_Booleans.html#%28part._booleans%29)
    handy. Remember to write some tests!
  id: totrans-958
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å‡è®¾`num-max`è¿˜æ²¡æœ‰å†…ç½®ã€‚ä½ èƒ½å®šä¹‰å®ƒå—ï¼Ÿä½ ä¼šå‘ç°ä½ å­¦åˆ°çš„å…³äº[å¸ƒå°”å€¼](Conditionals_and_Booleans.html#%28part._booleans%29)çš„çŸ¥è¯†å¾ˆæœ‰ç”¨ã€‚è®°å¾—å†™ä¸€äº›æµ‹è¯•ï¼
- en: 'Now we can look at `my-max` at work:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹çœ‹`my-max`æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼š
- en: '[PRE207]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Hmm. That didnâ€™t really teach us anything, did it? Maybe, we canâ€™t be sure.
    And we still donâ€™t know what to do with `empty`.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: å—¯ã€‚è¿™å¹¶æ²¡æœ‰çœŸæ­£æ•™ä¼šæˆ‘ä»¬ä»€ä¹ˆï¼Œæ˜¯å—ï¼Ÿä¹Ÿè®¸ï¼Œæˆ‘ä»¬æ— æ³•ç¡®å®šã€‚è€Œä¸”æˆ‘ä»¬ä»ç„¶ä¸çŸ¥é“å¦‚ä½•å¤„ç†`empty`ã€‚
- en: 'Letâ€™s try the second example input:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°è¯•ç¬¬äºŒä¸ªç¤ºä¾‹è¾“å…¥ï¼š
- en: '[PRE208]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'This is actually telling us something useful as well, but maybe we canâ€™t see
    it yet. Letâ€™s take on something more ambitious:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å®é™…ä¸Šåœ¨å‘Šè¯‰æˆ‘ä»¬ä¸€äº›æœ‰ç”¨çš„ä¿¡æ¯ï¼Œä½†æˆ‘ä»¬å¯èƒ½ç°åœ¨è¿˜çœ‹ä¸åˆ°ã€‚è®©æˆ‘ä»¬æ‰¿æ‹…ä¸€ä¸ªæ›´æœ‰é›„å¿ƒçš„ä»»åŠ¡ï¼š
- en: '[PRE209]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Observe how the maximum of the rest of the list gives us a candidate answer,
    but comparing it to the first element gives us a definitive one:'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿåˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„æœ€å¤§å€¼å¦‚ä½•ç»™æˆ‘ä»¬ä¸€ä¸ªå€™é€‰ç­”æ¡ˆï¼Œä½†ä¸ç¬¬ä¸€ä¸ªå…ƒç´ æ¯”è¾ƒåˆ™ç»™å‡ºäº†ä¸€ä¸ªç¡®å®šçš„ç­”æ¡ˆï¼š
- en: '[PRE210]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'The last one is a little awkward: weâ€™d like to write'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åä¸€ä¸ªæ˜¯æœ‰ç‚¹å°´å°¬ï¼šæˆ‘ä»¬å¸Œæœ›å†™
- en: '[PRE211]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: but we donâ€™t really know what the maximum (or minimum, or any other element)
    of the empty list is, but we can only provide numbers to `num-max`. Therefore,
    leaving out that dodgy case, weâ€™re left with
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æˆ‘ä»¬å®é™…ä¸Šå¹¶ä¸çŸ¥é“ç©ºåˆ—è¡¨çš„æœ€å¤§å€¼ï¼ˆæˆ–æœ€å°å€¼ï¼Œæˆ–ä»»ä½•å…¶ä»–å…ƒç´ ï¼‰æ˜¯ä»€ä¹ˆï¼Œä½†æˆ‘ä»¬åªèƒ½å‘ `num-max` æä¾›æ•°å­—ã€‚å› æ­¤ï¼Œæ’é™¤äº†é‚£ä¸ªå¯ç–‘çš„æƒ…å†µï¼Œæˆ‘ä»¬åªå‰©ä¸‹
- en: '[PRE212]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Our examples have again helped: theyâ€™ve revealed how we can use the answer
    for each rest of the list to compute the answer for the whole list, which in turn
    is the rest of some other list, and so on. If you go back and look at the other
    example lists we wrote above, youâ€™ll see the pattern holds there too.'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ä¾‹å­å†æ¬¡å¸®åˆ°äº†æˆ‘ä»¬ï¼šå®ƒä»¬æ­ç¤ºäº†æˆ‘ä»¬å¯ä»¥å¦‚ä½•ä½¿ç”¨æ¯ä¸ªåˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„ç­”æ¡ˆæ¥è®¡ç®—æ•´ä¸ªåˆ—è¡¨çš„ç­”æ¡ˆï¼Œè€Œè¿™ä¸ªç­”æ¡ˆåˆæ˜¯æŸä¸ªå…¶ä»–åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†ï¼Œä¾æ­¤ç±»æ¨ã€‚å¦‚æœä½ å›é¡¾ä¸€ä¸‹æˆ‘ä»¬ä¸Šé¢å†™çš„å…¶ä»–ç¤ºä¾‹åˆ—è¡¨ï¼Œä½ ä¹Ÿä¼šçœ‹åˆ°è¿™ä¸ªæ¨¡å¼åœ¨é‚£é‡Œæˆç«‹ã€‚
- en: 'However, itâ€™s time we now confront the `empty` case. The real problem is that
    we donâ€™t have a maximum for the empty list: for any number we might provide, there
    is always a number bigger than it (assuming our computer is large enough) that
    could have been the answer instead. In short, itâ€™s nonsensical to ask for the
    maximum (or minimum) of the empty list: the concept of â€œmaximumâ€ is only defined
    on non-empty lists! That is, when asked for the maximum of an empty list, we should
    signal an error:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œç°åœ¨æ˜¯æ—¶å€™æˆ‘ä»¬é¢å¯¹ `empty` çš„æƒ…å†µäº†ã€‚çœŸæ­£çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬æ²¡æœ‰ç©ºåˆ—è¡¨çš„æœ€å¤§å€¼ï¼šå¯¹äºæˆ‘ä»¬å¯èƒ½æä¾›çš„ä»»ä½•æ•°å­—ï¼Œæ€»æœ‰ä¸€ä¸ªæ›´å¤§çš„æ•°å­—ï¼ˆå‡è®¾æˆ‘ä»¬çš„è®¡ç®—æœºè¶³å¤Ÿå¤§ï¼‰å¯èƒ½æ˜¯ç­”æ¡ˆã€‚ç®€è€Œè¨€ä¹‹ï¼Œè¯¢é—®ç©ºåˆ—è¡¨çš„æœ€å¤§å€¼ï¼ˆæˆ–æœ€å°å€¼ï¼‰æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼šæœ€å¤§å€¼çš„æ¦‚å¿µä»…åœ¨éç©ºåˆ—è¡¨ä¸Šå®šä¹‰ï¼ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“è¯¢é—®ç©ºåˆ—è¡¨çš„æœ€å¤§å€¼æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥å¼•å‘é”™è¯¯ï¼š
- en: '[PRE213]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: (which is how, in Pyret, we say that it will generate an error; we donâ€™t care
    about the details of the error, hence the empty string).
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆè¿™æ˜¯æˆ‘ä»¬å¦‚ä½•åœ¨ Pyret ä¸­è¡¨ç¤ºå®ƒå°†ç”Ÿæˆé”™è¯¯çš„æ–¹å¼ï¼›æˆ‘ä»¬ä¸åœ¨ä¹é”™è¯¯çš„ç»†èŠ‚ï¼Œå› æ­¤æ˜¯ç©ºå­—ç¬¦ä¸²ï¼‰ã€‚
- en: '5.2.6.2Â `my-max`: From Examples to Code[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)
    "Link to here")'
  id: totrans-976
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.6.2Â `my-max`: ä»ç¤ºä¾‹åˆ°ä»£ç [ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.From_.Examples_to_.Code)
    "é“¾æ¥è‡³æ­¤")'
- en: 'Once again, we can codify the examples above, i.e., turn them into a uniform
    program that works for all instances. However, we now have a twist. If we blindly
    followed the pattern weâ€™ve used earlier, we would end up with:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸Šé¢çš„ä¾‹å­ç¼–ç åŒ–ï¼Œå³ï¼Œå°†å®ƒä»¬è½¬æ¢æˆä¸€ä¸ªé€‚ç”¨äºæ‰€æœ‰å®ä¾‹çš„ç»Ÿä¸€ç¨‹åºã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ç°åœ¨æœ‰ä¸€ä¸ªè½¬æŠ˜ã€‚å¦‚æœæˆ‘ä»¬ç›²ç›®åœ°éµå¾ªæˆ‘ä»¬ä¹‹å‰ä½¿ç”¨çš„æ¨¡å¼ï¼Œæˆ‘ä»¬æœ€ç»ˆä¼šå¾—åˆ°ï¼š
- en: '[PRE214]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: Do Now!
  id: totrans-979
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-980
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whatâ€™s wrong with this?
  id: totrans-981
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™æœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ
- en: 'Consider the list `[list: 2]`. This turns into'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 'è€ƒè™‘åˆ—è¡¨ `[list: 2]`ã€‚è¿™å˜æˆäº†'
- en: '[PRE215]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: which of course raises an error. Therefore, this function never works for any
    list that has one or more elements!
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å½“ç„¶ä¼šå¼•å‘é”™è¯¯ã€‚å› æ­¤ï¼Œè¿™ä¸ªå‡½æ•°å¯¹äºä»»ä½•åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªå…ƒç´ çš„åˆ—è¡¨éƒ½ä¸ä¼šå·¥ä½œï¼
- en: 'Thatâ€™s because we need to make sure we arenâ€™t trying to compute the maximum
    of the empty list. Going back to our examples, we see that what we need to do,
    before calling `my-max`, is check whether the rest of the list is empty. If it
    is, we do not want to call `my-max` at all. That is:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å› ä¸ºæˆ‘ä»¬éœ€è¦ç¡®ä¿æˆ‘ä»¬ä¸æ˜¯åœ¨å°è¯•è®¡ç®—ç©ºåˆ—è¡¨çš„æœ€å¤§å€¼ã€‚å›åˆ°æˆ‘ä»¬çš„ä¾‹å­ï¼Œæˆ‘ä»¬çœ‹åˆ°åœ¨è°ƒç”¨ `my-max` ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æ˜¯å¦ä¸ºç©ºã€‚å¦‚æœæ˜¯ï¼Œæˆ‘ä»¬æ ¹æœ¬ä¸æƒ³è°ƒç”¨
    `my-max`ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼š
- en: '[PRE216]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Weâ€™ll return to what to do when the rest is not empty in a moment.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç¨åä¼šå›åˆ°å½“å…¶ä½™éƒ¨åˆ†ä¸ä¸ºç©ºæ—¶åº”è¯¥åšä»€ä¹ˆã€‚
- en: 'If the rest of the list `l` is empty, our examples above tell us that the maximum
    is the first element in the list. Therefore, we can fill this in:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœåˆ—è¡¨ `l` çš„å…¶ä½™éƒ¨åˆ†ä¸ºç©ºï¼Œæˆ‘ä»¬ä¸Šé¢çš„ä¾‹å­å‘Šè¯‰æˆ‘ä»¬æœ€å¤§å€¼æ˜¯åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å¡«å†™ï¼š
- en: '[PRE217]'
  id: totrans-989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'Note in particular the absence of a call to `my-max`. If the list is not empty,
    however, our examples above tell us that `my-max` will give us the maximum of
    the rest of the list, and we just need to compare this answer with the first element
    (`f`):'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: ç‰¹åˆ«æ³¨æ„æ²¡æœ‰è°ƒç”¨ `my-max`ã€‚ç„¶è€Œï¼Œå¦‚æœåˆ—è¡¨ä¸ä¸ºç©ºï¼Œæˆ‘ä»¬ä¸Šé¢çš„ä¾‹å­å‘Šè¯‰æˆ‘ä»¬ `my-max` å°†ç»™å‡ºåˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„æœ€å¤§å€¼ï¼Œæˆ‘ä»¬åªéœ€è¦å°†è¿™ä¸ªç­”æ¡ˆä¸ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ˆ`f`ï¼‰è¿›è¡Œæ¯”è¾ƒï¼š
- en: '[PRE218]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: And sure enough, this definition does the job!
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œè¿™ä¸ªå®šä¹‰ç¡®å®å®Œæˆäº†ä»»åŠ¡ï¼
- en: 5.2.7Â More Structural Problems with Scalar Answers[ğŸ”—](#(part._.More_.Structural_.Problems_with_.Scalar_.Answers)
    "Link to here")
  id: totrans-993
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.7Â æ ‡é‡ç­”æ¡ˆçš„æ›´å¤šç»“æ„é—®é¢˜[ğŸ”—](#(part._.More_.Structural_.Problems_with_.Scalar_.Answers)
    "é“¾æ¥è‡³æ­¤")
- en: '5.2.7.1Â `my-avg`: Examples[ğŸ”—](#(part._avg-eg) "Link to here")'
  id: totrans-994
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.7.1Â `my-avg`: ç¤ºä¾‹[ğŸ”—](#(part._avg-eg) "é“¾æ¥è‡³æ­¤")'
- en: 'Letâ€™s now try to compute the average of a list of numbers. Letâ€™s start with
    the example list `[list: 1, 2, 3, 4]` and work out more examples from it. The
    average of numbers in this list is clearly `(1 + 2 + 3 + 4)/4`, or `10/4`.'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨æˆ‘ä»¬å°è¯•è®¡ç®—ä¸€ä¸ªæ•°å­—åˆ—è¡¨çš„å¹³å‡å€¼ã€‚è®©æˆ‘ä»¬ä»ç¤ºä¾‹åˆ—è¡¨ `[list: 1, 2, 3, 4]` å¼€å§‹ï¼Œå¹¶ä»ä¸­æ¨å¯¼å‡ºæ›´å¤šç¤ºä¾‹ã€‚è¿™ä¸ªåˆ—è¡¨ä¸­æ•°å­—çš„å¹³å‡å€¼æ˜¾ç„¶æ˜¯
    `(1 + 2 + 3 + 4)/4`ï¼Œå³ `10/4`ã€‚'
- en: 'Based on the listâ€™s structure, we see that the rest of the list is `[list:
    2, 3, 4]`, and the rest of that is `[list: 3, 4]`, and so on. The resulting averages
    are:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ ¹æ®åˆ—è¡¨çš„ç»“æ„ï¼Œæˆ‘ä»¬çœ‹åˆ°åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æ˜¯ `[list: 2, 3, 4]`ï¼Œè€Œé‚£éƒ¨åˆ†ä¸­çš„å…¶ä½™éƒ¨åˆ†æ˜¯ `[list: 3, 4]`ï¼Œä¾æ­¤ç±»æ¨ã€‚å¾—åˆ°çš„ç»“æœå¹³å‡å€¼æ˜¯ï¼š'
- en: '[PRE219]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'The problem is, itâ€™s simply not clear how we get from the answer for the sub-list
    to the answer for the whole list. That is, given the following two bits of information:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜åœ¨äºï¼Œæˆ‘ä»¬å¦‚ä½•ä»å­åˆ—è¡¨çš„ç­”æ¡ˆå¾—åˆ°æ•´ä¸ªåˆ—è¡¨çš„ç­”æ¡ˆå¹¶ä¸æ¸…æ¥šã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œç»™å®šä»¥ä¸‹ä¸¤æ¡ä¿¡æ¯ï¼š
- en: The average of the remainder of the list is `9/3`, i.e., `3`.
  id: totrans-999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„å¹³å‡å€¼ä¸º `9/3`ï¼Œå³ `3`ã€‚
- en: The first number in the list is `1`.
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªæ•°å­—æ˜¯ `1`ã€‚
- en: 'How do we determine that the average of the whole list must be `10/4`? If itâ€™s
    not clear to you, donâ€™t worry: with just those two pieces of information, itâ€™s
    impossible!'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½•ç¡®å®šæ•´ä¸ªåˆ—è¡¨çš„å¹³å‡å€¼å¿…é¡»æ˜¯ `10/4`ï¼Ÿå¦‚æœæ‚¨ä¸æ¸…æ¥šï¼Œè¯·ä¸è¦æ‹…å¿ƒï¼šä»…å‡­è¿™ä¸¤æ¡ä¿¡æ¯ï¼Œè¿™æ˜¯ä¸å¯èƒ½çš„ï¼
- en: 'Hereâ€™s a simpler example that explains why. Letâ€™s suppose the first value in
    a list is `1`, and the average of the rest of the list is `2`. Here are two very
    different lists that fit this description:'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªæ›´ç®€å•çš„ä¾‹å­æ¥è¯´æ˜åŸå› ã€‚å‡è®¾åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå€¼æ˜¯ `1`ï¼Œè€Œåˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„å¹³å‡å€¼æ˜¯ `2`ã€‚è¿™é‡Œæœ‰ä¸¤ç»„éå¸¸ä¸åŒçš„åˆ—è¡¨ç¬¦åˆè¿™ä¸ªæè¿°ï¼š
- en: '[PRE220]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: The average of the entire first list is `3/2`, while the average of the entire
    second list is `5/3`, and the two are not the same.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: æ•´ä¸ªç¬¬ä¸€ä¸ªåˆ—è¡¨çš„å¹³å‡å€¼æ˜¯ `3/2`ï¼Œè€Œæ•´ä¸ªç¬¬äºŒä¸ªåˆ—è¡¨çš„å¹³å‡å€¼æ˜¯ `5/3`ï¼Œè¿™ä¸¤ä¸ªå€¼å¹¶ä¸ç›¸åŒã€‚
- en: That is, to compute the average of a whole list, itâ€™s not even useful to know
    the average of the rest of the list. Rather, we need to know the sum and the length
    of the rest of the list. With these two, we can add the first to the sum, and
    `1` to the length, and compute the new average.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸ºäº†è®¡ç®—æ•´ä¸ªåˆ—è¡¨çš„å¹³å‡å€¼ï¼Œç”šè‡³çŸ¥é“åˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„å¹³å‡å€¼éƒ½æ²¡æœ‰ç”¨ã€‚ç›¸åï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“åˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„å’Œå’Œé•¿åº¦ã€‚æœ‰äº†è¿™ä¸¤ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥å°†ç¬¬ä¸€ä¸ªæ•°åŠ åˆ°æ€»å’Œä¸Šï¼Œå¹¶å°†
    `1` åŠ åˆ°é•¿åº¦ä¸Šï¼Œç„¶åè®¡ç®—æ–°çš„å¹³å‡å€¼ã€‚
- en: 'In principle, we could try to make a `average` function that returns all this
    information. Instead, it will be a lot simpler to simply decompose the task into
    two smaller tasks. After all, we have already seen how to compute the length and
    how to compute the sum. The average, therefore, can just use these existing functions:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åŸåˆ™ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å°è¯•åˆ›å»ºä¸€ä¸ªè¿”å›æ‰€æœ‰è¿™äº›ä¿¡æ¯çš„ `average` å‡½æ•°ã€‚ç›¸åï¼Œå°†ä»»åŠ¡åˆ†è§£æˆä¸¤ä¸ªæ›´å°çš„ä»»åŠ¡å°†ç®€å•å¾—å¤šã€‚æ¯•ç«Ÿï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°å¦‚ä½•è®¡ç®—é•¿åº¦å’Œå¦‚ä½•è®¡ç®—æ€»å’Œã€‚å› æ­¤ï¼Œå¹³å‡æ•°åªéœ€ä½¿ç”¨è¿™äº›ç°æœ‰çš„å‡½æ•°ï¼š
- en: '[PRE221]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Do Now!
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹åˆ»è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What should be the average of the empty list? Does the above code produce what
    you would expect?
  id: totrans-1010
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç©ºåˆ—è¡¨çš„å¹³å‡å€¼åº”è¯¥æ˜¯å¤šå°‘ï¼Ÿä¸Šè¿°ä»£ç äº§ç”Ÿçš„æ˜¯æ‚¨é¢„æœŸçš„ç»“æœå—ï¼Ÿ
- en: 'Just as we argued earlier about the maximum [[Structural Problems Over Relaxed
    Domains](#%28part._struct-prob-sub-dom%29)], the average of the empty list isnâ€™t
    a well-defined concept. Therefore, it would be appropriate to signal an error.
    The implementation above does this, but poorly: it reports an error on division.
    A better programming practice would be to catch this situation and report the
    error right away, rather than hoping some other function will report the error.'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬ä¹‹å‰å…³äºæœ€å¤§å€¼ [[ç»“æ„åŒ–é—®é¢˜åœ¨æ”¾å®½åŸŸä¸Šçš„é—®é¢˜](#%28part._struct-prob-sub-dom%29)] æ‰€è®¨è®ºçš„é‚£æ ·ï¼Œç©ºåˆ—è¡¨çš„å¹³å‡å€¼ä¸æ˜¯ä¸€ä¸ªå®šä¹‰è‰¯å¥½çš„æ¦‚å¿µã€‚å› æ­¤ï¼Œå‘å‡ºé”™è¯¯ä¿¡å·æ˜¯åˆé€‚çš„ã€‚ä¸Šè¿°å®ç°å°±æ˜¯è¿™æ ·åšçš„ï¼Œä½†åšå¾—ä¸å¥½ï¼šå®ƒåœ¨é™¤æ³•æ—¶æŠ¥å‘Šé”™è¯¯ã€‚æ›´å¥½çš„ç¼–ç¨‹å®è·µæ˜¯ç«‹å³æ•è·è¿™ç§æƒ…å†µå¹¶æŠ¥å‘Šé”™è¯¯ï¼Œè€Œä¸æ˜¯å¸Œæœ›å…¶ä»–å‡½æ•°ä¼šæŠ¥å‘Šé”™è¯¯ã€‚
- en: Exercise
  id: totrans-1012
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-1013
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alter `my-avg` above to signal an error when given the empty list.
  id: totrans-1014
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¿®æ”¹ `my-avg` ä»¥åœ¨ç»™å®šç©ºåˆ—è¡¨æ—¶å‘å‡ºé”™è¯¯ä¿¡å·ã€‚
- en: 'Therefore, we see that the process weâ€™ve usedâ€”<wbr>of inferring code from examplesâ€”<wbr>wonâ€™t
    always suffice, and weâ€™ll need more sophisticated techniques to solve some problems.
    However, notice that working from examples helps us quickly identify situations
    where this approach does and doesnâ€™t work. Furthermore, if you look more closely
    youâ€™ll notice that the examples above do hint at how to solve the problem: in
    our very first examples, we wrote answers like `10/4`, `9/3`, and `7/2`, which
    correspond to the sum of the numbers divided by the length. Thus, writing the
    answers in this form (as opposed, for instance, to writing the second of those
    as `3`) already reveals a structure for a solution.'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬çœ‹åˆ°æˆ‘ä»¬ä½¿ç”¨çš„æµç¨‹â€”â€”ä»ç¤ºä¾‹ä¸­æ¨æ–­ä»£ç â€”â€”å¹¶ä¸æ€»æ˜¯è¶³å¤Ÿï¼Œæˆ‘ä»¬éœ€è¦æ›´å¤æ‚çš„æŠ€å·§æ¥è§£å†³æŸäº›é—®é¢˜ã€‚ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œä»ç¤ºä¾‹å¼€å§‹å¯ä»¥å¸®åŠ©æˆ‘ä»¬å¿«é€Ÿè¯†åˆ«è¿™ç§æ–¹æ³•ä½•æ—¶æœ‰æ•ˆæˆ–æ— æ•ˆçš„æƒ…å†µã€‚æ­¤å¤–ï¼Œå¦‚æœæ‚¨æ›´ä»”ç»†åœ°è§‚å¯Ÿï¼Œæ‚¨ä¼šæ³¨æ„åˆ°ä¸Šè¿°ç¤ºä¾‹ç¡®å®æš—ç¤ºäº†å¦‚ä½•è§£å†³é—®é¢˜ï¼šåœ¨æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬å†™å‡ºäº†åƒ
    `10/4`ã€`9/3` å’Œ `7/2` è¿™æ ·çš„ç­”æ¡ˆï¼Œè¿™äº›ç­”æ¡ˆå¯¹åº”äºæ•°å­—çš„æ€»å’Œé™¤ä»¥é•¿åº¦ã€‚å› æ­¤ï¼Œä»¥è¿™ç§å½¢å¼ï¼ˆä¾‹å¦‚ï¼Œä¸å°†ç¬¬äºŒä¸ªç­”æ¡ˆå†™æˆ `3` ç›¸æ¯”ï¼‰å†™å‡ºç­”æ¡ˆå·²ç»æ­ç¤ºäº†è§£å†³æ–¹æ¡ˆçš„ç»“æ„ã€‚
- en: '5.2.7.1Â `my-avg`: Examples[ğŸ”—](#(part._avg-eg) "Link to here")'
  id: totrans-1016
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.7.1Â `my-avg`: ç¤ºä¾‹[ğŸ”—](#(part._avg-eg) "é“¾æ¥åˆ°æ­¤å¤„")'
- en: 'Letâ€™s now try to compute the average of a list of numbers. Letâ€™s start with
    the example list `[list: 1, 2, 3, 4]` and work out more examples from it. The
    average of numbers in this list is clearly `(1 + 2 + 3 + 4)/4`, or `10/4`.'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç°åœ¨æˆ‘ä»¬å°è¯•è®¡ç®—ä¸€ä¸ªæ•°å­—åˆ—è¡¨çš„å¹³å‡å€¼ã€‚è®©æˆ‘ä»¬ä»ä¸€ä¸ªä¾‹å­åˆ—è¡¨`[list: 1, 2, 3, 4]`å¼€å§‹ï¼Œå¹¶ä»ä¸­æ¨å¯¼å‡ºæ›´å¤šä¾‹å­ã€‚è¿™ä¸ªåˆ—è¡¨ä¸­æ•°å­—çš„å¹³å‡å€¼æ˜¾ç„¶æ˜¯`(1
    + 2 + 3 + 4)/4`ï¼Œå³`10/4`ã€‚'
- en: 'Based on the listâ€™s structure, we see that the rest of the list is `[list:
    2, 3, 4]`, and the rest of that is `[list: 3, 4]`, and so on. The resulting averages
    are:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 'æ ¹æ®åˆ—è¡¨çš„ç»“æ„ï¼Œæˆ‘ä»¬çœ‹åˆ°åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æ˜¯`[list: 2, 3, 4]`ï¼Œç„¶åæ˜¯`[list: 3, 4]`ï¼Œä¾æ­¤ç±»æ¨ã€‚å¾—åˆ°çš„å¹³å‡å€¼å¦‚ä¸‹ï¼š'
- en: '[PRE222]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'The problem is, itâ€™s simply not clear how we get from the answer for the sub-list
    to the answer for the whole list. That is, given the following two bits of information:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜åœ¨äºï¼Œæˆ‘ä»¬å¹¶ä¸æ¸…æ¥šå¦‚ä½•ä»å­åˆ—è¡¨çš„ç­”æ¡ˆè¿‡æ¸¡åˆ°æ•´ä¸ªåˆ—è¡¨çš„ç­”æ¡ˆã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œç»™å®šä»¥ä¸‹ä¸¤ä¸ªä¿¡æ¯ç‚¹ï¼š
- en: The average of the remainder of the list is `9/3`, i.e., `3`.
  id: totrans-1021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„å¹³å‡å€¼æ˜¯`9/3`ï¼Œå³`3`ã€‚
- en: The first number in the list is `1`.
  id: totrans-1022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªæ•°å­—æ˜¯`1`ã€‚
- en: 'How do we determine that the average of the whole list must be `10/4`? If itâ€™s
    not clear to you, donâ€™t worry: with just those two pieces of information, itâ€™s
    impossible!'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•ç¡®å®šæ•´ä¸ªåˆ—è¡¨çš„å¹³å‡å€¼å¿…é¡»æ˜¯`10/4`ï¼Ÿå¦‚æœä½ è§‰å¾—ä¸æ¸…æ¥šï¼Œä¸è¦æ‹…å¿ƒï¼šåªæœ‰è¿™ä¸¤æ¡ä¿¡æ¯ï¼Œè¿™æ˜¯ä¸å¯èƒ½çš„ï¼
- en: 'Hereâ€™s a simpler example that explains why. Letâ€™s suppose the first value in
    a list is `1`, and the average of the rest of the list is `2`. Here are two very
    different lists that fit this description:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæœ‰ä¸€ä¸ªæ›´ç®€å•çš„ä¾‹å­æ¥è§£é‡Šè¿™ä¸€ç‚¹ã€‚å‡è®¾åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå€¼æ˜¯`1`ï¼Œå…¶ä½™åˆ—è¡¨çš„å¹³å‡å€¼æ˜¯`2`ã€‚è¿™é‡Œæœ‰ä¸¤ç»„éå¸¸ä¸åŒçš„åˆ—è¡¨ç¬¦åˆè¿™ä¸ªæè¿°ï¼š
- en: '[PRE223]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: The average of the entire first list is `3/2`, while the average of the entire
    second list is `5/3`, and the two are not the same.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: æ•´ä¸ªç¬¬ä¸€ä¸ªåˆ—è¡¨çš„å¹³å‡å€¼æ˜¯`3/2`ï¼Œè€Œæ•´ä¸ªç¬¬äºŒä¸ªåˆ—è¡¨çš„å¹³å‡å€¼æ˜¯`5/3`ï¼Œè¿™ä¸¤ä¸ªå€¼å¹¶ä¸ç›¸åŒã€‚
- en: That is, to compute the average of a whole list, itâ€™s not even useful to know
    the average of the rest of the list. Rather, we need to know the sum and the length
    of the rest of the list. With these two, we can add the first to the sum, and
    `1` to the length, and compute the new average.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸ºäº†è®¡ç®—æ•´ä¸ªåˆ—è¡¨çš„å¹³å‡å€¼ï¼Œç”šè‡³æ²¡æœ‰å¿…è¦çŸ¥é“å…¶ä½™åˆ—è¡¨çš„å¹³å‡å€¼ã€‚ç›¸åï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å…¶ä½™åˆ—è¡¨çš„æ€»å’Œå’Œé•¿åº¦ã€‚æœ‰äº†è¿™ä¸¤ä¸ªå€¼ï¼Œæˆ‘ä»¬å¯ä»¥å°†ç¬¬ä¸€ä¸ªå€¼åŠ åˆ°æ€»å’Œä¸Šï¼Œå¹¶å°†`1`åŠ åˆ°é•¿åº¦ä¸Šï¼Œç„¶åè®¡ç®—æ–°çš„å¹³å‡å€¼ã€‚
- en: 'In principle, we could try to make a `average` function that returns all this
    information. Instead, it will be a lot simpler to simply decompose the task into
    two smaller tasks. After all, we have already seen how to compute the length and
    how to compute the sum. The average, therefore, can just use these existing functions:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: ä»åŸåˆ™ä¸Šè®²ï¼Œæˆ‘ä»¬å¯ä»¥å°è¯•ç¼–å†™ä¸€ä¸ªè¿”å›æ‰€æœ‰è¿™äº›ä¿¡æ¯çš„`average`å‡½æ•°ã€‚ç„¶è€Œï¼Œå°†ä»»åŠ¡åˆ†è§£æˆä¸¤ä¸ªæ›´å°çš„ä»»åŠ¡ä¼šç®€å•å¾—å¤šã€‚æ¯•ç«Ÿï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°å¦‚ä½•è®¡ç®—é•¿åº¦å’Œå¦‚ä½•è®¡ç®—æ€»å’Œã€‚å› æ­¤ï¼Œå¹³å‡å€¼å¯ä»¥ç›´æ¥ä½¿ç”¨è¿™äº›ç°æœ‰å‡½æ•°ï¼š
- en: '[PRE224]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Do Now!
  id: totrans-1030
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-1031
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What should be the average of the empty list? Does the above code produce what
    you would expect?
  id: totrans-1032
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç©ºåˆ—è¡¨çš„å¹³å‡å€¼åº”è¯¥æ˜¯å¤šå°‘ï¼Ÿä¸Šé¢çš„ä»£ç æ˜¯å¦äº§ç”Ÿäº†ä½ é¢„æœŸçš„ç»“æœï¼Ÿ
- en: 'Just as we argued earlier about the maximum [[Structural Problems Over Relaxed
    Domains](#%28part._struct-prob-sub-dom%29)], the average of the empty list isnâ€™t
    a well-defined concept. Therefore, it would be appropriate to signal an error.
    The implementation above does this, but poorly: it reports an error on division.
    A better programming practice would be to catch this situation and report the
    error right away, rather than hoping some other function will report the error.'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬ä¹‹å‰å…³äºæ”¾æ¾åŸŸç»“æ„é—®é¢˜[[ç»“æ„é—®é¢˜åœ¨æ”¾æ¾åŸŸ](#(part._struct-prob-sub-dom))]çš„è®ºè¯ä¸€æ ·ï¼Œç©ºåˆ—è¡¨çš„å¹³å‡å€¼ä¸æ˜¯ä¸€ä¸ªå®šä¹‰è‰¯å¥½çš„æ¦‚å¿µã€‚å› æ­¤ï¼Œå‘å‡ºé”™è¯¯ä¿¡å·æ˜¯åˆé€‚çš„ã€‚ä¸Šé¢çš„å®ç°å°±æ˜¯è¿™æ ·åšçš„ï¼Œä½†åšå¾—ä¸å¥½ï¼šå®ƒåœ¨é™¤æ³•æ—¶æŠ¥å‘Šé”™è¯¯ã€‚æ›´å¥½çš„ç¼–ç¨‹å®è·µæ˜¯æ•è·è¿™ç§æƒ…å†µå¹¶ç«‹å³æŠ¥å‘Šé”™è¯¯ï¼Œè€Œä¸æ˜¯å¸Œæœ›å…¶ä»–å‡½æ•°ä¼šæŠ¥å‘Šé”™è¯¯ã€‚
- en: Exercise
  id: totrans-1034
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-1035
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alter `my-avg` above to signal an error when given the empty list.
  id: totrans-1036
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å°†`my-avg`ä¸Šé¢çš„ä»£ç ä¿®æ”¹ä¸ºåœ¨ç»™å®šç©ºåˆ—è¡¨æ—¶å‘å‡ºé”™è¯¯ä¿¡å·ã€‚
- en: 'Therefore, we see that the process weâ€™ve usedâ€”<wbr>of inferring code from examplesâ€”<wbr>wonâ€™t
    always suffice, and weâ€™ll need more sophisticated techniques to solve some problems.
    However, notice that working from examples helps us quickly identify situations
    where this approach does and doesnâ€™t work. Furthermore, if you look more closely
    youâ€™ll notice that the examples above do hint at how to solve the problem: in
    our very first examples, we wrote answers like `10/4`, `9/3`, and `7/2`, which
    correspond to the sum of the numbers divided by the length. Thus, writing the
    answers in this form (as opposed, for instance, to writing the second of those
    as `3`) already reveals a structure for a solution.'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬çœ‹åˆ°æˆ‘ä»¬ä½¿ç”¨çš„ä»ä¾‹å­ä¸­æ¨æ–­ä»£ç çš„è¿‡ç¨‹â€”â€”å¹¶ä¸æ€»æ˜¯è¶³å¤Ÿï¼Œæˆ‘ä»¬éœ€è¦æ›´å¤æ‚çš„æŠ€å·§æ¥è§£å†³ä¸€äº›é—®é¢˜ã€‚ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œä»ä¾‹å­å¼€å§‹å·¥ä½œæœ‰åŠ©äºæˆ‘ä»¬å¿«é€Ÿè¯†åˆ«è¿™ç§æ–¹æ³•ä½•æ—¶æœ‰æ•ˆï¼Œä½•æ—¶æ— æ•ˆã€‚æ­¤å¤–ï¼Œå¦‚æœä½ æ›´ä»”ç»†åœ°è§‚å¯Ÿï¼Œä½ ä¼šå‘ç°ä¸Šé¢çš„ä¾‹å­ç¡®å®æš—ç¤ºäº†å¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜ï¼šåœ¨æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å†™å‡ºäº†åƒ`10/4`ã€`9/3`å’Œ`7/2`è¿™æ ·çš„ç­”æ¡ˆï¼Œè¿™äº›ç­”æ¡ˆå¯¹åº”äºæ•°å­—çš„æ€»å’Œé™¤ä»¥é•¿åº¦ã€‚å› æ­¤ï¼Œä»¥è¿™ç§å½¢å¼ï¼ˆä¾‹å¦‚ï¼Œä¸å°†ç¬¬äºŒä¸ªç­”æ¡ˆå†™æˆ`3`ç›¸æ¯”ï¼‰å†™å‡ºç­”æ¡ˆå·²ç»æ­ç¤ºäº†è§£å†³æ–¹æ¡ˆçš„ç»“æ„ã€‚
- en: 5.2.8Â Structural Problems with Accumulators[ğŸ”—](#(part._accumulators) "Link to
    here")
  id: totrans-1038
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.8 ç»“æ„æ€§é—®é¢˜[ğŸ”—](#(part._accumulators) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: '5.2.8.1Â `my-running-sum`: First Attempt[ğŸ”—](#(part._running-sum-1st-attempt)
    "Link to here")'
  id: totrans-1039
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.8.1 `my-running-sum`: ç¬¬ä¸€æ¬¡å°è¯•[ğŸ”—](#(part._running-sum-1st-attempt) "é“¾æ¥åˆ°è¿™é‡Œ")'
- en: One more time, weâ€™ll begin with an example.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¥ä¸€æ¬¡ï¼Œæˆ‘ä»¬ä»ä¾‹å­å¼€å§‹ã€‚
- en: Do Now!
  id: totrans-1041
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-1042
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Work out the results for `my-running-sum` starting from the list `[list: 1,
    2, 3, 4, 5]`.'
  id: totrans-1043
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'ä»åˆ—è¡¨`[list: 1, 2, 3, 4, 5]`å¼€å§‹è®¡ç®—`my-running-sum`çš„ç»“æœã€‚'
- en: 'Hereâ€™s what our first few examples look like:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æˆ‘ä»¬å‰å‡ ä¸ªä¾‹å­çœ‹èµ·æ¥åƒçš„ï¼š
- en: <running-sum-egs-1> ::=
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: <running-sum-egs-1> ::=
- en: '[PRE225]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Again, there doesnâ€™t appear to be any clear connection between the result on
    the rest of the list and the result on the entire list.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡ï¼Œä¼¼ä¹æ²¡æœ‰æ˜æ˜¾çš„è”ç³»ï¼Œå³åˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„ç­”æ¡ˆä¸æ•´ä¸ªåˆ—è¡¨çš„ç­”æ¡ˆä¹‹é—´çš„è”ç³»ã€‚
- en: '(That isnâ€™t strictly true: we can still line up the answers as follows:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆè¿™å¹¶ä¸å®Œå…¨æ­£ç¡®ï¼šæˆ‘ä»¬ä»ç„¶å¯ä»¥åƒä¸‹é¢è¿™æ ·æ’åˆ—ç­”æ¡ˆï¼š
- en: '[PRE226]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: and observe that weâ€™re computing the answer for the rest of the list, then adding
    the first element to each element in the answer, and `link`ing the first element
    to the front. In principle, we can compute this solution directly, but for now
    that may be more work than finding a simpler way to answer it.)
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿåˆ°æˆ‘ä»¬åœ¨è®¡ç®—åˆ—è¡¨å‰©ä½™éƒ¨åˆ†çš„ç­”æ¡ˆåï¼Œå°†ç¬¬ä¸€ä¸ªå…ƒç´ æ·»åŠ åˆ°æ¯ä¸ªç­”æ¡ˆå…ƒç´ ä¸­ï¼Œå¹¶å°†ç¬¬ä¸€ä¸ªå…ƒç´ `link`åˆ°å‰é¢ã€‚åŸåˆ™ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è®¡ç®—è¿™ä¸ªè§£å†³æ–¹æ¡ˆï¼Œä½†å°±ç›®å‰è€Œè¨€ï¼Œè¿™å¯èƒ½æ¯”æ‰¾åˆ°æ›´ç®€å•çš„æ–¹æ³•æ¥å›ç­”å®ƒè¦å¤æ‚å¾—å¤šã€‚ï¼‰
- en: '5.2.8.2Â `my-running-sum`: Examples and Code[ğŸ”—](#(part._running-sum-eg-code)
    "Link to here")'
  id: totrans-1051
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.8.2 `my-running-sum`: ç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._running-sum-eg-code) "é“¾æ¥åˆ°è¿™é‡Œ")'
- en: 'Recall how we began in [`my-running-sum`: First Attempt](#%28part._running-sum-1st-attempt%29).
    Our examples [[<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)] showed the
    following problem. When we process the rest of the list, we have forgotten everything
    about what preceded it. That is, when processing the list starting at `2` we forget
    that weâ€™ve seen a `1` earlier; when starting from `3`, we forget that weâ€™ve seen
    both `1` and `2` earlier; and so on. In other words, we keep forgetting the past.
    We need some way of avoiding that.'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 'å›æƒ³ä¸€ä¸‹æˆ‘ä»¬åœ¨[`my-running-sum`: ç¬¬ä¸€æ¬¡å°è¯•](#%28part._running-sum-1st-attempt%29)ä¸­çš„å¼€å§‹ã€‚æˆ‘ä»¬çš„ä¾‹å­[[<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)]å±•ç¤ºäº†ä»¥ä¸‹é—®é¢˜ã€‚å½“æˆ‘ä»¬å¤„ç†åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æ—¶ï¼Œæˆ‘ä»¬å·²ç»å¿˜è®°äº†ä¹‹å‰çš„ä¸€åˆ‡ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“æˆ‘ä»¬ä»`2`å¼€å§‹å¤„ç†åˆ—è¡¨æ—¶ï¼Œæˆ‘ä»¬å¿˜è®°äº†ä¹‹å‰å·²ç»çœ‹åˆ°äº†ä¸€ä¸ª`1`ï¼›å½“æˆ‘ä»¬ä»`3`å¼€å§‹æ—¶ï¼Œæˆ‘ä»¬å¿˜è®°äº†ä¹‹å‰å·²ç»çœ‹åˆ°äº†`1`å’Œ`2`ï¼›ä»¥æ­¤ç±»æ¨ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬ä¸€ç›´åœ¨å¿˜è®°è¿‡å»ã€‚æˆ‘ä»¬éœ€è¦ä¸€ç§é¿å…è¿™ç§æƒ…å†µçš„æ–¹æ³•ã€‚'
- en: The easiest thing we can do is simply change our function to carry along this
    â€œmemoryâ€, or what weâ€™ll call an accumulator. That is, imagine we were defining
    a new function, called `my-rs`. It will consume a list of numbers and produce
    a list of numbers, but in addition it will also take the sum of numbers preceding
    the current list.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬èƒ½åšçš„æœ€ç®€å•çš„äº‹æƒ…å°±æ˜¯å°†æˆ‘ä»¬çš„å‡½æ•°æ”¹ä¸ºæºå¸¦è¿™ç§â€œè®°å¿†â€ï¼Œæˆ–è€…æˆ‘ä»¬ç§°ä¹‹ä¸ºç´¯åŠ å™¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæƒ³è±¡æˆ‘ä»¬æ­£åœ¨å®šä¹‰ä¸€ä¸ªæ–°çš„å‡½æ•°ï¼Œç§°ä¸º`my-rs`ã€‚å®ƒå°†æ¶ˆè€—ä¸€ä¸ªæ•°å­—åˆ—è¡¨å¹¶ç”Ÿæˆä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œä½†é™¤æ­¤ä¹‹å¤–ï¼Œå®ƒè¿˜ä¼šè®¡ç®—å½“å‰åˆ—è¡¨ä¹‹å‰æ•°å­—çš„æ€»å’Œã€‚
- en: Do Now!
  id: totrans-1054
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-1055
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What should the initial sum be?
  id: totrans-1056
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åˆå§‹æ€»å’Œåº”è¯¥æ˜¯å¤šå°‘ï¼Ÿ
- en: 'Initially there is no â€œpreceding listâ€, so we will use the additive identity:
    `0`. The type of `my-rs` is'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: åˆå§‹æ—¶æ²¡æœ‰â€œå…ˆå‰åˆ—è¡¨â€ï¼Œå› æ­¤æˆ‘ä»¬å°†ä½¿ç”¨åŠ æ³•æ’ç­‰å¼ï¼š`0`ã€‚`my-rs`çš„ç±»å‹æ˜¯
- en: '[PRE227]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'Letâ€™s now re-work our examples from [<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)
    as examples of `my-rs` instead. The examples use the `+` operator to append two
    lists into one (the elements of the first list followed by the elements of the
    second):'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å°†é‡æ–°å¤„ç†æ¥è‡ª[<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)çš„ç¤ºä¾‹ï¼Œä½œä¸º`my-rs`çš„ä¾‹å­ã€‚è¿™äº›ç¤ºä¾‹ä½¿ç”¨`+`è¿ç®—ç¬¦å°†ä¸¤ä¸ªåˆ—è¡¨åˆå¹¶æˆä¸€ä¸ªï¼ˆç¬¬ä¸€ä¸ªåˆ—è¡¨çš„å…ƒç´ åé¢è·Ÿç€ç¬¬äºŒä¸ªåˆ—è¡¨çš„å…ƒç´ ï¼‰ï¼š
- en: '[PRE228]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'That is, `my-rs` translates into the following code:'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿå°±æ˜¯è¯´ï¼Œ`my-rs` è½¬æ¢ä¸ºä»¥ä¸‹ä»£ç ï¼š
- en: '[PRE229]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'All thatâ€™s then left is to call it from `my-running-sum`:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åå‰©ä¸‹çš„å°±æ˜¯ä» `my-running-sum` ä¸­è°ƒç”¨å®ƒï¼š
- en: '[PRE230]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Observe that we do not change `my-running-sum` itself to take extra arguments.
    The correctness of our code depends on the initial value of `acc` being 0\. If
    we added a parameter for `acc`, any code that calls `my-running-sum` could supply
    an unexpected value, which would distort the result. In addition, since the value
    is fixed, adding the parameter would amount to shifting additional (and needless)
    work onto others who use our code.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬æ²¡æœ‰æ”¹å˜ `my-running-sum` æœ¬èº«ä»¥æ¥å—é¢å¤–çš„å‚æ•°ã€‚æˆ‘ä»¬ä»£ç çš„æ­£ç¡®æ€§å–å†³äº `acc` çš„åˆå§‹å€¼æ˜¯ 0ã€‚å¦‚æœæˆ‘ä»¬ä¸º `acc`
    æ·»åŠ äº†ä¸€ä¸ªå‚æ•°ï¼Œä»»ä½•è°ƒç”¨ `my-running-sum` çš„ä»£ç éƒ½å¯èƒ½æä¾›ä¸€ä¸ªæ„å¤–çš„å€¼ï¼Œè¿™ä¼šæ‰­æ›²ç»“æœã€‚æ­¤å¤–ï¼Œç”±äºå€¼æ˜¯å›ºå®šçš„ï¼Œæ·»åŠ å‚æ•°ç›¸å½“äºå°†é¢å¤–çš„ï¼ˆä¸”ä¸å¿…è¦çš„ï¼‰å·¥ä½œè½¬ç§»åˆ°ä½¿ç”¨æˆ‘ä»¬ä»£ç çš„å…¶ä»–äººèº«ä¸Šã€‚
- en: '5.2.8.3Â `my-alternating`: Examples and Code[ğŸ”—](#(part._alternating-accumulator)
    "Link to here")'
  id: totrans-1066
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.8.3 `my-alternating`: [ç¤ºä¾‹å’Œä»£ç ](#(part._alternating-accumulator) "é“¾æ¥è‡³æ­¤")'
- en: 'Recall our examples in [`my-alternating`: Examples and Code](#%28part._alternating-eg-code%29).
    There, we noticed that the code built on every-other example. We might have chosen
    our examples differently, so that from one example to the next we skipped two
    elements rather than one. Here we will see another way to think about the same
    problem.'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 'å›æƒ³ä¸€ä¸‹æˆ‘ä»¬åœ¨ `my-alternating`: [ç¤ºä¾‹å’Œä»£ç ](#%28part._alternating-eg-code%29) ä¸­çš„ä¾‹å­ã€‚åœ¨é‚£é‡Œï¼Œæˆ‘ä»¬æ³¨æ„åˆ°ä»£ç åŸºäºæ¯éš”ä¸€ä¸ªä¾‹å­æ„å»ºã€‚æˆ‘ä»¬å¯èƒ½é€‰æ‹©äº†ä¸åŒçš„ä¾‹å­ï¼Œè¿™æ ·ä»ä¸€ä¸ªä¾‹å­åˆ°ä¸‹ä¸€ä¸ªä¾‹å­æˆ‘ä»¬è·³è¿‡äº†ä¸¤ä¸ªå…ƒç´ è€Œä¸æ˜¯ä¸€ä¸ªã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†çœ‹åˆ°å¦ä¸€ç§æ€è€ƒç›¸åŒé—®é¢˜çš„æ–¹æ³•ã€‚'
- en: 'Return to the examples weâ€™ve already seen [[<alternating-egs-1>](#%28elem._alternating-egs-1%29)].
    We wrote `my-alternating` to traverse the list essentially two elements at a time.
    Another option is to traverse it just one element at a time, but keeping track
    of whether weâ€™re at an odd or even elementâ€”<wbr>i.e., add â€œmemoryâ€ to our program.
    Since we just need to track that one piece of information, we can use a `Boolean`
    to do it. Letâ€™s define a new function for this purpose:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: å›åˆ°æˆ‘ä»¬å·²ç»çœ‹åˆ°çš„ä¾‹å­ [[<alternating-egs-1>](#%28elem._alternating-egs-1%29)]ã€‚æˆ‘ä»¬ç¼–å†™ `my-alternating`
    æ¥åŸºæœ¬ä¸Šæ¯æ¬¡éå†ä¸¤ä¸ªå…ƒç´ ã€‚å¦ä¸€ä¸ªé€‰æ‹©æ˜¯æ¯æ¬¡åªéå†ä¸€ä¸ªå…ƒç´ ï¼Œä½†è·Ÿè¸ªæˆ‘ä»¬æ˜¯åœ¨å¥‡æ•°å…ƒç´ è¿˜æ˜¯å¶æ•°å…ƒç´ â€”â€”å³ï¼Œç»™æˆ‘ä»¬çš„ç¨‹åºæ·»åŠ â€œè®°å¿†â€ã€‚ç”±äºæˆ‘ä»¬åªéœ€è¦è·Ÿè¸ªé‚£ä¸€æ¡ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ª
    `Boolean` æ¥å®ç°ã€‚è®©æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæ–°çš„å‡½æ•°æ¥å®Œæˆè¿™ä¸ªç›®çš„ï¼š
- en: '[PRE231]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: The extra argument accumulates whether weâ€™re at an element to keep or one to
    discard.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: é¢å¤–çš„å‚æ•°ä¼šç´¯ç§¯ï¼Œæ— è®ºæˆ‘ä»¬æ˜¯åœ¨ä¸€ä¸ªè¦ä¿ç•™çš„å…ƒç´ è¿˜æ˜¯ä¸€ä¸ªè¦ä¸¢å¼ƒçš„å…ƒç´ ã€‚
- en: 'We can reuse the existing template for list functions. When we have an element,
    we have to consult the accumulator whether to keep it or not. If its value is
    `true` we `link` it to the answer; otherwise we ignore it. As we process the rest
    of the list, however, we have to remember to update the accumulator: if we kept
    an element we donâ€™t wish to keep the next one, and vice versa.'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é‡ç”¨ç°æœ‰çš„åˆ—è¡¨å‡½æ•°æ¨¡æ¿ã€‚å½“æˆ‘ä»¬æœ‰ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»å’¨è¯¢ç´¯åŠ å™¨æ˜¯å¦è¦ä¿ç•™å®ƒã€‚å¦‚æœå…¶å€¼ä¸º `true`ï¼Œæˆ‘ä»¬å°†å…¶ `link` åˆ°ç­”æ¡ˆï¼›å¦åˆ™æˆ‘ä»¬å¿½ç•¥å®ƒã€‚ç„¶è€Œï¼Œå½“æˆ‘ä»¬å¤„ç†åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»è®°ä½æ›´æ–°ç´¯åŠ å™¨ï¼šå¦‚æœæˆ‘ä»¬ä¿ç•™äº†ä¸€ä¸ªæˆ‘ä»¬ä¸å¸Œæœ›ä¿ç•™çš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œåä¹‹äº¦ç„¶ã€‚
- en: '[PRE232]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'Finally, we have to determine the initial value of the accumulator. In this
    case, since we want to keep alternating elements starting with the first one,
    its initial value should be `true`:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬å¿…é¡»ç¡®å®šç´¯åŠ å™¨çš„åˆå§‹å€¼ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå› ä¸ºæˆ‘ä»¬æƒ³ä»ç¬¬ä¸€ä¸ªå…ƒç´ å¼€å§‹äº¤æ›¿ä¿ç•™å…ƒç´ ï¼Œæ‰€ä»¥å…¶åˆå§‹å€¼åº”è¯¥æ˜¯ `true`ï¼š
- en: '[PRE233]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: Exercise
  id: totrans-1075
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-1076
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define `my-max` using an accumulator. What does the accumulator represent? Do
    you encounter any difficulty?
  id: totrans-1077
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ç´¯åŠ å™¨å®šä¹‰ `my-max`ã€‚ç´¯åŠ å™¨ä»£è¡¨ä»€ä¹ˆï¼Ÿä½ é‡åˆ°ä»»ä½•å›°éš¾å—ï¼Ÿ
- en: '5.2.8.1Â `my-running-sum`: First Attempt[ğŸ”—](#(part._running-sum-1st-attempt)
    "Link to here")'
  id: totrans-1078
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.8.1 `my-running-sum`: ç¬¬ä¸€æ¬¡å°è¯•[ğŸ”—](#(part._running-sum-1st-attempt) "é“¾æ¥è‡³æ­¤")'
- en: One more time, weâ€™ll begin with an example.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¥ä¸€æ¬¡ï¼Œæˆ‘ä»¬ä»ä¾‹å­å¼€å§‹ã€‚
- en: Do Now!
  id: totrans-1080
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-1081
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Work out the results for `my-running-sum` starting from the list `[list: 1,
    2, 3, 4, 5]`.'
  id: totrans-1082
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'ä»åˆ—è¡¨ `[list: 1, 2, 3, 4, 5]` å¼€å§‹è®¡ç®— `my-running-sum` çš„ç»“æœã€‚'
- en: 'Hereâ€™s what our first few examples look like:'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æˆ‘ä»¬å‰å‡ ä¸ªä¾‹å­çœ‹èµ·æ¥åƒè¿™æ ·ï¼š
- en: <running-sum-egs-1> ::=
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: <running-sum-egs-1> ::=
- en: '[PRE234]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Again, there doesnâ€™t appear to be any clear connection between the result on
    the rest of the list and the result on the entire list.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡ï¼Œä¼¼ä¹ç»“æœä¸æ•´ä¸ªåˆ—è¡¨çš„ç»“æœä¹‹é—´æ²¡æœ‰æ˜æ˜¾çš„è”ç³»ã€‚
- en: '(That isnâ€™t strictly true: we can still line up the answers as follows:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆè¿™å¹¶ä¸å®Œå…¨æ­£ç¡®ï¼šæˆ‘ä»¬ä»ç„¶å¯ä»¥å¦‚ä¸‹æ’åˆ—ç­”æ¡ˆï¼š
- en: '[PRE235]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: and observe that weâ€™re computing the answer for the rest of the list, then adding
    the first element to each element in the answer, and `link`ing the first element
    to the front. In principle, we can compute this solution directly, but for now
    that may be more work than finding a simpler way to answer it.)
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¶è§‚å¯Ÿæˆ‘ä»¬æ˜¯åœ¨è®¡ç®—åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†çš„ç­”æ¡ˆï¼Œç„¶åå°†ç¬¬ä¸€ä¸ªå…ƒç´ æ·»åŠ åˆ°ç­”æ¡ˆä¸­çš„æ¯ä¸ªå…ƒç´ ä¸Šï¼Œå¹¶å°†ç¬¬ä¸€ä¸ªå…ƒç´ `link`åˆ°å‰é¢ã€‚åŸåˆ™ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è®¡ç®—è¿™ä¸ªè§£å†³æ–¹æ¡ˆï¼Œä½†å°±ç›®å‰è€Œè¨€ï¼Œè¿™å¯èƒ½æ¯”æ‰¾åˆ°æ›´ç®€å•çš„ç­”æ¡ˆè¦å¤æ‚ã€‚
- en: '5.2.8.2Â `my-running-sum`: Examples and Code[ğŸ”—](#(part._running-sum-eg-code)
    "Link to here")'
  id: totrans-1090
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.8.2Â `my-running-sum`: ç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._running-sum-eg-code) "é“¾æ¥è‡³æ­¤")'
- en: 'Recall how we began in [`my-running-sum`: First Attempt](#%28part._running-sum-1st-attempt%29).
    Our examples [[<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)] showed the
    following problem. When we process the rest of the list, we have forgotten everything
    about what preceded it. That is, when processing the list starting at `2` we forget
    that weâ€™ve seen a `1` earlier; when starting from `3`, we forget that weâ€™ve seen
    both `1` and `2` earlier; and so on. In other words, we keep forgetting the past.
    We need some way of avoiding that.'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 'å›é¡¾æˆ‘ä»¬æ˜¯å¦‚ä½•åœ¨[`my-running-sum`: ç¬¬ä¸€æ¬¡å°è¯•](#%28part._running-sum-1st-attempt%29)å¼€å§‹çš„ã€‚æˆ‘ä»¬çš„ä¾‹å­
    [[<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)] å±•ç¤ºäº†ä»¥ä¸‹é—®é¢˜ã€‚å½“æˆ‘ä»¬å¤„ç†åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æ—¶ï¼Œæˆ‘ä»¬å·²ç»å¿˜è®°äº†ä¹‹å‰çš„ä¸€åˆ‡ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“æˆ‘ä»¬ä»`2`å¼€å§‹å¤„ç†åˆ—è¡¨æ—¶ï¼Œæˆ‘ä»¬å¿˜è®°äº†ä¹‹å‰å·²ç»çœ‹åˆ°è¿‡`1`ï¼›å½“æˆ‘ä»¬ä»`3`å¼€å§‹æ—¶ï¼Œæˆ‘ä»¬å¿˜è®°äº†ä¹‹å‰å·²ç»çœ‹åˆ°è¿‡`1`å’Œ`2`ï¼›ä»¥æ­¤ç±»æ¨ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬ä¸€ç›´åœ¨å¿˜è®°è¿‡å»ã€‚æˆ‘ä»¬éœ€è¦ä¸€ç§é¿å…è¿™ç§æƒ…å†µçš„æ–¹æ³•ã€‚'
- en: The easiest thing we can do is simply change our function to carry along this
    â€œmemoryâ€, or what weâ€™ll call an accumulator. That is, imagine we were defining
    a new function, called `my-rs`. It will consume a list of numbers and produce
    a list of numbers, but in addition it will also take the sum of numbers preceding
    the current list.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬èƒ½åšçš„æœ€ç®€å•çš„äº‹æƒ…å°±æ˜¯ç®€å•åœ°æ”¹å˜æˆ‘ä»¬çš„å‡½æ•°ï¼Œè®©å®ƒæºå¸¦è¿™ç§â€œè®°å¿†â€ï¼Œæˆ–è€…æˆ‘ä»¬ç§°ä¹‹ä¸ºç´¯åŠ å™¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæƒ³è±¡æˆ‘ä»¬æ­£åœ¨å®šä¹‰ä¸€ä¸ªæ–°çš„å‡½æ•°ï¼Œç§°ä¸º`my-rs`ã€‚å®ƒå°†æ¶ˆè€—ä¸€ä¸ªæ•°å­—åˆ—è¡¨å¹¶äº§ç”Ÿä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œä½†é™¤æ­¤ä¹‹å¤–ï¼Œå®ƒè¿˜ä¼šæºå¸¦å½“å‰åˆ—è¡¨ä¹‹å‰çš„æ•°å­—æ€»å’Œã€‚
- en: Do Now!
  id: totrans-1093
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨è¡ŒåŠ¨èµ·æ¥ï¼
- en: ''
  id: totrans-1094
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What should the initial sum be?
  id: totrans-1095
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åˆå§‹æ€»å’Œåº”è¯¥æ˜¯å¤šå°‘ï¼Ÿ
- en: 'Initially there is no â€œpreceding listâ€, so we will use the additive identity:
    `0`. The type of `my-rs` is'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: åˆå§‹æ—¶æ²¡æœ‰â€œå‰ä¸€ä¸ªåˆ—è¡¨â€ï¼Œå› æ­¤æˆ‘ä»¬å°†ä½¿ç”¨åŠ æ³•æ’ç­‰å…ƒï¼š`0`ã€‚`my-rs`çš„ç±»å‹æ˜¯
- en: '[PRE236]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Letâ€™s now re-work our examples from [<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)
    as examples of `my-rs` instead. The examples use the `+` operator to append two
    lists into one (the elements of the first list followed by the elements of the
    second):'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç°åœ¨é‡æ–°å¤„ç†æˆ‘ä»¬çš„ä¾‹å­ [<running-sum-egs-1>](#%28elem._running-sum-egs-1%29)ï¼Œä½œä¸º`my-rs`çš„ä¾‹å­ã€‚è¿™äº›ä¾‹å­ä½¿ç”¨`+`è¿ç®—ç¬¦å°†ä¸¤ä¸ªåˆ—è¡¨è¿æ¥æˆä¸€ä¸ªï¼ˆç¬¬ä¸€ä¸ªåˆ—è¡¨çš„å…ƒç´ åé¢è·Ÿç€ç¬¬äºŒä¸ªåˆ—è¡¨çš„å…ƒç´ ï¼‰ï¼š
- en: '[PRE237]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'That is, `my-rs` translates into the following code:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿå°±æ˜¯è¯´ï¼Œ`my-rs`å¯ä»¥è½¬æ¢ä¸ºä»¥ä¸‹ä»£ç ï¼š
- en: '[PRE238]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'All thatâ€™s then left is to call it from `my-running-sum`:'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åå‰©ä¸‹çš„å°±æ˜¯ä»`my-running-sum`ä¸­è°ƒç”¨å®ƒï¼š
- en: '[PRE239]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Observe that we do not change `my-running-sum` itself to take extra arguments.
    The correctness of our code depends on the initial value of `acc` being 0\. If
    we added a parameter for `acc`, any code that calls `my-running-sum` could supply
    an unexpected value, which would distort the result. In addition, since the value
    is fixed, adding the parameter would amount to shifting additional (and needless)
    work onto others who use our code.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°æˆ‘ä»¬å¹¶æ²¡æœ‰æ”¹å˜`my-running-sum`æœ¬èº«æ¥æ¥å—é¢å¤–çš„å‚æ•°ã€‚æˆ‘ä»¬ä»£ç çš„æ­£ç¡®æ€§ä¾èµ–äº`acc`çš„åˆå§‹å€¼ä¸º0ã€‚å¦‚æœæˆ‘ä»¬ä¸º`acc`æ·»åŠ ä¸€ä¸ªå‚æ•°ï¼Œä»»ä½•è°ƒç”¨`my-running-sum`çš„ä»£ç éƒ½å¯èƒ½æä¾›ä¸€ä¸ªæ„å¤–çš„å€¼ï¼Œè¿™ä¼šæ‰­æ›²ç»“æœã€‚æ­¤å¤–ï¼Œç”±äºå€¼æ˜¯å›ºå®šçš„ï¼Œæ·»åŠ å‚æ•°ç›¸å½“äºå°†é¢å¤–çš„ï¼ˆä¸”ä¸å¿…è¦çš„ï¼‰å·¥ä½œè½¬å«ç»™ä½¿ç”¨æˆ‘ä»¬ä»£ç çš„å…¶ä»–äººã€‚
- en: '5.2.8.3Â `my-alternating`: Examples and Code[ğŸ”—](#(part._alternating-accumulator)
    "Link to here")'
  id: totrans-1105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.8.3Â `my-alternating`: ç¤ºä¾‹å’Œä»£ç [ğŸ”—](#(part._alternating-accumulator) "é“¾æ¥è‡³æ­¤")'
- en: 'Recall our examples in [`my-alternating`: Examples and Code](#%28part._alternating-eg-code%29).
    There, we noticed that the code built on every-other example. We might have chosen
    our examples differently, so that from one example to the next we skipped two
    elements rather than one. Here we will see another way to think about the same
    problem.'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 'å›é¡¾æˆ‘ä»¬ä¹‹å‰åœ¨[`my-alternating`: ç¤ºä¾‹å’Œä»£ç ](#%28part._alternating-eg-code%29)ä¸­çš„ä¾‹å­ã€‚åœ¨é‚£é‡Œï¼Œæˆ‘ä»¬æ³¨æ„åˆ°ä»£ç æ˜¯åŸºäºæ¯éš”ä¸€ä¸ªä¾‹å­æ„å»ºçš„ã€‚æˆ‘ä»¬å¯èƒ½é€‰æ‹©äº†ä¸åŒçš„ä¾‹å­ï¼Œä½¿å¾—ä»ä¸€ä¸ªä¾‹å­åˆ°ä¸‹ä¸€ä¸ªä¾‹å­æˆ‘ä»¬è·³è¿‡äº†ä¸¤ä¸ªå…ƒç´ è€Œä¸æ˜¯ä¸€ä¸ªã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†çœ‹åˆ°å¦ä¸€ç§æ€è€ƒç›¸åŒé—®é¢˜çš„æ–¹æ³•ã€‚'
- en: 'Return to the examples weâ€™ve already seen [[<alternating-egs-1>](#%28elem._alternating-egs-1%29)].
    We wrote `my-alternating` to traverse the list essentially two elements at a time.
    Another option is to traverse it just one element at a time, but keeping track
    of whether weâ€™re at an odd or even elementâ€”<wbr>i.e., add â€œmemoryâ€ to our program.
    Since we just need to track that one piece of information, we can use a `Boolean`
    to do it. Letâ€™s define a new function for this purpose:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: å›åˆ°æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„ç¤ºä¾‹ [[<alternating-egs-1>](#%28elem._alternating-egs-1%29)]ã€‚æˆ‘ä»¬ç¼–å†™äº† `my-alternating`
    æ¥éå†åˆ—è¡¨ï¼ŒåŸºæœ¬ä¸Šæ˜¯æ¯æ¬¡ä¸¤ä¸ªå…ƒç´ ã€‚å¦ä¸€ä¸ªé€‰æ‹©æ˜¯é€ä¸ªå…ƒç´ éå†å®ƒï¼Œä½†ä¿æŒè·Ÿè¸ªæˆ‘ä»¬æ˜¯å¦å¤„äºå¥‡æ•°æˆ–å¶æ•°å…ƒç´ â€”â€”å³ï¼Œç»™æˆ‘ä»¬çš„ç¨‹åºæ·»åŠ â€œè®°å¿†â€ã€‚ç”±äºæˆ‘ä»¬åªéœ€è¦è·Ÿè¸ªé‚£ä¸€æ¡ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ª
    `Boolean` æ¥å®ç°ã€‚è®©æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæ–°çš„å‡½æ•°æ¥å®Œæˆè¿™ä¸ªç›®çš„ï¼š
- en: '[PRE240]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: The extra argument accumulates whether weâ€™re at an element to keep or one to
    discard.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: é¢å¤–çš„å‚æ•°ç´¯åŠ å™¨è®°å½•æˆ‘ä»¬æ˜¯å¦å¤„äºè¦ä¿ç•™çš„å…ƒç´ æˆ–è¦ä¸¢å¼ƒçš„å…ƒç´ ã€‚
- en: 'We can reuse the existing template for list functions. When we have an element,
    we have to consult the accumulator whether to keep it or not. If its value is
    `true` we `link` it to the answer; otherwise we ignore it. As we process the rest
    of the list, however, we have to remember to update the accumulator: if we kept
    an element we donâ€™t wish to keep the next one, and vice versa.'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é‡ç”¨ç°æœ‰çš„åˆ—è¡¨å‡½æ•°æ¨¡æ¿ã€‚å½“æˆ‘ä»¬æœ‰ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»å’¨è¯¢ç´¯åŠ å™¨æ˜¯å¦ä¿ç•™å®ƒã€‚å¦‚æœå…¶å€¼ä¸º `true`ï¼Œæˆ‘ä»¬å°†å…¶ `link` åˆ°ç­”æ¡ˆï¼›å¦åˆ™æˆ‘ä»¬å¿½ç•¥å®ƒã€‚ç„¶è€Œï¼Œå½“æˆ‘ä»¬å¤„ç†åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»è®°ä½æ›´æ–°ç´¯åŠ å™¨ï¼šå¦‚æœæˆ‘ä»¬ä¿ç•™äº†ä¸€ä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬ä¸æƒ³ä¿ç•™ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œåä¹‹äº¦ç„¶ã€‚
- en: '[PRE241]'
  id: totrans-1111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'Finally, we have to determine the initial value of the accumulator. In this
    case, since we want to keep alternating elements starting with the first one,
    its initial value should be `true`:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬å¿…é¡»ç¡®å®šç´¯åŠ å™¨çš„åˆå§‹å€¼ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç”±äºæˆ‘ä»¬æƒ³è¦ä»ç¬¬ä¸€ä¸ªå…ƒç´ å¼€å§‹ä¿ç•™äº¤æ›¿å…ƒç´ ï¼Œå…¶åˆå§‹å€¼åº”è¯¥æ˜¯ `true`ï¼š
- en: '[PRE242]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: Exercise
  id: totrans-1114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-1115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define `my-max` using an accumulator. What does the accumulator represent? Do
    you encounter any difficulty?
  id: totrans-1116
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ç´¯åŠ å™¨å®šä¹‰ `my-max`ã€‚ç´¯åŠ å™¨ä»£è¡¨ä»€ä¹ˆï¼Ÿä½ é‡åˆ°ä»»ä½•å›°éš¾å—ï¼Ÿ
- en: 5.2.9Â Dealing with Multiple Answers[ğŸ”—](#(part._.Dealing_with_.Multiple_.Answers)
    "Link to here")
  id: totrans-1117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.9 å¤„ç†å¤šä¸ªç­”æ¡ˆ[ğŸ”—](#(part._.Dealing_with_.Multiple_.Answers) "é“¾æ¥è‡³æ­¤")
- en: Our discussion above has assumed there is only one answer for a given input.
    This is often true, but it also depends on how the problem is worded and how we
    choose to generate examples. We will study this in some detail now.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¸Šé¢çš„è®¨è®ºå‡è®¾å¯¹äºç»™å®šçš„è¾“å…¥åªæœ‰ä¸€ä¸ªç­”æ¡ˆã€‚è¿™é€šå¸¸æ˜¯æ­£ç¡®çš„ï¼Œä½†ä¹Ÿå–å†³äºé—®é¢˜çš„æªè¾ä»¥åŠæˆ‘ä»¬é€‰æ‹©ç”Ÿæˆç¤ºä¾‹çš„æ–¹å¼ã€‚æˆ‘ä»¬ç°åœ¨å°†å¯¹æ­¤è¿›è¡Œä¸€äº›è¯¦ç»†çš„ç ”ç©¶ã€‚
- en: '5.2.9.1Â `uniq`: Problem Setup[ğŸ”—](#(part._uniq) "Link to here")'
  id: totrans-1119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.9.1 `uniq`: é—®é¢˜è®¾ç½®[ğŸ”—](#(part._uniq) "é“¾æ¥è‡³æ­¤")'
- en: Consider the task of writing `uniq`:uniq is the name of a Unix utility with
    similar behavior; hence the spelling of the name. given a list of values, it produces
    a collection of the same elements while avoiding any duplicates (hence `uniq`,
    short for â€œuniqueâ€).
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘ç¼–å†™ `uniq` çš„ä»»åŠ¡ï¼š`uniq` æ˜¯ä¸€ä¸ªå…·æœ‰ç±»ä¼¼è¡Œä¸ºçš„ Unix å·¥å…·ï¼Œå› æ­¤åç§°çš„æ‹¼å†™ã€‚ç»™å®šä¸€ä¸ªå€¼åˆ—è¡¨ï¼Œå®ƒäº§ç”Ÿä¸€ä¸ªåŒ…å«ç›¸åŒå…ƒç´ çš„é›†åˆï¼ŒåŒæ—¶é¿å…ä»»ä½•é‡å¤ï¼ˆå› æ­¤ç§°ä¸º
    `uniq`ï¼Œæ„ä¸ºâ€œå”¯ä¸€â€ï¼‰ã€‚
- en: 'Consider the following input: `[list: 1, 2, 1, 3, 1, 2, 4, 1]`.'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 'è€ƒè™‘ä»¥ä¸‹è¾“å…¥ï¼š`[list: 1, 2, 1, 3, 1, 2, 4, 1]`ã€‚'
- en: Do Now!
  id: totrans-1122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç°åœ¨å°±åšï¼
- en: ''
  id: totrans-1123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the sequence of examples this input generates? Itâ€™s really important
    you stop and try to do this by hand. As we will see there are multiple solutions,
    and itâ€™s useful for you to consider what you generate. Even if you canâ€™t generate
    a sequence, trying to do so will better prepare you for what you read next.
  id: totrans-1124
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè¾“å…¥ç”Ÿæˆçš„ç¤ºä¾‹åºåˆ—æ˜¯ä»€ä¹ˆï¼Ÿä½ çœŸçš„éœ€è¦åœä¸‹æ¥å¹¶å°è¯•æ‰‹åŠ¨å®Œæˆè¿™ä¸ªä»»åŠ¡ã€‚æˆ‘ä»¬å°†çœ‹åˆ°æœ‰å¤šä¸ªè§£å†³æ–¹æ¡ˆï¼Œè€ƒè™‘ä½ ç”Ÿæˆçš„ç»“æœå°†æ˜¯æœ‰ç”¨çš„ã€‚å³ä½¿ä½ ä¸èƒ½ç”Ÿæˆä¸€ä¸ªåºåˆ—ï¼Œå°è¯•è¿™æ ·åšä¹Ÿä¼šæ›´å¥½åœ°ä¸ºä½ é˜…è¯»ä¸‹ä¸€éƒ¨åˆ†åšå¥½å‡†å¤‡ã€‚
- en: How did you obtain your example? If you just â€œthought about it for a moment
    and wrote something downâ€, you may or may not have gotten something you can turn
    into a program. Programs can only proceed systematically; they canâ€™t â€œthinkâ€.
    So, hopefully you took a well-defined path to computing the answer.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æ˜¯å¦‚ä½•å¾—åˆ°ä½ çš„ç¤ºä¾‹çš„ï¼Ÿå¦‚æœä½ åªæ˜¯â€œæ€è€ƒäº†ä¸€ä¼šå„¿å¹¶å†™ä¸‹äº†ä¸€äº›ä¸œè¥¿â€ï¼Œä½ å¯èƒ½å¾—åˆ°äº†ä¸€äº›å¯ä»¥è½¬åŒ–ä¸ºç¨‹åºçš„ä¸œè¥¿ï¼Œä¹Ÿå¯èƒ½æ²¡æœ‰ã€‚ç¨‹åºåªèƒ½ç³»ç»Ÿåœ°æ¨è¿›ï¼›å®ƒä»¬ä¸èƒ½â€œæ€è€ƒâ€ã€‚æ‰€ä»¥ï¼Œå¸Œæœ›ä½ å·²ç»é‡‡å–äº†ä¸€ä¸ªæ˜ç¡®çš„è·¯å¾„æ¥è®¡ç®—ç­”æ¡ˆã€‚
- en: '5.2.9.2Â `uniq`: Examples[ğŸ”—](#(part._uniq-eg) "Link to here")'
  id: totrans-1126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.9.2 `uniq`: ç¤ºä¾‹[ğŸ”—](#(part._uniq-eg) "é“¾æ¥è‡³æ­¤")'
- en: It turns out there are several possible answers, because we have (intentionally)
    left the problem unspecified. Suppose there are two instances of a value in the
    list; which one do we keep, the first or the second? On the one hand, since the
    two instances must be equivalent it doesnâ€™t matter, but it does for writing concrete
    examples and deriving a solution.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœæœ‰å‡ ä¸ªå¯èƒ½çš„ç­”æ¡ˆï¼Œå› ä¸ºæˆ‘ä»¬ï¼ˆæœ‰æ„ï¼‰æ²¡æœ‰å…·ä½“è¯´æ˜é—®é¢˜ã€‚å‡è®¾åˆ—è¡¨ä¸­æœ‰ä¸¤ä¸ªç›¸åŒå€¼çš„å®ä¾‹ï¼›æˆ‘ä»¬ä¿ç•™å“ªä¸€ä¸ªï¼Œç¬¬ä¸€ä¸ªè¿˜æ˜¯ç¬¬äºŒä¸ªï¼Ÿä¸€æ–¹é¢ï¼Œç”±äºè¿™ä¸¤ä¸ªå®ä¾‹å¿…é¡»ç­‰æ•ˆï¼Œæ‰€ä»¥è¿™å¹¶ä¸é‡è¦ï¼Œä½†åœ¨ç¼–å†™å…·ä½“ç¤ºä¾‹å’Œæ¨å¯¼è§£å†³æ–¹æ¡ˆæ—¶ï¼Œè¿™å¾ˆé‡è¦ã€‚
- en: 'For instance, you might have generated this sequence:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œä½ å¯èƒ½ç”Ÿæˆäº†ä»¥ä¸‹åºåˆ—ï¼š
- en: '[PRE243]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: However, you might have also generated sequences that began with
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œä½ ä¹Ÿå¯èƒ½ç”Ÿæˆäº†ä»¥ä»¥ä¸‹åºåˆ—å¼€å§‹çš„åºåˆ—
- en: '[PRE244]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: or
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…
- en: '[PRE245]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: and so on. Letâ€™s work with the examples weâ€™ve worked out above.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: ç­‰ç­‰ã€‚è®©æˆ‘ä»¬å¤„ç†æˆ‘ä»¬ä¸Šé¢å·²ç»è§£å†³çš„é—®é¢˜ã€‚
- en: '5.2.9.3Â `uniq`: Code[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)
    "Link to here")'
  id: totrans-1135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.9.3 `uniq`ï¼šä»£ç [ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'What is the systematic approach that gets us to this answer? When given a non-empty
    list, we split it into its first element and the rest of the list. Suppose we
    have the answer to `uniq` applied to the rest of the list. Now we can ask: is
    the first element in the rest of the list? If it is, then we can ignore it, since
    it is certain to be in the `uniq` of the rest of the list. If, however, it is
    not in the rest of the list, itâ€™s critical that we `link` it to the answer.'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¦‚ä½•ç³»ç»Ÿåœ°å¾—åˆ°è¿™ä¸ªç­”æ¡ˆï¼Ÿå½“ç»™å®šä¸€ä¸ªéç©ºåˆ—è¡¨æ—¶ï¼Œæˆ‘ä»¬å°†å…¶åˆ†ä¸ºå…¶ç¬¬ä¸€ä¸ªå…ƒç´ å’Œåˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†ã€‚å‡è®¾æˆ‘ä»¬å·²ç»å¾—åˆ°äº†å¯¹åˆ—è¡¨å…¶ä½™éƒ¨åˆ†åº”ç”¨`uniq`çš„ç­”æ¡ˆã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥é—®ï¼šç¬¬ä¸€ä¸ªå…ƒç´ åœ¨åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†ä¸­å—ï¼Ÿå¦‚æœæ˜¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å¿½ç•¥å®ƒï¼Œå› ä¸ºå®ƒè‚¯å®šåœ¨åˆ—è¡¨çš„`uniq`ä¸­ã€‚ç„¶è€Œï¼Œå¦‚æœå®ƒä¸åœ¨åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†ä¸­ï¼Œé‚£ä¹ˆå°†å®ƒä»¬`é“¾æ¥`åˆ°ç­”æ¡ˆä¸­æ˜¯è‡³å…³é‡è¦çš„ã€‚
- en: This translates into the following program. For the empty list, we return the
    empty list. If the list is non-empty, we check whether the first is in the rest
    of the list. If it is not, we include it; otherwise we can ignore it for now.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è½¬åŒ–ä¸ºä»¥ä¸‹ç¨‹åºã€‚å¯¹äºç©ºåˆ—è¡¨ï¼Œæˆ‘ä»¬è¿”å›ç©ºåˆ—è¡¨ã€‚å¦‚æœåˆ—è¡¨éç©ºï¼Œæˆ‘ä»¬æ£€æŸ¥ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¦åœ¨åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†ä¸­ã€‚å¦‚æœä¸æ˜¯ï¼Œæˆ‘ä»¬å°†å…¶åŒ…æ‹¬åœ¨å†…ï¼›å¦åˆ™ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥å¿½ç•¥å®ƒã€‚
- en: 'This results in the following program:'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯¼è‡´ä»¥ä¸‹ç¨‹åºï¼š
- en: '[PRE246]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: which weâ€™ve called `uniq-rec` instead of `uniq` to differentiate it from other
    versions of `uniq`.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†å…¶ç§°ä¸º`uniq-rec`è€Œä¸æ˜¯`uniq`ï¼Œä»¥åŒºåˆ†å…¶ä»–ç‰ˆæœ¬çš„`uniq`ã€‚
- en: Exercise
  id: totrans-1141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-1142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that weâ€™re using `.member` to check whether an element is a member of the
    list. Write a function `member` that consumes an element and a list, and tells
    us whether the element is a member of the list.
  id: totrans-1143
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬æ­£åœ¨ä½¿ç”¨`.member`æ¥æ£€æŸ¥ä¸€ä¸ªå…ƒç´ æ˜¯å¦æ˜¯åˆ—è¡¨çš„æˆå‘˜ã€‚ç¼–å†™ä¸€ä¸ª`member`å‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ªå…ƒç´ å’Œä¸€ä¸ªåˆ—è¡¨ï¼Œå¹¶å‘Šè¯‰æˆ‘ä»¬è¯¥å…ƒç´ æ˜¯å¦æ˜¯åˆ—è¡¨çš„æˆå‘˜ã€‚
- en: Exercise
  id: totrans-1144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-1145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Uniqueness checking has many practical applications. For example, one might
    have a list of names of people who have registered to vote in an election. To
    keep the voting fair, with only one vote allowed per person, we should remove
    duplicate names from the list.
  id: totrans-1146
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å”¯ä¸€æ€§æ£€æŸ¥æœ‰è®¸å¤šå®é™…åº”ç”¨ã€‚ä¾‹å¦‚ï¼Œå¯èƒ½æœ‰ä¸€ä»½æ³¨å†Œå‚åŠ é€‰ä¸¾çš„äººåçš„åˆ—è¡¨ã€‚ä¸ºäº†ä¿æŒé€‰ä¸¾çš„å…¬å¹³æ€§ï¼Œæ¯äººåªèƒ½æŠ•ä¸€ç¥¨ï¼Œæˆ‘ä»¬åº”è¯¥ä»åˆ—è¡¨ä¸­åˆ é™¤é‡å¤çš„åå­—ã€‚
- en: ''
  id: totrans-1147
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a set of examples for a function `rem-duplicate-voters` that takes a
    list of voter names and returns a list in which duplicate registrations have been
    removed. In developing your examples, consider real-world scenarios that you can
    imagine arising when identifying duplicate names. Can you identify cases in which
    two names might appear to be the same person, but not be? Cases in which two names
    might appear different but be referring to the same person?
  id: totrans-1148
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: æå‡ºä¸€ç»„ç¤ºä¾‹ï¼Œç”¨äºå‡½æ•°`rem-duplicate-voters`ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªé€‰æ°‘åå­—åˆ—è¡¨ï¼Œå¹¶è¿”å›ä¸€ä¸ªåˆ é™¤äº†é‡å¤æ³¨å†Œçš„åˆ—è¡¨ã€‚åœ¨å¼€å‘ä½ çš„ç¤ºä¾‹æ—¶ï¼Œè¯·è€ƒè™‘åœ¨è¯†åˆ«é‡å¤åå­—æ—¶å¯èƒ½å‡ºç°çš„ç°å®ä¸–ç•Œåœºæ™¯ã€‚ä½ èƒ½è¯†åˆ«å‡ºä¸¤ä¸ªåå­—å¯èƒ½çœ‹èµ·æ¥æ˜¯åŒä¸€ä¸ªäººï¼Œä½†å®é™…ä¸Šä¸æ˜¯çš„æƒ…å†µå—ï¼Ÿä¸¤ä¸ªåå­—å¯èƒ½çœ‹èµ·æ¥ä¸åŒï¼Œä½†å®é™…ä¸Šæ˜¯æŒ‡åŒä¸€ä¸ªäººçš„æƒ…å†µï¼Ÿ
- en: ''
  id: totrans-1149
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1150
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: What might you need to change about our current `uniq-rec` function to handle
    a situation like removing duplicate voters?
  id: totrans-1151
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦å¯¹æˆ‘ä»¬å½“å‰çš„`uniq-rec`å‡½æ•°è¿›è¡Œå“ªäº›æ›´æ”¹æ‰èƒ½å¤„ç†åƒåˆ é™¤é‡å¤é€‰æ°‘è¿™æ ·çš„æƒ…å†µï¼Ÿ
- en: 'Responsible Computing: Context Matters When Comparing Values'
  id: totrans-1152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è´£ä»»è®¡ç®—ï¼šæ¯”è¾ƒå€¼æ—¶ï¼Œä¸Šä¸‹æ–‡å¾ˆé‡è¦
- en: ''
  id: totrans-1153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The data de-duplication context in the above exercise reminds us that different
    contexts may call for different notions of when two data values are the same.
    Sometimes, we want exact matching to determine that two strings are equal. Sometimes,
    we need methods that normalize data, either in simple ways like capitalization
    or subtler ways based on middle initials. Sometimes, we need more information
    (like street addresses in addition to names) in order to determine whether two
    items in a list should be considered â€œthe sameâ€.
  id: totrans-1154
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ä¸Šé¢çš„ç»ƒä¹ ä¸­çš„æ•°æ®å»é‡ä¸Šä¸‹æ–‡æé†’æˆ‘ä»¬ï¼Œä¸åŒçš„ä¸Šä¸‹æ–‡å¯èƒ½éœ€è¦ä¸åŒçš„å…³äºä¸¤ä¸ªæ•°æ®å€¼ä½•æ—¶ç›¸åŒçš„è§‚å¿µã€‚æœ‰æ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›è¿›è¡Œç²¾ç¡®åŒ¹é…ä»¥ç¡®å®šä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰ã€‚æœ‰æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨å°†æ•°æ®è§„èŒƒåŒ–çš„æ–¹æ³•ï¼Œæ— è®ºæ˜¯ç®€å•çš„å¦‚å¤§å†™å­—æ¯è¿˜æ˜¯æ›´å¾®å¦™çš„æ–¹æ³•ï¼Œå¦‚åŸºäºä¸­é—´åé¦–å­—æ¯ã€‚æœ‰æ—¶ï¼Œæˆ‘ä»¬éœ€è¦æ›´å¤šä¿¡æ¯ï¼ˆå¦‚é™¤äº†åå­—ä¹‹å¤–è¿˜æœ‰è¡—é“åœ°å€ï¼‰æ¥ç¡®å®šåˆ—è¡¨ä¸­çš„ä¸¤ä¸ªé¡¹ç›®æ˜¯å¦åº”è¯¥è¢«è§†ä¸ºâ€œç›¸åŒâ€ã€‚
- en: ''
  id: totrans-1155
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is easy to write programs that encode assumptions about our data that might
    not apply in practice. This is again a situation that can be helped by thinking
    about the concrete examples on which your code needs to work in context.
  id: totrans-1156
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®¹æ˜“ç¼–å†™å‡ºç¼–ç äº†å…³äºæˆ‘ä»¬æ•°æ®çš„å‡è®¾çš„ç¨‹åºï¼Œè¿™äº›å‡è®¾åœ¨å®é™…åº”ç”¨ä¸­å¯èƒ½å¹¶ä¸é€‚ç”¨ã€‚è¿™ç§æƒ…å†µå¯ä»¥é€šè¿‡æ€è€ƒä»£ç éœ€è¦åœ¨ä»€ä¹ˆä¸Šä¸‹æ–‡ä¸­å·¥ä½œçš„å…·ä½“ä¾‹å­æ¥å¾—åˆ°å¸®åŠ©ã€‚
- en: '5.2.9.4Â `uniq`: Reducing Computation[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)
    "Link to here")'
  id: totrans-1157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.9.4 `uniq`ï¼šå‡å°‘è®¡ç®—[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Notice that this function has a repeated expression. Instead of writing it
    twice, we could call it just once and use the result in both places:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™ä¸ªå‡½æ•°æœ‰ä¸€ä¸ªé‡å¤çš„è¡¨è¾¾å¼ã€‚æˆ‘ä»¬ä¸å¿…å†™ä¸¤æ¬¡ï¼Œåªéœ€è°ƒç”¨ä¸€æ¬¡å¹¶åœ¨ä¸¤ä¸ªåœ°æ–¹ä½¿ç”¨ç»“æœï¼š
- en: '[PRE247]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: You might think, because we replaced two function calls with one, that weâ€™ve
    reduced the amount of computation the program does. It does not! The two function
    calls are both in the two branches of the same conditional; therefore, for any
    given list element, only one or the other call to `uniq` happens. In fact, in
    both cases, there was one call to `uniq` before, and there is one now. So we have
    reduced the number of calls in the source program, but not the number that take
    place when the program runs. In that sense, the name of this section was intentionally
    misleading!
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½ä¼šè®¤ä¸ºï¼Œå› ä¸ºæˆ‘ä»¬ç”¨ä¸€æ¬¡å‡½æ•°è°ƒç”¨æ›¿æ¢äº†ä¸¤æ¬¡è°ƒç”¨ï¼Œæ‰€ä»¥å‡å°‘äº†ç¨‹åºçš„è®¡ç®—é‡ã€‚ä½†è¿™å¹¶ä¸æ­£ç¡®ï¼è¿™ä¸¤ä¸ªå‡½æ•°è°ƒç”¨éƒ½åœ¨åŒä¸€ä¸ªæ¡ä»¶è¯­å¥çš„ä¸¤ä¸ªåˆ†æ”¯ä¸­ï¼›å› æ­¤ï¼Œå¯¹äºä»»ä½•ç»™å®šçš„åˆ—è¡¨å…ƒç´ ï¼Œåªä¼šå‘ç”Ÿä¸€æ¬¡æˆ–å¦ä¸€æ¬¡å¯¹`uniq`çš„è°ƒç”¨ã€‚å®é™…ä¸Šï¼Œåœ¨ä¸¤ç§æƒ…å†µä¸‹ï¼Œä¹‹å‰éƒ½è°ƒç”¨äº†ä¸€æ¬¡`uniq`ï¼Œç°åœ¨ä¹Ÿè°ƒç”¨äº†ä¸€æ¬¡ã€‚æ‰€ä»¥æˆ‘ä»¬åœ¨æºç¨‹åºä¸­å‡å°‘äº†è°ƒç”¨æ¬¡æ•°ï¼Œä½†å¹¶æ²¡æœ‰å‡å°‘ç¨‹åºè¿è¡Œæ—¶çš„è°ƒç”¨æ¬¡æ•°ã€‚ä»è¿™ä¸ªæ„ä¹‰ä¸Šè¯´ï¼Œè¿™ä¸ªç« èŠ‚çš„åç§°æ˜¯æœ‰æ„è¯¯å¯¼çš„ï¼
- en: 'However, there is one useful reduction we can perform, which is enabled by
    the structure of `uniq-rec2`. We currently check whether `f` is a member of `r`,
    which is the list of all the remaining elements. In our example, this means that
    in the very second turn, we check whether `2` is a member of the list `[list:
    1, 3, 1, 2, 4, 1]`. This is a list of six elements, including three copies of
    `1`. We compare `2` against two copies of `1`. However, we gain nothing from the
    second comparison. Put differently, we can think of `uniq(r)` as a â€œsummaryâ€ of
    the rest of the list that is exactly as good as `r` itself for checking membership,
    with the advantage that it might be significantly shorter. This, of course, is
    exactly what `ur` represents. Therefore, we can encode this intuition as follows:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç„¶è€Œï¼Œæˆ‘ä»¬å¯ä»¥æ‰§è¡Œä¸€ä¸ªæœ‰ç”¨çš„å‡å°‘æ“ä½œï¼Œè¿™æ˜¯ç”±`uniq-rec2`çš„ç»“æ„æ‰€å¯ç”¨çš„ã€‚æˆ‘ä»¬ç›®å‰æ£€æŸ¥`f`æ˜¯å¦æ˜¯`r`çš„æˆå‘˜ï¼Œ`r`æ˜¯æ‰€æœ‰å‰©ä½™å…ƒç´ çš„åˆ—è¡¨ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œè¿™æ„å‘³ç€åœ¨ç¬¬äºŒæ¬¡è¿­ä»£æ—¶ï¼Œæˆ‘ä»¬æ£€æŸ¥`2`æ˜¯å¦æ˜¯åˆ—è¡¨`[list:
    1, 3, 1, 2, 4, 1]`çš„æˆå‘˜ã€‚è¿™æ˜¯ä¸€ä¸ªåŒ…å«å…­ä¸ªå…ƒç´ çš„åˆ—è¡¨ï¼ŒåŒ…æ‹¬ä¸‰ä¸ª`1`çš„å‰¯æœ¬ã€‚æˆ‘ä»¬å°†`2`ä¸ä¸¤ä¸ª`1`è¿›è¡Œæ¯”è¾ƒã€‚ç„¶è€Œï¼Œç¬¬äºŒæ¬¡æ¯”è¾ƒå¹¶æ²¡æœ‰å¸¦æ¥ä»»ä½•å¥½å¤„ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥å°†`uniq(r)`è§†ä¸ºåˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„â€œæ‘˜è¦â€ï¼Œå®ƒåœ¨æ£€æŸ¥æˆå‘˜èµ„æ ¼æ–¹é¢ä¸`r`æœ¬èº«ä¸€æ ·å¥½ï¼Œè€Œä¸”å¯èƒ½æ˜¾è‘—æ›´çŸ­ã€‚è¿™æ­£æ˜¯`ur`æ‰€ä»£è¡¨çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™ç§ç›´è§‰ç¼–ç å¦‚ä¸‹ï¼š'
- en: '[PRE248]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: Note that all that changed is that we check for membership in `ur` rather than
    in `r`.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå”¯ä¸€æ”¹å˜çš„æ˜¯æˆ‘ä»¬æ£€æŸ¥`ur`è€Œä¸æ˜¯`r`ä¸­çš„æˆå‘˜èµ„æ ¼ã€‚
- en: Exercise
  id: totrans-1164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-1165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Later [[Predicting Growth](predicting-growth.html)] we will study how to formally
    study how long a program takes to run. By the measure introduced in that section,
    does the change we just made make any difference? Be careful with your answer:
    it depends on how we count â€œthe lengthâ€ of the list.'
  id: totrans-1166
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨åé¢çš„[[é¢„æµ‹å¢é•¿](predicting-growth.html)]ä¸­ï¼Œæˆ‘ä»¬å°†ç ”ç©¶å¦‚ä½•æ­£å¼ç ”ç©¶ç¨‹åºè¿è¡Œæ‰€éœ€çš„æ—¶é—´ã€‚æ ¹æ®è¯¥èŠ‚ä¸­å¼•å…¥çš„åº¦é‡æ ‡å‡†ï¼Œæˆ‘ä»¬åˆšæ‰æ‰€åšçš„æ›´æ”¹æœ‰ä»€ä¹ˆå½±å“ï¼Ÿè¯·æ³¨æ„ä½ çš„ç­”æ¡ˆï¼šè¿™å–å†³äºæˆ‘ä»¬å¦‚ä½•è®¡ç®—â€œé•¿åº¦â€ã€‚
- en: Observe that if the list never contained duplicates in the first place, then
    it wouldnâ€™t matter which list we check membership inâ€”<wbr>but if we knew the list
    didnâ€™t contain duplicates, we wouldnâ€™t be using `uniq` in the first place! We
    will return to the issue of lists and duplicate elements in [Representing Sets
    as Lists](sets-from-lists.html).
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå¦‚æœåˆ—è¡¨ä¸€å¼€å§‹å°±æ²¡æœ‰åŒ…å«é‡å¤é¡¹ï¼Œé‚£ä¹ˆæ£€æŸ¥å“ªä¸ªåˆ—è¡¨ä¸­çš„æˆå‘˜èµ„æ ¼å°±æ— å…³ç´§è¦â€”â€”<wbr>ä½†å¦‚æœæˆ‘ä»¬çŸ¥é“åˆ—è¡¨æ²¡æœ‰åŒ…å«é‡å¤é¡¹ï¼Œæˆ‘ä»¬ä¸€å¼€å§‹å°±ä¸ä¼šä½¿ç”¨`uniq`ï¼æˆ‘ä»¬å°†åœ¨[å°†é›†åˆè¡¨ç¤ºä¸ºåˆ—è¡¨](sets-from-lists.html)ä¸­å›åˆ°åˆ—è¡¨å’Œé‡å¤å…ƒç´ çš„é—®é¢˜ã€‚
- en: '5.2.9.5Â `uniq`: Example and Code Variations[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)
    "Link to here")'
  id: totrans-1168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.9.5 `uniq`: ç¤ºä¾‹å’Œä»£ç å˜åŒ–[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)
    "é“¾æ¥åˆ°æ­¤å¤„")'
- en: 'As we mentioned earlier, there are other example sequences you might have written
    down. Hereâ€™s a very different process:'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æˆ‘ä»¬ä¹‹å‰æåˆ°çš„ï¼Œä½ å¯èƒ½å·²ç»å†™ä¸‹äº†å…¶ä»–ç¤ºä¾‹åºåˆ—ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªéå¸¸ä¸åŒçš„è¿‡ç¨‹ï¼š
- en: Start with the entire given list and with the empty answer (so far).
  id: totrans-1170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»æ•´ä¸ªç»™å®šçš„åˆ—è¡¨å’Œç©ºç­”æ¡ˆï¼ˆåˆ°ç›®å‰ä¸ºæ­¢ï¼‰å¼€å§‹ã€‚
- en: For each list element, check whether itâ€™s already in the answer so far. If it
    is, ignore it, otherwise extend the answer with it.
  id: totrans-1171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºåˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦å·²ç»åœ¨åˆ°ç›®å‰ä¸ºæ­¢çš„ç­”æ¡ˆä¸­ã€‚å¦‚æœæ˜¯ï¼Œå¿½ç•¥å®ƒï¼Œå¦åˆ™ç”¨å®ƒæ‰©å±•ç­”æ¡ˆã€‚
- en: When there are no more elements in the list, the answer so far is the answer
    for the whole list.
  id: totrans-1172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“åˆ—è¡¨ä¸­æ²¡æœ‰æ›´å¤šå…ƒç´ æ—¶ï¼Œåˆ°ç›®å‰ä¸ºæ­¢çš„ç­”æ¡ˆå°±æ˜¯æ•´ä¸ªåˆ—è¡¨çš„ç­”æ¡ˆã€‚
- en: Notice that this solution assumes that we will be accumulating the answer as
    we traverse the list. Therefore, we canâ€™t even write the example with one parameter
    as we did before. We would argue that a natural solution asks whether we can solve
    the problem just from the structure of the data using the computation we are already
    defining, as we did above. If we cannot, then we have to resort to an accumulator.
    But because we can, the accumulator is unnecessary here and greatly complicates
    even writing down examples (give it a try!).
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™ä¸ªè§£å†³æ–¹æ¡ˆå‡è®¾æˆ‘ä»¬å°†åœ¨éå†åˆ—è¡¨æ—¶ç´¯ç§¯ç­”æ¡ˆã€‚å› æ­¤ï¼Œæˆ‘ä»¬ç”šè‡³ä¸èƒ½åƒä»¥å‰é‚£æ ·ç”¨ä¸€ä¸ªå‚æ•°å†™ä¾‹å­ã€‚æˆ‘ä»¬ä¼šäº‰è¾©è¯´ï¼Œä¸€ä¸ªè‡ªç„¶çš„è§£å†³æ–¹æ¡ˆæ˜¯è¯¢é—®æˆ‘ä»¬æ˜¯å¦å¯ä»¥ä½¿ç”¨æˆ‘ä»¬å·²ç»åœ¨å®šä¹‰çš„è®¡ç®—ä»…ä»æ•°æ®ç»“æ„ä¸­è§£å†³é—®é¢˜ï¼Œå°±åƒæˆ‘ä»¬ä¸Šé¢åšçš„é‚£æ ·ã€‚å¦‚æœæˆ‘ä»¬ä¸èƒ½ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¿…é¡»æ±‚åŠ©äºç´¯åŠ å™¨ã€‚ä½†ç”±äºæˆ‘ä»¬å¯ä»¥ï¼Œç´¯åŠ å™¨åœ¨è¿™é‡Œæ˜¯ä¸å¿…è¦çš„ï¼Œå¹¶ä¸”æå¤§åœ°å¤æ‚äº†ç”šè‡³å†™ä¸‹ä¾‹å­ï¼ˆè¯•è¯•çœ‹ï¼ï¼‰ã€‚
- en: '5.2.9.6Â `uniq`: Why Produce a List?[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)
    "Link to here")'
  id: totrans-1174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.9.6 `uniq`: ä¸ºä»€ä¹ˆç”Ÿæˆä¸€ä¸ªåˆ—è¡¨?[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)
    "é“¾æ¥åˆ°æ­¤å¤„")'
- en: 'If you go back to the original statement of the `uniq` problem [[`uniq`: Problem
    Setup](#%28part._uniq%29)], youâ€™ll notice it said nothing about what order the
    output should have; in fact, it didnâ€™t even say the output needs to be a list
    (and hence have an order). In that case, we should think about whether a list
    even makes sense for this problem. In fact, if we donâ€™t care about order and donâ€™t
    want duplicates (by definition of `uniq`), then there is a much simpler solution,
    which is to produce a set. Pyret already has sets built in, and converting the
    list to a set automatically takes care of duplicates. This is of course cheating
    from the perspective of learning how to write `uniq`, but it is worth remembering
    that sometimes the right data structure to produce isnâ€™t necessarily the same
    as the one we were given. Also, later [[Representing Sets as Lists](sets-from-lists.html)],
    we will see how to build sets for ourselves (at which point, `uniq` will look
    familiar, since it is at the heart of set-ness).'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¦‚æœä½ å›åˆ°`uniq`é—®é¢˜çš„åŸå§‹é™ˆè¿°[[`uniq`: é—®é¢˜è®¾ç½®](#(part._uniq))]ï¼Œä½ ä¼šæ³¨æ„åˆ°å®ƒæ²¡æœ‰æåˆ°è¾“å‡ºåº”è¯¥æœ‰ä»€ä¹ˆé¡ºåºï¼›äº‹å®ä¸Šï¼Œå®ƒç”šè‡³æ²¡æœ‰è¯´è¾“å‡ºéœ€è¦æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼ˆå› æ­¤æœ‰é¡ºåºï¼‰ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åº”è¯¥è€ƒè™‘åˆ—è¡¨å¯¹äºè¿™ä¸ªé—®é¢˜æ˜¯å¦æœ‰æ„ä¹‰ã€‚äº‹å®ä¸Šï¼Œå¦‚æœæˆ‘ä»¬ä¸å…³å¿ƒé¡ºåºå¹¶ä¸”ä¸æƒ³æœ‰é‡å¤ï¼ˆæ ¹æ®`uniq`çš„å®šä¹‰ï¼‰ï¼Œé‚£ä¹ˆæœ‰ä¸€ä¸ªæ›´ç®€å•çš„è§£å†³æ–¹æ¡ˆï¼Œé‚£å°±æ˜¯ç”Ÿæˆä¸€ä¸ªé›†åˆã€‚Pyretå·²ç»å†…ç½®äº†é›†åˆï¼Œå°†åˆ—è¡¨è½¬æ¢ä¸ºé›†åˆä¼šè‡ªåŠ¨å¤„ç†é‡å¤é¡¹ã€‚å½“ç„¶ï¼Œä»å­¦ä¹ å¦‚ä½•ç¼–å†™`uniq`çš„è§’åº¦æ¥çœ‹ï¼Œè¿™æœ‰ç‚¹ä½œå¼Šï¼Œä½†å€¼å¾—è®°ä½çš„æ˜¯ï¼Œæœ‰æ—¶äº§ç”Ÿæ­£ç¡®æ•°æ®ç»“æ„çš„æ–¹æ³•å¹¶ä¸ä¸€å®šæ˜¯æˆ‘ä»¬ç»™å‡ºçš„é‚£ä¸ªã€‚æ­¤å¤–ï¼Œåœ¨[å°†é›†åˆè¡¨ç¤ºä¸ºåˆ—è¡¨](sets-from-lists.html)ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šçœ‹åˆ°å¦‚ä½•è‡ªå·±æ„å»ºé›†åˆï¼ˆåˆ°é‚£æ—¶ï¼Œ`uniq`çœ‹èµ·æ¥ä¼šç†Ÿæ‚‰ï¼Œå› ä¸ºå®ƒå¤„äºé›†åˆçš„æ ¸å¿ƒï¼‰ã€‚'
- en: '5.2.9.1Â `uniq`: Problem Setup[ğŸ”—](#(part._uniq) "Link to here")'
  id: totrans-1176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '5.2.9.1 `uniq`: é—®é¢˜è®¾ç½®[ğŸ”—](#(part._uniq) "é“¾æ¥åˆ°æ­¤å¤„")'
- en: Consider the task of writing `uniq`:uniq is the name of a Unix utility with
    similar behavior; hence the spelling of the name. given a list of values, it produces
    a collection of the same elements while avoiding any duplicates (hence `uniq`,
    short for â€œuniqueâ€).
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘ç¼–å†™`uniq`çš„ä»»åŠ¡ï¼š`uniq`æ˜¯Unixå®ç”¨å·¥å…·çš„ä¸€ä¸ªåç§°ï¼Œå…·æœ‰ç±»ä¼¼çš„è¡Œä¸ºï¼›å› æ­¤ï¼Œåç§°çš„æ‹¼å†™ã€‚ç»™å®šä¸€ä¸ªå€¼åˆ—è¡¨ï¼Œå®ƒäº§ç”Ÿä¸€ä¸ªåŒ…å«ç›¸åŒå…ƒç´ çš„é›†åˆï¼ŒåŒæ—¶é¿å…ä»»ä½•é‡å¤ï¼ˆå› æ­¤ç§°ä¸º`uniq`ï¼Œæ„ä¸ºâ€œå”¯ä¸€â€ï¼‰ã€‚
- en: 'Consider the following input: `[list: 1, 2, 1, 3, 1, 2, 4, 1]`.'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 'è€ƒè™‘ä»¥ä¸‹è¾“å…¥ï¼š`[list: 1, 2, 1, 3, 1, 2, 4, 1]`ã€‚'
- en: Do Now!
  id: totrans-1179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç«‹å³è¡ŒåŠ¨ï¼
- en: ''
  id: totrans-1180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the sequence of examples this input generates? Itâ€™s really important
    you stop and try to do this by hand. As we will see there are multiple solutions,
    and itâ€™s useful for you to consider what you generate. Even if you canâ€™t generate
    a sequence, trying to do so will better prepare you for what you read next.
  id: totrans-1181
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè¾“å…¥ç”Ÿæˆçš„ç¤ºä¾‹åºåˆ—æ˜¯ä»€ä¹ˆï¼Ÿè¿™éå¸¸é‡è¦ï¼Œä½ éœ€è¦åœä¸‹æ¥å°è¯•æ‰‹åŠ¨å®Œæˆã€‚æ­£å¦‚æˆ‘ä»¬å°†çœ‹åˆ°çš„ï¼Œæœ‰å¤šä¸ªè§£å†³æ–¹æ¡ˆï¼Œè€ƒè™‘ä½ ç”Ÿæˆçš„è§£å†³æ–¹æ¡ˆæ˜¯æœ‰ç”¨çš„ã€‚å³ä½¿ä½ ä¸èƒ½ç”Ÿæˆä¸€ä¸ªåºåˆ—ï¼Œå°è¯•è¿™æ ·åšä¹Ÿä¼šæ›´å¥½åœ°ä¸ºä½ é˜…è¯»ä¸‹ä¸€éƒ¨åˆ†åšå¥½å‡†å¤‡ã€‚
- en: How did you obtain your example? If you just â€œthought about it for a moment
    and wrote something downâ€, you may or may not have gotten something you can turn
    into a program. Programs can only proceed systematically; they canâ€™t â€œthinkâ€.
    So, hopefully you took a well-defined path to computing the answer.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æ˜¯å¦‚ä½•å¾—åˆ°ä½ çš„ç¤ºä¾‹çš„ï¼Ÿå¦‚æœä½ åªæ˜¯â€œæ€è€ƒäº†ä¸€ä¼šå„¿å¹¶å†™ä¸‹æ¥â€ï¼Œä½ å¯èƒ½å¾—åˆ°äº†å¯ä»¥è½¬åŒ–ä¸ºç¨‹åºçš„ä¸œè¥¿ï¼Œä¹Ÿå¯èƒ½æ²¡æœ‰ã€‚ç¨‹åºåªèƒ½ç³»ç»Ÿåœ°æ‰§è¡Œï¼›å®ƒä»¬ä¸èƒ½â€œæ€è€ƒâ€ã€‚æ‰€ä»¥ï¼Œå¸Œæœ›ä½ å·²ç»é‡‡å–äº†ä¸€ä¸ªæ˜ç¡®çš„è·¯å¾„æ¥è®¡ç®—ç­”æ¡ˆã€‚
- en: '5.2.9.2Â `uniq`: Examples[ğŸ”—](#(part._uniq-eg) "Link to here")'
  id: totrans-1183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.9.2 `uniq`ï¼šç¤ºä¾‹[ğŸ”—](#(part._uniq-eg) "é“¾æ¥åˆ°è¿™é‡Œ")
- en: It turns out there are several possible answers, because we have (intentionally)
    left the problem unspecified. Suppose there are two instances of a value in the
    list; which one do we keep, the first or the second? On the one hand, since the
    two instances must be equivalent it doesnâ€™t matter, but it does for writing concrete
    examples and deriving a solution.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœè¡¨æ˜æœ‰å¤šä¸ªå¯èƒ½çš„ç­”æ¡ˆï¼Œå› ä¸ºæˆ‘ä»¬ï¼ˆæ•…æ„ï¼‰æ²¡æœ‰å…·ä½“è¯´æ˜é—®é¢˜ã€‚å‡è®¾åˆ—è¡¨ä¸­æœ‰ä¸¤ä¸ªç›¸åŒå€¼çš„å®ä¾‹ï¼›æˆ‘ä»¬ä¿ç•™å“ªä¸€ä¸ªï¼Œç¬¬ä¸€ä¸ªè¿˜æ˜¯ç¬¬äºŒä¸ªï¼Ÿä¸€æ–¹é¢ï¼Œç”±äºè¿™ä¸¤ä¸ªå®ä¾‹å¿…é¡»ç­‰æ•ˆï¼Œæ‰€ä»¥è¿™å¹¶ä¸é‡è¦ï¼Œä½†åœ¨ç¼–å†™å…·ä½“ç¤ºä¾‹å’Œæ¨å¯¼è§£å†³æ–¹æ¡ˆæ—¶ï¼Œè¿™å¾ˆé‡è¦ã€‚
- en: 'For instance, you might have generated this sequence:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œä½ å¯èƒ½å·²ç»ç”Ÿæˆäº†ä»¥ä¸‹åºåˆ—ï¼š
- en: '[PRE249]'
  id: totrans-1186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: However, you might have also generated sequences that began with
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œä½ ä¹Ÿå¯èƒ½ç”Ÿæˆäº†ä»¥ä»¥ä¸‹å†…å®¹å¼€å§‹çš„åºåˆ—ï¼š
- en: '[PRE250]'
  id: totrans-1188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: or
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…
- en: '[PRE251]'
  id: totrans-1190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: and so on. Letâ€™s work with the examples weâ€™ve worked out above.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: ç­‰ç­‰ã€‚è®©æˆ‘ä»¬å¤„ç†æˆ‘ä»¬ä¸Šé¢å·²ç»è§£å†³çš„é—®é¢˜ã€‚
- en: '5.2.9.3Â `uniq`: Code[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)
    "Link to here")'
  id: totrans-1192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.9.3 `uniq`ï¼šä»£ç [ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Code)
    "é“¾æ¥åˆ°è¿™é‡Œ")
- en: 'What is the systematic approach that gets us to this answer? When given a non-empty
    list, we split it into its first element and the rest of the list. Suppose we
    have the answer to `uniq` applied to the rest of the list. Now we can ask: is
    the first element in the rest of the list? If it is, then we can ignore it, since
    it is certain to be in the `uniq` of the rest of the list. If, however, it is
    not in the rest of the list, itâ€™s critical that we `link` it to the answer.'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åˆ°è¾¾è¿™ä¸ªç­”æ¡ˆçš„ç³»ç»Ÿæ–¹æ³•æ˜¯ä»€ä¹ˆï¼Ÿå½“ç»™å®šä¸€ä¸ªéç©ºåˆ—è¡¨æ—¶ï¼Œæˆ‘ä»¬å°†å…¶åˆ†ä¸ºå…¶ç¬¬ä¸€ä¸ªå…ƒç´ å’Œåˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†ã€‚å‡è®¾æˆ‘ä»¬å·²ç»å¯¹åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†åº”ç”¨äº†`uniq`ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥é—®ï¼šç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¦åœ¨åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†ä¸­ï¼Ÿå¦‚æœæ˜¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å¿½ç•¥å®ƒï¼Œå› ä¸ºå®ƒè‚¯å®šä¼šåœ¨åˆ—è¡¨çš„`uniq`ä¸­ã€‚å¦‚æœä¸æ˜¯ï¼Œé‚£ä¹ˆå°†è¿™ä¸ªå…ƒç´ `link`åˆ°ç­”æ¡ˆä¸­æ˜¯è‡³å…³é‡è¦çš„ã€‚
- en: This translates into the following program. For the empty list, we return the
    empty list. If the list is non-empty, we check whether the first is in the rest
    of the list. If it is not, we include it; otherwise we can ignore it for now.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯ä»¥è½¬æ¢ä¸ºä»¥ä¸‹ç¨‹åºã€‚å¯¹äºç©ºåˆ—è¡¨ï¼Œæˆ‘ä»¬è¿”å›ç©ºåˆ—è¡¨ã€‚å¦‚æœåˆ—è¡¨éç©ºï¼Œæˆ‘ä»¬æ£€æŸ¥ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¦åœ¨åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†ä¸­ã€‚å¦‚æœä¸æ˜¯ï¼Œæˆ‘ä»¬å°†å…¶åŒ…æ‹¬åœ¨å†…ï¼›å¦åˆ™ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥å¿½ç•¥å®ƒã€‚
- en: 'This results in the following program:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯¼è‡´ä»¥ä¸‹ç¨‹åºï¼š
- en: '[PRE252]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: which weâ€™ve called `uniq-rec` instead of `uniq` to differentiate it from other
    versions of `uniq`.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†å…¶ç§°ä¸º`uniq-rec`è€Œä¸æ˜¯`uniq`ï¼Œä»¥åŒºåˆ†å…¶ä»–ç‰ˆæœ¬çš„`uniq`ã€‚
- en: Exercise
  id: totrans-1198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-1199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that weâ€™re using `.member` to check whether an element is a member of the
    list. Write a function `member` that consumes an element and a list, and tells
    us whether the element is a member of the list.
  id: totrans-1200
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬æ­£åœ¨ä½¿ç”¨`.member`æ¥æ£€æŸ¥ä¸€ä¸ªå…ƒç´ æ˜¯å¦æ˜¯åˆ—è¡¨çš„æˆå‘˜ã€‚ç¼–å†™ä¸€ä¸ªå‡½æ•°`member`ï¼Œå®ƒæ¥å—ä¸€ä¸ªå…ƒç´ å’Œä¸€ä¸ªåˆ—è¡¨ï¼Œå¹¶å‘Šè¯‰æˆ‘ä»¬è¯¥å…ƒç´ æ˜¯å¦æ˜¯åˆ—è¡¨çš„æˆå‘˜ã€‚
- en: Exercise
  id: totrans-1201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-1202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Uniqueness checking has many practical applications. For example, one might
    have a list of names of people who have registered to vote in an election. To
    keep the voting fair, with only one vote allowed per person, we should remove
    duplicate names from the list.
  id: totrans-1203
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å”¯ä¸€æ€§æ£€æŸ¥æœ‰è®¸å¤šå®é™…åº”ç”¨ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªäººå¯èƒ½æœ‰ä¸€ä»½æ³¨å†Œå‚åŠ é€‰ä¸¾çš„äººåçš„åˆ—è¡¨ã€‚ä¸ºäº†ä¿æŒé€‰ä¸¾çš„å…¬å¹³æ€§ï¼Œæ¯äººåªèƒ½æŠ•ä¸€ç¥¨ï¼Œæˆ‘ä»¬åº”è¯¥ä»åˆ—è¡¨ä¸­åˆ é™¤é‡å¤çš„åå­—ã€‚
- en: ''
  id: totrans-1204
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Propose a set of examples for a function `rem-duplicate-voters` that takes a
    list of voter names and returns a list in which duplicate registrations have been
    removed. In developing your examples, consider real-world scenarios that you can
    imagine arising when identifying duplicate names. Can you identify cases in which
    two names might appear to be the same person, but not be? Cases in which two names
    might appear different but be referring to the same person?
  id: totrans-1205
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: æå‡ºä¸€ç»„ç¤ºä¾‹ï¼Œç”¨äºä¸€ä¸ªåä¸º`rem-duplicate-voters`çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªæŠ•ç¥¨è€…åå•åˆ—è¡¨ï¼Œå¹¶è¿”å›ä¸€ä¸ªå·²ç§»é™¤é‡å¤æ³¨å†Œçš„åå•åˆ—è¡¨ã€‚åœ¨å¼€å‘ä½ çš„ç¤ºä¾‹æ—¶ï¼Œè¯·è€ƒè™‘åœ¨è¯†åˆ«é‡å¤åç§°æ—¶å¯èƒ½å‡ºç°çš„ç°å®ä¸–ç•Œåœºæ™¯ã€‚ä½ èƒ½è¯†åˆ«å‡ºä¸¤ç§åç§°å¯èƒ½çœ‹èµ·æ¥æ˜¯åŒä¸€ä¸ªäººï¼Œä½†å®é™…ä¸Šä¸æ˜¯çš„æƒ…å†µå—ï¼Ÿä¸¤ç§åç§°å¯èƒ½çœ‹èµ·æ¥ä¸åŒï¼Œä½†å®é™…ä¸Šæ˜¯æŒ‡åŒä¸€ä¸ªäººçš„æƒ…å†µå—ï¼Ÿ
- en: ''
  id: totrans-1206
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1207
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: What might you need to change about our current `uniq-rec` function to handle
    a situation like removing duplicate voters?
  id: totrans-1208
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½éœ€è¦å¯¹æˆ‘ä»¬å½“å‰çš„`uniq-rec`å‡½æ•°è¿›è¡Œå“ªäº›ä¿®æ”¹ï¼Œä»¥å¤„ç†åƒç§»é™¤é‡å¤æŠ•ç¥¨è€…è¿™æ ·çš„æƒ…å†µï¼Ÿ
- en: 'Responsible Computing: Context Matters When Comparing Values'
  id: totrans-1209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: è´Ÿè´£ä»»è®¡ç®—ï¼šæ¯”è¾ƒå€¼æ—¶ï¼Œä¸Šä¸‹æ–‡å¾ˆé‡è¦
- en: ''
  id: totrans-1210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The data de-duplication context in the above exercise reminds us that different
    contexts may call for different notions of when two data values are the same.
    Sometimes, we want exact matching to determine that two strings are equal. Sometimes,
    we need methods that normalize data, either in simple ways like capitalization
    or subtler ways based on middle initials. Sometimes, we need more information
    (like street addresses in addition to names) in order to determine whether two
    items in a list should be considered â€œthe sameâ€.
  id: totrans-1211
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨ä¸Šè¿°ç»ƒä¹ ä¸­çš„æ•°æ®å»é‡ä¸Šä¸‹æ–‡æé†’æˆ‘ä»¬ï¼Œä¸åŒçš„ä¸Šä¸‹æ–‡å¯èƒ½éœ€è¦ä¸åŒçš„å…³äºä¸¤ä¸ªæ•°æ®å€¼ä½•æ—¶ç›¸åŒçš„è§‚å¿µã€‚æœ‰æ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›è¿›è¡Œç²¾ç¡®åŒ¹é…ä»¥ç¡®å®šä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰ã€‚æœ‰æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨æ–¹æ³•æ¥è§„èŒƒåŒ–æ•°æ®ï¼Œæ— è®ºæ˜¯ç®€å•çš„æ–¹å¼ï¼ˆå¦‚å¤§å†™å­—æ¯ï¼‰è¿˜æ˜¯åŸºäºä¸­é—´åé¦–å­—æ¯çš„å¾®å¦™æ–¹å¼ã€‚æœ‰æ—¶ï¼Œæˆ‘ä»¬éœ€è¦æ›´å¤šä¿¡æ¯ï¼ˆå¦‚é™¤äº†å§“åä¹‹å¤–è¿˜æœ‰è¡—é“åœ°å€ï¼‰æ¥ç¡®å®šåˆ—è¡¨ä¸­çš„ä¸¤ä¸ªé¡¹ç›®æ˜¯å¦åº”è¢«è§†ä¸ºâ€œç›¸åŒâ€ã€‚
- en: ''
  id: totrans-1212
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is easy to write programs that encode assumptions about our data that might
    not apply in practice. This is again a situation that can be helped by thinking
    about the concrete examples on which your code needs to work in context.
  id: totrans-1213
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç¼–å†™å‡è®¾æˆ‘ä»¬æ•°æ®å¯èƒ½ä¸é€‚ç”¨äºå®è·µçš„ç¨‹åºçš„ä»£ç å¾ˆå®¹æ˜“ã€‚è¿™åˆæ˜¯ä¸€ä¸ªå¯ä»¥é€šè¿‡è€ƒè™‘ä»£ç åœ¨ä¸Šä¸‹æ–‡ä¸­éœ€è¦å·¥ä½œçš„å…·ä½“ç¤ºä¾‹æ¥å¸®åŠ©çš„æƒ…å†µã€‚
- en: '5.2.9.4Â `uniq`: Reducing Computation[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)
    "Link to here")'
  id: totrans-1214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.9.4Â `uniq`ï¼šå‡å°‘è®¡ç®—[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Reducing_.Computation)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'Notice that this function has a repeated expression. Instead of writing it
    twice, we could call it just once and use the result in both places:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°è¿™ä¸ªå‡½æ•°æœ‰ä¸€ä¸ªé‡å¤çš„è¡¨è¾¾å¼ã€‚æˆ‘ä»¬ä¸å¿…å†™ä¸¤æ¬¡ï¼Œåªéœ€è°ƒç”¨ä¸€æ¬¡ï¼Œå¹¶åœ¨ä¸¤ä¸ªåœ°æ–¹ä½¿ç”¨ç»“æœï¼š
- en: '[PRE253]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: You might think, because we replaced two function calls with one, that weâ€™ve
    reduced the amount of computation the program does. It does not! The two function
    calls are both in the two branches of the same conditional; therefore, for any
    given list element, only one or the other call to `uniq` happens. In fact, in
    both cases, there was one call to `uniq` before, and there is one now. So we have
    reduced the number of calls in the source program, but not the number that take
    place when the program runs. In that sense, the name of this section was intentionally
    misleading!
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½ä¼šè®¤ä¸ºï¼Œå› ä¸ºæˆ‘ä»¬ç”¨ä¸€æ¬¡å‡½æ•°è°ƒç”¨æ›¿æ¢äº†ä¸¤æ¬¡ï¼Œæ‰€ä»¥å‡å°‘äº†ç¨‹åºçš„è®¡ç®—é‡ã€‚ä½†è¿™å¹¶ä¸æ­£ç¡®ï¼è¿™ä¸¤ä¸ªå‡½æ•°è°ƒç”¨éƒ½åœ¨åŒä¸€ä¸ªæ¡ä»¶è¯­å¥çš„ä¸¤ä¸ªåˆ†æ”¯ä¸­ï¼›å› æ­¤ï¼Œå¯¹äºä»»ä½•ç»™å®šçš„åˆ—è¡¨å…ƒç´ ï¼Œåªä¼šå‘ç”Ÿä¸€æ¬¡æˆ–å¦ä¸€æ¬¡å¯¹`uniq`çš„è°ƒç”¨ã€‚å®é™…ä¸Šï¼Œåœ¨ä¸¤ç§æƒ…å†µä¸‹ï¼Œä¹‹å‰éƒ½è°ƒç”¨äº†ä¸€æ¬¡`uniq`ï¼Œç°åœ¨ä¹Ÿæ˜¯ã€‚æ‰€ä»¥æˆ‘ä»¬åœ¨æºç¨‹åºä¸­å‡å°‘äº†è°ƒç”¨æ¬¡æ•°ï¼Œä½†å¹¶æ²¡æœ‰å‡å°‘ç¨‹åºè¿è¡Œæ—¶çš„è°ƒç”¨æ¬¡æ•°ã€‚ä»è¿™ä¸ªæ„ä¹‰ä¸Šè¯´ï¼Œè¿™ä¸ªç« èŠ‚çš„åç§°æ•…æ„å…·æœ‰è¯¯å¯¼æ€§ï¼
- en: 'However, there is one useful reduction we can perform, which is enabled by
    the structure of `uniq-rec2`. We currently check whether `f` is a member of `r`,
    which is the list of all the remaining elements. In our example, this means that
    in the very second turn, we check whether `2` is a member of the list `[list:
    1, 3, 1, 2, 4, 1]`. This is a list of six elements, including three copies of
    `1`. We compare `2` against two copies of `1`. However, we gain nothing from the
    second comparison. Put differently, we can think of `uniq(r)` as a â€œsummaryâ€ of
    the rest of the list that is exactly as good as `r` itself for checking membership,
    with the advantage that it might be significantly shorter. This, of course, is
    exactly what `ur` represents. Therefore, we can encode this intuition as follows:'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 'ç„¶è€Œï¼Œæœ‰ä¸€ä¸ªæœ‰ç”¨çš„ç®€åŒ–æˆ‘ä»¬å¯ä»¥æ‰§è¡Œï¼Œè¿™æ˜¯ç”±`uniq-rec2`çš„ç»“æ„æ‰€å¯ç”¨çš„ã€‚æˆ‘ä»¬ç›®å‰æ£€æŸ¥`f`æ˜¯å¦æ˜¯`r`çš„æˆå‘˜ï¼Œ`r`æ˜¯æ‰€æœ‰å‰©ä½™å…ƒç´ çš„åˆ—è¡¨ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œè¿™æ„å‘³ç€åœ¨ç¬¬äºŒæ¬¡è¿­ä»£æ—¶ï¼Œæˆ‘ä»¬æ£€æŸ¥`2`æ˜¯å¦æ˜¯åˆ—è¡¨`[list:
    1, 3, 1, 2, 4, 1]`çš„æˆå‘˜ã€‚è¿™æ˜¯ä¸€ä¸ªåŒ…å«ä¸‰ä¸ª`1`å‰¯æœ¬çš„å…­ä¸ªå…ƒç´ çš„åˆ—è¡¨ã€‚æˆ‘ä»¬å°†`2`ä¸ä¸¤ä¸ª`1`è¿›è¡Œæ¯”è¾ƒã€‚ç„¶è€Œï¼Œç¬¬äºŒæ¬¡æ¯”è¾ƒæˆ‘ä»¬æ²¡æœ‰å¾—åˆ°ä»»ä½•ä¸œè¥¿ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥å°†`uniq(r)`è§†ä¸ºåˆ—è¡¨å…¶ä½™éƒ¨åˆ†çš„â€œæ‘˜è¦â€ï¼Œå®ƒåœ¨æ£€æŸ¥æˆå‘˜èµ„æ ¼æ–¹é¢ä¸`r`æœ¬èº«ä¸€æ ·å¥½ï¼Œè€Œä¸”å®ƒå¯èƒ½æ˜¾è‘—æ›´çŸ­ã€‚å½“ç„¶ï¼Œè¿™æ­£æ˜¯`ur`æ‰€ä»£è¡¨çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™ç§ç›´è§‰ç¼–ç å¦‚ä¸‹ï¼š'
- en: '[PRE254]'
  id: totrans-1219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Note that all that changed is that we check for membership in `ur` rather than
    in `r`.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå”¯ä¸€æ”¹å˜çš„æ˜¯æˆ‘ä»¬æ£€æŸ¥`ur`ä¸­çš„æˆå‘˜èµ„æ ¼è€Œä¸æ˜¯`r`ä¸­çš„ã€‚
- en: Exercise
  id: totrans-1221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-1222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Later [[Predicting Growth](predicting-growth.html)] we will study how to formally
    study how long a program takes to run. By the measure introduced in that section,
    does the change we just made make any difference? Be careful with your answer:
    it depends on how we count â€œthe lengthâ€ of the list.'
  id: totrans-1223
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åœ¨åç»­çš„[[é¢„æµ‹å¢é•¿](predicting-growth.html)]ä¸­ï¼Œæˆ‘ä»¬å°†ç ”ç©¶å¦‚ä½•æ­£å¼ç ”ç©¶ç¨‹åºè¿è¡Œæ‰€éœ€çš„æ—¶é—´ã€‚æ ¹æ®è¯¥èŠ‚ä¸­å¼•å…¥çš„åº¦é‡æ ‡å‡†ï¼Œæˆ‘ä»¬åˆšæ‰æ‰€åšçš„æ›´æ”¹æ˜¯å¦æœ‰æ‰€å½±å“ï¼Ÿè¯·æ³¨æ„æ‚¨çš„ç­”æ¡ˆï¼šè¿™å–å†³äºæˆ‘ä»¬å¦‚ä½•è®¡ç®—â€œé•¿åº¦â€ã€‚
- en: Observe that if the list never contained duplicates in the first place, then
    it wouldnâ€™t matter which list we check membership inâ€”<wbr>but if we knew the list
    didnâ€™t contain duplicates, we wouldnâ€™t be using `uniq` in the first place! We
    will return to the issue of lists and duplicate elements in [Representing Sets
    as Lists](sets-from-lists.html).
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°ï¼Œå¦‚æœåˆ—è¡¨ä¸€å¼€å§‹å°±æ²¡æœ‰é‡å¤é¡¹ï¼Œé‚£ä¹ˆæ£€æŸ¥å“ªä¸ªåˆ—è¡¨ä¸­çš„æˆå‘˜èµ„æ ¼å°±æ— å…³ç´§è¦äº†â€”â€”<wbr>ä½†å¦‚æœæˆ‘ä»¬çŸ¥é“åˆ—è¡¨ä¸­æ²¡æœ‰é‡å¤é¡¹ï¼Œæˆ‘ä»¬ä¸€å¼€å§‹å°±ä¸ä¼šä½¿ç”¨`uniq`ï¼æˆ‘ä»¬å°†åœ¨[è¡¨ç¤ºåˆ—è¡¨ä½œä¸ºé›†åˆ](sets-from-lists.html)ä¸­è¿”å›åˆ°åˆ—è¡¨å’Œé‡å¤å…ƒç´ çš„é—®é¢˜ã€‚
- en: '5.2.9.5Â `uniq`: Example and Code Variations[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)
    "Link to here")'
  id: totrans-1225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.9.5Â `uniq`ï¼šç¤ºä¾‹å’Œä»£ç å˜åŒ–[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Example_and_.Code_.Variations)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'As we mentioned earlier, there are other example sequences you might have written
    down. Hereâ€™s a very different process:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æˆ‘ä»¬ä¹‹å‰æåˆ°çš„ï¼Œä½ å¯èƒ½å·²ç»å†™ä¸‹äº†å…¶ä»–ç¤ºä¾‹åºåˆ—ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªéå¸¸ä¸åŒçš„è¿‡ç¨‹ï¼š
- en: Start with the entire given list and with the empty answer (so far).
  id: totrans-1227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»æ•´ä¸ªç»™å®šçš„åˆ—è¡¨å’Œç©ºç­”æ¡ˆï¼ˆåˆ°ç›®å‰ä¸ºæ­¢ï¼‰å¼€å§‹ã€‚
- en: For each list element, check whether itâ€™s already in the answer so far. If it
    is, ignore it, otherwise extend the answer with it.
  id: totrans-1228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºåˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦å·²ç»åœ¨ç›®å‰çš„ç­”æ¡ˆä¸­ã€‚å¦‚æœæ˜¯ï¼Œå¿½ç•¥å®ƒï¼Œå¦åˆ™ç”¨å®ƒæ‰©å±•ç­”æ¡ˆã€‚
- en: When there are no more elements in the list, the answer so far is the answer
    for the whole list.
  id: totrans-1229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“åˆ—è¡¨ä¸­æ²¡æœ‰æ›´å¤šå…ƒç´ æ—¶ï¼Œç›®å‰çš„ç­”æ¡ˆå°±æ˜¯æ•´ä¸ªåˆ—è¡¨çš„ç­”æ¡ˆã€‚
- en: Notice that this solution assumes that we will be accumulating the answer as
    we traverse the list. Therefore, we canâ€™t even write the example with one parameter
    as we did before. We would argue that a natural solution asks whether we can solve
    the problem just from the structure of the data using the computation we are already
    defining, as we did above. If we cannot, then we have to resort to an accumulator.
    But because we can, the accumulator is unnecessary here and greatly complicates
    even writing down examples (give it a try!).
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œè¿™ä¸ªè§£å†³æ–¹æ¡ˆå‡è®¾æˆ‘ä»¬å°†åœ¨éå†åˆ—è¡¨æ—¶ç´¯ç§¯ç­”æ¡ˆã€‚å› æ­¤ï¼Œæˆ‘ä»¬ç”šè‡³ä¸èƒ½åƒä¹‹å‰é‚£æ ·ç”¨ä¸€ä¸ªå‚æ•°ç¼–å†™ç¤ºä¾‹ã€‚æˆ‘ä»¬ä¼šäº‰è¾©è¯´ï¼Œä¸€ä¸ªè‡ªç„¶çš„è§£å†³æ–¹æ¡ˆæ˜¯è¯¢é—®æˆ‘ä»¬æ˜¯å¦å¯ä»¥ä»…ä½¿ç”¨æˆ‘ä»¬å·²ç»åœ¨å®šä¹‰çš„è®¡ç®—ä»æ•°æ®ç»“æ„ä¸­è§£å†³é—®é¢˜ï¼Œå°±åƒæˆ‘ä»¬ä¸Šé¢åšçš„é‚£æ ·ã€‚å¦‚æœæˆ‘ä»¬ä¸èƒ½ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¿…é¡»æ±‚åŠ©äºç´¯åŠ å™¨ã€‚ä½†ç”±äºæˆ‘ä»¬å¯ä»¥ï¼Œç´¯åŠ å™¨åœ¨è¿™é‡Œæ˜¯ä¸å¿…è¦çš„ï¼Œå¹¶ä¸”æå¤§åœ°å¤æ‚äº†ç¤ºä¾‹çš„ç¼–å†™ï¼ˆè¯•ä¸€è¯•ï¼ï¼‰
- en: '5.2.9.6Â `uniq`: Why Produce a List?[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)
    "Link to here")'
  id: totrans-1231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2.9.6Â `uniq`ï¼šä¸ºä»€ä¹ˆäº§ç”Ÿä¸€ä¸ªåˆ—è¡¨?[ğŸ”—](#(part.___struct_traverse-element___procedure____lib_render-cond_rkt_38_12____.Why_.Produce_a_.List_)
    "é“¾æ¥åˆ°æ­¤å¤„")
- en: 'If you go back to the original statement of the `uniq` problem [[`uniq`: Problem
    Setup](#%28part._uniq%29)], youâ€™ll notice it said nothing about what order the
    output should have; in fact, it didnâ€™t even say the output needs to be a list
    (and hence have an order). In that case, we should think about whether a list
    even makes sense for this problem. In fact, if we donâ€™t care about order and donâ€™t
    want duplicates (by definition of `uniq`), then there is a much simpler solution,
    which is to produce a set. Pyret already has sets built in, and converting the
    list to a set automatically takes care of duplicates. This is of course cheating
    from the perspective of learning how to write `uniq`, but it is worth remembering
    that sometimes the right data structure to produce isnâ€™t necessarily the same
    as the one we were given. Also, later [[Representing Sets as Lists](sets-from-lists.html)],
    we will see how to build sets for ourselves (at which point, `uniq` will look
    familiar, since it is at the heart of set-ness).'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¦‚æœä½ å›åˆ°`uniq`é—®é¢˜çš„åŸå§‹é™ˆè¿°[[`uniq`: é—®é¢˜è®¾ç½®](#%28part._uniq%29)]ï¼Œä½ ä¼šæ³¨æ„åˆ°å®ƒæ²¡æœ‰æåˆ°è¾“å‡ºåº”è¯¥æœ‰ä»€ä¹ˆé¡ºåºï¼›äº‹å®ä¸Šï¼Œå®ƒç”šè‡³æ²¡æœ‰è¯´è¾“å‡ºéœ€è¦æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼ˆå› æ­¤æœ‰é¡ºåºï¼‰ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åº”è¯¥è€ƒè™‘åˆ—è¡¨æ˜¯å¦é€‚åˆè¿™ä¸ªé—®é¢˜ã€‚äº‹å®ä¸Šï¼Œå¦‚æœæˆ‘ä»¬ä¸å…³å¿ƒé¡ºåºå¹¶ä¸”ä¸æƒ³æœ‰é‡å¤ï¼ˆæ ¹æ®`uniq`çš„å®šä¹‰ï¼‰ï¼Œé‚£ä¹ˆæœ‰ä¸€ä¸ªæ›´ç®€å•çš„è§£å†³æ–¹æ¡ˆï¼Œé‚£å°±æ˜¯ç”Ÿæˆä¸€ä¸ªé›†åˆã€‚Pyretå·²ç»å†…ç½®äº†é›†åˆï¼Œå°†åˆ—è¡¨è½¬æ¢ä¸ºé›†åˆä¼šè‡ªåŠ¨å¤„ç†é‡å¤é¡¹ã€‚å½“ç„¶ï¼Œä»å­¦ä¹ å¦‚ä½•ç¼–å†™`uniq`çš„è§’åº¦æ¥çœ‹ï¼Œè¿™æœ‰ç‚¹ä½œå¼Šï¼Œä½†å€¼å¾—è®°ä½çš„æ˜¯ï¼Œæœ‰æ—¶äº§ç”Ÿæ­£ç¡®æ•°æ®ç»“æ„çš„æ–¹æ³•å¹¶ä¸ä¸€å®šæ˜¯æˆ‘ä»¬ç»™å‡ºçš„é‚£ä¸ªã€‚æ­¤å¤–ï¼Œåœ¨[[å°†é›†åˆè¡¨ç¤ºä¸ºåˆ—è¡¨](sets-from-lists.html)]ä¸­ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°å¦‚ä½•è‡ªå·±æ„å»ºé›†åˆï¼ˆåˆ°é‚£æ—¶ï¼Œ`uniq`å°†çœ‹èµ·æ¥å¾ˆç†Ÿæ‚‰ï¼Œå› ä¸ºå®ƒå¤„äºé›†åˆçš„æ ¸å¿ƒï¼‰ã€‚'
- en: 5.2.10Â Monomorphic Lists and Polymorphic Types[ğŸ”—](#(part._polymorphic-data)
    "Link to here")
  id: totrans-1233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.10 å•æ€å‹åˆ—è¡¨å’Œå¤šæ€å‹ç±»å‹[ğŸ”—](#(part._polymorphic-data) "é“¾æ¥è‡³æ­¤")
- en: 'Earlier we wrote contracts like:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹‹å‰æˆ‘ä»¬ç¼–å†™äº†å¦‚ä¸‹åˆçº¦ï¼š
- en: '[PRE255]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'These are unsatisfying for several reasons. Consider `my-max`. The contract
    suggests that any kind of element can be in the input list, but in fact that isnâ€™t
    true: the input `[list: 1, "two", 3]` is not valid, because we canâ€™t compare `1`
    with `"two"` or `"two"` with `3`.'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 'è¿™äº›åˆçº¦å­˜åœ¨å‡ ä¸ªä¸ä»¤äººæ»¡æ„çš„åŸå› ã€‚ä»¥`my-max`ä¸ºä¾‹ã€‚åˆçº¦æš—ç¤ºä»»ä½•ç±»å‹çš„å…ƒç´ éƒ½å¯ä»¥åœ¨è¾“å…¥åˆ—è¡¨ä¸­ï¼Œä½†å®é™…ä¸Šå¹¶éå¦‚æ­¤ï¼šè¾“å…¥`[list: 1, "two",
    3]`æ˜¯æ— æ•ˆçš„ï¼Œå› ä¸ºæˆ‘ä»¬ä¸èƒ½æ¯”è¾ƒ`1`ä¸`"two"`æˆ–`"two"`ä¸`3`ã€‚'
- en: Exercise
  id: totrans-1237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 
- en: ''
  id: totrans-1238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if we run `1 > "two"` or `"two" > 3`?
  id: totrans-1239
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬è¿è¡Œ`1 > "two"`æˆ–`"two" > 3`ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- en: 'Rather, what we mean is a list where all the elements are of the same kind,Technically,
    elements that are also comparable. and the contract has not captured that. Furthermore,
    we donâ€™t mean that `my-max` might return any old type: if we supply it with a
    list of numbers, we will not get a string as the maximum element! Rather, it will
    only return the kind of element that is in the provided list.'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åï¼Œæˆ‘ä»¬çš„æ„æ€æ˜¯æ‰€æœ‰å…ƒç´ éƒ½æ˜¯åŒä¸€ç±»å‹çš„åˆ—è¡¨ï¼ŒæŠ€æœ¯ä¸Šè®²ï¼Œè¿™äº›å…ƒç´ ä¹Ÿæ˜¯å¯æ¯”è¾ƒçš„ï¼Œè€Œåˆçº¦å¹¶æ²¡æœ‰æ•æ‰åˆ°è¿™ä¸€ç‚¹ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å¹¶ä¸æ˜¯è¯´`my-max`å¯èƒ½ä¼šè¿”å›ä»»ä½•æ—§ç±»å‹ï¼šå¦‚æœæˆ‘ä»¬å‘å®ƒæä¾›ä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œæˆ‘ä»¬ä¸ä¼šå¾—åˆ°ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºæœ€å¤§å…ƒç´ ï¼ç›¸åï¼Œå®ƒåªä¼šè¿”å›åˆ—è¡¨ä¸­å­˜åœ¨çš„å…ƒç´ ç±»å‹ã€‚
- en: 'In short, we mean that all elements of the list are of the same type, but they
    can be of any type. We call the former monomorphic: â€œmonoâ€ meaning one, and â€œmorphicâ€
    meaning shape, i.e., all values have one type. But the function `my-max` itself
    can operate over many of these kinds of lists, so we call it polymorphic (â€œpolyâ€
    meaning many).'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: ç®€è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬çš„æ„æ€æ˜¯åˆ—è¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½æ˜¯åŒä¸€ç±»å‹ï¼Œä½†å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ã€‚æˆ‘ä»¬ç§°å‰è€…ä¸ºå•æ€å‹ï¼šâ€œmonoâ€æ„å‘³ç€ä¸€ä¸ªï¼Œè€Œâ€œmorphicâ€æ„å‘³ç€å½¢çŠ¶ï¼Œå³æ‰€æœ‰å€¼éƒ½åªæœ‰ä¸€ä¸ªç±»å‹ã€‚ä½†å‡½æ•°`my-max`æœ¬èº«å¯ä»¥æ“ä½œè®¸å¤šè¿™ç±»åˆ—è¡¨ï¼Œæ‰€ä»¥æˆ‘ä»¬ç§°å®ƒä¸ºå¤šæ€å‹ï¼ˆâ€œpolyâ€æ„å‘³ç€è®¸å¤šï¼‰ã€‚
- en: 'Therefore, we need a better way of writing these contracts. Essentially, we
    want to say that there is a type variable (as opposed to regular program variable)
    that represents the type of element in the list. Given that type, `my-max` will
    return an element of that type. We write this syntactically as follows:'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§æ›´å¥½çš„æ–¹å¼æ¥ç¼–å†™è¿™äº›åˆçº¦ã€‚æœ¬è´¨ä¸Šï¼Œæˆ‘ä»¬æƒ³è¦è¡¨è¾¾çš„æ˜¯å­˜åœ¨ä¸€ä¸ªç±»å‹å˜é‡ï¼ˆä¸å¸¸è§„ç¨‹åºå˜é‡ç›¸å¯¹ï¼‰ï¼Œå®ƒä»£è¡¨åˆ—è¡¨ä¸­å…ƒç´ çš„ç±»å‹ã€‚ç»™å®šè¿™ç§ç±»å‹ï¼Œ`my-max`å°†è¿”å›è¯¥ç±»å‹çš„å…ƒç´ ã€‚æˆ‘ä»¬æŒ‰ç…§ä»¥ä¸‹è¯­æ³•æ¥ç¼–å†™ï¼š
- en: '[PRE256]'
  id: totrans-1243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: The notation `<T>` says that `T` is a type variable parameter that will be used
    in the rest of the function (both the header and the body).
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¦å·`<T>`è¡¨ç¤º`T`æ˜¯ä¸€ä¸ªç±»å‹å˜é‡å‚æ•°ï¼Œå®ƒå°†åœ¨å‡½æ•°çš„å…¶ä½™éƒ¨åˆ†ï¼ˆåŒ…æ‹¬å¤´å’Œä½“ï¼‰ä¸­ä½¿ç”¨ã€‚
- en: 'Using this notation, we can also revisit `my-len`. Its header now becomes:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ç§ç¬¦å·ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥å›é¡¾`my-len`ã€‚å®ƒçš„å¤´ç°åœ¨å˜ä¸ºï¼š
- en: '[PRE257]'
  id: totrans-1246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'Note that `my-len` did not actually â€œcareâ€ that whether all the values were
    of the same type or not: it never looks at the individual elements, much less
    at pairs of them. However, as a convention we demand that lists always be monomorphic.
    This is important because it enables us to process the elements of the list uniformly:
    if we know how to process elements of type `T`, then we will know how to process
    a `List<T>`. If the list elements can be of truly any old type, we canâ€™t know
    how to process its elements.'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„åˆ°`my-len`å®é™…ä¸Šå¹¶ä¸â€œå…³å¿ƒâ€æ‰€æœ‰å€¼æ˜¯å¦ä¸ºåŒä¸€ç±»å‹ï¼šå®ƒä»ä¸æŸ¥çœ‹å•ä¸ªå…ƒç´ ï¼Œæ›´ä¸ç”¨è¯´æˆå¯¹çš„å…ƒç´ äº†ã€‚ç„¶è€Œï¼ŒæŒ‰ç…§æƒ¯ä¾‹ï¼Œæˆ‘ä»¬è¦æ±‚åˆ—è¡¨å§‹ç»ˆæ˜¯å•æ€å‹çš„ã€‚è¿™å¾ˆé‡è¦ï¼Œå› ä¸ºå®ƒä½¿æˆ‘ä»¬èƒ½å¤Ÿç»Ÿä¸€å¤„ç†åˆ—è¡¨çš„å…ƒç´ ï¼šå¦‚æœæˆ‘ä»¬çŸ¥é“å¦‚ä½•å¤„ç†ç±»å‹`T`çš„å…ƒç´ ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±çŸ¥é“å¦‚ä½•å¤„ç†`List<T>`ã€‚å¦‚æœåˆ—è¡¨å…ƒç´ å¯ä»¥æ˜¯çœŸæ­£ä»»ä½•æ—§ç±»å‹ï¼Œæˆ‘ä»¬å°±æ— æ³•çŸ¥é“å¦‚ä½•å¤„ç†å…¶å…ƒç´ ã€‚
